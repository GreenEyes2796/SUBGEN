CCS PCH C Compiler, Version 5.071d, 1               06-Jul-17 16:09
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   115008 bytes (88%)
                           Largest free fragment is 15696
               RAM used:   2148 (56%) at main() level
                           2649 (69%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1B5F8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0EE8
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0F12
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   1908
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E14
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   16EA
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   1760
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E78
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 3F,40
00668:  DATA 42,53
0066A:  DATA 59,0D
0066C:  DATA 0A,00
0066E:  DATA 40,52
00670:  DATA 44,59
00672:  DATA 0D,0A
00674:  DATA 00,00
00676:  DATA 40,46
00678:  DATA 53,3A
0067A:  DATA 44,69
0067C:  DATA 73,63
0067E:  DATA 6F,76
00680:  DATA 65,72
00682:  DATA 79,0D
00684:  DATA 0A,00
00686:  DATA 40,46
00688:  DATA 53,3A
0068A:  DATA 55,6E
0068C:  DATA 61,62
0068E:  DATA 6C,65
00690:  DATA 20,74
00692:  DATA 6F,20
00694:  DATA 70,75
00696:  DATA 74,20
00698:  DATA 63,61
0069A:  DATA 72,64
0069C:  DATA 20,69
0069E:  DATA 6E,20
006A0:  DATA 69,64
006A2:  DATA 6C,65
006A4:  DATA 20,73
006A6:  DATA 74,61
006A8:  DATA 74,65
006AA:  DATA 2C,20
006AC:  DATA 72,65
006AE:  DATA 73,70
006B0:  DATA 6F,6E
006B2:  DATA 73,65
006B4:  DATA 20,3D
006B6:  DATA 20,25
006B8:  DATA 30,32
006BA:  DATA 78,0D
006BC:  DATA 0A,00
006BE:  DATA 40,46
006C0:  DATA 53,3A
006C2:  DATA 43,61
006C4:  DATA 72,64
006C6:  DATA 20,69
006C8:  DATA 64,6C
006CA:  DATA 65,2C
006CC:  DATA 20,72
006CE:  DATA 65,73
006D0:  DATA 70,6F
006D2:  DATA 6E,73
006D4:  DATA 65,20
006D6:  DATA 3D,20
006D8:  DATA 25,30
006DA:  DATA 32,78
006DC:  DATA 0D,0A
006DE:  DATA 00,00
006E0:  DATA 40,46
006E2:  DATA 53,3A
006E4:  DATA 52,65
006E6:  DATA 73,70
006E8:  DATA 6F,6E
006EA:  DATA 73,65
006EC:  DATA 20,74
006EE:  DATA 6F,20
006F0:  DATA 53,44
006F2:  DATA 20,76
006F4:  DATA 65,72
006F6:  DATA 20,32
006F8:  DATA 20,74
006FA:  DATA 65,73
006FC:  DATA 74,20
006FE:  DATA 43,4D
00700:  DATA 44,38
00702:  DATA 20,3D
00704:  DATA 20,25
00706:  DATA 78,0D
00708:  DATA 0A,00
0070A:  DATA 40,46
0070C:  DATA 53,3A
0070E:  DATA 50,6F
00710:  DATA 73,73
00712:  DATA 69,62
00714:  DATA 6C,65
00716:  DATA 20,53
00718:  DATA 44,76
0071A:  DATA 32,20
0071C:  DATA 63,61
0071E:  DATA 72,64
00720:  DATA 20,64
00722:  DATA 65,74
00724:  DATA 65,63
00726:  DATA 74,65
00728:  DATA 64,0D
0072A:  DATA 0A,00
0072C:  DATA 40,46
0072E:  DATA 53,3A
00730:  DATA 56,6F
00732:  DATA 6C,74
00734:  DATA 61,67
00736:  DATA 65,20
00738:  DATA 72,61
0073A:  DATA 6E,67
0073C:  DATA 65,20
0073E:  DATA 63,68
00740:  DATA 65,63
00742:  DATA 6B,2C
00744:  DATA 20,6F
00746:  DATA 63,72
00748:  DATA 20,3D
0074A:  DATA 20,25
0074C:  DATA 30,32
0074E:  DATA 78,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,0D
0075C:  DATA 0A,00
0075E:  DATA 40,46
00760:  DATA 53,3A
00762:  DATA 43,61
00764:  DATA 72,64
00766:  DATA 20,56
00768:  DATA 64,64
0076A:  DATA 20,72
0076C:  DATA 61,6E
0076E:  DATA 67,65
00770:  DATA 20,3D
00772:  DATA 20,32
00774:  DATA 2E,37
00776:  DATA 2D,33
00778:  DATA 2E,36
0077A:  DATA 20,76
0077C:  DATA 6F,6C
0077E:  DATA 74,73
00780:  DATA 0D,0A
00782:  DATA 00,00
00784:  DATA 40,46
00786:  DATA 53,3A
00788:  DATA 53,65
0078A:  DATA 6E,64
0078C:  DATA 69,6E
0078E:  DATA 67,20
00790:  DATA 41,43
00792:  DATA 4D,44
00794:  DATA 34,31
00796:  DATA 20,63
00798:  DATA 6F,6D
0079A:  DATA 6D,61
0079C:  DATA 6E,64
0079E:  DATA 20,74
007A0:  DATA 6F,20
007A2:  DATA 53,44
007A4:  DATA 20,76
007A6:  DATA 65,72
007A8:  DATA 20,32
007AA:  DATA 20,63
007AC:  DATA 61,72
007AE:  DATA 64,0D
007B0:  DATA 0A,00
007B2:  DATA 40,46
007B4:  DATA 53,3A
007B6:  DATA 52,65
007B8:  DATA 73,70
007BA:  DATA 6F,6E
007BC:  DATA 73,65
007BE:  DATA 20,66
007C0:  DATA 72,6F
007C2:  DATA 6D,20
007C4:  DATA 73,65
007C6:  DATA 6E,64
007C8:  DATA 69,6E
007CA:  DATA 67,20
007CC:  DATA 41,43
007CE:  DATA 4D,44
007D0:  DATA 34,31
007D2:  DATA 20,3D
007D4:  DATA 20,25
007D6:  DATA 30,32
007D8:  DATA 78,2C
007DA:  DATA 20,54
007DC:  DATA 69,6D
007DE:  DATA 65,72
007E0:  DATA 20,3D
007E2:  DATA 20,25
007E4:  DATA 6C,75
007E6:  DATA 0D,0A
007E8:  DATA 00,00
007EA:  DATA 40,46
007EC:  DATA 53,3A
007EE:  DATA 52,65
007F0:  DATA 73,70
007F2:  DATA 6F,6E
007F4:  DATA 73,65
007F6:  DATA 20,74
007F8:  DATA 6F,20
007FA:  DATA 43,4D
007FC:  DATA 44,35
007FE:  DATA 38,20
00800:  DATA 3D,20
00802:  DATA 25,78
00804:  DATA 0D,0A
00806:  DATA 00,00
00808:  DATA 40,46
0080A:  DATA 53,3A
0080C:  DATA 53,65
0080E:  DATA 6E,74
00810:  DATA 20,43
00812:  DATA 4D,44
00814:  DATA 20,35
00816:  DATA 38,2C
00818:  DATA 20,54
0081A:  DATA 69,6D
0081C:  DATA 65,72
0081E:  DATA 20,76
00820:  DATA 61,6C
00822:  DATA 75,65
00824:  DATA 20,3D
00826:  DATA 20,25
00828:  DATA 6C,75
0082A:  DATA 2C,20
0082C:  DATA 6F,63
0082E:  DATA 72,20
00830:  DATA 3D,20
00832:  DATA 25,30
00834:  DATA 32,78
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 0D,0A
00844:  DATA 00,00
00846:  DATA 40,46
00848:  DATA 53,3A
0084A:  DATA 43,61
0084C:  DATA 72,64
0084E:  DATA 20,43
00850:  DATA 41,4E
00852:  DATA 4E,4F
00854:  DATA 54,20
00856:  DATA 77,6F
00858:  DATA 72,6B
0085A:  DATA 20,56
0085C:  DATA 64,64
0085E:  DATA 20,72
00860:  DATA 61,6E
00862:  DATA 67,65
00864:  DATA 20,6F
00866:  DATA 66,20
00868:  DATA 32,2E
0086A:  DATA 37,2D
0086C:  DATA 33,2E
0086E:  DATA 36,20
00870:  DATA 76,6F
00872:  DATA 6C,74
00874:  DATA 73,0D
00876:  DATA 0A,00
00878:  DATA 40,46
0087A:  DATA 53,3A
0087C:  DATA 4E,6F
0087E:  DATA 74,20
00880:  DATA 61,6E
00882:  DATA 20,53
00884:  DATA 44,53
00886:  DATA 43,20
00888:  DATA 6F,72
0088A:  DATA 20,53
0088C:  DATA 44,48
0088E:  DATA 43,20
00890:  DATA 63,61
00892:  DATA 72,64
00894:  DATA 2C,20
00896:  DATA 54,65
00898:  DATA 73,74
0089A:  DATA 69,6E
0089C:  DATA 67,20
0089E:  DATA 66,6F
008A0:  DATA 72,20
008A2:  DATA 53,44
008A4:  DATA 20,56
008A6:  DATA 65,72
008A8:  DATA 31,20
008AA:  DATA 6F,72
008AC:  DATA 20,4D
008AE:  DATA 4D,43
008B0:  DATA 20,43
008B2:  DATA 61,72
008B4:  DATA 64,0D
008B6:  DATA 0A,00
008B8:  DATA 40,46
008BA:  DATA 53,3A
008BC:  DATA 52,65
008BE:  DATA 73,70
008C0:  DATA 6F,6E
008C2:  DATA 73,65
008C4:  DATA 20,66
008C6:  DATA 72,6F
008C8:  DATA 6D,20
008CA:  DATA 47,4F
008CC:  DATA 5F,49
008CE:  DATA 44,4C
008D0:  DATA 45,20
008D2:  DATA 3D,20
008D4:  DATA 25,30
008D6:  DATA 32,78
008D8:  DATA 0D,0A
008DA:  DATA 00,00
008DC:  DATA 40,46
008DE:  DATA 53,3A
008E0:  DATA 52,65
008E2:  DATA 73,70
008E4:  DATA 6F,6E
008E6:  DATA 73,65
008E8:  DATA 20,66
008EA:  DATA 72,6F
008EC:  DATA 6D,20
008EE:  DATA 53,44
008F0:  DATA 5F,43
008F2:  DATA 4D,44
008F4:  DATA 5F,53
008F6:  DATA 45,4E
008F8:  DATA 44,5F
008FA:  DATA 4F,50
008FC:  DATA 5F,43
008FE:  DATA 4F,4E
00900:  DATA 44,20
00902:  DATA 3D,20
00904:  DATA 25,30
00906:  DATA 32,78
00908:  DATA 2C,20
0090A:  DATA 54,69
0090C:  DATA 6D,65
0090E:  DATA 72,20
00910:  DATA 3D,20
00912:  DATA 25,6C
00914:  DATA 75,0D
00916:  DATA 0A,00
00918:  DATA 40,46
0091A:  DATA 53,3A
0091C:  DATA 41,74
0091E:  DATA 74,65
00920:  DATA 6D,70
00922:  DATA 74,69
00924:  DATA 6E,67
00926:  DATA 20,53
00928:  DATA 44,76
0092A:  DATA 31,20
0092C:  DATA 76,65
0092E:  DATA 72,73
00930:  DATA 75,73
00932:  DATA 20,4D
00934:  DATA 4D,43
00936:  DATA 20,49
00938:  DATA 44,2C
0093A:  DATA 20,52
0093C:  DATA 65,73
0093E:  DATA 70,6F
00940:  DATA 6E,73
00942:  DATA 65,20
00944:  DATA 66,72
00946:  DATA 6F,6D
00948:  DATA 20,53
0094A:  DATA 44,5F
0094C:  DATA 43,4D
0094E:  DATA 44,5F
00950:  DATA 41,50
00952:  DATA 50,4C
00954:  DATA 5F,43
00956:  DATA 4D,44
00958:  DATA 20,3D
0095A:  DATA 20,25
0095C:  DATA 30,32
0095E:  DATA 78,0D
00960:  DATA 0A,00
00962:  DATA 40,46
00964:  DATA 53,3A
00966:  DATA 49,6E
00968:  DATA 76,61
0096A:  DATA 6C,69
0096C:  DATA 64,20
0096E:  DATA 72,65
00970:  DATA 73,70
00972:  DATA 6F,6E
00974:  DATA 73,65
00976:  DATA 20,74
00978:  DATA 6F,20
0097A:  DATA 53,44
0097C:  DATA 5F,41
0097E:  DATA 43,4D
00980:  DATA 44,34
00982:  DATA 31,2C
00984:  DATA 20,72
00986:  DATA 65,73
00988:  DATA 70,6F
0098A:  DATA 6E,73
0098C:  DATA 65,20
0098E:  DATA 3D,20
00990:  DATA 25,30
00992:  DATA 32,58
00994:  DATA 2C,20
00996:  DATA 72,65
00998:  DATA 69,6E
0099A:  DATA 69,74
0099C:  DATA 69,61
0099E:  DATA 6C,69
009A0:  DATA 7A,69
009A2:  DATA 6E,67
009A4:  DATA 20,61
009A6:  DATA 73,20
009A8:  DATA 4D,4D
009AA:  DATA 43,0D
009AC:  DATA 0A,00
009AE:  DATA 40,46
009B0:  DATA 53,3A
009B2:  DATA 46,61
009B4:  DATA 69,6C
009B6:  DATA 65,64
009B8:  DATA 20,74
009BA:  DATA 6F,20
009BC:  DATA 69,6E
009BE:  DATA 69,74
009C0:  DATA 69,61
009C2:  DATA 6C,69
009C4:  DATA 7A,65
009C6:  DATA 20,61
009C8:  DATA 73,20
009CA:  DATA 4D,4D
009CC:  DATA 43,2C
009CE:  DATA 20,72
009D0:  DATA 65,73
009D2:  DATA 70,6F
009D4:  DATA 6E,73
009D6:  DATA 65,20
009D8:  DATA 3D,20
009DA:  DATA 25,30
009DC:  DATA 32,58
009DE:  DATA 2C,20
009E0:  DATA 65,78
009E2:  DATA 69,74
009E4:  DATA 69,6E
009E6:  DATA 67,0D
009E8:  DATA 0A,00
009EA:  DATA 40,46
009EC:  DATA 53,3A
009EE:  DATA 43,61
009F0:  DATA 72,64
009F2:  DATA 20,66
009F4:  DATA 61,69
009F6:  DATA 6C,65
009F8:  DATA 64,20
009FA:  DATA 74,6F
009FC:  DATA 20,72
009FE:  DATA 65,73
00A00:  DATA 70,6F
00A02:  DATA 6E,64
00A04:  DATA 20,63
00A06:  DATA 6F,72
00A08:  DATA 72,65
00A0A:  DATA 63,6C
00A0C:  DATA 79,20
00A0E:  DATA 61,66
00A10:  DATA 74,65
00A12:  DATA 72,20
00A14:  DATA 53,44
00A16:  DATA 5F,43
00A18:  DATA 4D,44
00A1A:  DATA 5F,53
00A1C:  DATA 45,4E
00A1E:  DATA 44,5F
00A20:  DATA 4F,50
00A22:  DATA 5F,43
00A24:  DATA 4F,4E
00A26:  DATA 44,2C
00A28:  DATA 20,72
00A2A:  DATA 65,73
00A2C:  DATA 70,6F
00A2E:  DATA 6E,73
00A30:  DATA 65,20
00A32:  DATA 3D,20
00A34:  DATA 25,30
00A36:  DATA 32,58
00A38:  DATA 2C,20
00A3A:  DATA 54,69
00A3C:  DATA 6D,65
00A3E:  DATA 72,20
00A40:  DATA 3D,20
00A42:  DATA 25,6C
00A44:  DATA 75,0D
00A46:  DATA 0A,00
00A48:  DATA 40,46
00A4A:  DATA 53,3A
00A4C:  DATA 53,65
00A4E:  DATA 74,74
00A50:  DATA 69,6E
00A52:  DATA 67,20
00A54:  DATA 62,6C
00A56:  DATA 6F,63
00A58:  DATA 6B,20
00A5A:  DATA 6C,65
00A5C:  DATA 6E,67
00A5E:  DATA 74,68
00A60:  DATA 0D,0A
00A62:  DATA 00,00
00A64:  DATA 40,46
00A66:  DATA 53,3A
00A68:  DATA 45,72
00A6A:  DATA 72,6F
00A6C:  DATA 72,20
00A6E:  DATA 73,65
00A70:  DATA 74,74
00A72:  DATA 69,6E
00A74:  DATA 67,20
00A76:  DATA 62,6C
00A78:  DATA 6F,63
00A7A:  DATA 6B,20
00A7C:  DATA 6C,65
00A7E:  DATA 6E,67
00A80:  DATA 74,68
00A82:  DATA 2C,20
00A84:  DATA 72,65
00A86:  DATA 73,70
00A88:  DATA 6F,6E
00A8A:  DATA 73,65
00A8C:  DATA 20,3D
00A8E:  DATA 20,25
00A90:  DATA 30,32
00A92:  DATA 78,2C
00A94:  DATA 20,74
00A96:  DATA 69,6D
00A98:  DATA 65,72
00A9A:  DATA 20,3D
00A9C:  DATA 20,25
00A9E:  DATA 6C,75
00AA0:  DATA 0D,0A
00AA2:  DATA 00,00
00AA4:  DATA 40,46
00AA6:  DATA 53,3A
00AA8:  DATA 43,61
00AAA:  DATA 72,64
00AAC:  DATA 20,54
00AAE:  DATA 79,70
00AB0:  DATA 65,20
00AB2:  DATA 44,69
00AB4:  DATA 73,63
00AB6:  DATA 6F,76
00AB8:  DATA 65,72
00ABA:  DATA 79,20
00ABC:  DATA 45,72
00ABE:  DATA 72,6F
00AC0:  DATA 72,0D
00AC2:  DATA 0A,00
00AC4:  DATA 40,46
00AC6:  DATA 53,3A
00AC8:  DATA 4D,4D
00ACA:  DATA 43,20
00ACC:  DATA 43,61
00ACE:  DATA 72,64
00AD0:  DATA 20,66
00AD2:  DATA 6F,75
00AD4:  DATA 6E,64
00AD6:  DATA 0D,0A
00AD8:  DATA 00,00
00ADA:  DATA 40,46
00ADC:  DATA 53,3A
00ADE:  DATA 53,44
00AE0:  DATA 76,31
00AE2:  DATA 20,43
00AE4:  DATA 61,72
00AE6:  DATA 64,20
00AE8:  DATA 66,6F
00AEA:  DATA 75,6E
00AEC:  DATA 64,0D
00AEE:  DATA 0A,00
00AF0:  DATA 40,46
00AF2:  DATA 53,3A
00AF4:  DATA 53,44
00AF6:  DATA 53,43
00AF8:  DATA 20,43
00AFA:  DATA 61,72
00AFC:  DATA 64,20
00AFE:  DATA 66,6F
00B00:  DATA 75,6E
00B02:  DATA 64,0D
00B04:  DATA 0A,00
00B06:  DATA 40,46
00B08:  DATA 53,3A
00B0A:  DATA 53,44
00B0C:  DATA 48,43
00B0E:  DATA 20,43
00B10:  DATA 61,72
00B12:  DATA 64,20
00B14:  DATA 66,6F
00B16:  DATA 75,6E
00B18:  DATA 64,0D
00B1A:  DATA 0A,00
00B1C:  DATA 40,46
00B1E:  DATA 53,3A
00B20:  DATA 43,61
00B22:  DATA 72,64
00B24:  DATA 20,54
00B26:  DATA 79,70
00B28:  DATA 65,20
00B2A:  DATA 44,69
00B2C:  DATA 73,63
00B2E:  DATA 6F,76
00B30:  DATA 65,72
00B32:  DATA 79,20
00B34:  DATA 45,72
00B36:  DATA 72,6F
00B38:  DATA 72,2C
00B3A:  DATA 20,43
00B3C:  DATA 61,72
00B3E:  DATA 64,20
00B40:  DATA 3D,20
00B42:  DATA 25,30
00B44:  DATA 32,58
00B46:  DATA 0D,0A
00B48:  DATA 00,00
00B4A:  DATA 40,46
00B4C:  DATA 53,3A
00B4E:  DATA 43,61
00B50:  DATA 72,64
00B52:  DATA 20,72
00B54:  DATA 65,73
00B56:  DATA 65,74
00B58:  DATA 20,73
00B5A:  DATA 75,63
00B5C:  DATA 63,65
00B5E:  DATA 73,73
00B60:  DATA 20,2D
00B62:  DATA 20,43
00B64:  DATA 6D,64
00B66:  DATA 20,74
00B68:  DATA 6F,20
00B6A:  DATA 52,65
00B6C:  DATA 61,64
00B6E:  DATA 79,20
00B70:  DATA 63,6F
00B72:  DATA 75,6E
00B74:  DATA 74,20
00B76:  DATA 3D,20
00B78:  DATA 25,6C
00B7A:  DATA 75,0D
00B7C:  DATA 0A,00
00B7E:  DATA 40,46
00B80:  DATA 53,3A
00B82:  DATA 53,50
00B84:  DATA 49,20
00B86:  DATA 62,75
00B88:  DATA 73,20
00B8A:  DATA 73,70
00B8C:  DATA 65,65
00B8E:  DATA 64,20
00B90:  DATA 73,65
00B92:  DATA 74,20
00B94:  DATA 74,6F
00B96:  DATA 20,68
00B98:  DATA 69,67
00B9A:  DATA 68,0D
00B9C:  DATA 0A,00
00B9E:  DATA 40,46
00BA0:  DATA 53,3A
00BA2:  DATA 43,61
00BA4:  DATA 72,64
00BA6:  DATA 20,61
00BA8:  DATA 63,74
00BAA:  DATA 69,76
00BAC:  DATA 61,74
00BAE:  DATA 65,20
00BB0:  DATA 66,61
00BB2:  DATA 69,6C
00BB4:  DATA 75,72
00BB6:  DATA 65,2C
00BB8:  DATA 20,72
00BBA:  DATA 65,73
00BBC:  DATA 70,6F
00BBE:  DATA 6E,73
00BC0:  DATA 65,20
00BC2:  DATA 3D,20
00BC4:  DATA 25,30
00BC6:  DATA 32,58
00BC8:  DATA 2C,20
00BCA:  DATA 54,69
00BCC:  DATA 6D,65
00BCE:  DATA 72,20
00BD0:  DATA 3D,20
00BD2:  DATA 25,6C
00BD4:  DATA 75,0D
00BD6:  DATA 0A,00
00BD8:  DATA 40,46
00BDA:  DATA 53,3A
00BDC:  DATA 43,61
00BDE:  DATA 72,64
00BE0:  DATA 20,61
00BE2:  DATA 63,74
00BE4:  DATA 69,76
00BE6:  DATA 61,74
00BE8:  DATA 65,20
00BEA:  DATA 73,75
00BEC:  DATA 63,63
00BEE:  DATA 65,73
00BF0:  DATA 73,20
00BF2:  DATA 6F,6E
00BF4:  DATA 20,61
00BF6:  DATA 74,74
00BF8:  DATA 65,6D
00BFA:  DATA 70,74
00BFC:  DATA 20,25
00BFE:  DATA 6C,75
00C00:  DATA 0D,0A
00C02:  DATA 00,00
00C04:  DATA 46,41
00C06:  DATA 54,20
00C08:  DATA 61,74
00C0A:  DATA 20,73
00C0C:  DATA 65,63
00C0E:  DATA 74,6F
00C10:  DATA 72,20
00C12:  DATA 30,0D
00C14:  DATA 0A,00
00C16:  DATA 54,59
00C18:  DATA 50,45
00C1A:  DATA 20,63
00C1C:  DATA 6F,6D
00C1E:  DATA 6D,61
00C20:  DATA 6E,64
00C22:  DATA 20,45
00C24:  DATA 52,52
00C26:  DATA 4F,52
00C28:  DATA 0D,0A
00C2A:  DATA 00,00
00C2C:  DATA 40,46
00C2E:  DATA 53,3A
00C30:  DATA 20,25
00C32:  DATA 73,0D
00C34:  DATA 0A,00
00C36:  DATA 40,46
00C38:  DATA 53,3A
00C3A:  DATA 20,25
00C3C:  DATA 73,0D
00C3E:  DATA 0A,00
00C40:  DATA 2A,2A
00C42:  DATA 20,40
00C44:  DATA 46,53
00C46:  DATA 3A,20
00C48:  DATA 45,52
00C4A:  DATA 52,4F
00C4C:  DATA 52,0D
00C4E:  DATA 0A,00
00C50:  DATA 20,20
00C52:  DATA 20,4E
00C54:  DATA 6F,45
00C56:  DATA 72,72
00C58:  DATA 6F,72
00C5A:  DATA 0D,0A
00C5C:  DATA 00,00
00C5E:  DATA 20,20
00C60:  DATA 20,4D
00C62:  DATA 65,64
00C64:  DATA 69,61
00C66:  DATA 20,4E
00C68:  DATA 6F,74
00C6A:  DATA 20,52
00C6C:  DATA 65,61
00C6E:  DATA 64,79
00C70:  DATA 0D,0A
00C72:  DATA 00,00
00C74:  DATA 20,20
00C76:  DATA 20,46
00C78:  DATA 69,6C
00C7A:  DATA 65,20
00C7C:  DATA 4E,6F
00C7E:  DATA 74,20
00C80:  DATA 46,6F
00C82:  DATA 75,6E
00C84:  DATA 64,0D
00C86:  DATA 0A,00
00C88:  DATA 20,20
00C8A:  DATA 20,49
00C8C:  DATA 6E,76
00C8E:  DATA 61,6C
00C90:  DATA 69,64
00C92:  DATA 20,50
00C94:  DATA 61,74
00C96:  DATA 68,0D
00C98:  DATA 0A,00
00C9A:  DATA 20,20
00C9C:  DATA 20,49
00C9E:  DATA 6E,76
00CA0:  DATA 61,6C
00CA2:  DATA 69,64
00CA4:  DATA 20,4E
00CA6:  DATA 61,6D
00CA8:  DATA 65,0D
00CAA:  DATA 0A,00
00CAC:  DATA 20,20
00CAE:  DATA 20,41
00CB0:  DATA 63,63
00CB2:  DATA 65,73
00CB4:  DATA 73,20
00CB6:  DATA 44,65
00CB8:  DATA 6E,69
00CBA:  DATA 65,64
00CBC:  DATA 0D,0A
00CBE:  DATA 00,00
00CC0:  DATA 20,20
00CC2:  DATA 20,44
00CC4:  DATA 69,73
00CC6:  DATA 6B,20
00CC8:  DATA 46,75
00CCA:  DATA 6C,6C
00CCC:  DATA 0D,0A
00CCE:  DATA 00,00
00CD0:  DATA 20,20
00CD2:  DATA 20,52
00CD4:  DATA 65,61
00CD6:  DATA 64,2F
00CD8:  DATA 57,72
00CDA:  DATA 69,74
00CDC:  DATA 65,20
00CDE:  DATA 45,72
00CE0:  DATA 72,6F
00CE2:  DATA 72,0D
00CE4:  DATA 0A,00
00CE6:  DATA 20,20
00CE8:  DATA 20,49
00CEA:  DATA 6E,63
00CEC:  DATA 6F,72
00CEE:  DATA 72,65
00CF0:  DATA 63,74
00CF2:  DATA 20,4D
00CF4:  DATA 65,64
00CF6:  DATA 69,61
00CF8:  DATA 20,43
00CFA:  DATA 68,61
00CFC:  DATA 6E,67
00CFE:  DATA 65,0D
00D00:  DATA 0A,00
00D02:  DATA 20,20
00D04:  DATA 20,57
00D06:  DATA 72,69
00D08:  DATA 74,65
00D0A:  DATA 20,50
00D0C:  DATA 72,6F
00D0E:  DATA 74,65
00D10:  DATA 63,74
00D12:  DATA 65,64
00D14:  DATA 0D,0A
00D16:  DATA 00,00
00D18:  DATA 20,20
00D1A:  DATA 20,4E
00D1C:  DATA 6F,74
00D1E:  DATA 20,45
00D20:  DATA 6E,61
00D22:  DATA 62,6C
00D24:  DATA 65,64
00D26:  DATA 0D,0A
00D28:  DATA 00,00
00D2A:  DATA 20,20
00D2C:  DATA 20,4E
00D2E:  DATA 6F,20
00D30:  DATA 46,69
00D32:  DATA 6C,65
00D34:  DATA 20,53
00D36:  DATA 79,73
00D38:  DATA 74,65
00D3A:  DATA 6D,0D
00D3C:  DATA 0A,00
00D3E:  DATA 61,70
00D40:  DATA 70,65
00D42:  DATA 6E,64
00D44:  DATA 3A,20
00D46:  DATA 46,53
00D48:  DATA 20,45
00D4A:  DATA 52,52
00D4C:  DATA 4F,52
00D4E:  DATA 20,6F
00D50:  DATA 6E,20
00D52:  DATA 66,69
00D54:  DATA 6C,65
00D56:  DATA 5F,6F
00D58:  DATA 70,65
00D5A:  DATA 6E,0D
00D5C:  DATA 0A,00
00D5E:  DATA 40,46
00D60:  DATA 53,3A
00D62:  DATA 57,72
00D64:  DATA 69,74
00D66:  DATA 69,6E
00D68:  DATA 67,0D
00D6A:  DATA 0A,5B
00D6C:  DATA 25,73
00D6E:  DATA 5D,0D
00D70:  DATA 0A,00
00D72:  DATA 40,46
00D74:  DATA 53,3A
00D76:  DATA 45,52
00D78:  DATA 52,4F
00D7A:  DATA 52,5B
00D7C:  DATA 61,70
00D7E:  DATA 70,65
00D80:  DATA 6E,64
00D82:  DATA 5D,0D
00D84:  DATA 0A,00
00D86:  DATA 40,46
00D88:  DATA 53,3A
00D8A:  DATA 43,6C
00D8C:  DATA 6F,73
00D8E:  DATA 69,6E
00D90:  DATA 67,0D
00D92:  DATA 0A,00
00D94:  DATA 40,52
00D96:  DATA 54,43
00D98:  DATA 3A,25
00D9A:  DATA 30,32
00D9C:  DATA 75,2F
00D9E:  DATA 00,00
00DA0:  DATA 40,52
00DA2:  DATA 54,43
00DA4:  DATA 3A,25
00DA6:  DATA 30,32
00DA8:  DATA 75,2F
00DAA:  DATA 00,00
00DAC:  DATA 40,41
00DAE:  DATA 4C,4D
00DB0:  DATA 3A,25
00DB2:  DATA 30,32
00DB4:  DATA 75,2F
00DB6:  DATA 00,00
00DB8:  DATA 40,41
00DBA:  DATA 4C,4D
00DBC:  DATA 3A,25
00DBE:  DATA 30,32
00DC0:  DATA 75,2F
00DC2:  DATA 00,00
00DC4:  DATA 74,65
00DC6:  DATA 73,74
00DC8:  DATA 36,3A
00DCA:  DATA 20,25
00DCC:  DATA 64,0D
00DCE:  DATA 0A,00
00DD0:  DATA 40,41
00DD2:  DATA 4C,4D
00DD4:  DATA 0D,0A
00DD6:  DATA 00,00
*
00E4E:  TBLRD*+
00E50:  MOVF   FF5,F
00E52:  BZ    0E76
00E54:  MOVFF  FF6,A38
00E58:  MOVFF  FF7,A39
00E5C:  MOVFF  FF8,A3A
00E60:  MOVF   FF5,W
00E62:  BTFSS  F9E.4
00E64:  BRA    0E62
00E66:  MOVWF  FAD
00E68:  MOVFF  A38,FF6
00E6C:  MOVFF  A39,FF7
00E70:  MOVFF  A3A,FF8
00E74:  BRA    0E4E
00E76:  RETURN 0
*
00ED8:  DATA 3F,40
00EDA:  DATA 42,53
00EDC:  DATA 59,0D
00EDE:  DATA 0A,00
00EE0:  DATA 40,52
00EE2:  DATA 44,59
00EE4:  DATA 0D,0A
00EE6:  DATA 00,00
*
00F28:  DATA 40,5B
00F2A:  DATA 4F,5D
00F2C:  DATA 0D,0A
00F2E:  DATA 00,00
00F30:  DATA 40,43
00F32:  DATA 4D,44
00F34:  DATA 20,74
00F36:  DATA 6F,6F
00F38:  DATA 20,6C
00F3A:  DATA 6F,6E
00F3C:  DATA 67,0D
00F3E:  DATA 0A,00
00F40:  DATA 40,5B
00F42:  DATA 43,5D
00F44:  DATA 0D,0A
00F46:  DATA 00,00
00F48:  DATA 40,53
00F4A:  DATA 4C,45
00F4C:  DATA 45,50
00F4E:  DATA 0D,0A
00F50:  DATA 00,00
00F52:  DATA 40,4D
00F54:  DATA 45,52
00F56:  DATA 2C,25
00F58:  DATA 4C,75
00F5A:  DATA 2C,25
00F5C:  DATA 4C,75
00F5E:  DATA 0D,0A
00F60:  DATA 00,00
00F62:  DATA 6D,3A
00F64:  DATA 25,75
00F66:  DATA 2C,25
00F68:  DATA 75,20
00F6A:  DATA 63,3A
00F6C:  DATA 25,4C
00F6E:  DATA 75,2C
00F70:  DATA 25,4C
00F72:  DATA 75,2C
00F74:  DATA 25,4C
00F76:  DATA 75,0D
00F78:  DATA 0A,00
00F7A:  MOVLB  A
00F7C:  MOVF   x43,W
00F7E:  CLRF   01
00F80:  SUBWF  x42,W
00F82:  BC    0F8A
00F84:  MOVFF  A42,00
00F88:  BRA    0FA2
00F8A:  CLRF   00
00F8C:  MOVLW  08
00F8E:  MOVWF  x44
00F90:  RLCF   x42,F
00F92:  RLCF   00,F
00F94:  MOVF   x43,W
00F96:  SUBWF  00,W
00F98:  BTFSC  FD8.0
00F9A:  MOVWF  00
00F9C:  RLCF   01,F
00F9E:  DECFSZ x44,F
00FA0:  BRA    0F90
00FA2:  MOVLB  0
00FA4:  RETURN 0
00FA6:  MOVF   01,W
00FA8:  MOVFF  A40,A42
00FAC:  MOVLW  64
00FAE:  MOVLB  A
00FB0:  MOVWF  x43
00FB2:  MOVLB  0
00FB4:  RCALL  0F7A
00FB6:  MOVFF  00,A40
00FBA:  MOVF   01,W
00FBC:  MOVLW  30
00FBE:  BNZ   0FD0
00FC0:  MOVLB  A
00FC2:  BTFSS  x41.1
00FC4:  BRA    0FE2
00FC6:  BTFSC  x41.3
00FC8:  BRA    0FE2
00FCA:  BTFSC  x41.4
00FCC:  MOVLW  20
00FCE:  BRA    0FD8
00FD0:  MOVLB  A
00FD2:  BCF    x41.3
00FD4:  BCF    x41.4
00FD6:  BSF    x41.0
00FD8:  ADDWF  01,F
00FDA:  MOVF   01,W
00FDC:  BTFSS  F9E.4
00FDE:  BRA    0FDC
00FE0:  MOVWF  FAD
00FE2:  MOVFF  A40,A42
00FE6:  MOVLW  0A
00FE8:  MOVWF  x43
00FEA:  MOVLB  0
00FEC:  RCALL  0F7A
00FEE:  MOVFF  00,A40
00FF2:  MOVF   01,W
00FF4:  MOVLW  30
00FF6:  BNZ   1008
00FF8:  MOVLB  A
00FFA:  BTFSC  x41.3
00FFC:  BRA    1014
00FFE:  BTFSS  x41.0
01000:  BRA    1014
01002:  BTFSC  x41.4
01004:  MOVLW  20
01006:  MOVLB  0
01008:  ADDWF  01,F
0100A:  MOVF   01,W
0100C:  BTFSS  F9E.4
0100E:  BRA    100C
01010:  MOVWF  FAD
01012:  MOVLB  A
01014:  MOVLW  30
01016:  ADDWF  x40,F
01018:  MOVF   x40,W
0101A:  BTFSS  F9E.4
0101C:  BRA    101A
0101E:  MOVWF  FAD
01020:  MOVLB  0
01022:  RETURN 0
01024:  TBLRD*+
01026:  MOVFF  FF6,A41
0102A:  MOVFF  FF7,A42
0102E:  MOVFF  FF8,A43
01032:  MOVF   FF5,W
01034:  BTFSS  F9E.4
01036:  BRA    1034
01038:  MOVWF  FAD
0103A:  MOVFF  A41,FF6
0103E:  MOVFF  A42,FF7
01042:  MOVFF  A43,FF8
01046:  MOVLB  A
01048:  DECFSZ x40,F
0104A:  BRA    104E
0104C:  BRA    1052
0104E:  MOVLB  0
01050:  BRA    1024
01052:  MOVLB  0
01054:  RETURN 0
01056:  BTFSC  FD8.1
01058:  BRA    1062
0105A:  MOVLW  0A
0105C:  MOVWF  FEA
0105E:  MOVLW  54
01060:  MOVWF  FE9
01062:  CLRF   00
01064:  CLRF   01
01066:  CLRF   02
01068:  CLRF   03
0106A:  MOVLB  A
0106C:  CLRF   x54
0106E:  CLRF   x55
01070:  CLRF   x56
01072:  CLRF   x57
01074:  MOVF   x53,W
01076:  IORWF  x52,W
01078:  IORWF  x51,W
0107A:  IORWF  x50,W
0107C:  BZ    10D6
0107E:  MOVLW  20
01080:  MOVWF  x58
01082:  BCF    FD8.0
01084:  RLCF   x4C,F
01086:  RLCF   x4D,F
01088:  RLCF   x4E,F
0108A:  RLCF   x4F,F
0108C:  RLCF   x54,F
0108E:  RLCF   x55,F
01090:  RLCF   x56,F
01092:  RLCF   x57,F
01094:  MOVF   x53,W
01096:  SUBWF  x57,W
01098:  BNZ   10AA
0109A:  MOVF   x52,W
0109C:  SUBWF  x56,W
0109E:  BNZ   10AA
010A0:  MOVF   x51,W
010A2:  SUBWF  x55,W
010A4:  BNZ   10AA
010A6:  MOVF   x50,W
010A8:  SUBWF  x54,W
010AA:  BNC   10CA
010AC:  MOVF   x50,W
010AE:  SUBWF  x54,F
010B0:  MOVF   x51,W
010B2:  BTFSS  FD8.0
010B4:  INCFSZ x51,W
010B6:  SUBWF  x55,F
010B8:  MOVF   x52,W
010BA:  BTFSS  FD8.0
010BC:  INCFSZ x52,W
010BE:  SUBWF  x56,F
010C0:  MOVF   x53,W
010C2:  BTFSS  FD8.0
010C4:  INCFSZ x53,W
010C6:  SUBWF  x57,F
010C8:  BSF    FD8.0
010CA:  RLCF   00,F
010CC:  RLCF   01,F
010CE:  RLCF   02,F
010D0:  RLCF   03,F
010D2:  DECFSZ x58,F
010D4:  BRA    1082
010D6:  MOVFF  A54,FEF
010DA:  MOVFF  A55,FEC
010DE:  MOVFF  A56,FEC
010E2:  MOVFF  A57,FEC
010E6:  MOVLB  0
010E8:  RETURN 0
010EA:  MOVF   FE9,W
010EC:  MOVLB  A
010EE:  MOVWF  x44
010F0:  MOVLW  3B
010F2:  MOVWF  x4B
010F4:  MOVLW  9A
010F6:  MOVWF  x4A
010F8:  MOVLW  CA
010FA:  MOVWF  x49
010FC:  CLRF   x48
010FE:  MOVLW  0A
01100:  MOVWF  x46
01102:  BSF    FD8.1
01104:  MOVLW  0A
01106:  MOVWF  FEA
01108:  MOVLW  40
0110A:  MOVWF  FE9
0110C:  MOVFF  A43,A4F
01110:  MOVFF  A42,A4E
01114:  MOVFF  A41,A4D
01118:  MOVFF  A40,A4C
0111C:  MOVFF  A4B,A53
01120:  MOVFF  A4A,A52
01124:  MOVFF  A49,A51
01128:  MOVFF  A48,A50
0112C:  MOVLB  0
0112E:  RCALL  1056
01130:  MOVF   01,W
01132:  MOVF   00,F
01134:  BNZ   115C
01136:  MOVLB  A
01138:  MOVF   x46,W
0113A:  XORLW  01
0113C:  BTFSS  FD8.2
0113E:  BRA    1144
01140:  MOVLB  0
01142:  BRA    115C
01144:  MOVF   x44,W
01146:  BZ    1160
01148:  ANDLW  0F
0114A:  SUBWF  x46,W
0114C:  BZ    1150
0114E:  BC    116C
01150:  BTFSC  x44.7
01152:  BRA    116C
01154:  BTFSC  x44.6
01156:  BRA    1160
01158:  MOVLW  20
0115A:  BRA    1162
0115C:  MOVLB  A
0115E:  CLRF   x44
01160:  MOVLW  30
01162:  ADDWF  00,F
01164:  MOVF   00,W
01166:  BTFSS  F9E.4
01168:  BRA    1166
0116A:  MOVWF  FAD
0116C:  BCF    FD8.1
0116E:  MOVFF  A4B,A4F
01172:  MOVFF  A4A,A4E
01176:  MOVFF  A49,A4D
0117A:  MOVFF  A48,A4C
0117E:  CLRF   x53
01180:  CLRF   x52
01182:  CLRF   x51
01184:  MOVLW  0A
01186:  MOVWF  x50
01188:  MOVLB  0
0118A:  RCALL  1056
0118C:  MOVFF  03,A4B
01190:  MOVFF  02,A4A
01194:  MOVFF  01,A49
01198:  MOVFF  00,A48
0119C:  MOVLB  A
0119E:  DECFSZ x46,F
011A0:  BRA    1102
011A2:  MOVLB  0
011A4:  RETURN 0
011A6:  MOVFF  FEA,A48
011AA:  MOVFF  FE9,A47
011AE:  MOVLB  A
011B0:  SWAPF  x41,W
011B2:  IORLW  F0
011B4:  MOVWF  x43
011B6:  ADDWF  x43,F
011B8:  ADDLW  E2
011BA:  MOVWF  x44
011BC:  ADDLW  32
011BE:  MOVWF  x46
011C0:  MOVF   x41,W
011C2:  ANDLW  0F
011C4:  ADDWF  x44,F
011C6:  ADDWF  x44,F
011C8:  ADDWF  x46,F
011CA:  ADDLW  E9
011CC:  MOVWF  x45
011CE:  ADDWF  x45,F
011D0:  ADDWF  x45,F
011D2:  SWAPF  x40,W
011D4:  ANDLW  0F
011D6:  ADDWF  x45,F
011D8:  ADDWF  x46,F
011DA:  RLCF   x45,F
011DC:  RLCF   x46,F
011DE:  COMF   x46,F
011E0:  RLCF   x46,F
011E2:  MOVF   x40,W
011E4:  ANDLW  0F
011E6:  ADDWF  x46,F
011E8:  RLCF   x43,F
011EA:  MOVLW  07
011EC:  MOVWF  x42
011EE:  MOVLW  0A
011F0:  DECF   x45,F
011F2:  ADDWF  x46,F
011F4:  BNC   11F0
011F6:  DECF   x44,F
011F8:  ADDWF  x45,F
011FA:  BNC   11F6
011FC:  DECF   x43,F
011FE:  ADDWF  x44,F
01200:  BNC   11FC
01202:  DECF   x42,F
01204:  ADDWF  x43,F
01206:  BNC   1202
01208:  MOVLW  0A
0120A:  MOVWF  FEA
0120C:  MOVLW  42
0120E:  MOVWF  FE9
01210:  MOVLW  07
01212:  ANDWF  x47,W
01214:  BCF    x47.6
01216:  ADDWF  FE9,F
01218:  MOVLW  00
0121A:  ADDWFC FEA,F
0121C:  MOVF   FE9,W
0121E:  SUBLW  46
01220:  BNZ   122A
01222:  MOVF   FEA,W
01224:  SUBLW  0A
01226:  BNZ   122A
01228:  BSF    x47.6
0122A:  MOVF   FEF,W
0122C:  MOVWF  00
0122E:  BNZ   1240
01230:  BTFSC  x47.6
01232:  BRA    1240
01234:  BTFSC  x47.4
01236:  BRA    1250
01238:  BTFSC  x47.3
0123A:  BRA    1240
0123C:  MOVLW  20
0123E:  BRA    1246
01240:  BSF    x47.3
01242:  BCF    x47.4
01244:  MOVLW  30
01246:  ADDWF  00,F
01248:  MOVF   00,W
0124A:  BTFSS  F9E.4
0124C:  BRA    124A
0124E:  MOVWF  FAD
01250:  MOVF   FEE,W
01252:  BTFSS  x47.6
01254:  BRA    121C
01256:  MOVLB  0
01258:  RETURN 0
*
01A5E:  DATA 40,4C
01A60:  DATA 50,43
01A62:  DATA 2C,25
01A64:  DATA 4C,75
01A66:  DATA 2C,25
01A68:  DATA 4C,64
01A6A:  DATA 0D,0A
01A6C:  DATA 00,00
01A6E:  DATA 40,4D
01A70:  DATA 4D,45
01A72:  DATA 2C,25
01A74:  DATA 75,2C
01A76:  DATA 25,4C
01A78:  DATA 64,2C
01A7A:  DATA 25,4C
01A7C:  DATA 75,2C
01A7E:  DATA 25,4C
01A80:  DATA 75,2C
01A82:  DATA 25,4C
01A84:  DATA 64,2C
01A86:  DATA 25,4C
01A88:  DATA 64,0D
01A8A:  DATA 0A,00
01A8C:  DATA 56,41
01A8E:  DATA 4C,56
01A90:  DATA 45,20
01A92:  DATA 53,54
01A94:  DATA 4F,50
01A96:  DATA 20,25
01A98:  DATA 4C,75
01A9A:  DATA 2C,25
01A9C:  DATA 4C,75
01A9E:  DATA 0D,0A
01AA0:  DATA 00,00
01AA2:  DATA 69,6E
01AA4:  DATA 64,3A
01AA6:  DATA 25,75
01AA8:  DATA 20,2F
01AAA:  DATA 20,70
01AAC:  DATA 68,61
01AAE:  DATA 3A,25
01AB0:  DATA 75,0D
01AB2:  DATA 0A,00
01AB4:  DATA 40,52
01AB6:  DATA 45,43
01AB8:  DATA 20,2D
01ABA:  DATA 20,68
01ABC:  DATA 6F,6D
01ABE:  DATA 69,6E
01AC0:  DATA 67,20
01AC2:  DATA 73,79
01AC4:  DATA 72,69
01AC6:  DATA 6E,67
01AC8:  DATA 65,20
01ACA:  DATA 61,6E
01ACC:  DATA 64,20
01ACE:  DATA 61,6C
01AD0:  DATA 69,67
01AD2:  DATA 6E,69
01AD4:  DATA 6E,67
01AD6:  DATA 20,76
01AD8:  DATA 61,6C
01ADA:  DATA 76,65
01ADC:  DATA 20,74
01ADE:  DATA 6F,20
01AE0:  DATA 70,6F
01AE2:  DATA 72,74
01AE4:  DATA 20,31
01AE6:  DATA 0D,0A
01AE8:  DATA 00,00
01AEA:  DATA 2C,73
01AEC:  DATA 65,72
01AEE:  DATA 69,61
01AF0:  DATA 6C,20
01AF2:  DATA 77,61
01AF4:  DATA 6B,65
01AF6:  DATA 2D,75
01AF8:  DATA 70,2C
01AFA:  DATA 53,44
01AFC:  DATA 20,69
01AFE:  DATA 6E,69
01B00:  DATA 74,69
01B02:  DATA 61,6C
01B04:  DATA 69,7A
01B06:  DATA 65,64
01B08:  DATA 0D,0A
01B0A:  DATA 00,00
01B0C:  DATA 40,52
01B0E:  DATA 53,54
01B10:  DATA 0D,0A
01B12:  DATA 00,00
01B14:  DATA 40,57
01B16:  DATA 44,54
01B18:  DATA 0D,0A
01B1A:  DATA 00,00
01B1C:  DATA 2C,72
01B1E:  DATA 65,73
01B20:  DATA 74,61
01B22:  DATA 72,74
01B24:  DATA 20,63
01B26:  DATA 61,75
01B28:  DATA 73,65
01B2A:  DATA 2C,57
01B2C:  DATA 44,20
01B2E:  DATA 74,69
01B30:  DATA 6D,65
01B32:  DATA 2D,6F
01B34:  DATA 75,74
01B36:  DATA 0D,0A
01B38:  DATA 00,00
01B3A:  DATA 40,57
01B3C:  DATA 44,53
01B3E:  DATA 0D,0A
01B40:  DATA 00,00
01B42:  DATA 2C,72
01B44:  DATA 65,73
01B46:  DATA 74,61
01B48:  DATA 72,74
01B4A:  DATA 20,63
01B4C:  DATA 61,75
01B4E:  DATA 73,65
01B50:  DATA 2C,57
01B52:  DATA 44,20
01B54:  DATA 66,72
01B56:  DATA 6F,6D
01B58:  DATA 20,73
01B5A:  DATA 6C,65
01B5C:  DATA 65,70
01B5E:  DATA 0D,0A
01B60:  DATA 00,00
01B62:  DATA 40,4E
01B64:  DATA 50,55
01B66:  DATA 0D,0A
01B68:  DATA 00,00
01B6A:  DATA 2C,69
01B6C:  DATA 64,23
01B6E:  DATA 5B,25
01B70:  DATA 4C,75
01B72:  DATA 5D,2C
01B74:  DATA 70,6F
01B76:  DATA 77,65
01B78:  DATA 72,20
01B7A:  DATA 61,70
01B7C:  DATA 70,6C
01B7E:  DATA 69,65
01B80:  DATA 64,2C
01B82:  DATA 53,44
01B84:  DATA 20,69
01B86:  DATA 6E,69
01B88:  DATA 74,69
01B8A:  DATA 61,6C
01B8C:  DATA 69,7A
01B8E:  DATA 65,64
01B90:  DATA 0D,0A
01B92:  DATA 00,00
01B94:  DATA 40,52
01B96:  DATA 53,54
01B98:  DATA 0D,0A
01B9A:  DATA 00,00
01B9C:  DATA 2C,72
01B9E:  DATA 65,73
01BA0:  DATA 74,61
01BA2:  DATA 72,74
01BA4:  DATA 20,63
01BA6:  DATA 61,75
01BA8:  DATA 73,65
01BAA:  DATA 2C,72
01BAC:  DATA 65,73
01BAE:  DATA 65,74
01BB0:  DATA 20,69
01BB2:  DATA 6E,73
01BB4:  DATA 74,72
01BB6:  DATA 75,63
01BB8:  DATA 74,69
01BBA:  DATA 6F,6E
01BBC:  DATA 0D,0A
01BBE:  DATA 00,00
01BC0:  DATA 40,42
01BC2:  DATA 4F,52
01BC4:  DATA 0D,0A
01BC6:  DATA 00,00
01BC8:  DATA 2C,72
01BCA:  DATA 65,73
01BCC:  DATA 74,61
01BCE:  DATA 72,74
01BD0:  DATA 20,63
01BD2:  DATA 61,75
01BD4:  DATA 73,65
01BD6:  DATA 2C,62
01BD8:  DATA 72,6F
01BDA:  DATA 77,6E
01BDC:  DATA 2D,6F
01BDE:  DATA 75,74
01BE0:  DATA 0D,0A
01BE2:  DATA 00,00
01BE4:  DATA 40,4D
01BE6:  DATA 52,53
01BE8:  DATA 0D,0A
01BEA:  DATA 00,00
01BEC:  DATA 2C,72
01BEE:  DATA 65,73
01BF0:  DATA 74,61
01BF2:  DATA 72,74
01BF4:  DATA 20,63
01BF6:  DATA 61,75
01BF8:  DATA 73,65
01BFA:  DATA 2C,4D
01BFC:  DATA 43,4C
01BFE:  DATA 52,20
01C00:  DATA 66,72
01C02:  DATA 6F,6D
01C04:  DATA 20,73
01C06:  DATA 6C,65
01C08:  DATA 65,70
01C0A:  DATA 0D,0A
01C0C:  DATA 00,00
01C0E:  DATA 40,4D
01C10:  DATA 52,52
01C12:  DATA 0D,0A
01C14:  DATA 00,00
01C16:  DATA 2C,72
01C18:  DATA 65,73
01C1A:  DATA 74,61
01C1C:  DATA 72,74
01C1E:  DATA 20,63
01C20:  DATA 61,75
01C22:  DATA 73,65
01C24:  DATA 2C,4D
01C26:  DATA 43,4C
01C28:  DATA 52,20
01C2A:  DATA 77,68
01C2C:  DATA 65,6E
01C2E:  DATA 20,72
01C30:  DATA 75,6E
01C32:  DATA 6E,69
01C34:  DATA 6E,67
01C36:  DATA 0D,0A
01C38:  DATA 00,00
01C3A:  DATA 4E,4F
01C3C:  DATA 33,00
01C3E:  DATA 4E,4F
01C40:  DATA 32,00
01C42:  DATA 50,4F
01C44:  DATA 34,00
01C46:  DATA 4E,48
01C48:  DATA 34,00
01C4A:  DATA 53,69
01C4C:  DATA 4F,00
01C4E:  DATA 00,00
01C50:  DATA 40,44
01C52:  DATA 45,54
01C54:  DATA 5B,2F
01C56:  DATA 25,75
01C58:  DATA 5D,5B
01C5A:  DATA 25,63
01C5C:  DATA 5D,41
01C5E:  DATA 52,47
01C60:  DATA 5B,25
01C62:  DATA 4C,75
01C64:  DATA 5D,0D
01C66:  DATA 0A,00
01C68:  DATA 20,74
01C6A:  DATA 69,6D
01C6C:  DATA 65,2D
01C6E:  DATA 6F,75
01C70:  DATA 74,00
01C72:  DATA 20,64
01C74:  DATA 61,74
01C76:  DATA 61,20
01C78:  DATA 74,6F
01C7A:  DATA 6F,20
01C7C:  DATA 73,68
01C7E:  DATA 6F,72
01C80:  DATA 74,00
01C82:  DATA 20,64
01C84:  DATA 61,74
01C86:  DATA 61,20
01C88:  DATA 74,6F
01C8A:  DATA 6F,20
01C8C:  DATA 6C,6F
01C8E:  DATA 6E,67
01C90:  DATA 00,00
01C92:  DATA 2C,64
01C94:  DATA 65,74
01C96:  DATA 65,63
01C98:  DATA 74,6F
01C9A:  DATA 72,5B
01C9C:  DATA 25,73
01C9E:  DATA 5D,2C
01CA0:  DATA 6C,65
01CA2:  DATA 6E,5B
01CA4:  DATA 25,75
01CA6:  DATA 5D,00
01CA8:  DATA 40,52
01CAA:  DATA 54,59
01CAC:  DATA 2C,25
01CAE:  DATA 75,0D
01CB0:  DATA 0A,00
01CB2:  DATA 2C,73
01CB4:  DATA 74,61
01CB6:  DATA 72,74
01CB8:  DATA 20,68
01CBA:  DATA 65,61
01CBC:  DATA 74,69
01CBE:  DATA 6E,67
01CC0:  DATA 2C,74
01CC2:  DATA 61,72
01CC4:  DATA 67,65
01CC6:  DATA 74,5B
01CC8:  DATA 25,4C
01CCA:  DATA 75,5D
01CCC:  DATA 2C,61
01CCE:  DATA 63,74
01CD0:  DATA 75,61
01CD2:  DATA 6C,5B
01CD4:  DATA 25,4C
01CD6:  DATA 75,5D
01CD8:  DATA 2C,72
01CDA:  DATA 65,61
01CDC:  DATA 64,69
01CDE:  DATA 6E,67
01CE0:  DATA 73,5B
01CE2:  DATA 25,4C
01CE4:  DATA 75,5D
01CE6:  DATA 0D,0A
01CE8:  DATA 00,00
01CEA:  DATA 2C,65
01CEC:  DATA 6E,64
01CEE:  DATA 20,68
01CF0:  DATA 65,61
01CF2:  DATA 74,69
01CF4:  DATA 6E,67
01CF6:  DATA 2C,74
01CF8:  DATA 61,72
01CFA:  DATA 67,65
01CFC:  DATA 74,5B
01CFE:  DATA 25,4C
01D00:  DATA 75,5D
01D02:  DATA 2C,61
01D04:  DATA 63,74
01D06:  DATA 75,61
01D08:  DATA 6C,5B
01D0A:  DATA 25,4C
01D0C:  DATA 75,5D
01D0E:  DATA 2C,72
01D10:  DATA 65,61
01D12:  DATA 64,69
01D14:  DATA 6E,67
01D16:  DATA 73,5B
01D18:  DATA 25,4C
01D1A:  DATA 75,5D
01D1C:  DATA 0D,0A
01D1E:  DATA 00,00
01D20:  DATA 4E,4F
01D22:  DATA 33,00
01D24:  DATA 4E,4F
01D26:  DATA 32,00
01D28:  DATA 50,4F
01D2A:  DATA 34,00
01D2C:  DATA 4E,48
01D2E:  DATA 34,00
01D30:  DATA 53,69
01D32:  DATA 4F,00
01D34:  DATA 00,00
01D36:  DATA 40,44
01D38:  DATA 41,43
01D3A:  DATA 2C,25
01D3C:  DATA 4C,75
01D3E:  DATA 2C,25
01D40:  DATA 4C,75
01D42:  DATA 2C,00
01D44:  DATA 40,53
01D46:  DATA 41,52
01D48:  DATA 2C,31
01D4A:  DATA 2C,25
01D4C:  DATA 4C,75
01D4E:  DATA 2C,00
01D50:  DATA 40,56
01D52:  DATA 41,4C
01D54:  DATA 20,00
01D56:  DATA 40,56
01D58:  DATA 41,4C
01D5A:  DATA 20,00
01D5C:  DATA 40,56
01D5E:  DATA 41,4C
01D60:  DATA 20,00
01D62:  DATA 40,56
01D64:  DATA 41,4C
01D66:  DATA 20,00
01D68:  DATA 40,53
01D6A:  DATA 4F,4C
01D6C:  DATA 5B,2F
01D6E:  DATA 31,5D
01D70:  DATA 5B,73
01D72:  DATA 5D,5B
01D74:  DATA 25,4C
01D76:  DATA 75,5D
01D78:  DATA 0D,0A
01D7A:  DATA 00,00
01D7C:  DATA 2F,31
01D7E:  DATA 73,25
01D80:  DATA 4C,75
01D82:  DATA 0D,00
01D84:  DATA 40,53
01D86:  DATA 4F,4C
01D88:  DATA 5B,2F
01D8A:  DATA 31,5D
01D8C:  DATA 5B,63
01D8E:  DATA 5D,5B
01D90:  DATA 25,75
01D92:  DATA 5D,0D
01D94:  DATA 0A,00
01D96:  DATA 2F,31
01D98:  DATA 63,25
01D9A:  DATA 75,0D
01D9C:  DATA 00,00
01D9E:  DATA 2F,31
01DA0:  DATA 73,32
01DA2:  DATA 35,36
01DA4:  DATA 0D,00
01DA6:  DATA 28,49
01DA8:  DATA 30,73
01DAA:  DATA 29,2C
01DAC:  DATA 25,4C
01DAE:  DATA 75,2C
01DB0:  DATA 28,49
01DB2:  DATA 31,73
01DB4:  DATA 29,2C
01DB6:  DATA 25,4C
01DB8:  DATA 75,2C
01DBA:  DATA 28,41
01DBC:  DATA 62,73
01DBE:  DATA 2D,73
01DC0:  DATA 29,2C
01DC2:  DATA 25,31
01DC4:  DATA 2E,34
01DC6:  DATA 67,2C
01DC8:  DATA 28,49
01DCA:  DATA 30,74
01DCC:  DATA 29,2C
01DCE:  DATA 25,4C
01DD0:  DATA 75,2C
01DD2:  DATA 28,49
01DD4:  DATA 31,74
01DD6:  DATA 29,2C
01DD8:  DATA 25,4C
01DDA:  DATA 75,2C
01DDC:  DATA 28,41
01DDE:  DATA 62,73
01DE0:  DATA 2D,74
01DE2:  DATA 29,2C
01DE4:  DATA 25,31
01DE6:  DATA 2E,34
01DE8:  DATA 67,2C
01DEA:  DATA 28,49
01DEC:  DATA 30,72
01DEE:  DATA 29,2C
01DF0:  DATA 25,4C
01DF2:  DATA 75,2C
01DF4:  DATA 28,49
01DF6:  DATA 31,72
01DF8:  DATA 29,2C
01DFA:  DATA 25,4C
01DFC:  DATA 75,2C
01DFE:  DATA 28,41
01E00:  DATA 62,73
01E02:  DATA 2D,72
01E04:  DATA 29,2C
01E06:  DATA 25,31
01E08:  DATA 2E,34
01E0A:  DATA 67,00
01E0C:  DATA 40,41
01E0E:  DATA 62,73
01E10:  DATA 2C,4E
01E12:  DATA 4F,33
01E14:  DATA 2C,25
01E16:  DATA 73,0D
01E18:  DATA 0A,00
01E1A:  DATA 28,49
01E1C:  DATA 30,73
01E1E:  DATA 29,2C
01E20:  DATA 25,4C
01E22:  DATA 75,2C
01E24:  DATA 28,49
01E26:  DATA 31,73
01E28:  DATA 29,2C
01E2A:  DATA 25,4C
01E2C:  DATA 75,2C
01E2E:  DATA 28,41
01E30:  DATA 62,73
01E32:  DATA 2D,73
01E34:  DATA 29,2C
01E36:  DATA 25,31
01E38:  DATA 2E,34
01E3A:  DATA 67,2C
01E3C:  DATA 28,49
01E3E:  DATA 30,74
01E40:  DATA 29,2C
01E42:  DATA 25,4C
01E44:  DATA 75,2C
01E46:  DATA 28,49
01E48:  DATA 31,74
01E4A:  DATA 29,2C
01E4C:  DATA 25,4C
01E4E:  DATA 75,2C
01E50:  DATA 28,41
01E52:  DATA 62,73
01E54:  DATA 2D,74
01E56:  DATA 29,2C
01E58:  DATA 25,31
01E5A:  DATA 2E,34
01E5C:  DATA 67,2C
01E5E:  DATA 28,49
01E60:  DATA 30,72
01E62:  DATA 29,2C
01E64:  DATA 25,4C
01E66:  DATA 75,2C
01E68:  DATA 28,49
01E6A:  DATA 31,72
01E6C:  DATA 29,2C
01E6E:  DATA 25,4C
01E70:  DATA 75,2C
01E72:  DATA 28,41
01E74:  DATA 62,73
01E76:  DATA 2D,72
01E78:  DATA 29,2C
01E7A:  DATA 25,31
01E7C:  DATA 2E,34
01E7E:  DATA 67,00
01E80:  DATA 40,41
01E82:  DATA 62,73
01E84:  DATA 2C,4E
01E86:  DATA 4F,32
01E88:  DATA 2C,25
01E8A:  DATA 73,0D
01E8C:  DATA 0A,00
01E8E:  DATA 28,49
01E90:  DATA 30,73
01E92:  DATA 29,2C
01E94:  DATA 25,4C
01E96:  DATA 75,2C
01E98:  DATA 28,49
01E9A:  DATA 31,73
01E9C:  DATA 29,2C
01E9E:  DATA 25,4C
01EA0:  DATA 75,2C
01EA2:  DATA 28,41
01EA4:  DATA 62,73
01EA6:  DATA 2D,73
01EA8:  DATA 29,2C
01EAA:  DATA 25,31
01EAC:  DATA 2E,34
01EAE:  DATA 67,2C
01EB0:  DATA 28,49
01EB2:  DATA 30,74
01EB4:  DATA 29,2C
01EB6:  DATA 25,4C
01EB8:  DATA 75,2C
01EBA:  DATA 28,49
01EBC:  DATA 31,74
01EBE:  DATA 29,2C
01EC0:  DATA 25,4C
01EC2:  DATA 75,2C
01EC4:  DATA 28,41
01EC6:  DATA 62,73
01EC8:  DATA 2D,74
01ECA:  DATA 29,2C
01ECC:  DATA 25,31
01ECE:  DATA 2E,34
01ED0:  DATA 67,2C
01ED2:  DATA 28,49
01ED4:  DATA 30,72
01ED6:  DATA 29,2C
01ED8:  DATA 25,4C
01EDA:  DATA 75,2C
01EDC:  DATA 28,49
01EDE:  DATA 31,72
01EE0:  DATA 29,2C
01EE2:  DATA 25,4C
01EE4:  DATA 75,2C
01EE6:  DATA 28,41
01EE8:  DATA 62,73
01EEA:  DATA 2D,72
01EEC:  DATA 29,2C
01EEE:  DATA 25,31
01EF0:  DATA 2E,34
01EF2:  DATA 67,00
01EF4:  DATA 40,41
01EF6:  DATA 62,73
01EF8:  DATA 2C,50
01EFA:  DATA 4F,34
01EFC:  DATA 2C,25
01EFE:  DATA 73,0D
01F00:  DATA 0A,00
01F02:  DATA 28,49
01F04:  DATA 30,73
01F06:  DATA 29,2C
01F08:  DATA 25,4C
01F0A:  DATA 75,2C
01F0C:  DATA 28,49
01F0E:  DATA 31,73
01F10:  DATA 29,2C
01F12:  DATA 25,4C
01F14:  DATA 75,2C
01F16:  DATA 28,41
01F18:  DATA 62,73
01F1A:  DATA 2D,73
01F1C:  DATA 29,2C
01F1E:  DATA 25,31
01F20:  DATA 2E,34
01F22:  DATA 67,2C
01F24:  DATA 28,49
01F26:  DATA 30,74
01F28:  DATA 29,2C
01F2A:  DATA 25,4C
01F2C:  DATA 75,2C
01F2E:  DATA 28,49
01F30:  DATA 31,74
01F32:  DATA 29,2C
01F34:  DATA 25,4C
01F36:  DATA 75,2C
01F38:  DATA 28,41
01F3A:  DATA 62,73
01F3C:  DATA 2D,74
01F3E:  DATA 29,2C
01F40:  DATA 25,31
01F42:  DATA 2E,34
01F44:  DATA 67,2C
01F46:  DATA 28,49
01F48:  DATA 30,72
01F4A:  DATA 29,2C
01F4C:  DATA 25,4C
01F4E:  DATA 75,2C
01F50:  DATA 28,49
01F52:  DATA 31,72
01F54:  DATA 29,2C
01F56:  DATA 25,4C
01F58:  DATA 75,2C
01F5A:  DATA 28,41
01F5C:  DATA 62,73
01F5E:  DATA 2D,72
01F60:  DATA 29,2C
01F62:  DATA 25,31
01F64:  DATA 2E,34
01F66:  DATA 67,00
01F68:  DATA 40,41
01F6A:  DATA 62,73
01F6C:  DATA 2C,4E
01F6E:  DATA 48,34
01F70:  DATA 2C,25
01F72:  DATA 73,0D
01F74:  DATA 0A,00
01F76:  DATA 28,49
01F78:  DATA 30,73
01F7A:  DATA 29,2C
01F7C:  DATA 25,4C
01F7E:  DATA 75,2C
01F80:  DATA 28,49
01F82:  DATA 31,73
01F84:  DATA 29,2C
01F86:  DATA 25,4C
01F88:  DATA 75,2C
01F8A:  DATA 28,41
01F8C:  DATA 62,73
01F8E:  DATA 2D,73
01F90:  DATA 29,2C
01F92:  DATA 25,31
01F94:  DATA 2E,34
01F96:  DATA 67,2C
01F98:  DATA 28,49
01F9A:  DATA 30,74
01F9C:  DATA 29,2C
01F9E:  DATA 25,4C
01FA0:  DATA 75,2C
01FA2:  DATA 28,49
01FA4:  DATA 31,74
01FA6:  DATA 29,2C
01FA8:  DATA 25,4C
01FAA:  DATA 75,2C
01FAC:  DATA 28,41
01FAE:  DATA 62,73
01FB0:  DATA 2D,74
01FB2:  DATA 29,2C
01FB4:  DATA 25,31
01FB6:  DATA 2E,34
01FB8:  DATA 67,2C
01FBA:  DATA 28,49
01FBC:  DATA 30,72
01FBE:  DATA 29,2C
01FC0:  DATA 25,4C
01FC2:  DATA 75,2C
01FC4:  DATA 28,49
01FC6:  DATA 31,72
01FC8:  DATA 29,2C
01FCA:  DATA 25,4C
01FCC:  DATA 75,2C
01FCE:  DATA 28,41
01FD0:  DATA 62,73
01FD2:  DATA 2D,72
01FD4:  DATA 29,2C
01FD6:  DATA 25,31
01FD8:  DATA 2E,34
01FDA:  DATA 67,00
01FDC:  DATA 40,41
01FDE:  DATA 42,53
01FE0:  DATA 2C,53
01FE2:  DATA 69,4F
01FE4:  DATA 2C,25
01FE6:  DATA 73,0D
01FE8:  DATA 0A,00
01FEA:  DATA 4E,4F
01FEC:  DATA 33,00
01FEE:  DATA 4E,4F
01FF0:  DATA 32,00
01FF2:  DATA 50,4F
01FF4:  DATA 34,00
01FF6:  DATA 4E,48
01FF8:  DATA 34,00
01FFA:  DATA 53,69
01FFC:  DATA 4F,00
01FFE:  DATA 00,00
02000:  DATA 28,6D
02002:  DATA 29,2C
02004:  DATA 25,33
02006:  DATA 2E,33
02008:  DATA 67,2C
0200A:  DATA 28,63
0200C:  DATA 29,2C
0200E:  DATA 25,33
02010:  DATA 2E,33
02012:  DATA 67,00
02014:  DATA 28,43
02016:  DATA 73,29
02018:  DATA 2C,25
0201A:  DATA 33,2E
0201C:  DATA 33,67
0201E:  DATA 0D,0A
02020:  DATA 00,00
02022:  DATA 40,43
02024:  DATA 4F,4E
02026:  DATA 2C,4E
02028:  DATA 4F,33
0202A:  DATA 2C,25
0202C:  DATA 73,0D
0202E:  DATA 0A,00
02030:  DATA 28,6D
02032:  DATA 29,2C
02034:  DATA 25,33
02036:  DATA 2E,33
02038:  DATA 67,2C
0203A:  DATA 28,63
0203C:  DATA 29,2C
0203E:  DATA 25,33
02040:  DATA 2E,33
02042:  DATA 67,00
02044:  DATA 28,43
02046:  DATA 73,29
02048:  DATA 2C,25
0204A:  DATA 33,2E
0204C:  DATA 33,67
0204E:  DATA 0D,0A
02050:  DATA 00,00
02052:  DATA 40,43
02054:  DATA 4F,4E
02056:  DATA 2C,50
02058:  DATA 4F,34
0205A:  DATA 2C,25
0205C:  DATA 73,0D
0205E:  DATA 0A,00
02060:  DATA 28,6D
02062:  DATA 29,2C
02064:  DATA 25,33
02066:  DATA 2E,33
02068:  DATA 67,2C
0206A:  DATA 28,63
0206C:  DATA 29,2C
0206E:  DATA 25,33
02070:  DATA 2E,33
02072:  DATA 67,00
02074:  DATA 28,43
02076:  DATA 73,29
02078:  DATA 2C,25
0207A:  DATA 33,2E
0207C:  DATA 33,67
0207E:  DATA 0D,0A
02080:  DATA 00,00
02082:  DATA 40,43
02084:  DATA 4F,4E
02086:  DATA 2C,4E
02088:  DATA 48,34
0208A:  DATA 2C,25
0208C:  DATA 73,0D
0208E:  DATA 0A,00
02090:  DATA 28,6D
02092:  DATA 29,2C
02094:  DATA 25,33
02096:  DATA 2E,33
02098:  DATA 67,2C
0209A:  DATA 28,63
0209C:  DATA 29,2C
0209E:  DATA 25,33
020A0:  DATA 2E,33
020A2:  DATA 67,00
020A4:  DATA 28,43
020A6:  DATA 73,29
020A8:  DATA 2C,25
020AA:  DATA 33,2E
020AC:  DATA 33,67
020AE:  DATA 0D,0A
020B0:  DATA 00,00
020B2:  DATA 40,43
020B4:  DATA 4F,4E
020B6:  DATA 2C,53
020B8:  DATA 69,4F
020BA:  DATA 2C,25
020BC:  DATA 73,0D
020BE:  DATA 0A,00
020C0:  DATA 4E,4F
020C2:  DATA 33,00
020C4:  DATA 50,4F
020C6:  DATA 34,00
020C8:  DATA 4E,48
020CA:  DATA 34,00
020CC:  DATA 53,69
020CE:  DATA 4F,00
020D0:  DATA 00,00
020D2:  DATA 4D,45
020D4:  DATA 4D,4F
020D6:  DATA 52,59
020D8:  DATA 20,4F
020DA:  DATA 56,45
020DC:  DATA 52,46
020DE:  DATA 4C,4F
020E0:  DATA 57,20
020E2:  DATA 45,52
020E4:  DATA 52,4F
020E6:  DATA 52,20
020E8:  DATA 40,20
020EA:  DATA 4C,69
020EC:  DATA 6E,65
020EE:  DATA 20,3A
020F0:  DATA 25,4C
020F2:  DATA 75,0A
020F4:  DATA 0D,00
020F6:  DATA 0D,0A
020F8:  DATA 3A,00
020FA:  DATA 0D,0A
020FC:  DATA 57,41
020FE:  DATA 52,4E
02100:  DATA 49,4E
02102:  DATA 47,3A
02104:  DATA 20,49
02106:  DATA 4E,56
02108:  DATA 41,4C
0210A:  DATA 49,44
0210C:  DATA 20,43
0210E:  DATA 4F,4D
02110:  DATA 4D,41
02112:  DATA 4E,44
02114:  DATA 20,49
02116:  DATA 4E,20
02118:  DATA 4D,41
0211A:  DATA 43,52
0211C:  DATA 4F,21
0211E:  DATA 0D,0A
02120:  DATA 00,00
02122:  DATA 42,61
02124:  DATA 64,20
02126:  DATA 63,6F
02128:  DATA 6D,6D
0212A:  DATA 61,6E
0212C:  DATA 64,20
0212E:  DATA 61,74
02130:  DATA 20,6C
02132:  DATA 69,6E
02134:  DATA 65,3A
02136:  DATA 20,25
02138:  DATA 4C,64
0213A:  DATA 20,0D
0213C:  DATA 0A,00
0213E:  DATA 50,6C
02140:  DATA 65,61
02142:  DATA 73,65
02144:  DATA 20,72
02146:  DATA 65,2D
02148:  DATA 75,70
0214A:  DATA 6C,6F
0214C:  DATA 61,64
0214E:  DATA 20,6D
02150:  DATA 61,63
02152:  DATA 72,6F
02154:  DATA 00,00
02156:  DATA 49,74
02158:  DATA 65,72
0215A:  DATA 61,74
0215C:  DATA 69,6F
0215E:  DATA 6E,73
02160:  DATA 20,6C
02162:  DATA 65,66
02164:  DATA 74,3A
02166:  DATA 20,25
02168:  DATA 4C,75
0216A:  DATA 0D,0A
0216C:  DATA 00,00
0216E:  DATA 2C,6D
02170:  DATA 61,63
02172:  DATA 72,6F
02174:  DATA 5B,25
02176:  DATA 75,5D
02178:  DATA 2C,73
0217A:  DATA 74,61
0217C:  DATA 72,74
0217E:  DATA 0D,0A
02180:  DATA 00,00
02182:  DATA 40,4D
02184:  DATA 43,4C
02186:  DATA 5B,25
02188:  DATA 63,5D
0218A:  DATA 5B,25
0218C:  DATA 4C,75
0218E:  DATA 5D,0D
02190:  DATA 0A,00
02192:  DATA 40,4C
02194:  DATA 4E,45
02196:  DATA 0D,0A
02198:  DATA 00,00
0219A:  DATA 40,52
0219C:  DATA 55,4E
0219E:  DATA 0D,0A
021A0:  DATA 00,00
021A2:  DATA 40,42
021A4:  DATA 41,44
021A6:  DATA 0D,0A
021A8:  DATA 00,00
021AA:  DATA 40,54
021AC:  DATA 2F,4F
021AE:  DATA 0D,0A
021B0:  DATA 00,00
021B2:  DATA 40,45
021B4:  DATA 52,52
021B6:  DATA 0D,0A
021B8:  DATA 00,00
021BA:  DATA 40,45
021BC:  DATA 4E,44
021BE:  DATA 0D,0A
021C0:  DATA 00,00
021C2:  DATA 40,48
021C4:  DATA 4C,54
021C6:  DATA 0D,0A
021C8:  DATA 00,00
021CA:  DATA 2C,6D
021CC:  DATA 61,63
021CE:  DATA 72,6F
021D0:  DATA 5B,25
021D2:  DATA 75,5D
021D4:  DATA 2C,73
021D6:  DATA 74,61
021D8:  DATA 74,75
021DA:  DATA 73,5B
021DC:  DATA 25,63
021DE:  DATA 5D,2C
021E0:  DATA 6C,69
021E2:  DATA 6E,65
021E4:  DATA 5B,25
021E6:  DATA 4C,75
021E8:  DATA 5D,0D
021EA:  DATA 0A,00
021EC:  DATA 40,52
021EE:  DATA 75,6E
021F0:  DATA 6E,69
021F2:  DATA 6E,67
021F4:  DATA 20,25
021F6:  DATA 63,25
021F8:  DATA 4C,75
021FA:  DATA 20,0D
021FC:  DATA 0A,00
021FE:  DATA 40,4D
02200:  DATA 61,63
02202:  DATA 72,6F
02204:  DATA 20,25
02206:  DATA 30,34
02208:  DATA 4C,75
0220A:  DATA 20,6F
0220C:  DATA 66,20
0220E:  DATA 25,30
02210:  DATA 34,4C
02212:  DATA 75,0D
02214:  DATA 0A,00
02216:  DATA 40,4C
02218:  DATA 4E,45
0221A:  DATA 0D,0A
0221C:  DATA 00,00
0221E:  DATA 40,52
02220:  DATA 55,4E
02222:  DATA 0D,0A
02224:  DATA 00,00
02226:  DATA 40,42
02228:  DATA 41,44
0222A:  DATA 0D,0A
0222C:  DATA 00,00
0222E:  DATA 40,54
02230:  DATA 2F,4F
02232:  DATA 0D,0A
02234:  DATA 00,00
02236:  DATA 40,45
02238:  DATA 52,52
0223A:  DATA 0D,0A
0223C:  DATA 00,00
0223E:  DATA 40,45
02240:  DATA 4E,44
02242:  DATA 0D,0A
02244:  DATA 00,00
02246:  DATA 2C,61
02248:  DATA 75,74
0224A:  DATA 6F,2D
0224C:  DATA 73,61
0224E:  DATA 6D,70
02250:  DATA 6C,65
02252:  DATA 2C,73
02254:  DATA 61,6D
02256:  DATA 70,6C
02258:  DATA 65,5B
0225A:  DATA 25,4C
0225C:  DATA 75,5D
0225E:  DATA 2C,73
02260:  DATA 74,61
02262:  DATA 72,74
02264:  DATA 0D,0A
02266:  DATA 00,00
02268:  DATA 2C,61
0226A:  DATA 75,74
0226C:  DATA 6F,2D
0226E:  DATA 73,61
02270:  DATA 6D,70
02272:  DATA 6C,65
02274:  DATA 2C,73
02276:  DATA 61,6D
02278:  DATA 70,6C
0227A:  DATA 65,5B
0227C:  DATA 25,4C
0227E:  DATA 75,5D
02280:  DATA 2C,63
02282:  DATA 6F,6D
02284:  DATA 70,6C
02286:  DATA 65,74
02288:  DATA 65,0D
0228A:  DATA 0A,00
0228C:  DATA 2C,61
0228E:  DATA 75,74
02290:  DATA 6F,2D
02292:  DATA 73,61
02294:  DATA 6D,70
02296:  DATA 6C,65
02298:  DATA 2C,73
0229A:  DATA 61,6D
0229C:  DATA 70,6C
0229E:  DATA 65,5B
022A0:  DATA 25,4C
022A2:  DATA 75,5D
022A4:  DATA 2C,65
022A6:  DATA 72,72
022A8:  DATA 6F,72
022AA:  DATA 0D,0A
022AC:  DATA 00,00
022AE:  DATA 2C,61
022B0:  DATA 75,74
022B2:  DATA 6F,2D
022B4:  DATA 73,61
022B6:  DATA 6D,70
022B8:  DATA 6C,65
022BA:  DATA 2C,73
022BC:  DATA 61,6D
022BE:  DATA 70,6C
022C0:  DATA 65,5B
022C2:  DATA 25,4C
022C4:  DATA 75,5D
022C6:  DATA 2C,6D
022C8:  DATA 61,78
022CA:  DATA 20,73
022CC:  DATA 61,6D
022CE:  DATA 70,6C
022D0:  DATA 65,73
022D2:  DATA 0D,0A
022D4:  DATA 00,00
022D6:  DATA 2C,61
022D8:  DATA 75,74
022DA:  DATA 6F,2D
022DC:  DATA 73,61
022DE:  DATA 6D,70
022E0:  DATA 6C,65
022E2:  DATA 2C,73
022E4:  DATA 61,6D
022E6:  DATA 70,6C
022E8:  DATA 65,5B
022EA:  DATA 25,4C
022EC:  DATA 75,5D
022EE:  DATA 2C,73
022F0:  DATA 74,61
022F2:  DATA 72,74
022F4:  DATA 0D,0A
022F6:  DATA 00,00
022F8:  DATA 2C,61
022FA:  DATA 75,74
022FC:  DATA 6F,2D
022FE:  DATA 73,61
02300:  DATA 6D,70
02302:  DATA 6C,65
02304:  DATA 2C,73
02306:  DATA 61,6D
02308:  DATA 70,6C
0230A:  DATA 65,5B
0230C:  DATA 25,4C
0230E:  DATA 75,5D
02310:  DATA 2C,63
02312:  DATA 6F,6D
02314:  DATA 70,6C
02316:  DATA 65,74
02318:  DATA 65,0D
0231A:  DATA 0A,00
0231C:  DATA 2C,61
0231E:  DATA 75,74
02320:  DATA 6F,2D
02322:  DATA 73,61
02324:  DATA 6D,70
02326:  DATA 6C,65
02328:  DATA 2C,73
0232A:  DATA 61,6D
0232C:  DATA 70,6C
0232E:  DATA 65,5B
02330:  DATA 25,4C
02332:  DATA 75,5D
02334:  DATA 2C,73
02336:  DATA 74,61
02338:  DATA 72,74
0233A:  DATA 0D,0A
0233C:  DATA 00,00
0233E:  DATA 2C,61
02340:  DATA 75,74
02342:  DATA 6F,2D
02344:  DATA 73,61
02346:  DATA 6D,70
02348:  DATA 6C,65
0234A:  DATA 2C,73
0234C:  DATA 61,6D
0234E:  DATA 70,6C
02350:  DATA 65,5B
02352:  DATA 25,4C
02354:  DATA 75,5D
02356:  DATA 2C,63
02358:  DATA 6F,6D
0235A:  DATA 70,6C
0235C:  DATA 65,74
0235E:  DATA 65,0D
02360:  DATA 0A,00
02362:  DATA 2C,61
02364:  DATA 75,74
02366:  DATA 6F,2D
02368:  DATA 73,61
0236A:  DATA 6D,70
0236C:  DATA 6C,65
0236E:  DATA 2C,73
02370:  DATA 61,6D
02372:  DATA 70,6C
02374:  DATA 65,5B
02376:  DATA 25,4C
02378:  DATA 75,5D
0237A:  DATA 2C,6D
0237C:  DATA 61,78
0237E:  DATA 20,73
02380:  DATA 61,6D
02382:  DATA 70,6C
02384:  DATA 65,73
02386:  DATA 0D,0A
02388:  DATA 00,00
0238A:  DATA 2C,61
0238C:  DATA 75,74
0238E:  DATA 6F,2D
02390:  DATA 73,61
02392:  DATA 6D,70
02394:  DATA 6C,65
02396:  DATA 2C,69
02398:  DATA 6E,69
0239A:  DATA 74,69
0239C:  DATA 61,6C
0239E:  DATA 69,7A
023A0:  DATA 65,0D
023A2:  DATA 0A,00
023A4:  DATA 2C,68
023A6:  DATA 65,61
023A8:  DATA 64,65
023AA:  DATA 72,2C
023AC:  DATA 69,64
023AE:  DATA 23,5B
023B0:  DATA 25,4C
023B2:  DATA 75,5D
023B4:  DATA 2C,69
023B6:  DATA 6E,74
023B8:  DATA 5B,25
023BA:  DATA 4C,75
023BC:  DATA 5D,2C
023BE:  DATA 6D,61
023C0:  DATA 78,5B
023C2:  DATA 25,4C
023C4:  DATA 75,5D
023C6:  DATA 0D,0A
023C8:  DATA 00,00
023CA:  DATA 2C,61
023CC:  DATA 75,74
023CE:  DATA 6F,2D
023D0:  DATA 73,61
023D2:  DATA 6D,70
023D4:  DATA 6C,65
023D6:  DATA 2C,73
023D8:  DATA 61,6D
023DA:  DATA 70,6C
023DC:  DATA 65,5B
023DE:  DATA 25,4C
023E0:  DATA 75,5D
023E2:  DATA 2C,61
023E4:  DATA 6C,61
023E6:  DATA 72,6D
023E8:  DATA 5B,25
023EA:  DATA 75,5D
023EC:  DATA 0D,0A
023EE:  DATA 00,00
023F0:  DATA 2C,61
023F2:  DATA 75,74
023F4:  DATA 6F,2D
023F6:  DATA 73,61
023F8:  DATA 6D,70
023FA:  DATA 6C,65
023FC:  DATA 2C,73
023FE:  DATA 6C,65
02400:  DATA 65,70
02402:  DATA 0D,0A
02404:  DATA 00,00
02406:  DATA 74,31
02408:  DATA 3A,25
0240A:  DATA 4C,75
0240C:  DATA 20,74
0240E:  DATA 32,3A
02410:  DATA 25,4C
02412:  DATA 75,0D
02414:  DATA 0A,00
02416:  DATA 40,44
02418:  DATA 45,54
0241A:  DATA 2C,25
0241C:  DATA 4C,75
0241E:  DATA 0D,0A
02420:  DATA 00,00
02422:  DATA 4E,4F
02424:  DATA 33,2C
02426:  DATA 25,31
02428:  DATA 2E,35
0242A:  DATA 67,2C
0242C:  DATA 25,31
0242E:  DATA 2E,35
02430:  DATA 67,0D
02432:  DATA 0A,00
02434:  DATA 50,4F
02436:  DATA 34,2C
02438:  DATA 25,31
0243A:  DATA 2E,35
0243C:  DATA 67,2C
0243E:  DATA 25,31
02440:  DATA 2E,35
02442:  DATA 67,0D
02444:  DATA 0A,00
02446:  DATA 4E,48
02448:  DATA 34,2C
0244A:  DATA 25,31
0244C:  DATA 2E,35
0244E:  DATA 67,2C
02450:  DATA 25,31
02452:  DATA 2E,35
02454:  DATA 67,0D
02456:  DATA 0A,00
02458:  DATA 53,69
0245A:  DATA 4F,34
0245C:  DATA 2C,25
0245E:  DATA 31,2E
02460:  DATA 35,67
02462:  DATA 2C,25
02464:  DATA 31,2E
02466:  DATA 35,67
02468:  DATA 0D,0A
0246A:  DATA 00,00
0246C:  DATA 4E,4F
0246E:  DATA 33,28
02470:  DATA 6D,29
02472:  DATA 3A,00
02474:  DATA 4E,4F
02476:  DATA 33,28
02478:  DATA 63,29
0247A:  DATA 3A,00
0247C:  DATA 50,4F
0247E:  DATA 34,28
02480:  DATA 6D,29
02482:  DATA 3A,00
02484:  DATA 50,4F
02486:  DATA 34,28
02488:  DATA 63,29
0248A:  DATA 3A,00
0248C:  DATA 4E,48
0248E:  DATA 34,28
02490:  DATA 6D,29
02492:  DATA 3A,00
02494:  DATA 4E,48
02496:  DATA 34,28
02498:  DATA 63,29
0249A:  DATA 3A,00
0249C:  DATA 53,69
0249E:  DATA 4F,34
024A0:  DATA 28,6D
024A2:  DATA 29,3A
024A4:  DATA 00,00
024A6:  DATA 53,69
024A8:  DATA 4F,34
024AA:  DATA 28,63
024AC:  DATA 29,3A
024AE:  DATA 00,00
024B0:  DATA 41,72
024B2:  DATA 65,20
024B4:  DATA 79,6F
024B6:  DATA 75,20
024B8:  DATA 73,75
024BA:  DATA 72,65
024BC:  DATA 20,79
024BE:  DATA 6F,75
024C0:  DATA 20,77
024C2:  DATA 61,6E
024C4:  DATA 74,20
024C6:  DATA 74,6F
024C8:  DATA 20,65
024CA:  DATA 72,61
024CC:  DATA 73,65
024CE:  DATA 20,74
024D0:  DATA 68,65
024D2:  DATA 20,72
024D4:  DATA 61,77
024D6:  DATA 20,64
024D8:  DATA 61,74
024DA:  DATA 61,20
024DC:  DATA 66,69
024DE:  DATA 6C,65
024E0:  DATA 3F,20
024E2:  DATA 59,20
024E4:  DATA 6F,72
024E6:  DATA 20,4E
024E8:  DATA 21,0D
024EA:  DATA 0A,00
024EC:  DATA 46,69
024EE:  DATA 6C,65
024F0:  DATA 20,64
024F2:  DATA 65,6C
024F4:  DATA 65,74
024F6:  DATA 65,64
024F8:  DATA 21,0A
024FA:  DATA 0D,00
024FC:  DATA 4F,70
024FE:  DATA 65,72
02500:  DATA 61,74
02502:  DATA 69,6F
02504:  DATA 6E,20
02506:  DATA 63,61
02508:  DATA 6E,63
0250A:  DATA 65,6C
0250C:  DATA 65,64
0250E:  DATA 21,0D
02510:  DATA 0A,00
02512:  DATA 41,72
02514:  DATA 65,20
02516:  DATA 79,6F
02518:  DATA 75,20
0251A:  DATA 73,75
0251C:  DATA 72,65
0251E:  DATA 20,79
02520:  DATA 6F,75
02522:  DATA 20,77
02524:  DATA 61,6E
02526:  DATA 74,20
02528:  DATA 74,6F
0252A:  DATA 20,65
0252C:  DATA 72,61
0252E:  DATA 73,65
02530:  DATA 20,74
02532:  DATA 68,65
02534:  DATA 20,63
02536:  DATA 61,6C
02538:  DATA 63,75
0253A:  DATA 6C,61
0253C:  DATA 74,65
0253E:  DATA 64,20
02540:  DATA 64,61
02542:  DATA 74,61
02544:  DATA 20,66
02546:  DATA 69,6C
02548:  DATA 65,3F
0254A:  DATA 20,59
0254C:  DATA 20,6F
0254E:  DATA 72,20
02550:  DATA 4E,21
02552:  DATA 0D,0A
02554:  DATA 00,00
02556:  DATA 46,69
02558:  DATA 6C,65
0255A:  DATA 20,64
0255C:  DATA 65,6C
0255E:  DATA 65,74
02560:  DATA 65,64
02562:  DATA 21,0A
02564:  DATA 0D,00
02566:  DATA 4F,70
02568:  DATA 65,72
0256A:  DATA 61,74
0256C:  DATA 69,6F
0256E:  DATA 6E,20
02570:  DATA 63,61
02572:  DATA 6E,63
02574:  DATA 65,6C
02576:  DATA 65,64
02578:  DATA 21,0D
0257A:  DATA 0A,00
0257C:  DATA 40,49
0257E:  DATA 44,23
02580:  DATA 25,4C
02582:  DATA 75,20
02584:  DATA 49,25
02586:  DATA 4C,75
02588:  DATA 20,4E
0258A:  DATA 25,4C
0258C:  DATA 75,2F
0258E:  DATA 25,4C
02590:  DATA 75,20
02592:  DATA 58,25
02594:  DATA 4C,75
02596:  DATA 20,55
02598:  DATA 25,75
0259A:  DATA 20,25
0259C:  DATA 34,2E
0259E:  DATA 32,77
025A0:  DATA 56,0D
025A2:  DATA 0A,00
025A4:  DATA 40,4D
025A6:  DATA 4F,54
025A8:  DATA 3A,56
025AA:  DATA 41,4C
025AC:  DATA 3D,25
025AE:  DATA 4C,75
025B0:  DATA 20,53
025B2:  DATA 59,52
025B4:  DATA 3D,25
025B6:  DATA 4C,64
025B8:  DATA 0D,0A
025BA:  DATA 00,00
025BC:  DATA 40,50
025BE:  DATA 57,52
025C0:  DATA 3A,25
025C2:  DATA 30,32
025C4:  DATA 75,2F
025C6:  DATA 25,30
025C8:  DATA 32,75
025CA:  DATA 2F,25
025CC:  DATA 30,32
025CE:  DATA 75,20
025D0:  DATA 25,30
025D2:  DATA 32,75
025D4:  DATA 3A,25
025D6:  DATA 30,32
025D8:  DATA 75,3A
025DA:  DATA 25,30
025DC:  DATA 32,75
025DE:  DATA 0D,0A
025E0:  DATA 00,00
025E2:  DATA 40,50
025E4:  DATA 57,52
025E6:  DATA 3A,25
025E8:  DATA 30,32
025EA:  DATA 75,2F
025EC:  DATA 25,30
025EE:  DATA 32,75
025F0:  DATA 2F,25
025F2:  DATA 30,32
025F4:  DATA 75,20
025F6:  DATA 25,30
025F8:  DATA 32,75
025FA:  DATA 3A,25
025FC:  DATA 30,32
025FE:  DATA 75,3A
02600:  DATA 25,30
02602:  DATA 32,75
02604:  DATA 0D,0A
02606:  DATA 00,00
02608:  DATA 41,25
0260A:  DATA 4C,75
0260C:  DATA 20,49
0260E:  DATA 25,4C
02610:  DATA 75,20
02612:  DATA 4C,25
02614:  DATA 4C,75
02616:  DATA 20,51
02618:  DATA 25,4C
0261A:  DATA 75,20
0261C:  DATA 53,25
0261E:  DATA 4C,75
02620:  DATA 20,25
02622:  DATA 34,2E
02624:  DATA 32,77
02626:  DATA 56,0D
02628:  DATA 0A,00
0262A:  DATA 40,4D
0262C:  DATA 4F,54
0262E:  DATA 3A,56
02630:  DATA 41,4C
02632:  DATA 3D,25
02634:  DATA 4C,75
02636:  DATA 20,53
02638:  DATA 59,52
0263A:  DATA 3D,25
0263C:  DATA 4C,64
0263E:  DATA 0D,0A
02640:  DATA 00,00
02642:  DATA 40,50
02644:  DATA 57,52
02646:  DATA 3A,25
02648:  DATA 30,32
0264A:  DATA 75,2F
0264C:  DATA 25,30
0264E:  DATA 32,75
02650:  DATA 2F,25
02652:  DATA 30,32
02654:  DATA 75,20
02656:  DATA 25,30
02658:  DATA 32,75
0265A:  DATA 3A,25
0265C:  DATA 30,32
0265E:  DATA 75,3A
02660:  DATA 25,30
02662:  DATA 32,75
02664:  DATA 0D,0A
02666:  DATA 00,00
02668:  DATA 49,25
0266A:  DATA 4C,75
0266C:  DATA 20,4E
0266E:  DATA 25,4C
02670:  DATA 75,2F
02672:  DATA 25,4C
02674:  DATA 75,20
02676:  DATA 50,25
02678:  DATA 4C,75
0267A:  DATA 20,25
0267C:  DATA 34,2E
0267E:  DATA 32,77
02680:  DATA 56,0D
02682:  DATA 0A,00
02684:  DATA 40,4D
02686:  DATA 4F,54
02688:  DATA 3A,53
0268A:  DATA 59,52
0268C:  DATA 3D,25
0268E:  DATA 4C,64
02690:  DATA 0D,0A
02692:  DATA 00,00
02694:  DATA 40,50
02696:  DATA 57,52
02698:  DATA 3A,25
0269A:  DATA 30,32
0269C:  DATA 75,2F
0269E:  DATA 25,30
026A0:  DATA 32,75
026A2:  DATA 2F,25
026A4:  DATA 30,32
026A6:  DATA 75,20
026A8:  DATA 25,30
026AA:  DATA 32,75
026AC:  DATA 3A,25
026AE:  DATA 30,32
026B0:  DATA 75,3A
026B2:  DATA 25,30
026B4:  DATA 32,75
026B6:  DATA 0D,0A
026B8:  DATA 00,00
026BA:  DATA 40,53
026BC:  DATA 4D,50
026BE:  DATA 20,25
026C0:  DATA 30,34
026C2:  DATA 4C,75
026C4:  DATA 0D,0A
026C6:  DATA 00,00
026C8:  DATA 40,53
026CA:  DATA 4D,50
026CC:  DATA 20,25
026CE:  DATA 30,34
026D0:  DATA 4C,75
026D2:  DATA 0D,0A
026D4:  DATA 00,00
026D6:  DATA 45,6E
026D8:  DATA 74,65
026DA:  DATA 72,20
026DC:  DATA 64,61
026DE:  DATA 74,65
026E0:  DATA 20,66
026E2:  DATA 6F,72
026E4:  DATA 6D,61
026E6:  DATA 74,20
026E8:  DATA 30,3D
026EA:  DATA 4D,4D
026EC:  DATA 2F,44
026EE:  DATA 44,2F
026F0:  DATA 59,59
026F2:  DATA 20,20
026F4:  DATA 31,3D
026F6:  DATA 44,44
026F8:  DATA 2F,4D
026FA:  DATA 4D,2F
026FC:  DATA 59,59
026FE:  DATA 0D,0A
02700:  DATA 00,00
02702:  DATA 40,4F
02704:  DATA 4B,21
02706:  DATA 0D,0A
02708:  DATA 20,00
0270A:  DATA 40,45
0270C:  DATA 52,52
0270E:  DATA 0D,0A
02710:  DATA 00,00
02712:  DATA 40,52
02714:  DATA 55,4E
02716:  DATA 0D,0A
02718:  DATA 00,00
0271A:  DATA 5B,6D
0271C:  DATA 6F,74
0271E:  DATA 6F,72
02720:  DATA 3A,31
02722:  DATA 5D,0D
02724:  DATA 0A,00
02726:  DATA 5B,6D
02728:  DATA 6F,74
0272A:  DATA 6F,72
0272C:  DATA 3A,32
0272E:  DATA 5D,0D
02730:  DATA 0A,00
02732:  DATA 2C,45
02734:  DATA 43,4F
02736:  DATA 20,6D
02738:  DATA 6F,64
0273A:  DATA 65,20
0273C:  DATA 73,65
0273E:  DATA 74,0D
02740:  DATA 0A,00
02742:  DATA 2C,57
02744:  DATA 4D,53
02746:  DATA 2D,34
02748:  DATA 2D,53
0274A:  DATA 44,20
0274C:  DATA 6D,6F
0274E:  DATA 64,65
02750:  DATA 20,73
02752:  DATA 65,74
02754:  DATA 0D,0A
02756:  DATA 00,00
02758:  DATA 2C,41
0275A:  DATA 57,53
0275C:  DATA 20,6D
0275E:  DATA 6F,64
02760:  DATA 65,20
02762:  DATA 73,65
02764:  DATA 74,0D
02766:  DATA 0A,00
02768:  DATA 2C,57
0276A:  DATA 4D,53
0276C:  DATA 2D,34
0276E:  DATA 2D,51
02770:  DATA 45,20
02772:  DATA 6D,6F
02774:  DATA 64,65
02776:  DATA 20,73
02778:  DATA 65,74
0277A:  DATA 0D,0A
0277C:  DATA 00,00
0277E:  DATA 30,36
02780:  DATA 2D,4A
02782:  DATA 75,6C
02784:  DATA 2D,31
02786:  DATA 37,00
02788:  DATA 31,36
0278A:  DATA 3A,30
0278C:  DATA 39,3A
0278E:  DATA 30,31
02790:  DATA 00,00
02792:  DATA 53,45
02794:  DATA 4E,44
02796:  DATA 20,48
02798:  DATA 45,58
0279A:  DATA 20,46
0279C:  DATA 49,4C
0279E:  DATA 45,20
027A0:  DATA 28,31
027A2:  DATA 39,32
027A4:  DATA 30,30
027A6:  DATA 2C,4E
027A8:  DATA 38,31
027AA:  DATA 2C,58
027AC:  DATA 4F,4E
027AE:  DATA 2D,58
027B0:  DATA 4F,46
027B2:  DATA 46,29
027B4:  DATA 0D,0A
027B6:  DATA 00,00
027B8:  DATA 40,4F
027BA:  DATA 4B,21
027BC:  DATA 20,00
027BE:  DATA 40,41
027C0:  DATA 52,47
027C2:  DATA 20,00
027C4:  DATA 40,4F
027C6:  DATA 4B,21
027C8:  DATA 20,00
027CA:  DATA 40,41
027CC:  DATA 52,47
027CE:  DATA 20,00
027D0:  DATA 0D,0A
027D2:  DATA 40,49
027D4:  DATA 4E,56
027D6:  DATA 00,00
027D8:  DATA 0D,0A
027DA:  DATA 40,4F
027DC:  DATA 4B,21
027DE:  DATA 20,00
027E0:  DATA 40,49
027E2:  DATA 4E,56
027E4:  DATA 00,00
027E6:  DATA 40,43
027E8:  DATA 4D,44
027EA:  DATA 00,00
027EC:  DATA 2C,63
027EE:  DATA 6F,6D
027F0:  DATA 6D,61
027F2:  DATA 6E,64
027F4:  DATA 20,70
027F6:  DATA 72,6F
027F8:  DATA 6D,70
027FA:  DATA 74,0D
027FC:  DATA 0A,00
027FE:  DATA 20,20
02800:  DATA 20,20
02802:  DATA 20,20
02804:  DATA 20,20
02806:  DATA 20,20
02808:  DATA 20,20
0280A:  DATA 20,20
0280C:  DATA 20,20
0280E:  DATA 20,20
02810:  DATA 20,20
02812:  DATA 20,20
02814:  DATA 20,20
02816:  DATA 20,20
02818:  DATA 20,20
0281A:  DATA 20,20
0281C:  DATA 20,20
0281E:  DATA 20,20
02820:  DATA 20,20
02822:  DATA 20,20
02824:  DATA 20,00
02826:  DATA 0D,0A
02828:  DATA 40,41
0282A:  DATA 52,47
0282C:  DATA 20,00
0282E:  DATA 40,43
02830:  DATA 4D,44
02832:  DATA 00,00
02834:  DATA 2C,63
02836:  DATA 6F,6D
02838:  DATA 6D,61
0283A:  DATA 6E,64
0283C:  DATA 20,70
0283E:  DATA 72,6F
02840:  DATA 6D,70
02842:  DATA 74,0D
02844:  DATA 0A,00
02846:  DATA 40,53
02848:  DATA 44,3D
0284A:  DATA 25,4C
0284C:  DATA 75,0D
0284E:  DATA 0A,00
02850:  DATA 40,4D
02852:  DATA 43,31
02854:  DATA 2C,25
02856:  DATA 4C,75
02858:  DATA 2C,25
0285A:  DATA 4C,64
0285C:  DATA 0D,0A
0285E:  DATA 00,00
02860:  DATA 40,4D
02862:  DATA 43,32
02864:  DATA 2C,25
02866:  DATA 4C,75
02868:  DATA 2C,25
0286A:  DATA 4C,64
0286C:  DATA 0D,0A
0286E:  DATA 00,00
02870:  DATA 50,72
02872:  DATA 65,73
02874:  DATA 73,20
02876:  DATA 61,6E
02878:  DATA 64,20
0287A:  DATA 68,6F
0287C:  DATA 6C,64
0287E:  DATA 20,74
02880:  DATA 68,65
02882:  DATA 20,45
02884:  DATA 73,63
02886:  DATA 20,6B
02888:  DATA 65,79
0288A:  DATA 20,74
0288C:  DATA 6F,20
0288E:  DATA 72,65
02890:  DATA 74,75
02892:  DATA 72,6E
02894:  DATA 20,74
02896:  DATA 6F,20
02898:  DATA 43,6F
0289A:  DATA 6D,6D
0289C:  DATA 61,6E
0289E:  DATA 64,20
028A0:  DATA 4D,6F
028A2:  DATA 64,65
028A4:  DATA 0D,0A
028A6:  DATA 00,00
028A8:  DATA 52,65
028AA:  DATA 74,75
028AC:  DATA 72,6E
028AE:  DATA 69,6E
028B0:  DATA 67,20
028B2:  DATA 74,6F
028B4:  DATA 20,4C
028B6:  DATA 6F,67
028B8:  DATA 67,69
028BA:  DATA 6E,67
028BC:  DATA 20,4D
028BE:  DATA 6F,64
028C0:  DATA 65,0D
028C2:  DATA 0A,00
*
02CD4:  CLRF   01
02CD6:  CLRF   02
02CD8:  CLRF   00
02CDA:  CLRF   03
02CDC:  MOVLB  8
02CDE:  MOVF   xDE,W
02CE0:  BNZ   2CE6
02CE2:  MOVF   xDD,W
02CE4:  BZ    2D16
02CE6:  MOVLW  10
02CE8:  MOVWF  xDF
02CEA:  BCF    FD8.0
02CEC:  RLCF   xDB,F
02CEE:  RLCF   xDC,F
02CF0:  RLCF   00,F
02CF2:  RLCF   03,F
02CF4:  MOVF   xDE,W
02CF6:  SUBWF  03,W
02CF8:  BNZ   2CFE
02CFA:  MOVF   xDD,W
02CFC:  SUBWF  00,W
02CFE:  BNC   2D0E
02D00:  MOVF   xDD,W
02D02:  SUBWF  00,F
02D04:  BTFSS  FD8.0
02D06:  DECF   03,F
02D08:  MOVF   xDE,W
02D0A:  SUBWF  03,F
02D0C:  BSF    FD8.0
02D0E:  RLCF   01,F
02D10:  RLCF   02,F
02D12:  DECFSZ xDF,F
02D14:  BRA    2CEA
02D16:  MOVLB  0
02D18:  RETURN 0
*
03526:  TSTFSZ 01
03528:  BRA    3530
0352A:  TSTFSZ 02
0352C:  BRA    3532
0352E:  BRA    353E
03530:  INCF   02,F
03532:  MOVFF  00,FEE
03536:  DECFSZ 01,F
03538:  BRA    3532
0353A:  DECFSZ 02,F
0353C:  BRA    3532
0353E:  RETURN 0
*
03610:  MOVLB  9
03612:  BTFSC  xED.7
03614:  BRA    3636
03616:  MOVLW  0F
03618:  MOVWF  00
0361A:  SWAPF  xEC,W
0361C:  ANDWF  00,F
0361E:  MOVLW  0A
03620:  SUBWF  00,W
03622:  BC    362A
03624:  MOVLW  30
03626:  ADDWF  00,F
03628:  BRA    362E
0362A:  MOVF   xED,W
0362C:  ADDWF  00,F
0362E:  MOVF   00,W
03630:  BTFSS  F9E.4
03632:  BRA    3630
03634:  MOVWF  FAD
03636:  MOVLW  0F
03638:  ANDWF  xEC,F
0363A:  MOVLW  0A
0363C:  SUBWF  xEC,W
0363E:  BC    3644
03640:  MOVLW  30
03642:  BRA    3648
03644:  BCF    xED.7
03646:  MOVF   xED,W
03648:  ADDWF  xEC,F
0364A:  MOVF   xEC,W
0364C:  BTFSS  F9E.4
0364E:  BRA    364C
03650:  MOVWF  FAD
03652:  MOVLB  0
03654:  RETURN 0
*
047F0:  MOVLB  9
047F2:  CLRF   xFE
047F4:  CLRF   xFF
047F6:  MOVLW  01
047F8:  MOVLB  A
047FA:  MOVWF  x00
047FC:  CLRF   FDA
047FE:  CLRF   FD9
04800:  MOVLW  09
04802:  MOVWF  x03
04804:  MOVLW  F6
04806:  MOVWF  x02
04808:  MOVLW  09
0480A:  MOVWF  FEA
0480C:  MOVLW  FA
0480E:  MOVWF  FE9
04810:  MOVFF  A03,FE2
04814:  MOVFF  A02,FE1
04818:  MOVFF  A00,A01
0481C:  BCF    FD8.0
0481E:  MOVF   FE5,W
04820:  MULWF  FEE
04822:  MOVF   FF3,W
04824:  MOVLB  9
04826:  ADDWFC xFE,F
04828:  MOVF   FF4,W
0482A:  ADDWFC xFF,F
0482C:  MOVLB  A
0482E:  DECFSZ x01,F
04830:  BRA    481C
04832:  MOVFF  9FE,FDE
04836:  MOVFF  9FF,9FE
0483A:  MOVLB  9
0483C:  CLRF   xFF
0483E:  BTFSC  FD8.0
04840:  INCF   xFF,F
04842:  MOVLB  A
04844:  INCF   x02,F
04846:  BTFSC  FD8.2
04848:  INCF   x03,F
0484A:  INCF   x00,F
0484C:  MOVF   x00,W
0484E:  SUBLW  05
04850:  BNZ   4808
04852:  MOVLB  0
04854:  RETURN 0
*
0509E:  MOVFF  1E,FEA
050A2:  MOVFF  1D,FE9
050A6:  MOVLB  8
050A8:  MOVFF  8FF,FEF
050AC:  INCF   FE9,F
050AE:  BTFSC  FD8.2
050B0:  INCF   FEA,F
050B2:  CLRF   FEF
050B4:  INCF   1D,F
050B6:  BTFSC  FD8.2
050B8:  INCF   1E,F
050BA:  MOVLB  0
050BC:  RETURN 0
050BE:  TBLRD*+
050C0:  MOVF   FF5,F
050C2:  BZ    50E4
050C4:  MOVFF  FF6,8EB
050C8:  MOVFF  FF7,8EC
050CC:  MOVFF  FF8,8ED
050D0:  MOVFF  FF5,8FF
050D4:  RCALL  509E
050D6:  MOVFF  8EB,FF6
050DA:  MOVFF  8EC,FF7
050DE:  MOVFF  8ED,FF8
050E2:  BRA    50BE
050E4:  RETURN 0
*
05280:  MOVF   01,W
05282:  CLRF   1B
05284:  BTFSC  FF2.7
05286:  BSF    1B.7
05288:  BCF    FF2.7
0528A:  MOVFF  8ED,A42
0528E:  MOVLW  64
05290:  MOVLB  A
05292:  MOVWF  x43
05294:  MOVLB  0
05296:  CALL   0F7A
0529A:  BTFSC  1B.7
0529C:  BSF    FF2.7
0529E:  MOVFF  00,8ED
052A2:  MOVF   01,W
052A4:  MOVLW  30
052A6:  BNZ   52B8
052A8:  MOVLB  8
052AA:  BTFSS  xEE.1
052AC:  BRA    52CC
052AE:  BTFSC  xEE.3
052B0:  BRA    52CC
052B2:  BTFSC  xEE.4
052B4:  MOVLW  20
052B6:  BRA    52C0
052B8:  MOVLB  8
052BA:  BCF    xEE.3
052BC:  BCF    xEE.4
052BE:  BSF    xEE.0
052C0:  ADDWF  01,F
052C2:  MOVFF  01,8FF
052C6:  MOVLB  0
052C8:  RCALL  509E
052CA:  MOVLB  8
052CC:  CLRF   1B
052CE:  BTFSC  FF2.7
052D0:  BSF    1B.7
052D2:  BCF    FF2.7
052D4:  MOVFF  8ED,A42
052D8:  MOVLW  0A
052DA:  MOVLB  A
052DC:  MOVWF  x43
052DE:  MOVLB  0
052E0:  CALL   0F7A
052E4:  BTFSC  1B.7
052E6:  BSF    FF2.7
052E8:  MOVFF  00,8ED
052EC:  MOVF   01,W
052EE:  MOVLW  30
052F0:  BNZ   5302
052F2:  MOVLB  8
052F4:  BTFSC  xEE.3
052F6:  BRA    530C
052F8:  BTFSS  xEE.0
052FA:  BRA    530C
052FC:  BTFSC  xEE.4
052FE:  MOVLW  20
05300:  MOVLB  0
05302:  ADDWF  01,F
05304:  MOVFF  01,8FF
05308:  RCALL  509E
0530A:  MOVLB  8
0530C:  MOVLW  30
0530E:  ADDWF  xED,F
05310:  MOVFF  8ED,8FF
05314:  MOVLB  0
05316:  RCALL  509E
05318:  RETURN 0
0531A:  MOVF   FE9,W
0531C:  MOVLB  8
0531E:  MOVWF  xF2
05320:  MOVLW  3B
05322:  MOVWF  xF9
05324:  MOVLW  9A
05326:  MOVWF  xF8
05328:  MOVLW  CA
0532A:  MOVWF  xF7
0532C:  CLRF   xF6
0532E:  MOVLW  0A
05330:  MOVWF  xF4
05332:  MOVF   xF1,W
05334:  BTFSS  FD8.2
05336:  DECF   xF2,F
05338:  BSF    FD8.1
0533A:  MOVLW  08
0533C:  MOVWF  FEA
0533E:  MOVLW  ED
05340:  MOVWF  FE9
05342:  CLRF   1B
05344:  BTFSC  FF2.7
05346:  BSF    1B.7
05348:  BCF    FF2.7
0534A:  MOVFF  8F0,A4F
0534E:  MOVFF  8EF,A4E
05352:  MOVFF  8EE,A4D
05356:  MOVFF  8ED,A4C
0535A:  MOVFF  8F9,A53
0535E:  MOVFF  8F8,A52
05362:  MOVFF  8F7,A51
05366:  MOVFF  8F6,A50
0536A:  MOVLB  0
0536C:  CALL   1056
05370:  BTFSC  1B.7
05372:  BSF    FF2.7
05374:  MOVF   01,W
05376:  MOVF   00,F
05378:  BNZ   53A0
0537A:  MOVLB  8
0537C:  INCF   xF1,W
0537E:  SUBWF  xF4,W
05380:  BTFSS  FD8.2
05382:  BRA    5388
05384:  MOVLB  0
05386:  BRA    53A0
05388:  MOVF   xF2,W
0538A:  BZ    53A4
0538C:  ANDLW  0F
0538E:  SUBWF  xF4,W
05390:  BZ    5394
05392:  BC    53D0
05394:  BTFSC  xF2.7
05396:  BRA    53D0
05398:  BTFSC  xF2.6
0539A:  BRA    53A4
0539C:  MOVLW  20
0539E:  BRA    53C4
053A0:  MOVLB  8
053A2:  CLRF   xF2
053A4:  MOVF   xF1,W
053A6:  SUBWF  xF4,W
053A8:  BNZ   53C2
053AA:  MOVFF  00,8F2
053AE:  MOVLW  2E
053B0:  MOVWF  xFF
053B2:  MOVLB  0
053B4:  RCALL  509E
053B6:  MOVLB  8
053B8:  MOVFF  8F2,00
053BC:  MOVLW  20
053BE:  ANDWF  xF2,F
053C0:  MOVLW  00
053C2:  MOVLW  30
053C4:  ADDWF  00,F
053C6:  MOVFF  00,8FF
053CA:  MOVLB  0
053CC:  RCALL  509E
053CE:  MOVLB  8
053D0:  BCF    FD8.1
053D2:  CLRF   1B
053D4:  BTFSC  FF2.7
053D6:  BSF    1B.7
053D8:  BCF    FF2.7
053DA:  MOVFF  8F9,A4F
053DE:  MOVFF  8F8,A4E
053E2:  MOVFF  8F7,A4D
053E6:  MOVFF  8F6,A4C
053EA:  MOVLB  A
053EC:  CLRF   x53
053EE:  CLRF   x52
053F0:  CLRF   x51
053F2:  MOVLW  0A
053F4:  MOVWF  x50
053F6:  MOVLB  0
053F8:  CALL   1056
053FC:  BTFSC  1B.7
053FE:  BSF    FF2.7
05400:  MOVFF  03,8F9
05404:  MOVFF  02,8F8
05408:  MOVFF  01,8F7
0540C:  MOVFF  00,8F6
05410:  MOVLB  8
05412:  DECFSZ xF4,F
05414:  BRA    5338
05416:  MOVLB  0
05418:  RETURN 0
*
05C98:  MOVLB  A
05C9A:  MOVF   x10,W
05C9C:  MULWF  x12
05C9E:  MOVFF  FF3,01
05CA2:  MOVFF  FF4,00
05CA6:  MULWF  x13
05CA8:  MOVF   FF3,W
05CAA:  ADDWF  00,F
05CAC:  MOVF   x11,W
05CAE:  MULWF  x12
05CB0:  MOVF   FF3,W
05CB2:  ADDWFC 00,W
05CB4:  MOVWF  02
05CB6:  MOVLB  0
05CB8:  RETURN 0
*
07996:  MOVF   FEF,F
07998:  BZ    79BA
0799A:  MOVFF  FEA,9B1
0799E:  MOVFF  FE9,9B0
079A2:  MOVF   FEF,W
079A4:  BTFSS  F9E.4
079A6:  BRA    79A4
079A8:  MOVWF  FAD
079AA:  MOVFF  9B1,FEA
079AE:  MOVFF  9B0,FE9
079B2:  INCF   FE9,F
079B4:  BTFSC  FD8.2
079B6:  INCF   FEA,F
079B8:  BRA    7996
079BA:  RETURN 0
*
08FE4:  MOVFF  FEA,8F8
08FE8:  MOVFF  FE9,8F7
08FEC:  MOVLB  8
08FEE:  BTFSS  xF1.7
08FF0:  BRA    9002
08FF2:  BSF    xF7.7
08FF4:  BTFSS  xF7.4
08FF6:  INCF   xF7,F
08FF8:  COMF   xF0,F
08FFA:  COMF   xF1,F
08FFC:  INCF   xF0,F
08FFE:  BTFSC  FD8.2
09000:  INCF   xF1,F
09002:  SWAPF  xF1,W
09004:  IORLW  F0
09006:  MOVWF  xF3
09008:  ADDWF  xF3,F
0900A:  ADDLW  E2
0900C:  MOVWF  xF4
0900E:  ADDLW  32
09010:  MOVWF  xF6
09012:  MOVF   xF1,W
09014:  ANDLW  0F
09016:  ADDWF  xF4,F
09018:  ADDWF  xF4,F
0901A:  ADDWF  xF6,F
0901C:  ADDLW  E9
0901E:  MOVWF  xF5
09020:  ADDWF  xF5,F
09022:  ADDWF  xF5,F
09024:  SWAPF  xF0,W
09026:  ANDLW  0F
09028:  ADDWF  xF5,F
0902A:  ADDWF  xF6,F
0902C:  RLCF   xF5,F
0902E:  RLCF   xF6,F
09030:  COMF   xF6,F
09032:  RLCF   xF6,F
09034:  MOVF   xF0,W
09036:  ANDLW  0F
09038:  ADDWF  xF6,F
0903A:  RLCF   xF3,F
0903C:  MOVLW  07
0903E:  MOVWF  xF2
09040:  MOVLW  0A
09042:  DECF   xF5,F
09044:  ADDWF  xF6,F
09046:  BNC   9042
09048:  DECF   xF4,F
0904A:  ADDWF  xF5,F
0904C:  BNC   9048
0904E:  DECF   xF3,F
09050:  ADDWF  xF4,F
09052:  BNC   904E
09054:  DECF   xF2,F
09056:  ADDWF  xF3,F
09058:  BNC   9054
0905A:  MOVLW  08
0905C:  MOVWF  FEA
0905E:  MOVLW  F2
09060:  MOVWF  FE9
09062:  MOVLW  07
09064:  ANDWF  xF7,W
09066:  BCF    xF7.6
09068:  MOVF   FED,F
0906A:  ANDWF  xF7,W
0906C:  BNZ   907C
0906E:  BTFSC  xF7.4
09070:  MOVF   FEE,F
09072:  BTFSC  xF7.4
09074:  BRA    907C
09076:  MOVLW  20
09078:  MOVWF  00
0907A:  BRA    90BE
0907C:  ADDWF  FE9,F
0907E:  MOVLW  00
09080:  ADDWFC FEA,F
09082:  MOVF   FE9,W
09084:  SUBLW  F6
09086:  BNZ   9090
09088:  MOVF   FEA,W
0908A:  SUBLW  08
0908C:  BNZ   9090
0908E:  BSF    xF7.6
09090:  MOVF   FEF,W
09092:  MOVWF  00
09094:  BNZ   90A6
09096:  BTFSC  xF7.6
09098:  BRA    90A6
0909A:  BTFSC  xF7.4
0909C:  BRA    90C6
0909E:  BTFSC  xF7.3
090A0:  BRA    90A6
090A2:  MOVLW  20
090A4:  BRA    90BC
090A6:  BTFSS  xF7.7
090A8:  BRA    90B6
090AA:  MOVLW  2D
090AC:  MOVWF  00
090AE:  MOVF   FED,W
090B0:  BCF    xF7.6
090B2:  BCF    xF7.7
090B4:  BRA    90BE
090B6:  BSF    xF7.3
090B8:  BCF    xF7.4
090BA:  MOVLW  30
090BC:  ADDWF  00,F
090BE:  MOVF   00,W
090C0:  BTFSS  F9E.4
090C2:  BRA    90C0
090C4:  MOVWF  FAD
090C6:  MOVF   FEE,W
090C8:  BTFSS  xF7.6
090CA:  BRA    9082
090CC:  MOVLB  0
090CE:  RETURN 0
*
09564:  MOVF   FE9,W
09566:  MOVLB  8
09568:  MOVWF  xF6
0956A:  BTFSS  xF5.7
0956C:  BRA    9588
0956E:  DECF   xF6,F
09570:  BSF    xF6.5
09572:  COMF   xF2,F
09574:  COMF   xF3,F
09576:  COMF   xF4,F
09578:  COMF   xF5,F
0957A:  INCF   xF2,F
0957C:  BTFSC  FD8.2
0957E:  INCF   xF3,F
09580:  BTFSC  FD8.2
09582:  INCF   xF4,F
09584:  BTFSC  FD8.2
09586:  INCF   xF5,F
09588:  MOVLW  3B
0958A:  MOVWF  xFD
0958C:  MOVLW  9A
0958E:  MOVWF  xFC
09590:  MOVLW  CA
09592:  MOVWF  xFB
09594:  CLRF   xFA
09596:  MOVLW  0A
09598:  MOVWF  xF8
0959A:  BSF    FD8.1
0959C:  MOVLW  08
0959E:  MOVWF  FEA
095A0:  MOVLW  F2
095A2:  MOVWF  FE9
095A4:  CLRF   1B
095A6:  BTFSC  FF2.7
095A8:  BSF    1B.7
095AA:  BCF    FF2.7
095AC:  MOVFF  8F5,A4F
095B0:  MOVFF  8F4,A4E
095B4:  MOVFF  8F3,A4D
095B8:  MOVFF  8F2,A4C
095BC:  MOVFF  8FD,A53
095C0:  MOVFF  8FC,A52
095C4:  MOVFF  8FB,A51
095C8:  MOVFF  8FA,A50
095CC:  MOVLB  0
095CE:  CALL   1056
095D2:  BTFSC  1B.7
095D4:  BSF    FF2.7
095D6:  MOVF   01,W
095D8:  MOVF   00,F
095DA:  BNZ   9602
095DC:  MOVLB  8
095DE:  MOVF   xF8,W
095E0:  XORLW  01
095E2:  BTFSS  FD8.2
095E4:  BRA    95EA
095E6:  MOVLB  0
095E8:  BRA    9602
095EA:  MOVF   xF6,W
095EC:  BZ    9608
095EE:  ANDLW  0F
095F0:  SUBWF  xF8,W
095F2:  BZ    95F6
095F4:  BC    9646
095F6:  BTFSC  xF6.7
095F8:  BRA    9646
095FA:  BTFSC  xF6.6
095FC:  BRA    9608
095FE:  MOVLW  20
09600:  BRA    963C
09602:  MOVLW  20
09604:  MOVLB  8
09606:  ANDWF  xF6,F
09608:  BTFSS  xF6.5
0960A:  BRA    9620
0960C:  BCF    xF6.5
0960E:  MOVFF  00,8F6
09612:  MOVLW  2D
09614:  BTFSS  F9E.4
09616:  BRA    9614
09618:  MOVWF  FAD
0961A:  MOVFF  8F6,00
0961E:  CLRF   xF6
09620:  MOVLW  30
09622:  BTFSS  xF6.5
09624:  BRA    963C
09626:  BCF    xF6.5
09628:  MOVFF  00,8F6
0962C:  MOVLW  2D
0962E:  BTFSS  F9E.4
09630:  BRA    962E
09632:  MOVWF  FAD
09634:  MOVFF  8F6,00
09638:  CLRF   xF6
0963A:  MOVLW  30
0963C:  ADDWF  00,F
0963E:  MOVF   00,W
09640:  BTFSS  F9E.4
09642:  BRA    9640
09644:  MOVWF  FAD
09646:  BCF    FD8.1
09648:  CLRF   1B
0964A:  BTFSC  FF2.7
0964C:  BSF    1B.7
0964E:  BCF    FF2.7
09650:  MOVFF  8FD,A4F
09654:  MOVFF  8FC,A4E
09658:  MOVFF  8FB,A4D
0965C:  MOVFF  8FA,A4C
09660:  MOVLB  A
09662:  CLRF   x53
09664:  CLRF   x52
09666:  CLRF   x51
09668:  MOVLW  0A
0966A:  MOVWF  x50
0966C:  MOVLB  0
0966E:  CALL   1056
09672:  BTFSC  1B.7
09674:  BSF    FF2.7
09676:  MOVFF  03,8FD
0967A:  MOVFF  02,8FC
0967E:  MOVFF  01,8FB
09682:  MOVFF  00,8FA
09686:  MOVLB  8
09688:  DECFSZ xF8,F
0968A:  BRA    959A
0968C:  MOVLB  0
0968E:  RETURN 0
*
0A758:  ADDWF  FE8,W
0A75A:  CLRF   FF7
0A75C:  RLCF   FF7,F
0A75E:  ADDLW  79
0A760:  MOVWF  FF6
0A762:  MOVLW  A7
0A764:  ADDWFC FF7,F
0A766:  MOVLW  00
0A768:  MOVWF  FF8
0A76A:  MOVWF  FFB
0A76C:  TBLRD*-
0A76E:  MOVF   FF5,W
0A770:  MOVWF  FFA
0A772:  TBLRD*
0A774:  MOVF   FF5,W
0A776:  MOVWF  FF9
0A778:  DATA B4,A0
0A77A:  DATA D4,A0
0A77C:  DATA FC,A0
0A77E:  DATA 2C,A1
0A780:  DATA 54,A1
*
0AACC:  TBLRD*+
0AACE:  MOVFF  FF6,8EC
0AAD2:  MOVFF  FF7,8ED
0AAD6:  MOVFF  FF8,8EE
0AADA:  MOVFF  FF5,8FF
0AADE:  CALL   509E
0AAE2:  MOVFF  8EC,FF6
0AAE6:  MOVFF  8ED,FF7
0AAEA:  MOVFF  8EE,FF8
0AAEE:  MOVLB  8
0AAF0:  DECFSZ xEB,F
0AAF2:  BRA    AAF6
0AAF4:  BRA    AAFA
0AAF6:  MOVLB  0
0AAF8:  BRA    AACC
0AAFA:  MOVLB  0
0AAFC:  RETURN 0
0AAFE:  MOVFF  FEA,8FE
0AB02:  MOVFF  FE9,8FD
0AB06:  MOVLB  8
0AB08:  SWAPF  xF7,W
0AB0A:  IORLW  F0
0AB0C:  MOVWF  xF9
0AB0E:  ADDWF  xF9,F
0AB10:  ADDLW  E2
0AB12:  MOVWF  xFA
0AB14:  ADDLW  32
0AB16:  MOVWF  xFC
0AB18:  MOVF   xF7,W
0AB1A:  ANDLW  0F
0AB1C:  ADDWF  xFA,F
0AB1E:  ADDWF  xFA,F
0AB20:  ADDWF  xFC,F
0AB22:  ADDLW  E9
0AB24:  MOVWF  xFB
0AB26:  ADDWF  xFB,F
0AB28:  ADDWF  xFB,F
0AB2A:  SWAPF  xF6,W
0AB2C:  ANDLW  0F
0AB2E:  ADDWF  xFB,F
0AB30:  ADDWF  xFC,F
0AB32:  RLCF   xFB,F
0AB34:  RLCF   xFC,F
0AB36:  COMF   xFC,F
0AB38:  RLCF   xFC,F
0AB3A:  MOVF   xF6,W
0AB3C:  ANDLW  0F
0AB3E:  ADDWF  xFC,F
0AB40:  RLCF   xF9,F
0AB42:  MOVLW  07
0AB44:  MOVWF  xF8
0AB46:  MOVLW  0A
0AB48:  DECF   xFB,F
0AB4A:  ADDWF  xFC,F
0AB4C:  BNC   AB48
0AB4E:  DECF   xFA,F
0AB50:  ADDWF  xFB,F
0AB52:  BNC   AB4E
0AB54:  DECF   xF9,F
0AB56:  ADDWF  xFA,F
0AB58:  BNC   AB54
0AB5A:  DECF   xF8,F
0AB5C:  ADDWF  xF9,F
0AB5E:  BNC   AB5A
0AB60:  MOVLW  08
0AB62:  MOVWF  FEA
0AB64:  MOVLW  F8
0AB66:  MOVWF  FE9
0AB68:  MOVLW  07
0AB6A:  ANDWF  xFD,W
0AB6C:  BCF    xFD.6
0AB6E:  ADDWF  FE9,F
0AB70:  MOVLW  00
0AB72:  ADDWFC FEA,F
0AB74:  MOVF   FE9,W
0AB76:  SUBLW  FC
0AB78:  BNZ   AB82
0AB7A:  MOVF   FEA,W
0AB7C:  SUBLW  08
0AB7E:  BNZ   AB82
0AB80:  BSF    xFD.6
0AB82:  MOVF   FEF,W
0AB84:  MOVWF  00
0AB86:  BNZ   AB98
0AB88:  BTFSC  xFD.6
0AB8A:  BRA    AB98
0AB8C:  BTFSC  xFD.4
0AB8E:  BRA    ABBC
0AB90:  BTFSC  xFD.3
0AB92:  BRA    AB98
0AB94:  MOVLW  20
0AB96:  BRA    AB9E
0AB98:  BSF    xFD.3
0AB9A:  BCF    xFD.4
0AB9C:  MOVLW  30
0AB9E:  ADDWF  00,F
0ABA0:  MOVFF  FEA,8F7
0ABA4:  MOVFF  FE9,8F6
0ABA8:  MOVFF  00,8FF
0ABAC:  MOVLB  0
0ABAE:  CALL   509E
0ABB2:  MOVFF  8F7,FEA
0ABB6:  MOVFF  8F6,FE9
0ABBA:  MOVLB  8
0ABBC:  MOVF   FEE,W
0ABBE:  BTFSS  xFD.6
0ABC0:  BRA    AB74
0ABC2:  MOVLB  0
0ABC4:  RETURN 0
*
0ADB0:  ADDWF  FE8,W
0ADB2:  CLRF   FF7
0ADB4:  RLCF   FF7,F
0ADB6:  ADDLW  D1
0ADB8:  MOVWF  FF6
0ADBA:  MOVLW  AD
0ADBC:  ADDWFC FF7,F
0ADBE:  MOVLW  00
0ADC0:  MOVWF  FF8
0ADC2:  MOVWF  FFB
0ADC4:  TBLRD*-
0ADC6:  MOVF   FF5,W
0ADC8:  MOVWF  FFA
0ADCA:  TBLRD*
0ADCC:  MOVF   FF5,W
0ADCE:  MOVWF  FF9
0ADD0:  DATA C0,AC
0ADD2:  DATA AC,AD
0ADD4:  DATA AC,AD
0ADD6:  DATA 20,AC
0ADD8:  DATA AC,AD
0ADDA:  DATA AC,AD
0ADDC:  DATA AC,AD
0ADDE:  DATA E4,AB
0ADE0:  DATA AC,AD
0ADE2:  DATA AC,AD
0ADE4:  DATA AC,AD
0ADE6:  DATA 36,AD
0ADE8:  DATA 5C,AC
0ADEA:  DATA AC,AD
0ADEC:  DATA FA,AC
0ADEE:  DATA 72,AD
*
0AE4A:  TBLRD*+
0AE4C:  MOVF   FF5,F
0AE4E:  BZ    AE72
0AE50:  MOVFF  FF6,885
0AE54:  MOVFF  FF7,886
0AE58:  MOVFF  FF8,887
0AE5C:  MOVF   FF5,W
0AE5E:  BTFSS  F9E.4
0AE60:  BRA    AE5E
0AE62:  MOVWF  FAD
0AE64:  MOVFF  885,FF6
0AE68:  MOVFF  886,FF7
0AE6C:  MOVFF  887,FF8
0AE70:  BRA    AE4A
0AE72:  RETURN 0
*
0C288:  MOVLB  9
0C28A:  MOVF   x13,W
0C28C:  BTFSC  FD8.2
0C28E:  BRA    C372
0C290:  MOVWF  00
0C292:  MOVF   x17,W
0C294:  BTFSC  FD8.2
0C296:  BRA    C372
0C298:  ADDWF  00,F
0C29A:  BNC   C2A4
0C29C:  MOVLW  81
0C29E:  ADDWF  00,F
0C2A0:  BC    C372
0C2A2:  BRA    C2AC
0C2A4:  MOVLW  7F
0C2A6:  SUBWF  00,F
0C2A8:  BNC   C372
0C2AA:  BZ    C372
0C2AC:  MOVFF  914,91B
0C2B0:  MOVF   x18,W
0C2B2:  XORWF  x1B,F
0C2B4:  BSF    x14.7
0C2B6:  BSF    x18.7
0C2B8:  MOVF   x16,W
0C2BA:  MULWF  x1A
0C2BC:  MOVFF  FF4,91D
0C2C0:  MOVF   x15,W
0C2C2:  MULWF  x19
0C2C4:  MOVFF  FF4,03
0C2C8:  MOVFF  FF3,91C
0C2CC:  MULWF  x1A
0C2CE:  MOVF   FF3,W
0C2D0:  ADDWF  x1D,F
0C2D2:  MOVF   FF4,W
0C2D4:  ADDWFC x1C,F
0C2D6:  MOVLW  00
0C2D8:  ADDWFC 03,F
0C2DA:  MOVF   x16,W
0C2DC:  MULWF  x19
0C2DE:  MOVF   FF3,W
0C2E0:  ADDWF  x1D,F
0C2E2:  MOVF   FF4,W
0C2E4:  ADDWFC x1C,F
0C2E6:  MOVLW  00
0C2E8:  CLRF   02
0C2EA:  ADDWFC 03,F
0C2EC:  ADDWFC 02,F
0C2EE:  MOVF   x14,W
0C2F0:  MULWF  x1A
0C2F2:  MOVF   FF3,W
0C2F4:  ADDWF  x1C,F
0C2F6:  MOVF   FF4,W
0C2F8:  ADDWFC 03,F
0C2FA:  MOVLW  00
0C2FC:  ADDWFC 02,F
0C2FE:  MOVF   x14,W
0C300:  MULWF  x19
0C302:  MOVF   FF3,W
0C304:  ADDWF  03,F
0C306:  MOVF   FF4,W
0C308:  ADDWFC 02,F
0C30A:  MOVLW  00
0C30C:  CLRF   01
0C30E:  ADDWFC 01,F
0C310:  MOVF   x16,W
0C312:  MULWF  x18
0C314:  MOVF   FF3,W
0C316:  ADDWF  x1C,F
0C318:  MOVF   FF4,W
0C31A:  ADDWFC 03,F
0C31C:  MOVLW  00
0C31E:  ADDWFC 02,F
0C320:  ADDWFC 01,F
0C322:  MOVF   x15,W
0C324:  MULWF  x18
0C326:  MOVF   FF3,W
0C328:  ADDWF  03,F
0C32A:  MOVF   FF4,W
0C32C:  ADDWFC 02,F
0C32E:  MOVLW  00
0C330:  ADDWFC 01,F
0C332:  MOVF   x14,W
0C334:  MULWF  x18
0C336:  MOVF   FF3,W
0C338:  ADDWF  02,F
0C33A:  MOVF   FF4,W
0C33C:  ADDWFC 01,F
0C33E:  INCF   00,F
0C340:  BTFSC  01.7
0C342:  BRA    C34E
0C344:  RLCF   x1C,F
0C346:  RLCF   03,F
0C348:  RLCF   02,F
0C34A:  RLCF   01,F
0C34C:  DECF   00,F
0C34E:  MOVLW  00
0C350:  BTFSS  x1C.7
0C352:  BRA    C368
0C354:  INCF   03,F
0C356:  ADDWFC 02,F
0C358:  ADDWFC 01,F
0C35A:  MOVF   01,W
0C35C:  BNZ   C368
0C35E:  MOVF   02,W
0C360:  BNZ   C368
0C362:  MOVF   03,W
0C364:  BNZ   C368
0C366:  INCF   00,F
0C368:  BTFSC  x1B.7
0C36A:  BSF    01.7
0C36C:  BTFSS  x1B.7
0C36E:  BCF    01.7
0C370:  BRA    C37A
0C372:  CLRF   00
0C374:  CLRF   01
0C376:  CLRF   02
0C378:  CLRF   03
0C37A:  MOVLB  0
0C37C:  RETURN 0
0C37E:  MOVLW  80
0C380:  BTFSS  FD8.1
0C382:  BRA    C388
0C384:  MOVLB  9
0C386:  XORWF  x1C,F
0C388:  MOVLB  9
0C38A:  CLRF   x21
0C38C:  CLRF   x22
0C38E:  MOVFF  918,920
0C392:  MOVF   x1C,W
0C394:  XORWF  x20,F
0C396:  MOVF   x17,W
0C398:  BTFSC  FD8.2
0C39A:  BRA    C55A
0C39C:  MOVWF  x1F
0C39E:  MOVWF  00
0C3A0:  MOVF   x1B,W
0C3A2:  BTFSC  FD8.2
0C3A4:  BRA    C56C
0C3A6:  SUBWF  x1F,F
0C3A8:  BTFSC  FD8.2
0C3AA:  BRA    C4B2
0C3AC:  BNC   C42A
0C3AE:  MOVFF  91C,925
0C3B2:  BSF    x25.7
0C3B4:  MOVFF  91D,924
0C3B8:  MOVFF  91E,923
0C3BC:  CLRF   x22
0C3BE:  BCF    FD8.0
0C3C0:  RRCF   x25,F
0C3C2:  RRCF   x24,F
0C3C4:  RRCF   x23,F
0C3C6:  RRCF   x22,F
0C3C8:  DECFSZ x1F,F
0C3CA:  BRA    C3BC
0C3CC:  BTFSS  x20.7
0C3CE:  BRA    C3D6
0C3D0:  BSF    x21.0
0C3D2:  BRA    C594
0C3D4:  BCF    x21.0
0C3D6:  BCF    x1F.0
0C3D8:  BSF    x21.4
0C3DA:  MOVLW  09
0C3DC:  MOVWF  FEA
0C3DE:  MOVLW  1A
0C3E0:  MOVWF  FE9
0C3E2:  BRA    C5BA
0C3E4:  BCF    x21.4
0C3E6:  BTFSC  x20.7
0C3E8:  BRA    C3FE
0C3EA:  BTFSS  x1F.0
0C3EC:  BRA    C414
0C3EE:  RRCF   x25,F
0C3F0:  RRCF   x24,F
0C3F2:  RRCF   x23,F
0C3F4:  RRCF   x22,F
0C3F6:  INCF   00,F
0C3F8:  BTFSC  FD8.2
0C3FA:  BRA    C58A
0C3FC:  BRA    C414
0C3FE:  BTFSC  x25.7
0C400:  BRA    C41A
0C402:  BCF    FD8.0
0C404:  RLCF   x22,F
0C406:  RLCF   x23,F
0C408:  RLCF   x24,F
0C40A:  RLCF   x25,F
0C40C:  DECF   00,F
0C40E:  BTFSC  FD8.2
0C410:  BRA    C58A
0C412:  BRA    C3FE
0C414:  BSF    x21.6
0C416:  BRA    C4F2
0C418:  BCF    x21.6
0C41A:  MOVFF  918,920
0C41E:  BTFSS  x18.7
0C420:  BRA    C426
0C422:  BSF    x25.7
0C424:  BRA    C57C
0C426:  BCF    x25.7
0C428:  BRA    C57C
0C42A:  MOVFF  91B,91F
0C42E:  MOVFF  91B,00
0C432:  MOVF   x17,W
0C434:  SUBWF  x1F,F
0C436:  MOVFF  918,925
0C43A:  BSF    x25.7
0C43C:  MOVFF  919,924
0C440:  MOVFF  91A,923
0C444:  CLRF   x22
0C446:  BCF    FD8.0
0C448:  RRCF   x25,F
0C44A:  RRCF   x24,F
0C44C:  RRCF   x23,F
0C44E:  RRCF   x22,F
0C450:  DECFSZ x1F,F
0C452:  BRA    C444
0C454:  BTFSS  x20.7
0C456:  BRA    C45E
0C458:  BSF    x21.1
0C45A:  BRA    C594
0C45C:  BCF    x21.1
0C45E:  BCF    x1F.0
0C460:  BSF    x21.5
0C462:  MOVLW  09
0C464:  MOVWF  FEA
0C466:  MOVLW  1E
0C468:  MOVWF  FE9
0C46A:  BRA    C5BA
0C46C:  BCF    x21.5
0C46E:  BTFSC  x20.7
0C470:  BRA    C486
0C472:  BTFSS  x1F.0
0C474:  BRA    C49C
0C476:  RRCF   x25,F
0C478:  RRCF   x24,F
0C47A:  RRCF   x23,F
0C47C:  RRCF   x22,F
0C47E:  INCF   00,F
0C480:  BTFSC  FD8.2
0C482:  BRA    C58A
0C484:  BRA    C49C
0C486:  BTFSC  x25.7
0C488:  BRA    C4A2
0C48A:  BCF    FD8.0
0C48C:  RLCF   x22,F
0C48E:  RLCF   x23,F
0C490:  RLCF   x24,F
0C492:  RLCF   x25,F
0C494:  DECF   00,F
0C496:  BTFSC  FD8.2
0C498:  BRA    C58A
0C49A:  BRA    C486
0C49C:  BSF    x21.7
0C49E:  BRA    C4F2
0C4A0:  BCF    x21.7
0C4A2:  MOVFF  91C,920
0C4A6:  BTFSS  x1C.7
0C4A8:  BRA    C4AE
0C4AA:  BSF    x25.7
0C4AC:  BRA    C57C
0C4AE:  BCF    x25.7
0C4B0:  BRA    C57C
0C4B2:  MOVFF  91C,925
0C4B6:  BSF    x25.7
0C4B8:  MOVFF  91D,924
0C4BC:  MOVFF  91E,923
0C4C0:  BTFSS  x20.7
0C4C2:  BRA    C4CC
0C4C4:  BCF    x25.7
0C4C6:  BSF    x21.2
0C4C8:  BRA    C594
0C4CA:  BCF    x21.2
0C4CC:  CLRF   x22
0C4CE:  BCF    x1F.0
0C4D0:  MOVLW  09
0C4D2:  MOVWF  FEA
0C4D4:  MOVLW  1A
0C4D6:  MOVWF  FE9
0C4D8:  BRA    C5BA
0C4DA:  BTFSC  x20.7
0C4DC:  BRA    C516
0C4DE:  MOVFF  918,920
0C4E2:  BTFSS  x1F.0
0C4E4:  BRA    C4F2
0C4E6:  RRCF   x25,F
0C4E8:  RRCF   x24,F
0C4EA:  RRCF   x23,F
0C4EC:  RRCF   x22,F
0C4EE:  INCF   00,F
0C4F0:  BZ    C58A
0C4F2:  BTFSS  x22.7
0C4F4:  BRA    C50C
0C4F6:  INCF   x23,F
0C4F8:  BNZ   C50C
0C4FA:  INCF   x24,F
0C4FC:  BNZ   C50C
0C4FE:  INCF   x25,F
0C500:  BNZ   C50C
0C502:  RRCF   x25,F
0C504:  RRCF   x24,F
0C506:  RRCF   x23,F
0C508:  INCF   00,F
0C50A:  BZ    C58A
0C50C:  BTFSC  x21.6
0C50E:  BRA    C418
0C510:  BTFSC  x21.7
0C512:  BRA    C4A0
0C514:  BRA    C54E
0C516:  MOVLW  80
0C518:  XORWF  x25,F
0C51A:  BTFSS  x25.7
0C51C:  BRA    C526
0C51E:  BRA    C594
0C520:  MOVFF  91C,920
0C524:  BRA    C53A
0C526:  MOVFF  918,920
0C52A:  MOVF   x25,F
0C52C:  BNZ   C53A
0C52E:  MOVF   x24,F
0C530:  BNZ   C53A
0C532:  MOVF   x23,F
0C534:  BNZ   C53A
0C536:  CLRF   00
0C538:  BRA    C57C
0C53A:  BTFSC  x25.7
0C53C:  BRA    C54E
0C53E:  BCF    FD8.0
0C540:  RLCF   x22,F
0C542:  RLCF   x23,F
0C544:  RLCF   x24,F
0C546:  RLCF   x25,F
0C548:  DECFSZ 00,F
0C54A:  BRA    C53A
0C54C:  BRA    C58A
0C54E:  BTFSS  x20.7
0C550:  BRA    C556
0C552:  BSF    x25.7
0C554:  BRA    C57C
0C556:  BCF    x25.7
0C558:  BRA    C57C
0C55A:  MOVFF  91B,00
0C55E:  MOVFF  91C,925
0C562:  MOVFF  91D,924
0C566:  MOVFF  91E,923
0C56A:  BRA    C57C
0C56C:  MOVFF  917,00
0C570:  MOVFF  918,925
0C574:  MOVFF  919,924
0C578:  MOVFF  91A,923
0C57C:  MOVFF  925,01
0C580:  MOVFF  924,02
0C584:  MOVFF  923,03
0C588:  BRA    C5F2
0C58A:  CLRF   00
0C58C:  CLRF   01
0C58E:  CLRF   02
0C590:  CLRF   03
0C592:  BRA    C5F2
0C594:  CLRF   x22
0C596:  COMF   x23,F
0C598:  COMF   x24,F
0C59A:  COMF   x25,F
0C59C:  COMF   x22,F
0C59E:  INCF   x22,F
0C5A0:  BNZ   C5AC
0C5A2:  INCF   x23,F
0C5A4:  BNZ   C5AC
0C5A6:  INCF   x24,F
0C5A8:  BNZ   C5AC
0C5AA:  INCF   x25,F
0C5AC:  BTFSC  x21.0
0C5AE:  BRA    C3D4
0C5B0:  BTFSC  x21.1
0C5B2:  BRA    C45C
0C5B4:  BTFSC  x21.2
0C5B6:  BRA    C4CA
0C5B8:  BRA    C520
0C5BA:  MOVF   FEF,W
0C5BC:  ADDWF  x23,F
0C5BE:  BNC   C5CA
0C5C0:  INCF   x24,F
0C5C2:  BNZ   C5CA
0C5C4:  INCF   x25,F
0C5C6:  BTFSC  FD8.2
0C5C8:  BSF    x1F.0
0C5CA:  MOVF   FED,F
0C5CC:  MOVF   FEF,W
0C5CE:  ADDWF  x24,F
0C5D0:  BNC   C5D8
0C5D2:  INCF   x25,F
0C5D4:  BTFSC  FD8.2
0C5D6:  BSF    x1F.0
0C5D8:  MOVF   FED,F
0C5DA:  MOVF   FEF,W
0C5DC:  BTFSC  FEF.7
0C5DE:  BRA    C5E2
0C5E0:  XORLW  80
0C5E2:  ADDWF  x25,F
0C5E4:  BTFSC  FD8.0
0C5E6:  BSF    x1F.0
0C5E8:  BTFSC  x21.4
0C5EA:  BRA    C3E4
0C5EC:  BTFSC  x21.5
0C5EE:  BRA    C46C
0C5F0:  BRA    C4DA
0C5F2:  MOVLB  0
0C5F4:  RETURN 0
0C5F6:  MOVLB  8
0C5F8:  MOVF   xDC,W
0C5FA:  SUBLW  B6
0C5FC:  MOVWF  xDC
0C5FE:  CLRF   03
0C600:  MOVFF  8DD,8E0
0C604:  BSF    xDD.7
0C606:  BCF    FD8.0
0C608:  RRCF   xDD,F
0C60A:  RRCF   xDE,F
0C60C:  RRCF   xDF,F
0C60E:  RRCF   03,F
0C610:  RRCF   02,F
0C612:  RRCF   01,F
0C614:  RRCF   00,F
0C616:  DECFSZ xDC,F
0C618:  BRA    C606
0C61A:  BTFSS  xE0.7
0C61C:  BRA    C634
0C61E:  COMF   00,F
0C620:  COMF   01,F
0C622:  COMF   02,F
0C624:  COMF   03,F
0C626:  INCF   00,F
0C628:  BTFSC  FD8.2
0C62A:  INCF   01,F
0C62C:  BTFSC  FD8.2
0C62E:  INCF   02,F
0C630:  BTFSC  FD8.2
0C632:  INCF   03,F
0C634:  MOVLB  0
0C636:  RETURN 0
0C638:  MOVF   FE9,W
0C63A:  MOVLB  8
0C63C:  MOVWF  x8A
0C63E:  MOVF   x89,W
0C640:  MOVWF  x8C
0C642:  BZ    C67C
0C644:  MOVFF  888,916
0C648:  MOVFF  887,915
0C64C:  MOVFF  886,914
0C650:  MOVFF  885,913
0C654:  MOVLB  9
0C656:  CLRF   x1A
0C658:  CLRF   x19
0C65A:  MOVLW  20
0C65C:  MOVWF  x18
0C65E:  MOVLW  82
0C660:  MOVWF  x17
0C662:  MOVLB  0
0C664:  RCALL  C288
0C666:  MOVFF  03,888
0C66A:  MOVFF  02,887
0C66E:  MOVFF  01,886
0C672:  MOVFF  00,885
0C676:  MOVLB  8
0C678:  DECFSZ x8C,F
0C67A:  BRA    C644
0C67C:  MOVLW  7E
0C67E:  MOVWF  00
0C680:  CLRF   01
0C682:  BTFSC  x86.7
0C684:  BSF    01.7
0C686:  CLRF   02
0C688:  CLRF   03
0C68A:  BCF    FD8.1
0C68C:  MOVFF  888,91A
0C690:  MOVFF  887,919
0C694:  MOVFF  886,918
0C698:  MOVFF  885,917
0C69C:  MOVFF  03,91E
0C6A0:  MOVFF  02,91D
0C6A4:  MOVFF  01,91C
0C6A8:  MOVFF  FE8,91B
0C6AC:  MOVLB  0
0C6AE:  RCALL  C37E
0C6B0:  MOVFF  03,888
0C6B4:  MOVFF  02,887
0C6B8:  MOVFF  01,886
0C6BC:  MOVFF  00,885
0C6C0:  MOVFF  888,8DF
0C6C4:  MOVFF  887,8DE
0C6C8:  MOVFF  886,8DD
0C6CC:  MOVFF  885,8DC
0C6D0:  RCALL  C5F6
0C6D2:  MOVFF  03,888
0C6D6:  MOVFF  02,887
0C6DA:  MOVFF  01,886
0C6DE:  MOVFF  00,885
0C6E2:  MOVLB  8
0C6E4:  BTFSS  x88.7
0C6E6:  BRA    C702
0C6E8:  DECF   x8A,F
0C6EA:  BSF    x8A.5
0C6EC:  COMF   x85,F
0C6EE:  COMF   x86,F
0C6F0:  COMF   x87,F
0C6F2:  COMF   x88,F
0C6F4:  INCF   x85,F
0C6F6:  BTFSC  FD8.2
0C6F8:  INCF   x86,F
0C6FA:  BTFSC  FD8.2
0C6FC:  INCF   x87,F
0C6FE:  BTFSC  FD8.2
0C700:  INCF   x88,F
0C702:  MOVLW  3B
0C704:  MOVWF  x91
0C706:  MOVLW  9A
0C708:  MOVWF  x90
0C70A:  MOVLW  CA
0C70C:  MOVWF  x8F
0C70E:  CLRF   x8E
0C710:  MOVLW  0A
0C712:  MOVWF  x8C
0C714:  MOVF   x89,W
0C716:  BTFSC  FD8.2
0C718:  INCF   x8A,F
0C71A:  BSF    FD8.1
0C71C:  MOVLW  08
0C71E:  MOVWF  FEA
0C720:  MOVLW  85
0C722:  MOVWF  FE9
0C724:  CLRF   1B
0C726:  BTFSC  FF2.7
0C728:  BSF    1B.7
0C72A:  BCF    FF2.7
0C72C:  MOVFF  888,A4F
0C730:  MOVFF  887,A4E
0C734:  MOVFF  886,A4D
0C738:  MOVFF  885,A4C
0C73C:  MOVFF  891,A53
0C740:  MOVFF  890,A52
0C744:  MOVFF  88F,A51
0C748:  MOVFF  88E,A50
0C74C:  MOVLB  0
0C74E:  CALL   1056
0C752:  BTFSC  1B.7
0C754:  BSF    FF2.7
0C756:  MOVF   01,W
0C758:  MOVF   00,F
0C75A:  BNZ   C782
0C75C:  MOVLB  8
0C75E:  INCF   x89,W
0C760:  SUBWF  x8C,W
0C762:  BTFSS  FD8.2
0C764:  BRA    C76A
0C766:  MOVLB  0
0C768:  BRA    C782
0C76A:  MOVF   x8A,W
0C76C:  BZ    C788
0C76E:  ANDLW  0F
0C770:  SUBWF  x8C,W
0C772:  BZ    C776
0C774:  BC    C7EE
0C776:  BTFSC  x8A.7
0C778:  BRA    C7EE
0C77A:  BTFSC  x8A.6
0C77C:  BRA    C788
0C77E:  MOVLW  20
0C780:  BRA    C7E4
0C782:  MOVLW  20
0C784:  MOVLB  8
0C786:  ANDWF  x8A,F
0C788:  BTFSS  x8A.5
0C78A:  BRA    C7A6
0C78C:  BCF    x8A.5
0C78E:  MOVF   x89,W
0C790:  BTFSS  FD8.2
0C792:  DECF   x8A,F
0C794:  MOVF   00,W
0C796:  MOVWF  x8A
0C798:  MOVLW  2D
0C79A:  BTFSS  F9E.4
0C79C:  BRA    C79A
0C79E:  MOVWF  FAD
0C7A0:  MOVF   x8A,W
0C7A2:  MOVWF  00
0C7A4:  CLRF   x8A
0C7A6:  MOVF   x89,W
0C7A8:  SUBWF  x8C,W
0C7AA:  BNZ   C7C2
0C7AC:  MOVF   00,W
0C7AE:  MOVWF  x8A
0C7B0:  MOVLW  2E
0C7B2:  BTFSS  F9E.4
0C7B4:  BRA    C7B2
0C7B6:  MOVWF  FAD
0C7B8:  MOVF   x8A,W
0C7BA:  MOVWF  00
0C7BC:  MOVLW  20
0C7BE:  ANDWF  x8A,F
0C7C0:  MOVLW  00
0C7C2:  MOVLW  30
0C7C4:  BTFSS  x8A.5
0C7C6:  BRA    C7E4
0C7C8:  BCF    x8A.5
0C7CA:  MOVF   x89,W
0C7CC:  BTFSS  FD8.2
0C7CE:  DECF   x8A,F
0C7D0:  MOVF   00,W
0C7D2:  MOVWF  x8A
0C7D4:  MOVLW  2D
0C7D6:  BTFSS  F9E.4
0C7D8:  BRA    C7D6
0C7DA:  MOVWF  FAD
0C7DC:  MOVF   x8A,W
0C7DE:  MOVWF  00
0C7E0:  CLRF   x8A
0C7E2:  MOVLW  30
0C7E4:  ADDWF  00,F
0C7E6:  MOVF   00,W
0C7E8:  BTFSS  F9E.4
0C7EA:  BRA    C7E8
0C7EC:  MOVWF  FAD
0C7EE:  BCF    FD8.1
0C7F0:  CLRF   1B
0C7F2:  BTFSC  FF2.7
0C7F4:  BSF    1B.7
0C7F6:  BCF    FF2.7
0C7F8:  MOVFF  891,A4F
0C7FC:  MOVFF  890,A4E
0C800:  MOVFF  88F,A4D
0C804:  MOVFF  88E,A4C
0C808:  MOVLB  A
0C80A:  CLRF   x53
0C80C:  CLRF   x52
0C80E:  CLRF   x51
0C810:  MOVLW  0A
0C812:  MOVWF  x50
0C814:  MOVLB  0
0C816:  CALL   1056
0C81A:  BTFSC  1B.7
0C81C:  BSF    FF2.7
0C81E:  MOVFF  03,891
0C822:  MOVFF  02,890
0C826:  MOVFF  01,88F
0C82A:  MOVFF  00,88E
0C82E:  MOVLB  8
0C830:  DECFSZ x8C,F
0C832:  BRA    C71A
0C834:  MOVLB  0
0C836:  RETURN 0
*
0C8BA:  MOVLW  8E
0C8BC:  MOVWF  00
0C8BE:  MOVFF  918,01
0C8C2:  MOVFF  917,02
0C8C6:  CLRF   03
0C8C8:  MOVF   01,F
0C8CA:  BNZ   C8DE
0C8CC:  MOVFF  02,01
0C8D0:  CLRF   02
0C8D2:  MOVLW  08
0C8D4:  SUBWF  00,F
0C8D6:  MOVF   01,F
0C8D8:  BNZ   C8DE
0C8DA:  CLRF   00
0C8DC:  BRA    C8EE
0C8DE:  BCF    FD8.0
0C8E0:  BTFSC  01.7
0C8E2:  BRA    C8EC
0C8E4:  RLCF   02,F
0C8E6:  RLCF   01,F
0C8E8:  DECF   00,F
0C8EA:  BRA    C8DE
0C8EC:  BCF    01.7
0C8EE:  RETURN 0
0C8F0:  MOVLB  8
0C8F2:  MOVF   xFB,W
0C8F4:  BTFSC  FD8.2
0C8F6:  BRA    CA60
0C8F8:  MOVLB  9
0C8FA:  MOVWF  x07
0C8FC:  MOVLB  8
0C8FE:  MOVF   xFF,W
0C900:  BTFSC  FD8.2
0C902:  BRA    CA60
0C904:  MOVLB  9
0C906:  SUBWF  x07,F
0C908:  BNC   C918
0C90A:  MOVLW  7F
0C90C:  ADDWF  x07,F
0C90E:  BTFSS  FD8.0
0C910:  BRA    C916
0C912:  MOVLB  8
0C914:  BRA    CA60
0C916:  BRA    C92C
0C918:  MOVLW  81
0C91A:  SUBWF  x07,F
0C91C:  BTFSC  FD8.0
0C91E:  BRA    C924
0C920:  MOVLB  8
0C922:  BRA    CA60
0C924:  BTFSS  FD8.2
0C926:  BRA    C92C
0C928:  MOVLB  8
0C92A:  BRA    CA60
0C92C:  MOVFF  907,00
0C930:  CLRF   01
0C932:  CLRF   02
0C934:  CLRF   03
0C936:  CLRF   x06
0C938:  MOVFF  8FC,905
0C93C:  BSF    x05.7
0C93E:  MOVFF  8FD,904
0C942:  MOVFF  8FE,903
0C946:  MOVLW  19
0C948:  MOVWF  x07
0C94A:  MOVF   x02,W
0C94C:  SUBWF  x03,F
0C94E:  BC    C96A
0C950:  MOVLW  01
0C952:  SUBWF  x04,F
0C954:  BC    C96A
0C956:  SUBWF  x05,F
0C958:  BC    C96A
0C95A:  SUBWF  x06,F
0C95C:  BC    C96A
0C95E:  INCF   x06,F
0C960:  INCF   x05,F
0C962:  INCF   x04,F
0C964:  MOVF   x02,W
0C966:  ADDWF  x03,F
0C968:  BRA    C9BA
0C96A:  MOVF   x01,W
0C96C:  SUBWF  x04,F
0C96E:  BC    C994
0C970:  MOVLW  01
0C972:  SUBWF  x05,F
0C974:  BC    C994
0C976:  SUBWF  x06,F
0C978:  BC    C994
0C97A:  INCF   x06,F
0C97C:  INCF   x05,F
0C97E:  MOVF   x01,W
0C980:  ADDWF  x04,F
0C982:  MOVF   x02,W
0C984:  ADDWF  x03,F
0C986:  BNC   C9BA
0C988:  INCF   x04,F
0C98A:  BNZ   C9BA
0C98C:  INCF   x05,F
0C98E:  BNZ   C9BA
0C990:  INCF   x06,F
0C992:  BRA    C9BA
0C994:  MOVF   x00,W
0C996:  IORLW  80
0C998:  SUBWF  x05,F
0C99A:  BC    C9B8
0C99C:  MOVLW  01
0C99E:  SUBWF  x06,F
0C9A0:  BC    C9B8
0C9A2:  INCF   x06,F
0C9A4:  MOVF   x00,W
0C9A6:  IORLW  80
0C9A8:  ADDWF  x05,F
0C9AA:  MOVF   x01,W
0C9AC:  ADDWF  x04,F
0C9AE:  BNC   C982
0C9B0:  INCF   x05,F
0C9B2:  BNZ   C982
0C9B4:  INCF   x06,F
0C9B6:  BRA    C982
0C9B8:  BSF    03.0
0C9BA:  DECFSZ x07,F
0C9BC:  BRA    C9C0
0C9BE:  BRA    C9D6
0C9C0:  BCF    FD8.0
0C9C2:  RLCF   x03,F
0C9C4:  RLCF   x04,F
0C9C6:  RLCF   x05,F
0C9C8:  RLCF   x06,F
0C9CA:  BCF    FD8.0
0C9CC:  RLCF   03,F
0C9CE:  RLCF   02,F
0C9D0:  RLCF   01,F
0C9D2:  RLCF   x08,F
0C9D4:  BRA    C94A
0C9D6:  BTFSS  x08.0
0C9D8:  BRA    C9E6
0C9DA:  BCF    FD8.0
0C9DC:  RRCF   01,F
0C9DE:  RRCF   02,F
0C9E0:  RRCF   03,F
0C9E2:  RRCF   x08,F
0C9E4:  BRA    C9EE
0C9E6:  DECFSZ 00,F
0C9E8:  BRA    C9EE
0C9EA:  MOVLB  8
0C9EC:  BRA    CA60
0C9EE:  BTFSC  x08.7
0C9F0:  BRA    CA2E
0C9F2:  BCF    FD8.0
0C9F4:  RLCF   x03,F
0C9F6:  RLCF   x04,F
0C9F8:  RLCF   x05,F
0C9FA:  RLCF   x06,F
0C9FC:  MOVF   x02,W
0C9FE:  SUBWF  x03,F
0CA00:  BC    CA10
0CA02:  MOVLW  01
0CA04:  SUBWF  x04,F
0CA06:  BC    CA10
0CA08:  SUBWF  x05,F
0CA0A:  BC    CA10
0CA0C:  SUBWF  x06,F
0CA0E:  BNC   CA4A
0CA10:  MOVF   x01,W
0CA12:  SUBWF  x04,F
0CA14:  BC    CA20
0CA16:  MOVLW  01
0CA18:  SUBWF  x05,F
0CA1A:  BC    CA20
0CA1C:  SUBWF  x06,F
0CA1E:  BNC   CA4A
0CA20:  MOVF   x00,W
0CA22:  IORLW  80
0CA24:  SUBWF  x05,F
0CA26:  BC    CA2E
0CA28:  MOVLW  01
0CA2A:  SUBWF  x06,F
0CA2C:  BNC   CA4A
0CA2E:  INCF   03,F
0CA30:  BNZ   CA4A
0CA32:  INCF   02,F
0CA34:  BNZ   CA4A
0CA36:  INCF   01,F
0CA38:  BNZ   CA4A
0CA3A:  INCF   00,F
0CA3C:  BTFSS  FD8.2
0CA3E:  BRA    CA44
0CA40:  MOVLB  8
0CA42:  BRA    CA60
0CA44:  RRCF   01,F
0CA46:  RRCF   02,F
0CA48:  RRCF   03,F
0CA4A:  MOVFF  8FC,907
0CA4E:  MOVF   x00,W
0CA50:  XORWF  x07,F
0CA52:  BTFSS  x07.7
0CA54:  BRA    CA5A
0CA56:  BSF    01.7
0CA58:  BRA    CA6A
0CA5A:  BCF    01.7
0CA5C:  BRA    CA6A
0CA5E:  MOVLB  8
0CA60:  CLRF   00
0CA62:  CLRF   01
0CA64:  CLRF   02
0CA66:  CLRF   03
0CA68:  MOVLB  9
0CA6A:  MOVLB  0
0CA6C:  RETURN 0
*
0D500:  MOVFF  FEA,8C9
0D504:  MOVFF  FE9,8C8
0D508:  MOVLB  8
0D50A:  BTFSS  xC2.7
0D50C:  BRA    D51E
0D50E:  BSF    xC8.7
0D510:  BTFSS  xC8.4
0D512:  INCF   xC8,F
0D514:  COMF   xC1,F
0D516:  COMF   xC2,F
0D518:  INCF   xC1,F
0D51A:  BTFSC  FD8.2
0D51C:  INCF   xC2,F
0D51E:  SWAPF  xC2,W
0D520:  IORLW  F0
0D522:  MOVWF  xC4
0D524:  ADDWF  xC4,F
0D526:  ADDLW  E2
0D528:  MOVWF  xC5
0D52A:  ADDLW  32
0D52C:  MOVWF  xC7
0D52E:  MOVF   xC2,W
0D530:  ANDLW  0F
0D532:  ADDWF  xC5,F
0D534:  ADDWF  xC5,F
0D536:  ADDWF  xC7,F
0D538:  ADDLW  E9
0D53A:  MOVWF  xC6
0D53C:  ADDWF  xC6,F
0D53E:  ADDWF  xC6,F
0D540:  SWAPF  xC1,W
0D542:  ANDLW  0F
0D544:  ADDWF  xC6,F
0D546:  ADDWF  xC7,F
0D548:  RLCF   xC6,F
0D54A:  RLCF   xC7,F
0D54C:  COMF   xC7,F
0D54E:  RLCF   xC7,F
0D550:  MOVF   xC1,W
0D552:  ANDLW  0F
0D554:  ADDWF  xC7,F
0D556:  RLCF   xC4,F
0D558:  MOVLW  07
0D55A:  MOVWF  xC3
0D55C:  MOVLW  0A
0D55E:  DECF   xC6,F
0D560:  ADDWF  xC7,F
0D562:  BNC   D55E
0D564:  DECF   xC5,F
0D566:  ADDWF  xC6,F
0D568:  BNC   D564
0D56A:  DECF   xC4,F
0D56C:  ADDWF  xC5,F
0D56E:  BNC   D56A
0D570:  DECF   xC3,F
0D572:  ADDWF  xC4,F
0D574:  BNC   D570
0D576:  MOVLW  08
0D578:  MOVWF  FEA
0D57A:  MOVLW  C3
0D57C:  MOVWF  FE9
0D57E:  MOVLW  07
0D580:  ANDWF  xC8,W
0D582:  BCF    xC8.6
0D584:  MOVF   FED,F
0D586:  ANDWF  xC8,W
0D588:  BNZ   D598
0D58A:  BTFSC  xC8.4
0D58C:  MOVF   FEE,F
0D58E:  BTFSC  xC8.4
0D590:  BRA    D598
0D592:  MOVLW  20
0D594:  MOVWF  00
0D596:  BRA    D5DA
0D598:  ADDWF  FE9,F
0D59A:  MOVLW  00
0D59C:  ADDWFC FEA,F
0D59E:  MOVF   FE9,W
0D5A0:  SUBLW  C7
0D5A2:  BNZ   D5AC
0D5A4:  MOVF   FEA,W
0D5A6:  SUBLW  08
0D5A8:  BNZ   D5AC
0D5AA:  BSF    xC8.6
0D5AC:  MOVF   FEF,W
0D5AE:  MOVWF  00
0D5B0:  BNZ   D5C2
0D5B2:  BTFSC  xC8.6
0D5B4:  BRA    D5C2
0D5B6:  BTFSC  xC8.4
0D5B8:  BRA    D5F6
0D5BA:  BTFSC  xC8.3
0D5BC:  BRA    D5C2
0D5BE:  MOVLW  20
0D5C0:  BRA    D5D8
0D5C2:  BTFSS  xC8.7
0D5C4:  BRA    D5D2
0D5C6:  MOVLW  2D
0D5C8:  MOVWF  00
0D5CA:  MOVF   FED,W
0D5CC:  BCF    xC8.6
0D5CE:  BCF    xC8.7
0D5D0:  BRA    D5DA
0D5D2:  BSF    xC8.3
0D5D4:  BCF    xC8.4
0D5D6:  MOVLW  30
0D5D8:  ADDWF  00,F
0D5DA:  MOVFF  FEA,8C2
0D5DE:  MOVFF  FE9,8C1
0D5E2:  MOVFF  00,8FF
0D5E6:  MOVLB  0
0D5E8:  CALL   509E
0D5EC:  MOVFF  8C2,FEA
0D5F0:  MOVFF  8C1,FE9
0D5F4:  MOVLB  8
0D5F6:  MOVF   FEE,W
0D5F8:  BTFSS  xC8.6
0D5FA:  BRA    D59E
0D5FC:  MOVLB  0
0D5FE:  GOTO   D722 (RETURN)
*
0D9A6:  ADDWF  FE8,W
0D9A8:  CLRF   FF7
0D9AA:  RLCF   FF7,F
0D9AC:  ADDLW  C7
0D9AE:  MOVWF  FF6
0D9B0:  MOVLW  D9
0D9B2:  ADDWFC FF7,F
0D9B4:  MOVLW  00
0D9B6:  MOVWF  FF8
0D9B8:  MOVWF  FFB
0D9BA:  TBLRD*-
0D9BC:  MOVF   FF5,W
0D9BE:  MOVWF  FFA
0D9C0:  TBLRD*
0D9C2:  MOVF   FF5,W
0D9C4:  MOVWF  FF9
0D9C6:  DATA D8,D8
0D9C8:  DATA 00,D9
0D9CA:  DATA 20,D9
0D9CC:  DATA 40,D9
0D9CE:  DATA 60,D9
0D9D0:  DATA 80,D9
*
0DA50:  TBLRD*+
0DA52:  MOVFF  FF6,8B9
0DA56:  MOVFF  FF7,8BA
0DA5A:  MOVFF  FF8,8BB
0DA5E:  MOVF   FF5,W
0DA60:  BTFSS  FA4.4
0DA62:  BRA    DA60
0DA64:  MOVLB  F
0DA66:  MOVWF  x1C
0DA68:  MOVFF  8B9,FF6
0DA6C:  MOVFF  8BA,FF7
0DA70:  MOVFF  8BB,FF8
0DA74:  MOVLB  8
0DA76:  DECFSZ xB8,F
0DA78:  BRA    DA7C
0DA7A:  BRA    DA80
0DA7C:  MOVLB  0
0DA7E:  BRA    DA50
0DA80:  MOVLB  0
0DA82:  RETURN 0
0DA84:  MOVF   01,W
0DA86:  CLRF   1B
0DA88:  BTFSC  FF2.7
0DA8A:  BSF    1B.7
0DA8C:  BCF    FF2.7
0DA8E:  MOVFF  8F3,A42
0DA92:  MOVLW  64
0DA94:  MOVLB  A
0DA96:  MOVWF  x43
0DA98:  MOVLB  0
0DA9A:  CALL   0F7A
0DA9E:  BTFSC  1B.7
0DAA0:  BSF    FF2.7
0DAA2:  MOVFF  00,8F3
0DAA6:  MOVF   01,W
0DAA8:  MOVLW  30
0DAAA:  BNZ   DABC
0DAAC:  MOVLB  8
0DAAE:  BTFSS  xF4.1
0DAB0:  BRA    DAD2
0DAB2:  BTFSC  xF4.3
0DAB4:  BRA    DAD2
0DAB6:  BTFSC  xF4.4
0DAB8:  MOVLW  20
0DABA:  BRA    DAC4
0DABC:  MOVLB  8
0DABE:  BCF    xF4.3
0DAC0:  BCF    xF4.4
0DAC2:  BSF    xF4.0
0DAC4:  ADDWF  01,F
0DAC6:  MOVF   01,W
0DAC8:  BTFSS  FA4.4
0DACA:  BRA    DAC8
0DACC:  MOVLB  F
0DACE:  MOVWF  x1C
0DAD0:  MOVLB  8
0DAD2:  CLRF   1B
0DAD4:  BTFSC  FF2.7
0DAD6:  BSF    1B.7
0DAD8:  BCF    FF2.7
0DADA:  MOVFF  8F3,A42
0DADE:  MOVLW  0A
0DAE0:  MOVLB  A
0DAE2:  MOVWF  x43
0DAE4:  MOVLB  0
0DAE6:  CALL   0F7A
0DAEA:  BTFSC  1B.7
0DAEC:  BSF    FF2.7
0DAEE:  MOVFF  00,8F3
0DAF2:  MOVF   01,W
0DAF4:  MOVLW  30
0DAF6:  BNZ   DB08
0DAF8:  MOVLB  8
0DAFA:  BTFSC  xF4.3
0DAFC:  BRA    DB16
0DAFE:  BTFSS  xF4.0
0DB00:  BRA    DB16
0DB02:  BTFSC  xF4.4
0DB04:  MOVLW  20
0DB06:  MOVLB  0
0DB08:  ADDWF  01,F
0DB0A:  MOVF   01,W
0DB0C:  BTFSS  FA4.4
0DB0E:  BRA    DB0C
0DB10:  MOVLB  F
0DB12:  MOVWF  x1C
0DB14:  MOVLB  8
0DB16:  MOVLW  30
0DB18:  ADDWF  xF3,F
0DB1A:  MOVF   xF3,W
0DB1C:  BTFSS  FA4.4
0DB1E:  BRA    DB1C
0DB20:  MOVLB  F
0DB22:  MOVWF  x1C
0DB24:  MOVLB  0
0DB26:  RETURN 0
*
0DB4A:  TBLRD*+
0DB4C:  MOVF   FF5,F
0DB4E:  BZ    DB76
0DB50:  MOVFF  FF6,8B7
0DB54:  MOVFF  FF7,8B8
0DB58:  MOVFF  FF8,8B9
0DB5C:  MOVF   FF5,W
0DB5E:  BTFSS  FA4.4
0DB60:  BRA    DB5E
0DB62:  MOVLB  F
0DB64:  MOVWF  x1C
0DB66:  MOVFF  8B7,FF6
0DB6A:  MOVFF  8B8,FF7
0DB6E:  MOVFF  8B9,FF8
0DB72:  MOVLB  0
0DB74:  BRA    DB4A
0DB76:  GOTO   DC38 (RETURN)
*
0E152:  MOVF   FE9,W
0E154:  MOVLB  8
0E156:  MOVWF  x8C
0E158:  MOVLW  3B
0E15A:  MOVWF  x93
0E15C:  MOVLW  9A
0E15E:  MOVWF  x92
0E160:  MOVLW  CA
0E162:  MOVWF  x91
0E164:  CLRF   x90
0E166:  MOVLW  0A
0E168:  MOVWF  x8E
0E16A:  MOVF   x8B,W
0E16C:  BTFSS  FD8.2
0E16E:  DECF   x8C,F
0E170:  BSF    FD8.1
0E172:  MOVLW  08
0E174:  MOVWF  FEA
0E176:  MOVLW  87
0E178:  MOVWF  FE9
0E17A:  CLRF   1B
0E17C:  BTFSC  FF2.7
0E17E:  BSF    1B.7
0E180:  BCF    FF2.7
0E182:  MOVFF  88A,A4F
0E186:  MOVFF  889,A4E
0E18A:  MOVFF  888,A4D
0E18E:  MOVFF  887,A4C
0E192:  MOVFF  893,A53
0E196:  MOVFF  892,A52
0E19A:  MOVFF  891,A51
0E19E:  MOVFF  890,A50
0E1A2:  MOVLB  0
0E1A4:  CALL   1056
0E1A8:  BTFSC  1B.7
0E1AA:  BSF    FF2.7
0E1AC:  MOVF   01,W
0E1AE:  MOVF   00,F
0E1B0:  BNZ   E1D8
0E1B2:  MOVLB  8
0E1B4:  INCF   x8B,W
0E1B6:  SUBWF  x8E,W
0E1B8:  BTFSS  FD8.2
0E1BA:  BRA    E1C0
0E1BC:  MOVLB  0
0E1BE:  BRA    E1D8
0E1C0:  MOVF   x8C,W
0E1C2:  BZ    E1DC
0E1C4:  ANDLW  0F
0E1C6:  SUBWF  x8E,W
0E1C8:  BZ    E1CC
0E1CA:  BC    E204
0E1CC:  BTFSC  x8C.7
0E1CE:  BRA    E204
0E1D0:  BTFSC  x8C.6
0E1D2:  BRA    E1DC
0E1D4:  MOVLW  20
0E1D6:  BRA    E1FA
0E1D8:  MOVLB  8
0E1DA:  CLRF   x8C
0E1DC:  MOVF   x8B,W
0E1DE:  SUBWF  x8E,W
0E1E0:  BNZ   E1F8
0E1E2:  MOVFF  00,88C
0E1E6:  MOVLW  2E
0E1E8:  BTFSS  F9E.4
0E1EA:  BRA    E1E8
0E1EC:  MOVWF  FAD
0E1EE:  MOVFF  88C,00
0E1F2:  MOVLW  20
0E1F4:  ANDWF  x8C,F
0E1F6:  MOVLW  00
0E1F8:  MOVLW  30
0E1FA:  ADDWF  00,F
0E1FC:  MOVF   00,W
0E1FE:  BTFSS  F9E.4
0E200:  BRA    E1FE
0E202:  MOVWF  FAD
0E204:  BCF    FD8.1
0E206:  CLRF   1B
0E208:  BTFSC  FF2.7
0E20A:  BSF    1B.7
0E20C:  BCF    FF2.7
0E20E:  MOVFF  893,A4F
0E212:  MOVFF  892,A4E
0E216:  MOVFF  891,A4D
0E21A:  MOVFF  890,A4C
0E21E:  MOVLB  A
0E220:  CLRF   x53
0E222:  CLRF   x52
0E224:  CLRF   x51
0E226:  MOVLW  0A
0E228:  MOVWF  x50
0E22A:  MOVLB  0
0E22C:  CALL   1056
0E230:  BTFSC  1B.7
0E232:  BSF    FF2.7
0E234:  MOVFF  03,893
0E238:  MOVFF  02,892
0E23C:  MOVFF  01,891
0E240:  MOVFF  00,890
0E244:  MOVLB  8
0E246:  DECFSZ x8E,F
0E248:  BRA    E170
0E24A:  MOVLB  0
0E24C:  RETURN 0
*
0F2E6:  MOVF   FE9,W
0F2E8:  MOVLB  8
0F2EA:  MOVWF  xF7
0F2EC:  MOVLW  3B
0F2EE:  MOVWF  xFE
0F2F0:  MOVLW  9A
0F2F2:  MOVWF  xFD
0F2F4:  MOVLW  CA
0F2F6:  MOVWF  xFC
0F2F8:  CLRF   xFB
0F2FA:  MOVLW  0A
0F2FC:  MOVWF  xF9
0F2FE:  BSF    FD8.1
0F300:  MOVLW  08
0F302:  MOVWF  FEA
0F304:  MOVLW  F3
0F306:  MOVWF  FE9
0F308:  CLRF   1B
0F30A:  BTFSC  FF2.7
0F30C:  BSF    1B.7
0F30E:  BCF    FF2.7
0F310:  MOVFF  8F6,A4F
0F314:  MOVFF  8F5,A4E
0F318:  MOVFF  8F4,A4D
0F31C:  MOVFF  8F3,A4C
0F320:  MOVFF  8FE,A53
0F324:  MOVFF  8FD,A52
0F328:  MOVFF  8FC,A51
0F32C:  MOVFF  8FB,A50
0F330:  MOVLB  0
0F332:  CALL   1056
0F336:  BTFSC  1B.7
0F338:  BSF    FF2.7
0F33A:  MOVF   01,W
0F33C:  MOVF   00,F
0F33E:  BNZ   F366
0F340:  MOVLB  8
0F342:  MOVF   xF9,W
0F344:  XORLW  01
0F346:  BTFSS  FD8.2
0F348:  BRA    F34E
0F34A:  MOVLB  0
0F34C:  BRA    F366
0F34E:  MOVF   xF7,W
0F350:  BZ    F36A
0F352:  ANDLW  0F
0F354:  SUBWF  xF9,W
0F356:  BZ    F35A
0F358:  BC    F37A
0F35A:  BTFSC  xF7.7
0F35C:  BRA    F37A
0F35E:  BTFSC  xF7.6
0F360:  BRA    F36A
0F362:  MOVLW  20
0F364:  BRA    F36C
0F366:  MOVLB  8
0F368:  CLRF   xF7
0F36A:  MOVLW  30
0F36C:  ADDWF  00,F
0F36E:  MOVF   00,W
0F370:  BTFSS  FA4.4
0F372:  BRA    F370
0F374:  MOVLB  F
0F376:  MOVWF  x1C
0F378:  MOVLB  8
0F37A:  BCF    FD8.1
0F37C:  CLRF   1B
0F37E:  BTFSC  FF2.7
0F380:  BSF    1B.7
0F382:  BCF    FF2.7
0F384:  MOVFF  8FE,A4F
0F388:  MOVFF  8FD,A4E
0F38C:  MOVFF  8FC,A4D
0F390:  MOVFF  8FB,A4C
0F394:  MOVLB  A
0F396:  CLRF   x53
0F398:  CLRF   x52
0F39A:  CLRF   x51
0F39C:  MOVLW  0A
0F39E:  MOVWF  x50
0F3A0:  MOVLB  0
0F3A2:  CALL   1056
0F3A6:  BTFSC  1B.7
0F3A8:  BSF    FF2.7
0F3AA:  MOVFF  03,8FE
0F3AE:  MOVFF  02,8FD
0F3B2:  MOVFF  01,8FC
0F3B6:  MOVFF  00,8FB
0F3BA:  MOVLB  8
0F3BC:  DECFSZ xF9,F
0F3BE:  BRA    F2FE
0F3C0:  MOVLB  0
0F3C2:  GOTO   F4EC (RETURN)
*
0F5BC:  ADDWF  FE8,W
0F5BE:  CLRF   FF7
0F5C0:  RLCF   FF7,F
0F5C2:  ADDLW  DD
0F5C4:  MOVWF  FF6
0F5C6:  MOVLW  F5
0F5C8:  ADDWFC FF7,F
0F5CA:  MOVLW  00
0F5CC:  MOVWF  FF8
0F5CE:  MOVWF  FFB
0F5D0:  TBLRD*-
0F5D2:  MOVF   FF5,W
0F5D4:  MOVWF  FFA
0F5D6:  TBLRD*
0F5D8:  MOVF   FF5,W
0F5DA:  MOVWF  FF9
0F5DC:  DATA 7C,F5
0F5DE:  DATA 84,F5
0F5E0:  DATA 8C,F5
0F5E2:  DATA 94,F5
*
0FE00:  MOVF   FEF,F
0FE02:  BZ    FE24
0FE04:  MOVFF  FEA,8EC
0FE08:  MOVFF  FE9,8EB
0FE0C:  MOVFF  FEF,8FF
0FE10:  CALL   509E
0FE14:  MOVFF  8EC,FEA
0FE18:  MOVFF  8EB,FE9
0FE1C:  INCF   FE9,F
0FE1E:  BTFSC  FD8.2
0FE20:  INCF   FEA,F
0FE22:  BRA    FE00
0FE24:  RETURN 0
0FE26:  MOVFF  FEA,FE2
0FE2A:  MOVFF  FE9,FE1
0FE2E:  CLRF   01
0FE30:  BSF    00.0
0FE32:  TBLRD*+
0FE34:  MOVF   FF5,W
0FE36:  BTFSS  00.0
0FE38:  BRA    FE44
0FE3A:  SUBWF  FEE,W
0FE3C:  BNZ   FE44
0FE3E:  MOVF   FF5,F
0FE40:  BNZ   FE32
0FE42:  BRA    FE5E
0FE44:  BCF    00.0
0FE46:  MOVF   FF5,F
0FE48:  BNZ   FE32
0FE4A:  INCF   01,F
0FE4C:  BSF    00.0
0FE4E:  MOVFF  FE2,FEA
0FE52:  MOVFF  FE1,FE9
0FE56:  TBLRD*
0FE58:  MOVF   FF5,F
0FE5A:  BNZ   FE32
0FE5C:  SETF   01
0FE5E:  RETURN 0
*
10730:  MOVFF  914,91B
10734:  MOVLB  9
10736:  MOVF   x18,W
10738:  XORWF  x1B,F
1073A:  BTFSS  x1B.7
1073C:  BRA    10748
1073E:  BCF    FD8.2
10740:  BCF    FD8.0
10742:  BTFSC  x14.7
10744:  BSF    FD8.0
10746:  BRA    107A6
10748:  MOVFF  914,91B
1074C:  MOVFF  917,91C
10750:  MOVF   x13,W
10752:  SUBWF  x1C,F
10754:  BZ    10762
10756:  BTFSS  x1B.7
10758:  BRA    107A6
1075A:  MOVF   FD8,W
1075C:  XORLW  01
1075E:  MOVWF  FD8
10760:  BRA    107A6
10762:  MOVFF  918,91C
10766:  MOVF   x14,W
10768:  SUBWF  x1C,F
1076A:  BZ    10778
1076C:  BTFSS  x1B.7
1076E:  BRA    107A6
10770:  MOVF   FD8,W
10772:  XORLW  01
10774:  MOVWF  FD8
10776:  BRA    107A6
10778:  MOVFF  919,91C
1077C:  MOVF   x15,W
1077E:  SUBWF  x1C,F
10780:  BZ    1078E
10782:  BTFSS  x1B.7
10784:  BRA    107A6
10786:  MOVF   FD8,W
10788:  XORLW  01
1078A:  MOVWF  FD8
1078C:  BRA    107A6
1078E:  MOVFF  91A,91C
10792:  MOVF   x16,W
10794:  SUBWF  x1C,F
10796:  BZ    107A4
10798:  BTFSS  x1B.7
1079A:  BRA    107A6
1079C:  MOVF   FD8,W
1079E:  XORLW  01
107A0:  MOVWF  FD8
107A2:  BRA    107A6
107A4:  BCF    FD8.0
107A6:  MOVLB  0
107A8:  RETURN 0
107AA:  MOVLW  8E
107AC:  MOVWF  00
107AE:  MOVFF  8ED,01
107B2:  MOVFF  8EC,02
107B6:  CLRF   03
107B8:  BTFSS  01.7
107BA:  BRA    107C6
107BC:  COMF   01,F
107BE:  COMF   02,F
107C0:  INCF   02,F
107C2:  BNZ   107C6
107C4:  INCF   01,F
107C6:  MOVF   01,F
107C8:  BNZ   107DC
107CA:  MOVFF  02,01
107CE:  CLRF   02
107D0:  MOVLW  08
107D2:  SUBWF  00,F
107D4:  MOVF   01,F
107D6:  BNZ   107DC
107D8:  CLRF   00
107DA:  BRA    107F8
107DC:  BCF    FD8.0
107DE:  BTFSC  01.7
107E0:  BRA    107EA
107E2:  RLCF   02,F
107E4:  RLCF   01,F
107E6:  DECF   00,F
107E8:  BRA    107DC
107EA:  MOVLB  8
107EC:  BTFSS  xED.7
107EE:  BRA    107F4
107F0:  MOVLB  0
107F2:  BRA    107F8
107F4:  BCF    01.7
107F6:  MOVLB  0
107F8:  RETURN 0
*
10BFA:  MOVF   FE9,W
10BFC:  MOVLB  8
10BFE:  MOVWF  xD4
10C00:  MOVF   xD3,W
10C02:  MOVWF  xD6
10C04:  BZ    10C40
10C06:  MOVFF  8D2,916
10C0A:  MOVFF  8D1,915
10C0E:  MOVFF  8D0,914
10C12:  MOVFF  8CF,913
10C16:  MOVLB  9
10C18:  CLRF   x1A
10C1A:  CLRF   x19
10C1C:  MOVLW  20
10C1E:  MOVWF  x18
10C20:  MOVLW  82
10C22:  MOVWF  x17
10C24:  MOVLB  0
10C26:  CALL   C288
10C2A:  MOVFF  03,8D2
10C2E:  MOVFF  02,8D1
10C32:  MOVFF  01,8D0
10C36:  MOVFF  00,8CF
10C3A:  MOVLB  8
10C3C:  DECFSZ xD6,F
10C3E:  BRA    10C06
10C40:  MOVLW  7E
10C42:  MOVWF  00
10C44:  CLRF   01
10C46:  BTFSC  xD0.7
10C48:  BSF    01.7
10C4A:  CLRF   02
10C4C:  CLRF   03
10C4E:  BCF    FD8.1
10C50:  MOVFF  8D2,91A
10C54:  MOVFF  8D1,919
10C58:  MOVFF  8D0,918
10C5C:  MOVFF  8CF,917
10C60:  MOVFF  03,91E
10C64:  MOVFF  02,91D
10C68:  MOVFF  01,91C
10C6C:  MOVFF  FE8,91B
10C70:  MOVLB  0
10C72:  CALL   C37E
10C76:  MOVFF  03,8D2
10C7A:  MOVFF  02,8D1
10C7E:  MOVFF  01,8D0
10C82:  MOVFF  00,8CF
10C86:  MOVFF  8D2,8DF
10C8A:  MOVFF  8D1,8DE
10C8E:  MOVFF  8D0,8DD
10C92:  MOVFF  8CF,8DC
10C96:  CALL   C5F6
10C9A:  MOVFF  03,8D2
10C9E:  MOVFF  02,8D1
10CA2:  MOVFF  01,8D0
10CA6:  MOVFF  00,8CF
10CAA:  MOVLB  8
10CAC:  BTFSS  xD2.7
10CAE:  BRA    10CCA
10CB0:  DECF   xD4,F
10CB2:  BSF    xD4.5
10CB4:  COMF   xCF,F
10CB6:  COMF   xD0,F
10CB8:  COMF   xD1,F
10CBA:  COMF   xD2,F
10CBC:  INCF   xCF,F
10CBE:  BTFSC  FD8.2
10CC0:  INCF   xD0,F
10CC2:  BTFSC  FD8.2
10CC4:  INCF   xD1,F
10CC6:  BTFSC  FD8.2
10CC8:  INCF   xD2,F
10CCA:  MOVLW  3B
10CCC:  MOVWF  xDB
10CCE:  MOVLW  9A
10CD0:  MOVWF  xDA
10CD2:  MOVLW  CA
10CD4:  MOVWF  xD9
10CD6:  CLRF   xD8
10CD8:  MOVLW  0A
10CDA:  MOVWF  xD6
10CDC:  MOVF   xD3,W
10CDE:  BTFSC  FD8.2
10CE0:  INCF   xD4,F
10CE2:  BSF    FD8.1
10CE4:  MOVLW  08
10CE6:  MOVWF  FEA
10CE8:  MOVLW  CF
10CEA:  MOVWF  FE9
10CEC:  CLRF   1B
10CEE:  BTFSC  FF2.7
10CF0:  BSF    1B.7
10CF2:  BCF    FF2.7
10CF4:  MOVFF  8D2,A4F
10CF8:  MOVFF  8D1,A4E
10CFC:  MOVFF  8D0,A4D
10D00:  MOVFF  8CF,A4C
10D04:  MOVFF  8DB,A53
10D08:  MOVFF  8DA,A52
10D0C:  MOVFF  8D9,A51
10D10:  MOVFF  8D8,A50
10D14:  MOVLB  0
10D16:  CALL   1056
10D1A:  BTFSC  1B.7
10D1C:  BSF    FF2.7
10D1E:  MOVF   01,W
10D20:  MOVF   00,F
10D22:  BNZ   10D4A
10D24:  MOVLB  8
10D26:  INCF   xD3,W
10D28:  SUBWF  xD6,W
10D2A:  BTFSS  FD8.2
10D2C:  BRA    10D32
10D2E:  MOVLB  0
10D30:  BRA    10D4A
10D32:  MOVF   xD4,W
10D34:  BZ    10D50
10D36:  ANDLW  0F
10D38:  SUBWF  xD6,W
10D3A:  BZ    10D3E
10D3C:  BC    10DC6
10D3E:  BTFSC  xD4.7
10D40:  BRA    10DC6
10D42:  BTFSC  xD4.6
10D44:  BRA    10D50
10D46:  MOVLW  20
10D48:  BRA    10DB8
10D4A:  MOVLW  20
10D4C:  MOVLB  8
10D4E:  ANDWF  xD4,F
10D50:  BTFSS  xD4.5
10D52:  BRA    10D72
10D54:  BCF    xD4.5
10D56:  MOVF   xD3,W
10D58:  BTFSS  FD8.2
10D5A:  DECF   xD4,F
10D5C:  MOVF   00,W
10D5E:  MOVWF  xD4
10D60:  MOVLW  2D
10D62:  MOVWF  xFF
10D64:  MOVLB  0
10D66:  CALL   509E
10D6A:  MOVLB  8
10D6C:  MOVF   xD4,W
10D6E:  MOVWF  00
10D70:  CLRF   xD4
10D72:  MOVF   xD3,W
10D74:  SUBWF  xD6,W
10D76:  BNZ   10D92
10D78:  MOVF   00,W
10D7A:  MOVWF  xD4
10D7C:  MOVLW  2E
10D7E:  MOVWF  xFF
10D80:  MOVLB  0
10D82:  CALL   509E
10D86:  MOVLB  8
10D88:  MOVF   xD4,W
10D8A:  MOVWF  00
10D8C:  MOVLW  20
10D8E:  ANDWF  xD4,F
10D90:  MOVLW  00
10D92:  MOVLW  30
10D94:  BTFSS  xD4.5
10D96:  BRA    10DB8
10D98:  BCF    xD4.5
10D9A:  MOVF   xD3,W
10D9C:  BTFSS  FD8.2
10D9E:  DECF   xD4,F
10DA0:  MOVF   00,W
10DA2:  MOVWF  xD4
10DA4:  MOVLW  2D
10DA6:  MOVWF  xFF
10DA8:  MOVLB  0
10DAA:  CALL   509E
10DAE:  MOVLB  8
10DB0:  MOVF   xD4,W
10DB2:  MOVWF  00
10DB4:  CLRF   xD4
10DB6:  MOVLW  30
10DB8:  ADDWF  00,F
10DBA:  MOVFF  00,8FF
10DBE:  MOVLB  0
10DC0:  CALL   509E
10DC4:  MOVLB  8
10DC6:  BCF    FD8.1
10DC8:  CLRF   1B
10DCA:  BTFSC  FF2.7
10DCC:  BSF    1B.7
10DCE:  BCF    FF2.7
10DD0:  MOVFF  8DB,A4F
10DD4:  MOVFF  8DA,A4E
10DD8:  MOVFF  8D9,A4D
10DDC:  MOVFF  8D8,A4C
10DE0:  MOVLB  A
10DE2:  CLRF   x53
10DE4:  CLRF   x52
10DE6:  CLRF   x51
10DE8:  MOVLW  0A
10DEA:  MOVWF  x50
10DEC:  MOVLB  0
10DEE:  CALL   1056
10DF2:  BTFSC  1B.7
10DF4:  BSF    FF2.7
10DF6:  MOVFF  03,8DB
10DFA:  MOVFF  02,8DA
10DFE:  MOVFF  01,8D9
10E02:  MOVFF  00,8D8
10E06:  MOVLB  8
10E08:  DECFSZ xD6,F
10E0A:  BRA    10CE2
10E0C:  MOVLB  0
10E0E:  RETURN 0
*
12712:  ADDWF  FE8,W
12714:  CLRF   FF7
12716:  RLCF   FF7,F
12718:  ADDLW  33
1271A:  MOVWF  FF6
1271C:  MOVLW  27
1271E:  ADDWFC FF7,F
12720:  MOVLW  01
12722:  MOVWF  FF8
12724:  MOVWF  FFB
12726:  TBLRD*-
12728:  MOVF   FF5,W
1272A:  MOVWF  FFA
1272C:  TBLRD*
1272E:  MOVF   FF5,W
12730:  MOVWF  FF9
12732:  DATA D6,26
12734:  DATA DE,26
12736:  DATA E4,26
12738:  DATA EA,26
*
127CA:  MOVLW  8E
127CC:  MOVWF  00
127CE:  MOVLB  9
127D0:  MOVF   x13,W
127D2:  SUBWF  00,F
127D4:  MOVFF  914,02
127D8:  MOVFF  915,01
127DC:  BSF    02.7
127DE:  MOVF   00,F
127E0:  BZ    127F4
127E2:  BCF    FD8.0
127E4:  MOVF   02,F
127E6:  BNZ   127EC
127E8:  MOVF   01,F
127EA:  BZ    127F4
127EC:  RRCF   02,F
127EE:  RRCF   01,F
127F0:  DECFSZ 00,F
127F2:  BRA    127E2
127F4:  BTFSS  x14.7
127F6:  BRA    12802
127F8:  COMF   01,F
127FA:  COMF   02,F
127FC:  INCF   01,F
127FE:  BTFSC  FD8.2
12800:  INCF   02,F
12802:  MOVLB  0
12804:  RETURN 0
*
132C2:  ADDWF  FE8,W
132C4:  CLRF   FF7
132C6:  RLCF   FF7,F
132C8:  ADDLW  E3
132CA:  MOVWF  FF6
132CC:  MOVLW  32
132CE:  ADDWFC FF7,F
132D0:  MOVLW  01
132D2:  MOVWF  FF8
132D4:  MOVWF  FFB
132D6:  TBLRD*-
132D8:  MOVF   FF5,W
132DA:  MOVWF  FFA
132DC:  TBLRD*
132DE:  MOVF   FF5,W
132E0:  MOVWF  FF9
132E2:  DATA FE,30
132E4:  DATA 04,31
132E6:  DATA 22,31
132E8:  DATA 40,31
*
1335A:  MOVLB  8
1335C:  MOVF   xDD,W
1335E:  XORWF  xDF,W
13360:  ANDLW  80
13362:  MOVWF  xE1
13364:  BTFSS  xDD.7
13366:  BRA    13372
13368:  COMF   xDC,F
1336A:  COMF   xDD,F
1336C:  INCF   xDC,F
1336E:  BTFSC  FD8.2
13370:  INCF   xDD,F
13372:  BTFSS  xDF.7
13374:  BRA    13380
13376:  COMF   xDE,F
13378:  COMF   xDF,F
1337A:  INCF   xDE,F
1337C:  BTFSC  FD8.2
1337E:  INCF   xDF,F
13380:  MOVF   xDC,W
13382:  MULWF  xDE
13384:  MOVFF  FF3,01
13388:  MOVFF  FF4,00
1338C:  MULWF  xDF
1338E:  MOVF   FF3,W
13390:  ADDWF  00,F
13392:  MOVF   xDD,W
13394:  MULWF  xDE
13396:  MOVF   FF3,W
13398:  ADDWFC 00,W
1339A:  MOVWF  02
1339C:  BTFSS  xE1.7
1339E:  BRA    133AA
133A0:  COMF   01,F
133A2:  COMF   02,F
133A4:  INCF   01,F
133A6:  BTFSC  FD8.2
133A8:  INCF   02,F
133AA:  MOVLB  0
133AC:  GOTO   1348A (RETURN)
*
14248:  ADDWF  FE8,W
1424A:  CLRF   FF7
1424C:  RLCF   FF7,F
1424E:  ADDLW  69
14250:  MOVWF  FF6
14252:  MOVLW  42
14254:  ADDWFC FF7,F
14256:  MOVLW  01
14258:  MOVWF  FF8
1425A:  MOVWF  FFB
1425C:  TBLRD*-
1425E:  MOVF   FF5,W
14260:  MOVWF  FFA
14262:  TBLRD*
14264:  MOVF   FF5,W
14266:  MOVWF  FF9
14268:  DATA FE,40
1426A:  DATA 3C,42
1426C:  DATA 2A,41
1426E:  DATA 3C,42
14270:  DATA F4,3F
14272:  DATA 3C,42
14274:  DATA 3C,42
14276:  DATA 3C,42
14278:  DATA 3C,42
1427A:  DATA 3C,42
1427C:  DATA 3C,42
1427E:  DATA 3C,42
14280:  DATA 3C,42
14282:  DATA 3C,42
14284:  DATA 3C,42
14286:  DATA 3C,42
14288:  DATA 34,42
1428A:  DATA 3C,42
1428C:  DATA 3C,42
1428E:  DATA 3C,42
14290:  DATA 3C,42
14292:  DATA 3C,42
14294:  DATA 94,3F
14296:  DATA 3C,42
14298:  DATA C8,3F
1429A:  DATA D0,3F
1429C:  DATA 3C,42
1429E:  DATA E4,3F
142A0:  DATA 56,41
142A2:  DATA 18,40
142A4:  DATA 3C,42
142A6:  DATA 3C,42
142A8:  DATA AA,40
142AA:  DATA 8C,40
142AC:  DATA 3C,42
142AE:  DATA 3C,42
142B0:  DATA 3C,42
142B2:  DATA 70,41
142B4:  DATA 9C,41
142B6:  DATA C8,41
142B8:  DATA C6,40
142BA:  DATA F4,40
142BC:  DATA 3C,42
142BE:  DATA 3C,42
142C0:  DATA 3C,42
142C2:  DATA 3C,42
142C4:  DATA F4,41
142C6:  DATA 3C,42
142C8:  DATA 3C,42
142CA:  DATA 3C,42
142CC:  DATA 3C,42
142CE:  DATA 3C,42
142D0:  DATA 3C,42
142D2:  DATA 3C,42
142D4:  DATA 3C,42
142D6:  DATA 3C,42
142D8:  DATA 3C,42
142DA:  DATA 00,40
142DC:  DATA 3C,42
142DE:  DATA 3C,42
142E0:  DATA 3C,42
142E2:  DATA 3C,42
142E4:  DATA 30,40
142E6:  DATA 3C,42
142E8:  DATA 3C,42
142EA:  DATA 56,40
142EC:  DATA 3C,42
142EE:  DATA 3C,42
142F0:  DATA 3C,42
142F2:  DATA A4,3F
142F4:  DATA 3C,42
142F6:  DATA 3C,42
142F8:  DATA 3C,42
142FA:  DATA 3C,42
142FC:  DATA 3C,42
142FE:  DATA 1E,42
*
143B4:  MOVFF  FEA,8C0
143B8:  MOVFF  FE9,8BF
143BC:  MOVLB  8
143BE:  SWAPF  xB9,W
143C0:  IORLW  F0
143C2:  MOVWF  xBB
143C4:  ADDWF  xBB,F
143C6:  ADDLW  E2
143C8:  MOVWF  xBC
143CA:  ADDLW  32
143CC:  MOVWF  xBE
143CE:  MOVF   xB9,W
143D0:  ANDLW  0F
143D2:  ADDWF  xBC,F
143D4:  ADDWF  xBC,F
143D6:  ADDWF  xBE,F
143D8:  ADDLW  E9
143DA:  MOVWF  xBD
143DC:  ADDWF  xBD,F
143DE:  ADDWF  xBD,F
143E0:  SWAPF  xB8,W
143E2:  ANDLW  0F
143E4:  ADDWF  xBD,F
143E6:  ADDWF  xBE,F
143E8:  RLCF   xBD,F
143EA:  RLCF   xBE,F
143EC:  COMF   xBE,F
143EE:  RLCF   xBE,F
143F0:  MOVF   xB8,W
143F2:  ANDLW  0F
143F4:  ADDWF  xBE,F
143F6:  RLCF   xBB,F
143F8:  MOVLW  07
143FA:  MOVWF  xBA
143FC:  MOVLW  0A
143FE:  DECF   xBD,F
14400:  ADDWF  xBE,F
14402:  BNC   143FE
14404:  DECF   xBC,F
14406:  ADDWF  xBD,F
14408:  BNC   14404
1440A:  DECF   xBB,F
1440C:  ADDWF  xBC,F
1440E:  BNC   1440A
14410:  DECF   xBA,F
14412:  ADDWF  xBB,F
14414:  BNC   14410
14416:  MOVLW  08
14418:  MOVWF  FEA
1441A:  MOVLW  BA
1441C:  MOVWF  FE9
1441E:  MOVLW  07
14420:  ANDWF  xBF,W
14422:  BCF    xBF.6
14424:  ADDWF  FE9,F
14426:  MOVLW  00
14428:  ADDWFC FEA,F
1442A:  MOVF   FE9,W
1442C:  SUBLW  BE
1442E:  BNZ   14438
14430:  MOVF   FEA,W
14432:  SUBLW  08
14434:  BNZ   14438
14436:  BSF    xBF.6
14438:  MOVF   FEF,W
1443A:  MOVWF  00
1443C:  BNZ   1444E
1443E:  BTFSC  xBF.6
14440:  BRA    1444E
14442:  BTFSC  xBF.4
14444:  BRA    14462
14446:  BTFSC  xBF.3
14448:  BRA    1444E
1444A:  MOVLW  20
1444C:  BRA    14454
1444E:  BSF    xBF.3
14450:  BCF    xBF.4
14452:  MOVLW  30
14454:  ADDWF  00,F
14456:  MOVF   00,W
14458:  BTFSS  FA4.4
1445A:  BRA    14458
1445C:  MOVLB  F
1445E:  MOVWF  x1C
14460:  MOVLB  8
14462:  MOVF   FEE,W
14464:  BTFSS  xBF.6
14466:  BRA    1442A
14468:  MOVLB  0
1446A:  GOTO   14506 (RETURN)
*
1494A:  ADDWF  FE8,W
1494C:  CLRF   FF7
1494E:  RLCF   FF7,F
14950:  ADDLW  6B
14952:  MOVWF  FF6
14954:  MOVLW  49
14956:  ADDWFC FF7,F
14958:  MOVLW  01
1495A:  MOVWF  FF8
1495C:  MOVWF  FFB
1495E:  TBLRD*-
14960:  MOVF   FF5,W
14962:  MOVWF  FFA
14964:  TBLRD*
14966:  MOVF   FF5,W
14968:  MOVWF  FF9
1496A:  DATA 36,45
1496C:  DATA 96,45
1496E:  DATA B2,45
14970:  DATA CE,45
14972:  DATA EA,45
14974:  DATA 06,46
14976:  DATA 22,46
14978:  DATA 3E,46
1497A:  DATA 5A,46
1497C:  DATA 76,46
1497E:  DATA 92,46
14980:  DATA AE,46
14982:  DATA CA,46
14984:  DATA E6,46
14986:  DATA 02,47
14988:  DATA 1E,47
1498A:  DATA 3A,47
1498C:  DATA 56,47
1498E:  DATA 72,47
14990:  DATA 8E,47
14992:  DATA AA,47
14994:  DATA C6,47
14996:  DATA E2,47
14998:  DATA FE,47
1499A:  DATA 1A,48
1499C:  DATA 36,48
1499E:  DATA 52,48
149A0:  DATA 6E,48
149A2:  DATA 8A,48
149A4:  DATA A6,48
149A6:  DATA C2,48
149A8:  DATA DE,48
149AA:  DATA FA,48
*
15198:  ADDWF  FE8,W
1519A:  CLRF   FF7
1519C:  RLCF   FF7,F
1519E:  ADDLW  B9
151A0:  MOVWF  FF6
151A2:  MOVLW  51
151A4:  ADDWFC FF7,F
151A6:  MOVLW  01
151A8:  MOVWF  FF8
151AA:  MOVWF  FFB
151AC:  TBLRD*-
151AE:  MOVF   FF5,W
151B0:  MOVWF  FFA
151B2:  TBLRD*
151B4:  MOVF   FF5,W
151B6:  MOVWF  FF9
151B8:  DATA 8C,4D
151BA:  DATA CC,4E
151BC:  DATA B8,4D
151BE:  DATA CC,4E
151C0:  DATA 7E,4C
151C2:  DATA CC,4E
151C4:  DATA CC,4E
151C6:  DATA CC,4E
151C8:  DATA CC,4E
151CA:  DATA CC,4E
151CC:  DATA CC,4E
151CE:  DATA CC,4E
151D0:  DATA CC,4E
151D2:  DATA CC,4E
151D4:  DATA CC,4E
151D6:  DATA CC,4E
151D8:  DATA C4,4E
151DA:  DATA CC,4E
151DC:  DATA CC,4E
151DE:  DATA CC,4E
151E0:  DATA CC,4E
151E2:  DATA CC,4E
151E4:  DATA 88,4A
151E6:  DATA CC,4E
151E8:  DATA BC,4A
151EA:  DATA 5A,4C
151EC:  DATA CC,4E
151EE:  DATA 6E,4C
151F0:  DATA E4,4D
151F2:  DATA A2,4C
151F4:  DATA CC,4E
151F6:  DATA CC,4E
151F8:  DATA 34,4D
151FA:  DATA 16,4D
151FC:  DATA CC,4E
151FE:  DATA CC,4E
15200:  DATA CC,4E
15202:  DATA FE,4D
15204:  DATA 2A,4E
15206:  DATA 56,4E
15208:  DATA 50,4D
1520A:  DATA 80,4D
1520C:  DATA CC,4E
1520E:  DATA CC,4E
15210:  DATA CC,4E
15212:  DATA CC,4E
15214:  DATA 82,4E
15216:  DATA CC,4E
15218:  DATA CC,4E
1521A:  DATA CC,4E
1521C:  DATA CC,4E
1521E:  DATA CC,4E
15220:  DATA CC,4E
15222:  DATA CC,4E
15224:  DATA CC,4E
15226:  DATA CC,4E
15228:  DATA CC,4E
1522A:  DATA 8A,4C
1522C:  DATA CC,4E
1522E:  DATA CC,4E
15230:  DATA CC,4E
15232:  DATA CC,4E
15234:  DATA BA,4C
15236:  DATA CC,4E
15238:  DATA CC,4E
1523A:  DATA E0,4C
1523C:  DATA CC,4E
1523E:  DATA CC,4E
15240:  DATA CC,4E
15242:  DATA 98,4A
15244:  DATA CC,4E
15246:  DATA C4,4A
15248:  DATA CC,4E
1524A:  DATA CC,4E
1524C:  DATA CC,4E
1524E:  DATA AC,4E
*
156B2:  ADDWF  FE8,W
156B4:  CLRF   FF7
156B6:  RLCF   FF7,F
156B8:  ADDLW  D3
156BA:  MOVWF  FF6
156BC:  MOVLW  56
156BE:  ADDWFC FF7,F
156C0:  MOVLW  01
156C2:  MOVWF  FF8
156C4:  MOVWF  FFB
156C6:  TBLRD*-
156C8:  MOVF   FF5,W
156CA:  MOVWF  FFA
156CC:  TBLRD*
156CE:  MOVF   FF5,W
156D0:  MOVWF  FF9
156D2:  DATA 24,55
156D4:  DATA 44,55
156D6:  DATA 64,55
156D8:  DATA 84,55
156DA:  DATA A4,55
156DC:  DATA C4,55
156DE:  DATA E4,55
*
187DA:  MOVLW  20
187DC:  MOVLB  8
187DE:  BTFSS  x88.4
187E0:  MOVLW  30
187E2:  MOVWF  x89
187E4:  MOVFF  887,00
187E8:  BTFSS  x87.7
187EA:  BRA    187FC
187EC:  COMF   00,F
187EE:  INCF   00,F
187F0:  MOVFF  00,887
187F4:  MOVLW  2D
187F6:  MOVWF  x89
187F8:  BSF    x88.7
187FA:  BSF    x88.0
187FC:  MOVF   01,W
187FE:  CLRF   1B
18800:  BTFSC  FF2.7
18802:  BSF    1B.7
18804:  BCF    FF2.7
18806:  MOVFF  887,A42
1880A:  MOVLW  64
1880C:  MOVLB  A
1880E:  MOVWF  x43
18810:  MOVLB  0
18812:  CALL   0F7A
18816:  BTFSC  1B.7
18818:  BSF    FF2.7
1881A:  MOVFF  00,887
1881E:  MOVLW  30
18820:  ADDWF  01,W
18822:  MOVLB  8
18824:  MOVWF  x8A
18826:  CLRF   1B
18828:  BTFSC  FF2.7
1882A:  BSF    1B.7
1882C:  BCF    FF2.7
1882E:  MOVFF  887,A42
18832:  MOVLW  0A
18834:  MOVLB  A
18836:  MOVWF  x43
18838:  MOVLB  0
1883A:  CALL   0F7A
1883E:  BTFSC  1B.7
18840:  BSF    FF2.7
18842:  MOVLW  30
18844:  ADDWF  00,W
18846:  MOVLB  8
18848:  MOVWF  x8C
1884A:  MOVLW  30
1884C:  ADDWF  01,W
1884E:  MOVWF  x8B
18850:  MOVFF  889,00
18854:  MOVLW  30
18856:  SUBWF  x8A,W
18858:  BZ    18862
1885A:  BSF    x88.1
1885C:  BTFSC  x88.7
1885E:  BSF    x88.2
18860:  BRA    18886
18862:  MOVFF  889,88A
18866:  MOVLW  20
18868:  MOVWF  x89
1886A:  MOVLW  30
1886C:  SUBWF  x8B,W
1886E:  BZ    18878
18870:  BSF    x88.0
18872:  BTFSC  x88.7
18874:  BSF    x88.1
18876:  BRA    18886
18878:  BTFSS  FD8.2
1887A:  BSF    x88.0
1887C:  BNZ   18886
1887E:  MOVFF  88A,88B
18882:  MOVLW  20
18884:  MOVWF  x8A
18886:  BTFSC  x88.2
18888:  BRA    18894
1888A:  BTFSC  x88.1
1888C:  BRA    1889C
1888E:  BTFSC  x88.0
18890:  BRA    188A4
18892:  BRA    188AC
18894:  MOVF   x89,W
18896:  BTFSS  F9E.4
18898:  BRA    18896
1889A:  MOVWF  FAD
1889C:  MOVF   x8A,W
1889E:  BTFSS  F9E.4
188A0:  BRA    1889E
188A2:  MOVWF  FAD
188A4:  MOVF   x8B,W
188A6:  BTFSS  F9E.4
188A8:  BRA    188A6
188AA:  MOVWF  FAD
188AC:  MOVF   x8C,W
188AE:  BTFSS  F9E.4
188B0:  BRA    188AE
188B2:  MOVWF  FAD
188B4:  MOVLB  0
188B6:  GOTO   18A16 (RETURN)
*
1B302:  ADDWF  FE8,W
1B304:  CLRF   FF7
1B306:  RLCF   FF7,F
1B308:  ADDLW  23
1B30A:  MOVWF  FF6
1B30C:  MOVLW  B3
1B30E:  ADDWFC FF7,F
1B310:  MOVLW  01
1B312:  MOVWF  FF8
1B314:  MOVWF  FFB
1B316:  TBLRD*-
1B318:  MOVF   FF5,W
1B31A:  MOVWF  FFA
1B31C:  TBLRD*
1B31E:  MOVF   FF5,W
1B320:  MOVWF  FF9
1B322:  DATA 7C,B1
1B324:  DATA FE,B2
1B326:  DATA 82,B1
1B328:  DATA 76,B1
1B32A:  DATA FE,B2
1B32C:  DATA FE,B2
1B32E:  DATA FE,B2
1B330:  DATA 88,B1
1B332:  DATA 3C,B2
1B334:  DATA FE,B2
1B336:  DATA 58,B2
1B338:  DATA FE,B2
1B33A:  DATA 8E,B1
1B33C:  DATA FE,B2
1B33E:  DATA FE,B2
1B340:  DATA FE,B2
1B342:  DATA FE,B2
1B344:  DATA FE,B2
1B346:  DATA FE,B2
1B348:  DATA FE,B2
1B34A:  DATA FE,B2
1B34C:  DATA FE,B2
1B34E:  DATA FE,B2
1B350:  DATA FE,B2
1B352:  DATA FE,B2
1B354:  DATA FE,B2
1B356:  DATA FE,B2
1B358:  DATA FE,B2
1B35A:  DATA FE,B2
1B35C:  DATA FE,B2
1B35E:  DATA 94,B1
1B360:  DATA 9A,B1
1B362:  DATA A0,B1
1B364:  DATA A6,B1
1B366:  DATA AC,B1
1B368:  DATA B2,B1
1B36A:  DATA B8,B1
1B36C:  DATA BE,B1
1B36E:  DATA C4,B1
1B370:  DATA CA,B1
1B372:  DATA D0,B1
1B374:  DATA D6,B1
1B376:  DATA DC,B1
1B378:  DATA E8,B1
1B37A:  DATA EE,B1
1B37C:  DATA F4,B1
1B37E:  DATA FA,B1
1B380:  DATA 00,B2
1B382:  DATA 06,B2
1B384:  DATA 0C,B2
1B386:  DATA 12,B2
1B388:  DATA 18,B2
1B38A:  DATA 1E,B2
1B38C:  DATA 24,B2
1B38E:  DATA 2A,B2
1B390:  DATA 30,B2
1B392:  DATA FE,B2
1B394:  DATA FE,B2
1B396:  DATA FE,B2
1B398:  DATA 36,B2
1B39A:  DATA FE,B2
1B39C:  DATA FE,B2
1B39E:  DATA 74,B2
1B3A0:  DATA 7A,B2
1B3A2:  DATA 80,B2
1B3A4:  DATA 86,B2
1B3A6:  DATA 8C,B2
1B3A8:  DATA 92,B2
1B3AA:  DATA 98,B2
1B3AC:  DATA 9E,B2
1B3AE:  DATA A4,B2
1B3B0:  DATA AA,B2
1B3B2:  DATA B0,B2
1B3B4:  DATA B6,B2
1B3B6:  DATA BC,B2
1B3B8:  DATA C2,B2
1B3BA:  DATA C8,B2
1B3BC:  DATA CE,B2
1B3BE:  DATA D4,B2
1B3C0:  DATA DA,B2
1B3C2:  DATA DE,B2
1B3C4:  DATA E2,B2
1B3C6:  DATA E6,B2
1B3C8:  DATA EA,B2
1B3CA:  DATA F0,B2
1B3CC:  DATA F4,B2
1B3CE:  DATA F8,B2
1B3D0:  DATA FC,B2
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8F4
1F8BA:  MOVFF  FF7,8F5
1F8BE:  MOVFF  FF8,8F6
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8F4,FF6
1F8CE:  MOVFF  8F5,FF7
1F8D2:  MOVFF  8F6,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8F5
1F8E0:  MOVFF  FF7,8F6
1F8E4:  MOVFF  FF8,8F7
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8F5,FF6
1F8F4:  MOVFF  8F6,FF7
1F8F8:  MOVFF  8F7,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xF4,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xF5.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xF4,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xF5,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xF4,F
1F936:  MOVLW  0A
1F938:  SUBWF  xF4,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xF5.7
1F942:  MOVF   xF5,W
1F944:  ADDWF  xF4,F
1F946:  MOVF   xF4,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xF7,W
1F956:  CLRF   01
1F958:  SUBWF  xF6,W
1F95A:  BC    1F962
1F95C:  MOVFF  8F6,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xF8
1F968:  RLCF   xF6,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xF7,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xF8,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8F4,8F6
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xF7
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8F4
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xF5.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xF5.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xF5.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xF5.3
1F9AC:  BCF    xF5.4
1F9AE:  BSF    xF5.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8F4,8F6
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xF7
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8F4
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xF5.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xF5.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xF5.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xF4,F
1F9F0:  MOVF   xF4,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8F4,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8F5,01
1FA60:  MOVFF  8F4,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... #FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... #FUSES WDT_SW   
.................... //#use delay(clock=2000000) 
....................  
.................... #FUSES NOWDT 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
02910:  MOVLW  09
02912:  MOVWF  FEA
02914:  MOVLW  EC
02916:  MOVWF  FE9
02918:  MOVF   FEF,W
0291A:  BZ    2938
0291C:  MOVLW  14
0291E:  MOVWF  01
02920:  CLRF   00
02922:  DECFSZ 00,F
02924:  BRA    2922
02926:  DECFSZ 01,F
02928:  BRA    2920
0292A:  MOVLW  BF
0292C:  MOVWF  00
0292E:  DECFSZ 00,F
02930:  BRA    292E
02932:  BRA    2934
02934:  DECFSZ FEF,F
02936:  BRA    291C
02938:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E38:  BTFSS  F9E.5
00E3A:  BRA    0E38
00E3C:  MOVFF  FAB,1C
00E40:  MOVFF  FAE,01
00E44:  BTFSS  1C.1
00E46:  BRA    0E4C
00E48:  BCF    FAB.4
00E4A:  BSF    FAB.4
00E4C:  RETURN 0
*
0AE7C:  BTFSS  F9E.4
0AE7E:  BRA    AE7C
0AE80:  MOVWF  FAD
0AE82:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12DF0:  BTFSS  FA4.5
12DF2:  BRA    12DF0
12DF4:  MOVLB  F
12DF6:  MOVFF  F22,1C
12DFA:  MOVFF  F1D,01
12DFE:  BTFSS  1C.1
12E00:  BRA    12E06
12E02:  BCF    x22.4
12E04:  BSF    x22.4
12E06:  MOVLB  0
12E08:  RETURN 0
*
16F10:  BTFSS  FA4.4
16F12:  BRA    16F10
16F14:  MOVLB  F
16F16:  MOVWF  x1C
16F18:  MOVLB  0
16F1A:  GOTO   16FBE (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xFA
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xFB
1F850:  MOVF   xFB,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8F9,03
1F85A:  MOVFF  8F8,FE9
1F85E:  MOVFF  8F9,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xFA,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8FC
1F870:  MOVFF  8F8,FE9
1F874:  MOVFF  8F9,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xFC,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xFA
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xFA,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8FC
1F88C:  MOVFF  8F8,FE9
1F890:  MOVFF  8F9,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xFC,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xFA
....................       }  
1F89C:  MOVF   xFB,W
1F89E:  INCF   xFB,F
1F8A0:  INCF   xF8,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xF9,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8FA,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xF8,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8F5,03
1FA84:  MOVFF  8F4,FE9
1FA88:  MOVFF  8F5,FEA
1FA8C:  MOVFF  FEF,8F9
1FA90:  MOVFF  8F7,03
1FA94:  MOVFF  8F6,FE9
1FA98:  MOVFF  8F7,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xF9,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8F5,03
1FAA6:  MOVFF  8F4,FE9
1FAAA:  MOVFF  8F5,FEA
1FAAE:  MOVFF  FEF,8F9
1FAB2:  MOVFF  8F7,03
1FAB6:  MOVFF  8F6,FE9
1FABA:  MOVFF  8F7,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xF9,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8F5,03
1FAD4:  MOVFF  8F4,FE9
1FAD8:  MOVFF  8F5,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8F5,03
1FAEA:  MOVF   xF4,W
1FAEC:  INCF   xF4,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xF5,F
1FAF2:  MOVFF  8F7,03
1FAF6:  MOVF   xF6,W
1FAF8:  INCF   xF6,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xF7,F
1FAFE:  DECF   xF8,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x85.1
1FB0E:  CLRF   x8F
1FB10:  CLRF   x8E
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xEC
1FB2A:  MOVLB  0
1FB2C:  CALL   2910
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x85.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x8B
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x8B,W
1FB3C:  ADDLW  B4
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x8B,W
1FB50:  INCF   x8B,F
1FB52:  CLRF   03
1FB54:  ADDLW  B4
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x8B,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x85.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   xB4,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xF9
1FB80:  MOVLW  B5
1FB82:  MOVWF  xF8
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,88A
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xF9
1FB92:  MOVLW  B7
1FB94:  MOVWF  xF8
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8F4
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xF9
1FBA4:  MOVLW  B9
1FBA6:  MOVWF  xF8
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8F4,88D
1FBB0:  MOVFF  01,88C
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xF9
1FBBA:  MOVLW  BB
1FBBC:  MOVWF  xF8
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,887
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  88E,892
1FBCA:  MOVFF  88F,893
1FBCE:  MOVFF  88C,890
1FBD2:  MOVFF  88D,891
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x87,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x85.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x85.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x93,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x92,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x91,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x93,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x92,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x93,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x92,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x86
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x89
1FC26:  MOVLW  03
1FC28:  SUBWF  x8B,W
1FC2A:  SUBWF  x89,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x89,W
1FC32:  ADDLW  B4
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8F4
1FC3E:  MOVFF  03,8F5
1FC42:  MOVFF  03,8F9
1FC46:  MOVFF  01,8F8
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x86,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x89,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x86,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x86
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x8B,W
1FC68:  CLRF   03
1FC6A:  ADDLW  B4
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8F4
1FC76:  MOVFF  03,8F5
1FC7A:  MOVFF  03,8F9
1FC7E:  MOVFF  01,8F8
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x86,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x85.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x87,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x89
1FCAE:  CLRF   x88
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x8B,W
1FCB4:  SUBWF  x89,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x88,W
1FCBA:  INCF   x88,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  94
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8F4
1FCCA:  MOVFF  03,8F5
1FCCE:  CLRF   03
1FCD0:  MOVF   x89,W
1FCD2:  ADDLW  B4
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8F6
1FCDE:  MOVFF  03,8F7
1FCE2:  MOVFF  03,8F9
1FCE6:  MOVFF  01,8F8
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8F5,FEA
1FCF2:  MOVFF  8F4,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x89,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xF4
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  893,8F4
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xF5
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  892,8F4
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xF5
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  891,8F4
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xF5
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  890,8F4
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xF5
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  88A,8F4
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xF5
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  892,FF8
1FD80:  MOVFF  891,FF7
1FD84:  MOVFF  890,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  94
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  88A,8F4
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  892,FF8
1FD9A:  MOVFF  891,FF7
1FD9E:  MOVFF  890,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  B4
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xF5
1FDAE:  MOVFF  88A,8F4
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xF5
1FDBC:  MOVLW  94
1FDBE:  MOVWF  xF4
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xF7
1FDC4:  MOVLW  B4
1FDC6:  MOVWF  xF6
1FDC8:  MOVFF  88A,8F8
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x85.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x87,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xF9
1FE02:  MOVLW  BD
1FE04:  MOVWF  xF8
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8F4
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xF9
1FE14:  MOVLW  BF
1FE16:  MOVWF  xF8
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8F4,88F
1FE20:  MOVFF  01,88E
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xF4
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  88E,8F4
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xF5
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x85.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x85.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xF4
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xEC
1FE8E:  MOVLB  0
1FE90:  CALL   2910
1FE94:  MOVLB  8
1FE96:  DECFSZ xF4,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... int16 valve_align_timeout = -1; 
.................... int16 valve_align_counter = -1; 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
05554:  BCF    FF2.5
....................    restart_wdt(); 
05556:  CLRWDT
05558:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
0555A:  CLRF   FCF
0555C:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
0555E:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
05560:  MOVF   2F,W
05562:  SUBLW  02
05564:  BNZ   556C
05566:  MOVF   30,F
05568:  BNZ   556C
0556A:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
0556C:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
0556E:  BSF    F9D.0
05570:  GOTO   5584 (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
05574:  MOVLW  0B
05576:  MOVWF  FD7
05578:  MOVLW  DC
0557A:  MOVWF  FD6
....................    restart_wdt(); 
0557C:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
0557E:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
05580:  BSF    FF2.5
....................    setup_led_pulse(); 
05582:  BRA    555A
05584:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
05586:  MOVLB  8
05588:  MOVF   xED,W
0558A:  XORLW  00
0558C:  MOVLB  0
0558E:  BZ    5596
05590:  XORLW  01
05592:  BZ    559A
05594:  BRA    559C
....................       case 0 : suspend_heartbeat(); 
05596:  RCALL  5554
....................          break; 
05598:  BRA    559C
....................       case 1 : restart_heartbeat(); 
0559A:  RCALL  5574
....................          break; 
....................    } 
0559C:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
030F6:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
030F8:  BCF    FD1.0
030FA:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
02900:  MOVLW  0B
02902:  MOVWF  FD7
02904:  MOVLW  DC
02906:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
02908:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
0290A:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
0290C:  BSF    FD1.0
0290E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
07908:  MOVFF  9B1,9B7
0790C:  MOVFF  9B0,9B6
07910:  MOVLB  9
07912:  MOVF   xB4,F
07914:  BNZ   791A
07916:  MOVF   xB5,F
07918:  BZ    7964
0791A:  MOVFF  9B3,03
0791E:  MOVFF  9B2,FE9
07922:  MOVFF  9B3,FEA
07926:  MOVF   FEF,F
07928:  BZ    7964
....................      *s++ = *s2++; 
0792A:  MOVFF  9B7,9B9
0792E:  MOVF   xB6,W
07930:  INCF   xB6,F
07932:  BTFSC  FD8.2
07934:  INCF   xB7,F
07936:  MOVWF  xB8
07938:  MOVFF  9B3,03
0793C:  MOVF   xB2,W
0793E:  INCF   xB2,F
07940:  BTFSC  FD8.2
07942:  INCF   xB3,F
07944:  MOVWF  FE9
07946:  MOVFF  03,FEA
0794A:  MOVFF  FEF,9BA
0794E:  MOVFF  9B9,FEA
07952:  MOVFF  9B8,FE9
07956:  MOVFF  9BA,FEF
0795A:  MOVF   xB4,W
0795C:  BTFSC  FD8.2
0795E:  DECF   xB5,F
07960:  DECF   xB4,F
07962:  BRA    7912
....................   for (; n > 0; n--) 
07964:  MOVF   xB4,F
07966:  BNZ   796C
07968:  MOVF   xB5,F
0796A:  BZ    798A
....................      *s++ = '\0'; 
0796C:  MOVFF  9B7,03
07970:  MOVF   xB6,W
07972:  INCF   xB6,F
07974:  BTFSC  FD8.2
07976:  INCF   xB7,F
07978:  MOVWF  FE9
0797A:  MOVFF  03,FEA
0797E:  CLRF   FEF
07980:  MOVF   xB4,W
07982:  BTFSC  FD8.2
07984:  DECF   xB5,F
07986:  DECF   xB4,F
07988:  BRA    7964
....................  
....................   return(s1); 
0798A:  MOVFF  9B0,01
0798E:  MOVFF  9B1,02
07992:  MOVLB  0
07994:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
054DE:  MOVFF  8F9,8FD
054E2:  MOVFF  8F8,8FC
054E6:  MOVFF  8FD,03
054EA:  MOVLB  8
054EC:  MOVFF  8FC,FE9
054F0:  MOVFF  8FD,FEA
054F4:  MOVF   FEF,F
054F6:  BZ    5504
054F8:  INCF   xFC,F
054FA:  BTFSC  FD8.2
054FC:  INCF   xFD,F
054FE:  MOVLB  0
05500:  BRA    54E6
05502:  MOVLB  8
....................    while(*s2 != '\0') 
05504:  MOVFF  8FB,03
05508:  MOVFF  8FA,FE9
0550C:  MOVFF  8FB,FEA
05510:  MOVF   FEF,F
05512:  BZ    553E
....................    { 
....................       *s = *s2; 
05514:  MOVFF  8FA,FE9
05518:  MOVFF  8FB,FEA
0551C:  MOVFF  FEF,900
05520:  MOVLB  9
05522:  MOVFF  8FD,FEA
05526:  MOVFF  8FC,FE9
0552A:  MOVFF  900,FEF
....................       ++s; 
0552E:  MOVLB  8
05530:  INCF   xFC,F
05532:  BTFSC  FD8.2
05534:  INCF   xFD,F
....................       ++s2; 
05536:  INCF   xFA,F
05538:  BTFSC  FD8.2
0553A:  INCF   xFB,F
0553C:  BRA    5504
....................    } 
....................  
....................    *s = '\0'; 
0553E:  MOVFF  8FC,FE9
05542:  MOVFF  8FD,FEA
05546:  CLRF   FEF
....................    return(s1); 
05548:  MOVFF  8F8,01
0554C:  MOVFF  8F9,02
05550:  MOVLB  0
05552:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12D6C:  MOVFF  8EE,8F4
12D70:  MOVFF  8ED,8F3
12D74:  MOVFF  8F4,03
12D78:  MOVLB  8
12D7A:  MOVFF  8F3,FE9
12D7E:  MOVFF  8F4,FEA
12D82:  MOVF   FEF,F
12D84:  BZ    12D92
12D86:  INCF   xF3,F
12D88:  BTFSC  FD8.2
12D8A:  INCF   xF4,F
12D8C:  MOVLB  0
12D8E:  BRA    12D74
12D90:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12D92:  MOVFF  8F0,03
12D96:  MOVFF  8EF,FE9
12D9A:  MOVFF  8F0,FEA
12D9E:  MOVF   FEF,F
12DA0:  BZ    12DDA
12DA2:  MOVF   xF2,F
12DA4:  BNZ   12DAC
12DA6:  MOVF   xF1,W
12DA8:  SUBLW  00
12DAA:  BC    12DDA
....................    { 
....................       *s = *s2; 
12DAC:  MOVFF  8EF,FE9
12DB0:  MOVFF  8F0,FEA
12DB4:  MOVFF  FEF,8F7
12DB8:  MOVFF  8F4,FEA
12DBC:  MOVFF  8F3,FE9
12DC0:  MOVFF  8F7,FEF
....................       ++s; 
12DC4:  INCF   xF3,F
12DC6:  BTFSC  FD8.2
12DC8:  INCF   xF4,F
....................       ++s2; 
12DCA:  INCF   xEF,F
12DCC:  BTFSC  FD8.2
12DCE:  INCF   xF0,F
....................       --n; 
12DD0:  MOVF   xF1,W
12DD2:  BTFSC  FD8.2
12DD4:  DECF   xF2,F
12DD6:  DECF   xF1,F
12DD8:  BRA    12D92
....................    } 
....................  
....................    *s = '\0'; 
12DDA:  MOVFF  8F3,FE9
12DDE:  MOVFF  8F4,FEA
12DE2:  CLRF   FEF
....................    return(s1); 
12DE4:  MOVFF  8ED,01
12DE8:  MOVFF  8EE,02
12DEC:  MOVLB  0
12DEE:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
0460C:  MOVFF  9EA,9F0
04610:  MOVFF  9E9,9EF
04614:  MOVFF  9EC,9F2
04618:  MOVFF  9EB,9F1
0461C:  MOVLB  9
0461E:  MOVF   xEE,F
04620:  BNZ   4628
04622:  MOVF   xED,W
04624:  SUBLW  00
04626:  BC    4688
.................... { 
....................    if(*su1!=*su2) 
04628:  MOVFF  9EF,FE9
0462C:  MOVFF  9F0,FEA
04630:  MOVFF  FEF,9F3
04634:  MOVFF  9F2,03
04638:  MOVFF  9F1,FE9
0463C:  MOVFF  9F2,FEA
04640:  MOVF   FEF,W
04642:  SUBWF  xF3,W
04644:  BZ    4672
....................       return ((*su1<*su2)?-1:1); 
04646:  MOVFF  9F0,03
0464A:  MOVFF  9EF,FE9
0464E:  MOVFF  03,FEA
04652:  MOVFF  FEF,9F3
04656:  MOVFF  9F2,03
0465A:  MOVFF  9F1,FE9
0465E:  MOVFF  9F2,FEA
04662:  MOVF   FEF,W
04664:  SUBWF  xF3,W
04666:  BC    466C
04668:  MOVLW  FF
0466A:  BRA    466E
0466C:  MOVLW  01
0466E:  MOVWF  01
04670:  BRA    468C
04672:  INCF   xEF,F
04674:  BTFSC  FD8.2
04676:  INCF   xF0,F
04678:  INCF   xF1,F
0467A:  BTFSC  FD8.2
0467C:  INCF   xF2,F
0467E:  MOVF   xED,W
04680:  BTFSC  FD8.2
04682:  DECF   xEE,F
04684:  DECF   xED,F
04686:  BRA    461E
.................... } 
.................... return 0; 
04688:  MOVLW  00
0468A:  MOVWF  01
0468C:  MOVLB  0
0468E:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12D30:  MOVFF  8EC,8EE
12D34:  MOVFF  8EB,8ED
12D38:  MOVFF  8EE,03
12D3C:  MOVLB  8
12D3E:  MOVFF  8ED,FE9
12D42:  MOVFF  8EE,FEA
12D46:  MOVF   FEF,F
12D48:  BZ    12D56
12D4A:  INCF   xED,F
12D4C:  BTFSC  FD8.2
12D4E:  INCF   xEE,F
12D50:  MOVLB  0
12D52:  BRA    12D38
12D54:  MOVLB  8
....................    return(sc - s); 
12D56:  MOVF   xEB,W
12D58:  SUBWF  xED,W
12D5A:  MOVWF  00
12D5C:  MOVF   xEC,W
12D5E:  SUBWFB xEE,W
12D60:  MOVWF  03
12D62:  MOVFF  00,01
12D66:  MOVWF  02
12D68:  MOVLB  0
12D6A:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
133B0:  MOVLB  8
133B2:  CLRF   xDA
....................    sign = 0; 
133B4:  CLRF   xD8
....................    base = 10; 
133B6:  MOVLW  0A
133B8:  MOVWF  xD9
....................    result = 0; 
133BA:  CLRF   xD7
133BC:  CLRF   xD6
....................  
....................    if (!s) 
133BE:  MOVF   xD4,W
133C0:  IORWF  xD5,W
133C2:  BNZ   133CC
....................       return 0; 
133C4:  MOVLW  00
133C6:  MOVWF  01
133C8:  MOVWF  02
133CA:  BRA    13590
....................    c = s[index++]; 
133CC:  MOVF   xDA,W
133CE:  INCF   xDA,F
133D0:  ADDWF  xD4,W
133D2:  MOVWF  FE9
133D4:  MOVLW  00
133D6:  ADDWFC xD5,W
133D8:  MOVWF  FEA
133DA:  MOVFF  FEF,8DB
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
133DE:  MOVF   xDB,W
133E0:  SUBLW  2D
133E2:  BNZ   133FC
....................    { 
....................       sign = 1;         // Set the sign to negative 
133E4:  MOVLW  01
133E6:  MOVWF  xD8
....................       c = s[index++]; 
133E8:  MOVF   xDA,W
133EA:  INCF   xDA,F
133EC:  ADDWF  xD4,W
133EE:  MOVWF  FE9
133F0:  MOVLW  00
133F2:  ADDWFC xD5,W
133F4:  MOVWF  FEA
133F6:  MOVFF  FEF,8DB
....................    } 
133FA:  BRA    13414
....................    else if (c == '+') 
133FC:  MOVF   xDB,W
133FE:  SUBLW  2B
13400:  BNZ   13414
....................    { 
....................       c = s[index++]; 
13402:  MOVF   xDA,W
13404:  INCF   xDA,F
13406:  ADDWF  xD4,W
13408:  MOVWF  FE9
1340A:  MOVLW  00
1340C:  ADDWFC xD5,W
1340E:  MOVWF  FEA
13410:  MOVFF  FEF,8DB
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
13414:  MOVF   xDB,W
13416:  SUBLW  2F
13418:  BTFSC  FD8.0
1341A:  BRA    13574
1341C:  MOVF   xDB,W
1341E:  SUBLW  39
13420:  BTFSS  FD8.0
13422:  BRA    13574
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
13424:  MOVF   xDB,W
13426:  SUBLW  30
13428:  BNZ   13466
1342A:  MOVF   xDA,W
1342C:  ADDWF  xD4,W
1342E:  MOVWF  FE9
13430:  MOVLW  00
13432:  ADDWFC xD5,W
13434:  MOVWF  FEA
13436:  MOVF   FEF,W
13438:  SUBLW  78
1343A:  BZ    1344E
1343C:  MOVF   xDA,W
1343E:  ADDWF  xD4,W
13440:  MOVWF  FE9
13442:  MOVLW  00
13444:  ADDWFC xD5,W
13446:  MOVWF  FEA
13448:  MOVF   FEF,W
1344A:  SUBLW  58
1344C:  BNZ   13466
....................       { 
....................          base = 16; 
1344E:  MOVLW  10
13450:  MOVWF  xD9
....................          index++; 
13452:  INCF   xDA,F
....................          c = s[index++]; 
13454:  MOVF   xDA,W
13456:  INCF   xDA,F
13458:  ADDWF  xD4,W
1345A:  MOVWF  FE9
1345C:  MOVLW  00
1345E:  ADDWFC xD5,W
13460:  MOVWF  FEA
13462:  MOVFF  FEF,8DB
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
13466:  MOVF   xD9,W
13468:  SUBLW  0A
1346A:  BNZ   134B0
....................       { 
....................          while (c >= '0' && c <= '9') 
1346C:  MOVF   xDB,W
1346E:  SUBLW  2F
13470:  BC    134AE
13472:  MOVF   xDB,W
13474:  SUBLW  39
13476:  BNC   134AE
....................          { 
....................             result = 10*result + (c - '0'); 
13478:  CLRF   xDD
1347A:  MOVLW  0A
1347C:  MOVWF  xDC
1347E:  MOVFF  8D7,8DF
13482:  MOVFF  8D6,8DE
13486:  MOVLB  0
13488:  BRA    1335A
1348A:  MOVLW  30
1348C:  MOVLB  8
1348E:  SUBWF  xDB,W
13490:  ADDWF  01,W
13492:  MOVWF  xD6
13494:  MOVLW  00
13496:  ADDWFC 02,W
13498:  MOVWF  xD7
....................             c = s[index++]; 
1349A:  MOVF   xDA,W
1349C:  INCF   xDA,F
1349E:  ADDWF  xD4,W
134A0:  MOVWF  FE9
134A2:  MOVLW  00
134A4:  ADDWFC xD5,W
134A6:  MOVWF  FEA
134A8:  MOVFF  FEF,8DB
134AC:  BRA    1346C
....................          } 
....................       } 
134AE:  BRA    13574
....................       else if (base == 16)    // The number is a hexa number 
134B0:  MOVF   xD9,W
134B2:  SUBLW  10
134B4:  BNZ   13574
....................       { 
....................          c = toupper(c); 
134B6:  MOVF   xDB,W
134B8:  SUBLW  60
134BA:  BC    134C8
134BC:  MOVF   xDB,W
134BE:  SUBLW  7A
134C0:  BNC   134C8
134C2:  MOVF   xDB,W
134C4:  ANDLW  DF
134C6:  BRA    134CA
134C8:  MOVF   xDB,W
134CA:  MOVWF  xDB
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
134CC:  MOVF   xDB,W
134CE:  SUBLW  2F
134D0:  BC    134D8
134D2:  MOVF   xDB,W
134D4:  SUBLW  39
134D6:  BC    134E4
134D8:  MOVF   xDB,W
134DA:  SUBLW  40
134DC:  BC    13574
134DE:  MOVF   xDB,W
134E0:  SUBLW  46
134E2:  BNC   13574
....................          { 
....................             if (c >= '0' && c <= '9') 
134E4:  MOVF   xDB,W
134E6:  SUBLW  2F
134E8:  BC    1351E
134EA:  MOVF   xDB,W
134EC:  SUBLW  39
134EE:  BNC   1351E
....................                result = (result << 4) + (c - '0'); 
134F0:  RLCF   xD6,W
134F2:  MOVWF  xDC
134F4:  RLCF   xD7,W
134F6:  MOVWF  xDD
134F8:  RLCF   xDC,F
134FA:  RLCF   xDD,F
134FC:  RLCF   xDC,F
134FE:  RLCF   xDD,F
13500:  RLCF   xDC,F
13502:  RLCF   xDD,F
13504:  MOVLW  F0
13506:  ANDWF  xDC,F
13508:  MOVLW  30
1350A:  SUBWF  xDB,W
1350C:  ADDWF  xDC,W
1350E:  MOVWF  01
13510:  MOVLW  00
13512:  ADDWFC xDD,W
13514:  MOVWF  03
13516:  MOVFF  01,8D6
1351A:  MOVWF  xD7
1351C:  BRA    1354A
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
1351E:  RLCF   xD6,W
13520:  MOVWF  xDC
13522:  RLCF   xD7,W
13524:  MOVWF  xDD
13526:  RLCF   xDC,F
13528:  RLCF   xDD,F
1352A:  RLCF   xDC,F
1352C:  RLCF   xDD,F
1352E:  RLCF   xDC,F
13530:  RLCF   xDD,F
13532:  MOVLW  F0
13534:  ANDWF  xDC,F
13536:  MOVLW  41
13538:  SUBWF  xDB,W
1353A:  ADDLW  0A
1353C:  ADDWF  xDC,W
1353E:  MOVWF  01
13540:  MOVLW  00
13542:  ADDWFC xDD,W
13544:  MOVFF  01,8D6
13548:  MOVWF  xD7
....................  
....................             c = s[index++];c = toupper(c); 
1354A:  MOVF   xDA,W
1354C:  INCF   xDA,F
1354E:  ADDWF  xD4,W
13550:  MOVWF  FE9
13552:  MOVLW  00
13554:  ADDWFC xD5,W
13556:  MOVWF  FEA
13558:  MOVFF  FEF,8DB
1355C:  MOVF   xDB,W
1355E:  SUBLW  60
13560:  BC    1356E
13562:  MOVF   xDB,W
13564:  SUBLW  7A
13566:  BNC   1356E
13568:  MOVF   xDB,W
1356A:  ANDLW  DF
1356C:  BRA    13570
1356E:  MOVF   xDB,W
13570:  MOVWF  xDB
13572:  BRA    134CC
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
13574:  MOVF   xD9,W
13576:  SUBLW  0A
13578:  BNZ   13588
1357A:  DECFSZ xD8,W
1357C:  BRA    13588
....................       result = -result; 
1357E:  COMF   xD6,F
13580:  COMF   xD7,F
13582:  INCF   xD6,F
13584:  BTFSC  FD8.2
13586:  INCF   xD7,F
....................  
....................    return(result); 
13588:  MOVFF  8D6,01
1358C:  MOVFF  8D7,02
13590:  MOVLB  0
13592:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0AE84:  MOVLB  8
0AE86:  CLRF   x8D
....................    sign = 0; 
0AE88:  CLRF   x8B
....................    base = 10; 
0AE8A:  MOVLW  0A
0AE8C:  MOVWF  x8C
....................    result = 0; 
0AE8E:  CLRF   x8A
0AE90:  CLRF   x89
0AE92:  CLRF   x88
0AE94:  CLRF   x87
....................  
....................    if (!s) 
0AE96:  MOVF   x85,W
0AE98:  IORWF  x86,W
0AE9A:  BNZ   AEA6
....................       return 0; 
0AE9C:  CLRF   00
0AE9E:  CLRF   01
0AEA0:  CLRF   02
0AEA2:  CLRF   03
0AEA4:  BRA    B114
....................    c = s[index++]; 
0AEA6:  MOVF   x8D,W
0AEA8:  INCF   x8D,F
0AEAA:  ADDWF  x85,W
0AEAC:  MOVWF  FE9
0AEAE:  MOVLW  00
0AEB0:  ADDWFC x86,W
0AEB2:  MOVWF  FEA
0AEB4:  MOVFF  FEF,88E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0AEB8:  MOVF   x8E,W
0AEBA:  SUBLW  2D
0AEBC:  BNZ   AED6
....................    { 
....................       sign = 1;         // Set the sign to negative 
0AEBE:  MOVLW  01
0AEC0:  MOVWF  x8B
....................       c = s[index++]; 
0AEC2:  MOVF   x8D,W
0AEC4:  INCF   x8D,F
0AEC6:  ADDWF  x85,W
0AEC8:  MOVWF  FE9
0AECA:  MOVLW  00
0AECC:  ADDWFC x86,W
0AECE:  MOVWF  FEA
0AED0:  MOVFF  FEF,88E
....................    } 
0AED4:  BRA    AEEE
....................    else if (c == '+') 
0AED6:  MOVF   x8E,W
0AED8:  SUBLW  2B
0AEDA:  BNZ   AEEE
....................    { 
....................       c = s[index++]; 
0AEDC:  MOVF   x8D,W
0AEDE:  INCF   x8D,F
0AEE0:  ADDWF  x85,W
0AEE2:  MOVWF  FE9
0AEE4:  MOVLW  00
0AEE6:  ADDWFC x86,W
0AEE8:  MOVWF  FEA
0AEEA:  MOVFF  FEF,88E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0AEEE:  MOVF   x8E,W
0AEF0:  SUBLW  2F
0AEF2:  BTFSC  FD8.0
0AEF4:  BRA    B0E4
0AEF6:  MOVF   x8E,W
0AEF8:  SUBLW  39
0AEFA:  BTFSS  FD8.0
0AEFC:  BRA    B0E4
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0AEFE:  MOVF   x8E,W
0AF00:  SUBLW  30
0AF02:  BNZ   AF40
0AF04:  MOVF   x8D,W
0AF06:  ADDWF  x85,W
0AF08:  MOVWF  FE9
0AF0A:  MOVLW  00
0AF0C:  ADDWFC x86,W
0AF0E:  MOVWF  FEA
0AF10:  MOVF   FEF,W
0AF12:  SUBLW  78
0AF14:  BZ    AF28
0AF16:  MOVF   x8D,W
0AF18:  ADDWF  x85,W
0AF1A:  MOVWF  FE9
0AF1C:  MOVLW  00
0AF1E:  ADDWFC x86,W
0AF20:  MOVWF  FEA
0AF22:  MOVF   FEF,W
0AF24:  SUBLW  58
0AF26:  BNZ   AF40
....................       { 
....................          base = 16; 
0AF28:  MOVLW  10
0AF2A:  MOVWF  x8C
....................          index++; 
0AF2C:  INCF   x8D,F
....................          c = s[index++]; 
0AF2E:  MOVF   x8D,W
0AF30:  INCF   x8D,F
0AF32:  ADDWF  x85,W
0AF34:  MOVWF  FE9
0AF36:  MOVLW  00
0AF38:  ADDWFC x86,W
0AF3A:  MOVWF  FEA
0AF3C:  MOVFF  FEF,88E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0AF40:  MOVF   x8C,W
0AF42:  SUBLW  0A
0AF44:  BNZ   AFCC
....................       { 
....................          while (c >= '0' && c <= '9') { 
0AF46:  MOVF   x8E,W
0AF48:  SUBLW  2F
0AF4A:  BC    AFCA
0AF4C:  MOVF   x8E,W
0AF4E:  SUBLW  39
0AF50:  BNC   AFCA
....................             result = (result << 1) + (result << 3);  // result *= 10; 
0AF52:  BCF    FD8.0
0AF54:  RLCF   x87,W
0AF56:  MOVWF  x90
0AF58:  RLCF   x88,W
0AF5A:  MOVWF  x91
0AF5C:  RLCF   x89,W
0AF5E:  MOVWF  x92
0AF60:  RLCF   x8A,W
0AF62:  MOVWF  x93
0AF64:  RLCF   x87,W
0AF66:  MOVWF  00
0AF68:  RLCF   x88,W
0AF6A:  MOVWF  01
0AF6C:  RLCF   x89,W
0AF6E:  MOVWF  02
0AF70:  RLCF   x8A,W
0AF72:  MOVWF  03
0AF74:  RLCF   00,F
0AF76:  RLCF   01,F
0AF78:  RLCF   02,F
0AF7A:  RLCF   03,F
0AF7C:  RLCF   00,F
0AF7E:  RLCF   01,F
0AF80:  RLCF   02,F
0AF82:  RLCF   03,F
0AF84:  MOVLW  F8
0AF86:  ANDWF  00,F
0AF88:  MOVF   x90,W
0AF8A:  ADDWF  00,F
0AF8C:  MOVF   x91,W
0AF8E:  ADDWFC 01,F
0AF90:  MOVF   x92,W
0AF92:  ADDWFC 02,F
0AF94:  MOVF   x93,W
0AF96:  ADDWFC 03,F
0AF98:  MOVFF  03,88A
0AF9C:  MOVFF  02,889
0AFA0:  MOVFF  01,888
0AFA4:  MOVFF  00,887
....................             result += (c - '0'); 
0AFA8:  MOVLW  30
0AFAA:  SUBWF  x8E,W
0AFAC:  ADDWF  x87,F
0AFAE:  MOVLW  00
0AFB0:  ADDWFC x88,F
0AFB2:  ADDWFC x89,F
0AFB4:  ADDWFC x8A,F
....................             c = s[index++]; 
0AFB6:  MOVF   x8D,W
0AFB8:  INCF   x8D,F
0AFBA:  ADDWF  x85,W
0AFBC:  MOVWF  FE9
0AFBE:  MOVLW  00
0AFC0:  ADDWFC x86,W
0AFC2:  MOVWF  FEA
0AFC4:  MOVFF  FEF,88E
0AFC8:  BRA    AF46
....................          } 
....................       } 
0AFCA:  BRA    B0E4
....................       else if (base == 16)    // The number is a hexa number 
0AFCC:  MOVF   x8C,W
0AFCE:  SUBLW  10
0AFD0:  BTFSS  FD8.2
0AFD2:  BRA    B0E4
....................       { 
....................          c = toupper(c); 
0AFD4:  MOVF   x8E,W
0AFD6:  SUBLW  60
0AFD8:  BC    AFE6
0AFDA:  MOVF   x8E,W
0AFDC:  SUBLW  7A
0AFDE:  BNC   AFE6
0AFE0:  MOVF   x8E,W
0AFE2:  ANDLW  DF
0AFE4:  BRA    AFE8
0AFE6:  MOVF   x8E,W
0AFE8:  MOVWF  x8E
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0AFEA:  MOVF   x8E,W
0AFEC:  SUBLW  2F
0AFEE:  BC    AFF6
0AFF0:  MOVF   x8E,W
0AFF2:  SUBLW  39
0AFF4:  BC    B004
0AFF6:  MOVF   x8E,W
0AFF8:  SUBLW  40
0AFFA:  BTFSC  FD8.0
0AFFC:  BRA    B0E4
0AFFE:  MOVF   x8E,W
0B000:  SUBLW  46
0B002:  BNC   B0E4
....................          { 
....................             if (c >= '0' && c <= '9') 
0B004:  MOVF   x8E,W
0B006:  SUBLW  2F
0B008:  BC    B066
0B00A:  MOVF   x8E,W
0B00C:  SUBLW  39
0B00E:  BNC   B066
....................                result = (result << 4) + (c - '0'); 
0B010:  RLCF   x87,W
0B012:  MOVWF  x90
0B014:  RLCF   x88,W
0B016:  MOVWF  x91
0B018:  RLCF   x89,W
0B01A:  MOVWF  x92
0B01C:  RLCF   x8A,W
0B01E:  MOVWF  x93
0B020:  RLCF   x90,F
0B022:  RLCF   x91,F
0B024:  RLCF   x92,F
0B026:  RLCF   x93,F
0B028:  RLCF   x90,F
0B02A:  RLCF   x91,F
0B02C:  RLCF   x92,F
0B02E:  RLCF   x93,F
0B030:  RLCF   x90,F
0B032:  RLCF   x91,F
0B034:  RLCF   x92,F
0B036:  RLCF   x93,F
0B038:  MOVLW  F0
0B03A:  ANDWF  x90,F
0B03C:  MOVLW  30
0B03E:  SUBWF  x8E,W
0B040:  ADDWF  x90,W
0B042:  MOVWF  00
0B044:  MOVLW  00
0B046:  ADDWFC x91,W
0B048:  MOVWF  01
0B04A:  MOVLW  00
0B04C:  ADDWFC x92,W
0B04E:  MOVWF  02
0B050:  MOVLW  00
0B052:  ADDWFC x93,W
0B054:  MOVWF  03
0B056:  MOVWF  x8A
0B058:  MOVFF  02,889
0B05C:  MOVFF  01,888
0B060:  MOVFF  00,887
0B064:  BRA    B0BA
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B066:  RLCF   x87,W
0B068:  MOVWF  x90
0B06A:  RLCF   x88,W
0B06C:  MOVWF  x91
0B06E:  RLCF   x89,W
0B070:  MOVWF  x92
0B072:  RLCF   x8A,W
0B074:  MOVWF  x93
0B076:  RLCF   x90,F
0B078:  RLCF   x91,F
0B07A:  RLCF   x92,F
0B07C:  RLCF   x93,F
0B07E:  RLCF   x90,F
0B080:  RLCF   x91,F
0B082:  RLCF   x92,F
0B084:  RLCF   x93,F
0B086:  RLCF   x90,F
0B088:  RLCF   x91,F
0B08A:  RLCF   x92,F
0B08C:  RLCF   x93,F
0B08E:  MOVLW  F0
0B090:  ANDWF  x90,F
0B092:  MOVLW  41
0B094:  SUBWF  x8E,W
0B096:  ADDLW  0A
0B098:  ADDWF  x90,W
0B09A:  MOVWF  00
0B09C:  MOVLW  00
0B09E:  ADDWFC x91,W
0B0A0:  MOVWF  01
0B0A2:  MOVLW  00
0B0A4:  ADDWFC x92,W
0B0A6:  MOVWF  02
0B0A8:  MOVLW  00
0B0AA:  ADDWFC x93,W
0B0AC:  MOVWF  x8A
0B0AE:  MOVFF  02,889
0B0B2:  MOVFF  01,888
0B0B6:  MOVFF  00,887
....................  
....................             c = s[index++];c = toupper(c); 
0B0BA:  MOVF   x8D,W
0B0BC:  INCF   x8D,F
0B0BE:  ADDWF  x85,W
0B0C0:  MOVWF  FE9
0B0C2:  MOVLW  00
0B0C4:  ADDWFC x86,W
0B0C6:  MOVWF  FEA
0B0C8:  MOVFF  FEF,88E
0B0CC:  MOVF   x8E,W
0B0CE:  SUBLW  60
0B0D0:  BC    B0DE
0B0D2:  MOVF   x8E,W
0B0D4:  SUBLW  7A
0B0D6:  BNC   B0DE
0B0D8:  MOVF   x8E,W
0B0DA:  ANDLW  DF
0B0DC:  BRA    B0E0
0B0DE:  MOVF   x8E,W
0B0E0:  MOVWF  x8E
0B0E2:  BRA    AFEA
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0B0E4:  MOVF   x8C,W
0B0E6:  SUBLW  0A
0B0E8:  BNZ   B104
0B0EA:  DECFSZ x8B,W
0B0EC:  BRA    B104
....................       result = -result; 
0B0EE:  COMF   x87,F
0B0F0:  COMF   x88,F
0B0F2:  COMF   x89,F
0B0F4:  COMF   x8A,F
0B0F6:  INCF   x87,F
0B0F8:  BTFSC  FD8.2
0B0FA:  INCF   x88,F
0B0FC:  BTFSC  FD8.2
0B0FE:  INCF   x89,F
0B100:  BTFSC  FD8.2
0B102:  INCF   x8A,F
....................  
....................    return(result); 
0B104:  MOVFF  887,00
0B108:  MOVFF  888,01
0B10C:  MOVFF  889,02
0B110:  MOVFF  88A,03
0B114:  MOVLB  0
0B116:  GOTO   1B5CA (RETURN)
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0CA6E:  MOVLB  8
0CA70:  CLRF   xA4
0CA72:  CLRF   xA3
0CA74:  CLRF   xA2
0CA76:  MOVLW  7F
0CA78:  MOVWF  xA1
0CA7A:  CLRF   xA8
0CA7C:  CLRF   xA7
0CA7E:  CLRF   xA6
0CA80:  CLRF   xA5
0CA82:  BSF    xA9.0
0CA84:  BCF    xA9.1
0CA86:  BCF    xA9.2
0CA88:  CLRF   xAB
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0CA8A:  MOVF   x9D,W
0CA8C:  IORWF  x9E,W
0CA8E:  BNZ   CA9A
....................       return 0; 
0CA90:  CLRF   00
0CA92:  CLRF   01
0CA94:  CLRF   02
0CA96:  CLRF   03
0CA98:  BRA    CCC4
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0CA9A:  MOVF   xAB,W
0CA9C:  INCF   xAB,F
0CA9E:  ADDWF  x9D,W
0CAA0:  MOVWF  FE9
0CAA2:  MOVLW  00
0CAA4:  ADDWFC x9E,W
0CAA6:  MOVWF  FEA
0CAA8:  MOVFF  FEF,8AA
0CAAC:  MOVF   xAA,F
0CAAE:  BTFSC  FD8.2
0CAB0:  BRA    CC46
....................    { 
....................       if (skip && !isspace(c)) 
0CAB2:  BTFSS  xA9.0
0CAB4:  BRA    CAD4
0CAB6:  MOVF   xAA,W
0CAB8:  SUBLW  20
0CABA:  BZ    CAD4
....................       { 
....................          skip = 0; 
0CABC:  BCF    xA9.0
....................          if (c == '+') 
0CABE:  MOVF   xAA,W
0CAC0:  SUBLW  2B
0CAC2:  BNZ   CACA
....................          { 
....................             sign = 0; 
0CAC4:  BCF    xA9.1
....................             continue; 
0CAC6:  BRA    CC2E
....................          }             
0CAC8:  BRA    CAD4
....................          else if (c == '-') 
0CACA:  MOVF   xAA,W
0CACC:  SUBLW  2D
0CACE:  BNZ   CAD4
....................          { 
....................             sign = 1; 
0CAD0:  BSF    xA9.1
....................             continue; 
0CAD2:  BRA    CC2E
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0CAD4:  BTFSC  xA9.0
0CAD6:  BRA    CAE6
0CAD8:  MOVF   xAA,W
0CADA:  SUBLW  2E
0CADC:  BNZ   CAE6
0CADE:  BTFSC  xA9.2
0CAE0:  BRA    CAE6
....................          point = 1; 
0CAE2:  BSF    xA9.2
0CAE4:  BRA    CC2E
....................       else if (!skip && isdigit(c)) 
0CAE6:  BTFSC  xA9.0
0CAE8:  BRA    CC28
0CAEA:  MOVF   xAA,W
0CAEC:  SUBLW  2F
0CAEE:  BTFSC  FD8.0
0CAF0:  BRA    CC28
0CAF2:  MOVF   xAA,W
0CAF4:  SUBLW  39
0CAF6:  BTFSS  FD8.0
0CAF8:  BRA    CC28
....................       { 
....................          c -= '0'; 
0CAFA:  MOVLW  30
0CAFC:  SUBWF  xAA,F
....................          if (point) 
0CAFE:  BTFSS  xA9.2
0CB00:  BRA    CBAE
....................          { 
....................             pow10 = pow10 * 10.0; 
0CB02:  MOVFF  8A4,916
0CB06:  MOVFF  8A3,915
0CB0A:  MOVFF  8A2,914
0CB0E:  MOVFF  8A1,913
0CB12:  MOVLB  9
0CB14:  CLRF   x1A
0CB16:  CLRF   x19
0CB18:  MOVLW  20
0CB1A:  MOVWF  x18
0CB1C:  MOVLW  82
0CB1E:  MOVWF  x17
0CB20:  MOVLB  0
0CB22:  CALL   C288
0CB26:  MOVFF  03,8A4
0CB2A:  MOVFF  02,8A3
0CB2E:  MOVFF  01,8A2
0CB32:  MOVFF  00,8A1
....................             result += (float)c / pow10;    
0CB36:  MOVLB  9
0CB38:  CLRF   x18
0CB3A:  MOVFF  8AA,917
0CB3E:  MOVLB  0
0CB40:  RCALL  C8BA
0CB42:  MOVFF  03,8AF
0CB46:  MOVFF  02,8AE
0CB4A:  MOVFF  01,8AD
0CB4E:  MOVFF  00,8AC
0CB52:  MOVFF  03,8FE
0CB56:  MOVFF  02,8FD
0CB5A:  MOVFF  01,8FC
0CB5E:  MOVFF  00,8FB
0CB62:  MOVFF  8A4,902
0CB66:  MOVFF  8A3,901
0CB6A:  MOVFF  8A2,900
0CB6E:  MOVFF  8A1,8FF
0CB72:  RCALL  C8F0
0CB74:  BCF    FD8.1
0CB76:  MOVFF  8A8,91A
0CB7A:  MOVFF  8A7,919
0CB7E:  MOVFF  8A6,918
0CB82:  MOVFF  8A5,917
0CB86:  MOVFF  03,91E
0CB8A:  MOVFF  02,91D
0CB8E:  MOVFF  01,91C
0CB92:  MOVFF  00,91B
0CB96:  CALL   C37E
0CB9A:  MOVFF  03,8A8
0CB9E:  MOVFF  02,8A7
0CBA2:  MOVFF  01,8A6
0CBA6:  MOVFF  00,8A5
....................          } 
0CBAA:  BRA    CC24
0CBAC:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0CBAE:  MOVLB  9
0CBB0:  CLRF   x16
0CBB2:  CLRF   x15
0CBB4:  MOVLW  20
0CBB6:  MOVWF  x14
0CBB8:  MOVLW  82
0CBBA:  MOVWF  x13
0CBBC:  MOVFF  8A8,91A
0CBC0:  MOVFF  8A7,919
0CBC4:  MOVFF  8A6,918
0CBC8:  MOVFF  8A5,917
0CBCC:  MOVLB  0
0CBCE:  CALL   C288
0CBD2:  MOVFF  03,8AF
0CBD6:  MOVFF  02,8AE
0CBDA:  MOVFF  01,8AD
0CBDE:  MOVFF  00,8AC
0CBE2:  MOVLB  9
0CBE4:  CLRF   x18
0CBE6:  MOVFF  8AA,917
0CBEA:  MOVLB  0
0CBEC:  RCALL  C8BA
0CBEE:  BCF    FD8.1
0CBF0:  MOVFF  8AF,91A
0CBF4:  MOVFF  8AE,919
0CBF8:  MOVFF  8AD,918
0CBFC:  MOVFF  8AC,917
0CC00:  MOVFF  03,91E
0CC04:  MOVFF  02,91D
0CC08:  MOVFF  01,91C
0CC0C:  MOVFF  00,91B
0CC10:  CALL   C37E
0CC14:  MOVFF  03,8A8
0CC18:  MOVFF  02,8A7
0CC1C:  MOVFF  01,8A6
0CC20:  MOVFF  00,8A5
....................          } 
....................       } 
0CC24:  BRA    CC30
0CC26:  MOVLB  8
....................       else if (!skip) 
0CC28:  BTFSC  xA9.0
0CC2A:  BRA    CC2E
....................          break; 
0CC2C:  BRA    CC46
0CC2E:  MOVLB  0
0CC30:  MOVLB  8
0CC32:  MOVF   xAB,W
0CC34:  INCF   xAB,F
0CC36:  ADDWF  x9D,W
0CC38:  MOVWF  FE9
0CC3A:  MOVLW  00
0CC3C:  ADDWFC x9E,W
0CC3E:  MOVWF  FEA
0CC40:  MOVFF  FEF,8AA
0CC44:  BRA    CAAC
....................    } 
....................  
....................    if (sign) 
0CC46:  BTFSS  xA9.1
0CC48:  BRA    CC80
....................       result = -1*result; 
0CC4A:  MOVLB  9
0CC4C:  CLRF   x16
0CC4E:  CLRF   x15
0CC50:  MOVLW  80
0CC52:  MOVWF  x14
0CC54:  MOVLW  7F
0CC56:  MOVWF  x13
0CC58:  MOVFF  8A8,91A
0CC5C:  MOVFF  8A7,919
0CC60:  MOVFF  8A6,918
0CC64:  MOVFF  8A5,917
0CC68:  MOVLB  0
0CC6A:  CALL   C288
0CC6E:  MOVFF  03,8A8
0CC72:  MOVFF  02,8A7
0CC76:  MOVFF  01,8A6
0CC7A:  MOVFF  00,8A5
0CC7E:  MOVLB  8
....................        
....................    if(endptr) 
0CC80:  MOVF   x9F,W
0CC82:  IORWF  xA0,W
0CC84:  BZ    CCB4
....................    { 
....................       if (ptr) { 
0CC86:  MOVF   xAB,F
0CC88:  BZ    CCA2
....................          ptr--; 
0CC8A:  DECF   xAB,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0CC8C:  MOVFF  89F,FE9
0CC90:  MOVFF  8A0,FEA
0CC94:  MOVF   xAB,W
0CC96:  ADDWF  x9D,W
0CC98:  MOVWF  FEF
0CC9A:  MOVLW  00
0CC9C:  ADDWFC x9E,W
0CC9E:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0CCA0:  BRA    CCB4
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0CCA2:  MOVFF  89F,FE9
0CCA6:  MOVFF  8A0,FEA
0CCAA:  MOVFF  89E,FEC
0CCAE:  MOVF   FED,F
0CCB0:  MOVFF  89D,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0CCB4:  MOVFF  8A5,00
0CCB8:  MOVFF  8A6,01
0CCBC:  MOVFF  8A7,02
0CCC0:  MOVFF  8A8,03
0CCC4:  MOVLB  0
0CCC6:  GOTO   CCEE (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
12806:  MOVLB  9
12808:  BCF    x12.0
....................    y = x; 
1280A:  MOVFF  906,90B
1280E:  MOVFF  905,90A
12812:  MOVFF  904,909
12816:  MOVFF  903,908
....................  
....................    if (x < 0) 
1281A:  MOVFF  906,916
1281E:  MOVFF  905,915
12822:  MOVFF  904,914
12826:  MOVFF  903,913
1282A:  CLRF   x1A
1282C:  CLRF   x19
1282E:  CLRF   x18
12830:  CLRF   x17
12832:  MOVLB  0
12834:  CALL   10730
12838:  BNC   12846
....................    { 
....................       s = 1; 
1283A:  MOVLB  9
1283C:  BSF    x12.0
....................       y = -y; 
1283E:  MOVF   x09,W
12840:  XORLW  80
12842:  MOVWF  x09
12844:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
12846:  MOVFF  90B,916
1284A:  MOVFF  90A,915
1284E:  MOVFF  909,914
12852:  MOVFF  908,913
12856:  MOVLB  9
12858:  CLRF   x1A
1285A:  CLRF   x19
1285C:  CLRF   x18
1285E:  MOVLW  8E
12860:  MOVWF  x17
12862:  MOVLB  0
12864:  CALL   10730
12868:  BC    1286C
1286A:  BNZ   1289C
....................       res = (float32)(unsigned int16)y; 
1286C:  MOVFF  90B,916
12870:  MOVFF  90A,915
12874:  MOVFF  909,914
12878:  MOVFF  908,913
1287C:  RCALL  127CA
1287E:  MOVFF  02,918
12882:  MOVFF  01,917
12886:  CALL   C8BA
1288A:  MOVFF  03,90F
1288E:  MOVFF  02,90E
12892:  MOVFF  01,90D
12896:  MOVFF  00,90C
1289A:  BRA    12A3E
....................  
....................  else if (y < 10000000.0) 
1289C:  MOVFF  90B,916
128A0:  MOVFF  90A,915
128A4:  MOVFF  909,914
128A8:  MOVFF  908,913
128AC:  MOVLW  80
128AE:  MOVLB  9
128B0:  MOVWF  x1A
128B2:  MOVLW  96
128B4:  MOVWF  x19
128B6:  MOVLW  18
128B8:  MOVWF  x18
128BA:  MOVLW  96
128BC:  MOVWF  x17
128BE:  MOVLB  0
128C0:  CALL   10730
128C4:  BTFSS  FD8.0
128C6:  BRA    12A2E
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
128C8:  MOVFF  90B,916
128CC:  MOVFF  90A,915
128D0:  MOVFF  909,914
128D4:  MOVFF  908,913
128D8:  MOVLB  9
128DA:  CLRF   x1A
128DC:  CLRF   x19
128DE:  CLRF   x18
128E0:  MOVLW  70
128E2:  MOVWF  x17
128E4:  MOVLB  0
128E6:  CALL   C288
128EA:  MOVFF  03,916
128EE:  MOVFF  02,915
128F2:  MOVFF  01,914
128F6:  MOVFF  00,913
128FA:  RCALL  127CA
128FC:  MOVFF  02,911
12900:  MOVFF  01,910
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
12904:  MOVFF  90B,916
12908:  MOVFF  90A,915
1290C:  MOVFF  909,914
12910:  MOVFF  908,913
12914:  MOVLB  9
12916:  CLRF   x1A
12918:  CLRF   x19
1291A:  CLRF   x18
1291C:  MOVLW  70
1291E:  MOVWF  x17
12920:  MOVLB  0
12922:  CALL   C288
12926:  MOVFF  03,916
1292A:  MOVFF  02,915
1292E:  MOVFF  01,914
12932:  MOVFF  00,913
12936:  MOVFF  911,918
1293A:  MOVFF  910,917
1293E:  CALL   C8BA
12942:  BSF    FD8.1
12944:  MOVFF  916,91A
12948:  MOVFF  915,919
1294C:  MOVFF  914,918
12950:  MOVFF  913,917
12954:  MOVFF  03,91E
12958:  MOVFF  02,91D
1295C:  MOVFF  01,91C
12960:  MOVFF  00,91B
12964:  CALL   C37E
12968:  MOVLB  9
1296A:  CLRF   x16
1296C:  CLRF   x15
1296E:  CLRF   x14
12970:  MOVLW  8E
12972:  MOVWF  x13
12974:  MOVFF  03,91A
12978:  MOVFF  02,919
1297C:  MOVFF  01,918
12980:  MOVFF  00,917
12984:  MOVLB  0
12986:  CALL   C288
1298A:  MOVFF  03,90B
1298E:  MOVFF  02,90A
12992:  MOVFF  01,909
12996:  MOVFF  00,908
....................       res = 32768.0*(float32)l; 
1299A:  MOVFF  911,918
1299E:  MOVFF  910,917
129A2:  CALL   C8BA
129A6:  MOVLB  9
129A8:  CLRF   x16
129AA:  CLRF   x15
129AC:  CLRF   x14
129AE:  MOVLW  8E
129B0:  MOVWF  x13
129B2:  MOVFF  03,91A
129B6:  MOVFF  02,919
129BA:  MOVFF  01,918
129BE:  MOVFF  00,917
129C2:  MOVLB  0
129C4:  CALL   C288
129C8:  MOVFF  03,90F
129CC:  MOVFF  02,90E
129D0:  MOVFF  01,90D
129D4:  MOVFF  00,90C
....................       res += (float32)(unsigned int16)y; 
129D8:  MOVFF  90B,916
129DC:  MOVFF  90A,915
129E0:  MOVFF  909,914
129E4:  MOVFF  908,913
129E8:  RCALL  127CA
129EA:  MOVFF  02,918
129EE:  MOVFF  01,917
129F2:  CALL   C8BA
129F6:  BCF    FD8.1
129F8:  MOVFF  90F,91A
129FC:  MOVFF  90E,919
12A00:  MOVFF  90D,918
12A04:  MOVFF  90C,917
12A08:  MOVFF  03,91E
12A0C:  MOVFF  02,91D
12A10:  MOVFF  01,91C
12A14:  MOVFF  00,91B
12A18:  CALL   C37E
12A1C:  MOVFF  03,90F
12A20:  MOVFF  02,90E
12A24:  MOVFF  01,90D
12A28:  MOVFF  00,90C
....................    } 
12A2C:  BRA    12A3E
....................  
....................  else 
....................   res = y; 
12A2E:  MOVFF  90B,90F
12A32:  MOVFF  90A,90E
12A36:  MOVFF  909,90D
12A3A:  MOVFF  908,90C
....................  
....................  y = y - (float32)(unsigned int16)y; 
12A3E:  MOVFF  90B,916
12A42:  MOVFF  90A,915
12A46:  MOVFF  909,914
12A4A:  MOVFF  908,913
12A4E:  RCALL  127CA
12A50:  MOVFF  02,918
12A54:  MOVFF  01,917
12A58:  CALL   C8BA
12A5C:  BSF    FD8.1
12A5E:  MOVFF  90B,91A
12A62:  MOVFF  90A,919
12A66:  MOVFF  909,918
12A6A:  MOVFF  908,917
12A6E:  MOVFF  03,91E
12A72:  MOVFF  02,91D
12A76:  MOVFF  01,91C
12A7A:  MOVFF  00,91B
12A7E:  CALL   C37E
12A82:  MOVFF  03,90B
12A86:  MOVFF  02,90A
12A8A:  MOVFF  01,909
12A8E:  MOVFF  00,908
....................  
....................  if (s) 
12A92:  MOVLB  9
12A94:  BTFSS  x12.0
12A96:  BRA    12A9E
....................   res = -res; 
12A98:  MOVF   x0D,W
12A9A:  XORLW  80
12A9C:  MOVWF  x0D
....................  
....................  if (y != 0) 
12A9E:  MOVFF  90B,916
12AA2:  MOVFF  90A,915
12AA6:  MOVFF  909,914
12AAA:  MOVFF  908,913
12AAE:  CLRF   x1A
12AB0:  CLRF   x19
12AB2:  CLRF   x18
12AB4:  CLRF   x17
12AB6:  MOVLB  0
12AB8:  CALL   10730
12ABC:  BZ    12B36
....................  { 
....................   if (s == 1 && n == 0) 
12ABE:  MOVLB  9
12AC0:  BTFSS  x12.0
12AC2:  BRA    12AFC
12AC4:  MOVF   x07,F
12AC6:  BNZ   12AFC
....................    res -= 1.0; 
12AC8:  BSF    FD8.1
12ACA:  MOVFF  90F,91A
12ACE:  MOVFF  90E,919
12AD2:  MOVFF  90D,918
12AD6:  MOVFF  90C,917
12ADA:  CLRF   x1E
12ADC:  CLRF   x1D
12ADE:  CLRF   x1C
12AE0:  MOVLW  7F
12AE2:  MOVWF  x1B
12AE4:  MOVLB  0
12AE6:  CALL   C37E
12AEA:  MOVFF  03,90F
12AEE:  MOVFF  02,90E
12AF2:  MOVFF  01,90D
12AF6:  MOVFF  00,90C
12AFA:  MOVLB  9
....................  
....................   if (s == 0 && n == 1) 
12AFC:  BTFSC  x12.0
12AFE:  BRA    12B38
12B00:  DECFSZ x07,W
12B02:  BRA    12B38
....................    res += 1.0; 
12B04:  BCF    FD8.1
12B06:  MOVFF  90F,91A
12B0A:  MOVFF  90E,919
12B0E:  MOVFF  90D,918
12B12:  MOVFF  90C,917
12B16:  CLRF   x1E
12B18:  CLRF   x1D
12B1A:  CLRF   x1C
12B1C:  MOVLW  7F
12B1E:  MOVWF  x1B
12B20:  MOVLB  0
12B22:  CALL   C37E
12B26:  MOVFF  03,90F
12B2A:  MOVFF  02,90E
12B2E:  MOVFF  01,90D
12B32:  MOVFF  00,90C
12B36:  MOVLB  9
....................  } 
....................  if (x == 0) 
12B38:  MOVFF  906,916
12B3C:  MOVFF  905,915
12B40:  MOVFF  904,914
12B44:  MOVFF  903,913
12B48:  CLRF   x1A
12B4A:  CLRF   x19
12B4C:  CLRF   x18
12B4E:  CLRF   x17
12B50:  MOVLB  0
12B52:  CALL   10730
12B56:  BNZ   12B64
....................     res = 0; 
12B58:  MOVLB  9
12B5A:  CLRF   x0F
12B5C:  CLRF   x0E
12B5E:  CLRF   x0D
12B60:  CLRF   x0C
12B62:  MOVLB  0
....................  
....................  return (res); 
12B64:  MOVFF  90C,00
12B68:  MOVFF  90D,01
12B6C:  MOVFF  90E,02
12B70:  MOVFF  90F,03
12B74:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
12B94:  MOVFF  902,906
12B98:  MOVFF  901,905
12B9C:  MOVFF  900,904
12BA0:  MOVFF  8FF,903
12BA4:  MOVLB  9
12BA6:  CLRF   x07
12BA8:  MOVLB  0
12BAA:  RCALL  12806
12BAC:  GOTO   12CB8 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
12B76:  MOVFF  902,906
12B7A:  MOVFF  901,905
12B7E:  MOVFF  900,904
12B82:  MOVFF  8FF,903
12B86:  MOVLW  01
12B88:  MOVLB  9
12B8A:  MOVWF  x07
12B8C:  MOVLB  0
12B8E:  RCALL  12806
12B90:  GOTO   12C70 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
12BB0:  MOVFF  8F6,916
12BB4:  MOVFF  8F5,915
12BB8:  MOVFF  8F4,914
12BBC:  MOVFF  8F3,913
12BC0:  MOVLB  9
12BC2:  CLRF   x1A
12BC4:  CLRF   x19
12BC6:  CLRF   x18
12BC8:  CLRF   x17
12BCA:  MOVLB  0
12BCC:  CALL   10730
12BD0:  BTFSC  FD8.2
12BD2:  BRA    12D14
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
12BD4:  MOVFF  8F2,8FE
12BD8:  MOVFF  8F1,8FD
12BDC:  MOVFF  8F0,8FC
12BE0:  MOVFF  8EF,8FB
12BE4:  MOVFF  8F6,902
12BE8:  MOVFF  8F5,901
12BEC:  MOVFF  8F4,900
12BF0:  MOVFF  8F3,8FF
12BF4:  CALL   C8F0
12BF8:  MOVFF  03,8FE
12BFC:  MOVFF  02,8FD
12C00:  MOVFF  01,8FC
12C04:  MOVFF  00,8FB
12C08:  MOVFF  03,916
12C0C:  MOVFF  02,915
12C10:  MOVFF  01,914
12C14:  MOVFF  00,913
12C18:  MOVLB  9
12C1A:  CLRF   x1A
12C1C:  CLRF   x19
12C1E:  CLRF   x18
12C20:  CLRF   x17
12C22:  MOVLB  0
12C24:  CALL   10730
12C28:  BNC   12C72
12C2A:  MOVFF  8F2,8FE
12C2E:  MOVFF  8F1,8FD
12C32:  MOVFF  8F0,8FC
12C36:  MOVFF  8EF,8FB
12C3A:  MOVFF  8F6,902
12C3E:  MOVFF  8F5,901
12C42:  MOVFF  8F4,900
12C46:  MOVFF  8F3,8FF
12C4A:  CALL   C8F0
12C4E:  MOVFF  03,8FE
12C52:  MOVFF  02,8FD
12C56:  MOVFF  01,8FC
12C5A:  MOVFF  00,8FB
12C5E:  MOVFF  03,902
12C62:  MOVFF  02,901
12C66:  MOVFF  01,900
12C6A:  MOVFF  00,8FF
12C6E:  BRA    12B76
12C70:  BRA    12CB8
12C72:  MOVFF  8F2,8FE
12C76:  MOVFF  8F1,8FD
12C7A:  MOVFF  8F0,8FC
12C7E:  MOVFF  8EF,8FB
12C82:  MOVFF  8F6,902
12C86:  MOVFF  8F5,901
12C8A:  MOVFF  8F4,900
12C8E:  MOVFF  8F3,8FF
12C92:  CALL   C8F0
12C96:  MOVFF  03,8FE
12C9A:  MOVFF  02,8FD
12C9E:  MOVFF  01,8FC
12CA2:  MOVFF  00,8FB
12CA6:  MOVFF  03,902
12CAA:  MOVFF  02,901
12CAE:  MOVFF  01,900
12CB2:  MOVFF  00,8FF
12CB6:  BRA    12B94
12CB8:  MOVFF  03,8FA
12CBC:  MOVFF  02,8F9
12CC0:  MOVFF  01,8F8
12CC4:  MOVFF  00,8F7
....................       return(x-(i*y)); 
12CC8:  MOVFF  8FA,916
12CCC:  MOVFF  8F9,915
12CD0:  MOVFF  8F8,914
12CD4:  MOVFF  8F7,913
12CD8:  MOVFF  8F6,91A
12CDC:  MOVFF  8F5,919
12CE0:  MOVFF  8F4,918
12CE4:  MOVFF  8F3,917
12CE8:  CALL   C288
12CEC:  BSF    FD8.1
12CEE:  MOVFF  8F2,91A
12CF2:  MOVFF  8F1,919
12CF6:  MOVFF  8F0,918
12CFA:  MOVFF  8EF,917
12CFE:  MOVFF  03,91E
12D02:  MOVFF  02,91D
12D06:  MOVFF  01,91C
12D0A:  MOVFF  00,91B
12D0E:  CALL   C37E
12D12:  BRA    12D14
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12D14:  GOTO   12FAC (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
107FA:  MOVFF  8DA,8DE
107FE:  MOVFF  8D9,8DD
10802:  MOVFF  8D8,8DC
10806:  MOVFF  8D7,8DB
....................  
....................    if (y != 1.0) 
1080A:  MOVFF  8DE,916
1080E:  MOVFF  8DD,915
10812:  MOVFF  8DC,914
10816:  MOVFF  8DB,913
1081A:  MOVLB  9
1081C:  CLRF   x1A
1081E:  CLRF   x19
10820:  CLRF   x18
10822:  MOVLW  7F
10824:  MOVWF  x17
10826:  MOVLB  0
10828:  RCALL  10730
1082A:  BTFSC  FD8.2
1082C:  BRA    10B6E
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
1082E:  MOVLW  08
10830:  MOVLB  8
10832:  MOVWF  xED
10834:  MOVLW  DB
10836:  MOVWF  FE9
10838:  MOVFF  8ED,FEA
1083C:  MOVLW  7E
1083E:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
10840:  BSF    FD8.1
10842:  MOVFF  8DE,91A
10846:  MOVFF  8DD,919
1084A:  MOVFF  8DC,918
1084E:  MOVFF  8DB,917
10852:  MOVLB  9
10854:  CLRF   x1E
10856:  CLRF   x1D
10858:  CLRF   x1C
1085A:  MOVLW  7F
1085C:  MOVWF  x1B
1085E:  MOVLB  0
10860:  CALL   C37E
10864:  MOVFF  03,8EF
10868:  MOVFF  02,8EE
1086C:  MOVFF  01,8ED
10870:  MOVFF  00,8EC
10874:  BCF    FD8.1
10876:  MOVFF  8DE,91A
1087A:  MOVFF  8DD,919
1087E:  MOVFF  8DC,918
10882:  MOVFF  8DB,917
10886:  MOVLB  9
10888:  CLRF   x1E
1088A:  CLRF   x1D
1088C:  CLRF   x1C
1088E:  MOVLW  7F
10890:  MOVWF  x1B
10892:  MOVLB  0
10894:  CALL   C37E
10898:  MOVFF  8EF,8FE
1089C:  MOVFF  8EE,8FD
108A0:  MOVFF  8ED,8FC
108A4:  MOVFF  8EC,8FB
108A8:  MOVFF  03,902
108AC:  MOVFF  02,901
108B0:  MOVFF  01,900
108B4:  MOVFF  00,8FF
108B8:  CALL   C8F0
108BC:  MOVFF  03,8DE
108C0:  MOVFF  02,8DD
108C4:  MOVFF  01,8DC
108C8:  MOVFF  00,8DB
....................  
....................       y2=y*y; 
108CC:  MOVFF  8DE,916
108D0:  MOVFF  8DD,915
108D4:  MOVFF  8DC,914
108D8:  MOVFF  8DB,913
108DC:  MOVFF  8DE,91A
108E0:  MOVFF  8DD,919
108E4:  MOVFF  8DC,918
108E8:  MOVFF  8DB,917
108EC:  CALL   C288
108F0:  MOVFF  03,8EA
108F4:  MOVFF  02,8E9
108F8:  MOVFF  01,8E8
108FC:  MOVFF  00,8E7
....................  
....................       res = pl[0]*y2 + pl[1]; 
10900:  MOVLW  99
10902:  MOVLB  9
10904:  MOVWF  x16
10906:  MOVLW  47
10908:  MOVWF  x15
1090A:  MOVLW  8A
1090C:  MOVWF  x14
1090E:  MOVLW  7F
10910:  MOVWF  x13
10912:  MOVFF  8EA,91A
10916:  MOVFF  8E9,919
1091A:  MOVFF  8E8,918
1091E:  MOVFF  8E7,917
10922:  MOVLB  0
10924:  CALL   C288
10928:  MOVFF  03,8EF
1092C:  MOVFF  02,8EE
10930:  MOVFF  01,8ED
10934:  MOVFF  00,8EC
10938:  BCF    FD8.1
1093A:  MOVFF  03,91A
1093E:  MOVFF  02,919
10942:  MOVFF  01,918
10946:  MOVFF  00,917
1094A:  MOVLB  9
1094C:  CLRF   x1E
1094E:  CLRF   x1D
10950:  CLRF   x1C
10952:  MOVLW  80
10954:  MOVWF  x1B
10956:  MOVLB  0
10958:  CALL   C37E
1095C:  MOVFF  03,8E2
10960:  MOVFF  02,8E1
10964:  MOVFF  01,8E0
10968:  MOVFF  00,8DF
....................  
....................       r = ql[0]*y2 + ql[1]; 
1096C:  MOVLW  4C
1096E:  MOVLB  9
10970:  MOVWF  x16
10972:  MOVLW  F3
10974:  MOVWF  x15
10976:  MOVLW  3A
10978:  MOVWF  x14
1097A:  MOVLW  7B
1097C:  MOVWF  x13
1097E:  MOVFF  8EA,91A
10982:  MOVFF  8E9,919
10986:  MOVFF  8E8,918
1098A:  MOVFF  8E7,917
1098E:  MOVLB  0
10990:  CALL   C288
10994:  MOVFF  03,8EF
10998:  MOVFF  02,8EE
1099C:  MOVFF  01,8ED
109A0:  MOVFF  00,8EC
109A4:  BCF    FD8.1
109A6:  MOVFF  03,91A
109AA:  MOVFF  02,919
109AE:  MOVFF  01,918
109B2:  MOVFF  00,917
109B6:  MOVLW  2B
109B8:  MOVLB  9
109BA:  MOVWF  x1E
109BC:  MOVLW  9D
109BE:  MOVWF  x1D
109C0:  MOVLW  DF
109C2:  MOVWF  x1C
109C4:  MOVLW  7E
109C6:  MOVWF  x1B
109C8:  MOVLB  0
109CA:  CALL   C37E
109CE:  MOVFF  03,8E6
109D2:  MOVFF  02,8E5
109D6:  MOVFF  01,8E4
109DA:  MOVFF  00,8E3
....................       r = r*y2 + 1.0; 
109DE:  MOVFF  8E6,916
109E2:  MOVFF  8E5,915
109E6:  MOVFF  8E4,914
109EA:  MOVFF  8E3,913
109EE:  MOVFF  8EA,91A
109F2:  MOVFF  8E9,919
109F6:  MOVFF  8E8,918
109FA:  MOVFF  8E7,917
109FE:  CALL   C288
10A02:  MOVFF  03,8EF
10A06:  MOVFF  02,8EE
10A0A:  MOVFF  01,8ED
10A0E:  MOVFF  00,8EC
10A12:  BCF    FD8.1
10A14:  MOVFF  03,91A
10A18:  MOVFF  02,919
10A1C:  MOVFF  01,918
10A20:  MOVFF  00,917
10A24:  MOVLB  9
10A26:  CLRF   x1E
10A28:  CLRF   x1D
10A2A:  CLRF   x1C
10A2C:  MOVLW  7F
10A2E:  MOVWF  x1B
10A30:  MOVLB  0
10A32:  CALL   C37E
10A36:  MOVFF  03,8E6
10A3A:  MOVFF  02,8E5
10A3E:  MOVFF  01,8E4
10A42:  MOVFF  00,8E3
....................  
....................       res = y*res/r; 
10A46:  MOVFF  8DE,916
10A4A:  MOVFF  8DD,915
10A4E:  MOVFF  8DC,914
10A52:  MOVFF  8DB,913
10A56:  MOVFF  8E2,91A
10A5A:  MOVFF  8E1,919
10A5E:  MOVFF  8E0,918
10A62:  MOVFF  8DF,917
10A66:  CALL   C288
10A6A:  MOVFF  03,8EF
10A6E:  MOVFF  02,8EE
10A72:  MOVFF  01,8ED
10A76:  MOVFF  00,8EC
10A7A:  MOVFF  03,8FE
10A7E:  MOVFF  02,8FD
10A82:  MOVFF  01,8FC
10A86:  MOVFF  00,8FB
10A8A:  MOVFF  8E6,902
10A8E:  MOVFF  8E5,901
10A92:  MOVFF  8E4,900
10A96:  MOVFF  8E3,8FF
10A9A:  CALL   C8F0
10A9E:  MOVFF  03,8E2
10AA2:  MOVFF  02,8E1
10AA6:  MOVFF  01,8E0
10AAA:  MOVFF  00,8DF
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
10AAE:  MOVLW  08
10AB0:  MOVLB  8
10AB2:  MOVWF  xED
10AB4:  MOVLW  D7
10AB6:  MOVWF  FE9
10AB8:  MOVFF  8ED,FEA
10ABC:  MOVLW  7E
10ABE:  SUBWF  FEF,W
10AC0:  MOVWF  xEB
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
10AC2:  BTFSS  xEB.7
10AC4:  BRA    10AEE
....................          r = -(float32)-n; 
10AC6:  MOVLW  00
10AC8:  BSF    FD8.0
10ACA:  SUBFWB xEB,W
10ACC:  CLRF   xED
10ACE:  MOVWF  xEC
10AD0:  BTFSC  xEC.7
10AD2:  DECF   xED,F
10AD4:  MOVLB  0
10AD6:  RCALL  107AA
10AD8:  MOVFF  00,8E3
10ADC:  MOVF   01,W
10ADE:  XORLW  80
10AE0:  MOVLB  8
10AE2:  MOVWF  xE4
10AE4:  MOVFF  02,8E5
10AE8:  MOVFF  03,8E6
10AEC:  BRA    10B0E
....................       else 
....................          r = (float32)n; 
10AEE:  CLRF   xED
10AF0:  MOVFF  8EB,8EC
10AF4:  BTFSC  xEC.7
10AF6:  DECF   xED,F
10AF8:  MOVLB  0
10AFA:  RCALL  107AA
10AFC:  MOVFF  03,8E6
10B00:  MOVFF  02,8E5
10B04:  MOVFF  01,8E4
10B08:  MOVFF  00,8E3
10B0C:  MOVLB  8
....................  
....................       res += r*LN2; 
10B0E:  MOVFF  8E6,916
10B12:  MOVFF  8E5,915
10B16:  MOVFF  8E4,914
10B1A:  MOVFF  8E3,913
10B1E:  MOVLW  18
10B20:  MOVLB  9
10B22:  MOVWF  x1A
10B24:  MOVLW  72
10B26:  MOVWF  x19
10B28:  MOVLW  31
10B2A:  MOVWF  x18
10B2C:  MOVLW  7E
10B2E:  MOVWF  x17
10B30:  MOVLB  0
10B32:  CALL   C288
10B36:  BCF    FD8.1
10B38:  MOVFF  8E2,91A
10B3C:  MOVFF  8E1,919
10B40:  MOVFF  8E0,918
10B44:  MOVFF  8DF,917
10B48:  MOVFF  03,91E
10B4C:  MOVFF  02,91D
10B50:  MOVFF  01,91C
10B54:  MOVFF  00,91B
10B58:  CALL   C37E
10B5C:  MOVFF  03,8E2
10B60:  MOVFF  02,8E1
10B64:  MOVFF  01,8E0
10B68:  MOVFF  00,8DF
....................    } 
10B6C:  BRA    10B7A
....................  
....................    else 
....................       res = 0.0; 
10B6E:  MOVLB  8
10B70:  CLRF   xE2
10B72:  CLRF   xE1
10B74:  CLRF   xE0
10B76:  CLRF   xDF
10B78:  MOVLB  0
....................  
....................    return(res); 
10B7A:  MOVFF  8DF,00
10B7E:  MOVFF  8E0,01
10B82:  MOVFF  8E1,02
10B86:  MOVFF  8E2,03
10B8A:  GOTO   10BA0 (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
10B8E:  MOVFF  8D2,8DA
10B92:  MOVFF  8D1,8D9
10B96:  MOVFF  8D0,8D8
10B9A:  MOVFF  8CF,8D7
10B9E:  BRA    107FA
10BA0:  MOVFF  03,8D6
10BA4:  MOVFF  02,8D5
10BA8:  MOVFF  01,8D4
10BAC:  MOVFF  00,8D3
....................    r = r*LN10_INV; 
10BB0:  MOVFF  8D6,916
10BB4:  MOVFF  8D5,915
10BB8:  MOVFF  8D4,914
10BBC:  MOVFF  8D3,913
10BC0:  MOVLW  D9
10BC2:  MOVLB  9
10BC4:  MOVWF  x1A
10BC6:  MOVLW  5B
10BC8:  MOVWF  x19
10BCA:  MOVLW  5E
10BCC:  MOVWF  x18
10BCE:  MOVLW  7D
10BD0:  MOVWF  x17
10BD2:  MOVLB  0
10BD4:  CALL   C288
10BD8:  MOVFF  03,8D6
10BDC:  MOVFF  02,8D5
10BE0:  MOVFF  01,8D4
10BE4:  MOVFF  00,8D3
....................    return(r); 
10BE8:  MOVFF  8D3,00
10BEC:  MOVFF  8D4,01
10BF0:  MOVFF  8D5,02
10BF4:  MOVFF  8D6,03
10BF8:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
10588:  BCF    FC6.5
1058A:  MOVLW  21
1058C:  MOVWF  FC6
1058E:  MOVLW  40
10590:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
10592:  BSF    F91.2
....................    output_high(EEP_WP); 
10594:  BSF    F91.3
10596:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
10598:  BCF    F91.2
....................    spi_write(0x05);  
1059A:  MOVF   FC9,W
1059C:  MOVLW  05
1059E:  MOVWF  FC9
105A0:  RRCF   FC7,W
105A2:  BNC   105A0
....................    data = spi_read(0);  
105A4:  MOVF   FC9,W
105A6:  CLRF   FC9
105A8:  RRCF   FC7,W
105AA:  BNC   105A8
105AC:  MOVFF  FC9,8CE
....................    output_high(EEP_CS);  
105B0:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
105B2:  MOVLW  00
105B4:  MOVLB  8
105B6:  BTFSS  xCE.0
105B8:  MOVLW  01
105BA:  MOVWF  01
105BC:  MOVLB  0
105BE:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
18002:  MOVLB  8
18004:  CLRF   xED
18006:  MOVLB  0
18008:  CALL   5586
....................       while(!ext_eeprom_ready()); 
1800C:  CALL   10598
18010:  MOVF   01,F
18012:  BZ    1800C
....................     
....................       output_low(EEP_CS);  
18014:  BCF    F91.2
....................       spi_write(0x06);  
18016:  MOVF   FC9,W
18018:  MOVLW  06
1801A:  MOVWF  FC9
1801C:  RRCF   FC7,W
1801E:  BNC   1801C
....................       output_high(EEP_CS);  
18020:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
18022:  BCF    F91.2
....................       spi_write(0x02);  
18024:  MOVF   FC9,W
18026:  MOVLW  02
18028:  MOVWF  FC9
1802A:  RRCF   FC7,W
1802C:  BNC   1802A
....................       spi_write(address >> 8);  
1802E:  MOVFF  8A8,8AA
18032:  MOVLB  8
18034:  CLRF   xAB
18036:  MOVF   FC9,W
18038:  MOVFF  8A8,FC9
1803C:  RRCF   FC7,W
1803E:  BNC   1803C
....................       spi_write(address);  
18040:  MOVF   FC9,W
18042:  MOVFF  8A7,FC9
18046:  RRCF   FC7,W
18048:  BNC   18046
....................       spi_write(data);  
1804A:  MOVF   FC9,W
1804C:  MOVFF  8A9,FC9
18050:  RRCF   FC7,W
18052:  BNC   18050
....................       output_high(EEP_CS);  
18054:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
18056:  MOVLW  01
18058:  MOVWF  xED
1805A:  MOVLB  0
1805C:  CALL   5586
18060:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
105C0:  MOVLB  8
105C2:  CLRF   xED
105C4:  MOVLB  0
105C6:  CALL   5586
....................     
....................       while(!ext_eeprom_ready()); 
105CA:  RCALL  10598
105CC:  MOVF   01,F
105CE:  BZ    105CA
....................        
....................       output_low(EEP_CS);  
105D0:  BCF    F91.2
....................       spi_write(0x03);  
105D2:  MOVF   FC9,W
105D4:  MOVLW  03
105D6:  MOVWF  FC9
105D8:  RRCF   FC7,W
105DA:  BNC   105D8
....................       spi_write(address >> 8);  
105DC:  MOVFF  8CC,8CE
105E0:  MOVLB  8
105E2:  CLRF   xCF
105E4:  MOVF   FC9,W
105E6:  MOVFF  8CC,FC9
105EA:  RRCF   FC7,W
105EC:  BNC   105EA
....................       spi_write(address);  
105EE:  MOVF   FC9,W
105F0:  MOVFF  8CB,FC9
105F4:  RRCF   FC7,W
105F6:  BNC   105F4
....................        
....................       data = spi_read(0);  
105F8:  MOVF   FC9,W
105FA:  CLRF   FC9
105FC:  RRCF   FC7,W
105FE:  BNC   105FC
10600:  MOVFF  FC9,8CD
....................       output_high(EEP_CS);  
10604:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
10606:  MOVLW  01
10608:  MOVWF  xED
1060A:  MOVLB  0
1060C:  CALL   5586
....................     
....................    return(data);  
10610:  MOVLB  8
10612:  MOVFF  8CD,01
10616:  MOVLB  0
10618:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
03412:  MOVF   FF2,W
03414:  MOVWF  00
03416:  BCF    FF2.7
03418:  CLRF   F63
0341A:  MOVFF  889,F62
0341E:  MOVFF  88A,F61
03422:  BCF    F7F.6
03424:  BCF    F7F.7
03426:  BSF    F7F.2
03428:  MOVLB  F
0342A:  MOVLW  55
0342C:  MOVWF  F7E
0342E:  MOVLW  AA
03430:  MOVWF  F7E
03432:  BSF    F7F.1
03434:  BTFSC  F7F.1
03436:  BRA    3434
03438:  BCF    F7F.2
0343A:  MOVF   00,W
0343C:  IORWF  FF2,F
0343E:  MOVLB  0
03440:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
02A24:  MOVLB  8
02A26:  CLRF   xB8
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
02A28:  MOVFF  FF2,8B9
02A2C:  BCF    FF2.7
02A2E:  CLRF   F63
02A30:  MOVFF  8B7,F62
02A34:  BCF    F7F.6
02A36:  BCF    F7F.7
02A38:  BSF    F7F.0
02A3A:  MOVF   F61,W
02A3C:  BTFSC  xB9.7
02A3E:  BSF    FF2.7
02A40:  MOVWF  xB8
....................    return(data); 
02A42:  MOVFF  8B8,01
02A46:  MOVLB  0
02A48:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04FD4:  MOVLB  8
04FD6:  CLRF   xF1
04FD8:  MOVF   xF1,W
04FDA:  SUBLW  01
04FDC:  BNC   5036
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
04FDE:  MOVF   xEE,W
04FE0:  ADDWF  xF1,W
04FE2:  MOVWF  xF2
04FE4:  MOVLW  08
04FE6:  MOVWF  xF4
04FE8:  MOVLW  EF
04FEA:  MOVWF  xF3
04FEC:  MOVF   xF1,W
04FEE:  ADDWF  xF3,W
04FF0:  MOVWF  01
04FF2:  MOVLW  00
04FF4:  ADDWFC xF4,W
04FF6:  MOVWF  03
04FF8:  MOVF   01,W
04FFA:  MOVWF  FE9
04FFC:  MOVFF  03,FEA
05000:  MOVFF  FEF,8F3
05004:  MOVF   FF2,W
05006:  MOVWF  00
05008:  BCF    FF2.7
0500A:  CLRF   F63
0500C:  MOVFF  8F2,F62
05010:  MOVFF  8F3,F61
05014:  BCF    F7F.6
05016:  BCF    F7F.7
05018:  BSF    F7F.2
0501A:  MOVLB  F
0501C:  MOVLW  55
0501E:  MOVWF  F7E
05020:  MOVLW  AA
05022:  MOVWF  F7E
05024:  BSF    F7F.1
05026:  BTFSC  F7F.1
05028:  BRA    5026
0502A:  BCF    F7F.2
0502C:  MOVF   00,W
0502E:  IORWF  FF2,F
05030:  MOVLB  8
05032:  INCF   xF1,F
05034:  BRA    4FD8
....................     }  
05036:  MOVLB  0
05038:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
029CA:  MOVLB  8
029CC:  CLRF   x9A
029CE:  CLRF   x99
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
029D0:  CLRF   x98
029D2:  MOVF   x98,W
029D4:  SUBLW  01
029D6:  BNC   2A18
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
029D8:  MOVLW  08
029DA:  MOVWF  x9C
029DC:  MOVLW  99
029DE:  MOVWF  x9B
029E0:  MOVF   x98,W
029E2:  ADDWF  x9B,W
029E4:  MOVWF  01
029E6:  MOVLW  00
029E8:  ADDWFC x9C,W
029EA:  MOVWF  03
029EC:  MOVF   01,W
029EE:  MOVWF  FE9
029F0:  MOVFF  03,FEA
029F4:  MOVF   x97,W
029F6:  ADDWF  x98,W
029F8:  MOVWF  x9D
029FA:  MOVFF  FF2,89E
029FE:  BCF    FF2.7
02A00:  CLRF   F63
02A02:  MOVFF  89D,F62
02A06:  BCF    F7F.6
02A08:  BCF    F7F.7
02A0A:  BSF    F7F.0
02A0C:  MOVF   F61,W
02A0E:  BTFSC  x9E.7
02A10:  BSF    FF2.7
02A12:  MOVWF  FEF
02A14:  INCF   x98,F
02A16:  BRA    29D2
....................    } 
....................  
....................    return(data);  
02A18:  MOVFF  899,01
02A1C:  MOVFF  89A,02
02A20:  MOVLB  0
02A22:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CD10:  MOVLB  8
0CD12:  CLRF   x8B
0CD14:  MOVF   x8B,W
0CD16:  SUBLW  03
0CD18:  BNC   CD7A
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CD1A:  MOVF   x8B,W
0CD1C:  ADDWF  x85,W
0CD1E:  MOVWF  x8C
0CD20:  MOVLW  00
0CD22:  ADDWFC x86,W
0CD24:  MOVWF  x8D
0CD26:  MOVLW  08
0CD28:  MOVWF  x8F
0CD2A:  MOVLW  87
0CD2C:  MOVWF  x8E
0CD2E:  MOVF   x8B,W
0CD30:  ADDWF  x8E,W
0CD32:  MOVWF  01
0CD34:  MOVLW  00
0CD36:  ADDWFC x8F,W
0CD38:  MOVWF  03
0CD3A:  MOVF   01,W
0CD3C:  MOVWF  FE9
0CD3E:  MOVFF  03,FEA
0CD42:  MOVFF  FEF,88E
0CD46:  MOVF   FF2,W
0CD48:  MOVWF  00
0CD4A:  BCF    FF2.7
0CD4C:  MOVFF  88D,F63
0CD50:  MOVFF  88C,F62
0CD54:  MOVFF  88E,F61
0CD58:  BCF    F7F.6
0CD5A:  BCF    F7F.7
0CD5C:  BSF    F7F.2
0CD5E:  MOVLB  F
0CD60:  MOVLW  55
0CD62:  MOVWF  F7E
0CD64:  MOVLW  AA
0CD66:  MOVWF  F7E
0CD68:  BSF    F7F.1
0CD6A:  BTFSC  F7F.1
0CD6C:  BRA    CD6A
0CD6E:  BCF    F7F.2
0CD70:  MOVF   00,W
0CD72:  IORWF  FF2,F
0CD74:  MOVLB  8
0CD76:  INCF   x8B,F
0CD78:  BRA    CD14
....................    } 
0CD7A:  MOVLB  0
0CD7C:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
02A4A:  MOVLB  8
02A4C:  CLRF   x8B
02A4E:  CLRF   x8A
02A50:  CLRF   x89
02A52:  CLRF   x88
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
02A54:  CLRF   x87
02A56:  MOVF   x87,W
02A58:  SUBLW  03
02A5A:  BNC   2AA4
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A5C:  MOVLW  08
02A5E:  MOVWF  x8D
02A60:  MOVLW  88
02A62:  MOVWF  x8C
02A64:  MOVF   x87,W
02A66:  ADDWF  x8C,W
02A68:  MOVWF  01
02A6A:  MOVLW  00
02A6C:  ADDWFC x8D,W
02A6E:  MOVWF  03
02A70:  MOVF   01,W
02A72:  MOVWF  FE9
02A74:  MOVFF  03,FEA
02A78:  MOVF   x87,W
02A7A:  ADDWF  x85,W
02A7C:  MOVWF  x8E
02A7E:  MOVLW  00
02A80:  ADDWFC x86,W
02A82:  MOVWF  x8F
02A84:  MOVFF  FF2,890
02A88:  BCF    FF2.7
02A8A:  MOVFF  88F,F63
02A8E:  MOVFF  88E,F62
02A92:  BCF    F7F.6
02A94:  BCF    F7F.7
02A96:  BSF    F7F.0
02A98:  MOVF   F61,W
02A9A:  BTFSC  x90.7
02A9C:  BSF    FF2.7
02A9E:  MOVWF  FEF
02AA0:  INCF   x87,F
02AA2:  BRA    2A56
....................    } 
....................  
....................    return(data);  
02AA4:  MOVFF  888,00
02AA8:  MOVFF  889,01
02AAC:  MOVFF  88A,02
02AB0:  MOVFF  88B,03
02AB4:  MOVLB  0
02AB6:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
18242:  MOVLB  8
18244:  CLRF   xA3
18246:  MOVF   xA3,W
18248:  SUBLW  01
1824A:  BNC   18288
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
1824C:  MOVF   xA3,W
1824E:  ADDWF  x9F,W
18250:  MOVWF  xA4
18252:  MOVLW  00
18254:  ADDWFC xA0,W
18256:  MOVWF  xA5
18258:  MOVLW  08
1825A:  MOVWF  xA7
1825C:  MOVLW  A1
1825E:  MOVWF  xA6
18260:  MOVF   xA3,W
18262:  ADDWF  xA6,W
18264:  MOVWF  01
18266:  MOVLW  00
18268:  ADDWFC xA7,W
1826A:  MOVWF  03
1826C:  MOVFF  01,FE9
18270:  MOVWF  FEA
18272:  MOVFF  FEF,8A9
18276:  MOVFF  8A5,8A8
1827A:  MOVFF  8A4,8A7
1827E:  MOVLB  0
18280:  RCALL  18002
18282:  MOVLB  8
18284:  INCF   xA3,F
18286:  BRA    18246
....................     }  
18288:  MOVLB  0
1828A:  GOTO   182FA (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
106D4:  MOVLB  8
106D6:  CLRF   xC6
106D8:  CLRF   xC5
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
106DA:  CLRF   xC4
106DC:  MOVF   xC4,W
106DE:  SUBLW  01
106E0:  BNC   10724
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
106E2:  MOVLW  08
106E4:  MOVWF  xC8
106E6:  MOVLW  C5
106E8:  MOVWF  xC7
106EA:  MOVF   xC4,W
106EC:  ADDWF  xC7,W
106EE:  MOVWF  01
106F0:  MOVLW  00
106F2:  ADDWFC xC8,W
106F4:  MOVWF  03
106F6:  MOVFF  01,8C7
106FA:  MOVWF  xC8
106FC:  MOVF   xC4,W
106FE:  ADDWF  xC2,W
10700:  MOVWF  xC9
10702:  MOVLW  00
10704:  ADDWFC xC3,W
10706:  MOVWF  xCA
10708:  MOVWF  xCC
1070A:  MOVFF  8C9,8CB
1070E:  MOVLB  0
10710:  RCALL  105C0
10712:  MOVFF  8C8,FEA
10716:  MOVFF  8C7,FE9
1071A:  MOVFF  01,FEF
1071E:  MOVLB  8
10720:  INCF   xC4,F
10722:  BRA    106DC
....................    } 
....................    return(data);  
10724:  MOVFF  8C5,01
10728:  MOVFF  8C6,02
1072C:  MOVLB  0
1072E:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
15CBC:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
15CBE:  MOVF   2F,W
15CC0:  SUBLW  02
15CC2:  BNZ   15CCA
15CC4:  MOVF   30,F
15CC6:  BNZ   15CCA
15CC8:  BSF    F90.6
....................    delay_ms(32); 
15CCA:  MOVLW  20
15CCC:  MOVLB  9
15CCE:  MOVWF  xEC
15CD0:  MOVLB  0
15CD2:  CALL   2910
....................    output_bit(BOARD_LED, OFF); 
15CD6:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15CD8:  MOVF   2F,W
15CDA:  SUBLW  02
15CDC:  BNZ   15CE4
15CDE:  MOVF   30,F
15CE0:  BNZ   15CE4
15CE2:  BCF    F90.6
....................    delay_ms(32); 
15CE4:  MOVLW  20
15CE6:  MOVLB  9
15CE8:  MOVWF  xEC
15CEA:  MOVLB  0
15CEC:  CALL   2910
15CF0:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
03148:  MOVF   2F,W
0314A:  MOVWF  00
0314C:  MOVF   30,W
0314E:  MOVWF  03
03150:  BNZ   3156
03152:  MOVF   00,F
03154:  BZ    3178
03156:  MOVF   03,W
03158:  BNZ   3160
0315A:  MOVLW  01
0315C:  SUBWF  00,W
0315E:  BZ    31CA
03160:  MOVF   03,W
03162:  BNZ   316A
03164:  MOVLW  02
03166:  SUBWF  00,W
03168:  BZ    321C
0316A:  MOVF   03,W
0316C:  BNZ   3176
0316E:  MOVLW  03
03170:  SUBWF  00,W
03172:  BTFSC  FD8.2
03174:  BRA    326E
03176:  BRA    32C0
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
03178:  MOVLW  BE
0317A:  MOVWF  FF6
0317C:  MOVLW  05
0317E:  MOVWF  FF7
03180:  MOVLW  00
03182:  MOVWF  FF8
03184:  CLRF   1B
03186:  BTFSC  FF2.7
03188:  BSF    1B.7
0318A:  BCF    FF2.7
0318C:  MOVLW  06
0318E:  MOVLB  A
03190:  MOVWF  x40
03192:  MOVLB  0
03194:  CALL   1024
03198:  BTFSC  1B.7
0319A:  BSF    FF2.7
0319C:  MOVLW  CA
0319E:  MOVWF  FF6
031A0:  MOVLW  05
031A2:  MOVWF  FF7
031A4:  MOVLW  00
031A6:  MOVWF  FF8
031A8:  CLRF   1B
031AA:  BTFSC  FF2.7
031AC:  BSF    1B.7
031AE:  BCF    FF2.7
031B0:  CALL   0E4E
031B4:  BTFSC  1B.7
031B6:  BSF    FF2.7
031B8:  MOVLW  0D
031BA:  BTFSS  F9E.4
031BC:  BRA    31BA
031BE:  MOVWF  FAD
031C0:  MOVLW  0A
031C2:  BTFSS  F9E.4
031C4:  BRA    31C2
031C6:  MOVWF  FAD
....................          break; 
031C8:  BRA    3310
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
031CA:  MOVLW  D2
031CC:  MOVWF  FF6
031CE:  MOVLW  05
031D0:  MOVWF  FF7
031D2:  MOVLW  00
031D4:  MOVWF  FF8
031D6:  CLRF   1B
031D8:  BTFSC  FF2.7
031DA:  BSF    1B.7
031DC:  BCF    FF2.7
031DE:  MOVLW  09
031E0:  MOVLB  A
031E2:  MOVWF  x40
031E4:  MOVLB  0
031E6:  CALL   1024
031EA:  BTFSC  1B.7
031EC:  BSF    FF2.7
031EE:  MOVLW  E0
031F0:  MOVWF  FF6
031F2:  MOVLW  05
031F4:  MOVWF  FF7
031F6:  MOVLW  00
031F8:  MOVWF  FF8
031FA:  CLRF   1B
031FC:  BTFSC  FF2.7
031FE:  BSF    1B.7
03200:  BCF    FF2.7
03202:  CALL   0E4E
03206:  BTFSC  1B.7
03208:  BSF    FF2.7
0320A:  MOVLW  0D
0320C:  BTFSS  F9E.4
0320E:  BRA    320C
03210:  MOVWF  FAD
03212:  MOVLW  0A
03214:  BTFSS  F9E.4
03216:  BRA    3214
03218:  MOVWF  FAD
....................          break;  
0321A:  BRA    3310
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
0321C:  MOVLW  E8
0321E:  MOVWF  FF6
03220:  MOVLW  05
03222:  MOVWF  FF7
03224:  MOVLW  00
03226:  MOVWF  FF8
03228:  CLRF   1B
0322A:  BTFSC  FF2.7
0322C:  BSF    1B.7
0322E:  BCF    FF2.7
03230:  MOVLW  06
03232:  MOVLB  A
03234:  MOVWF  x40
03236:  MOVLB  0
03238:  CALL   1024
0323C:  BTFSC  1B.7
0323E:  BSF    FF2.7
03240:  MOVLW  F4
03242:  MOVWF  FF6
03244:  MOVLW  05
03246:  MOVWF  FF7
03248:  MOVLW  00
0324A:  MOVWF  FF8
0324C:  CLRF   1B
0324E:  BTFSC  FF2.7
03250:  BSF    1B.7
03252:  BCF    FF2.7
03254:  CALL   0E4E
03258:  BTFSC  1B.7
0325A:  BSF    FF2.7
0325C:  MOVLW  0D
0325E:  BTFSS  F9E.4
03260:  BRA    325E
03262:  MOVWF  FAD
03264:  MOVLW  0A
03266:  BTFSS  F9E.4
03268:  BRA    3266
0326A:  MOVWF  FAD
....................          break; 
0326C:  BRA    3310
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
0326E:  MOVLW  FC
03270:  MOVWF  FF6
03272:  MOVLW  05
03274:  MOVWF  FF7
03276:  MOVLW  00
03278:  MOVWF  FF8
0327A:  CLRF   1B
0327C:  BTFSC  FF2.7
0327E:  BSF    1B.7
03280:  BCF    FF2.7
03282:  MOVLW  09
03284:  MOVLB  A
03286:  MOVWF  x40
03288:  MOVLB  0
0328A:  CALL   1024
0328E:  BTFSC  1B.7
03290:  BSF    FF2.7
03292:  MOVLW  0A
03294:  MOVWF  FF6
03296:  MOVLW  06
03298:  MOVWF  FF7
0329A:  MOVLW  00
0329C:  MOVWF  FF8
0329E:  CLRF   1B
032A0:  BTFSC  FF2.7
032A2:  BSF    1B.7
032A4:  BCF    FF2.7
032A6:  CALL   0E4E
032AA:  BTFSC  1B.7
032AC:  BSF    FF2.7
032AE:  MOVLW  0D
032B0:  BTFSS  F9E.4
032B2:  BRA    32B0
032B4:  MOVWF  FAD
032B6:  MOVLW  0A
032B8:  BTFSS  F9E.4
032BA:  BRA    32B8
032BC:  MOVWF  FAD
....................          break;           
032BE:  BRA    3310
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
032C0:  MOVLW  12
032C2:  MOVWF  FF6
032C4:  MOVLW  06
032C6:  MOVWF  FF7
032C8:  MOVLW  00
032CA:  MOVWF  FF8
032CC:  CLRF   1B
032CE:  BTFSC  FF2.7
032D0:  BSF    1B.7
032D2:  BCF    FF2.7
032D4:  MOVLW  06
032D6:  MOVLB  A
032D8:  MOVWF  x40
032DA:  MOVLB  0
032DC:  CALL   1024
032E0:  BTFSC  1B.7
032E2:  BSF    FF2.7
032E4:  MOVLW  1E
032E6:  MOVWF  FF6
032E8:  MOVLW  06
032EA:  MOVWF  FF7
032EC:  MOVLW  00
032EE:  MOVWF  FF8
032F0:  CLRF   1B
032F2:  BTFSC  FF2.7
032F4:  BSF    1B.7
032F6:  BCF    FF2.7
032F8:  CALL   0E4E
032FC:  BTFSC  1B.7
032FE:  BSF    FF2.7
03300:  MOVLW  0D
03302:  BTFSS  F9E.4
03304:  BRA    3302
03306:  MOVWF  FAD
03308:  MOVLW  0A
0330A:  BTFSS  F9E.4
0330C:  BRA    330A
0330E:  MOVWF  FAD
....................          break; 
....................    } 
03310:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
176F2:  MOVLW  26
176F4:  MOVWF  FF6
176F6:  MOVLW  06
176F8:  MOVWF  FF7
176FA:  MOVLW  00
176FC:  MOVWF  FF8
176FE:  CLRF   1B
17700:  BTFSC  FF2.7
17702:  BSF    1B.7
17704:  BCF    FF2.7
17706:  CALL   0E4E
1770A:  BTFSC  1B.7
1770C:  BSF    FF2.7
1770E:  GOTO   17AB8 (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0B2C2:  MOVLW  2E
0B2C4:  MOVWF  FF6
0B2C6:  MOVLW  06
0B2C8:  MOVWF  FF7
0B2CA:  MOVLW  00
0B2CC:  MOVWF  FF8
0B2CE:  CLRF   1B
0B2D0:  BTFSC  FF2.7
0B2D2:  BSF    1B.7
0B2D4:  BCF    FF2.7
0B2D6:  CALL   0E4E
0B2DA:  BTFSC  1B.7
0B2DC:  BSF    FF2.7
0B2DE:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BF84:  MOVLW  36
0BF86:  MOVWF  FF6
0BF88:  MOVLW  06
0BF8A:  MOVWF  FF7
0BF8C:  MOVLW  00
0BF8E:  MOVWF  FF8
0BF90:  CLRF   1B
0BF92:  BTFSC  FF2.7
0BF94:  BSF    1B.7
0BF96:  BCF    FF2.7
0BF98:  CALL   0E4E
0BF9C:  BTFSC  1B.7
0BF9E:  BSF    FF2.7
0BFA0:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
03656:  MOVLW  4E
03658:  MOVWF  FF6
0365A:  MOVLW  06
0365C:  MOVWF  FF7
0365E:  MOVLW  00
03660:  MOVWF  FF8
03662:  CLRF   1B
03664:  BTFSC  FF2.7
03666:  BSF    1B.7
03668:  BCF    FF2.7
0366A:  CALL   0E4E
0366E:  BTFSC  1B.7
03670:  BSF    FF2.7
03672:  GOTO   43C8 (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
05080:  MOVLW  56
05082:  MOVWF  FF6
05084:  MOVLW  06
05086:  MOVWF  FF7
05088:  MOVLW  00
0508A:  MOVWF  FF8
0508C:  CLRF   1B
0508E:  BTFSC  FF2.7
05090:  BSF    1B.7
05092:  BCF    FF2.7
05094:  CALL   0E4E
05098:  BTFSC  1B.7
0509A:  BSF    FF2.7
0509C:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
161E8:  MOVLW  5E
161EA:  MOVWF  FF6
161EC:  MOVLW  06
161EE:  MOVWF  FF7
161F0:  MOVLW  00
161F2:  MOVWF  FF8
161F4:  CLRF   1B
161F6:  BTFSC  FF2.7
161F8:  BSF    1B.7
161FA:  BCF    FF2.7
161FC:  CALL   0E4E
16200:  BTFSC  1B.7
16202:  BSF    FF2.7
16204:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
*
0B11A:  DECFSZ 4E,W
0B11C:  BRA    B13C
0B11E:  MOVLW  66
0B120:  MOVWF  FF6
0B122:  MOVLW  06
0B124:  MOVWF  FF7
0B126:  MOVLW  00
0B128:  MOVWF  FF8
0B12A:  CLRF   1B
0B12C:  BTFSC  FF2.7
0B12E:  BSF    1B.7
0B130:  BCF    FF2.7
0B132:  CALL   0E4E
0B136:  BTFSC  1B.7
0B138:  BSF    FF2.7
0B13A:  BRA    B158
....................    else fprintf(COM_A, "@RDY\r\n"); 
0B13C:  MOVLW  6E
0B13E:  MOVWF  FF6
0B140:  MOVLW  06
0B142:  MOVWF  FF7
0B144:  MOVLW  00
0B146:  MOVWF  FF8
0B148:  CLRF   1B
0B14A:  BTFSC  FF2.7
0B14C:  BSF    1B.7
0B14E:  BCF    FF2.7
0B150:  CALL   0E4E
0B154:  BTFSC  1B.7
0B156:  BSF    FF2.7
0B158:  GOTO   1B5E8 (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
03540:  MOVLW  0A
03542:  MOVLB  A
03544:  MOVWF  x35
03546:  MOVLW  2C
03548:  MOVFF  A35,A33
0354C:  MOVWF  x32
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
0354E:  MOVF   FC9,W
03550:  SETF   FC9
03552:  RRCF   FC7,W
03554:  BNC   3552
....................    SD_spi_read(sdcmd); 
03556:  MOVF   FC9,W
03558:  MOVFF  A2B,FC9
0355C:  RRCF   FC7,W
0355E:  BNC   355C
....................    SD_spi_read(value[3]); 
03560:  MOVLW  03
03562:  ADDWF  x32,W
03564:  MOVWF  FE9
03566:  MOVLW  00
03568:  ADDWFC x33,W
0356A:  MOVWF  FEA
0356C:  MOVFF  FEF,A34
03570:  MOVF   FC9,W
03572:  MOVFF  A34,FC9
03576:  RRCF   FC7,W
03578:  BNC   3576
....................    SD_spi_read(value[2]); 
0357A:  MOVLW  02
0357C:  ADDWF  x32,W
0357E:  MOVWF  FE9
03580:  MOVLW  00
03582:  ADDWFC x33,W
03584:  MOVWF  FEA
03586:  MOVFF  FEF,A34
0358A:  MOVF   FC9,W
0358C:  MOVFF  A34,FC9
03590:  RRCF   FC7,W
03592:  BNC   3590
....................    SD_spi_read(value[1]); 
03594:  MOVLW  01
03596:  ADDWF  x32,W
03598:  MOVWF  FE9
0359A:  MOVLW  00
0359C:  ADDWFC x33,W
0359E:  MOVWF  FEA
035A0:  MOVFF  FEF,A34
035A4:  MOVF   FC9,W
035A6:  MOVFF  A34,FC9
035AA:  RRCF   FC7,W
035AC:  BNC   35AA
....................    SD_spi_read(value[0]); 
035AE:  MOVFF  A32,FE9
035B2:  MOVFF  A33,FEA
035B6:  MOVFF  FEF,A34
035BA:  MOVF   FC9,W
035BC:  MOVFF  A34,FC9
035C0:  RRCF   FC7,W
035C2:  BNC   35C0
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
035C4:  MOVF   x2B,W
035C6:  SUBLW  48
035C8:  BNZ   35D6
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
035CA:  MOVF   FC9,W
035CC:  MOVLW  87
035CE:  MOVWF  FC9
035D0:  RRCF   FC7,W
035D2:  BNC   35D0
035D4:  BRA    35E0
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
035D6:  MOVF   FC9,W
035D8:  MOVLW  95
035DA:  MOVWF  FC9
035DC:  RRCF   FC7,W
035DE:  BNC   35DC
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
035E0:  CLRF   x30
....................    response = SD_spi_read(0xFF); 
035E2:  MOVF   FC9,W
035E4:  SETF   FC9
035E6:  RRCF   FC7,W
035E8:  BNC   35E6
035EA:  MOVFF  FC9,A31
....................    while ((response == 0xFF) && (i < 100)) 
035EE:  INCFSZ x31,W
035F0:  BRA    3608
035F2:  MOVF   x30,W
035F4:  SUBLW  63
035F6:  BNC   3608
....................       { 
....................       i++; 
035F8:  INCF   x30,F
....................       response = SD_spi_read(0xFF); 
035FA:  MOVF   FC9,W
035FC:  SETF   FC9
035FE:  RRCF   FC7,W
03600:  BNC   35FE
03602:  MOVFF  FC9,A31
03606:  BRA    35EE
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
03608:  MOVFF  A31,01
0360C:  MOVLB  0
0360E:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
043D4:  MOVLW  50
043D6:  MOVLB  A
043D8:  MOVWF  x2B
043DA:  MOVFF  A2A,A2F
043DE:  MOVFF  A29,A2E
043E2:  MOVFF  A28,A2D
043E6:  MOVFF  A27,A2C
043EA:  MOVLB  0
043EC:  CALL   3540
043F0:  MOVF   01,W
043F2:  BZ    43FA
043F4:  XORLW  40
043F6:  BZ    4410
043F8:  BRA    4416
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
043FA:  MOVFF  A2A,4EC
043FE:  MOVFF  A29,4EB
04402:  MOVFF  A28,4EA
04406:  MOVFF  A27,4E9
....................          return(TRUE); 
0440A:  MOVLW  01
0440C:  MOVWF  01
0440E:  BRA    441A
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
04410:  MOVLW  00
04412:  MOVWF  01
04414:  BRA    441A
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
04416:  MOVLW  00
04418:  MOVWF  01
....................       } 
0441A:  GOTO   44FE (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
0441E:  MOVF   FC9,W
04420:  SETF   FC9
04422:  RRCF   FC7,W
04424:  BNC   4422
04426:  MOVFF  FC9,A2F
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
0442A:  MOVLB  A
0442C:  CLRF   x2E
0442E:  CLRF   x2D
04430:  MOVF   x2E,W
04432:  SUBLW  27
04434:  BNC   445E
04436:  BNZ   443E
04438:  MOVF   x2D,W
0443A:  SUBLW  0F
0443C:  BNC   445E
0443E:  INCFSZ x2F,W
04440:  BRA    445E
....................       { 
....................       delay_us(10); 
04442:  MOVLW  35
04444:  MOVWF  00
04446:  DECFSZ 00,F
04448:  BRA    4446
....................       response = SD_spi_read(0xFF);  
0444A:  MOVF   FC9,W
0444C:  SETF   FC9
0444E:  RRCF   FC7,W
04450:  BNC   444E
04452:  MOVFF  FC9,A2F
04456:  INCF   x2D,F
04458:  BTFSC  FD8.2
0445A:  INCF   x2E,F
0445C:  BRA    4430
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
0445E:  MOVF   x2F,W
04460:  SUBLW  FE
04462:  BZ    4472
....................       { 
....................       if (!response) 
04464:  MOVF   x2F,F
04466:  BNZ   446C
....................          response = 0xFE; 
04468:  MOVLW  FE
0446A:  MOVWF  x2F
....................       return(response); 
0446C:  MOVFF  A2F,01
04470:  BRA    44C8
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
04472:  CLRF   x2E
04474:  CLRF   x2D
04476:  MOVF   x2C,F
04478:  BNZ   448C
0447A:  MOVF   x2B,F
0447C:  BNZ   448C
0447E:  MOVF   x2E,W
04480:  SUBWF  x2A,W
04482:  BNC   44AC
04484:  BNZ   448C
04486:  MOVF   x29,W
04488:  SUBWF  x2D,W
0448A:  BC    44AC
....................       ptr[i]=SD_spi_read(0xFF); 
0448C:  MOVF   x27,W
0448E:  ADDWF  x2D,W
04490:  MOVWF  FE9
04492:  MOVF   x28,W
04494:  ADDWFC x2E,W
04496:  MOVWF  FEA
04498:  MOVF   FC9,W
0449A:  SETF   FC9
0449C:  RRCF   FC7,W
0449E:  BNC   449C
044A0:  MOVFF  FC9,FEF
044A4:  INCF   x2D,F
044A6:  BTFSC  FD8.2
044A8:  INCF   x2E,F
044AA:  BRA    4476
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
044AC:  MOVF   FC9,W
044AE:  SETF   FC9
044B0:  RRCF   FC7,W
044B2:  BNC   44B0
....................    SD_spi_read(0xFF); 
044B4:  MOVF   FC9,W
044B6:  SETF   FC9
044B8:  RRCF   FC7,W
044BA:  BNC   44B8
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
044BC:  MOVF   FC9,W
044BE:  SETF   FC9
044C0:  RRCF   FC7,W
044C2:  BNC   44C0
....................    return(0); 
044C4:  MOVLW  00
044C6:  MOVWF  01
044C8:  MOVLB  0
044CA:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
05846:  MOVLW  C3
05848:  MOVLB  A
0584A:  MOVWF  x2F
0584C:  MOVLW  50
0584E:  MOVWF  x2E
....................    SD_spi_read(0xFF); 
05850:  MOVF   FC9,W
05852:  SETF   FC9
05854:  RRCF   FC7,W
05856:  BNC   5854
....................    do 
....................       { 
....................       delay_us(10); 
05858:  MOVLW  35
0585A:  MOVWF  00
0585C:  DECFSZ 00,F
0585E:  BRA    585C
....................       response = SD_spi_read(0xFF); 
05860:  MOVF   FC9,W
05862:  SETF   FC9
05864:  RRCF   FC7,W
05866:  BNC   5864
05868:  MOVFF  FC9,A2D
....................       Timer--; 
0586C:  MOVF   x2E,W
0586E:  BTFSC  FD8.2
05870:  DECF   x2F,F
05872:  DECF   x2E,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
05874:  INCFSZ x2D,W
05876:  BRA    587A
05878:  BRA    5880
0587A:  MOVF   x2E,W
0587C:  IORWF  x2F,W
0587E:  BNZ   5858
....................       ; 
....................  
....................    return (response); 
05880:  MOVFF  A2D,01
05884:  MOVLB  0
05886:  GOTO   5896 (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
0588A:  MOVLW  02
0588C:  MOVLB  A
0588E:  MOVWF  x2C
05890:  CLRF   x2B
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
05892:  MOVLB  0
05894:  BRA    5846
05896:  INCFSZ 01,W
05898:  BRA    589C
0589A:  BRA    58A2
....................       return (FALSE); 
0589C:  MOVLW  00
0589E:  MOVWF  01
058A0:  BRA    593C
....................  
....................    SD_spi_write(token);               // transmit data token 
058A2:  MOVF   FC9,W
058A4:  MOVFF  A29,FC9
058A8:  RRCF   FC7,W
058AA:  BNC   58A8
....................    if (token != 0xFD) 
058AC:  MOVLB  A
058AE:  MOVF   x29,W
058B0:  SUBLW  FD
058B2:  BZ    5936
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
058B4:  MOVFF  A2C,03
058B8:  MOVF   x2B,W
058BA:  BTFSC  FD8.2
058BC:  DECF   x2C,F
058BE:  DECF   x2B,F
058C0:  IORWF  03,W
058C2:  BZ    58E6
....................          SD_spi_write(*ptr++); 
058C4:  MOVFF  A28,03
058C8:  MOVF   x27,W
058CA:  INCF   x27,F
058CC:  BTFSC  FD8.2
058CE:  INCF   x28,F
058D0:  MOVWF  FE9
058D2:  MOVFF  03,FEA
058D6:  MOVFF  FEF,A2D
058DA:  MOVF   FC9,W
058DC:  MOVFF  A2D,FC9
058E0:  RRCF   FC7,W
058E2:  BNC   58E0
058E4:  BRA    58B4
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
058E6:  MOVF   FC9,W
058E8:  SETF   FC9
058EA:  RRCF   FC7,W
058EC:  BNC   58EA
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
058EE:  MOVF   FC9,W
058F0:  SETF   FC9
058F2:  RRCF   FC7,W
058F4:  BNC   58F2
....................       response = SD_spi_read(0xFF);      // Receive data response 
058F6:  MOVF   FC9,W
058F8:  SETF   FC9
058FA:  RRCF   FC7,W
058FC:  BNC   58FA
058FE:  MOVFF  FC9,A2A
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
05902:  CLRF   x2C
05904:  CLRF   x2B
05906:  MOVF   x2C,W
05908:  SUBLW  C3
0590A:  BNC   5936
0590C:  BNZ   5914
0590E:  MOVF   x2B,W
05910:  SUBLW  4F
05912:  BNC   5936
....................          { 
....................          delay_us(10); 
05914:  MOVLW  35
05916:  MOVWF  00
05918:  DECFSZ 00,F
0591A:  BRA    5918
....................          response = SD_spi_read(0xFF);   // digest prior operation 
0591C:  MOVF   FC9,W
0591E:  SETF   FC9
05920:  RRCF   FC7,W
05922:  BNC   5920
05924:  MOVFF  FC9,A2A
....................          if (response != 0x00) 
05928:  MOVF   x2A,F
0592A:  BZ    592E
....................             break; 
0592C:  BRA    5936
0592E:  INCF   x2B,F
05930:  BTFSC  FD8.2
05932:  INCF   x2C,F
05934:  BRA    5906
....................          } 
....................  
....................       } 
....................    return(TRUE); 
05936:  MOVLW  01
05938:  MOVWF  01
0593A:  MOVLB  0
0593C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
0593E:  MOVLB  4
05940:  BTFSS  xED.0
05942:  BRA    594A
....................       return (RES_NOTRDY); 
05944:  MOVLW  03
05946:  MOVWF  01
05948:  BRA    5A7E
....................  
....................    if (Media_Status & STA_PROTECT) 
0594A:  BTFSS  xED.2
0594C:  BRA    5954
....................       return (RES_WRPRT); 
0594E:  MOVLW  02
05950:  MOVWF  01
05952:  BRA    5A7E
....................  
....................    if (!SectorCount) 
05954:  MOVLB  A
05956:  MOVF   x26,F
05958:  BNZ   5964
....................       return (RES_PARERR); 
0595A:  MOVLW  04
0595C:  MOVWF  01
0595E:  MOVLB  4
05960:  BRA    5A7E
05962:  MOVLB  A
....................  
....................    SelectSD; 
05964:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
05966:  MOVLB  4
05968:  MOVF   xE7,W
0596A:  SUBLW  05
0596C:  BZ    5988
....................       SectorNumber *= 512; 
0596E:  BCF    FD8.0
05970:  MOVFF  A24,A25
05974:  MOVFF  A23,A24
05978:  MOVFF  A22,A23
0597C:  MOVLB  A
0597E:  CLRF   x22
05980:  RLCF   x23,F
05982:  RLCF   x24,F
05984:  RLCF   x25,F
05986:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
05988:  MOVLB  A
0598A:  DECFSZ x26,W
0598C:  BRA    59CC
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
0598E:  MOVLW  58
05990:  MOVWF  x2B
05992:  MOVFF  A25,A2F
05996:  MOVFF  A24,A2E
0599A:  MOVFF  A23,A2D
0599E:  MOVFF  A22,A2C
059A2:  MOVLB  0
059A4:  CALL   3540
059A8:  MOVF   01,F
059AA:  BNZ   59C8
....................          if (SD_write_data(Buffer, 0xFE)) 
059AC:  MOVFF  A21,A28
059B0:  MOVFF  A20,A27
059B4:  MOVLW  FE
059B6:  MOVLB  A
059B8:  MOVWF  x29
059BA:  MOVLB  0
059BC:  RCALL  588A
059BE:  MOVF   01,F
059C0:  BZ    59C8
....................             SectorCount = 0; 
059C2:  MOVLB  A
059C4:  CLRF   x26
059C6:  MOVLB  0
....................       } 
059C8:  BRA    5A64
059CA:  MOVLB  A
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
059CC:  MOVLB  4
059CE:  MOVF   xE7,W
059D0:  ANDLW  03
059D2:  BZ    5A00
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
059D4:  MOVLW  77
059D6:  MOVLB  A
059D8:  MOVWF  x2B
059DA:  CLRF   x2F
059DC:  CLRF   x2E
059DE:  CLRF   x2D
059E0:  CLRF   x2C
059E2:  MOVLB  0
059E4:  CALL   3540
....................          SD_cmd(SD_ACMD23, SectorCount); 
059E8:  MOVLW  57
059EA:  MOVLB  A
059EC:  MOVWF  x2B
059EE:  CLRF   x2F
059F0:  CLRF   x2E
059F2:  CLRF   x2D
059F4:  MOVFF  A26,A2C
059F8:  MOVLB  0
059FA:  CALL   3540
059FE:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05A00:  MOVLW  59
05A02:  MOVLB  A
05A04:  MOVWF  x2B
05A06:  MOVFF  A25,A2F
05A0A:  MOVFF  A24,A2E
05A0E:  MOVFF  A23,A2D
05A12:  MOVFF  A22,A2C
05A16:  MOVLB  0
05A18:  CALL   3540
05A1C:  MOVF   01,F
05A1E:  BNZ   5A64
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
05A20:  MOVFF  A21,A28
05A24:  MOVFF  A20,A27
05A28:  MOVLW  FC
05A2A:  MOVLB  A
05A2C:  MOVWF  x29
05A2E:  MOVLB  0
05A30:  RCALL  588A
05A32:  MOVF   01,F
05A34:  BNZ   5A38
....................                break; 
05A36:  BRA    5A4A
....................             Buffer += 512; 
05A38:  MOVLW  02
05A3A:  MOVLB  A
05A3C:  ADDWF  x21,F
....................             } while (--SectorCount); 
05A3E:  DECF   x26,F
05A40:  BTFSC  FD8.2
05A42:  BRA    5A48
05A44:  MOVLB  0
05A46:  BRA    5A20
05A48:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
05A4A:  MOVLB  A
05A4C:  CLRF   x28
05A4E:  CLRF   x27
05A50:  MOVLW  FD
05A52:  MOVWF  x29
05A54:  MOVLB  0
05A56:  RCALL  588A
05A58:  MOVF   01,F
05A5A:  BNZ   5A64
....................             SectorCount = 1; 
05A5C:  MOVLW  01
05A5E:  MOVLB  A
05A60:  MOVWF  x26
05A62:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
05A64:  BSF    F91.1
....................    SD_spi_read(0xFF); 
05A66:  MOVF   FC9,W
05A68:  SETF   FC9
05A6A:  RRCF   FC7,W
05A6C:  BNC   5A6A
....................    return SectorCount ? RES_ERROR : RES_OK; 
05A6E:  MOVLB  A
05A70:  MOVF   x26,F
05A72:  BZ    5A78
05A74:  MOVLW  01
05A76:  BRA    5A7A
05A78:  MOVLW  00
05A7A:  MOVWF  01
05A7C:  MOVLB  4
05A7E:  MOVLB  0
05A80:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
044CC:  MOVLB  4
044CE:  BTFSS  xED.0
044D0:  BRA    44D8
....................       return (RES_NOTRDY); 
044D2:  MOVLW  03
044D4:  MOVWF  01
044D6:  BRA    4608
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
044D8:  MOVLB  A
044DA:  MOVF   x26,W
044DC:  SUBLW  01
044DE:  BNC   44E4
044E0:  MOVF   x26,F
044E2:  BNZ   44EE
....................       return(RES_PARERR); 
044E4:  MOVLW  04
044E6:  MOVWF  01
044E8:  MOVLB  4
044EA:  BRA    4608
044EC:  MOVLB  A
....................  
....................    SelectSD; 
044EE:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
044F0:  CLRF   x2A
044F2:  CLRF   x29
044F4:  MOVLW  02
044F6:  MOVWF  x28
044F8:  CLRF   x27
044FA:  MOVLB  0
044FC:  BRA    43D4
044FE:  MOVF   01,F
04500:  BNZ   450E
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
04502:  BSF    F91.1
....................       return(RES_ERROR); 
04504:  MOVLW  01
04506:  MOVWF  01
04508:  MOVLB  4
0450A:  BRA    4608
0450C:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
0450E:  MOVLB  4
04510:  MOVF   xE7,W
04512:  SUBLW  05
04514:  BZ    4530
....................       SectorNumber *= 512; 
04516:  BCF    FD8.0
04518:  MOVFF  A24,A25
0451C:  MOVFF  A23,A24
04520:  MOVFF  A22,A23
04524:  MOVLB  A
04526:  CLRF   x22
04528:  RLCF   x23,F
0452A:  RLCF   x24,F
0452C:  RLCF   x25,F
0452E:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
04530:  MOVLB  A
04532:  DECFSZ x26,W
04534:  BRA    458C
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
04536:  MOVLW  51
04538:  MOVWF  x2B
0453A:  MOVFF  A25,A2F
0453E:  MOVFF  A24,A2E
04542:  MOVFF  A23,A2D
04546:  MOVFF  A22,A2C
0454A:  MOVLB  0
0454C:  CALL   3540
04550:  MOVF   01,F
04552:  BZ    4560
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
04554:  BSF    F91.1
....................          return(RES_PARERR); 
04556:  MOVLW  04
04558:  MOVWF  01
0455A:  MOVLB  4
0455C:  BRA    4608
0455E:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
04560:  MOVFF  A21,A28
04564:  MOVFF  A20,A27
04568:  MOVLB  A
0456A:  CLRF   x2C
0456C:  CLRF   x2B
0456E:  MOVLW  02
04570:  MOVWF  x2A
04572:  CLRF   x29
04574:  MOVLB  0
04576:  RCALL  441E
04578:  MOVF   01,F
0457A:  BZ    4588
....................          { 
....................          DeselectSD; 
0457C:  BSF    F91.1
....................          return(RES_ERROR); 
0457E:  MOVLW  01
04580:  MOVWF  01
04582:  MOVLB  4
04584:  BRA    4608
04586:  MOVLB  0
....................          } 
....................       } 
04588:  BRA    4600
0458A:  MOVLB  A
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
0458C:  MOVLW  52
0458E:  MOVWF  x2B
04590:  MOVFF  A25,A2F
04594:  MOVFF  A24,A2E
04598:  MOVFF  A23,A2D
0459C:  MOVFF  A22,A2C
045A0:  MOVLB  0
045A2:  CALL   3540
045A6:  MOVF   01,F
045A8:  BZ    45B6
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
045AA:  BSF    F91.1
....................          return(RES_PARERR); 
045AC:  MOVLW  04
045AE:  MOVWF  01
045B0:  MOVLB  4
045B2:  BRA    4608
045B4:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
045B6:  MOVFF  A21,A28
045BA:  MOVFF  A20,A27
045BE:  MOVLB  A
045C0:  CLRF   x2C
045C2:  CLRF   x2B
045C4:  MOVLW  02
045C6:  MOVWF  x2A
045C8:  CLRF   x29
045CA:  MOVLB  0
045CC:  RCALL  441E
045CE:  MOVF   01,F
045D0:  BZ    45DE
....................             { 
....................             DeselectSD; 
045D2:  BSF    F91.1
....................             return(RES_ERROR); 
045D4:  MOVLW  01
045D6:  MOVWF  01
045D8:  MOVLB  4
045DA:  BRA    4608
045DC:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
045DE:  MOVLW  02
045E0:  MOVLB  A
045E2:  ADDWF  x21,F
....................          } while (--SectorCount); 
045E4:  DECF   x26,F
045E6:  BTFSC  FD8.2
045E8:  BRA    45EE
045EA:  MOVLB  0
045EC:  BRA    45B6
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
045EE:  MOVLW  4C
045F0:  MOVWF  x2B
045F2:  CLRF   x2F
045F4:  CLRF   x2E
045F6:  CLRF   x2D
045F8:  CLRF   x2C
045FA:  MOVLB  0
045FC:  CALL   3540
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
04600:  BSF    F91.1
....................    return(RES_OK); 
04602:  MOVLW  00
04604:  MOVWF  01
04606:  MOVLB  4
04608:  MOVLB  0
0460A:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
0559E:  MOVLB  4
055A0:  BCF    xED.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
055A2:  BCF    xED.2
....................  
....................    return(Media_Status); 
055A4:  MOVFF  4ED,01
055A8:  MOVLB  0
055AA:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
03676:  MOVLB  9
03678:  CLRF   xEB
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
0367A:  MOVLB  4
0367C:  CLRF   xE7
....................  
....................    DeselectSD; 
0367E:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
03680:  MOVLW  0A
03682:  MOVLB  9
03684:  MOVWF  xEC
03686:  MOVLB  0
03688:  CALL   2910
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
0368C:  BCF    FC6.5
0368E:  MOVLW  22
03690:  MOVWF  FC6
03692:  MOVLW  40
03694:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
03696:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
03698:  MOVLB  9
0369A:  CLRF   xE3
0369C:  MOVF   xE3,W
0369E:  SUBLW  09
036A0:  BNC   36AE
....................       SD_spi_read(0xFF); 
036A2:  MOVF   FC9,W
036A4:  SETF   FC9
036A6:  RRCF   FC7,W
036A8:  BNC   36A6
036AA:  INCF   xE3,F
036AC:  BRA    369C
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
036AE:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
036B0:  MOVF   1F,W
036B2:  SUBLW  04
036B4:  BNZ   36DA
036B6:  MOVF   20,F
036B8:  BNZ   36DA
036BA:  MOVLW  76
036BC:  MOVWF  FF6
036BE:  MOVLW  06
036C0:  MOVWF  FF7
036C2:  MOVLW  00
036C4:  MOVWF  FF8
036C6:  CLRF   1B
036C8:  BTFSC  FF2.7
036CA:  BSF    1B.7
036CC:  BCF    FF2.7
036CE:  MOVLB  0
036D0:  CALL   0E4E
036D4:  BTFSC  1B.7
036D6:  BSF    FF2.7
036D8:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
036DA:  MOVLW  40
036DC:  MOVLB  A
036DE:  MOVWF  x2B
036E0:  CLRF   x2F
036E2:  CLRF   x2E
036E4:  CLRF   x2D
036E6:  CLRF   x2C
036E8:  MOVLB  0
036EA:  RCALL  3540
036EC:  MOVFF  01,9E4
....................    if (response > 1 ) 
036F0:  MOVLB  9
036F2:  MOVF   xE4,W
036F4:  SUBLW  01
036F6:  BC    374C
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
036F8:  MOVF   1F,W
036FA:  SUBLW  04
036FC:  BNZ   3746
036FE:  MOVF   20,F
03700:  BNZ   3746
03702:  MOVLW  86
03704:  MOVWF  FF6
03706:  MOVLW  06
03708:  MOVWF  FF7
0370A:  MOVLW  00
0370C:  MOVWF  FF8
0370E:  CLRF   1B
03710:  BTFSC  FF2.7
03712:  BSF    1B.7
03714:  BCF    FF2.7
03716:  MOVLW  31
03718:  MOVLB  A
0371A:  MOVWF  x40
0371C:  MOVLB  0
0371E:  CALL   1024
03722:  BTFSC  1B.7
03724:  BSF    FF2.7
03726:  MOVFF  9E4,9EC
0372A:  MOVLW  57
0372C:  MOVLB  9
0372E:  MOVWF  xED
03730:  MOVLB  0
03732:  RCALL  3610
03734:  MOVLW  0D
03736:  BTFSS  F9E.4
03738:  BRA    3736
0373A:  MOVWF  FAD
0373C:  MOVLW  0A
0373E:  BTFSS  F9E.4
03740:  BRA    373E
03742:  MOVWF  FAD
03744:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
03746:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
03748:  GOTO   43CA
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
0374C:  MOVF   1F,W
0374E:  SUBLW  04
03750:  BNZ   379A
03752:  MOVF   20,F
03754:  BNZ   379A
03756:  MOVLW  BE
03758:  MOVWF  FF6
0375A:  MOVLW  06
0375C:  MOVWF  FF7
0375E:  MOVLW  00
03760:  MOVWF  FF8
03762:  CLRF   1B
03764:  BTFSC  FF2.7
03766:  BSF    1B.7
03768:  BCF    FF2.7
0376A:  MOVLW  1A
0376C:  MOVLB  A
0376E:  MOVWF  x40
03770:  MOVLB  0
03772:  CALL   1024
03776:  BTFSC  1B.7
03778:  BSF    FF2.7
0377A:  MOVFF  9E4,9EC
0377E:  MOVLW  57
03780:  MOVLB  9
03782:  MOVWF  xED
03784:  MOVLB  0
03786:  RCALL  3610
03788:  MOVLW  0D
0378A:  BTFSS  F9E.4
0378C:  BRA    378A
0378E:  MOVWF  FAD
03790:  MOVLW  0A
03792:  BTFSS  F9E.4
03794:  BRA    3792
03796:  MOVWF  FAD
03798:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
0379A:  MOVLW  48
0379C:  MOVLB  A
0379E:  MOVWF  x2B
037A0:  CLRF   x2F
037A2:  CLRF   x2E
037A4:  MOVLW  01
037A6:  MOVWF  x2D
037A8:  MOVLW  AA
037AA:  MOVWF  x2C
037AC:  MOVLB  0
037AE:  RCALL  3540
037B0:  MOVFF  01,9E4
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
037B4:  MOVF   1F,W
037B6:  SUBLW  04
037B8:  BNZ   3800
037BA:  MOVF   20,F
037BC:  BNZ   3800
037BE:  MOVLW  E0
037C0:  MOVWF  FF6
037C2:  MOVLW  06
037C4:  MOVWF  FF7
037C6:  MOVLW  00
037C8:  MOVWF  FF8
037CA:  CLRF   1B
037CC:  BTFSC  FF2.7
037CE:  BSF    1B.7
037D0:  BCF    FF2.7
037D2:  MOVLW  25
037D4:  MOVLB  A
037D6:  MOVWF  x40
037D8:  MOVLB  0
037DA:  CALL   1024
037DE:  BTFSC  1B.7
037E0:  BSF    FF2.7
037E2:  MOVFF  9E4,9EC
037E6:  MOVLW  57
037E8:  MOVLB  9
037EA:  MOVWF  xED
037EC:  MOVLB  0
037EE:  RCALL  3610
037F0:  MOVLW  0D
037F2:  BTFSS  F9E.4
037F4:  BRA    37F2
037F6:  MOVWF  FAD
037F8:  MOVLW  0A
037FA:  BTFSS  F9E.4
037FC:  BRA    37FA
037FE:  MOVWF  FAD
....................    if (response == 1)  
03800:  MOVLB  9
03802:  DECFSZ xE4,W
03804:  BRA    3BD6
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
03806:  MOVF   1F,W
03808:  SUBLW  04
0380A:  BNZ   3830
0380C:  MOVF   20,F
0380E:  BNZ   3830
03810:  MOVLW  0A
03812:  MOVWF  FF6
03814:  MOVLW  07
03816:  MOVWF  FF7
03818:  MOVLW  00
0381A:  MOVWF  FF8
0381C:  CLRF   1B
0381E:  BTFSC  FF2.7
03820:  BSF    1B.7
03822:  BCF    FF2.7
03824:  MOVLB  0
03826:  CALL   0E4E
0382A:  BTFSC  1B.7
0382C:  BSF    FF2.7
0382E:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
03830:  CLRF   xE3
03832:  MOVF   xE3,W
03834:  SUBLW  03
03836:  BNC   3856
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
03838:  CLRF   03
0383A:  MOVF   xE3,W
0383C:  ADDLW  E5
0383E:  MOVWF  FE9
03840:  MOVLW  09
03842:  ADDWFC 03,W
03844:  MOVWF  FEA
03846:  MOVF   FC9,W
03848:  SETF   FC9
0384A:  RRCF   FC7,W
0384C:  BNC   384A
0384E:  MOVFF  FC9,FEF
03852:  INCF   xE3,F
03854:  BRA    3832
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
03856:  MOVF   1F,W
03858:  SUBLW  04
0385A:  BNZ   38CE
0385C:  MOVF   20,F
0385E:  BNZ   38CE
03860:  MOVLW  2C
03862:  MOVWF  FF6
03864:  MOVLW  07
03866:  MOVWF  FF7
03868:  MOVLW  00
0386A:  MOVWF  FF8
0386C:  CLRF   1B
0386E:  BTFSC  FF2.7
03870:  BSF    1B.7
03872:  BCF    FF2.7
03874:  MOVLW  1F
03876:  MOVLB  A
03878:  MOVWF  x40
0387A:  MOVLB  0
0387C:  CALL   1024
03880:  BTFSC  1B.7
03882:  BSF    FF2.7
03884:  MOVFF  9E5,9EC
03888:  MOVLW  57
0388A:  MOVLB  9
0388C:  MOVWF  xED
0388E:  MOVLB  0
03890:  RCALL  3610
03892:  MOVFF  9E6,9EC
03896:  MOVLW  57
03898:  MOVLB  9
0389A:  MOVWF  xED
0389C:  MOVLB  0
0389E:  RCALL  3610
038A0:  MOVFF  9E7,9EC
038A4:  MOVLW  57
038A6:  MOVLB  9
038A8:  MOVWF  xED
038AA:  MOVLB  0
038AC:  RCALL  3610
038AE:  MOVFF  9E8,9EC
038B2:  MOVLW  57
038B4:  MOVLB  9
038B6:  MOVWF  xED
038B8:  MOVLB  0
038BA:  RCALL  3610
038BC:  MOVLW  0D
038BE:  BTFSS  F9E.4
038C0:  BRA    38BE
038C2:  MOVWF  FAD
038C4:  MOVLW  0A
038C6:  BTFSS  F9E.4
038C8:  BRA    38C6
038CA:  MOVWF  FAD
038CC:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
038CE:  DECFSZ xE7,W
038D0:  BRA    3BAC
038D2:  MOVF   xE8,W
038D4:  SUBLW  AA
038D6:  BTFSS  FD8.2
038D8:  BRA    3BAC
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
038DA:  MOVF   1F,W
038DC:  SUBLW  04
038DE:  BNZ   3904
038E0:  MOVF   20,F
038E2:  BNZ   3904
038E4:  MOVLW  5E
038E6:  MOVWF  FF6
038E8:  MOVLW  07
038EA:  MOVWF  FF7
038EC:  MOVLW  00
038EE:  MOVWF  FF8
038F0:  CLRF   1B
038F2:  BTFSC  FF2.7
038F4:  BSF    1B.7
038F6:  BCF    FF2.7
038F8:  MOVLB  0
038FA:  CALL   0E4E
038FE:  BTFSC  1B.7
03900:  BSF    FF2.7
03902:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
03904:  MOVF   1F,W
03906:  SUBLW  04
03908:  BNZ   392E
0390A:  MOVF   20,F
0390C:  BNZ   392E
0390E:  MOVLW  84
03910:  MOVWF  FF6
03912:  MOVLW  07
03914:  MOVWF  FF7
03916:  MOVLW  00
03918:  MOVWF  FF8
0391A:  CLRF   1B
0391C:  BTFSC  FF2.7
0391E:  BSF    1B.7
03920:  BCF    FF2.7
03922:  MOVLB  0
03924:  CALL   0E4E
03928:  BTFSC  1B.7
0392A:  BSF    FF2.7
0392C:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
0392E:  CLRF   xEA
03930:  CLRF   xE9
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
03932:  MOVLW  77
03934:  MOVLB  A
03936:  MOVWF  x2B
03938:  CLRF   x2F
0393A:  CLRF   x2E
0393C:  CLRF   x2D
0393E:  CLRF   x2C
03940:  MOVLB  0
03942:  RCALL  3540
03944:  MOVFF  01,9E4
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
03948:  MOVLW  69
0394A:  MOVLB  A
0394C:  MOVWF  x2B
0394E:  MOVLW  40
03950:  MOVWF  x2F
03952:  CLRF   x2E
03954:  CLRF   x2D
03956:  CLRF   x2C
03958:  MOVLB  0
0395A:  RCALL  3540
0395C:  MOVFF  01,9E4
....................          while (response && (Timer < 50000)) 
03960:  MOVLB  9
03962:  MOVF   xE4,F
03964:  BZ    39B6
03966:  MOVF   xEA,W
03968:  SUBLW  C3
0396A:  BNC   39B6
0396C:  BNZ   3974
0396E:  MOVF   xE9,W
03970:  SUBLW  4F
03972:  BNC   39B6
....................          { 
....................             delay_us(20); 
03974:  MOVLW  6A
03976:  MOVWF  00
03978:  DECFSZ 00,F
0397A:  BRA    3978
0397C:  NOP   
....................             Timer++; 
0397E:  INCF   xE9,F
03980:  BTFSC  FD8.2
03982:  INCF   xEA,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
03984:  MOVLW  77
03986:  MOVLB  A
03988:  MOVWF  x2B
0398A:  CLRF   x2F
0398C:  CLRF   x2E
0398E:  CLRF   x2D
03990:  CLRF   x2C
03992:  MOVLB  0
03994:  RCALL  3540
03996:  MOVFF  01,9E4
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
0399A:  MOVLW  69
0399C:  MOVLB  A
0399E:  MOVWF  x2B
039A0:  MOVLW  40
039A2:  MOVWF  x2F
039A4:  CLRF   x2E
039A6:  CLRF   x2D
039A8:  CLRF   x2C
039AA:  MOVLB  0
039AC:  RCALL  3540
039AE:  MOVFF  01,9E4
039B2:  BRA    3960
039B4:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
039B6:  MOVF   1F,W
039B8:  SUBLW  04
039BA:  BNZ   3A44
039BC:  MOVF   20,F
039BE:  BNZ   3A44
039C0:  MOVLW  B2
039C2:  MOVWF  FF6
039C4:  MOVLW  07
039C6:  MOVWF  FF7
039C8:  MOVLW  00
039CA:  MOVWF  FF8
039CC:  CLRF   1B
039CE:  BTFSC  FF2.7
039D0:  BSF    1B.7
039D2:  BCF    FF2.7
039D4:  MOVLW  23
039D6:  MOVLB  A
039D8:  MOVWF  x40
039DA:  MOVLB  0
039DC:  CALL   1024
039E0:  BTFSC  1B.7
039E2:  BSF    FF2.7
039E4:  MOVFF  9E4,9EC
039E8:  MOVLW  57
039EA:  MOVLB  9
039EC:  MOVWF  xED
039EE:  MOVLB  0
039F0:  RCALL  3610
039F2:  MOVLW  D9
039F4:  MOVWF  FF6
039F6:  MOVLW  07
039F8:  MOVWF  FF7
039FA:  MOVLW  00
039FC:  MOVWF  FF8
039FE:  CLRF   1B
03A00:  BTFSC  FF2.7
03A02:  BSF    1B.7
03A04:  BCF    FF2.7
03A06:  MOVLW  0A
03A08:  MOVLB  A
03A0A:  MOVWF  x40
03A0C:  MOVLB  0
03A0E:  CALL   1024
03A12:  BTFSC  1B.7
03A14:  BSF    FF2.7
03A16:  MOVLW  10
03A18:  MOVWF  FE9
03A1A:  CLRF   1B
03A1C:  BTFSC  FF2.7
03A1E:  BSF    1B.7
03A20:  BCF    FF2.7
03A22:  MOVFF  9EA,A41
03A26:  MOVFF  9E9,A40
03A2A:  CALL   11A6
03A2E:  BTFSC  1B.7
03A30:  BSF    FF2.7
03A32:  MOVLW  0D
03A34:  BTFSS  F9E.4
03A36:  BRA    3A34
03A38:  MOVWF  FAD
03A3A:  MOVLW  0A
03A3C:  BTFSS  F9E.4
03A3E:  BRA    3A3C
03A40:  MOVWF  FAD
03A42:  MOVLB  9
....................          if (!response) 
03A44:  MOVF   xE4,F
03A46:  BTFSS  FD8.2
03A48:  BRA    3BAA
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
03A4A:  MOVLW  7A
03A4C:  MOVLB  A
03A4E:  MOVWF  x2B
03A50:  MOVLW  40
03A52:  MOVWF  x2F
03A54:  CLRF   x2E
03A56:  CLRF   x2D
03A58:  CLRF   x2C
03A5A:  MOVLB  0
03A5C:  RCALL  3540
03A5E:  MOVFF  01,9E4
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
03A62:  MOVF   1F,W
03A64:  SUBLW  04
03A66:  BNZ   3AAE
03A68:  MOVF   20,F
03A6A:  BNZ   3AAE
03A6C:  MOVLW  EA
03A6E:  MOVWF  FF6
03A70:  MOVLW  07
03A72:  MOVWF  FF7
03A74:  MOVLW  00
03A76:  MOVWF  FF8
03A78:  CLRF   1B
03A7A:  BTFSC  FF2.7
03A7C:  BSF    1B.7
03A7E:  BCF    FF2.7
03A80:  MOVLW  18
03A82:  MOVLB  A
03A84:  MOVWF  x40
03A86:  MOVLB  0
03A88:  CALL   1024
03A8C:  BTFSC  1B.7
03A8E:  BSF    FF2.7
03A90:  MOVFF  9E4,9EC
03A94:  MOVLW  57
03A96:  MOVLB  9
03A98:  MOVWF  xED
03A9A:  MOVLB  0
03A9C:  RCALL  3610
03A9E:  MOVLW  0D
03AA0:  BTFSS  F9E.4
03AA2:  BRA    3AA0
03AA4:  MOVWF  FAD
03AA6:  MOVLW  0A
03AA8:  BTFSS  F9E.4
03AAA:  BRA    3AA8
03AAC:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03AAE:  MOVLB  9
03AB0:  MOVF   xE4,F
03AB2:  BTFSS  FD8.2
03AB4:  BRA    3BAA
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03AB6:  CLRF   xE3
03AB8:  MOVF   xE3,W
03ABA:  SUBLW  03
03ABC:  BNC   3ADC
....................                   ocr[i] = SD_spi_read(0xFF); 
03ABE:  CLRF   03
03AC0:  MOVF   xE3,W
03AC2:  ADDLW  E5
03AC4:  MOVWF  FE9
03AC6:  MOVLW  09
03AC8:  ADDWFC 03,W
03ACA:  MOVWF  FEA
03ACC:  MOVF   FC9,W
03ACE:  SETF   FC9
03AD0:  RRCF   FC7,W
03AD2:  BNC   3AD0
03AD4:  MOVFF  FC9,FEF
03AD8:  INCF   xE3,F
03ADA:  BRA    3AB8
....................                if (ocr[0] & 0x40) 
03ADC:  BTFSS  xE5.6
03ADE:  BRA    3AEA
....................                   Card = SDHC; 
03AE0:  MOVLW  05
03AE2:  MOVLB  4
03AE4:  MOVWF  xE7
03AE6:  BRA    3AF0
03AE8:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03AEA:  MOVLW  04
03AEC:  MOVLB  4
03AEE:  MOVWF  xE7
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03AF0:  MOVF   1F,W
03AF2:  SUBLW  04
03AF4:  BNZ   3BA8
03AF6:  MOVF   20,F
03AF8:  BNZ   3BA8
03AFA:  MOVLW  08
03AFC:  MOVWF  FF6
03AFE:  MOVLW  08
03B00:  MOVWF  FF7
03B02:  MOVLW  00
03B04:  MOVWF  FF8
03B06:  CLRF   1B
03B08:  BTFSC  FF2.7
03B0A:  BSF    1B.7
03B0C:  BCF    FF2.7
03B0E:  MOVLW  1F
03B10:  MOVLB  A
03B12:  MOVWF  x40
03B14:  MOVLB  0
03B16:  CALL   1024
03B1A:  BTFSC  1B.7
03B1C:  BSF    FF2.7
03B1E:  MOVLW  10
03B20:  MOVWF  FE9
03B22:  CLRF   1B
03B24:  BTFSC  FF2.7
03B26:  BSF    1B.7
03B28:  BCF    FF2.7
03B2A:  MOVFF  9EA,A41
03B2E:  MOVFF  9E9,A40
03B32:  CALL   11A6
03B36:  BTFSC  1B.7
03B38:  BSF    FF2.7
03B3A:  MOVLW  2A
03B3C:  MOVWF  FF6
03B3E:  MOVLW  08
03B40:  MOVWF  FF7
03B42:  MOVLW  00
03B44:  MOVWF  FF8
03B46:  CLRF   1B
03B48:  BTFSC  FF2.7
03B4A:  BSF    1B.7
03B4C:  BCF    FF2.7
03B4E:  MOVLW  08
03B50:  MOVLB  A
03B52:  MOVWF  x40
03B54:  MOVLB  0
03B56:  CALL   1024
03B5A:  BTFSC  1B.7
03B5C:  BSF    FF2.7
03B5E:  MOVFF  9E5,9EC
03B62:  MOVLW  57
03B64:  MOVLB  9
03B66:  MOVWF  xED
03B68:  MOVLB  0
03B6A:  RCALL  3610
03B6C:  MOVFF  9E6,9EC
03B70:  MOVLW  57
03B72:  MOVLB  9
03B74:  MOVWF  xED
03B76:  MOVLB  0
03B78:  RCALL  3610
03B7A:  MOVFF  9E7,9EC
03B7E:  MOVLW  57
03B80:  MOVLB  9
03B82:  MOVWF  xED
03B84:  MOVLB  0
03B86:  RCALL  3610
03B88:  MOVFF  9E8,9EC
03B8C:  MOVLW  57
03B8E:  MOVLB  9
03B90:  MOVWF  xED
03B92:  MOVLB  0
03B94:  RCALL  3610
03B96:  MOVLW  0D
03B98:  BTFSS  F9E.4
03B9A:  BRA    3B98
03B9C:  MOVWF  FAD
03B9E:  MOVLW  0A
03BA0:  BTFSS  F9E.4
03BA2:  BRA    3BA0
03BA4:  MOVWF  FAD
03BA6:  MOVLB  4
03BA8:  MOVLB  9
....................             } 
....................          } 
....................       } 
03BAA:  BRA    3BD6
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03BAC:  MOVF   1F,W
03BAE:  SUBLW  04
03BB0:  BNZ   3BD6
03BB2:  MOVF   20,F
03BB4:  BNZ   3BD6
03BB6:  MOVLW  46
03BB8:  MOVWF  FF6
03BBA:  MOVLW  08
03BBC:  MOVWF  FF7
03BBE:  MOVLW  00
03BC0:  MOVWF  FF8
03BC2:  CLRF   1B
03BC4:  BTFSC  FF2.7
03BC6:  BSF    1B.7
03BC8:  BCF    FF2.7
03BCA:  MOVLB  0
03BCC:  CALL   0E4E
03BD0:  BTFSC  1B.7
03BD2:  BSF    FF2.7
03BD4:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03BD6:  MOVLB  4
03BD8:  MOVF   xE7,F
03BDA:  BTFSS  FD8.2
03BDC:  BRA    40AC
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03BDE:  MOVF   1F,W
03BE0:  SUBLW  04
03BE2:  BNZ   3C08
03BE4:  MOVF   20,F
03BE6:  BNZ   3C08
03BE8:  MOVLW  78
03BEA:  MOVWF  FF6
03BEC:  MOVLW  08
03BEE:  MOVWF  FF7
03BF0:  MOVLW  00
03BF2:  MOVWF  FF8
03BF4:  CLRF   1B
03BF6:  BTFSC  FF2.7
03BF8:  BSF    1B.7
03BFA:  BCF    FF2.7
03BFC:  MOVLB  0
03BFE:  CALL   0E4E
03C02:  BTFSC  1B.7
03C04:  BSF    FF2.7
03C06:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03C08:  MOVLW  40
03C0A:  MOVLB  A
03C0C:  MOVWF  x2B
03C0E:  CLRF   x2F
03C10:  CLRF   x2E
03C12:  CLRF   x2D
03C14:  CLRF   x2C
03C16:  MOVLB  0
03C18:  RCALL  3540
03C1A:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03C1E:  MOVF   1F,W
03C20:  SUBLW  04
03C22:  BNZ   3C6A
03C24:  MOVF   20,F
03C26:  BNZ   3C6A
03C28:  MOVLW  B8
03C2A:  MOVWF  FF6
03C2C:  MOVLW  08
03C2E:  MOVWF  FF7
03C30:  MOVLW  00
03C32:  MOVWF  FF8
03C34:  CLRF   1B
03C36:  BTFSC  FF2.7
03C38:  BSF    1B.7
03C3A:  BCF    FF2.7
03C3C:  MOVLW  1C
03C3E:  MOVLB  A
03C40:  MOVWF  x40
03C42:  MOVLB  0
03C44:  CALL   1024
03C48:  BTFSC  1B.7
03C4A:  BSF    FF2.7
03C4C:  MOVFF  9E4,9EC
03C50:  MOVLW  57
03C52:  MOVLB  9
03C54:  MOVWF  xED
03C56:  MOVLB  0
03C58:  RCALL  3610
03C5A:  MOVLW  0D
03C5C:  BTFSS  F9E.4
03C5E:  BRA    3C5C
03C60:  MOVWF  FAD
03C62:  MOVLW  0A
03C64:  BTFSS  F9E.4
03C66:  BRA    3C64
03C68:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03C6A:  MOVLB  9
03C6C:  DECFSZ xE4,W
03C6E:  BRA    3C72
03C70:  BRA    3C7C
03C72:  MOVF   xE4,F
03C74:  BZ    3C7C
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03C76:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03C78:  GOTO   43CA
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03C7C:  CLRF   xEA
03C7E:  CLRF   xE9
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03C80:  MOVLW  41
03C82:  MOVLB  A
03C84:  MOVWF  x2B
03C86:  CLRF   x2F
03C88:  CLRF   x2E
03C8A:  CLRF   x2D
03C8C:  CLRF   x2C
03C8E:  MOVLB  0
03C90:  RCALL  3540
03C92:  MOVFF  01,9E4
....................          if (response != 0x00 ) 
03C96:  MOVLB  9
03C98:  MOVF   xE4,F
03C9A:  BZ    3CA4
....................             delay_us(10); 
03C9C:  MOVLW  35
03C9E:  MOVWF  00
03CA0:  DECFSZ 00,F
03CA2:  BRA    3CA0
....................          Timer++; 
03CA4:  INCF   xE9,F
03CA6:  BTFSC  FD8.2
03CA8:  INCF   xEA,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03CAA:  MOVF   xE4,F
03CAC:  BZ    3CBC
03CAE:  MOVF   xEA,W
03CB0:  SUBLW  C3
03CB2:  BNC   3CBC
03CB4:  BNZ   3C80
03CB6:  MOVF   xE9,W
03CB8:  SUBLW  4F
03CBA:  BC    3C80
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03CBC:  MOVF   1F,W
03CBE:  SUBLW  04
03CC0:  BNZ   3D4A
03CC2:  MOVF   20,F
03CC4:  BNZ   3D4A
03CC6:  MOVLW  DC
03CC8:  MOVWF  FF6
03CCA:  MOVLW  08
03CCC:  MOVWF  FF7
03CCE:  MOVLW  00
03CD0:  MOVWF  FF8
03CD2:  CLRF   1B
03CD4:  BTFSC  FF2.7
03CD6:  BSF    1B.7
03CD8:  BCF    FF2.7
03CDA:  MOVLW  28
03CDC:  MOVLB  A
03CDE:  MOVWF  x40
03CE0:  MOVLB  0
03CE2:  CALL   1024
03CE6:  BTFSC  1B.7
03CE8:  BSF    FF2.7
03CEA:  MOVFF  9E4,9EC
03CEE:  MOVLW  57
03CF0:  MOVLB  9
03CF2:  MOVWF  xED
03CF4:  MOVLB  0
03CF6:  RCALL  3610
03CF8:  MOVLW  08
03CFA:  MOVWF  FF6
03CFC:  MOVLW  09
03CFE:  MOVWF  FF7
03D00:  MOVLW  00
03D02:  MOVWF  FF8
03D04:  CLRF   1B
03D06:  BTFSC  FF2.7
03D08:  BSF    1B.7
03D0A:  BCF    FF2.7
03D0C:  MOVLW  0A
03D0E:  MOVLB  A
03D10:  MOVWF  x40
03D12:  MOVLB  0
03D14:  CALL   1024
03D18:  BTFSC  1B.7
03D1A:  BSF    FF2.7
03D1C:  MOVLW  10
03D1E:  MOVWF  FE9
03D20:  CLRF   1B
03D22:  BTFSC  FF2.7
03D24:  BSF    1B.7
03D26:  BCF    FF2.7
03D28:  MOVFF  9EA,A41
03D2C:  MOVFF  9E9,A40
03D30:  CALL   11A6
03D34:  BTFSC  1B.7
03D36:  BSF    FF2.7
03D38:  MOVLW  0D
03D3A:  BTFSS  F9E.4
03D3C:  BRA    3D3A
03D3E:  MOVWF  FAD
03D40:  MOVLW  0A
03D42:  BTFSS  F9E.4
03D44:  BRA    3D42
03D46:  MOVWF  FAD
03D48:  MOVLB  9
....................       if(response) 
03D4A:  MOVF   xE4,F
03D4C:  BZ    3D52
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03D4E:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03D50:  BRA    43CA
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03D52:  MOVLW  77
03D54:  MOVLB  A
03D56:  MOVWF  x2B
03D58:  CLRF   x2F
03D5A:  CLRF   x2E
03D5C:  CLRF   x2D
03D5E:  CLRF   x2C
03D60:  MOVLB  0
03D62:  CALL   3540
03D66:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03D6A:  MOVF   1F,W
03D6C:  SUBLW  04
03D6E:  BNZ   3DB6
03D70:  MOVF   20,F
03D72:  BNZ   3DB6
03D74:  MOVLW  18
03D76:  MOVWF  FF6
03D78:  MOVLW  09
03D7A:  MOVWF  FF7
03D7C:  MOVLW  00
03D7E:  MOVWF  FF8
03D80:  CLRF   1B
03D82:  BTFSC  FF2.7
03D84:  BSF    1B.7
03D86:  BCF    FF2.7
03D88:  MOVLW  43
03D8A:  MOVLB  A
03D8C:  MOVWF  x40
03D8E:  MOVLB  0
03D90:  CALL   1024
03D94:  BTFSC  1B.7
03D96:  BSF    FF2.7
03D98:  MOVFF  9E4,9EC
03D9C:  MOVLW  57
03D9E:  MOVLB  9
03DA0:  MOVWF  xED
03DA2:  MOVLB  0
03DA4:  RCALL  3610
03DA6:  MOVLW  0D
03DA8:  BTFSS  F9E.4
03DAA:  BRA    3DA8
03DAC:  MOVWF  FAD
03DAE:  MOVLW  0A
03DB0:  BTFSS  F9E.4
03DB2:  BRA    3DB0
03DB4:  MOVWF  FAD
....................       if (response) 
03DB6:  MOVLB  9
03DB8:  MOVF   xE4,F
03DBA:  BZ    3DC6
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03DBC:  MOVLW  02
03DBE:  MOVLB  4
03DC0:  MOVWF  xE7
....................          } 
03DC2:  BRA    3FC0
03DC4:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03DC6:  MOVLW  69
03DC8:  MOVLB  A
03DCA:  MOVWF  x2B
03DCC:  CLRF   x2F
03DCE:  CLRF   x2E
03DD0:  CLRF   x2D
03DD2:  CLRF   x2C
03DD4:  MOVLB  0
03DD6:  CALL   3540
03DDA:  MOVFF  01,9E4
....................          if (response <= 1 ) 
03DDE:  MOVLB  9
03DE0:  MOVF   xE4,W
03DE2:  SUBLW  01
03DE4:  BNC   3DF0
....................             Card = SDv1; 
03DE6:  MOVLW  03
03DE8:  MOVLB  4
03DEA:  MOVWF  xE7
03DEC:  BRA    3FC0
03DEE:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03DF0:  MOVF   1F,W
03DF2:  SUBLW  04
03DF4:  BNZ   3E54
03DF6:  MOVF   20,F
03DF8:  BNZ   3E54
03DFA:  MOVLW  62
03DFC:  MOVWF  FF6
03DFE:  MOVLW  09
03E00:  MOVWF  FF7
03E02:  MOVLW  00
03E04:  MOVWF  FF8
03E06:  CLRF   1B
03E08:  BTFSC  FF2.7
03E0A:  BSF    1B.7
03E0C:  BCF    FF2.7
03E0E:  MOVLW  2E
03E10:  MOVLB  A
03E12:  MOVWF  x40
03E14:  MOVLB  0
03E16:  CALL   1024
03E1A:  BTFSC  1B.7
03E1C:  BSF    FF2.7
03E1E:  MOVFF  9E4,9EC
03E22:  MOVLW  37
03E24:  MOVLB  9
03E26:  MOVWF  xED
03E28:  MOVLB  0
03E2A:  CALL   3610
03E2E:  MOVLW  94
03E30:  MOVWF  FF6
03E32:  MOVLW  09
03E34:  MOVWF  FF7
03E36:  MOVLW  00
03E38:  MOVWF  FF8
03E3A:  CLRF   1B
03E3C:  BTFSC  FF2.7
03E3E:  BSF    1B.7
03E40:  BCF    FF2.7
03E42:  MOVLW  19
03E44:  MOVLB  A
03E46:  MOVWF  x40
03E48:  MOVLB  0
03E4A:  CALL   1024
03E4E:  BTFSC  1B.7
03E50:  BSF    FF2.7
03E52:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03E54:  MOVLW  40
03E56:  MOVLB  A
03E58:  MOVWF  x2B
03E5A:  CLRF   x2F
03E5C:  CLRF   x2E
03E5E:  CLRF   x2D
03E60:  CLRF   x2C
03E62:  MOVLB  0
03E64:  CALL   3540
03E68:  MOVFF  01,9E4
....................             if ((response !=0x01) && (response != 0)) 
03E6C:  MOVLB  9
03E6E:  DECFSZ xE4,W
03E70:  BRA    3E74
03E72:  BRA    3EE0
03E74:  MOVF   xE4,F
03E76:  BZ    3EE0
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03E78:  MOVF   1F,W
03E7A:  SUBLW  04
03E7C:  BNZ   3EDC
03E7E:  MOVF   20,F
03E80:  BNZ   3EDC
03E82:  MOVLW  AE
03E84:  MOVWF  FF6
03E86:  MOVLW  09
03E88:  MOVWF  FF7
03E8A:  MOVLW  00
03E8C:  MOVWF  FF8
03E8E:  CLRF   1B
03E90:  BTFSC  FF2.7
03E92:  BSF    1B.7
03E94:  BCF    FF2.7
03E96:  MOVLW  2C
03E98:  MOVLB  A
03E9A:  MOVWF  x40
03E9C:  MOVLB  0
03E9E:  CALL   1024
03EA2:  BTFSC  1B.7
03EA4:  BSF    FF2.7
03EA6:  MOVFF  9E4,9EC
03EAA:  MOVLW  37
03EAC:  MOVLB  9
03EAE:  MOVWF  xED
03EB0:  MOVLB  0
03EB2:  CALL   3610
03EB6:  MOVLW  DE
03EB8:  MOVWF  FF6
03EBA:  MOVLW  09
03EBC:  MOVWF  FF7
03EBE:  MOVLW  00
03EC0:  MOVWF  FF8
03EC2:  CLRF   1B
03EC4:  BTFSC  FF2.7
03EC6:  BSF    1B.7
03EC8:  BCF    FF2.7
03ECA:  MOVLW  0B
03ECC:  MOVLB  A
03ECE:  MOVWF  x40
03ED0:  MOVLB  0
03ED2:  CALL   1024
03ED6:  BTFSC  1B.7
03ED8:  BSF    FF2.7
03EDA:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03EDC:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03EDE:  BRA    43CA
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03EE0:  CLRF   xEA
03EE2:  CLRF   xE9
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03EE4:  MOVLW  41
03EE6:  MOVLB  A
03EE8:  MOVWF  x2B
03EEA:  CLRF   x2F
03EEC:  CLRF   x2E
03EEE:  CLRF   x2D
03EF0:  CLRF   x2C
03EF2:  MOVLB  0
03EF4:  CALL   3540
03EF8:  MOVFF  01,9E4
....................                if (response != 0x00 ) 
03EFC:  MOVLB  9
03EFE:  MOVF   xE4,F
03F00:  BZ    3F0A
....................                   delay_us(10); 
03F02:  MOVLW  35
03F04:  MOVWF  00
03F06:  DECFSZ 00,F
03F08:  BRA    3F06
....................                Timer++; 
03F0A:  INCF   xE9,F
03F0C:  BTFSC  FD8.2
03F0E:  INCF   xEA,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03F10:  MOVF   xE4,F
03F12:  BZ    3F22
03F14:  MOVF   xEA,W
03F16:  SUBLW  C3
03F18:  BNC   3F22
03F1A:  BNZ   3EE4
03F1C:  MOVF   xE9,W
03F1E:  SUBLW  4F
03F20:  BC    3EE4
....................     
....................             if(response) 
03F22:  MOVF   xE4,F
03F24:  BZ    3FBA
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03F26:  MOVF   1F,W
03F28:  SUBLW  04
03F2A:  BNZ   3FB6
03F2C:  MOVF   20,F
03F2E:  BNZ   3FB6
03F30:  MOVLW  EA
03F32:  MOVWF  FF6
03F34:  MOVLW  09
03F36:  MOVWF  FF7
03F38:  MOVLW  00
03F3A:  MOVWF  FF8
03F3C:  CLRF   1B
03F3E:  BTFSC  FF2.7
03F40:  BSF    1B.7
03F42:  BCF    FF2.7
03F44:  MOVLW  4A
03F46:  MOVLB  A
03F48:  MOVWF  x40
03F4A:  MOVLB  0
03F4C:  CALL   1024
03F50:  BTFSC  1B.7
03F52:  BSF    FF2.7
03F54:  MOVFF  9E4,9EC
03F58:  MOVLW  37
03F5A:  MOVLB  9
03F5C:  MOVWF  xED
03F5E:  MOVLB  0
03F60:  CALL   3610
03F64:  MOVLW  38
03F66:  MOVWF  FF6
03F68:  MOVLW  0A
03F6A:  MOVWF  FF7
03F6C:  MOVLW  00
03F6E:  MOVWF  FF8
03F70:  CLRF   1B
03F72:  BTFSC  FF2.7
03F74:  BSF    1B.7
03F76:  BCF    FF2.7
03F78:  MOVLW  0A
03F7A:  MOVLB  A
03F7C:  MOVWF  x40
03F7E:  MOVLB  0
03F80:  CALL   1024
03F84:  BTFSC  1B.7
03F86:  BSF    FF2.7
03F88:  MOVLW  10
03F8A:  MOVWF  FE9
03F8C:  CLRF   1B
03F8E:  BTFSC  FF2.7
03F90:  BSF    1B.7
03F92:  BCF    FF2.7
03F94:  MOVFF  9EA,A41
03F98:  MOVFF  9E9,A40
03F9C:  CALL   11A6
03FA0:  BTFSC  1B.7
03FA2:  BSF    FF2.7
03FA4:  MOVLW  0D
03FA6:  BTFSS  F9E.4
03FA8:  BRA    3FA6
03FAA:  MOVWF  FAD
03FAC:  MOVLW  0A
03FAE:  BTFSS  F9E.4
03FB0:  BRA    3FAE
03FB2:  MOVWF  FAD
03FB4:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03FB6:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03FB8:  BRA    43CA
....................                } 
....................  
....................             Card = MMC; 
03FBA:  MOVLW  02
03FBC:  MOVLB  4
03FBE:  MOVWF  xE7
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03FC0:  MOVF   1F,W
03FC2:  SUBLW  04
03FC4:  BNZ   3FEA
03FC6:  MOVF   20,F
03FC8:  BNZ   3FEA
03FCA:  MOVLW  48
03FCC:  MOVWF  FF6
03FCE:  MOVLW  0A
03FD0:  MOVWF  FF7
03FD2:  MOVLW  00
03FD4:  MOVWF  FF8
03FD6:  CLRF   1B
03FD8:  BTFSC  FF2.7
03FDA:  BSF    1B.7
03FDC:  BCF    FF2.7
03FDE:  MOVLB  0
03FE0:  CALL   0E4E
03FE4:  BTFSC  1B.7
03FE6:  BSF    FF2.7
03FE8:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
03FEA:  MOVLW  50
03FEC:  MOVLB  A
03FEE:  MOVWF  x2B
03FF0:  CLRF   x2F
03FF2:  CLRF   x2E
03FF4:  MOVLW  02
03FF6:  MOVWF  x2D
03FF8:  CLRF   x2C
03FFA:  MOVLB  0
03FFC:  CALL   3540
04000:  MOVFF  01,9E4
....................       if ((Timer == 50000) || (response > 1))    
04004:  MOVLB  9
04006:  MOVF   xE9,W
04008:  SUBLW  50
0400A:  BNZ   4012
0400C:  MOVF   xEA,W
0400E:  SUBLW  C3
04010:  BZ    4018
04012:  MOVF   xE4,W
04014:  SUBLW  01
04016:  BC    40AE
....................       { 
....................          Card = None; 
04018:  MOVLB  4
0401A:  CLRF   xE7
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
0401C:  MOVF   1F,W
0401E:  SUBLW  04
04020:  BNZ   40AC
04022:  MOVF   20,F
04024:  BNZ   40AC
04026:  MOVLW  64
04028:  MOVWF  FF6
0402A:  MOVLW  0A
0402C:  MOVWF  FF7
0402E:  MOVLW  00
04030:  MOVWF  FF8
04032:  CLRF   1B
04034:  BTFSC  FF2.7
04036:  BSF    1B.7
04038:  BCF    FF2.7
0403A:  MOVLW  2B
0403C:  MOVLB  A
0403E:  MOVWF  x40
04040:  MOVLB  0
04042:  CALL   1024
04046:  BTFSC  1B.7
04048:  BSF    FF2.7
0404A:  MOVFF  9E4,9EC
0404E:  MOVLW  57
04050:  MOVLB  9
04052:  MOVWF  xED
04054:  MOVLB  0
04056:  CALL   3610
0405A:  MOVLW  93
0405C:  MOVWF  FF6
0405E:  MOVLW  0A
04060:  MOVWF  FF7
04062:  MOVLW  00
04064:  MOVWF  FF8
04066:  CLRF   1B
04068:  BTFSC  FF2.7
0406A:  BSF    1B.7
0406C:  BCF    FF2.7
0406E:  MOVLW  0A
04070:  MOVLB  A
04072:  MOVWF  x40
04074:  MOVLB  0
04076:  CALL   1024
0407A:  BTFSC  1B.7
0407C:  BSF    FF2.7
0407E:  MOVLW  10
04080:  MOVWF  FE9
04082:  CLRF   1B
04084:  BTFSC  FF2.7
04086:  BSF    1B.7
04088:  BCF    FF2.7
0408A:  MOVFF  9EA,A41
0408E:  MOVFF  9E9,A40
04092:  CALL   11A6
04096:  BTFSC  1B.7
04098:  BSF    FF2.7
0409A:  MOVLW  0D
0409C:  BTFSS  F9E.4
0409E:  BRA    409C
040A0:  MOVWF  FAD
040A2:  MOVLW  0A
040A4:  BTFSS  F9E.4
040A6:  BRA    40A4
040A8:  MOVWF  FAD
040AA:  MOVLB  4
040AC:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
040AE:  MOVLB  4
040B0:  MOVF   xE7,F
040B2:  BNZ   40E6
....................    { 
....................       if (nv_report_mode == 4) 
040B4:  MOVF   1F,W
040B6:  SUBLW  04
040B8:  BNZ   40DE
040BA:  MOVF   20,F
040BC:  BNZ   40DE
....................          printf("@FS:Card Type Discovery Error\r\n"); 
040BE:  MOVLW  A4
040C0:  MOVWF  FF6
040C2:  MOVLW  0A
040C4:  MOVWF  FF7
040C6:  MOVLW  00
040C8:  MOVWF  FF8
040CA:  CLRF   1B
040CC:  BTFSC  FF2.7
040CE:  BSF    1B.7
040D0:  BCF    FF2.7
040D2:  MOVLB  0
040D4:  CALL   0E4E
040D8:  BTFSC  1B.7
040DA:  BSF    FF2.7
040DC:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
040DE:  MOVLB  9
040E0:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
040E2:  BRA    43CA
040E4:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
040E6:  MOVF   xE7,W
040E8:  XORLW  02
040EA:  MOVLB  0
040EC:  BZ    40FC
040EE:  XORLW  01
040F0:  BZ    4124
040F2:  XORLW  07
040F4:  BZ    414C
040F6:  XORLW  01
040F8:  BZ    4174
040FA:  BRA    419C
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
040FC:  MOVF   1F,W
040FE:  SUBLW  04
04100:  BNZ   4122
04102:  MOVF   20,F
04104:  BNZ   4122
04106:  MOVLW  C4
04108:  MOVWF  FF6
0410A:  MOVLW  0A
0410C:  MOVWF  FF7
0410E:  MOVLW  00
04110:  MOVWF  FF8
04112:  CLRF   1B
04114:  BTFSC  FF2.7
04116:  BSF    1B.7
04118:  BCF    FF2.7
0411A:  CALL   0E4E
0411E:  BTFSC  1B.7
04120:  BSF    FF2.7
....................          break; 
04122:  BRA    41F2
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
04124:  MOVF   1F,W
04126:  SUBLW  04
04128:  BNZ   414A
0412A:  MOVF   20,F
0412C:  BNZ   414A
0412E:  MOVLW  DA
04130:  MOVWF  FF6
04132:  MOVLW  0A
04134:  MOVWF  FF7
04136:  MOVLW  00
04138:  MOVWF  FF8
0413A:  CLRF   1B
0413C:  BTFSC  FF2.7
0413E:  BSF    1B.7
04140:  BCF    FF2.7
04142:  CALL   0E4E
04146:  BTFSC  1B.7
04148:  BSF    FF2.7
....................          break; 
0414A:  BRA    41F2
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
0414C:  MOVF   1F,W
0414E:  SUBLW  04
04150:  BNZ   4172
04152:  MOVF   20,F
04154:  BNZ   4172
04156:  MOVLW  F0
04158:  MOVWF  FF6
0415A:  MOVLW  0A
0415C:  MOVWF  FF7
0415E:  MOVLW  00
04160:  MOVWF  FF8
04162:  CLRF   1B
04164:  BTFSC  FF2.7
04166:  BSF    1B.7
04168:  BCF    FF2.7
0416A:  CALL   0E4E
0416E:  BTFSC  1B.7
04170:  BSF    FF2.7
....................          break; 
04172:  BRA    41F2
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
04174:  MOVF   1F,W
04176:  SUBLW  04
04178:  BNZ   419A
0417A:  MOVF   20,F
0417C:  BNZ   419A
0417E:  MOVLW  06
04180:  MOVWF  FF6
04182:  MOVLW  0B
04184:  MOVWF  FF7
04186:  MOVLW  00
04188:  MOVWF  FF8
0418A:  CLRF   1B
0418C:  BTFSC  FF2.7
0418E:  BSF    1B.7
04190:  BCF    FF2.7
04192:  CALL   0E4E
04196:  BTFSC  1B.7
04198:  BSF    FF2.7
....................          break; 
0419A:  BRA    41F2
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
0419C:  MOVF   1F,W
0419E:  SUBLW  04
041A0:  BNZ   41EA
041A2:  MOVF   20,F
041A4:  BNZ   41EA
041A6:  MOVLW  1C
041A8:  MOVWF  FF6
041AA:  MOVLW  0B
041AC:  MOVWF  FF7
041AE:  MOVLW  00
041B0:  MOVWF  FF8
041B2:  CLRF   1B
041B4:  BTFSC  FF2.7
041B6:  BSF    1B.7
041B8:  BCF    FF2.7
041BA:  MOVLW  26
041BC:  MOVLB  A
041BE:  MOVWF  x40
041C0:  MOVLB  0
041C2:  CALL   1024
041C6:  BTFSC  1B.7
041C8:  BSF    FF2.7
041CA:  MOVFF  4E7,9EC
041CE:  MOVLW  37
041D0:  MOVLB  9
041D2:  MOVWF  xED
041D4:  MOVLB  0
041D6:  CALL   3610
041DA:  MOVLW  0D
041DC:  BTFSS  F9E.4
041DE:  BRA    41DC
041E0:  MOVWF  FAD
041E2:  MOVLW  0A
041E4:  BTFSS  F9E.4
041E6:  BRA    41E4
041E8:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
041EA:  MOVLB  9
041EC:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
041EE:  BRA    43CA
041F0:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
041F2:  MOVLB  9
041F4:  BCF    xEB.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
041F6:  MOVF   1F,W
041F8:  SUBLW  04
041FA:  BNZ   4252
041FC:  MOVF   20,F
041FE:  BNZ   4252
04200:  MOVLW  4A
04202:  MOVWF  FF6
04204:  MOVLW  0B
04206:  MOVWF  FF7
04208:  MOVLW  00
0420A:  MOVWF  FF8
0420C:  CLRF   1B
0420E:  BTFSC  FF2.7
04210:  BSF    1B.7
04212:  BCF    FF2.7
04214:  MOVLW  2E
04216:  MOVLB  A
04218:  MOVWF  x40
0421A:  MOVLB  0
0421C:  CALL   1024
04220:  BTFSC  1B.7
04222:  BSF    FF2.7
04224:  MOVLW  10
04226:  MOVWF  FE9
04228:  CLRF   1B
0422A:  BTFSC  FF2.7
0422C:  BSF    1B.7
0422E:  BCF    FF2.7
04230:  MOVFF  9EA,A41
04234:  MOVFF  9E9,A40
04238:  CALL   11A6
0423C:  BTFSC  1B.7
0423E:  BSF    FF2.7
04240:  MOVLW  0D
04242:  BTFSS  F9E.4
04244:  BRA    4242
04246:  MOVWF  FAD
04248:  MOVLW  0A
0424A:  BTFSS  F9E.4
0424C:  BRA    424A
0424E:  MOVWF  FAD
04250:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
04252:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
04254:  BCF    FC6.5
04256:  MOVLW  20
04258:  MOVWF  FC6
0425A:  MOVLW  40
0425C:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
0425E:  BCF    F9E.3
....................    SelectSD; 
04260:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
04262:  MOVF   1F,W
04264:  SUBLW  04
04266:  BNZ   428C
04268:  MOVF   20,F
0426A:  BNZ   428C
0426C:  MOVLW  7E
0426E:  MOVWF  FF6
04270:  MOVLW  0B
04272:  MOVWF  FF7
04274:  MOVLW  00
04276:  MOVWF  FF8
04278:  CLRF   1B
0427A:  BTFSC  FF2.7
0427C:  BSF    1B.7
0427E:  BCF    FF2.7
04280:  MOVLB  0
04282:  CALL   0E4E
04286:  BTFSC  1B.7
04288:  BSF    FF2.7
0428A:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
0428C:  CLRF   xEA
0428E:  CLRF   xE9
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
04290:  MOVLW  41
04292:  MOVLB  A
04294:  MOVWF  x2B
04296:  CLRF   x2F
04298:  CLRF   x2E
0429A:  CLRF   x2D
0429C:  CLRF   x2C
0429E:  MOVLB  0
042A0:  CALL   3540
042A4:  MOVFF  01,9E4
....................       if (response != 0x00 ) 
042A8:  MOVLB  9
042AA:  MOVF   xE4,F
042AC:  BZ    42B6
....................          delay_us(10); 
042AE:  MOVLW  35
042B0:  MOVWF  00
042B2:  DECFSZ 00,F
042B4:  BRA    42B2
....................  
....................       Timer++; 
042B6:  INCF   xE9,F
042B8:  BTFSC  FD8.2
042BA:  INCF   xEA,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
042BC:  MOVF   xE4,F
042BE:  BZ    42CE
042C0:  MOVF   xEA,W
042C2:  SUBLW  C3
042C4:  BNC   42CE
042C6:  BNZ   4290
042C8:  MOVF   xE9,W
042CA:  SUBLW  4F
042CC:  BC    4290
....................  
....................    if (response != 0x00) 
042CE:  MOVF   xE4,F
042D0:  BZ    4366
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
042D2:  MOVF   1F,W
042D4:  SUBLW  04
042D6:  BNZ   4362
042D8:  MOVF   20,F
042DA:  BNZ   4362
042DC:  MOVLW  9E
042DE:  MOVWF  FF6
042E0:  MOVLW  0B
042E2:  MOVWF  FF7
042E4:  MOVLW  00
042E6:  MOVWF  FF8
042E8:  CLRF   1B
042EA:  BTFSC  FF2.7
042EC:  BSF    1B.7
042EE:  BCF    FF2.7
042F0:  MOVLW  26
042F2:  MOVLB  A
042F4:  MOVWF  x40
042F6:  MOVLB  0
042F8:  CALL   1024
042FC:  BTFSC  1B.7
042FE:  BSF    FF2.7
04300:  MOVFF  9E4,9EC
04304:  MOVLW  37
04306:  MOVLB  9
04308:  MOVWF  xED
0430A:  MOVLB  0
0430C:  CALL   3610
04310:  MOVLW  C8
04312:  MOVWF  FF6
04314:  MOVLW  0B
04316:  MOVWF  FF7
04318:  MOVLW  00
0431A:  MOVWF  FF8
0431C:  CLRF   1B
0431E:  BTFSC  FF2.7
04320:  BSF    1B.7
04322:  BCF    FF2.7
04324:  MOVLW  0A
04326:  MOVLB  A
04328:  MOVWF  x40
0432A:  MOVLB  0
0432C:  CALL   1024
04330:  BTFSC  1B.7
04332:  BSF    FF2.7
04334:  MOVLW  10
04336:  MOVWF  FE9
04338:  CLRF   1B
0433A:  BTFSC  FF2.7
0433C:  BSF    1B.7
0433E:  BCF    FF2.7
04340:  MOVFF  9EA,A41
04344:  MOVFF  9E9,A40
04348:  CALL   11A6
0434C:  BTFSC  1B.7
0434E:  BSF    FF2.7
04350:  MOVLW  0D
04352:  BTFSS  F9E.4
04354:  BRA    4352
04356:  MOVWF  FAD
04358:  MOVLW  0A
0435A:  BTFSS  F9E.4
0435C:  BRA    435A
0435E:  MOVWF  FAD
04360:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
04362:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
04364:  BRA    43CA
....................    } 
....................  
....................    if (nv_report_mode == 4) 
04366:  MOVF   1F,W
04368:  SUBLW  04
0436A:  BNZ   43C2
0436C:  MOVF   20,F
0436E:  BNZ   43C2
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
04370:  MOVLW  D8
04372:  MOVWF  FF6
04374:  MOVLW  0B
04376:  MOVWF  FF7
04378:  MOVLW  00
0437A:  MOVWF  FF8
0437C:  CLRF   1B
0437E:  BTFSC  FF2.7
04380:  BSF    1B.7
04382:  BCF    FF2.7
04384:  MOVLW  25
04386:  MOVLB  A
04388:  MOVWF  x40
0438A:  MOVLB  0
0438C:  CALL   1024
04390:  BTFSC  1B.7
04392:  BSF    FF2.7
04394:  MOVLW  10
04396:  MOVWF  FE9
04398:  CLRF   1B
0439A:  BTFSC  FF2.7
0439C:  BSF    1B.7
0439E:  BCF    FF2.7
043A0:  MOVFF  9EA,A41
043A4:  MOVFF  9E9,A40
043A8:  CALL   11A6
043AC:  BTFSC  1B.7
043AE:  BSF    FF2.7
043B0:  MOVLW  0D
043B2:  BTFSS  F9E.4
043B4:  BRA    43B2
043B6:  MOVWF  FAD
043B8:  MOVLW  0A
043BA:  BTFSS  F9E.4
043BC:  BRA    43BA
043BE:  MOVWF  FAD
043C0:  MOVLB  9
....................  
....................    msg_card_ok(); 
043C2:  MOVLB  0
043C4:  GOTO   3656
043C8:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
043CA:  BSF    F91.1
....................    return(SDCardStatus); 
043CC:  MOVFF  9EB,01
043D0:  MOVLB  0
043D2:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05A82:  MOVLW  20
05A84:  MOVLB  7
05A86:  ADDWF  x12,W
05A88:  MOVWF  FE9
05A8A:  MOVLW  00
05A8C:  ADDWFC x13,W
05A8E:  MOVWF  FEA
05A90:  MOVFF  FEF,A18
05A94:  MOVFF  FEC,A19
05A98:  MOVFF  FEC,A1A
05A9C:  MOVFF  FEC,A1B
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05AA0:  MOVLB  A
05AA2:  MOVF   x14,W
05AA4:  SUBWF  x18,W
05AA6:  BNZ   5ABC
05AA8:  MOVF   x15,W
05AAA:  SUBWF  x19,W
05AAC:  BNZ   5ABC
05AAE:  MOVF   x16,W
05AB0:  SUBWF  x1A,W
05AB2:  BNZ   5ABC
05AB4:  MOVF   x17,W
05AB6:  SUBWF  x1B,W
05AB8:  BTFSC  FD8.2
05ABA:  BRA    5C90
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05ABC:  MOVLW  06
05ABE:  MOVLB  7
05AC0:  ADDWF  x12,W
05AC2:  MOVWF  FE9
05AC4:  MOVLW  00
05AC6:  ADDWFC x13,W
05AC8:  MOVWF  FEA
05ACA:  MOVF   FEF,F
05ACC:  BTFSC  FD8.2
05ACE:  BRA    5C1A
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05AD0:  MOVLW  24
05AD2:  ADDWF  x12,W
05AD4:  MOVWF  01
05AD6:  MOVLW  00
05AD8:  ADDWFC x13,W
05ADA:  MOVWF  03
05ADC:  MOVFF  01,A1E
05AE0:  MOVLB  A
05AE2:  MOVWF  x1F
05AE4:  MOVWF  x21
05AE6:  MOVFF  01,A20
05AEA:  MOVFF  A1B,A25
05AEE:  MOVFF  A1A,A24
05AF2:  MOVFF  A19,A23
05AF6:  MOVFF  A18,A22
05AFA:  MOVLW  01
05AFC:  MOVWF  x26
05AFE:  MOVLB  0
05B00:  RCALL  593E
05B02:  MOVFF  01,A1C
....................             if (response != RES_OK) 
05B06:  MOVLB  A
05B08:  MOVF   x1C,F
05B0A:  BZ    5B12
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05B0C:  MOVLW  00
05B0E:  MOVWF  01
05B10:  BRA    5C94
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05B12:  MOVLW  06
05B14:  MOVLB  7
05B16:  ADDWF  x12,W
05B18:  MOVWF  FE9
05B1A:  MOVLW  00
05B1C:  ADDWFC x13,W
05B1E:  MOVWF  FEA
05B20:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05B22:  MOVLW  10
05B24:  ADDWF  x12,W
05B26:  MOVWF  FE9
05B28:  MOVLW  00
05B2A:  ADDWFC x13,W
05B2C:  MOVWF  FEA
05B2E:  MOVFF  FEF,A1E
05B32:  MOVFF  FEC,A1F
05B36:  MOVFF  FEC,A20
05B3A:  MOVFF  FEC,A21
05B3E:  MOVLW  08
05B40:  ADDWF  x12,W
05B42:  MOVWF  FE9
05B44:  MOVLW  00
05B46:  ADDWFC x13,W
05B48:  MOVWF  FEA
05B4A:  MOVFF  FEF,00
05B4E:  MOVFF  FEC,01
05B52:  MOVFF  FEC,02
05B56:  MOVFF  FEC,03
05B5A:  MOVLB  A
05B5C:  MOVF   x1E,W
05B5E:  ADDWF  00,F
05B60:  MOVF   x1F,W
05B62:  ADDWFC 01,F
05B64:  MOVF   x20,W
05B66:  ADDWFC 02,F
05B68:  MOVF   x21,W
05B6A:  ADDWFC 03,F
05B6C:  MOVF   x1B,W
05B6E:  SUBWF  03,W
05B70:  BNC   5C18
05B72:  BNZ   5B8A
05B74:  MOVF   x1A,W
05B76:  SUBWF  02,W
05B78:  BNC   5C18
05B7A:  BNZ   5B8A
05B7C:  MOVF   x19,W
05B7E:  SUBWF  01,W
05B80:  BNC   5C18
05B82:  BNZ   5B8A
05B84:  MOVF   00,W
05B86:  SUBWF  x18,W
05B88:  BC    5C18
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05B8A:  MOVLW  03
05B8C:  MOVLB  7
05B8E:  ADDWF  x12,W
05B90:  MOVWF  FE9
05B92:  MOVLW  00
05B94:  ADDWFC x13,W
05B96:  MOVWF  FEA
05B98:  MOVFF  FEF,A1D
05B9C:  MOVLB  A
05B9E:  MOVF   x1D,W
05BA0:  SUBLW  01
05BA2:  BC    5C18
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05BA4:  MOVLW  08
05BA6:  MOVLB  7
05BA8:  ADDWF  x12,W
05BAA:  MOVWF  FE9
05BAC:  MOVLW  00
05BAE:  ADDWFC x13,W
05BB0:  MOVWF  FEA
05BB2:  MOVFF  FEF,00
05BB6:  MOVFF  FEC,01
05BBA:  MOVFF  FEC,02
05BBE:  MOVFF  FEC,03
05BC2:  MOVF   00,W
05BC4:  MOVLB  A
05BC6:  ADDWF  x18,F
05BC8:  MOVF   01,W
05BCA:  ADDWFC x19,F
05BCC:  MOVF   02,W
05BCE:  ADDWFC x1A,F
05BD0:  MOVF   03,W
05BD2:  ADDWFC x1B,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05BD4:  MOVLW  24
05BD6:  MOVLB  7
05BD8:  ADDWF  x12,W
05BDA:  MOVWF  01
05BDC:  MOVLW  00
05BDE:  ADDWFC x13,W
05BE0:  MOVWF  03
05BE2:  MOVFF  01,A1E
05BE6:  MOVLB  A
05BE8:  MOVWF  x1F
05BEA:  MOVWF  x21
05BEC:  MOVFF  01,A20
05BF0:  MOVFF  A1B,A25
05BF4:  MOVFF  A1A,A24
05BF8:  MOVFF  A19,A23
05BFC:  MOVFF  A18,A22
05C00:  MOVLW  01
05C02:  MOVWF  x26
05C04:  MOVLB  0
05C06:  RCALL  593E
05C08:  MOVF   01,F
05C0A:  BZ    5C12
....................                      break; 
05C0C:  MOVLB  A
05C0E:  BRA    5C18
05C10:  MOVLB  0
05C12:  MOVLB  A
05C14:  DECF   x1D,F
05C16:  BRA    5B9E
05C18:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05C1A:  MOVLB  A
05C1C:  MOVF   x14,F
05C1E:  BNZ   5C2C
05C20:  MOVF   x15,F
05C22:  BNZ   5C2C
05C24:  MOVF   x16,F
05C26:  BNZ   5C2C
05C28:  MOVF   x17,F
05C2A:  BZ    5C90
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05C2C:  MOVLW  24
05C2E:  MOVLB  7
05C30:  ADDWF  x12,W
05C32:  MOVWF  01
05C34:  MOVLW  00
05C36:  ADDWFC x13,W
05C38:  MOVWF  03
05C3A:  MOVFF  01,A1E
05C3E:  MOVLB  A
05C40:  MOVWF  x1F
05C42:  MOVWF  x21
05C44:  MOVFF  01,A20
05C48:  MOVFF  A17,A25
05C4C:  MOVFF  A16,A24
05C50:  MOVFF  A15,A23
05C54:  MOVFF  A14,A22
05C58:  MOVLW  01
05C5A:  MOVWF  x26
05C5C:  MOVLB  0
05C5E:  CALL   44CC
05C62:  MOVF   01,F
05C64:  BZ    5C70
....................             return FALSE; 
05C66:  MOVLW  00
05C68:  MOVWF  01
05C6A:  MOVLB  A
05C6C:  BRA    5C94
05C6E:  MOVLB  0
....................          fs->winsect = sector; 
05C70:  MOVLW  20
05C72:  MOVLB  7
05C74:  ADDWF  x12,W
05C76:  MOVWF  FE9
05C78:  MOVLW  00
05C7A:  ADDWFC x13,W
05C7C:  MOVWF  FEA
05C7E:  MOVFF  A14,FEF
05C82:  MOVFF  A15,FEC
05C86:  MOVFF  A16,FEC
05C8A:  MOVFF  A17,FEC
05C8E:  MOVLB  A
....................          } 
....................       } 
....................    return (TRUE); 
05C90:  MOVLW  01
05C92:  MOVWF  01
05C94:  MOVLB  0
05C96:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05CBA:  MOVLB  9
05CBC:  MOVF   xFF,F
05CBE:  BNZ   5CD0
05CC0:  MOVF   xFE,F
05CC2:  BNZ   5CD0
05CC4:  MOVF   xFD,F
05CC6:  BNZ   5CD0
05CC8:  MOVF   xFC,W
05CCA:  SUBLW  01
05CCC:  BTFSC  FD8.0
05CCE:  BRA    5FF8
05CD0:  MOVLW  0C
05CD2:  MOVLB  7
05CD4:  ADDWF  x12,W
05CD6:  MOVWF  FE9
05CD8:  MOVLW  00
05CDA:  ADDWFC x13,W
05CDC:  MOVWF  FEA
05CDE:  MOVFF  FEF,00
05CE2:  MOVFF  FEC,01
05CE6:  MOVFF  FEC,02
05CEA:  MOVFF  FEC,03
05CEE:  MOVLB  9
05CF0:  MOVF   xFF,W
05CF2:  SUBWF  03,W
05CF4:  BTFSS  FD8.0
05CF6:  BRA    5FF8
05CF8:  BNZ   5D16
05CFA:  MOVF   xFE,W
05CFC:  SUBWF  02,W
05CFE:  BTFSS  FD8.0
05D00:  BRA    5FF8
05D02:  BNZ   5D16
05D04:  MOVF   xFD,W
05D06:  SUBWF  01,W
05D08:  BTFSS  FD8.0
05D0A:  BRA    5FF8
05D0C:  BNZ   5D16
05D0E:  MOVF   00,W
05D10:  SUBWF  xFC,W
05D12:  BTFSC  FD8.0
05D14:  BRA    5FF8
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05D16:  MOVLW  10
05D18:  MOVLB  7
05D1A:  ADDWF  x12,W
05D1C:  MOVWF  FE9
05D1E:  MOVLW  00
05D20:  ADDWFC x13,W
05D22:  MOVWF  FEA
05D24:  MOVFF  FEF,A04
05D28:  MOVFF  FEC,A05
05D2C:  MOVFF  FEC,A06
05D30:  MOVFF  FEC,A07
....................       switch (fs->fs_type)  
05D34:  MOVF   x12,W
05D36:  MOVWF  FE9
05D38:  MOVF   x13,W
05D3A:  MOVWF  FEA
05D3C:  MOVF   FEF,W
05D3E:  XORLW  01
05D40:  MOVLB  0
05D42:  BZ    5D52
05D44:  XORLW  03
05D46:  BTFSC  FD8.2
05D48:  BRA    5E9E
05D4A:  XORLW  01
05D4C:  BTFSC  FD8.2
05D4E:  BRA    5F26
05D50:  BRA    5FF6
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05D52:  MOVFF  9FD,A11
05D56:  MOVFF  9FC,A10
05D5A:  MOVLB  A
05D5C:  CLRF   x13
05D5E:  MOVLW  03
05D60:  MOVWF  x12
05D62:  MOVLB  0
05D64:  RCALL  5C98
05D66:  BCF    FD8.0
05D68:  MOVLB  A
05D6A:  RRCF   02,W
05D6C:  MOVWF  x03
05D6E:  RRCF   01,W
05D70:  MOVWF  x02
....................             if (!move_window(fatsect + bc / 512))  
05D72:  BCF    FD8.0
05D74:  CLRF   03
05D76:  RRCF   x03,W
05D78:  MOVWF  02
05D7A:  ADDWF  x04,W
05D7C:  MOVWF  x08
05D7E:  MOVF   03,W
05D80:  ADDWFC x05,W
05D82:  MOVWF  x09
05D84:  MOVLW  00
05D86:  ADDWFC x06,W
05D88:  MOVWF  x0A
05D8A:  MOVLW  00
05D8C:  ADDWFC x07,W
05D8E:  MOVWF  x0B
05D90:  MOVWF  x17
05D92:  MOVFF  A0A,A16
05D96:  MOVFF  A09,A15
05D9A:  MOVFF  A08,A14
05D9E:  MOVLB  0
05DA0:  RCALL  5A82
05DA2:  MOVF   01,F
05DA4:  BNZ   5DA8
....................                break; 
05DA6:  BRA    5FF6
....................             wc = fs->win[bc % 512]; 
05DA8:  MOVLB  A
05DAA:  MOVF   x03,W
05DAC:  ANDLW  01
05DAE:  MOVWF  x09
05DB0:  MOVLW  24
05DB2:  ADDWF  x02,W
05DB4:  MOVWF  01
05DB6:  MOVLW  00
05DB8:  ADDWFC x09,W
05DBA:  MOVWF  03
05DBC:  MOVF   01,W
05DBE:  MOVLB  7
05DC0:  ADDWF  x12,W
05DC2:  MOVWF  FE9
05DC4:  MOVF   x13,W
05DC6:  ADDWFC 03,W
05DC8:  MOVWF  FEA
05DCA:  MOVLB  A
05DCC:  CLRF   x01
05DCE:  MOVFF  FEF,A00
....................             bc++; 
05DD2:  INCF   x02,F
05DD4:  BTFSC  FD8.2
05DD6:  INCF   x03,F
....................             if (!move_window(fatsect + bc / 512))  
05DD8:  BCF    FD8.0
05DDA:  CLRF   03
05DDC:  RRCF   x03,W
05DDE:  MOVWF  02
05DE0:  ADDWF  x04,W
05DE2:  MOVWF  x08
05DE4:  MOVF   03,W
05DE6:  ADDWFC x05,W
05DE8:  MOVWF  x09
05DEA:  MOVLW  00
05DEC:  ADDWFC x06,W
05DEE:  MOVWF  x0A
05DF0:  MOVLW  00
05DF2:  ADDWFC x07,W
05DF4:  MOVWF  x0B
05DF6:  MOVWF  x17
05DF8:  MOVFF  A0A,A16
05DFC:  MOVFF  A09,A15
05E00:  MOVFF  A08,A14
05E04:  MOVLB  0
05E06:  RCALL  5A82
05E08:  MOVF   01,F
05E0A:  BNZ   5E0E
....................                break; 
05E0C:  BRA    5FF6
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05E0E:  MOVLB  A
05E10:  MOVF   x03,W
05E12:  ANDLW  01
05E14:  MOVWF  x09
05E16:  MOVLW  24
05E18:  ADDWF  x02,W
05E1A:  MOVWF  01
05E1C:  MOVLW  00
05E1E:  ADDWFC x09,W
05E20:  MOVWF  03
05E22:  MOVF   01,W
05E24:  MOVLB  7
05E26:  ADDWF  x12,W
05E28:  MOVWF  FE9
05E2A:  MOVF   x13,W
05E2C:  ADDWFC 03,W
05E2E:  MOVWF  FEA
05E30:  MOVF   FEF,W
05E32:  MOVLB  A
05E34:  MOVWF  x0A
05E36:  MOVLW  00
05E38:  IORWF  x00,F
05E3A:  MOVF   x0A,W
05E3C:  IORWF  x01,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05E3E:  MOVLB  9
05E40:  MOVF   xFC,W
05E42:  ANDLW  01
05E44:  MOVWF  00
05E46:  CLRF   01
05E48:  CLRF   02
05E4A:  CLRF   03
05E4C:  MOVF   00,F
05E4E:  BNZ   5E5C
05E50:  MOVF   01,F
05E52:  BNZ   5E5C
05E54:  MOVF   02,F
05E56:  BNZ   5E5C
05E58:  MOVF   03,F
05E5A:  BZ    5E84
05E5C:  MOVLB  A
05E5E:  RRCF   x01,W
05E60:  MOVWF  03
05E62:  RRCF   x00,W
05E64:  MOVWF  02
05E66:  RRCF   03,F
05E68:  RRCF   02,F
05E6A:  RRCF   03,F
05E6C:  RRCF   02,F
05E6E:  RRCF   03,F
05E70:  RRCF   02,F
05E72:  MOVLW  0F
05E74:  ANDWF  03,F
05E76:  MOVFF  02,00
05E7A:  MOVFF  03,01
05E7E:  CLRF   02
05E80:  CLRF   03
05E82:  BRA    5E9A
05E84:  MOVLB  A
05E86:  MOVFF  A00,00
05E8A:  MOVF   x01,W
05E8C:  ANDLW  0F
05E8E:  MOVWF  03
05E90:  MOVF   x00,W
05E92:  MOVFF  03,01
05E96:  CLRF   02
05E98:  CLRF   03
05E9A:  BRA    6004
05E9C:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05E9E:  MOVFF  9FD,00
05EA2:  MOVFF  9FE,01
05EA6:  MOVFF  9FF,02
05EAA:  CLRF   03
05EAC:  MOVF   00,W
05EAE:  MOVLB  A
05EB0:  ADDWF  x04,W
05EB2:  MOVWF  x08
05EB4:  MOVF   01,W
05EB6:  ADDWFC x05,W
05EB8:  MOVWF  x09
05EBA:  MOVF   02,W
05EBC:  ADDWFC x06,W
05EBE:  MOVWF  x0A
05EC0:  MOVF   03,W
05EC2:  ADDWFC x07,W
05EC4:  MOVWF  x0B
05EC6:  MOVWF  x17
05EC8:  MOVFF  A0A,A16
05ECC:  MOVFF  A09,A15
05ED0:  MOVFF  A08,A14
05ED4:  MOVLB  0
05ED6:  RCALL  5A82
05ED8:  MOVF   01,F
05EDA:  BNZ   5EDE
....................                break; 
05EDC:  BRA    5FF6
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05EDE:  BCF    FD8.0
05EE0:  MOVLB  9
05EE2:  RLCF   xFC,W
05EE4:  MOVLB  A
05EE6:  MOVWF  x08
05EE8:  MOVLB  9
05EEA:  RLCF   xFD,W
05EEC:  MOVLB  A
05EEE:  MOVWF  x09
05EF0:  MOVLW  01
05EF2:  ANDWF  x09,F
05EF4:  MOVLW  24
05EF6:  ADDWF  x08,W
05EF8:  MOVWF  01
05EFA:  MOVLW  00
05EFC:  ADDWFC x09,W
05EFE:  MOVWF  03
05F00:  MOVF   01,W
05F02:  MOVLB  7
05F04:  ADDWF  x12,W
05F06:  MOVWF  01
05F08:  MOVF   x13,W
05F0A:  ADDWFC 03,F
05F0C:  MOVFF  01,FE9
05F10:  MOVFF  03,FEA
05F14:  MOVFF  FEF,00
05F18:  MOVFF  FEC,01
05F1C:  CLRF   02
05F1E:  CLRF   03
05F20:  MOVLB  A
05F22:  BRA    6004
05F24:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05F26:  MOVLB  9
05F28:  RRCF   xFF,W
05F2A:  MOVWF  03
05F2C:  RRCF   xFE,W
05F2E:  MOVWF  02
05F30:  RRCF   xFD,W
05F32:  MOVWF  01
05F34:  RRCF   xFC,W
05F36:  MOVWF  00
05F38:  RRCF   03,F
05F3A:  RRCF   02,F
05F3C:  RRCF   01,F
05F3E:  RRCF   00,F
05F40:  RRCF   03,F
05F42:  RRCF   02,F
05F44:  RRCF   01,F
05F46:  RRCF   00,F
05F48:  RRCF   03,F
05F4A:  RRCF   02,F
05F4C:  RRCF   01,F
05F4E:  RRCF   00,F
05F50:  RRCF   03,F
05F52:  RRCF   02,F
05F54:  RRCF   01,F
05F56:  RRCF   00,F
05F58:  RRCF   03,F
05F5A:  RRCF   02,F
05F5C:  RRCF   01,F
05F5E:  RRCF   00,F
05F60:  RRCF   03,F
05F62:  RRCF   02,F
05F64:  RRCF   01,F
05F66:  RRCF   00,F
05F68:  MOVLW  01
05F6A:  ANDWF  03,F
05F6C:  MOVF   00,W
05F6E:  MOVLB  A
05F70:  ADDWF  x04,W
05F72:  MOVWF  x08
05F74:  MOVF   01,W
05F76:  ADDWFC x05,W
05F78:  MOVWF  x09
05F7A:  MOVF   02,W
05F7C:  ADDWFC x06,W
05F7E:  MOVWF  x0A
05F80:  MOVF   03,W
05F82:  ADDWFC x07,W
05F84:  MOVWF  x0B
05F86:  MOVWF  x17
05F88:  MOVFF  A0A,A16
05F8C:  MOVFF  A09,A15
05F90:  MOVFF  A08,A14
05F94:  MOVLB  0
05F96:  RCALL  5A82
05F98:  MOVF   01,F
05F9A:  BNZ   5F9E
....................                break; 
05F9C:  BRA    5FF6
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05F9E:  MOVLB  9
05FA0:  RLCF   xFC,W
05FA2:  MOVLB  A
05FA4:  MOVWF  x08
05FA6:  MOVLB  9
05FA8:  RLCF   xFD,W
05FAA:  MOVLB  A
05FAC:  MOVWF  x09
05FAE:  RLCF   x08,F
05FB0:  RLCF   x09,F
05FB2:  MOVLW  FC
05FB4:  ANDWF  x08,F
05FB6:  MOVLW  01
05FB8:  ANDWF  x09,F
05FBA:  MOVLW  24
05FBC:  ADDWF  x08,W
05FBE:  MOVWF  01
05FC0:  MOVLW  00
05FC2:  ADDWFC x09,W
05FC4:  MOVWF  03
05FC6:  MOVF   01,W
05FC8:  MOVLB  7
05FCA:  ADDWF  x12,W
05FCC:  MOVWF  01
05FCE:  MOVF   x13,W
05FD0:  ADDWFC 03,F
05FD2:  MOVFF  01,FE9
05FD6:  MOVFF  03,FEA
05FDA:  MOVFF  FEF,00
05FDE:  MOVFF  FEC,01
05FE2:  MOVFF  FEC,02
05FE6:  MOVFF  FEC,A0D
05FEA:  MOVLB  A
05FEC:  MOVF   x0D,W
05FEE:  ANDLW  0F
05FF0:  MOVWF  03
05FF2:  BRA    6004
05FF4:  MOVLB  0
05FF6:  MOVLB  9
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
05FF8:  MOVLW  01
05FFA:  MOVWF  00
05FFC:  CLRF   01
05FFE:  CLRF   02
06000:  CLRF   03
06002:  MOVLB  A
06004:  MOVLB  0
06006:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
065CA:  MOVLW  10
065CC:  MOVLB  7
065CE:  ADDWF  x12,W
065D0:  MOVWF  FE9
065D2:  MOVLW  00
065D4:  ADDWFC x13,W
065D6:  MOVWF  FEA
065D8:  MOVFF  FEF,A08
065DC:  MOVFF  FEC,A09
065E0:  MOVFF  FEC,A0A
065E4:  MOVFF  FEC,A0B
....................    switch (fs->fs_type)  
065E8:  MOVF   x12,W
065EA:  MOVWF  FE9
065EC:  MOVF   x13,W
065EE:  MOVWF  FEA
065F0:  MOVF   FEF,W
065F2:  XORLW  01
065F4:  MOVLB  0
065F6:  BZ    6606
065F8:  XORLW  03
065FA:  BTFSC  FD8.2
065FC:  BRA    67EA
065FE:  XORLW  01
06600:  BTFSC  FD8.2
06602:  BRA    6874
06604:  BRA    6944
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
06606:  MOVFF  9FD,A11
0660A:  MOVFF  9FC,A10
0660E:  MOVLB  A
06610:  CLRF   x13
06612:  MOVLW  03
06614:  MOVWF  x12
06616:  MOVLB  0
06618:  CALL   5C98
0661C:  BCF    FD8.0
0661E:  MOVLB  A
06620:  RRCF   02,W
06622:  MOVWF  x05
06624:  RRCF   01,W
06626:  MOVWF  x04
....................          if (!move_window(fatsect + bc / 512)) 
06628:  BCF    FD8.0
0662A:  CLRF   03
0662C:  RRCF   x05,W
0662E:  MOVWF  02
06630:  ADDWF  x08,W
06632:  MOVWF  x0C
06634:  MOVF   03,W
06636:  ADDWFC x09,W
06638:  MOVWF  x0D
0663A:  MOVLW  00
0663C:  ADDWFC x0A,W
0663E:  MOVWF  x0E
06640:  MOVLW  00
06642:  ADDWFC x0B,W
06644:  MOVWF  x0F
06646:  MOVWF  x17
06648:  MOVFF  A0E,A16
0664C:  MOVFF  A0D,A15
06650:  MOVFF  A0C,A14
06654:  MOVLB  0
06656:  CALL   5A82
0665A:  MOVF   01,F
0665C:  BNZ   6664
....................             return (FALSE); 
0665E:  MOVLW  00
06660:  MOVWF  01
06662:  BRA    6962
....................          p = &fs->win[bc % 512]; 
06664:  MOVLB  A
06666:  MOVF   x05,W
06668:  ANDLW  01
0666A:  MOVWF  x0D
0666C:  MOVLW  24
0666E:  ADDWF  x04,W
06670:  MOVWF  01
06672:  MOVLW  00
06674:  ADDWFC x0D,W
06676:  MOVWF  03
06678:  MOVF   01,W
0667A:  MOVLB  7
0667C:  ADDWF  x12,W
0667E:  MOVWF  01
06680:  MOVF   x13,W
06682:  ADDWFC 03,F
06684:  MOVFF  01,A06
06688:  MOVLB  A
0668A:  MOVFF  03,A07
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
0668E:  MOVFF  A06,A0C
06692:  MOVFF  A07,A0D
06696:  MOVLB  9
06698:  MOVF   xFC,W
0669A:  ANDLW  01
0669C:  MOVWF  00
0669E:  CLRF   01
066A0:  CLRF   02
066A2:  CLRF   03
066A4:  MOVF   00,F
066A6:  BNZ   66B4
066A8:  MOVF   01,F
066AA:  BNZ   66B4
066AC:  MOVF   02,F
066AE:  BNZ   66B4
066B0:  MOVF   03,F
066B2:  BZ    66D6
066B4:  MOVFF  A07,03
066B8:  MOVLB  A
066BA:  MOVFF  A06,FE9
066BE:  MOVFF  A07,FEA
066C2:  MOVF   FEF,W
066C4:  ANDLW  0F
066C6:  MOVWF  x0E
066C8:  SWAPF  x00,W
066CA:  MOVWF  00
066CC:  MOVLW  F0
066CE:  ANDWF  00,F
066D0:  MOVF   00,W
066D2:  IORWF  x0E,W
066D4:  BRA    66DA
066D6:  MOVLB  A
066D8:  MOVF   x00,W
066DA:  MOVFF  A0D,FEA
066DE:  MOVFF  A0C,FE9
066E2:  MOVWF  FEF
....................          fs->winflag = 1; 
066E4:  MOVLW  06
066E6:  MOVLB  7
066E8:  ADDWF  x12,W
066EA:  MOVWF  FE9
066EC:  MOVLW  00
066EE:  ADDWFC x13,W
066F0:  MOVWF  FEA
066F2:  MOVLW  01
066F4:  MOVWF  FEF
....................          bc++; 
066F6:  MOVLB  A
066F8:  INCF   x04,F
066FA:  BTFSC  FD8.2
066FC:  INCF   x05,F
....................          if (!move_window(fatsect + bc / 512)) 
066FE:  BCF    FD8.0
06700:  CLRF   03
06702:  RRCF   x05,W
06704:  MOVWF  02
06706:  ADDWF  x08,W
06708:  MOVWF  x0C
0670A:  MOVF   03,W
0670C:  ADDWFC x09,W
0670E:  MOVWF  x0D
06710:  MOVLW  00
06712:  ADDWFC x0A,W
06714:  MOVWF  x0E
06716:  MOVLW  00
06718:  ADDWFC x0B,W
0671A:  MOVWF  x0F
0671C:  MOVWF  x17
0671E:  MOVFF  A0E,A16
06722:  MOVFF  A0D,A15
06726:  MOVFF  A0C,A14
0672A:  MOVLB  0
0672C:  CALL   5A82
06730:  MOVF   01,F
06732:  BNZ   673A
....................             return (FALSE); 
06734:  MOVLW  00
06736:  MOVWF  01
06738:  BRA    6962
....................          p = &fs->win[bc % 512]; 
0673A:  MOVLB  A
0673C:  MOVF   x05,W
0673E:  ANDLW  01
06740:  MOVWF  x0D
06742:  MOVLW  24
06744:  ADDWF  x04,W
06746:  MOVWF  01
06748:  MOVLW  00
0674A:  ADDWFC x0D,W
0674C:  MOVWF  03
0674E:  MOVF   01,W
06750:  MOVLB  7
06752:  ADDWF  x12,W
06754:  MOVWF  01
06756:  MOVF   x13,W
06758:  ADDWFC 03,F
0675A:  MOVFF  01,A06
0675E:  MOVLB  A
06760:  MOVFF  03,A07
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
06764:  MOVFF  A06,A0C
06768:  MOVFF  A07,A0D
0676C:  MOVLB  9
0676E:  MOVF   xFC,W
06770:  ANDLW  01
06772:  MOVWF  00
06774:  CLRF   01
06776:  CLRF   02
06778:  CLRF   03
0677A:  MOVF   00,F
0677C:  BNZ   678A
0677E:  MOVF   01,F
06780:  BNZ   678A
06782:  MOVF   02,F
06784:  BNZ   678A
06786:  MOVF   03,F
06788:  BZ    67BC
0678A:  MOVLB  A
0678C:  RRCF   x03,W
0678E:  MOVWF  03
06790:  RRCF   x02,W
06792:  MOVWF  02
06794:  RRCF   x01,W
06796:  MOVWF  01
06798:  RRCF   x00,W
0679A:  MOVWF  00
0679C:  RRCF   03,F
0679E:  RRCF   02,F
067A0:  RRCF   01,F
067A2:  RRCF   00,F
067A4:  RRCF   03,F
067A6:  RRCF   02,F
067A8:  RRCF   01,F
067AA:  RRCF   00,F
067AC:  RRCF   03,F
067AE:  RRCF   02,F
067B0:  RRCF   01,F
067B2:  RRCF   00,F
067B4:  MOVLW  0F
067B6:  ANDWF  03,F
067B8:  MOVF   00,W
067BA:  BRA    67DE
067BC:  MOVLB  A
067BE:  MOVFF  A06,FE9
067C2:  MOVFF  A07,FEA
067C6:  MOVF   FEF,W
067C8:  ANDLW  F0
067CA:  MOVWF  x0F
067CC:  MOVFF  A01,00
067D0:  MOVFF  A02,01
067D4:  MOVFF  A03,02
067D8:  MOVF   x01,W
067DA:  ANDLW  0F
067DC:  IORWF  x0F,W
067DE:  MOVFF  A0D,FEA
067E2:  MOVFF  A0C,FE9
067E6:  MOVWF  FEF
....................          break; 
067E8:  BRA    694C
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
067EA:  MOVFF  9FD,00
067EE:  MOVFF  9FE,01
067F2:  MOVFF  9FF,02
067F6:  CLRF   03
067F8:  MOVF   00,W
067FA:  MOVLB  A
067FC:  ADDWF  x08,W
067FE:  MOVWF  x0C
06800:  MOVF   01,W
06802:  ADDWFC x09,W
06804:  MOVWF  x0D
06806:  MOVF   02,W
06808:  ADDWFC x0A,W
0680A:  MOVWF  x0E
0680C:  MOVF   03,W
0680E:  ADDWFC x0B,W
06810:  MOVWF  x0F
06812:  MOVWF  x17
06814:  MOVFF  A0E,A16
06818:  MOVFF  A0D,A15
0681C:  MOVFF  A0C,A14
06820:  MOVLB  0
06822:  CALL   5A82
06826:  MOVF   01,F
06828:  BNZ   6830
....................             return (FALSE); 
0682A:  MOVLW  00
0682C:  MOVWF  01
0682E:  BRA    6962
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
06830:  BCF    FD8.0
06832:  MOVLB  9
06834:  RLCF   xFC,W
06836:  MOVLB  A
06838:  MOVWF  x0C
0683A:  MOVLB  9
0683C:  RLCF   xFD,W
0683E:  MOVLB  A
06840:  MOVWF  x0D
06842:  MOVLW  01
06844:  ANDWF  x0D,F
06846:  MOVLW  24
06848:  ADDWF  x0C,W
0684A:  MOVWF  01
0684C:  MOVLW  00
0684E:  ADDWFC x0D,W
06850:  MOVWF  03
06852:  MOVF   01,W
06854:  MOVLB  7
06856:  ADDWF  x12,W
06858:  MOVWF  01
0685A:  MOVF   x13,W
0685C:  ADDWFC 03,F
0685E:  MOVFF  01,FE9
06862:  MOVFF  03,FEA
06866:  MOVFF  A01,FEC
0686A:  MOVF   FED,F
0686C:  MOVFF  A00,FEF
....................          break; 
06870:  MOVLB  A
06872:  BRA    694C
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
06874:  MOVLB  9
06876:  RRCF   xFF,W
06878:  MOVWF  03
0687A:  RRCF   xFE,W
0687C:  MOVWF  02
0687E:  RRCF   xFD,W
06880:  MOVWF  01
06882:  RRCF   xFC,W
06884:  MOVWF  00
06886:  RRCF   03,F
06888:  RRCF   02,F
0688A:  RRCF   01,F
0688C:  RRCF   00,F
0688E:  RRCF   03,F
06890:  RRCF   02,F
06892:  RRCF   01,F
06894:  RRCF   00,F
06896:  RRCF   03,F
06898:  RRCF   02,F
0689A:  RRCF   01,F
0689C:  RRCF   00,F
0689E:  RRCF   03,F
068A0:  RRCF   02,F
068A2:  RRCF   01,F
068A4:  RRCF   00,F
068A6:  RRCF   03,F
068A8:  RRCF   02,F
068AA:  RRCF   01,F
068AC:  RRCF   00,F
068AE:  RRCF   03,F
068B0:  RRCF   02,F
068B2:  RRCF   01,F
068B4:  RRCF   00,F
068B6:  MOVLW  01
068B8:  ANDWF  03,F
068BA:  MOVF   00,W
068BC:  MOVLB  A
068BE:  ADDWF  x08,W
068C0:  MOVWF  x0C
068C2:  MOVF   01,W
068C4:  ADDWFC x09,W
068C6:  MOVWF  x0D
068C8:  MOVF   02,W
068CA:  ADDWFC x0A,W
068CC:  MOVWF  x0E
068CE:  MOVF   03,W
068D0:  ADDWFC x0B,W
068D2:  MOVWF  x0F
068D4:  MOVWF  x17
068D6:  MOVFF  A0E,A16
068DA:  MOVFF  A0D,A15
068DE:  MOVFF  A0C,A14
068E2:  MOVLB  0
068E4:  CALL   5A82
068E8:  MOVF   01,F
068EA:  BNZ   68F2
....................             return (FALSE); 
068EC:  MOVLW  00
068EE:  MOVWF  01
068F0:  BRA    6962
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
068F2:  MOVLB  9
068F4:  RLCF   xFC,W
068F6:  MOVLB  A
068F8:  MOVWF  x0C
068FA:  MOVLB  9
068FC:  RLCF   xFD,W
068FE:  MOVLB  A
06900:  MOVWF  x0D
06902:  RLCF   x0C,F
06904:  RLCF   x0D,F
06906:  MOVLW  FC
06908:  ANDWF  x0C,F
0690A:  MOVLW  01
0690C:  ANDWF  x0D,F
0690E:  MOVLW  24
06910:  ADDWF  x0C,W
06912:  MOVWF  01
06914:  MOVLW  00
06916:  ADDWFC x0D,W
06918:  MOVWF  03
0691A:  MOVF   01,W
0691C:  MOVLB  7
0691E:  ADDWF  x12,W
06920:  MOVWF  01
06922:  MOVF   x13,W
06924:  ADDWFC 03,F
06926:  MOVFF  01,FE9
0692A:  MOVFF  03,FEA
0692E:  MOVFF  A00,FEF
06932:  MOVFF  A01,FEC
06936:  MOVFF  A02,FEC
0693A:  MOVFF  A03,FEC
....................          break; 
0693E:  MOVLB  A
06940:  BRA    694C
06942:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
06944:  MOVLW  00
06946:  MOVWF  01
06948:  BRA    6962
0694A:  MOVLB  A
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
0694C:  MOVLW  06
0694E:  MOVLB  7
06950:  ADDWF  x12,W
06952:  MOVWF  FE9
06954:  MOVLW  00
06956:  ADDWFC x13,W
06958:  MOVWF  FEA
0695A:  MOVLW  01
0695C:  MOVWF  FEF
....................    return (TRUE); 
0695E:  MOVWF  01
06960:  MOVLB  0
06962:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06F46:  MOVFF  9DE,9FF
06F4A:  MOVFF  9DD,9FE
06F4E:  MOVFF  9DC,9FD
06F52:  MOVFF  9DB,9FC
06F56:  CALL   5CBA
06F5A:  MOVFF  03,9E2
06F5E:  MOVFF  02,9E1
06F62:  MOVFF  01,9E0
06F66:  MOVFF  00,9DF
06F6A:  MOVLB  9
06F6C:  MOVF   xE2,F
06F6E:  BNZ   6F7E
06F70:  MOVF   xE1,F
06F72:  BNZ   6F7E
06F74:  MOVF   xE0,F
06F76:  BNZ   6F7E
06F78:  MOVF   xDF,W
06F7A:  SUBLW  01
06F7C:  BC    6FE0
....................       { 
....................       if (!put_cluster(clust, 0)) 
06F7E:  MOVFF  9DE,9FF
06F82:  MOVFF  9DD,9FE
06F86:  MOVFF  9DC,9FD
06F8A:  MOVFF  9DB,9FC
06F8E:  MOVLB  A
06F90:  CLRF   x03
06F92:  CLRF   x02
06F94:  CLRF   x01
06F96:  CLRF   x00
06F98:  MOVLB  0
06F9A:  CALL   65CA
06F9E:  MOVF   01,F
06FA0:  BNZ   6FA8
....................          return FALSE; 
06FA2:  MOVLW  00
06FA4:  MOVWF  01
06FA6:  BRA    6FE6
....................       clust = nxt; 
06FA8:  MOVFF  9E2,9DE
06FAC:  MOVFF  9E1,9DD
06FB0:  MOVFF  9E0,9DC
06FB4:  MOVFF  9DF,9DB
06FB8:  MOVFF  9DE,9FF
06FBC:  MOVFF  9DD,9FE
06FC0:  MOVFF  9DC,9FD
06FC4:  MOVFF  9DB,9FC
06FC8:  CALL   5CBA
06FCC:  MOVFF  03,9E2
06FD0:  MOVFF  02,9E1
06FD4:  MOVFF  01,9E0
06FD8:  MOVFF  00,9DF
06FDC:  BRA    6F6A
06FDE:  MOVLB  9
....................       } 
....................    return TRUE; 
06FE0:  MOVLW  01
06FE2:  MOVWF  01
06FE4:  MOVLB  0
06FE6:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
06964:  MOVLW  0C
06966:  MOVLB  7
06968:  ADDWF  x12,W
0696A:  MOVWF  FE9
0696C:  MOVLW  00
0696E:  ADDWFC x13,W
06970:  MOVWF  FEA
06972:  MOVFF  FEF,9F8
06976:  MOVFF  FEC,9F9
0697A:  MOVFF  FEC,9FA
0697E:  MOVFF  FEC,9FB
....................    if (clust == 0)  
06982:  MOVLB  9
06984:  MOVF   xE8,F
06986:  BNZ   69F0
06988:  MOVF   xE9,F
0698A:  BNZ   69F0
0698C:  MOVF   xEA,F
0698E:  BNZ   69F0
06990:  MOVF   xEB,F
06992:  BNZ   69F0
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
06994:  MOVLW  1C
06996:  MOVLB  7
06998:  ADDWF  x12,W
0699A:  MOVWF  FE9
0699C:  MOVLW  00
0699E:  ADDWFC x13,W
069A0:  MOVWF  FEA
069A2:  MOVFF  FEF,9F4
069A6:  MOVFF  FEC,9F5
069AA:  MOVFF  FEC,9F6
069AE:  MOVFF  FEC,9F7
....................       if (scl < 2 || scl >= mcl) scl = 1; 
069B2:  MOVLB  9
069B4:  MOVF   xF7,F
069B6:  BNZ   69C6
069B8:  MOVF   xF6,F
069BA:  BNZ   69C6
069BC:  MOVF   xF5,F
069BE:  BNZ   69C6
069C0:  MOVF   xF4,W
069C2:  SUBLW  01
069C4:  BC    69E4
069C6:  MOVF   xFB,W
069C8:  SUBWF  xF7,W
069CA:  BNC   69EE
069CC:  BNZ   69E4
069CE:  MOVF   xFA,W
069D0:  SUBWF  xF6,W
069D2:  BNC   69EE
069D4:  BNZ   69E4
069D6:  MOVF   xF9,W
069D8:  SUBWF  xF5,W
069DA:  BNC   69EE
069DC:  BNZ   69E4
069DE:  MOVF   xF8,W
069E0:  SUBWF  xF4,W
069E2:  BNC   69EE
069E4:  CLRF   xF7
069E6:  CLRF   xF6
069E8:  CLRF   xF5
069EA:  MOVLW  01
069EC:  MOVWF  xF4
....................       } 
069EE:  BRA    6A74
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
069F0:  MOVFF  9EB,9FF
069F4:  MOVFF  9EA,9FE
069F8:  MOVFF  9E9,9FD
069FC:  MOVFF  9E8,9FC
06A00:  MOVLB  0
06A02:  CALL   5CBA
06A06:  MOVFF  03,9EF
06A0A:  MOVFF  02,9EE
06A0E:  MOVFF  01,9ED
06A12:  MOVFF  00,9EC
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06A16:  MOVLB  9
06A18:  MOVF   xEF,F
06A1A:  BNZ   6A34
06A1C:  MOVF   xEE,F
06A1E:  BNZ   6A34
06A20:  MOVF   xED,F
06A22:  BNZ   6A34
06A24:  MOVF   xEC,W
06A26:  SUBLW  01
06A28:  BNC   6A34
06A2A:  CLRF   00
06A2C:  CLRF   01
06A2E:  CLRF   02
06A30:  CLRF   03
06A32:  BRA    6BF8
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
06A34:  MOVF   xEF,W
06A36:  SUBWF  xFB,W
06A38:  BNC   6A64
06A3A:  BNZ   6A52
06A3C:  MOVF   xEE,W
06A3E:  SUBWF  xFA,W
06A40:  BNC   6A64
06A42:  BNZ   6A52
06A44:  MOVF   xED,W
06A46:  SUBWF  xF9,W
06A48:  BNC   6A64
06A4A:  BNZ   6A52
06A4C:  MOVF   xF8,W
06A4E:  SUBWF  xEC,W
06A50:  BC    6A64
06A52:  MOVFF  9EC,00
06A56:  MOVFF  9ED,01
06A5A:  MOVFF  9EE,02
06A5E:  MOVFF  9EF,03
06A62:  BRA    6BF8
....................       scl = clust; 
06A64:  MOVFF  9EB,9F7
06A68:  MOVFF  9EA,9F6
06A6C:  MOVFF  9E9,9F5
06A70:  MOVFF  9E8,9F4
....................       } 
....................       ncl = scl;                  // Scan start cluster 
06A74:  MOVFF  9F7,9F3
06A78:  MOVFF  9F6,9F2
06A7C:  MOVFF  9F5,9F1
06A80:  MOVFF  9F4,9F0
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
06A84:  MOVLW  01
06A86:  ADDWF  xF0,F
06A88:  BTFSC  FD8.0
06A8A:  INCF   xF1,F
06A8C:  BTFSC  FD8.2
06A8E:  INCF   xF2,F
06A90:  BTFSC  FD8.2
06A92:  INCF   xF3,F
....................       if (ncl >= mcl)  
06A94:  MOVF   xFB,W
06A96:  SUBWF  xF3,W
06A98:  BNC   6AD6
06A9A:  BNZ   6AB2
06A9C:  MOVF   xFA,W
06A9E:  SUBWF  xF2,W
06AA0:  BNC   6AD6
06AA2:  BNZ   6AB2
06AA4:  MOVF   xF9,W
06AA6:  SUBWF  xF1,W
06AA8:  BNC   6AD6
06AAA:  BNZ   6AB2
06AAC:  MOVF   xF8,W
06AAE:  SUBWF  xF0,W
06AB0:  BNC   6AD6
....................          {         // Wrap around 
....................          ncl = 2; 
06AB2:  CLRF   xF3
06AB4:  CLRF   xF2
06AB6:  CLRF   xF1
06AB8:  MOVLW  02
06ABA:  MOVWF  xF0
....................          if (scl == 1) return 0;      // No free custer was found 
06ABC:  DECFSZ xF4,W
06ABE:  BRA    6AD6
06AC0:  MOVF   xF5,F
06AC2:  BNZ   6AD6
06AC4:  MOVF   xF6,F
06AC6:  BNZ   6AD6
06AC8:  MOVF   xF7,F
06ACA:  BNZ   6AD6
06ACC:  CLRF   00
06ACE:  CLRF   01
06AD0:  CLRF   02
06AD2:  CLRF   03
06AD4:  BRA    6BF8
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06AD6:  MOVF   xF4,W
06AD8:  SUBWF  xF0,W
06ADA:  BNZ   6AF8
06ADC:  MOVF   xF5,W
06ADE:  SUBWF  xF1,W
06AE0:  BNZ   6AF8
06AE2:  MOVF   xF6,W
06AE4:  SUBWF  xF2,W
06AE6:  BNZ   6AF8
06AE8:  MOVF   xF7,W
06AEA:  SUBWF  xF3,W
06AEC:  BNZ   6AF8
06AEE:  CLRF   00
06AF0:  CLRF   01
06AF2:  CLRF   02
06AF4:  CLRF   03
06AF6:  BRA    6BF8
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06AF8:  MOVFF  9F3,9FF
06AFC:  MOVFF  9F2,9FE
06B00:  MOVFF  9F1,9FD
06B04:  MOVFF  9F0,9FC
06B08:  MOVLB  0
06B0A:  CALL   5CBA
06B0E:  MOVFF  03,9EF
06B12:  MOVFF  02,9EE
06B16:  MOVFF  01,9ED
06B1A:  MOVFF  00,9EC
....................       if (cstat == 1) return 0;      // Any error occured 
06B1E:  MOVLB  9
06B20:  DECFSZ xEC,W
06B22:  BRA    6B3A
06B24:  MOVF   xED,F
06B26:  BNZ   6B3A
06B28:  MOVF   xEE,F
06B2A:  BNZ   6B3A
06B2C:  MOVF   xEF,F
06B2E:  BNZ   6B3A
06B30:  CLRF   00
06B32:  CLRF   01
06B34:  CLRF   02
06B36:  CLRF   03
06B38:  BRA    6BF8
....................       } while (cstat);            // Repeat until find a free cluster 
06B3A:  MOVF   xEC,F
06B3C:  BNZ   6A84
06B3E:  MOVF   xED,F
06B40:  BNZ   6A84
06B42:  MOVF   xEE,F
06B44:  BNZ   6A84
06B46:  MOVF   xEF,F
06B48:  BNZ   6A84
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06B4A:  MOVFF  9F3,9FF
06B4E:  MOVFF  9F2,9FE
06B52:  MOVFF  9F1,9FD
06B56:  MOVFF  9F0,9FC
06B5A:  MOVLW  0F
06B5C:  MOVLB  A
06B5E:  MOVWF  x03
06B60:  SETF   x02
06B62:  SETF   x01
06B64:  SETF   x00
06B66:  MOVLB  0
06B68:  RCALL  65CA
06B6A:  MOVF   01,F
06B6C:  BNZ   6B7C
06B6E:  CLRF   00
06B70:  CLRF   01
06B72:  CLRF   02
06B74:  CLRF   03
06B76:  MOVLB  9
06B78:  BRA    6BF8
06B7A:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06B7C:  MOVLB  9
06B7E:  MOVF   xE8,F
06B80:  BNZ   6B8E
06B82:  MOVF   xE9,F
06B84:  BNZ   6B8E
06B86:  MOVF   xEA,F
06B88:  BNZ   6B8E
06B8A:  MOVF   xEB,F
06B8C:  BZ    6BC8
06B8E:  MOVFF  9EB,9FF
06B92:  MOVFF  9EA,9FE
06B96:  MOVFF  9E9,9FD
06B9A:  MOVFF  9E8,9FC
06B9E:  MOVFF  9F3,A03
06BA2:  MOVFF  9F2,A02
06BA6:  MOVFF  9F1,A01
06BAA:  MOVFF  9F0,A00
06BAE:  MOVLB  0
06BB0:  RCALL  65CA
06BB2:  MOVF   01,F
06BB4:  BTFSC  FD8.2
06BB6:  BRA    6BBC
06BB8:  MOVLB  9
06BBA:  BRA    6BC8
06BBC:  CLRF   00
06BBE:  CLRF   01
06BC0:  CLRF   02
06BC2:  CLRF   03
06BC4:  MOVLB  9
06BC6:  BRA    6BF8
....................    fs->last_clust = ncl; 
06BC8:  MOVLW  1C
06BCA:  MOVLB  7
06BCC:  ADDWF  x12,W
06BCE:  MOVWF  FE9
06BD0:  MOVLW  00
06BD2:  ADDWFC x13,W
06BD4:  MOVWF  FEA
06BD6:  MOVFF  9F0,FEF
06BDA:  MOVFF  9F1,FEC
06BDE:  MOVFF  9F2,FEC
06BE2:  MOVFF  9F3,FEC
....................  
....................    return ncl;      // Return new cluster number 
06BE6:  MOVFF  9F0,00
06BEA:  MOVFF  9F1,01
06BEE:  MOVFF  9F2,02
06BF2:  MOVFF  9F3,03
06BF6:  MOVLB  9
06BF8:  MOVLB  0
06BFA:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
0560E:  MOVLW  02
05610:  MOVLB  9
05612:  SUBWF  xEF,F
05614:  MOVLW  00
05616:  SUBWFB xF0,F
05618:  SUBWFB xF1,F
0561A:  SUBWFB xF2,F
....................    if (clust >= fs->max_clust)  
0561C:  MOVLW  0C
0561E:  MOVLB  7
05620:  ADDWF  x12,W
05622:  MOVWF  FE9
05624:  MOVLW  00
05626:  ADDWFC x13,W
05628:  MOVWF  FEA
0562A:  MOVFF  FEF,00
0562E:  MOVFF  FEC,01
05632:  MOVFF  FEC,02
05636:  MOVFF  FEC,03
0563A:  MOVF   03,W
0563C:  MOVLB  9
0563E:  SUBWF  xF2,W
05640:  BNC   5664
05642:  BNZ   565A
05644:  MOVF   02,W
05646:  SUBWF  xF1,W
05648:  BNC   5664
0564A:  BNZ   565A
0564C:  MOVF   01,W
0564E:  SUBWF  xF0,W
05650:  BNC   5664
05652:  BNZ   565A
05654:  MOVF   00,W
05656:  SUBWF  xEF,W
05658:  BNC   5664
....................       return 0;      // Invalid cluster#  
0565A:  CLRF   00
0565C:  CLRF   01
0565E:  CLRF   02
05660:  CLRF   03
05662:  BRA    56E4
....................    return (clust * fs->sects_clust + fs->database); 
05664:  MOVLW  02
05666:  MOVLB  7
05668:  ADDWF  x12,W
0566A:  MOVWF  FE9
0566C:  MOVLW  00
0566E:  ADDWFC x13,W
05670:  MOVWF  FEA
05672:  MOVFF  FEF,9FA
05676:  MOVLB  9
05678:  MOVFF  FEA,9F5
0567C:  MOVFF  FE9,9F4
05680:  MOVFF  9F2,9F9
05684:  MOVFF  9F1,9F8
05688:  MOVFF  9F0,9F7
0568C:  MOVFF  9EF,9F6
05690:  CLRF   xFD
05692:  CLRF   xFC
05694:  CLRF   xFB
05696:  MOVLB  0
05698:  CALL   47F0
0569C:  MOVFF  9F5,FEA
056A0:  MOVFF  9F4,FE9
056A4:  MOVFF  03,9F6
056A8:  MOVFF  02,9F5
056AC:  MOVFF  01,9F4
056B0:  MOVFF  00,9F3
056B4:  MOVLW  18
056B6:  MOVLB  7
056B8:  ADDWF  x12,W
056BA:  MOVWF  FE9
056BC:  MOVLW  00
056BE:  ADDWFC x13,W
056C0:  MOVWF  FEA
056C2:  MOVFF  FEF,00
056C6:  MOVFF  FEC,01
056CA:  MOVFF  FEC,02
056CE:  MOVFF  FEC,03
056D2:  MOVLB  9
056D4:  MOVF   xF3,W
056D6:  ADDWF  00,F
056D8:  MOVF   xF4,W
056DA:  ADDWFC 01,F
056DC:  MOVF   xF5,W
056DE:  ADDWFC 02,F
056E0:  MOVF   xF6,W
056E2:  ADDWFC 03,F
056E4:  MOVLB  0
056E6:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
04690:  MOVLW  24
04692:  MOVLB  7
04694:  ADDWF  x12,W
04696:  MOVWF  01
04698:  MOVLW  00
0469A:  ADDWFC x13,W
0469C:  MOVWF  03
0469E:  MOVFF  01,9E7
046A2:  MOVLB  9
046A4:  MOVWF  xE8
046A6:  MOVWF  FEA
046A8:  MOVFF  01,FE9
046AC:  CLRF   00
046AE:  MOVLW  02
046B0:  MOVWF  02
046B2:  CLRF   01
046B4:  MOVLB  0
046B6:  CALL   3526
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
046BA:  MOVLW  24
046BC:  MOVLB  7
046BE:  ADDWF  x12,W
046C0:  MOVWF  01
046C2:  MOVLW  00
046C4:  ADDWFC x13,W
046C6:  MOVWF  03
046C8:  MOVFF  01,9E7
046CC:  MOVLB  9
046CE:  MOVWF  xE8
046D0:  MOVFF  FE8,A21
046D4:  MOVFF  01,A20
046D8:  MOVFF  9E6,A25
046DC:  MOVFF  9E5,A24
046E0:  MOVFF  9E4,A23
046E4:  MOVFF  9E3,A22
046E8:  MOVLW  01
046EA:  MOVLB  A
046EC:  MOVWF  x26
046EE:  MOVLB  0
046F0:  RCALL  44CC
046F2:  MOVF   01,F
046F4:  BTFSS  FD8.2
046F6:  BRA    47E6
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
046F8:  MOVLW  22
046FA:  MOVLB  7
046FC:  ADDWF  x12,W
046FE:  MOVWF  01
04700:  MOVLW  02
04702:  ADDWFC x13,W
04704:  MOVWF  03
04706:  MOVFF  01,FE9
0470A:  MOVWF  FEA
0470C:  MOVFF  FEC,9E8
04710:  MOVF   FED,F
04712:  MOVFF  FEF,9E7
04716:  MOVLB  9
04718:  MOVF   xE7,W
0471A:  SUBLW  55
0471C:  BNZ   47E8
0471E:  MOVF   xE8,W
04720:  SUBLW  AA
04722:  BNZ   47E8
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
04724:  MOVLW  5A
04726:  MOVLB  7
04728:  ADDWF  x12,W
0472A:  MOVWF  01
0472C:  MOVLW  00
0472E:  ADDWFC x13,W
04730:  MOVWF  03
04732:  MOVFF  01,9E7
04736:  MOVLB  9
04738:  MOVWF  xE8
0473A:  MOVWF  xEA
0473C:  MOVFF  01,9E9
04740:  MOVLW  07
04742:  MOVWF  xEC
04744:  MOVLW  14
04746:  MOVWF  xEB
04748:  CLRF   xEE
0474A:  MOVLW  05
0474C:  MOVWF  xED
0474E:  MOVLB  0
04750:  RCALL  460C
04752:  MOVF   01,F
04754:  BNZ   475C
....................             return (FS_FAT12); 
04756:  MOVLW  01
04758:  MOVWF  01
0475A:  BRA    47EE
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
0475C:  MOVLW  5A
0475E:  MOVLB  7
04760:  ADDWF  x12,W
04762:  MOVWF  01
04764:  MOVLW  00
04766:  ADDWFC x13,W
04768:  MOVWF  03
0476A:  MOVFF  01,9E7
0476E:  MOVLB  9
04770:  MOVWF  xE8
04772:  MOVWF  xEA
04774:  MOVFF  01,9E9
04778:  MOVLW  07
0477A:  MOVWF  xEC
0477C:  MOVLW  19
0477E:  MOVWF  xEB
04780:  CLRF   xEE
04782:  MOVLW  05
04784:  MOVWF  xED
04786:  MOVLB  0
04788:  RCALL  460C
0478A:  MOVF   01,F
0478C:  BNZ   4794
....................             return (FS_FAT16); 
0478E:  MOVLW  02
04790:  MOVWF  01
04792:  BRA    47EE
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
04794:  MOVLW  76
04796:  MOVLB  7
04798:  ADDWF  x12,W
0479A:  MOVWF  01
0479C:  MOVLW  00
0479E:  ADDWFC x13,W
047A0:  MOVWF  03
047A2:  MOVFF  01,9E7
047A6:  MOVLB  9
047A8:  MOVWF  xE8
047AA:  MOVWF  xEA
047AC:  MOVFF  01,9E9
047B0:  MOVLW  07
047B2:  MOVWF  xEC
047B4:  MOVLW  1E
047B6:  MOVWF  xEB
047B8:  CLRF   xEE
047BA:  MOVLW  05
047BC:  MOVWF  xED
047BE:  MOVLB  0
047C0:  RCALL  460C
047C2:  MOVF   01,F
047C4:  BNZ   47E6
047C6:  MOVLW  4C
047C8:  MOVLB  7
047CA:  ADDWF  x12,W
047CC:  MOVWF  FE9
047CE:  MOVLW  00
047D0:  ADDWFC x13,W
047D2:  MOVWF  FEA
047D4:  MOVF   FEF,F
047D6:  BTFSC  FD8.2
047D8:  BRA    47DE
047DA:  MOVLB  0
047DC:  BRA    47E6
....................             return (FS_FAT32); 
047DE:  MOVLW  03
047E0:  MOVWF  01
047E2:  MOVLB  0
047E4:  BRA    47EE
047E6:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
047E8:  MOVLW  00
047EA:  MOVWF  01
047EC:  MOVLB  0
047EE:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
06008:  MOVLW  0C
0600A:  MOVLB  9
0600C:  ADDWF  xE5,W
0600E:  MOVWF  FE9
06010:  MOVLW  00
06012:  ADDWFC xE6,W
06014:  MOVWF  FEA
06016:  MOVFF  FEC,9EE
0601A:  MOVF   FED,F
0601C:  MOVFF  FEF,9ED
06020:  MOVLW  01
06022:  ADDWF  xED,W
06024:  MOVWF  xEB
06026:  MOVLW  00
06028:  ADDWFC xEE,W
0602A:  MOVWF  xEC
....................    if ((idx & 15) == 0)  
0602C:  MOVF   xEB,W
0602E:  ANDLW  0F
06030:  MOVWF  xED
06032:  CLRF   xEE
06034:  MOVF   xED,F
06036:  BTFSS  FD8.2
06038:  BRA    61C4
0603A:  MOVF   xEE,F
0603C:  BTFSS  FD8.2
0603E:  BRA    61C4
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
06040:  MOVLW  08
06042:  ADDWF  xE5,W
06044:  MOVWF  FE9
06046:  MOVLW  00
06048:  ADDWFC xE6,W
0604A:  MOVWF  FEA
0604C:  MOVLW  01
0604E:  ADDWF  FEE,F
06050:  MOVLW  00
06052:  ADDWFC FEE,F
06054:  ADDWFC FEE,F
06056:  ADDWFC FED,F
....................       if (!scan->clust)  
06058:  MOVLW  04
0605A:  ADDWF  xE5,W
0605C:  MOVWF  FE9
0605E:  MOVLW  00
06060:  ADDWFC xE6,W
06062:  MOVWF  FEA
06064:  MOVF   FEF,F
06066:  BNZ   60A4
06068:  MOVF   FEC,F
0606A:  BNZ   60A4
0606C:  MOVF   FEC,F
0606E:  BNZ   60A4
06070:  MOVF   FEC,F
06072:  BNZ   60A4
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
06074:  MOVLW  04
06076:  MOVLB  7
06078:  ADDWF  x12,W
0607A:  MOVWF  FE9
0607C:  MOVLW  00
0607E:  ADDWFC x13,W
06080:  MOVWF  FEA
06082:  MOVFF  FEC,03
06086:  MOVF   FED,F
06088:  MOVFF  FEF,01
0608C:  MOVF   03,W
0608E:  MOVLB  9
06090:  SUBWF  xEC,W
06092:  BNC   60A2
06094:  BNZ   609C
06096:  MOVF   01,W
06098:  SUBWF  xEB,W
0609A:  BNC   60A2
....................             return (FALSE);   // Reached to end of table  
0609C:  MOVLW  00
0609E:  MOVWF  01
060A0:  BRA    61DE
....................          }  
060A2:  BRA    61C4
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
060A4:  RRCF   xEC,W
060A6:  MOVWF  xEE
060A8:  RRCF   xEB,W
060AA:  MOVWF  xED
060AC:  RRCF   xEE,F
060AE:  RRCF   xED,F
060B0:  RRCF   xEE,F
060B2:  RRCF   xED,F
060B4:  RRCF   xEE,F
060B6:  RRCF   xED,F
060B8:  MOVLW  0F
060BA:  ANDWF  xEE,F
060BC:  MOVLW  02
060BE:  MOVLB  7
060C0:  ADDWF  x12,W
060C2:  MOVWF  FE9
060C4:  MOVLW  00
060C6:  ADDWFC x13,W
060C8:  MOVWF  FEA
060CA:  MOVLW  01
060CC:  SUBWF  FEF,W
060CE:  MOVLB  9
060D0:  ANDWF  xED,F
060D2:  CLRF   xEE
060D4:  MOVF   xED,F
060D6:  BTFSS  FD8.2
060D8:  BRA    61C4
060DA:  MOVF   xEE,F
060DC:  BTFSS  FD8.2
060DE:  BRA    61C4
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
060E0:  MOVLW  04
060E2:  ADDWF  xE5,W
060E4:  MOVWF  FE9
060E6:  MOVLW  00
060E8:  ADDWFC xE6,W
060EA:  MOVWF  FEA
060EC:  MOVFF  FEF,9FC
060F0:  MOVFF  FEC,9FD
060F4:  MOVFF  FEC,9FE
060F8:  MOVFF  FEC,9FF
060FC:  MOVLB  0
060FE:  RCALL  5CBA
06100:  MOVFF  03,9EA
06104:  MOVFF  02,9E9
06108:  MOVFF  01,9E8
0610C:  MOVFF  00,9E7
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06110:  MOVLW  0C
06112:  MOVLB  7
06114:  ADDWF  x12,W
06116:  MOVWF  FE9
06118:  MOVLW  00
0611A:  ADDWFC x13,W
0611C:  MOVWF  FEA
0611E:  MOVFF  FEF,00
06122:  MOVFF  FEC,01
06126:  MOVFF  FEC,02
0612A:  MOVFF  FEC,03
0612E:  MOVF   03,W
06130:  MOVLB  9
06132:  SUBWF  xEA,W
06134:  BNC   614E
06136:  BNZ   6160
06138:  MOVF   02,W
0613A:  SUBWF  xE9,W
0613C:  BNC   614E
0613E:  BNZ   6160
06140:  MOVF   01,W
06142:  SUBWF  xE8,W
06144:  BNC   614E
06146:  BNZ   6160
06148:  MOVF   00,W
0614A:  SUBWF  xE7,W
0614C:  BC    6160
0614E:  MOVF   xEA,F
06150:  BNZ   6166
06152:  MOVF   xE9,F
06154:  BNZ   6166
06156:  MOVF   xE8,F
06158:  BNZ   6166
0615A:  MOVF   xE7,W
0615C:  SUBLW  01
0615E:  BNC   6166
....................                return (FALSE); 
06160:  MOVLW  00
06162:  MOVWF  01
06164:  BRA    61DE
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
06166:  MOVLW  04
06168:  ADDWF  xE5,W
0616A:  MOVWF  FE9
0616C:  MOVLW  00
0616E:  ADDWFC xE6,W
06170:  MOVWF  FEA
06172:  MOVFF  9E7,FEF
06176:  MOVFF  9E8,FEC
0617A:  MOVFF  9E9,FEC
0617E:  MOVFF  9EA,FEC
....................             scan->sect = clust2sect(clust); 
06182:  MOVLW  08
06184:  ADDWF  xE5,W
06186:  MOVWF  01
06188:  MOVLW  00
0618A:  ADDWFC xE6,W
0618C:  MOVWF  03
0618E:  MOVFF  01,9ED
06192:  MOVWF  xEE
06194:  MOVFF  9EA,9F2
06198:  MOVFF  9E9,9F1
0619C:  MOVFF  9E8,9F0
061A0:  MOVFF  9E7,9EF
061A4:  MOVLB  0
061A6:  CALL   560E
061AA:  MOVFF  9EE,FEA
061AE:  MOVFF  9ED,FE9
061B2:  MOVFF  00,FEF
061B6:  MOVFF  01,FEC
061BA:  MOVFF  02,FEC
061BE:  MOVFF  03,FEC
061C2:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
061C4:  MOVLW  0C
061C6:  ADDWF  xE5,W
061C8:  MOVWF  FE9
061CA:  MOVLW  00
061CC:  ADDWFC xE6,W
061CE:  MOVWF  FEA
061D0:  MOVFF  9EC,FEC
061D4:  MOVF   FED,F
061D6:  MOVFF  9EB,FEF
....................    return (TRUE); 
061DA:  MOVLW  01
061DC:  MOVWF  01
061DE:  MOVLB  0
061E0:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
056E8:  MOVFF  9E8,FEA
056EC:  MOVFF  9E7,FE9
056F0:  MOVLW  20
056F2:  MOVWF  00
056F4:  CLRF   02
056F6:  MOVLW  0B
056F8:  MOVWF  01
056FA:  CALL   3526
....................    a = 0; b = 0x18;            // NT flag 
056FE:  MOVLB  9
05700:  CLRF   xEC
05702:  MOVLW  18
05704:  MOVWF  xED
....................    n = 0; t = 8; 
05706:  CLRF   xE9
05708:  MOVLW  08
0570A:  MOVWF  xEA
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
0570C:  MOVFF  9E5,FE9
05710:  MOVFF  9E6,FEA
05714:  MOVFF  FEC,9EF
05718:  MOVF   FED,F
0571A:  MOVFF  FEF,9EE
....................       c = *ptr; 
0571E:  MOVFF  9EE,FE9
05722:  MOVFF  9EF,FEA
05726:  MOVFF  FEF,9EB
....................       (*path)++; 
0572A:  MOVFF  9E6,03
0572E:  MOVFF  9E5,FE9
05732:  MOVFF  9E6,FEA
05736:  MOVLW  01
05738:  ADDWF  FEE,F
0573A:  BNC   573E
0573C:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
0573E:  MOVF   xEB,W
05740:  SUBLW  20
05742:  BNC   5746
....................          c = 0; 
05744:  CLRF   xEB
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
05746:  MOVF   xEB,F
05748:  BZ    5756
0574A:  MOVF   xEB,W
0574C:  SUBLW  2F
0574E:  BZ    5756
05750:  MOVF   xEB,W
05752:  SUBLW  5C
05754:  BNZ   5774
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
05756:  MOVF   xE9,F
05758:  BNZ   575C
....................             break; 
0575A:  BRA    583C
....................          dirname[11] = a & b;  
0575C:  MOVLW  0B
0575E:  ADDWF  xE7,W
05760:  MOVWF  FE9
05762:  MOVLW  00
05764:  ADDWFC xE8,W
05766:  MOVWF  FEA
05768:  MOVF   xEC,W
0576A:  ANDWF  xED,W
0576C:  MOVWF  FEF
....................             return (c); 
0576E:  MOVFF  9EB,01
05772:  BRA    5840
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
05774:  MOVF   xEB,W
05776:  SUBLW  20
05778:  BC    5780
0577A:  MOVF   xEB,W
0577C:  SUBLW  7F
0577E:  BNZ   5782
....................          break;   // reject invisible characters 
05780:  BRA    583C
....................       if (c == '.')  
05782:  MOVF   xEB,W
05784:  SUBLW  2E
05786:  BNZ   57A4
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
05788:  BTFSC  xEC.0
0578A:  BRA    57A2
0578C:  MOVF   xE9,W
0578E:  SUBLW  00
05790:  BC    57A2
05792:  MOVF   xE9,W
05794:  SUBLW  08
05796:  BNC   57A2
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
05798:  MOVLW  08
0579A:  MOVWF  xE9
0579C:  MOVLW  0B
0579E:  MOVWF  xEA
....................             continue; 
057A0:  BRA    583A
....................             } 
....................          break; 
057A2:  BRA    583C
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
057A4:  MOVF   xEB,W
057A6:  SUBLW  22
057A8:  BNZ   57AC
....................          break;               // Reject "  
057AA:  BRA    583C
....................  
....................       if (c <= ')')  
057AC:  MOVF   xEB,W
057AE:  SUBLW  29
057B0:  BNC   57B4
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
057B2:  BRA    581E
....................  
....................       if (c <= ',') 
057B4:  MOVF   xEB,W
057B6:  SUBLW  2C
057B8:  BNC   57BC
....................          break;               // Reject * + ,  
057BA:  BRA    583C
....................  
....................       if (c <= '9')  
057BC:  MOVF   xEB,W
057BE:  SUBLW  39
057C0:  BNC   57C4
....................          goto md_l1;            // Accept - 0-9  
057C2:  BRA    581E
....................  
....................       if (c <= '?')  
057C4:  MOVF   xEB,W
057C6:  SUBLW  3F
057C8:  BNC   57CC
....................          break;               // Reject : ; < = > ?  
057CA:  BRA    583C
....................  
....................       if (!(a & 1))  
057CC:  BTFSC  xEC.0
057CE:  BRA    581E
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
057D0:  MOVF   xEB,W
057D2:  SUBLW  7C
057D4:  BNZ   57D8
....................             break;            // Reject |  
057D6:  BRA    583C
....................  
....................          if ((c >= '[') && (c <= ']')) 
057D8:  MOVF   xEB,W
057DA:  SUBLW  5A
057DC:  BC    57E6
057DE:  MOVF   xEB,W
057E0:  SUBLW  5D
057E2:  BNC   57E6
....................             break;// Reject [ \ ]  
057E4:  BRA    583C
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
057E6:  MOVF   xEB,W
057E8:  SUBLW  40
057EA:  BC    5800
057EC:  MOVF   xEB,W
057EE:  SUBLW  5A
057F0:  BNC   5800
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
057F2:  MOVF   xEA,W
057F4:  SUBLW  08
057F6:  BNZ   57FE
057F8:  BCF    xED.3
057FA:  MOVF   xED,W
057FC:  BRA    5800
057FE:  BCF    xED.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
05800:  MOVF   xEB,W
05802:  SUBLW  60
05804:  BC    581E
05806:  MOVF   xEB,W
05808:  SUBLW  7A
0580A:  BNC   581E
....................             {      // Convert to upper case  
....................             c -= 0x20; 
0580C:  MOVLW  20
0580E:  SUBWF  xEB,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
05810:  MOVF   xEA,W
05812:  SUBLW  08
05814:  BNZ   581C
05816:  BSF    xEC.3
05818:  MOVF   xEC,W
0581A:  BRA    581E
0581C:  BSF    xEC.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
0581E:  BCF    xEC.0
....................    md_l2: 
....................       if (n >= t)  
05820:  MOVF   xEA,W
05822:  SUBWF  xE9,W
05824:  BNC   5828
....................          break; 
05826:  BRA    583C
....................       dirname[n++] = c; 
05828:  MOVF   xE9,W
0582A:  INCF   xE9,F
0582C:  ADDWF  xE7,W
0582E:  MOVWF  FE9
05830:  MOVLW  00
05832:  ADDWFC xE8,W
05834:  MOVWF  FEA
05836:  MOVFF  9EB,FEF
0583A:  BRA    570C
....................       } 
....................    return 1; 
0583C:  MOVLW  01
0583E:  MOVWF  01
05840:  MOVLB  0
05842:  GOTO   6384 (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
061E2:  MOVLB  9
061E4:  CLRF   xE4
061E6:  CLRF   xE3
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
061E8:  MOVLW  14
061EA:  MOVLB  7
061EC:  ADDWF  x12,W
061EE:  MOVWF  FE9
061F0:  MOVLW  00
061F2:  ADDWFC x13,W
061F4:  MOVWF  FEA
061F6:  MOVFF  FEF,9DE
061FA:  MOVFF  FEC,9DF
061FE:  MOVFF  FEC,9E0
06202:  MOVFF  FEC,9E1
....................    if (fs->fs_type == FS_FAT32)  
06206:  MOVFF  712,FE9
0620A:  MOVFF  713,FEA
0620E:  MOVF   FEF,W
06210:  SUBLW  03
06212:  BNZ   6296
....................       { 
....................       scan->clust = scan->sclust = clust; 
06214:  MOVLW  04
06216:  MOVLB  9
06218:  ADDWF  xD6,W
0621A:  MOVWF  01
0621C:  MOVLW  00
0621E:  ADDWFC xD7,W
06220:  MOVFF  01,9E5
06224:  MOVFF  9D6,FE9
06228:  MOVFF  9D7,FEA
0622C:  MOVFF  9DE,FEF
06230:  MOVFF  9DF,FEC
06234:  MOVFF  9E0,FEC
06238:  MOVFF  9E1,FEC
0623C:  MOVWF  FEA
0623E:  MOVFF  9E5,FE9
06242:  MOVFF  9DE,FEF
06246:  MOVFF  9DF,FEC
0624A:  MOVFF  9E0,FEC
0624E:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
06252:  MOVLW  08
06254:  ADDWF  xD6,W
06256:  MOVWF  01
06258:  MOVLW  00
0625A:  ADDWFC xD7,W
0625C:  MOVWF  03
0625E:  MOVFF  01,9E5
06262:  MOVWF  xE6
06264:  MOVFF  9E1,9F2
06268:  MOVFF  9E0,9F1
0626C:  MOVFF  9DF,9F0
06270:  MOVFF  9DE,9EF
06274:  MOVLB  0
06276:  CALL   560E
0627A:  MOVFF  9E6,FEA
0627E:  MOVFF  9E5,FE9
06282:  MOVFF  00,FEF
06286:  MOVFF  01,FEC
0628A:  MOVFF  02,FEC
0628E:  MOVFF  03,FEC
....................       } 
06292:  BRA    62F6
06294:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
06296:  MOVLW  04
06298:  MOVLB  9
0629A:  ADDWF  xD6,W
0629C:  MOVWF  01
0629E:  MOVLW  00
062A0:  ADDWFC xD7,W
062A2:  MOVWF  03
062A4:  MOVFF  9D6,FE9
062A8:  MOVFF  9D7,FEA
062AC:  MOVF   FEE,F
062AE:  MOVF   FEE,F
062B0:  CLRF   FEC
062B2:  MOVF   FED,F
062B4:  CLRF   FEF
062B6:  MOVF   FED,F
062B8:  CLRF   FEF
062BA:  MOVF   FED,F
062BC:  CLRF   FEF
062BE:  MOVLW  00
062C0:  MOVFF  03,FEA
062C4:  MOVFF  01,FE9
062C8:  MOVFF  00,FEF
062CC:  MOVFF  01,FEC
062D0:  MOVFF  02,FEC
062D4:  MOVFF  03,FEC
....................       scan->sect = clust; 
062D8:  MOVLW  08
062DA:  ADDWF  xD6,W
062DC:  MOVWF  FE9
062DE:  MOVLW  00
062E0:  ADDWFC xD7,W
062E2:  MOVWF  FEA
062E4:  MOVFF  9DE,FEF
062E8:  MOVFF  9DF,FEC
062EC:  MOVFF  9E0,FEC
062F0:  MOVFF  9E1,FEC
062F4:  MOVLB  0
....................       } 
....................    scan->index = 0; 
062F6:  MOVLW  0C
062F8:  MOVLB  9
062FA:  ADDWF  xD6,W
062FC:  MOVWF  FE9
062FE:  MOVLW  00
06300:  ADDWFC xD7,W
06302:  MOVWF  FEA
06304:  CLRF   FEC
06306:  MOVF   FED,F
06308:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
0630A:  MOVFF  9DB,03
0630E:  MOVFF  9DA,FE9
06312:  MOVFF  9DB,FEA
06316:  MOVF   FEF,W
06318:  SUBLW  20
0631A:  BZ    6340
0631C:  MOVFF  9DB,03
06320:  MOVFF  9DA,FE9
06324:  MOVFF  9DB,FEA
06328:  MOVF   FEF,W
0632A:  SUBLW  2F
0632C:  BZ    6340
0632E:  MOVFF  9DB,03
06332:  MOVFF  9DA,FE9
06336:  MOVFF  9DB,FEA
0633A:  MOVF   FEF,W
0633C:  SUBLW  5C
0633E:  BNZ   6348
....................        path++; 
06340:  INCF   xDA,F
06342:  BTFSC  FD8.2
06344:  INCF   xDB,F
06346:  BRA    630A
....................  
....................    if ((BYTE)*path < ' ')  
06348:  MOVFF  9DB,03
0634C:  MOVFF  9DA,FE9
06350:  MOVFF  9DB,FEA
06354:  MOVF   FEF,W
06356:  SUBLW  1F
06358:  BNC   636E
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
0635A:  MOVFF  9DC,FE9
0635E:  MOVFF  9DD,FEA
06362:  CLRF   FEC
06364:  MOVF   FED,F
06366:  CLRF   FEF
....................       return (FR_OK); 
06368:  MOVLW  00
0636A:  MOVWF  01
0636C:  BRA    65C6
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
0636E:  MOVLW  09
06370:  MOVWF  xE6
06372:  MOVLW  DA
06374:  MOVWF  xE5
06376:  MOVFF  9D9,9E8
0637A:  MOVFF  9D8,9E7
0637E:  MOVLB  0
06380:  GOTO   56E8
06384:  MOVFF  01,9E2
....................       if (ds == 1)  
06388:  MOVLB  9
0638A:  DECFSZ xE2,W
0638C:  BRA    6394
....................          return (FR_INVALID_NAME); 
0638E:  MOVLW  04
06390:  MOVWF  01
06392:  BRA    65C6
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
06394:  MOVLW  08
06396:  ADDWF  xD6,W
06398:  MOVWF  FE9
0639A:  MOVLW  00
0639C:  ADDWFC xD7,W
0639E:  MOVWF  FEA
063A0:  MOVFF  FEF,A14
063A4:  MOVFF  FEC,A15
063A8:  MOVFF  FEC,A16
063AC:  MOVFF  FEC,A17
063B0:  MOVLB  0
063B2:  CALL   5A82
063B6:  MOVF   01,F
063B8:  BNZ   63C4
....................             return (FR_RW_ERROR); 
063BA:  MOVLW  07
063BC:  MOVWF  01
063BE:  MOVLB  9
063C0:  BRA    65C6
063C2:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
063C4:  MOVLW  0C
063C6:  MOVLB  9
063C8:  ADDWF  xD6,W
063CA:  MOVWF  FE9
063CC:  MOVLW  00
063CE:  ADDWFC xD7,W
063D0:  MOVWF  FEA
063D2:  MOVFF  FEC,9E6
063D6:  MOVF   FED,F
063D8:  MOVFF  FEF,9E5
063DC:  MOVLW  0F
063DE:  ANDWF  xE5,F
063E0:  CLRF   xE6
063E2:  RLCF   xE5,F
063E4:  RLCF   xE6,F
063E6:  RLCF   xE5,F
063E8:  RLCF   xE6,F
063EA:  RLCF   xE5,F
063EC:  RLCF   xE6,F
063EE:  RLCF   xE5,F
063F0:  RLCF   xE6,F
063F2:  RLCF   xE5,F
063F4:  RLCF   xE6,F
063F6:  MOVLW  E0
063F8:  ANDWF  xE5,F
063FA:  MOVLW  24
063FC:  ADDWF  xE5,W
063FE:  MOVWF  01
06400:  MOVLW  00
06402:  ADDWFC xE6,W
06404:  MOVWF  03
06406:  MOVF   01,W
06408:  MOVLB  7
0640A:  ADDWF  x12,W
0640C:  MOVWF  01
0640E:  MOVF   x13,W
06410:  ADDWFC 03,F
06412:  MOVFF  01,9E3
06416:  MOVLB  9
06418:  MOVFF  03,9E4
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
0641C:  MOVFF  9E4,03
06420:  MOVFF  9E3,FE9
06424:  MOVFF  9E4,FEA
06428:  MOVF   FEF,F
0642A:  BNZ   643A
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
0642C:  MOVF   xE2,F
0642E:  BNZ   6434
06430:  MOVLW  02
06432:  BRA    6436
06434:  MOVLW  03
06436:  MOVWF  01
06438:  BRA    65C6
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
0643A:  MOVFF  9E4,03
0643E:  MOVFF  9E3,FE9
06442:  MOVFF  9E4,FEA
06446:  MOVF   FEF,W
06448:  SUBLW  E5
0644A:  BZ    648C
0644C:  MOVLW  0B
0644E:  ADDWF  xE3,W
06450:  MOVWF  01
06452:  MOVLW  00
06454:  ADDWFC xE4,W
06456:  MOVWF  03
06458:  MOVFF  01,FE9
0645C:  MOVWF  FEA
0645E:  BTFSC  FEF.3
06460:  BRA    648C
06462:  MOVFF  9E4,9EA
06466:  MOVFF  9E3,9E9
0646A:  MOVFF  9D9,9EC
0646E:  MOVFF  9D8,9EB
06472:  CLRF   xEE
06474:  MOVLW  0B
06476:  MOVWF  xED
06478:  MOVLB  0
0647A:  CALL   460C
0647E:  MOVF   01,F
06480:  BTFSC  FD8.2
06482:  BRA    6488
06484:  MOVLB  9
06486:  BRA    648C
....................              break; 
06488:  BRA    64B4
0648A:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
0648C:  MOVFF  9D7,9E6
06490:  MOVFF  9D6,9E5
06494:  MOVLB  0
06496:  RCALL  6008
06498:  MOVF   01,F
0649A:  BNZ   64AE
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
0649C:  MOVLB  9
0649E:  MOVF   xE2,F
064A0:  BNZ   64A6
064A2:  MOVLW  02
064A4:  BRA    64A8
064A6:  MOVLW  03
064A8:  MOVWF  01
064AA:  BRA    65C6
064AC:  MOVLB  0
064AE:  MOVLB  9
064B0:  BRA    6394
064B2:  MOVLB  0
....................          } 
....................       if (!ds)  
064B4:  MOVLB  9
064B6:  MOVF   xE2,F
064B8:  BNZ   64D2
....................          {  
....................          *win_dir = dptr;  
064BA:  MOVFF  9DC,FE9
064BE:  MOVFF  9DD,FEA
064C2:  MOVFF  9E4,FEC
064C6:  MOVF   FED,F
064C8:  MOVFF  9E3,FEF
....................          return (FR_OK); 
064CC:  MOVLW  00
064CE:  MOVWF  01
064D0:  BRA    65C6
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
064D2:  MOVLW  0B
064D4:  ADDWF  xE3,W
064D6:  MOVWF  01
064D8:  MOVLW  00
064DA:  ADDWFC xE4,W
064DC:  MOVWF  03
064DE:  MOVFF  01,FE9
064E2:  MOVWF  FEA
064E4:  BTFSC  FEF.4
064E6:  BRA    64EE
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
064E8:  MOVLW  03
064EA:  MOVWF  01
064EC:  BRA    65C6
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
064EE:  MOVLW  14
064F0:  ADDWF  xE3,W
064F2:  MOVWF  01
064F4:  MOVLW  00
064F6:  ADDWFC xE4,W
064F8:  MOVWF  03
064FA:  MOVFF  01,FE9
064FE:  MOVWF  FEA
06500:  MOVFF  FEC,9E1
06504:  MOVF   FED,F
06506:  MOVFF  FEF,9E5
0650A:  MOVFF  9E5,9E0
0650E:  CLRF   xE5
06510:  CLRF   xE6
06512:  MOVLW  1A
06514:  ADDWF  xE3,W
06516:  MOVWF  01
06518:  MOVLW  00
0651A:  ADDWFC xE4,W
0651C:  MOVFF  01,FE9
06520:  MOVWF  FEA
06522:  MOVFF  FEC,03
06526:  MOVF   FED,F
06528:  MOVF   FEF,W
0652A:  IORWF  xE5,W
0652C:  MOVWF  xDE
0652E:  MOVF   03,W
06530:  IORWF  xE6,W
06532:  MOVWF  xDF
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
06534:  MOVLW  04
06536:  ADDWF  xD6,W
06538:  MOVWF  01
0653A:  MOVLW  00
0653C:  ADDWFC xD7,W
0653E:  MOVFF  01,9E5
06542:  MOVFF  9D6,FE9
06546:  MOVFF  9D7,FEA
0654A:  MOVFF  9DE,FEF
0654E:  MOVFF  9DF,FEC
06552:  MOVFF  9E0,FEC
06556:  MOVFF  9E1,FEC
0655A:  MOVWF  FEA
0655C:  MOVFF  9E5,FE9
06560:  MOVFF  9DE,FEF
06564:  MOVFF  9DF,FEC
06568:  MOVFF  9E0,FEC
0656C:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
06570:  MOVLW  08
06572:  ADDWF  xD6,W
06574:  MOVWF  01
06576:  MOVLW  00
06578:  ADDWFC xD7,W
0657A:  MOVWF  03
0657C:  MOVFF  01,9E5
06580:  MOVWF  xE6
06582:  MOVFF  9E1,9F2
06586:  MOVFF  9E0,9F1
0658A:  MOVFF  9DF,9F0
0658E:  MOVFF  9DE,9EF
06592:  MOVLB  0
06594:  CALL   560E
06598:  MOVFF  9E6,FEA
0659C:  MOVFF  9E5,FE9
065A0:  MOVFF  00,FEF
065A4:  MOVFF  01,FEC
065A8:  MOVFF  02,FEC
065AC:  MOVFF  03,FEC
....................       scan->index = 0; 
065B0:  MOVLW  0C
065B2:  MOVLB  9
065B4:  ADDWF  xD6,W
065B6:  MOVWF  FE9
065B8:  MOVLW  00
065BA:  ADDWFC xD7,W
065BC:  MOVWF  FEA
065BE:  CLRF   FEC
065C0:  MOVF   FED,F
065C2:  CLRF   FEF
065C4:  BRA    636E
....................       } 
065C6:  MOVLB  0
065C8:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06BFC:  MOVLB  9
06BFE:  MOVFF  9D6,FE9
06C02:  MOVFF  9D7,FEA
06C06:  MOVFF  FEF,9D8
06C0A:  MOVFF  FEC,9D9
06C0E:  MOVFF  FEC,9DA
06C12:  MOVFF  FEC,9DB
....................    if (clust) {   // Dyanmic directory table  
06C16:  MOVF   xD8,F
06C18:  BNZ   6C26
06C1A:  MOVF   xD9,F
06C1C:  BNZ   6C26
06C1E:  MOVF   xDA,F
06C20:  BNZ   6C26
06C22:  MOVF   xDB,F
06C24:  BZ    6C86
....................       scan->clust = clust; 
06C26:  MOVLW  04
06C28:  ADDWF  xD6,W
06C2A:  MOVWF  FE9
06C2C:  MOVLW  00
06C2E:  ADDWFC xD7,W
06C30:  MOVWF  FEA
06C32:  MOVFF  9D8,FEF
06C36:  MOVFF  9D9,FEC
06C3A:  MOVFF  9DA,FEC
06C3E:  MOVFF  9DB,FEC
....................       scan->sect = clust2sect(clust); 
06C42:  MOVLW  08
06C44:  ADDWF  xD6,W
06C46:  MOVWF  01
06C48:  MOVLW  00
06C4A:  ADDWFC xD7,W
06C4C:  MOVWF  03
06C4E:  MOVFF  01,9E4
06C52:  MOVWF  xE5
06C54:  MOVFF  9DB,9F2
06C58:  MOVFF  9DA,9F1
06C5C:  MOVFF  9D9,9F0
06C60:  MOVFF  9D8,9EF
06C64:  MOVLB  0
06C66:  CALL   560E
06C6A:  MOVFF  9E5,FEA
06C6E:  MOVFF  9E4,FE9
06C72:  MOVFF  00,FEF
06C76:  MOVFF  01,FEC
06C7A:  MOVFF  02,FEC
06C7E:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06C82:  BRA    6CD0
06C84:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06C86:  MOVLW  08
06C88:  ADDWF  xD6,W
06C8A:  MOVWF  01
06C8C:  MOVLW  00
06C8E:  ADDWFC xD7,W
06C90:  MOVWF  03
06C92:  MOVFF  01,9E4
06C96:  MOVWF  xE5
06C98:  MOVLW  14
06C9A:  MOVLB  7
06C9C:  ADDWF  x12,W
06C9E:  MOVWF  FE9
06CA0:  MOVLW  00
06CA2:  ADDWFC x13,W
06CA4:  MOVWF  FEA
06CA6:  MOVFF  FEF,00
06CAA:  MOVFF  FEC,01
06CAE:  MOVFF  FEC,02
06CB2:  MOVFF  FEC,03
06CB6:  MOVFF  9E5,FEA
06CBA:  MOVFF  9E4,FE9
06CBE:  MOVFF  00,FEF
06CC2:  MOVFF  01,FEC
06CC6:  MOVFF  02,FEC
06CCA:  MOVFF  03,FEC
06CCE:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06CD0:  MOVLW  0C
06CD2:  MOVLB  9
06CD4:  ADDWF  xD6,W
06CD6:  MOVWF  FE9
06CD8:  MOVLW  00
06CDA:  ADDWFC xD7,W
06CDC:  MOVWF  FEA
06CDE:  CLRF   FEC
06CE0:  MOVF   FED,F
06CE2:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06CE4:  MOVLW  08
06CE6:  ADDWF  xD6,W
06CE8:  MOVWF  FE9
06CEA:  MOVLW  00
06CEC:  ADDWFC xD7,W
06CEE:  MOVWF  FEA
06CF0:  MOVFF  FEF,A14
06CF4:  MOVFF  FEC,A15
06CF8:  MOVFF  FEC,A16
06CFC:  MOVFF  FEC,A17
06D00:  MOVLB  0
06D02:  CALL   5A82
06D06:  MOVF   01,F
06D08:  BNZ   6D12
....................          return (NULL); 
06D0A:  MOVLW  00
06D0C:  MOVWF  01
06D0E:  MOVWF  02
06D10:  BRA    6F40
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06D12:  MOVLW  0C
06D14:  MOVLB  9
06D16:  ADDWF  xD6,W
06D18:  MOVWF  FE9
06D1A:  MOVLW  00
06D1C:  ADDWFC xD7,W
06D1E:  MOVWF  FEA
06D20:  MOVFF  FEC,9E5
06D24:  MOVF   FED,F
06D26:  MOVFF  FEF,9E4
06D2A:  MOVLW  0F
06D2C:  ANDWF  xE4,F
06D2E:  CLRF   xE5
06D30:  RLCF   xE4,F
06D32:  RLCF   xE5,F
06D34:  RLCF   xE4,F
06D36:  RLCF   xE5,F
06D38:  RLCF   xE4,F
06D3A:  RLCF   xE5,F
06D3C:  RLCF   xE4,F
06D3E:  RLCF   xE5,F
06D40:  RLCF   xE4,F
06D42:  RLCF   xE5,F
06D44:  MOVLW  E0
06D46:  ANDWF  xE4,F
06D48:  MOVLW  24
06D4A:  ADDWF  xE4,W
06D4C:  MOVWF  01
06D4E:  MOVLW  00
06D50:  ADDWFC xE5,W
06D52:  MOVWF  03
06D54:  MOVF   01,W
06D56:  MOVLB  7
06D58:  ADDWF  x12,W
06D5A:  MOVWF  01
06D5C:  MOVF   x13,W
06D5E:  ADDWFC 03,F
06D60:  MOVFF  01,9E2
06D64:  MOVLB  9
06D66:  MOVFF  03,9E3
....................       c = *dptr; 
06D6A:  MOVFF  9E2,FE9
06D6E:  MOVFF  9E3,FEA
06D72:  MOVFF  FEF,9E0
....................       if ((c == 0) || (c == 0xE5))  
06D76:  MOVF   xE0,F
06D78:  BZ    6D80
06D7A:  MOVF   xE0,W
06D7C:  SUBLW  E5
06D7E:  BNZ   6D8E
....................          return (dptr);      // Found an empty entry!  
06D80:  MOVFF  9E2,01
06D84:  MOVFF  9E3,02
06D88:  MOVLB  0
06D8A:  BRA    6F40
06D8C:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06D8E:  MOVFF  9D7,9E6
06D92:  MOVFF  9D6,9E5
06D96:  MOVLB  0
06D98:  CALL   6008
06D9C:  MOVF   01,F
06D9E:  BTFSC  FD8.2
06DA0:  BRA    6DA6
06DA2:  MOVLB  9
06DA4:  BRA    6CE4
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06DA6:  MOVLB  9
06DA8:  MOVF   xD8,F
06DAA:  BNZ   6DC4
06DAC:  MOVF   xD9,F
06DAE:  BNZ   6DC4
06DB0:  MOVF   xDA,F
06DB2:  BNZ   6DC4
06DB4:  MOVF   xDB,F
06DB6:  BNZ   6DC4
....................        return (NULL); 
06DB8:  MOVLW  00
06DBA:  MOVWF  01
06DBC:  MOVWF  02
06DBE:  MOVLB  0
06DC0:  BRA    6F40
06DC2:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06DC4:  MOVLW  04
06DC6:  ADDWF  xD6,W
06DC8:  MOVWF  FE9
06DCA:  MOVLW  00
06DCC:  ADDWFC xD7,W
06DCE:  MOVWF  FEA
06DD0:  MOVFF  FEF,9E8
06DD4:  MOVFF  FEC,9E9
06DD8:  MOVFF  FEC,9EA
06DDC:  MOVFF  FEC,9EB
06DE0:  MOVLB  0
06DE2:  RCALL  6964
06DE4:  MOVFF  03,9DB
06DE8:  MOVFF  02,9DA
06DEC:  MOVFF  01,9D9
06DF0:  MOVFF  00,9D8
....................    if (!(clust))  
06DF4:  MOVLB  9
06DF6:  MOVF   xD8,F
06DF8:  BNZ   6E12
06DFA:  MOVF   xD9,F
06DFC:  BNZ   6E12
06DFE:  MOVF   xDA,F
06E00:  BNZ   6E12
06E02:  MOVF   xDB,F
06E04:  BNZ   6E12
....................       return (NULL); 
06E06:  MOVLW  00
06E08:  MOVWF  01
06E0A:  MOVWF  02
06E0C:  MOVLB  0
06E0E:  BRA    6F40
06E10:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06E12:  MOVLB  A
06E14:  CLRF   x17
06E16:  CLRF   x16
06E18:  CLRF   x15
06E1A:  CLRF   x14
06E1C:  MOVLB  0
06E1E:  CALL   5A82
06E22:  MOVF   01,F
06E24:  BNZ   6E2E
....................       return (0); 
06E26:  MOVLW  00
06E28:  MOVWF  01
06E2A:  MOVWF  02
06E2C:  BRA    6F40
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06E2E:  MOVLW  20
06E30:  MOVLB  7
06E32:  ADDWF  x12,W
06E34:  MOVWF  01
06E36:  MOVLW  00
06E38:  ADDWFC x13,W
06E3A:  MOVWF  03
06E3C:  MOVFF  01,9E4
06E40:  MOVLB  9
06E42:  MOVWF  xE5
06E44:  MOVFF  9DB,9F2
06E48:  MOVFF  9DA,9F1
06E4C:  MOVFF  9D9,9F0
06E50:  MOVFF  9D8,9EF
06E54:  MOVLB  0
06E56:  CALL   560E
06E5A:  MOVFF  03,9DF
06E5E:  MOVFF  02,9DE
06E62:  MOVFF  01,9DD
06E66:  MOVFF  00,9DC
06E6A:  MOVFF  9E5,FEA
06E6E:  MOVFF  9E4,FE9
06E72:  MOVFF  9DC,FEF
06E76:  MOVFF  9DD,FEC
06E7A:  MOVFF  9DE,FEC
06E7E:  MOVFF  9DF,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06E82:  MOVLW  24
06E84:  MOVLB  7
06E86:  ADDWF  x12,W
06E88:  MOVWF  01
06E8A:  MOVLW  00
06E8C:  ADDWFC x13,W
06E8E:  MOVWF  03
06E90:  MOVFF  01,9E4
06E94:  MOVLB  9
06E96:  MOVWF  xE5
06E98:  MOVWF  FEA
06E9A:  MOVFF  01,FE9
06E9E:  CLRF   00
06EA0:  MOVLW  02
06EA2:  MOVWF  02
06EA4:  CLRF   01
06EA6:  MOVLB  0
06EA8:  CALL   3526
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06EAC:  MOVLW  02
06EAE:  MOVLB  7
06EB0:  ADDWF  x12,W
06EB2:  MOVWF  FE9
06EB4:  MOVLW  00
06EB6:  ADDWFC x13,W
06EB8:  MOVWF  FEA
06EBA:  MOVFF  FEF,9E1
06EBE:  MOVLB  9
06EC0:  MOVF   xE1,F
06EC2:  BZ    6F20
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06EC4:  MOVLW  24
06EC6:  MOVLB  7
06EC8:  ADDWF  x12,W
06ECA:  MOVWF  01
06ECC:  MOVLW  00
06ECE:  ADDWFC x13,W
06ED0:  MOVWF  03
06ED2:  MOVFF  01,9E4
06ED6:  MOVLB  9
06ED8:  MOVWF  xE5
06EDA:  MOVFF  FE8,A21
06EDE:  MOVFF  01,A20
06EE2:  MOVFF  9DF,A25
06EE6:  MOVFF  9DE,A24
06EEA:  MOVFF  9DD,A23
06EEE:  MOVFF  9DC,A22
06EF2:  MOVLW  01
06EF4:  MOVLB  A
06EF6:  MOVWF  x26
06EF8:  MOVLB  0
06EFA:  CALL   593E
06EFE:  MOVF   01,F
06F00:  BZ    6F0A
....................          return (NULL); 
06F02:  MOVLW  00
06F04:  MOVWF  01
06F06:  MOVWF  02
06F08:  BRA    6F40
....................       sector++; 
06F0A:  MOVLW  01
06F0C:  MOVLB  9
06F0E:  ADDWF  xDC,F
06F10:  BTFSC  FD8.0
06F12:  INCF   xDD,F
06F14:  BTFSC  FD8.2
06F16:  INCF   xDE,F
06F18:  BTFSC  FD8.2
06F1A:  INCF   xDF,F
06F1C:  DECF   xE1,F
06F1E:  BRA    6EC0
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06F20:  MOVLW  06
06F22:  MOVLB  7
06F24:  ADDWF  x12,W
06F26:  MOVWF  FE9
06F28:  MOVLW  00
06F2A:  ADDWFC x13,W
06F2C:  MOVWF  FEA
06F2E:  MOVLW  01
06F30:  MOVWF  FEF
....................    return (fs->win); 
06F32:  MOVLW  24
06F34:  ADDWF  x12,W
06F36:  MOVWF  01
06F38:  MOVLW  00
06F3A:  ADDWFC x13,W
06F3C:  MOVWF  03
06F3E:  MOVWF  02
06F40:  MOVLB  0
06F42:  GOTO   71DA (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
055AC:  MOVLB  7
055AE:  MOVF   x12,W
055B0:  IORWF  x13,W
055B2:  BNZ   55BA
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
055B4:  MOVLW  0B
055B6:  MOVWF  01
055B8:  BRA    560A
....................  
....................    if (disk_status() & STA_NOINIT)  
055BA:  MOVLB  0
055BC:  RCALL  559E
055BE:  BTFSS  01.0
055C0:  BRA    55EC
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
055C2:  MOVLW  01
055C4:  MOVLB  7
055C6:  ADDWF  x12,W
055C8:  MOVWF  FE9
055CA:  MOVLW  00
055CC:  ADDWFC x13,W
055CE:  MOVWF  FEA
055D0:  MOVF   FEF,F
055D2:  BZ    55DC
....................          return (FR_INCORRECT_DISK_CHANGE); 
055D4:  MOVLW  09
055D6:  MOVWF  01
055D8:  BRA    560A
055DA:  BRA    55E8
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
055DC:  MOVLB  0
055DE:  CALL   4856
055E2:  MOVF   01,W
055E4:  MOVLB  7
055E6:  BRA    560A
....................       }  
055E8:  BRA    5606
055EA:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
055EC:  MOVLB  7
055EE:  MOVFF  712,FE9
055F2:  MOVFF  713,FEA
055F6:  MOVF   FEF,F
055F8:  BNZ   5606
....................          return (f_mountdrv());      // Initialize file system and return resulut  
055FA:  MOVLB  0
055FC:  CALL   4856
05600:  MOVF   01,W
05602:  MOVLB  7
05604:  BRA    560A
....................       } 
....................    return FR_OK;                  // File system is valid  
05606:  MOVLW  00
05608:  MOVWF  01
0560A:  MOVLB  0
0560C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B93A:  MOVLB  8
0B93C:  MOVF   xCC,W
0B93E:  XORLW  00
0B940:  MOVLB  0
0B942:  BZ    B97C
0B944:  XORLW  04
0B946:  BZ    B998
0B948:  XORLW  05
0B94A:  BZ    B9B4
0B94C:  XORLW  03
0B94E:  BZ    B9D0
0B950:  XORLW  01
0B952:  BZ    B9EC
0B954:  XORLW  06
0B956:  BZ    BA08
0B958:  XORLW  03
0B95A:  BZ    BA24
0B95C:  XORLW  01
0B95E:  BTFSC  FD8.2
0B960:  BRA    BA40
0B962:  XORLW  0E
0B964:  BTFSC  FD8.2
0B966:  BRA    BA5C
0B968:  XORLW  03
0B96A:  BTFSC  FD8.2
0B96C:  BRA    BA78
0B96E:  XORLW  01
0B970:  BTFSC  FD8.2
0B972:  BRA    BA94
0B974:  XORLW  07
0B976:  BTFSC  FD8.2
0B978:  BRA    BAB0
0B97A:  BRA    BACC
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B97C:  MOVFF  8CE,FEA
0B980:  MOVFF  8CD,FE9
0B984:  MOVLW  00
0B986:  CALL   0106
0B98A:  TBLRD*-
0B98C:  TBLRD*+
0B98E:  MOVF   FF5,W
0B990:  MOVWF  FEE
0B992:  IORLW  00
0B994:  BNZ   B98C
....................          break; 
0B996:  BRA    BAE6
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B998:  MOVFF  8CE,FEA
0B99C:  MOVFF  8CD,FE9
0B9A0:  MOVLW  00
0B9A2:  CALL   0124
0B9A6:  TBLRD*-
0B9A8:  TBLRD*+
0B9AA:  MOVF   FF5,W
0B9AC:  MOVWF  FEE
0B9AE:  IORLW  00
0B9B0:  BNZ   B9A8
....................          break; 
0B9B2:  BRA    BAE6
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B9B4:  MOVFF  8CE,FEA
0B9B8:  MOVFF  8CD,FE9
0B9BC:  MOVLW  00
0B9BE:  CALL   014A
0B9C2:  TBLRD*-
0B9C4:  TBLRD*+
0B9C6:  MOVF   FF5,W
0B9C8:  MOVWF  FEE
0B9CA:  IORLW  00
0B9CC:  BNZ   B9C4
....................          break; 
0B9CE:  BRA    BAE6
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0B9D0:  MOVFF  8CE,FEA
0B9D4:  MOVFF  8CD,FE9
0B9D8:  MOVLW  00
0B9DA:  CALL   016E
0B9DE:  TBLRD*-
0B9E0:  TBLRD*+
0B9E2:  MOVF   FF5,W
0B9E4:  MOVWF  FEE
0B9E6:  IORLW  00
0B9E8:  BNZ   B9E0
....................          break; 
0B9EA:  BRA    BAE6
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0B9EC:  MOVFF  8CE,FEA
0B9F0:  MOVFF  8CD,FE9
0B9F4:  MOVLW  00
0B9F6:  CALL   0192
0B9FA:  TBLRD*-
0B9FC:  TBLRD*+
0B9FE:  MOVF   FF5,W
0BA00:  MOVWF  FEE
0BA02:  IORLW  00
0BA04:  BNZ   B9FC
....................          break; 
0BA06:  BRA    BAE6
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0BA08:  MOVFF  8CE,FEA
0BA0C:  MOVFF  8CD,FE9
0BA10:  MOVLW  00
0BA12:  CALL   01B6
0BA16:  TBLRD*-
0BA18:  TBLRD*+
0BA1A:  MOVF   FF5,W
0BA1C:  MOVWF  FEE
0BA1E:  IORLW  00
0BA20:  BNZ   BA18
....................          break; 
0BA22:  BRA    BAE6
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0BA24:  MOVFF  8CE,FEA
0BA28:  MOVFF  8CD,FE9
0BA2C:  MOVLW  00
0BA2E:  CALL   01D8
0BA32:  TBLRD*-
0BA34:  TBLRD*+
0BA36:  MOVF   FF5,W
0BA38:  MOVWF  FEE
0BA3A:  IORLW  00
0BA3C:  BNZ   BA34
....................          break; 
0BA3E:  BRA    BAE6
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0BA40:  MOVFF  8CE,FEA
0BA44:  MOVFF  8CD,FE9
0BA48:  MOVLW  00
0BA4A:  CALL   01F8
0BA4E:  TBLRD*-
0BA50:  TBLRD*+
0BA52:  MOVF   FF5,W
0BA54:  MOVWF  FEE
0BA56:  IORLW  00
0BA58:  BNZ   BA50
....................          break; 
0BA5A:  BRA    BAE6
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0BA5C:  MOVFF  8CE,FEA
0BA60:  MOVFF  8CD,FE9
0BA64:  MOVLW  00
0BA66:  CALL   0216
0BA6A:  TBLRD*-
0BA6C:  TBLRD*+
0BA6E:  MOVF   FF5,W
0BA70:  MOVWF  FEE
0BA72:  IORLW  00
0BA74:  BNZ   BA6C
....................          break; 
0BA76:  BRA    BAE6
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0BA78:  MOVFF  8CE,FEA
0BA7C:  MOVFF  8CD,FE9
0BA80:  MOVLW  00
0BA82:  CALL   0242
0BA86:  TBLRD*-
0BA88:  TBLRD*+
0BA8A:  MOVF   FF5,W
0BA8C:  MOVWF  FEE
0BA8E:  IORLW  00
0BA90:  BNZ   BA88
....................          break; 
0BA92:  BRA    BAE6
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0BA94:  MOVFF  8CE,FEA
0BA98:  MOVFF  8CD,FE9
0BA9C:  MOVLW  00
0BA9E:  CALL   0266
0BAA2:  TBLRD*-
0BAA4:  TBLRD*+
0BAA6:  MOVF   FF5,W
0BAA8:  MOVWF  FEE
0BAAA:  IORLW  00
0BAAC:  BNZ   BAA4
....................          break; 
0BAAE:  BRA    BAE6
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0BAB0:  MOVFF  8CE,FEA
0BAB4:  MOVFF  8CD,FE9
0BAB8:  MOVLW  00
0BABA:  CALL   028A
0BABE:  TBLRD*-
0BAC0:  TBLRD*+
0BAC2:  MOVF   FF5,W
0BAC4:  MOVWF  FEE
0BAC6:  IORLW  00
0BAC8:  BNZ   BAC0
....................          break; 
0BACA:  BRA    BAE6
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0BACC:  MOVFF  8CE,FEA
0BAD0:  MOVFF  8CD,FE9
0BAD4:  MOVLW  00
0BAD6:  CALL   02AC
0BADA:  TBLRD*-
0BADC:  TBLRD*+
0BADE:  MOVF   FF5,W
0BAE0:  MOVWF  FEE
0BAE2:  IORLW  00
0BAE4:  BNZ   BADC
....................       } 
0BAE6:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
04856:  MOVLB  7
04858:  MOVF   x12,W
0485A:  IORWF  x13,W
0485C:  BNZ   4864
....................       return (FR_NOT_ENABLED); 
0485E:  MOVLW  0B
04860:  MOVWF  01
04862:  BRA    4DF0
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
04864:  MOVFF  713,FEA
04868:  MOVFF  712,FE9
0486C:  CLRF   00
0486E:  MOVLW  02
04870:  MOVWF  02
04872:  MOVLW  24
04874:  MOVWF  01
04876:  MOVLB  0
04878:  CALL   3526
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
0487C:  CALL   3676
04880:  MOVFF  01,4ED
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
04884:  MOVLB  4
04886:  BTFSS  xED.0
04888:  BRA    4896
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
0488A:  MOVLB  0
0488C:  CALL   3676
04890:  MOVFF  01,4ED
04894:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
04896:  BTFSS  xED.0
04898:  BRA    48A4
0489A:  MOVLW  01
0489C:  MOVWF  01
0489E:  MOVLB  7
048A0:  BRA    4DF0
048A2:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
048A4:  MOVLB  9
048A6:  CLRF   xDA
048A8:  CLRF   xD9
048AA:  CLRF   xD8
048AC:  CLRF   xD7
048AE:  MOVFF  9DA,9E6
048B2:  MOVFF  9D9,9E5
048B6:  MOVFF  9D8,9E4
048BA:  MOVFF  9D7,9E3
048BE:  MOVLB  0
048C0:  RCALL  4690
048C2:  MOVFF  01,9D6
....................    if (!fat)  
048C6:  MOVLB  9
048C8:  MOVF   xD6,F
048CA:  BNZ   493A
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
048CC:  MOVLW  E6
048CE:  MOVLB  7
048D0:  ADDWF  x12,W
048D2:  MOVWF  FE9
048D4:  MOVLW  01
048D6:  ADDWFC x13,W
048D8:  MOVWF  FEA
048DA:  MOVF   FEF,F
048DC:  BZ    491A
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
048DE:  MOVLW  EA
048E0:  ADDWF  x12,W
048E2:  MOVWF  01
048E4:  MOVLW  01
048E6:  ADDWFC x13,W
048E8:  MOVFF  01,FE9
048EC:  MOVWF  FEA
048EE:  MOVFF  FEF,9D7
048F2:  MOVFF  FEC,9D8
048F6:  MOVFF  FEC,9D9
048FA:  MOVFF  FEC,9DA
....................          fat = check_fs(sect);            // Check the partition  
048FE:  MOVFF  9DA,9E6
04902:  MOVFF  9D9,9E5
04906:  MOVFF  9D8,9E4
0490A:  MOVFF  9D7,9E3
0490E:  MOVLB  0
04910:  RCALL  4690
04912:  MOVFF  01,9D6
....................          } 
04916:  BRA    4938
04918:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
0491A:  MOVLW  04
0491C:  MOVWF  FF6
0491E:  MOVLW  0C
04920:  MOVWF  FF7
04922:  MOVLW  00
04924:  MOVWF  FF8
04926:  CLRF   1B
04928:  BTFSC  FF2.7
0492A:  BSF    1B.7
0492C:  BCF    FF2.7
0492E:  MOVLB  0
04930:  CALL   0E4E
04934:  BTFSC  1B.7
04936:  BSF    FF2.7
04938:  MOVLB  9
....................       } 
....................    if (!fat)  
0493A:  MOVF   xD6,F
0493C:  BNZ   4948
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
0493E:  MOVLW  0C
04940:  MOVWF  01
04942:  MOVLB  7
04944:  BRA    4DF0
04946:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
04948:  MOVLB  7
0494A:  MOVFF  712,FE9
0494E:  MOVFF  713,FEA
04952:  MOVFF  9D6,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
04956:  MOVLB  9
04958:  MOVF   xD6,W
0495A:  SUBLW  03
0495C:  BNZ   49C2
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
0495E:  MOVLW  08
04960:  MOVLB  7
04962:  ADDWF  x12,W
04964:  MOVWF  01
04966:  MOVLW  00
04968:  ADDWFC x13,W
0496A:  MOVWF  03
0496C:  MOVFF  01,9E3
04970:  MOVLB  9
04972:  MOVWF  xE4
04974:  MOVLW  48
04976:  MOVLB  7
04978:  ADDWF  x12,W
0497A:  MOVWF  01
0497C:  MOVLW  00
0497E:  ADDWFC x13,W
04980:  MOVFF  01,FE9
04984:  MOVWF  FEA
04986:  MOVFF  FEF,00
0498A:  MOVFF  FEC,01
0498E:  MOVFF  FEC,02
04992:  MOVFF  FEC,03
04996:  MOVFF  03,9E8
0499A:  MOVFF  02,9E7
0499E:  MOVFF  01,9E6
049A2:  MOVFF  00,9E5
049A6:  MOVFF  9E4,FEA
049AA:  MOVFF  9E3,FE9
049AE:  MOVFF  00,FEF
049B2:  MOVFF  01,FEC
049B6:  MOVFF  02,FEC
049BA:  MOVFF  03,FEC
049BE:  BRA    4A1A
049C0:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
049C2:  MOVLW  08
049C4:  MOVLB  7
049C6:  ADDWF  x12,W
049C8:  MOVWF  01
049CA:  MOVLW  00
049CC:  ADDWFC x13,W
049CE:  MOVWF  03
049D0:  MOVFF  01,9E3
049D4:  MOVLB  9
049D6:  MOVWF  xE4
049D8:  MOVLW  3A
049DA:  MOVLB  7
049DC:  ADDWF  x12,W
049DE:  MOVWF  01
049E0:  MOVLW  00
049E2:  ADDWFC x13,W
049E4:  MOVFF  01,FE9
049E8:  MOVWF  FEA
049EA:  MOVFF  FEC,03
049EE:  MOVF   FED,F
049F0:  MOVFF  FEF,9E5
049F4:  MOVLB  9
049F6:  MOVFF  03,9E6
049FA:  MOVFF  9E4,FEA
049FE:  MOVFF  9E3,FE9
04A02:  MOVF   FEE,F
04A04:  MOVF   FEE,F
04A06:  CLRF   FEC
04A08:  MOVF   FED,F
04A0A:  CLRF   FEF
04A0C:  MOVF   FED,F
04A0E:  MOVFF  03,FEF
04A12:  MOVF   FED,F
04A14:  MOVFF  9E5,FEF
04A18:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
04A1A:  MOVLW  02
04A1C:  ADDWF  x12,W
04A1E:  MOVWF  01
04A20:  MOVLW  00
04A22:  ADDWFC x13,W
04A24:  MOVWF  03
04A26:  MOVLW  31
04A28:  MOVLB  7
04A2A:  ADDWF  x12,W
04A2C:  MOVWF  FE9
04A2E:  MOVLW  00
04A30:  ADDWFC x13,W
04A32:  MOVWF  FEA
04A34:  MOVFF  FEF,9E5
04A38:  MOVLB  9
04A3A:  MOVFF  03,FEA
04A3E:  MOVFF  01,FE9
04A42:  MOVFF  9E5,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
04A46:  MOVLW  03
04A48:  MOVLB  7
04A4A:  ADDWF  x12,W
04A4C:  MOVWF  01
04A4E:  MOVLW  00
04A50:  ADDWFC x13,W
04A52:  MOVWF  03
04A54:  MOVLW  34
04A56:  MOVLB  7
04A58:  ADDWF  x12,W
04A5A:  MOVWF  FE9
04A5C:  MOVLW  00
04A5E:  ADDWFC x13,W
04A60:  MOVWF  FEA
04A62:  MOVFF  FEF,9E5
04A66:  MOVLB  9
04A68:  MOVFF  03,FEA
04A6C:  MOVFF  01,FE9
04A70:  MOVFF  9E5,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
04A74:  MOVLW  10
04A76:  MOVLB  7
04A78:  ADDWF  x12,W
04A7A:  MOVWF  01
04A7C:  MOVLW  00
04A7E:  ADDWFC x13,W
04A80:  MOVWF  03
04A82:  MOVFF  01,9E3
04A86:  MOVLB  9
04A88:  MOVWF  xE4
04A8A:  MOVLW  32
04A8C:  MOVLB  7
04A8E:  ADDWF  x12,W
04A90:  MOVWF  01
04A92:  MOVLW  00
04A94:  ADDWFC x13,W
04A96:  MOVFF  01,FE9
04A9A:  MOVWF  FEA
04A9C:  MOVFF  FEC,03
04AA0:  MOVF   FED,F
04AA2:  MOVF   FEF,W
04AA4:  MOVLB  9
04AA6:  ADDWF  xD7,W
04AA8:  MOVWF  00
04AAA:  MOVF   03,W
04AAC:  ADDWFC xD8,W
04AAE:  MOVWF  01
04AB0:  MOVLW  00
04AB2:  ADDWFC xD9,W
04AB4:  MOVWF  02
04AB6:  MOVLW  00
04AB8:  ADDWFC xDA,W
04ABA:  MOVFF  9E4,FEA
04ABE:  MOVFF  9E3,FE9
04AC2:  MOVFF  00,FEF
04AC6:  MOVFF  01,FEC
04ACA:  MOVFF  02,FEC
04ACE:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04AD0:  MOVLW  04
04AD2:  MOVLB  7
04AD4:  ADDWF  x12,W
04AD6:  MOVWF  01
04AD8:  MOVLW  00
04ADA:  ADDWFC x13,W
04ADC:  MOVWF  03
04ADE:  MOVFF  01,9E3
04AE2:  MOVLB  9
04AE4:  MOVWF  xE4
04AE6:  MOVLW  35
04AE8:  MOVLB  7
04AEA:  ADDWF  x12,W
04AEC:  MOVWF  01
04AEE:  MOVLW  00
04AF0:  ADDWFC x13,W
04AF2:  MOVFF  01,FE9
04AF6:  MOVWF  FEA
04AF8:  MOVFF  FEC,03
04AFC:  MOVF   FED,F
04AFE:  MOVFF  FEF,9E5
04B02:  MOVLB  9
04B04:  MOVFF  9E4,FEA
04B08:  MOVFF  9E3,FE9
04B0C:  MOVFF  03,FEC
04B10:  MOVF   FED,F
04B12:  MOVFF  9E5,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04B16:  MOVLW  08
04B18:  MOVLB  7
04B1A:  ADDWF  x12,W
04B1C:  MOVWF  FE9
04B1E:  MOVLW  00
04B20:  ADDWFC x13,W
04B22:  MOVWF  FEA
04B24:  MOVFF  FEF,9F6
04B28:  MOVFF  FEC,9F7
04B2C:  MOVFF  FEC,9F8
04B30:  MOVFF  FEC,9F9
04B34:  MOVLW  03
04B36:  ADDWF  x12,W
04B38:  MOVWF  FE9
04B3A:  MOVLW  00
04B3C:  ADDWFC x13,W
04B3E:  MOVWF  FEA
04B40:  MOVFF  FEF,9FA
04B44:  MOVLB  9
04B46:  MOVFF  FEA,9E9
04B4A:  MOVFF  FE9,9E8
04B4E:  CLRF   xFD
04B50:  CLRF   xFC
04B52:  CLRF   xFB
04B54:  MOVLB  0
04B56:  RCALL  47F0
04B58:  MOVFF  9E9,FEA
04B5C:  MOVFF  9E8,FE9
04B60:  MOVFF  03,9E6
04B64:  MOVFF  02,9E5
04B68:  MOVFF  01,9E4
04B6C:  MOVFF  00,9E3
04B70:  MOVLW  10
04B72:  MOVLB  7
04B74:  ADDWF  x12,W
04B76:  MOVWF  FE9
04B78:  MOVLW  00
04B7A:  ADDWFC x13,W
04B7C:  MOVWF  FEA
04B7E:  MOVFF  FEF,00
04B82:  MOVFF  FEC,01
04B86:  MOVFF  FEC,02
04B8A:  MOVFF  FEC,03
04B8E:  MOVF   00,W
04B90:  MOVLB  9
04B92:  ADDWF  xE3,W
04B94:  MOVWF  xDB
04B96:  MOVF   01,W
04B98:  ADDWFC xE4,W
04B9A:  MOVWF  xDC
04B9C:  MOVF   02,W
04B9E:  ADDWFC xE5,W
04BA0:  MOVWF  xDD
04BA2:  MOVF   03,W
04BA4:  ADDWFC xE6,W
04BA6:  MOVWF  xDE
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04BA8:  MOVF   xD6,W
04BAA:  SUBLW  03
04BAC:  BNZ   4C1E
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04BAE:  MOVLW  14
04BB0:  MOVLB  7
04BB2:  ADDWF  x12,W
04BB4:  MOVWF  01
04BB6:  MOVLW  00
04BB8:  ADDWFC x13,W
04BBA:  MOVWF  03
04BBC:  MOVFF  01,9E3
04BC0:  MOVLB  9
04BC2:  MOVWF  xE4
04BC4:  MOVLW  50
04BC6:  MOVLB  7
04BC8:  ADDWF  x12,W
04BCA:  MOVWF  01
04BCC:  MOVLW  00
04BCE:  ADDWFC x13,W
04BD0:  MOVFF  01,FE9
04BD4:  MOVWF  FEA
04BD6:  MOVFF  FEF,00
04BDA:  MOVFF  FEC,01
04BDE:  MOVFF  FEC,02
04BE2:  MOVFF  FEC,03
04BE6:  MOVFF  9E4,FEA
04BEA:  MOVFF  9E3,FE9
04BEE:  MOVFF  00,FEF
04BF2:  MOVFF  01,FEC
04BF6:  MOVFF  02,FEC
04BFA:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04BFE:  MOVLW  18
04C00:  ADDWF  x12,W
04C02:  MOVWF  FE9
04C04:  MOVLW  00
04C06:  ADDWFC x13,W
04C08:  MOVWF  FEA
04C0A:  MOVFF  9DB,FEF
04C0E:  MOVFF  9DC,FEC
04C12:  MOVFF  9DD,FEC
04C16:  MOVFF  9DE,FEC
....................       }  
04C1A:  BRA    4CAA
04C1C:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04C1E:  MOVLW  14
04C20:  MOVLB  7
04C22:  ADDWF  x12,W
04C24:  MOVWF  FE9
04C26:  MOVLW  00
04C28:  ADDWFC x13,W
04C2A:  MOVWF  FEA
04C2C:  MOVFF  9DB,FEF
04C30:  MOVFF  9DC,FEC
04C34:  MOVFF  9DD,FEC
04C38:  MOVFF  9DE,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04C3C:  MOVLW  18
04C3E:  ADDWF  x12,W
04C40:  MOVWF  01
04C42:  MOVLW  00
04C44:  ADDWFC x13,W
04C46:  MOVFF  01,9E3
04C4A:  MOVLB  9
04C4C:  MOVWF  xE4
04C4E:  MOVLW  04
04C50:  MOVLB  7
04C52:  ADDWF  x12,W
04C54:  MOVWF  FE9
04C56:  MOVLW  00
04C58:  ADDWFC x13,W
04C5A:  MOVWF  FEA
04C5C:  MOVFF  FEC,9E6
04C60:  MOVF   FED,F
04C62:  MOVFF  FEF,9E5
04C66:  MOVLB  9
04C68:  RRCF   xE6,F
04C6A:  RRCF   xE5,F
04C6C:  RRCF   xE6,F
04C6E:  RRCF   xE5,F
04C70:  RRCF   xE6,F
04C72:  RRCF   xE5,F
04C74:  RRCF   xE6,F
04C76:  RRCF   xE5,F
04C78:  MOVLW  0F
04C7A:  ANDWF  xE6,F
04C7C:  MOVF   xE5,W
04C7E:  ADDWF  xDB,W
04C80:  MOVWF  00
04C82:  MOVF   xE6,W
04C84:  ADDWFC xDC,W
04C86:  MOVWF  01
04C88:  MOVLW  00
04C8A:  ADDWFC xDD,W
04C8C:  MOVWF  02
04C8E:  MOVLW  00
04C90:  ADDWFC xDE,W
04C92:  MOVFF  9E4,FEA
04C96:  MOVFF  9E3,FE9
04C9A:  MOVFF  00,FEF
04C9E:  MOVFF  01,FEC
04CA2:  MOVFF  02,FEC
04CA6:  MOVWF  FEC
04CA8:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04CAA:  MOVLW  44
04CAC:  ADDWF  x12,W
04CAE:  MOVWF  01
04CB0:  MOVLW  00
04CB2:  ADDWFC x13,W
04CB4:  MOVFF  01,FE9
04CB8:  MOVWF  FEA
04CBA:  MOVFF  FEF,9DF
04CBE:  MOVFF  FEC,9E0
04CC2:  MOVFF  FEC,9E1
04CC6:  MOVFF  FEC,9E2
....................    if (!maxsect)  
04CCA:  MOVLB  9
04CCC:  MOVF   xDF,F
04CCE:  BNZ   4CFE
04CD0:  MOVF   xE0,F
04CD2:  BNZ   4CFE
04CD4:  MOVF   xE1,F
04CD6:  BNZ   4CFE
04CD8:  MOVF   xE2,F
04CDA:  BNZ   4CFE
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04CDC:  MOVLW  37
04CDE:  MOVLB  7
04CE0:  ADDWF  x12,W
04CE2:  MOVWF  01
04CE4:  MOVLW  00
04CE6:  ADDWFC x13,W
04CE8:  MOVFF  01,FE9
04CEC:  MOVWF  FEA
04CEE:  MOVLB  9
04CF0:  CLRF   xE2
04CF2:  CLRF   xE1
04CF4:  MOVFF  FEC,9E0
04CF8:  MOVF   FED,F
04CFA:  MOVFF  FEF,9DF
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04CFE:  MOVLW  0C
04D00:  MOVLB  7
04D02:  ADDWF  x12,W
04D04:  MOVWF  01
04D06:  MOVLW  00
04D08:  ADDWFC x13,W
04D0A:  MOVWF  03
04D0C:  MOVFF  01,9E3
04D10:  MOVLB  9
04D12:  MOVWF  xE4
04D14:  MOVLW  18
04D16:  MOVLB  7
04D18:  ADDWF  x12,W
04D1A:  MOVWF  FE9
04D1C:  MOVLW  00
04D1E:  ADDWFC x13,W
04D20:  MOVWF  FEA
04D22:  MOVFF  FEF,00
04D26:  MOVFF  FEC,01
04D2A:  MOVFF  FEC,02
04D2E:  MOVFF  FEC,03
04D32:  MOVF   00,W
04D34:  MOVLB  9
04D36:  SUBWF  xDF,W
04D38:  MOVWF  xE5
04D3A:  MOVF   01,W
04D3C:  SUBWFB xE0,W
04D3E:  MOVWF  xE6
04D40:  MOVF   02,W
04D42:  SUBWFB xE1,W
04D44:  MOVWF  xE7
04D46:  MOVF   03,W
04D48:  SUBWFB xE2,W
04D4A:  MOVWF  xE8
04D4C:  MOVF   xD7,W
04D4E:  ADDWF  xE5,F
04D50:  MOVF   xD8,W
04D52:  ADDWFC xE6,F
04D54:  MOVF   xD9,W
04D56:  ADDWFC xE7,F
04D58:  MOVF   xDA,W
04D5A:  ADDWFC xE8,F
04D5C:  MOVLW  02
04D5E:  MOVLB  7
04D60:  ADDWF  x12,W
04D62:  MOVWF  FE9
04D64:  MOVLW  00
04D66:  ADDWFC x13,W
04D68:  MOVWF  FEA
04D6A:  MOVFF  FEF,A50
04D6E:  MOVLB  9
04D70:  MOVFF  FEA,9EB
04D74:  MOVFF  FE9,9EA
04D78:  BCF    FD8.1
04D7A:  CLRF   1B
04D7C:  BTFSC  FF2.7
04D7E:  BSF    1B.7
04D80:  BCF    FF2.7
04D82:  MOVFF  9E8,A4F
04D86:  MOVFF  9E7,A4E
04D8A:  MOVFF  9E6,A4D
04D8E:  MOVFF  9E5,A4C
04D92:  MOVLB  A
04D94:  CLRF   x53
04D96:  CLRF   x52
04D98:  CLRF   x51
04D9A:  MOVLB  0
04D9C:  CALL   1056
04DA0:  BTFSC  1B.7
04DA2:  BSF    FF2.7
04DA4:  MOVFF  9EB,FEA
04DA8:  MOVFF  9EA,FE9
04DAC:  MOVFF  03,9E8
04DB0:  MOVFF  02,9E7
04DB4:  MOVFF  01,9E6
04DB8:  MOVFF  00,9E5
04DBC:  MOVLW  02
04DBE:  MOVLB  9
04DC0:  ADDWF  00,W
04DC2:  MOVWF  00
04DC4:  MOVLW  00
04DC6:  ADDWFC 01,W
04DC8:  MOVWF  01
04DCA:  MOVLW  00
04DCC:  ADDWFC 02,W
04DCE:  MOVWF  02
04DD0:  MOVLW  00
04DD2:  ADDWFC 03,W
04DD4:  MOVFF  9E4,FEA
04DD8:  MOVFF  9E3,FE9
04DDC:  MOVFF  00,FEF
04DE0:  MOVFF  01,FEC
04DE4:  MOVFF  02,FEC
04DE8:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04DEA:  MOVLW  00
04DEC:  MOVWF  01
04DEE:  MOVLB  7
04DF0:  MOVLB  0
04DF2:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
07158:  CALL   55AC
0715C:  MOVFF  01,9C3
....................    if (result != FR_OK)  
07160:  MOVLB  9
07162:  MOVF   xC3,F
07164:  BZ    716C
....................       return (result); 
07166:  MOVFF  9C3,01
0716A:  BRA    759C
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
0716C:  MOVF   xB4,W
0716E:  ANDLW  0A
07170:  BZ    7188
07172:  MOVLB  0
07174:  CALL   559E
07178:  BTFSC  01.2
0717A:  BRA    7180
0717C:  MOVLB  9
0717E:  BRA    7188
....................          return (FR_WRITE_PROTECTED); 
07180:  MOVLW  0A
07182:  MOVWF  01
07184:  MOVLB  9
07186:  BRA    759C
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
07188:  MOVLW  09
0718A:  MOVWF  xD7
0718C:  MOVLW  B5
0718E:  MOVWF  xD6
07190:  MOVLW  09
07192:  MOVWF  xD9
07194:  MOVLW  C6
07196:  MOVWF  xD8
07198:  MOVFF  9B3,9DB
0719C:  MOVFF  9B2,9DA
071A0:  MOVLW  09
071A2:  MOVWF  xDD
071A4:  MOVLW  C4
071A6:  MOVWF  xDC
071A8:  MOVLB  0
071AA:  CALL   61E2
071AE:  MOVFF  01,9C3
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
071B2:  MOVLB  9
071B4:  MOVF   xB4,W
071B6:  ANDLW  18
071B8:  BTFSC  FD8.2
071BA:  BRA    73DE
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
071BC:  MOVF   xC3,F
071BE:  BZ    7246
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
071C0:  BSF    xB4.3
....................          if (result != FR_NO_FILE) 
071C2:  MOVF   xC3,W
071C4:  SUBLW  02
071C6:  BZ    71CE
....................             return (result); 
071C8:  MOVFF  9C3,01
071CC:  BRA    759C
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
071CE:  MOVLW  09
071D0:  MOVWF  xD7
071D2:  MOVLW  B5
071D4:  MOVWF  xD6
071D6:  MOVLB  0
071D8:  BRA    6BFC
071DA:  MOVFF  02,9C5
071DE:  MOVFF  01,9C4
....................          if (dir_ptr == NULL) 
071E2:  MOVLB  9
071E4:  MOVF   xC4,F
071E6:  BNZ   71F2
071E8:  MOVF   xC5,F
071EA:  BNZ   71F2
....................             return (FR_DENIED); 
071EC:  MOVLW  05
071EE:  MOVWF  01
071F0:  BRA    759C
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
071F2:  MOVFF  9C5,FEA
071F6:  MOVFF  9C4,FE9
071FA:  MOVLW  09
071FC:  MOVWF  FE2
071FE:  MOVLW  C6
07200:  MOVWF  FE1
07202:  MOVLW  0B
07204:  MOVWF  01
07206:  MOVFF  FE6,FEE
0720A:  DECFSZ 01,F
0720C:  BRA    7206
....................          *(dir_ptr+12) = fn[11]; 
0720E:  MOVLW  0C
07210:  ADDWF  xC4,W
07212:  MOVWF  01
07214:  MOVLW  00
07216:  ADDWFC xC5,W
07218:  MOVFF  01,FE9
0721C:  MOVWF  FEA
0721E:  MOVFF  9D1,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
07222:  MOVLW  0D
07224:  ADDWF  xC4,W
07226:  MOVWF  xD6
07228:  MOVLW  00
0722A:  ADDWFC xC5,W
0722C:  MOVWF  xD7
0722E:  MOVWF  FEA
07230:  MOVFF  9D6,FE9
07234:  CLRF   00
07236:  CLRF   02
07238:  MOVLW  13
0723A:  MOVWF  01
0723C:  MOVLB  0
0723E:  CALL   3526
....................       }  
07242:  BRA    7358
07244:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
07246:  MOVF   xC4,F
07248:  BNZ   724E
0724A:  MOVF   xC5,F
0724C:  BZ    7266
0724E:  MOVLW  0B
07250:  ADDWF  xC4,W
07252:  MOVWF  01
07254:  MOVLW  00
07256:  ADDWFC xC5,W
07258:  MOVWF  03
0725A:  MOVFF  01,FE9
0725E:  MOVWF  FEA
07260:  MOVF   FEF,W
07262:  ANDLW  11
07264:  BZ    726C
....................             return (FR_DENIED); 
07266:  MOVLW  05
07268:  MOVWF  01
0726A:  BRA    759C
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
0726C:  BTFSS  xB4.3
0726E:  BRA    7356
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
07270:  MOVLW  20
07272:  MOVLB  7
07274:  ADDWF  x12,W
07276:  MOVWF  FE9
07278:  MOVLW  00
0727A:  ADDWFC x13,W
0727C:  MOVWF  FEA
0727E:  MOVFF  FEF,9D2
07282:  MOVFF  FEC,9D3
07286:  MOVFF  FEC,9D4
0728A:  MOVFF  FEC,9D5
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
0728E:  MOVLW  14
07290:  MOVLB  9
07292:  ADDWF  xC4,W
07294:  MOVWF  01
07296:  MOVLW  00
07298:  ADDWFC xC5,W
0729A:  MOVWF  03
0729C:  MOVFF  01,FE9
072A0:  MOVWF  FEA
072A2:  MOVFF  FEC,9DE
072A6:  MOVF   FED,F
072A8:  MOVFF  FEF,9D6
072AC:  CLRF   xD8
072AE:  MOVFF  9D6,9DD
072B2:  CLRF   xD6
072B4:  CLRF   xD7
072B6:  MOVLW  1A
072B8:  ADDWF  xC4,W
072BA:  MOVWF  01
072BC:  MOVLW  00
072BE:  ADDWFC xC5,W
072C0:  MOVFF  01,FE9
072C4:  MOVWF  FEA
072C6:  MOVFF  FEC,03
072CA:  MOVF   FED,F
072CC:  MOVF   FEF,W
072CE:  IORWF  xD6,F
072D0:  MOVF   03,W
072D2:  IORWF  xD7,F
072D4:  MOVFF  9D7,9DC
072D8:  MOVFF  9D6,9DB
072DC:  MOVLB  0
072DE:  RCALL  6F46
072E0:  MOVF   01,F
072E2:  BZ    72FC
072E4:  MOVFF  9D5,A17
072E8:  MOVFF  9D4,A16
072EC:  MOVFF  9D3,A15
072F0:  MOVFF  9D2,A14
072F4:  CALL   5A82
072F8:  MOVF   01,F
072FA:  BNZ   7306
....................                return (FR_RW_ERROR); 
072FC:  MOVLW  07
072FE:  MOVWF  01
07300:  MOVLB  9
07302:  BRA    759C
07304:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
07306:  MOVLW  14
07308:  MOVLB  9
0730A:  ADDWF  xC4,W
0730C:  MOVWF  01
0730E:  MOVLW  00
07310:  ADDWFC xC5,W
07312:  MOVFF  01,FE9
07316:  MOVWF  FEA
07318:  CLRF   FEC
0731A:  MOVF   FED,F
0731C:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
0731E:  MOVLW  1A
07320:  ADDWF  xC4,W
07322:  MOVWF  01
07324:  MOVLW  00
07326:  ADDWFC xC5,W
07328:  MOVFF  01,FE9
0732C:  MOVWF  FEA
0732E:  CLRF   FEC
07330:  MOVF   FED,F
07332:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
07334:  MOVLW  1C
07336:  ADDWF  xC4,W
07338:  MOVWF  01
0733A:  MOVLW  00
0733C:  ADDWFC xC5,W
0733E:  MOVFF  01,FE9
07342:  MOVWF  FEA
07344:  MOVF   FEE,F
07346:  MOVF   FEE,F
07348:  CLRF   FEC
0734A:  MOVF   FED,F
0734C:  CLRF   FEF
0734E:  MOVF   FED,F
07350:  CLRF   FEF
07352:  MOVF   FED,F
07354:  CLRF   FEF
07356:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
07358:  MOVLB  9
0735A:  BTFSS  xB4.3
0735C:  BRA    73DC
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
0735E:  MOVLW  0B
07360:  ADDWF  xC4,W
07362:  MOVWF  01
07364:  MOVLW  00
07366:  ADDWFC xC5,W
07368:  MOVFF  01,FE9
0736C:  MOVWF  FEA
0736E:  MOVLW  20
07370:  MOVWF  FEF
....................          dw = get_fattime(); 
07372:  MOVLB  0
07374:  RCALL  6FE8
07376:  MOVFF  03,9D5
0737A:  MOVFF  02,9D4
0737E:  MOVFF  01,9D3
07382:  MOVFF  00,9D2
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
07386:  MOVLW  0E
07388:  MOVLB  9
0738A:  ADDWF  xC4,W
0738C:  MOVWF  01
0738E:  MOVLW  00
07390:  ADDWFC xC5,W
07392:  MOVFF  01,FE9
07396:  MOVWF  FEA
07398:  MOVFF  9D2,FEF
0739C:  MOVFF  9D3,FEC
073A0:  MOVFF  9D4,FEC
073A4:  MOVFF  9D5,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
073A8:  MOVLW  16
073AA:  ADDWF  xC4,W
073AC:  MOVWF  01
073AE:  MOVLW  00
073B0:  ADDWFC xC5,W
073B2:  MOVFF  01,FE9
073B6:  MOVWF  FEA
073B8:  MOVFF  9D2,FEF
073BC:  MOVFF  9D3,FEC
073C0:  MOVFF  9D4,FEC
073C4:  MOVFF  9D5,FEC
....................          fs->winflag = 1; 
073C8:  MOVLW  06
073CA:  MOVLB  7
073CC:  ADDWF  x12,W
073CE:  MOVWF  FE9
073D0:  MOVLW  00
073D2:  ADDWFC x13,W
073D4:  MOVWF  FEA
073D6:  MOVLW  01
073D8:  MOVWF  FEF
073DA:  MOVLB  9
....................       } 
....................    } 
073DC:  BRA    742C
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
073DE:  MOVF   xC3,F
073E0:  BZ    73E8
....................          return (result);      // Trace failed  
073E2:  MOVFF  9C3,01
073E6:  BRA    759C
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
073E8:  MOVF   xC4,F
073EA:  BNZ   73F0
073EC:  MOVF   xC5,F
073EE:  BZ    7406
073F0:  MOVLW  0B
073F2:  ADDWF  xC4,W
073F4:  MOVWF  01
073F6:  MOVLW  00
073F8:  ADDWFC xC5,W
073FA:  MOVWF  03
073FC:  MOVFF  01,FE9
07400:  MOVWF  FEA
07402:  BTFSS  FEF.4
07404:  BRA    740C
....................          return (FR_NO_FILE); 
07406:  MOVLW  02
07408:  MOVWF  01
0740A:  BRA    759C
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
0740C:  BTFSS  xB4.1
0740E:  BRA    742C
07410:  MOVLW  0B
07412:  ADDWF  xC4,W
07414:  MOVWF  01
07416:  MOVLW  00
07418:  ADDWFC xC5,W
0741A:  MOVWF  03
0741C:  MOVFF  01,FE9
07420:  MOVWF  FEA
07422:  BTFSS  FEF.0
07424:  BRA    742C
....................          return (FR_DENIED); 
07426:  MOVLW  05
07428:  MOVWF  01
0742A:  BRA    759C
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
0742C:  MOVLW  1A
0742E:  ADDWF  xB0,W
07430:  MOVWF  FE9
07432:  MOVLW  00
07434:  ADDWFC xB1,W
07436:  MOVWF  FEA
07438:  MOVF   xB4,W
0743A:  ANDLW  03
0743C:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
0743E:  MOVLW  14
07440:  ADDWF  xB0,W
07442:  MOVWF  01
07444:  MOVLW  00
07446:  ADDWFC xB1,W
07448:  MOVWF  03
0744A:  MOVFF  01,9D6
0744E:  MOVWF  xD7
07450:  MOVLW  20
07452:  MOVLB  7
07454:  ADDWF  x12,W
07456:  MOVWF  FE9
07458:  MOVLW  00
0745A:  ADDWFC x13,W
0745C:  MOVWF  FEA
0745E:  MOVFF  FEF,00
07462:  MOVFF  FEC,01
07466:  MOVFF  FEC,02
0746A:  MOVFF  FEC,03
0746E:  MOVFF  9D7,FEA
07472:  MOVFF  9D6,FE9
07476:  MOVFF  00,FEF
0747A:  MOVFF  01,FEC
0747E:  MOVFF  02,FEC
07482:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
07486:  MOVLW  18
07488:  MOVLB  9
0748A:  ADDWF  xB0,W
0748C:  MOVWF  FE9
0748E:  MOVLW  00
07490:  ADDWFC xB1,W
07492:  MOVWF  FEA
07494:  MOVFF  9C5,FEC
07498:  MOVF   FED,F
0749A:  MOVFF  9C4,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
0749E:  MOVLW  08
074A0:  ADDWF  xB0,W
074A2:  MOVWF  01
074A4:  MOVLW  00
074A6:  ADDWFC xB1,W
074A8:  MOVWF  03
074AA:  MOVFF  01,9D6
074AE:  MOVWF  xD7
074B0:  MOVLW  14
074B2:  ADDWF  xC4,W
074B4:  MOVWF  01
074B6:  MOVLW  00
074B8:  ADDWFC xC5,W
074BA:  MOVWF  03
074BC:  MOVFF  01,FE9
074C0:  MOVWF  FEA
074C2:  MOVFF  FEC,9DB
074C6:  MOVF   FED,F
074C8:  MOVFF  FEF,9D8
074CC:  CLRF   xDA
074CE:  MOVFF  9D8,9DA
074D2:  CLRF   xD8
074D4:  CLRF   xD9
074D6:  MOVLW  1A
074D8:  ADDWF  xC4,W
074DA:  MOVWF  01
074DC:  MOVLW  00
074DE:  ADDWFC xC5,W
074E0:  MOVFF  01,FE9
074E4:  MOVWF  FEA
074E6:  MOVFF  FEC,03
074EA:  MOVF   FED,F
074EC:  MOVF   FEF,W
074EE:  IORWF  xD8,W
074F0:  MOVWF  00
074F2:  MOVF   03,W
074F4:  IORWF  xD9,W
074F6:  MOVFF  9DA,02
074FA:  MOVFF  9DB,03
074FE:  MOVFF  9D7,FEA
07502:  MOVFF  9D6,FE9
07506:  MOVFF  00,FEF
0750A:  MOVWF  FEC
0750C:  MOVFF  9DA,FEC
07510:  MOVFF  9DB,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
07514:  MOVLW  04
07516:  ADDWF  xB0,W
07518:  MOVWF  01
0751A:  MOVLW  00
0751C:  ADDWFC xB1,W
0751E:  MOVWF  03
07520:  MOVFF  01,9D6
07524:  MOVWF  xD7
07526:  MOVLW  1C
07528:  ADDWF  xC4,W
0752A:  MOVWF  01
0752C:  MOVLW  00
0752E:  ADDWFC xC5,W
07530:  MOVFF  01,FE9
07534:  MOVWF  FEA
07536:  MOVFF  FEF,00
0753A:  MOVFF  FEC,01
0753E:  MOVFF  FEC,02
07542:  MOVFF  FEC,03
07546:  MOVFF  9D7,FEA
0754A:  MOVFF  9D6,FE9
0754E:  MOVFF  00,FEF
07552:  MOVFF  01,FEC
07556:  MOVFF  02,FEC
0755A:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
0755E:  MOVFF  9B0,FE9
07562:  MOVFF  9B1,FEA
07566:  MOVF   FEE,F
07568:  MOVF   FEE,F
0756A:  CLRF   FEC
0756C:  MOVF   FED,F
0756E:  CLRF   FEF
07570:  MOVF   FED,F
07572:  CLRF   FEF
07574:  MOVF   FED,F
07576:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
07578:  MOVLW  1B
0757A:  ADDWF  xB0,W
0757C:  MOVWF  FE9
0757E:  MOVLW  00
07580:  ADDWFC xB1,W
07582:  MOVWF  FEA
07584:  MOVLW  01
07586:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
07588:  MOVLB  7
0758A:  ADDWF  x12,W
0758C:  MOVWF  FE9
0758E:  MOVLW  00
07590:  ADDWFC x13,W
07592:  MOVWF  FEA
07594:  INCF   FEF,F
....................    return (FR_OK); 
07596:  MOVLW  00
07598:  MOVWF  01
0759A:  MOVLB  9
0759C:  MOVLB  0
0759E:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B42C:  MOVFF  8CF,8E4
0B430:  MOVFF  8CE,8E3
....................       *br = 0; 
0B434:  MOVLB  8
0B436:  MOVFF  8D2,FE9
0B43A:  MOVFF  8D3,FEA
0B43E:  CLRF   FEC
0B440:  MOVF   FED,F
0B442:  CLRF   FEF
....................       if (!fs)  
0B444:  MOVLB  7
0B446:  MOVF   x12,W
0B448:  IORWF  x13,W
0B44A:  BNZ   B452
....................          return (FR_NOT_ENABLED); 
0B44C:  MOVLW  0B
0B44E:  MOVWF  01
0B450:  BRA    B934
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B452:  MOVLB  0
0B454:  CALL   559E
0B458:  BTFSC  01.0
0B45A:  BRA    B46C
0B45C:  MOVLB  7
0B45E:  MOVFF  712,FE9
0B462:  MOVFF  713,FEA
0B466:  MOVF   FEF,F
0B468:  BNZ   B474
0B46A:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B46C:  MOVLW  01
0B46E:  MOVWF  01
0B470:  MOVLB  7
0B472:  BRA    B934
....................     
....................       if (fp->flag & FA__ERROR) 
0B474:  MOVLW  1A
0B476:  MOVLB  8
0B478:  ADDWF  xCC,W
0B47A:  MOVWF  FE9
0B47C:  MOVLW  00
0B47E:  ADDWFC xCD,W
0B480:  MOVWF  FEA
0B482:  BTFSS  FEF.7
0B484:  BRA    B490
....................          return (FR_RW_ERROR);   // Check error flag  
0B486:  MOVLW  07
0B488:  MOVWF  01
0B48A:  MOVLB  7
0B48C:  BRA    B934
0B48E:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B490:  MOVLW  1A
0B492:  ADDWF  xCC,W
0B494:  MOVWF  FE9
0B496:  MOVLW  00
0B498:  ADDWFC xCD,W
0B49A:  MOVWF  FEA
0B49C:  BTFSC  FEF.0
0B49E:  BRA    B4AA
....................          return (FR_DENIED);      // Check access mode  
0B4A0:  MOVLW  05
0B4A2:  MOVWF  01
0B4A4:  MOVLB  7
0B4A6:  BRA    B934
0B4A8:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B4AA:  MOVLW  04
0B4AC:  ADDWF  xCC,W
0B4AE:  MOVWF  FE9
0B4B0:  MOVLW  00
0B4B2:  ADDWFC xCD,W
0B4B4:  MOVWF  FEA
0B4B6:  MOVFF  FEF,8E5
0B4BA:  MOVFF  FEC,8E6
0B4BE:  MOVFF  FEC,8E7
0B4C2:  MOVFF  FEC,8E8
0B4C6:  MOVFF  8CC,FE9
0B4CA:  MOVFF  8CD,FEA
0B4CE:  MOVFF  FEF,00
0B4D2:  MOVFF  FEC,01
0B4D6:  MOVFF  FEC,02
0B4DA:  MOVFF  FEC,03
0B4DE:  MOVF   00,W
0B4E0:  SUBWF  xE5,W
0B4E2:  MOVWF  xDC
0B4E4:  MOVF   01,W
0B4E6:  SUBWFB xE6,W
0B4E8:  MOVWF  xDD
0B4EA:  MOVF   02,W
0B4EC:  SUBWFB xE7,W
0B4EE:  MOVWF  xDE
0B4F0:  MOVF   03,W
0B4F2:  SUBWFB xE8,W
0B4F4:  MOVWF  xDF
....................       if (btr > ln) 
0B4F6:  MOVF   xDF,F
0B4F8:  BNZ   B514
0B4FA:  MOVF   xDE,F
0B4FC:  BNZ   B514
0B4FE:  MOVF   xDD,W
0B500:  SUBWF  xD1,W
0B502:  BNC   B514
0B504:  BNZ   B50C
0B506:  MOVF   xD0,W
0B508:  SUBWF  xDC,W
0B50A:  BC    B514
....................          btr = ln;            // Truncate read count by number of bytes left  
0B50C:  MOVFF  8DD,8D1
0B510:  MOVFF  8DC,8D0
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B514:  MOVF   xD0,W
0B516:  IORWF  xD1,W
0B518:  BTFSC  FD8.2
0B51A:  BRA    B912
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B51C:  MOVFF  8CC,FE9
0B520:  MOVFF  8CD,FEA
0B524:  MOVFF  FEF,8E5
0B528:  MOVFF  FEC,8E6
0B52C:  MOVFF  FEC,8E7
0B530:  MOVFF  FEC,8E8
0B534:  MOVLW  01
0B536:  ANDWF  xE6,F
0B538:  CLRF   xE7
0B53A:  CLRF   xE8
0B53C:  MOVF   xE5,F
0B53E:  BTFSS  FD8.2
0B540:  BRA    B7BA
0B542:  MOVF   xE6,F
0B544:  BTFSS  FD8.2
0B546:  BRA    B7BA
0B548:  MOVF   xE7,F
0B54A:  BTFSS  FD8.2
0B54C:  BRA    B7BA
0B54E:  MOVF   xE8,F
0B550:  BTFSS  FD8.2
0B552:  BRA    B7BA
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B554:  MOVLW  1B
0B556:  ADDWF  xCC,W
0B558:  MOVWF  FE9
0B55A:  MOVLW  00
0B55C:  ADDWFC xCD,W
0B55E:  MOVWF  FEA
0B560:  DECF   FEF,F
0B562:  BZ    B59A
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B564:  MOVLW  10
0B566:  ADDWF  xCC,W
0B568:  MOVWF  FE9
0B56A:  MOVLW  00
0B56C:  ADDWFC xCD,W
0B56E:  MOVWF  FEA
0B570:  MOVFF  FEF,8E5
0B574:  MOVFF  FEC,8E6
0B578:  MOVFF  FEC,8E7
0B57C:  MOVFF  FEC,8E8
0B580:  MOVLW  01
0B582:  ADDWF  xE5,W
0B584:  MOVWF  xD8
0B586:  MOVLW  00
0B588:  ADDWFC xE6,W
0B58A:  MOVWF  xD9
0B58C:  MOVLW  00
0B58E:  ADDWFC xE7,W
0B590:  MOVWF  xDA
0B592:  MOVLW  00
0B594:  ADDWFC xE8,W
0B596:  MOVWF  xDB
....................                }  
0B598:  BRA    B6D6
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B59A:  MOVFF  8CC,FE9
0B59E:  MOVFF  8CD,FEA
0B5A2:  MOVFF  FEF,8E5
0B5A6:  MOVFF  FEC,8E6
0B5AA:  MOVFF  FEC,8E7
0B5AE:  MOVFF  FEC,8E8
0B5B2:  MOVF   xE5,F
0B5B4:  BNZ   B5E0
0B5B6:  MOVF   xE6,F
0B5B8:  BNZ   B5E0
0B5BA:  MOVF   xE7,F
0B5BC:  BNZ   B5E0
0B5BE:  MOVF   xE8,F
0B5C0:  BNZ   B5E0
0B5C2:  MOVLW  08
0B5C4:  ADDWF  xCC,W
0B5C6:  MOVWF  FE9
0B5C8:  MOVLW  00
0B5CA:  ADDWFC xCD,W
0B5CC:  MOVWF  FEA
0B5CE:  MOVFF  FEF,00
0B5D2:  MOVFF  FEC,01
0B5D6:  MOVFF  FEC,02
0B5DA:  MOVFF  FEC,03
0B5DE:  BRA    B604
0B5E0:  MOVLW  0C
0B5E2:  ADDWF  xCC,W
0B5E4:  MOVWF  FE9
0B5E6:  MOVLW  00
0B5E8:  ADDWFC xCD,W
0B5EA:  MOVWF  FEA
0B5EC:  MOVFF  FEF,9FC
0B5F0:  MOVFF  FEC,9FD
0B5F4:  MOVFF  FEC,9FE
0B5F8:  MOVFF  FEC,9FF
0B5FC:  MOVLB  0
0B5FE:  CALL   5CBA
0B602:  MOVLB  8
0B604:  MOVFF  03,8D7
0B608:  MOVFF  02,8D6
0B60C:  MOVFF  01,8D5
0B610:  MOVFF  00,8D4
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B614:  MOVF   xD7,F
0B616:  BNZ   B626
0B618:  MOVF   xD6,F
0B61A:  BNZ   B626
0B61C:  MOVF   xD5,F
0B61E:  BNZ   B626
0B620:  MOVF   xD4,W
0B622:  SUBLW  01
0B624:  BC    B664
0B626:  MOVLW  0C
0B628:  MOVLB  7
0B62A:  ADDWF  x12,W
0B62C:  MOVWF  FE9
0B62E:  MOVLW  00
0B630:  ADDWFC x13,W
0B632:  MOVWF  FEA
0B634:  MOVFF  FEF,00
0B638:  MOVFF  FEC,01
0B63C:  MOVFF  FEC,02
0B640:  MOVFF  FEC,03
0B644:  MOVF   03,W
0B646:  MOVLB  8
0B648:  SUBWF  xD7,W
0B64A:  BNC   B666
0B64C:  BNZ   B664
0B64E:  MOVF   02,W
0B650:  SUBWF  xD6,W
0B652:  BNC   B666
0B654:  BNZ   B664
0B656:  MOVF   01,W
0B658:  SUBWF  xD5,W
0B65A:  BNC   B666
0B65C:  BNZ   B664
0B65E:  MOVF   00,W
0B660:  SUBWF  xD4,W
0B662:  BNC   B666
....................                   goto fr_error; 
0B664:  BRA    B91C
....................                fp->curr_clust = clust;            // Current cluster  
0B666:  MOVLW  0C
0B668:  ADDWF  xCC,W
0B66A:  MOVWF  FE9
0B66C:  MOVLW  00
0B66E:  ADDWFC xCD,W
0B670:  MOVWF  FEA
0B672:  MOVFF  8D4,FEF
0B676:  MOVFF  8D5,FEC
0B67A:  MOVFF  8D6,FEC
0B67E:  MOVFF  8D7,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B682:  MOVFF  8D7,9F2
0B686:  MOVFF  8D6,9F1
0B68A:  MOVFF  8D5,9F0
0B68E:  MOVFF  8D4,9EF
0B692:  MOVLB  0
0B694:  CALL   560E
0B698:  MOVFF  03,8DB
0B69C:  MOVFF  02,8DA
0B6A0:  MOVFF  01,8D9
0B6A4:  MOVFF  00,8D8
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B6A8:  MOVLW  1B
0B6AA:  MOVLB  8
0B6AC:  ADDWF  xCC,W
0B6AE:  MOVWF  01
0B6B0:  MOVLW  00
0B6B2:  ADDWFC xCD,W
0B6B4:  MOVWF  03
0B6B6:  MOVLW  02
0B6B8:  MOVLB  7
0B6BA:  ADDWF  x12,W
0B6BC:  MOVWF  FE9
0B6BE:  MOVLW  00
0B6C0:  ADDWFC x13,W
0B6C2:  MOVWF  FEA
0B6C4:  MOVFF  FEF,8E7
0B6C8:  MOVLB  8
0B6CA:  MOVFF  03,FEA
0B6CE:  MOVFF  01,FE9
0B6D2:  MOVFF  8E7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B6D6:  MOVLW  10
0B6D8:  ADDWF  xCC,W
0B6DA:  MOVWF  FE9
0B6DC:  MOVLW  00
0B6DE:  ADDWFC xCD,W
0B6E0:  MOVWF  FEA
0B6E2:  MOVFF  8D8,FEF
0B6E6:  MOVFF  8D9,FEC
0B6EA:  MOVFF  8DA,FEC
0B6EE:  MOVFF  8DB,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B6F2:  BCF    FD8.0
0B6F4:  RRCF   xD1,W
0B6F6:  MOVWF  xE2
....................             if (cc)  
0B6F8:  MOVF   xE2,F
0B6FA:  BZ    B7BA
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B6FC:  MOVLW  1B
0B6FE:  ADDWF  xCC,W
0B700:  MOVWF  FE9
0B702:  MOVLW  00
0B704:  ADDWFC xCD,W
0B706:  MOVWF  FEA
0B708:  MOVF   FEF,W
0B70A:  SUBWF  xE2,W
0B70C:  BZ    B720
0B70E:  BNC   B720
....................                   cc = fp->sect_clust; 
0B710:  MOVLW  1B
0B712:  ADDWF  xCC,W
0B714:  MOVWF  FE9
0B716:  MOVLW  00
0B718:  ADDWFC xCD,W
0B71A:  MOVWF  FEA
0B71C:  MOVFF  FEF,8E2
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B720:  MOVFF  8E4,A21
0B724:  MOVFF  8E3,A20
0B728:  MOVFF  8DB,A25
0B72C:  MOVFF  8DA,A24
0B730:  MOVFF  8D9,A23
0B734:  MOVFF  8D8,A22
0B738:  MOVFF  8E2,A26
0B73C:  MOVLB  0
0B73E:  CALL   44CC
0B742:  MOVF   01,F
0B744:  BZ    B74C
....................                   goto fr_error; 
0B746:  MOVLB  8
0B748:  BRA    B91C
0B74A:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B74C:  MOVLW  1B
0B74E:  MOVLB  8
0B750:  ADDWF  xCC,W
0B752:  MOVWF  FE9
0B754:  MOVLW  00
0B756:  ADDWFC xCD,W
0B758:  MOVWF  FEA
0B75A:  MOVLW  01
0B75C:  SUBWF  xE2,W
0B75E:  SUBWF  FEF,W
0B760:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B762:  MOVLW  10
0B764:  ADDWF  xCC,W
0B766:  MOVWF  FE9
0B768:  MOVLW  00
0B76A:  ADDWFC xCD,W
0B76C:  MOVWF  FEA
0B76E:  MOVLW  01
0B770:  SUBWF  xE2,W
0B772:  ADDWF  FEF,W
0B774:  MOVWF  00
0B776:  MOVLW  00
0B778:  ADDWFC FEC,W
0B77A:  MOVWF  01
0B77C:  MOVLW  00
0B77E:  ADDWFC FEC,W
0B780:  MOVWF  02
0B782:  MOVLW  00
0B784:  ADDWFC FEC,W
0B786:  MOVF   FED,F
0B788:  MOVF   FED,F
0B78A:  MOVF   FED,F
0B78C:  MOVFF  00,FEF
0B790:  MOVFF  01,FEC
0B794:  MOVFF  02,FEC
0B798:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B79A:  MOVLB  A
0B79C:  CLRF   x11
0B79E:  MOVFF  8E2,A10
0B7A2:  MOVLW  02
0B7A4:  MOVWF  x13
0B7A6:  CLRF   x12
0B7A8:  MOVLB  0
0B7AA:  CALL   5C98
0B7AE:  MOVFF  02,8E1
0B7B2:  MOVFF  01,8E0
....................                continue; 
0B7B6:  BRA    B8AE
0B7B8:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B7BA:  MOVLW  10
0B7BC:  ADDWF  xCC,W
0B7BE:  MOVWF  FE9
0B7C0:  MOVLW  00
0B7C2:  ADDWFC xCD,W
0B7C4:  MOVWF  FEA
0B7C6:  MOVFF  FEF,A14
0B7CA:  MOVFF  FEC,A15
0B7CE:  MOVFF  FEC,A16
0B7D2:  MOVFF  FEC,A17
0B7D6:  MOVLB  0
0B7D8:  CALL   5A82
0B7DC:  MOVF   01,F
0B7DE:  BNZ   B7E6
....................                goto fr_error; 
0B7E0:  MOVLB  8
0B7E2:  BRA    B91C
0B7E4:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B7E6:  MOVLB  8
0B7E8:  MOVFF  8CC,FE9
0B7EC:  MOVFF  8CD,FEA
0B7F0:  MOVFF  FEF,8E5
0B7F4:  MOVFF  FEC,8E6
0B7F8:  MOVFF  FEC,8E7
0B7FC:  MOVFF  FEC,8E8
0B800:  MOVF   xE6,W
0B802:  ANDLW  01
0B804:  MOVWF  01
0B806:  MOVLW  00
0B808:  BSF    FD8.0
0B80A:  SUBFWB xE5,W
0B80C:  MOVWF  xE0
0B80E:  MOVLW  02
0B810:  SUBFWB 01,W
0B812:  MOVWF  xE1
....................          if (rcnt > btr) 
0B814:  MOVF   xD1,W
0B816:  SUBWF  xE1,W
0B818:  BNC   B82A
0B81A:  BNZ   B822
0B81C:  MOVF   xE0,W
0B81E:  SUBWF  xD0,W
0B820:  BC    B82A
....................             rcnt = btr; 
0B822:  MOVFF  8D1,8E1
0B826:  MOVFF  8D0,8E0
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B82A:  MOVFF  8CC,FE9
0B82E:  MOVFF  8CD,FEA
0B832:  MOVFF  FEF,8E5
0B836:  MOVFF  FEC,8E6
0B83A:  MOVFF  FEC,8E7
0B83E:  MOVFF  FEC,8E8
0B842:  MOVLW  01
0B844:  ANDWF  xE6,F
0B846:  CLRF   xE7
0B848:  CLRF   xE8
0B84A:  MOVLW  24
0B84C:  ADDWF  xE5,W
0B84E:  MOVWF  00
0B850:  MOVLW  00
0B852:  ADDWFC xE6,W
0B854:  MOVWF  01
0B856:  MOVLW  00
0B858:  ADDWFC xE7,W
0B85A:  MOVWF  02
0B85C:  MOVLW  00
0B85E:  ADDWFC xE8,W
0B860:  MOVWF  03
0B862:  MOVFF  01,03
0B866:  MOVF   00,W
0B868:  MOVLB  7
0B86A:  ADDWF  x12,W
0B86C:  MOVWF  01
0B86E:  MOVF   x13,W
0B870:  ADDWFC 03,F
0B872:  MOVFF  01,8E9
0B876:  MOVLB  8
0B878:  MOVFF  03,8EA
0B87C:  MOVFF  8E4,FEA
0B880:  MOVFF  8E3,FE9
0B884:  MOVFF  03,FE2
0B888:  MOVFF  01,FE1
0B88C:  MOVFF  8E1,02
0B890:  MOVFF  8E0,01
0B894:  MOVF   01,F
0B896:  BZ    B89C
0B898:  INCF   02,F
0B89A:  BRA    B8A0
0B89C:  MOVF   02,F
0B89E:  BZ    B8AC
0B8A0:  MOVFF  FE6,FEE
0B8A4:  DECFSZ 01,F
0B8A6:  BRA    B8A0
0B8A8:  DECFSZ 02,F
0B8AA:  BRA    B8A0
0B8AC:  MOVLB  0
0B8AE:  MOVLB  8
0B8B0:  MOVF   xE0,W
0B8B2:  ADDWF  xE3,F
0B8B4:  MOVF   xE1,W
0B8B6:  ADDWFC xE4,F
0B8B8:  MOVFF  8CC,FE9
0B8BC:  MOVFF  8CD,FEA
0B8C0:  MOVF   xE0,W
0B8C2:  ADDWF  FEF,W
0B8C4:  MOVWF  00
0B8C6:  MOVF   xE1,W
0B8C8:  ADDWFC FEC,W
0B8CA:  MOVWF  01
0B8CC:  MOVLW  00
0B8CE:  ADDWFC FEC,W
0B8D0:  MOVWF  02
0B8D2:  MOVLW  00
0B8D4:  ADDWFC FEC,W
0B8D6:  MOVWF  03
0B8D8:  MOVF   FED,F
0B8DA:  MOVF   FED,F
0B8DC:  MOVF   FED,F
0B8DE:  MOVFF  00,FEF
0B8E2:  MOVFF  01,FEC
0B8E6:  MOVFF  02,FEC
0B8EA:  MOVWF  FEC
0B8EC:  MOVFF  8D2,FE9
0B8F0:  MOVFF  8D3,FEA
0B8F4:  MOVF   xE0,W
0B8F6:  ADDWF  FEF,W
0B8F8:  MOVWF  01
0B8FA:  MOVF   xE1,W
0B8FC:  ADDWFC FEC,W
0B8FE:  MOVWF  03
0B900:  MOVF   FED,F
0B902:  MOVFF  01,FEF
0B906:  MOVWF  FEC
0B908:  MOVF   xE0,W
0B90A:  SUBWF  xD0,F
0B90C:  MOVF   xE1,W
0B90E:  SUBWFB xD1,F
0B910:  BRA    B514
....................          } 
....................       return (FR_OK); 
0B912:  MOVLW  00
0B914:  MOVWF  01
0B916:  MOVLB  7
0B918:  BRA    B934
0B91A:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B91C:  MOVLW  1A
0B91E:  ADDWF  xCC,W
0B920:  MOVWF  FE9
0B922:  MOVLW  00
0B924:  ADDWFC xCD,W
0B926:  MOVWF  FEA
0B928:  MOVF   FEF,W
0B92A:  IORLW  80
0B92C:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B92E:  MOVLW  07
0B930:  MOVWF  01
0B932:  MOVLB  7
0B934:  MOVLB  0
0B936:  GOTO   BB32 (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
079FA:  MOVFF  9B3,9C4
079FE:  MOVFF  9B2,9C3
....................       *bw = 0; 
07A02:  MOVLB  9
07A04:  MOVFF  9B6,FE9
07A08:  MOVFF  9B7,FEA
07A0C:  CLRF   FEC
07A0E:  MOVF   FED,F
07A10:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07A12:  CLRF   xC1
07A14:  CLRF   xC0
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07A16:  MOVLB  7
07A18:  MOVF   x12,W
07A1A:  IORWF  x13,W
07A1C:  BNZ   7A24
....................          return (FR_NOT_ENABLED); 
07A1E:  MOVLW  0B
07A20:  MOVWF  01
07A22:  BRA    80C4
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07A24:  MOVLB  0
07A26:  CALL   559E
07A2A:  BTFSC  01.0
07A2C:  BRA    7A3E
07A2E:  MOVLB  7
07A30:  MOVFF  712,FE9
07A34:  MOVFF  713,FEA
07A38:  MOVF   FEF,F
07A3A:  BNZ   7A46
07A3C:  MOVLB  0
....................          return (FR_NOT_READY); 
07A3E:  MOVLW  01
07A40:  MOVWF  01
07A42:  MOVLB  7
07A44:  BRA    80C4
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
07A46:  MOVLW  1A
07A48:  MOVLB  9
07A4A:  ADDWF  xB0,W
07A4C:  MOVWF  FE9
07A4E:  MOVLW  00
07A50:  ADDWFC xB1,W
07A52:  MOVWF  FEA
07A54:  BTFSS  FEF.7
07A56:  BRA    7A62
....................          return (FR_RW_ERROR);         // Check error flag  
07A58:  MOVLW  07
07A5A:  MOVWF  01
07A5C:  MOVLB  7
07A5E:  BRA    80C4
07A60:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
07A62:  MOVLW  1A
07A64:  ADDWF  xB0,W
07A66:  MOVWF  FE9
07A68:  MOVLW  00
07A6A:  ADDWFC xB1,W
07A6C:  MOVWF  FEA
07A6E:  BTFSC  FEF.1
07A70:  BRA    7A7C
....................          return (FR_DENIED);            // Check access mode  
07A72:  MOVLW  05
07A74:  MOVWF  01
07A76:  MOVLB  7
07A78:  BRA    80C4
07A7A:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
07A7C:  MOVLW  04
07A7E:  ADDWF  xB0,W
07A80:  MOVWF  FE9
07A82:  MOVLW  00
07A84:  ADDWFC xB1,W
07A86:  MOVWF  FEA
07A88:  MOVFF  FEF,9C5
07A8C:  MOVFF  FEC,9C6
07A90:  MOVFF  FEC,9C7
07A94:  MOVFF  FEC,9C8
07A98:  MOVF   xB4,W
07A9A:  ADDWF  xC5,F
07A9C:  MOVF   xB5,W
07A9E:  ADDWFC xC6,F
07AA0:  MOVLW  00
07AA2:  ADDWFC xC7,F
07AA4:  ADDWFC xC8,F
07AA6:  MOVLW  04
07AA8:  ADDWF  xB0,W
07AAA:  MOVWF  FE9
07AAC:  MOVLW  00
07AAE:  ADDWFC xB1,W
07AB0:  MOVWF  FEA
07AB2:  MOVFF  FEF,00
07AB6:  MOVFF  FEC,01
07ABA:  MOVFF  FEC,02
07ABE:  MOVFF  FEC,03
07AC2:  MOVF   xC8,W
07AC4:  SUBWF  03,W
07AC6:  BNC   7AE4
07AC8:  BNZ   7AE0
07ACA:  MOVF   xC7,W
07ACC:  SUBWF  02,W
07ACE:  BNC   7AE4
07AD0:  BNZ   7AE0
07AD2:  MOVF   xC6,W
07AD4:  SUBWF  01,W
07AD6:  BNC   7AE4
07AD8:  BNZ   7AE0
07ADA:  MOVF   00,W
07ADC:  SUBWF  xC5,W
07ADE:  BC    7AE4
....................          btw = 0;                  // File size cannot reach 4GB  
07AE0:  CLRF   xB5
07AE2:  CLRF   xB4
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07AE4:  MOVF   xB4,W
07AE6:  IORWF  xB5,W
07AE8:  BTFSC  FD8.2
07AEA:  BRA    7FF8
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07AEC:  MOVFF  9B0,FE9
07AF0:  MOVFF  9B1,FEA
07AF4:  MOVFF  FEF,9C5
07AF8:  MOVFF  FEC,9C6
07AFC:  MOVFF  FEC,9C7
07B00:  MOVFF  FEC,9C8
07B04:  MOVLW  01
07B06:  ANDWF  xC6,F
07B08:  CLRF   xC7
07B0A:  CLRF   xC8
07B0C:  MOVF   xC5,F
07B0E:  BTFSS  FD8.2
07B10:  BRA    7E92
07B12:  MOVF   xC6,F
07B14:  BTFSS  FD8.2
07B16:  BRA    7E92
07B18:  MOVF   xC7,F
07B1A:  BTFSS  FD8.2
07B1C:  BRA    7E92
07B1E:  MOVF   xC8,F
07B20:  BTFSS  FD8.2
07B22:  BRA    7E92
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07B24:  MOVLW  1B
07B26:  ADDWF  xB0,W
07B28:  MOVWF  FE9
07B2A:  MOVLW  00
07B2C:  ADDWFC xB1,W
07B2E:  MOVWF  FEA
07B30:  DECF   FEF,F
07B32:  BZ    7B6A
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07B34:  MOVLW  10
07B36:  ADDWF  xB0,W
07B38:  MOVWF  FE9
07B3A:  MOVLW  00
07B3C:  ADDWFC xB1,W
07B3E:  MOVWF  FEA
07B40:  MOVFF  FEF,9C5
07B44:  MOVFF  FEC,9C6
07B48:  MOVFF  FEC,9C7
07B4C:  MOVFF  FEC,9C8
07B50:  MOVLW  01
07B52:  ADDWF  xC5,W
07B54:  MOVWF  xBC
07B56:  MOVLW  00
07B58:  ADDWFC xC6,W
07B5A:  MOVWF  xBD
07B5C:  MOVLW  00
07B5E:  ADDWFC xC7,W
07B60:  MOVWF  xBE
07B62:  MOVLW  00
07B64:  ADDWFC xC8,W
07B66:  MOVWF  xBF
....................                }  
07B68:  BRA    7D00
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07B6A:  MOVFF  9B0,FE9
07B6E:  MOVFF  9B1,FEA
07B72:  MOVFF  FEF,9C5
07B76:  MOVFF  FEC,9C6
07B7A:  MOVFF  FEC,9C7
07B7E:  MOVFF  FEC,9C8
07B82:  MOVF   xC5,F
07B84:  BNZ   7C0A
07B86:  MOVF   xC6,F
07B88:  BNZ   7C0A
07B8A:  MOVF   xC7,F
07B8C:  BNZ   7C0A
07B8E:  MOVF   xC8,F
07B90:  BNZ   7C0A
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07B92:  MOVLW  08
07B94:  ADDWF  xB0,W
07B96:  MOVWF  FE9
07B98:  MOVLW  00
07B9A:  ADDWFC xB1,W
07B9C:  MOVWF  FEA
07B9E:  MOVFF  FEF,9B8
07BA2:  MOVFF  FEC,9B9
07BA6:  MOVFF  FEC,9BA
07BAA:  MOVFF  FEC,9BB
....................                   if (clust == 0)            // No cluster is created  
07BAE:  MOVF   xB8,F
07BB0:  BNZ   7C08
07BB2:  MOVF   xB9,F
07BB4:  BNZ   7C08
07BB6:  MOVF   xBA,F
07BB8:  BNZ   7C08
07BBA:  MOVF   xBB,F
07BBC:  BNZ   7C08
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07BBE:  MOVLW  08
07BC0:  ADDWF  xB0,W
07BC2:  MOVWF  01
07BC4:  MOVLW  00
07BC6:  ADDWFC xB1,W
07BC8:  MOVWF  03
07BCA:  MOVFF  01,9C5
07BCE:  MOVWF  xC6
07BD0:  CLRF   xEB
07BD2:  CLRF   xEA
07BD4:  CLRF   xE9
07BD6:  CLRF   xE8
07BD8:  MOVLB  0
07BDA:  CALL   6964
07BDE:  MOVFF  03,9BB
07BE2:  MOVFF  02,9BA
07BE6:  MOVFF  01,9B9
07BEA:  MOVFF  00,9B8
07BEE:  MOVFF  9C6,FEA
07BF2:  MOVFF  9C5,FE9
07BF6:  MOVFF  9B8,FEF
07BFA:  MOVFF  9B9,FEC
07BFE:  MOVFF  9BA,FEC
07C02:  MOVFF  9BB,FEC
07C06:  MOVLB  9
....................                   } 
07C08:  BRA    7C3E
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07C0A:  MOVLW  0C
07C0C:  ADDWF  xB0,W
07C0E:  MOVWF  FE9
07C10:  MOVLW  00
07C12:  ADDWFC xB1,W
07C14:  MOVWF  FEA
07C16:  MOVFF  FEF,9E8
07C1A:  MOVFF  FEC,9E9
07C1E:  MOVFF  FEC,9EA
07C22:  MOVFF  FEC,9EB
07C26:  MOVLB  0
07C28:  CALL   6964
07C2C:  MOVFF  03,9BB
07C30:  MOVFF  02,9BA
07C34:  MOVFF  01,9B9
07C38:  MOVFF  00,9B8
07C3C:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07C3E:  MOVF   xBB,F
07C40:  BNZ   7C50
07C42:  MOVF   xBA,F
07C44:  BNZ   7C50
07C46:  MOVF   xB9,F
07C48:  BNZ   7C50
07C4A:  MOVF   xB8,W
07C4C:  SUBLW  01
07C4E:  BC    7C8E
07C50:  MOVLW  0C
07C52:  MOVLB  7
07C54:  ADDWF  x12,W
07C56:  MOVWF  FE9
07C58:  MOVLW  00
07C5A:  ADDWFC x13,W
07C5C:  MOVWF  FEA
07C5E:  MOVFF  FEF,00
07C62:  MOVFF  FEC,01
07C66:  MOVFF  FEC,02
07C6A:  MOVFF  FEC,03
07C6E:  MOVF   03,W
07C70:  MOVLB  9
07C72:  SUBWF  xBB,W
07C74:  BNC   7C90
07C76:  BNZ   7C8E
07C78:  MOVF   02,W
07C7A:  SUBWF  xBA,W
07C7C:  BNC   7C90
07C7E:  BNZ   7C8E
07C80:  MOVF   01,W
07C82:  SUBWF  xB9,W
07C84:  BNC   7C90
07C86:  BNZ   7C8E
07C88:  MOVF   00,W
07C8A:  SUBWF  xB8,W
07C8C:  BNC   7C90
....................                   break; 
07C8E:  BRA    7FF8
....................                fp->curr_clust = clust;            // Current cluster  
07C90:  MOVLW  0C
07C92:  ADDWF  xB0,W
07C94:  MOVWF  FE9
07C96:  MOVLW  00
07C98:  ADDWFC xB1,W
07C9A:  MOVWF  FEA
07C9C:  MOVFF  9B8,FEF
07CA0:  MOVFF  9B9,FEC
07CA4:  MOVFF  9BA,FEC
07CA8:  MOVFF  9BB,FEC
....................                sect = clust2sect(clust);         // Current sector  
07CAC:  MOVFF  9BB,9F2
07CB0:  MOVFF  9BA,9F1
07CB4:  MOVFF  9B9,9F0
07CB8:  MOVFF  9B8,9EF
07CBC:  MOVLB  0
07CBE:  CALL   560E
07CC2:  MOVFF  03,9BF
07CC6:  MOVFF  02,9BE
07CCA:  MOVFF  01,9BD
07CCE:  MOVFF  00,9BC
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07CD2:  MOVLW  1B
07CD4:  MOVLB  9
07CD6:  ADDWF  xB0,W
07CD8:  MOVWF  01
07CDA:  MOVLW  00
07CDC:  ADDWFC xB1,W
07CDE:  MOVWF  03
07CE0:  MOVLW  02
07CE2:  MOVLB  7
07CE4:  ADDWF  x12,W
07CE6:  MOVWF  FE9
07CE8:  MOVLW  00
07CEA:  ADDWFC x13,W
07CEC:  MOVWF  FEA
07CEE:  MOVFF  FEF,9C7
07CF2:  MOVLB  9
07CF4:  MOVFF  03,FEA
07CF8:  MOVFF  01,FE9
07CFC:  MOVFF  9C7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07D00:  MOVLW  10
07D02:  ADDWF  xB0,W
07D04:  MOVWF  FE9
07D06:  MOVLW  00
07D08:  ADDWFC xB1,W
07D0A:  MOVWF  FEA
07D0C:  MOVFF  9BC,FEF
07D10:  MOVFF  9BD,FEC
07D14:  MOVFF  9BE,FEC
07D18:  MOVFF  9BF,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07D1C:  BCF    FD8.0
07D1E:  RRCF   xB5,W
07D20:  MOVWF  xC2
....................             if (cc)  
07D22:  MOVF   xC2,F
07D24:  BZ    7DE0
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07D26:  MOVLW  1B
07D28:  ADDWF  xB0,W
07D2A:  MOVWF  FE9
07D2C:  MOVLW  00
07D2E:  ADDWFC xB1,W
07D30:  MOVWF  FEA
07D32:  MOVF   FEF,W
07D34:  SUBWF  xC2,W
07D36:  BZ    7D4A
07D38:  BNC   7D4A
....................                   cc = fp->sect_clust; 
07D3A:  MOVLW  1B
07D3C:  ADDWF  xB0,W
07D3E:  MOVWF  FE9
07D40:  MOVLW  00
07D42:  ADDWFC xB1,W
07D44:  MOVWF  FEA
07D46:  MOVFF  FEF,9C2
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07D4A:  MOVFF  9C4,A21
07D4E:  MOVFF  9C3,A20
07D52:  MOVFF  9BF,A25
07D56:  MOVFF  9BE,A24
07D5A:  MOVFF  9BD,A23
07D5E:  MOVFF  9BC,A22
07D62:  MOVFF  9C2,A26
07D66:  MOVLB  0
07D68:  CALL   593E
07D6C:  MOVF   01,F
07D6E:  BZ    7D72
....................                   goto fw_error; 
07D70:  BRA    80AA
....................                fp->sect_clust -= cc - 1; 
07D72:  MOVLW  1B
07D74:  MOVLB  9
07D76:  ADDWF  xB0,W
07D78:  MOVWF  FE9
07D7A:  MOVLW  00
07D7C:  ADDWFC xB1,W
07D7E:  MOVWF  FEA
07D80:  MOVLW  01
07D82:  SUBWF  xC2,W
07D84:  SUBWF  FEF,W
07D86:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07D88:  MOVLW  10
07D8A:  ADDWF  xB0,W
07D8C:  MOVWF  FE9
07D8E:  MOVLW  00
07D90:  ADDWFC xB1,W
07D92:  MOVWF  FEA
07D94:  MOVLW  01
07D96:  SUBWF  xC2,W
07D98:  ADDWF  FEF,W
07D9A:  MOVWF  00
07D9C:  MOVLW  00
07D9E:  ADDWFC FEC,W
07DA0:  MOVWF  01
07DA2:  MOVLW  00
07DA4:  ADDWFC FEC,W
07DA6:  MOVWF  02
07DA8:  MOVLW  00
07DAA:  ADDWFC FEC,W
07DAC:  MOVF   FED,F
07DAE:  MOVF   FED,F
07DB0:  MOVF   FED,F
07DB2:  MOVFF  00,FEF
07DB6:  MOVFF  01,FEC
07DBA:  MOVFF  02,FEC
07DBE:  MOVWF  FEC
....................                wcnt = cc * 512; 
07DC0:  MOVLB  A
07DC2:  CLRF   x11
07DC4:  MOVFF  9C2,A10
07DC8:  MOVLW  02
07DCA:  MOVWF  x13
07DCC:  CLRF   x12
07DCE:  MOVLB  0
07DD0:  CALL   5C98
07DD4:  MOVFF  02,9C1
07DD8:  MOVFF  01,9C0
....................                continue; 
07DDC:  BRA    7F94
07DDE:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07DE0:  MOVFF  9B0,FE9
07DE4:  MOVFF  9B1,FEA
07DE8:  MOVFF  FEF,9C5
07DEC:  MOVFF  FEC,9C6
07DF0:  MOVFF  FEC,9C7
07DF4:  MOVFF  FEC,9C8
07DF8:  MOVLW  04
07DFA:  ADDWF  xB0,W
07DFC:  MOVWF  FE9
07DFE:  MOVLW  00
07E00:  ADDWFC xB1,W
07E02:  MOVWF  FEA
07E04:  MOVFF  FEF,00
07E08:  MOVFF  FEC,01
07E0C:  MOVFF  FEC,02
07E10:  MOVFF  FEC,03
07E14:  MOVF   03,W
07E16:  SUBWF  xC8,W
07E18:  BNC   7E92
07E1A:  BNZ   7E32
07E1C:  MOVF   02,W
07E1E:  SUBWF  xC7,W
07E20:  BNC   7E92
07E22:  BNZ   7E32
07E24:  MOVF   01,W
07E26:  SUBWF  xC6,W
07E28:  BNC   7E92
07E2A:  BNZ   7E32
07E2C:  MOVF   00,W
07E2E:  SUBWF  xC5,W
07E30:  BNC   7E92
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07E32:  MOVLB  A
07E34:  CLRF   x17
07E36:  CLRF   x16
07E38:  CLRF   x15
07E3A:  CLRF   x14
07E3C:  MOVLB  0
07E3E:  CALL   5A82
07E42:  MOVF   01,F
07E44:  BNZ   7E48
....................                   goto fw_error; 
07E46:  BRA    80AA
....................                fs->winsect = fp->curr_sect; 
07E48:  MOVLW  20
07E4A:  MOVLB  7
07E4C:  ADDWF  x12,W
07E4E:  MOVWF  01
07E50:  MOVLW  00
07E52:  ADDWFC x13,W
07E54:  MOVWF  03
07E56:  MOVFF  01,9C5
07E5A:  MOVLB  9
07E5C:  MOVWF  xC6
07E5E:  MOVLW  10
07E60:  ADDWF  xB0,W
07E62:  MOVWF  FE9
07E64:  MOVLW  00
07E66:  ADDWFC xB1,W
07E68:  MOVWF  FEA
07E6A:  MOVFF  FEF,00
07E6E:  MOVFF  FEC,01
07E72:  MOVFF  FEC,02
07E76:  MOVFF  FEC,03
07E7A:  MOVFF  9C6,FEA
07E7E:  MOVFF  9C5,FE9
07E82:  MOVFF  00,FEF
07E86:  MOVFF  01,FEC
07E8A:  MOVFF  02,FEC
07E8E:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07E92:  MOVLW  10
07E94:  ADDWF  xB0,W
07E96:  MOVWF  FE9
07E98:  MOVLW  00
07E9A:  ADDWFC xB1,W
07E9C:  MOVWF  FEA
07E9E:  MOVFF  FEF,A14
07EA2:  MOVFF  FEC,A15
07EA6:  MOVFF  FEC,A16
07EAA:  MOVFF  FEC,A17
07EAE:  MOVLB  0
07EB0:  CALL   5A82
07EB4:  MOVF   01,F
07EB6:  BNZ   7EBA
....................             goto fw_error;               // Move sector window 
07EB8:  BRA    80AA
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07EBA:  MOVLB  9
07EBC:  MOVFF  9B0,FE9
07EC0:  MOVFF  9B1,FEA
07EC4:  MOVFF  FEF,9C5
07EC8:  MOVFF  FEC,9C6
07ECC:  MOVFF  FEC,9C7
07ED0:  MOVFF  FEC,9C8
07ED4:  MOVF   xC6,W
07ED6:  ANDLW  01
07ED8:  MOVWF  01
07EDA:  MOVLW  00
07EDC:  BSF    FD8.0
07EDE:  SUBFWB xC5,W
07EE0:  MOVWF  xC0
07EE2:  MOVLW  02
07EE4:  SUBFWB 01,W
07EE6:  MOVWF  xC1
....................          if (wcnt > btw) 
07EE8:  MOVF   xB5,W
07EEA:  SUBWF  xC1,W
07EEC:  BNC   7EFE
07EEE:  BNZ   7EF6
07EF0:  MOVF   xC0,W
07EF2:  SUBWF  xB4,W
07EF4:  BC    7EFE
....................             wcnt = btw; 
07EF6:  MOVFF  9B5,9C1
07EFA:  MOVFF  9B4,9C0
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07EFE:  MOVFF  9B0,FE9
07F02:  MOVFF  9B1,FEA
07F06:  MOVFF  FEF,9C5
07F0A:  MOVFF  FEC,9C6
07F0E:  MOVFF  FEC,9C7
07F12:  MOVFF  FEC,9C8
07F16:  MOVLW  01
07F18:  ANDWF  xC6,F
07F1A:  CLRF   xC7
07F1C:  CLRF   xC8
07F1E:  MOVLW  24
07F20:  ADDWF  xC5,W
07F22:  MOVWF  00
07F24:  MOVLW  00
07F26:  ADDWFC xC6,W
07F28:  MOVWF  01
07F2A:  MOVLW  00
07F2C:  ADDWFC xC7,W
07F2E:  MOVWF  02
07F30:  MOVLW  00
07F32:  ADDWFC xC8,W
07F34:  MOVWF  03
07F36:  MOVFF  01,03
07F3A:  MOVF   00,W
07F3C:  MOVLB  7
07F3E:  ADDWF  x12,W
07F40:  MOVWF  01
07F42:  MOVF   x13,W
07F44:  ADDWFC 03,F
07F46:  MOVFF  01,9C9
07F4A:  MOVLB  9
07F4C:  MOVFF  03,9CA
07F50:  MOVFF  03,FEA
07F54:  MOVFF  01,FE9
07F58:  MOVFF  9C4,FE2
07F5C:  MOVFF  9C3,FE1
07F60:  MOVFF  9C1,02
07F64:  MOVFF  9C0,01
07F68:  MOVF   01,F
07F6A:  BZ    7F70
07F6C:  INCF   02,F
07F6E:  BRA    7F74
07F70:  MOVF   02,F
07F72:  BZ    7F80
07F74:  MOVFF  FE6,FEE
07F78:  DECFSZ 01,F
07F7A:  BRA    7F74
07F7C:  DECFSZ 02,F
07F7E:  BRA    7F74
....................          fs->winflag = 1; 
07F80:  MOVLW  06
07F82:  MOVLB  7
07F84:  ADDWF  x12,W
07F86:  MOVWF  FE9
07F88:  MOVLW  00
07F8A:  ADDWFC x13,W
07F8C:  MOVWF  FEA
07F8E:  MOVLW  01
07F90:  MOVWF  FEF
07F92:  MOVLB  0
07F94:  MOVLB  9
07F96:  MOVF   xC0,W
07F98:  ADDWF  xC3,F
07F9A:  MOVF   xC1,W
07F9C:  ADDWFC xC4,F
07F9E:  MOVFF  9B0,FE9
07FA2:  MOVFF  9B1,FEA
07FA6:  MOVF   xC0,W
07FA8:  ADDWF  FEF,W
07FAA:  MOVWF  00
07FAC:  MOVF   xC1,W
07FAE:  ADDWFC FEC,W
07FB0:  MOVWF  01
07FB2:  MOVLW  00
07FB4:  ADDWFC FEC,W
07FB6:  MOVWF  02
07FB8:  MOVLW  00
07FBA:  ADDWFC FEC,W
07FBC:  MOVWF  03
07FBE:  MOVF   FED,F
07FC0:  MOVF   FED,F
07FC2:  MOVF   FED,F
07FC4:  MOVFF  00,FEF
07FC8:  MOVFF  01,FEC
07FCC:  MOVFF  02,FEC
07FD0:  MOVWF  FEC
07FD2:  MOVFF  9B6,FE9
07FD6:  MOVFF  9B7,FEA
07FDA:  MOVF   xC0,W
07FDC:  ADDWF  FEF,W
07FDE:  MOVWF  01
07FE0:  MOVF   xC1,W
07FE2:  ADDWFC FEC,W
07FE4:  MOVWF  03
07FE6:  MOVF   FED,F
07FE8:  MOVFF  01,FEF
07FEC:  MOVWF  FEC
07FEE:  MOVF   xC0,W
07FF0:  SUBWF  xB4,F
07FF2:  MOVF   xC1,W
07FF4:  SUBWFB xB5,F
07FF6:  BRA    7AE4
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
07FF8:  MOVFF  9B0,FE9
07FFC:  MOVFF  9B1,FEA
08000:  MOVFF  FEF,9C5
08004:  MOVFF  FEC,9C6
08008:  MOVFF  FEC,9C7
0800C:  MOVFF  FEC,9C8
08010:  MOVLW  04
08012:  ADDWF  xB0,W
08014:  MOVWF  FE9
08016:  MOVLW  00
08018:  ADDWFC xB1,W
0801A:  MOVWF  FEA
0801C:  MOVFF  FEF,00
08020:  MOVFF  FEC,01
08024:  MOVFF  FEC,02
08028:  MOVFF  FEC,03
0802C:  MOVF   03,W
0802E:  SUBWF  xC8,W
08030:  BNC   808E
08032:  BNZ   804A
08034:  MOVF   02,W
08036:  SUBWF  xC7,W
08038:  BNC   808E
0803A:  BNZ   804A
0803C:  MOVF   01,W
0803E:  SUBWF  xC6,W
08040:  BNC   808E
08042:  BNZ   804A
08044:  MOVF   xC5,W
08046:  SUBWF  00,W
08048:  BC    808E
....................          fp->fsize = fp->fptr;      // Update file size if needed  
0804A:  MOVLW  04
0804C:  ADDWF  xB0,W
0804E:  MOVWF  01
08050:  MOVLW  00
08052:  ADDWFC xB1,W
08054:  MOVWF  03
08056:  MOVFF  01,9C5
0805A:  MOVFF  03,9C6
0805E:  MOVFF  9B0,FE9
08062:  MOVFF  9B1,FEA
08066:  MOVFF  FEF,00
0806A:  MOVFF  FEC,01
0806E:  MOVFF  FEC,02
08072:  MOVFF  FEC,03
08076:  MOVFF  9C6,FEA
0807A:  MOVFF  9C5,FE9
0807E:  MOVFF  00,FEF
08082:  MOVFF  01,FEC
08086:  MOVFF  02,FEC
0808A:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
0808E:  MOVLW  1A
08090:  ADDWF  xB0,W
08092:  MOVWF  FE9
08094:  MOVLW  00
08096:  ADDWFC xB1,W
08098:  MOVWF  FEA
0809A:  MOVF   FEF,W
0809C:  IORLW  20
0809E:  MOVWF  FEF
....................       return (FR_OK); 
080A0:  MOVLW  00
080A2:  MOVWF  01
080A4:  MOVLB  7
080A6:  BRA    80C4
080A8:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
080AA:  MOVLW  1A
080AC:  MOVLB  9
080AE:  ADDWF  xB0,W
080B0:  MOVWF  FE9
080B2:  MOVLW  00
080B4:  ADDWFC xB1,W
080B6:  MOVWF  FEA
080B8:  MOVF   FEF,W
080BA:  IORLW  80
080BC:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
080BE:  MOVLW  07
080C0:  MOVWF  01
080C2:  MOVLB  7
080C4:  MOVLB  0
080C6:  GOTO   846E (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
075A0:  MOVLB  7
075A2:  MOVF   x12,W
075A4:  IORWF  x13,W
075A6:  BNZ   75AE
....................          return (FR_NOT_ENABLED); 
075A8:  MOVLW  0B
075AA:  MOVWF  01
075AC:  BRA    7902
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
075AE:  MOVLB  0
075B0:  CALL   559E
075B4:  BTFSC  01.0
075B6:  BRA    75C8
075B8:  MOVLB  7
075BA:  MOVFF  712,FE9
075BE:  MOVFF  713,FEA
075C2:  MOVF   FEF,F
075C4:  BNZ   75D0
075C6:  MOVLB  0
....................          return (FR_NOT_READY); 
075C8:  MOVLW  01
075CA:  MOVWF  01
075CC:  MOVLB  7
075CE:  BRA    7902
....................     
....................       if (fp->flag & FA__ERROR) 
075D0:  MOVLW  1A
075D2:  MOVLB  9
075D4:  ADDWF  xB0,W
075D6:  MOVWF  FE9
075D8:  MOVLW  00
075DA:  ADDWFC xB1,W
075DC:  MOVWF  FEA
075DE:  BTFSS  FEF.7
075E0:  BRA    75EC
....................          return (FR_RW_ERROR); 
075E2:  MOVLW  07
075E4:  MOVWF  01
075E6:  MOVLB  7
075E8:  BRA    7902
075EA:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
075EC:  MOVLW  04
075EE:  ADDWF  xB0,W
075F0:  MOVWF  FE9
075F2:  MOVLW  00
075F4:  ADDWFC xB1,W
075F6:  MOVWF  FEA
075F8:  MOVFF  FEF,00
075FC:  MOVFF  FEC,01
07600:  MOVFF  FEC,02
07604:  MOVFF  FEC,03
07608:  MOVF   03,W
0760A:  SUBWF  xB5,W
0760C:  BNC   7642
0760E:  BNZ   7626
07610:  MOVF   02,W
07612:  SUBWF  xB4,W
07614:  BNC   7642
07616:  BNZ   7626
07618:  MOVF   01,W
0761A:  SUBWF  xB3,W
0761C:  BNC   7642
0761E:  BNZ   7626
07620:  MOVF   xB2,W
07622:  SUBWF  00,W
07624:  BC    7642
....................          ofs = fp->fsize;               // Clip offset by file size  
07626:  MOVLW  04
07628:  ADDWF  xB0,W
0762A:  MOVWF  FE9
0762C:  MOVLW  00
0762E:  ADDWFC xB1,W
07630:  MOVWF  FEA
07632:  MOVFF  FEF,9B2
07636:  MOVFF  FEC,9B3
0763A:  MOVFF  FEC,9B4
0763E:  MOVFF  FEC,9B5
....................       fp->fptr = ofs;  
07642:  MOVFF  9B0,FE9
07646:  MOVF   xB1,W
07648:  MOVWF  FEA
0764A:  MOVFF  9B2,FEF
0764E:  MOVFF  9B3,FEC
07652:  MOVFF  9B4,FEC
07656:  MOVFF  9B5,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
0765A:  MOVLW  1B
0765C:  ADDWF  xB0,W
0765E:  MOVWF  FE9
07660:  MOVLW  00
07662:  ADDWFC xB1,W
07664:  MOVWF  FEA
07666:  MOVLW  01
07668:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
0766A:  MOVF   xB2,F
0766C:  BNZ   767C
0766E:  MOVF   xB3,F
07670:  BNZ   767C
07672:  MOVF   xB4,F
07674:  BNZ   767C
07676:  MOVF   xB5,F
07678:  BTFSC  FD8.2
0767A:  BRA    78E0
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
0767C:  MOVLW  01
0767E:  SUBWF  xB2,W
07680:  MOVLW  00
07682:  SUBWFB xB3,W
07684:  MOVWF  xBC
07686:  MOVLW  00
07688:  SUBWFB xB4,W
0768A:  MOVWF  xBD
0768C:  MOVLW  00
0768E:  SUBWFB xB5,W
07690:  MOVWF  xBE
07692:  BCF    FD8.0
07694:  CLRF   xB5
07696:  RRCF   xBE,W
07698:  MOVWF  xB4
0769A:  RRCF   xBD,W
0769C:  MOVWF  xB3
0769E:  RRCF   xBC,W
076A0:  MOVWF  xB2
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
076A2:  MOVLW  02
076A4:  MOVLB  7
076A6:  ADDWF  x12,W
076A8:  MOVWF  FE9
076AA:  MOVLW  00
076AC:  ADDWFC x13,W
076AE:  MOVWF  FEA
076B0:  MOVFF  FEF,9BA
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
076B4:  MOVLW  1B
076B6:  MOVLB  9
076B8:  ADDWF  xB0,W
076BA:  MOVWF  01
076BC:  MOVLW  00
076BE:  ADDWFC xB1,W
076C0:  MOVWF  03
076C2:  MOVFF  01,9BB
076C6:  MOVWF  xBC
076C8:  MOVFF  FEA,9BE
076CC:  MOVFF  FE9,9BD
076D0:  BSF    FD8.1
076D2:  MOVLW  09
076D4:  MOVWF  FEA
076D6:  MOVLW  BF
076D8:  MOVWF  FE9
076DA:  CLRF   1B
076DC:  BTFSC  FF2.7
076DE:  BSF    1B.7
076E0:  BCF    FF2.7
076E2:  MOVFF  9B5,A4F
076E6:  MOVFF  9B4,A4E
076EA:  MOVFF  9B3,A4D
076EE:  MOVFF  9B2,A4C
076F2:  MOVLB  A
076F4:  CLRF   x53
076F6:  CLRF   x52
076F8:  CLRF   x51
076FA:  MOVFF  9BA,A50
076FE:  MOVLB  0
07700:  CALL   1056
07704:  BTFSC  1B.7
07706:  BSF    FF2.7
07708:  MOVFF  9BF,00
0770C:  MOVFF  9C0,01
07710:  MOVFF  9C1,02
07714:  MOVFF  9C2,03
07718:  MOVFF  9BE,FEA
0771C:  MOVFF  9BD,FE9
07720:  MOVF   00,W
07722:  MOVLB  9
07724:  SUBWF  xBA,W
07726:  MOVWF  00
07728:  MOVLW  00
0772A:  SUBFWB 01,F
0772C:  SUBFWB 02,F
0772E:  SUBFWB 03,F
07730:  MOVFF  9BC,FEA
07734:  MOVFF  9BB,FE9
07738:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
0773C:  BCF    FD8.1
0773E:  CLRF   1B
07740:  BTFSC  FF2.7
07742:  BSF    1B.7
07744:  BCF    FF2.7
07746:  MOVFF  9B5,A4F
0774A:  MOVFF  9B4,A4E
0774E:  MOVFF  9B3,A4D
07752:  MOVFF  9B2,A4C
07756:  MOVLB  A
07758:  CLRF   x53
0775A:  CLRF   x52
0775C:  CLRF   x51
0775E:  MOVFF  9BA,A50
07762:  MOVLB  0
07764:  CALL   1056
07768:  BTFSC  1B.7
0776A:  BSF    FF2.7
0776C:  MOVFF  03,9B5
07770:  MOVFF  02,9B4
07774:  MOVFF  01,9B3
07778:  MOVFF  00,9B2
....................          clust = fp->org_clust;            // Seek to current cluster  
0777C:  MOVLW  08
0777E:  MOVLB  9
07780:  ADDWF  xB0,W
07782:  MOVWF  FE9
07784:  MOVLW  00
07786:  ADDWFC xB1,W
07788:  MOVWF  FEA
0778A:  MOVFF  FEF,9B6
0778E:  MOVFF  FEC,9B7
07792:  MOVFF  FEC,9B8
07796:  MOVFF  FEC,9B9
....................     
....................          while (ofs--) 
0779A:  MOVFF  9B5,03
0779E:  MOVFF  9B4,02
077A2:  MOVFF  9B3,01
077A6:  MOVFF  9B2,00
077AA:  MOVLW  FF
077AC:  ADDWF  xB2,F
077AE:  BTFSS  FD8.0
077B0:  ADDWF  xB3,F
077B2:  BTFSS  FD8.0
077B4:  ADDWF  xB4,F
077B6:  BTFSS  FD8.0
077B8:  ADDWF  xB5,F
077BA:  MOVF   00,F
077BC:  BNZ   77CA
077BE:  MOVF   01,F
077C0:  BNZ   77CA
077C2:  MOVF   02,F
077C4:  BNZ   77CA
077C6:  MOVF   03,F
077C8:  BZ    77F4
....................             clust = get_cluster(clust); 
077CA:  MOVFF  9B9,9FF
077CE:  MOVFF  9B8,9FE
077D2:  MOVFF  9B7,9FD
077D6:  MOVFF  9B6,9FC
077DA:  MOVLB  0
077DC:  CALL   5CBA
077E0:  MOVFF  03,9B9
077E4:  MOVFF  02,9B8
077E8:  MOVFF  01,9B7
077EC:  MOVFF  00,9B6
077F0:  MOVLB  9
077F2:  BRA    779A
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
077F4:  MOVF   xB9,F
077F6:  BNZ   7806
077F8:  MOVF   xB8,F
077FA:  BNZ   7806
077FC:  MOVF   xB7,F
077FE:  BNZ   7806
07800:  MOVF   xB6,W
07802:  SUBLW  01
07804:  BC    7844
07806:  MOVLW  0C
07808:  MOVLB  7
0780A:  ADDWF  x12,W
0780C:  MOVWF  FE9
0780E:  MOVLW  00
07810:  ADDWFC x13,W
07812:  MOVWF  FEA
07814:  MOVFF  FEF,00
07818:  MOVFF  FEC,01
0781C:  MOVFF  FEC,02
07820:  MOVFF  FEC,03
07824:  MOVF   03,W
07826:  MOVLB  9
07828:  SUBWF  xB9,W
0782A:  BNC   7846
0782C:  BNZ   7844
0782E:  MOVF   02,W
07830:  SUBWF  xB8,W
07832:  BNC   7846
07834:  BNZ   7844
07836:  MOVF   01,W
07838:  SUBWF  xB7,W
0783A:  BNC   7846
0783C:  BNZ   7844
0783E:  MOVF   00,W
07840:  SUBWF  xB6,W
07842:  BNC   7846
....................             goto fk_error; 
07844:  BRA    78EA
....................     
....................          fp->curr_clust = clust; 
07846:  MOVLW  0C
07848:  ADDWF  xB0,W
0784A:  MOVWF  FE9
0784C:  MOVLW  00
0784E:  ADDWFC xB1,W
07850:  MOVWF  FEA
07852:  MOVFF  9B6,FEF
07856:  MOVFF  9B7,FEC
0785A:  MOVFF  9B8,FEC
0785E:  MOVFF  9B9,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
07862:  MOVLW  10
07864:  ADDWF  xB0,W
07866:  MOVWF  01
07868:  MOVLW  00
0786A:  ADDWFC xB1,W
0786C:  MOVWF  03
0786E:  MOVFF  01,9BB
07872:  MOVWF  xBC
07874:  MOVFF  9B9,9F2
07878:  MOVFF  9B8,9F1
0787C:  MOVFF  9B7,9F0
07880:  MOVFF  9B6,9EF
07884:  MOVLB  0
07886:  CALL   560E
0788A:  MOVFF  03,9C0
0788E:  MOVFF  02,9BF
07892:  MOVFF  01,9BE
07896:  MOVFF  00,9BD
0789A:  MOVLB  9
0789C:  MOVF   xBA,W
0789E:  ADDWF  xBD,F
078A0:  MOVLW  00
078A2:  ADDWFC xBE,F
078A4:  ADDWFC xBF,F
078A6:  ADDWFC xC0,F
078A8:  MOVLW  1B
078AA:  ADDWF  xB0,W
078AC:  MOVWF  FE9
078AE:  MOVLW  00
078B0:  ADDWFC xB1,W
078B2:  MOVWF  FEA
078B4:  MOVF   FEF,W
078B6:  SUBWF  xBD,W
078B8:  MOVWF  00
078BA:  MOVLW  00
078BC:  SUBWFB xBE,W
078BE:  MOVWF  01
078C0:  MOVLW  00
078C2:  SUBWFB xBF,W
078C4:  MOVWF  02
078C6:  MOVLW  00
078C8:  SUBWFB xC0,W
078CA:  MOVFF  9BC,FEA
078CE:  MOVFF  9BB,FE9
078D2:  MOVFF  00,FEF
078D6:  MOVFF  01,FEC
078DA:  MOVFF  02,FEC
078DE:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
078E0:  MOVLW  00
078E2:  MOVWF  01
078E4:  MOVLB  7
078E6:  BRA    7902
078E8:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
078EA:  MOVLW  1A
078EC:  ADDWF  xB0,W
078EE:  MOVWF  FE9
078F0:  MOVLW  00
078F2:  ADDWFC xB1,W
078F4:  MOVWF  FEA
078F6:  MOVF   FEF,W
078F8:  IORLW  80
078FA:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
078FC:  MOVLW  07
078FE:  MOVWF  01
07900:  MOVLB  7
07902:  MOVLB  0
07904:  GOTO   8386 (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
080CA:  MOVLB  7
080CC:  MOVF   x12,W
080CE:  IORWF  x13,W
080D0:  BNZ   80D8
....................       return (FR_NOT_ENABLED); 
080D2:  MOVLW  0B
080D4:  MOVWF  01
080D6:  BRA    82A6
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
080D8:  MOVLB  0
080DA:  CALL   559E
080DE:  BTFSC  01.0
080E0:  BRA    80F2
080E2:  MOVLB  7
080E4:  MOVFF  712,FE9
080E8:  MOVFF  713,FEA
080EC:  MOVF   FEF,F
080EE:  BNZ   80FA
080F0:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
080F2:  MOVLW  09
080F4:  MOVWF  01
080F6:  MOVLB  7
080F8:  BRA    82A6
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
080FA:  MOVLW  1A
080FC:  MOVLB  9
080FE:  ADDWF  xB3,W
08100:  MOVWF  FE9
08102:  MOVLW  00
08104:  ADDWFC xB4,W
08106:  MOVWF  FEA
08108:  BTFSS  FEF.5
0810A:  BRA    8282
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
0810C:  MOVLW  14
0810E:  ADDWF  xB3,W
08110:  MOVWF  FE9
08112:  MOVLW  00
08114:  ADDWFC xB4,W
08116:  MOVWF  FEA
08118:  MOVFF  FEF,A14
0811C:  MOVFF  FEC,A15
08120:  MOVFF  FEC,A16
08124:  MOVFF  FEC,A17
08128:  MOVLB  0
0812A:  CALL   5A82
0812E:  MOVF   01,F
08130:  BNZ   813C
....................          return (FR_RW_ERROR); 
08132:  MOVLW  07
08134:  MOVWF  01
08136:  MOVLB  7
08138:  BRA    82A6
0813A:  MOVLB  0
....................       ptr = fp->dir_ptr; 
0813C:  MOVLW  18
0813E:  MOVLB  9
08140:  ADDWF  xB3,W
08142:  MOVWF  FE9
08144:  MOVLW  00
08146:  ADDWFC xB4,W
08148:  MOVWF  FEA
0814A:  MOVFF  FEC,9B6
0814E:  MOVF   FED,F
08150:  MOVFF  FEF,9B5
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
08154:  MOVLW  0B
08156:  ADDWF  xB5,W
08158:  MOVWF  01
0815A:  MOVLW  00
0815C:  ADDWFC xB6,W
0815E:  MOVFF  01,FE9
08162:  MOVWF  FEA
08164:  MOVF   FEF,W
08166:  IORLW  20
08168:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
0816A:  MOVLW  1C
0816C:  ADDWF  xB5,W
0816E:  MOVWF  01
08170:  MOVLW  00
08172:  ADDWFC xB6,W
08174:  MOVWF  03
08176:  MOVFF  01,9B7
0817A:  MOVWF  xB8
0817C:  MOVLW  04
0817E:  ADDWF  xB3,W
08180:  MOVWF  FE9
08182:  MOVLW  00
08184:  ADDWFC xB4,W
08186:  MOVWF  FEA
08188:  MOVFF  FEF,00
0818C:  MOVFF  FEC,01
08190:  MOVFF  FEC,02
08194:  MOVFF  FEC,03
08198:  MOVFF  9B8,FEA
0819C:  MOVFF  9B7,FE9
081A0:  MOVFF  00,FEF
081A4:  MOVFF  01,FEC
081A8:  MOVFF  02,FEC
081AC:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
081B0:  MOVLW  1A
081B2:  ADDWF  xB5,W
081B4:  MOVWF  01
081B6:  MOVLW  00
081B8:  ADDWFC xB6,W
081BA:  MOVWF  03
081BC:  MOVFF  01,9B7
081C0:  MOVWF  xB8
081C2:  MOVLW  08
081C4:  ADDWF  xB3,W
081C6:  MOVWF  FE9
081C8:  MOVLW  00
081CA:  ADDWFC xB4,W
081CC:  MOVWF  FEA
081CE:  MOVFF  FEF,00
081D2:  MOVFF  FEC,01
081D6:  MOVFF  FEC,02
081DA:  MOVFF  FEC,03
081DE:  MOVFF  9B8,FEA
081E2:  MOVFF  9B7,FE9
081E6:  MOVFF  00,FEF
081EA:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
081EE:  MOVLW  14
081F0:  ADDWF  xB5,W
081F2:  MOVWF  01
081F4:  MOVLW  00
081F6:  ADDWFC xB6,W
081F8:  MOVWF  03
081FA:  MOVFF  01,9B7
081FE:  MOVWF  xB8
08200:  MOVLW  08
08202:  ADDWF  xB3,W
08204:  MOVWF  FE9
08206:  MOVLW  00
08208:  ADDWFC xB4,W
0820A:  MOVWF  FEA
0820C:  MOVFF  FEF,9B9
08210:  MOVFF  FEC,9BA
08214:  MOVFF  FEC,00
08218:  MOVFF  FEC,01
0821C:  MOVFF  9B8,FEA
08220:  MOVFF  9B7,FE9
08224:  MOVFF  00,FEF
08228:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
0822C:  MOVLW  16
0822E:  ADDWF  xB5,W
08230:  MOVWF  01
08232:  MOVLW  00
08234:  ADDWFC xB6,W
08236:  MOVWF  03
08238:  MOVFF  01,9B7
0823C:  MOVWF  xB8
0823E:  MOVLB  0
08240:  CALL   6FE8
08244:  MOVFF  9B8,FEA
08248:  MOVFF  9B7,FE9
0824C:  MOVFF  00,FEF
08250:  MOVFF  01,FEC
08254:  MOVFF  02,FEC
08258:  MOVFF  03,FEC
....................       fs->winflag = 1; 
0825C:  MOVLW  06
0825E:  MOVLB  7
08260:  ADDWF  x12,W
08262:  MOVWF  FE9
08264:  MOVLW  00
08266:  ADDWFC x13,W
08268:  MOVWF  FEA
0826A:  MOVLW  01
0826C:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
0826E:  MOVLW  1A
08270:  MOVLB  9
08272:  ADDWF  xB3,W
08274:  MOVWF  FE9
08276:  MOVLW  00
08278:  ADDWFC xB4,W
0827A:  MOVWF  FEA
0827C:  MOVF   FEF,W
0827E:  ANDLW  DF
08280:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
08282:  MOVLB  A
08284:  CLRF   x17
08286:  CLRF   x16
08288:  CLRF   x15
0828A:  CLRF   x14
0828C:  MOVLB  0
0828E:  CALL   5A82
08292:  MOVF   01,F
08294:  BNZ   82A0
....................       return (FR_RW_ERROR); 
08296:  MOVLW  07
08298:  MOVWF  01
0829A:  MOVLB  7
0829C:  BRA    82A6
0829E:  MOVLB  0
....................  
....................    return (FR_OK); 
082A0:  MOVLW  00
082A2:  MOVWF  01
082A4:  MOVLB  7
082A6:  MOVLB  0
082A8:  GOTO   82B6 (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
082AC:  MOVFF  9B1,9B4
082B0:  MOVFF  9B0,9B3
082B4:  BRA    80CA
082B6:  MOVFF  01,9B2
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
082BA:  MOVLB  9
082BC:  MOVF   xB2,F
082BE:  BNZ   82F0
....................       { 
....................       fp->flag = 0; 
082C0:  MOVLW  1A
082C2:  ADDWF  xB0,W
082C4:  MOVWF  FE9
082C6:  MOVLW  00
082C8:  ADDWFC xB1,W
082CA:  MOVWF  FEA
082CC:  CLRF   FEF
....................       if (fs->files) 
082CE:  MOVLW  01
082D0:  MOVLB  7
082D2:  ADDWF  x12,W
082D4:  MOVWF  FE9
082D6:  MOVLW  00
082D8:  ADDWFC x13,W
082DA:  MOVWF  FEA
082DC:  MOVF   FEF,F
082DE:  BZ    82EE
....................          fs->files--; 
082E0:  MOVLW  01
082E2:  ADDWF  x12,W
082E4:  MOVWF  FE9
082E6:  MOVLW  00
082E8:  ADDWFC x13,W
082EA:  MOVWF  FEA
082EC:  DECF   FEF,F
082EE:  MOVLB  9
....................       } 
....................    return (res); 
082F0:  MOVFF  9B2,01
082F4:  MOVLB  0
082F6:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0BC62:  CALL   55AC
0BC66:  MOVFF  01,88B
....................    if (res != FR_OK)  
0BC6A:  MOVLB  8
0BC6C:  MOVF   x8B,F
0BC6E:  BZ    BC76
....................       return (res); 
0BC70:  MOVFF  88B,01
0BC74:  BRA    BF06
....................  
....................    if (disk_status() & STA_PROTECT) 
0BC76:  MOVLB  0
0BC78:  CALL   559E
0BC7C:  BTFSS  01.2
0BC7E:  BRA    BC8A
....................       return (FR_WRITE_PROTECTED); 
0BC80:  MOVLW  0A
0BC82:  MOVWF  01
0BC84:  MOVLB  8
0BC86:  BRA    BF06
0BC88:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0BC8A:  MOVLW  08
0BC8C:  MOVLB  9
0BC8E:  MOVWF  xD7
0BC90:  MOVLW  98
0BC92:  MOVWF  xD6
0BC94:  MOVLW  08
0BC96:  MOVWF  xD9
0BC98:  MOVLW  A6
0BC9A:  MOVWF  xD8
0BC9C:  MOVFF  88A,9DB
0BCA0:  MOVFF  889,9DA
0BCA4:  MOVLW  08
0BCA6:  MOVWF  xDD
0BCA8:  MOVLW  8C
0BCAA:  MOVWF  xDC
0BCAC:  MOVLB  0
0BCAE:  CALL   61E2
0BCB2:  MOVFF  01,88B
....................  
....................    if (res != FR_OK)  
0BCB6:  MOVLB  8
0BCB8:  MOVF   x8B,F
0BCBA:  BZ    BCC2
....................       return (res);            // Trace failed  
0BCBC:  MOVFF  88B,01
0BCC0:  BRA    BF06
....................  
....................    if (dir_ptr == NULL)  
0BCC2:  MOVF   x8C,F
0BCC4:  BNZ   BCD0
0BCC6:  MOVF   x8D,F
0BCC8:  BNZ   BCD0
....................       return (FR_NO_FILE);      // It is a root directory  
0BCCA:  MOVLW  02
0BCCC:  MOVWF  01
0BCCE:  BRA    BF06
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0BCD0:  MOVLW  0B
0BCD2:  ADDWF  x8C,W
0BCD4:  MOVWF  01
0BCD6:  MOVLW  00
0BCD8:  ADDWFC x8D,W
0BCDA:  MOVWF  03
0BCDC:  MOVFF  01,FE9
0BCE0:  MOVWF  FEA
0BCE2:  BTFSS  FEF.0
0BCE4:  BRA    BCEC
....................       return (FR_DENIED);         // It is a R/O item  
0BCE6:  MOVLW  05
0BCE8:  MOVWF  01
0BCEA:  BRA    BF06
....................  
....................    dsect = fs->winsect; 
0BCEC:  MOVLW  20
0BCEE:  MOVLB  7
0BCF0:  ADDWF  x12,W
0BCF2:  MOVWF  FE9
0BCF4:  MOVLW  00
0BCF6:  ADDWFC x13,W
0BCF8:  MOVWF  FEA
0BCFA:  MOVFF  FEF,894
0BCFE:  MOVFF  FEC,895
0BD02:  MOVFF  FEC,896
0BD06:  MOVFF  FEC,897
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0BD0A:  MOVLW  14
0BD0C:  MOVLB  8
0BD0E:  ADDWF  x8C,W
0BD10:  MOVWF  01
0BD12:  MOVLW  00
0BD14:  ADDWFC x8D,W
0BD16:  MOVWF  03
0BD18:  MOVFF  01,FE9
0BD1C:  MOVWF  FEA
0BD1E:  MOVFF  FEC,893
0BD22:  MOVF   FED,F
0BD24:  MOVFF  FEF,8B2
0BD28:  MOVFF  8B2,892
0BD2C:  CLRF   xB2
0BD2E:  CLRF   xB3
0BD30:  MOVLW  1A
0BD32:  ADDWF  x8C,W
0BD34:  MOVWF  01
0BD36:  MOVLW  00
0BD38:  ADDWFC x8D,W
0BD3A:  MOVFF  01,FE9
0BD3E:  MOVWF  FEA
0BD40:  MOVFF  FEC,03
0BD44:  MOVF   FED,F
0BD46:  MOVF   FEF,W
0BD48:  IORWF  xB2,W
0BD4A:  MOVWF  x90
0BD4C:  MOVF   03,W
0BD4E:  IORWF  xB3,W
0BD50:  MOVWF  x91
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BD52:  MOVLW  0B
0BD54:  ADDWF  x8C,W
0BD56:  MOVWF  01
0BD58:  MOVLW  00
0BD5A:  ADDWFC x8D,W
0BD5C:  MOVWF  03
0BD5E:  MOVFF  01,FE9
0BD62:  MOVWF  FEA
0BD64:  BTFSS  FEF.4
0BD66:  BRA    BE7A
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BD68:  MOVFF  893,89F
0BD6C:  MOVFF  892,89E
0BD70:  MOVFF  891,89D
0BD74:  MOVFF  890,89C
....................       dirscan.sect = clust2sect(dclust); 
0BD78:  MOVFF  893,9F2
0BD7C:  MOVFF  892,9F1
0BD80:  MOVFF  891,9F0
0BD84:  MOVFF  890,9EF
0BD88:  MOVLB  0
0BD8A:  CALL   560E
0BD8E:  MOVFF  03,8A3
0BD92:  MOVFF  02,8A2
0BD96:  MOVFF  01,8A1
0BD9A:  MOVFF  00,8A0
....................       dirscan.index = 0; 
0BD9E:  MOVLB  8
0BDA0:  CLRF   xA5
0BDA2:  CLRF   xA4
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BDA4:  MOVFF  8A3,A17
0BDA8:  MOVFF  8A2,A16
0BDAC:  MOVFF  8A1,A15
0BDB0:  MOVFF  8A0,A14
0BDB4:  MOVLB  0
0BDB6:  CALL   5A82
0BDBA:  MOVF   01,F
0BDBC:  BNZ   BDC8
....................             return (FR_RW_ERROR); 
0BDBE:  MOVLW  07
0BDC0:  MOVWF  01
0BDC2:  MOVLB  8
0BDC4:  BRA    BF06
0BDC6:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BDC8:  MOVLB  8
0BDCA:  MOVF   xA4,W
0BDCC:  ANDLW  0F
0BDCE:  MOVWF  xB2
0BDD0:  CLRF   xB3
0BDD2:  RLCF   xB2,F
0BDD4:  RLCF   xB3,F
0BDD6:  RLCF   xB2,F
0BDD8:  RLCF   xB3,F
0BDDA:  RLCF   xB2,F
0BDDC:  RLCF   xB3,F
0BDDE:  RLCF   xB2,F
0BDE0:  RLCF   xB3,F
0BDE2:  RLCF   xB2,F
0BDE4:  RLCF   xB3,F
0BDE6:  MOVLW  E0
0BDE8:  ANDWF  xB2,F
0BDEA:  MOVLW  24
0BDEC:  ADDWF  xB2,W
0BDEE:  MOVWF  01
0BDF0:  MOVLW  00
0BDF2:  ADDWFC xB3,W
0BDF4:  MOVWF  03
0BDF6:  MOVF   01,W
0BDF8:  MOVLB  7
0BDFA:  ADDWF  x12,W
0BDFC:  MOVWF  01
0BDFE:  MOVF   x13,W
0BE00:  ADDWFC 03,F
0BE02:  MOVFF  01,88E
0BE06:  MOVLB  8
0BE08:  MOVFF  03,88F
....................          if (*sdir == 0) 
0BE0C:  MOVFF  88F,03
0BE10:  MOVFF  88E,FE9
0BE14:  MOVFF  88F,FEA
0BE18:  MOVF   FEF,F
0BE1A:  BNZ   BE1E
....................             break; 
0BE1C:  BRA    BE7A
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BE1E:  MOVFF  88F,03
0BE22:  MOVFF  88E,FE9
0BE26:  MOVFF  88F,FEA
0BE2A:  MOVF   FEF,W
0BE2C:  SUBLW  E5
0BE2E:  BZ    BE5E
0BE30:  MOVFF  88F,03
0BE34:  MOVFF  88E,FE9
0BE38:  MOVFF  88F,FEA
0BE3C:  MOVF   FEF,W
0BE3E:  SUBLW  2E
0BE40:  BZ    BE5E
0BE42:  MOVLW  0B
0BE44:  ADDWF  x8E,W
0BE46:  MOVWF  01
0BE48:  MOVLW  00
0BE4A:  ADDWFC x8F,W
0BE4C:  MOVWF  03
0BE4E:  MOVFF  01,FE9
0BE52:  MOVWF  FEA
0BE54:  BTFSC  FEF.3
0BE56:  BRA    BE5E
....................             return (FR_DENIED);   // The directory is not empty  
0BE58:  MOVLW  05
0BE5A:  MOVWF  01
0BE5C:  BRA    BF06
....................          } while (next_dir_ptr(&dirscan)); 
0BE5E:  MOVLW  08
0BE60:  MOVLB  9
0BE62:  MOVWF  xE6
0BE64:  MOVLW  98
0BE66:  MOVWF  xE5
0BE68:  MOVLB  0
0BE6A:  CALL   6008
0BE6E:  MOVF   01,F
0BE70:  BTFSC  FD8.2
0BE72:  BRA    BE78
0BE74:  MOVLB  8
0BE76:  BRA    BDA4
0BE78:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BE7A:  MOVFF  897,A17
0BE7E:  MOVFF  896,A16
0BE82:  MOVFF  895,A15
0BE86:  MOVFF  894,A14
0BE8A:  MOVLB  0
0BE8C:  CALL   5A82
0BE90:  MOVF   01,F
0BE92:  BNZ   BE9E
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BE94:  MOVLW  07
0BE96:  MOVWF  01
0BE98:  MOVLB  8
0BE9A:  BRA    BF06
0BE9C:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BE9E:  MOVLB  8
0BEA0:  MOVFF  88C,FE9
0BEA4:  MOVFF  88D,FEA
0BEA8:  MOVLW  E5
0BEAA:  MOVWF  FEF
....................    fs->winflag = 1; 
0BEAC:  MOVLW  06
0BEAE:  MOVLB  7
0BEB0:  ADDWF  x12,W
0BEB2:  MOVWF  FE9
0BEB4:  MOVLW  00
0BEB6:  ADDWFC x13,W
0BEB8:  MOVWF  FEA
0BEBA:  MOVLW  01
0BEBC:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BEBE:  MOVFF  893,9DE
0BEC2:  MOVFF  892,9DD
0BEC6:  MOVFF  891,9DC
0BECA:  MOVFF  890,9DB
0BECE:  MOVLB  0
0BED0:  CALL   6F46
0BED4:  MOVF   01,F
0BED6:  BNZ   BEE2
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BED8:  MOVLW  07
0BEDA:  MOVWF  01
0BEDC:  MOVLB  8
0BEDE:  BRA    BF06
0BEE0:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BEE2:  MOVLB  A
0BEE4:  CLRF   x17
0BEE6:  CLRF   x16
0BEE8:  CLRF   x15
0BEEA:  CLRF   x14
0BEEC:  MOVLB  0
0BEEE:  CALL   5A82
0BEF2:  MOVF   01,F
0BEF4:  BNZ   BF00
....................       return (FR_RW_ERROR); 
0BEF6:  MOVLW  07
0BEF8:  MOVWF  01
0BEFA:  MOVLB  8
0BEFC:  BRA    BF06
0BEFE:  MOVLB  0
....................  
....................    return (FR_OK); 
0BF00:  MOVLW  00
0BF02:  MOVWF  01
0BF04:  MOVLB  8
0BF06:  MOVLB  0
0BF08:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
079BC:  MOVFF  9B1,9B3
079C0:  MOVFF  9B0,9B2
079C4:  MOVFF  9B3,03
079C8:  MOVLB  9
079CA:  MOVFF  9B2,FE9
079CE:  MOVFF  9B3,FEA
079D2:  MOVF   FEF,F
079D4:  BZ    79E2
079D6:  INCF   xB2,F
079D8:  BTFSC  FD8.2
079DA:  INCF   xB3,F
079DC:  MOVLB  0
079DE:  BRA    79C4
079E0:  MOVLB  9
....................    return(sc - s); 
079E2:  MOVF   xB0,W
079E4:  SUBWF  xB2,W
079E6:  MOVWF  00
079E8:  MOVF   xB1,W
079EA:  SUBWFB xB3,W
079EC:  MOVWF  03
079EE:  MOVFF  00,01
079F2:  MOVWF  02
079F4:  MOVLB  0
079F6:  GOTO   843E (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
03508:  MOVLB  4
0350A:  CLRF   xE6
0350C:  MOVLW  01
0350E:  MOVWF  xE5
....................    rtc.year=10; 
03510:  MOVLW  0A
03512:  MOVWF  xE4
....................    rtc.month=1; 
03514:  MOVLW  01
03516:  MOVWF  xE3
....................    rtc.day=1; 
03518:  MOVWF  xE2
....................    rtc.hour=0; 
0351A:  CLRF   xE1
....................    rtc.min=0; 
0351C:  CLRF   xE0
....................    rtc.sec=0; 
0351E:  CLRF   xDF
....................    rtc.ms100=0; 
03520:  CLRF   xDE
03522:  MOVLB  0
03524:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
06FE8:  MOVLB  9
06FEA:  CLRF   xDD
06FEC:  CLRF   xDC
06FEE:  CLRF   xDB
06FF0:  MOVFF  4E4,9DA
06FF4:  MOVLW  14
06FF6:  ADDWF  xDA,F
06FF8:  MOVLW  00
06FFA:  ADDWFC xDB,F
06FFC:  ADDWFC xDC,F
06FFE:  ADDWFC xDD,F
07000:  BCF    FD8.0
07002:  CLRF   xD6
07004:  CLRF   xD7
07006:  CLRF   xD8
07008:  RLCF   xDA,W
0700A:  MOVWF  xD9
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
0700C:  CLRF   xDD
0700E:  CLRF   xDC
07010:  CLRF   xDB
07012:  MOVFF  4E3,9DA
07016:  MOVLW  0F
07018:  ANDWF  xDA,F
0701A:  CLRF   xDB
0701C:  CLRF   xDC
0701E:  CLRF   xDD
07020:  CLRF   00
07022:  CLRF   01
07024:  RLCF   xDA,W
07026:  MOVWF  02
07028:  RLCF   xDB,W
0702A:  MOVWF  03
0702C:  RLCF   02,F
0702E:  RLCF   03,F
07030:  RLCF   02,F
07032:  RLCF   03,F
07034:  RLCF   02,F
07036:  RLCF   03,F
07038:  RLCF   02,F
0703A:  RLCF   03,F
0703C:  MOVLW  E0
0703E:  ANDWF  02,F
07040:  MOVF   00,W
07042:  IORWF  xD6,F
07044:  MOVF   01,W
07046:  IORWF  xD7,F
07048:  MOVF   02,W
0704A:  IORWF  xD8,F
0704C:  MOVF   03,W
0704E:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
07050:  CLRF   xDD
07052:  CLRF   xDC
07054:  CLRF   xDB
07056:  MOVFF  4E2,9DA
0705A:  MOVLW  1F
0705C:  ANDWF  xDA,F
0705E:  CLRF   xDB
07060:  CLRF   xDC
07062:  CLRF   xDD
07064:  CLRF   00
07066:  CLRF   01
07068:  MOVF   00,W
0706A:  IORWF  xD6,F
0706C:  MOVF   01,W
0706E:  IORWF  xD7,F
07070:  MOVF   xDA,W
07072:  IORWF  xD8,F
07074:  MOVF   xDB,W
07076:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
07078:  CLRF   xDD
0707A:  CLRF   xDC
0707C:  CLRF   xDB
0707E:  MOVFF  4E1,9DA
07082:  MOVLW  1F
07084:  ANDWF  xDA,F
07086:  CLRF   xDB
07088:  CLRF   xDC
0708A:  CLRF   xDD
0708C:  CLRF   00
0708E:  RLCF   xDA,W
07090:  MOVWF  01
07092:  RLCF   xDB,W
07094:  MOVWF  02
07096:  RLCF   xDC,W
07098:  MOVWF  03
0709A:  RLCF   01,F
0709C:  RLCF   02,F
0709E:  RLCF   03,F
070A0:  RLCF   01,F
070A2:  RLCF   02,F
070A4:  RLCF   03,F
070A6:  MOVLW  F8
070A8:  ANDWF  01,F
070AA:  MOVF   00,W
070AC:  IORWF  xD6,F
070AE:  MOVF   01,W
070B0:  IORWF  xD7,F
070B2:  MOVF   02,W
070B4:  IORWF  xD8,F
070B6:  MOVF   03,W
070B8:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
070BA:  CLRF   xDD
070BC:  CLRF   xDC
070BE:  CLRF   xDB
070C0:  MOVFF  4E0,9DA
070C4:  MOVLW  3F
070C6:  ANDWF  xDA,F
070C8:  CLRF   xDB
070CA:  CLRF   xDC
070CC:  CLRF   xDD
070CE:  RLCF   xDA,W
070D0:  MOVWF  00
070D2:  RLCF   xDB,W
070D4:  MOVWF  01
070D6:  RLCF   xDC,W
070D8:  MOVWF  02
070DA:  RLCF   xDD,W
070DC:  MOVWF  03
070DE:  RLCF   00,F
070E0:  RLCF   01,F
070E2:  RLCF   02,F
070E4:  RLCF   03,F
070E6:  RLCF   00,F
070E8:  RLCF   01,F
070EA:  RLCF   02,F
070EC:  RLCF   03,F
070EE:  RLCF   00,F
070F0:  RLCF   01,F
070F2:  RLCF   02,F
070F4:  RLCF   03,F
070F6:  RLCF   00,F
070F8:  RLCF   01,F
070FA:  RLCF   02,F
070FC:  RLCF   03,F
070FE:  MOVLW  E0
07100:  ANDWF  00,F
07102:  MOVF   00,W
07104:  IORWF  xD6,F
07106:  MOVF   01,W
07108:  IORWF  xD7,F
0710A:  MOVF   02,W
0710C:  IORWF  xD8,F
0710E:  MOVF   03,W
07110:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
07112:  CLRF   xDD
07114:  CLRF   xDC
07116:  CLRF   xDB
07118:  MOVFF  4DF,9DA
0711C:  MOVLW  3F
0711E:  ANDWF  xDA,F
07120:  CLRF   xDB
07122:  CLRF   xDC
07124:  CLRF   xDD
07126:  BCF    FD8.0
07128:  RRCF   xDD,W
0712A:  MOVWF  03
0712C:  RRCF   xDC,W
0712E:  MOVWF  02
07130:  RRCF   xDB,W
07132:  MOVWF  01
07134:  RRCF   xDA,W
07136:  IORWF  xD6,F
07138:  MOVF   01,W
0713A:  IORWF  xD7,F
0713C:  MOVF   02,W
0713E:  IORWF  xD8,F
07140:  MOVF   03,W
07142:  IORWF  xD9,F
....................    return (work); 
07144:  MOVFF  9D6,00
07148:  MOVFF  9D7,01
0714C:  MOVFF  9D8,02
07150:  MOVFF  9D9,03
07154:  MOVLB  0
07156:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0BAE8:  MOVLW  08
0BAEA:  MOVLB  9
0BAEC:  MOVWF  xB1
0BAEE:  MOVLW  8B
0BAF0:  MOVWF  xB0
0BAF2:  MOVFF  88A,9B3
0BAF6:  MOVFF  889,9B2
0BAFA:  MOVLW  01
0BAFC:  MOVWF  xB4
0BAFE:  MOVLB  0
0BB00:  CALL   7158
0BB04:  MOVFF  01,8A7
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0BB08:  MOVLB  8
0BB0A:  MOVF   xA7,F
0BB0C:  BTFSS  FD8.2
0BB0E:  BRA    BC10
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0BB10:  MOVLW  08
0BB12:  MOVWF  xCD
0BB14:  MOVLW  8B
0BB16:  MOVWF  xCC
0BB18:  MOVLW  08
0BB1A:  MOVWF  xCF
0BB1C:  MOVLW  A8
0BB1E:  MOVWF  xCE
0BB20:  CLRF   xD1
0BB22:  MOVLW  20
0BB24:  MOVWF  xD0
0BB26:  MOVLW  08
0BB28:  MOVWF  xD3
0BB2A:  MOVLW  CA
0BB2C:  MOVWF  xD2
0BB2E:  MOVLB  0
0BB30:  BRA    B42C
0BB32:  MOVFF  01,8A7
....................          for (i = 0; i < br; i++) 
0BB36:  MOVLB  8
0BB38:  CLRF   xC9
0BB3A:  CLRF   xC8
0BB3C:  MOVF   xC9,W
0BB3E:  SUBWF  xCB,W
0BB40:  BNC   BB6C
0BB42:  BNZ   BB4A
0BB44:  MOVF   xCA,W
0BB46:  SUBWF  xC8,W
0BB48:  BC    BB6C
....................          { 
....................             putc(mesg[i]); 
0BB4A:  MOVLW  A8
0BB4C:  ADDWF  xC8,W
0BB4E:  MOVWF  FE9
0BB50:  MOVLW  08
0BB52:  ADDWFC xC9,W
0BB54:  MOVWF  FEA
0BB56:  MOVFF  FEF,8CC
0BB5A:  MOVF   xCC,W
0BB5C:  MOVLB  0
0BB5E:  CALL   AE7C
0BB62:  MOVLB  8
0BB64:  INCF   xC8,F
0BB66:  BTFSC  FD8.2
0BB68:  INCF   xC9,F
0BB6A:  BRA    BB3C
....................          } 
....................       } while ((result == FR_OK) && br); 
0BB6C:  MOVF   xA7,F
0BB6E:  BNZ   BB76
0BB70:  MOVF   xCA,W
0BB72:  IORWF  xCB,W
0BB74:  BNZ   BB10
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0BB76:  MOVF   xA7,F
0BB78:  BZ    BBEC
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0BB7A:  MOVLW  16
0BB7C:  MOVWF  FF6
0BB7E:  MOVLW  0C
0BB80:  MOVWF  FF7
0BB82:  MOVLW  00
0BB84:  MOVWF  FF8
0BB86:  CLRF   1B
0BB88:  BTFSC  FF2.7
0BB8A:  BSF    1B.7
0BB8C:  BCF    FF2.7
0BB8E:  MOVLB  0
0BB90:  CALL   0E4E
0BB94:  BTFSC  1B.7
0BB96:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0BB98:  MOVFF  8A7,8CC
0BB9C:  MOVLW  08
0BB9E:  MOVLB  8
0BBA0:  MOVWF  xCE
0BBA2:  MOVLW  A8
0BBA4:  MOVWF  xCD
0BBA6:  MOVLB  0
0BBA8:  RCALL  B93A
....................          printf("@FS: %s\r\n",mesg); 
0BBAA:  MOVLW  2C
0BBAC:  MOVWF  FF6
0BBAE:  MOVLW  0C
0BBB0:  MOVWF  FF7
0BBB2:  MOVLW  00
0BBB4:  MOVWF  FF8
0BBB6:  CLRF   1B
0BBB8:  BTFSC  FF2.7
0BBBA:  BSF    1B.7
0BBBC:  BCF    FF2.7
0BBBE:  MOVLW  05
0BBC0:  MOVLB  A
0BBC2:  MOVWF  x40
0BBC4:  MOVLB  0
0BBC6:  CALL   1024
0BBCA:  BTFSC  1B.7
0BBCC:  BSF    FF2.7
0BBCE:  MOVLW  08
0BBD0:  MOVWF  FEA
0BBD2:  MOVLW  A8
0BBD4:  MOVWF  FE9
0BBD6:  CALL   7996
0BBDA:  MOVLW  0D
0BBDC:  BTFSS  F9E.4
0BBDE:  BRA    BBDC
0BBE0:  MOVWF  FAD
0BBE2:  MOVLW  0A
0BBE4:  BTFSS  F9E.4
0BBE6:  BRA    BBE4
0BBE8:  MOVWF  FAD
0BBEA:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0BBEC:  MOVLW  08
0BBEE:  MOVLB  9
0BBF0:  MOVWF  xB1
0BBF2:  MOVLW  8B
0BBF4:  MOVWF  xB0
0BBF6:  MOVLB  0
0BBF8:  CALL   82AC
....................       printf("\r\n");       
0BBFC:  MOVLW  0D
0BBFE:  BTFSS  F9E.4
0BC00:  BRA    BBFE
0BC02:  MOVWF  FAD
0BC04:  MOVLW  0A
0BC06:  BTFSS  F9E.4
0BC08:  BRA    BC06
0BC0A:  MOVWF  FAD
....................    } 
0BC0C:  BRA    BC60
0BC0E:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0BC10:  MOVFF  8A7,8CC
0BC14:  MOVLW  08
0BC16:  MOVWF  xCE
0BC18:  MOVLW  A8
0BC1A:  MOVWF  xCD
0BC1C:  MOVLB  0
0BC1E:  RCALL  B93A
....................       printf("@FS: %s\r\n",mesg); 
0BC20:  MOVLW  36
0BC22:  MOVWF  FF6
0BC24:  MOVLW  0C
0BC26:  MOVWF  FF7
0BC28:  MOVLW  00
0BC2A:  MOVWF  FF8
0BC2C:  CLRF   1B
0BC2E:  BTFSC  FF2.7
0BC30:  BSF    1B.7
0BC32:  BCF    FF2.7
0BC34:  MOVLW  05
0BC36:  MOVLB  A
0BC38:  MOVWF  x40
0BC3A:  MOVLB  0
0BC3C:  CALL   1024
0BC40:  BTFSC  1B.7
0BC42:  BSF    FF2.7
0BC44:  MOVLW  08
0BC46:  MOVWF  FEA
0BC48:  MOVLW  A8
0BC4A:  MOVWF  FE9
0BC4C:  CALL   7996
0BC50:  MOVLW  0D
0BC52:  BTFSS  F9E.4
0BC54:  BRA    BC52
0BC56:  MOVWF  FAD
0BC58:  MOVLW  0A
0BC5A:  BTFSS  F9E.4
0BC5C:  BRA    BC5A
0BC5E:  MOVWF  FAD
....................    } 
0BC60:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04DF4:  MOVLW  40
04DF6:  MOVWF  FF6
04DF8:  MOVLW  0C
04DFA:  MOVWF  FF7
04DFC:  MOVLW  00
04DFE:  MOVWF  FF8
04E00:  CLRF   1B
04E02:  BTFSC  FF2.7
04E04:  BSF    1B.7
04E06:  BCF    FF2.7
04E08:  CALL   0E4E
04E0C:  BTFSC  1B.7
04E0E:  BSF    FF2.7
....................    if (status & FR_OK) 
04E10:  ANDLW  00
04E12:  BZ    4E30
....................       printf("   NoError\r\n"); 
04E14:  MOVLW  50
04E16:  MOVWF  FF6
04E18:  MOVLW  0C
04E1A:  MOVWF  FF7
04E1C:  MOVLW  00
04E1E:  MOVWF  FF8
04E20:  CLRF   1B
04E22:  BTFSC  FF2.7
04E24:  BSF    1B.7
04E26:  BCF    FF2.7
04E28:  CALL   0E4E
04E2C:  BTFSC  1B.7
04E2E:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04E30:  MOVLB  8
04E32:  BTFSS  x8A.0
04E34:  BRA    4E56
....................       printf("   Media Not Ready\r\n"); 
04E36:  MOVLW  5E
04E38:  MOVWF  FF6
04E3A:  MOVLW  0C
04E3C:  MOVWF  FF7
04E3E:  MOVLW  00
04E40:  MOVWF  FF8
04E42:  CLRF   1B
04E44:  BTFSC  FF2.7
04E46:  BSF    1B.7
04E48:  BCF    FF2.7
04E4A:  MOVLB  0
04E4C:  CALL   0E4E
04E50:  BTFSC  1B.7
04E52:  BSF    FF2.7
04E54:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04E56:  BTFSS  x8A.1
04E58:  BRA    4E7A
....................       printf("   File Not Found\r\n"); 
04E5A:  MOVLW  74
04E5C:  MOVWF  FF6
04E5E:  MOVLW  0C
04E60:  MOVWF  FF7
04E62:  MOVLW  00
04E64:  MOVWF  FF8
04E66:  CLRF   1B
04E68:  BTFSC  FF2.7
04E6A:  BSF    1B.7
04E6C:  BCF    FF2.7
04E6E:  MOVLB  0
04E70:  CALL   0E4E
04E74:  BTFSC  1B.7
04E76:  BSF    FF2.7
04E78:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04E7A:  MOVF   x8A,W
04E7C:  ANDLW  03
04E7E:  BZ    4EA0
....................       printf("   Invalid Path\r\n"); 
04E80:  MOVLW  88
04E82:  MOVWF  FF6
04E84:  MOVLW  0C
04E86:  MOVWF  FF7
04E88:  MOVLW  00
04E8A:  MOVWF  FF8
04E8C:  CLRF   1B
04E8E:  BTFSC  FF2.7
04E90:  BSF    1B.7
04E92:  BCF    FF2.7
04E94:  MOVLB  0
04E96:  CALL   0E4E
04E9A:  BTFSC  1B.7
04E9C:  BSF    FF2.7
04E9E:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04EA0:  BTFSS  x8A.2
04EA2:  BRA    4EC4
....................       printf("   Invalid Name\r\n"); 
04EA4:  MOVLW  9A
04EA6:  MOVWF  FF6
04EA8:  MOVLW  0C
04EAA:  MOVWF  FF7
04EAC:  MOVLW  00
04EAE:  MOVWF  FF8
04EB0:  CLRF   1B
04EB2:  BTFSC  FF2.7
04EB4:  BSF    1B.7
04EB6:  BCF    FF2.7
04EB8:  MOVLB  0
04EBA:  CALL   0E4E
04EBE:  BTFSC  1B.7
04EC0:  BSF    FF2.7
04EC2:  MOVLB  8
....................    if (status & FR_DENIED) 
04EC4:  MOVF   x8A,W
04EC6:  ANDLW  05
04EC8:  BZ    4EEA
....................       printf("   Access Denied\r\n"); 
04ECA:  MOVLW  AC
04ECC:  MOVWF  FF6
04ECE:  MOVLW  0C
04ED0:  MOVWF  FF7
04ED2:  MOVLW  00
04ED4:  MOVWF  FF8
04ED6:  CLRF   1B
04ED8:  BTFSC  FF2.7
04EDA:  BSF    1B.7
04EDC:  BCF    FF2.7
04EDE:  MOVLB  0
04EE0:  CALL   0E4E
04EE4:  BTFSC  1B.7
04EE6:  BSF    FF2.7
04EE8:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04EEA:  MOVF   x8A,W
04EEC:  ANDLW  06
04EEE:  BZ    4F10
....................       printf("   Disk Full\r\n"); 
04EF0:  MOVLW  C0
04EF2:  MOVWF  FF6
04EF4:  MOVLW  0C
04EF6:  MOVWF  FF7
04EF8:  MOVLW  00
04EFA:  MOVWF  FF8
04EFC:  CLRF   1B
04EFE:  BTFSC  FF2.7
04F00:  BSF    1B.7
04F02:  BCF    FF2.7
04F04:  MOVLB  0
04F06:  CALL   0E4E
04F0A:  BTFSC  1B.7
04F0C:  BSF    FF2.7
04F0E:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04F10:  MOVF   x8A,W
04F12:  ANDLW  07
04F14:  BZ    4F36
....................       printf("   Read/Write Error\r\n"); 
04F16:  MOVLW  D0
04F18:  MOVWF  FF6
04F1A:  MOVLW  0C
04F1C:  MOVWF  FF7
04F1E:  MOVLW  00
04F20:  MOVWF  FF8
04F22:  CLRF   1B
04F24:  BTFSC  FF2.7
04F26:  BSF    1B.7
04F28:  BCF    FF2.7
04F2A:  MOVLB  0
04F2C:  CALL   0E4E
04F30:  BTFSC  1B.7
04F32:  BSF    FF2.7
04F34:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04F36:  MOVF   x8A,W
04F38:  ANDLW  09
04F3A:  BZ    4F5C
....................       printf("   Incorrect Media Change\r\n"); 
04F3C:  MOVLW  E6
04F3E:  MOVWF  FF6
04F40:  MOVLW  0C
04F42:  MOVWF  FF7
04F44:  MOVLW  00
04F46:  MOVWF  FF8
04F48:  CLRF   1B
04F4A:  BTFSC  FF2.7
04F4C:  BSF    1B.7
04F4E:  BCF    FF2.7
04F50:  MOVLB  0
04F52:  CALL   0E4E
04F56:  BTFSC  1B.7
04F58:  BSF    FF2.7
04F5A:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04F5C:  MOVF   x8A,W
04F5E:  ANDLW  0A
04F60:  BZ    4F82
....................       printf("   Write Protected\r\n"); 
04F62:  MOVLW  02
04F64:  MOVWF  FF6
04F66:  MOVLW  0D
04F68:  MOVWF  FF7
04F6A:  MOVLW  00
04F6C:  MOVWF  FF8
04F6E:  CLRF   1B
04F70:  BTFSC  FF2.7
04F72:  BSF    1B.7
04F74:  BCF    FF2.7
04F76:  MOVLB  0
04F78:  CALL   0E4E
04F7C:  BTFSC  1B.7
04F7E:  BSF    FF2.7
04F80:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04F82:  MOVF   x8A,W
04F84:  ANDLW  0B
04F86:  BZ    4FA8
....................       printf("   Not Enabled\r\n"); 
04F88:  MOVLW  18
04F8A:  MOVWF  FF6
04F8C:  MOVLW  0D
04F8E:  MOVWF  FF7
04F90:  MOVLW  00
04F92:  MOVWF  FF8
04F94:  CLRF   1B
04F96:  BTFSC  FF2.7
04F98:  BSF    1B.7
04F9A:  BCF    FF2.7
04F9C:  MOVLB  0
04F9E:  CALL   0E4E
04FA2:  BTFSC  1B.7
04FA4:  BSF    FF2.7
04FA6:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04FA8:  MOVF   x8A,W
04FAA:  ANDLW  0C
04FAC:  BZ    4FCE
....................       printf("   No File System\r\n"); 
04FAE:  MOVLW  2A
04FB0:  MOVWF  FF6
04FB2:  MOVLW  0D
04FB4:  MOVWF  FF7
04FB6:  MOVLW  00
04FB8:  MOVWF  FF8
04FBA:  CLRF   1B
04FBC:  BTFSC  FF2.7
04FBE:  BSF    1B.7
04FC0:  BCF    FF2.7
04FC2:  MOVLB  0
04FC4:  CALL   0E4E
04FC8:  BTFSC  1B.7
04FCA:  BSF    FF2.7
04FCC:  MOVLB  8
04FCE:  MOVLB  0
04FD0:  GOTO   505A (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
082F8:  MOVLW  09
082FA:  MOVWF  FEA
082FC:  MOVLW  10
082FE:  MOVWF  FE9
08300:  CLRF   00
08302:  CLRF   02
08304:  MOVLW  A0
08306:  MOVWF  01
08308:  CALL   3526
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
0830C:  MOVLW  08
0830E:  MOVLB  9
08310:  MOVWF  xB1
08312:  MOVLW  EF
08314:  MOVWF  xB0
08316:  MOVFF  8EE,9B3
0831A:  MOVFF  8ED,9B2
0831E:  MOVLW  12
08320:  MOVWF  xB4
08322:  MOVLB  0
08324:  CALL   7158
08328:  MOVFF  01,90B
....................    if (result) 
0832C:  MOVLB  9
0832E:  MOVF   x0B,F
08330:  BZ    8354
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
08332:  MOVLW  3E
08334:  MOVWF  FF6
08336:  MOVLW  0D
08338:  MOVWF  FF7
0833A:  MOVLW  00
0833C:  MOVWF  FF8
0833E:  CLRF   1B
08340:  BTFSC  FF2.7
08342:  BSF    1B.7
08344:  BCF    FF2.7
08346:  MOVLB  0
08348:  CALL   0E4E
0834C:  BTFSC  1B.7
0834E:  BSF    FF2.7
....................    } 
08350:  BRA    84D0
08352:  MOVLB  9
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
08354:  MOVLB  8
08356:  MOVF   xF3,F
08358:  BNZ   8366
0835A:  MOVF   xF4,F
0835C:  BNZ   8366
0835E:  MOVF   xF5,F
08360:  BNZ   8366
08362:  MOVF   xF6,F
08364:  BZ    838C
....................          result = f_lseek(&fdst, fdst.fsize);  
08366:  MOVLW  08
08368:  MOVLB  9
0836A:  MOVWF  xB1
0836C:  MOVLW  EF
0836E:  MOVWF  xB0
08370:  MOVFF  8F6,9B5
08374:  MOVFF  8F5,9B4
08378:  MOVFF  8F4,9B3
0837C:  MOVFF  8F3,9B2
08380:  MOVLB  0
08382:  GOTO   75A0
08386:  MOVFF  01,90B
0838A:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
0838C:  MOVLB  0
0838E:  MOVF   x66,F
08390:  BNZ   83AE
08392:  MOVLW  09
08394:  MOVLB  9
08396:  MOVWF  xB1
08398:  MOVLW  10
0839A:  MOVWF  xB0
0839C:  CLRF   xB3
0839E:  MOVLW  67
083A0:  MOVWF  xB2
083A2:  CLRF   xB5
083A4:  MOVLW  9F
083A6:  MOVWF  xB4
083A8:  MOVLB  0
083AA:  CALL   7908
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
083AE:  DECFSZ x66,W
083B0:  BRA    83D0
083B2:  MOVLW  09
083B4:  MOVLB  9
083B6:  MOVWF  xB1
083B8:  MOVLW  10
083BA:  MOVWF  xB0
083BC:  MOVLW  01
083BE:  MOVWF  xB3
083C0:  MOVLW  07
083C2:  MOVWF  xB2
083C4:  CLRF   xB5
083C6:  MOVLW  9F
083C8:  MOVWF  xB4
083CA:  MOVLB  0
083CC:  CALL   7908
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
083D0:  MOVF   20,F
083D2:  BNZ   83DA
083D4:  MOVF   1F,W
083D6:  SUBLW  04
083D8:  BC    842E
083DA:  MOVLW  5E
083DC:  MOVWF  FF6
083DE:  MOVLW  0D
083E0:  MOVWF  FF7
083E2:  MOVLW  00
083E4:  MOVWF  FF8
083E6:  CLRF   1B
083E8:  BTFSC  FF2.7
083EA:  BSF    1B.7
083EC:  BCF    FF2.7
083EE:  MOVLW  0E
083F0:  MOVLB  A
083F2:  MOVWF  x40
083F4:  MOVLB  0
083F6:  CALL   1024
083FA:  BTFSC  1B.7
083FC:  BSF    FF2.7
083FE:  MOVLW  09
08400:  MOVWF  FEA
08402:  MOVLW  10
08404:  MOVWF  FE9
08406:  CALL   7996
0840A:  MOVLW  6E
0840C:  MOVWF  FF6
0840E:  MOVLW  0D
08410:  MOVWF  FF7
08412:  MOVLW  00
08414:  MOVWF  FF8
08416:  CLRF   1B
08418:  BTFSC  FF2.7
0841A:  BSF    1B.7
0841C:  BCF    FF2.7
0841E:  MOVLW  03
08420:  MOVLB  A
08422:  MOVWF  x40
08424:  MOVLB  0
08426:  CALL   1024
0842A:  BTFSC  1B.7
0842C:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
0842E:  MOVLW  09
08430:  MOVLB  9
08432:  MOVWF  xB1
08434:  MOVLW  10
08436:  MOVWF  xB0
08438:  MOVLB  0
0843A:  GOTO   79BC
0843E:  MOVFF  02,90D
08442:  MOVFF  01,90C
....................       result = f_write(&fdst, mesg, btw, &bw); 
08446:  MOVLW  08
08448:  MOVLB  9
0844A:  MOVWF  xB1
0844C:  MOVLW  EF
0844E:  MOVWF  xB0
08450:  MOVLW  09
08452:  MOVWF  xB3
08454:  MOVLW  10
08456:  MOVWF  xB2
08458:  MOVFF  90D,9B5
0845C:  MOVFF  90C,9B4
08460:  MOVLW  09
08462:  MOVWF  xB7
08464:  MOVLW  0E
08466:  MOVWF  xB6
08468:  MOVLB  0
0846A:  GOTO   79FA
0846E:  MOVFF  01,90B
....................       if (result) 
08472:  MOVLB  9
08474:  MOVF   x0B,F
08476:  BZ    849A
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
08478:  MOVLW  72
0847A:  MOVWF  FF6
0847C:  MOVLW  0D
0847E:  MOVWF  FF7
08480:  MOVLW  00
08482:  MOVWF  FF8
08484:  CLRF   1B
08486:  BTFSC  FF2.7
08488:  BSF    1B.7
0848A:  BCF    FF2.7
0848C:  MOVLB  0
0848E:  CALL   0E4E
08492:  BTFSC  1B.7
08494:  BSF    FF2.7
....................       } 
08496:  BRA    84C2
08498:  MOVLB  9
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
0849A:  MOVF   20,F
0849C:  BNZ   84A4
0849E:  MOVF   1F,W
084A0:  SUBLW  04
084A2:  BC    84C4
084A4:  MOVLW  86
084A6:  MOVWF  FF6
084A8:  MOVLW  0D
084AA:  MOVWF  FF7
084AC:  MOVLW  00
084AE:  MOVWF  FF8
084B0:  CLRF   1B
084B2:  BTFSC  FF2.7
084B4:  BSF    1B.7
084B6:  BCF    FF2.7
084B8:  MOVLB  0
084BA:  CALL   0E4E
084BE:  BTFSC  1B.7
084C0:  BSF    FF2.7
084C2:  MOVLB  9
....................       } 
....................  
....................       f_close(&fdst); 
084C4:  MOVLW  08
084C6:  MOVWF  xB1
084C8:  MOVLW  EF
084CA:  MOVWF  xB0
084CC:  MOVLB  0
084CE:  RCALL  82AC
....................    } 
....................  
....................    return (result); 
084D0:  MOVLB  9
084D2:  MOVFF  90B,01
084D6:  MOVLB  0
084D8:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
17ACC:  CLRF   1B
17ACE:  BTFSC  FF2.7
17AD0:  BSF    1B.7
17AD2:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
17AD4:  MOVFF  887,A42
17AD8:  MOVLW  0A
17ADA:  MOVLB  A
17ADC:  MOVWF  x43
17ADE:  MOVLB  0
17AE0:  CALL   0F7A
17AE4:  BTFSC  1B.7
17AE6:  BSF    FF2.7
17AE8:  MOVFF  01,888
....................    nibl=data-(nibh*10); 
17AEC:  MOVLB  8
17AEE:  MOVF   x88,W
17AF0:  MULLW  0A
17AF2:  MOVF   FF3,W
17AF4:  SUBWF  x87,W
17AF6:  MOVWF  x89
....................  
....................    return((nibh<<4)|nibl); 
17AF8:  SWAPF  x88,W
17AFA:  MOVWF  00
17AFC:  MOVLW  F0
17AFE:  ANDWF  00,F
17B00:  MOVF   00,W
17B02:  IORWF  x89,W
17B04:  MOVWF  01
17B06:  MOVLB  0
17B08:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
03312:  MOVFF  8EE,8EF
....................    data=(i>>4)*10; 
03316:  MOVLB  8
03318:  SWAPF  xEF,W
0331A:  MOVWF  00
0331C:  MOVLW  0F
0331E:  ANDWF  00,F
03320:  MOVF   00,W
03322:  MULLW  0A
03324:  MOVFF  FF3,8EE
....................    data=data+(i<<4>>4); 
03328:  SWAPF  xEF,W
0332A:  MOVWF  00
0332C:  MOVLW  F0
0332E:  ANDWF  00,F
03330:  MOVF   00,W
03332:  SWAPF  00,F
03334:  MOVLW  0F
03336:  ANDWF  00,F
03338:  MOVF   00,W
0333A:  ADDWF  xEE,F
....................  
....................    return data; 
0333C:  MOVFF  8EE,01
03340:  MOVLB  0
03342:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
034B2:  MOVLB  8
034B4:  CLRF   xCB
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
034B6:  BCF    FC6.5
034B8:  MOVLW  21
034BA:  MOVWF  FC6
034BC:  MOVLW  40
034BE:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
034C0:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
034C2:  MOVF   FC9,W
034C4:  MOVLW  0C
034C6:  MOVWF  FC9
034C8:  RRCF   FC7,W
034CA:  BNC   34C8
034CC:  MOVFF  FC9,8CB
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
034D0:  MOVF   FC9,W
034D2:  MOVFF  8CB,FC9
034D6:  RRCF   FC7,W
034D8:  BNC   34D6
034DA:  MOVFF  FC9,730
....................    output_bit(RTC_CS, DISABLE); 
034DE:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
034E0:  MOVLB  7
034E2:  BCF    x30.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
034E4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
034E6:  MOVF   FC9,W
034E8:  MOVLW  8C
034EA:  MOVWF  FC9
034EC:  RRCF   FC7,W
034EE:  BNC   34EC
034F0:  MOVFF  FC9,8CB
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
034F4:  MOVF   FC9,W
034F6:  MOVFF  730,FC9
034FA:  RRCF   FC7,W
034FC:  BNC   34FA
034FE:  MOVFF  FC9,8CB
....................    output_bit(RTC_CS, DISABLE); 
03502:  BSF    F91.0
03504:  MOVLB  0
03506:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0E24E:  MOVLW  1A
0E250:  MOVLB  8
0E252:  MOVWF  x97
0E254:  MOVLB  0
0E256:  CALL   29CA
0E25A:  MOVFF  01,4F
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0E25E:  MOVF   4F,F
0E260:  BNZ   E2CE
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0E262:  MOVLW  94
0E264:  MOVWF  FF6
0E266:  MOVLW  0D
0E268:  MOVWF  FF7
0E26A:  MOVLW  00
0E26C:  MOVWF  FF8
0E26E:  CLRF   1B
0E270:  BTFSC  FF2.7
0E272:  BSF    1B.7
0E274:  BCF    FF2.7
0E276:  MOVLW  05
0E278:  MOVLB  A
0E27A:  MOVWF  x40
0E27C:  MOVLB  0
0E27E:  CALL   1024
0E282:  BTFSC  1B.7
0E284:  BSF    FF2.7
0E286:  CLRF   1B
0E288:  BTFSC  FF2.7
0E28A:  BSF    1B.7
0E28C:  BCF    FF2.7
0E28E:  MOVFF  72A,A40
0E292:  MOVLW  01
0E294:  MOVLB  A
0E296:  MOVWF  x41
0E298:  MOVLB  0
0E29A:  CALL   0FA6
0E29E:  BTFSC  1B.7
0E2A0:  BSF    FF2.7
0E2A2:  MOVLW  2F
0E2A4:  BTFSS  F9E.4
0E2A6:  BRA    E2A4
0E2A8:  MOVWF  FAD
0E2AA:  CLRF   1B
0E2AC:  BTFSC  FF2.7
0E2AE:  BSF    1B.7
0E2B0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0E2B2:  MOVFF  729,A40
0E2B6:  MOVLW  01
0E2B8:  MOVLB  A
0E2BA:  MOVWF  x41
0E2BC:  MOVLB  0
0E2BE:  CALL   0FA6
0E2C2:  BTFSC  1B.7
0E2C4:  BSF    FF2.7
0E2C6:  MOVLW  2F
0E2C8:  BTFSS  F9E.4
0E2CA:  BRA    E2C8
0E2CC:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E2CE:  DECFSZ 4F,W
0E2D0:  BRA    E33E
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E2D2:  MOVLW  A0
0E2D4:  MOVWF  FF6
0E2D6:  MOVLW  0D
0E2D8:  MOVWF  FF7
0E2DA:  MOVLW  00
0E2DC:  MOVWF  FF8
0E2DE:  CLRF   1B
0E2E0:  BTFSC  FF2.7
0E2E2:  BSF    1B.7
0E2E4:  BCF    FF2.7
0E2E6:  MOVLW  05
0E2E8:  MOVLB  A
0E2EA:  MOVWF  x40
0E2EC:  MOVLB  0
0E2EE:  CALL   1024
0E2F2:  BTFSC  1B.7
0E2F4:  BSF    FF2.7
0E2F6:  CLRF   1B
0E2F8:  BTFSC  FF2.7
0E2FA:  BSF    1B.7
0E2FC:  BCF    FF2.7
0E2FE:  MOVFF  729,A40
0E302:  MOVLW  01
0E304:  MOVLB  A
0E306:  MOVWF  x41
0E308:  MOVLB  0
0E30A:  CALL   0FA6
0E30E:  BTFSC  1B.7
0E310:  BSF    FF2.7
0E312:  MOVLW  2F
0E314:  BTFSS  F9E.4
0E316:  BRA    E314
0E318:  MOVWF  FAD
0E31A:  CLRF   1B
0E31C:  BTFSC  FF2.7
0E31E:  BSF    1B.7
0E320:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E322:  MOVFF  72A,A40
0E326:  MOVLW  01
0E328:  MOVLB  A
0E32A:  MOVWF  x41
0E32C:  MOVLB  0
0E32E:  CALL   0FA6
0E332:  BTFSC  1B.7
0E334:  BSF    FF2.7
0E336:  MOVLW  2F
0E338:  BTFSS  F9E.4
0E33A:  BRA    E338
0E33C:  MOVWF  FAD
0E33E:  CLRF   1B
0E340:  BTFSC  FF2.7
0E342:  BSF    1B.7
0E344:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E346:  MOVFF  72B,A40
0E34A:  MOVLW  01
0E34C:  MOVLB  A
0E34E:  MOVWF  x41
0E350:  MOVLB  0
0E352:  CALL   0FA6
0E356:  BTFSC  1B.7
0E358:  BSF    FF2.7
0E35A:  MOVLW  20
0E35C:  BTFSS  F9E.4
0E35E:  BRA    E35C
0E360:  MOVWF  FAD
0E362:  CLRF   1B
0E364:  BTFSC  FF2.7
0E366:  BSF    1B.7
0E368:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E36A:  MOVFF  727,A40
0E36E:  MOVLW  01
0E370:  MOVLB  A
0E372:  MOVWF  x41
0E374:  MOVLB  0
0E376:  CALL   0FA6
0E37A:  BTFSC  1B.7
0E37C:  BSF    FF2.7
0E37E:  MOVLW  3A
0E380:  BTFSS  F9E.4
0E382:  BRA    E380
0E384:  MOVWF  FAD
0E386:  CLRF   1B
0E388:  BTFSC  FF2.7
0E38A:  BSF    1B.7
0E38C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E38E:  MOVFF  726,A40
0E392:  MOVLW  01
0E394:  MOVLB  A
0E396:  MOVWF  x41
0E398:  MOVLB  0
0E39A:  CALL   0FA6
0E39E:  BTFSC  1B.7
0E3A0:  BSF    FF2.7
0E3A2:  MOVLW  3A
0E3A4:  BTFSS  F9E.4
0E3A6:  BRA    E3A4
0E3A8:  MOVWF  FAD
0E3AA:  CLRF   1B
0E3AC:  BTFSC  FF2.7
0E3AE:  BSF    1B.7
0E3B0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E3B2:  MOVFF  725,A40
0E3B6:  MOVLW  01
0E3B8:  MOVLB  A
0E3BA:  MOVWF  x41
0E3BC:  MOVLB  0
0E3BE:  CALL   0FA6
0E3C2:  BTFSC  1B.7
0E3C4:  BSF    FF2.7
0E3C6:  MOVLW  0A
0E3C8:  BTFSS  F9E.4
0E3CA:  BRA    E3C8
0E3CC:  MOVWF  FAD
0E3CE:  MOVLW  0D
0E3D0:  BTFSS  F9E.4
0E3D2:  BRA    E3D0
0E3D4:  MOVWF  FAD
0E3D6:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03344:  MOVLB  8
03346:  CLRF   xED
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
03348:  BCF    FC6.5
0334A:  MOVLW  21
0334C:  MOVWF  FC6
0334E:  MOVLW  40
03350:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
03352:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
03354:  MOVF   FC9,W
03356:  CLRF   FC9
03358:  RRCF   FC7,W
0335A:  BNC   3358
0335C:  MOVFF  FC9,8ED
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
03360:  MOVF   FC9,W
03362:  MOVFF  8ED,FC9
03366:  RRCF   FC7,W
03368:  BNC   3366
0336A:  MOVFF  FC9,72C
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
0336E:  MOVF   FC9,W
03370:  MOVFF  8ED,FC9
03374:  RRCF   FC7,W
03376:  BNC   3374
03378:  MOVFF  FC9,725
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
0337C:  MOVF   FC9,W
0337E:  MOVFF  8ED,FC9
03382:  RRCF   FC7,W
03384:  BNC   3382
03386:  MOVFF  FC9,726
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
0338A:  MOVF   FC9,W
0338C:  MOVFF  8ED,FC9
03390:  RRCF   FC7,W
03392:  BNC   3390
03394:  MOVFF  FC9,727
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
03398:  MOVF   FC9,W
0339A:  MOVFF  8ED,FC9
0339E:  RRCF   FC7,W
033A0:  BNC   339E
033A2:  MOVFF  FC9,728
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
033A6:  MOVF   FC9,W
033A8:  MOVFF  8ED,FC9
033AC:  RRCF   FC7,W
033AE:  BNC   33AC
033B0:  MOVFF  FC9,729
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
033B4:  MOVF   FC9,W
033B6:  MOVFF  8ED,FC9
033BA:  RRCF   FC7,W
033BC:  BNC   33BA
033BE:  MOVFF  FC9,72A
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
033C2:  MOVF   FC9,W
033C4:  MOVFF  8ED,FC9
033C8:  RRCF   FC7,W
033CA:  BNC   33C8
033CC:  MOVFF  FC9,72B
....................    output_bit(RTC_CS, DISABLE); 
033D0:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
033D2:  MOVFF  725,8EE
033D6:  MOVLB  0
033D8:  RCALL  3312
033DA:  MOVFF  01,725
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
033DE:  MOVFF  726,8EE
033E2:  RCALL  3312
033E4:  MOVFF  01,726
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
033E8:  MOVFF  727,8EE
033EC:  RCALL  3312
033EE:  MOVFF  01,727
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
033F2:  MOVFF  729,8EE
033F6:  RCALL  3312
033F8:  MOVFF  01,729
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
033FC:  MOVFF  72A,8EE
03400:  RCALL  3312
03402:  MOVFF  01,72A
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
03406:  MOVFF  72B,8EE
0340A:  RCALL  3312
0340C:  MOVFF  01,72B
03410:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DD8:  MOVLB  A
00DDA:  CLRF   x37
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DDC:  BCF    FC6.5
00DDE:  MOVLW  21
00DE0:  MOVWF  FC6
00DE2:  MOVLW  40
00DE4:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00DE6:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00DE8:  MOVF   FC9,W
00DEA:  MOVLW  0F
00DEC:  MOVWF  FC9
00DEE:  RRCF   FC7,W
00DF0:  BNC   0DEE
00DF2:  MOVFF  FC9,A37
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00DF6:  MOVF   FC9,W
00DF8:  MOVFF  A37,FC9
00DFC:  RRCF   FC7,W
00DFE:  BNC   0DFC
00E00:  MOVFF  FC9,733
....................    spi_read(0x00); 
00E04:  MOVF   FC9,W
00E06:  CLRF   FC9
00E08:  RRCF   FC7,W
00E0A:  BNC   0E08
....................    output_bit(RTC_CS, DISABLE); 
00E0C:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00E0E:  BCF    4D.2
00E10:  MOVLB  0
00E12:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E4AE:  MOVF   4F,F
0E4B0:  BNZ   E51E
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E4B2:  MOVLW  AC
0E4B4:  MOVWF  FF6
0E4B6:  MOVLW  0D
0E4B8:  MOVWF  FF7
0E4BA:  MOVLW  00
0E4BC:  MOVWF  FF8
0E4BE:  CLRF   1B
0E4C0:  BTFSC  FF2.7
0E4C2:  BSF    1B.7
0E4C4:  BCF    FF2.7
0E4C6:  MOVLW  05
0E4C8:  MOVLB  A
0E4CA:  MOVWF  x40
0E4CC:  MOVLB  0
0E4CE:  CALL   1024
0E4D2:  BTFSC  1B.7
0E4D4:  BSF    FF2.7
0E4D6:  CLRF   1B
0E4D8:  BTFSC  FF2.7
0E4DA:  BSF    1B.7
0E4DC:  BCF    FF2.7
0E4DE:  MOVFF  72E,A40
0E4E2:  MOVLW  01
0E4E4:  MOVLB  A
0E4E6:  MOVWF  x41
0E4E8:  MOVLB  0
0E4EA:  CALL   0FA6
0E4EE:  BTFSC  1B.7
0E4F0:  BSF    FF2.7
0E4F2:  MOVLW  2F
0E4F4:  BTFSS  F9E.4
0E4F6:  BRA    E4F4
0E4F8:  MOVWF  FAD
0E4FA:  CLRF   1B
0E4FC:  BTFSC  FF2.7
0E4FE:  BSF    1B.7
0E500:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E502:  MOVFF  72F,A40
0E506:  MOVLW  01
0E508:  MOVLB  A
0E50A:  MOVWF  x41
0E50C:  MOVLB  0
0E50E:  CALL   0FA6
0E512:  BTFSC  1B.7
0E514:  BSF    FF2.7
0E516:  MOVLW  2F
0E518:  BTFSS  F9E.4
0E51A:  BRA    E518
0E51C:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E51E:  DECFSZ 4F,W
0E520:  BRA    E58E
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E522:  MOVLW  B8
0E524:  MOVWF  FF6
0E526:  MOVLW  0D
0E528:  MOVWF  FF7
0E52A:  MOVLW  00
0E52C:  MOVWF  FF8
0E52E:  CLRF   1B
0E530:  BTFSC  FF2.7
0E532:  BSF    1B.7
0E534:  BCF    FF2.7
0E536:  MOVLW  05
0E538:  MOVLB  A
0E53A:  MOVWF  x40
0E53C:  MOVLB  0
0E53E:  CALL   1024
0E542:  BTFSC  1B.7
0E544:  BSF    FF2.7
0E546:  CLRF   1B
0E548:  BTFSC  FF2.7
0E54A:  BSF    1B.7
0E54C:  BCF    FF2.7
0E54E:  MOVFF  72F,A40
0E552:  MOVLW  01
0E554:  MOVLB  A
0E556:  MOVWF  x41
0E558:  MOVLB  0
0E55A:  CALL   0FA6
0E55E:  BTFSC  1B.7
0E560:  BSF    FF2.7
0E562:  MOVLW  2F
0E564:  BTFSS  F9E.4
0E566:  BRA    E564
0E568:  MOVWF  FAD
0E56A:  CLRF   1B
0E56C:  BTFSC  FF2.7
0E56E:  BSF    1B.7
0E570:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E572:  MOVFF  72E,A40
0E576:  MOVLW  01
0E578:  MOVLB  A
0E57A:  MOVWF  x41
0E57C:  MOVLB  0
0E57E:  CALL   0FA6
0E582:  BTFSC  1B.7
0E584:  BSF    FF2.7
0E586:  MOVLW  2F
0E588:  BTFSS  F9E.4
0E58A:  BRA    E588
0E58C:  MOVWF  FAD
0E58E:  CLRF   1B
0E590:  BTFSC  FF2.7
0E592:  BSF    1B.7
0E594:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E596:  MOVFF  72D,A40
0E59A:  MOVLW  01
0E59C:  MOVLB  A
0E59E:  MOVWF  x41
0E5A0:  MOVLB  0
0E5A2:  CALL   0FA6
0E5A6:  BTFSC  1B.7
0E5A8:  BSF    FF2.7
0E5AA:  MOVLW  20
0E5AC:  BTFSS  F9E.4
0E5AE:  BRA    E5AC
0E5B0:  MOVWF  FAD
0E5B2:  CLRF   1B
0E5B4:  BTFSC  FF2.7
0E5B6:  BSF    1B.7
0E5B8:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E5BA:  MOVFF  730,A40
0E5BE:  MOVLW  01
0E5C0:  MOVLB  A
0E5C2:  MOVWF  x41
0E5C4:  MOVLB  0
0E5C6:  CALL   0FA6
0E5CA:  BTFSC  1B.7
0E5CC:  BSF    FF2.7
0E5CE:  MOVLW  3A
0E5D0:  BTFSS  F9E.4
0E5D2:  BRA    E5D0
0E5D4:  MOVWF  FAD
0E5D6:  CLRF   1B
0E5D8:  BTFSC  FF2.7
0E5DA:  BSF    1B.7
0E5DC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E5DE:  MOVFF  731,A40
0E5E2:  MOVLW  01
0E5E4:  MOVLB  A
0E5E6:  MOVWF  x41
0E5E8:  MOVLB  0
0E5EA:  CALL   0FA6
0E5EE:  BTFSC  1B.7
0E5F0:  BSF    FF2.7
0E5F2:  MOVLW  3A
0E5F4:  BTFSS  F9E.4
0E5F6:  BRA    E5F4
0E5F8:  MOVWF  FAD
0E5FA:  CLRF   1B
0E5FC:  BTFSC  FF2.7
0E5FE:  BSF    1B.7
0E600:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E602:  MOVFF  732,A40
0E606:  MOVLW  01
0E608:  MOVLB  A
0E60A:  MOVWF  x41
0E60C:  MOVLB  0
0E60E:  CALL   0FA6
0E612:  BTFSC  1B.7
0E614:  BSF    FF2.7
0E616:  MOVLW  0A
0E618:  BTFSS  F9E.4
0E61A:  BRA    E618
0E61C:  MOVWF  FAD
0E61E:  MOVLW  0D
0E620:  BTFSS  F9E.4
0E622:  BRA    E620
0E624:  MOVWF  FAD
0E626:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E3D8:  MOVLB  8
0E3DA:  CLRF   xB7
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E3DC:  BCF    FC6.5
0E3DE:  MOVLW  21
0E3E0:  MOVWF  FC6
0E3E2:  MOVLW  40
0E3E4:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E3E6:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E3E8:  MOVF   FC9,W
0E3EA:  MOVLW  0A
0E3EC:  MOVWF  FC9
0E3EE:  RRCF   FC7,W
0E3F0:  BNC   E3EE
0E3F2:  MOVFF  FC9,8B7
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E3F6:  MOVF   FC9,W
0E3F8:  MOVFF  8B7,FC9
0E3FC:  RRCF   FC7,W
0E3FE:  BNC   E3FC
0E400:  MOVFF  FC9,72E
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E404:  MOVF   FC9,W
0E406:  MOVFF  8B7,FC9
0E40A:  RRCF   FC7,W
0E40C:  BNC   E40A
0E40E:  MOVFF  FC9,72F
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E412:  MOVF   FC9,W
0E414:  MOVFF  8B7,FC9
0E418:  RRCF   FC7,W
0E41A:  BNC   E418
0E41C:  MOVFF  FC9,730
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E420:  MOVF   FC9,W
0E422:  MOVFF  8B7,FC9
0E426:  RRCF   FC7,W
0E428:  BNC   E426
0E42A:  MOVFF  FC9,731
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E42E:  MOVF   FC9,W
0E430:  MOVFF  8B7,FC9
0E434:  RRCF   FC7,W
0E436:  BNC   E434
0E438:  MOVFF  FC9,732
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E43C:  MOVF   FC9,W
0E43E:  MOVFF  8B7,FC9
0E442:  RRCF   FC7,W
0E444:  BNC   E442
0E446:  MOVFF  FC9,733
....................    output_bit(RTC_CS, DISABLE); 
0E44A:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E44C:  MOVLW  1F
0E44E:  MOVLB  7
0E450:  ANDWF  x2E,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E452:  MOVFF  72E,8EE
0E456:  MOVLB  0
0E458:  CALL   3312
0E45C:  MOVFF  01,72E
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E460:  MOVLW  3F
0E462:  MOVLB  7
0E464:  ANDWF  x2F,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E466:  MOVFF  72F,8EE
0E46A:  MOVLB  0
0E46C:  CALL   3312
0E470:  MOVFF  01,72F
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E474:  MOVLW  3F
0E476:  MOVLB  7
0E478:  ANDWF  x30,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E47A:  MOVFF  730,8EE
0E47E:  MOVLB  0
0E480:  CALL   3312
0E484:  MOVFF  01,730
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E488:  MOVLB  7
0E48A:  BCF    x31.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E48C:  MOVFF  731,8EE
0E490:  MOVLB  0
0E492:  CALL   3312
0E496:  MOVFF  01,731
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E49A:  MOVLB  7
0E49C:  BCF    x32.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E49E:  MOVFF  732,8EE
0E4A2:  MOVLB  0
0E4A4:  CALL   3312
0E4A8:  MOVFF  01,732
0E4AC:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
17712:  MOVLW  08
17714:  MOVWF  FEA
17716:  MOVLW  89
17718:  MOVWF  FE9
1771A:  CLRF   00
1771C:  CLRF   02
1771E:  MOVLW  0C
17720:  MOVWF  01
17722:  CALL   3526
....................  
....................    time_error = 0; 
17726:  MOVLB  8
17728:  CLRF   x95
....................     
....................    fputc('[', COM_A); 
1772A:  MOVLW  5B
1772C:  MOVLB  0
1772E:  CALL   AE7C
....................     
....................    for (n=0; n<12; ++n){ 
17732:  MOVLB  8
17734:  CLRF   x88
17736:  MOVF   x88,W
17738:  SUBLW  0B
1773A:  BNC   17780
....................       c = fgetc(COM_A); 
1773C:  MOVLB  0
1773E:  CALL   0E38
17742:  MOVFF  01,887
....................       if (com_echo == TRUE) 
17746:  DECFSZ 4C,W
17748:  BRA    17754
....................       { 
....................          fputc(c, COM_A); 
1774A:  MOVLB  8
1774C:  MOVF   x87,W
1774E:  MOVLB  0
17750:  CALL   AE7C
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
17754:  MOVLB  8
17756:  MOVF   x87,W
17758:  SUBLW  2F
1775A:  BC    17776
1775C:  MOVF   x87,W
1775E:  SUBLW  39
17760:  BNC   17776
17762:  CLRF   03
17764:  MOVF   x88,W
17766:  ADDLW  89
17768:  MOVWF  FE9
1776A:  MOVLW  08
1776C:  ADDWFC 03,W
1776E:  MOVWF  FEA
17770:  MOVFF  887,FEF
17774:  BRA    1777C
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
17776:  MOVLW  01
17778:  MOVWF  x95
....................          break; 
1777A:  BRA    17780
....................       } 
1777C:  INCF   x88,F
1777E:  BRA    17736
....................    } 
....................     
....................    if (time_error == 0){ 
17780:  MOVF   x95,F
17782:  BTFSS  FD8.2
17784:  BRA    17ABC
....................     
....................       fputc(']', COM_A); 
17786:  MOVLW  5D
17788:  MOVLB  0
1778A:  CALL   AE7C
....................        
....................       for (n=0; n<12; ++n){ 
1778E:  MOVLB  8
17790:  CLRF   x88
17792:  MOVF   x88,W
17794:  SUBLW  0B
17796:  BNC   177C8
....................          t_entry[n] = (t_entry[n] - 48); 
17798:  CLRF   03
1779A:  MOVF   x88,W
1779C:  ADDLW  89
1779E:  MOVWF  01
177A0:  MOVLW  08
177A2:  ADDWFC 03,F
177A4:  MOVFF  03,897
177A8:  CLRF   03
177AA:  MOVF   x88,W
177AC:  ADDLW  89
177AE:  MOVWF  FE9
177B0:  MOVLW  08
177B2:  ADDWFC 03,W
177B4:  MOVWF  FEA
177B6:  MOVLW  30
177B8:  SUBWF  FEF,W
177BA:  MOVFF  897,FEA
177BE:  MOVFF  01,FE9
177C2:  MOVWF  FEF
177C4:  INCF   x88,F
177C6:  BRA    17792
....................       } 
....................        
....................       if (RTCfmt == 0) 
177C8:  MOVF   4F,F
177CA:  BNZ   17808
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
177CC:  MOVF   x89,W
177CE:  MULLW  0A
177D0:  MOVF   FF3,W
177D2:  ADDWF  x8A,W
177D4:  MOVLB  7
177D6:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
177D8:  MOVF   x38,F
177DA:  BZ    177E2
177DC:  MOVF   x38,W
177DE:  SUBLW  0C
177E0:  BC    177EA
177E2:  MOVLW  02
177E4:  MOVLB  8
177E6:  MOVWF  x95
177E8:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
177EA:  MOVLB  8
177EC:  MOVF   x8B,W
177EE:  MULLW  0A
177F0:  MOVF   FF3,W
177F2:  ADDWF  x8C,W
177F4:  MOVLB  7
177F6:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
177F8:  MOVF   x37,F
177FA:  BZ    17802
177FC:  MOVF   x37,W
177FE:  SUBLW  1F
17800:  BC    1780A
17802:  MOVLW  02
17804:  MOVLB  8
17806:  MOVWF  x95
17808:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
1780A:  DECFSZ 4F,W
1780C:  BRA    1784E
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
1780E:  MOVLB  8
17810:  MOVF   x89,W
17812:  MULLW  0A
17814:  MOVF   FF3,W
17816:  ADDWF  x8A,W
17818:  MOVLB  7
1781A:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
1781C:  MOVF   x37,F
1781E:  BZ    17826
17820:  MOVF   x37,W
17822:  SUBLW  1F
17824:  BC    1782E
17826:  MOVLW  02
17828:  MOVLB  8
1782A:  MOVWF  x95
1782C:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
1782E:  MOVLB  8
17830:  MOVF   x8B,W
17832:  MULLW  0A
17834:  MOVF   FF3,W
17836:  ADDWF  x8C,W
17838:  MOVLB  7
1783A:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
1783C:  MOVF   x38,F
1783E:  BZ    17846
17840:  MOVF   x38,W
17842:  SUBLW  0C
17844:  BC    1784E
17846:  MOVLW  02
17848:  MOVLB  8
1784A:  MOVWF  x95
1784C:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
1784E:  MOVLB  8
17850:  MOVF   x8D,W
17852:  MULLW  0A
17854:  MOVF   FF3,W
17856:  ADDWF  x8E,W
17858:  MOVLB  7
1785A:  MOVWF  x39
....................       if (RTC_Yr_Data > 99) time_error = 2;  
1785C:  MOVF   x39,W
1785E:  SUBLW  63
17860:  BC    1786A
17862:  MOVLW  02
17864:  MOVLB  8
17866:  MOVWF  x95
17868:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
1786A:  MOVLB  8
1786C:  MOVF   x8F,W
1786E:  MULLW  0A
17870:  MOVF   FF3,W
17872:  ADDWF  x90,W
17874:  MOVLB  7
17876:  MOVWF  x36
....................       if (RTC_Hr_Data > 24) time_error = 2;  
17878:  MOVF   x36,W
1787A:  SUBLW  18
1787C:  BC    17886
1787E:  MOVLW  02
17880:  MOVLB  8
17882:  MOVWF  x95
17884:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
17886:  MOVLB  8
17888:  MOVF   x91,W
1788A:  MULLW  0A
1788C:  MOVF   FF3,W
1788E:  ADDWF  x92,W
17890:  MOVLB  7
17892:  MOVWF  x35
....................       if (RTC_Min_Data > 60) time_error = 2;  
17894:  MOVF   x35,W
17896:  SUBLW  3C
17898:  BC    178A2
1789A:  MOVLW  02
1789C:  MOVLB  8
1789E:  MOVWF  x95
178A0:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
178A2:  MOVLB  8
178A4:  MOVF   x93,W
178A6:  MULLW  0A
178A8:  MOVF   FF3,W
178AA:  ADDWF  x94,W
178AC:  MOVLB  7
178AE:  MOVWF  x34
....................       if (RTC_Sec_Data > 60) time_error = 2; 
178B0:  MOVF   x34,W
178B2:  SUBLW  3C
178B4:  BC    178BE
178B6:  MOVLW  02
178B8:  MOVLB  8
178BA:  MOVWF  x95
178BC:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
178BE:  MOVF   4F,F
178C0:  BTFSS  FD8.2
178C2:  BRA    179B6
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
178C4:  MOVLW  0A
178C6:  BTFSS  F9E.4
178C8:  BRA    178C6
178CA:  MOVWF  FAD
178CC:  MOVLW  0D
178CE:  BTFSS  F9E.4
178D0:  BRA    178CE
178D2:  MOVWF  FAD
178D4:  CLRF   1B
178D6:  BTFSC  FF2.7
178D8:  BSF    1B.7
178DA:  BCF    FF2.7
178DC:  MOVFF  738,A40
178E0:  MOVLW  01
178E2:  MOVLB  A
178E4:  MOVWF  x41
178E6:  MOVLB  0
178E8:  CALL   0FA6
178EC:  BTFSC  1B.7
178EE:  BSF    FF2.7
178F0:  MOVLW  2F
178F2:  BTFSS  F9E.4
178F4:  BRA    178F2
178F6:  MOVWF  FAD
178F8:  CLRF   1B
178FA:  BTFSC  FF2.7
178FC:  BSF    1B.7
178FE:  BCF    FF2.7
17900:  MOVFF  737,A40
17904:  MOVLW  01
17906:  MOVLB  A
17908:  MOVWF  x41
1790A:  MOVLB  0
1790C:  CALL   0FA6
17910:  BTFSC  1B.7
17912:  BSF    FF2.7
17914:  MOVLW  2F
17916:  BTFSS  F9E.4
17918:  BRA    17916
1791A:  MOVWF  FAD
1791C:  CLRF   1B
1791E:  BTFSC  FF2.7
17920:  BSF    1B.7
17922:  BCF    FF2.7
17924:  MOVFF  739,A40
17928:  MOVLW  01
1792A:  MOVLB  A
1792C:  MOVWF  x41
1792E:  MOVLB  0
17930:  CALL   0FA6
17934:  BTFSC  1B.7
17936:  BSF    FF2.7
17938:  MOVLW  20
1793A:  BTFSS  F9E.4
1793C:  BRA    1793A
1793E:  MOVWF  FAD
17940:  CLRF   1B
17942:  BTFSC  FF2.7
17944:  BSF    1B.7
17946:  BCF    FF2.7
17948:  MOVFF  736,A40
1794C:  MOVLW  01
1794E:  MOVLB  A
17950:  MOVWF  x41
17952:  MOVLB  0
17954:  CALL   0FA6
17958:  BTFSC  1B.7
1795A:  BSF    FF2.7
1795C:  MOVLW  3A
1795E:  BTFSS  F9E.4
17960:  BRA    1795E
17962:  MOVWF  FAD
17964:  CLRF   1B
17966:  BTFSC  FF2.7
17968:  BSF    1B.7
1796A:  BCF    FF2.7
1796C:  MOVFF  735,A40
17970:  MOVLW  01
17972:  MOVLB  A
17974:  MOVWF  x41
17976:  MOVLB  0
17978:  CALL   0FA6
1797C:  BTFSC  1B.7
1797E:  BSF    FF2.7
17980:  MOVLW  3A
17982:  BTFSS  F9E.4
17984:  BRA    17982
17986:  MOVWF  FAD
17988:  CLRF   1B
1798A:  BTFSC  FF2.7
1798C:  BSF    1B.7
1798E:  BCF    FF2.7
17990:  MOVFF  734,A40
17994:  MOVLW  01
17996:  MOVLB  A
17998:  MOVWF  x41
1799A:  MOVLB  0
1799C:  CALL   0FA6
179A0:  BTFSC  1B.7
179A2:  BSF    FF2.7
179A4:  MOVLW  0A
179A6:  BTFSS  F9E.4
179A8:  BRA    179A6
179AA:  MOVWF  FAD
179AC:  MOVLW  0D
179AE:  BTFSS  F9E.4
179B0:  BRA    179AE
179B2:  MOVWF  FAD
179B4:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
179B6:  DECFSZ 4F,W
179B8:  BRA    17AAC
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
179BA:  MOVLW  0A
179BC:  BTFSS  F9E.4
179BE:  BRA    179BC
179C0:  MOVWF  FAD
179C2:  MOVLW  0D
179C4:  BTFSS  F9E.4
179C6:  BRA    179C4
179C8:  MOVWF  FAD
179CA:  CLRF   1B
179CC:  BTFSC  FF2.7
179CE:  BSF    1B.7
179D0:  BCF    FF2.7
179D2:  MOVFF  737,A40
179D6:  MOVLW  01
179D8:  MOVLB  A
179DA:  MOVWF  x41
179DC:  MOVLB  0
179DE:  CALL   0FA6
179E2:  BTFSC  1B.7
179E4:  BSF    FF2.7
179E6:  MOVLW  2F
179E8:  BTFSS  F9E.4
179EA:  BRA    179E8
179EC:  MOVWF  FAD
179EE:  CLRF   1B
179F0:  BTFSC  FF2.7
179F2:  BSF    1B.7
179F4:  BCF    FF2.7
179F6:  MOVFF  738,A40
179FA:  MOVLW  01
179FC:  MOVLB  A
179FE:  MOVWF  x41
17A00:  MOVLB  0
17A02:  CALL   0FA6
17A06:  BTFSC  1B.7
17A08:  BSF    FF2.7
17A0A:  MOVLW  2F
17A0C:  BTFSS  F9E.4
17A0E:  BRA    17A0C
17A10:  MOVWF  FAD
17A12:  CLRF   1B
17A14:  BTFSC  FF2.7
17A16:  BSF    1B.7
17A18:  BCF    FF2.7
17A1A:  MOVFF  739,A40
17A1E:  MOVLW  01
17A20:  MOVLB  A
17A22:  MOVWF  x41
17A24:  MOVLB  0
17A26:  CALL   0FA6
17A2A:  BTFSC  1B.7
17A2C:  BSF    FF2.7
17A2E:  MOVLW  20
17A30:  BTFSS  F9E.4
17A32:  BRA    17A30
17A34:  MOVWF  FAD
17A36:  CLRF   1B
17A38:  BTFSC  FF2.7
17A3A:  BSF    1B.7
17A3C:  BCF    FF2.7
17A3E:  MOVFF  736,A40
17A42:  MOVLW  01
17A44:  MOVLB  A
17A46:  MOVWF  x41
17A48:  MOVLB  0
17A4A:  CALL   0FA6
17A4E:  BTFSC  1B.7
17A50:  BSF    FF2.7
17A52:  MOVLW  3A
17A54:  BTFSS  F9E.4
17A56:  BRA    17A54
17A58:  MOVWF  FAD
17A5A:  CLRF   1B
17A5C:  BTFSC  FF2.7
17A5E:  BSF    1B.7
17A60:  BCF    FF2.7
17A62:  MOVFF  735,A40
17A66:  MOVLW  01
17A68:  MOVLB  A
17A6A:  MOVWF  x41
17A6C:  MOVLB  0
17A6E:  CALL   0FA6
17A72:  BTFSC  1B.7
17A74:  BSF    FF2.7
17A76:  MOVLW  3A
17A78:  BTFSS  F9E.4
17A7A:  BRA    17A78
17A7C:  MOVWF  FAD
17A7E:  CLRF   1B
17A80:  BTFSC  FF2.7
17A82:  BSF    1B.7
17A84:  BCF    FF2.7
17A86:  MOVFF  734,A40
17A8A:  MOVLW  01
17A8C:  MOVLB  A
17A8E:  MOVWF  x41
17A90:  MOVLB  0
17A92:  CALL   0FA6
17A96:  BTFSC  1B.7
17A98:  BSF    FF2.7
17A9A:  MOVLW  0A
17A9C:  BTFSS  F9E.4
17A9E:  BRA    17A9C
17AA0:  MOVWF  FAD
17AA2:  MOVLW  0D
17AA4:  BTFSS  F9E.4
17AA6:  BRA    17AA4
17AA8:  MOVWF  FAD
17AAA:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
17AAC:  MOVLB  8
17AAE:  MOVF   x95,W
17AB0:  SUBLW  02
17AB2:  BNZ   17ABA
17AB4:  MOVLB  0
17AB6:  BRA    176F2
17AB8:  MOVLB  8
....................  
....................    } 
17ABA:  BRA    17AC4
....................    else cmd_arg(); 
17ABC:  MOVLB  0
17ABE:  CALL   B2C2
17AC2:  MOVLB  8
....................     
....................    return time_error; 
17AC4:  MOVFF  895,01
17AC8:  MOVLB  0
17ACA:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
17B0A:  RCALL  17712
17B0C:  MOVFF  01,885
....................     
....................    if (time_error ==0 ){ 
17B10:  MOVLB  8
17B12:  MOVF   x85,F
17B14:  BTFSS  FD8.2
17B16:  BRA    17C4E
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
17B18:  BCF    FC6.5
17B1A:  MOVLW  21
17B1C:  MOVWF  FC6
17B1E:  MOVLW  40
17B20:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
17B22:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
17B24:  MOVF   FC9,W
17B26:  MOVLW  86
17B28:  MOVWF  FC9
17B2A:  RRCF   FC7,W
17B2C:  BNC   17B2A
17B2E:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
17B32:  MOVFF  738,887
17B36:  MOVLB  0
17B38:  RCALL  17ACC
17B3A:  MOVFF  01,887
17B3E:  MOVF   FC9,W
17B40:  MOVFF  01,FC9
17B44:  RRCF   FC7,W
17B46:  BNC   17B44
17B48:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17B4C:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17B4E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
17B50:  MOVF   FC9,W
17B52:  MOVLW  85
17B54:  MOVWF  FC9
17B56:  RRCF   FC7,W
17B58:  BNC   17B56
17B5A:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
17B5E:  MOVFF  737,887
17B62:  RCALL  17ACC
17B64:  MOVFF  01,887
17B68:  MOVF   FC9,W
17B6A:  MOVFF  01,FC9
17B6E:  RRCF   FC7,W
17B70:  BNC   17B6E
17B72:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17B76:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17B78:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
17B7A:  MOVF   FC9,W
17B7C:  MOVLW  87
17B7E:  MOVWF  FC9
17B80:  RRCF   FC7,W
17B82:  BNC   17B80
17B84:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
17B88:  MOVFF  739,887
17B8C:  RCALL  17ACC
17B8E:  MOVFF  01,887
17B92:  MOVF   FC9,W
17B94:  MOVFF  01,FC9
17B98:  RRCF   FC7,W
17B9A:  BNC   17B98
17B9C:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17BA0:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17BA2:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
17BA4:  MOVF   FC9,W
17BA6:  MOVLW  83
17BA8:  MOVWF  FC9
17BAA:  RRCF   FC7,W
17BAC:  BNC   17BAA
17BAE:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
17BB2:  MOVFF  736,887
17BB6:  RCALL  17ACC
17BB8:  MOVFF  01,887
17BBC:  MOVF   FC9,W
17BBE:  MOVFF  01,FC9
17BC2:  RRCF   FC7,W
17BC4:  BNC   17BC2
17BC6:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17BCA:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17BCC:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
17BCE:  MOVF   FC9,W
17BD0:  MOVLW  82
17BD2:  MOVWF  FC9
17BD4:  RRCF   FC7,W
17BD6:  BNC   17BD4
17BD8:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
17BDC:  MOVFF  735,887
17BE0:  RCALL  17ACC
17BE2:  MOVFF  01,887
17BE6:  MOVF   FC9,W
17BE8:  MOVFF  01,FC9
17BEC:  RRCF   FC7,W
17BEE:  BNC   17BEC
17BF0:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17BF4:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17BF6:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
17BF8:  MOVF   FC9,W
17BFA:  MOVLW  81
17BFC:  MOVWF  FC9
17BFE:  RRCF   FC7,W
17C00:  BNC   17BFE
17C02:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
17C06:  MOVFF  734,887
17C0A:  RCALL  17ACC
17C0C:  MOVFF  01,887
17C10:  MOVF   FC9,W
17C12:  MOVFF  01,FC9
17C16:  RRCF   FC7,W
17C18:  BNC   17C16
17C1A:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C1E:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C20:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
17C22:  MOVF   FC9,W
17C24:  MOVLW  80
17C26:  MOVWF  FC9
17C28:  RRCF   FC7,W
17C2A:  BNC   17C28
17C2C:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
17C30:  MOVLB  8
17C32:  CLRF   x87
17C34:  MOVLB  0
17C36:  RCALL  17ACC
17C38:  MOVFF  01,887
17C3C:  MOVF   FC9,W
17C3E:  MOVFF  01,FC9
17C42:  RRCF   FC7,W
17C44:  BNC   17C42
17C46:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C4A:  BSF    F91.0
17C4C:  MOVLB  8
....................    } 
17C4E:  MOVLB  0
17C50:  GOTO   17CDC (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
188BA:  CALL   E3D8
....................     
....................    time_error = get_time(); 
188BE:  CALL   17712
188C2:  MOVFF  01,885
....................     
....................    if (time_error == 0 ){ 
188C6:  MOVLB  8
188C8:  MOVF   x85,F
188CA:  BTFSS  FD8.2
188CC:  BRA    18A44
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
188CE:  MOVFF  739,72D
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
188D2:  MOVLW  04
188D4:  MOVWF  x89
188D6:  MOVFF  72D,88A
188DA:  MOVLB  0
188DC:  CALL   3412
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
188E0:  MOVFF  738,887
188E4:  CALL   17ACC
188E8:  MOVFF  01,738
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
188EC:  MOVLB  7
188EE:  BSF    x38.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
188F0:  BCF    FC6.5
188F2:  MOVLW  21
188F4:  MOVWF  FC6
188F6:  MOVLW  40
188F8:  MOVWF  FC7
....................       delay_us(10); 
188FA:  MOVLW  35
188FC:  MOVWF  00
188FE:  DECFSZ 00,F
18900:  BRA    188FE
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
18902:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
18904:  MOVF   FC9,W
18906:  MOVLW  8E
18908:  MOVWF  FC9
1890A:  RRCF   FC7,W
1890C:  BNC   1890A
1890E:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
18912:  MOVFF  734,887
18916:  MOVLB  0
18918:  CALL   17ACC
1891C:  MOVFF  01,887
18920:  MOVF   FC9,W
18922:  MOVFF  01,FC9
18926:  RRCF   FC7,W
18928:  BNC   18926
1892A:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
1892E:  BSF    F91.0
....................       delay_us(1); // Delays added 1.020A 
18930:  MOVLW  05
18932:  MOVWF  00
18934:  DECFSZ 00,F
18936:  BRA    18934
....................        
....................       output_bit(RTC_CS, ENABLE); 
18938:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
1893A:  MOVF   FC9,W
1893C:  MOVLW  8D
1893E:  MOVWF  FC9
18940:  RRCF   FC7,W
18942:  BNC   18940
18944:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
18948:  MOVFF  735,887
1894C:  CALL   17ACC
18950:  MOVFF  01,887
18954:  MOVF   FC9,W
18956:  MOVFF  01,FC9
1895A:  RRCF   FC7,W
1895C:  BNC   1895A
1895E:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18962:  BSF    F91.0
....................       delay_us(1); 
18964:  MOVLW  05
18966:  MOVWF  00
18968:  DECFSZ 00,F
1896A:  BRA    18968
....................        
....................       output_bit(RTC_CS, ENABLE); 
1896C:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
1896E:  MOVF   FC9,W
18970:  MOVLW  8C
18972:  MOVWF  FC9
18974:  RRCF   FC7,W
18976:  BNC   18974
18978:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
1897C:  MOVFF  736,887
18980:  CALL   17ACC
18984:  MOVFF  01,887
18988:  MOVF   FC9,W
1898A:  MOVFF  01,FC9
1898E:  RRCF   FC7,W
18990:  BNC   1898E
18992:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18996:  BSF    F91.0
....................       delay_us(1);  
18998:  MOVLW  05
1899A:  MOVWF  00
1899C:  DECFSZ 00,F
1899E:  BRA    1899C
....................        
....................       output_bit(RTC_CS, ENABLE); 
189A0:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
189A2:  MOVF   FC9,W
189A4:  MOVLW  8B
189A6:  MOVWF  FC9
189A8:  RRCF   FC7,W
189AA:  BNC   189A8
189AC:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
189B0:  MOVFF  737,887
189B4:  CALL   17ACC
189B8:  MOVFF  01,887
189BC:  MOVF   FC9,W
189BE:  MOVFF  01,FC9
189C2:  RRCF   FC7,W
189C4:  BNC   189C2
189C6:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE);  
189CA:  BSF    F91.0
....................       delay_us(1); 
189CC:  MOVLW  05
189CE:  MOVWF  00
189D0:  DECFSZ 00,F
189D2:  BRA    189D0
....................        
....................       output_bit(RTC_CS, ENABLE); 
189D4:  BCF    F91.0
....................       //fprintf(COM_A,"test61\r\n"); 
....................       RTC_buffer = spi_read(0x8A);// address - Month 
189D6:  MOVF   FC9,W
189D8:  MOVLW  8A
189DA:  MOVWF  FC9
189DC:  RRCF   FC7,W
189DE:  BNC   189DC
189E0:  MOVFF  FC9,886
....................       //fprintf(COM_A,"test62\r\n"); 
....................       fprintf(COM_A,"test6: %d\r\n",RTC_Mon_Data); 
189E4:  MOVLW  C4
189E6:  MOVWF  FF6
189E8:  MOVLW  0D
189EA:  MOVWF  FF7
189EC:  MOVLW  00
189EE:  MOVWF  FF8
189F0:  CLRF   1B
189F2:  BTFSC  FF2.7
189F4:  BSF    1B.7
189F6:  BCF    FF2.7
189F8:  MOVLW  07
189FA:  MOVLB  A
189FC:  MOVWF  x40
189FE:  MOVLB  0
18A00:  CALL   1024
18A04:  BTFSC  1B.7
18A06:  BSF    FF2.7
18A08:  MOVFF  738,887
18A0C:  MOVLW  18
18A0E:  MOVLB  8
18A10:  MOVWF  x88
18A12:  MOVLB  0
18A14:  BRA    187DA
18A16:  MOVLW  0D
18A18:  BTFSS  F9E.4
18A1A:  BRA    18A18
18A1C:  MOVWF  FAD
18A1E:  MOVLW  0A
18A20:  BTFSS  F9E.4
18A22:  BRA    18A20
18A24:  MOVWF  FAD
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
18A26:  MOVF   FC9,W
18A28:  MOVFF  738,FC9
18A2C:  RRCF   FC7,W
18A2E:  BNC   18A2C
18A30:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18A34:  BSF    F91.0
....................       delay_us(1); 
18A36:  MOVLW  05
18A38:  MOVWF  00
18A3A:  DECFSZ 00,F
18A3C:  BRA    18A3A
....................       //fprintf(COM_A,"test6\r\n"); 
....................     
....................    RTC_read_alarm(); 
18A3E:  CALL   E3D8
18A42:  MOVLB  8
....................    } 
18A44:  MOVLB  0
18A46:  GOTO   18A5C (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15EA2:  BCF    FC6.5
15EA4:  MOVLW  21
15EA6:  MOVWF  FC6
15EA8:  MOVLW  40
15EAA:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15EAC:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15EAE:  MOVF   FC9,W
15EB0:  MOVLW  8E
15EB2:  MOVWF  FC9
15EB4:  RRCF   FC7,W
15EB6:  BNC   15EB4
15EB8:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b00000000);  // data 
15EBC:  MOVF   FC9,W
15EBE:  CLRF   FC9
15EC0:  RRCF   FC7,W
15EC2:  BNC   15EC0
15EC4:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15EC8:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15ECA:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15ECC:  MOVF   FC9,W
15ECE:  MOVLW  8D
15ED0:  MOVWF  FC9
15ED2:  RRCF   FC7,W
15ED4:  BNC   15ED2
15ED6:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15EDA:  MOVF   FC9,W
15EDC:  MOVLW  80
15EDE:  MOVWF  FC9
15EE0:  RRCF   FC7,W
15EE2:  BNC   15EE0
15EE4:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15EE8:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15EEA:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15EEC:  MOVF   FC9,W
15EEE:  MOVLW  8C
15EF0:  MOVWF  FC9
15EF2:  RRCF   FC7,W
15EF4:  BNC   15EF2
15EF6:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15EFA:  MOVF   FC9,W
15EFC:  MOVLW  80
15EFE:  MOVWF  FC9
15F00:  RRCF   FC7,W
15F02:  BNC   15F00
15F04:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F08:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F0A:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15F0C:  MOVF   FC9,W
15F0E:  MOVLW  8B
15F10:  MOVWF  FC9
15F12:  RRCF   FC7,W
15F14:  BNC   15F12
15F16:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b11000000);  // data 
15F1A:  MOVF   FC9,W
15F1C:  MOVLW  C0
15F1E:  MOVWF  FC9
15F20:  RRCF   FC7,W
15F22:  BNC   15F20
15F24:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE);    
15F28:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F2A:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15F2C:  MOVF   FC9,W
15F2E:  MOVLW  8A
15F30:  MOVWF  FC9
15F32:  RRCF   FC7,W
15F34:  BNC   15F32
15F36:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F3A:  MOVF   FC9,W
15F3C:  MOVLW  80
15F3E:  MOVWF  FC9
15F40:  RRCF   FC7,W
15F42:  BNC   15F40
15F44:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F48:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15F4A:  CALL   E3D8
15F4E:  GOTO   16D0E (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
156E0:  MOVLB  8
156E2:  CLRF   x87
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
156E4:  BCF    FC6.5
156E6:  MOVLW  21
156E8:  MOVWF  FC6
156EA:  MOVLW  40
156EC:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
156EE:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
156F0:  MOVF   FC9,W
156F2:  MOVLW  0A
156F4:  MOVWF  FC9
156F6:  RRCF   FC7,W
156F8:  BNC   156F6
156FA:  MOVFF  FC9,887
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
156FE:  MOVF   FC9,W
15700:  MOVFF  887,FC9
15704:  RRCF   FC7,W
15706:  BNC   15704
15708:  MOVFF  FC9,72E
....................    output_bit(RTC_CS, DISABLE); 
1570C:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
1570E:  MOVLB  7
15710:  BSF    x2E.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15712:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15714:  MOVF   FC9,W
15716:  MOVLW  8A
15718:  MOVWF  FC9
1571A:  RRCF   FC7,W
1571C:  BNC   1571A
1571E:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
15722:  MOVF   FC9,W
15724:  MOVFF  72E,FC9
15728:  RRCF   FC7,W
1572A:  BNC   15728
1572C:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15730:  BSF    F91.0
15732:  MOVLB  0
15734:  GOTO   16C38 (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
03442:  MOVFF  725,73F
....................    rtc_last_min   = RTC_Min_Reg; 
03446:  MOVFF  726,73E
....................    rtc_last_hour  = RTC_Hr_Reg; 
0344A:  MOVFF  727,73D
....................    rtc_last_day   = RTC_DOM_Reg; 
0344E:  MOVFF  729,73B
....................    rtc_last_month = RTC_Mon_Reg; 
03452:  MOVFF  72A,73A
....................    rtc_last_year  = RTC_Yr_Reg; 
03456:  MOVFF  72B,73C
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
0345A:  MOVLW  06
0345C:  MOVLB  8
0345E:  MOVWF  x89
03460:  MOVFF  73A,88A
03464:  MOVLB  0
03466:  RCALL  3412
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
03468:  MOVLW  08
0346A:  MOVLB  8
0346C:  MOVWF  x89
0346E:  MOVFF  73B,88A
03472:  MOVLB  0
03474:  RCALL  3412
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
03476:  MOVLW  0A
03478:  MOVLB  8
0347A:  MOVWF  x89
0347C:  MOVFF  73C,88A
03480:  MOVLB  0
03482:  RCALL  3412
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
03484:  MOVLW  0C
03486:  MOVLB  8
03488:  MOVWF  x89
0348A:  MOVFF  73D,88A
0348E:  MOVLB  0
03490:  RCALL  3412
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
03492:  MOVLW  0E
03494:  MOVLB  8
03496:  MOVWF  x89
03498:  MOVFF  73E,88A
0349C:  MOVLB  0
0349E:  RCALL  3412
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
034A0:  MOVLW  10
034A2:  MOVLB  8
034A4:  MOVWF  x89
034A6:  MOVFF  73F,88A
034AA:  MOVLB  0
034AC:  RCALL  3412
034AE:  GOTO   1B84C (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
15738:  MOVLB  8
1573A:  CLRF   x8A
1573C:  CLRF   x89
1573E:  CLRF   x88
15740:  CLRF   x87
15742:  CLRF   x8E
15744:  CLRF   x8D
15746:  CLRF   x8C
15748:  CLRF   x8B
1574A:  CLRF   x92
1574C:  CLRF   x91
1574E:  CLRF   x90
15750:  CLRF   x8F
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
15752:  CLRF   x9F
15754:  CLRF   xA0
15756:  MOVLW  1F
15758:  MOVWF  xA1
1575A:  CLRF   xA2
1575C:  MOVLW  3B
1575E:  MOVWF  xA3
15760:  CLRF   xA4
15762:  MOVLW  5A
15764:  MOVWF  xA5
15766:  CLRF   xA6
15768:  MOVLW  78
1576A:  MOVWF  xA7
1576C:  CLRF   xA8
1576E:  MOVLW  97
15770:  MOVWF  xA9
15772:  CLRF   xAA
15774:  MOVLW  B5
15776:  MOVWF  xAB
15778:  CLRF   xAC
1577A:  MOVLW  D4
1577C:  MOVWF  xAD
1577E:  CLRF   xAE
15780:  MOVLW  F3
15782:  MOVWF  xAF
15784:  CLRF   xB0
15786:  MOVLW  11
15788:  MOVWF  xB1
1578A:  MOVLW  01
1578C:  MOVWF  xB2
1578E:  MOVLW  30
15790:  MOVWF  xB3
15792:  MOVLW  01
15794:  MOVWF  xB4
15796:  MOVLW  4E
15798:  MOVWF  xB5
1579A:  MOVLW  01
1579C:  MOVWF  xB6
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
1579E:  BCF    4D.3
....................     
....................    RTC_read(); 
157A0:  MOVLB  0
157A2:  CALL   3344
....................    RTC_read_alarm(); 
157A6:  CALL   E3D8
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
157AA:  MOVLW  04
157AC:  MOVLB  8
157AE:  MOVWF  xB7
157B0:  MOVLB  0
157B2:  CALL   2A24
157B6:  MOVFF  01,72D
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
157BA:  MOVLB  7
157BC:  MOVF   x2B,W
157BE:  SUBWF  x2D,W
157C0:  BC    157C6
157C2:  BSF    4D.3
157C4:  BRA    15BFA
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
157C6:  MOVF   x2D,W
157C8:  SUBWF  x2B,W
157CA:  BTFSS  FD8.2
157CC:  BRA    15BFA
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
157CE:  MOVLW  01
157D0:  SUBWF  x2A,W
157D2:  MOVWF  00
157D4:  BCF    FD8.0
157D6:  RLCF   00,F
157D8:  MOVF   00,W
157DA:  CLRF   03
157DC:  ADDLW  9F
157DE:  MOVWF  FE9
157E0:  MOVLW  08
157E2:  ADDWFC 03,W
157E4:  MOVWF  FEA
157E6:  MOVFF  FEC,03
157EA:  MOVF   FED,F
157EC:  MOVFF  FEF,917
157F0:  MOVFF  03,918
157F4:  MOVLB  0
157F6:  CALL   C8BA
157FA:  MOVFF  03,88A
157FE:  MOVFF  02,889
15802:  MOVFF  01,888
15806:  MOVFF  00,887
....................          time_now = time_now + RTC_DOM_Reg; 
1580A:  MOVLB  9
1580C:  CLRF   x18
1580E:  MOVFF  729,917
15812:  MOVLB  0
15814:  CALL   C8BA
15818:  BCF    FD8.1
1581A:  MOVFF  88A,91A
1581E:  MOVFF  889,919
15822:  MOVFF  888,918
15826:  MOVFF  887,917
1582A:  MOVFF  03,91E
1582E:  MOVFF  02,91D
15832:  MOVFF  01,91C
15836:  MOVFF  00,91B
1583A:  CALL   C37E
1583E:  MOVFF  03,88A
15842:  MOVFF  02,889
15846:  MOVFF  01,888
1584A:  MOVFF  00,887
....................           
....................          hour = RTC_Hr_Reg; 
1584E:  MOVLB  9
15850:  CLRF   x18
15852:  MOVFF  727,917
15856:  MOVLB  0
15858:  CALL   C8BA
1585C:  MOVFF  03,896
15860:  MOVFF  02,895
15864:  MOVFF  01,894
15868:  MOVFF  00,893
....................          minute = RTC_Min_Reg; 
1586C:  MOVLB  9
1586E:  CLRF   x18
15870:  MOVFF  726,917
15874:  MOVLB  0
15876:  CALL   C8BA
1587A:  MOVFF  03,89A
1587E:  MOVFF  02,899
15882:  MOVFF  01,898
15886:  MOVFF  00,897
....................          second = RTC_Sec_Reg; 
1588A:  MOVLB  9
1588C:  CLRF   x18
1588E:  MOVFF  725,917
15892:  MOVLB  0
15894:  CALL   C8BA
15898:  MOVFF  03,89E
1589C:  MOVFF  02,89D
158A0:  MOVFF  01,89C
158A4:  MOVFF  00,89B
....................           
....................          fraction_of_day = (hour / 24); 
158A8:  MOVFF  896,8FE
158AC:  MOVFF  895,8FD
158B0:  MOVFF  894,8FC
158B4:  MOVFF  893,8FB
158B8:  MOVLB  9
158BA:  CLRF   x02
158BC:  CLRF   x01
158BE:  MOVLW  40
158C0:  MOVWF  x00
158C2:  MOVLW  83
158C4:  MOVLB  8
158C6:  MOVWF  xFF
158C8:  MOVLB  0
158CA:  CALL   C8F0
158CE:  MOVFF  03,892
158D2:  MOVFF  02,891
158D6:  MOVFF  01,890
158DA:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
158DE:  MOVFF  89A,8FE
158E2:  MOVFF  899,8FD
158E6:  MOVFF  898,8FC
158EA:  MOVFF  897,8FB
158EE:  MOVLB  9
158F0:  CLRF   x02
158F2:  CLRF   x01
158F4:  MOVLW  34
158F6:  MOVWF  x00
158F8:  MOVLW  89
158FA:  MOVLB  8
158FC:  MOVWF  xFF
158FE:  MOVLB  0
15900:  CALL   C8F0
15904:  BCF    FD8.1
15906:  MOVFF  892,91A
1590A:  MOVFF  891,919
1590E:  MOVFF  890,918
15912:  MOVFF  88F,917
15916:  MOVFF  03,91E
1591A:  MOVFF  02,91D
1591E:  MOVFF  01,91C
15922:  MOVFF  00,91B
15926:  CALL   C37E
1592A:  MOVFF  03,892
1592E:  MOVFF  02,891
15932:  MOVFF  01,890
15936:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
1593A:  MOVFF  89E,8FE
1593E:  MOVFF  89D,8FD
15942:  MOVFF  89C,8FC
15946:  MOVFF  89B,8FB
1594A:  MOVLB  9
1594C:  CLRF   x02
1594E:  MOVLW  C0
15950:  MOVWF  x01
15952:  MOVLW  28
15954:  MOVWF  x00
15956:  MOVLW  8F
15958:  MOVLB  8
1595A:  MOVWF  xFF
1595C:  MOVLB  0
1595E:  CALL   C8F0
15962:  BCF    FD8.1
15964:  MOVFF  892,91A
15968:  MOVFF  891,919
1596C:  MOVFF  890,918
15970:  MOVFF  88F,917
15974:  MOVFF  03,91E
15978:  MOVFF  02,91D
1597C:  MOVFF  01,91C
15980:  MOVFF  00,91B
15984:  CALL   C37E
15988:  MOVFF  03,892
1598C:  MOVFF  02,891
15990:  MOVFF  01,890
15994:  MOVFF  00,88F
....................           
....................          time_now = time_now + fraction_of_day; 
15998:  BCF    FD8.1
1599A:  MOVFF  88A,91A
1599E:  MOVFF  889,919
159A2:  MOVFF  888,918
159A6:  MOVFF  887,917
159AA:  MOVFF  892,91E
159AE:  MOVFF  891,91D
159B2:  MOVFF  890,91C
159B6:  MOVFF  88F,91B
159BA:  CALL   C37E
159BE:  MOVFF  03,88A
159C2:  MOVFF  02,889
159C6:  MOVFF  01,888
159CA:  MOVFF  00,887
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
159CE:  MOVLB  9
159D0:  CLRF   x18
159D2:  MOVFF  730,917
159D6:  MOVLB  0
159D8:  CALL   C8BA
159DC:  MOVFF  03,896
159E0:  MOVFF  02,895
159E4:  MOVFF  01,894
159E8:  MOVFF  00,893
....................          minute = RTC_Al_Min_Reg; 
159EC:  MOVLB  9
159EE:  CLRF   x18
159F0:  MOVFF  731,917
159F4:  MOVLB  0
159F6:  CALL   C8BA
159FA:  MOVFF  03,89A
159FE:  MOVFF  02,899
15A02:  MOVFF  01,898
15A06:  MOVFF  00,897
....................          second = RTC_Al_Sec_Reg; 
15A0A:  MOVLB  9
15A0C:  CLRF   x18
15A0E:  MOVFF  732,917
15A12:  MOVLB  0
15A14:  CALL   C8BA
15A18:  MOVFF  03,89E
15A1C:  MOVFF  02,89D
15A20:  MOVFF  01,89C
15A24:  MOVFF  00,89B
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
15A28:  MOVLW  01
15A2A:  MOVLB  7
15A2C:  SUBWF  x2E,W
15A2E:  MOVWF  00
15A30:  BCF    FD8.0
15A32:  RLCF   00,F
15A34:  MOVF   00,W
15A36:  CLRF   03
15A38:  ADDLW  9F
15A3A:  MOVWF  FE9
15A3C:  MOVLW  08
15A3E:  ADDWFC 03,W
15A40:  MOVWF  FEA
15A42:  MOVFF  FEC,03
15A46:  MOVF   FED,F
15A48:  MOVFF  FEF,917
15A4C:  MOVFF  03,918
15A50:  MOVLB  0
15A52:  CALL   C8BA
15A56:  MOVFF  03,88E
15A5A:  MOVFF  02,88D
15A5E:  MOVFF  01,88C
15A62:  MOVFF  00,88B
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
15A66:  MOVLB  9
15A68:  CLRF   x18
15A6A:  MOVFF  72F,917
15A6E:  MOVLB  0
15A70:  CALL   C8BA
15A74:  BCF    FD8.1
15A76:  MOVFF  88E,91A
15A7A:  MOVFF  88D,919
15A7E:  MOVFF  88C,918
15A82:  MOVFF  88B,917
15A86:  MOVFF  03,91E
15A8A:  MOVFF  02,91D
15A8E:  MOVFF  01,91C
15A92:  MOVFF  00,91B
15A96:  CALL   C37E
15A9A:  MOVFF  03,88E
15A9E:  MOVFF  02,88D
15AA2:  MOVFF  01,88C
15AA6:  MOVFF  00,88B
....................           
....................          fraction_of_day = (hour / 24); 
15AAA:  MOVFF  896,8FE
15AAE:  MOVFF  895,8FD
15AB2:  MOVFF  894,8FC
15AB6:  MOVFF  893,8FB
15ABA:  MOVLB  9
15ABC:  CLRF   x02
15ABE:  CLRF   x01
15AC0:  MOVLW  40
15AC2:  MOVWF  x00
15AC4:  MOVLW  83
15AC6:  MOVLB  8
15AC8:  MOVWF  xFF
15ACA:  MOVLB  0
15ACC:  CALL   C8F0
15AD0:  MOVFF  03,892
15AD4:  MOVFF  02,891
15AD8:  MOVFF  01,890
15ADC:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15AE0:  MOVFF  89A,8FE
15AE4:  MOVFF  899,8FD
15AE8:  MOVFF  898,8FC
15AEC:  MOVFF  897,8FB
15AF0:  MOVLB  9
15AF2:  CLRF   x02
15AF4:  CLRF   x01
15AF6:  MOVLW  34
15AF8:  MOVWF  x00
15AFA:  MOVLW  89
15AFC:  MOVLB  8
15AFE:  MOVWF  xFF
15B00:  MOVLB  0
15B02:  CALL   C8F0
15B06:  BCF    FD8.1
15B08:  MOVFF  892,91A
15B0C:  MOVFF  891,919
15B10:  MOVFF  890,918
15B14:  MOVFF  88F,917
15B18:  MOVFF  03,91E
15B1C:  MOVFF  02,91D
15B20:  MOVFF  01,91C
15B24:  MOVFF  00,91B
15B28:  CALL   C37E
15B2C:  MOVFF  03,892
15B30:  MOVFF  02,891
15B34:  MOVFF  01,890
15B38:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15B3C:  MOVFF  89E,8FE
15B40:  MOVFF  89D,8FD
15B44:  MOVFF  89C,8FC
15B48:  MOVFF  89B,8FB
15B4C:  MOVLB  9
15B4E:  CLRF   x02
15B50:  MOVLW  C0
15B52:  MOVWF  x01
15B54:  MOVLW  28
15B56:  MOVWF  x00
15B58:  MOVLW  8F
15B5A:  MOVLB  8
15B5C:  MOVWF  xFF
15B5E:  MOVLB  0
15B60:  CALL   C8F0
15B64:  BCF    FD8.1
15B66:  MOVFF  892,91A
15B6A:  MOVFF  891,919
15B6E:  MOVFF  890,918
15B72:  MOVFF  88F,917
15B76:  MOVFF  03,91E
15B7A:  MOVFF  02,91D
15B7E:  MOVFF  01,91C
15B82:  MOVFF  00,91B
15B86:  CALL   C37E
15B8A:  MOVFF  03,892
15B8E:  MOVFF  02,891
15B92:  MOVFF  01,890
15B96:  MOVFF  00,88F
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
15B9A:  BCF    FD8.1
15B9C:  MOVFF  88E,91A
15BA0:  MOVFF  88D,919
15BA4:  MOVFF  88C,918
15BA8:  MOVFF  88B,917
15BAC:  MOVFF  892,91E
15BB0:  MOVFF  891,91D
15BB4:  MOVFF  890,91C
15BB8:  MOVFF  88F,91B
15BBC:  CALL   C37E
15BC0:  MOVFF  03,88E
15BC4:  MOVFF  02,88D
15BC8:  MOVFF  01,88C
15BCC:  MOVFF  00,88B
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
15BD0:  MOVFF  88E,916
15BD4:  MOVFF  88D,915
15BD8:  MOVFF  88C,914
15BDC:  MOVFF  88B,913
15BE0:  MOVFF  88A,91A
15BE4:  MOVFF  889,919
15BE8:  MOVFF  888,918
15BEC:  MOVFF  887,917
15BF0:  CALL   10730
15BF4:  BNC   15BF8
15BF6:  BSF    4D.3
15BF8:  MOVLB  7
....................       } 
....................    } 
15BFA:  MOVLB  0
15BFC:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
15BFE:  BTFSS  4D.3
15C00:  BRA    15C1E
15C02:  MOVLW  D0
15C04:  MOVWF  FF6
15C06:  MOVLW  0D
15C08:  MOVWF  FF7
15C0A:  MOVLW  00
15C0C:  MOVWF  FF8
15C0E:  CLRF   1B
15C10:  BTFSC  FF2.7
15C12:  BSF    1B.7
15C14:  BCF    FF2.7
15C16:  CALL   0E4E
15C1A:  BTFSC  1B.7
15C1C:  BSF    FF2.7
15C1E:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F53C:  BCF    F67.5
0F53E:  MOVLW  32
0F540:  MOVWF  F67
0F542:  MOVLW  40
0F544:  MOVWF  F68
....................     
....................    data = 0; 
0F546:  MOVLB  8
0F548:  CLRF   xD7
0F54A:  CLRF   xD6
....................     
....................    DAC_MS_byte = 0; 
0F54C:  CLRF   xD8
....................    DAC_LS_byte = 0; 
0F54E:  CLRF   xD9
....................     
....................    data = setting & 0b0000111100000000; 
0F550:  CLRF   xD6
0F552:  MOVF   xD5,W
0F554:  ANDLW  0F
0F556:  MOVWF  xD7
....................    data = data >> 8; 
0F558:  MOVFF  8D7,8D6
0F55C:  CLRF   xD7
....................    DAC_MS_byte = data; 
0F55E:  MOVFF  8D6,8D8
....................     
....................    data = setting & 0b0000000011111111; 
0F562:  MOVFF  8D4,8D6
0F566:  CLRF   xD7
....................    DAC_LS_byte = data; 
0F568:  MOVFF  8D6,8D9
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F56C:  MOVLW  01
0F56E:  SUBWF  xD3,W
0F570:  ADDLW  FC
0F572:  BC    F59E
0F574:  ADDLW  04
0F576:  MOVLB  0
0F578:  GOTO   F5BC
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F57C:  MOVLW  30
0F57E:  MOVLB  8
0F580:  IORWF  xD8,F
....................          break; 
0F582:  BRA    F59E
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F584:  MOVLW  70
0F586:  MOVLB  8
0F588:  IORWF  xD8,F
....................          break; 
0F58A:  BRA    F59E
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F58C:  MOVLW  B0
0F58E:  MOVLB  8
0F590:  IORWF  xD8,F
....................          break; 
0F592:  BRA    F59E
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F594:  MOVLW  F0
0F596:  MOVLB  8
0F598:  IORWF  xD8,F
....................          break; 
0F59A:  BRA    F59E
0F59C:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F59E:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F5A0:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F5A2:  MOVF   F6A,W
0F5A4:  MOVFF  8D8,F6A
0F5A8:  RRCF   F68,W
0F5AA:  BNC   F5A8
....................    spi_write2(DAC_LS_byte); 
0F5AC:  MOVF   F6A,W
0F5AE:  MOVFF  8D9,F6A
0F5B2:  RRCF   F68,W
0F5B4:  BNC   F5B2
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F5B6:  BSF    F8C.3
0F5B8:  MOVLB  0
0F5BA:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F5E4:  MOVLB  8
0F5E6:  CLRF   xD8
0F5E8:  CLRF   xD9
0F5EA:  CLRF   xDA
0F5EC:  CLRF   xDB
0F5EE:  CLRF   xDC
0F5F0:  CLRF   xDD
0F5F2:  CLRF   xDE
0F5F4:  CLRF   xDF
0F5F6:  CLRF   xE0
0F5F8:  CLRF   xE1
0F5FA:  CLRF   xE2
0F5FC:  CLRF   xE3
0F5FE:  CLRF   xE4
0F600:  CLRF   xE5
0F602:  CLRF   xE6
0F604:  CLRF   xE7
0F606:  CLRF   xE8
0F608:  CLRF   xE9
0F60A:  CLRF   xEA
0F60C:  CLRF   xEB
0F60E:  CLRF   xEC
0F610:  CLRF   xED
0F612:  CLRF   xEE
0F614:  CLRF   xEF
0F616:  CLRF   xF0
0F618:  CLRF   xF1
0F61A:  CLRF   xF2
0F61C:  CLRF   xF3
0F61E:  CLRF   xF4
0F620:  CLRF   xF5
0F622:  CLRF   xF6
0F624:  CLRF   xF7
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F626:  CLRF   xF8
0F628:  CLRF   xF9
0F62A:  CLRF   xFA
0F62C:  CLRF   xFB
0F62E:  CLRF   xFC
0F630:  CLRF   xFD
0F632:  CLRF   xFE
0F634:  CLRF   xFF
0F636:  MOVLB  9
0F638:  CLRF   x00
0F63A:  CLRF   x01
0F63C:  CLRF   x02
0F63E:  CLRF   x03
0F640:  CLRF   x04
0F642:  CLRF   x05
0F644:  CLRF   x06
0F646:  CLRF   x07
0F648:  CLRF   x08
0F64A:  CLRF   x09
0F64C:  CLRF   x0A
0F64E:  CLRF   x0B
0F650:  CLRF   x0C
0F652:  CLRF   x0D
0F654:  CLRF   x0E
0F656:  CLRF   x0F
0F658:  CLRF   x10
0F65A:  CLRF   x11
0F65C:  CLRF   x12
0F65E:  CLRF   x13
0F660:  CLRF   x14
0F662:  CLRF   x15
0F664:  CLRF   x16
0F666:  CLRF   x17
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F668:  MOVLB  8
0F66A:  CLRF   xD7
0F66C:  MOVLW  01
0F66E:  MOVWF  xD6
0F670:  MOVLW  01
0F672:  ADDWF  xD3,W
0F674:  MOVWF  01
0F676:  MOVLW  00
0F678:  ADDWFC xD4,W
0F67A:  MOVWF  03
0F67C:  MOVF   xD7,W
0F67E:  SUBWF  03,W
0F680:  BTFSS  FD8.0
0F682:  BRA    F76E
0F684:  BNZ   F68C
0F686:  MOVF   01,W
0F688:  SUBWF  xD6,W
0F68A:  BC    F76E
....................    { 
....................       for (n=1; n<5; ++n) 
0F68C:  MOVLW  01
0F68E:  MOVWF  xD5
0F690:  MOVF   xD5,W
0F692:  SUBLW  04
0F694:  BNC   F766
....................       { 
....................          set_adc_channel(n,VSS); 
0F696:  RLCF   xD5,W
0F698:  MOVWF  00
0F69A:  RLCF   00,F
0F69C:  MOVLW  FC
0F69E:  ANDWF  00,F
0F6A0:  MOVF   FC2,W
0F6A2:  ANDLW  83
0F6A4:  IORWF  00,W
0F6A6:  MOVWF  FC2
0F6A8:  MOVLW  00
0F6AA:  MOVWF  01
0F6AC:  MOVF   FC1,W
0F6AE:  ANDLW  F8
0F6B0:  IORWF  01,W
0F6B2:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F6B4:  MOVF   xD5,W
0F6B6:  MULLW  04
0F6B8:  MOVF   FF3,W
0F6BA:  CLRF   03
0F6BC:  ADDLW  F8
0F6BE:  MOVWF  FE9
0F6C0:  MOVLW  08
0F6C2:  ADDWFC 03,W
0F6C4:  MOVWF  FEA
0F6C6:  BSF    FC2.1
0F6C8:  BTFSC  FC2.1
0F6CA:  BRA    F6C8
0F6CC:  MOVFF  FC3,FEF
0F6D0:  MOVFF  FC4,FEC
0F6D4:  CLRF   FEC
0F6D6:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F6D8:  MOVF   xD5,W
0F6DA:  MULLW  04
0F6DC:  MOVF   FF3,W
0F6DE:  CLRF   03
0F6E0:  ADDLW  D8
0F6E2:  MOVWF  01
0F6E4:  MOVLW  08
0F6E6:  ADDWFC 03,F
0F6E8:  MOVFF  01,918
0F6EC:  MOVFF  03,919
0F6F0:  MOVLB  8
0F6F2:  MOVF   xD5,W
0F6F4:  MULLW  04
0F6F6:  MOVF   FF3,W
0F6F8:  CLRF   03
0F6FA:  ADDLW  D8
0F6FC:  MOVWF  FE9
0F6FE:  MOVLW  08
0F700:  ADDWFC 03,W
0F702:  MOVWF  FEA
0F704:  MOVFF  FEF,91A
0F708:  MOVFF  FEC,91B
0F70C:  MOVFF  FEC,91C
0F710:  MOVFF  FEC,91D
0F714:  MOVF   xD5,W
0F716:  MULLW  04
0F718:  MOVF   FF3,W
0F71A:  CLRF   03
0F71C:  ADDLW  F8
0F71E:  MOVWF  FE9
0F720:  MOVLW  08
0F722:  ADDWFC 03,W
0F724:  MOVWF  FEA
0F726:  MOVFF  FEF,00
0F72A:  MOVFF  FEC,01
0F72E:  MOVFF  FEC,02
0F732:  MOVFF  FEC,03
0F736:  MOVLB  9
0F738:  MOVF   x1A,W
0F73A:  ADDWF  00,F
0F73C:  MOVF   x1B,W
0F73E:  ADDWFC 01,F
0F740:  MOVF   x1C,W
0F742:  ADDWFC 02,F
0F744:  MOVF   x1D,W
0F746:  ADDWFC 03,F
0F748:  MOVFF  919,FEA
0F74C:  MOVFF  918,FE9
0F750:  MOVFF  00,FEF
0F754:  MOVFF  01,FEC
0F758:  MOVFF  02,FEC
0F75C:  MOVFF  03,FEC
0F760:  MOVLB  8
0F762:  INCF   xD5,F
0F764:  BRA    F690
....................       } 
0F766:  INCF   xD6,F
0F768:  BTFSC  FD8.2
0F76A:  INCF   xD7,F
0F76C:  BRA    F670
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F76E:  MOVLW  01
0F770:  MOVWF  xD5
0F772:  MOVF   xD5,W
0F774:  SUBLW  04
0F776:  BNC   F7EA
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F778:  BCF    FD8.0
0F77A:  RLCF   xD5,W
0F77C:  CLRF   03
0F77E:  ADDLW  A5
0F780:  MOVWF  01
0F782:  MOVLW  04
0F784:  ADDWFC 03,F
0F786:  MOVFF  01,918
0F78A:  MOVFF  03,919
0F78E:  MOVLB  8
0F790:  MOVF   xD5,W
0F792:  MULLW  04
0F794:  MOVF   FF3,W
0F796:  CLRF   03
0F798:  ADDLW  D8
0F79A:  MOVWF  FE9
0F79C:  MOVLW  08
0F79E:  ADDWFC 03,W
0F7A0:  MOVWF  FEA
0F7A2:  MOVFF  FEF,A4C
0F7A6:  MOVFF  FEC,A4D
0F7AA:  MOVFF  FEC,A4E
0F7AE:  MOVFF  FEC,A4F
0F7B2:  BCF    FD8.1
0F7B4:  CLRF   1B
0F7B6:  BTFSC  FF2.7
0F7B8:  BSF    1B.7
0F7BA:  BCF    FF2.7
0F7BC:  MOVLB  A
0F7BE:  CLRF   x53
0F7C0:  CLRF   x52
0F7C2:  MOVFF  8D4,A51
0F7C6:  MOVFF  8D3,A50
0F7CA:  MOVLB  0
0F7CC:  CALL   1056
0F7D0:  BTFSC  1B.7
0F7D2:  BSF    FF2.7
0F7D4:  MOVFF  919,FEA
0F7D8:  MOVFF  918,FE9
0F7DC:  MOVFF  00,FEF
0F7E0:  MOVFF  01,FEC
0F7E4:  MOVLB  8
0F7E6:  INCF   xD5,F
0F7E8:  BRA    F772
....................    } 
0F7EA:  MOVLB  0
0F7EC:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    //Handle updating variables for the valve timeout 
....................    /*if(valve_align_timeout != -1){ 
....................       fprintf(COM_A,"align_var: %Ld \r\n",valve_align_timeout); 
....................       if(valve_align_timeout >= 2){ 
....................          valve_align_timeout = -1; 
....................          reset_cpu(); 
....................       } 
....................       valve_align_timeout++; 
....................    }*/ 
....................    //Service watchdog 
....................    output_bit(PIN_J7,(!input(PIN_J7))); 
*
00E14:  BTFSS  F88.7
00E16:  BRA    0E1C
00E18:  BCF    F91.7
00E1A:  BRA    0E1E
00E1C:  BSF    F91.7
....................     
....................    rtc_alarm = TRUE; 
00E1E:  BSF    4D.0
....................    sleep_mode = FALSE; 
00E20:  BCF    4D.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E22:  BTFSS  4D.2
00E24:  BRA    0E28
....................    { 
....................       ; 
00E26:  BRA    0E22
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E28:  BSF    4D.2
....................    RTC_read_flags(); 
00E2A:  RCALL  0DD8
....................    ++nv_elapsed; 
00E2C:  INCF   35,F
00E2E:  BTFSC  FD8.2
00E30:  INCF   36,F
.................... } 
....................  
00E32:  BCF    FF2.1
00E34:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E78:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E7A:  BTFSC  4D.1
00E7C:  BRA    0ECE
....................    { 
....................       if (kbhit(COM_A)) 
00E7E:  BTFSS  F9E.5
00E80:  BRA    0ECC
....................       { 
....................          c = getc(COM_A); 
00E82:  RCALL  0E38
00E84:  MOVFF  01,A37
....................          switch (c) 
00E88:  MOVLB  A
00E8A:  MOVF   x37,W
00E8C:  XORLW  3F
00E8E:  MOVLB  0
00E90:  BZ    0E9C
00E92:  XORLW  2E
00E94:  BZ    0EC0
00E96:  XORLW  0A
00E98:  BZ    0EC6
00E9A:  BRA    0ECC
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00E9C:  DECFSZ 4E,W
00E9E:  BRA    0EB0
00EA0:  MOVLW  D8
00EA2:  MOVWF  FF6
00EA4:  MOVLW  0E
00EA6:  MOVWF  FF7
00EA8:  MOVLW  00
00EAA:  MOVWF  FF8
00EAC:  RCALL  0E4E
00EAE:  BRA    0EBE
....................                else fprintf(COM_A, "@RDY\r\n"); 
00EB0:  MOVLW  E0
00EB2:  MOVWF  FF6
00EB4:  MOVLW  0E
00EB6:  MOVWF  FF7
00EB8:  MOVLW  00
00EBA:  MOVWF  FF8
00EBC:  RCALL  0E4E
....................                break; 
00EBE:  BRA    0ECC
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EC0:  MOVLW  01
00EC2:  MOVWF  50
....................                break;          
00EC4:  BRA    0ECC
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EC6:  CLRF   32
00EC8:  MOVLW  01
00ECA:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00ECC:  BRA    0ED2
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00ECE:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00ED0:  BCF    F9E.5
....................    } 
00ED2:  BCF    F9E.5
00ED4:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0AE74:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0AE76:  MOVF   FAE,W
....................    busy_status = FALSE; 
0AE78:  CLRF   4E
0AE7A:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
029C0:  MOVLW  01
029C2:  MOVWF  4E
....................    clear_interrupt(INT_RDA); 
029C4:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
029C6:  BSF    F9D.5
029C8:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00EE8:  MOVLW  0B
00EEA:  MOVWF  FD7
00EEC:  MOVLW  DC
00EEE:  MOVWF  FD6
....................    restart_wdt(); 
00EF0:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00EF2:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00EF4:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00EF6:  CLRF   FCF
00EF8:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00EFA:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00EFC:  MOVF   2F,W
00EFE:  SUBLW  02
00F00:  BNZ   0F08
00F02:  MOVF   30,F
00F04:  BNZ   0F08
00F06:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00F08:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00F0A:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00F0C:  BCF    FF2.2
00F0E:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00F12:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F14:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F16:  MOVF   2F,W
00F18:  SUBLW  02
00F1A:  BNZ   0F22
00F1C:  MOVF   30,F
00F1E:  BNZ   0F22
00F20:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F22:  BCF    F9E.0
00F24:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
15CF2:  MOVLB  8
15CF4:  CLRF   x8C
15CF6:  CLRF   x90
15CF8:  CLRF   x8F
15CFA:  CLRF   x8E
15CFC:  CLRF   x8D
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
15CFE:  MOVLW  01
15D00:  ADDWF  x8D,F
15D02:  BTFSC  FD8.0
15D04:  INCF   x8E,F
15D06:  BTFSC  FD8.2
15D08:  INCF   x8F,F
15D0A:  BTFSC  FD8.2
15D0C:  INCF   x90,F
15D0E:  MOVF   x90,F
15D10:  BNZ   15D52
15D12:  MOVF   x8F,W
15D14:  SUBLW  04
15D16:  BNC   15D52
15D18:  BNZ   15D28
15D1A:  MOVF   x8E,W
15D1C:  SUBLW  93
15D1E:  BNC   15D52
15D20:  BNZ   15D28
15D22:  MOVF   x8D,W
15D24:  SUBLW  DF
15D26:  BNC   15D52
....................    { 
....................       if(kbhit(COM_A)) 
15D28:  BTFSS  F9E.5
15D2A:  BRA    15D48
....................       { 
....................          c = fgetc(COM_A); 
15D2C:  MOVLB  0
15D2E:  CALL   0E38
15D32:  MOVFF  01,88C
....................          if (com_echo == TRUE) 
15D36:  DECFSZ 4C,W
15D38:  BRA    15D44
....................          { 
....................             fputc(c, COM_A); 
15D3A:  MOVLB  8
15D3C:  MOVF   x8C,W
15D3E:  MOVLB  0
15D40:  CALL   AE7C
....................          } 
....................          break; 
15D44:  MOVLB  8
15D46:  BRA    15D52
....................       } 
....................  
....................       delay_us(10); 
15D48:  MOVLW  35
15D4A:  MOVWF  00
15D4C:  DECFSZ 00,F
15D4E:  BRA    15D4C
15D50:  BRA    15CFE
....................    } 
....................  
....................    return(c); 
15D52:  MOVFF  88C,01
15D56:  MOVLB  0
15D58:  GOTO   15D68 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0ADF0:  MOVLW  58
0ADF2:  MOVLB  8
0ADF4:  MOVWF  x64
0ADF6:  CLRF   x68
0ADF8:  CLRF   x67
0ADFA:  CLRF   x66
0ADFC:  CLRF   x65
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0ADFE:  MOVLW  01
0AE00:  ADDWF  x65,F
0AE02:  BTFSC  FD8.0
0AE04:  INCF   x66,F
0AE06:  BTFSC  FD8.2
0AE08:  INCF   x67,F
0AE0A:  BTFSC  FD8.2
0AE0C:  INCF   x68,F
0AE0E:  MOVF   x68,F
0AE10:  BNZ   AE40
0AE12:  MOVF   x67,F
0AE14:  BNZ   AE40
0AE16:  MOVF   x66,W
0AE18:  SUBLW  C3
0AE1A:  BNC   AE40
0AE1C:  BNZ   AE24
0AE1E:  MOVF   x65,W
0AE20:  SUBLW  4F
0AE22:  BNC   AE40
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AE24:  MOVLW  05
0AE26:  MOVWF  00
0AE28:  DECFSZ 00,F
0AE2A:  BRA    AE28
....................  
....................       if(kbhit()) 
0AE2C:  BTFSS  F9E.5
0AE2E:  BRA    AE3E
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AE30:  MOVLB  0
0AE32:  CALL   0E38
0AE36:  MOVFF  01,864
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AE3A:  MOVLB  8
0AE3C:  BRA    AE40
....................       } 
0AE3E:  BRA    ADFE
....................    } 
....................  
....................    return(EscChar); 
0AE40:  MOVFF  864,01
0AE44:  MOVLB  0
0AE46:  GOTO   1BA40 (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0DA3C:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0DA3E:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0DA40:  BSF    F8F.3
....................    delay_ms(10); 
0DA42:  MOVLW  0A
0DA44:  MOVLB  9
0DA46:  MOVWF  xEC
0DA48:  MOVLB  0
0DA4A:  CALL   2910
0DA4E:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0DB28:  MOVLB  8
0DB2A:  CLRF   xF4
0DB2C:  CLRF   xF3
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0DB2E:  MOVLB  F
0DB30:  BTFSC  x21.1
0DB32:  BRA    DB40
....................       ++c; 
0DB34:  MOVLB  8
0DB36:  INCF   xF3,F
0DB38:  BTFSC  FD8.2
0DB3A:  INCF   xF4,F
0DB3C:  BRA    DB2E
0DB3E:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0DB40:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0DB42:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0DB44:  BCF    F8F.3
0DB46:  MOVLB  0
0DB48:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
16F1E:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
16F20:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
16F22:  BCF    F8F.3
16F24:  GOTO   17012 (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
16F28:  MOVLB  8
16F2A:  CLRF   x85
16F2C:  CLRF   x86
16F2E:  CLRF   xD7
16F30:  CLRF   xD8
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16F32:  MOVLW  28
16F34:  MOVWF  FF6
16F36:  MOVLW  0F
16F38:  MOVWF  FF7
16F3A:  MOVLW  00
16F3C:  MOVWF  FF8
16F3E:  CLRF   1B
16F40:  BTFSC  FF2.7
16F42:  BSF    1B.7
16F44:  BCF    FF2.7
16F46:  MOVLB  0
16F48:  CALL   0E4E
16F4C:  BTFSC  1B.7
16F4E:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16F50:  MOVLB  8
16F52:  MOVF   x86,W
16F54:  SUBLW  04
16F56:  BZ    1700E
....................    { 
....................        if (kbhit(COM_A)) 
16F58:  BTFSS  F9E.5
16F5A:  BRA    16FF2
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16F5C:  MOVLB  0
16F5E:  CALL   0E38
16F62:  MOVFF  01,885
....................           if (com_echo == TRUE) 
16F66:  DECFSZ 4C,W
16F68:  BRA    16F74
....................           { 
....................              fputc(charFromA, COM_A); 
16F6A:  MOVLB  8
16F6C:  MOVF   x85,W
16F6E:  MOVLB  0
16F70:  CALL   AE7C
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16F74:  MOVLB  8
16F76:  MOVF   xD8,W
16F78:  SUBLW  4F
16F7A:  BNC   16FD0
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16F7C:  MOVF   xD8,W
16F7E:  INCF   xD8,F
16F80:  CLRF   03
16F82:  ADDLW  87
16F84:  MOVWF  FE9
16F86:  MOVLW  08
16F88:  ADDWFC 03,W
16F8A:  MOVWF  FEA
16F8C:  MOVFF  885,FEF
....................              if (CARRIAGE_RET == charFromA) 
16F90:  MOVF   x85,W
16F92:  SUBLW  0D
16F94:  BNZ   16FCE
....................              { 
....................                 multidrop_on(); 
16F96:  MOVLB  0
16F98:  CALL   DA3C
....................                 for (index = 0 ; index < charCount; index++) 
16F9C:  MOVLB  8
16F9E:  CLRF   xD7
16FA0:  MOVF   xD8,W
16FA2:  SUBWF  xD7,W
16FA4:  BC    16FC4
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
16FA6:  CLRF   03
16FA8:  MOVF   xD7,W
16FAA:  ADDLW  87
16FAC:  MOVWF  FE9
16FAE:  MOVLW  08
16FB0:  ADDWFC 03,W
16FB2:  MOVWF  FEA
16FB4:  MOVFF  FEF,8D9
16FB8:  MOVF   xD9,W
16FBA:  MOVLB  0
16FBC:  BRA    16F10
16FBE:  MOVLB  8
16FC0:  INCF   xD7,F
16FC2:  BRA    16FA0
....................                 } 
....................                 charCount = 0; 
16FC4:  CLRF   xD8
....................                 multidrop_off(); 
16FC6:  MOVLB  0
16FC8:  CALL   DB28
16FCC:  MOVLB  8
....................              } 
....................           } 
16FCE:  BRA    16FF2
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
16FD0:  MOVLW  30
16FD2:  MOVWF  FF6
16FD4:  MOVLW  0F
16FD6:  MOVWF  FF7
16FD8:  MOVLW  00
16FDA:  MOVWF  FF8
16FDC:  CLRF   1B
16FDE:  BTFSC  FF2.7
16FE0:  BSF    1B.7
16FE2:  BCF    FF2.7
16FE4:  MOVLB  0
16FE6:  CALL   0E4E
16FEA:  BTFSC  1B.7
16FEC:  BSF    FF2.7
....................              charCount = 0; 
16FEE:  MOVLB  8
16FF0:  CLRF   xD8
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
16FF2:  BTFSS  FA4.5
16FF4:  BRA    1700C
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
16FF6:  MOVLB  0
16FF8:  CALL   12DF0
16FFC:  MOVFF  01,886
....................           fputc(charFromB, COM_A);                  // send data via USART 
17000:  MOVLB  8
17002:  MOVF   x86,W
17004:  MOVLB  0
17006:  CALL   AE7C
1700A:  MOVLB  8
....................        } 
1700C:  BRA    16F52
....................    } 
....................  
....................    multidrop_shdn(); 
1700E:  MOVLB  0
17010:  BRA    16F1E
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
17012:  MOVLW  40
17014:  MOVWF  FF6
17016:  MOVLW  0F
17018:  MOVWF  FF7
1701A:  MOVLW  00
1701C:  MOVWF  FF8
1701E:  CLRF   1B
17020:  BTFSC  FF2.7
17022:  BSF    1B.7
17024:  BCF    FF2.7
17026:  CALL   0E4E
1702A:  BTFSC  1B.7
1702C:  BSF    FF2.7
1702E:  GOTO   17048 (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C838:  MOVLB  8
0C83A:  DECF   x9F,F
....................    len=0; 
0C83C:  CLRF   xA0
....................    do { 
....................      c=getc(); 
0C83E:  MOVLB  0
0C840:  CALL   0E38
0C844:  MOVFF  01,8A1
....................      if(c==8) {  // Backspace 
0C848:  MOVLB  8
0C84A:  MOVF   xA1,W
0C84C:  SUBLW  08
0C84E:  BNZ   C872
....................         if(len>0) { 
0C850:  MOVF   xA0,F
0C852:  BZ    C870
....................           len--; 
0C854:  DECF   xA0,F
....................           putc(c); 
0C856:  MOVF   xA1,W
0C858:  MOVLB  0
0C85A:  CALL   AE7C
....................           putc(' '); 
0C85E:  MOVLW  20
0C860:  CALL   AE7C
....................           putc(c); 
0C864:  MOVLB  8
0C866:  MOVF   xA1,W
0C868:  MOVLB  0
0C86A:  CALL   AE7C
0C86E:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C870:  BRA    C8A0
0C872:  MOVF   xA1,W
0C874:  SUBLW  1F
0C876:  BC    C8A0
0C878:  MOVF   xA1,W
0C87A:  SUBLW  7E
0C87C:  BNC   C8A0
....................        if(len<=max) { 
0C87E:  MOVF   xA0,W
0C880:  SUBWF  x9F,W
0C882:  BNC   C8A0
....................          s[len++]=c; 
0C884:  MOVF   xA0,W
0C886:  INCF   xA0,F
0C888:  ADDWF  x9D,W
0C88A:  MOVWF  FE9
0C88C:  MOVLW  00
0C88E:  ADDWFC x9E,W
0C890:  MOVWF  FEA
0C892:  MOVFF  8A1,FEF
....................          putc(c); 
0C896:  MOVF   xA1,W
0C898:  MOVLB  0
0C89A:  CALL   AE7C
0C89E:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C8A0:  MOVF   xA1,W
0C8A2:  SUBLW  0D
0C8A4:  BNZ   C83E
....................    s[len]=0; 
0C8A6:  MOVF   xA0,W
0C8A8:  ADDWF  x9D,W
0C8AA:  MOVWF  FE9
0C8AC:  MOVLW  00
0C8AE:  ADDWFC x9E,W
0C8B0:  MOVWF  FEA
0C8B2:  CLRF   FEF
0C8B4:  MOVLB  0
0C8B6:  GOTO   CCDC (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CCCA:  MOVLW  08
0CCCC:  MOVLB  8
0CCCE:  MOVWF  x9E
0CCD0:  MOVLW  85
0CCD2:  MOVWF  x9D
0CCD4:  MOVLW  14
0CCD6:  MOVWF  x9F
0CCD8:  MOVLB  0
0CCDA:  BRA    C838
....................   f = atof(s); 
0CCDC:  MOVLW  08
0CCDE:  MOVLB  8
0CCE0:  MOVWF  x9E
0CCE2:  MOVLW  85
0CCE4:  MOVWF  x9D
0CCE6:  CLRF   xA0
0CCE8:  CLRF   x9F
0CCEA:  MOVLB  0
0CCEC:  BRA    CA6E
0CCEE:  MOVFF  03,89C
0CCF2:  MOVFF  02,89B
0CCF6:  MOVFF  01,89A
0CCFA:  MOVFF  00,899
....................   return(f); 
0CCFE:  MOVFF  899,00
0CD02:  MOVFF  89A,01
0CD06:  MOVFF  89B,02
0CD0A:  MOVFF  89C,03
0CD0E:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
0293A:  MOVLW  2F
0293C:  MOVWF  F92
....................    set_tris_b(0b00110111); 
0293E:  MOVLW  37
02940:  MOVWF  F93
....................    set_tris_c(0b10010000); 
02942:  MOVLW  90
02944:  MOVWF  F94
....................    set_tris_d(0b00100000); 
02946:  MOVLW  20
02948:  MOVWF  F95
....................    set_tris_e(0b01000000); 
0294A:  MOVLW  40
0294C:  MOVWF  F96
....................    set_tris_f(0b00000000); 
0294E:  MOVLW  00
02950:  MOVWF  F97
....................    set_tris_g(0b11100100); 
02952:  MOVLW  E4
02954:  MOVWF  F98
....................    set_tris_h(0b01000000); 
02956:  MOVLW  40
02958:  MOVWF  F99
....................    set_tris_j(0b00000000); 
0295A:  MOVLW  00
0295C:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
0295E:  BCF    F8E.3
....................    output_low(HB_IN1); 
02960:  BCF    F8E.4
....................    output_low(HB_IN2); 
02962:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
02964:  BCF    F91.3
....................    output_high(EEP_CS);        
02966:  BSF    F91.2
....................    output_high(RTC_CS); 
02968:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
0296A:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
0296C:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
0296E:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
02970:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
02972:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
02974:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
02976:  BCF    F8F.3
....................    delay_ms(20);   
02978:  MOVLW  14
0297A:  MOVLB  9
0297C:  MOVWF  xEC
0297E:  MOVLB  0
02980:  RCALL  2910
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
02982:  BCF    F8E.1
....................    output_low(VDET);     
02984:  BCF    F90.7
....................    bus_pwr_status=0; 
02986:  MOVLB  4
02988:  CLRF   xB6
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
0298A:  BSF    F8C.2
....................    output_high(DAC_CS); 
0298C:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
0298E:  BCF    F8C.0
....................    output_low(HSW2); 
02990:  BCF    F8C.1
....................    heater_stat=0; 
02992:  CLRF   xB5
02994:  MOVLB  0
02996:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
15C20:  BSF    F91.1
....................    output_low(EEP_WP);        
15C22:  BCF    F91.3
....................    output_high(EEP_CS);        
15C24:  BSF    F91.2
....................    output_high(RTC_CS);  
15C26:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
15C28:  BCF    F8E.3
....................    output_low(HB_IN1);        
15C2A:  BCF    F8E.4
....................    output_low(HB_IN2); 
15C2C:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
15C2E:  BCF    F8C.2
....................    output_low(DAC_CS); 
15C30:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
15C32:  BCF    F8C.0
....................    output_low(HSW2); 
15C34:  BCF    F8C.1
....................    heater_stat=0; 
15C36:  MOVLB  4
15C38:  CLRF   xB5
....................    // Power switches 
....................    output_low(VMOT);         
15C3A:  BCF    F8E.1
....................    output_low(VDET);  
15C3C:  BCF    F90.7
....................    bus_pwr_status=0; 
15C3E:  CLRF   xB6
....................    output_low(VENC1);         
15C40:  BCF    F8E.6
....................    output_low(VENC2);         
15C42:  BCF    F8E.7
....................    output_low(VHBRDG);  
15C44:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
15C46:  MOVLW  48
15C48:  MOVWF  FF6
15C4A:  MOVLW  0F
15C4C:  MOVWF  FF7
15C4E:  MOVLW  00
15C50:  MOVWF  FF8
15C52:  CLRF   1B
15C54:  BTFSC  FF2.7
15C56:  BSF    1B.7
15C58:  BCF    FF2.7
15C5A:  MOVLB  0
15C5C:  CALL   0E4E
15C60:  BTFSC  1B.7
15C62:  BSF    FF2.7
....................    delay_ms(50); 
15C64:  MOVLW  32
15C66:  MOVLB  9
15C68:  MOVWF  xEC
15C6A:  MOVLB  0
15C6C:  CALL   2910
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
15C70:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
15C72:  BSF    F91.6
....................    output_low(MD1_TXEN); 
15C74:  BCF    F91.5
....................    output_low(MD2_SHDN);    
15C76:  BCF    F8F.0
....................    output_low(MD2_REN); 
15C78:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
15C7A:  BCF    F8F.3
....................  
....................    delay_ms(30); 
15C7C:  MOVLW  1E
15C7E:  MOVLB  9
15C80:  MOVWF  xEC
15C82:  MOVLB  0
15C84:  CALL   2910
15C88:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
0503A:  MOVLB  8
0503C:  CLRF   x89
0503E:  MOVF   x89,W
05040:  SUBLW  02
05042:  BNC   5068
....................       FS_Status = f_mountdrv(); 
05044:  MOVLB  0
05046:  RCALL  4856
05048:  MOVFF  01,724
....................       if (FS_Status) 
0504C:  MOVLB  7
0504E:  MOVF   x24,F
05050:  BZ    505C
....................          { 
....................          display_file_result(FS_Status); 
05052:  MOVFF  724,88A
05056:  MOVLB  0
05058:  BRA    4DF4
....................          } 
0505A:  BRA    5062
....................       else break; 
0505C:  MOVLB  8
0505E:  BRA    5068
05060:  MOVLB  0
05062:  MOVLB  8
05064:  INCF   x89,F
05066:  BRA    503E
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
05068:  MOVLW  3E
0506A:  MOVWF  xEE
0506C:  CLRF   xF0
0506E:  MOVFF  724,8EF
05072:  MOVLB  0
05074:  RCALL  4FD4
....................     
....................    return(FS_Status); 
05076:  MOVLB  7
05078:  MOVFF  724,01
0507C:  MOVLB  0
0507E:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
030FC:  MOVLW  01
030FE:  MOVLB  8
03100:  MOVWF  x64
03102:  MOVF   x64,W
03104:  SUBLW  03
03106:  BNC   3142
....................    { 
....................       output_bit(BOARD_LED, ON); 
03108:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
0310A:  MOVF   2F,W
0310C:  SUBLW  02
0310E:  BNZ   3116
03110:  MOVF   30,F
03112:  BNZ   3116
03114:  BSF    F90.6
....................       delay_ms(32); 
03116:  MOVLW  20
03118:  MOVLB  9
0311A:  MOVWF  xEC
0311C:  MOVLB  0
0311E:  CALL   2910
....................       output_bit(BOARD_LED, OFF); 
03122:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
03124:  MOVF   2F,W
03126:  SUBLW  02
03128:  BNZ   3130
0312A:  MOVF   30,F
0312C:  BNZ   3130
0312E:  BCF    F90.6
....................       delay_ms(32); 
03130:  MOVLW  20
03132:  MOVLB  9
03134:  MOVWF  xEC
03136:  MOVLB  0
03138:  CALL   2910
0313C:  MOVLB  8
0313E:  INCF   x64,F
03140:  BRA    3102
....................    } 
03142:  MOVLB  0
03144:  GOTO   1B840 (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
050FC:  MOVLB  8
050FE:  CLRF   xF3
05100:  CLRF   xF2
05102:  CLRF   xF1
05104:  CLRF   xF0
....................    set_adc_channel(0,VSS); 
05106:  MOVLW  00
05108:  MOVWF  01
0510A:  MOVF   FC2,W
0510C:  ANDLW  83
0510E:  IORWF  01,W
05110:  MOVWF  FC2
05112:  MOVLW  00
05114:  MOVWF  01
05116:  MOVF   FC1,W
05118:  ANDLW  F8
0511A:  IORWF  01,W
0511C:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
0511E:  MOVLW  01
05120:  MOVWF  xED
05122:  MOVF   xED,W
05124:  SUBLW  32
05126:  BNC   514C
....................       reading=read_adc(); 
05128:  BSF    FC2.1
0512A:  BTFSC  FC2.1
0512C:  BRA    512A
0512E:  MOVFF  FC3,8F4
05132:  MOVFF  FC4,8F5
05136:  CLRF   xF6
05138:  CLRF   xF7
....................       delay_ms(5); 
0513A:  MOVLW  05
0513C:  MOVLB  9
0513E:  MOVWF  xEC
05140:  MOVLB  0
05142:  CALL   2910
05146:  MOVLB  8
05148:  INCF   xED,F
0514A:  BRA    5122
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
0514C:  MOVLW  01
0514E:  MOVWF  xED
05150:  MOVF   xED,W
05152:  SUBLW  64
05154:  BNC   5202
....................       reading=read_adc(); 
05156:  BSF    FC2.1
05158:  BTFSC  FC2.1
0515A:  BRA    5158
0515C:  MOVFF  FC3,8F4
05160:  MOVFF  FC4,8F5
05164:  CLRF   xF6
05166:  CLRF   xF7
....................       result=(((result*(i-1))+reading)/i); 
05168:  MOVLW  01
0516A:  SUBWF  xED,W
0516C:  MOVWF  xF8
0516E:  MOVFF  8F3,9F9
05172:  MOVFF  8F2,9F8
05176:  MOVFF  8F1,9F7
0517A:  MOVFF  8F0,9F6
0517E:  MOVLB  9
05180:  CLRF   xFD
05182:  CLRF   xFC
05184:  CLRF   xFB
05186:  MOVWF  xFA
05188:  MOVLB  0
0518A:  CALL   47F0
0518E:  MOVFF  03,8FB
05192:  MOVFF  02,8FA
05196:  MOVFF  01,8F9
0519A:  MOVFF  00,8F8
0519E:  MOVLB  8
051A0:  MOVF   xF4,W
051A2:  ADDWF  xF8,F
051A4:  MOVF   xF5,W
051A6:  ADDWFC xF9,F
051A8:  MOVF   xF6,W
051AA:  ADDWFC xFA,F
051AC:  MOVF   xF7,W
051AE:  ADDWFC xFB,F
051B0:  BCF    FD8.1
051B2:  CLRF   1B
051B4:  BTFSC  FF2.7
051B6:  BSF    1B.7
051B8:  BCF    FF2.7
051BA:  MOVFF  8FB,A4F
051BE:  MOVFF  8FA,A4E
051C2:  MOVFF  8F9,A4D
051C6:  MOVFF  8F8,A4C
051CA:  MOVLB  A
051CC:  CLRF   x53
051CE:  CLRF   x52
051D0:  CLRF   x51
051D2:  MOVFF  8ED,A50
051D6:  MOVLB  0
051D8:  CALL   1056
051DC:  BTFSC  1B.7
051DE:  BSF    FF2.7
051E0:  MOVFF  03,8F3
051E4:  MOVFF  02,8F2
051E8:  MOVFF  01,8F1
051EC:  MOVFF  00,8F0
....................       delay_ms(5); 
051F0:  MOVLW  05
051F2:  MOVLB  9
051F4:  MOVWF  xEC
051F6:  MOVLB  0
051F8:  CALL   2910
051FC:  MOVLB  8
051FE:  INCF   xED,F
05200:  BRA    5150
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
05202:  MOVFF  8F3,9F9
05206:  MOVFF  8F2,9F8
0520A:  MOVFF  8F1,9F7
0520E:  MOVFF  8F0,9F6
05212:  MOVLB  9
05214:  CLRF   xFD
05216:  CLRF   xFC
05218:  CLRF   xFB
0521A:  MOVLW  64
0521C:  MOVWF  xFA
0521E:  MOVLB  0
05220:  CALL   47F0
05224:  MOVFF  03,8FB
05228:  MOVFF  02,8FA
0522C:  MOVFF  01,8F9
05230:  MOVFF  00,8F8
05234:  BCF    FD8.1
05236:  CLRF   1B
05238:  BTFSC  FF2.7
0523A:  BSF    1B.7
0523C:  BCF    FF2.7
0523E:  MOVFF  03,A4F
05242:  MOVFF  02,A4E
05246:  MOVFF  01,A4D
0524A:  MOVFF  00,A4C
0524E:  MOVLB  A
05250:  CLRF   x53
05252:  CLRF   x52
05254:  MOVLW  01
05256:  MOVWF  x51
05258:  MOVLW  10
0525A:  MOVWF  x50
0525C:  MOVLB  0
0525E:  CALL   1056
05262:  BTFSC  1B.7
05264:  BSF    FF2.7
05266:  MOVLW  56
05268:  MOVLB  8
0526A:  ADDWF  00,W
0526C:  MOVWF  xEE
0526E:  MOVLW  00
05270:  ADDWFC 01,W
05272:  MOVWF  xEF
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
05274:  MOVFF  8EE,01
05278:  MOVFF  8EF,02
0527C:  MOVLB  0
0527E:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
050E6:  MOVLW  02
050E8:  MOVWF  FEA
050EA:  MOVLW  99
050EC:  MOVWF  FE9
050EE:  CLRF   00
050F0:  CLRF   02
050F2:  MOVLW  1E
050F4:  MOVWF  01
050F6:  CALL   3526
050FA:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12D18:  MOVLW  02
12D1A:  MOVWF  FEA
12D1C:  MOVLW  B7
12D1E:  MOVWF  FE9
12D20:  CLRF   00
12D22:  CLRF   02
12D24:  MOVLW  1E
12D26:  MOVWF  01
12D28:  CALL   3526
12D2C:  GOTO   12FD4 (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
0541A:  RCALL  50E6
....................     
....................    v_supply = read_supply(); 
0541C:  RCALL  50FC
0541E:  MOVFF  02,8EC
05422:  MOVFF  01,8EB
....................    RTC_read(); 
05426:  CALL   3344
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
0542A:  MOVLW  02
0542C:  MOVWF  1E
0542E:  MOVLW  99
05430:  MOVWF  1D
05432:  MOVFF  72A,8ED
05436:  MOVLW  01
05438:  MOVLB  8
0543A:  MOVWF  xEE
0543C:  MOVLB  0
0543E:  RCALL  5280
05440:  MOVLW  2F
05442:  MOVLB  8
05444:  MOVWF  xFF
05446:  MOVLB  0
05448:  RCALL  509E
0544A:  MOVFF  729,8ED
0544E:  MOVLW  01
05450:  MOVLB  8
05452:  MOVWF  xEE
05454:  MOVLB  0
05456:  RCALL  5280
05458:  MOVLW  2F
0545A:  MOVLB  8
0545C:  MOVWF  xFF
0545E:  MOVLB  0
05460:  RCALL  509E
05462:  MOVFF  72B,8ED
05466:  MOVLW  01
05468:  MOVLB  8
0546A:  MOVWF  xEE
0546C:  MOVLB  0
0546E:  RCALL  5280
05470:  MOVLW  20
05472:  MOVLB  8
05474:  MOVWF  xFF
05476:  MOVLB  0
05478:  RCALL  509E
0547A:  MOVFF  727,8ED
0547E:  MOVLW  01
05480:  MOVLB  8
05482:  MOVWF  xEE
05484:  MOVLB  0
05486:  RCALL  5280
05488:  MOVLW  3A
0548A:  MOVLB  8
0548C:  MOVWF  xFF
0548E:  MOVLB  0
05490:  RCALL  509E
05492:  MOVFF  726,8ED
05496:  MOVLW  01
05498:  MOVLB  8
0549A:  MOVWF  xEE
0549C:  MOVLB  0
0549E:  RCALL  5280
054A0:  MOVLW  3A
054A2:  MOVLB  8
054A4:  MOVWF  xFF
054A6:  MOVLB  0
054A8:  RCALL  509E
054AA:  MOVFF  725,8ED
054AE:  MOVLW  01
054B0:  MOVLB  8
054B2:  MOVWF  xEE
054B4:  MOVLB  0
054B6:  RCALL  5280
054B8:  MOVLW  2C
054BA:  MOVLB  8
054BC:  MOVWF  xFF
054BE:  MOVLB  0
054C0:  RCALL  509E
054C2:  MOVLW  44
054C4:  MOVWF  FE9
054C6:  MOVLB  8
054C8:  CLRF   xF0
054CA:  CLRF   xEF
054CC:  MOVFF  8EC,8EE
054D0:  MOVFF  8EB,8ED
054D4:  MOVLW  02
054D6:  MOVWF  xF1
054D8:  MOVLB  0
054DA:  RCALL  531A
054DC:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
084DA:  MOVLB  2
084DC:  MOVF   xDC,F
084DE:  BNZ   855A
....................    { 
....................       strcopy(event_buffer,""); 
084E0:  MOVLW  01
084E2:  MOVWF  FEA
084E4:  MOVLW  07
084E6:  MOVWF  FE9
084E8:  MOVLW  00
084EA:  MOVLB  0
084EC:  CALL   02CE
084F0:  TBLRD*-
084F2:  TBLRD*+
084F4:  MOVF   FF5,W
084F6:  MOVWF  FEE
084F8:  IORLW  00
084FA:  BNZ   84F2
....................       time_stamp(); 
084FC:  CALL   541A
....................       strcat(event_buffer, time_stmp_str); 
08500:  MOVLW  01
08502:  MOVLB  8
08504:  MOVWF  xF9
08506:  MOVLW  07
08508:  MOVWF  xF8
0850A:  MOVLW  02
0850C:  MOVWF  xFB
0850E:  MOVLW  99
08510:  MOVWF  xFA
08512:  MOVLB  0
08514:  CALL   54DE
....................       strcat(event_buffer, event_str); 
08518:  MOVLW  01
0851A:  MOVLB  8
0851C:  MOVWF  xF9
0851E:  MOVLW  07
08520:  MOVWF  xF8
08522:  MOVLW  01
08524:  MOVWF  xFB
08526:  MOVLW  A7
08528:  MOVWF  xFA
0852A:  MOVLB  0
0852C:  CALL   54DE
....................       buffer_select = 1; 
08530:  MOVLW  01
08532:  MOVWF  x66
....................     
....................       heartbeat(FALSE); 
08534:  MOVLB  8
08536:  CLRF   xED
08538:  MOVLB  0
0853A:  CALL   5586
....................          append_data(file_ptr_events); 
0853E:  MOVLW  03
08540:  MOVLB  8
08542:  MOVWF  xEE
08544:  MOVLW  15
08546:  MOVWF  xED
08548:  MOVLB  0
0854A:  RCALL  82F8
....................       heartbeat(TRUE); 
0854C:  MOVLW  01
0854E:  MOVLB  8
08550:  MOVWF  xED
08552:  MOVLB  0
08554:  CALL   5586
08558:  MOVLB  2
....................    } 
0855A:  MOVLB  0
0855C:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
028C4:  BCF    F8B.2
028C6:  MOVLW  0C
028C8:  MOVWF  FBB
028CA:  CLRF   FBE
028CC:  CLRF   FBF
028CE:  MOVLW  01
028D0:  MOVWF  F9C
028D2:  MOVLW  F8
028D4:  MOVLB  F
028D6:  ANDWF  x2D,F
028D8:  MOVLW  00
028DA:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
028DC:  BCF    F8B.1
028DE:  MOVLW  0C
028E0:  MOVWF  x4E
028E2:  CLRF   x51
028E4:  CLRF   x52
028E6:  MOVLW  01
028E8:  MOVWF  x1B
028EA:  MOVLW  C7
028EC:  ANDWF  x2D,F
028EE:  MOVLW  00
028F0:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
028F2:  IORLW  05
028F4:  MOVWF  FCA
028F6:  MOVLW  7F
028F8:  MOVWF  FCB
028FA:  MOVLB  0
028FC:  GOTO   1B7F6 (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09D02:  MOVLW  52
09D04:  MOVWF  FF6
09D06:  MOVLW  0F
09D08:  MOVWF  FF7
09D0A:  MOVLW  00
09D0C:  MOVWF  FF8
09D0E:  CLRF   1B
09D10:  BTFSC  FF2.7
09D12:  BSF    1B.7
09D14:  BCF    FF2.7
09D16:  MOVLW  05
09D18:  MOVLB  A
09D1A:  MOVWF  x40
09D1C:  MOVLB  0
09D1E:  CALL   1024
09D22:  BTFSC  1B.7
09D24:  BSF    FF2.7
09D26:  MOVLW  10
09D28:  MOVWF  FE9
09D2A:  CLRF   1B
09D2C:  BTFSC  FF2.7
09D2E:  BSF    1B.7
09D30:  BCF    FF2.7
09D32:  MOVFF  797,A41
09D36:  MOVFF  796,A40
09D3A:  CALL   11A6
09D3E:  BTFSC  1B.7
09D40:  BSF    FF2.7
09D42:  MOVLW  2C
09D44:  BTFSS  F9E.4
09D46:  BRA    9D44
09D48:  MOVWF  FAD
09D4A:  MOVLW  10
09D4C:  MOVWF  FE9
09D4E:  CLRF   1B
09D50:  BTFSC  FF2.7
09D52:  BSF    1B.7
09D54:  BCF    FF2.7
09D56:  MOVFF  799,A41
09D5A:  MOVFF  798,A40
09D5E:  CALL   11A6
09D62:  BTFSC  1B.7
09D64:  BSF    FF2.7
09D66:  MOVLW  0D
09D68:  BTFSS  F9E.4
09D6A:  BRA    9D68
09D6C:  MOVWF  FAD
09D6E:  MOVLW  0A
09D70:  BTFSS  F9E.4
09D72:  BRA    9D70
09D74:  MOVWF  FAD
09D76:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02D1A:  MOVLW  86
02D1C:  MOVLB  8
02D1E:  MOVWF  x97
02D20:  MOVLB  0
02D22:  RCALL  29CA
02D24:  MOVFF  02,743
02D28:  MOVFF  01,742
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02D2C:  MOVLW  8A
02D2E:  MOVLB  8
02D30:  MOVWF  x97
02D32:  MOVLB  0
02D34:  RCALL  29CA
02D36:  MOVFF  02,747
02D3A:  MOVFF  01,746
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02D3E:  MOVLW  8E
02D40:  MOVLB  8
02D42:  MOVWF  x97
02D44:  MOVLB  0
02D46:  RCALL  29CA
02D48:  MOVFF  02,74B
02D4C:  MOVFF  01,74A
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02D50:  MOVLW  92
02D52:  MOVLB  8
02D54:  MOVWF  x97
02D56:  MOVLB  0
02D58:  RCALL  29CA
02D5A:  MOVFF  02,74F
02D5E:  MOVFF  01,74E
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02D62:  MOVLW  96
02D64:  MOVLB  8
02D66:  MOVWF  x97
02D68:  MOVLB  0
02D6A:  RCALL  29CA
02D6C:  MOVFF  02,753
02D70:  MOVFF  01,752
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02D74:  MOVLW  9A
02D76:  MOVLB  8
02D78:  MOVWF  x97
02D7A:  MOVLB  0
02D7C:  RCALL  29CA
02D7E:  MOVFF  02,757
02D82:  MOVFF  01,756
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02D86:  MOVLW  9E
02D88:  MOVLB  8
02D8A:  MOVWF  x97
02D8C:  MOVLB  0
02D8E:  RCALL  29CA
02D90:  MOVFF  02,75B
02D94:  MOVFF  01,75A
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02D98:  MOVLW  A2
02D9A:  MOVLB  8
02D9C:  MOVWF  x97
02D9E:  MOVLB  0
02DA0:  RCALL  29CA
02DA2:  MOVFF  02,75F
02DA6:  MOVFF  01,75E
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02DAA:  MOVLW  A6
02DAC:  MOVLB  8
02DAE:  MOVWF  x97
02DB0:  MOVLB  0
02DB2:  RCALL  29CA
02DB4:  MOVFF  02,763
02DB8:  MOVFF  01,762
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02DBC:  MOVLW  82
02DBE:  MOVLB  8
02DC0:  MOVWF  x97
02DC2:  MOVLB  0
02DC4:  RCALL  29CA
02DC6:  MOVFF  02,767
02DCA:  MOVFF  01,766
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02DCE:  MOVLW  7E
02DD0:  MOVLB  8
02DD2:  MOVWF  x97
02DD4:  MOVLB  0
02DD6:  RCALL  29CA
02DD8:  MOVFF  02,7C0
02DDC:  MOVFF  01,7BF
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02DE0:  MOVLW  AA
02DE2:  MOVLB  8
02DE4:  MOVWF  x97
02DE6:  MOVLB  0
02DE8:  RCALL  29CA
02DEA:  MOVFF  02,7C4
02DEE:  MOVFF  01,7C3
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02DF2:  MOVLW  7A
02DF4:  MOVLB  8
02DF6:  MOVWF  x97
02DF8:  MOVLB  0
02DFA:  RCALL  29CA
02DFC:  MOVFF  02,76B
02E00:  MOVFF  01,76A
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02E04:  MOVLW  76
02E06:  MOVLB  8
02E08:  MOVWF  x97
02E0A:  MOVLB  0
02E0C:  RCALL  29CA
02E0E:  MOVFF  02,76F
02E12:  MOVFF  01,76E
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02E16:  MOVLW  72
02E18:  MOVLB  8
02E1A:  MOVWF  x97
02E1C:  MOVLB  0
02E1E:  RCALL  29CA
02E20:  MOVFF  02,773
02E24:  MOVFF  01,772
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02E28:  MOVLW  6E
02E2A:  MOVLB  8
02E2C:  MOVWF  x97
02E2E:  MOVLB  0
02E30:  RCALL  29CA
02E32:  MOVFF  02,797
02E36:  MOVFF  01,796
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02E3A:  MOVLW  AE
02E3C:  MOVLB  8
02E3E:  MOVWF  x97
02E40:  MOVLB  0
02E42:  RCALL  29CA
02E44:  MOVFF  02,777
02E48:  MOVFF  01,776
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02E4C:  MOVLW  B2
02E4E:  MOVLB  8
02E50:  MOVWF  x97
02E52:  MOVLB  0
02E54:  RCALL  29CA
02E56:  MOVFF  02,7B0
02E5A:  MOVFF  01,7AF
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02E5E:  MOVLW  B6
02E60:  MOVLB  8
02E62:  MOVWF  x97
02E64:  MOVLB  0
02E66:  RCALL  29CA
02E68:  MOVFF  02,7B4
02E6C:  MOVFF  01,7B3
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02E70:  MOVLW  BA
02E72:  MOVLB  8
02E74:  MOVWF  x97
02E76:  MOVLB  0
02E78:  RCALL  29CA
02E7A:  MOVFF  02,77B
02E7E:  MOVFF  01,77A
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02E82:  MOVLW  BE
02E84:  MOVLB  8
02E86:  MOVWF  x97
02E88:  MOVLB  0
02E8A:  RCALL  29CA
02E8C:  MOVFF  02,77F
02E90:  MOVFF  01,77E
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02E94:  MOVLW  C2
02E96:  MOVLB  8
02E98:  MOVWF  x97
02E9A:  MOVLB  0
02E9C:  RCALL  29CA
02E9E:  MOVFF  02,783
02EA2:  MOVFF  01,782
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02EA6:  MOVLW  88
02EA8:  MOVLB  8
02EAA:  MOVWF  x97
02EAC:  MOVLB  0
02EAE:  RCALL  29CA
02EB0:  MOVFF  02,745
02EB4:  MOVFF  01,744
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02EB8:  MOVLW  8C
02EBA:  MOVLB  8
02EBC:  MOVWF  x97
02EBE:  MOVLB  0
02EC0:  RCALL  29CA
02EC2:  MOVFF  02,749
02EC6:  MOVFF  01,748
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02ECA:  MOVLW  90
02ECC:  MOVLB  8
02ECE:  MOVWF  x97
02ED0:  MOVLB  0
02ED2:  RCALL  29CA
02ED4:  MOVFF  02,74D
02ED8:  MOVFF  01,74C
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02EDC:  MOVLW  94
02EDE:  MOVLB  8
02EE0:  MOVWF  x97
02EE2:  MOVLB  0
02EE4:  RCALL  29CA
02EE6:  MOVFF  02,751
02EEA:  MOVFF  01,750
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02EEE:  MOVLW  98
02EF0:  MOVLB  8
02EF2:  MOVWF  x97
02EF4:  MOVLB  0
02EF6:  RCALL  29CA
02EF8:  MOVFF  02,755
02EFC:  MOVFF  01,754
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02F00:  MOVLW  9C
02F02:  MOVLB  8
02F04:  MOVWF  x97
02F06:  MOVLB  0
02F08:  RCALL  29CA
02F0A:  MOVFF  02,759
02F0E:  MOVFF  01,758
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02F12:  MOVLW  A0
02F14:  MOVLB  8
02F16:  MOVWF  x97
02F18:  MOVLB  0
02F1A:  RCALL  29CA
02F1C:  MOVFF  02,75D
02F20:  MOVFF  01,75C
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02F24:  MOVLW  A4
02F26:  MOVLB  8
02F28:  MOVWF  x97
02F2A:  MOVLB  0
02F2C:  RCALL  29CA
02F2E:  MOVFF  02,761
02F32:  MOVFF  01,760
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02F36:  MOVLW  A8
02F38:  MOVLB  8
02F3A:  MOVWF  x97
02F3C:  MOVLB  0
02F3E:  RCALL  29CA
02F40:  MOVFF  02,765
02F44:  MOVFF  01,764
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02F48:  MOVLW  84
02F4A:  MOVLB  8
02F4C:  MOVWF  x97
02F4E:  MOVLB  0
02F50:  RCALL  29CA
02F52:  MOVFF  02,769
02F56:  MOVFF  01,768
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02F5A:  MOVLW  80
02F5C:  MOVLB  8
02F5E:  MOVWF  x97
02F60:  MOVLB  0
02F62:  RCALL  29CA
02F64:  MOVFF  02,7C2
02F68:  MOVFF  01,7C1
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02F6C:  MOVLW  AC
02F6E:  MOVLB  8
02F70:  MOVWF  x97
02F72:  MOVLB  0
02F74:  RCALL  29CA
02F76:  MOVFF  02,7C6
02F7A:  MOVFF  01,7C5
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02F7E:  MOVLW  7C
02F80:  MOVLB  8
02F82:  MOVWF  x97
02F84:  MOVLB  0
02F86:  RCALL  29CA
02F88:  MOVFF  02,76D
02F8C:  MOVFF  01,76C
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02F90:  MOVLW  78
02F92:  MOVLB  8
02F94:  MOVWF  x97
02F96:  MOVLB  0
02F98:  RCALL  29CA
02F9A:  MOVFF  02,771
02F9E:  MOVFF  01,770
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02FA2:  MOVLW  74
02FA4:  MOVLB  8
02FA6:  MOVWF  x97
02FA8:  MOVLB  0
02FAA:  RCALL  29CA
02FAC:  MOVFF  02,775
02FB0:  MOVFF  01,774
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02FB4:  MOVLW  70
02FB6:  MOVLB  8
02FB8:  MOVWF  x97
02FBA:  MOVLB  0
02FBC:  RCALL  29CA
02FBE:  MOVFF  02,799
02FC2:  MOVFF  01,798
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02FC6:  MOVLW  B0
02FC8:  MOVLB  8
02FCA:  MOVWF  x97
02FCC:  MOVLB  0
02FCE:  RCALL  29CA
02FD0:  MOVFF  02,779
02FD4:  MOVFF  01,778
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
02FD8:  MOVLW  B4
02FDA:  MOVLB  8
02FDC:  MOVWF  x97
02FDE:  MOVLB  0
02FE0:  RCALL  29CA
02FE2:  MOVFF  02,7B2
02FE6:  MOVFF  01,7B1
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
02FEA:  MOVLW  B8
02FEC:  MOVLB  8
02FEE:  MOVWF  x97
02FF0:  MOVLB  0
02FF2:  RCALL  29CA
02FF4:  MOVFF  02,7B6
02FF8:  MOVFF  01,7B5
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
02FFC:  MOVLW  BC
02FFE:  MOVLB  8
03000:  MOVWF  x97
03002:  MOVLB  0
03004:  RCALL  29CA
03006:  MOVFF  02,77D
0300A:  MOVFF  01,77C
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
0300E:  MOVLW  C0
03010:  MOVLB  8
03012:  MOVWF  x97
03014:  MOVLB  0
03016:  RCALL  29CA
03018:  MOVFF  02,781
0301C:  MOVFF  01,780
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
03020:  MOVLW  C4
03022:  MOVLB  8
03024:  MOVWF  x97
03026:  MOVLB  0
03028:  RCALL  29CA
0302A:  MOVFF  02,785
0302E:  MOVFF  01,784
....................     
....................    motor=0; 
03032:  MOVLB  7
03034:  CLRF   x40
....................    m_fixed=1; 
03036:  MOVLW  01
03038:  MOVWF  x41
....................    m_step_cnt[0]=0; 
0303A:  CLRF   xA5
0303C:  CLRF   xA4
0303E:  CLRF   xA3
03040:  CLRF   xA2
....................    m_step_cnt[1]=0; 
03042:  CLRF   xA9
03044:  CLRF   xA8
03046:  CLRF   xA7
03048:  CLRF   xA6
....................    e_cha_cnt[0]=0; 
0304A:  CLRF   xBC
0304C:  CLRF   xBB
....................    e_cha_cnt[1]=0;  
0304E:  CLRF   xBE
03050:  CLRF   xBD
....................    m_gb_cnt[0]=0; 
03052:  CLRF   x9B
03054:  CLRF   x9A
....................    m_gb_cnt[1]=0; 
03056:  CLRF   x9D
03058:  CLRF   x9C
....................    e_mode_rst[0]=0; 
0305A:  CLRF   x9F
0305C:  CLRF   x9E
....................    e_mode_rst[1]=0;    
0305E:  CLRF   xA1
03060:  CLRF   xA0
....................    e_port_dist[0]=0; 
03062:  CLRF   xB8
03064:  CLRF   xB7
....................    e_port_dist[1]=0; 
03066:  CLRF   xBA
03068:  CLRF   xB9
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
0306A:  MOVFF  777,8DC
0306E:  MOVFF  776,8DB
03072:  MOVFF  763,8DE
03076:  MOVFF  762,8DD
0307A:  MOVLB  0
0307C:  RCALL  2CD4
0307E:  BCF    FD8.0
03080:  MOVLB  8
03082:  RLCF   01,W
03084:  MOVLB  7
03086:  MOVWF  xAB
03088:  MOVLB  8
0308A:  RLCF   02,W
0308C:  MOVLB  7
0308E:  MOVWF  xAC
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
03090:  MOVFF  779,8DC
03094:  MOVFF  778,8DB
03098:  MOVFF  765,8DE
0309C:  MOVFF  764,8DD
030A0:  MOVLB  0
030A2:  RCALL  2CD4
030A4:  BCF    FD8.0
030A6:  MOVLB  8
030A8:  RLCF   01,W
030AA:  MOVLB  7
030AC:  MOVWF  xAD
030AE:  MOVLB  8
030B0:  RLCF   02,W
030B2:  MOVLB  7
030B4:  MOVWF  xAE
030B6:  MOVLB  0
030B8:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
1A1D2:  MOVLW  86
1A1D4:  MOVLB  8
1A1D6:  MOVWF  xEE
1A1D8:  CLRF   xF0
1A1DA:  MOVLW  01
1A1DC:  MOVWF  xEF
1A1DE:  MOVLB  0
1A1E0:  CALL   4FD4
....................    write16(ADDR_M1_MODE,FULL); 
1A1E4:  MOVLW  8A
1A1E6:  MOVLB  8
1A1E8:  MOVWF  xEE
1A1EA:  CLRF   xF0
1A1EC:  CLRF   xEF
1A1EE:  MOVLB  0
1A1F0:  CALL   4FD4
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A1F4:  MOVLW  8E
1A1F6:  MOVLB  8
1A1F8:  MOVWF  xEE
1A1FA:  CLRF   xF0
1A1FC:  MOVLW  0A
1A1FE:  MOVWF  xEF
1A200:  MOVLB  0
1A202:  CALL   4FD4
....................    write16(ADDR_M1_POS_DIR,0); 
1A206:  MOVLW  92
1A208:  MOVLB  8
1A20A:  MOVWF  xEE
1A20C:  CLRF   xF0
1A20E:  CLRF   xEF
1A210:  MOVLB  0
1A212:  CALL   4FD4
....................    write16(ADDR_M1_PWM_HLD,0); 
1A216:  MOVLW  96
1A218:  MOVLB  8
1A21A:  MOVWF  xEE
1A21C:  CLRF   xF0
1A21E:  CLRF   xEF
1A220:  MOVLB  0
1A222:  CALL   4FD4
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A226:  MOVLW  9A
1A228:  MOVLB  8
1A22A:  MOVWF  xEE
1A22C:  CLRF   xF0
1A22E:  MOVLW  7F
1A230:  MOVWF  xEF
1A232:  MOVLB  0
1A234:  CALL   4FD4
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A238:  MOVLW  9E
1A23A:  MOVLB  8
1A23C:  MOVWF  xEE
1A23E:  MOVLW  17
1A240:  MOVWF  xF0
1A242:  MOVLW  70
1A244:  MOVWF  xEF
1A246:  MOVLB  0
1A248:  CALL   4FD4
....................    write16(ADDR_E1_CPR,16); 
1A24C:  MOVLW  A2
1A24E:  MOVLB  8
1A250:  MOVWF  xEE
1A252:  CLRF   xF0
1A254:  MOVLW  10
1A256:  MOVWF  xEF
1A258:  MOVLB  0
1A25A:  CALL   4FD4
....................    write16(ADDR_E1_PPR,16); 
1A25E:  MOVLW  A6
1A260:  MOVLB  8
1A262:  MOVWF  xEE
1A264:  CLRF   xF0
1A266:  MOVLW  10
1A268:  MOVWF  xEF
1A26A:  MOVLB  0
1A26C:  CALL   4FD4
....................    write16(ADDR_E1_MODE,2); 
1A270:  MOVLW  82
1A272:  MOVLB  8
1A274:  MOVWF  xEE
1A276:  CLRF   xF0
1A278:  MOVLW  02
1A27A:  MOVWF  xEF
1A27C:  MOVLB  0
1A27E:  CALL   4FD4
....................    write16(ADDR_E1_POS,0); 
1A282:  MOVLW  7E
1A284:  MOVLB  8
1A286:  MOVWF  xEE
1A288:  CLRF   xF0
1A28A:  CLRF   xEF
1A28C:  MOVLB  0
1A28E:  CALL   4FD4
....................    write16(ADDR_E1_PORT,0); 
1A292:  MOVLW  AA
1A294:  MOVLB  8
1A296:  MOVWF  xEE
1A298:  CLRF   xF0
1A29A:  CLRF   xEF
1A29C:  MOVLB  0
1A29E:  CALL   4FD4
....................    write16(ADDR_E1_TYPE,2); 
1A2A2:  MOVLW  7A
1A2A4:  MOVLB  8
1A2A6:  MOVWF  xEE
1A2A8:  CLRF   xF0
1A2AA:  MOVLW  02
1A2AC:  MOVWF  xEF
1A2AE:  MOVLB  0
1A2B0:  CALL   4FD4
....................    write16(ADDR_M1_RUN,270); 
1A2B4:  MOVLW  76
1A2B6:  MOVLB  8
1A2B8:  MOVWF  xEE
1A2BA:  MOVLW  01
1A2BC:  MOVWF  xF0
1A2BE:  MOVLW  0E
1A2C0:  MOVWF  xEF
1A2C2:  MOVLB  0
1A2C4:  CALL   4FD4
....................    write16(ADDR_M1_BKLSH,0); 
1A2C8:  MOVLW  72
1A2CA:  MOVLB  8
1A2CC:  MOVWF  xEE
1A2CE:  CLRF   xF0
1A2D0:  CLRF   xEF
1A2D2:  MOVLB  0
1A2D4:  CALL   4FD4
....................    write16(ADDR_M1_ERROR,0);   
1A2D8:  MOVLW  6E
1A2DA:  MOVLB  8
1A2DC:  MOVWF  xEE
1A2DE:  CLRF   xF0
1A2E0:  CLRF   xEF
1A2E2:  MOVLB  0
1A2E4:  CALL   4FD4
....................    write16(ADDR_M1_SPR,38400); 
1A2E8:  MOVLW  AE
1A2EA:  MOVLB  8
1A2EC:  MOVWF  xEE
1A2EE:  MOVLW  96
1A2F0:  MOVWF  xF0
1A2F2:  CLRF   xEF
1A2F4:  MOVLB  0
1A2F6:  CALL   4FD4
....................    write16(ADDR_M1_COMP,0); 
1A2FA:  MOVLW  B2
1A2FC:  MOVLB  8
1A2FE:  MOVWF  xEE
1A300:  CLRF   xF0
1A302:  CLRF   xEF
1A304:  MOVLB  0
1A306:  CALL   4FD4
....................    write16(ADDR_M1_LIN_POS,0); 
1A30A:  MOVLW  B6
1A30C:  MOVLB  8
1A30E:  MOVWF  xEE
1A310:  CLRF   xF0
1A312:  CLRF   xEF
1A314:  MOVLB  0
1A316:  CALL   4FD4
....................    write16(ADDR_E1_INDEX,1); 
1A31A:  MOVLW  BA
1A31C:  MOVLB  8
1A31E:  MOVWF  xEE
1A320:  CLRF   xF0
1A322:  MOVLW  01
1A324:  MOVWF  xEF
1A326:  MOVLB  0
1A328:  CALL   4FD4
....................    write16(ADDR_M1_EVN_SO,0); 
1A32C:  MOVLW  BE
1A32E:  MOVLB  8
1A330:  MOVWF  xEE
1A332:  CLRF   xF0
1A334:  CLRF   xEF
1A336:  MOVLB  0
1A338:  CALL   4FD4
....................    write16(ADDR_M1_ALIGN_OS,0); 
1A33C:  MOVLW  C2
1A33E:  MOVLB  8
1A340:  MOVWF  xEE
1A342:  CLRF   xF0
1A344:  CLRF   xEF
1A346:  MOVLB  0
1A348:  CALL   4FD4
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A34C:  MOVLW  88
1A34E:  MOVLB  8
1A350:  MOVWF  xEE
1A352:  CLRF   xF0
1A354:  MOVLW  01
1A356:  MOVWF  xEF
1A358:  MOVLB  0
1A35A:  CALL   4FD4
....................    write16(ADDR_M2_MODE,HALF); 
1A35E:  MOVLW  8C
1A360:  MOVLB  8
1A362:  MOVWF  xEE
1A364:  CLRF   xF0
1A366:  MOVLW  01
1A368:  MOVWF  xEF
1A36A:  MOVLB  0
1A36C:  CALL   4FD4
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
1A370:  MOVLW  90
1A372:  MOVLB  8
1A374:  MOVWF  xEE
1A376:  CLRF   xF0
1A378:  MOVLW  05
1A37A:  MOVWF  xEF
1A37C:  MOVLB  0
1A37E:  CALL   4FD4
....................    write16(ADDR_M2_POS_DIR,0); 
1A382:  MOVLW  94
1A384:  MOVLB  8
1A386:  MOVWF  xEE
1A388:  CLRF   xF0
1A38A:  CLRF   xEF
1A38C:  MOVLB  0
1A38E:  CALL   4FD4
....................    write16(ADDR_M2_PWM_HLD,0); 
1A392:  MOVLW  98
1A394:  MOVLB  8
1A396:  MOVWF  xEE
1A398:  CLRF   xF0
1A39A:  CLRF   xEF
1A39C:  MOVLB  0
1A39E:  CALL   4FD4
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A3A2:  MOVLW  9C
1A3A4:  MOVLB  8
1A3A6:  MOVWF  xEE
1A3A8:  CLRF   xF0
1A3AA:  MOVLW  7F
1A3AC:  MOVWF  xEF
1A3AE:  MOVLB  0
1A3B0:  CALL   4FD4
....................    write16(ADDR_M2_GB_ERR,0); 
1A3B4:  MOVLW  A0
1A3B6:  MOVLB  8
1A3B8:  MOVWF  xEE
1A3BA:  CLRF   xF0
1A3BC:  CLRF   xEF
1A3BE:  MOVLB  0
1A3C0:  CALL   4FD4
....................    write16(ADDR_E2_CPR,0); 
1A3C4:  MOVLW  A4
1A3C6:  MOVLB  8
1A3C8:  MOVWF  xEE
1A3CA:  CLRF   xF0
1A3CC:  CLRF   xEF
1A3CE:  MOVLB  0
1A3D0:  CALL   4FD4
....................    write16(ADDR_E2_PPR,0);   
1A3D4:  MOVLW  A8
1A3D6:  MOVLB  8
1A3D8:  MOVWF  xEE
1A3DA:  CLRF   xF0
1A3DC:  CLRF   xEF
1A3DE:  MOVLB  0
1A3E0:  CALL   4FD4
....................    write16(ADDR_E2_MODE,0); 
1A3E4:  MOVLW  84
1A3E6:  MOVLB  8
1A3E8:  MOVWF  xEE
1A3EA:  CLRF   xF0
1A3EC:  CLRF   xEF
1A3EE:  MOVLB  0
1A3F0:  CALL   4FD4
....................    write16(ADDR_E2_POS,0); 
1A3F4:  MOVLW  80
1A3F6:  MOVLB  8
1A3F8:  MOVWF  xEE
1A3FA:  CLRF   xF0
1A3FC:  CLRF   xEF
1A3FE:  MOVLB  0
1A400:  CALL   4FD4
....................    write16(ADDR_E2_PORT,0); 
1A404:  MOVLW  AC
1A406:  MOVLB  8
1A408:  MOVWF  xEE
1A40A:  CLRF   xF0
1A40C:  CLRF   xEF
1A40E:  MOVLB  0
1A410:  CALL   4FD4
....................    write16(ADDR_E2_TYPE,0); 
1A414:  MOVLW  7C
1A416:  MOVLB  8
1A418:  MOVWF  xEE
1A41A:  CLRF   xF0
1A41C:  CLRF   xEF
1A41E:  MOVLB  0
1A420:  CALL   4FD4
....................    write16(ADDR_M2_RUN,0); 
1A424:  MOVLW  78
1A426:  MOVLB  8
1A428:  MOVWF  xEE
1A42A:  CLRF   xF0
1A42C:  CLRF   xEF
1A42E:  MOVLB  0
1A430:  CALL   4FD4
....................    write16(ADDR_M2_BKLSH,0); 
1A434:  MOVLW  74
1A436:  MOVLB  8
1A438:  MOVWF  xEE
1A43A:  CLRF   xF0
1A43C:  CLRF   xEF
1A43E:  MOVLB  0
1A440:  CALL   4FD4
....................    write16(ADDR_M2_ERROR,0);   
1A444:  MOVLW  70
1A446:  MOVLB  8
1A448:  MOVWF  xEE
1A44A:  CLRF   xF0
1A44C:  CLRF   xEF
1A44E:  MOVLB  0
1A450:  CALL   4FD4
....................    write16(ADDR_M2_SPR,0); 
1A454:  MOVLW  B0
1A456:  MOVLB  8
1A458:  MOVWF  xEE
1A45A:  CLRF   xF0
1A45C:  CLRF   xEF
1A45E:  MOVLB  0
1A460:  CALL   4FD4
....................    write16(ADDR_M2_COMP,0); 
1A464:  MOVLW  B4
1A466:  MOVLB  8
1A468:  MOVWF  xEE
1A46A:  CLRF   xF0
1A46C:  CLRF   xEF
1A46E:  MOVLB  0
1A470:  CALL   4FD4
....................    write16(ADDR_M2_LIN_POS,0);    
1A474:  MOVLW  B8
1A476:  MOVLB  8
1A478:  MOVWF  xEE
1A47A:  CLRF   xF0
1A47C:  CLRF   xEF
1A47E:  MOVLB  0
1A480:  CALL   4FD4
....................    write16(ADDR_E2_INDEX,0); 
1A484:  MOVLW  BC
1A486:  MOVLB  8
1A488:  MOVWF  xEE
1A48A:  CLRF   xF0
1A48C:  CLRF   xEF
1A48E:  MOVLB  0
1A490:  CALL   4FD4
....................    write16(ADDR_M2_EVN_SO,0); 
1A494:  MOVLW  C0
1A496:  MOVLB  8
1A498:  MOVWF  xEE
1A49A:  CLRF   xF0
1A49C:  CLRF   xEF
1A49E:  MOVLB  0
1A4A0:  CALL   4FD4
....................    write16(ADDR_M2_ALIGN_OS,0); 
1A4A4:  MOVLW  C4
1A4A6:  MOVLB  8
1A4A8:  MOVWF  xEE
1A4AA:  CLRF   xF0
1A4AC:  CLRF   xEF
1A4AE:  MOVLB  0
1A4B0:  CALL   4FD4
....................     
....................    get_step_vars(); 
1A4B4:  CALL   2D1A
1A4B8:  GOTO   1AD02 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A4BC:  MOVLW  86
1A4BE:  MOVLB  8
1A4C0:  MOVWF  xEE
1A4C2:  CLRF   xF0
1A4C4:  MOVLW  01
1A4C6:  MOVWF  xEF
1A4C8:  MOVLB  0
1A4CA:  CALL   4FD4
....................    write16(ADDR_M1_MODE,FULL); 
1A4CE:  MOVLW  8A
1A4D0:  MOVLB  8
1A4D2:  MOVWF  xEE
1A4D4:  CLRF   xF0
1A4D6:  CLRF   xEF
1A4D8:  MOVLB  0
1A4DA:  CALL   4FD4
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
1A4DE:  MOVLW  8E
1A4E0:  MOVLB  8
1A4E2:  MOVWF  xEE
1A4E4:  CLRF   xF0
1A4E6:  MOVLW  14
1A4E8:  MOVWF  xEF
1A4EA:  MOVLB  0
1A4EC:  CALL   4FD4
....................    write16(ADDR_M1_POS_DIR,1); 
1A4F0:  MOVLW  92
1A4F2:  MOVLB  8
1A4F4:  MOVWF  xEE
1A4F6:  CLRF   xF0
1A4F8:  MOVLW  01
1A4FA:  MOVWF  xEF
1A4FC:  MOVLB  0
1A4FE:  CALL   4FD4
....................    write16(ADDR_M1_PWM_HLD,51); 
1A502:  MOVLW  96
1A504:  MOVLB  8
1A506:  MOVWF  xEE
1A508:  CLRF   xF0
1A50A:  MOVLW  33
1A50C:  MOVWF  xEF
1A50E:  MOVLB  0
1A510:  CALL   4FD4
....................    write16(ADDR_M1_PWM_DRV,511); 
1A514:  MOVLW  9A
1A516:  MOVLB  8
1A518:  MOVWF  xEE
1A51A:  MOVLW  01
1A51C:  MOVWF  xF0
1A51E:  SETF   xEF
1A520:  MOVLB  0
1A522:  CALL   4FD4
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
1A526:  MOVLW  9E
1A528:  MOVLB  8
1A52A:  MOVWF  xEE
1A52C:  MOVLW  02
1A52E:  MOVWF  xF0
1A530:  MOVLW  9E
1A532:  MOVWF  xEF
1A534:  MOVLB  0
1A536:  CALL   4FD4
....................    write16(ADDR_E1_CPR,24); 
1A53A:  MOVLW  A2
1A53C:  MOVLB  8
1A53E:  MOVWF  xEE
1A540:  CLRF   xF0
1A542:  MOVLW  18
1A544:  MOVWF  xEF
1A546:  MOVLB  0
1A548:  CALL   4FD4
....................    write16(ADDR_E1_PPR,48); 
1A54C:  MOVLW  A6
1A54E:  MOVLB  8
1A550:  MOVWF  xEE
1A552:  CLRF   xF0
1A554:  MOVLW  30
1A556:  MOVWF  xEF
1A558:  MOVLB  0
1A55A:  CALL   4FD4
....................    write16(ADDR_E1_MODE,2); 
1A55E:  MOVLW  82
1A560:  MOVLB  8
1A562:  MOVWF  xEE
1A564:  CLRF   xF0
1A566:  MOVLW  02
1A568:  MOVWF  xEF
1A56A:  MOVLB  0
1A56C:  CALL   4FD4
....................    write16(ADDR_E1_POS,0); 
1A570:  MOVLW  7E
1A572:  MOVLB  8
1A574:  MOVWF  xEE
1A576:  CLRF   xF0
1A578:  CLRF   xEF
1A57A:  MOVLB  0
1A57C:  CALL   4FD4
....................    write16(ADDR_E1_PORT,0); 
1A580:  MOVLW  AA
1A582:  MOVLB  8
1A584:  MOVWF  xEE
1A586:  CLRF   xF0
1A588:  CLRF   xEF
1A58A:  MOVLB  0
1A58C:  CALL   4FD4
....................    write16(ADDR_E1_TYPE,2); 
1A590:  MOVLW  7A
1A592:  MOVLB  8
1A594:  MOVWF  xEE
1A596:  CLRF   xF0
1A598:  MOVLW  02
1A59A:  MOVWF  xEF
1A59C:  MOVLB  0
1A59E:  CALL   4FD4
....................    write16(ADDR_M1_RUN,34); 
1A5A2:  MOVLW  76
1A5A4:  MOVLB  8
1A5A6:  MOVWF  xEE
1A5A8:  CLRF   xF0
1A5AA:  MOVLW  22
1A5AC:  MOVWF  xEF
1A5AE:  MOVLB  0
1A5B0:  CALL   4FD4
....................    write16(ADDR_M1_BKLSH,0); 
1A5B4:  MOVLW  72
1A5B6:  MOVLB  8
1A5B8:  MOVWF  xEE
1A5BA:  CLRF   xF0
1A5BC:  CLRF   xEF
1A5BE:  MOVLB  0
1A5C0:  CALL   4FD4
....................    write16(ADDR_M1_ERROR,0);   
1A5C4:  MOVLW  6E
1A5C6:  MOVLB  8
1A5C8:  MOVWF  xEE
1A5CA:  CLRF   xF0
1A5CC:  CLRF   xEF
1A5CE:  MOVLB  0
1A5D0:  CALL   4FD4
....................    write16(ADDR_M1_SPR,6400); 
1A5D4:  MOVLW  AE
1A5D6:  MOVLB  8
1A5D8:  MOVWF  xEE
1A5DA:  MOVLW  19
1A5DC:  MOVWF  xF0
1A5DE:  CLRF   xEF
1A5E0:  MOVLB  0
1A5E2:  CALL   4FD4
....................    write16(ADDR_M1_COMP,0); 
1A5E6:  MOVLW  B2
1A5E8:  MOVLB  8
1A5EA:  MOVWF  xEE
1A5EC:  CLRF   xF0
1A5EE:  CLRF   xEF
1A5F0:  MOVLB  0
1A5F2:  CALL   4FD4
....................    write16(ADDR_M1_LIN_POS,0); 
1A5F6:  MOVLW  B6
1A5F8:  MOVLB  8
1A5FA:  MOVWF  xEE
1A5FC:  CLRF   xF0
1A5FE:  CLRF   xEF
1A600:  MOVLB  0
1A602:  CALL   4FD4
....................    write16(ADDR_E1_INDEX,1);    
1A606:  MOVLW  BA
1A608:  MOVLB  8
1A60A:  MOVWF  xEE
1A60C:  CLRF   xF0
1A60E:  MOVLW  01
1A610:  MOVWF  xEF
1A612:  MOVLB  0
1A614:  CALL   4FD4
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A618:  MOVLW  88
1A61A:  MOVLB  8
1A61C:  MOVWF  xEE
1A61E:  CLRF   xF0
1A620:  MOVLW  01
1A622:  MOVWF  xEF
1A624:  MOVLB  0
1A626:  CALL   4FD4
....................    write16(ADDR_M2_MODE,HALF); 
1A62A:  MOVLW  8C
1A62C:  MOVLB  8
1A62E:  MOVWF  xEE
1A630:  CLRF   xF0
1A632:  MOVLW  01
1A634:  MOVWF  xEF
1A636:  MOVLB  0
1A638:  CALL   4FD4
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A63C:  MOVLW  90
1A63E:  MOVLB  8
1A640:  MOVWF  xEE
1A642:  CLRF   xF0
1A644:  MOVLW  28
1A646:  MOVWF  xEF
1A648:  MOVLB  0
1A64A:  CALL   4FD4
....................    write16(ADDR_M2_POS_DIR,0); 
1A64E:  MOVLW  94
1A650:  MOVLB  8
1A652:  MOVWF  xEE
1A654:  CLRF   xF0
1A656:  CLRF   xEF
1A658:  MOVLB  0
1A65A:  CALL   4FD4
....................    write16(ADDR_M2_PWM_HLD,0); 
1A65E:  MOVLW  98
1A660:  MOVLB  8
1A662:  MOVWF  xEE
1A664:  CLRF   xF0
1A666:  CLRF   xEF
1A668:  MOVLB  0
1A66A:  CALL   4FD4
....................    write16(ADDR_M2_PWM_DRV,511); 
1A66E:  MOVLW  9C
1A670:  MOVLB  8
1A672:  MOVWF  xEE
1A674:  MOVLW  01
1A676:  MOVWF  xF0
1A678:  SETF   xEF
1A67A:  MOVLB  0
1A67C:  CALL   4FD4
....................    write16(ADDR_M2_GB_ERR,0); 
1A680:  MOVLW  A0
1A682:  MOVLB  8
1A684:  MOVWF  xEE
1A686:  CLRF   xF0
1A688:  CLRF   xEF
1A68A:  MOVLB  0
1A68C:  CALL   4FD4
....................    write16(ADDR_E2_CPR,0); 
1A690:  MOVLW  A4
1A692:  MOVLB  8
1A694:  MOVWF  xEE
1A696:  CLRF   xF0
1A698:  CLRF   xEF
1A69A:  MOVLB  0
1A69C:  CALL   4FD4
....................    write16(ADDR_E2_PPR,0);   
1A6A0:  MOVLW  A8
1A6A2:  MOVLB  8
1A6A4:  MOVWF  xEE
1A6A6:  CLRF   xF0
1A6A8:  CLRF   xEF
1A6AA:  MOVLB  0
1A6AC:  CALL   4FD4
....................    write16(ADDR_E2_MODE,0); 
1A6B0:  MOVLW  84
1A6B2:  MOVLB  8
1A6B4:  MOVWF  xEE
1A6B6:  CLRF   xF0
1A6B8:  CLRF   xEF
1A6BA:  MOVLB  0
1A6BC:  CALL   4FD4
....................    write16(ADDR_E2_POS,0); 
1A6C0:  MOVLW  80
1A6C2:  MOVLB  8
1A6C4:  MOVWF  xEE
1A6C6:  CLRF   xF0
1A6C8:  CLRF   xEF
1A6CA:  MOVLB  0
1A6CC:  CALL   4FD4
....................    write16(ADDR_E2_PORT,0); 
1A6D0:  MOVLW  AC
1A6D2:  MOVLB  8
1A6D4:  MOVWF  xEE
1A6D6:  CLRF   xF0
1A6D8:  CLRF   xEF
1A6DA:  MOVLB  0
1A6DC:  CALL   4FD4
....................    write16(ADDR_E2_TYPE,0); 
1A6E0:  MOVLW  7C
1A6E2:  MOVLB  8
1A6E4:  MOVWF  xEE
1A6E6:  CLRF   xF0
1A6E8:  CLRF   xEF
1A6EA:  MOVLB  0
1A6EC:  CALL   4FD4
....................    write16(ADDR_M2_RUN,0); 
1A6F0:  MOVLW  78
1A6F2:  MOVLB  8
1A6F4:  MOVWF  xEE
1A6F6:  CLRF   xF0
1A6F8:  CLRF   xEF
1A6FA:  MOVLB  0
1A6FC:  CALL   4FD4
....................    write16(ADDR_M2_BKLSH,0); 
1A700:  MOVLW  74
1A702:  MOVLB  8
1A704:  MOVWF  xEE
1A706:  CLRF   xF0
1A708:  CLRF   xEF
1A70A:  MOVLB  0
1A70C:  CALL   4FD4
....................    write16(ADDR_M2_ERROR,0);   
1A710:  MOVLW  70
1A712:  MOVLB  8
1A714:  MOVWF  xEE
1A716:  CLRF   xF0
1A718:  CLRF   xEF
1A71A:  MOVLB  0
1A71C:  CALL   4FD4
....................    write16(ADDR_M2_SPR,0); 
1A720:  MOVLW  B0
1A722:  MOVLB  8
1A724:  MOVWF  xEE
1A726:  CLRF   xF0
1A728:  CLRF   xEF
1A72A:  MOVLB  0
1A72C:  CALL   4FD4
....................    write16(ADDR_M2_COMP,0); 
1A730:  MOVLW  B4
1A732:  MOVLB  8
1A734:  MOVWF  xEE
1A736:  CLRF   xF0
1A738:  CLRF   xEF
1A73A:  MOVLB  0
1A73C:  CALL   4FD4
....................    write16(ADDR_M2_LIN_POS,0);   
1A740:  MOVLW  B8
1A742:  MOVLB  8
1A744:  MOVWF  xEE
1A746:  CLRF   xF0
1A748:  CLRF   xEF
1A74A:  MOVLB  0
1A74C:  CALL   4FD4
....................    write16(ADDR_E2_INDEX,0);    
1A750:  MOVLW  BC
1A752:  MOVLB  8
1A754:  MOVWF  xEE
1A756:  CLRF   xF0
1A758:  CLRF   xEF
1A75A:  MOVLB  0
1A75C:  CALL   4FD4
....................     
....................    get_step_vars(); 
1A760:  CALL   2D1A
1A764:  GOTO   1AD02 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A768:  MOVLW  86
1A76A:  MOVLB  8
1A76C:  MOVWF  xEE
1A76E:  CLRF   xF0
1A770:  MOVLW  01
1A772:  MOVWF  xEF
1A774:  MOVLB  0
1A776:  CALL   4FD4
....................    write16(ADDR_M1_MODE,FULL); 
1A77A:  MOVLW  8A
1A77C:  MOVLB  8
1A77E:  MOVWF  xEE
1A780:  CLRF   xF0
1A782:  CLRF   xEF
1A784:  MOVLB  0
1A786:  CALL   4FD4
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A78A:  MOVLW  8E
1A78C:  MOVLB  8
1A78E:  MOVWF  xEE
1A790:  CLRF   xF0
1A792:  MOVLW  0A
1A794:  MOVWF  xEF
1A796:  MOVLB  0
1A798:  CALL   4FD4
....................    write16(ADDR_M1_POS_DIR,0); 
1A79C:  MOVLW  92
1A79E:  MOVLB  8
1A7A0:  MOVWF  xEE
1A7A2:  CLRF   xF0
1A7A4:  CLRF   xEF
1A7A6:  MOVLB  0
1A7A8:  CALL   4FD4
....................    write16(ADDR_M1_PWM_HLD,0); 
1A7AC:  MOVLW  96
1A7AE:  MOVLB  8
1A7B0:  MOVWF  xEE
1A7B2:  CLRF   xF0
1A7B4:  CLRF   xEF
1A7B6:  MOVLB  0
1A7B8:  CALL   4FD4
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A7BC:  MOVLW  9A
1A7BE:  MOVLB  8
1A7C0:  MOVWF  xEE
1A7C2:  CLRF   xF0
1A7C4:  MOVLW  7F
1A7C6:  MOVWF  xEF
1A7C8:  MOVLB  0
1A7CA:  CALL   4FD4
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A7CE:  MOVLW  9E
1A7D0:  MOVLB  8
1A7D2:  MOVWF  xEE
1A7D4:  MOVLW  17
1A7D6:  MOVWF  xF0
1A7D8:  MOVLW  70
1A7DA:  MOVWF  xEF
1A7DC:  MOVLB  0
1A7DE:  CALL   4FD4
....................    write16(ADDR_E1_CPR,16); 
1A7E2:  MOVLW  A2
1A7E4:  MOVLB  8
1A7E6:  MOVWF  xEE
1A7E8:  CLRF   xF0
1A7EA:  MOVLW  10
1A7EC:  MOVWF  xEF
1A7EE:  MOVLB  0
1A7F0:  CALL   4FD4
....................    write16(ADDR_E1_PPR,16); 
1A7F4:  MOVLW  A6
1A7F6:  MOVLB  8
1A7F8:  MOVWF  xEE
1A7FA:  CLRF   xF0
1A7FC:  MOVLW  10
1A7FE:  MOVWF  xEF
1A800:  MOVLB  0
1A802:  CALL   4FD4
....................    write16(ADDR_E1_MODE,2); 
1A806:  MOVLW  82
1A808:  MOVLB  8
1A80A:  MOVWF  xEE
1A80C:  CLRF   xF0
1A80E:  MOVLW  02
1A810:  MOVWF  xEF
1A812:  MOVLB  0
1A814:  CALL   4FD4
....................    write16(ADDR_E1_POS,0); 
1A818:  MOVLW  7E
1A81A:  MOVLB  8
1A81C:  MOVWF  xEE
1A81E:  CLRF   xF0
1A820:  CLRF   xEF
1A822:  MOVLB  0
1A824:  CALL   4FD4
....................    write16(ADDR_E1_PORT,0); 
1A828:  MOVLW  AA
1A82A:  MOVLB  8
1A82C:  MOVWF  xEE
1A82E:  CLRF   xF0
1A830:  CLRF   xEF
1A832:  MOVLB  0
1A834:  CALL   4FD4
....................    write16(ADDR_E1_TYPE,2); 
1A838:  MOVLW  7A
1A83A:  MOVLB  8
1A83C:  MOVWF  xEE
1A83E:  CLRF   xF0
1A840:  MOVLW  02
1A842:  MOVWF  xEF
1A844:  MOVLB  0
1A846:  CALL   4FD4
....................    write16(ADDR_M1_RUN,270); 
1A84A:  MOVLW  76
1A84C:  MOVLB  8
1A84E:  MOVWF  xEE
1A850:  MOVLW  01
1A852:  MOVWF  xF0
1A854:  MOVLW  0E
1A856:  MOVWF  xEF
1A858:  MOVLB  0
1A85A:  CALL   4FD4
....................    write16(ADDR_M1_BKLSH,0); 
1A85E:  MOVLW  72
1A860:  MOVLB  8
1A862:  MOVWF  xEE
1A864:  CLRF   xF0
1A866:  CLRF   xEF
1A868:  MOVLB  0
1A86A:  CALL   4FD4
....................    write16(ADDR_M1_ERROR,0);   
1A86E:  MOVLW  6E
1A870:  MOVLB  8
1A872:  MOVWF  xEE
1A874:  CLRF   xF0
1A876:  CLRF   xEF
1A878:  MOVLB  0
1A87A:  CALL   4FD4
....................    write16(ADDR_M1_SPR,38400); 
1A87E:  MOVLW  AE
1A880:  MOVLB  8
1A882:  MOVWF  xEE
1A884:  MOVLW  96
1A886:  MOVWF  xF0
1A888:  CLRF   xEF
1A88A:  MOVLB  0
1A88C:  CALL   4FD4
....................    write16(ADDR_M1_COMP,0); 
1A890:  MOVLW  B2
1A892:  MOVLB  8
1A894:  MOVWF  xEE
1A896:  CLRF   xF0
1A898:  CLRF   xEF
1A89A:  MOVLB  0
1A89C:  CALL   4FD4
....................    write16(ADDR_M1_LIN_POS,0); 
1A8A0:  MOVLW  B6
1A8A2:  MOVLB  8
1A8A4:  MOVWF  xEE
1A8A6:  CLRF   xF0
1A8A8:  CLRF   xEF
1A8AA:  MOVLB  0
1A8AC:  CALL   4FD4
....................    write16(ADDR_E1_INDEX,1); 
1A8B0:  MOVLW  BA
1A8B2:  MOVLB  8
1A8B4:  MOVWF  xEE
1A8B6:  CLRF   xF0
1A8B8:  MOVLW  01
1A8BA:  MOVWF  xEF
1A8BC:  MOVLB  0
1A8BE:  CALL   4FD4
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A8C2:  MOVLW  88
1A8C4:  MOVLB  8
1A8C6:  MOVWF  xEE
1A8C8:  CLRF   xF0
1A8CA:  MOVLW  01
1A8CC:  MOVWF  xEF
1A8CE:  MOVLB  0
1A8D0:  CALL   4FD4
....................    write16(ADDR_M2_MODE,HALF); 
1A8D4:  MOVLW  8C
1A8D6:  MOVLB  8
1A8D8:  MOVWF  xEE
1A8DA:  CLRF   xF0
1A8DC:  MOVLW  01
1A8DE:  MOVWF  xEF
1A8E0:  MOVLB  0
1A8E2:  CALL   4FD4
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A8E6:  MOVLW  90
1A8E8:  MOVLB  8
1A8EA:  MOVWF  xEE
1A8EC:  CLRF   xF0
1A8EE:  MOVLW  64
1A8F0:  MOVWF  xEF
1A8F2:  MOVLB  0
1A8F4:  CALL   4FD4
....................    write16(ADDR_M2_POS_DIR,0); 
1A8F8:  MOVLW  94
1A8FA:  MOVLB  8
1A8FC:  MOVWF  xEE
1A8FE:  CLRF   xF0
1A900:  CLRF   xEF
1A902:  MOVLB  0
1A904:  CALL   4FD4
....................    write16(ADDR_M2_PWM_HLD,0); 
1A908:  MOVLW  98
1A90A:  MOVLB  8
1A90C:  MOVWF  xEE
1A90E:  CLRF   xF0
1A910:  CLRF   xEF
1A912:  MOVLB  0
1A914:  CALL   4FD4
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A918:  MOVLW  9C
1A91A:  MOVLB  8
1A91C:  MOVWF  xEE
1A91E:  CLRF   xF0
1A920:  MOVLW  7F
1A922:  MOVWF  xEF
1A924:  MOVLB  0
1A926:  CALL   4FD4
....................    write16(ADDR_M2_GB_ERR,0); 
1A92A:  MOVLW  A0
1A92C:  MOVLB  8
1A92E:  MOVWF  xEE
1A930:  CLRF   xF0
1A932:  CLRF   xEF
1A934:  MOVLB  0
1A936:  CALL   4FD4
....................    write16(ADDR_E2_CPR,0); 
1A93A:  MOVLW  A4
1A93C:  MOVLB  8
1A93E:  MOVWF  xEE
1A940:  CLRF   xF0
1A942:  CLRF   xEF
1A944:  MOVLB  0
1A946:  CALL   4FD4
....................    write16(ADDR_E2_PPR,0);   
1A94A:  MOVLW  A8
1A94C:  MOVLB  8
1A94E:  MOVWF  xEE
1A950:  CLRF   xF0
1A952:  CLRF   xEF
1A954:  MOVLB  0
1A956:  CALL   4FD4
....................    write16(ADDR_E2_MODE,0); 
1A95A:  MOVLW  84
1A95C:  MOVLB  8
1A95E:  MOVWF  xEE
1A960:  CLRF   xF0
1A962:  CLRF   xEF
1A964:  MOVLB  0
1A966:  CALL   4FD4
....................    write16(ADDR_E2_POS,0); 
1A96A:  MOVLW  80
1A96C:  MOVLB  8
1A96E:  MOVWF  xEE
1A970:  CLRF   xF0
1A972:  CLRF   xEF
1A974:  MOVLB  0
1A976:  CALL   4FD4
....................    write16(ADDR_E2_PORT,0); 
1A97A:  MOVLW  AC
1A97C:  MOVLB  8
1A97E:  MOVWF  xEE
1A980:  CLRF   xF0
1A982:  CLRF   xEF
1A984:  MOVLB  0
1A986:  CALL   4FD4
....................    write16(ADDR_E2_TYPE,0); 
1A98A:  MOVLW  7C
1A98C:  MOVLB  8
1A98E:  MOVWF  xEE
1A990:  CLRF   xF0
1A992:  CLRF   xEF
1A994:  MOVLB  0
1A996:  CALL   4FD4
....................    write16(ADDR_M2_RUN,0); 
1A99A:  MOVLW  78
1A99C:  MOVLB  8
1A99E:  MOVWF  xEE
1A9A0:  CLRF   xF0
1A9A2:  CLRF   xEF
1A9A4:  MOVLB  0
1A9A6:  CALL   4FD4
....................    write16(ADDR_M2_BKLSH,0); 
1A9AA:  MOVLW  74
1A9AC:  MOVLB  8
1A9AE:  MOVWF  xEE
1A9B0:  CLRF   xF0
1A9B2:  CLRF   xEF
1A9B4:  MOVLB  0
1A9B6:  CALL   4FD4
....................    write16(ADDR_M2_ERROR,0);   
1A9BA:  MOVLW  70
1A9BC:  MOVLB  8
1A9BE:  MOVWF  xEE
1A9C0:  CLRF   xF0
1A9C2:  CLRF   xEF
1A9C4:  MOVLB  0
1A9C6:  CALL   4FD4
....................    write16(ADDR_M2_SPR,0); 
1A9CA:  MOVLW  B0
1A9CC:  MOVLB  8
1A9CE:  MOVWF  xEE
1A9D0:  CLRF   xF0
1A9D2:  CLRF   xEF
1A9D4:  MOVLB  0
1A9D6:  CALL   4FD4
....................    write16(ADDR_M2_COMP,0); 
1A9DA:  MOVLW  B4
1A9DC:  MOVLB  8
1A9DE:  MOVWF  xEE
1A9E0:  CLRF   xF0
1A9E2:  CLRF   xEF
1A9E4:  MOVLB  0
1A9E6:  CALL   4FD4
....................    write16(ADDR_M2_LIN_POS,0);    
1A9EA:  MOVLW  B8
1A9EC:  MOVLB  8
1A9EE:  MOVWF  xEE
1A9F0:  CLRF   xF0
1A9F2:  CLRF   xEF
1A9F4:  MOVLB  0
1A9F6:  CALL   4FD4
....................     
....................    get_step_vars(); 
1A9FA:  CALL   2D1A
1A9FE:  GOTO   1AD02 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1AA02:  MOVLW  86
1AA04:  MOVLB  8
1AA06:  MOVWF  xEE
1AA08:  CLRF   xF0
1AA0A:  MOVLW  01
1AA0C:  MOVWF  xEF
1AA0E:  MOVLB  0
1AA10:  CALL   4FD4
....................    write16(ADDR_M1_MODE,FULL); 
1AA14:  MOVLW  8A
1AA16:  MOVLB  8
1AA18:  MOVWF  xEE
1AA1A:  CLRF   xF0
1AA1C:  CLRF   xEF
1AA1E:  MOVLB  0
1AA20:  CALL   4FD4
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1AA24:  MOVLW  8E
1AA26:  MOVLB  8
1AA28:  MOVWF  xEE
1AA2A:  CLRF   xF0
1AA2C:  MOVLW  28
1AA2E:  MOVWF  xEF
1AA30:  MOVLB  0
1AA32:  CALL   4FD4
....................    write16(ADDR_M1_POS_DIR,1); 
1AA36:  MOVLW  92
1AA38:  MOVLB  8
1AA3A:  MOVWF  xEE
1AA3C:  CLRF   xF0
1AA3E:  MOVLW  01
1AA40:  MOVWF  xEF
1AA42:  MOVLB  0
1AA44:  CALL   4FD4
....................    write16(ADDR_M1_PWM_HLD,0); 
1AA48:  MOVLW  96
1AA4A:  MOVLB  8
1AA4C:  MOVWF  xEE
1AA4E:  CLRF   xF0
1AA50:  CLRF   xEF
1AA52:  MOVLB  0
1AA54:  CALL   4FD4
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1AA58:  MOVLW  9A
1AA5A:  MOVLB  8
1AA5C:  MOVWF  xEE
1AA5E:  CLRF   xF0
1AA60:  MOVLW  7F
1AA62:  MOVWF  xEF
1AA64:  MOVLB  0
1AA66:  CALL   4FD4
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1AA6A:  MOVLW  9E
1AA6C:  MOVLB  8
1AA6E:  MOVWF  xEE
1AA70:  MOVLW  02
1AA72:  MOVWF  xF0
1AA74:  MOVLW  9E
1AA76:  MOVWF  xEF
1AA78:  MOVLB  0
1AA7A:  CALL   4FD4
....................    write16(ADDR_E1_CPR,500); 
1AA7E:  MOVLW  A2
1AA80:  MOVLB  8
1AA82:  MOVWF  xEE
1AA84:  MOVLW  01
1AA86:  MOVWF  xF0
1AA88:  MOVLW  F4
1AA8A:  MOVWF  xEF
1AA8C:  MOVLB  0
1AA8E:  CALL   4FD4
....................    write16(ADDR_E1_PPR,50); 
1AA92:  MOVLW  A6
1AA94:  MOVLB  8
1AA96:  MOVWF  xEE
1AA98:  CLRF   xF0
1AA9A:  MOVLW  32
1AA9C:  MOVWF  xEF
1AA9E:  MOVLB  0
1AAA0:  CALL   4FD4
....................    write16(ADDR_E1_MODE,2); 
1AAA4:  MOVLW  82
1AAA6:  MOVLB  8
1AAA8:  MOVWF  xEE
1AAAA:  CLRF   xF0
1AAAC:  MOVLW  02
1AAAE:  MOVWF  xEF
1AAB0:  MOVLB  0
1AAB2:  CALL   4FD4
....................    write16(ADDR_E1_POS,0); 
1AAB6:  MOVLW  7E
1AAB8:  MOVLB  8
1AABA:  MOVWF  xEE
1AABC:  CLRF   xF0
1AABE:  CLRF   xEF
1AAC0:  MOVLB  0
1AAC2:  CALL   4FD4
....................    write16(ADDR_E1_PORT,0); 
1AAC6:  MOVLW  AA
1AAC8:  MOVLB  8
1AACA:  MOVWF  xEE
1AACC:  CLRF   xF0
1AACE:  CLRF   xEF
1AAD0:  MOVLB  0
1AAD2:  CALL   4FD4
....................    write16(ADDR_E1_TYPE,1); 
1AAD6:  MOVLW  7A
1AAD8:  MOVLB  8
1AADA:  MOVWF  xEE
1AADC:  CLRF   xF0
1AADE:  MOVLW  01
1AAE0:  MOVWF  xEF
1AAE2:  MOVLB  0
1AAE4:  CALL   4FD4
....................    write16(ADDR_M1_RUN,0); 
1AAE8:  MOVLW  76
1AAEA:  MOVLB  8
1AAEC:  MOVWF  xEE
1AAEE:  CLRF   xF0
1AAF0:  CLRF   xEF
1AAF2:  MOVLB  0
1AAF4:  CALL   4FD4
....................    write16(ADDR_M1_BKLSH,1300); 
1AAF8:  MOVLW  72
1AAFA:  MOVLB  8
1AAFC:  MOVWF  xEE
1AAFE:  MOVLW  05
1AB00:  MOVWF  xF0
1AB02:  MOVLW  14
1AB04:  MOVWF  xEF
1AB06:  MOVLB  0
1AB08:  CALL   4FD4
....................    write16(ADDR_M1_ERROR,0);   
1AB0C:  MOVLW  6E
1AB0E:  MOVLB  8
1AB10:  MOVWF  xEE
1AB12:  CLRF   xF0
1AB14:  CLRF   xEF
1AB16:  MOVLB  0
1AB18:  CALL   4FD4
....................    write16(ADDR_M1_SPR,20000); 
1AB1C:  MOVLW  AE
1AB1E:  MOVLB  8
1AB20:  MOVWF  xEE
1AB22:  MOVLW  4E
1AB24:  MOVWF  xF0
1AB26:  MOVLW  20
1AB28:  MOVWF  xEF
1AB2A:  MOVLB  0
1AB2C:  CALL   4FD4
....................    write16(ADDR_M1_COMP,0); 
1AB30:  MOVLW  B2
1AB32:  MOVLB  8
1AB34:  MOVWF  xEE
1AB36:  CLRF   xF0
1AB38:  CLRF   xEF
1AB3A:  MOVLB  0
1AB3C:  CALL   4FD4
....................    write16(ADDR_M1_LIN_POS,0); 
1AB40:  MOVLW  B6
1AB42:  MOVLB  8
1AB44:  MOVWF  xEE
1AB46:  CLRF   xF0
1AB48:  CLRF   xEF
1AB4A:  MOVLB  0
1AB4C:  CALL   4FD4
....................    write16(ADDR_E1_INDEX,0); 
1AB50:  MOVLW  BA
1AB52:  MOVLB  8
1AB54:  MOVWF  xEE
1AB56:  CLRF   xF0
1AB58:  CLRF   xEF
1AB5A:  MOVLB  0
1AB5C:  CALL   4FD4
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1AB60:  MOVLW  88
1AB62:  MOVLB  8
1AB64:  MOVWF  xEE
1AB66:  CLRF   xF0
1AB68:  MOVLW  01
1AB6A:  MOVWF  xEF
1AB6C:  MOVLB  0
1AB6E:  CALL   4FD4
....................    write16(ADDR_M2_MODE,HALF); 
1AB72:  MOVLW  8C
1AB74:  MOVLB  8
1AB76:  MOVWF  xEE
1AB78:  CLRF   xF0
1AB7A:  MOVLW  01
1AB7C:  MOVWF  xEF
1AB7E:  MOVLB  0
1AB80:  CALL   4FD4
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1AB84:  MOVLW  90
1AB86:  MOVLB  8
1AB88:  MOVWF  xEE
1AB8A:  CLRF   xF0
1AB8C:  MOVLW  28
1AB8E:  MOVWF  xEF
1AB90:  MOVLB  0
1AB92:  CALL   4FD4
....................    write16(ADDR_M2_POS_DIR,1); 
1AB96:  MOVLW  94
1AB98:  MOVLB  8
1AB9A:  MOVWF  xEE
1AB9C:  CLRF   xF0
1AB9E:  MOVLW  01
1ABA0:  MOVWF  xEF
1ABA2:  MOVLB  0
1ABA4:  CALL   4FD4
....................    write16(ADDR_M2_PWM_HLD,0); 
1ABA8:  MOVLW  98
1ABAA:  MOVLB  8
1ABAC:  MOVWF  xEE
1ABAE:  CLRF   xF0
1ABB0:  CLRF   xEF
1ABB2:  MOVLB  0
1ABB4:  CALL   4FD4
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1ABB8:  MOVLW  9C
1ABBA:  MOVLB  8
1ABBC:  MOVWF  xEE
1ABBE:  CLRF   xF0
1ABC0:  MOVLW  7F
1ABC2:  MOVWF  xEF
1ABC4:  MOVLB  0
1ABC6:  CALL   4FD4
....................    write16(ADDR_M2_GB_ERR,0); 
1ABCA:  MOVLW  A0
1ABCC:  MOVLB  8
1ABCE:  MOVWF  xEE
1ABD0:  CLRF   xF0
1ABD2:  CLRF   xEF
1ABD4:  MOVLB  0
1ABD6:  CALL   4FD4
....................    write16(ADDR_E2_CPR,0); 
1ABDA:  MOVLW  A4
1ABDC:  MOVLB  8
1ABDE:  MOVWF  xEE
1ABE0:  CLRF   xF0
1ABE2:  CLRF   xEF
1ABE4:  MOVLB  0
1ABE6:  CALL   4FD4
....................    write16(ADDR_E2_PPR,0);   
1ABEA:  MOVLW  A8
1ABEC:  MOVLB  8
1ABEE:  MOVWF  xEE
1ABF0:  CLRF   xF0
1ABF2:  CLRF   xEF
1ABF4:  MOVLB  0
1ABF6:  CALL   4FD4
....................    write16(ADDR_E2_MODE,0); 
1ABFA:  MOVLW  84
1ABFC:  MOVLB  8
1ABFE:  MOVWF  xEE
1AC00:  CLRF   xF0
1AC02:  CLRF   xEF
1AC04:  MOVLB  0
1AC06:  CALL   4FD4
....................    write16(ADDR_E2_POS,0); 
1AC0A:  MOVLW  80
1AC0C:  MOVLB  8
1AC0E:  MOVWF  xEE
1AC10:  CLRF   xF0
1AC12:  CLRF   xEF
1AC14:  MOVLB  0
1AC16:  CALL   4FD4
....................    write16(ADDR_E2_PORT,0); 
1AC1A:  MOVLW  AC
1AC1C:  MOVLB  8
1AC1E:  MOVWF  xEE
1AC20:  CLRF   xF0
1AC22:  CLRF   xEF
1AC24:  MOVLB  0
1AC26:  CALL   4FD4
....................    write16(ADDR_E2_TYPE,0); 
1AC2A:  MOVLW  7C
1AC2C:  MOVLB  8
1AC2E:  MOVWF  xEE
1AC30:  CLRF   xF0
1AC32:  CLRF   xEF
1AC34:  MOVLB  0
1AC36:  CALL   4FD4
....................    write16(ADDR_M2_RUN,0); 
1AC3A:  MOVLW  78
1AC3C:  MOVLB  8
1AC3E:  MOVWF  xEE
1AC40:  CLRF   xF0
1AC42:  CLRF   xEF
1AC44:  MOVLB  0
1AC46:  CALL   4FD4
....................    write16(ADDR_M2_BKLSH,0); 
1AC4A:  MOVLW  74
1AC4C:  MOVLB  8
1AC4E:  MOVWF  xEE
1AC50:  CLRF   xF0
1AC52:  CLRF   xEF
1AC54:  MOVLB  0
1AC56:  CALL   4FD4
....................    write16(ADDR_M2_ERROR,0);   
1AC5A:  MOVLW  70
1AC5C:  MOVLB  8
1AC5E:  MOVWF  xEE
1AC60:  CLRF   xF0
1AC62:  CLRF   xEF
1AC64:  MOVLB  0
1AC66:  CALL   4FD4
....................    write16(ADDR_M2_SPR,0); 
1AC6A:  MOVLW  B0
1AC6C:  MOVLB  8
1AC6E:  MOVWF  xEE
1AC70:  CLRF   xF0
1AC72:  CLRF   xEF
1AC74:  MOVLB  0
1AC76:  CALL   4FD4
....................    write16(ADDR_M2_COMP,0); 
1AC7A:  MOVLW  B4
1AC7C:  MOVLB  8
1AC7E:  MOVWF  xEE
1AC80:  CLRF   xF0
1AC82:  CLRF   xEF
1AC84:  MOVLB  0
1AC86:  CALL   4FD4
....................    write16(ADDR_M2_LIN_POS,0);    
1AC8A:  MOVLW  B8
1AC8C:  MOVLB  8
1AC8E:  MOVWF  xEE
1AC90:  CLRF   xF0
1AC92:  CLRF   xEF
1AC94:  MOVLB  0
1AC96:  CALL   4FD4
....................    write16(ADDR_E2_INDEX,0); 
1AC9A:  MOVLW  BC
1AC9C:  MOVLB  8
1AC9E:  MOVWF  xEE
1ACA0:  CLRF   xF0
1ACA2:  CLRF   xEF
1ACA4:  MOVLB  0
1ACA6:  CALL   4FD4
....................     
....................    get_step_vars(); 
1ACAA:  CALL   2D1A
1ACAE:  GOTO   1AD02 (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
02998:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
0299A:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
0299C:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
0299E:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
029A0:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
029A2:  BCF    F90.5
....................    set_pwm1_duty(0);    
029A4:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
029A6:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
029A8:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
029AA:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
029AC:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
029AE:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
029B0:  BCF    F8D.5
....................    set_pwm2_duty(0);  
029B2:  MOVLB  F
029B4:  CLRF   x4F
....................  
....................    output_low(VENC1); 
029B6:  BCF    F8E.6
....................    output_low(VENC2);         
029B8:  BCF    F8E.7
....................    output_low(VHBRDG); 
029BA:  BCF    F8E.2
029BC:  MOVLB  0
029BE:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
0125A:  BCF    FD8.0
0125C:  MOVLB  7
0125E:  RLCF   x40,W
01260:  CLRF   03
01262:  ADDLW  4E
01264:  MOVWF  FE9
01266:  MOVLW  07
01268:  ADDWFC 03,W
0126A:  MOVWF  FEA
0126C:  MOVFF  FEC,A38
01270:  MOVF   FED,F
01272:  MOVFF  FEF,A37
01276:  MOVLB  A
01278:  MOVF   x37,F
0127A:  BTFSS  FD8.2
0127C:  BRA    1404
0127E:  MOVF   x38,F
01280:  BTFSS  FD8.2
01282:  BRA    1404
....................       if(m_way[motor]==POS) { 
01284:  BCF    FD8.0
01286:  MOVLB  7
01288:  RLCF   x40,W
0128A:  CLRF   03
0128C:  ADDLW  86
0128E:  MOVWF  FE9
01290:  MOVLW  07
01292:  ADDWFC 03,W
01294:  MOVWF  FEA
01296:  MOVFF  FEC,A38
0129A:  MOVF   FED,F
0129C:  MOVFF  FEF,A37
012A0:  MOVLB  A
012A2:  MOVF   x37,F
012A4:  BNZ   133E
012A6:  MOVF   x38,F
012A8:  BNZ   133E
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
012AA:  BCF    FD8.0
012AC:  MOVLB  7
012AE:  RLCF   x40,W
012B0:  CLRF   03
012B2:  ADDLW  BF
012B4:  MOVWF  FE9
012B6:  MOVLW  07
012B8:  ADDWFC 03,W
012BA:  MOVWF  FEA
012BC:  MOVFF  FEC,A38
012C0:  MOVF   FED,F
012C2:  MOVFF  FEF,A37
012C6:  BCF    FD8.0
012C8:  RLCF   x40,W
012CA:  CLRF   03
012CC:  ADDLW  5E
012CE:  MOVWF  FE9
012D0:  MOVLW  07
012D2:  ADDWFC 03,W
012D4:  MOVWF  FEA
012D6:  MOVFF  FEC,03
012DA:  MOVF   FED,F
012DC:  MOVFF  FEF,01
012E0:  MOVF   03,W
012E2:  MOVLB  A
012E4:  SUBWF  x38,W
012E6:  BNC   130A
012E8:  BNZ   12F0
012EA:  MOVF   01,W
012EC:  SUBWF  x37,W
012EE:  BNC   130A
012F0:  BCF    FD8.0
012F2:  MOVLB  7
012F4:  RLCF   x40,W
012F6:  CLRF   03
012F8:  ADDLW  BF
012FA:  MOVWF  FE9
012FC:  MOVLW  07
012FE:  ADDWFC 03,W
01300:  MOVWF  FEA
01302:  CLRF   FEC
01304:  MOVF   FED,F
01306:  CLRF   FEF
01308:  MOVLB  A
....................          e_pos[motor]++; 
0130A:  BCF    FD8.0
0130C:  MOVLB  7
0130E:  RLCF   x40,W
01310:  CLRF   03
01312:  ADDLW  BF
01314:  MOVWF  FE9
01316:  MOVLW  07
01318:  ADDWFC 03,W
0131A:  MOVWF  FEA
0131C:  MOVLW  01
0131E:  ADDWF  FEE,F
01320:  BNC   1324
01322:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
01324:  BCF    FD8.0
01326:  RLCF   x40,W
01328:  CLRF   03
0132A:  ADDLW  9A
0132C:  MOVWF  FE9
0132E:  MOVLW  07
01330:  ADDWFC 03,W
01332:  MOVWF  FEA
01334:  CLRF   FEC
01336:  MOVF   FED,F
01338:  CLRF   FEF
....................       } 
0133A:  BRA    1402
0133C:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
0133E:  BCF    FD8.0
01340:  MOVLB  7
01342:  RLCF   x40,W
01344:  CLRF   03
01346:  ADDLW  86
01348:  MOVWF  FE9
0134A:  MOVLW  07
0134C:  ADDWFC 03,W
0134E:  MOVWF  FEA
01350:  MOVFF  FEC,A38
01354:  MOVF   FED,F
01356:  MOVFF  FEF,A37
0135A:  MOVLB  A
0135C:  DECFSZ x37,W
0135E:  BRA    1404
01360:  MOVF   x38,F
01362:  BNZ   1404
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01364:  BCF    FD8.0
01366:  MOVLB  7
01368:  RLCF   x40,W
0136A:  CLRF   03
0136C:  ADDLW  BF
0136E:  MOVWF  FE9
01370:  MOVLW  07
01372:  ADDWFC 03,W
01374:  MOVWF  FEA
01376:  MOVFF  FEC,A38
0137A:  MOVF   FED,F
0137C:  MOVFF  FEF,A37
01380:  MOVLB  A
01382:  MOVF   x37,F
01384:  BNZ   13D0
01386:  MOVF   x38,F
01388:  BNZ   13D0
0138A:  BCF    FD8.0
0138C:  MOVLB  7
0138E:  RLCF   x40,W
01390:  CLRF   03
01392:  ADDLW  BF
01394:  MOVWF  01
01396:  MOVLW  07
01398:  ADDWFC 03,F
0139A:  MOVLB  A
0139C:  MOVFF  03,A38
013A0:  BCF    FD8.0
013A2:  MOVLB  7
013A4:  RLCF   x40,W
013A6:  CLRF   03
013A8:  ADDLW  5E
013AA:  MOVWF  FE9
013AC:  MOVLW  07
013AE:  ADDWFC 03,W
013B0:  MOVWF  FEA
013B2:  MOVFF  FEC,03
013B6:  MOVF   FED,F
013B8:  MOVFF  FEF,A39
013BC:  MOVLB  A
013BE:  MOVFF  A38,FEA
013C2:  MOVFF  01,FE9
013C6:  MOVFF  03,FEC
013CA:  MOVF   FED,F
013CC:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
013D0:  BCF    FD8.0
013D2:  MOVLB  7
013D4:  RLCF   x40,W
013D6:  CLRF   03
013D8:  ADDLW  BF
013DA:  MOVWF  FE9
013DC:  MOVLW  07
013DE:  ADDWFC 03,W
013E0:  MOVWF  FEA
013E2:  MOVLW  FF
013E4:  ADDWF  FEF,F
013E6:  BC    13EC
013E8:  MOVF   FEE,F
013EA:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
013EC:  BCF    FD8.0
013EE:  RLCF   x40,W
013F0:  CLRF   03
013F2:  ADDLW  9A
013F4:  MOVWF  FE9
013F6:  MOVLW  07
013F8:  ADDWFC 03,W
013FA:  MOVWF  FEA
013FC:  CLRF   FEC
013FE:  MOVF   FED,F
01400:  CLRF   FEF
01402:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
01404:  BCF    FD8.0
01406:  MOVLB  7
01408:  RLCF   x40,W
0140A:  CLRF   03
0140C:  ADDLW  4E
0140E:  MOVWF  FE9
01410:  MOVLW  07
01412:  ADDWFC 03,W
01414:  MOVWF  FEA
01416:  MOVFF  FEC,A38
0141A:  MOVF   FED,F
0141C:  MOVFF  FEF,A37
01420:  MOVLB  A
01422:  DECFSZ x37,W
01424:  BRA    15AC
01426:  MOVF   x38,F
01428:  BTFSS  FD8.2
0142A:  BRA    15AC
....................       if(m_way[motor]==NEG) { 
0142C:  BCF    FD8.0
0142E:  MOVLB  7
01430:  RLCF   x40,W
01432:  CLRF   03
01434:  ADDLW  86
01436:  MOVWF  FE9
01438:  MOVLW  07
0143A:  ADDWFC 03,W
0143C:  MOVWF  FEA
0143E:  MOVFF  FEC,A38
01442:  MOVF   FED,F
01444:  MOVFF  FEF,A37
01448:  MOVLB  A
0144A:  DECFSZ x37,W
0144C:  BRA    14E6
0144E:  MOVF   x38,F
01450:  BNZ   14E6
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
01452:  BCF    FD8.0
01454:  MOVLB  7
01456:  RLCF   x40,W
01458:  CLRF   03
0145A:  ADDLW  BF
0145C:  MOVWF  FE9
0145E:  MOVLW  07
01460:  ADDWFC 03,W
01462:  MOVWF  FEA
01464:  MOVFF  FEC,A38
01468:  MOVF   FED,F
0146A:  MOVFF  FEF,A37
0146E:  BCF    FD8.0
01470:  RLCF   x40,W
01472:  CLRF   03
01474:  ADDLW  5E
01476:  MOVWF  FE9
01478:  MOVLW  07
0147A:  ADDWFC 03,W
0147C:  MOVWF  FEA
0147E:  MOVFF  FEC,03
01482:  MOVF   FED,F
01484:  MOVFF  FEF,01
01488:  MOVF   03,W
0148A:  MOVLB  A
0148C:  SUBWF  x38,W
0148E:  BNC   14B2
01490:  BNZ   1498
01492:  MOVF   01,W
01494:  SUBWF  x37,W
01496:  BNC   14B2
01498:  BCF    FD8.0
0149A:  MOVLB  7
0149C:  RLCF   x40,W
0149E:  CLRF   03
014A0:  ADDLW  BF
014A2:  MOVWF  FE9
014A4:  MOVLW  07
014A6:  ADDWFC 03,W
014A8:  MOVWF  FEA
014AA:  CLRF   FEC
014AC:  MOVF   FED,F
014AE:  CLRF   FEF
014B0:  MOVLB  A
....................          e_pos[motor]++; 
014B2:  BCF    FD8.0
014B4:  MOVLB  7
014B6:  RLCF   x40,W
014B8:  CLRF   03
014BA:  ADDLW  BF
014BC:  MOVWF  FE9
014BE:  MOVLW  07
014C0:  ADDWFC 03,W
014C2:  MOVWF  FEA
014C4:  MOVLW  01
014C6:  ADDWF  FEE,F
014C8:  BNC   14CC
014CA:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014CC:  BCF    FD8.0
014CE:  RLCF   x40,W
014D0:  CLRF   03
014D2:  ADDLW  9A
014D4:  MOVWF  FE9
014D6:  MOVLW  07
014D8:  ADDWFC 03,W
014DA:  MOVWF  FEA
014DC:  CLRF   FEC
014DE:  MOVF   FED,F
014E0:  CLRF   FEF
....................       } 
014E2:  BRA    15AA
014E4:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
014E6:  BCF    FD8.0
014E8:  MOVLB  7
014EA:  RLCF   x40,W
014EC:  CLRF   03
014EE:  ADDLW  86
014F0:  MOVWF  FE9
014F2:  MOVLW  07
014F4:  ADDWFC 03,W
014F6:  MOVWF  FEA
014F8:  MOVFF  FEC,A38
014FC:  MOVF   FED,F
014FE:  MOVFF  FEF,A37
01502:  MOVLB  A
01504:  MOVF   x37,F
01506:  BNZ   15AC
01508:  MOVF   x38,F
0150A:  BNZ   15AC
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
0150C:  BCF    FD8.0
0150E:  MOVLB  7
01510:  RLCF   x40,W
01512:  CLRF   03
01514:  ADDLW  BF
01516:  MOVWF  FE9
01518:  MOVLW  07
0151A:  ADDWFC 03,W
0151C:  MOVWF  FEA
0151E:  MOVFF  FEC,A38
01522:  MOVF   FED,F
01524:  MOVFF  FEF,A37
01528:  MOVLB  A
0152A:  MOVF   x37,F
0152C:  BNZ   1578
0152E:  MOVF   x38,F
01530:  BNZ   1578
01532:  BCF    FD8.0
01534:  MOVLB  7
01536:  RLCF   x40,W
01538:  CLRF   03
0153A:  ADDLW  BF
0153C:  MOVWF  01
0153E:  MOVLW  07
01540:  ADDWFC 03,F
01542:  MOVLB  A
01544:  MOVFF  03,A38
01548:  BCF    FD8.0
0154A:  MOVLB  7
0154C:  RLCF   x40,W
0154E:  CLRF   03
01550:  ADDLW  5E
01552:  MOVWF  FE9
01554:  MOVLW  07
01556:  ADDWFC 03,W
01558:  MOVWF  FEA
0155A:  MOVFF  FEC,03
0155E:  MOVF   FED,F
01560:  MOVFF  FEF,A39
01564:  MOVLB  A
01566:  MOVFF  A38,FEA
0156A:  MOVFF  01,FE9
0156E:  MOVFF  03,FEC
01572:  MOVF   FED,F
01574:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
01578:  BCF    FD8.0
0157A:  MOVLB  7
0157C:  RLCF   x40,W
0157E:  CLRF   03
01580:  ADDLW  BF
01582:  MOVWF  FE9
01584:  MOVLW  07
01586:  ADDWFC 03,W
01588:  MOVWF  FEA
0158A:  MOVLW  FF
0158C:  ADDWF  FEF,F
0158E:  BC    1594
01590:  MOVF   FEE,F
01592:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
01594:  BCF    FD8.0
01596:  RLCF   x40,W
01598:  CLRF   03
0159A:  ADDLW  9A
0159C:  MOVWF  FE9
0159E:  MOVLW  07
015A0:  ADDWFC 03,W
015A2:  MOVWF  FEA
015A4:  CLRF   FEC
015A6:  MOVF   FED,F
015A8:  CLRF   FEF
015AA:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
015AC:  MOVF   1F,W
015AE:  SUBLW  04
015B0:  BTFSS  FD8.2
015B2:  BRA    16E6
015B4:  MOVF   20,F
015B6:  BTFSS  FD8.2
015B8:  BRA    16E6
015BA:  BCF    FD8.0
015BC:  MOVLB  7
015BE:  RLCF   x40,W
015C0:  CLRF   03
015C2:  ADDLW  6A
015C4:  MOVWF  FE9
015C6:  MOVLW  07
015C8:  ADDWFC 03,W
015CA:  MOVWF  FEA
015CC:  MOVFF  FEC,A38
015D0:  MOVF   FED,F
015D2:  MOVFF  FEF,A37
015D6:  MOVLB  A
015D8:  MOVF   x37,W
015DA:  SUBLW  02
015DC:  BTFSS  FD8.2
015DE:  BRA    16E6
015E0:  MOVF   x38,F
015E2:  BTFSS  FD8.2
015E4:  BRA    16E6
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
015E6:  MOVLW  01
015E8:  MOVLB  7
015EA:  ADDWF  x40,W
015EC:  MOVLB  A
015EE:  MOVWF  x37
015F0:  MOVLB  7
015F2:  MOVF   x40,W
015F4:  MULLW  04
015F6:  MOVF   FF3,W
015F8:  CLRF   03
015FA:  ADDLW  A2
015FC:  MOVWF  FE9
015FE:  MOVLW  07
01600:  ADDWFC 03,W
01602:  MOVWF  FEA
01604:  MOVFF  FEF,A38
01608:  MOVFF  FEC,A39
0160C:  MOVFF  FEC,A3A
01610:  MOVFF  FEC,A3B
01614:  BCF    FD8.0
01616:  RLCF   x40,W
01618:  CLRF   03
0161A:  ADDLW  BB
0161C:  MOVWF  FE9
0161E:  MOVLW  07
01620:  ADDWFC 03,W
01622:  MOVWF  FEA
01624:  MOVFF  FEC,A3D
01628:  MOVF   FED,F
0162A:  MOVFF  FEF,A3C
0162E:  BCF    FD8.0
01630:  RLCF   x40,W
01632:  CLRF   03
01634:  ADDLW  BF
01636:  MOVWF  FE9
01638:  MOVLW  07
0163A:  ADDWFC 03,W
0163C:  MOVWF  FEA
0163E:  MOVFF  FEC,A3F
01642:  MOVF   FED,F
01644:  MOVFF  FEF,A3E
01648:  MOVLW  6D
0164A:  BTFSS  F9E.4
0164C:  BRA    164A
0164E:  MOVWF  FAD
01650:  MOVLW  3A
01652:  BTFSS  F9E.4
01654:  BRA    1652
01656:  MOVWF  FAD
01658:  MOVFF  A37,A40
0165C:  MOVLW  1B
0165E:  MOVLB  A
01660:  MOVWF  x41
01662:  MOVLB  0
01664:  RCALL  0FA6
01666:  MOVLW  2C
01668:  BTFSS  F9E.4
0166A:  BRA    1668
0166C:  MOVWF  FAD
0166E:  MOVFF  7AA,A40
01672:  MOVLW  1B
01674:  MOVLB  A
01676:  MOVWF  x41
01678:  MOVLB  0
0167A:  RCALL  0FA6
0167C:  MOVLW  69
0167E:  MOVWF  FF6
01680:  MOVLW  0F
01682:  MOVWF  FF7
01684:  MOVLW  00
01686:  MOVWF  FF8
01688:  MOVLW  03
0168A:  MOVLB  A
0168C:  MOVWF  x40
0168E:  MOVLB  0
01690:  RCALL  1024
01692:  MOVLW  41
01694:  MOVWF  FE9
01696:  MOVFF  A3B,A43
0169A:  MOVFF  A3A,A42
0169E:  MOVFF  A39,A41
016A2:  MOVFF  A38,A40
016A6:  RCALL  10EA
016A8:  MOVLW  2C
016AA:  BTFSS  F9E.4
016AC:  BRA    16AA
016AE:  MOVWF  FAD
016B0:  MOVLW  10
016B2:  MOVWF  FE9
016B4:  MOVFF  A3D,A41
016B8:  MOVFF  A3C,A40
016BC:  RCALL  11A6
016BE:  MOVLW  2C
016C0:  BTFSS  F9E.4
016C2:  BRA    16C0
016C4:  MOVWF  FAD
016C6:  MOVLW  10
016C8:  MOVWF  FE9
016CA:  MOVFF  A3F,A41
016CE:  MOVFF  A3E,A40
016D2:  RCALL  11A6
016D4:  MOVLW  0D
016D6:  BTFSS  F9E.4
016D8:  BRA    16D6
016DA:  MOVWF  FAD
016DC:  MOVLW  0A
016DE:  BTFSS  F9E.4
016E0:  BRA    16DE
016E2:  MOVWF  FAD
016E4:  MOVLB  A
....................    }    
016E6:  MOVLB  0
016E8:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A782:  MOVLB  7
0A784:  MOVF   x40,W
0A786:  XORLW  00
0A788:  MOVLB  0
0A78A:  BZ    A792
0A78C:  XORLW  01
0A78E:  BZ    A822
0A790:  BRA    A8B0
....................       case 0 : if (e_type[motor]==1) { 
0A792:  BCF    FD8.0
0A794:  MOVLB  7
0A796:  RLCF   x40,W
0A798:  CLRF   03
0A79A:  ADDLW  6A
0A79C:  MOVWF  FE9
0A79E:  MOVLW  07
0A7A0:  ADDWFC 03,W
0A7A2:  MOVWF  FEA
0A7A4:  MOVFF  FEC,8C8
0A7A8:  MOVF   FED,F
0A7AA:  MOVFF  FEF,8C7
0A7AE:  MOVLB  8
0A7B0:  DECFSZ xC7,W
0A7B2:  BRA    A7D2
0A7B4:  MOVF   xC8,F
0A7B6:  BNZ   A7D2
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A7B8:  CLRF   03
0A7BA:  MOVLB  7
0A7BC:  MOVF   x40,W
0A7BE:  ADDLW  CB
0A7C0:  MOVWF  FE9
0A7C2:  MOVLW  07
0A7C4:  ADDWFC 03,W
0A7C6:  MOVWF  FEA
0A7C8:  MOVLW  00
0A7CA:  BTFSC  F81.4
0A7CC:  MOVLW  01
0A7CE:  MOVWF  FEF
0A7D0:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A7D2:  BCF    FD8.0
0A7D4:  MOVLB  7
0A7D6:  RLCF   x40,W
0A7D8:  CLRF   03
0A7DA:  ADDLW  6A
0A7DC:  MOVWF  FE9
0A7DE:  MOVLW  07
0A7E0:  ADDWFC 03,W
0A7E2:  MOVWF  FEA
0A7E4:  MOVFF  FEC,8C8
0A7E8:  MOVF   FED,F
0A7EA:  MOVFF  FEF,8C7
0A7EE:  MOVLB  8
0A7F0:  MOVF   xC7,W
0A7F2:  SUBLW  02
0A7F4:  BNZ   A81E
0A7F6:  MOVF   xC8,F
0A7F8:  BNZ   A81E
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A7FA:  CLRF   03
0A7FC:  MOVLB  7
0A7FE:  MOVF   x40,W
0A800:  ADDLW  CB
0A802:  MOVWF  FE9
0A804:  MOVLW  07
0A806:  ADDWFC 03,W
0A808:  MOVWF  FEA
0A80A:  MOVLW  00
0A80C:  BTFSC  F81.4
0A80E:  MOVLW  01
0A810:  MOVLB  8
0A812:  MOVWF  xC9
0A814:  MOVLW  00
0A816:  BTFSC  F81.1
0A818:  MOVLW  01
0A81A:  ANDWF  xC9,W
0A81C:  MOVWF  FEF
....................                } 
....................          break; 
0A81E:  MOVLB  0
0A820:  BRA    A8B0
....................       case 1 : if (e_type[motor]==1) { 
0A822:  BCF    FD8.0
0A824:  MOVLB  7
0A826:  RLCF   x40,W
0A828:  CLRF   03
0A82A:  ADDLW  6A
0A82C:  MOVWF  FE9
0A82E:  MOVLW  07
0A830:  ADDWFC 03,W
0A832:  MOVWF  FEA
0A834:  MOVFF  FEC,8C8
0A838:  MOVF   FED,F
0A83A:  MOVFF  FEF,8C7
0A83E:  MOVLB  8
0A840:  DECFSZ xC7,W
0A842:  BRA    A862
0A844:  MOVF   xC8,F
0A846:  BNZ   A862
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A848:  CLRF   03
0A84A:  MOVLB  7
0A84C:  MOVF   x40,W
0A84E:  ADDLW  CB
0A850:  MOVWF  FE9
0A852:  MOVLW  07
0A854:  ADDWFC 03,W
0A856:  MOVWF  FEA
0A858:  MOVLW  00
0A85A:  BTFSC  F81.5
0A85C:  MOVLW  01
0A85E:  MOVWF  FEF
0A860:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A862:  BCF    FD8.0
0A864:  MOVLB  7
0A866:  RLCF   x40,W
0A868:  CLRF   03
0A86A:  ADDLW  6A
0A86C:  MOVWF  FE9
0A86E:  MOVLW  07
0A870:  ADDWFC 03,W
0A872:  MOVWF  FEA
0A874:  MOVFF  FEC,8C8
0A878:  MOVF   FED,F
0A87A:  MOVFF  FEF,8C7
0A87E:  MOVLB  8
0A880:  MOVF   xC7,W
0A882:  SUBLW  02
0A884:  BNZ   A8AE
0A886:  MOVF   xC8,F
0A888:  BNZ   A8AE
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A88A:  CLRF   03
0A88C:  MOVLB  7
0A88E:  MOVF   x40,W
0A890:  ADDLW  CB
0A892:  MOVWF  FE9
0A894:  MOVLW  07
0A896:  ADDWFC 03,W
0A898:  MOVWF  FEA
0A89A:  MOVLW  00
0A89C:  BTFSC  F81.5
0A89E:  MOVLW  01
0A8A0:  MOVLB  8
0A8A2:  MOVWF  xC9
0A8A4:  MOVLW  00
0A8A6:  BTFSC  F81.2
0A8A8:  MOVLW  01
0A8AA:  ANDWF  xC9,W
0A8AC:  MOVWF  FEF
....................                } 
....................          break; 
0A8AE:  MOVLB  0
....................    } 
0A8B0:  GOTO   A96A (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017D6:  MOVLB  7
017D8:  MOVF   x40,W
017DA:  XORLW  00
017DC:  MOVLB  0
017DE:  BZ    17E6
017E0:  XORLW  01
017E2:  BZ    1876
017E4:  BRA    1904
....................       case 0 : if (e_type[motor]==1) { 
017E6:  BCF    FD8.0
017E8:  MOVLB  7
017EA:  RLCF   x40,W
017EC:  CLRF   03
017EE:  ADDLW  6A
017F0:  MOVWF  FE9
017F2:  MOVLW  07
017F4:  ADDWFC 03,W
017F6:  MOVWF  FEA
017F8:  MOVFF  FEC,A38
017FC:  MOVF   FED,F
017FE:  MOVFF  FEF,A37
01802:  MOVLB  A
01804:  DECFSZ x37,W
01806:  BRA    1826
01808:  MOVF   x38,F
0180A:  BNZ   1826
....................                   e_ch_n[motor]=input(ENC1_IND); 
0180C:  CLRF   03
0180E:  MOVLB  7
01810:  MOVF   x40,W
01812:  ADDLW  CB
01814:  MOVWF  FE9
01816:  MOVLW  07
01818:  ADDWFC 03,W
0181A:  MOVWF  FEA
0181C:  MOVLW  00
0181E:  BTFSC  F81.4
01820:  MOVLW  01
01822:  MOVWF  FEF
01824:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01826:  BCF    FD8.0
01828:  MOVLB  7
0182A:  RLCF   x40,W
0182C:  CLRF   03
0182E:  ADDLW  6A
01830:  MOVWF  FE9
01832:  MOVLW  07
01834:  ADDWFC 03,W
01836:  MOVWF  FEA
01838:  MOVFF  FEC,A38
0183C:  MOVF   FED,F
0183E:  MOVFF  FEF,A37
01842:  MOVLB  A
01844:  MOVF   x37,W
01846:  SUBLW  02
01848:  BNZ   1872
0184A:  MOVF   x38,F
0184C:  BNZ   1872
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0184E:  CLRF   03
01850:  MOVLB  7
01852:  MOVF   x40,W
01854:  ADDLW  CB
01856:  MOVWF  FE9
01858:  MOVLW  07
0185A:  ADDWFC 03,W
0185C:  MOVWF  FEA
0185E:  MOVLW  00
01860:  BTFSC  F81.4
01862:  MOVLW  01
01864:  MOVLB  A
01866:  MOVWF  x39
01868:  MOVLW  00
0186A:  BTFSC  F81.1
0186C:  MOVLW  01
0186E:  ANDWF  x39,W
01870:  MOVWF  FEF
....................                } 
....................          break; 
01872:  MOVLB  0
01874:  BRA    1904
....................       case 1 : if (e_type[motor]==1) { 
01876:  BCF    FD8.0
01878:  MOVLB  7
0187A:  RLCF   x40,W
0187C:  CLRF   03
0187E:  ADDLW  6A
01880:  MOVWF  FE9
01882:  MOVLW  07
01884:  ADDWFC 03,W
01886:  MOVWF  FEA
01888:  MOVFF  FEC,A38
0188C:  MOVF   FED,F
0188E:  MOVFF  FEF,A37
01892:  MOVLB  A
01894:  DECFSZ x37,W
01896:  BRA    18B6
01898:  MOVF   x38,F
0189A:  BNZ   18B6
....................                   e_ch_n[motor]=input(ENC2_IND); 
0189C:  CLRF   03
0189E:  MOVLB  7
018A0:  MOVF   x40,W
018A2:  ADDLW  CB
018A4:  MOVWF  FE9
018A6:  MOVLW  07
018A8:  ADDWFC 03,W
018AA:  MOVWF  FEA
018AC:  MOVLW  00
018AE:  BTFSC  F81.5
018B0:  MOVLW  01
018B2:  MOVWF  FEF
018B4:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018B6:  BCF    FD8.0
018B8:  MOVLB  7
018BA:  RLCF   x40,W
018BC:  CLRF   03
018BE:  ADDLW  6A
018C0:  MOVWF  FE9
018C2:  MOVLW  07
018C4:  ADDWFC 03,W
018C6:  MOVWF  FEA
018C8:  MOVFF  FEC,A38
018CC:  MOVF   FED,F
018CE:  MOVFF  FEF,A37
018D2:  MOVLB  A
018D4:  MOVF   x37,W
018D6:  SUBLW  02
018D8:  BNZ   1902
018DA:  MOVF   x38,F
018DC:  BNZ   1902
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018DE:  CLRF   03
018E0:  MOVLB  7
018E2:  MOVF   x40,W
018E4:  ADDLW  CB
018E6:  MOVWF  FE9
018E8:  MOVLW  07
018EA:  ADDWFC 03,W
018EC:  MOVWF  FEA
018EE:  MOVLW  00
018F0:  BTFSC  F81.5
018F2:  MOVLW  01
018F4:  MOVLB  A
018F6:  MOVWF  x39
018F8:  MOVLW  00
018FA:  BTFSC  F81.2
018FC:  MOVLW  01
018FE:  ANDWF  x39,W
01900:  MOVWF  FEF
....................                } 
....................          break; 
01902:  MOVLB  0
....................    } 
01904:  GOTO   1A52 (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
016EA:  BCF    FD8.0
016EC:  MOVLB  7
016EE:  RLCF   x40,W
016F0:  CLRF   03
016F2:  ADDLW  BB
016F4:  MOVWF  FE9
016F6:  MOVLW  07
016F8:  ADDWFC 03,W
016FA:  MOVWF  FEA
016FC:  MOVLW  01
016FE:  ADDWF  FEE,F
01700:  BNC   1704
01702:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
01704:  MOVF   xAA,W
01706:  XORLW  00
01708:  MOVLB  0
0170A:  BZ    1716
0170C:  XORLW  01
0170E:  BZ    171C
01710:  XORLW  03
01712:  BZ    172E
01714:  BRA    1758
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
01716:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
01718:  BCF    FF0.0
....................          break; 
0171A:  BRA    1758
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
0171C:  MOVLW  02
0171E:  MOVLB  7
01720:  MOVWF  xAA
....................                disable_interrupts(INT_EXT1_L2H); 
01722:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
01724:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01726:  BSF    FF0.3
01728:  BCF    FF1.5
....................          break; 
0172A:  MOVLB  0
0172C:  BRA    1758
....................       case 2 : edge_mode=1; 
0172E:  MOVLW  01
01730:  MOVLB  7
01732:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01734:  BCF    FD8.0
01736:  RLCF   x40,W
01738:  CLRF   03
0173A:  ADDLW  BB
0173C:  MOVWF  FE9
0173E:  MOVLW  07
01740:  ADDWFC 03,W
01742:  MOVWF  FEA
01744:  MOVLW  FF
01746:  ADDWF  FEF,F
01748:  BC    174E
0174A:  MOVF   FEE,F
0174C:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
0174E:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
01750:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
01752:  BSF    FF0.3
01754:  BSF    FF1.5
....................          break; 
01756:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
01758:  RCALL  125A
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
0175A:  BCF    FF0.0
0175C:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
01760:  BCF    FD8.0
01762:  MOVLB  7
01764:  RLCF   x40,W
01766:  CLRF   03
01768:  ADDLW  BB
0176A:  MOVWF  FE9
0176C:  MOVLW  07
0176E:  ADDWFC 03,W
01770:  MOVWF  FEA
01772:  MOVLW  01
01774:  ADDWF  FEE,F
01776:  BNC   177A
01778:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
0177A:  MOVF   xAA,W
0177C:  XORLW  00
0177E:  MOVLB  0
01780:  BZ    178C
01782:  XORLW  01
01784:  BZ    1792
01786:  XORLW  03
01788:  BZ    17A4
0178A:  BRA    17CE
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
0178C:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
0178E:  BCF    FF0.1
....................          break; 
01790:  BRA    17CE
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01792:  MOVLW  02
01794:  MOVLB  7
01796:  MOVWF  xAA
....................                disable_interrupts(INT_EXT2_L2H); 
01798:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
0179A:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
0179C:  BSF    FF0.4
0179E:  BCF    FF1.4
....................          break; 
017A0:  MOVLB  0
017A2:  BRA    17CE
....................       case 2 : edge_mode=1; 
017A4:  MOVLW  01
017A6:  MOVLB  7
017A8:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
017AA:  BCF    FD8.0
017AC:  RLCF   x40,W
017AE:  CLRF   03
017B0:  ADDLW  BB
017B2:  MOVWF  FE9
017B4:  MOVLW  07
017B6:  ADDWFC 03,W
017B8:  MOVWF  FEA
017BA:  MOVLW  FF
017BC:  ADDWF  FEF,F
017BE:  BC    17C4
017C0:  MOVF   FEE,F
017C2:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017C4:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017C6:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017C8:  BSF    FF0.4
017CA:  BSF    FF1.4
....................          break; 
017CC:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017CE:  RCALL  125A
.................... } 
....................  
.................... // motor step timer interrupt 
017D0:  BCF    FF0.1
017D2:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
01908:  MOVLW  F9
0190A:  MOVWF  FB3
0190C:  MOVLW  C0
0190E:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
01910:  BCF    FD8.0
01912:  MOVLB  7
01914:  RLCF   x40,W
01916:  CLRF   03
01918:  ADDLW  8E
0191A:  MOVWF  FE9
0191C:  MOVLW  07
0191E:  ADDWFC 03,W
01920:  MOVWF  FEA
01922:  MOVLW  01
01924:  ADDWF  FEE,F
01926:  BNC   192A
01928:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
0192A:  BCF    FD8.0
0192C:  RLCF   x40,W
0192E:  CLRF   03
01930:  ADDLW  8E
01932:  MOVWF  FE9
01934:  MOVLW  07
01936:  ADDWFC 03,W
01938:  MOVWF  FEA
0193A:  MOVFF  FEC,A38
0193E:  MOVF   FED,F
01940:  MOVFF  FEF,A37
01944:  BCF    FD8.0
01946:  RLCF   x40,W
01948:  CLRF   03
0194A:  ADDLW  4A
0194C:  MOVWF  FE9
0194E:  MOVLW  07
01950:  ADDWFC 03,W
01952:  MOVWF  FEA
01954:  MOVFF  FEC,03
01958:  MOVF   FED,F
0195A:  MOVFF  FEF,01
0195E:  MOVF   03,W
01960:  MOVLB  A
01962:  SUBWF  x38,W
01964:  BTFSS  FD8.0
01966:  BRA    1A54
01968:  BNZ   1972
0196A:  MOVF   01,W
0196C:  SUBWF  x37,W
0196E:  BTFSS  FD8.0
01970:  BRA    1A54
....................    { 
....................       m_step_cnt[motor]++; 
01972:  MOVLB  7
01974:  MOVF   x40,W
01976:  MULLW  04
01978:  MOVF   FF3,W
0197A:  CLRF   03
0197C:  ADDLW  A2
0197E:  MOVWF  FE9
01980:  MOVLW  07
01982:  ADDWFC 03,W
01984:  MOVWF  FEA
01986:  MOVLW  01
01988:  ADDWF  FEE,F
0198A:  MOVLW  00
0198C:  ADDWFC FEE,F
0198E:  ADDWFC FEE,F
01990:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
01992:  BCF    FD8.0
01994:  RLCF   x40,W
01996:  CLRF   03
01998:  ADDLW  9A
0199A:  MOVWF  FE9
0199C:  MOVLW  07
0199E:  ADDWFC 03,W
019A0:  MOVWF  FEA
019A2:  MOVLW  01
019A4:  ADDWF  FEE,F
019A6:  BNC   19AA
019A8:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
019AA:  BCF    FD8.0
019AC:  RLCF   x40,W
019AE:  CLRF   03
019B0:  ADDLW  8E
019B2:  MOVWF  FE9
019B4:  MOVLW  07
019B6:  ADDWFC 03,W
019B8:  MOVWF  FEA
019BA:  CLRF   FEC
019BC:  MOVF   FED,F
019BE:  CLRF   FEF
....................  
....................       if (motor==0) 
019C0:  MOVF   x40,F
019C2:  BNZ   19C8
....................       { 
....................          output_toggle(M1_CLOCK); 
019C4:  BTG    F90.4
....................       } 
019C6:  BRA    1A28
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019C8:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019CA:  BCF    FD8.0
019CC:  RLCF   x40,W
019CE:  CLRF   03
019D0:  ADDLW  86
019D2:  MOVWF  FE9
019D4:  MOVLW  07
019D6:  ADDWFC 03,W
019D8:  MOVWF  FEA
019DA:  MOVFF  FEC,A38
019DE:  MOVF   FED,F
019E0:  MOVFF  FEF,A37
019E4:  MOVLB  A
019E6:  MOVF   x37,F
019E8:  BNZ   1A0E
019EA:  MOVF   x38,F
019EC:  BNZ   1A0E
019EE:  BCF    FD8.0
019F0:  MOVLB  7
019F2:  RLCF   x40,W
019F4:  CLRF   03
019F6:  ADDLW  B3
019F8:  MOVWF  FE9
019FA:  MOVLW  07
019FC:  ADDWFC 03,W
019FE:  MOVWF  FEA
01A00:  MOVLW  FF
01A02:  ADDWF  FEF,F
01A04:  BC    1A0A
01A06:  MOVF   FEE,F
01A08:  DECF   FED,F
01A0A:  BRA    1A28
01A0C:  MOVLB  A
....................          else m_lin_pos[motor]++;          
01A0E:  BCF    FD8.0
01A10:  MOVLB  7
01A12:  RLCF   x40,W
01A14:  CLRF   03
01A16:  ADDLW  B3
01A18:  MOVWF  FE9
01A1A:  MOVLW  07
01A1C:  ADDWFC 03,W
01A1E:  MOVWF  FEA
01A20:  MOVLW  01
01A22:  ADDWF  FEE,F
01A24:  BNC   1A28
01A26:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A28:  BCF    FD8.0
01A2A:  RLCF   x40,W
01A2C:  CLRF   03
01A2E:  ADDLW  66
01A30:  MOVWF  FE9
01A32:  MOVLW  07
01A34:  ADDWFC 03,W
01A36:  MOVWF  FEA
01A38:  MOVFF  FEC,A38
01A3C:  MOVF   FED,F
01A3E:  MOVFF  FEF,A37
01A42:  MOVLB  A
01A44:  MOVF   x37,W
01A46:  SUBLW  03
01A48:  BNZ   1A54
01A4A:  MOVF   x38,F
01A4C:  BNZ   1A54
01A4E:  MOVLB  0
01A50:  BRA    17D6
01A52:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A54:  BCF    FA1.1
01A56:  BCF    FA1.1
01A58:  MOVLB  0
01A5A:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
089E4:  BCF    FD8.0
089E6:  MOVLB  7
089E8:  RLCF   x40,W
089EA:  CLRF   03
089EC:  ADDLW  4E
089EE:  MOVWF  FE9
089F0:  MOVLW  07
089F2:  ADDWFC 03,W
089F4:  MOVWF  FEA
089F6:  MOVFF  FEC,8D9
089FA:  MOVF   FED,F
089FC:  MOVFF  FEF,8D8
08A00:  MOVLB  8
08A02:  DECFSZ xD8,W
08A04:  BRA    8A54
08A06:  MOVF   xD9,F
08A08:  BNZ   8A54
08A0A:  BCF    FD8.0
08A0C:  MOVLB  7
08A0E:  RLCF   x40,W
08A10:  CLRF   03
08A12:  ADDLW  86
08A14:  MOVWF  01
08A16:  MOVLW  07
08A18:  ADDWFC 03,F
08A1A:  MOVFF  01,8D8
08A1E:  MOVLB  8
08A20:  MOVFF  03,8D9
08A24:  BCF    FD8.0
08A26:  MOVLB  7
08A28:  RLCF   x40,W
08A2A:  CLRF   03
08A2C:  ADDLW  86
08A2E:  MOVWF  FE9
08A30:  MOVLW  07
08A32:  ADDWFC 03,W
08A34:  MOVWF  FEA
08A36:  MOVF   FEF,F
08A38:  BNZ   8A3E
08A3A:  MOVF   FEC,F
08A3C:  BZ    8A42
08A3E:  MOVLW  00
08A40:  BRA    8A44
08A42:  MOVLW  01
08A44:  MOVLB  8
08A46:  MOVFF  8D9,FEA
08A4A:  MOVFF  8D8,FE9
08A4E:  CLRF   FEC
08A50:  MOVF   FED,F
08A52:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
08A54:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
08A56:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
08A58:  BCF    FD8.0
08A5A:  MOVLB  7
08A5C:  RLCF   x40,W
08A5E:  CLRF   03
08A60:  ADDLW  42
08A62:  MOVWF  FE9
08A64:  MOVLW  07
08A66:  ADDWFC 03,W
08A68:  MOVWF  FEA
08A6A:  MOVF   FEF,F
08A6C:  BNZ   8A76
08A6E:  MOVF   FEC,F
08A70:  BNZ   8A76
08A72:  BCF    F90.2
08A74:  BRA    8A78
08A76:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
08A78:  BCF    FD8.0
08A7A:  RLCF   x40,W
08A7C:  CLRF   03
08A7E:  ADDLW  46
08A80:  MOVWF  FE9
08A82:  MOVLW  07
08A84:  ADDWFC 03,W
08A86:  MOVWF  FEA
08A88:  MOVF   FEF,F
08A8A:  BNZ   8A94
08A8C:  MOVF   FEC,F
08A8E:  BNZ   8A94
08A90:  BCF    F90.3
08A92:  BRA    8A96
08A94:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
08A96:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
08A98:  BCF    FD8.0
08A9A:  RLCF   x40,W
08A9C:  CLRF   03
08A9E:  ADDLW  86
08AA0:  MOVWF  FE9
08AA2:  MOVLW  07
08AA4:  ADDWFC 03,W
08AA6:  MOVWF  FEA
08AA8:  MOVF   FEF,F
08AAA:  BNZ   8AB4
08AAC:  MOVF   FEC,F
08AAE:  BNZ   8AB4
08AB0:  BCF    F90.5
08AB2:  BRA    8AB6
08AB4:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08AB6:  BCF    FD8.0
08AB8:  RLCF   x40,W
08ABA:  CLRF   03
08ABC:  ADDLW  56
08ABE:  MOVWF  FE9
08AC0:  MOVLW  07
08AC2:  ADDWFC 03,W
08AC4:  MOVWF  FEA
08AC6:  MOVFF  FEC,8D9
08ACA:  MOVF   FED,F
08ACC:  MOVFF  FEF,8D8
08AD0:  MOVLB  8
08AD2:  RRCF   xD9,F
08AD4:  RRCF   xD8,F
08AD6:  RRCF   xD9,F
08AD8:  RRCF   xD8,F
08ADA:  RRCF   xD9,F
08ADC:  MOVFF  8D8,FBC
08AE0:  RRCF   xD9,F
08AE2:  RRCF   xD9,W
08AE4:  ANDLW  30
08AE6:  MOVWF  00
08AE8:  MOVF   FBB,W
08AEA:  ANDLW  CF
08AEC:  IORWF  00,W
08AEE:  MOVWF  FBB
08AF0:  MOVLB  0
08AF2:  GOTO   8C7C (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08AF6:  BCF    FD8.0
08AF8:  MOVLB  7
08AFA:  RLCF   x40,W
08AFC:  CLRF   03
08AFE:  ADDLW  4E
08B00:  MOVWF  FE9
08B02:  MOVLW  07
08B04:  ADDWFC 03,W
08B06:  MOVWF  FEA
08B08:  MOVFF  FEC,8D9
08B0C:  MOVF   FED,F
08B0E:  MOVFF  FEF,8D8
08B12:  MOVLB  8
08B14:  DECFSZ xD8,W
08B16:  BRA    8B66
08B18:  MOVF   xD9,F
08B1A:  BNZ   8B66
08B1C:  BCF    FD8.0
08B1E:  MOVLB  7
08B20:  RLCF   x40,W
08B22:  CLRF   03
08B24:  ADDLW  86
08B26:  MOVWF  01
08B28:  MOVLW  07
08B2A:  ADDWFC 03,F
08B2C:  MOVFF  01,8D8
08B30:  MOVLB  8
08B32:  MOVFF  03,8D9
08B36:  BCF    FD8.0
08B38:  MOVLB  7
08B3A:  RLCF   x40,W
08B3C:  CLRF   03
08B3E:  ADDLW  86
08B40:  MOVWF  FE9
08B42:  MOVLW  07
08B44:  ADDWFC 03,W
08B46:  MOVWF  FEA
08B48:  MOVF   FEF,F
08B4A:  BNZ   8B50
08B4C:  MOVF   FEC,F
08B4E:  BZ    8B54
08B50:  MOVLW  00
08B52:  BRA    8B56
08B54:  MOVLW  01
08B56:  MOVLB  8
08B58:  MOVFF  8D9,FEA
08B5C:  MOVFF  8D8,FE9
08B60:  CLRF   FEC
08B62:  MOVF   FED,F
08B64:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08B66:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08B68:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08B6A:  BCF    FD8.0
08B6C:  MOVLB  7
08B6E:  RLCF   x40,W
08B70:  CLRF   03
08B72:  ADDLW  42
08B74:  MOVWF  FE9
08B76:  MOVLW  07
08B78:  ADDWFC 03,W
08B7A:  MOVWF  FEA
08B7C:  MOVF   FEF,F
08B7E:  BNZ   8B88
08B80:  MOVF   FEC,F
08B82:  BNZ   8B88
08B84:  BCF    F8D.2
08B86:  BRA    8B8A
08B88:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08B8A:  BCF    FD8.0
08B8C:  RLCF   x40,W
08B8E:  CLRF   03
08B90:  ADDLW  46
08B92:  MOVWF  FE9
08B94:  MOVLW  07
08B96:  ADDWFC 03,W
08B98:  MOVWF  FEA
08B9A:  MOVF   FEF,F
08B9C:  BNZ   8BA6
08B9E:  MOVF   FEC,F
08BA0:  BNZ   8BA6
08BA2:  BCF    F8D.3
08BA4:  BRA    8BA8
08BA6:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08BA8:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08BAA:  BCF    FD8.0
08BAC:  RLCF   x40,W
08BAE:  CLRF   03
08BB0:  ADDLW  86
08BB2:  MOVWF  FE9
08BB4:  MOVLW  07
08BB6:  ADDWFC 03,W
08BB8:  MOVWF  FEA
08BBA:  MOVF   FEF,F
08BBC:  BNZ   8BC6
08BBE:  MOVF   FEC,F
08BC0:  BNZ   8BC6
08BC2:  BCF    F8D.5
08BC4:  BRA    8BC8
08BC6:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08BC8:  BCF    FD8.0
08BCA:  RLCF   x40,W
08BCC:  CLRF   03
08BCE:  ADDLW  56
08BD0:  MOVWF  FE9
08BD2:  MOVLW  07
08BD4:  ADDWFC 03,W
08BD6:  MOVWF  FEA
08BD8:  MOVFF  FEC,8D9
08BDC:  MOVF   FED,F
08BDE:  MOVFF  FEF,8D8
08BE2:  MOVLB  8
08BE4:  RRCF   xD9,F
08BE6:  RRCF   xD8,F
08BE8:  RRCF   xD9,F
08BEA:  RRCF   xD8,F
08BEC:  RRCF   xD9,F
08BEE:  MOVFF  8D8,F4F
08BF2:  RRCF   xD9,F
08BF4:  RRCF   xD9,W
08BF6:  ANDLW  30
08BF8:  MOVWF  00
08BFA:  MOVLB  F
08BFC:  MOVF   x4E,W
08BFE:  ANDLW  CF
08C00:  IORWF  00,W
08C02:  MOVWF  x4E
08C04:  MOVLB  0
08C06:  GOTO   8C7C (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
089D0:  MOVLB  8
089D2:  MOVF   xEC,F
089D4:  BZ    89DC
....................       output_bit(VENC1,ON); 
089D6:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
089D8:  BSF    F8E.7
....................    } 
089DA:  BRA    89E0
....................    else {       
....................       output_bit(VENC1,OFF); 
089DC:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
089DE:  BCF    F8E.7
....................    } 
089E0:  MOVLB  0
089E2:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08D6A:  MOVLB  8
08D6C:  MOVF   xED,F
08D6E:  BNZ   8D96
08D70:  MOVF   xEE,F
08D72:  BNZ   8D96
....................       edge_mode=0; 
08D74:  MOVLB  7
08D76:  CLRF   xAA
....................       switch (motor){ 
08D78:  MOVF   x40,W
08D7A:  XORLW  00
08D7C:  MOVLB  0
08D7E:  BZ    8D86
08D80:  XORLW  01
08D82:  BZ    8D8E
08D84:  BRA    8D94
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08D86:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08D88:  BSF    FF0.3
08D8A:  BCF    FF1.5
....................             break; 
08D8C:  BRA    8D94
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08D8E:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08D90:  BSF    FF0.4
08D92:  BCF    FF1.4
....................             break; 
08D94:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08D96:  DECFSZ xED,W
08D98:  BRA    8DC0
08D9A:  MOVF   xEE,F
08D9C:  BNZ   8DC0
....................       edge_mode=0; 
08D9E:  MOVLB  7
08DA0:  CLRF   xAA
....................       switch (motor){ 
08DA2:  MOVF   x40,W
08DA4:  XORLW  00
08DA6:  MOVLB  0
08DA8:  BZ    8DB0
08DAA:  XORLW  01
08DAC:  BZ    8DB8
08DAE:  BRA    8DBE
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08DB0:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08DB2:  BSF    FF0.3
08DB4:  BSF    FF1.5
....................             break; 
08DB6:  BRA    8DBE
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08DB8:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08DBA:  BSF    FF0.4
08DBC:  BSF    FF1.4
....................             break; 
08DBE:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08DC0:  MOVF   xED,W
08DC2:  SUBLW  02
08DC4:  BNZ   8E16
08DC6:  MOVF   xEE,F
08DC8:  BNZ   8E16
08DCA:  BCF    FD8.0
08DCC:  MOVLB  7
08DCE:  RLCF   x40,W
08DD0:  CLRF   03
08DD2:  ADDLW  6A
08DD4:  MOVWF  FE9
08DD6:  MOVLW  07
08DD8:  ADDWFC 03,W
08DDA:  MOVWF  FEA
08DDC:  MOVFF  FEC,8F0
08DE0:  MOVF   FED,F
08DE2:  MOVFF  FEF,8EF
08DE6:  MOVLB  8
08DE8:  MOVF   xEF,W
08DEA:  SUBLW  02
08DEC:  BNZ   8E16
08DEE:  MOVF   xF0,F
08DF0:  BNZ   8E16
....................       edge_mode=1; 
08DF2:  MOVLW  01
08DF4:  MOVLB  7
08DF6:  MOVWF  xAA
....................       switch (motor){ 
08DF8:  MOVF   x40,W
08DFA:  XORLW  00
08DFC:  MOVLB  0
08DFE:  BZ    8E06
08E00:  XORLW  01
08E02:  BZ    8E0E
08E04:  BRA    8E14
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08E06:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08E08:  BSF    FF0.3
08E0A:  BSF    FF1.5
....................             break; 
08E0C:  BRA    8E14
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08E0E:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08E10:  BSF    FF0.4
08E12:  BSF    FF1.4
....................             break; 
08E14:  MOVLB  8
....................       }  
....................    }     
08E16:  MOVLB  0
08E18:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08F80:  MOVLB  7
08F82:  MOVF   x40,W
08F84:  XORLW  00
08F86:  MOVLB  0
08F88:  BZ    8F90
08F8A:  XORLW  01
08F8C:  BZ    8FBA
08F8E:  BRA    8FE2
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08F90:  BCF    FD8.0
08F92:  MOVLB  7
08F94:  RLCF   x40,W
08F96:  CLRF   03
08F98:  ADDLW  96
08F9A:  MOVWF  FE9
08F9C:  MOVLW  07
08F9E:  ADDWFC 03,W
08FA0:  MOVWF  FEA
08FA2:  MOVFF  FEC,8F0
08FA6:  MOVF   FED,F
08FA8:  MOVFF  FEF,8EF
08FAC:  MOVLW  6E
08FAE:  MOVLB  8
08FB0:  MOVWF  xEE
08FB2:  MOVLB  0
08FB4:  CALL   4FD4
....................          break; 
08FB8:  BRA    8FE2
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08FBA:  BCF    FD8.0
08FBC:  MOVLB  7
08FBE:  RLCF   x40,W
08FC0:  CLRF   03
08FC2:  ADDLW  96
08FC4:  MOVWF  FE9
08FC6:  MOVLW  07
08FC8:  ADDWFC 03,W
08FCA:  MOVWF  FEA
08FCC:  MOVFF  FEC,8F0
08FD0:  MOVF   FED,F
08FD2:  MOVFF  FEF,8EF
08FD6:  MOVLW  70
08FD8:  MOVLB  8
08FDA:  MOVWF  xEE
08FDC:  MOVLB  0
08FDE:  CALL   4FD4
....................          break;          
....................    } 
08FE2:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08E1A:  MOVLB  8
08E1C:  MOVF   xEC,F
08E1E:  BNZ   8E3C
....................    { 
....................       switch (motor) 
08E20:  MOVLB  7
08E22:  MOVF   x40,W
08E24:  XORLW  00
08E26:  MOVLB  0
08E28:  BZ    8E30
08E2A:  XORLW  01
08E2C:  BZ    8E36
08E2E:  BRA    8E3A
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08E30:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08E32:  BCF    FF0.3
....................             break; 
08E34:  BRA    8E3A
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08E36:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08E38:  BCF    FF0.4
....................             break; 
08E3A:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08E3C:  DECFSZ xEC,W
08E3E:  BRA    8EA4
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08E40:  BCF    FD8.0
08E42:  MOVLB  7
08E44:  RLCF   x40,W
08E46:  CLRF   03
08E48:  ADDLW  6A
08E4A:  MOVWF  FE9
08E4C:  MOVLW  07
08E4E:  ADDWFC 03,W
08E50:  MOVWF  FEA
08E52:  MOVFF  FEC,8EE
08E56:  MOVF   FED,F
08E58:  MOVFF  FEF,8ED
08E5C:  MOVLB  8
08E5E:  DECFSZ xED,W
08E60:  BRA    8E70
08E62:  MOVF   xEE,F
08E64:  BNZ   8E70
08E66:  CLRF   xEE
08E68:  CLRF   xED
08E6A:  MOVLB  0
08E6C:  RCALL  8D6A
08E6E:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08E70:  BCF    FD8.0
08E72:  MOVLB  7
08E74:  RLCF   x40,W
08E76:  CLRF   03
08E78:  ADDLW  6A
08E7A:  MOVWF  FE9
08E7C:  MOVLW  07
08E7E:  ADDWFC 03,W
08E80:  MOVWF  FEA
08E82:  MOVFF  FEC,8EE
08E86:  MOVF   FED,F
08E88:  MOVFF  FEF,8ED
08E8C:  MOVLB  8
08E8E:  MOVF   xED,W
08E90:  SUBLW  02
08E92:  BNZ   8EA4
08E94:  MOVF   xEE,F
08E96:  BNZ   8EA4
08E98:  CLRF   xEE
08E9A:  MOVLW  01
08E9C:  MOVWF  xED
08E9E:  MOVLB  0
08EA0:  RCALL  8D6A
08EA2:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08EA4:  MOVF   xEC,W
08EA6:  SUBLW  02
08EA8:  BNZ   8EDE
08EAA:  BCF    FD8.0
08EAC:  MOVLB  7
08EAE:  RLCF   x40,W
08EB0:  CLRF   03
08EB2:  ADDLW  6A
08EB4:  MOVWF  FE9
08EB6:  MOVLW  07
08EB8:  ADDWFC 03,W
08EBA:  MOVWF  FEA
08EBC:  MOVFF  FEC,8EE
08EC0:  MOVF   FED,F
08EC2:  MOVFF  FEF,8ED
08EC6:  MOVLB  8
08EC8:  MOVF   xED,W
08ECA:  SUBLW  02
08ECC:  BNZ   8EDE
08ECE:  MOVF   xEE,F
08ED0:  BNZ   8EDE
....................    { 
....................       enable_enc_isr(2);   
08ED2:  CLRF   xEE
08ED4:  MOVLW  02
08ED6:  MOVWF  xED
08ED8:  MOVLB  0
08EDA:  RCALL  8D6A
08EDC:  MOVLB  8
....................    } 
08EDE:  MOVLB  0
08EE0:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08C0A:  BCF    FD8.0
08C0C:  MOVLB  7
08C0E:  RLCF   x40,W
08C10:  CLRF   03
08C12:  ADDLW  8E
08C14:  MOVWF  FE9
08C16:  MOVLW  07
08C18:  ADDWFC 03,W
08C1A:  MOVWF  FEA
08C1C:  CLRF   FEC
08C1E:  MOVF   FED,F
08C20:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08C22:  BCF    FD8.0
08C24:  RLCF   x40,W
08C26:  CLRF   03
08C28:  ADDLW  BB
08C2A:  MOVWF  FE9
08C2C:  MOVLW  07
08C2E:  ADDWFC 03,W
08C30:  MOVWF  FEA
08C32:  CLRF   FEC
08C34:  MOVF   FED,F
08C36:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08C38:  BCF    FD8.0
08C3A:  RLCF   x40,W
08C3C:  CLRF   03
08C3E:  ADDLW  9A
08C40:  MOVWF  FE9
08C42:  MOVLW  07
08C44:  ADDWFC 03,W
08C46:  MOVWF  FEA
08C48:  CLRF   FEC
08C4A:  MOVF   FED,F
08C4C:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08C4E:  BSF    F8E.1
....................    enc_pwr(ON); 
08C50:  MOVLW  01
08C52:  MOVLB  8
08C54:  MOVWF  xEC
08C56:  MOVLB  0
08C58:  RCALL  89D0
....................    delay_ms(100); 
08C5A:  MOVLW  64
08C5C:  MOVLB  9
08C5E:  MOVWF  xEC
08C60:  MOVLB  0
08C62:  CALL   2910
....................     
....................    switch (motor){ 
08C66:  MOVLB  7
08C68:  MOVF   x40,W
08C6A:  XORLW  00
08C6C:  MOVLB  0
08C6E:  BZ    8C76
08C70:  XORLW  01
08C72:  BZ    8C7A
08C74:  BRA    8C7C
....................       case 0 : motor_setup1(); 
08C76:  BRA    89E4
....................          break; 
08C78:  BRA    8C7C
....................       case 1 : motor_setup2(); 
08C7A:  BRA    8AF6
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08C7C:  BCF    FD8.0
08C7E:  MOVLB  7
08C80:  RLCF   x40,W
08C82:  CLRF   03
08C84:  ADDLW  8A
08C86:  MOVWF  FE9
08C88:  MOVLW  07
08C8A:  ADDWFC 03,W
08C8C:  MOVWF  FEA
08C8E:  MOVFF  FEC,8D9
08C92:  MOVF   FED,F
08C94:  MOVFF  FEF,8D8
08C98:  BCF    FD8.0
08C9A:  RLCF   x40,W
08C9C:  CLRF   03
08C9E:  ADDLW  86
08CA0:  MOVWF  FE9
08CA2:  MOVLW  07
08CA4:  ADDWFC 03,W
08CA6:  MOVWF  FEA
08CA8:  MOVFF  FEC,03
08CAC:  MOVF   FED,F
08CAE:  MOVF   FEF,W
08CB0:  MOVLB  8
08CB2:  SUBWF  xD8,W
08CB4:  BNZ   8CBC
08CB6:  MOVF   03,W
08CB8:  SUBWF  xD9,W
08CBA:  BZ    8D64
....................       m_way_rst[motor]=m_way[motor]; 
08CBC:  BCF    FD8.0
08CBE:  MOVLB  7
08CC0:  RLCF   x40,W
08CC2:  CLRF   03
08CC4:  ADDLW  8A
08CC6:  MOVWF  01
08CC8:  MOVLW  07
08CCA:  ADDWFC 03,F
08CCC:  MOVLB  8
08CCE:  MOVFF  03,8D9
08CD2:  BCF    FD8.0
08CD4:  MOVLB  7
08CD6:  RLCF   x40,W
08CD8:  CLRF   03
08CDA:  ADDLW  86
08CDC:  MOVWF  FE9
08CDE:  MOVLW  07
08CE0:  ADDWFC 03,W
08CE2:  MOVWF  FEA
08CE4:  MOVFF  FEC,03
08CE8:  MOVF   FED,F
08CEA:  MOVFF  FEF,8DA
08CEE:  MOVLB  8
08CF0:  MOVFF  8D9,FEA
08CF4:  MOVFF  01,FE9
08CF8:  MOVFF  03,FEC
08CFC:  MOVF   FED,F
08CFE:  MOVFF  8DA,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08D02:  BCF    FD8.0
08D04:  MOVLB  7
08D06:  RLCF   x40,W
08D08:  CLRF   03
08D0A:  ADDLW  9E
08D0C:  MOVWF  01
08D0E:  MOVLW  07
08D10:  ADDWFC 03,F
08D12:  MOVLB  8
08D14:  MOVFF  03,8D9
08D18:  BCF    FD8.0
08D1A:  MOVLB  7
08D1C:  RLCF   x40,W
08D1E:  CLRF   03
08D20:  ADDLW  66
08D22:  MOVWF  FE9
08D24:  MOVLW  07
08D26:  ADDWFC 03,W
08D28:  MOVWF  FEA
08D2A:  MOVFF  FEC,03
08D2E:  MOVF   FED,F
08D30:  MOVFF  FEF,8DA
08D34:  MOVLB  8
08D36:  MOVFF  8D9,FEA
08D3A:  MOVFF  01,FE9
08D3E:  MOVFF  03,FEC
08D42:  MOVF   FED,F
08D44:  MOVFF  8DA,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08D48:  BCF    FD8.0
08D4A:  MOVLB  7
08D4C:  RLCF   x40,W
08D4E:  CLRF   03
08D50:  ADDLW  66
08D52:  MOVWF  FE9
08D54:  MOVLW  07
08D56:  ADDWFC 03,W
08D58:  MOVWF  FEA
08D5A:  CLRF   FEC
08D5C:  MOVF   FED,F
08D5E:  MOVLW  05
08D60:  MOVWF  FEF
08D62:  MOVLB  8
....................    } 
08D64:  MOVLB  0
08D66:  GOTO   8EE4 (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08EE2:  BRA    8C0A
....................     
....................    m_comp[motor]=FALSE; 
08EE4:  BCF    FD8.0
08EE6:  MOVLB  7
08EE8:  RLCF   x40,W
08EEA:  CLRF   03
08EEC:  ADDLW  AF
08EEE:  MOVWF  FE9
08EF0:  MOVLW  07
08EF2:  ADDWFC 03,W
08EF4:  MOVWF  FEA
08EF6:  CLRF   FEC
08EF8:  MOVF   FED,F
08EFA:  CLRF   FEF
....................     
....................    switch (motor){ 
08EFC:  MOVF   x40,W
08EFE:  XORLW  00
08F00:  MOVLB  0
08F02:  BZ    8F0A
08F04:  XORLW  01
08F06:  BZ    8F1C
08F08:  BRA    8F2C
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08F0A:  MOVLW  B2
08F0C:  MOVLB  8
08F0E:  MOVWF  xEE
08F10:  CLRF   xF0
08F12:  CLRF   xEF
08F14:  MOVLB  0
08F16:  CALL   4FD4
....................          break; 
08F1A:  BRA    8F2C
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08F1C:  MOVLW  B4
08F1E:  MOVLB  8
08F20:  MOVWF  xEE
08F22:  CLRF   xF0
08F24:  CLRF   xEF
08F26:  MOVLB  0
08F28:  CALL   4FD4
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08F2C:  MOVLB  7
08F2E:  MOVF   x40,W
08F30:  XORLW  00
08F32:  MOVLB  0
08F34:  BZ    8F3C
08F36:  XORLW  01
08F38:  BZ    8F40
08F3A:  BRA    8F42
....................       case 0 : output_bit(M1_ENABLE, ON); 
08F3C:  BSF    F90.1
....................          break; 
08F3E:  BRA    8F42
....................       case 1 : output_bit(M2_ENABLE, ON); 
08F40:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08F42:  MOVLW  32
08F44:  MOVLB  9
08F46:  MOVWF  xEC
08F48:  MOVLB  0
08F4A:  CALL   2910
....................     
....................    set_timer3(STEP_INTERVAL); 
08F4E:  MOVLW  F9
08F50:  MOVWF  FB3
08F52:  MOVLW  C0
08F54:  MOVWF  FB2
....................    enc_isr(int_mode); 
08F56:  MOVFF  8D7,8EC
08F5A:  RCALL  8E1A
....................    clear_interrupt(INT_TIMER3); 
08F5C:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08F5E:  BCF    FD8.0
08F60:  MOVLB  7
08F62:  RLCF   x40,W
08F64:  CLRF   03
08F66:  ADDLW  92
08F68:  MOVWF  FE9
08F6A:  MOVLW  07
08F6C:  ADDWFC 03,W
08F6E:  MOVWF  FEA
08F70:  CLRF   FEC
08F72:  MOVF   FED,F
08F74:  MOVLW  01
08F76:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08F78:  BSF    FA0.1
08F7A:  MOVLB  0
08F7C:  GOTO   A1F4 (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
08606:  MOVFF  8DA,8E2
0860A:  MOVFF  8D9,8E1
0860E:  MOVFF  8D8,8E0
08612:  MOVFF  8D7,8DF
....................    enc_res    = e_cpr[motor]; 
08616:  BCF    FD8.0
08618:  MOVLB  7
0861A:  RLCF   x40,W
0861C:  CLRF   03
0861E:  ADDLW  5E
08620:  MOVWF  FE9
08622:  MOVLW  07
08624:  ADDWFC 03,W
08626:  MOVWF  FEA
08628:  MOVLB  8
0862A:  CLRF   xE6
0862C:  CLRF   xE5
0862E:  MOVFF  FEC,8E4
08632:  MOVF   FED,F
08634:  MOVFF  FEF,8E3
....................    ports      = e_ppr[motor]; 
08638:  BCF    FD8.0
0863A:  MOVLB  7
0863C:  RLCF   x40,W
0863E:  CLRF   03
08640:  ADDLW  62
08642:  MOVWF  FE9
08644:  MOVLW  07
08646:  ADDWFC 03,W
08648:  MOVWF  FEA
0864A:  MOVLB  8
0864C:  CLRF   xEE
0864E:  CLRF   xED
08650:  MOVFF  FEC,8EC
08654:  MOVF   FED,F
08656:  MOVFF  FEF,8EB
....................     
....................    enc_res = enc_res * 1000; 
0865A:  MOVFF  8E6,9F9
0865E:  MOVFF  8E5,9F8
08662:  MOVFF  8E4,9F7
08666:  MOVFF  8E3,9F6
0866A:  MOVLB  9
0866C:  CLRF   xFD
0866E:  CLRF   xFC
08670:  MOVLW  03
08672:  MOVWF  xFB
08674:  MOVLW  E8
08676:  MOVWF  xFA
08678:  MOVLB  0
0867A:  CALL   47F0
0867E:  MOVFF  03,8E6
08682:  MOVFF  02,8E5
08686:  MOVFF  01,8E4
0868A:  MOVFF  00,8E3
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
0868E:  BCF    FD8.1
08690:  CLRF   1B
08692:  BTFSC  FF2.7
08694:  BSF    1B.7
08696:  BCF    FF2.7
08698:  MOVFF  8E6,A4F
0869C:  MOVFF  8E5,A4E
086A0:  MOVFF  8E4,A4D
086A4:  MOVFF  8E3,A4C
086A8:  MOVFF  8EE,A53
086AC:  MOVFF  8ED,A52
086B0:  MOVFF  8EC,A51
086B4:  MOVFF  8EB,A50
086B8:  CALL   1056
086BC:  BTFSC  1B.7
086BE:  BSF    FF2.7
086C0:  MOVFF  03,8DE
086C4:  MOVFF  02,8DD
086C8:  MOVFF  01,8DC
086CC:  MOVFF  00,8DB
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
086D0:  MOVFF  8DA,9F9
086D4:  MOVFF  8D9,9F8
086D8:  MOVFF  8D8,9F7
086DC:  MOVFF  8D7,9F6
086E0:  MOVFF  8DE,9FD
086E4:  MOVFF  8DD,9FC
086E8:  MOVFF  8DC,9FB
086EC:  MOVFF  8DB,9FA
086F0:  CALL   47F0
086F4:  MOVLB  8
086F6:  MOVF   xDB,W
086F8:  SUBWF  00,W
086FA:  MOVWF  xDF
086FC:  MOVF   xDC,W
086FE:  SUBWFB 01,W
08700:  MOVWF  xE0
08702:  MOVF   xDD,W
08704:  SUBWFB 02,W
08706:  MOVWF  xE1
08708:  MOVF   xDE,W
0870A:  SUBWFB 03,W
0870C:  MOVWF  xE2
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
0870E:  BCF    FD8.1
08710:  CLRF   1B
08712:  BTFSC  FF2.7
08714:  BSF    1B.7
08716:  BCF    FF2.7
08718:  MOVFF  8E2,A4F
0871C:  MOVFF  8E1,A4E
08720:  MOVFF  8E0,A4D
08724:  MOVFF  8DF,A4C
08728:  MOVLB  A
0872A:  CLRF   x53
0872C:  CLRF   x52
0872E:  MOVLW  03
08730:  MOVWF  x51
08732:  MOVLW  E8
08734:  MOVWF  x50
08736:  MOVLB  0
08738:  CALL   1056
0873C:  BTFSC  1B.7
0873E:  BSF    FF2.7
08740:  MOVFF  03,8EA
08744:  MOVFF  02,8E9
08748:  MOVFF  01,8E8
0874C:  MOVFF  00,8E7
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
08750:  MOVFF  8EA,9F9
08754:  MOVFF  8E9,9F8
08758:  MOVFF  8E8,9F7
0875C:  MOVFF  8E7,9F6
08760:  MOVLB  9
08762:  CLRF   xFD
08764:  CLRF   xFC
08766:  MOVLW  03
08768:  MOVWF  xFB
0876A:  MOVLW  E8
0876C:  MOVWF  xFA
0876E:  MOVLB  0
08770:  CALL   47F0
08774:  MOVFF  03,8EA
08778:  MOVFF  02,8E9
0877C:  MOVFF  01,8E8
08780:  MOVFF  00,8E7
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
08784:  MOVLB  8
08786:  MOVF   xE7,W
08788:  SUBWF  xDF,F
0878A:  MOVF   xE8,W
0878C:  SUBWFB xE0,F
0878E:  MOVF   xE9,W
08790:  SUBWFB xE1,F
08792:  MOVF   xEA,W
08794:  SUBWFB xE2,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
08796:  BCF    FD8.1
08798:  CLRF   1B
0879A:  BTFSC  FF2.7
0879C:  BSF    1B.7
0879E:  BCF    FF2.7
087A0:  MOVFF  8EA,A4F
087A4:  MOVFF  8E9,A4E
087A8:  MOVFF  8E8,A4D
087AC:  MOVFF  8E7,A4C
087B0:  MOVLB  A
087B2:  CLRF   x53
087B4:  CLRF   x52
087B6:  MOVLW  03
087B8:  MOVWF  x51
087BA:  MOVLW  E8
087BC:  MOVWF  x50
087BE:  MOVLB  0
087C0:  CALL   1056
087C4:  BTFSC  1B.7
087C6:  BSF    FF2.7
087C8:  MOVFF  03,8EA
087CC:  MOVFF  02,8E9
087D0:  MOVFF  01,8E8
087D4:  MOVFF  00,8E7
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
087D8:  MOVLB  8
087DA:  MOVF   xE2,F
087DC:  BNZ   87F2
087DE:  MOVF   xE1,F
087E0:  BNZ   87F2
087E2:  MOVF   xE0,W
087E4:  SUBLW  00
087E6:  BC    8802
087E8:  XORLW  FF
087EA:  BNZ   87F2
087EC:  MOVF   xDF,W
087EE:  SUBLW  F3
087F0:  BC    8802
087F2:  MOVLW  01
087F4:  ADDWF  xE7,F
087F6:  BTFSC  FD8.0
087F8:  INCF   xE8,F
087FA:  BTFSC  FD8.2
087FC:  INCF   xE9,F
087FE:  BTFSC  FD8.2
08800:  INCF   xEA,F
....................    return(enc_pos); 
08802:  MOVFF  8E7,00
08806:  MOVFF  8E8,01
0880A:  MOVFF  8E9,02
0880E:  MOVFF  8EA,03
08812:  MOVLB  0
08814:  GOTO   A17C (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
08818:  BCF    FD8.0
0881A:  MOVLB  7
0881C:  RLCF   x40,W
0881E:  CLRF   03
08820:  ADDLW  BF
08822:  MOVWF  FE9
08824:  MOVLW  07
08826:  ADDWFC 03,W
08828:  MOVWF  FEA
0882A:  MOVFF  FEC,03
0882E:  MOVF   FED,F
08830:  MOVFF  FEF,01
08834:  MOVF   03,W
08836:  MOVLB  8
08838:  SUBWF  xDA,W
0883A:  BNC   8902
0883C:  BNZ   8844
0883E:  MOVF   xD9,W
08840:  SUBWF  01,W
08842:  BC    8902
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
08844:  BCF    FD8.0
08846:  MOVLB  7
08848:  RLCF   x40,W
0884A:  CLRF   03
0884C:  ADDLW  BF
0884E:  MOVWF  FE9
08850:  MOVLW  07
08852:  ADDWFC 03,W
08854:  MOVWF  FEA
08856:  MOVFF  FEC,03
0885A:  MOVF   FED,F
0885C:  MOVF   FEF,W
0885E:  MOVLB  8
08860:  SUBWF  xD9,W
08862:  MOVWF  xDB
08864:  MOVF   03,W
08866:  SUBWFB xDA,W
08868:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0886A:  BCF    FD8.0
0886C:  MOVLB  7
0886E:  RLCF   x40,W
08870:  CLRF   03
08872:  ADDLW  5E
08874:  MOVWF  FE9
08876:  MOVLW  07
08878:  ADDWFC 03,W
0887A:  MOVWF  FEA
0887C:  MOVFF  FEC,8DE
08880:  MOVF   FED,F
08882:  MOVFF  FEF,8DD
08886:  BCF    FD8.0
08888:  MOVLB  8
0888A:  RRCF   xDE,W
0888C:  MOVWF  03
0888E:  RRCF   xDD,W
08890:  MOVWF  02
08892:  MOVWF  01
08894:  MOVF   03,W
08896:  SUBWF  xDC,W
08898:  BNC   88E6
0889A:  BNZ   88A2
0889C:  MOVF   xDB,W
0889E:  SUBWF  01,W
088A0:  BC    88E6
....................       { 
....................          m_way[motor] = NEG; 
088A2:  BCF    FD8.0
088A4:  MOVLB  7
088A6:  RLCF   x40,W
088A8:  CLRF   03
088AA:  ADDLW  86
088AC:  MOVWF  FE9
088AE:  MOVLW  07
088B0:  ADDWFC 03,W
088B2:  MOVWF  FEA
088B4:  CLRF   FEC
088B6:  MOVF   FED,F
088B8:  MOVLW  01
088BA:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088BC:  BCF    FD8.0
088BE:  RLCF   x40,W
088C0:  CLRF   03
088C2:  ADDLW  5E
088C4:  MOVWF  FE9
088C6:  MOVLW  07
088C8:  ADDWFC 03,W
088CA:  MOVWF  FEA
088CC:  MOVFF  FEC,8DE
088D0:  MOVF   FED,F
088D2:  MOVFF  FEF,8DD
088D6:  MOVLB  8
088D8:  MOVF   xDB,W
088DA:  SUBWF  xDD,W
088DC:  MOVWF  xDB
088DE:  MOVF   xDC,W
088E0:  SUBWFB xDE,W
088E2:  MOVWF  xDC
....................       } 
088E4:  BRA    8900
....................       else 
....................       { 
....................          m_way[motor] = POS; 
088E6:  BCF    FD8.0
088E8:  MOVLB  7
088EA:  RLCF   x40,W
088EC:  CLRF   03
088EE:  ADDLW  86
088F0:  MOVWF  FE9
088F2:  MOVLW  07
088F4:  ADDWFC 03,W
088F6:  MOVWF  FEA
088F8:  CLRF   FEC
088FA:  MOVF   FED,F
088FC:  CLRF   FEF
088FE:  MOVLB  8
....................       } 
....................    } 
08900:  BRA    89C2
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
08902:  BCF    FD8.0
08904:  MOVLB  7
08906:  RLCF   x40,W
08908:  CLRF   03
0890A:  ADDLW  BF
0890C:  MOVWF  FE9
0890E:  MOVLW  07
08910:  ADDWFC 03,W
08912:  MOVWF  FEA
08914:  MOVFF  FEC,8DE
08918:  MOVF   FED,F
0891A:  MOVFF  FEF,8DD
0891E:  MOVLB  8
08920:  MOVF   xD9,W
08922:  SUBWF  xDD,W
08924:  MOVWF  xDB
08926:  MOVF   xDA,W
08928:  SUBWFB xDE,W
0892A:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0892C:  BCF    FD8.0
0892E:  MOVLB  7
08930:  RLCF   x40,W
08932:  CLRF   03
08934:  ADDLW  5E
08936:  MOVWF  FE9
08938:  MOVLW  07
0893A:  ADDWFC 03,W
0893C:  MOVWF  FEA
0893E:  MOVFF  FEC,8DE
08942:  MOVF   FED,F
08944:  MOVFF  FEF,8DD
08948:  BCF    FD8.0
0894A:  MOVLB  8
0894C:  RRCF   xDE,W
0894E:  MOVWF  03
08950:  RRCF   xDD,W
08952:  MOVWF  02
08954:  MOVWF  01
08956:  MOVF   03,W
08958:  SUBWF  xDC,W
0895A:  BNC   89A6
0895C:  BNZ   8964
0895E:  MOVF   xDB,W
08960:  SUBWF  01,W
08962:  BC    89A6
....................       { 
....................          m_way[motor] = POS; 
08964:  BCF    FD8.0
08966:  MOVLB  7
08968:  RLCF   x40,W
0896A:  CLRF   03
0896C:  ADDLW  86
0896E:  MOVWF  FE9
08970:  MOVLW  07
08972:  ADDWFC 03,W
08974:  MOVWF  FEA
08976:  CLRF   FEC
08978:  MOVF   FED,F
0897A:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
0897C:  BCF    FD8.0
0897E:  RLCF   x40,W
08980:  CLRF   03
08982:  ADDLW  5E
08984:  MOVWF  FE9
08986:  MOVLW  07
08988:  ADDWFC 03,W
0898A:  MOVWF  FEA
0898C:  MOVFF  FEC,8DE
08990:  MOVF   FED,F
08992:  MOVFF  FEF,8DD
08996:  MOVLB  8
08998:  MOVF   xDB,W
0899A:  SUBWF  xDD,W
0899C:  MOVWF  xDB
0899E:  MOVF   xDC,W
089A0:  SUBWFB xDE,W
089A2:  MOVWF  xDC
....................       } 
089A4:  BRA    89C2
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
089A6:  BCF    FD8.0
089A8:  MOVLB  7
089AA:  RLCF   x40,W
089AC:  CLRF   03
089AE:  ADDLW  86
089B0:  MOVWF  FE9
089B2:  MOVLW  07
089B4:  ADDWFC 03,W
089B6:  MOVWF  FEA
089B8:  CLRF   FEC
089BA:  MOVF   FED,F
089BC:  MOVLW  01
089BE:  MOVWF  FEF
089C0:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
089C2:  MOVFF  8DB,01
089C6:  MOVFF  8DC,02
089CA:  MOVLB  0
089CC:  GOTO   A1A8 (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
090D0:  BCF    FD8.0
090D2:  MOVLB  7
090D4:  RLCF   x40,W
090D6:  CLRF   03
090D8:  ADDLW  92
090DA:  MOVWF  FE9
090DC:  MOVLW  07
090DE:  ADDWFC 03,W
090E0:  MOVWF  FEA
090E2:  CLRF   FEC
090E4:  MOVF   FED,F
090E6:  CLRF   FEF
....................           
....................    switch (motor){ 
090E8:  MOVF   x40,W
090EA:  XORLW  00
090EC:  MOVLB  0
090EE:  BZ    90F6
090F0:  XORLW  01
090F2:  BZ    9160
090F4:  BRA    91CE
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
090F6:  BCF    FD8.0
090F8:  MOVLB  7
090FA:  RLCF   x40,W
090FC:  CLRF   03
090FE:  ADDLW  52
09100:  MOVWF  FE9
09102:  MOVLW  07
09104:  ADDWFC 03,W
09106:  MOVWF  FEA
09108:  MOVFF  FEC,8ED
0910C:  MOVF   FED,F
0910E:  MOVFF  FEF,8EC
09112:  MOVLB  8
09114:  MOVF   xEC,F
09116:  BNZ   911C
09118:  MOVF   xED,F
0911A:  BZ    915A
0911C:  BCF    FD8.0
0911E:  MOVLB  7
09120:  RLCF   x40,W
09122:  CLRF   03
09124:  ADDLW  52
09126:  MOVWF  FE9
09128:  MOVLW  07
0912A:  ADDWFC 03,W
0912C:  MOVWF  FEA
0912E:  MOVFF  FEC,8ED
09132:  MOVF   FED,F
09134:  MOVFF  FEF,8EC
09138:  MOVLB  8
0913A:  RRCF   xED,F
0913C:  RRCF   xEC,F
0913E:  RRCF   xED,F
09140:  RRCF   xEC,F
09142:  RRCF   xED,F
09144:  MOVFF  8EC,FBC
09148:  RRCF   xED,F
0914A:  RRCF   xED,W
0914C:  ANDLW  30
0914E:  MOVWF  00
09150:  MOVF   FBB,W
09152:  ANDLW  CF
09154:  IORWF  00,W
09156:  MOVWF  FBB
09158:  BRA    915C
....................                else output_bit(M1_ENABLE, OFF); 
0915A:  BCF    F90.1
....................          break;   
0915C:  MOVLB  0
0915E:  BRA    91CE
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
09160:  BCF    FD8.0
09162:  MOVLB  7
09164:  RLCF   x40,W
09166:  CLRF   03
09168:  ADDLW  52
0916A:  MOVWF  FE9
0916C:  MOVLW  07
0916E:  ADDWFC 03,W
09170:  MOVWF  FEA
09172:  MOVFF  FEC,8ED
09176:  MOVF   FED,F
09178:  MOVFF  FEF,8EC
0917C:  MOVLB  8
0917E:  MOVF   xEC,F
09180:  BNZ   9186
09182:  MOVF   xED,F
09184:  BZ    91C8
09186:  BCF    FD8.0
09188:  MOVLB  7
0918A:  RLCF   x40,W
0918C:  CLRF   03
0918E:  ADDLW  52
09190:  MOVWF  FE9
09192:  MOVLW  07
09194:  ADDWFC 03,W
09196:  MOVWF  FEA
09198:  MOVFF  FEC,8ED
0919C:  MOVF   FED,F
0919E:  MOVFF  FEF,8EC
091A2:  MOVLB  8
091A4:  RRCF   xED,F
091A6:  RRCF   xEC,F
091A8:  RRCF   xED,F
091AA:  RRCF   xEC,F
091AC:  RRCF   xED,F
091AE:  MOVFF  8EC,F4F
091B2:  RRCF   xED,F
091B4:  RRCF   xED,W
091B6:  ANDLW  30
091B8:  MOVWF  00
091BA:  MOVLB  F
091BC:  MOVF   x4E,W
091BE:  ANDLW  CF
091C0:  IORWF  00,W
091C2:  MOVWF  x4E
091C4:  BRA    91CC
091C6:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
091C8:  BCF    F8D.1
091CA:  MOVLB  F
....................          break; 
091CC:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
091CE:  BCF    FA0.1
....................    enc_isr(OFF); 
091D0:  MOVLB  8
091D2:  CLRF   xEC
091D4:  MOVLB  0
091D6:  RCALL  8E1A
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
091D8:  MOVLB  7
091DA:  MOVF   x52,F
091DC:  BNZ   91EC
091DE:  MOVF   x53,F
091E0:  BNZ   91EC
091E2:  MOVF   x54,F
091E4:  BNZ   91EC
091E6:  MOVF   x55,F
091E8:  BNZ   91EC
....................    { 
....................       output_bit(VMOT,OFF); 
091EA:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
091EC:  MOVLB  8
091EE:  CLRF   xEC
091F0:  MOVLB  0
091F2:  CALL   89D0
....................  
....................    if(success==TRUE) 
091F6:  MOVLB  8
091F8:  DECFSZ xEB,W
091FA:  BRA    9396
....................    { 
....................       m_error[motor]=FALSE; 
091FC:  BCF    FD8.0
091FE:  MOVLB  7
09200:  RLCF   x40,W
09202:  CLRF   03
09204:  ADDLW  96
09206:  MOVWF  FE9
09208:  MOVLW  07
0920A:  ADDWFC 03,W
0920C:  MOVWF  FEA
0920E:  CLRF   FEC
09210:  MOVF   FED,F
09212:  CLRF   FEF
....................       wrt_m_error(); 
09214:  MOVLB  0
09216:  RCALL  8F80
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
09218:  BCF    FD8.0
0921A:  MOVLB  7
0921C:  RLCF   x40,W
0921E:  CLRF   03
09220:  ADDLW  66
09222:  MOVWF  FE9
09224:  MOVLW  07
09226:  ADDWFC 03,W
09228:  MOVWF  FEA
0922A:  MOVFF  FEC,8ED
0922E:  MOVF   FED,F
09230:  MOVFF  FEF,8EC
09234:  MOVLB  8
09236:  MOVF   xEC,W
09238:  SUBLW  03
0923A:  BNZ   9272
0923C:  MOVF   xED,F
0923E:  BNZ   9272
....................       { 
....................          e_pos[motor] = 0; 
09240:  BCF    FD8.0
09242:  MOVLB  7
09244:  RLCF   x40,W
09246:  CLRF   03
09248:  ADDLW  BF
0924A:  MOVWF  FE9
0924C:  MOVLW  07
0924E:  ADDWFC 03,W
09250:  MOVWF  FEA
09252:  CLRF   FEC
09254:  MOVF   FED,F
09256:  CLRF   FEF
....................          e_port[motor] = 1; 
09258:  BCF    FD8.0
0925A:  RLCF   x40,W
0925C:  CLRF   03
0925E:  ADDLW  C3
09260:  MOVWF  FE9
09262:  MOVLW  07
09264:  ADDWFC 03,W
09266:  MOVWF  FEA
09268:  CLRF   FEC
0926A:  MOVF   FED,F
0926C:  MOVLW  01
0926E:  MOVWF  FEF
09270:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
09272:  BCF    FD8.0
09274:  MOVLB  7
09276:  RLCF   x40,W
09278:  CLRF   03
0927A:  ADDLW  66
0927C:  MOVWF  FE9
0927E:  MOVLW  07
09280:  ADDWFC 03,W
09282:  MOVWF  FEA
09284:  MOVFF  FEC,8ED
09288:  MOVF   FED,F
0928A:  MOVFF  FEF,8EC
0928E:  MOVLB  8
09290:  MOVF   xEC,W
09292:  SUBLW  02
09294:  BNZ   92E0
09296:  MOVF   xED,F
09298:  BNZ   92E0
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
0929A:  BCF    FD8.0
0929C:  MOVLB  7
0929E:  RLCF   x40,W
092A0:  CLRF   03
092A2:  ADDLW  C3
092A4:  MOVWF  01
092A6:  MOVLW  07
092A8:  ADDWFC 03,F
092AA:  MOVLB  8
092AC:  MOVFF  03,8ED
092B0:  BCF    FD8.0
092B2:  MOVLB  7
092B4:  RLCF   x40,W
092B6:  CLRF   03
092B8:  ADDLW  C7
092BA:  MOVWF  FE9
092BC:  MOVLW  07
092BE:  ADDWFC 03,W
092C0:  MOVWF  FEA
092C2:  MOVFF  FEC,03
092C6:  MOVF   FED,F
092C8:  MOVFF  FEF,8EE
092CC:  MOVLB  8
092CE:  MOVFF  8ED,FEA
092D2:  MOVFF  01,FE9
092D6:  MOVFF  03,FEC
092DA:  MOVF   FED,F
092DC:  MOVFF  8EE,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
092E0:  BCF    FD8.0
092E2:  MOVLB  7
092E4:  RLCF   x40,W
092E6:  CLRF   03
092E8:  ADDLW  66
092EA:  MOVWF  FE9
092EC:  MOVLW  07
092EE:  ADDWFC 03,W
092F0:  MOVWF  FEA
092F2:  MOVFF  FEC,8ED
092F6:  MOVF   FED,F
092F8:  MOVFF  FEF,8EC
092FC:  MOVLB  8
092FE:  MOVF   xEC,W
09300:  SUBLW  02
09302:  BNZ   9308
09304:  MOVF   xED,F
09306:  BZ    9330
09308:  BCF    FD8.0
0930A:  MOVLB  7
0930C:  RLCF   x40,W
0930E:  CLRF   03
09310:  ADDLW  66
09312:  MOVWF  FE9
09314:  MOVLW  07
09316:  ADDWFC 03,W
09318:  MOVWF  FEA
0931A:  MOVFF  FEC,8ED
0931E:  MOVF   FED,F
09320:  MOVFF  FEF,8EC
09324:  MOVLB  8
09326:  MOVF   xEC,W
09328:  SUBLW  03
0932A:  BNZ   9394
0932C:  MOVF   xED,F
0932E:  BNZ   9394
....................       { 
....................          switch(motor) 
09330:  MOVLB  7
09332:  MOVF   x40,W
09334:  XORLW  00
09336:  MOVLB  0
09338:  BZ    9340
0933A:  XORLW  01
0933C:  BZ    936A
0933E:  BRA    9392
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09340:  MOVLW  7E
09342:  MOVLB  8
09344:  MOVWF  xEE
09346:  MOVFF  7C0,8F0
0934A:  MOVFF  7BF,8EF
0934E:  MOVLB  0
09350:  CALL   4FD4
....................                      write16(ADDR_E1_PORT,e_port[0]); 
09354:  MOVLW  AA
09356:  MOVLB  8
09358:  MOVWF  xEE
0935A:  MOVFF  7C4,8F0
0935E:  MOVFF  7C3,8EF
09362:  MOVLB  0
09364:  CALL   4FD4
....................                break; 
09368:  BRA    9392
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
0936A:  MOVLW  80
0936C:  MOVLB  8
0936E:  MOVWF  xEE
09370:  MOVFF  7C2,8F0
09374:  MOVFF  7C1,8EF
09378:  MOVLB  0
0937A:  CALL   4FD4
....................                      write16(ADDR_E2_PORT,e_port[1]); 
0937E:  MOVLW  AC
09380:  MOVLB  8
09382:  MOVWF  xEE
09384:  MOVFF  7C6,8F0
09388:  MOVFF  7C5,8EF
0938C:  MOVLB  0
0938E:  CALL   4FD4
....................                break;             
09392:  MOVLB  8
....................          } 
....................       } 
....................    } 
09394:  BRA    943E
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
09396:  BCF    FD8.0
09398:  MOVLB  7
0939A:  RLCF   x40,W
0939C:  CLRF   03
0939E:  ADDLW  96
093A0:  MOVWF  FE9
093A2:  MOVLW  07
093A4:  ADDWFC 03,W
093A6:  MOVWF  FEA
093A8:  CLRF   FEC
093AA:  MOVF   FED,F
093AC:  MOVLW  01
093AE:  MOVWF  FEF
....................       e_pos[motor] = 0; 
093B0:  BCF    FD8.0
093B2:  RLCF   x40,W
093B4:  CLRF   03
093B6:  ADDLW  BF
093B8:  MOVWF  FE9
093BA:  MOVLW  07
093BC:  ADDWFC 03,W
093BE:  MOVWF  FEA
093C0:  CLRF   FEC
093C2:  MOVF   FED,F
093C4:  CLRF   FEF
....................       e_port[motor] = 0; 
093C6:  BCF    FD8.0
093C8:  RLCF   x40,W
093CA:  CLRF   03
093CC:  ADDLW  C3
093CE:  MOVWF  FE9
093D0:  MOVLW  07
093D2:  ADDWFC 03,W
093D4:  MOVWF  FEA
093D6:  CLRF   FEC
093D8:  MOVF   FED,F
093DA:  CLRF   FEF
....................       switch(motor) 
093DC:  MOVF   x40,W
093DE:  XORLW  00
093E0:  MOVLB  0
093E2:  BZ    93EA
093E4:  XORLW  01
093E6:  BZ    9414
093E8:  BRA    943C
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
093EA:  MOVLW  7E
093EC:  MOVLB  8
093EE:  MOVWF  xEE
093F0:  MOVFF  7C0,8F0
093F4:  MOVFF  7BF,8EF
093F8:  MOVLB  0
093FA:  CALL   4FD4
....................                   write16(ADDR_E1_PORT,e_port[0]); 
093FE:  MOVLW  AA
09400:  MOVLB  8
09402:  MOVWF  xEE
09404:  MOVFF  7C4,8F0
09408:  MOVFF  7C3,8EF
0940C:  MOVLB  0
0940E:  CALL   4FD4
....................             break; 
09412:  BRA    943C
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
09414:  MOVLW  80
09416:  MOVLB  8
09418:  MOVWF  xEE
0941A:  MOVFF  7C2,8F0
0941E:  MOVFF  7C1,8EF
09422:  MOVLB  0
09424:  CALL   4FD4
....................                   write16(ADDR_E2_PORT,e_port[1]); 
09428:  MOVLW  AC
0942A:  MOVLB  8
0942C:  MOVWF  xEE
0942E:  MOVFF  7C6,8F0
09432:  MOVFF  7C5,8EF
09436:  MOVLB  0
09438:  CALL   4FD4
....................             break;             
0943C:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
0943E:  BCF    FD8.0
09440:  MOVLB  7
09442:  RLCF   x40,W
09444:  CLRF   03
09446:  ADDLW  AF
09448:  MOVWF  FE9
0944A:  MOVLW  07
0944C:  ADDWFC 03,W
0944E:  MOVWF  FEA
09450:  CLRF   FEC
09452:  MOVF   FED,F
09454:  MOVLW  01
09456:  MOVWF  FEF
....................     
....................    switch (motor) 
09458:  MOVF   x40,W
0945A:  XORLW  00
0945C:  MOVLB  0
0945E:  BZ    9466
09460:  XORLW  01
09462:  BZ    948E
09464:  BRA    94B4
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
09466:  MOVLW  B2
09468:  MOVLB  8
0946A:  MOVWF  xEE
0946C:  CLRF   xF0
0946E:  MOVLW  01
09470:  MOVWF  xEF
09472:  MOVLB  0
09474:  CALL   4FD4
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
09478:  MOVLW  B6
0947A:  MOVLB  8
0947C:  MOVWF  xEE
0947E:  MOVFF  7B4,8F0
09482:  MOVFF  7B3,8EF
09486:  MOVLB  0
09488:  CALL   4FD4
....................          break; 
0948C:  BRA    94B4
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
0948E:  MOVLW  B4
09490:  MOVLB  8
09492:  MOVWF  xEE
09494:  CLRF   xF0
09496:  MOVLW  01
09498:  MOVWF  xEF
0949A:  MOVLB  0
0949C:  CALL   4FD4
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
094A0:  MOVLW  B8
094A2:  MOVLB  8
094A4:  MOVWF  xEE
094A6:  MOVFF  7B6,8F0
094AA:  MOVFF  7B5,8EF
094AE:  MOVLB  0
094B0:  CALL   4FD4
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
094B4:  MOVF   1F,W
094B6:  SUBLW  04
094B8:  BNZ   955E
094BA:  MOVF   20,F
094BC:  BNZ   955E
....................    { 
....................       if(motor==1) 
094BE:  MOVLB  7
094C0:  DECFSZ x40,W
094C2:  BRA    9560
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
094C4:  BCF    FD8.0
094C6:  RLCF   x40,W
094C8:  CLRF   03
094CA:  ADDLW  AF
094CC:  MOVWF  FE9
094CE:  MOVLW  07
094D0:  ADDWFC 03,W
094D2:  MOVWF  FEA
094D4:  MOVFF  FEC,8ED
094D8:  MOVF   FED,F
094DA:  MOVFF  FEF,8EC
094DE:  BCF    FD8.0
094E0:  RLCF   x40,W
094E2:  CLRF   03
094E4:  ADDLW  B3
094E6:  MOVWF  FE9
094E8:  MOVLW  07
094EA:  ADDWFC 03,W
094EC:  MOVWF  FEA
094EE:  MOVFF  FEC,8EF
094F2:  MOVF   FED,F
094F4:  MOVFF  FEF,8EE
094F8:  MOVLW  5E
094FA:  MOVWF  FF6
094FC:  MOVLW  1A
094FE:  MOVWF  FF7
09500:  MOVLW  00
09502:  MOVWF  FF8
09504:  CLRF   1B
09506:  BTFSC  FF2.7
09508:  BSF    1B.7
0950A:  BCF    FF2.7
0950C:  MOVLW  05
0950E:  MOVLB  A
09510:  MOVWF  x40
09512:  MOVLB  0
09514:  CALL   1024
09518:  BTFSC  1B.7
0951A:  BSF    FF2.7
0951C:  MOVLW  10
0951E:  MOVWF  FE9
09520:  CLRF   1B
09522:  BTFSC  FF2.7
09524:  BSF    1B.7
09526:  BCF    FF2.7
09528:  MOVFF  8ED,A41
0952C:  MOVFF  8EC,A40
09530:  CALL   11A6
09534:  BTFSC  1B.7
09536:  BSF    FF2.7
09538:  MOVLW  2C
0953A:  BTFSS  F9E.4
0953C:  BRA    953A
0953E:  MOVWF  FAD
09540:  MOVLW  10
09542:  MOVWF  FE9
09544:  MOVFF  8EF,8F1
09548:  MOVFF  8EE,8F0
0954C:  RCALL  8FE4
0954E:  MOVLW  0D
09550:  BTFSS  F9E.4
09552:  BRA    9550
09554:  MOVWF  FAD
09556:  MOVLW  0A
09558:  BTFSS  F9E.4
0955A:  BRA    9558
0955C:  MOVWF  FAD
0955E:  MOVLB  7
....................       } 
....................    } 
09560:  MOVLB  0
09562:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
09690:  BCF    FD8.0
09692:  MOVLB  7
09694:  RLCF   x40,W
09696:  CLRF   03
09698:  ADDLW  6A
0969A:  MOVWF  FE9
0969C:  MOVLW  07
0969E:  ADDWFC 03,W
096A0:  MOVWF  FEA
096A2:  MOVFF  FEC,8EC
096A6:  MOVF   FED,F
096A8:  MOVFF  FEF,8EB
096AC:  MOVLB  8
096AE:  DECFSZ xEB,W
096B0:  BRA    96C0
096B2:  MOVF   xEC,F
096B4:  BNZ   96C0
096B6:  MOVLW  01
096B8:  MOVWF  xEB
096BA:  MOVLB  0
096BC:  RCALL  90D0
096BE:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
096C0:  BCF    FD8.0
096C2:  MOVLB  7
096C4:  RLCF   x40,W
096C6:  CLRF   03
096C8:  ADDLW  6A
096CA:  MOVWF  FE9
096CC:  MOVLW  07
096CE:  ADDWFC 03,W
096D0:  MOVWF  FEA
096D2:  MOVFF  FEC,8EC
096D6:  MOVF   FED,F
096D8:  MOVFF  FEF,8EB
096DC:  MOVLB  8
096DE:  MOVF   xEB,W
096E0:  SUBLW  02
096E2:  BTFSS  FD8.2
096E4:  BRA    9CEE
096E6:  MOVF   xEC,F
096E8:  BTFSS  FD8.2
096EA:  BRA    9CEE
....................       if (e_mode[motor]==2){ 
096EC:  BCF    FD8.0
096EE:  MOVLB  7
096F0:  RLCF   x40,W
096F2:  CLRF   03
096F4:  ADDLW  66
096F6:  MOVWF  FE9
096F8:  MOVLW  07
096FA:  ADDWFC 03,W
096FC:  MOVWF  FEA
096FE:  MOVFF  FEC,8EC
09702:  MOVF   FED,F
09704:  MOVFF  FEF,8EB
09708:  MOVLB  8
0970A:  MOVF   xEB,W
0970C:  SUBLW  02
0970E:  BTFSS  FD8.2
09710:  BRA    9C6A
09712:  MOVF   xEC,F
09714:  BTFSS  FD8.2
09716:  BRA    9C6A
....................          if(nv_product==ECO || nv_product==WMS2){ 
09718:  MOVF   2F,F
0971A:  BNZ   9720
0971C:  MOVF   30,F
0971E:  BZ    972E
09720:  MOVF   2F,W
09722:  SUBLW  03
09724:  BTFSS  FD8.2
09726:  BRA    9872
09728:  MOVF   30,F
0972A:  BTFSS  FD8.2
0972C:  BRA    9872
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
0972E:  BCF    FD8.0
09730:  MOVLB  7
09732:  RLCF   x40,W
09734:  CLRF   03
09736:  ADDLW  AB
09738:  MOVWF  FE9
0973A:  MOVLW  07
0973C:  ADDWFC 03,W
0973E:  MOVWF  FEA
09740:  MOVFF  FEC,9F7
09744:  MOVF   FED,F
09746:  MOVFF  FEF,9F6
0974A:  MOVFF  FEA,8EE
0974E:  MOVFF  FE9,8ED
09752:  MOVLB  9
09754:  CLRF   xF9
09756:  CLRF   xF8
09758:  MOVFF  8DC,9FD
0975C:  MOVFF  8DB,9FC
09760:  MOVFF  8DA,9FB
09764:  MOVFF  8D9,9FA
09768:  MOVLB  0
0976A:  CALL   47F0
0976E:  MOVFF  8EE,FEA
09772:  MOVFF  8ED,FE9
09776:  MOVFF  03,8EE
0977A:  MOVFF  02,8ED
0977E:  MOVFF  01,8EC
09782:  MOVFF  00,8EB
09786:  BCF    FD8.0
09788:  MOVLB  7
0978A:  RLCF   x40,W
0978C:  CLRF   03
0978E:  ADDLW  AB
09790:  MOVWF  FE9
09792:  MOVLW  07
09794:  ADDWFC 03,W
09796:  MOVWF  FEA
09798:  MOVFF  FEC,8F0
0979C:  MOVF   FED,F
0979E:  MOVFF  FEF,8EF
097A2:  BCF    FD8.0
097A4:  MOVLB  8
097A6:  RRCF   xF0,W
097A8:  MOVWF  03
097AA:  RRCF   xEF,W
097AC:  MOVWF  02
097AE:  ADDWF  00,W
097B0:  MOVWF  00
097B2:  MOVF   03,W
097B4:  ADDWFC 01,W
097B6:  MOVWF  01
097B8:  MOVLW  00
097BA:  ADDWFC xED,W
097BC:  MOVWF  02
097BE:  MOVLW  00
097C0:  ADDWFC xEE,W
097C2:  MOVWF  xE6
097C4:  MOVFF  02,8E5
097C8:  MOVFF  01,8E4
097CC:  MOVFF  00,8E3
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
097D0:  BCF    FD8.0
097D2:  MOVLB  7
097D4:  RLCF   x40,W
097D6:  CLRF   03
097D8:  ADDLW  AB
097DA:  MOVWF  FE9
097DC:  MOVLW  07
097DE:  ADDWFC 03,W
097E0:  MOVWF  FEA
097E2:  MOVFF  FEC,9F7
097E6:  MOVF   FED,F
097E8:  MOVFF  FEF,9F6
097EC:  MOVFF  FEA,8EE
097F0:  MOVFF  FE9,8ED
097F4:  MOVLB  9
097F6:  CLRF   xF9
097F8:  CLRF   xF8
097FA:  MOVFF  8DC,9FD
097FE:  MOVFF  8DB,9FC
09802:  MOVFF  8DA,9FB
09806:  MOVFF  8D9,9FA
0980A:  MOVLB  0
0980C:  CALL   47F0
09810:  MOVFF  8EE,FEA
09814:  MOVFF  8ED,FE9
09818:  MOVFF  03,8EE
0981C:  MOVFF  02,8ED
09820:  MOVFF  01,8EC
09824:  MOVFF  00,8EB
09828:  BCF    FD8.0
0982A:  MOVLB  7
0982C:  RLCF   x40,W
0982E:  CLRF   03
09830:  ADDLW  AB
09832:  MOVWF  FE9
09834:  MOVLW  07
09836:  ADDWFC 03,W
09838:  MOVWF  FEA
0983A:  MOVFF  FEC,8F0
0983E:  MOVF   FED,F
09840:  MOVFF  FEF,8EF
09844:  BCF    FD8.0
09846:  MOVLB  8
09848:  RRCF   xF0,W
0984A:  MOVWF  03
0984C:  RRCF   xEF,W
0984E:  MOVWF  02
09850:  SUBWF  00,W
09852:  MOVWF  00
09854:  MOVF   03,W
09856:  SUBWFB 01,W
09858:  MOVWF  01
0985A:  MOVLW  00
0985C:  SUBWFB xED,W
0985E:  MOVWF  02
09860:  MOVLW  00
09862:  SUBWFB xEE,W
09864:  MOVWF  xEA
09866:  MOVFF  02,8E9
0986A:  MOVFF  01,8E8
0986E:  MOVFF  00,8E7
....................          } 
....................          if (nv_product==WMS4){ 
09872:  DECFSZ 2F,W
09874:  BRA    9A8C
09876:  MOVF   30,F
09878:  BTFSS  FD8.2
0987A:  BRA    9A8C
....................             if (end_even_port==FALSE){ 
0987C:  MOVLB  2
0987E:  MOVF   xDB,F
09880:  BNZ   9976
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
09882:  BCF    FD8.0
09884:  MOVLB  7
09886:  RLCF   x40,W
09888:  CLRF   03
0988A:  ADDLW  AB
0988C:  MOVWF  FE9
0988E:  MOVLW  07
09890:  ADDWFC 03,W
09892:  MOVWF  FEA
09894:  MOVFF  FEC,A11
09898:  MOVF   FED,F
0989A:  MOVFF  FEF,A10
0989E:  MOVFF  8DE,A13
098A2:  MOVFF  8DD,A12
098A6:  MOVLB  0
098A8:  CALL   5C98
098AC:  MOVFF  02,8EC
098B0:  MOVFF  01,8EB
098B4:  BCF    FD8.0
098B6:  MOVLB  7
098B8:  RLCF   x40,W
098BA:  CLRF   03
098BC:  ADDLW  AB
098BE:  MOVWF  FE9
098C0:  MOVLW  07
098C2:  ADDWFC 03,W
098C4:  MOVWF  FEA
098C6:  MOVFF  FEC,8EE
098CA:  MOVF   FED,F
098CC:  MOVFF  FEF,8ED
098D0:  BCF    FD8.0
098D2:  MOVLB  8
098D4:  RRCF   xEE,W
098D6:  MOVWF  03
098D8:  RRCF   xED,W
098DA:  MOVWF  02
098DC:  ADDWF  01,W
098DE:  MOVWF  01
098E0:  MOVF   xEC,W
098E2:  ADDWFC 03,F
098E4:  MOVFF  01,8E3
098E8:  MOVFF  03,8E4
098EC:  CLRF   02
098EE:  CLRF   03
098F0:  MOVFF  03,8E6
098F4:  MOVFF  02,8E5
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
098F8:  BCF    FD8.0
098FA:  MOVLB  7
098FC:  RLCF   x40,W
098FE:  CLRF   03
09900:  ADDLW  AB
09902:  MOVWF  FE9
09904:  MOVLW  07
09906:  ADDWFC 03,W
09908:  MOVWF  FEA
0990A:  MOVFF  FEC,A11
0990E:  MOVF   FED,F
09910:  MOVFF  FEF,A10
09914:  MOVFF  8DE,A13
09918:  MOVFF  8DD,A12
0991C:  MOVLB  0
0991E:  CALL   5C98
09922:  MOVFF  02,8EC
09926:  MOVFF  01,8EB
0992A:  BCF    FD8.0
0992C:  MOVLB  7
0992E:  RLCF   x40,W
09930:  CLRF   03
09932:  ADDLW  AB
09934:  MOVWF  FE9
09936:  MOVLW  07
09938:  ADDWFC 03,W
0993A:  MOVWF  FEA
0993C:  MOVFF  FEC,8EE
09940:  MOVF   FED,F
09942:  MOVFF  FEF,8ED
09946:  BCF    FD8.0
09948:  MOVLB  8
0994A:  RRCF   xEE,W
0994C:  MOVWF  03
0994E:  RRCF   xED,W
09950:  MOVWF  02
09952:  SUBWF  01,W
09954:  MOVWF  00
09956:  MOVF   03,W
09958:  SUBWFB xEC,W
0995A:  MOVWF  03
0995C:  MOVF   00,W
0995E:  MOVFF  03,8E8
09962:  CLRF   02
09964:  CLRF   03
09966:  MOVFF  03,8EA
0996A:  MOVFF  02,8E9
0996E:  MOVFF  00,8E7
....................             } 
09972:  BRA    9A8C
09974:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
09976:  DECFSZ xDB,W
09978:  BRA    9A8E
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
0997A:  BCF    FD8.0
0997C:  MOVLB  7
0997E:  RLCF   x40,W
09980:  CLRF   03
09982:  ADDLW  AB
09984:  MOVWF  FE9
09986:  MOVLW  07
09988:  ADDWFC 03,W
0998A:  MOVWF  FEA
0998C:  MOVFF  FEC,A11
09990:  MOVF   FED,F
09992:  MOVFF  FEF,A10
09996:  MOVLW  01
09998:  MOVLB  8
0999A:  SUBWF  xDD,W
0999C:  MOVWF  00
0999E:  MOVLW  00
099A0:  SUBWFB xDE,W
099A2:  MOVWF  03
099A4:  MOVFF  00,8ED
099A8:  MOVWF  xEE
099AA:  MOVFF  FE8,A13
099AE:  MOVFF  00,A12
099B2:  MOVLB  0
099B4:  CALL   5C98
099B8:  MOVFF  02,8EC
099BC:  MOVFF  01,8EB
099C0:  BCF    FD8.0
099C2:  MOVLB  7
099C4:  RLCF   x40,W
099C6:  CLRF   03
099C8:  ADDLW  AB
099CA:  MOVWF  FE9
099CC:  MOVLW  07
099CE:  ADDWFC 03,W
099D0:  MOVWF  FEA
099D2:  MOVFF  FEC,8EE
099D6:  MOVF   FED,F
099D8:  MOVFF  FEF,8ED
099DC:  BCF    FD8.0
099DE:  MOVLB  8
099E0:  RRCF   xEE,W
099E2:  MOVWF  03
099E4:  RRCF   xED,W
099E6:  MOVWF  02
099E8:  ADDWF  01,W
099EA:  MOVWF  01
099EC:  MOVF   xEC,W
099EE:  ADDWFC 03,F
099F0:  MOVFF  01,8E3
099F4:  MOVFF  03,8E4
099F8:  CLRF   02
099FA:  CLRF   03
099FC:  MOVFF  03,8E6
09A00:  MOVFF  02,8E5
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
09A04:  BCF    FD8.0
09A06:  MOVLB  7
09A08:  RLCF   x40,W
09A0A:  CLRF   03
09A0C:  ADDLW  AB
09A0E:  MOVWF  FE9
09A10:  MOVLW  07
09A12:  ADDWFC 03,W
09A14:  MOVWF  FEA
09A16:  MOVFF  FEC,A11
09A1A:  MOVF   FED,F
09A1C:  MOVFF  FEF,A10
09A20:  MOVLW  01
09A22:  MOVLB  8
09A24:  SUBWF  xDD,W
09A26:  MOVWF  00
09A28:  MOVLW  00
09A2A:  SUBWFB xDE,W
09A2C:  MOVWF  03
09A2E:  MOVFF  00,8ED
09A32:  MOVWF  xEE
09A34:  MOVFF  FE8,A13
09A38:  MOVFF  00,A12
09A3C:  MOVLB  0
09A3E:  CALL   5C98
09A42:  MOVFF  02,03
09A46:  MOVFF  01,8E7
09A4A:  MOVFF  02,8E8
09A4E:  CLRF   02
09A50:  CLRF   03
09A52:  MOVFF  03,8EA
09A56:  MOVFF  02,8E9
....................                m_pll = m_pll -(m_ppp[motor]/2); 
09A5A:  BCF    FD8.0
09A5C:  MOVLB  7
09A5E:  RLCF   x40,W
09A60:  CLRF   03
09A62:  ADDLW  AB
09A64:  MOVWF  FE9
09A66:  MOVLW  07
09A68:  ADDWFC 03,W
09A6A:  MOVWF  FEA
09A6C:  MOVFF  FEC,8EC
09A70:  MOVF   FED,F
09A72:  MOVFF  FEF,8EB
09A76:  BCF    FD8.0
09A78:  MOVLB  8
09A7A:  RRCF   xEC,W
09A7C:  MOVWF  03
09A7E:  RRCF   xEB,W
09A80:  SUBWF  xE7,F
09A82:  MOVF   03,W
09A84:  SUBWFB xE8,F
09A86:  MOVLW  00
09A88:  SUBWFB xE9,F
09A8A:  SUBWFB xEA,F
09A8C:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
09A8E:  MOVLB  7
09A90:  MOVF   x40,W
09A92:  MULLW  04
09A94:  MOVF   FF3,W
09A96:  CLRF   03
09A98:  ADDLW  A2
09A9A:  MOVWF  FE9
09A9C:  MOVLW  07
09A9E:  ADDWFC 03,W
09AA0:  MOVWF  FEA
09AA2:  MOVFF  FEF,8EB
09AA6:  MOVFF  FEC,8EC
09AAA:  MOVFF  FEC,8ED
09AAE:  MOVFF  FEC,8EE
09AB2:  MOVLB  8
09AB4:  BTFSC  xE6.7
09AB6:  BRA    9B26
09AB8:  MOVF   xE6,W
09ABA:  SUBWF  xEE,W
09ABC:  BNC   9AD6
09ABE:  BNZ   9B26
09AC0:  MOVF   xE5,W
09AC2:  SUBWF  xED,W
09AC4:  BNC   9AD6
09AC6:  BNZ   9B26
09AC8:  MOVF   xE4,W
09ACA:  SUBWF  xEC,W
09ACC:  BNC   9AD6
09ACE:  BNZ   9B26
09AD0:  MOVF   xEB,W
09AD2:  SUBWF  xE3,W
09AD4:  BNC   9B26
09AD6:  MOVLB  7
09AD8:  MOVF   x40,W
09ADA:  MULLW  04
09ADC:  MOVF   FF3,W
09ADE:  CLRF   03
09AE0:  ADDLW  A2
09AE2:  MOVWF  FE9
09AE4:  MOVLW  07
09AE6:  ADDWFC 03,W
09AE8:  MOVWF  FEA
09AEA:  MOVFF  FEF,8EB
09AEE:  MOVFF  FEC,8EC
09AF2:  MOVFF  FEC,8ED
09AF6:  MOVFF  FEC,8EE
09AFA:  MOVLB  8
09AFC:  BTFSC  xEA.7
09AFE:  BRA    9C6A
09B00:  MOVF   xEE,W
09B02:  SUBWF  xEA,W
09B04:  BTFSS  FD8.0
09B06:  BRA    9C6A
09B08:  BNZ   9B26
09B0A:  MOVF   xED,W
09B0C:  SUBWF  xE9,W
09B0E:  BTFSS  FD8.0
09B10:  BRA    9C6A
09B12:  BNZ   9B26
09B14:  MOVF   xEC,W
09B16:  SUBWF  xE8,W
09B18:  BTFSS  FD8.0
09B1A:  BRA    9C6A
09B1C:  BNZ   9B26
09B1E:  MOVF   xE7,W
09B20:  SUBWF  xEB,W
09B22:  BTFSC  FD8.0
09B24:  BRA    9C6A
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09B26:  MOVLW  01
09B28:  MOVLB  7
09B2A:  ADDWF  x40,W
09B2C:  MOVLB  8
09B2E:  MOVWF  xEB
09B30:  BCF    FD8.0
09B32:  MOVLB  7
09B34:  RLCF   x40,W
09B36:  CLRF   03
09B38:  ADDLW  AB
09B3A:  MOVWF  FE9
09B3C:  MOVLW  07
09B3E:  ADDWFC 03,W
09B40:  MOVWF  FEA
09B42:  MOVFF  FEC,8ED
09B46:  MOVF   FED,F
09B48:  MOVFF  FEF,8EC
09B4C:  MOVF   x40,W
09B4E:  MULLW  04
09B50:  MOVF   FF3,W
09B52:  CLRF   03
09B54:  ADDLW  A2
09B56:  MOVWF  FE9
09B58:  MOVLW  07
09B5A:  ADDWFC 03,W
09B5C:  MOVWF  FEA
09B5E:  MOVFF  FEF,8EE
09B62:  MOVFF  FEC,8EF
09B66:  MOVFF  FEC,8F0
09B6A:  MOVFF  FEC,8F1
09B6E:  MOVLW  6E
09B70:  MOVWF  FF6
09B72:  MOVLW  1A
09B74:  MOVWF  FF7
09B76:  MOVLW  00
09B78:  MOVWF  FF8
09B7A:  CLRF   1B
09B7C:  BTFSC  FF2.7
09B7E:  BSF    1B.7
09B80:  BCF    FF2.7
09B82:  MOVLW  05
09B84:  MOVLB  A
09B86:  MOVWF  x40
09B88:  MOVLB  0
09B8A:  CALL   1024
09B8E:  BTFSC  1B.7
09B90:  BSF    FF2.7
09B92:  CLRF   1B
09B94:  BTFSC  FF2.7
09B96:  BSF    1B.7
09B98:  BCF    FF2.7
09B9A:  MOVFF  8EB,A40
09B9E:  MOVLW  1B
09BA0:  MOVLB  A
09BA2:  MOVWF  x41
09BA4:  MOVLB  0
09BA6:  CALL   0FA6
09BAA:  BTFSC  1B.7
09BAC:  BSF    FF2.7
09BAE:  MOVLW  2C
09BB0:  BTFSS  F9E.4
09BB2:  BRA    9BB0
09BB4:  MOVWF  FAD
09BB6:  MOVLW  41
09BB8:  MOVWF  FE9
09BBA:  MOVFF  8DC,8F5
09BBE:  MOVFF  8DB,8F4
09BC2:  MOVFF  8DA,8F3
09BC6:  MOVFF  8D9,8F2
09BCA:  RCALL  9564
09BCC:  MOVLW  2C
09BCE:  BTFSS  F9E.4
09BD0:  BRA    9BCE
09BD2:  MOVWF  FAD
09BD4:  MOVLW  10
09BD6:  MOVWF  FE9
09BD8:  CLRF   1B
09BDA:  BTFSC  FF2.7
09BDC:  BSF    1B.7
09BDE:  BCF    FF2.7
09BE0:  MOVFF  8ED,A41
09BE4:  MOVFF  8EC,A40
09BE8:  CALL   11A6
09BEC:  BTFSC  1B.7
09BEE:  BSF    FF2.7
09BF0:  MOVLW  2C
09BF2:  BTFSS  F9E.4
09BF4:  BRA    9BF2
09BF6:  MOVWF  FAD
09BF8:  MOVLW  41
09BFA:  MOVWF  FE9
09BFC:  CLRF   1B
09BFE:  BTFSC  FF2.7
09C00:  BSF    1B.7
09C02:  BCF    FF2.7
09C04:  MOVFF  8F1,A43
09C08:  MOVFF  8F0,A42
09C0C:  MOVFF  8EF,A41
09C10:  MOVFF  8EE,A40
09C14:  CALL   10EA
09C18:  BTFSC  1B.7
09C1A:  BSF    FF2.7
09C1C:  MOVLW  2C
09C1E:  BTFSS  F9E.4
09C20:  BRA    9C1E
09C22:  MOVWF  FAD
09C24:  MOVLW  41
09C26:  MOVWF  FE9
09C28:  MOVFF  8E6,8F5
09C2C:  MOVFF  8E5,8F4
09C30:  MOVFF  8E4,8F3
09C34:  MOVFF  8E3,8F2
09C38:  RCALL  9564
09C3A:  MOVLW  2C
09C3C:  BTFSS  F9E.4
09C3E:  BRA    9C3C
09C40:  MOVWF  FAD
09C42:  MOVLW  41
09C44:  MOVWF  FE9
09C46:  MOVFF  8EA,8F5
09C4A:  MOVFF  8E9,8F4
09C4E:  MOVFF  8E8,8F3
09C52:  MOVFF  8E7,8F2
09C56:  RCALL  9564
09C58:  MOVLW  0D
09C5A:  BTFSS  F9E.4
09C5C:  BRA    9C5A
09C5E:  MOVWF  FAD
09C60:  MOVLW  0A
09C62:  BTFSS  F9E.4
09C64:  BRA    9C62
09C66:  MOVWF  FAD
09C68:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09C6A:  BCF    FD8.0
09C6C:  MOVLB  7
09C6E:  RLCF   x40,W
09C70:  CLRF   03
09C72:  ADDLW  9E
09C74:  MOVWF  01
09C76:  MOVLW  07
09C78:  ADDWFC 03,F
09C7A:  MOVLB  8
09C7C:  MOVFF  03,8EC
09C80:  BCF    FD8.0
09C82:  MOVLB  7
09C84:  RLCF   x40,W
09C86:  CLRF   03
09C88:  ADDLW  66
09C8A:  MOVWF  FE9
09C8C:  MOVLW  07
09C8E:  ADDWFC 03,W
09C90:  MOVWF  FEA
09C92:  MOVFF  FEC,03
09C96:  MOVF   FED,F
09C98:  MOVFF  FEF,8ED
09C9C:  MOVLB  8
09C9E:  MOVFF  8EC,FEA
09CA2:  MOVFF  01,FE9
09CA6:  MOVFF  03,FEC
09CAA:  MOVF   FED,F
09CAC:  MOVFF  8ED,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09CB0:  BCF    FD8.0
09CB2:  MOVLB  7
09CB4:  RLCF   x40,W
09CB6:  CLRF   03
09CB8:  ADDLW  66
09CBA:  MOVWF  FE9
09CBC:  MOVLW  07
09CBE:  ADDWFC 03,W
09CC0:  MOVWF  FEA
09CC2:  CLRF   FEC
09CC4:  MOVF   FED,F
09CC6:  MOVLW  04
09CC8:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09CCA:  MOVF   x40,W
09CCC:  MULLW  04
09CCE:  MOVF   FF3,W
09CD0:  CLRF   03
09CD2:  ADDLW  A2
09CD4:  MOVWF  FE9
09CD6:  MOVLW  07
09CD8:  ADDWFC 03,W
09CDA:  MOVWF  FEA
09CDC:  MOVFF  FEF,8DF
09CE0:  MOVFF  FEC,8E0
09CE4:  MOVFF  FEC,8E1
09CE8:  MOVFF  FEC,8E2
09CEC:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09CEE:  MOVFF  8DF,00
09CF2:  MOVFF  8E0,01
09CF6:  MOVFF  8E1,02
09CFA:  MOVFF  8E2,03
09CFE:  MOVLB  0
09D00:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
0855E:  MOVLB  2
08560:  CLRF   xDB
....................    start_even_port = FALSE; 
08562:  CLRF   xDA
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
08564:  BCF    FD8.0
08566:  MOVLB  7
08568:  RLCF   x40,W
0856A:  CLRF   03
0856C:  ADDLW  C7
0856E:  MOVWF  FE9
08570:  MOVLW  07
08572:  ADDWFC 03,W
08574:  MOVWF  FEA
08576:  MOVFF  FEC,8D9
0857A:  MOVF   FED,F
0857C:  MOVFF  FEF,8D8
08580:  MOVLW  01
08582:  MOVLB  8
08584:  ANDWF  xD8,F
08586:  CLRF   xD9
08588:  MOVF   xD8,F
0858A:  BNZ   8598
0858C:  MOVF   xD9,F
0858E:  BNZ   8598
....................    { 
....................       end_even_port = TRUE; 
08590:  MOVLW  01
08592:  MOVLB  2
08594:  MOVWF  xDB
08596:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
08598:  BCF    FD8.0
0859A:  MOVLB  7
0859C:  RLCF   x40,W
0859E:  CLRF   03
085A0:  ADDLW  C3
085A2:  MOVWF  FE9
085A4:  MOVLW  07
085A6:  ADDWFC 03,W
085A8:  MOVWF  FEA
085AA:  MOVFF  FEC,8D9
085AE:  MOVF   FED,F
085B0:  MOVFF  FEF,8D8
085B4:  MOVLW  01
085B6:  MOVLB  8
085B8:  ANDWF  xD8,F
085BA:  CLRF   xD9
085BC:  MOVF   xD8,F
085BE:  BNZ   85CC
085C0:  MOVF   xD9,F
085C2:  BNZ   85CC
....................    { 
....................       start_even_port = TRUE; 
085C4:  MOVLW  01
085C6:  MOVLB  2
085C8:  MOVWF  xDA
085CA:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
085CC:  MOVLB  2
085CE:  MOVF   xDA,F
085D0:  BNZ   85E6
....................    { 
....................       evenOdd = 0; 
085D2:  MOVLB  8
085D4:  CLRF   xD7
....................       if (TRUE == end_even_port) 
085D6:  MOVLB  2
085D8:  DECFSZ xDB,W
085DA:  BRA    85E4
....................       { 
....................          evenOdd = 1; 
085DC:  MOVLW  01
085DE:  MOVLB  8
085E0:  MOVWF  xD7
085E2:  MOVLB  2
....................       } 
....................    } 
085E4:  BRA    85FA
....................    else 
....................    { 
....................       evenOdd = 2; 
085E6:  MOVLW  02
085E8:  MOVLB  8
085EA:  MOVWF  xD7
....................       if (TRUE == end_even_port) 
085EC:  MOVLB  2
085EE:  DECFSZ xDB,W
085F0:  BRA    85FA
....................       { 
....................          evenOdd = 3; 
085F2:  MOVLW  03
085F4:  MOVLB  8
085F6:  MOVWF  xD7
085F8:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
085FA:  MOVLB  8
085FC:  MOVFF  8D7,01
08600:  MOVLB  0
08602:  GOTO   A050 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09D78:  BCF    FD8.0
09D7A:  MOVLB  7
09D7C:  RLCF   x40,W
09D7E:  CLRF   03
09D80:  ADDLW  86
09D82:  MOVWF  FE9
09D84:  MOVLW  07
09D86:  ADDWFC 03,W
09D88:  MOVWF  FEA
09D8A:  CLRF   FEC
09D8C:  MOVF   FED,F
09D8E:  MOVFF  8C8,FEF
....................    m_step_cnt[motor] = 0; 
09D92:  MOVF   x40,W
09D94:  MULLW  04
09D96:  MOVF   FF3,W
09D98:  CLRF   03
09D9A:  ADDLW  A2
09D9C:  MOVWF  FE9
09D9E:  MOVLW  07
09DA0:  ADDWFC 03,W
09DA2:  MOVWF  FEA
09DA4:  MOVF   FEE,F
09DA6:  MOVF   FEE,F
09DA8:  CLRF   FEC
09DAA:  MOVF   FED,F
09DAC:  CLRF   FEF
09DAE:  MOVF   FED,F
09DB0:  CLRF   FEF
09DB2:  MOVF   FED,F
09DB4:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09DB6:  BCF    FD8.0
09DB8:  RLCF   x40,W
09DBA:  CLRF   03
09DBC:  ADDLW  6E
09DBE:  MOVWF  FE9
09DC0:  MOVLW  07
09DC2:  ADDWFC 03,W
09DC4:  MOVWF  FEA
09DC6:  MOVFF  FEC,8D5
09DCA:  MOVF   FED,F
09DCC:  MOVFF  FEF,8D4
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09DD0:  BCF    FD8.0
09DD2:  RLCF   x40,W
09DD4:  CLRF   03
09DD6:  ADDLW  76
09DD8:  MOVWF  FE9
09DDA:  MOVLW  07
09DDC:  ADDWFC 03,W
09DDE:  MOVWF  FEA
09DE0:  MOVFF  FEC,8DC
09DE4:  MOVF   FED,F
09DE6:  MOVFF  FEF,8DB
09DEA:  BCF    FD8.0
09DEC:  RLCF   x40,W
09DEE:  CLRF   03
09DF0:  ADDLW  5E
09DF2:  MOVWF  FE9
09DF4:  MOVLW  07
09DF6:  ADDWFC 03,W
09DF8:  MOVWF  FEA
09DFA:  MOVFF  FEC,03
09DFE:  MOVF   FED,F
09E00:  MOVFF  FEF,8DD
09E04:  MOVFF  03,8DA
09E08:  MOVFF  03,8DE
09E0C:  MOVLB  0
09E0E:  CALL   2CD4
09E12:  MOVFF  02,8D3
09E16:  MOVFF  01,8D2
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09E1A:  BCF    FD8.0
09E1C:  MOVLB  7
09E1E:  RLCF   x40,W
09E20:  CLRF   03
09E22:  ADDLW  66
09E24:  MOVWF  FE9
09E26:  MOVLW  07
09E28:  ADDWFC 03,W
09E2A:  MOVWF  FEA
09E2C:  MOVFF  FEC,8D8
09E30:  MOVF   FED,F
09E32:  MOVFF  FEF,8D7
09E36:  MOVLB  8
09E38:  MOVF   xD7,W
09E3A:  SUBLW  02
09E3C:  BNZ   9E6C
09E3E:  MOVF   xD8,F
09E40:  BNZ   9E6C
09E42:  BCF    FD8.0
09E44:  MOVLB  7
09E46:  RLCF   x40,W
09E48:  CLRF   03
09E4A:  ADDLW  C3
09E4C:  MOVWF  FE9
09E4E:  MOVLW  07
09E50:  ADDWFC 03,W
09E52:  MOVWF  FEA
09E54:  MOVFF  FEC,8D8
09E58:  MOVF   FED,F
09E5A:  MOVFF  FEF,8D7
09E5E:  MOVLB  8
09E60:  MOVF   xD7,F
09E62:  BNZ   9E6C
09E64:  MOVF   xD8,F
09E66:  BTFSC  FD8.2
09E68:  GOTO   A70A
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09E6C:  BCF    FD8.0
09E6E:  MOVLB  7
09E70:  RLCF   x40,W
09E72:  CLRF   03
09E74:  ADDLW  66
09E76:  MOVWF  FE9
09E78:  MOVLW  07
09E7A:  ADDWFC 03,W
09E7C:  MOVWF  FEA
09E7E:  MOVFF  FEC,8D8
09E82:  MOVF   FED,F
09E84:  MOVFF  FEF,8D7
09E88:  MOVLB  8
09E8A:  MOVF   xD7,W
09E8C:  SUBLW  02
09E8E:  BTFSS  FD8.2
09E90:  BRA    A1EA
09E92:  MOVF   xD8,F
09E94:  BTFSS  FD8.2
09E96:  BRA    A1EA
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09E98:  BCF    FD8.0
09E9A:  MOVLB  7
09E9C:  RLCF   x40,W
09E9E:  CLRF   03
09EA0:  ADDLW  C7
09EA2:  MOVWF  FE9
09EA4:  MOVLW  07
09EA6:  ADDWFC 03,W
09EA8:  MOVWF  FEA
09EAA:  MOVFF  8C9,FEF
09EAE:  MOVFF  8CA,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09EB2:  DECFSZ 2F,W
09EB4:  BRA    A166
09EB6:  MOVF   30,F
09EB8:  BTFSS  FD8.2
09EBA:  BRA    A166
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09EBC:  BCF    FD8.0
09EBE:  RLCF   x40,W
09EC0:  CLRF   03
09EC2:  ADDLW  C7
09EC4:  MOVWF  FE9
09EC6:  MOVLW  07
09EC8:  ADDWFC 03,W
09ECA:  MOVWF  FEA
09ECC:  MOVFF  FEC,8D8
09ED0:  MOVF   FED,F
09ED2:  MOVFF  FEF,8D7
09ED6:  BCF    FD8.0
09ED8:  RLCF   x40,W
09EDA:  CLRF   03
09EDC:  ADDLW  C3
09EDE:  MOVWF  FE9
09EE0:  MOVLW  07
09EE2:  ADDWFC 03,W
09EE4:  MOVWF  FEA
09EE6:  MOVFF  FEC,03
09EEA:  MOVF   FED,F
09EEC:  MOVFF  FEF,01
09EF0:  MOVF   03,W
09EF2:  MOVLB  8
09EF4:  SUBWF  xD8,W
09EF6:  BNC   9F92
09EF8:  BNZ   9F00
09EFA:  MOVF   xD7,W
09EFC:  SUBWF  01,W
09EFE:  BC    9F92
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09F00:  BCF    FD8.0
09F02:  MOVLB  7
09F04:  RLCF   x40,W
09F06:  CLRF   03
09F08:  ADDLW  B7
09F0A:  MOVWF  01
09F0C:  MOVLW  07
09F0E:  ADDWFC 03,F
09F10:  MOVLB  8
09F12:  MOVFF  03,8D8
09F16:  BCF    FD8.0
09F18:  MOVLB  7
09F1A:  RLCF   x40,W
09F1C:  CLRF   03
09F1E:  ADDLW  C7
09F20:  MOVWF  FE9
09F22:  MOVLW  07
09F24:  ADDWFC 03,W
09F26:  MOVWF  FEA
09F28:  MOVFF  FEC,8DA
09F2C:  MOVF   FED,F
09F2E:  MOVFF  FEF,8D9
09F32:  BCF    FD8.0
09F34:  RLCF   x40,W
09F36:  CLRF   03
09F38:  ADDLW  C3
09F3A:  MOVWF  FE9
09F3C:  MOVLW  07
09F3E:  ADDWFC 03,W
09F40:  MOVWF  FEA
09F42:  MOVFF  FEC,03
09F46:  MOVF   FED,F
09F48:  MOVF   FEF,W
09F4A:  MOVLB  8
09F4C:  SUBWF  xD9,W
09F4E:  MOVWF  00
09F50:  MOVF   03,W
09F52:  SUBWFB xDA,W
09F54:  MOVFF  8D8,FEA
09F58:  MOVFF  01,FE9
09F5C:  MOVWF  FEC
09F5E:  MOVF   FED,F
09F60:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F64:  BCF    FD8.0
09F66:  MOVLB  7
09F68:  RLCF   x40,W
09F6A:  CLRF   03
09F6C:  ADDLW  B7
09F6E:  MOVWF  FE9
09F70:  MOVLW  07
09F72:  ADDWFC 03,W
09F74:  MOVWF  FEA
09F76:  MOVFF  FEC,8D8
09F7A:  MOVF   FED,F
09F7C:  MOVFF  FEF,8D7
09F80:  BCF    FD8.0
09F82:  MOVLB  8
09F84:  CLRF   xCC
09F86:  CLRF   xCB
09F88:  RRCF   xD8,W
09F8A:  MOVWF  xCA
09F8C:  RRCF   xD7,W
09F8E:  MOVWF  xC9
....................             } 
09F90:  BRA    A04A
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09F92:  BCF    FD8.0
09F94:  MOVLB  7
09F96:  RLCF   x40,W
09F98:  CLRF   03
09F9A:  ADDLW  B7
09F9C:  MOVWF  01
09F9E:  MOVLW  07
09FA0:  ADDWFC 03,F
09FA2:  MOVFF  01,8D7
09FA6:  MOVLB  8
09FA8:  MOVFF  03,8D8
09FAC:  BCF    FD8.0
09FAE:  MOVLB  7
09FB0:  RLCF   x40,W
09FB2:  CLRF   03
09FB4:  ADDLW  62
09FB6:  MOVWF  FE9
09FB8:  MOVLW  07
09FBA:  ADDWFC 03,W
09FBC:  MOVWF  FEA
09FBE:  MOVFF  FEC,8DA
09FC2:  MOVF   FED,F
09FC4:  MOVFF  FEF,8D9
09FC8:  BCF    FD8.0
09FCA:  RLCF   x40,W
09FCC:  CLRF   03
09FCE:  ADDLW  C3
09FD0:  MOVWF  FE9
09FD2:  MOVLW  07
09FD4:  ADDWFC 03,W
09FD6:  MOVWF  FEA
09FD8:  MOVFF  FEC,03
09FDC:  MOVF   FED,F
09FDE:  MOVF   FEF,W
09FE0:  MOVLB  8
09FE2:  SUBWF  xD9,F
09FE4:  MOVF   03,W
09FE6:  SUBWFB xDA,F
09FE8:  BCF    FD8.0
09FEA:  MOVLB  7
09FEC:  RLCF   x40,W
09FEE:  CLRF   03
09FF0:  ADDLW  C7
09FF2:  MOVWF  FE9
09FF4:  MOVLW  07
09FF6:  ADDWFC 03,W
09FF8:  MOVWF  FEA
09FFA:  MOVFF  FEC,03
09FFE:  MOVF   FED,F
0A000:  MOVF   FEF,W
0A002:  MOVLB  8
0A004:  ADDWF  xD9,W
0A006:  MOVWF  01
0A008:  MOVF   xDA,W
0A00A:  ADDWFC 03,F
0A00C:  MOVFF  8D8,FEA
0A010:  MOVFF  8D7,FE9
0A014:  MOVFF  03,FEC
0A018:  MOVF   FED,F
0A01A:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
0A01E:  BCF    FD8.0
0A020:  MOVLB  7
0A022:  RLCF   x40,W
0A024:  CLRF   03
0A026:  ADDLW  B7
0A028:  MOVWF  FE9
0A02A:  MOVLW  07
0A02C:  ADDWFC 03,W
0A02E:  MOVWF  FEA
0A030:  MOVFF  FEC,8D8
0A034:  MOVF   FED,F
0A036:  MOVFF  FEF,8D7
0A03A:  BCF    FD8.0
0A03C:  MOVLB  8
0A03E:  CLRF   xCC
0A040:  CLRF   xCB
0A042:  RRCF   xD8,W
0A044:  MOVWF  xCA
0A046:  RRCF   xD7,W
0A048:  MOVWF  xC9
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
0A04A:  MOVLB  0
0A04C:  GOTO   855E
0A050:  MOVFF  01,8D6
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
0A054:  BCF    FD8.0
0A056:  MOVLB  7
0A058:  RLCF   x40,W
0A05A:  CLRF   03
0A05C:  ADDLW  C7
0A05E:  MOVWF  FE9
0A060:  MOVLW  07
0A062:  ADDWFC 03,W
0A064:  MOVWF  FEA
0A066:  MOVFF  FEC,8D8
0A06A:  MOVF   FED,F
0A06C:  MOVFF  FEF,8D7
0A070:  MOVLB  8
0A072:  MOVF   xD7,W
0A074:  SUBLW  02
0A076:  BNZ   A0A6
0A078:  MOVF   xD8,F
0A07A:  BNZ   A0A6
0A07C:  BCF    FD8.0
0A07E:  MOVLB  7
0A080:  RLCF   x40,W
0A082:  CLRF   03
0A084:  ADDLW  C3
0A086:  MOVWF  FE9
0A088:  MOVLW  07
0A08A:  ADDWFC 03,W
0A08C:  MOVWF  FEA
0A08E:  MOVFF  FEC,8D8
0A092:  MOVF   FED,F
0A094:  MOVFF  FEF,8D7
0A098:  MOVLB  8
0A09A:  DECFSZ xD7,W
0A09C:  BRA    A0A6
0A09E:  MOVF   xD8,F
0A0A0:  BNZ   A0A6
....................             { 
....................                port_port=4; 
0A0A2:  MOVLW  04
0A0A4:  MOVWF  xD6
....................             } 
....................              
....................             switch(port_port){ 
0A0A6:  MOVF   xD6,W
0A0A8:  ADDLW  FB
0A0AA:  BC    A162
0A0AC:  ADDLW  05
0A0AE:  MOVLB  0
0A0B0:  GOTO   A758
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
0A0B4:  BCF    FD8.0
0A0B6:  MOVLB  7
0A0B8:  RLCF   x40,W
0A0BA:  CLRF   03
0A0BC:  ADDLW  6E
0A0BE:  MOVWF  FE9
0A0C0:  MOVLW  07
0A0C2:  ADDWFC 03,W
0A0C4:  MOVWF  FEA
0A0C6:  MOVFF  FEC,8D5
0A0CA:  MOVF   FED,F
0A0CC:  MOVFF  FEF,8D4
....................                   break; 
0A0D0:  MOVLB  8
0A0D2:  BRA    A162
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A0D4:  BCF    FD8.0
0A0D6:  MOVLB  7
0A0D8:  RLCF   x40,W
0A0DA:  CLRF   03
0A0DC:  ADDLW  7E
0A0DE:  MOVWF  FE9
0A0E0:  MOVLW  07
0A0E2:  ADDWFC 03,W
0A0E4:  MOVWF  FEA
0A0E6:  MOVFF  FEC,03
0A0EA:  MOVF   FED,F
0A0EC:  MOVF   FEF,W
0A0EE:  MOVLB  8
0A0F0:  ADDWF  xD2,W
0A0F2:  MOVWF  xD4
0A0F4:  MOVF   03,W
0A0F6:  ADDWFC xD3,W
0A0F8:  MOVWF  xD5
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A0FA:  BRA    A162
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A0FC:  BCF    FD8.0
0A0FE:  MOVLB  7
0A100:  RLCF   x40,W
0A102:  CLRF   03
0A104:  ADDLW  6E
0A106:  MOVWF  FE9
0A108:  MOVLW  07
0A10A:  ADDWFC 03,W
0A10C:  MOVWF  FEA
0A10E:  MOVFF  FEC,8D5
0A112:  MOVF   FED,F
0A114:  MOVFF  FEF,8D4
....................                         ++m_steps; 
0A118:  MOVLW  01
0A11A:  MOVLB  8
0A11C:  ADDWF  xC9,F
0A11E:  BTFSC  FD8.0
0A120:  INCF   xCA,F
0A122:  BTFSC  FD8.2
0A124:  INCF   xCB,F
0A126:  BTFSC  FD8.2
0A128:  INCF   xCC,F
....................                   break; 
0A12A:  BRA    A162
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A12C:  BCF    FD8.0
0A12E:  MOVLB  7
0A130:  RLCF   x40,W
0A132:  CLRF   03
0A134:  ADDLW  7E
0A136:  MOVWF  FE9
0A138:  MOVLW  07
0A13A:  ADDWFC 03,W
0A13C:  MOVWF  FEA
0A13E:  MOVFF  FEC,03
0A142:  MOVF   FED,F
0A144:  MOVF   FEF,W
0A146:  MOVLB  8
0A148:  ADDWF  xD2,W
0A14A:  MOVWF  xD4
0A14C:  MOVF   03,W
0A14E:  ADDWFC xD3,W
0A150:  MOVWF  xD5
....................  
....................                   break; 
0A152:  BRA    A162
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A154:  MOVFF  8D3,8D5
0A158:  MOVFF  8D2,8D4
....................                   break;     
0A15C:  MOVLB  8
0A15E:  BRA    A162
0A160:  MOVLB  8
....................             } 
....................          } 
0A162:  BRA    A18E
0A164:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A166:  MOVFF  8CC,8DA
0A16A:  MOVFF  8CB,8D9
0A16E:  MOVFF  8CA,8D8
0A172:  MOVFF  8C9,8D7
0A176:  MOVLB  0
0A178:  GOTO   8606
0A17C:  MOVFF  03,8CC
0A180:  MOVFF  02,8CB
0A184:  MOVFF  01,8CA
0A188:  MOVFF  00,8C9
0A18C:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A18E:  DECFSZ xC7,W
0A190:  BRA    A1B8
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A192:  MOVFF  8CA,8D8
0A196:  MOVFF  8C9,8D7
0A19A:  MOVFF  8CA,8DA
0A19E:  MOVFF  8C9,8D9
0A1A2:  MOVLB  0
0A1A4:  GOTO   8818
0A1A8:  MOVLB  8
0A1AA:  CLRF   xCC
0A1AC:  CLRF   xCB
0A1AE:  MOVFF  02,8CA
0A1B2:  MOVFF  01,8C9
....................          } 
0A1B6:  BRA    A1EA
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A1B8:  MOVF   2F,W
0A1BA:  SUBLW  03
0A1BC:  BNZ   A1EA
0A1BE:  MOVF   30,F
0A1C0:  BNZ   A1EA
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A1C2:  BCF    FD8.0
0A1C4:  MOVLB  7
0A1C6:  RLCF   x40,W
0A1C8:  CLRF   03
0A1CA:  ADDLW  BF
0A1CC:  MOVWF  FE9
0A1CE:  MOVLW  07
0A1D0:  ADDWFC 03,W
0A1D2:  MOVWF  FEA
0A1D4:  MOVFF  FEC,03
0A1D8:  MOVF   FED,F
0A1DA:  MOVF   FEF,W
0A1DC:  MOVLB  8
0A1DE:  SUBWF  xC9,F
0A1E0:  MOVF   03,W
0A1E2:  SUBWFB xCA,F
0A1E4:  MOVLW  00
0A1E6:  SUBWFB xCB,F
0A1E8:  SUBWFB xCC,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A1EA:  MOVFF  8CD,8D7
0A1EE:  MOVLB  0
0A1F0:  GOTO   8EE2
....................        
....................       //timeout could be set here!!! 
....................       while (m_running[motor]) 
0A1F4:  BCF    FD8.0
0A1F6:  MOVLB  7
0A1F8:  RLCF   x40,W
0A1FA:  CLRF   03
0A1FC:  ADDLW  92
0A1FE:  MOVWF  FE9
0A200:  MOVLW  07
0A202:  ADDWFC 03,W
0A204:  MOVWF  FEA
0A206:  MOVF   FEF,F
0A208:  BNZ   A210
0A20A:  MOVF   FEC,F
0A20C:  BTFSC  FD8.2
0A20E:  BRA    A706
....................       { 
....................          switch(e_mode[motor]) 
0A210:  BCF    FD8.0
0A212:  RLCF   x40,W
0A214:  CLRF   03
0A216:  ADDLW  66
0A218:  MOVWF  FE9
0A21A:  MOVLW  07
0A21C:  ADDWFC 03,W
0A21E:  MOVWF  FEA
0A220:  MOVF   FEF,W
0A222:  MOVWF  00
0A224:  MOVF   FEE,F
0A226:  MOVF   FED,W
0A228:  MOVWF  03
0A22A:  MOVF   03,W
0A22C:  BNZ   A236
0A22E:  MOVF   00,F
0A230:  MOVLB  0
0A232:  BZ    A284
0A234:  MOVLB  7
0A236:  MOVF   03,W
0A238:  BNZ   A244
0A23A:  MOVLW  01
0A23C:  SUBWF  00,W
0A23E:  MOVLB  0
0A240:  BZ    A2DA
0A242:  MOVLB  7
0A244:  MOVF   03,W
0A246:  BNZ   A252
0A248:  MOVLW  02
0A24A:  SUBWF  00,W
0A24C:  MOVLB  0
0A24E:  BZ    A2DA
0A250:  MOVLB  7
0A252:  MOVF   03,W
0A254:  BNZ   A262
0A256:  MOVLW  03
0A258:  SUBWF  00,W
0A25A:  MOVLB  0
0A25C:  BTFSC  FD8.2
0A25E:  BRA    A3A8
0A260:  MOVLB  7
0A262:  MOVF   03,W
0A264:  BNZ   A272
0A266:  MOVLW  04
0A268:  SUBWF  00,W
0A26A:  MOVLB  0
0A26C:  BTFSC  FD8.2
0A26E:  BRA    A4F8
0A270:  MOVLB  7
0A272:  MOVF   03,W
0A274:  BNZ   A282
0A276:  MOVLW  05
0A278:  SUBWF  00,W
0A27A:  MOVLB  0
0A27C:  BTFSC  FD8.2
0A27E:  BRA    A648
0A280:  MOVLB  7
0A282:  BRA    A700
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A284:  MOVLB  7
0A286:  MOVF   x40,W
0A288:  MULLW  04
0A28A:  MOVF   FF3,W
0A28C:  CLRF   03
0A28E:  ADDLW  A2
0A290:  MOVWF  FE9
0A292:  MOVLW  07
0A294:  ADDWFC 03,W
0A296:  MOVWF  FEA
0A298:  MOVFF  FEF,8D7
0A29C:  MOVFF  FEC,8D8
0A2A0:  MOVFF  FEC,8D9
0A2A4:  MOVFF  FEC,8DA
0A2A8:  MOVLB  8
0A2AA:  MOVF   xCC,W
0A2AC:  SUBWF  xDA,W
0A2AE:  BNC   A2D4
0A2B0:  BNZ   A2C8
0A2B2:  MOVF   xCB,W
0A2B4:  SUBWF  xD9,W
0A2B6:  BNC   A2D4
0A2B8:  BNZ   A2C8
0A2BA:  MOVF   xCA,W
0A2BC:  SUBWF  xD8,W
0A2BE:  BNC   A2D4
0A2C0:  BNZ   A2C8
0A2C2:  MOVF   xC9,W
0A2C4:  SUBWF  xD7,W
0A2C6:  BNC   A2D4
....................                { 
....................                   terminate(1); 
0A2C8:  MOVLW  01
0A2CA:  MOVWF  xEB
0A2CC:  MOVLB  0
0A2CE:  CALL   90D0
0A2D2:  MOVLB  8
....................                } 
....................                break; 
0A2D4:  MOVLB  7
0A2D6:  BRA    A700
0A2D8:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A2DA:  BCF    FD8.0
0A2DC:  MOVLB  7
0A2DE:  RLCF   x40,W
0A2E0:  CLRF   03
0A2E2:  ADDLW  9A
0A2E4:  MOVWF  FE9
0A2E6:  MOVLW  07
0A2E8:  ADDWFC 03,W
0A2EA:  MOVWF  FEA
0A2EC:  MOVFF  FEC,8D8
0A2F0:  MOVF   FED,F
0A2F2:  MOVFF  FEF,8D7
0A2F6:  BCF    FD8.0
0A2F8:  RLCF   x40,W
0A2FA:  CLRF   03
0A2FC:  ADDLW  5A
0A2FE:  MOVWF  FE9
0A300:  MOVLW  07
0A302:  ADDWFC 03,W
0A304:  MOVWF  FEA
0A306:  MOVFF  FEC,03
0A30A:  MOVF   FED,F
0A30C:  MOVFF  FEF,01
0A310:  MOVF   03,W
0A312:  MOVLB  8
0A314:  SUBWF  xD8,W
0A316:  BNC   A32A
0A318:  BNZ   A320
0A31A:  MOVF   01,W
0A31C:  SUBWF  xD7,W
0A31E:  BNC   A32A
....................                { 
....................                   terminate(0); 
0A320:  CLRF   xEB
0A322:  MOVLB  0
0A324:  CALL   90D0
0A328:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A32A:  BCF    FD8.0
0A32C:  MOVLB  7
0A32E:  RLCF   x40,W
0A330:  CLRF   03
0A332:  ADDLW  BB
0A334:  MOVWF  FE9
0A336:  MOVLW  07
0A338:  ADDWFC 03,W
0A33A:  MOVWF  FEA
0A33C:  MOVFF  FEC,8D8
0A340:  MOVF   FED,F
0A342:  MOVFF  FEF,8D7
0A346:  MOVLB  8
0A348:  MOVF   xCC,F
0A34A:  BNZ   A3A2
0A34C:  MOVF   xCB,F
0A34E:  BNZ   A3A2
0A350:  MOVF   xCA,W
0A352:  SUBWF  xD8,W
0A354:  BNC   A3A2
0A356:  BNZ   A35E
0A358:  MOVF   xC9,W
0A35A:  SUBWF  xD7,W
0A35C:  BNC   A3A2
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A35E:  BCF    FD8.0
0A360:  MOVLB  7
0A362:  RLCF   x40,W
0A364:  CLRF   03
0A366:  ADDLW  B7
0A368:  MOVWF  FE9
0A36A:  MOVLW  07
0A36C:  ADDWFC 03,W
0A36E:  MOVWF  FEA
0A370:  MOVFF  FEC,8DE
0A374:  MOVF   FED,F
0A376:  MOVFF  FEF,8DD
0A37A:  MOVFF  8CC,8DC
0A37E:  MOVFF  8CB,8DB
0A382:  MOVFF  8CA,8DA
0A386:  MOVFF  8C9,8D9
0A38A:  MOVLB  0
0A38C:  CALL   9690
0A390:  MOVFF  03,8D1
0A394:  MOVFF  02,8D0
0A398:  MOVFF  01,8CF
0A39C:  MOVFF  00,8CE
0A3A0:  MOVLB  8
....................                } 
....................                break; 
0A3A2:  MOVLB  7
0A3A4:  BRA    A700
0A3A6:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A3A8:  BCF    FD8.0
0A3AA:  MOVLB  7
0A3AC:  RLCF   x40,W
0A3AE:  CLRF   03
0A3B0:  ADDLW  BB
0A3B2:  MOVWF  FE9
0A3B4:  MOVLW  07
0A3B6:  ADDWFC 03,W
0A3B8:  MOVWF  FEA
0A3BA:  MOVFF  FEC,8D8
0A3BE:  MOVF   FED,F
0A3C0:  MOVFF  FEF,8D7
0A3C4:  MOVLB  8
0A3C6:  MOVF   xCC,F
0A3C8:  BNZ   A3E6
0A3CA:  MOVF   xCB,F
0A3CC:  BNZ   A3E6
0A3CE:  MOVF   xCA,W
0A3D0:  SUBWF  xD8,W
0A3D2:  BNC   A3E6
0A3D4:  BNZ   A3DC
0A3D6:  MOVF   xC9,W
0A3D8:  SUBWF  xD7,W
0A3DA:  BNC   A3E6
....................                { 
....................                   terminate(0); 
0A3DC:  CLRF   xEB
0A3DE:  MOVLB  0
0A3E0:  CALL   90D0
0A3E4:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A3E6:  BCF    FD8.0
0A3E8:  MOVLB  7
0A3EA:  RLCF   x40,W
0A3EC:  CLRF   03
0A3EE:  ADDLW  7A
0A3F0:  MOVWF  FE9
0A3F2:  MOVLW  07
0A3F4:  ADDWFC 03,W
0A3F6:  MOVWF  FEA
0A3F8:  MOVFF  FEC,8D8
0A3FC:  MOVF   FED,F
0A3FE:  MOVFF  FEF,8D7
0A402:  MOVLB  8
0A404:  MOVF   xD7,F
0A406:  BNZ   A46C
0A408:  MOVF   xD8,F
0A40A:  BNZ   A46C
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A40C:  CLRF   03
0A40E:  MOVLB  7
0A410:  MOVF   x40,W
0A412:  ADDLW  CB
0A414:  MOVWF  FE9
0A416:  MOVLW  07
0A418:  ADDWFC 03,W
0A41A:  MOVWF  FEA
0A41C:  MOVF   FEF,F
0A41E:  BNZ   A46A
....................                   { 
....................                      wrt_m_error(); 
0A420:  MOVLB  0
0A422:  CALL   8F80
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A426:  BCF    FD8.0
0A428:  MOVLB  7
0A42A:  RLCF   x40,W
0A42C:  CLRF   03
0A42E:  ADDLW  B7
0A430:  MOVWF  FE9
0A432:  MOVLW  07
0A434:  ADDWFC 03,W
0A436:  MOVWF  FEA
0A438:  MOVFF  FEC,8DE
0A43C:  MOVF   FED,F
0A43E:  MOVFF  FEF,8DD
0A442:  MOVFF  8CC,8DC
0A446:  MOVFF  8CB,8DB
0A44A:  MOVFF  8CA,8DA
0A44E:  MOVFF  8C9,8D9
0A452:  MOVLB  0
0A454:  CALL   9690
0A458:  MOVFF  03,8D1
0A45C:  MOVFF  02,8D0
0A460:  MOVFF  01,8CF
0A464:  MOVFF  00,8CE
0A468:  MOVLB  7
0A46A:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A46C:  BCF    FD8.0
0A46E:  MOVLB  7
0A470:  RLCF   x40,W
0A472:  CLRF   03
0A474:  ADDLW  7A
0A476:  MOVWF  FE9
0A478:  MOVLW  07
0A47A:  ADDWFC 03,W
0A47C:  MOVWF  FEA
0A47E:  MOVFF  FEC,8D8
0A482:  MOVF   FED,F
0A484:  MOVFF  FEF,8D7
0A488:  MOVLB  8
0A48A:  DECFSZ xD7,W
0A48C:  BRA    A4F2
0A48E:  MOVF   xD8,F
0A490:  BNZ   A4F2
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A492:  CLRF   03
0A494:  MOVLB  7
0A496:  MOVF   x40,W
0A498:  ADDLW  CB
0A49A:  MOVWF  FE9
0A49C:  MOVLW  07
0A49E:  ADDWFC 03,W
0A4A0:  MOVWF  FEA
0A4A2:  DECFSZ FEF,W
0A4A4:  BRA    A4F0
....................                   { 
....................                      wrt_m_error(); 
0A4A6:  MOVLB  0
0A4A8:  CALL   8F80
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A4AC:  BCF    FD8.0
0A4AE:  MOVLB  7
0A4B0:  RLCF   x40,W
0A4B2:  CLRF   03
0A4B4:  ADDLW  B7
0A4B6:  MOVWF  FE9
0A4B8:  MOVLW  07
0A4BA:  ADDWFC 03,W
0A4BC:  MOVWF  FEA
0A4BE:  MOVFF  FEC,8DE
0A4C2:  MOVF   FED,F
0A4C4:  MOVFF  FEF,8DD
0A4C8:  MOVFF  8CC,8DC
0A4CC:  MOVFF  8CB,8DB
0A4D0:  MOVFF  8CA,8DA
0A4D4:  MOVFF  8C9,8D9
0A4D8:  MOVLB  0
0A4DA:  CALL   9690
0A4DE:  MOVFF  03,8D1
0A4E2:  MOVFF  02,8D0
0A4E6:  MOVFF  01,8CF
0A4EA:  MOVFF  00,8CE
0A4EE:  MOVLB  7
0A4F0:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A4F2:  MOVLB  7
0A4F4:  BRA    A700
0A4F6:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A4F8:  MOVLB  7
0A4FA:  MOVF   x40,W
0A4FC:  MULLW  04
0A4FE:  MOVF   FF3,W
0A500:  CLRF   03
0A502:  ADDLW  A2
0A504:  MOVWF  FE9
0A506:  MOVLW  07
0A508:  ADDWFC 03,W
0A50A:  MOVWF  FEA
0A50C:  MOVFF  FEF,8D7
0A510:  MOVFF  FEC,8D8
0A514:  MOVFF  FEC,8D9
0A518:  MOVFF  FEC,8DA
0A51C:  MOVLB  8
0A51E:  MOVF   xCE,W
0A520:  SUBWF  xD7,F
0A522:  MOVF   xCF,W
0A524:  SUBWFB xD8,F
0A526:  MOVF   xD0,W
0A528:  SUBWFB xD9,F
0A52A:  MOVF   xD1,W
0A52C:  SUBWFB xDA,F
0A52E:  BNZ   A546
0A530:  MOVF   xD9,F
0A532:  BNZ   A546
0A534:  MOVF   xD5,W
0A536:  SUBWF  xD8,W
0A538:  BTFSS  FD8.0
0A53A:  BRA    A642
0A53C:  BNZ   A546
0A53E:  MOVF   xD4,W
0A540:  SUBWF  xD7,W
0A542:  BTFSS  FD8.0
0A544:  BRA    A642
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A546:  BCF    FD8.0
0A548:  MOVLB  7
0A54A:  RLCF   x40,W
0A54C:  CLRF   03
0A54E:  ADDLW  66
0A550:  MOVWF  01
0A552:  MOVLW  07
0A554:  ADDWFC 03,F
0A556:  MOVLB  8
0A558:  MOVFF  03,8D8
0A55C:  BCF    FD8.0
0A55E:  MOVLB  7
0A560:  RLCF   x40,W
0A562:  CLRF   03
0A564:  ADDLW  9E
0A566:  MOVWF  FE9
0A568:  MOVLW  07
0A56A:  ADDWFC 03,W
0A56C:  MOVWF  FEA
0A56E:  MOVFF  FEC,03
0A572:  MOVF   FED,F
0A574:  MOVFF  FEF,8D9
0A578:  MOVLB  8
0A57A:  MOVFF  8D8,FEA
0A57E:  MOVFF  01,FE9
0A582:  MOVFF  03,FEC
0A586:  MOVF   FED,F
0A588:  MOVFF  8D9,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A58C:  MOVLB  7
0A58E:  MOVF   x40,W
0A590:  MULLW  04
0A592:  MOVF   FF3,W
0A594:  CLRF   03
0A596:  ADDLW  A2
0A598:  MOVWF  FE9
0A59A:  MOVLW  07
0A59C:  ADDWFC 03,W
0A59E:  MOVWF  FEA
0A5A0:  MOVFF  FEF,8D7
0A5A4:  MOVFF  FEC,8D8
0A5A8:  MOVFF  FEC,8D9
0A5AC:  MOVFF  FEC,8DA
0A5B0:  MOVLW  8C
0A5B2:  MOVWF  FF6
0A5B4:  MOVLW  1A
0A5B6:  MOVWF  FF7
0A5B8:  MOVLW  00
0A5BA:  MOVWF  FF8
0A5BC:  CLRF   1B
0A5BE:  BTFSC  FF2.7
0A5C0:  BSF    1B.7
0A5C2:  BCF    FF2.7
0A5C4:  MOVLW  0B
0A5C6:  MOVLB  A
0A5C8:  MOVWF  x40
0A5CA:  MOVLB  0
0A5CC:  CALL   1024
0A5D0:  BTFSC  1B.7
0A5D2:  BSF    FF2.7
0A5D4:  MOVLW  41
0A5D6:  MOVWF  FE9
0A5D8:  CLRF   1B
0A5DA:  BTFSC  FF2.7
0A5DC:  BSF    1B.7
0A5DE:  BCF    FF2.7
0A5E0:  MOVFF  8DA,A43
0A5E4:  MOVFF  8D9,A42
0A5E8:  MOVFF  8D8,A41
0A5EC:  MOVFF  8D7,A40
0A5F0:  CALL   10EA
0A5F4:  BTFSC  1B.7
0A5F6:  BSF    FF2.7
0A5F8:  MOVLW  2C
0A5FA:  BTFSS  F9E.4
0A5FC:  BRA    A5FA
0A5FE:  MOVWF  FAD
0A600:  MOVLW  41
0A602:  MOVWF  FE9
0A604:  CLRF   1B
0A606:  BTFSC  FF2.7
0A608:  BSF    1B.7
0A60A:  BCF    FF2.7
0A60C:  MOVFF  8D1,A43
0A610:  MOVFF  8D0,A42
0A614:  MOVFF  8CF,A41
0A618:  MOVFF  8CE,A40
0A61C:  CALL   10EA
0A620:  BTFSC  1B.7
0A622:  BSF    FF2.7
0A624:  MOVLW  0D
0A626:  BTFSS  F9E.4
0A628:  BRA    A626
0A62A:  MOVWF  FAD
0A62C:  MOVLW  0A
0A62E:  BTFSS  F9E.4
0A630:  BRA    A62E
0A632:  MOVWF  FAD
....................                   terminate(1); 
0A634:  MOVLW  01
0A636:  MOVLB  8
0A638:  MOVWF  xEB
0A63A:  MOVLB  0
0A63C:  CALL   90D0
0A640:  MOVLB  8
....................                } 
....................                break; 
0A642:  MOVLB  7
0A644:  BRA    A700
0A646:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A648:  MOVLB  7
0A64A:  MOVF   x40,W
0A64C:  MULLW  04
0A64E:  MOVF   FF3,W
0A650:  CLRF   03
0A652:  ADDLW  A2
0A654:  MOVWF  FE9
0A656:  MOVLW  07
0A658:  ADDWFC 03,W
0A65A:  MOVWF  FEA
0A65C:  MOVFF  FEF,8D7
0A660:  MOVFF  FEC,8D8
0A664:  MOVFF  FEC,8D9
0A668:  MOVFF  FEC,8DA
0A66C:  BCF    FD8.0
0A66E:  RLCF   x40,W
0A670:  CLRF   03
0A672:  ADDLW  72
0A674:  MOVWF  FE9
0A676:  MOVLW  07
0A678:  ADDWFC 03,W
0A67A:  MOVWF  FEA
0A67C:  MOVFF  FEC,03
0A680:  MOVF   FED,F
0A682:  MOVFF  FEF,01
0A686:  MOVLB  8
0A688:  MOVF   xDA,F
0A68A:  BNZ   A69E
0A68C:  MOVF   xD9,F
0A68E:  BNZ   A69E
0A690:  MOVF   03,W
0A692:  SUBWF  xD8,W
0A694:  BNC   A6FE
0A696:  BNZ   A69E
0A698:  MOVF   01,W
0A69A:  SUBWF  xD7,W
0A69C:  BNC   A6FE
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A69E:  BCF    FD8.0
0A6A0:  MOVLB  7
0A6A2:  RLCF   x40,W
0A6A4:  CLRF   03
0A6A6:  ADDLW  66
0A6A8:  MOVWF  01
0A6AA:  MOVLW  07
0A6AC:  ADDWFC 03,F
0A6AE:  MOVLB  8
0A6B0:  MOVFF  03,8D8
0A6B4:  BCF    FD8.0
0A6B6:  MOVLB  7
0A6B8:  RLCF   x40,W
0A6BA:  CLRF   03
0A6BC:  ADDLW  9E
0A6BE:  MOVWF  FE9
0A6C0:  MOVLW  07
0A6C2:  ADDWFC 03,W
0A6C4:  MOVWF  FEA
0A6C6:  MOVFF  FEC,03
0A6CA:  MOVF   FED,F
0A6CC:  MOVFF  FEF,8D9
0A6D0:  MOVLB  8
0A6D2:  MOVFF  8D8,FEA
0A6D6:  MOVFF  01,FE9
0A6DA:  MOVFF  03,FEC
0A6DE:  MOVF   FED,F
0A6E0:  MOVFF  8D9,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A6E4:  BCF    FD8.0
0A6E6:  MOVLB  7
0A6E8:  RLCF   x40,W
0A6EA:  CLRF   03
0A6EC:  ADDLW  BB
0A6EE:  MOVWF  FE9
0A6F0:  MOVLW  07
0A6F2:  ADDWFC 03,W
0A6F4:  MOVWF  FEA
0A6F6:  CLRF   FEC
0A6F8:  MOVF   FED,F
0A6FA:  CLRF   FEF
0A6FC:  MOVLB  8
....................                } 
....................                break; 
0A6FE:  MOVLB  7
....................             } 
....................          } 
0A700:  MOVLB  0
0A702:  BRA    A1F4
0A704:  MOVLB  7
....................       } 
....................    } 
0A706:  BRA    A724
0A708:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A70A:  BCF    FD8.0
0A70C:  MOVLB  7
0A70E:  RLCF   x40,W
0A710:  CLRF   03
0A712:  ADDLW  96
0A714:  MOVWF  FE9
0A716:  MOVLW  07
0A718:  ADDWFC 03,W
0A71A:  MOVWF  FEA
0A71C:  CLRF   FEC
0A71E:  MOVF   FED,F
0A720:  MOVLW  01
0A722:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A724:  BCF    FD8.0
0A726:  RLCF   x40,W
0A728:  CLRF   03
0A72A:  ADDLW  96
0A72C:  MOVWF  FE9
0A72E:  MOVLW  07
0A730:  ADDWFC 03,W
0A732:  MOVWF  FEA
0A734:  MOVFF  FEC,8D8
0A738:  MOVF   FED,F
0A73A:  MOVFF  FEF,8D7
0A73E:  MOVLB  8
0A740:  DECFSZ xD7,W
0A742:  BRA    A754
0A744:  MOVF   xD8,F
0A746:  BNZ   A754
....................       wrt_m_error(); 
0A748:  MOVLB  0
0A74A:  CALL   8F80
....................       msg_mer(); 
0A74E:  CALL   9D02
0A752:  MOVLB  8
....................    } 
0A754:  MOVLB  0
0A756:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
17056:  MOVF   48,F
17058:  BNZ   17066
1705A:  MOVF   49,F
1705C:  BNZ   17066
1705E:  MOVF   4A,F
17060:  BNZ   17066
17062:  MOVF   4B,F
17064:  BZ    17092
17066:  MOVF   4B,F
17068:  BNZ   17092
1706A:  MOVF   4A,W
1706C:  SUBLW  00
1706E:  BNC   17092
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
17070:  MOVFF  885,8C7
17074:  MOVFF  886,8C8
17078:  MOVFF  4B,8CC
1707C:  MOVFF  4A,8CB
17080:  MOVFF  49,8CA
17084:  MOVFF  48,8C9
17088:  MOVFF  887,8CD
1708C:  CALL   9D78
....................    } 
17090:  BRA    1710E
....................    else if(arg==0) 
17092:  MOVF   48,F
17094:  BNZ   1710A
17096:  MOVF   49,F
17098:  BNZ   1710A
1709A:  MOVF   4A,F
1709C:  BNZ   1710A
1709E:  MOVF   4B,F
170A0:  BNZ   1710A
....................    { 
....................       m_lin_pos[motor]=0; 
170A2:  BCF    FD8.0
170A4:  MOVLB  7
170A6:  RLCF   x40,W
170A8:  CLRF   03
170AA:  ADDLW  B3
170AC:  MOVWF  FE9
170AE:  MOVLW  07
170B0:  ADDWFC 03,W
170B2:  MOVWF  FEA
170B4:  CLRF   FEC
170B6:  MOVF   FED,F
170B8:  CLRF   FEF
....................       switch (motor){ 
170BA:  MOVF   x40,W
170BC:  XORLW  00
170BE:  MOVLB  0
170C0:  BZ    170C8
170C2:  XORLW  01
170C4:  BZ    170DA
170C6:  BRA    170EA
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
170C8:  MOVLW  B6
170CA:  MOVLB  8
170CC:  MOVWF  xEE
170CE:  CLRF   xF0
170D0:  CLRF   xEF
170D2:  MOVLB  0
170D4:  CALL   4FD4
....................             break; 
170D8:  BRA    170EA
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
170DA:  MOVLW  B8
170DC:  MOVLB  8
170DE:  MOVWF  xEE
170E0:  CLRF   xF0
170E2:  CLRF   xEF
170E4:  MOVLB  0
170E6:  CALL   4FD4
....................             break; 
....................       }  
....................       m_error[motor]=0; 
170EA:  BCF    FD8.0
170EC:  MOVLB  7
170EE:  RLCF   x40,W
170F0:  CLRF   03
170F2:  ADDLW  96
170F4:  MOVWF  FE9
170F6:  MOVLW  07
170F8:  ADDWFC 03,W
170FA:  MOVWF  FEA
170FC:  CLRF   FEC
170FE:  MOVF   FED,F
17100:  CLRF   FEF
....................       wrt_m_error(); 
17102:  MOVLB  0
17104:  CALL   8F80
....................    } 
17108:  BRA    1710E
....................    else cmd_arg(); 
1710A:  CALL   B2C2
1710E:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
18C28:  MOVLW  01
18C2A:  MOVLB  8
18C2C:  MOVWF  xEC
18C2E:  MOVLB  0
18C30:  CALL   89D0
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18C34:  MOVLW  FA
18C36:  MOVLB  9
18C38:  MOVWF  xEC
18C3A:  MOVLB  0
18C3C:  CALL   2910
....................       switch(motor) 
18C40:  MOVLB  7
18C42:  MOVF   x40,W
18C44:  XORLW  00
18C46:  MOVLB  0
18C48:  BZ    18C50
18C4A:  XORLW  01
18C4C:  BZ    18C62
18C4E:  BRA    18C72
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18C50:  MOVLB  8
18C52:  CLRF   x85
18C54:  BTFSC  F81.4
18C56:  INCF   x85,F
....................             chanA = input(ENC1_PHA); 
18C58:  CLRF   x86
18C5A:  BTFSC  F81.1
18C5C:  INCF   x86,F
....................             break; 
18C5E:  MOVLB  0
18C60:  BRA    18C72
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18C62:  MOVLB  8
18C64:  CLRF   x85
18C66:  BTFSC  F81.5
18C68:  INCF   x85,F
....................             chanA = input(ENC2_PHA); 
18C6A:  CLRF   x86
18C6C:  BTFSC  F81.2
18C6E:  INCF   x86,F
....................             break; 
18C70:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18C72:  MOVLW  A2
18C74:  MOVWF  FF6
18C76:  MOVLW  1A
18C78:  MOVWF  FF7
18C7A:  MOVLW  00
18C7C:  MOVWF  FF8
18C7E:  CLRF   1B
18C80:  BTFSC  FF2.7
18C82:  BSF    1B.7
18C84:  BCF    FF2.7
18C86:  MOVLW  04
18C88:  MOVLB  A
18C8A:  MOVWF  x40
18C8C:  MOVLB  0
18C8E:  CALL   1024
18C92:  BTFSC  1B.7
18C94:  BSF    FF2.7
18C96:  CLRF   1B
18C98:  BTFSC  FF2.7
18C9A:  BSF    1B.7
18C9C:  BCF    FF2.7
18C9E:  MOVFF  885,A40
18CA2:  MOVLW  1B
18CA4:  MOVLB  A
18CA6:  MOVWF  x41
18CA8:  MOVLB  0
18CAA:  CALL   0FA6
18CAE:  BTFSC  1B.7
18CB0:  BSF    FF2.7
18CB2:  MOVLW  A8
18CB4:  MOVWF  FF6
18CB6:  MOVLW  1A
18CB8:  MOVWF  FF7
18CBA:  MOVLW  00
18CBC:  MOVWF  FF8
18CBE:  CLRF   1B
18CC0:  BTFSC  FF2.7
18CC2:  BSF    1B.7
18CC4:  BCF    FF2.7
18CC6:  MOVLW  07
18CC8:  MOVLB  A
18CCA:  MOVWF  x40
18CCC:  MOVLB  0
18CCE:  CALL   1024
18CD2:  BTFSC  1B.7
18CD4:  BSF    FF2.7
18CD6:  CLRF   1B
18CD8:  BTFSC  FF2.7
18CDA:  BSF    1B.7
18CDC:  BCF    FF2.7
18CDE:  MOVFF  886,A40
18CE2:  MOVLW  1B
18CE4:  MOVLB  A
18CE6:  MOVWF  x41
18CE8:  MOVLB  0
18CEA:  CALL   0FA6
18CEE:  BTFSC  1B.7
18CF0:  BSF    FF2.7
18CF2:  MOVLW  0D
18CF4:  BTFSS  F9E.4
18CF6:  BRA    18CF4
18CF8:  MOVWF  FAD
18CFA:  MOVLW  0A
18CFC:  BTFSS  F9E.4
18CFE:  BRA    18CFC
18D00:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
18D02:  BTFSS  F9E.5
18D04:  BRA    18D12
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
18D06:  CALL   0E38
18D0A:  MOVF   01,W
18D0C:  SUBLW  1B
18D0E:  BNZ   18D12
....................          { 
....................             break; 
18D10:  BRA    18D14
....................          } 
....................       } 
18D12:  BRA    18C34
....................    } 
....................  
....................    delay_ms(100); 
18D14:  MOVLW  64
18D16:  MOVLB  9
18D18:  MOVWF  xEC
18D1A:  MOVLB  0
18D1C:  CALL   2910
....................    enc_pwr(OFF); 
18D20:  MOVLB  8
18D22:  CLRF   xEC
18D24:  MOVLB  0
18D26:  CALL   89D0
18D2A:  GOTO   18D46 (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A8B4:  BCF    FD8.0
0A8B6:  MOVLB  7
0A8B8:  RLCF   x40,W
0A8BA:  CLRF   03
0A8BC:  ADDLW  66
0A8BE:  MOVWF  FE9
0A8C0:  MOVLW  07
0A8C2:  ADDWFC 03,W
0A8C4:  MOVWF  FEA
0A8C6:  MOVFF  FEC,8C6
0A8CA:  MOVF   FED,F
0A8CC:  MOVFF  FEF,8C5
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A8D0:  BCF    FD8.0
0A8D2:  RLCF   x40,W
0A8D4:  CLRF   03
0A8D6:  ADDLW  76
0A8D8:  MOVWF  FE9
0A8DA:  MOVLW  07
0A8DC:  ADDWFC 03,W
0A8DE:  MOVWF  FEA
0A8E0:  MOVFF  FEC,8DC
0A8E4:  MOVF   FED,F
0A8E6:  MOVFF  FEF,8DB
0A8EA:  BCF    FD8.0
0A8EC:  RLCF   x40,W
0A8EE:  CLRF   03
0A8F0:  ADDLW  62
0A8F2:  MOVWF  FE9
0A8F4:  MOVLW  07
0A8F6:  ADDWFC 03,W
0A8F8:  MOVWF  FEA
0A8FA:  MOVFF  FEC,03
0A8FE:  MOVF   FED,F
0A900:  MOVFF  FEF,8DD
0A904:  MOVFF  03,8CA
0A908:  MOVFF  03,8DE
0A90C:  MOVLB  0
0A90E:  CALL   2CD4
0A912:  MOVFF  02,8C4
0A916:  MOVFF  01,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A91A:  BCF    FD8.0
0A91C:  MOVLB  7
0A91E:  RLCF   x40,W
0A920:  CLRF   03
0A922:  ADDLW  66
0A924:  MOVWF  FE9
0A926:  MOVLW  07
0A928:  ADDWFC 03,W
0A92A:  MOVWF  FEA
0A92C:  CLRF   FEC
0A92E:  MOVF   FED,F
0A930:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A932:  MOVLB  8
0A934:  CLRF   xC7
0A936:  MOVFF  8C2,8C8
0A93A:  CLRF   xCC
0A93C:  CLRF   xCB
0A93E:  MOVFF  8C4,8CA
0A942:  MOVFF  8C3,8C9
0A946:  MOVLW  01
0A948:  MOVWF  xCD
0A94A:  MOVLB  0
0A94C:  CALL   9D78
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A950:  MOVLW  01
0A952:  MOVLB  8
0A954:  MOVWF  xEC
0A956:  MOVLB  0
0A958:  CALL   89D0
....................    delay_ms(100); 
0A95C:  MOVLW  64
0A95E:  MOVLB  9
0A960:  MOVWF  xEC
0A962:  MOVLB  0
0A964:  CALL   2910
....................    poll_index(); 
0A968:  BRA    A782
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A96A:  BCF    FD8.0
0A96C:  MOVLB  7
0A96E:  RLCF   x40,W
0A970:  CLRF   03
0A972:  ADDLW  5E
0A974:  MOVWF  FE9
0A976:  MOVLW  07
0A978:  ADDWFC 03,W
0A97A:  MOVWF  FEA
0A97C:  MOVFF  FEC,8C8
0A980:  MOVF   FED,F
0A982:  MOVFF  FEF,8C7
0A986:  MOVLW  02
0A988:  MOVLB  8
0A98A:  ADDWF  xC7,W
0A98C:  MOVWF  xC3
0A98E:  MOVLW  00
0A990:  ADDWFC xC8,W
0A992:  MOVWF  xC4
....................    e_mode[motor] = 3; 
0A994:  BCF    FD8.0
0A996:  MOVLB  7
0A998:  RLCF   x40,W
0A99A:  CLRF   03
0A99C:  ADDLW  66
0A99E:  MOVWF  FE9
0A9A0:  MOVLW  07
0A9A2:  ADDWFC 03,W
0A9A4:  MOVWF  FEA
0A9A6:  CLRF   FEC
0A9A8:  MOVF   FED,F
0A9AA:  MOVLW  03
0A9AC:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A9AE:  MOVLB  8
0A9B0:  CLRF   xC7
0A9B2:  MOVFF  8C2,8C8
0A9B6:  CLRF   xCC
0A9B8:  CLRF   xCB
0A9BA:  MOVFF  8C4,8CA
0A9BE:  MOVFF  8C3,8C9
0A9C2:  MOVLW  01
0A9C4:  MOVWF  xCD
0A9C6:  MOVLB  0
0A9C8:  CALL   9D78
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A9CC:  MOVFF  783,8C4
0A9D0:  MOVFF  782,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A9D4:  BCF    FD8.0
0A9D6:  MOVLB  7
0A9D8:  RLCF   x40,W
0A9DA:  CLRF   03
0A9DC:  ADDLW  66
0A9DE:  MOVWF  FE9
0A9E0:  MOVLW  07
0A9E2:  ADDWFC 03,W
0A9E4:  MOVWF  FEA
0A9E6:  CLRF   FEC
0A9E8:  MOVF   FED,F
0A9EA:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0A9EC:  MOVLB  8
0A9EE:  CLRF   xC7
0A9F0:  MOVFF  8C2,8C8
0A9F4:  CLRF   xCC
0A9F6:  CLRF   xCB
0A9F8:  MOVFF  8C4,8CA
0A9FC:  MOVFF  8C3,8C9
0AA00:  MOVLW  01
0AA02:  MOVWF  xCD
0AA04:  MOVLB  0
0AA06:  CALL   9D78
....................  
....................    e_pos[motor] = 0; 
0AA0A:  BCF    FD8.0
0AA0C:  MOVLB  7
0AA0E:  RLCF   x40,W
0AA10:  CLRF   03
0AA12:  ADDLW  BF
0AA14:  MOVWF  FE9
0AA16:  MOVLW  07
0AA18:  ADDWFC 03,W
0AA1A:  MOVWF  FEA
0AA1C:  CLRF   FEC
0AA1E:  MOVF   FED,F
0AA20:  CLRF   FEF
....................    e_port[motor] = 1; 
0AA22:  BCF    FD8.0
0AA24:  RLCF   x40,W
0AA26:  CLRF   03
0AA28:  ADDLW  C3
0AA2A:  MOVWF  FE9
0AA2C:  MOVLW  07
0AA2E:  ADDWFC 03,W
0AA30:  MOVWF  FEA
0AA32:  CLRF   FEC
0AA34:  MOVF   FED,F
0AA36:  MOVLW  01
0AA38:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0AA3A:  BCF    FD8.0
0AA3C:  RLCF   x40,W
0AA3E:  CLRF   03
0AA40:  ADDLW  66
0AA42:  MOVWF  FE9
0AA44:  MOVLW  07
0AA46:  ADDWFC 03,W
0AA48:  MOVWF  FEA
0AA4A:  MOVFF  8C6,FEC
0AA4E:  MOVF   FED,F
0AA50:  MOVFF  8C5,FEF
0AA54:  MOVLB  0
0AA56:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0E078:  BCF    FD8.0
0E07A:  MOVLB  7
0E07C:  RLCF   x40,W
0E07E:  CLRF   03
0E080:  ADDLW  5E
0E082:  MOVWF  FE9
0E084:  MOVLW  07
0E086:  ADDWFC 03,W
0E088:  MOVWF  FEA
0E08A:  MOVFF  FEC,889
0E08E:  MOVF   FED,F
0E090:  MOVFF  FEF,888
0E094:  MOVLW  02
0E096:  MOVLB  8
0E098:  ADDWF  x88,W
0E09A:  MOVWF  x86
0E09C:  MOVLW  00
0E09E:  ADDWFC x89,W
0E0A0:  MOVWF  x87
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0E0A2:  CLRF   xC7
0E0A4:  MOVFF  885,8C8
0E0A8:  CLRF   xCC
0E0AA:  CLRF   xCB
0E0AC:  MOVFF  887,8CA
0E0B0:  MOVFF  886,8C9
0E0B4:  MOVLW  02
0E0B6:  MOVWF  xCD
0E0B8:  MOVLB  0
0E0BA:  CALL   9D78
0E0BE:  GOTO   E13E (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0AA58:  MOVF   2F,W
0AA5A:  SUBLW  02
0AA5C:  BNZ   AA62
0AA5E:  MOVF   30,F
0AA60:  BZ    AACA
....................    { 
....................       //setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_256); 
....................       //set up valve timeout variable 
....................       /*ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
....................       enable_interrupts(INT_EXT); 
....................  
....................       start_heartbeat(); 
....................  
....................       enable_interrupts(GLOBAL); 
....................       busy_set();*/ 
....................       valve_align_timeout = 0; 
0AA62:  CLRF   3A
0AA64:  CLRF   39
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0AA66:  MOVLW  B4
0AA68:  MOVWF  FF6
0AA6A:  MOVLW  1A
0AA6C:  MOVWF  FF7
0AA6E:  MOVLW  00
0AA70:  MOVWF  FF8
0AA72:  CLRF   1B
0AA74:  BTFSC  FF2.7
0AA76:  BSF    1B.7
0AA78:  BCF    FF2.7
0AA7A:  CALL   0E4E
0AA7E:  BTFSC  1B.7
0AA80:  BSF    FF2.7
....................       motor=0; 
0AA82:  MOVLB  7
0AA84:  CLRF   x40
....................       align(0); 
0AA86:  MOVLB  8
0AA88:  CLRF   xC2
0AA8A:  MOVLB  0
0AA8C:  RCALL  A8B4
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0AA8E:  MOVLW  01
0AA90:  MOVLB  7
0AA92:  MOVWF  x40
....................       move_motor(0,0,22000,1); 
0AA94:  MOVLB  8
0AA96:  CLRF   xC7
0AA98:  CLRF   xC8
0AA9A:  CLRF   xCC
0AA9C:  CLRF   xCB
0AA9E:  MOVLW  55
0AAA0:  MOVWF  xCA
0AAA2:  MOVLW  F0
0AAA4:  MOVWF  xC9
0AAA6:  MOVLW  01
0AAA8:  MOVWF  xCD
0AAAA:  MOVLB  0
0AAAC:  CALL   9D78
....................        
....................       m_lin_pos[1]=0; 
0AAB0:  MOVLB  7
0AAB2:  CLRF   xB6
0AAB4:  CLRF   xB5
....................       write16(ADDR_M2_LIN_POS,0); 
0AAB6:  MOVLW  B8
0AAB8:  MOVLB  8
0AABA:  MOVWF  xEE
0AABC:  CLRF   xF0
0AABE:  CLRF   xEF
0AAC0:  MOVLB  0
0AAC2:  CALL   4FD4
....................       valve_align_timeout = -1; 
0AAC6:  SETF   3A
0AAC8:  SETF   39
....................    } 
0AACA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0C1C6:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C1C8:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0C1CA:  BCF    F8E.3
....................   delay_ms(20); 
0C1CC:  MOVLW  14
0C1CE:  MOVLB  9
0C1D0:  MOVWF  xEC
0C1D2:  MOVLB  0
0C1D4:  CALL   2910
....................   output_bit(VMOT,  OFF); 
0C1D8:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0C1DA:  BCF    F8E.2
0C1DC:  GOTO   C232 (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C1E0:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C1E2:  BSF    F8E.1
....................   delay_ms(50); 
0C1E4:  MOVLW  32
0C1E6:  MOVLB  9
0C1E8:  MOVWF  xEC
0C1EA:  MOVLB  0
0C1EC:  CALL   2910
....................   output_bit(HB_IN1,ON);           
0C1F0:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C1F2:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0C1F4:  BSF    F8E.3
0C1F6:  GOTO   C232 (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C1FA:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C1FC:  BSF    F8E.1
....................   delay_ms(50); 
0C1FE:  MOVLW  32
0C200:  MOVLB  9
0C202:  MOVWF  xEC
0C204:  MOVLB  0
0C206:  CALL   2910
....................   output_bit(HB_IN1,OFF);           
0C20A:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0C20C:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0C20E:  BSF    F8E.3
0C210:  GOTO   C232 (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0C214:  MOVLB  8
0C216:  MOVF   xB5,W
0C218:  XORLW  00
0C21A:  MOVLB  0
0C21C:  BZ    C228
0C21E:  XORLW  01
0C220:  BZ    C22C
0C222:  XORLW  03
0C224:  BZ    C230
0C226:  BRA    C232
....................       case 0:  HB_all_OFF(); 
0C228:  BRA    C1C6
....................          break; 
0C22A:  BRA    C232
....................       case 1:  HB_m1_ON(); 
0C22C:  BRA    C1E0
....................          break; 
0C22E:  BRA    C232
....................       case 2:  HB_m2_ON(); 
0C230:  BRA    C1FA
....................          break; 
....................    } 
0C232:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
15D5C:  MOVLB  8
15D5E:  CLRF   x89
15D60:  CLRF   x8A
15D62:  CLRF   x8B
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
15D64:  MOVLB  0
15D66:  BRA    15CF2
15D68:  MOVFF  01,88A
....................       if (serChar) 
15D6C:  MOVLB  8
15D6E:  MOVF   x8A,F
15D70:  BZ    15D9A
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
15D72:  MOVF   x8A,W
15D74:  SUBLW  24
15D76:  BNZ   15D80
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
15D78:  MOVLW  02
15D7A:  MOVWF  x8B
....................             break; 
15D7C:  BRA    15DA6
....................          }else if (serChar == 'D'){ 
15D7E:  BRA    15D9A
15D80:  MOVF   x8A,W
15D82:  SUBLW  44
15D84:  BNZ   15D96
....................             wakeup_char_is_D = 1; 
15D86:  MOVLW  01
15D88:  MOVLB  7
15D8A:  MOVWF  xCD
....................             wakeUpReason = WAKE_UP_GOOD; 
15D8C:  MOVLW  02
15D8E:  MOVLB  8
15D90:  MOVWF  x8B
....................             break; 
15D92:  BRA    15DA6
....................          }else 
15D94:  BRA    15D9A
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
15D96:  MOVLW  01
15D98:  MOVWF  x8B
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
15D9A:  INCF   x89,F
15D9C:  MOVF   x89,W
15D9E:  SUBLW  02
15DA0:  BC    15DA4
....................       { 
....................          break; 
15DA2:  BRA    15DA6
....................       } 
15DA4:  BRA    15D64
....................    } 
....................  
....................    return (wakeUpReason); 
15DA6:  MOVFF  88B,01
15DAA:  MOVLB  0
15DAC:  GOTO   15DC0 (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
15C8A:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
15C8C:  BSF    4D.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
15C8E:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
15C90:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
15C92:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
15C94:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
15C96:  BSF    FF2.6
15C98:  GOTO   15CA4 (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
15C9C:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
15C9E:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
15CA0:  BCF    4D.0
....................    set_usart_int(); 
15CA2:  BRA    15C8A
....................    kill_wd(); 
15CA4:  CALL   30F6
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
15CA8:  BSF    FF2.4
....................    sleep();  
15CAA:  MOVFF  FD3,00
15CAE:  BCF    FD1.7
15CB0:  BCF    FD3.7
15CB2:  SLEEP 
15CB4:  MOVFF  00,FD3
....................    delay_cycles(1); 
15CB8:  NOP   
15CBA:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
15DB0:  MOVLB  8
15DB2:  CLRF   x88
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
15DB4:  MOVLB  0
15DB6:  RCALL  15CBC
....................  
....................    if (TRUE != rtc_alarm) 
15DB8:  BTFSC  4D.0
15DBA:  BRA    15E7C
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15DBC:  RCALL  15CBC
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15DBE:  BRA    15D5C
15DC0:  MOVFF  01,888
....................       if (WAKE_UP_GOOD == serWakeupReason) 
15DC4:  MOVLB  8
15DC6:  MOVF   x88,W
15DC8:  SUBLW  02
15DCA:  BNZ   15E74
....................       { 
....................          sleep_mode = FALSE; 
15DCC:  BCF    4D.1
....................          start_heartbeat(); 
15DCE:  MOVLB  0
15DD0:  CALL   2900
....................          init_hardware(); 
15DD4:  CALL   293A
....................          init_rtc();                      // This is the FAT RTC 
15DD8:  CALL   3508
....................          sd_status = init_sdcard(); 
15DDC:  CALL   503A
15DE0:  MOVFF  01,2DC
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
15DE4:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
15DE6:  MOVLW  01
15DE8:  MOVWF  1E
15DEA:  MOVLW  A7
15DEC:  MOVWF  1D
15DEE:  MOVLW  EA
15DF0:  MOVWF  FF6
15DF2:  MOVLW  1A
15DF4:  MOVWF  FF7
15DF6:  MOVLW  00
15DF8:  MOVWF  FF8
15DFA:  CALL   50BE
....................          record_event(); 
15DFE:  CALL   84DA
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15E02:  CLRF   32
15E04:  MOVLW  01
15E06:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
15E08:  MOVLW  02
15E0A:  MOVLB  8
15E0C:  MOVWF  x89
15E0E:  MOVFF  31,88A
15E12:  MOVLB  0
15E14:  CALL   3412
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
15E18:  MOVLB  7
15E1A:  MOVF   xCD,F
15E1C:  BZ    15E42
....................             file_list(file_ptr_rel_new); 
15E1E:  MOVLW  03
15E20:  MOVLB  8
15E22:  MOVWF  x8A
15E24:  MOVLW  07
15E26:  MOVWF  x89
15E28:  MOVLB  0
15E2A:  CALL   BAE8
....................             f_unlink(file_ptr_rel_new); 
15E2E:  MOVLW  03
15E30:  MOVLB  8
15E32:  MOVWF  x8A
15E34:  MOVLW  07
15E36:  MOVWF  x89
15E38:  MOVLB  0
15E3A:  CALL   BC62
....................              
....................             wakeup_char_is_D = 0; 
15E3E:  MOVLB  7
15E40:  CLRF   xCD
....................          } 
....................          if(sd_status>0) 
15E42:  MOVLB  2
15E44:  MOVF   xDC,F
15E46:  BZ    15E50
....................          { 
....................             msg_card_fail(); 
15E48:  MOVLB  0
15E4A:  CALL   5080
15E4E:  MOVLB  2
....................          } 
....................  
....................          fprintf(COM_A, "@RST\r\n"); 
15E50:  MOVLW  0C
15E52:  MOVWF  FF6
15E54:  MOVLW  1B
15E56:  MOVWF  FF7
15E58:  MOVLW  00
15E5A:  MOVWF  FF8
15E5C:  CLRF   1B
15E5E:  BTFSC  FF2.7
15E60:  BSF    1B.7
15E62:  BCF    FF2.7
15E64:  MOVLB  0
15E66:  CALL   0E4E
15E6A:  BTFSC  1B.7
15E6C:  BSF    FF2.7
....................          reset_cpu(); 
15E6E:  RESET
....................       } 
15E70:  BRA    15E7C
15E72:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
15E74:  DECFSZ x88,W
15E76:  BRA    15E7E
....................          { 
....................             initilizeSleepState(); 
15E78:  MOVLB  0
15E7A:  RCALL  15C9C
15E7C:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
15E7E:  MOVLW  00
15E80:  BTFSC  4D.0
15E82:  MOVLW  01
15E84:  MOVWF  01
15E86:  MOVLB  0
15E88:  GOTO   15E92 (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
15E8C:  RCALL  15C20
....................    initilizeSleepState(); 
15E8E:  RCALL  15C9C
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
15E90:  BRA    15DB0
15E92:  DECFSZ 01,W
15E94:  BRA    15E9A
....................       { 
....................          rtc_alarm = FALSE; 
15E96:  BCF    4D.0
....................          break; 
15E98:  BRA    15EA0
....................       } 
....................  
....................       blip(); 
15E9A:  RCALL  15CBC
....................       blip(); 
15E9C:  RCALL  15CBC
15E9E:  BRA    15E90
....................    } 
15EA0:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0ABC6:  MOVF   FD0,W
0ABC8:  ANDLW  0F
0ABCA:  BTFSS  FD0.4
0ABCC:  MOVLW  00
0ABCE:  BSF    FD0.0
0ABD0:  BSF    FD0.1
0ABD2:  BSF    FD0.4
0ABD4:  BSF    FD8.3
0ABD6:  BSF    FD8.4
0ABD8:  ADDLW  F0
0ABDA:  BTFSC  FD8.0
0ABDC:  BRA    ADAC
0ABDE:  ADDLW  10
0ABE0:  GOTO   ADB0
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0ABE4:  MOVLW  14
0ABE6:  MOVWF  FF6
0ABE8:  MOVLW  1B
0ABEA:  MOVWF  FF7
0ABEC:  MOVLW  00
0ABEE:  MOVWF  FF8
0ABF0:  CLRF   1B
0ABF2:  BTFSC  FF2.7
0ABF4:  BSF    1B.7
0ABF6:  BCF    FF2.7
0ABF8:  CALL   0E4E
0ABFC:  BTFSC  1B.7
0ABFE:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AC00:  MOVLW  01
0AC02:  MOVWF  1E
0AC04:  MOVLW  A7
0AC06:  MOVWF  1D
0AC08:  MOVLW  1C
0AC0A:  MOVWF  FF6
0AC0C:  MOVLW  1B
0AC0E:  MOVWF  FF7
0AC10:  MOVLW  00
0AC12:  MOVWF  FF8
0AC14:  CALL   50BE
....................          record_event(); 
0AC18:  CALL   84DA
....................          recovery(); 
0AC1C:  RCALL  AA58
....................          break; 
0AC1E:  BRA    ADAC
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AC20:  MOVLW  3A
0AC22:  MOVWF  FF6
0AC24:  MOVLW  1B
0AC26:  MOVWF  FF7
0AC28:  MOVLW  00
0AC2A:  MOVWF  FF8
0AC2C:  CLRF   1B
0AC2E:  BTFSC  FF2.7
0AC30:  BSF    1B.7
0AC32:  BCF    FF2.7
0AC34:  CALL   0E4E
0AC38:  BTFSC  1B.7
0AC3A:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AC3C:  MOVLW  01
0AC3E:  MOVWF  1E
0AC40:  MOVLW  A7
0AC42:  MOVWF  1D
0AC44:  MOVLW  42
0AC46:  MOVWF  FF6
0AC48:  MOVLW  1B
0AC4A:  MOVWF  FF7
0AC4C:  MOVLW  00
0AC4E:  MOVWF  FF8
0AC50:  CALL   50BE
....................          record_event(); 
0AC54:  CALL   84DA
....................          recovery(); 
0AC58:  RCALL  AA58
....................          break; 
0AC5A:  BRA    ADAC
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AC5C:  MOVLW  62
0AC5E:  MOVWF  FF6
0AC60:  MOVLW  1B
0AC62:  MOVWF  FF7
0AC64:  MOVLW  00
0AC66:  MOVWF  FF8
0AC68:  CLRF   1B
0AC6A:  BTFSC  FF2.7
0AC6C:  BSF    1B.7
0AC6E:  BCF    FF2.7
0AC70:  CALL   0E4E
0AC74:  BTFSC  1B.7
0AC76:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0AC78:  MOVLW  01
0AC7A:  MOVWF  1E
0AC7C:  MOVLW  A7
0AC7E:  MOVWF  1D
0AC80:  MOVLW  6A
0AC82:  MOVWF  FF6
0AC84:  MOVLW  1B
0AC86:  MOVWF  FF7
0AC88:  MOVLW  00
0AC8A:  MOVWF  FF8
0AC8C:  MOVLW  05
0AC8E:  MOVLB  8
0AC90:  MOVWF  xEB
0AC92:  MOVLB  0
0AC94:  RCALL  AACC
0AC96:  MOVLW  10
0AC98:  MOVWF  FE9
0AC9A:  MOVFF  26,8F7
0AC9E:  MOVFF  25,8F6
0ACA2:  RCALL  AAFE
0ACA4:  MOVLW  72
0ACA6:  MOVWF  FF6
0ACA8:  MOVLW  1B
0ACAA:  MOVWF  FF7
0ACAC:  MOVLW  00
0ACAE:  MOVWF  FF8
0ACB0:  MOVLW  20
0ACB2:  MOVLB  8
0ACB4:  MOVWF  xEB
0ACB6:  MOVLB  0
0ACB8:  RCALL  AACC
....................          record_event(); 
0ACBA:  CALL   84DA
....................          break; 
0ACBE:  BRA    ADAC
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0ACC0:  MOVLW  94
0ACC2:  MOVWF  FF6
0ACC4:  MOVLW  1B
0ACC6:  MOVWF  FF7
0ACC8:  MOVLW  00
0ACCA:  MOVWF  FF8
0ACCC:  CLRF   1B
0ACCE:  BTFSC  FF2.7
0ACD0:  BSF    1B.7
0ACD2:  BCF    FF2.7
0ACD4:  CALL   0E4E
0ACD8:  BTFSC  1B.7
0ACDA:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0ACDC:  MOVLW  01
0ACDE:  MOVWF  1E
0ACE0:  MOVLW  A7
0ACE2:  MOVWF  1D
0ACE4:  MOVLW  9C
0ACE6:  MOVWF  FF6
0ACE8:  MOVLW  1B
0ACEA:  MOVWF  FF7
0ACEC:  MOVLW  00
0ACEE:  MOVWF  FF8
0ACF0:  CALL   50BE
....................          record_event(); 
0ACF4:  CALL   84DA
....................          break; 
0ACF8:  BRA    ADAC
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0ACFA:  MOVLW  C0
0ACFC:  MOVWF  FF6
0ACFE:  MOVLW  1B
0AD00:  MOVWF  FF7
0AD02:  MOVLW  00
0AD04:  MOVWF  FF8
0AD06:  CLRF   1B
0AD08:  BTFSC  FF2.7
0AD0A:  BSF    1B.7
0AD0C:  BCF    FF2.7
0AD0E:  CALL   0E4E
0AD12:  BTFSC  1B.7
0AD14:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AD16:  MOVLW  01
0AD18:  MOVWF  1E
0AD1A:  MOVLW  A7
0AD1C:  MOVWF  1D
0AD1E:  MOVLW  C8
0AD20:  MOVWF  FF6
0AD22:  MOVLW  1B
0AD24:  MOVWF  FF7
0AD26:  MOVLW  00
0AD28:  MOVWF  FF8
0AD2A:  CALL   50BE
....................          record_event(); 
0AD2E:  CALL   84DA
....................          recovery(); 
0AD32:  RCALL  AA58
....................          break; 
0AD34:  BRA    ADAC
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AD36:  MOVLW  E4
0AD38:  MOVWF  FF6
0AD3A:  MOVLW  1B
0AD3C:  MOVWF  FF7
0AD3E:  MOVLW  00
0AD40:  MOVWF  FF8
0AD42:  CLRF   1B
0AD44:  BTFSC  FF2.7
0AD46:  BSF    1B.7
0AD48:  BCF    FF2.7
0AD4A:  CALL   0E4E
0AD4E:  BTFSC  1B.7
0AD50:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AD52:  MOVLW  01
0AD54:  MOVWF  1E
0AD56:  MOVLW  A7
0AD58:  MOVWF  1D
0AD5A:  MOVLW  EC
0AD5C:  MOVWF  FF6
0AD5E:  MOVLW  1B
0AD60:  MOVWF  FF7
0AD62:  MOVLW  00
0AD64:  MOVWF  FF8
0AD66:  CALL   50BE
....................          record_event(); 
0AD6A:  CALL   84DA
....................          recovery(); 
0AD6E:  RCALL  AA58
....................          break; 
0AD70:  BRA    ADAC
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0AD72:  MOVLW  0E
0AD74:  MOVWF  FF6
0AD76:  MOVLW  1C
0AD78:  MOVWF  FF7
0AD7A:  MOVLW  00
0AD7C:  MOVWF  FF8
0AD7E:  CLRF   1B
0AD80:  BTFSC  FF2.7
0AD82:  BSF    1B.7
0AD84:  BCF    FF2.7
0AD86:  CALL   0E4E
0AD8A:  BTFSC  1B.7
0AD8C:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0AD8E:  MOVLW  01
0AD90:  MOVWF  1E
0AD92:  MOVLW  A7
0AD94:  MOVWF  1D
0AD96:  MOVLW  16
0AD98:  MOVWF  FF6
0AD9A:  MOVLW  1C
0AD9C:  MOVWF  FF7
0AD9E:  MOVLW  00
0ADA0:  MOVWF  FF8
0ADA2:  CALL   50BE
....................          record_event(); 
0ADA6:  CALL   84DA
....................          recovery(); 
0ADAA:  RCALL  AA58
....................          break; 
....................       }         
....................    } 
0ADAC:  GOTO   1B8DC (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02AB8:  MOVLW  1E
02ABA:  MOVLB  8
02ABC:  MOVWF  x97
02ABE:  MOVLB  0
02AC0:  RCALL  29CA
02AC2:  MOVFF  02,30
02AC6:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02ACA:  MOVLW  1C
02ACC:  MOVLB  8
02ACE:  MOVWF  x97
02AD0:  MOVLB  0
02AD2:  RCALL  29CA
02AD4:  MOVFF  02,20
02AD8:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02ADC:  MOVLW  16
02ADE:  MOVLB  8
02AE0:  MOVWF  x97
02AE2:  MOVLB  0
02AE4:  RCALL  29CA
02AE6:  MOVFF  02,22
02AEA:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02AEE:  MOVLW  14
02AF0:  MOVLB  8
02AF2:  MOVWF  x97
02AF4:  MOVLB  0
02AF6:  RCALL  29CA
02AF8:  MOVFF  02,24
02AFC:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02B00:  MOVLB  8
02B02:  CLRF   x97
02B04:  MOVLB  0
02B06:  RCALL  29CA
02B08:  MOVFF  02,26
02B0C:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02B10:  MOVLW  18
02B12:  MOVLB  8
02B14:  MOVWF  x97
02B16:  MOVLB  0
02B18:  RCALL  29CA
02B1A:  MOVFF  02,28
02B1E:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02B22:  MOVLW  02
02B24:  MOVLB  8
02B26:  MOVWF  xB7
02B28:  MOVLB  0
02B2A:  RCALL  2A24
02B2C:  CLRF   32
02B2E:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02B32:  MOVLW  28
02B34:  MOVLB  8
02B36:  MOVWF  xB7
02B38:  MOVLB  0
02B3A:  RCALL  2A24
02B3C:  CLRF   34
02B3E:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02B42:  MOVLW  12
02B44:  MOVLB  8
02B46:  MOVWF  x97
02B48:  MOVLB  0
02B4A:  RCALL  29CA
02B4C:  MOVFF  02,36
02B50:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02B54:  MOVLW  3A
02B56:  MOVLB  8
02B58:  MOVWF  x97
02B5A:  MOVLB  0
02B5C:  RCALL  29CA
02B5E:  MOVFF  02,38
02B62:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02B66:  MOVLW  3C
02B68:  MOVLB  8
02B6A:  MOVWF  x97
02B6C:  MOVLB  0
02B6E:  RCALL  29CA
02B70:  MOVFF  02,3E
02B74:  MOVFF  01,3D
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02B78:  MOVLW  3E
02B7A:  MOVLB  8
02B7C:  MOVWF  x97
02B7E:  MOVLB  0
02B80:  RCALL  29CA
02B82:  MOVFF  02,40
02B86:  MOVFF  01,3F
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02B8A:  MOVLW  40
02B8C:  MOVLB  8
02B8E:  MOVWF  x97
02B90:  MOVLB  0
02B92:  RCALL  29CA
02B94:  MOVFF  02,42
02B98:  MOVFF  01,41
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02B9C:  MOVLW  42
02B9E:  MOVLB  8
02BA0:  MOVWF  x97
02BA2:  MOVLB  0
02BA4:  RCALL  29CA
02BA6:  MOVFF  02,44
02BAA:  MOVFF  01,43
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02BAE:  MOVLW  04
02BB0:  MOVLB  8
02BB2:  MOVWF  xB7
02BB4:  MOVLB  0
02BB6:  RCALL  2A24
02BB8:  MOVFF  01,72D
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02BBC:  MOVLB  8
02BBE:  CLRF   x86
02BC0:  MOVLW  44
02BC2:  MOVWF  x85
02BC4:  MOVLB  0
02BC6:  RCALL  2A4A
02BC8:  MOVFF  03,3F8
02BCC:  MOVFF  02,3F7
02BD0:  MOVFF  01,3F6
02BD4:  MOVFF  00,3F5
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02BD8:  MOVLB  8
02BDA:  CLRF   x86
02BDC:  MOVLW  48
02BDE:  MOVWF  x85
02BE0:  MOVLB  0
02BE2:  RCALL  2A4A
02BE4:  MOVFF  03,3FC
02BE8:  MOVFF  02,3FB
02BEC:  MOVFF  01,3FA
02BF0:  MOVFF  00,3F9
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02BF4:  MOVLB  8
02BF6:  CLRF   x86
02BF8:  MOVLW  4C
02BFA:  MOVWF  x85
02BFC:  MOVLB  0
02BFE:  RCALL  2A4A
02C00:  MOVFF  03,400
02C04:  MOVFF  02,3FF
02C08:  MOVFF  01,3FE
02C0C:  MOVFF  00,3FD
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02C10:  MOVLB  8
02C12:  CLRF   x86
02C14:  MOVLW  52
02C16:  MOVWF  x85
02C18:  MOVLB  0
02C1A:  RCALL  2A4A
02C1C:  MOVFF  03,404
02C20:  MOVFF  02,403
02C24:  MOVFF  01,402
02C28:  MOVFF  00,401
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02C2C:  MOVLB  8
02C2E:  CLRF   x86
02C30:  MOVLW  56
02C32:  MOVWF  x85
02C34:  MOVLB  0
02C36:  RCALL  2A4A
02C38:  MOVFF  03,408
02C3C:  MOVFF  02,407
02C40:  MOVFF  01,406
02C44:  MOVFF  00,405
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02C48:  MOVLB  8
02C4A:  CLRF   x86
02C4C:  MOVLW  5A
02C4E:  MOVWF  x85
02C50:  MOVLB  0
02C52:  RCALL  2A4A
02C54:  MOVFF  03,40C
02C58:  MOVFF  02,40B
02C5C:  MOVFF  01,40A
02C60:  MOVFF  00,409
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02C64:  MOVLB  8
02C66:  CLRF   x86
02C68:  MOVLW  5E
02C6A:  MOVWF  x85
02C6C:  MOVLB  0
02C6E:  RCALL  2A4A
02C70:  MOVFF  03,410
02C74:  MOVFF  02,40F
02C78:  MOVFF  01,40E
02C7C:  MOVFF  00,40D
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02C80:  MOVLB  8
02C82:  CLRF   x86
02C84:  MOVLW  62
02C86:  MOVWF  x85
02C88:  MOVLB  0
02C8A:  RCALL  2A4A
02C8C:  MOVFF  03,414
02C90:  MOVFF  02,413
02C94:  MOVFF  01,412
02C98:  MOVFF  00,411
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02C9C:  MOVLW  20
02C9E:  MOVLB  8
02CA0:  MOVWF  x97
02CA2:  MOVLB  0
02CA4:  RCALL  29CA
02CA6:  MOVFF  02,2A
02CAA:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02CAE:  MOVLW  22
02CB0:  MOVLB  8
02CB2:  MOVWF  x97
02CB4:  MOVLB  0
02CB6:  RCALL  29CA
02CB8:  MOVFF  02,2C
02CBC:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02CC0:  MOVLW  24
02CC2:  MOVLB  8
02CC4:  MOVWF  x97
02CC6:  MOVLB  0
02CC8:  RCALL  29CA
02CCA:  MOVFF  02,2E
02CCE:  MOVFF  01,2D
02CD2:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DE70:  MOVLW  1C
0DE72:  MOVLB  8
0DE74:  MOVWF  xEE
0DE76:  CLRF   xF0
0DE78:  CLRF   xEF
0DE7A:  MOVLB  0
0DE7C:  CALL   4FD4
....................    write16(ADDR_SAMPLE,0); 
0DE80:  MOVLW  16
0DE82:  MOVLB  8
0DE84:  MOVWF  xEE
0DE86:  CLRF   xF0
0DE88:  CLRF   xEF
0DE8A:  MOVLB  0
0DE8C:  CALL   4FD4
....................    write16(ADDR_INTERVAL,60); 
0DE90:  MOVLW  14
0DE92:  MOVLB  8
0DE94:  MOVWF  xEE
0DE96:  CLRF   xF0
0DE98:  MOVLW  3C
0DE9A:  MOVWF  xEF
0DE9C:  MOVLB  0
0DE9E:  CALL   4FD4
....................    write16(ADDR_SERIALNO,9999); 
0DEA2:  MOVLB  8
0DEA4:  CLRF   xEE
0DEA6:  MOVLW  27
0DEA8:  MOVWF  xF0
0DEAA:  MOVLW  0F
0DEAC:  MOVWF  xEF
0DEAE:  MOVLB  0
0DEB0:  CALL   4FD4
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DEB4:  MOVLW  18
0DEB6:  MOVLB  8
0DEB8:  MOVWF  xEE
0DEBA:  MOVLW  0D
0DEBC:  MOVWF  xF0
0DEBE:  MOVLW  20
0DEC0:  MOVWF  xEF
0DEC2:  MOVLB  0
0DEC4:  CALL   4FD4
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DEC8:  MOVLW  02
0DECA:  MOVLB  8
0DECC:  MOVWF  x89
0DECE:  MOVLW  01
0DED0:  MOVWF  x8A
0DED2:  MOVLB  0
0DED4:  CALL   3412
....................    write16(ADDR_MACRO_STEP, 0); 
0DED8:  MOVLW  3A
0DEDA:  MOVLB  8
0DEDC:  MOVWF  xEE
0DEDE:  CLRF   xF0
0DEE0:  CLRF   xEF
0DEE2:  MOVLB  0
0DEE4:  CALL   4FD4
....................    write16(ADDR_COM_ERR,3); 
0DEE8:  MOVLW  3C
0DEEA:  MOVLB  8
0DEEC:  MOVWF  xEE
0DEEE:  CLRF   xF0
0DEF0:  MOVLW  03
0DEF2:  MOVWF  xEF
0DEF4:  MOVLB  0
0DEF6:  CALL   4FD4
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DEFA:  MOVLW  04
0DEFC:  MOVLB  8
0DEFE:  MOVWF  x89
0DF00:  MOVLW  0A
0DF02:  MOVWF  x8A
0DF04:  MOVLB  0
0DF06:  CALL   3412
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DF0A:  MOVLB  8
0DF0C:  CLRF   x86
0DF0E:  MOVLW  44
0DF10:  MOVWF  x85
0DF12:  CLRF   x8A
0DF14:  CLRF   x89
0DF16:  CLRF   x88
0DF18:  MOVLW  7F
0DF1A:  MOVWF  x87
0DF1C:  MOVLB  0
0DF1E:  CALL   CD10
....................    write_float(ADDR_CAL_C1,0); 
0DF22:  MOVLB  8
0DF24:  CLRF   x86
0DF26:  MOVLW  48
0DF28:  MOVWF  x85
0DF2A:  CLRF   x8A
0DF2C:  CLRF   x89
0DF2E:  CLRF   x88
0DF30:  CLRF   x87
0DF32:  MOVLB  0
0DF34:  CALL   CD10
....................    write_float(ADDR_CAL_M2,1); 
0DF38:  MOVLB  8
0DF3A:  CLRF   x86
0DF3C:  MOVLW  4C
0DF3E:  MOVWF  x85
0DF40:  CLRF   x8A
0DF42:  CLRF   x89
0DF44:  CLRF   x88
0DF46:  MOVLW  7F
0DF48:  MOVWF  x87
0DF4A:  MOVLB  0
0DF4C:  CALL   CD10
....................    write_float(ADDR_CAL_C2,0); 
0DF50:  MOVLB  8
0DF52:  CLRF   x86
0DF54:  MOVLW  52
0DF56:  MOVWF  x85
0DF58:  CLRF   x8A
0DF5A:  CLRF   x89
0DF5C:  CLRF   x88
0DF5E:  CLRF   x87
0DF60:  MOVLB  0
0DF62:  CALL   CD10
....................    write_float(ADDR_CAL_M3,1); 
0DF66:  MOVLB  8
0DF68:  CLRF   x86
0DF6A:  MOVLW  56
0DF6C:  MOVWF  x85
0DF6E:  CLRF   x8A
0DF70:  CLRF   x89
0DF72:  CLRF   x88
0DF74:  MOVLW  7F
0DF76:  MOVWF  x87
0DF78:  MOVLB  0
0DF7A:  CALL   CD10
....................    write_float(ADDR_CAL_C3,0); 
0DF7E:  MOVLB  8
0DF80:  CLRF   x86
0DF82:  MOVLW  5A
0DF84:  MOVWF  x85
0DF86:  CLRF   x8A
0DF88:  CLRF   x89
0DF8A:  CLRF   x88
0DF8C:  CLRF   x87
0DF8E:  MOVLB  0
0DF90:  CALL   CD10
....................    write_float(ADDR_CAL_M4,1); 
0DF94:  MOVLB  8
0DF96:  CLRF   x86
0DF98:  MOVLW  5E
0DF9A:  MOVWF  x85
0DF9C:  CLRF   x8A
0DF9E:  CLRF   x89
0DFA0:  CLRF   x88
0DFA2:  MOVLW  7F
0DFA4:  MOVWF  x87
0DFA6:  MOVLB  0
0DFA8:  CALL   CD10
....................    write_float(ADDR_CAL_C4,0);  
0DFAC:  MOVLB  8
0DFAE:  CLRF   x86
0DFB0:  MOVLW  62
0DFB2:  MOVWF  x85
0DFB4:  CLRF   x8A
0DFB6:  CLRF   x89
0DFB8:  CLRF   x88
0DFBA:  CLRF   x87
0DFBC:  MOVLB  0
0DFBE:  CALL   CD10
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0DFC2:  MOVLW  40
0DFC4:  MOVLB  8
0DFC6:  MOVWF  xEE
0DFC8:  MOVLW  4E
0DFCA:  MOVWF  xF0
0DFCC:  MOVLW  20
0DFCE:  MOVWF  xEF
0DFD0:  MOVLB  0
0DFD2:  CALL   4FD4
....................    write16(ADDR_D2_TEMP,20000); 
0DFD6:  MOVLW  42
0DFD8:  MOVLB  8
0DFDA:  MOVWF  xEE
0DFDC:  MOVLW  4E
0DFDE:  MOVWF  xF0
0DFE0:  MOVLW  20
0DFE2:  MOVWF  xEF
0DFE4:  MOVLB  0
0DFE6:  CALL   4FD4
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0DFEA:  MOVLW  20
0DFEC:  MOVLB  8
0DFEE:  MOVWF  xEE
0DFF0:  CLRF   xF0
0DFF2:  CLRF   xEF
0DFF4:  MOVLB  0
0DFF6:  CALL   4FD4
....................    write16(ADDR_VOLUME,22500);  
0DFFA:  MOVLW  22
0DFFC:  MOVLB  8
0DFFE:  MOVWF  xEE
0E000:  MOVLW  57
0E002:  MOVWF  xF0
0E004:  MOVLW  E4
0E006:  MOVWF  xEF
0E008:  MOVLB  0
0E00A:  CALL   4FD4
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0E00E:  MOVF   2F,W
0E010:  SUBLW  02
0E012:  BNZ   E018
0E014:  MOVF   30,F
0E016:  BZ    E02C
0E018:  MOVLW  24
0E01A:  MOVLB  8
0E01C:  MOVWF  xEE
0E01E:  CLRF   xF0
0E020:  MOVLW  02
0E022:  MOVWF  xEF
0E024:  MOVLB  0
0E026:  CALL   4FD4
0E02A:  BRA    E03E
....................    else write16(ADDR_PORT,1); 
0E02C:  MOVLW  24
0E02E:  MOVLB  8
0E030:  MOVWF  xEE
0E032:  CLRF   xF0
0E034:  MOVLW  01
0E036:  MOVWF  xEF
0E038:  MOVLB  0
0E03A:  CALL   4FD4
....................     
....................    write16(ADDR_DET_TYPE,1); 
0E03E:  MOVLW  26
0E040:  MOVLB  8
0E042:  MOVWF  xEE
0E044:  CLRF   xF0
0E046:  MOVLW  01
0E048:  MOVWF  xEF
0E04A:  MOVLB  0
0E04C:  CALL   4FD4
....................     
....................    init_nv_vars(); 
0E050:  CALL   2AB8
0E054:  GOTO   E06E (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
127B4:  MOVLW  02
127B6:  MOVWF  FEA
127B8:  MOVLW  47
127BA:  MOVWF  FE9
127BC:  CLRF   00
127BE:  CLRF   02
127C0:  MOVLW  51
127C2:  MOVWF  01
127C4:  CALL   3526
127C8:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F8E0:  MOVLW  03
0F8E2:  MOVWF  FEA
0F8E4:  MOVLW  25
0F8E6:  MOVWF  FE9
0F8E8:  CLRF   00
0F8EA:  CLRF   02
0F8EC:  MOVLW  14
0F8EE:  MOVWF  01
0F8F0:  CALL   3526
0F8F4:  GOTO   F914 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
132EA:  MOVLB  8
132EC:  CLRF   xD4
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
132EE:  CLRF   FEA
132F0:  MOVLW  52
132F2:  MOVWF  FE9
132F4:  CLRF   00
132F6:  CLRF   02
132F8:  MOVLW  14
132FA:  MOVWF  01
132FC:  MOVLB  0
132FE:  CALL   3526
....................  
....................    for(n=0; n<20; n++) { 
13302:  MOVLB  8
13304:  CLRF   xD5
13306:  MOVF   xD5,W
13308:  SUBLW  13
1330A:  BNC   13350
....................         c = data_buffer[string_pos];  
1330C:  CLRF   03
1330E:  MOVLB  2
13310:  MOVF   x98,W
13312:  ADDLW  67
13314:  MOVWF  FE9
13316:  MOVLW  00
13318:  ADDWFC 03,W
1331A:  MOVWF  FEA
1331C:  MOVFF  FEF,8D4
....................         ++string_pos; 
13320:  INCF   x98,F
....................         if (c == '\0') return(1); // found end 
13322:  MOVLB  8
13324:  MOVF   xD4,F
13326:  BNZ   1332E
13328:  MOVLW  01
1332A:  MOVWF  01
1332C:  BRA    13354
....................         if (c == ',')  return(0); // found seperator  
1332E:  MOVF   xD4,W
13330:  SUBLW  2C
13332:  BNZ   1333A
13334:  MOVLW  00
13336:  MOVWF  01
13338:  BRA    13354
....................         sub_string[n] = c; 
1333A:  CLRF   03
1333C:  MOVF   xD5,W
1333E:  ADDLW  52
13340:  MOVWF  FE9
13342:  MOVLW  00
13344:  ADDWFC 03,W
13346:  MOVWF  FEA
13348:  MOVFF  8D4,FEF
1334C:  INCF   xD5,F
1334E:  BRA    13306
....................    } 
....................     
....................    return(2); // failed = bad string 
13350:  MOVLW  02
13352:  MOVWF  01
13354:  MOVLB  0
13356:  GOTO   13680 (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
13594:  MOVLW  3A
13596:  MOVWF  FF6
13598:  MOVLW  1C
1359A:  MOVWF  FF7
1359C:  MOVLW  00
1359E:  MOVWF  FF8
135A0:  MOVLW  03
135A2:  MOVWF  FEA
135A4:  MOVLW  3D
135A6:  MOVWF  FE9
135A8:  CALL   FE26
135AC:  MOVF   01,W
135AE:  BZ    135C2
135B0:  XORLW  01
135B2:  BZ    135E2
135B4:  XORLW  03
135B6:  BZ    13602
135B8:  XORLW  01
135BA:  BZ    13622
135BC:  XORLW  07
135BE:  BZ    13642
135C0:  BRA    13660
....................       case "NO3" : NO3_array[read_i] = result; 
135C2:  BCF    FD8.0
135C4:  MOVLB  3
135C6:  RLCF   x4A,W
135C8:  CLRF   03
135CA:  ADDLW  4B
135CC:  MOVWF  FE9
135CE:  MOVLW  03
135D0:  ADDWFC 03,W
135D2:  MOVWF  FEA
135D4:  MOVFF  8D5,FEC
135D8:  MOVF   FED,F
135DA:  MOVFF  8D4,FEF
....................          break; 
135DE:  MOVLB  0
135E0:  BRA    13660
....................       case "NO2" : NO2_array[read_i] = result; 
135E2:  BCF    FD8.0
135E4:  MOVLB  3
135E6:  RLCF   x4A,W
135E8:  CLRF   03
135EA:  ADDLW  5D
135EC:  MOVWF  FE9
135EE:  MOVLW  03
135F0:  ADDWFC 03,W
135F2:  MOVWF  FEA
135F4:  MOVFF  8D5,FEC
135F8:  MOVF   FED,F
135FA:  MOVFF  8D4,FEF
....................          break;    
135FE:  MOVLB  0
13600:  BRA    13660
....................       case "PO4" : PO4_array[read_i] = result; 
13602:  BCF    FD8.0
13604:  MOVLB  3
13606:  RLCF   x4A,W
13608:  CLRF   03
1360A:  ADDLW  6F
1360C:  MOVWF  FE9
1360E:  MOVLW  03
13610:  ADDWFC 03,W
13612:  MOVWF  FEA
13614:  MOVFF  8D5,FEC
13618:  MOVF   FED,F
1361A:  MOVFF  8D4,FEF
....................          break; 
1361E:  MOVLB  0
13620:  BRA    13660
....................       case "NH4" : NH4_array[read_i] = result; 
13622:  BCF    FD8.0
13624:  MOVLB  3
13626:  RLCF   x4A,W
13628:  CLRF   03
1362A:  ADDLW  81
1362C:  MOVWF  FE9
1362E:  MOVLW  03
13630:  ADDWFC 03,W
13632:  MOVWF  FEA
13634:  MOVFF  8D5,FEC
13638:  MOVF   FED,F
1363A:  MOVFF  8D4,FEF
....................          break; 
1363E:  MOVLB  0
13640:  BRA    13660
....................       case "SiO" : SiO_array[read_i] = result; 
13642:  BCF    FD8.0
13644:  MOVLB  3
13646:  RLCF   x4A,W
13648:  CLRF   03
1364A:  ADDLW  93
1364C:  MOVWF  FE9
1364E:  MOVLW  03
13650:  ADDWFC 03,W
13652:  MOVWF  FEA
13654:  MOVFF  8D5,FEC
13658:  MOVF   FED,F
1365A:  MOVFF  8D4,FEF
....................          break; 
1365E:  MOVLB  0
....................    } 
13660:  GOTO   136D8 (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
13664:  MOVLB  8
13666:  CLRF   xCF
13668:  CLRF   xCE
1366A:  CLRF   xD1
1366C:  CLRF   xD0
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
1366E:  MOVLB  2
13670:  CLRF   x98
....................     
....................    for (n=0; n<11; ++n){ 
13672:  MOVLB  8
13674:  CLRF   xD2
13676:  MOVF   xD2,W
13678:  SUBLW  0A
1367A:  BNC   136CC
....................       parsed = parse_string(); 
1367C:  MOVLB  0
1367E:  BRA    132EA
13680:  MOVFF  01,8D3
....................       if (parsed == 2) return(0); 
13684:  MOVLB  8
13686:  MOVF   xD3,W
13688:  SUBLW  02
1368A:  BNZ   13694
1368C:  MOVLW  00
1368E:  MOVWF  01
13690:  MOVWF  02
13692:  BRA    136E2
....................       if (n==8) result = atol(sub_string); 
13694:  MOVF   xD2,W
13696:  SUBLW  08
13698:  BNZ   136AE
1369A:  CLRF   xD5
1369C:  MOVLW  52
1369E:  MOVWF  xD4
136A0:  MOVLB  0
136A2:  RCALL  133B0
136A4:  MOVFF  02,8CF
136A8:  MOVFF  01,8CE
136AC:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
136AE:  MOVF   xD2,W
136B0:  SUBLW  0A
136B2:  BNZ   136C8
136B4:  CLRF   xD5
136B6:  MOVLW  52
136B8:  MOVWF  xD4
136BA:  MOVLB  0
136BC:  RCALL  133B0
136BE:  MOVFF  02,8D1
136C2:  MOVFF  01,8D0
136C6:  MOVLB  8
136C8:  INCF   xD2,F
136CA:  BRA    13676
....................    } 
....................    load_parsed_data(result); 
136CC:  MOVFF  8CF,8D5
136D0:  MOVFF  8CE,8D4
136D4:  MOVLB  0
136D6:  BRA    13594
....................    return (temp); 
136D8:  MOVLB  8
136DA:  MOVFF  8D0,01
136DE:  MOVFF  8D1,02
136E2:  MOVLB  0
136E4:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D4EC:  CLRF   FEA
0D4EE:  MOVLW  67
0D4F0:  MOVWF  FE9
0D4F2:  CLRF   00
0D4F4:  CLRF   02
0D4F6:  MOVLW  A0
0D4F8:  MOVWF  01
0D4FA:  CALL   3526
0D4FE:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F8F8:  MOVLW  03
0F8FA:  MOVWF  FEA
0F8FC:  MOVLW  3D
0F8FE:  MOVWF  FE9
0F900:  MOVLW  00
0F902:  CALL   02E4
0F906:  TBLRD*-
0F908:  TBLRD*+
0F90A:  MOVF   FF5,W
0F90C:  MOVWF  FEE
0F90E:  IORLW  00
0F910:  BNZ   F908
....................  
....................    clear_flag_str(); 
0F912:  BRA    F8E0
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F914:  MOVLW  08
0F916:  MOVWF  1E
0F918:  MOVLW  ED
0F91A:  MOVWF  1D
0F91C:  MOVLW  10
0F91E:  MOVWF  FE9
0F920:  MOVFF  324,8F7
0F924:  MOVFF  323,8F6
0F928:  CALL   AAFE
....................  
....................    if (macro_flag < 100) { 
0F92C:  MOVLB  3
0F92E:  MOVF   x24,F
0F930:  BNZ   F94A
0F932:  MOVF   x23,W
0F934:  SUBLW  63
0F936:  BNC   F94A
....................       temp_str[3] = '\0'; 
0F938:  MOVLB  8
0F93A:  CLRF   xF0
....................       temp_str[2] = temp_str[1]; 
0F93C:  MOVFF  8EE,8EF
....................       temp_str[1] = temp_str[0]; 
0F940:  MOVFF  8ED,8EE
....................       temp_str[0] = '0'; 
0F944:  MOVLW  30
0F946:  MOVWF  xED
0F948:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F94A:  MOVLB  8
0F94C:  MOVF   xED,W
0F94E:  XORLW  30
0F950:  MOVLB  0
0F952:  BZ    F976
0F954:  XORLW  01
0F956:  BZ    F99C
0F958:  XORLW  03
0F95A:  BZ    F9C2
0F95C:  XORLW  01
0F95E:  BZ    F9E8
0F960:  XORLW  07
0F962:  BZ    FA0E
0F964:  XORLW  01
0F966:  BZ    FA34
0F968:  XORLW  03
0F96A:  BTFSC  FD8.2
0F96C:  BRA    FA5A
0F96E:  XORLW  01
0F970:  BTFSC  FD8.2
0F972:  BRA    FA80
0F974:  BRA    FAA8
....................       case '0' : strcopy(chem,"NO3"); 
0F976:  MOVLW  03
0F978:  MOVWF  FEA
0F97A:  MOVLW  3D
0F97C:  MOVWF  FE9
0F97E:  MOVLW  00
0F980:  CALL   02FC
0F984:  TBLRD*-
0F986:  TBLRD*+
0F988:  MOVF   FF5,W
0F98A:  MOVWF  FEE
0F98C:  IORLW  00
0F98E:  BNZ   F986
....................                  wave_l=543; 
0F990:  MOVLW  02
0F992:  MOVLB  8
0F994:  MOVWF  xEC
0F996:  MOVLW  1F
0F998:  MOVWF  xEB
....................          break; 
0F99A:  BRA    FACC
....................       case '1' : strcopy(chem,"PO4"); 
0F99C:  MOVLW  03
0F99E:  MOVWF  FEA
0F9A0:  MOVLW  3D
0F9A2:  MOVWF  FE9
0F9A4:  MOVLW  00
0F9A6:  CALL   0314
0F9AA:  TBLRD*-
0F9AC:  TBLRD*+
0F9AE:  MOVF   FF5,W
0F9B0:  MOVWF  FEE
0F9B2:  IORLW  00
0F9B4:  BNZ   F9AC
....................                  wave_l=880;       
0F9B6:  MOVLW  03
0F9B8:  MOVLB  8
0F9BA:  MOVWF  xEC
0F9BC:  MOVLW  70
0F9BE:  MOVWF  xEB
....................          break; 
0F9C0:  BRA    FACC
....................       case '2' : strcopy(chem,"NH4"); 
0F9C2:  MOVLW  03
0F9C4:  MOVWF  FEA
0F9C6:  MOVLW  3D
0F9C8:  MOVWF  FE9
0F9CA:  MOVLW  00
0F9CC:  CALL   032C
0F9D0:  TBLRD*-
0F9D2:  TBLRD*+
0F9D4:  MOVF   FF5,W
0F9D6:  MOVWF  FEE
0F9D8:  IORLW  00
0F9DA:  BNZ   F9D2
....................                  wave_l=660;       
0F9DC:  MOVLW  02
0F9DE:  MOVLB  8
0F9E0:  MOVWF  xEC
0F9E2:  MOVLW  94
0F9E4:  MOVWF  xEB
....................          break; 
0F9E6:  BRA    FACC
....................       case '3' : strcopy(chem,"SiO"); 
0F9E8:  MOVLW  03
0F9EA:  MOVWF  FEA
0F9EC:  MOVLW  3D
0F9EE:  MOVWF  FE9
0F9F0:  MOVLW  00
0F9F2:  CALL   0344
0F9F6:  TBLRD*-
0F9F8:  TBLRD*+
0F9FA:  MOVF   FF5,W
0F9FC:  MOVWF  FEE
0F9FE:  IORLW  00
0FA00:  BNZ   F9F8
....................                  wave_l=810;       
0FA02:  MOVLW  03
0FA04:  MOVLB  8
0FA06:  MOVWF  xEC
0FA08:  MOVLW  2A
0FA0A:  MOVWF  xEB
....................          break; 
0FA0C:  BRA    FACC
....................       case '4' : strcopy(chem,"Ure"); 
0FA0E:  MOVLW  03
0FA10:  MOVWF  FEA
0FA12:  MOVLW  3D
0FA14:  MOVWF  FE9
0FA16:  MOVLW  00
0FA18:  CALL   035C
0FA1C:  TBLRD*-
0FA1E:  TBLRD*+
0FA20:  MOVF   FF5,W
0FA22:  MOVWF  FEE
0FA24:  IORLW  00
0FA26:  BNZ   FA1E
....................                  wave_l=525;       
0FA28:  MOVLW  02
0FA2A:  MOVLB  8
0FA2C:  MOVWF  xEC
0FA2E:  MOVLW  0D
0FA30:  MOVWF  xEB
....................          break; 
0FA32:  BRA    FACC
....................       case '5' : strcopy(chem,"NO2"); 
0FA34:  MOVLW  03
0FA36:  MOVWF  FEA
0FA38:  MOVLW  3D
0FA3A:  MOVWF  FE9
0FA3C:  MOVLW  00
0FA3E:  CALL   0374
0FA42:  TBLRD*-
0FA44:  TBLRD*+
0FA46:  MOVF   FF5,W
0FA48:  MOVWF  FEE
0FA4A:  IORLW  00
0FA4C:  BNZ   FA44
....................                  wave_l=543;       
0FA4E:  MOVLW  02
0FA50:  MOVLB  8
0FA52:  MOVWF  xEC
0FA54:  MOVLW  1F
0FA56:  MOVWF  xEB
....................          break; 
0FA58:  BRA    FACC
....................       case '6' : strcopy(chem,"Fe_"); 
0FA5A:  MOVLW  03
0FA5C:  MOVWF  FEA
0FA5E:  MOVLW  3D
0FA60:  MOVWF  FE9
0FA62:  MOVLW  00
0FA64:  CALL   038C
0FA68:  TBLRD*-
0FA6A:  TBLRD*+
0FA6C:  MOVF   FF5,W
0FA6E:  MOVWF  FEE
0FA70:  IORLW  00
0FA72:  BNZ   FA6A
....................                  wave_l=543;       
0FA74:  MOVLW  02
0FA76:  MOVLB  8
0FA78:  MOVWF  xEC
0FA7A:  MOVLW  1F
0FA7C:  MOVWF  xEB
....................          break; 
0FA7E:  BRA    FACC
....................       case '7' : strcopy(chem,"Cl_"); 
0FA80:  MOVLW  03
0FA82:  MOVWF  FEA
0FA84:  MOVLW  3D
0FA86:  MOVWF  FE9
0FA88:  MOVLW  00
0FA8A:  CALL   03A4
0FA8E:  TBLRD*-
0FA90:  TBLRD*+
0FA92:  MOVF   FF5,W
0FA94:  MOVWF  FEE
0FA96:  IORLW  00
0FA98:  BNZ   FA90
....................                  wave_l=560;       
0FA9A:  MOVLW  02
0FA9C:  MOVLB  8
0FA9E:  MOVWF  xEC
0FAA0:  MOVLW  30
0FAA2:  MOVWF  xEB
....................          break; 
0FAA4:  BRA    FACC
0FAA6:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0FAA8:  MOVLW  03
0FAAA:  MOVWF  FEA
0FAAC:  MOVLW  3D
0FAAE:  MOVWF  FE9
0FAB0:  MOVLW  00
0FAB2:  CALL   02E4
0FAB6:  TBLRD*-
0FAB8:  TBLRD*+
0FABA:  MOVF   FF5,W
0FABC:  MOVWF  FEE
0FABE:  IORLW  00
0FAC0:  BNZ   FAB8
....................                  wave_l=999;       
0FAC2:  MOVLW  03
0FAC4:  MOVLB  8
0FAC6:  MOVWF  xEC
0FAC8:  MOVLW  E7
0FACA:  MOVWF  xEB
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0FACC:  MOVF   xEE,W
0FACE:  XORLW  31
0FAD0:  MOVLB  0
0FAD2:  BZ    FAF2
0FAD4:  XORLW  03
0FAD6:  BZ    FB0E
0FAD8:  XORLW  01
0FADA:  BZ    FB2A
0FADC:  XORLW  07
0FADE:  BZ    FB46
0FAE0:  XORLW  01
0FAE2:  BZ    FB62
0FAE4:  XORLW  03
0FAE6:  BZ    FB7E
0FAE8:  XORLW  01
0FAEA:  BZ    FB9A
0FAEC:  XORLW  0F
0FAEE:  BZ    FBB6
0FAF0:  BRA    FBD2
....................       case '1' : strcopy(anal,"Smp"); 
0FAF2:  MOVLW  03
0FAF4:  MOVWF  FEA
0FAF6:  MOVLW  42
0FAF8:  MOVWF  FE9
0FAFA:  MOVLW  00
0FAFC:  CALL   03BC
0FB00:  TBLRD*-
0FB02:  TBLRD*+
0FB04:  MOVF   FF5,W
0FB06:  MOVWF  FEE
0FB08:  IORLW  00
0FB0A:  BNZ   FB02
....................          break; 
0FB0C:  BRA    FBEC
....................       case '2' : strcopy(anal,"Std"); 
0FB0E:  MOVLW  03
0FB10:  MOVWF  FEA
0FB12:  MOVLW  42
0FB14:  MOVWF  FE9
0FB16:  MOVLW  00
0FB18:  CALL   03D4
0FB1C:  TBLRD*-
0FB1E:  TBLRD*+
0FB20:  MOVF   FF5,W
0FB22:  MOVWF  FEE
0FB24:  IORLW  00
0FB26:  BNZ   FB1E
....................          break; 
0FB28:  BRA    FBEC
....................       case '3' : strcopy(anal,"Cmb"); 
0FB2A:  MOVLW  03
0FB2C:  MOVWF  FEA
0FB2E:  MOVLW  42
0FB30:  MOVWF  FE9
0FB32:  MOVLW  00
0FB34:  CALL   03EC
0FB38:  TBLRD*-
0FB3A:  TBLRD*+
0FB3C:  MOVF   FF5,W
0FB3E:  MOVWF  FEE
0FB40:  IORLW  00
0FB42:  BNZ   FB3A
....................          break; 
0FB44:  BRA    FBEC
....................       case '4' : strcopy(anal,"Tst"); 
0FB46:  MOVLW  03
0FB48:  MOVWF  FEA
0FB4A:  MOVLW  42
0FB4C:  MOVWF  FE9
0FB4E:  MOVLW  00
0FB50:  CALL   0404
0FB54:  TBLRD*-
0FB56:  TBLRD*+
0FB58:  MOVF   FF5,W
0FB5A:  MOVWF  FEE
0FB5C:  IORLW  00
0FB5E:  BNZ   FB56
....................          break; 
0FB60:  BRA    FBEC
....................       case '5' : strcopy(anal,"Rbl"); 
0FB62:  MOVLW  03
0FB64:  MOVWF  FEA
0FB66:  MOVLW  42
0FB68:  MOVWF  FE9
0FB6A:  MOVLW  00
0FB6C:  CALL   041C
0FB70:  TBLRD*-
0FB72:  TBLRD*+
0FB74:  MOVF   FF5,W
0FB76:  MOVWF  FEE
0FB78:  IORLW  00
0FB7A:  BNZ   FB72
....................          break; 
0FB7C:  BRA    FBEC
....................       case '6' : strcopy(anal,"Cal"); 
0FB7E:  MOVLW  03
0FB80:  MOVWF  FEA
0FB82:  MOVLW  42
0FB84:  MOVWF  FE9
0FB86:  MOVLW  00
0FB88:  CALL   0434
0FB8C:  TBLRD*-
0FB8E:  TBLRD*+
0FB90:  MOVF   FF5,W
0FB92:  MOVWF  FEE
0FB94:  IORLW  00
0FB96:  BNZ   FB8E
....................          break; 
0FB98:  BRA    FBEC
....................       case '7' : strcopy(anal,"Fls"); 
0FB9A:  MOVLW  03
0FB9C:  MOVWF  FEA
0FB9E:  MOVLW  42
0FBA0:  MOVWF  FE9
0FBA2:  MOVLW  00
0FBA4:  CALL   044C
0FBA8:  TBLRD*-
0FBAA:  TBLRD*+
0FBAC:  MOVF   FF5,W
0FBAE:  MOVWF  FEE
0FBB0:  IORLW  00
0FBB2:  BNZ   FBAA
....................          break; 
0FBB4:  BRA    FBEC
....................       case '8' : strcopy(anal,"Utl"); 
0FBB6:  MOVLW  03
0FBB8:  MOVWF  FEA
0FBBA:  MOVLW  42
0FBBC:  MOVWF  FE9
0FBBE:  MOVLW  00
0FBC0:  CALL   0464
0FBC4:  TBLRD*-
0FBC6:  TBLRD*+
0FBC8:  MOVF   FF5,W
0FBCA:  MOVWF  FEE
0FBCC:  IORLW  00
0FBCE:  BNZ   FBC6
....................          break;     
0FBD0:  BRA    FBEC
....................       default  : strcopy(anal,"XXX"); 
0FBD2:  MOVLW  03
0FBD4:  MOVWF  FEA
0FBD6:  MOVLW  42
0FBD8:  MOVWF  FE9
0FBDA:  MOVLW  00
0FBDC:  CALL   02E4
0FBE0:  TBLRD*-
0FBE2:  TBLRD*+
0FBE4:  MOVF   FF5,W
0FBE6:  MOVWF  FEE
0FBE8:  IORLW  00
0FBEA:  BNZ   FBE2
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0FBEC:  MOVLB  8
0FBEE:  MOVF   xEF,W
0FBF0:  XORLW  31
0FBF2:  MOVLB  0
0FBF4:  BZ    FC1E
0FBF6:  XORLW  03
0FBF8:  BZ    FC3E
0FBFA:  XORLW  01
0FBFC:  BZ    FC60
0FBFE:  XORLW  07
0FC00:  BZ    FC82
0FC02:  XORLW  01
0FC04:  BZ    FCA4
0FC06:  XORLW  03
0FC08:  BZ    FCC6
0FC0A:  XORLW  01
0FC0C:  BTFSC  FD8.2
0FC0E:  BRA    FCE8
0FC10:  XORLW  0F
0FC12:  BTFSC  FD8.2
0FC14:  BRA    FD0A
0FC16:  XORLW  01
0FC18:  BTFSC  FD8.2
0FC1A:  BRA    FD2C
0FC1C:  BRA    FD50
....................       case '1' : strcopy(read_t,"I0s"); 
0FC1E:  MOVLW  03
0FC20:  MOVWF  FEA
0FC22:  MOVLW  46
0FC24:  MOVWF  FE9
0FC26:  MOVLW  00
0FC28:  CALL   047C
0FC2C:  TBLRD*-
0FC2E:  TBLRD*+
0FC30:  MOVF   FF5,W
0FC32:  MOVWF  FEE
0FC34:  IORLW  00
0FC36:  BNZ   FC2E
....................                  read_i = 0; 
0FC38:  MOVLB  3
0FC3A:  CLRF   x4A
....................          break; 
0FC3C:  BRA    FD6E
....................       case '2' : strcopy(read_t,"I1s"); 
0FC3E:  MOVLW  03
0FC40:  MOVWF  FEA
0FC42:  MOVLW  46
0FC44:  MOVWF  FE9
0FC46:  MOVLW  00
0FC48:  CALL   0494
0FC4C:  TBLRD*-
0FC4E:  TBLRD*+
0FC50:  MOVF   FF5,W
0FC52:  MOVWF  FEE
0FC54:  IORLW  00
0FC56:  BNZ   FC4E
....................                  read_i = 1;       
0FC58:  MOVLW  01
0FC5A:  MOVLB  3
0FC5C:  MOVWF  x4A
....................          break; 
0FC5E:  BRA    FD6E
....................       case '3' : strcopy(read_t,"I0t"); 
0FC60:  MOVLW  03
0FC62:  MOVWF  FEA
0FC64:  MOVLW  46
0FC66:  MOVWF  FE9
0FC68:  MOVLW  00
0FC6A:  CALL   04AC
0FC6E:  TBLRD*-
0FC70:  TBLRD*+
0FC72:  MOVF   FF5,W
0FC74:  MOVWF  FEE
0FC76:  IORLW  00
0FC78:  BNZ   FC70
....................                  read_i = 2;       
0FC7A:  MOVLW  02
0FC7C:  MOVLB  3
0FC7E:  MOVWF  x4A
....................          break; 
0FC80:  BRA    FD6E
....................       case '4' : strcopy(read_t,"I1t"); 
0FC82:  MOVLW  03
0FC84:  MOVWF  FEA
0FC86:  MOVLW  46
0FC88:  MOVWF  FE9
0FC8A:  MOVLW  00
0FC8C:  CALL   04C4
0FC90:  TBLRD*-
0FC92:  TBLRD*+
0FC94:  MOVF   FF5,W
0FC96:  MOVWF  FEE
0FC98:  IORLW  00
0FC9A:  BNZ   FC92
....................                  read_i = 3;       
0FC9C:  MOVLW  03
0FC9E:  MOVLB  3
0FCA0:  MOVWF  x4A
....................          break; 
0FCA2:  BRA    FD6E
....................       case '5' : strcopy(read_t,"I0r"); 
0FCA4:  MOVLW  03
0FCA6:  MOVWF  FEA
0FCA8:  MOVLW  46
0FCAA:  MOVWF  FE9
0FCAC:  MOVLW  00
0FCAE:  CALL   04DC
0FCB2:  TBLRD*-
0FCB4:  TBLRD*+
0FCB6:  MOVF   FF5,W
0FCB8:  MOVWF  FEE
0FCBA:  IORLW  00
0FCBC:  BNZ   FCB4
....................                  read_i = 4;       
0FCBE:  MOVLW  04
0FCC0:  MOVLB  3
0FCC2:  MOVWF  x4A
....................          break; 
0FCC4:  BRA    FD6E
....................       case '6' : strcopy(read_t,"I1r"); 
0FCC6:  MOVLW  03
0FCC8:  MOVWF  FEA
0FCCA:  MOVLW  46
0FCCC:  MOVWF  FE9
0FCCE:  MOVLW  00
0FCD0:  CALL   04F4
0FCD4:  TBLRD*-
0FCD6:  TBLRD*+
0FCD8:  MOVF   FF5,W
0FCDA:  MOVWF  FEE
0FCDC:  IORLW  00
0FCDE:  BNZ   FCD6
....................                  read_i = 5;       
0FCE0:  MOVLW  05
0FCE2:  MOVLB  3
0FCE4:  MOVWF  x4A
....................          break; 
0FCE6:  BRA    FD6E
....................       case '7' : strcopy(read_t,"I0u"); 
0FCE8:  MOVLW  03
0FCEA:  MOVWF  FEA
0FCEC:  MOVLW  46
0FCEE:  MOVWF  FE9
0FCF0:  MOVLW  00
0FCF2:  CALL   050C
0FCF6:  TBLRD*-
0FCF8:  TBLRD*+
0FCFA:  MOVF   FF5,W
0FCFC:  MOVWF  FEE
0FCFE:  IORLW  00
0FD00:  BNZ   FCF8
....................                  read_i = 6;       
0FD02:  MOVLW  06
0FD04:  MOVLB  3
0FD06:  MOVWF  x4A
....................          break; 
0FD08:  BRA    FD6E
....................       case '8' : strcopy(read_t,"I1u"); 
0FD0A:  MOVLW  03
0FD0C:  MOVWF  FEA
0FD0E:  MOVLW  46
0FD10:  MOVWF  FE9
0FD12:  MOVLW  00
0FD14:  CALL   0524
0FD18:  TBLRD*-
0FD1A:  TBLRD*+
0FD1C:  MOVF   FF5,W
0FD1E:  MOVWF  FEE
0FD20:  IORLW  00
0FD22:  BNZ   FD1A
....................                  read_i = 7;       
0FD24:  MOVLW  07
0FD26:  MOVLB  3
0FD28:  MOVWF  x4A
....................          break; 
0FD2A:  BRA    FD6E
....................       case '9' : strcopy(read_t,"Chk"); 
0FD2C:  MOVLW  03
0FD2E:  MOVWF  FEA
0FD30:  MOVLW  46
0FD32:  MOVWF  FE9
0FD34:  MOVLW  00
0FD36:  CALL   053C
0FD3A:  TBLRD*-
0FD3C:  TBLRD*+
0FD3E:  MOVF   FF5,W
0FD40:  MOVWF  FEE
0FD42:  IORLW  00
0FD44:  BNZ   FD3C
....................                  read_i = 8;       
0FD46:  MOVLW  08
0FD48:  MOVLB  3
0FD4A:  MOVWF  x4A
....................          break;        
0FD4C:  BRA    FD6E
0FD4E:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FD50:  MOVLW  03
0FD52:  MOVWF  FEA
0FD54:  MOVLW  46
0FD56:  MOVWF  FE9
0FD58:  MOVLW  00
0FD5A:  CALL   0554
0FD5E:  TBLRD*-
0FD60:  TBLRD*+
0FD62:  MOVF   FF5,W
0FD64:  MOVWF  FEE
0FD66:  IORLW  00
0FD68:  BNZ   FD60
....................                  read_i = 0;       
0FD6A:  MOVLB  3
0FD6C:  CLRF   x4A
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FD6E:  MOVLW  03
0FD70:  MOVLB  8
0FD72:  MOVWF  xF9
0FD74:  MOVLW  25
0FD76:  MOVWF  xF8
0FD78:  MOVLW  03
0FD7A:  MOVWF  xFB
0FD7C:  MOVLW  3D
0FD7E:  MOVWF  xFA
0FD80:  MOVLB  0
0FD82:  CALL   54DE
....................    strcat(flag_str, (char *)","); 
0FD86:  MOVLW  2C
0FD88:  MOVLB  8
0FD8A:  MOVWF  xF4
0FD8C:  CLRF   xF5
0FD8E:  MOVLW  03
0FD90:  MOVWF  xF9
0FD92:  MOVLW  25
0FD94:  MOVWF  xF8
0FD96:  MOVLW  08
0FD98:  MOVWF  xFB
0FD9A:  MOVLW  F4
0FD9C:  MOVWF  xFA
0FD9E:  MOVLB  0
0FDA0:  CALL   54DE
....................    strcat(flag_str, anal); 
0FDA4:  MOVLW  03
0FDA6:  MOVLB  8
0FDA8:  MOVWF  xF9
0FDAA:  MOVLW  25
0FDAC:  MOVWF  xF8
0FDAE:  MOVLW  03
0FDB0:  MOVWF  xFB
0FDB2:  MOVLW  42
0FDB4:  MOVWF  xFA
0FDB6:  MOVLB  0
0FDB8:  CALL   54DE
....................    strcat(flag_str, (char *)","); 
0FDBC:  MOVLW  2C
0FDBE:  MOVLB  8
0FDC0:  MOVWF  xF4
0FDC2:  CLRF   xF5
0FDC4:  MOVLW  03
0FDC6:  MOVWF  xF9
0FDC8:  MOVLW  25
0FDCA:  MOVWF  xF8
0FDCC:  MOVLW  08
0FDCE:  MOVWF  xFB
0FDD0:  MOVLW  F4
0FDD2:  MOVWF  xFA
0FDD4:  MOVLB  0
0FDD6:  CALL   54DE
....................    strcat(flag_str, read_t);   
0FDDA:  MOVLW  03
0FDDC:  MOVLB  8
0FDDE:  MOVWF  xF9
0FDE0:  MOVLW  25
0FDE2:  MOVWF  xF8
0FDE4:  MOVLW  03
0FDE6:  MOVWF  xFB
0FDE8:  MOVLW  46
0FDEA:  MOVWF  xFA
0FDEC:  MOVLB  0
0FDEE:  CALL   54DE
....................     
....................    return wave_l; 
0FDF2:  MOVLB  8
0FDF4:  MOVFF  8EB,01
0FDF8:  MOVFF  8EC,02
0FDFC:  MOVLB  0
0FDFE:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F3C6:  MOVF   47,W
0F3C8:  SUBLW  4B
0F3CA:  BTFSC  FD8.2
0F3CC:  MOVFF  48,2D6
....................    if (cmd=='L') detector_li = arg; 
0F3D0:  MOVF   47,W
0F3D2:  SUBLW  4C
0F3D4:  BNZ   F3DE
0F3D6:  MOVFF  49,2D8
0F3DA:  MOVFF  48,2D7
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F3DE:  MOVF   1F,W
0F3E0:  SUBLW  04
0F3E2:  BNZ   F4AC
0F3E4:  MOVF   20,F
0F3E6:  BNZ   F4AC
0F3E8:  MOVLW  50
0F3EA:  MOVWF  FF6
0F3EC:  MOVLW  1C
0F3EE:  MOVWF  FF7
0F3F0:  MOVLW  00
0F3F2:  MOVWF  FF8
0F3F4:  CLRF   1B
0F3F6:  BTFSC  FF2.7
0F3F8:  BSF    1B.7
0F3FA:  BCF    FF2.7
0F3FC:  MOVLW  06
0F3FE:  MOVLB  A
0F400:  MOVWF  x40
0F402:  MOVLB  0
0F404:  CALL   1024
0F408:  BTFSC  1B.7
0F40A:  BSF    FF2.7
0F40C:  CLRF   1B
0F40E:  BTFSC  FF2.7
0F410:  BSF    1B.7
0F412:  BCF    FF2.7
0F414:  MOVFF  2D5,A40
0F418:  MOVLW  1B
0F41A:  MOVLB  A
0F41C:  MOVWF  x41
0F41E:  MOVLB  0
0F420:  CALL   0FA6
0F424:  BTFSC  1B.7
0F426:  BSF    FF2.7
0F428:  MOVLW  5D
0F42A:  BTFSS  F9E.4
0F42C:  BRA    F42A
0F42E:  MOVWF  FAD
0F430:  MOVLW  5B
0F432:  BTFSS  F9E.4
0F434:  BRA    F432
0F436:  MOVWF  FAD
0F438:  MOVF   47,W
0F43A:  BTFSS  F9E.4
0F43C:  BRA    F43A
0F43E:  MOVWF  FAD
0F440:  MOVLW  5C
0F442:  MOVWF  FF6
0F444:  MOVLW  1C
0F446:  MOVWF  FF7
0F448:  MOVLW  00
0F44A:  MOVWF  FF8
0F44C:  CLRF   1B
0F44E:  BTFSC  FF2.7
0F450:  BSF    1B.7
0F452:  BCF    FF2.7
0F454:  MOVLW  05
0F456:  MOVLB  A
0F458:  MOVWF  x40
0F45A:  MOVLB  0
0F45C:  CALL   1024
0F460:  BTFSC  1B.7
0F462:  BSF    FF2.7
0F464:  MOVLW  41
0F466:  MOVWF  FE9
0F468:  CLRF   1B
0F46A:  BTFSC  FF2.7
0F46C:  BSF    1B.7
0F46E:  BCF    FF2.7
0F470:  MOVFF  4B,A43
0F474:  MOVFF  4A,A42
0F478:  MOVFF  49,A41
0F47C:  MOVFF  48,A40
0F480:  CALL   10EA
0F484:  BTFSC  1B.7
0F486:  BSF    FF2.7
0F488:  MOVLW  64
0F48A:  MOVWF  FF6
0F48C:  MOVLW  1C
0F48E:  MOVWF  FF7
0F490:  MOVLW  00
0F492:  MOVWF  FF8
0F494:  CLRF   1B
0F496:  BTFSC  FF2.7
0F498:  BSF    1B.7
0F49A:  BCF    FF2.7
0F49C:  MOVLW  03
0F49E:  MOVLB  A
0F4A0:  MOVWF  x40
0F4A2:  MOVLB  0
0F4A4:  CALL   1024
0F4A8:  BTFSC  1B.7
0F4AA:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F4AC:  CALL   DA3C
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F4B0:  MOVLW  2F
0F4B2:  BTFSS  FA4.4
0F4B4:  BRA    F4B2
0F4B6:  MOVLB  F
0F4B8:  MOVWF  x1C
0F4BA:  MOVFF  2D5,8F3
0F4BE:  MOVLW  1B
0F4C0:  MOVLB  8
0F4C2:  MOVWF  xF4
0F4C4:  MOVLB  0
0F4C6:  CALL   DA84
0F4CA:  MOVF   47,W
0F4CC:  BTFSS  FA4.4
0F4CE:  BRA    F4CC
0F4D0:  MOVLB  F
0F4D2:  MOVWF  x1C
0F4D4:  MOVLW  41
0F4D6:  MOVWF  FE9
0F4D8:  MOVFF  4B,8F6
0F4DC:  MOVFF  4A,8F5
0F4E0:  MOVFF  49,8F4
0F4E4:  MOVFF  48,8F3
0F4E8:  MOVLB  0
0F4EA:  BRA    F2E6
0F4EC:  MOVLW  0D
0F4EE:  BTFSS  FA4.4
0F4F0:  BRA    F4EE
0F4F2:  MOVLB  F
0F4F4:  MOVWF  x1C
0F4F6:  MOVLW  0A
0F4F8:  BTFSS  FA4.4
0F4FA:  BRA    F4F8
0F4FC:  MOVWF  x1C
....................    multidrop_off(); 
0F4FE:  MOVLB  0
0F500:  CALL   DB28
0F504:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12E0A:  MOVLB  8
12E0C:  CLRF   xEC
12E0E:  BCF    xED.0
12E10:  CLRF   xEE
12E12:  CLRF   xF2
12E14:  CLRF   xF1
12E16:  CLRF   xF0
12E18:  CLRF   xEF
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12E1A:  MOVLW  02
12E1C:  MOVWF  FEA
12E1E:  MOVLW  47
12E20:  MOVWF  FE9
12E22:  CLRF   00
12E24:  CLRF   02
12E26:  MOVLW  51
12E28:  MOVWF  01
12E2A:  MOVLB  0
12E2C:  CALL   3526
....................  
....................    det_cmd(); 
12E30:  CALL   F3C6
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12E34:  CALL   5554
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12E38:  MOVLB  8
12E3A:  MOVF   xEE,W
12E3C:  SUBLW  02
12E3E:  BZ    12ED2
12E40:  MOVF   xEE,W
12E42:  SUBLW  03
12E44:  BZ    12ED2
12E46:  MOVF   xEC,W
12E48:  SUBLW  50
12E4A:  BNC   12ED2
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12E4C:  BTFSS  FA4.5
12E4E:  BRA    12E86
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12E50:  MOVLB  0
12E52:  RCALL  12DF0
12E54:  MOVFF  01,8EB
....................  
....................          if(startCharacterRcvd) 
12E58:  MOVLB  8
12E5A:  BTFSS  xED.0
12E5C:  BRA    12E7E
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12E5E:  MOVF   xEC,W
12E60:  INCF   xEC,F
12E62:  CLRF   03
12E64:  ADDLW  47
12E66:  MOVWF  FE9
12E68:  MOVLW  02
12E6A:  ADDWFC 03,W
12E6C:  MOVWF  FEA
12E6E:  MOVFF  8EB,FEF
....................             if (CARRIAGE_RET == c) 
12E72:  MOVF   xEB,W
12E74:  SUBLW  0D
12E76:  BNZ   12E7C
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12E78:  MOVLW  02
12E7A:  MOVWF  xEE
....................             } 
....................          } 
12E7C:  BRA    12E86
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12E7E:  MOVF   xEB,W
12E80:  SUBLW  40
12E82:  BNZ   12E86
....................             { 
....................                startCharacterRcvd = TRUE; 
12E84:  BSF    xED.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12E86:  MOVLW  35
12E88:  MOVWF  00
12E8A:  DECFSZ 00,F
12E8C:  BRA    12E8A
....................       if (tenMicroSecDelayCounter++ > 500000) 
12E8E:  MOVFF  8F2,8F6
12E92:  MOVFF  8F1,8F5
12E96:  MOVFF  8F0,8F4
12E9A:  MOVFF  8EF,8F3
12E9E:  MOVLW  01
12EA0:  ADDWF  xEF,F
12EA2:  BTFSC  FD8.0
12EA4:  INCF   xF0,F
12EA6:  BTFSC  FD8.2
12EA8:  INCF   xF1,F
12EAA:  BTFSC  FD8.2
12EAC:  INCF   xF2,F
12EAE:  MOVF   xF6,F
12EB0:  BNZ   12ECC
12EB2:  MOVF   xF5,W
12EB4:  SUBLW  06
12EB6:  BC    12ED0
12EB8:  XORLW  FF
12EBA:  BNZ   12ECC
12EBC:  MOVF   xF4,W
12EBE:  SUBLW  A0
12EC0:  BC    12ED0
12EC2:  XORLW  FF
12EC4:  BNZ   12ECC
12EC6:  MOVF   xF3,W
12EC8:  SUBLW  20
12ECA:  BC    12ED0
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12ECC:  MOVLW  03
12ECE:  MOVWF  xEE
....................       } 
12ED0:  BRA    12E3A
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12ED2:  MOVF   xEC,W
12ED4:  SUBLW  50
12ED6:  BC    12EE8
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12ED8:  MOVF   xEE,W
12EDA:  SUBLW  03
12EDC:  BZ    12EE8
12EDE:  MOVF   xEE,W
12EE0:  SUBLW  02
12EE2:  BZ    12EE8
....................       { 
....................          rcvDataType = SOME_DATA; 
12EE4:  MOVLW  01
12EE6:  MOVWF  xEE
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12EE8:  MOVLB  0
12EEA:  CALL   5574
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12EEE:  MOVLB  8
12EF0:  MOVFF  8EE,01
12EF4:  MOVLB  0
12EF6:  GOTO   1306E (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
0FF2E:  MOVF   1F,F
0FF30:  BNZ   FF50
0FF32:  MOVF   20,F
0FF34:  BNZ   FF50
0FF36:  MOVLB  8
0FF38:  DECFSZ xEC,W
0FF3A:  BRA    FF3E
0FF3C:  BRA    FF42
0FF3E:  MOVLB  0
0FF40:  BRA    FF50
0FF42:  CLRF   FEA
0FF44:  MOVLW  67
0FF46:  MOVWF  FE9
0FF48:  MOVLB  0
0FF4A:  CALL   7996
0FF4E:  BRA    FF64
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
0FF50:  MOVF   20,F
0FF52:  BNZ   FF5A
0FF54:  MOVF   1F,W
0FF56:  SUBLW  03
0FF58:  BC    FF64
0FF5A:  CLRF   FEA
0FF5C:  MOVLW  67
0FF5E:  MOVWF  FE9
0FF60:  CALL   7996
....................  
....................    if (store==TRUE && sd_status==0) { 
0FF64:  MOVLB  8
0FF66:  DECFSZ xEB,W
0FF68:  BRA    FFC8
0FF6A:  MOVLB  2
0FF6C:  MOVF   xDC,F
0FF6E:  BTFSC  FD8.2
0FF70:  BRA    FF76
0FF72:  MOVLB  8
0FF74:  BRA    FFC8
....................        
....................       buffer_select = 0; 
0FF76:  MOVLB  0
0FF78:  CLRF   x66
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FF7A:  MOVLB  8
0FF7C:  CLRF   xED
0FF7E:  MOVLB  0
0FF80:  CALL   5586
....................          append_data(file_ptr_raw_all); 
0FF84:  MOVLW  02
0FF86:  MOVLB  8
0FF88:  MOVWF  xEE
0FF8A:  MOVLW  DD
0FF8C:  MOVWF  xED
0FF8E:  MOVLB  0
0FF90:  CALL   82F8
....................       heartbeat(TRUE); 
0FF94:  MOVLW  01
0FF96:  MOVLB  8
0FF98:  MOVWF  xED
0FF9A:  MOVLB  0
0FF9C:  CALL   5586
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FFA0:  MOVLB  8
0FFA2:  CLRF   xED
0FFA4:  MOVLB  0
0FFA6:  CALL   5586
....................          append_data(file_ptr_raw_new); 
0FFAA:  MOVLW  02
0FFAC:  MOVLB  8
0FFAE:  MOVWF  xEE
0FFB0:  MOVLW  EB
0FFB2:  MOVWF  xED
0FFB4:  MOVLB  0
0FFB6:  CALL   82F8
....................       heartbeat(TRUE); 
0FFBA:  MOVLW  01
0FFBC:  MOVLB  8
0FFBE:  MOVWF  xED
0FFC0:  MOVLB  0
0FFC2:  CALL   5586
0FFC6:  MOVLB  8
....................    } 
0FFC8:  MOVLB  0
0FFCA:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12F06:  CLRF   xE5
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12EFA:  MOVLW  0D
12EFC:  MOVLB  8
12EFE:  MOVWF  xCE
12F00:  MOVLW  0A
12F02:  MOVWF  xCF
12F04:  CLRF   xD0
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12F08:  MOVLB  0
12F0A:  RCALL  127B4
....................    clear_data_buffer(); 
12F0C:  CALL   D4EC
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12F10:  MOVLW  08
12F12:  MOVWF  FEA
12F14:  MOVLW  D1
12F16:  MOVWF  FE9
12F18:  CLRF   00
12F1A:  CLRF   02
12F1C:  MOVLW  14
12F1E:  MOVWF  01
12F20:  CALL   3526
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12F24:  MOVLW  01
12F26:  MOVWF  FEA
12F28:  MOVLW  A7
12F2A:  MOVWF  FE9
12F2C:  CLRF   00
12F2E:  CLRF   02
12F30:  MOVLW  A0
12F32:  MOVWF  01
12F34:  CALL   3526
....................  
....................    time_stamp(); 
12F38:  CALL   541A
....................    strcpy(data_buffer, time_stmp_str); 
12F3C:  CLRF   FEA
12F3E:  MOVLW  67
12F40:  MOVWF  FE9
12F42:  MOVLW  02
12F44:  MOVWF  FE2
12F46:  MOVLW  99
12F48:  MOVWF  FE1
12F4A:  MOVF   FE7,F
12F4C:  MOVFF  FE6,FEE
12F50:  BNZ   12F4A
....................    strcat(data_buffer, (char *)","); 
12F52:  MOVLW  2C
12F54:  MOVLB  8
12F56:  MOVWF  xE9
12F58:  CLRF   xEA
12F5A:  CLRF   xF9
12F5C:  MOVLW  67
12F5E:  MOVWF  xF8
12F60:  MOVLW  08
12F62:  MOVWF  xFB
12F64:  MOVLW  E9
12F66:  MOVWF  xFA
12F68:  MOVLB  0
12F6A:  CALL   54DE
....................  
....................    flag_mod=fmod(macro_flag,10); 
12F6E:  MOVFF  324,918
12F72:  MOVFF  323,917
12F76:  CALL   C8BA
12F7A:  MOVFF  03,8EE
12F7E:  MOVFF  02,8ED
12F82:  MOVFF  01,8EC
12F86:  MOVFF  00,8EB
12F8A:  MOVFF  03,8F2
12F8E:  MOVFF  02,8F1
12F92:  MOVFF  01,8F0
12F96:  MOVFF  00,8EF
12F9A:  MOVLB  8
12F9C:  CLRF   xF6
12F9E:  CLRF   xF5
12FA0:  MOVLW  20
12FA2:  MOVWF  xF4
12FA4:  MOVLW  82
12FA6:  MOVWF  xF3
12FA8:  MOVLB  0
12FAA:  BRA    12BB0
12FAC:  MOVFF  03,916
12FB0:  MOVFF  02,915
12FB4:  MOVFF  01,914
12FB8:  MOVFF  00,913
12FBC:  RCALL  127CA
12FBE:  MOVFF  01,8E8
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
12FC2:  MOVLB  8
12FC4:  DECFSZ xE8,W
12FC6:  BRA    12FCA
12FC8:  BRA    12FD0
12FCA:  MOVF   xE8,W
12FCC:  SUBLW  03
12FCE:  BNZ   12FEE
....................    { 
....................       clear_proc_time_stmp_str(); 
12FD0:  MOVLB  0
12FD2:  BRA    12D18
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
12FD4:  MOVLW  02
12FD6:  MOVWF  FEA
12FD8:  MOVLW  B7
12FDA:  MOVWF  FE9
12FDC:  MOVLW  02
12FDE:  MOVWF  FE2
12FE0:  MOVLW  99
12FE2:  MOVWF  FE1
12FE4:  MOVF   FE7,F
12FE6:  MOVFF  FE6,FEE
12FEA:  BNZ   12FE4
12FEC:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
12FEE:  MOVLB  0
12FF0:  CALL   F8F8
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12FF4:  MOVLB  8
12FF6:  CLRF   xEC
12FF8:  MOVLW  67
12FFA:  MOVWF  xEB
12FFC:  MOVLB  0
12FFE:  RCALL  12D30
13000:  MOVFF  02,03
13004:  MOVF   01,W
13006:  XORLW  FF
13008:  ADDLW  A1
1300A:  MOVLB  8
1300C:  MOVWF  xEB
1300E:  MOVLW  00
13010:  SUBFWB 02,W
13012:  MOVWF  xEC
13014:  MOVLW  01
13016:  SUBWF  xEB,F
13018:  MOVLW  00
1301A:  SUBWFB xEC,F
1301C:  CLRF   xEE
1301E:  MOVLW  67
13020:  MOVWF  xED
13022:  MOVLW  03
13024:  MOVWF  xF0
13026:  MOVLW  25
13028:  MOVWF  xEF
1302A:  MOVFF  8EC,8F2
1302E:  MOVFF  8EB,8F1
13032:  MOVLB  0
13034:  RCALL  12D6C
....................    strcat(data_buffer, (char *)","); 
13036:  MOVLW  2C
13038:  MOVLB  8
1303A:  MOVWF  xE9
1303C:  CLRF   xEA
1303E:  CLRF   xF9
13040:  MOVLW  67
13042:  MOVWF  xF8
13044:  MOVLW  08
13046:  MOVWF  xFB
13048:  MOVLW  E9
1304A:  MOVWF  xFA
1304C:  MOVLB  0
1304E:  CALL   54DE
....................     
....................    cmd = 'S'; 
13052:  MOVLW  53
13054:  MOVWF  47
....................    arg = 1; 
13056:  CLRF   4B
13058:  CLRF   4A
1305A:  CLRF   49
1305C:  MOVLW  01
1305E:  MOVWF  48
....................  
....................    for(i = 0; i < 6; i++) 
13060:  MOVLB  8
13062:  CLRF   xE6
13064:  MOVF   xE6,W
13066:  SUBLW  05
13068:  BNC   13080
....................    { 
....................       rcvdData = get_slave_data(); 
1306A:  MOVLB  0
1306C:  BRA    12E0A
1306E:  MOVFF  01,8E5
....................       if (DATA_COMPLETE == rcvdData) 
13072:  MOVLB  8
13074:  MOVF   xE5,W
13076:  SUBLW  02
13078:  BNZ   1307C
....................       { 
....................          break; 
1307A:  BRA    13080
....................       } 
1307C:  INCF   xE6,F
1307E:  BRA    13064
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13080:  CLRF   xEC
13082:  MOVLW  67
13084:  MOVWF  xEB
13086:  MOVLB  0
13088:  RCALL  12D30
1308A:  MOVFF  02,03
1308E:  MOVF   01,W
13090:  XORLW  FF
13092:  ADDLW  A1
13094:  MOVLB  8
13096:  MOVWF  xEB
13098:  MOVLW  00
1309A:  SUBFWB 02,W
1309C:  MOVWF  xEC
1309E:  MOVLW  01
130A0:  SUBWF  xEB,F
130A2:  MOVLW  00
130A4:  SUBWFB xEC,F
130A6:  CLRF   xEE
130A8:  MOVLW  67
130AA:  MOVWF  xED
130AC:  MOVLW  02
130AE:  MOVWF  xF0
130B0:  MOVLW  47
130B2:  MOVWF  xEF
130B4:  MOVFF  8EC,8F2
130B8:  MOVFF  8EB,8F1
130BC:  MOVLB  0
130BE:  RCALL  12D6C
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
130C0:  MOVLW  02
130C2:  MOVLB  8
130C4:  MOVWF  xEC
130C6:  MOVLW  47
130C8:  MOVWF  xEB
130CA:  MOVLB  0
130CC:  RCALL  12D30
130CE:  MOVFF  01,8E7
....................    if (rec_len > 0 && rec_len < 12) 
130D2:  MOVLB  8
130D4:  MOVF   xE7,F
130D6:  BZ    130E4
130D8:  MOVF   xE7,W
130DA:  SUBLW  0B
130DC:  BNC   130E4
....................    { 
....................       rcvdData = SHORT_DATA; 
130DE:  MOVLW  04
130E0:  MOVWF  xE5
....................    } 
130E2:  BRA    130EE
....................    else 
....................    { 
....................       if (rec_len > 30) 
130E4:  MOVF   xE7,W
130E6:  SUBLW  1E
130E8:  BC    130EE
....................       { 
....................          rcvdData = LONG_DATA; 
130EA:  MOVLW  05
130EC:  MOVWF  xE5
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
130EE:  MOVLW  02
130F0:  SUBWF  xE5,W
130F2:  ADDLW  FC
130F4:  BC    13160
130F6:  ADDLW  04
130F8:  MOVLB  0
130FA:  GOTO   132C2
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
130FE:  MOVLB  8
13100:  BRA    13160
13102:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
13104:  MOVLW  08
13106:  MOVWF  1E
13108:  MOVLW  D1
1310A:  MOVWF  1D
1310C:  MOVLW  68
1310E:  MOVWF  FF6
13110:  MOVLW  1C
13112:  MOVWF  FF7
13114:  MOVLW  00
13116:  MOVWF  FF8
13118:  CALL   50BE
....................          break; 
1311C:  MOVLB  8
1311E:  BRA    13160
13120:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
13122:  MOVLW  08
13124:  MOVWF  1E
13126:  MOVLW  D1
13128:  MOVWF  1D
1312A:  MOVLW  72
1312C:  MOVWF  FF6
1312E:  MOVLW  1C
13130:  MOVWF  FF7
13132:  MOVLW  00
13134:  MOVWF  FF8
13136:  CALL   50BE
....................          break; 
1313A:  MOVLB  8
1313C:  BRA    13160
1313E:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
13140:  MOVLW  08
13142:  MOVWF  1E
13144:  MOVLW  D1
13146:  MOVWF  1D
13148:  MOVLW  82
1314A:  MOVWF  FF6
1314C:  MOVLW  1C
1314E:  MOVWF  FF7
13150:  MOVLW  00
13152:  MOVWF  FF8
13154:  CALL   50BE
....................          break; 
13158:  MOVLB  8
1315A:  BRA    13160
1315C:  MOVLB  0
1315E:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13160:  CLRF   xEC
13162:  MOVLW  67
13164:  MOVWF  xEB
13166:  MOVLB  0
13168:  RCALL  12D30
1316A:  MOVFF  02,03
1316E:  MOVF   01,W
13170:  XORLW  FF
13172:  ADDLW  A1
13174:  MOVLB  8
13176:  MOVWF  xEB
13178:  MOVLW  00
1317A:  SUBFWB 02,W
1317C:  MOVWF  xEC
1317E:  MOVLW  01
13180:  SUBWF  xEB,F
13182:  MOVLW  00
13184:  SUBWFB xEC,F
13186:  CLRF   xEE
13188:  MOVLW  67
1318A:  MOVWF  xED
1318C:  MOVLW  08
1318E:  MOVWF  xF0
13190:  MOVLW  D1
13192:  MOVWF  xEF
13194:  MOVFF  8EC,8F2
13198:  MOVFF  8EB,8F1
1319C:  MOVLB  0
1319E:  RCALL  12D6C
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
131A0:  MOVLB  8
131A2:  CLRF   xEC
131A4:  MOVLW  67
131A6:  MOVWF  xEB
131A8:  MOVLB  0
131AA:  RCALL  12D30
131AC:  MOVFF  02,03
131B0:  MOVF   01,W
131B2:  XORLW  FF
131B4:  ADDLW  A1
131B6:  MOVLB  8
131B8:  MOVWF  xEB
131BA:  MOVLW  00
131BC:  SUBFWB 02,W
131BE:  MOVWF  xEC
131C0:  MOVLW  01
131C2:  SUBWF  xEB,F
131C4:  MOVLW  00
131C6:  SUBWFB xEC,F
131C8:  CLRF   xEE
131CA:  MOVLW  67
131CC:  MOVWF  xED
131CE:  MOVLW  08
131D0:  MOVWF  xF0
131D2:  MOVLW  CE
131D4:  MOVWF  xEF
131D6:  MOVFF  8EC,8F2
131DA:  MOVFF  8EB,8F1
131DE:  MOVLB  0
131E0:  RCALL  12D6C
....................  
....................    if(DATA_COMPLETE != rcvdData) 
131E2:  MOVLB  8
131E4:  MOVF   xE5,W
131E6:  SUBLW  02
131E8:  BZ    132A4
....................    {    //housekeeping 
....................       time_stamp(); 
131EA:  MOVLB  0
131EC:  CALL   541A
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
131F0:  MOVLW  01
131F2:  MOVWF  1E
131F4:  MOVLW  A7
131F6:  MOVWF  1D
131F8:  MOVLW  92
131FA:  MOVWF  FF6
131FC:  MOVLW  1C
131FE:  MOVWF  FF7
13200:  MOVLW  00
13202:  MOVWF  FF8
13204:  MOVLW  0A
13206:  MOVLB  8
13208:  MOVWF  xEB
1320A:  MOVLB  0
1320C:  CALL   AACC
13210:  MOVFF  1E,FEA
13214:  MOVFF  1D,FE9
13218:  CLRF   FEF
1321A:  MOVLW  08
1321C:  MOVWF  FEA
1321E:  MOVLW  D1
13220:  MOVWF  FE9
13222:  CALL   FE00
13226:  MOVLW  9E
13228:  MOVWF  FF6
1322A:  MOVLW  1C
1322C:  MOVWF  FF7
1322E:  MOVLW  00
13230:  MOVWF  FF8
13232:  MOVLW  06
13234:  MOVLB  8
13236:  MOVWF  xEB
13238:  MOVLB  0
1323A:  CALL   AACC
1323E:  MOVFF  8E7,8ED
13242:  MOVLW  1B
13244:  MOVLB  8
13246:  MOVWF  xEE
13248:  MOVLB  0
1324A:  CALL   5280
1324E:  MOVLW  5D
13250:  MOVLB  8
13252:  MOVWF  xFF
13254:  MOVLB  0
13256:  CALL   509E
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
1325A:  MOVLW  01
1325C:  MOVLB  8
1325E:  MOVWF  xEC
13260:  MOVLW  A7
13262:  MOVWF  xEB
13264:  MOVLB  0
13266:  RCALL  12D30
13268:  MOVFF  02,03
1326C:  MOVF   01,W
1326E:  XORLW  FF
13270:  ADDLW  A1
13272:  MOVLB  8
13274:  MOVWF  xEB
13276:  MOVLW  00
13278:  SUBFWB 02,W
1327A:  MOVWF  xEC
1327C:  MOVLW  01
1327E:  SUBWF  xEB,F
13280:  MOVLW  00
13282:  SUBWFB xEC,F
13284:  MOVLW  01
13286:  MOVWF  xEE
13288:  MOVLW  A7
1328A:  MOVWF  xED
1328C:  CLRF   xF0
1328E:  MOVLW  67
13290:  MOVWF  xEF
13292:  MOVFF  8EC,8F2
13296:  MOVFF  8EB,8F1
1329A:  MOVLB  0
1329C:  RCALL  12D6C
....................       record_event(); 
1329E:  CALL   84DA
132A2:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
132A4:  MOVFF  8CC,8EB
132A8:  MOVFF  8CD,8EC
132AC:  MOVLB  0
132AE:  CALL   FF2E
....................  
....................    return (rcvdData); 
132B2:  CLRF   03
132B4:  MOVLB  8
132B6:  MOVFF  8E5,01
132BA:  MOVFF  03,02
132BE:  MOVLB  0
132C0:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
136E6:  MOVLB  8
136E8:  CLRF   xC4
136EA:  MOVF   xC4,W
136EC:  SUBLW  02
136EE:  BTFSS  FD8.0
136F0:  BRA    13806
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
136F2:  MOVFF  8C2,8CC
136F6:  MOVFF  8C3,8CD
136FA:  MOVLB  0
136FC:  CALL   12EFA
13700:  MOVFF  02,03
13704:  MOVF   01,W
13706:  SUBLW  02
13708:  BNZ   13716
1370A:  MOVF   03,F
1370C:  BNZ   13716
....................       { 
....................          break; 
1370E:  MOVLB  8
13710:  BRA    13806
....................       } 
13712:  BRA    13802
13714:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
13716:  MOVLW  01
13718:  MOVLB  8
1371A:  ADDWF  xC4,W
1371C:  MOVWF  xC5
1371E:  MOVLW  A8
13720:  MOVWF  FF6
13722:  MOVLW  1C
13724:  MOVWF  FF7
13726:  MOVLW  00
13728:  MOVWF  FF8
1372A:  CLRF   1B
1372C:  BTFSC  FF2.7
1372E:  BSF    1B.7
13730:  BCF    FF2.7
13732:  MOVLW  05
13734:  MOVLB  A
13736:  MOVWF  x40
13738:  MOVLB  0
1373A:  CALL   1024
1373E:  BTFSC  1B.7
13740:  BSF    FF2.7
13742:  CLRF   1B
13744:  BTFSC  FF2.7
13746:  BSF    1B.7
13748:  BCF    FF2.7
1374A:  MOVFF  8C5,A40
1374E:  MOVLW  1B
13750:  MOVLB  A
13752:  MOVWF  x41
13754:  MOVLB  0
13756:  CALL   0FA6
1375A:  BTFSC  1B.7
1375C:  BSF    FF2.7
1375E:  MOVLW  0D
13760:  BTFSS  F9E.4
13762:  BRA    13760
13764:  MOVWF  FAD
13766:  MOVLW  0A
13768:  BTFSS  F9E.4
1376A:  BRA    13768
1376C:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
1376E:  BCF    F90.7
....................          delay_ms(1000); 
13770:  MOVLW  04
13772:  MOVLB  8
13774:  MOVWF  xC5
13776:  MOVLW  FA
13778:  MOVLB  9
1377A:  MOVWF  xEC
1377C:  MOVLB  0
1377E:  CALL   2910
13782:  MOVLB  8
13784:  DECFSZ xC5,F
13786:  BRA    13776
....................          output_bit(VDET,ON); 
13788:  BSF    F90.7
....................          delay_ms(1000); 
1378A:  MOVLW  04
1378C:  MOVWF  xC5
1378E:  MOVLW  FA
13790:  MOVLB  9
13792:  MOVWF  xEC
13794:  MOVLB  0
13796:  CALL   2910
1379A:  MOVLB  8
1379C:  DECFSZ xC5,F
1379E:  BRA    1378E
....................          if (LightTargetFlag==0) 
137A0:  MOVLB  2
137A2:  MOVF   xD9,F
137A4:  BNZ   137EC
....................          { 
....................           cmd='K'; 
137A6:  MOVLW  4B
137A8:  MOVWF  47
....................           arg=detector_ch; 
137AA:  CLRF   4B
137AC:  CLRF   4A
137AE:  CLRF   49
137B0:  MOVFF  2D6,48
....................           det_cmd(); 
137B4:  MOVLB  0
137B6:  CALL   F3C6
....................           delay_ms(1000); 
137BA:  MOVLW  04
137BC:  MOVLB  8
137BE:  MOVWF  xC5
137C0:  MOVLW  FA
137C2:  MOVLB  9
137C4:  MOVWF  xEC
137C6:  MOVLB  0
137C8:  CALL   2910
137CC:  MOVLB  8
137CE:  DECFSZ xC5,F
137D0:  BRA    137C0
....................           cmd='L'; 
137D2:  MOVLW  4C
137D4:  MOVWF  47
....................           arg=detector_li; 
137D6:  CLRF   4B
137D8:  CLRF   4A
137DA:  MOVFF  2D8,49
137DE:  MOVFF  2D7,48
....................           det_cmd(); 
137E2:  MOVLB  0
137E4:  CALL   F3C6
....................          }  
137E8:  BRA    13800
137EA:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
137EC:  MOVLW  6C
137EE:  MOVWF  47
....................           arg=1; 
137F0:  CLRF   4B
137F2:  CLRF   4A
137F4:  CLRF   49
137F6:  MOVLW  01
137F8:  MOVWF  48
....................           det_cmd(); 
137FA:  MOVLB  0
137FC:  CALL   F3C6
13800:  MOVLB  8
....................          }  
....................       } 
13802:  INCF   xC4,F
13804:  BRA    136EA
....................    } 
....................  
....................    parse_data(); 
13806:  MOVLB  0
13808:  RCALL  13664
....................    data_available = TRUE; 
1380A:  MOVLW  01
1380C:  MOVLB  3
1380E:  MOVWF  x3B
....................    macro_flag = 900; 
13810:  MOVLW  03
13812:  MOVWF  x24
13814:  MOVLW  84
13816:  MOVWF  x23
....................  
....................    return; 
13818:  MOVLB  0
1381A:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
13B86:  MOVLB  8
13B88:  CLRF   xCD
13B8A:  CLRF   xCC
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
13B8C:  MOVLB  0
13B8E:  RCALL  13664
13B90:  MOVFF  02,8CD
13B94:  MOVFF  01,8CC
....................    return (temp); 
13B98:  MOVLB  8
13B9A:  MOVFF  8CC,01
13B9E:  MOVFF  8CD,02
13BA2:  MOVLB  0
13BA4:  GOTO   13CB6 (RETURN)
.................... } 
....................  
.................... void det_temp() 
13BA8:  MOVLB  8
13BAA:  CLRF   xC9
13BAC:  CLRF   xC8
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
13BAE:  MOVLB  2
13BB0:  MOVF   xD5,W
13BB2:  XORLW  01
13BB4:  MOVLB  0
13BB6:  BZ    13BBE
13BB8:  XORLW  03
13BBA:  BZ    13BC8
13BBC:  BRA    13BD2
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
13BBE:  MOVFF  42,8CB
13BC2:  MOVFF  41,8CA
....................          break; 
13BC6:  BRA    13BDE
....................       case 2 : target_temp = nv_d2_temp; 
13BC8:  MOVFF  44,8CB
13BCC:  MOVFF  43,8CA
....................          break; 
13BD0:  BRA    13BDE
....................       default : target_temp = 20000; 
13BD2:  MOVLW  4E
13BD4:  MOVLB  8
13BD6:  MOVWF  xCB
13BD8:  MOVLW  20
13BDA:  MOVWF  xCA
....................          break; 
13BDC:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
13BDE:  MOVLB  8
13BE0:  CLRF   xC7
13BE2:  MOVLW  3C
13BE4:  MOVWF  xC6
....................    n = 0; 
13BE6:  CLRF   xC5
13BE8:  CLRF   xC4
....................    store=FALSE; 
13BEA:  CLRF   xC2
....................    display=FALSE; 
13BEC:  CLRF   xC3
....................  
....................    time_stamp(); 
13BEE:  MOVLB  0
13BF0:  CALL   541A
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
13BF4:  MOVLW  01
13BF6:  MOVWF  1E
13BF8:  MOVLW  A7
13BFA:  MOVWF  1D
13BFC:  MOVLW  B2
13BFE:  MOVWF  FF6
13C00:  MOVLW  1C
13C02:  MOVWF  FF7
13C04:  MOVLW  00
13C06:  MOVWF  FF8
13C08:  MOVLW  16
13C0A:  MOVLB  8
13C0C:  MOVWF  xEB
13C0E:  MOVLB  0
13C10:  CALL   AACC
13C14:  MOVLW  10
13C16:  MOVWF  FE9
13C18:  MOVFF  8CB,8F7
13C1C:  MOVFF  8CA,8F6
13C20:  CALL   AAFE
13C24:  MOVLW  CB
13C26:  MOVWF  FF6
13C28:  MOVLW  1C
13C2A:  MOVWF  FF7
13C2C:  MOVLW  00
13C2E:  MOVWF  FF8
13C30:  MOVLW  09
13C32:  MOVLB  8
13C34:  MOVWF  xEB
13C36:  MOVLB  0
13C38:  CALL   AACC
13C3C:  MOVLW  10
13C3E:  MOVWF  FE9
13C40:  MOVFF  8C9,8F7
13C44:  MOVFF  8C8,8F6
13C48:  CALL   AAFE
13C4C:  MOVLW  D7
13C4E:  MOVWF  FF6
13C50:  MOVLW  1C
13C52:  MOVWF  FF7
13C54:  MOVLW  00
13C56:  MOVWF  FF8
13C58:  MOVLW  0B
13C5A:  MOVLB  8
13C5C:  MOVWF  xEB
13C5E:  MOVLB  0
13C60:  CALL   AACC
13C64:  MOVLW  10
13C66:  MOVWF  FE9
13C68:  MOVFF  8C5,8F7
13C6C:  MOVFF  8C4,8F6
13C70:  CALL   AAFE
13C74:  MOVLW  E5
13C76:  MOVWF  FF6
13C78:  MOVLW  1C
13C7A:  MOVWF  FF7
13C7C:  MOVLW  00
13C7E:  MOVWF  FF8
13C80:  MOVLW  03
13C82:  MOVLB  8
13C84:  MOVWF  xEB
13C86:  MOVLB  0
13C88:  CALL   AACC
....................    record_event(); 
13C8C:  CALL   84DA
....................  
....................    for (n=1; n<t; ++n) 
13C90:  MOVLB  8
13C92:  CLRF   xC5
13C94:  MOVLW  01
13C96:  MOVWF  xC4
13C98:  MOVF   xC5,W
13C9A:  SUBWF  xC7,W
13C9C:  BNC   13CF8
13C9E:  BNZ   13CA6
13CA0:  MOVF   xC6,W
13CA2:  SUBWF  xC4,W
13CA4:  BC    13CF8
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
13CA6:  MOVFF  8C2,8CC
13CAA:  MOVFF  8C3,8CD
13CAE:  MOVLB  0
13CB0:  CALL   12EFA
....................       current_temp=parse_temp(); 
13CB4:  BRA    13B86
13CB6:  MOVFF  02,8C9
13CBA:  MOVFF  01,8C8
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
13CBE:  MOVLB  8
13CC0:  MOVF   xCB,W
13CC2:  SUBWF  xC9,W
13CC4:  BNC   13CCE
13CC6:  BNZ   13CD6
13CC8:  MOVF   xCA,W
13CCA:  SUBWF  xC8,W
13CCC:  BC    13CD6
13CCE:  MOVF   xC8,F
13CD0:  BNZ   13CDA
13CD2:  MOVF   xC9,F
13CD4:  BNZ   13CDA
13CD6:  BRA    13CF8
13CD8:  BRA    13CF0
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13CDA:  MOVLW  0A
13CDC:  MOVWF  xCC
13CDE:  MOVLW  FA
13CE0:  MOVLB  9
13CE2:  MOVWF  xEC
13CE4:  MOVLB  0
13CE6:  CALL   2910
13CEA:  MOVLB  8
13CEC:  DECFSZ xCC,F
13CEE:  BRA    13CDE
13CF0:  INCF   xC4,F
13CF2:  BTFSC  FD8.2
13CF4:  INCF   xC5,F
13CF6:  BRA    13C98
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13CF8:  MOVLW  01
13CFA:  MOVWF  1E
13CFC:  MOVLW  A7
13CFE:  MOVWF  1D
13D00:  MOVLW  EA
13D02:  MOVWF  FF6
13D04:  MOVLW  1C
13D06:  MOVWF  FF7
13D08:  MOVLW  00
13D0A:  MOVWF  FF8
13D0C:  MOVLW  14
13D0E:  MOVWF  xEB
13D10:  MOVLB  0
13D12:  CALL   AACC
13D16:  MOVLW  10
13D18:  MOVWF  FE9
13D1A:  MOVFF  8CB,8F7
13D1E:  MOVFF  8CA,8F6
13D22:  CALL   AAFE
13D26:  MOVLW  01
13D28:  MOVWF  FF6
13D2A:  MOVLW  1D
13D2C:  MOVWF  FF7
13D2E:  MOVLW  00
13D30:  MOVWF  FF8
13D32:  MOVLW  09
13D34:  MOVLB  8
13D36:  MOVWF  xEB
13D38:  MOVLB  0
13D3A:  CALL   AACC
13D3E:  MOVLW  10
13D40:  MOVWF  FE9
13D42:  MOVFF  8C9,8F7
13D46:  MOVFF  8C8,8F6
13D4A:  CALL   AAFE
13D4E:  MOVLW  0D
13D50:  MOVWF  FF6
13D52:  MOVLW  1D
13D54:  MOVWF  FF7
13D56:  MOVLW  00
13D58:  MOVWF  FF8
13D5A:  MOVLW  0B
13D5C:  MOVLB  8
13D5E:  MOVWF  xEB
13D60:  MOVLB  0
13D62:  CALL   AACC
13D66:  MOVLW  10
13D68:  MOVWF  FE9
13D6A:  MOVFF  8C5,8F7
13D6E:  MOVFF  8C4,8F6
13D72:  CALL   AAFE
13D76:  MOVLW  1B
13D78:  MOVWF  FF6
13D7A:  MOVLW  1D
13D7C:  MOVWF  FF7
13D7E:  MOVLW  00
13D80:  MOVWF  FF8
13D82:  MOVLW  03
13D84:  MOVLB  8
13D86:  MOVWF  xEB
13D88:  MOVLB  0
13D8A:  CALL   AACC
....................    record_event();    
13D8E:  CALL   84DA
13D92:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
1385E:  MOVLB  8
13860:  CLRF   xD5
13862:  CLRF   xD4
13864:  CLRF   xD3
13866:  CLRF   xD2
....................    set_adc_channel(1,VSS); 
13868:  MOVLW  04
1386A:  MOVWF  01
1386C:  MOVF   FC2,W
1386E:  ANDLW  83
13870:  IORWF  01,W
13872:  MOVWF  FC2
13874:  MOVLW  00
13876:  MOVWF  01
13878:  MOVF   FC1,W
1387A:  ANDLW  F8
1387C:  IORWF  01,W
1387E:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
13880:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
13882:  MOVLW  01
13884:  MOVWF  xCF
13886:  MOVF   xCF,W
13888:  SUBLW  32
1388A:  BNC   138B0
....................       reading=read_adc(); 
1388C:  BSF    FC2.1
1388E:  BTFSC  FC2.1
13890:  BRA    1388E
13892:  MOVFF  FC3,8D6
13896:  MOVFF  FC4,8D7
1389A:  CLRF   xD8
1389C:  CLRF   xD9
....................       delay_ms(5); 
1389E:  MOVLW  05
138A0:  MOVLB  9
138A2:  MOVWF  xEC
138A4:  MOVLB  0
138A6:  CALL   2910
138AA:  MOVLB  8
138AC:  INCF   xCF,F
138AE:  BRA    13886
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
138B0:  MOVLW  01
138B2:  MOVWF  xCF
138B4:  MOVF   xCF,W
138B6:  SUBLW  64
138B8:  BNC   13966
....................       reading=read_adc(); 
138BA:  BSF    FC2.1
138BC:  BTFSC  FC2.1
138BE:  BRA    138BC
138C0:  MOVFF  FC3,8D6
138C4:  MOVFF  FC4,8D7
138C8:  CLRF   xD8
138CA:  CLRF   xD9
....................       result=(((result*(i-1))+reading)/i); 
138CC:  MOVLW  01
138CE:  SUBWF  xCF,W
138D0:  MOVWF  xDA
138D2:  MOVFF  8D5,9F9
138D6:  MOVFF  8D4,9F8
138DA:  MOVFF  8D3,9F7
138DE:  MOVFF  8D2,9F6
138E2:  MOVLB  9
138E4:  CLRF   xFD
138E6:  CLRF   xFC
138E8:  CLRF   xFB
138EA:  MOVWF  xFA
138EC:  MOVLB  0
138EE:  CALL   47F0
138F2:  MOVFF  03,8DD
138F6:  MOVFF  02,8DC
138FA:  MOVFF  01,8DB
138FE:  MOVFF  00,8DA
13902:  MOVLB  8
13904:  MOVF   xD6,W
13906:  ADDWF  xDA,F
13908:  MOVF   xD7,W
1390A:  ADDWFC xDB,F
1390C:  MOVF   xD8,W
1390E:  ADDWFC xDC,F
13910:  MOVF   xD9,W
13912:  ADDWFC xDD,F
13914:  BCF    FD8.1
13916:  CLRF   1B
13918:  BTFSC  FF2.7
1391A:  BSF    1B.7
1391C:  BCF    FF2.7
1391E:  MOVFF  8DD,A4F
13922:  MOVFF  8DC,A4E
13926:  MOVFF  8DB,A4D
1392A:  MOVFF  8DA,A4C
1392E:  MOVLB  A
13930:  CLRF   x53
13932:  CLRF   x52
13934:  CLRF   x51
13936:  MOVFF  8CF,A50
1393A:  MOVLB  0
1393C:  CALL   1056
13940:  BTFSC  1B.7
13942:  BSF    FF2.7
13944:  MOVFF  03,8D5
13948:  MOVFF  02,8D4
1394C:  MOVFF  01,8D3
13950:  MOVFF  00,8D2
....................       delay_ms(5); 
13954:  MOVLW  05
13956:  MOVLB  9
13958:  MOVWF  xEC
1395A:  MOVLB  0
1395C:  CALL   2910
13960:  MOVLB  8
13962:  INCF   xCF,F
13964:  BRA    138B4
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
13966:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
13968:  MOVFF  8D5,9F9
1396C:  MOVFF  8D4,9F8
13970:  MOVFF  8D3,9F7
13974:  MOVFF  8D2,9F6
13978:  MOVLB  9
1397A:  CLRF   xFD
1397C:  CLRF   xFC
1397E:  MOVLW  10
13980:  MOVWF  xFB
13982:  MOVLW  25
13984:  MOVWF  xFA
13986:  MOVLB  0
13988:  CALL   47F0
1398C:  MOVFF  03,8DD
13990:  MOVFF  02,8DC
13994:  MOVFF  01,8DB
13998:  MOVFF  00,8DA
1399C:  BCF    FD8.1
1399E:  CLRF   1B
139A0:  BTFSC  FF2.7
139A2:  BSF    1B.7
139A4:  BCF    FF2.7
139A6:  MOVFF  03,A4F
139AA:  MOVFF  02,A4E
139AE:  MOVFF  01,A4D
139B2:  MOVFF  00,A4C
139B6:  MOVLB  A
139B8:  CLRF   x53
139BA:  CLRF   x52
139BC:  CLRF   x51
139BE:  MOVLW  64
139C0:  MOVWF  x50
139C2:  MOVLB  0
139C4:  CALL   1056
139C8:  BTFSC  1B.7
139CA:  BSF    FF2.7
139CC:  MOVLW  21
139CE:  MOVLB  8
139D0:  SUBWF  00,W
139D2:  MOVWF  xD0
139D4:  MOVLW  50
139D6:  SUBWFB 01,W
139D8:  MOVWF  xD1
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
139DA:  MOVFF  8D0,01
139DE:  MOVFF  8D1,02
139E2:  MOVLB  0
139E4:  GOTO   13A4A (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
139F4:  CLRF   xC8
139F6:  CLRF   xC7
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
139E8:  MOVLW  0D
139EA:  MOVLB  8
139EC:  MOVWF  xC4
139EE:  MOVLW  0A
139F0:  MOVWF  xC5
139F2:  CLRF   xC6
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
139F8:  MOVLB  0
139FA:  CALL   127B4
....................    clear_data_buffer(); 
139FE:  CALL   D4EC
....................  
....................    time_stamp(); 
13A02:  CALL   541A
....................    strcpy(data_buffer, time_stmp_str); 
13A06:  CLRF   FEA
13A08:  MOVLW  67
13A0A:  MOVWF  FE9
13A0C:  MOVLW  02
13A0E:  MOVWF  FE2
13A10:  MOVLW  99
13A12:  MOVWF  FE1
13A14:  MOVF   FE7,F
13A16:  MOVFF  FE6,FEE
13A1A:  BNZ   13A14
....................    strcat(data_buffer, (char *)",Tmp,"); 
13A1C:  MOVLW  2C
13A1E:  MOVLB  8
13A20:  MOVWF  xC9
13A22:  MOVLW  54
13A24:  MOVWF  xCA
13A26:  MOVLW  6D
13A28:  MOVWF  xCB
13A2A:  MOVLW  70
13A2C:  MOVWF  xCC
13A2E:  MOVLW  2C
13A30:  MOVWF  xCD
13A32:  CLRF   xCE
13A34:  CLRF   xF9
13A36:  MOVLW  67
13A38:  MOVWF  xF8
13A3A:  MOVLW  08
13A3C:  MOVWF  xFB
13A3E:  MOVLW  C9
13A40:  MOVWF  xFA
13A42:  MOVLB  0
13A44:  CALL   54DE
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
13A48:  BRA    1385E
13A4A:  MOVFF  02,8C8
13A4E:  MOVFF  01,8C7
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
13A52:  MOVLW  02
13A54:  MOVWF  1E
13A56:  MOVLW  47
13A58:  MOVWF  1D
13A5A:  MOVLW  45
13A5C:  MOVWF  FE9
13A5E:  MOVLB  8
13A60:  CLRF   xF0
13A62:  CLRF   xEF
13A64:  MOVFF  8C8,8EE
13A68:  MOVFF  8C7,8ED
13A6C:  MOVLW  03
13A6E:  MOVWF  xF1
13A70:  MOVLB  0
13A72:  CALL   531A
....................  
....................    strcat(slave_reply, endofline); 
13A76:  MOVLW  02
13A78:  MOVLB  8
13A7A:  MOVWF  xF9
13A7C:  MOVLW  47
13A7E:  MOVWF  xF8
13A80:  MOVLW  08
13A82:  MOVWF  xFB
13A84:  MOVLW  C4
13A86:  MOVWF  xFA
13A88:  MOVLB  0
13A8A:  CALL   54DE
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13A8E:  MOVLB  8
13A90:  CLRF   xEC
13A92:  MOVLW  67
13A94:  MOVWF  xEB
13A96:  MOVLB  0
13A98:  CALL   12D30
13A9C:  MOVFF  02,03
13AA0:  MOVF   01,W
13AA2:  XORLW  FF
13AA4:  ADDLW  A1
13AA6:  MOVLB  8
13AA8:  MOVWF  xCF
13AAA:  MOVLW  00
13AAC:  SUBFWB 02,W
13AAE:  MOVWF  xD0
13AB0:  MOVLW  01
13AB2:  SUBWF  xCF,F
13AB4:  MOVLW  00
13AB6:  SUBWFB xD0,F
13AB8:  CLRF   xEE
13ABA:  MOVLW  67
13ABC:  MOVWF  xED
13ABE:  MOVLW  02
13AC0:  MOVWF  xF0
13AC2:  MOVLW  47
13AC4:  MOVWF  xEF
13AC6:  MOVFF  8D0,8F2
13ACA:  MOVFF  8CF,8F1
13ACE:  MOVLB  0
13AD0:  CALL   12D6C
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
13AD4:  MOVF   1F,F
13AD6:  BNZ   13AF6
13AD8:  MOVF   20,F
13ADA:  BNZ   13AF6
13ADC:  MOVLB  8
13ADE:  DECFSZ xC3,W
13AE0:  BRA    13AE4
13AE2:  BRA    13AE8
13AE4:  MOVLB  0
13AE6:  BRA    13AF6
13AE8:  CLRF   FEA
13AEA:  MOVLW  67
13AEC:  MOVWF  FE9
13AEE:  MOVLB  0
13AF0:  CALL   7996
13AF4:  BRA    13B0A
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
13AF6:  MOVF   20,F
13AF8:  BNZ   13B00
13AFA:  MOVF   1F,W
13AFC:  SUBLW  03
13AFE:  BC    13B0A
13B00:  CLRF   FEA
13B02:  MOVLW  67
13B04:  MOVWF  FE9
13B06:  CALL   7996
....................  
....................    if (store == TRUE && sd_status==0) { 
13B0A:  MOVLB  8
13B0C:  DECFSZ xC2,W
13B0E:  BRA    13B6E
13B10:  MOVLB  2
13B12:  MOVF   xDC,F
13B14:  BTFSC  FD8.2
13B16:  BRA    13B1C
13B18:  MOVLB  8
13B1A:  BRA    13B6E
....................       buffer_select = 0; 
13B1C:  MOVLB  0
13B1E:  CLRF   x66
....................       
....................       heartbeat(FALSE); 
13B20:  MOVLB  8
13B22:  CLRF   xED
13B24:  MOVLB  0
13B26:  CALL   5586
....................          append_data(file_ptr_raw_all); 
13B2A:  MOVLW  02
13B2C:  MOVLB  8
13B2E:  MOVWF  xEE
13B30:  MOVLW  DD
13B32:  MOVWF  xED
13B34:  MOVLB  0
13B36:  CALL   82F8
....................       heartbeat(TRUE); 
13B3A:  MOVLW  01
13B3C:  MOVLB  8
13B3E:  MOVWF  xED
13B40:  MOVLB  0
13B42:  CALL   5586
....................        
....................       heartbeat(FALSE); 
13B46:  MOVLB  8
13B48:  CLRF   xED
13B4A:  MOVLB  0
13B4C:  CALL   5586
....................          append_data(file_ptr_raw_new); 
13B50:  MOVLW  02
13B52:  MOVLB  8
13B54:  MOVWF  xEE
13B56:  MOVLW  EB
13B58:  MOVWF  xED
13B5A:  MOVLB  0
13B5C:  CALL   82F8
....................       heartbeat(TRUE); 
13B60:  MOVLW  01
13B62:  MOVLB  8
13B64:  MOVWF  xED
13B66:  MOVLB  0
13B68:  CALL   5586
13B6C:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13B6E:  MOVLW  03
13B70:  MOVLB  3
13B72:  MOVWF  x24
13B74:  MOVLW  84
13B76:  MOVWF  x23
....................     
....................    return (temp); 
13B78:  MOVLB  8
13B7A:  MOVFF  8C7,01
13B7E:  MOVFF  8C8,02
13B82:  MOVLB  0
13B84:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
126C6:  MOVLB  8
126C8:  MOVF   xC5,W
126CA:  ADDLW  FC
126CC:  BC    1270A
126CE:  ADDLW  04
126D0:  MOVLB  0
126D2:  GOTO   12712
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
126D6:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
126D8:  BCF    F8C.1
....................          break; 
126DA:  MOVLB  8
126DC:  BRA    1270A
....................       case 1 :  
....................             output_bit(HSW1, ON); 
126DE:  BSF    F8C.0
....................          break; 
126E0:  MOVLB  8
126E2:  BRA    1270A
....................       case 2 :  
....................             output_bit(HSW2, ON); 
126E4:  BSF    F8C.1
....................          break;  
126E6:  MOVLB  8
126E8:  BRA    1270A
....................       case 3 :  
....................             output_bit(HSW1, ON); 
126EA:  BSF    F8C.0
....................             delay_ms(500); 
126EC:  MOVLW  02
126EE:  MOVLB  8
126F0:  MOVWF  xC6
126F2:  MOVLW  FA
126F4:  MOVLB  9
126F6:  MOVWF  xEC
126F8:  MOVLB  0
126FA:  CALL   2910
126FE:  MOVLB  8
12700:  DECFSZ xC6,F
12702:  BRA    126F2
....................             output_bit(HSW2, ON); 
12704:  BSF    F8C.1
....................          break;             
12706:  BRA    1270A
12708:  MOVLB  8
....................    } 
....................    heater_stat=set; 
1270A:  MOVFF  8C5,4B5
1270E:  MOVLB  0
12710:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F7EE:  MOVLW  08
0F7F0:  MOVLB  8
0F7F2:  MOVWF  xCC
0F7F4:  CLRF   xCB
....................    LED_level_change=2048; 
0F7F6:  MOVWF  xCE
0F7F8:  CLRF   xCD
....................     
....................    for (i=0; i<12; i++){ 
0F7FA:  CLRF   xCA
0F7FC:  MOVF   xCA,W
0F7FE:  SUBLW  0B
0F800:  BNC   F878
....................       DAC_set(1,LED_level); 
0F802:  MOVLW  01
0F804:  MOVWF  xD3
0F806:  MOVFF  8CC,8D5
0F80A:  MOVFF  8CB,8D4
0F80E:  MOVLB  0
0F810:  RCALL  F53C
....................       LED_level_change = LED_level_change/2; 
0F812:  BCF    FD8.0
0F814:  MOVLB  8
0F816:  RRCF   xCE,F
0F818:  RRCF   xCD,F
....................       ADC_average(200); 
0F81A:  CLRF   xD4
0F81C:  MOVLW  C8
0F81E:  MOVWF  xD3
0F820:  MOVLB  0
0F822:  RCALL  F5E4
....................       output = ADC_val[2]; 
0F824:  MOVFF  4AA,8D0
0F828:  MOVFF  4A9,8CF
....................       temp = ADC_val[3]; 
0F82C:  MOVFF  4AC,8D2
0F830:  MOVFF  4AB,8D1
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F834:  MOVLB  8
0F836:  MOVF   xC9,W
0F838:  SUBWF  xD0,W
0F83A:  BNC   F84E
0F83C:  BNZ   F844
0F83E:  MOVF   xCF,W
0F840:  SUBWF  xC8,W
0F842:  BC    F84E
....................          LED_level=LED_level-LED_level_change; 
0F844:  MOVF   xCD,W
0F846:  SUBWF  xCB,F
0F848:  MOVF   xCE,W
0F84A:  SUBWFB xCC,F
....................       } 
0F84C:  BRA    F874
....................       else if(output<intensity){ 
0F84E:  MOVF   xD0,W
0F850:  SUBWF  xC9,W
0F852:  BNC   F866
0F854:  BNZ   F85C
0F856:  MOVF   xC8,W
0F858:  SUBWF  xCF,W
0F85A:  BC    F866
....................          LED_level=LED_level+LED_level_change; 
0F85C:  MOVF   xCD,W
0F85E:  ADDWF  xCB,F
0F860:  MOVF   xCE,W
0F862:  ADDWFC xCC,F
....................       } 
0F864:  BRA    F874
....................       else if(output==intensity) break; 
0F866:  MOVF   xC8,W
0F868:  SUBWF  xCF,W
0F86A:  BNZ   F874
0F86C:  MOVF   xC9,W
0F86E:  SUBWF  xD0,W
0F870:  BTFSC  FD8.2
0F872:  BRA    F878
0F874:  INCF   xCA,F
0F876:  BRA    F7FC
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F878:  MOVLW  01
0F87A:  MOVWF  xD3
0F87C:  MOVFF  8CC,8D5
0F880:  MOVFF  8CB,8D4
0F884:  MOVLB  0
0F886:  RCALL  F53C
0F888:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F88A:  MOVLW  01
0F88C:  MOVLB  8
0F88E:  MOVWF  xC7
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F890:  MOVF   xC5,F
0F892:  BNZ   F898
0F894:  MOVF   xC6,F
0F896:  BZ    F8AC
0F898:  MOVF   xC6,W
0F89A:  SUBLW  0F
0F89C:  BNC   F8AC
0F89E:  MOVFF  8C6,8C9
0F8A2:  MOVFF  8C5,8C8
0F8A6:  MOVLB  0
0F8A8:  RCALL  F7EE
0F8AA:  MOVLB  8
....................   if(intensity == 0) { 
0F8AC:  MOVF   xC5,F
0F8AE:  BNZ   F8D2
0F8B0:  MOVF   xC6,F
0F8B2:  BNZ   F8D2
....................       DAC_set(1, 0); 
0F8B4:  MOVLW  01
0F8B6:  MOVWF  xD3
0F8B8:  CLRF   xD5
0F8BA:  CLRF   xD4
0F8BC:  MOVLB  0
0F8BE:  RCALL  F53C
....................       DAC_set(2, 0); 
0F8C0:  MOVLW  02
0F8C2:  MOVLB  8
0F8C4:  MOVWF  xD3
0F8C6:  CLRF   xD5
0F8C8:  CLRF   xD4
0F8CA:  MOVLB  0
0F8CC:  RCALL  F53C
....................    } 
0F8CE:  BRA    F8D6
0F8D0:  MOVLB  8
....................    else valid=FALSE; 
0F8D2:  CLRF   xC7
0F8D4:  MOVLB  0
....................    return(valid); 
0F8D6:  MOVLB  8
0F8D8:  MOVFF  8C7,01
0F8DC:  MOVLB  0
0F8DE:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FE60:  MOVLW  20
0FE62:  MOVWF  FF6
0FE64:  MOVLW  1D
0FE66:  MOVWF  FF7
0FE68:  MOVLW  00
0FE6A:  MOVWF  FF8
0FE6C:  MOVLW  03
0FE6E:  MOVWF  FEA
0FE70:  MOVLW  3D
0FE72:  MOVWF  FE9
0FE74:  RCALL  FE26
0FE76:  MOVF   01,W
0FE78:  BZ    FE8C
0FE7A:  XORLW  01
0FE7C:  BZ    FEAC
0FE7E:  XORLW  03
0FE80:  BZ    FECC
0FE82:  XORLW  01
0FE84:  BZ    FEEC
0FE86:  XORLW  07
0FE88:  BZ    FF0C
0FE8A:  BRA    FF2A
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FE8C:  BCF    FD8.0
0FE8E:  MOVLB  3
0FE90:  RLCF   x4A,W
0FE92:  CLRF   03
0FE94:  ADDLW  4B
0FE96:  MOVWF  FE9
0FE98:  MOVLW  03
0FE9A:  ADDWFC 03,W
0FE9C:  MOVWF  FEA
0FE9E:  MOVFF  4A8,FEC
0FEA2:  MOVF   FED,F
0FEA4:  MOVFF  4A7,FEF
....................          break; 
0FEA8:  MOVLB  0
0FEAA:  BRA    FF2A
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FEAC:  BCF    FD8.0
0FEAE:  MOVLB  3
0FEB0:  RLCF   x4A,W
0FEB2:  CLRF   03
0FEB4:  ADDLW  5D
0FEB6:  MOVWF  FE9
0FEB8:  MOVLW  03
0FEBA:  ADDWFC 03,W
0FEBC:  MOVWF  FEA
0FEBE:  MOVFF  4A8,FEC
0FEC2:  MOVF   FED,F
0FEC4:  MOVFF  4A7,FEF
....................          break;    
0FEC8:  MOVLB  0
0FECA:  BRA    FF2A
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FECC:  BCF    FD8.0
0FECE:  MOVLB  3
0FED0:  RLCF   x4A,W
0FED2:  CLRF   03
0FED4:  ADDLW  6F
0FED6:  MOVWF  FE9
0FED8:  MOVLW  03
0FEDA:  ADDWFC 03,W
0FEDC:  MOVWF  FEA
0FEDE:  MOVFF  4A8,FEC
0FEE2:  MOVF   FED,F
0FEE4:  MOVFF  4A7,FEF
....................          break; 
0FEE8:  MOVLB  0
0FEEA:  BRA    FF2A
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FEEC:  BCF    FD8.0
0FEEE:  MOVLB  3
0FEF0:  RLCF   x4A,W
0FEF2:  CLRF   03
0FEF4:  ADDLW  81
0FEF6:  MOVWF  FE9
0FEF8:  MOVLW  03
0FEFA:  ADDWFC 03,W
0FEFC:  MOVWF  FEA
0FEFE:  MOVFF  4A8,FEC
0FF02:  MOVF   FED,F
0FF04:  MOVFF  4A7,FEF
....................          break; 
0FF08:  MOVLB  0
0FF0A:  BRA    FF2A
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FF0C:  BCF    FD8.0
0FF0E:  MOVLB  3
0FF10:  RLCF   x4A,W
0FF12:  CLRF   03
0FF14:  ADDLW  93
0FF16:  MOVWF  FE9
0FF18:  MOVLW  03
0FF1A:  ADDWFC 03,W
0FF1C:  MOVWF  FEA
0FF1E:  MOVFF  4A8,FEC
0FF22:  MOVF   FED,F
0FF24:  MOVFF  4A7,FEF
....................          break; 
0FF28:  MOVLB  0
....................    } 
0FF2A:  GOTO   10250 (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
10000:  MOVFF  8C3,8D4
10004:  MOVFF  8C2,8D3
10008:  CALL   F5E4
....................     
....................    v_supply = read_supply(); 
1000C:  CALL   50FC
10010:  MOVFF  02,8C8
10014:  MOVFF  01,8C7
....................        
....................    RTC_reset_HT(); 
10018:  CALL   34B2
....................    RTC_read(); 
1001C:  CALL   3344
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
10020:  CALL   F8F8
10024:  MOVFF  02,8CA
10028:  MOVFF  01,8C9
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
1002C:  MOVLB  8
1002E:  DECFSZ xC6,W
10030:  GOTO   1005E
10034:  MOVLW  10
10036:  MOVWF  FE9
10038:  CLRF   1B
1003A:  BTFSC  FF2.7
1003C:  BSF    1B.7
1003E:  BCF    FF2.7
10040:  MOVFF  4AA,A41
10044:  MOVFF  4A9,A40
10048:  MOVLB  0
1004A:  CALL   11A6
1004E:  BTFSC  1B.7
10050:  BSF    FF2.7
10052:  MOVLW  2C
10054:  BTFSS  F9E.4
10056:  GOTO   10054
1005A:  MOVWF  FAD
1005C:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
1005E:  CLRF   1E
10060:  MOVLW  67
10062:  MOVWF  1D
10064:  MOVFF  72A,8ED
10068:  MOVLW  01
1006A:  MOVWF  xEE
1006C:  MOVLB  0
1006E:  CALL   5280
10072:  MOVLW  2F
10074:  MOVLB  8
10076:  MOVWF  xFF
10078:  MOVLB  0
1007A:  CALL   509E
1007E:  MOVFF  729,8ED
10082:  MOVLW  01
10084:  MOVLB  8
10086:  MOVWF  xEE
10088:  MOVLB  0
1008A:  CALL   5280
1008E:  MOVLW  2F
10090:  MOVLB  8
10092:  MOVWF  xFF
10094:  MOVLB  0
10096:  CALL   509E
1009A:  MOVFF  72B,8ED
1009E:  MOVLW  01
100A0:  MOVLB  8
100A2:  MOVWF  xEE
100A4:  MOVLB  0
100A6:  CALL   5280
100AA:  MOVLW  20
100AC:  MOVLB  8
100AE:  MOVWF  xFF
100B0:  MOVLB  0
100B2:  CALL   509E
100B6:  MOVFF  727,8ED
100BA:  MOVLW  01
100BC:  MOVLB  8
100BE:  MOVWF  xEE
100C0:  MOVLB  0
100C2:  CALL   5280
100C6:  MOVLW  3A
100C8:  MOVLB  8
100CA:  MOVWF  xFF
100CC:  MOVLB  0
100CE:  CALL   509E
100D2:  MOVFF  726,8ED
100D6:  MOVLW  01
100D8:  MOVLB  8
100DA:  MOVWF  xEE
100DC:  MOVLB  0
100DE:  CALL   5280
100E2:  MOVLW  3A
100E4:  MOVLB  8
100E6:  MOVWF  xFF
100E8:  MOVLB  0
100EA:  CALL   509E
100EE:  MOVFF  725,8ED
100F2:  MOVLW  01
100F4:  MOVLB  8
100F6:  MOVWF  xEE
100F8:  MOVLB  0
100FA:  CALL   5280
100FE:  MOVLW  2C
10100:  MOVLB  8
10102:  MOVWF  xFF
10104:  MOVLB  0
10106:  CALL   509E
1010A:  MOVLW  04
1010C:  MOVWF  FE9
1010E:  MOVLB  8
10110:  CLRF   xF0
10112:  CLRF   xEF
10114:  MOVFF  8C8,8EE
10118:  MOVFF  8C7,8ED
1011C:  MOVLW  02
1011E:  MOVWF  xF1
10120:  MOVLB  0
10122:  CALL   531A
10126:  MOVLW  2C
10128:  MOVLB  8
1012A:  MOVWF  xFF
1012C:  MOVLB  0
1012E:  CALL   509E
10132:  MOVFF  1E,FEA
10136:  MOVFF  1D,FE9
1013A:  CLRF   FEF
1013C:  MOVLW  03
1013E:  MOVWF  FEA
10140:  MOVLW  3D
10142:  MOVWF  FE9
10144:  CALL   FE00
10148:  MOVLW  2C
1014A:  MOVLB  8
1014C:  MOVWF  xFF
1014E:  MOVLB  0
10150:  CALL   509E
10154:  MOVFF  1E,FEA
10158:  MOVFF  1D,FE9
1015C:  CLRF   FEF
1015E:  MOVLW  03
10160:  MOVWF  FEA
10162:  MOVLW  42
10164:  MOVWF  FE9
10166:  CALL   FE00
1016A:  MOVLW  2C
1016C:  MOVLB  8
1016E:  MOVWF  xFF
10170:  MOVLB  0
10172:  CALL   509E
10176:  MOVFF  1E,FEA
1017A:  MOVFF  1D,FE9
1017E:  CLRF   FEF
10180:  MOVLW  03
10182:  MOVWF  FEA
10184:  MOVLW  46
10186:  MOVWF  FE9
10188:  CALL   FE00
1018C:  MOVLW  2C
1018E:  MOVLB  8
10190:  MOVWF  xFF
10192:  MOVLB  0
10194:  CALL   509E
10198:  MOVLW  10
1019A:  MOVWF  FE9
1019C:  MOVFF  26,8F7
101A0:  MOVFF  25,8F6
101A4:  CALL   AAFE
101A8:  MOVLW  2C
101AA:  MOVLB  8
101AC:  MOVWF  xFF
101AE:  MOVLB  0
101B0:  CALL   509E
101B4:  MOVLW  10
101B6:  MOVWF  FE9
101B8:  MOVFF  8CA,8F7
101BC:  MOVFF  8C9,8F6
101C0:  CALL   AAFE
101C4:  MOVLW  2C
101C6:  MOVLB  8
101C8:  MOVWF  xFF
101CA:  MOVLB  0
101CC:  CALL   509E
101D0:  MOVFF  4B5,8ED
101D4:  MOVLW  1B
101D6:  MOVLB  8
101D8:  MOVWF  xEE
101DA:  MOVLB  0
101DC:  CALL   5280
101E0:  MOVLW  2C
101E2:  MOVLB  8
101E4:  MOVWF  xFF
101E6:  MOVLB  0
101E8:  CALL   509E
101EC:  MOVLW  10
101EE:  MOVWF  FE9
101F0:  MOVFF  4A8,8F7
101F4:  MOVFF  4A7,8F6
101F8:  CALL   AAFE
101FC:  MOVLW  2C
101FE:  MOVLB  8
10200:  MOVWF  xFF
10202:  MOVLB  0
10204:  CALL   509E
10208:  MOVLW  10
1020A:  MOVWF  FE9
1020C:  MOVFF  4AE,8F7
10210:  MOVFF  4AD,8F6
10214:  CALL   AAFE
10218:  MOVLW  2C
1021A:  MOVLB  8
1021C:  MOVWF  xFF
1021E:  MOVLB  0
10220:  CALL   509E
10224:  MOVLW  10
10226:  MOVWF  FE9
10228:  MOVFF  4AC,8F7
1022C:  MOVFF  4AB,8F6
10230:  CALL   AAFE
10234:  MOVLW  0D
10236:  MOVLB  8
10238:  MOVWF  xFF
1023A:  MOVLB  0
1023C:  CALL   509E
10240:  MOVLW  0A
10242:  MOVLB  8
10244:  MOVWF  xFF
10246:  MOVLB  0
10248:  CALL   509E
....................  
....................    load_scanned_data();  
1024C:  GOTO   FE60
....................  
....................    display_rec(store, display); 
10250:  MOVFF  8C4,8EB
10254:  MOVFF  8C5,8EC
10258:  CALL   FF2E
....................     
....................    data_available = TRUE; 
1025C:  MOVLW  01
1025E:  MOVLB  3
10260:  MOVWF  x3B
....................    macro_flag = 900; 
10262:  MOVLW  03
10264:  MOVWF  x24
10266:  MOVLW  84
10268:  MOVWF  x23
1026A:  MOVLB  0
1026C:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
1026E:  MOVLB  8
10270:  CLRF   x8B
10272:  CLRF   x8A
....................    channel=channel-20000; 
10274:  MOVLW  20
10276:  SUBWF  x87,F
10278:  MOVLW  4E
1027A:  SUBWFB x88,F
....................     
....................    for (i=0; i<9; i++){ 
1027C:  CLRF   x89
1027E:  MOVF   x89,W
10280:  SUBLW  08
10282:  BNC   10324
....................       DAC_set(channel, setting); 
10284:  MOVFF  887,8D3
10288:  MOVFF  88B,8D5
1028C:  MOVFF  88A,8D4
10290:  MOVLB  0
10292:  CALL   F53C
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
10296:  MOVLW  36
10298:  MOVWF  FF6
1029A:  MOVLW  1D
1029C:  MOVWF  FF7
1029E:  MOVLW  00
102A0:  MOVWF  FF8
102A2:  CLRF   1B
102A4:  BTFSC  FF2.7
102A6:  BSF    1B.7
102A8:  BCF    FF2.7
102AA:  MOVLW  05
102AC:  MOVLB  A
102AE:  MOVWF  x40
102B0:  MOVLB  0
102B2:  CALL   1024
102B6:  BTFSC  1B.7
102B8:  BSF    FF2.7
102BA:  MOVLW  10
102BC:  MOVWF  FE9
102BE:  CLRF   1B
102C0:  BTFSC  FF2.7
102C2:  BSF    1B.7
102C4:  BCF    FF2.7
102C6:  MOVFF  888,A41
102CA:  MOVFF  887,A40
102CE:  CALL   11A6
102D2:  BTFSC  1B.7
102D4:  BSF    FF2.7
102D6:  MOVLW  2C
102D8:  BTFSS  F9E.4
102DA:  BRA    102D8
102DC:  MOVWF  FAD
102DE:  MOVLW  10
102E0:  MOVWF  FE9
102E2:  CLRF   1B
102E4:  BTFSC  FF2.7
102E6:  BSF    1B.7
102E8:  BCF    FF2.7
102EA:  MOVFF  88B,A41
102EE:  MOVFF  88A,A40
102F2:  CALL   11A6
102F6:  BTFSC  1B.7
102F8:  BSF    FF2.7
102FA:  MOVLW  2C
102FC:  BTFSS  F9E.4
102FE:  BRA    102FC
10300:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
10302:  MOVLB  8
10304:  CLRF   xC3
10306:  MOVLW  C8
10308:  MOVWF  xC2
1030A:  CLRF   xC4
1030C:  MOVLW  01
1030E:  MOVWF  xC5
10310:  MOVWF  xC6
10312:  MOVLB  0
10314:  RCALL  10000
....................       setting = setting+500; 
10316:  MOVLW  F4
10318:  MOVLB  8
1031A:  ADDWF  x8A,F
1031C:  MOVLW  01
1031E:  ADDWFC x8B,F
10320:  INCF   x89,F
10322:  BRA    1027E
....................    } 
10324:  MOVLB  0
10326:  GOTO   10482 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
1032A:  MOVLB  8
1032C:  CLRF   x87
1032E:  CLRF   x86
....................     
....................    for (i=0; i<9; i++){ 
10330:  CLRF   x85
10332:  MOVF   x85,W
10334:  SUBLW  08
10336:  BNC   103B0
....................       LED_SAR(intensity); 
10338:  MOVFF  887,8C9
1033C:  MOVFF  886,8C8
10340:  MOVLB  0
10342:  CALL   F7EE
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
10346:  MOVLW  44
10348:  MOVWF  FF6
1034A:  MOVLW  1D
1034C:  MOVWF  FF7
1034E:  MOVLW  00
10350:  MOVWF  FF8
10352:  CLRF   1B
10354:  BTFSC  FF2.7
10356:  BSF    1B.7
10358:  BCF    FF2.7
1035A:  MOVLW  07
1035C:  MOVLB  A
1035E:  MOVWF  x40
10360:  MOVLB  0
10362:  CALL   1024
10366:  BTFSC  1B.7
10368:  BSF    FF2.7
1036A:  MOVLW  10
1036C:  MOVWF  FE9
1036E:  CLRF   1B
10370:  BTFSC  FF2.7
10372:  BSF    1B.7
10374:  BCF    FF2.7
10376:  MOVFF  887,A41
1037A:  MOVFF  886,A40
1037E:  CALL   11A6
10382:  BTFSC  1B.7
10384:  BSF    FF2.7
10386:  MOVLW  2C
10388:  BTFSS  F9E.4
1038A:  BRA    10388
1038C:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1038E:  MOVLB  8
10390:  CLRF   xC3
10392:  MOVLW  C8
10394:  MOVWF  xC2
10396:  CLRF   xC4
10398:  MOVLW  01
1039A:  MOVWF  xC5
1039C:  MOVWF  xC6
1039E:  MOVLB  0
103A0:  RCALL  10000
....................       intensity = intensity+500; 
103A2:  MOVLW  F4
103A4:  MOVLB  8
103A6:  ADDWF  x86,F
103A8:  MOVLW  01
103AA:  ADDWFC x87,F
103AC:  INCF   x85,F
103AE:  BRA    10332
....................    } 
103B0:  MOVLB  0
103B2:  GOTO   10482 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
030BA:  MOVLB  8
030BC:  CLRF   xB6
030BE:  MOVF   xB6,W
030C0:  SUBLW  20
030C2:  BNC   30D8
030C4:  CLRF   03
030C6:  MOVF   xB6,W
030C8:  ADDLW  B7
030CA:  MOVWF  FE9
030CC:  MOVLW  04
030CE:  ADDWFC 03,W
030D0:  MOVWF  FEA
030D2:  CLRF   FEF
030D4:  INCF   xB6,F
030D6:  BRA    30BE
030D8:  MOVLB  0
030DA:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
030DC:  MOVF   2F,W
030DE:  SUBLW  02
030E0:  BNZ   30EA
030E2:  MOVF   30,F
030E4:  BNZ   30EA
030E6:  MOVLW  00
030E8:  MOVWF  F99
....................    init_valve_status(); 
030EA:  RCALL  30BA
....................    bus_pwr_status=0; 
030EC:  MOVLB  4
030EE:  CLRF   xB6
030F0:  MOVLB  0
030F2:  GOTO   1B838 (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0ED2A:  MOVLW  50
0ED2C:  MOVWF  FF6
0ED2E:  MOVLW  1D
0ED30:  MOVWF  FF7
0ED32:  MOVLW  00
0ED34:  MOVWF  FF8
0ED36:  CLRF   1B
0ED38:  BTFSC  FF2.7
0ED3A:  BSF    1B.7
0ED3C:  BCF    FF2.7
0ED3E:  CALL   0E4E
0ED42:  BTFSC  1B.7
0ED44:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0ED46:  MOVLW  01
0ED48:  MOVLB  8
0ED4A:  MOVWF  xB6
0ED4C:  MOVF   xB6,W
0ED4E:  SUBLW  08
0ED50:  BNC   EDBA
0ED52:  CLRF   03
0ED54:  MOVF   xB6,W
0ED56:  ADDLW  B7
0ED58:  MOVWF  FE9
0ED5A:  MOVLW  04
0ED5C:  ADDWFC 03,W
0ED5E:  MOVWF  FEA
0ED60:  MOVFF  FEF,8B7
0ED64:  CLRF   1B
0ED66:  BTFSC  FF2.7
0ED68:  BSF    1B.7
0ED6A:  BCF    FF2.7
0ED6C:  MOVFF  8B6,A40
0ED70:  MOVLW  01
0ED72:  MOVLB  A
0ED74:  MOVWF  x41
0ED76:  MOVLB  0
0ED78:  CALL   0FA6
0ED7C:  BTFSC  1B.7
0ED7E:  BSF    FF2.7
0ED80:  MOVLW  5B
0ED82:  BTFSS  F9E.4
0ED84:  BRA    ED82
0ED86:  MOVWF  FAD
0ED88:  CLRF   1B
0ED8A:  BTFSC  FF2.7
0ED8C:  BSF    1B.7
0ED8E:  BCF    FF2.7
0ED90:  MOVFF  8B7,A40
0ED94:  MOVLW  1B
0ED96:  MOVLB  A
0ED98:  MOVWF  x41
0ED9A:  MOVLB  0
0ED9C:  CALL   0FA6
0EDA0:  BTFSC  1B.7
0EDA2:  BSF    FF2.7
0EDA4:  MOVLW  5D
0EDA6:  BTFSS  F9E.4
0EDA8:  BRA    EDA6
0EDAA:  MOVWF  FAD
0EDAC:  MOVLW  20
0EDAE:  BTFSS  F9E.4
0EDB0:  BRA    EDAE
0EDB2:  MOVWF  FAD
0EDB4:  MOVLB  8
0EDB6:  INCF   xB6,F
0EDB8:  BRA    ED4C
....................    fprintf(COM_A, "\r\n"); 
0EDBA:  MOVLW  0D
0EDBC:  BTFSS  F9E.4
0EDBE:  BRA    EDBC
0EDC0:  MOVWF  FAD
0EDC2:  MOVLW  0A
0EDC4:  BTFSS  F9E.4
0EDC6:  BRA    EDC4
0EDC8:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EDCA:  MOVLW  56
0EDCC:  MOVWF  FF6
0EDCE:  MOVLW  1D
0EDD0:  MOVWF  FF7
0EDD2:  MOVLW  00
0EDD4:  MOVWF  FF8
0EDD6:  CLRF   1B
0EDD8:  BTFSC  FF2.7
0EDDA:  BSF    1B.7
0EDDC:  BCF    FF2.7
0EDDE:  MOVLB  0
0EDE0:  CALL   0E4E
0EDE4:  BTFSC  1B.7
0EDE6:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EDE8:  MOVLW  09
0EDEA:  MOVLB  8
0EDEC:  MOVWF  xB6
0EDEE:  MOVF   xB6,W
0EDF0:  SUBLW  10
0EDF2:  BNC   EE5C
0EDF4:  CLRF   03
0EDF6:  MOVF   xB6,W
0EDF8:  ADDLW  B7
0EDFA:  MOVWF  FE9
0EDFC:  MOVLW  04
0EDFE:  ADDWFC 03,W
0EE00:  MOVWF  FEA
0EE02:  MOVFF  FEF,8B7
0EE06:  CLRF   1B
0EE08:  BTFSC  FF2.7
0EE0A:  BSF    1B.7
0EE0C:  BCF    FF2.7
0EE0E:  MOVFF  8B6,A40
0EE12:  MOVLW  01
0EE14:  MOVLB  A
0EE16:  MOVWF  x41
0EE18:  MOVLB  0
0EE1A:  CALL   0FA6
0EE1E:  BTFSC  1B.7
0EE20:  BSF    FF2.7
0EE22:  MOVLW  5B
0EE24:  BTFSS  F9E.4
0EE26:  BRA    EE24
0EE28:  MOVWF  FAD
0EE2A:  CLRF   1B
0EE2C:  BTFSC  FF2.7
0EE2E:  BSF    1B.7
0EE30:  BCF    FF2.7
0EE32:  MOVFF  8B7,A40
0EE36:  MOVLW  1B
0EE38:  MOVLB  A
0EE3A:  MOVWF  x41
0EE3C:  MOVLB  0
0EE3E:  CALL   0FA6
0EE42:  BTFSC  1B.7
0EE44:  BSF    FF2.7
0EE46:  MOVLW  5D
0EE48:  BTFSS  F9E.4
0EE4A:  BRA    EE48
0EE4C:  MOVWF  FAD
0EE4E:  MOVLW  20
0EE50:  BTFSS  F9E.4
0EE52:  BRA    EE50
0EE54:  MOVWF  FAD
0EE56:  MOVLB  8
0EE58:  INCF   xB6,F
0EE5A:  BRA    EDEE
....................    fprintf(COM_A, "\r\n"); 
0EE5C:  MOVLW  0D
0EE5E:  BTFSS  F9E.4
0EE60:  BRA    EE5E
0EE62:  MOVWF  FAD
0EE64:  MOVLW  0A
0EE66:  BTFSS  F9E.4
0EE68:  BRA    EE66
0EE6A:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EE6C:  MOVLW  5C
0EE6E:  MOVWF  FF6
0EE70:  MOVLW  1D
0EE72:  MOVWF  FF7
0EE74:  MOVLW  00
0EE76:  MOVWF  FF8
0EE78:  CLRF   1B
0EE7A:  BTFSC  FF2.7
0EE7C:  BSF    1B.7
0EE7E:  BCF    FF2.7
0EE80:  MOVLB  0
0EE82:  CALL   0E4E
0EE86:  BTFSC  1B.7
0EE88:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EE8A:  MOVLW  11
0EE8C:  MOVLB  8
0EE8E:  MOVWF  xB6
0EE90:  MOVF   xB6,W
0EE92:  SUBLW  18
0EE94:  BNC   EEFE
0EE96:  CLRF   03
0EE98:  MOVF   xB6,W
0EE9A:  ADDLW  B7
0EE9C:  MOVWF  FE9
0EE9E:  MOVLW  04
0EEA0:  ADDWFC 03,W
0EEA2:  MOVWF  FEA
0EEA4:  MOVFF  FEF,8B7
0EEA8:  CLRF   1B
0EEAA:  BTFSC  FF2.7
0EEAC:  BSF    1B.7
0EEAE:  BCF    FF2.7
0EEB0:  MOVFF  8B6,A40
0EEB4:  MOVLW  01
0EEB6:  MOVLB  A
0EEB8:  MOVWF  x41
0EEBA:  MOVLB  0
0EEBC:  CALL   0FA6
0EEC0:  BTFSC  1B.7
0EEC2:  BSF    FF2.7
0EEC4:  MOVLW  5B
0EEC6:  BTFSS  F9E.4
0EEC8:  BRA    EEC6
0EECA:  MOVWF  FAD
0EECC:  CLRF   1B
0EECE:  BTFSC  FF2.7
0EED0:  BSF    1B.7
0EED2:  BCF    FF2.7
0EED4:  MOVFF  8B7,A40
0EED8:  MOVLW  1B
0EEDA:  MOVLB  A
0EEDC:  MOVWF  x41
0EEDE:  MOVLB  0
0EEE0:  CALL   0FA6
0EEE4:  BTFSC  1B.7
0EEE6:  BSF    FF2.7
0EEE8:  MOVLW  5D
0EEEA:  BTFSS  F9E.4
0EEEC:  BRA    EEEA
0EEEE:  MOVWF  FAD
0EEF0:  MOVLW  20
0EEF2:  BTFSS  F9E.4
0EEF4:  BRA    EEF2
0EEF6:  MOVWF  FAD
0EEF8:  MOVLB  8
0EEFA:  INCF   xB6,F
0EEFC:  BRA    EE90
....................    fprintf(COM_A, "\r\n"); 
0EEFE:  MOVLW  0D
0EF00:  BTFSS  F9E.4
0EF02:  BRA    EF00
0EF04:  MOVWF  FAD
0EF06:  MOVLW  0A
0EF08:  BTFSS  F9E.4
0EF0A:  BRA    EF08
0EF0C:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EF0E:  MOVLW  62
0EF10:  MOVWF  FF6
0EF12:  MOVLW  1D
0EF14:  MOVWF  FF7
0EF16:  MOVLW  00
0EF18:  MOVWF  FF8
0EF1A:  CLRF   1B
0EF1C:  BTFSC  FF2.7
0EF1E:  BSF    1B.7
0EF20:  BCF    FF2.7
0EF22:  MOVLB  0
0EF24:  CALL   0E4E
0EF28:  BTFSC  1B.7
0EF2A:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EF2C:  MOVLW  19
0EF2E:  MOVLB  8
0EF30:  MOVWF  xB6
0EF32:  MOVF   xB6,W
0EF34:  SUBLW  20
0EF36:  BNC   EFA0
0EF38:  CLRF   03
0EF3A:  MOVF   xB6,W
0EF3C:  ADDLW  B7
0EF3E:  MOVWF  FE9
0EF40:  MOVLW  04
0EF42:  ADDWFC 03,W
0EF44:  MOVWF  FEA
0EF46:  MOVFF  FEF,8B7
0EF4A:  CLRF   1B
0EF4C:  BTFSC  FF2.7
0EF4E:  BSF    1B.7
0EF50:  BCF    FF2.7
0EF52:  MOVFF  8B6,A40
0EF56:  MOVLW  01
0EF58:  MOVLB  A
0EF5A:  MOVWF  x41
0EF5C:  MOVLB  0
0EF5E:  CALL   0FA6
0EF62:  BTFSC  1B.7
0EF64:  BSF    FF2.7
0EF66:  MOVLW  5B
0EF68:  BTFSS  F9E.4
0EF6A:  BRA    EF68
0EF6C:  MOVWF  FAD
0EF6E:  CLRF   1B
0EF70:  BTFSC  FF2.7
0EF72:  BSF    1B.7
0EF74:  BCF    FF2.7
0EF76:  MOVFF  8B7,A40
0EF7A:  MOVLW  1B
0EF7C:  MOVLB  A
0EF7E:  MOVWF  x41
0EF80:  MOVLB  0
0EF82:  CALL   0FA6
0EF86:  BTFSC  1B.7
0EF88:  BSF    FF2.7
0EF8A:  MOVLW  5D
0EF8C:  BTFSS  F9E.4
0EF8E:  BRA    EF8C
0EF90:  MOVWF  FAD
0EF92:  MOVLW  20
0EF94:  BTFSS  F9E.4
0EF96:  BRA    EF94
0EF98:  MOVWF  FAD
0EF9A:  MOVLB  8
0EF9C:  INCF   xB6,F
0EF9E:  BRA    EF32
....................    fprintf(COM_A, "\r\n");    
0EFA0:  MOVLW  0D
0EFA2:  BTFSS  F9E.4
0EFA4:  BRA    EFA2
0EFA6:  MOVWF  FAD
0EFA8:  MOVLW  0A
0EFAA:  BTFSS  F9E.4
0EFAC:  BRA    EFAA
0EFAE:  MOVWF  FAD
0EFB0:  MOVLB  0
0EFB2:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
1446E:  MOVF   1F,W
14470:  SUBLW  04
14472:  BNZ   144DC
14474:  MOVF   20,F
14476:  BNZ   144DC
14478:  MOVLW  68
1447A:  MOVWF  FF6
1447C:  MOVLW  1D
1447E:  MOVWF  FF7
14480:  MOVLW  00
14482:  MOVWF  FF8
14484:  CLRF   1B
14486:  BTFSC  FF2.7
14488:  BSF    1B.7
1448A:  BCF    FF2.7
1448C:  MOVLW  0C
1448E:  MOVLB  A
14490:  MOVWF  x40
14492:  MOVLB  0
14494:  CALL   1024
14498:  BTFSC  1B.7
1449A:  BSF    FF2.7
1449C:  MOVLW  10
1449E:  MOVWF  FE9
144A0:  CLRF   1B
144A2:  BTFSC  FF2.7
144A4:  BSF    1B.7
144A6:  BCF    FF2.7
144A8:  MOVFF  8B7,A41
144AC:  MOVFF  8B6,A40
144B0:  CALL   11A6
144B4:  BTFSC  1B.7
144B6:  BSF    FF2.7
144B8:  MOVLW  77
144BA:  MOVWF  FF6
144BC:  MOVLW  1D
144BE:  MOVWF  FF7
144C0:  MOVLW  00
144C2:  MOVWF  FF8
144C4:  CLRF   1B
144C6:  BTFSC  FF2.7
144C8:  BSF    1B.7
144CA:  BCF    FF2.7
144CC:  MOVLW  03
144CE:  MOVLB  A
144D0:  MOVWF  x40
144D2:  MOVLB  0
144D4:  CALL   1024
144D8:  BTFSC  1B.7
144DA:  BSF    FF2.7
....................  
....................    multidrop_on(); 
144DC:  CALL   DA3C
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
144E0:  MOVLW  7C
144E2:  MOVWF  FF6
144E4:  MOVLW  1D
144E6:  MOVWF  FF7
144E8:  MOVLW  00
144EA:  MOVWF  FF8
144EC:  MOVLW  03
144EE:  MOVLB  8
144F0:  MOVWF  xB8
144F2:  MOVLB  0
144F4:  CALL   DA50
144F8:  MOVLW  10
144FA:  MOVWF  FE9
144FC:  MOVFF  8B7,8B9
14500:  MOVFF  8B6,8B8
14504:  BRA    143B4
14506:  MOVLW  0D
14508:  BTFSS  FA4.4
1450A:  BRA    14508
1450C:  MOVLB  F
1450E:  MOVWF  x1C
....................    multidrop_off(); 
14510:  MOVLB  0
14512:  CALL   DB28
....................  
....................    delay_ms(100); 
14516:  MOVLW  64
14518:  MOVLB  9
1451A:  MOVWF  xEC
1451C:  MOVLB  0
1451E:  CALL   2910
14522:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0DB7A:  MOVF   1F,W
0DB7C:  SUBLW  04
0DB7E:  BNZ   DBE8
0DB80:  MOVF   20,F
0DB82:  BNZ   DBE8
0DB84:  MOVLW  84
0DB86:  MOVWF  FF6
0DB88:  MOVLW  1D
0DB8A:  MOVWF  FF7
0DB8C:  MOVLW  00
0DB8E:  MOVWF  FF8
0DB90:  CLRF   1B
0DB92:  BTFSC  FF2.7
0DB94:  BSF    1B.7
0DB96:  BCF    FF2.7
0DB98:  MOVLW  0C
0DB9A:  MOVLB  A
0DB9C:  MOVWF  x40
0DB9E:  MOVLB  0
0DBA0:  CALL   1024
0DBA4:  BTFSC  1B.7
0DBA6:  BSF    FF2.7
0DBA8:  CLRF   1B
0DBAA:  BTFSC  FF2.7
0DBAC:  BSF    1B.7
0DBAE:  BCF    FF2.7
0DBB0:  MOVFF  8B6,A40
0DBB4:  MOVLW  1B
0DBB6:  MOVLB  A
0DBB8:  MOVWF  x41
0DBBA:  MOVLB  0
0DBBC:  CALL   0FA6
0DBC0:  BTFSC  1B.7
0DBC2:  BSF    FF2.7
0DBC4:  MOVLW  92
0DBC6:  MOVWF  FF6
0DBC8:  MOVLW  1D
0DBCA:  MOVWF  FF7
0DBCC:  MOVLW  00
0DBCE:  MOVWF  FF8
0DBD0:  CLRF   1B
0DBD2:  BTFSC  FF2.7
0DBD4:  BSF    1B.7
0DBD6:  BCF    FF2.7
0DBD8:  MOVLW  03
0DBDA:  MOVLB  A
0DBDC:  MOVWF  x40
0DBDE:  MOVLB  0
0DBE0:  CALL   1024
0DBE4:  BTFSC  1B.7
0DBE6:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0DBE8:  RCALL  DA3C
....................       fprintf(COM_B, "/1c%u\r",chip); 
0DBEA:  MOVLW  96
0DBEC:  MOVWF  FF6
0DBEE:  MOVLW  1D
0DBF0:  MOVWF  FF7
0DBF2:  MOVLW  00
0DBF4:  MOVWF  FF8
0DBF6:  MOVLW  03
0DBF8:  MOVLB  8
0DBFA:  MOVWF  xB8
0DBFC:  MOVLB  0
0DBFE:  RCALL  DA50
0DC00:  MOVFF  8B6,8F3
0DC04:  MOVLW  1B
0DC06:  MOVLB  8
0DC08:  MOVWF  xF4
0DC0A:  MOVLB  0
0DC0C:  RCALL  DA84
0DC0E:  MOVLW  0D
0DC10:  BTFSS  FA4.4
0DC12:  BRA    DC10
0DC14:  MOVLB  F
0DC16:  MOVWF  x1C
....................    multidrop_off(); 
0DC18:  MOVLB  0
0DC1A:  RCALL  DB28
....................    delay_ms(100); 
0DC1C:  MOVLW  64
0DC1E:  MOVLB  9
0DC20:  MOVWF  xEC
0DC22:  MOVLB  0
0DC24:  CALL   2910
....................  
....................    multidrop_on(); 
0DC28:  RCALL  DA3C
....................      fprintf(COM_B, "/1s256\r"); 
0DC2A:  MOVLW  9E
0DC2C:  MOVWF  FF6
0DC2E:  MOVLW  1D
0DC30:  MOVWF  FF7
0DC32:  MOVLW  00
0DC34:  MOVWF  FF8
0DC36:  BRA    DB4A
....................    multidrop_off();  
0DC38:  RCALL  DB28
....................    delay_ms(100); 
0DC3A:  MOVLW  64
0DC3C:  MOVLB  9
0DC3E:  MOVWF  xEC
0DC40:  MOVLB  0
0DC42:  CALL   2910
0DC46:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
14524:  MOVLB  8
14526:  MOVF   xB5,W
14528:  ADDLW  DF
1452A:  BTFSC  FD8.0
1452C:  BRA    14918
1452E:  ADDLW  21
14530:  MOVLB  0
14532:  GOTO   1494A
....................       case 0 : sol_chip_cmd(1); 
14536:  MOVLW  01
14538:  MOVLB  8
1453A:  MOVWF  xB6
1453C:  MOVLB  0
1453E:  CALL   DB7A
....................                sol_switch_cmd(0); 
14542:  MOVLB  8
14544:  CLRF   xB7
14546:  CLRF   xB6
14548:  MOVLB  0
1454A:  RCALL  1446E
....................                sol_chip_cmd(2); 
1454C:  MOVLW  02
1454E:  MOVLB  8
14550:  MOVWF  xB6
14552:  MOVLB  0
14554:  CALL   DB7A
....................                sol_switch_cmd(0); 
14558:  MOVLB  8
1455A:  CLRF   xB7
1455C:  CLRF   xB6
1455E:  MOVLB  0
14560:  RCALL  1446E
....................                sol_chip_cmd(3); 
14562:  MOVLW  03
14564:  MOVLB  8
14566:  MOVWF  xB6
14568:  MOVLB  0
1456A:  CALL   DB7A
....................                sol_switch_cmd(0); 
1456E:  MOVLB  8
14570:  CLRF   xB7
14572:  CLRF   xB6
14574:  MOVLB  0
14576:  RCALL  1446E
....................                sol_chip_cmd(4); 
14578:  MOVLW  04
1457A:  MOVLB  8
1457C:  MOVWF  xB6
1457E:  MOVLB  0
14580:  CALL   DB7A
....................                sol_switch_cmd(0); 
14584:  MOVLB  8
14586:  CLRF   xB7
14588:  CLRF   xB6
1458A:  MOVLB  0
1458C:  RCALL  1446E
....................                init_valve_status(); 
1458E:  CALL   30BA
....................          break; 
14592:  MOVLB  8
14594:  BRA    14918
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
14596:  MOVLW  01
14598:  MOVLB  8
1459A:  MOVWF  xB6
1459C:  MOVLB  0
1459E:  CALL   DB7A
....................                sol_switch_cmd(1); 
145A2:  MOVLB  8
145A4:  CLRF   xB7
145A6:  MOVLW  01
145A8:  MOVWF  xB6
145AA:  MOVLB  0
145AC:  RCALL  1446E
....................          break;     
145AE:  MOVLB  8
145B0:  BRA    14918
....................       case 2 : sol_chip_cmd(1); 
145B2:  MOVLW  01
145B4:  MOVLB  8
145B6:  MOVWF  xB6
145B8:  MOVLB  0
145BA:  CALL   DB7A
....................                sol_switch_cmd(2); 
145BE:  MOVLB  8
145C0:  CLRF   xB7
145C2:  MOVLW  02
145C4:  MOVWF  xB6
145C6:  MOVLB  0
145C8:  RCALL  1446E
....................          break;           
145CA:  MOVLB  8
145CC:  BRA    14918
....................       case 3 : sol_chip_cmd(1); 
145CE:  MOVLW  01
145D0:  MOVLB  8
145D2:  MOVWF  xB6
145D4:  MOVLB  0
145D6:  CALL   DB7A
....................                sol_switch_cmd(4); 
145DA:  MOVLB  8
145DC:  CLRF   xB7
145DE:  MOVLW  04
145E0:  MOVWF  xB6
145E2:  MOVLB  0
145E4:  RCALL  1446E
....................          break;  
145E6:  MOVLB  8
145E8:  BRA    14918
....................       case 4 : sol_chip_cmd(1); 
145EA:  MOVLW  01
145EC:  MOVLB  8
145EE:  MOVWF  xB6
145F0:  MOVLB  0
145F2:  CALL   DB7A
....................                sol_switch_cmd(8); 
145F6:  MOVLB  8
145F8:  CLRF   xB7
145FA:  MOVLW  08
145FC:  MOVWF  xB6
145FE:  MOVLB  0
14600:  RCALL  1446E
....................          break;  
14602:  MOVLB  8
14604:  BRA    14918
....................       case 5 : sol_chip_cmd(1); 
14606:  MOVLW  01
14608:  MOVLB  8
1460A:  MOVWF  xB6
1460C:  MOVLB  0
1460E:  CALL   DB7A
....................                sol_switch_cmd(16); 
14612:  MOVLB  8
14614:  CLRF   xB7
14616:  MOVLW  10
14618:  MOVWF  xB6
1461A:  MOVLB  0
1461C:  RCALL  1446E
....................          break;  
1461E:  MOVLB  8
14620:  BRA    14918
....................       case 6 : sol_chip_cmd(1); 
14622:  MOVLW  01
14624:  MOVLB  8
14626:  MOVWF  xB6
14628:  MOVLB  0
1462A:  CALL   DB7A
....................                sol_switch_cmd(32); 
1462E:  MOVLB  8
14630:  CLRF   xB7
14632:  MOVLW  20
14634:  MOVWF  xB6
14636:  MOVLB  0
14638:  RCALL  1446E
....................          break;  
1463A:  MOVLB  8
1463C:  BRA    14918
....................       case 7 : sol_chip_cmd(1); 
1463E:  MOVLW  01
14640:  MOVLB  8
14642:  MOVWF  xB6
14644:  MOVLB  0
14646:  CALL   DB7A
....................                sol_switch_cmd(64); 
1464A:  MOVLB  8
1464C:  CLRF   xB7
1464E:  MOVLW  40
14650:  MOVWF  xB6
14652:  MOVLB  0
14654:  RCALL  1446E
....................          break;  
14656:  MOVLB  8
14658:  BRA    14918
....................       case 8 : sol_chip_cmd(1); 
1465A:  MOVLW  01
1465C:  MOVLB  8
1465E:  MOVWF  xB6
14660:  MOVLB  0
14662:  CALL   DB7A
....................                sol_switch_cmd(128); 
14666:  MOVLB  8
14668:  CLRF   xB7
1466A:  MOVLW  80
1466C:  MOVWF  xB6
1466E:  MOVLB  0
14670:  RCALL  1446E
....................          break;   
14672:  MOVLB  8
14674:  BRA    14918
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
14676:  MOVLW  02
14678:  MOVLB  8
1467A:  MOVWF  xB6
1467C:  MOVLB  0
1467E:  CALL   DB7A
....................                sol_switch_cmd(1); 
14682:  MOVLB  8
14684:  CLRF   xB7
14686:  MOVLW  01
14688:  MOVWF  xB6
1468A:  MOVLB  0
1468C:  RCALL  1446E
....................          break;     
1468E:  MOVLB  8
14690:  BRA    14918
....................       case 10 : sol_chip_cmd(2); 
14692:  MOVLW  02
14694:  MOVLB  8
14696:  MOVWF  xB6
14698:  MOVLB  0
1469A:  CALL   DB7A
....................                sol_switch_cmd(2); 
1469E:  MOVLB  8
146A0:  CLRF   xB7
146A2:  MOVLW  02
146A4:  MOVWF  xB6
146A6:  MOVLB  0
146A8:  RCALL  1446E
....................          break;           
146AA:  MOVLB  8
146AC:  BRA    14918
....................       case 11 : sol_chip_cmd(2); 
146AE:  MOVLW  02
146B0:  MOVLB  8
146B2:  MOVWF  xB6
146B4:  MOVLB  0
146B6:  CALL   DB7A
....................                sol_switch_cmd(4); 
146BA:  MOVLB  8
146BC:  CLRF   xB7
146BE:  MOVLW  04
146C0:  MOVWF  xB6
146C2:  MOVLB  0
146C4:  RCALL  1446E
....................          break;  
146C6:  MOVLB  8
146C8:  BRA    14918
....................       case 12 : sol_chip_cmd(2); 
146CA:  MOVLW  02
146CC:  MOVLB  8
146CE:  MOVWF  xB6
146D0:  MOVLB  0
146D2:  CALL   DB7A
....................                sol_switch_cmd(8); 
146D6:  MOVLB  8
146D8:  CLRF   xB7
146DA:  MOVLW  08
146DC:  MOVWF  xB6
146DE:  MOVLB  0
146E0:  RCALL  1446E
....................          break;  
146E2:  MOVLB  8
146E4:  BRA    14918
....................       case 13 : sol_chip_cmd(2); 
146E6:  MOVLW  02
146E8:  MOVLB  8
146EA:  MOVWF  xB6
146EC:  MOVLB  0
146EE:  CALL   DB7A
....................                sol_switch_cmd(16); 
146F2:  MOVLB  8
146F4:  CLRF   xB7
146F6:  MOVLW  10
146F8:  MOVWF  xB6
146FA:  MOVLB  0
146FC:  RCALL  1446E
....................          break;  
146FE:  MOVLB  8
14700:  BRA    14918
....................       case 14 : sol_chip_cmd(2); 
14702:  MOVLW  02
14704:  MOVLB  8
14706:  MOVWF  xB6
14708:  MOVLB  0
1470A:  CALL   DB7A
....................                sol_switch_cmd(32); 
1470E:  MOVLB  8
14710:  CLRF   xB7
14712:  MOVLW  20
14714:  MOVWF  xB6
14716:  MOVLB  0
14718:  RCALL  1446E
....................          break;  
1471A:  MOVLB  8
1471C:  BRA    14918
....................       case 15 : sol_chip_cmd(2); 
1471E:  MOVLW  02
14720:  MOVLB  8
14722:  MOVWF  xB6
14724:  MOVLB  0
14726:  CALL   DB7A
....................                sol_switch_cmd(64); 
1472A:  MOVLB  8
1472C:  CLRF   xB7
1472E:  MOVLW  40
14730:  MOVWF  xB6
14732:  MOVLB  0
14734:  RCALL  1446E
....................          break;  
14736:  MOVLB  8
14738:  BRA    14918
....................       case 16 : sol_chip_cmd(2); 
1473A:  MOVLW  02
1473C:  MOVLB  8
1473E:  MOVWF  xB6
14740:  MOVLB  0
14742:  CALL   DB7A
....................                sol_switch_cmd(128); 
14746:  MOVLB  8
14748:  CLRF   xB7
1474A:  MOVLW  80
1474C:  MOVWF  xB6
1474E:  MOVLB  0
14750:  RCALL  1446E
....................          break;   
14752:  MOVLB  8
14754:  BRA    14918
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
14756:  MOVLW  03
14758:  MOVLB  8
1475A:  MOVWF  xB6
1475C:  MOVLB  0
1475E:  CALL   DB7A
....................                sol_switch_cmd(1); 
14762:  MOVLB  8
14764:  CLRF   xB7
14766:  MOVLW  01
14768:  MOVWF  xB6
1476A:  MOVLB  0
1476C:  RCALL  1446E
....................          break;     
1476E:  MOVLB  8
14770:  BRA    14918
....................       case 18 : sol_chip_cmd(3); 
14772:  MOVLW  03
14774:  MOVLB  8
14776:  MOVWF  xB6
14778:  MOVLB  0
1477A:  CALL   DB7A
....................                sol_switch_cmd(2); 
1477E:  MOVLB  8
14780:  CLRF   xB7
14782:  MOVLW  02
14784:  MOVWF  xB6
14786:  MOVLB  0
14788:  RCALL  1446E
....................          break;           
1478A:  MOVLB  8
1478C:  BRA    14918
....................       case 19 : sol_chip_cmd(3); 
1478E:  MOVLW  03
14790:  MOVLB  8
14792:  MOVWF  xB6
14794:  MOVLB  0
14796:  CALL   DB7A
....................                sol_switch_cmd(4); 
1479A:  MOVLB  8
1479C:  CLRF   xB7
1479E:  MOVLW  04
147A0:  MOVWF  xB6
147A2:  MOVLB  0
147A4:  RCALL  1446E
....................          break;  
147A6:  MOVLB  8
147A8:  BRA    14918
....................       case 20 : sol_chip_cmd(3); 
147AA:  MOVLW  03
147AC:  MOVLB  8
147AE:  MOVWF  xB6
147B0:  MOVLB  0
147B2:  CALL   DB7A
....................                sol_switch_cmd(8); 
147B6:  MOVLB  8
147B8:  CLRF   xB7
147BA:  MOVLW  08
147BC:  MOVWF  xB6
147BE:  MOVLB  0
147C0:  RCALL  1446E
....................          break;  
147C2:  MOVLB  8
147C4:  BRA    14918
....................       case 21 : sol_chip_cmd(3); 
147C6:  MOVLW  03
147C8:  MOVLB  8
147CA:  MOVWF  xB6
147CC:  MOVLB  0
147CE:  CALL   DB7A
....................                sol_switch_cmd(16); 
147D2:  MOVLB  8
147D4:  CLRF   xB7
147D6:  MOVLW  10
147D8:  MOVWF  xB6
147DA:  MOVLB  0
147DC:  RCALL  1446E
....................          break;  
147DE:  MOVLB  8
147E0:  BRA    14918
....................       case 22 : sol_chip_cmd(3); 
147E2:  MOVLW  03
147E4:  MOVLB  8
147E6:  MOVWF  xB6
147E8:  MOVLB  0
147EA:  CALL   DB7A
....................                sol_switch_cmd(32); 
147EE:  MOVLB  8
147F0:  CLRF   xB7
147F2:  MOVLW  20
147F4:  MOVWF  xB6
147F6:  MOVLB  0
147F8:  RCALL  1446E
....................          break;  
147FA:  MOVLB  8
147FC:  BRA    14918
....................       case 23 : sol_chip_cmd(3); 
147FE:  MOVLW  03
14800:  MOVLB  8
14802:  MOVWF  xB6
14804:  MOVLB  0
14806:  CALL   DB7A
....................                sol_switch_cmd(64); 
1480A:  MOVLB  8
1480C:  CLRF   xB7
1480E:  MOVLW  40
14810:  MOVWF  xB6
14812:  MOVLB  0
14814:  RCALL  1446E
....................          break;  
14816:  MOVLB  8
14818:  BRA    14918
....................       case 24 : sol_chip_cmd(3); 
1481A:  MOVLW  03
1481C:  MOVLB  8
1481E:  MOVWF  xB6
14820:  MOVLB  0
14822:  CALL   DB7A
....................                sol_switch_cmd(128); 
14826:  MOVLB  8
14828:  CLRF   xB7
1482A:  MOVLW  80
1482C:  MOVWF  xB6
1482E:  MOVLB  0
14830:  RCALL  1446E
....................          break;      
14832:  MOVLB  8
14834:  BRA    14918
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
14836:  MOVLW  04
14838:  MOVLB  8
1483A:  MOVWF  xB6
1483C:  MOVLB  0
1483E:  CALL   DB7A
....................                sol_switch_cmd(1); 
14842:  MOVLB  8
14844:  CLRF   xB7
14846:  MOVLW  01
14848:  MOVWF  xB6
1484A:  MOVLB  0
1484C:  RCALL  1446E
....................          break;     
1484E:  MOVLB  8
14850:  BRA    14918
....................       case 26 : sol_chip_cmd(4); 
14852:  MOVLW  04
14854:  MOVLB  8
14856:  MOVWF  xB6
14858:  MOVLB  0
1485A:  CALL   DB7A
....................                sol_switch_cmd(2); 
1485E:  MOVLB  8
14860:  CLRF   xB7
14862:  MOVLW  02
14864:  MOVWF  xB6
14866:  MOVLB  0
14868:  RCALL  1446E
....................          break;           
1486A:  MOVLB  8
1486C:  BRA    14918
....................       case 27 : sol_chip_cmd(4); 
1486E:  MOVLW  04
14870:  MOVLB  8
14872:  MOVWF  xB6
14874:  MOVLB  0
14876:  CALL   DB7A
....................                sol_switch_cmd(4); 
1487A:  MOVLB  8
1487C:  CLRF   xB7
1487E:  MOVLW  04
14880:  MOVWF  xB6
14882:  MOVLB  0
14884:  RCALL  1446E
....................          break;  
14886:  MOVLB  8
14888:  BRA    14918
....................       case 28 : sol_chip_cmd(4); 
1488A:  MOVLW  04
1488C:  MOVLB  8
1488E:  MOVWF  xB6
14890:  MOVLB  0
14892:  CALL   DB7A
....................                sol_switch_cmd(8); 
14896:  MOVLB  8
14898:  CLRF   xB7
1489A:  MOVLW  08
1489C:  MOVWF  xB6
1489E:  MOVLB  0
148A0:  RCALL  1446E
....................          break;  
148A2:  MOVLB  8
148A4:  BRA    14918
....................       case 29 : sol_chip_cmd(4); 
148A6:  MOVLW  04
148A8:  MOVLB  8
148AA:  MOVWF  xB6
148AC:  MOVLB  0
148AE:  CALL   DB7A
....................                sol_switch_cmd(16); 
148B2:  MOVLB  8
148B4:  CLRF   xB7
148B6:  MOVLW  10
148B8:  MOVWF  xB6
148BA:  MOVLB  0
148BC:  RCALL  1446E
....................          break;  
148BE:  MOVLB  8
148C0:  BRA    14918
....................       case 30 : sol_chip_cmd(4); 
148C2:  MOVLW  04
148C4:  MOVLB  8
148C6:  MOVWF  xB6
148C8:  MOVLB  0
148CA:  CALL   DB7A
....................                sol_switch_cmd(32); 
148CE:  MOVLB  8
148D0:  CLRF   xB7
148D2:  MOVLW  20
148D4:  MOVWF  xB6
148D6:  MOVLB  0
148D8:  RCALL  1446E
....................          break;  
148DA:  MOVLB  8
148DC:  BRA    14918
....................       case 31 : sol_chip_cmd(4); 
148DE:  MOVLW  04
148E0:  MOVLB  8
148E2:  MOVWF  xB6
148E4:  MOVLB  0
148E6:  CALL   DB7A
....................                sol_switch_cmd(64); 
148EA:  MOVLB  8
148EC:  CLRF   xB7
148EE:  MOVLW  40
148F0:  MOVWF  xB6
148F2:  MOVLB  0
148F4:  RCALL  1446E
....................          break;  
148F6:  MOVLB  8
148F8:  BRA    14918
....................       case 32 : sol_chip_cmd(4); 
148FA:  MOVLW  04
148FC:  MOVLB  8
148FE:  MOVWF  xB6
14900:  MOVLB  0
14902:  CALL   DB7A
....................                sol_switch_cmd(128); 
14906:  MOVLB  8
14908:  CLRF   xB7
1490A:  MOVLW  80
1490C:  MOVWF  xB6
1490E:  MOVLB  0
14910:  RCALL  1446E
....................          break; 
14912:  MOVLB  8
14914:  BRA    14918
14916:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
14918:  MOVF   xB5,F
1491A:  BZ    14934
1491C:  MOVF   xB5,W
1491E:  SUBLW  20
14920:  BNC   14934
14922:  CLRF   03
14924:  MOVF   xB5,W
14926:  ADDLW  B7
14928:  MOVWF  FE9
1492A:  MOVLW  04
1492C:  ADDWFC 03,W
1492E:  MOVWF  FEA
14930:  MOVLW  01
14932:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
14934:  MOVF   1F,W
14936:  SUBLW  04
14938:  BNZ   14946
1493A:  MOVF   20,F
1493C:  BNZ   14946
1493E:  MOVLB  0
14940:  CALL   ED2A
14944:  MOVLB  8
14946:  MOVLB  0
14948:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
104C2:  MOVLB  8
104C4:  CLRF   x9D
104C6:  MOVF   x9D,W
104C8:  SUBLW  07
104CA:  BNC   104E6
104CC:  BCF    FD8.0
104CE:  RLCF   x9D,W
104D0:  CLRF   03
104D2:  ADDLW  4B
104D4:  MOVWF  FE9
104D6:  MOVLW  03
104D8:  ADDWFC 03,W
104DA:  MOVWF  FEA
104DC:  CLRF   FEC
104DE:  MOVF   FED,F
104E0:  CLRF   FEF
104E2:  INCF   x9D,F
104E4:  BRA    104C6
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
104E6:  CLRF   x9D
104E8:  MOVF   x9D,W
104EA:  SUBLW  07
104EC:  BNC   10508
104EE:  BCF    FD8.0
104F0:  RLCF   x9D,W
104F2:  CLRF   03
104F4:  ADDLW  5D
104F6:  MOVWF  FE9
104F8:  MOVLW  03
104FA:  ADDWFC 03,W
104FC:  MOVWF  FEA
104FE:  CLRF   FEC
10500:  MOVF   FED,F
10502:  CLRF   FEF
10504:  INCF   x9D,F
10506:  BRA    104E8
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
10508:  CLRF   x9D
1050A:  MOVF   x9D,W
1050C:  SUBLW  07
1050E:  BNC   1052A
10510:  BCF    FD8.0
10512:  RLCF   x9D,W
10514:  CLRF   03
10516:  ADDLW  6F
10518:  MOVWF  FE9
1051A:  MOVLW  03
1051C:  ADDWFC 03,W
1051E:  MOVWF  FEA
10520:  CLRF   FEC
10522:  MOVF   FED,F
10524:  CLRF   FEF
10526:  INCF   x9D,F
10528:  BRA    1050A
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
1052A:  CLRF   x9D
1052C:  MOVF   x9D,W
1052E:  SUBLW  07
10530:  BNC   1054C
10532:  BCF    FD8.0
10534:  RLCF   x9D,W
10536:  CLRF   03
10538:  ADDLW  81
1053A:  MOVWF  FE9
1053C:  MOVLW  03
1053E:  ADDWFC 03,W
10540:  MOVWF  FEA
10542:  CLRF   FEC
10544:  MOVF   FED,F
10546:  CLRF   FEF
10548:  INCF   x9D,F
1054A:  BRA    1052C
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
1054C:  CLRF   x9D
1054E:  MOVF   x9D,W
10550:  SUBLW  07
10552:  BNC   1056E
10554:  BCF    FD8.0
10556:  RLCF   x9D,W
10558:  CLRF   03
1055A:  ADDLW  93
1055C:  MOVWF  FE9
1055E:  MOVLW  03
10560:  ADDWFC 03,W
10562:  MOVWF  FEA
10564:  CLRF   FEC
10566:  MOVF   FED,F
10568:  CLRF   FEF
1056A:  INCF   x9D,F
1056C:  BRA    1054E
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
1056E:  MOVLW  04
10570:  MOVWF  FEA
10572:  MOVLW  25
10574:  MOVWF  FE9
10576:  CLRF   00
10578:  CLRF   02
1057A:  MOVLW  44
1057C:  MOVWF  01
1057E:  MOVLB  0
10580:  CALL   3526
10584:  GOTO   1538A (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10E10:  MOVLB  8
10E12:  CLRF   xC2
10E14:  MOVF   xC2,W
10E16:  SUBLW  03
10E18:  BNC   10E38
10E1A:  MOVF   xC2,W
10E1C:  MULLW  04
10E1E:  MOVF   FF3,W
10E20:  CLRF   03
10E22:  ADDLW  A5
10E24:  MOVWF  FE9
10E26:  MOVLW  03
10E28:  ADDWFC 03,W
10E2A:  MOVWF  FEA
10E2C:  CLRF   FEF
10E2E:  CLRF   FEC
10E30:  CLRF   FEC
10E32:  CLRF   FEC
10E34:  INCF   xC2,F
10E36:  BRA    10E14
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10E38:  MOVLB  3
10E3A:  MOVF   x4B,F
10E3C:  BTFSS  FD8.2
10E3E:  BRA    10E44
10E40:  MOVF   x4C,F
10E42:  BZ    10EDE
10E44:  MOVF   x4D,F
10E46:  BNZ   10E4C
10E48:  MOVF   x4E,F
10E4A:  BZ    10EDE
....................       blank = NO3_array[0]; 
10E4C:  MOVFF  34C,918
10E50:  MOVFF  34B,917
10E54:  MOVLB  0
10E56:  CALL   C8BA
10E5A:  MOVFF  03,8C6
10E5E:  MOVFF  02,8C5
10E62:  MOVFF  01,8C4
10E66:  MOVFF  00,8C3
....................       react = NO3_array[1]; 
10E6A:  MOVFF  34E,918
10E6E:  MOVFF  34D,917
10E72:  CALL   C8BA
10E76:  MOVFF  03,8CA
10E7A:  MOVFF  02,8C9
10E7E:  MOVFF  01,8C8
10E82:  MOVFF  00,8C7
....................       ratio = blank / react; 
10E86:  MOVFF  8C6,8FE
10E8A:  MOVFF  8C5,8FD
10E8E:  MOVFF  8C4,8FC
10E92:  MOVFF  8C3,8FB
10E96:  MOVFF  8CA,902
10E9A:  MOVFF  8C9,901
10E9E:  MOVFF  8C8,900
10EA2:  MOVFF  8C7,8FF
10EA6:  CALL   C8F0
10EAA:  MOVFF  03,8CE
10EAE:  MOVFF  02,8CD
10EB2:  MOVFF  01,8CC
10EB6:  MOVFF  00,8CB
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10EBA:  MOVFF  8CE,8D2
10EBE:  MOVFF  8CD,8D1
10EC2:  MOVFF  8CC,8D0
10EC6:  MOVFF  8CB,8CF
10ECA:  RCALL  10B8E
10ECC:  MOVFF  03,3A8
10ED0:  MOVFF  02,3A7
10ED4:  MOVFF  01,3A6
10ED8:  MOVFF  00,3A5
10EDC:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10EDE:  MOVF   x4F,F
10EE0:  BNZ   10EE6
10EE2:  MOVF   x50,F
10EE4:  BZ    10F80
10EE6:  MOVF   x51,F
10EE8:  BNZ   10EEE
10EEA:  MOVF   x52,F
10EEC:  BZ    10F80
....................       blank = NO3_array[2]; 
10EEE:  MOVFF  350,918
10EF2:  MOVFF  34F,917
10EF6:  MOVLB  0
10EF8:  CALL   C8BA
10EFC:  MOVFF  03,8C6
10F00:  MOVFF  02,8C5
10F04:  MOVFF  01,8C4
10F08:  MOVFF  00,8C3
....................       react = NO3_array[3]; 
10F0C:  MOVFF  352,918
10F10:  MOVFF  351,917
10F14:  CALL   C8BA
10F18:  MOVFF  03,8CA
10F1C:  MOVFF  02,8C9
10F20:  MOVFF  01,8C8
10F24:  MOVFF  00,8C7
....................       ratio = blank / react;    
10F28:  MOVFF  8C6,8FE
10F2C:  MOVFF  8C5,8FD
10F30:  MOVFF  8C4,8FC
10F34:  MOVFF  8C3,8FB
10F38:  MOVFF  8CA,902
10F3C:  MOVFF  8C9,901
10F40:  MOVFF  8C8,900
10F44:  MOVFF  8C7,8FF
10F48:  CALL   C8F0
10F4C:  MOVFF  03,8CE
10F50:  MOVFF  02,8CD
10F54:  MOVFF  01,8CC
10F58:  MOVFF  00,8CB
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10F5C:  MOVFF  8CE,8D2
10F60:  MOVFF  8CD,8D1
10F64:  MOVFF  8CC,8D0
10F68:  MOVFF  8CB,8CF
10F6C:  RCALL  10B8E
10F6E:  MOVFF  03,3AC
10F72:  MOVFF  02,3AB
10F76:  MOVFF  01,3AA
10F7A:  MOVFF  00,3A9
10F7E:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10F80:  MOVF   x53,F
10F82:  BNZ   10F88
10F84:  MOVF   x54,F
10F86:  BZ    11022
10F88:  MOVF   x55,F
10F8A:  BNZ   10F90
10F8C:  MOVF   x56,F
10F8E:  BZ    11022
....................       blank = NO3_array[4]; 
10F90:  MOVFF  354,918
10F94:  MOVFF  353,917
10F98:  MOVLB  0
10F9A:  CALL   C8BA
10F9E:  MOVFF  03,8C6
10FA2:  MOVFF  02,8C5
10FA6:  MOVFF  01,8C4
10FAA:  MOVFF  00,8C3
....................       react = NO3_array[5]; 
10FAE:  MOVFF  356,918
10FB2:  MOVFF  355,917
10FB6:  CALL   C8BA
10FBA:  MOVFF  03,8CA
10FBE:  MOVFF  02,8C9
10FC2:  MOVFF  01,8C8
10FC6:  MOVFF  00,8C7
....................       ratio = blank / react; 
10FCA:  MOVFF  8C6,8FE
10FCE:  MOVFF  8C5,8FD
10FD2:  MOVFF  8C4,8FC
10FD6:  MOVFF  8C3,8FB
10FDA:  MOVFF  8CA,902
10FDE:  MOVFF  8C9,901
10FE2:  MOVFF  8C8,900
10FE6:  MOVFF  8C7,8FF
10FEA:  CALL   C8F0
10FEE:  MOVFF  03,8CE
10FF2:  MOVFF  02,8CD
10FF6:  MOVFF  01,8CC
10FFA:  MOVFF  00,8CB
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
10FFE:  MOVFF  8CE,8D2
11002:  MOVFF  8CD,8D1
11006:  MOVFF  8CC,8D0
1100A:  MOVFF  8CB,8CF
1100E:  RCALL  10B8E
11010:  MOVFF  03,3B0
11014:  MOVFF  02,3AF
11018:  MOVFF  01,3AE
1101C:  MOVFF  00,3AD
11020:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
11022:  MOVF   x57,F
11024:  BNZ   1102A
11026:  MOVF   x58,F
11028:  BZ    110C4
1102A:  MOVF   x59,F
1102C:  BNZ   11032
1102E:  MOVF   x5A,F
11030:  BZ    110C4
....................       blank = NO3_array[6]; 
11032:  MOVFF  358,918
11036:  MOVFF  357,917
1103A:  MOVLB  0
1103C:  CALL   C8BA
11040:  MOVFF  03,8C6
11044:  MOVFF  02,8C5
11048:  MOVFF  01,8C4
1104C:  MOVFF  00,8C3
....................       react = NO3_array[7]; 
11050:  MOVFF  35A,918
11054:  MOVFF  359,917
11058:  CALL   C8BA
1105C:  MOVFF  03,8CA
11060:  MOVFF  02,8C9
11064:  MOVFF  01,8C8
11068:  MOVFF  00,8C7
....................       ratio = blank / react; 
1106C:  MOVFF  8C6,8FE
11070:  MOVFF  8C5,8FD
11074:  MOVFF  8C4,8FC
11078:  MOVFF  8C3,8FB
1107C:  MOVFF  8CA,902
11080:  MOVFF  8C9,901
11084:  MOVFF  8C8,900
11088:  MOVFF  8C7,8FF
1108C:  CALL   C8F0
11090:  MOVFF  03,8CE
11094:  MOVFF  02,8CD
11098:  MOVFF  01,8CC
1109C:  MOVFF  00,8CB
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
110A0:  MOVFF  8CE,8D2
110A4:  MOVFF  8CD,8D1
110A8:  MOVFF  8CC,8D0
110AC:  MOVFF  8CB,8CF
110B0:  RCALL  10B8E
110B2:  MOVFF  03,3B4
110B6:  MOVFF  02,3B3
110BA:  MOVFF  01,3B2
110BE:  MOVFF  00,3B1
110C2:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
110C4:  MOVLW  04
110C6:  MOVWF  1E
110C8:  MOVLW  25
110CA:  MOVWF  1D
110CC:  MOVLW  A6
110CE:  MOVWF  FF6
110D0:  MOVLW  1D
110D2:  MOVWF  FF7
110D4:  MOVLW  00
110D6:  MOVWF  FF8
110D8:  MOVLW  06
110DA:  MOVLB  8
110DC:  MOVWF  xEB
110DE:  MOVLB  0
110E0:  CALL   AACC
110E4:  MOVLW  10
110E6:  MOVWF  FE9
110E8:  MOVFF  34C,8F7
110EC:  MOVFF  34B,8F6
110F0:  CALL   AAFE
110F4:  MOVLW  AF
110F6:  MOVWF  FF6
110F8:  MOVLW  1D
110FA:  MOVWF  FF7
110FC:  MOVLW  00
110FE:  MOVWF  FF8
11100:  MOVLW  07
11102:  MOVLB  8
11104:  MOVWF  xEB
11106:  MOVLB  0
11108:  CALL   AACC
1110C:  MOVLW  10
1110E:  MOVWF  FE9
11110:  MOVFF  34E,8F7
11114:  MOVFF  34D,8F6
11118:  CALL   AAFE
1111C:  MOVLW  B9
1111E:  MOVWF  FF6
11120:  MOVLW  1D
11122:  MOVWF  FF7
11124:  MOVLW  00
11126:  MOVWF  FF8
11128:  MOVLW  09
1112A:  MOVLB  8
1112C:  MOVWF  xEB
1112E:  MOVLB  0
11130:  CALL   AACC
11134:  MOVLW  89
11136:  MOVWF  FE9
11138:  MOVFF  3A8,8D2
1113C:  MOVFF  3A7,8D1
11140:  MOVFF  3A6,8D0
11144:  MOVFF  3A5,8CF
11148:  MOVLW  04
1114A:  MOVLB  8
1114C:  MOVWF  xD3
1114E:  MOVLB  0
11150:  RCALL  10BFA
11152:  MOVLW  C7
11154:  MOVWF  FF6
11156:  MOVLW  1D
11158:  MOVWF  FF7
1115A:  MOVLW  00
1115C:  MOVWF  FF8
1115E:  MOVLW  07
11160:  MOVLB  8
11162:  MOVWF  xEB
11164:  MOVLB  0
11166:  CALL   AACC
1116A:  MOVLW  10
1116C:  MOVWF  FE9
1116E:  MOVFF  350,8F7
11172:  MOVFF  34F,8F6
11176:  CALL   AAFE
1117A:  MOVLW  D1
1117C:  MOVWF  FF6
1117E:  MOVLW  1D
11180:  MOVWF  FF7
11182:  MOVLW  00
11184:  MOVWF  FF8
11186:  MOVLW  07
11188:  MOVLB  8
1118A:  MOVWF  xEB
1118C:  MOVLB  0
1118E:  CALL   AACC
11192:  MOVLW  10
11194:  MOVWF  FE9
11196:  MOVFF  352,8F7
1119A:  MOVFF  351,8F6
1119E:  CALL   AAFE
111A2:  MOVLW  DB
111A4:  MOVWF  FF6
111A6:  MOVLW  1D
111A8:  MOVWF  FF7
111AA:  MOVLW  00
111AC:  MOVWF  FF8
111AE:  MOVLW  09
111B0:  MOVLB  8
111B2:  MOVWF  xEB
111B4:  MOVLB  0
111B6:  CALL   AACC
111BA:  MOVLW  89
111BC:  MOVWF  FE9
111BE:  MOVFF  3AC,8D2
111C2:  MOVFF  3AB,8D1
111C6:  MOVFF  3AA,8D0
111CA:  MOVFF  3A9,8CF
111CE:  MOVLW  04
111D0:  MOVLB  8
111D2:  MOVWF  xD3
111D4:  MOVLB  0
111D6:  RCALL  10BFA
111D8:  MOVLW  E9
111DA:  MOVWF  FF6
111DC:  MOVLW  1D
111DE:  MOVWF  FF7
111E0:  MOVLW  00
111E2:  MOVWF  FF8
111E4:  MOVLW  07
111E6:  MOVLB  8
111E8:  MOVWF  xEB
111EA:  MOVLB  0
111EC:  CALL   AACC
111F0:  MOVLW  10
111F2:  MOVWF  FE9
111F4:  MOVFF  354,8F7
111F8:  MOVFF  353,8F6
111FC:  CALL   AAFE
11200:  MOVLW  F3
11202:  MOVWF  FF6
11204:  MOVLW  1D
11206:  MOVWF  FF7
11208:  MOVLW  00
1120A:  MOVWF  FF8
1120C:  MOVLW  07
1120E:  MOVLB  8
11210:  MOVWF  xEB
11212:  MOVLB  0
11214:  CALL   AACC
11218:  MOVLW  10
1121A:  MOVWF  FE9
1121C:  MOVFF  356,8F7
11220:  MOVFF  355,8F6
11224:  CALL   AAFE
11228:  MOVLW  FD
1122A:  MOVWF  FF6
1122C:  MOVLW  1D
1122E:  MOVWF  FF7
11230:  MOVLW  00
11232:  MOVWF  FF8
11234:  MOVLW  09
11236:  MOVLB  8
11238:  MOVWF  xEB
1123A:  MOVLB  0
1123C:  CALL   AACC
11240:  MOVLW  89
11242:  MOVWF  FE9
11244:  MOVFF  3B0,8D2
11248:  MOVFF  3AF,8D1
1124C:  MOVFF  3AE,8D0
11250:  MOVFF  3AD,8CF
11254:  MOVLW  04
11256:  MOVLB  8
11258:  MOVWF  xD3
1125A:  MOVLB  0
1125C:  RCALL  10BFA
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
1125E:  MOVF   1F,W
11260:  SUBLW  02
11262:  BNZ   11268
11264:  MOVF   20,F
11266:  BZ    112A8
11268:  MOVLW  0C
1126A:  MOVWF  FF6
1126C:  MOVLW  1E
1126E:  MOVWF  FF7
11270:  MOVLW  00
11272:  MOVWF  FF8
11274:  CLRF   1B
11276:  BTFSC  FF2.7
11278:  BSF    1B.7
1127A:  BCF    FF2.7
1127C:  MOVLW  09
1127E:  MOVLB  A
11280:  MOVWF  x40
11282:  MOVLB  0
11284:  CALL   1024
11288:  BTFSC  1B.7
1128A:  BSF    FF2.7
1128C:  MOVLW  04
1128E:  MOVWF  FEA
11290:  MOVLW  25
11292:  MOVWF  FE9
11294:  CALL   7996
11298:  MOVLW  0D
1129A:  BTFSS  F9E.4
1129C:  BRA    1129A
1129E:  MOVWF  FAD
112A0:  MOVLW  0A
112A2:  BTFSS  F9E.4
112A4:  BRA    112A2
112A6:  MOVWF  FAD
112A8:  GOTO   125B4 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
112AC:  MOVLB  8
112AE:  CLRF   xC2
112B0:  MOVF   xC2,W
112B2:  SUBLW  03
112B4:  BNC   112D4
112B6:  MOVF   xC2,W
112B8:  MULLW  04
112BA:  MOVF   FF3,W
112BC:  CLRF   03
112BE:  ADDLW  B5
112C0:  MOVWF  FE9
112C2:  MOVLW  03
112C4:  ADDWFC 03,W
112C6:  MOVWF  FEA
112C8:  CLRF   FEF
112CA:  CLRF   FEC
112CC:  CLRF   FEC
112CE:  CLRF   FEC
112D0:  INCF   xC2,F
112D2:  BRA    112B0
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
112D4:  MOVLB  3
112D6:  MOVF   x5D,F
112D8:  BTFSS  FD8.2
112DA:  BRA    112E0
112DC:  MOVF   x5E,F
112DE:  BZ    1137A
112E0:  MOVF   x5F,F
112E2:  BNZ   112E8
112E4:  MOVF   x60,F
112E6:  BZ    1137A
....................       blank = NO2_array[0]; 
112E8:  MOVFF  35E,918
112EC:  MOVFF  35D,917
112F0:  MOVLB  0
112F2:  CALL   C8BA
112F6:  MOVFF  03,8C6
112FA:  MOVFF  02,8C5
112FE:  MOVFF  01,8C4
11302:  MOVFF  00,8C3
....................       react = NO2_array[1]; 
11306:  MOVFF  360,918
1130A:  MOVFF  35F,917
1130E:  CALL   C8BA
11312:  MOVFF  03,8CA
11316:  MOVFF  02,8C9
1131A:  MOVFF  01,8C8
1131E:  MOVFF  00,8C7
....................       ratio = blank / react; 
11322:  MOVFF  8C6,8FE
11326:  MOVFF  8C5,8FD
1132A:  MOVFF  8C4,8FC
1132E:  MOVFF  8C3,8FB
11332:  MOVFF  8CA,902
11336:  MOVFF  8C9,901
1133A:  MOVFF  8C8,900
1133E:  MOVFF  8C7,8FF
11342:  CALL   C8F0
11346:  MOVFF  03,8CE
1134A:  MOVFF  02,8CD
1134E:  MOVFF  01,8CC
11352:  MOVFF  00,8CB
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
11356:  MOVFF  8CE,8D2
1135A:  MOVFF  8CD,8D1
1135E:  MOVFF  8CC,8D0
11362:  MOVFF  8CB,8CF
11366:  RCALL  10B8E
11368:  MOVFF  03,3B8
1136C:  MOVFF  02,3B7
11370:  MOVFF  01,3B6
11374:  MOVFF  00,3B5
11378:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
1137A:  MOVF   x61,F
1137C:  BNZ   11382
1137E:  MOVF   x62,F
11380:  BZ    1141E
11382:  MOVF   x63,F
11384:  BNZ   1138A
11386:  MOVF   x64,F
11388:  BZ    1141E
....................       blank = NO2_array[2]; 
1138A:  MOVFF  362,918
1138E:  MOVFF  361,917
11392:  MOVLB  0
11394:  CALL   C8BA
11398:  MOVFF  03,8C6
1139C:  MOVFF  02,8C5
113A0:  MOVFF  01,8C4
113A4:  MOVFF  00,8C3
....................       react = NO2_array[3]; 
113A8:  MOVFF  364,918
113AC:  MOVFF  363,917
113B0:  CALL   C8BA
113B4:  MOVFF  03,8CA
113B8:  MOVFF  02,8C9
113BC:  MOVFF  01,8C8
113C0:  MOVFF  00,8C7
....................       ratio = blank / react;    
113C4:  MOVFF  8C6,8FE
113C8:  MOVFF  8C5,8FD
113CC:  MOVFF  8C4,8FC
113D0:  MOVFF  8C3,8FB
113D4:  MOVFF  8CA,902
113D8:  MOVFF  8C9,901
113DC:  MOVFF  8C8,900
113E0:  MOVFF  8C7,8FF
113E4:  CALL   C8F0
113E8:  MOVFF  03,8CE
113EC:  MOVFF  02,8CD
113F0:  MOVFF  01,8CC
113F4:  MOVFF  00,8CB
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
113F8:  MOVFF  8CE,8D2
113FC:  MOVFF  8CD,8D1
11400:  MOVFF  8CC,8D0
11404:  MOVFF  8CB,8CF
11408:  CALL   10B8E
1140C:  MOVFF  03,3BC
11410:  MOVFF  02,3BB
11414:  MOVFF  01,3BA
11418:  MOVFF  00,3B9
1141C:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
1141E:  MOVF   x65,F
11420:  BNZ   11426
11422:  MOVF   x66,F
11424:  BZ    114C2
11426:  MOVF   x67,F
11428:  BNZ   1142E
1142A:  MOVF   x68,F
1142C:  BZ    114C2
....................       blank = NO2_array[4]; 
1142E:  MOVFF  366,918
11432:  MOVFF  365,917
11436:  MOVLB  0
11438:  CALL   C8BA
1143C:  MOVFF  03,8C6
11440:  MOVFF  02,8C5
11444:  MOVFF  01,8C4
11448:  MOVFF  00,8C3
....................       react = NO2_array[5]; 
1144C:  MOVFF  368,918
11450:  MOVFF  367,917
11454:  CALL   C8BA
11458:  MOVFF  03,8CA
1145C:  MOVFF  02,8C9
11460:  MOVFF  01,8C8
11464:  MOVFF  00,8C7
....................       ratio = blank / react; 
11468:  MOVFF  8C6,8FE
1146C:  MOVFF  8C5,8FD
11470:  MOVFF  8C4,8FC
11474:  MOVFF  8C3,8FB
11478:  MOVFF  8CA,902
1147C:  MOVFF  8C9,901
11480:  MOVFF  8C8,900
11484:  MOVFF  8C7,8FF
11488:  CALL   C8F0
1148C:  MOVFF  03,8CE
11490:  MOVFF  02,8CD
11494:  MOVFF  01,8CC
11498:  MOVFF  00,8CB
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
1149C:  MOVFF  8CE,8D2
114A0:  MOVFF  8CD,8D1
114A4:  MOVFF  8CC,8D0
114A8:  MOVFF  8CB,8CF
114AC:  CALL   10B8E
114B0:  MOVFF  03,3C0
114B4:  MOVFF  02,3BF
114B8:  MOVFF  01,3BE
114BC:  MOVFF  00,3BD
114C0:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
114C2:  MOVF   x69,F
114C4:  BNZ   114CA
114C6:  MOVF   x6A,F
114C8:  BZ    11566
114CA:  MOVF   x6B,F
114CC:  BNZ   114D2
114CE:  MOVF   x6C,F
114D0:  BZ    11566
....................       blank = NO2_array[6]; 
114D2:  MOVFF  36A,918
114D6:  MOVFF  369,917
114DA:  MOVLB  0
114DC:  CALL   C8BA
114E0:  MOVFF  03,8C6
114E4:  MOVFF  02,8C5
114E8:  MOVFF  01,8C4
114EC:  MOVFF  00,8C3
....................       react = NO2_array[7]; 
114F0:  MOVFF  36C,918
114F4:  MOVFF  36B,917
114F8:  CALL   C8BA
114FC:  MOVFF  03,8CA
11500:  MOVFF  02,8C9
11504:  MOVFF  01,8C8
11508:  MOVFF  00,8C7
....................       ratio = blank / react; 
1150C:  MOVFF  8C6,8FE
11510:  MOVFF  8C5,8FD
11514:  MOVFF  8C4,8FC
11518:  MOVFF  8C3,8FB
1151C:  MOVFF  8CA,902
11520:  MOVFF  8C9,901
11524:  MOVFF  8C8,900
11528:  MOVFF  8C7,8FF
1152C:  CALL   C8F0
11530:  MOVFF  03,8CE
11534:  MOVFF  02,8CD
11538:  MOVFF  01,8CC
1153C:  MOVFF  00,8CB
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
11540:  MOVFF  8CE,8D2
11544:  MOVFF  8CD,8D1
11548:  MOVFF  8CC,8D0
1154C:  MOVFF  8CB,8CF
11550:  CALL   10B8E
11554:  MOVFF  03,3C4
11558:  MOVFF  02,3C3
1155C:  MOVFF  01,3C2
11560:  MOVFF  00,3C1
11564:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
11566:  MOVLW  04
11568:  MOVWF  1E
1156A:  MOVLW  25
1156C:  MOVWF  1D
1156E:  MOVLW  1A
11570:  MOVWF  FF6
11572:  MOVLW  1E
11574:  MOVWF  FF7
11576:  MOVLW  00
11578:  MOVWF  FF8
1157A:  MOVLW  06
1157C:  MOVLB  8
1157E:  MOVWF  xEB
11580:  MOVLB  0
11582:  CALL   AACC
11586:  MOVLW  10
11588:  MOVWF  FE9
1158A:  MOVFF  35E,8F7
1158E:  MOVFF  35D,8F6
11592:  CALL   AAFE
11596:  MOVLW  23
11598:  MOVWF  FF6
1159A:  MOVLW  1E
1159C:  MOVWF  FF7
1159E:  MOVLW  00
115A0:  MOVWF  FF8
115A2:  MOVLW  07
115A4:  MOVLB  8
115A6:  MOVWF  xEB
115A8:  MOVLB  0
115AA:  CALL   AACC
115AE:  MOVLW  10
115B0:  MOVWF  FE9
115B2:  MOVFF  360,8F7
115B6:  MOVFF  35F,8F6
115BA:  CALL   AAFE
115BE:  MOVLW  2D
115C0:  MOVWF  FF6
115C2:  MOVLW  1E
115C4:  MOVWF  FF7
115C6:  MOVLW  00
115C8:  MOVWF  FF8
115CA:  MOVLW  09
115CC:  MOVLB  8
115CE:  MOVWF  xEB
115D0:  MOVLB  0
115D2:  CALL   AACC
115D6:  MOVLW  89
115D8:  MOVWF  FE9
115DA:  MOVFF  3B8,8D2
115DE:  MOVFF  3B7,8D1
115E2:  MOVFF  3B6,8D0
115E6:  MOVFF  3B5,8CF
115EA:  MOVLW  04
115EC:  MOVLB  8
115EE:  MOVWF  xD3
115F0:  MOVLB  0
115F2:  CALL   10BFA
115F6:  MOVLW  3B
115F8:  MOVWF  FF6
115FA:  MOVLW  1E
115FC:  MOVWF  FF7
115FE:  MOVLW  00
11600:  MOVWF  FF8
11602:  MOVLW  07
11604:  MOVLB  8
11606:  MOVWF  xEB
11608:  MOVLB  0
1160A:  CALL   AACC
1160E:  MOVLW  10
11610:  MOVWF  FE9
11612:  MOVFF  362,8F7
11616:  MOVFF  361,8F6
1161A:  CALL   AAFE
1161E:  MOVLW  45
11620:  MOVWF  FF6
11622:  MOVLW  1E
11624:  MOVWF  FF7
11626:  MOVLW  00
11628:  MOVWF  FF8
1162A:  MOVLW  07
1162C:  MOVLB  8
1162E:  MOVWF  xEB
11630:  MOVLB  0
11632:  CALL   AACC
11636:  MOVLW  10
11638:  MOVWF  FE9
1163A:  MOVFF  364,8F7
1163E:  MOVFF  363,8F6
11642:  CALL   AAFE
11646:  MOVLW  4F
11648:  MOVWF  FF6
1164A:  MOVLW  1E
1164C:  MOVWF  FF7
1164E:  MOVLW  00
11650:  MOVWF  FF8
11652:  MOVLW  09
11654:  MOVLB  8
11656:  MOVWF  xEB
11658:  MOVLB  0
1165A:  CALL   AACC
1165E:  MOVLW  89
11660:  MOVWF  FE9
11662:  MOVFF  3BC,8D2
11666:  MOVFF  3BB,8D1
1166A:  MOVFF  3BA,8D0
1166E:  MOVFF  3B9,8CF
11672:  MOVLW  04
11674:  MOVLB  8
11676:  MOVWF  xD3
11678:  MOVLB  0
1167A:  CALL   10BFA
1167E:  MOVLW  5D
11680:  MOVWF  FF6
11682:  MOVLW  1E
11684:  MOVWF  FF7
11686:  MOVLW  00
11688:  MOVWF  FF8
1168A:  MOVLW  07
1168C:  MOVLB  8
1168E:  MOVWF  xEB
11690:  MOVLB  0
11692:  CALL   AACC
11696:  MOVLW  10
11698:  MOVWF  FE9
1169A:  MOVFF  366,8F7
1169E:  MOVFF  365,8F6
116A2:  CALL   AAFE
116A6:  MOVLW  67
116A8:  MOVWF  FF6
116AA:  MOVLW  1E
116AC:  MOVWF  FF7
116AE:  MOVLW  00
116B0:  MOVWF  FF8
116B2:  MOVLW  07
116B4:  MOVLB  8
116B6:  MOVWF  xEB
116B8:  MOVLB  0
116BA:  CALL   AACC
116BE:  MOVLW  10
116C0:  MOVWF  FE9
116C2:  MOVFF  368,8F7
116C6:  MOVFF  367,8F6
116CA:  CALL   AAFE
116CE:  MOVLW  71
116D0:  MOVWF  FF6
116D2:  MOVLW  1E
116D4:  MOVWF  FF7
116D6:  MOVLW  00
116D8:  MOVWF  FF8
116DA:  MOVLW  09
116DC:  MOVLB  8
116DE:  MOVWF  xEB
116E0:  MOVLB  0
116E2:  CALL   AACC
116E6:  MOVLW  89
116E8:  MOVWF  FE9
116EA:  MOVFF  3C0,8D2
116EE:  MOVFF  3BF,8D1
116F2:  MOVFF  3BE,8D0
116F6:  MOVFF  3BD,8CF
116FA:  MOVLW  04
116FC:  MOVLB  8
116FE:  MOVWF  xD3
11700:  MOVLB  0
11702:  CALL   10BFA
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
11706:  MOVF   1F,W
11708:  SUBLW  02
1170A:  BNZ   11710
1170C:  MOVF   20,F
1170E:  BZ    11750
11710:  MOVLW  80
11712:  MOVWF  FF6
11714:  MOVLW  1E
11716:  MOVWF  FF7
11718:  MOVLW  00
1171A:  MOVWF  FF8
1171C:  CLRF   1B
1171E:  BTFSC  FF2.7
11720:  BSF    1B.7
11722:  BCF    FF2.7
11724:  MOVLW  09
11726:  MOVLB  A
11728:  MOVWF  x40
1172A:  MOVLB  0
1172C:  CALL   1024
11730:  BTFSC  1B.7
11732:  BSF    FF2.7
11734:  MOVLW  04
11736:  MOVWF  FEA
11738:  MOVLW  25
1173A:  MOVWF  FE9
1173C:  CALL   7996
11740:  MOVLW  0D
11742:  BTFSS  F9E.4
11744:  BRA    11742
11746:  MOVWF  FAD
11748:  MOVLW  0A
1174A:  BTFSS  F9E.4
1174C:  BRA    1174A
1174E:  MOVWF  FAD
11750:  GOTO   125B4 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
11754:  MOVLB  8
11756:  CLRF   xC2
11758:  MOVF   xC2,W
1175A:  SUBLW  03
1175C:  BNC   1177C
1175E:  MOVF   xC2,W
11760:  MULLW  04
11762:  MOVF   FF3,W
11764:  CLRF   03
11766:  ADDLW  C5
11768:  MOVWF  FE9
1176A:  MOVLW  03
1176C:  ADDWFC 03,W
1176E:  MOVWF  FEA
11770:  CLRF   FEF
11772:  CLRF   FEC
11774:  CLRF   FEC
11776:  CLRF   FEC
11778:  INCF   xC2,F
1177A:  BRA    11758
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
1177C:  MOVLB  3
1177E:  MOVF   x6F,F
11780:  BTFSS  FD8.2
11782:  BRA    11788
11784:  MOVF   x70,F
11786:  BZ    11824
11788:  MOVF   x71,F
1178A:  BNZ   11790
1178C:  MOVF   x72,F
1178E:  BZ    11824
....................       blank = PO4_array[0]; 
11790:  MOVFF  370,918
11794:  MOVFF  36F,917
11798:  MOVLB  0
1179A:  CALL   C8BA
1179E:  MOVFF  03,8C6
117A2:  MOVFF  02,8C5
117A6:  MOVFF  01,8C4
117AA:  MOVFF  00,8C3
....................       react = PO4_array[1]; 
117AE:  MOVFF  372,918
117B2:  MOVFF  371,917
117B6:  CALL   C8BA
117BA:  MOVFF  03,8CA
117BE:  MOVFF  02,8C9
117C2:  MOVFF  01,8C8
117C6:  MOVFF  00,8C7
....................       ratio = blank / react; 
117CA:  MOVFF  8C6,8FE
117CE:  MOVFF  8C5,8FD
117D2:  MOVFF  8C4,8FC
117D6:  MOVFF  8C3,8FB
117DA:  MOVFF  8CA,902
117DE:  MOVFF  8C9,901
117E2:  MOVFF  8C8,900
117E6:  MOVFF  8C7,8FF
117EA:  CALL   C8F0
117EE:  MOVFF  03,8CE
117F2:  MOVFF  02,8CD
117F6:  MOVFF  01,8CC
117FA:  MOVFF  00,8CB
....................       PO4_abs_array[0] = log10(ratio); 
117FE:  MOVFF  8CE,8D2
11802:  MOVFF  8CD,8D1
11806:  MOVFF  8CC,8D0
1180A:  MOVFF  8CB,8CF
1180E:  CALL   10B8E
11812:  MOVFF  03,3C8
11816:  MOVFF  02,3C7
1181A:  MOVFF  01,3C6
1181E:  MOVFF  00,3C5
11822:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
11824:  MOVF   x73,F
11826:  BNZ   1182C
11828:  MOVF   x74,F
1182A:  BZ    118C8
1182C:  MOVF   x75,F
1182E:  BNZ   11834
11830:  MOVF   x76,F
11832:  BZ    118C8
....................       blank = PO4_array[2]; 
11834:  MOVFF  374,918
11838:  MOVFF  373,917
1183C:  MOVLB  0
1183E:  CALL   C8BA
11842:  MOVFF  03,8C6
11846:  MOVFF  02,8C5
1184A:  MOVFF  01,8C4
1184E:  MOVFF  00,8C3
....................       react = PO4_array[3]; 
11852:  MOVFF  376,918
11856:  MOVFF  375,917
1185A:  CALL   C8BA
1185E:  MOVFF  03,8CA
11862:  MOVFF  02,8C9
11866:  MOVFF  01,8C8
1186A:  MOVFF  00,8C7
....................       ratio = blank / react;    
1186E:  MOVFF  8C6,8FE
11872:  MOVFF  8C5,8FD
11876:  MOVFF  8C4,8FC
1187A:  MOVFF  8C3,8FB
1187E:  MOVFF  8CA,902
11882:  MOVFF  8C9,901
11886:  MOVFF  8C8,900
1188A:  MOVFF  8C7,8FF
1188E:  CALL   C8F0
11892:  MOVFF  03,8CE
11896:  MOVFF  02,8CD
1189A:  MOVFF  01,8CC
1189E:  MOVFF  00,8CB
....................       PO4_abs_array[1] = log10(ratio); 
118A2:  MOVFF  8CE,8D2
118A6:  MOVFF  8CD,8D1
118AA:  MOVFF  8CC,8D0
118AE:  MOVFF  8CB,8CF
118B2:  CALL   10B8E
118B6:  MOVFF  03,3CC
118BA:  MOVFF  02,3CB
118BE:  MOVFF  01,3CA
118C2:  MOVFF  00,3C9
118C6:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
118C8:  MOVF   x77,F
118CA:  BNZ   118D0
118CC:  MOVF   x78,F
118CE:  BZ    1196C
118D0:  MOVF   x79,F
118D2:  BNZ   118D8
118D4:  MOVF   x7A,F
118D6:  BZ    1196C
....................       blank = PO4_array[4]; 
118D8:  MOVFF  378,918
118DC:  MOVFF  377,917
118E0:  MOVLB  0
118E2:  CALL   C8BA
118E6:  MOVFF  03,8C6
118EA:  MOVFF  02,8C5
118EE:  MOVFF  01,8C4
118F2:  MOVFF  00,8C3
....................       react = PO4_array[5]; 
118F6:  MOVFF  37A,918
118FA:  MOVFF  379,917
118FE:  CALL   C8BA
11902:  MOVFF  03,8CA
11906:  MOVFF  02,8C9
1190A:  MOVFF  01,8C8
1190E:  MOVFF  00,8C7
....................       ratio = blank / react; 
11912:  MOVFF  8C6,8FE
11916:  MOVFF  8C5,8FD
1191A:  MOVFF  8C4,8FC
1191E:  MOVFF  8C3,8FB
11922:  MOVFF  8CA,902
11926:  MOVFF  8C9,901
1192A:  MOVFF  8C8,900
1192E:  MOVFF  8C7,8FF
11932:  CALL   C8F0
11936:  MOVFF  03,8CE
1193A:  MOVFF  02,8CD
1193E:  MOVFF  01,8CC
11942:  MOVFF  00,8CB
....................       PO4_abs_array[2] = log10(ratio); 
11946:  MOVFF  8CE,8D2
1194A:  MOVFF  8CD,8D1
1194E:  MOVFF  8CC,8D0
11952:  MOVFF  8CB,8CF
11956:  CALL   10B8E
1195A:  MOVFF  03,3D0
1195E:  MOVFF  02,3CF
11962:  MOVFF  01,3CE
11966:  MOVFF  00,3CD
1196A:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
1196C:  MOVF   x7B,F
1196E:  BNZ   11974
11970:  MOVF   x7C,F
11972:  BZ    11A10
11974:  MOVF   x7D,F
11976:  BNZ   1197C
11978:  MOVF   x7E,F
1197A:  BZ    11A10
....................       blank = PO4_array[6]; 
1197C:  MOVFF  37C,918
11980:  MOVFF  37B,917
11984:  MOVLB  0
11986:  CALL   C8BA
1198A:  MOVFF  03,8C6
1198E:  MOVFF  02,8C5
11992:  MOVFF  01,8C4
11996:  MOVFF  00,8C3
....................       react = PO4_array[7]; 
1199A:  MOVFF  37E,918
1199E:  MOVFF  37D,917
119A2:  CALL   C8BA
119A6:  MOVFF  03,8CA
119AA:  MOVFF  02,8C9
119AE:  MOVFF  01,8C8
119B2:  MOVFF  00,8C7
....................       ratio = blank / react; 
119B6:  MOVFF  8C6,8FE
119BA:  MOVFF  8C5,8FD
119BE:  MOVFF  8C4,8FC
119C2:  MOVFF  8C3,8FB
119C6:  MOVFF  8CA,902
119CA:  MOVFF  8C9,901
119CE:  MOVFF  8C8,900
119D2:  MOVFF  8C7,8FF
119D6:  CALL   C8F0
119DA:  MOVFF  03,8CE
119DE:  MOVFF  02,8CD
119E2:  MOVFF  01,8CC
119E6:  MOVFF  00,8CB
....................       PO4_abs_array[3] = log10(ratio); 
119EA:  MOVFF  8CE,8D2
119EE:  MOVFF  8CD,8D1
119F2:  MOVFF  8CC,8D0
119F6:  MOVFF  8CB,8CF
119FA:  CALL   10B8E
119FE:  MOVFF  03,3D4
11A02:  MOVFF  02,3D3
11A06:  MOVFF  01,3D2
11A0A:  MOVFF  00,3D1
11A0E:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
11A10:  MOVLW  04
11A12:  MOVWF  1E
11A14:  MOVLW  25
11A16:  MOVWF  1D
11A18:  MOVLW  8E
11A1A:  MOVWF  FF6
11A1C:  MOVLW  1E
11A1E:  MOVWF  FF7
11A20:  MOVLW  00
11A22:  MOVWF  FF8
11A24:  MOVLW  06
11A26:  MOVLB  8
11A28:  MOVWF  xEB
11A2A:  MOVLB  0
11A2C:  CALL   AACC
11A30:  MOVLW  10
11A32:  MOVWF  FE9
11A34:  MOVFF  370,8F7
11A38:  MOVFF  36F,8F6
11A3C:  CALL   AAFE
11A40:  MOVLW  97
11A42:  MOVWF  FF6
11A44:  MOVLW  1E
11A46:  MOVWF  FF7
11A48:  MOVLW  00
11A4A:  MOVWF  FF8
11A4C:  MOVLW  07
11A4E:  MOVLB  8
11A50:  MOVWF  xEB
11A52:  MOVLB  0
11A54:  CALL   AACC
11A58:  MOVLW  10
11A5A:  MOVWF  FE9
11A5C:  MOVFF  372,8F7
11A60:  MOVFF  371,8F6
11A64:  CALL   AAFE
11A68:  MOVLW  A1
11A6A:  MOVWF  FF6
11A6C:  MOVLW  1E
11A6E:  MOVWF  FF7
11A70:  MOVLW  00
11A72:  MOVWF  FF8
11A74:  MOVLW  09
11A76:  MOVLB  8
11A78:  MOVWF  xEB
11A7A:  MOVLB  0
11A7C:  CALL   AACC
11A80:  MOVLW  89
11A82:  MOVWF  FE9
11A84:  MOVFF  3C8,8D2
11A88:  MOVFF  3C7,8D1
11A8C:  MOVFF  3C6,8D0
11A90:  MOVFF  3C5,8CF
11A94:  MOVLW  04
11A96:  MOVLB  8
11A98:  MOVWF  xD3
11A9A:  MOVLB  0
11A9C:  CALL   10BFA
11AA0:  MOVLW  AF
11AA2:  MOVWF  FF6
11AA4:  MOVLW  1E
11AA6:  MOVWF  FF7
11AA8:  MOVLW  00
11AAA:  MOVWF  FF8
11AAC:  MOVLW  07
11AAE:  MOVLB  8
11AB0:  MOVWF  xEB
11AB2:  MOVLB  0
11AB4:  CALL   AACC
11AB8:  MOVLW  10
11ABA:  MOVWF  FE9
11ABC:  MOVFF  374,8F7
11AC0:  MOVFF  373,8F6
11AC4:  CALL   AAFE
11AC8:  MOVLW  B9
11ACA:  MOVWF  FF6
11ACC:  MOVLW  1E
11ACE:  MOVWF  FF7
11AD0:  MOVLW  00
11AD2:  MOVWF  FF8
11AD4:  MOVLW  07
11AD6:  MOVLB  8
11AD8:  MOVWF  xEB
11ADA:  MOVLB  0
11ADC:  CALL   AACC
11AE0:  MOVLW  10
11AE2:  MOVWF  FE9
11AE4:  MOVFF  376,8F7
11AE8:  MOVFF  375,8F6
11AEC:  CALL   AAFE
11AF0:  MOVLW  C3
11AF2:  MOVWF  FF6
11AF4:  MOVLW  1E
11AF6:  MOVWF  FF7
11AF8:  MOVLW  00
11AFA:  MOVWF  FF8
11AFC:  MOVLW  09
11AFE:  MOVLB  8
11B00:  MOVWF  xEB
11B02:  MOVLB  0
11B04:  CALL   AACC
11B08:  MOVLW  89
11B0A:  MOVWF  FE9
11B0C:  MOVFF  3CC,8D2
11B10:  MOVFF  3CB,8D1
11B14:  MOVFF  3CA,8D0
11B18:  MOVFF  3C9,8CF
11B1C:  MOVLW  04
11B1E:  MOVLB  8
11B20:  MOVWF  xD3
11B22:  MOVLB  0
11B24:  CALL   10BFA
11B28:  MOVLW  D1
11B2A:  MOVWF  FF6
11B2C:  MOVLW  1E
11B2E:  MOVWF  FF7
11B30:  MOVLW  00
11B32:  MOVWF  FF8
11B34:  MOVLW  07
11B36:  MOVLB  8
11B38:  MOVWF  xEB
11B3A:  MOVLB  0
11B3C:  CALL   AACC
11B40:  MOVLW  10
11B42:  MOVWF  FE9
11B44:  MOVFF  378,8F7
11B48:  MOVFF  377,8F6
11B4C:  CALL   AAFE
11B50:  MOVLW  DB
11B52:  MOVWF  FF6
11B54:  MOVLW  1E
11B56:  MOVWF  FF7
11B58:  MOVLW  00
11B5A:  MOVWF  FF8
11B5C:  MOVLW  07
11B5E:  MOVLB  8
11B60:  MOVWF  xEB
11B62:  MOVLB  0
11B64:  CALL   AACC
11B68:  MOVLW  10
11B6A:  MOVWF  FE9
11B6C:  MOVFF  37A,8F7
11B70:  MOVFF  379,8F6
11B74:  CALL   AAFE
11B78:  MOVLW  E5
11B7A:  MOVWF  FF6
11B7C:  MOVLW  1E
11B7E:  MOVWF  FF7
11B80:  MOVLW  00
11B82:  MOVWF  FF8
11B84:  MOVLW  09
11B86:  MOVLB  8
11B88:  MOVWF  xEB
11B8A:  MOVLB  0
11B8C:  CALL   AACC
11B90:  MOVLW  89
11B92:  MOVWF  FE9
11B94:  MOVFF  3D0,8D2
11B98:  MOVFF  3CF,8D1
11B9C:  MOVFF  3CE,8D0
11BA0:  MOVFF  3CD,8CF
11BA4:  MOVLW  04
11BA6:  MOVLB  8
11BA8:  MOVWF  xD3
11BAA:  MOVLB  0
11BAC:  CALL   10BFA
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
11BB0:  MOVF   1F,W
11BB2:  SUBLW  02
11BB4:  BNZ   11BBA
11BB6:  MOVF   20,F
11BB8:  BZ    11BFA
11BBA:  MOVLW  F4
11BBC:  MOVWF  FF6
11BBE:  MOVLW  1E
11BC0:  MOVWF  FF7
11BC2:  MOVLW  00
11BC4:  MOVWF  FF8
11BC6:  CLRF   1B
11BC8:  BTFSC  FF2.7
11BCA:  BSF    1B.7
11BCC:  BCF    FF2.7
11BCE:  MOVLW  09
11BD0:  MOVLB  A
11BD2:  MOVWF  x40
11BD4:  MOVLB  0
11BD6:  CALL   1024
11BDA:  BTFSC  1B.7
11BDC:  BSF    FF2.7
11BDE:  MOVLW  04
11BE0:  MOVWF  FEA
11BE2:  MOVLW  25
11BE4:  MOVWF  FE9
11BE6:  CALL   7996
11BEA:  MOVLW  0D
11BEC:  BTFSS  F9E.4
11BEE:  BRA    11BEC
11BF0:  MOVWF  FAD
11BF2:  MOVLW  0A
11BF4:  BTFSS  F9E.4
11BF6:  BRA    11BF4
11BF8:  MOVWF  FAD
11BFA:  GOTO   125B4 (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
11BFE:  MOVLB  8
11C00:  CLRF   xC2
11C02:  MOVF   xC2,W
11C04:  SUBLW  03
11C06:  BNC   11C26
11C08:  MOVF   xC2,W
11C0A:  MULLW  04
11C0C:  MOVF   FF3,W
11C0E:  CLRF   03
11C10:  ADDLW  D5
11C12:  MOVWF  FE9
11C14:  MOVLW  03
11C16:  ADDWFC 03,W
11C18:  MOVWF  FEA
11C1A:  CLRF   FEF
11C1C:  CLRF   FEC
11C1E:  CLRF   FEC
11C20:  CLRF   FEC
11C22:  INCF   xC2,F
11C24:  BRA    11C02
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
11C26:  MOVLB  3
11C28:  MOVF   x81,F
11C2A:  BTFSS  FD8.2
11C2C:  BRA    11C32
11C2E:  MOVF   x82,F
11C30:  BZ    11CCE
11C32:  MOVF   x83,F
11C34:  BNZ   11C3A
11C36:  MOVF   x84,F
11C38:  BZ    11CCE
....................       blank = NH4_array[0]; 
11C3A:  MOVFF  382,918
11C3E:  MOVFF  381,917
11C42:  MOVLB  0
11C44:  CALL   C8BA
11C48:  MOVFF  03,8C6
11C4C:  MOVFF  02,8C5
11C50:  MOVFF  01,8C4
11C54:  MOVFF  00,8C3
....................       react = NH4_array[1]; 
11C58:  MOVFF  384,918
11C5C:  MOVFF  383,917
11C60:  CALL   C8BA
11C64:  MOVFF  03,8CA
11C68:  MOVFF  02,8C9
11C6C:  MOVFF  01,8C8
11C70:  MOVFF  00,8C7
....................       ratio = blank / react; 
11C74:  MOVFF  8C6,8FE
11C78:  MOVFF  8C5,8FD
11C7C:  MOVFF  8C4,8FC
11C80:  MOVFF  8C3,8FB
11C84:  MOVFF  8CA,902
11C88:  MOVFF  8C9,901
11C8C:  MOVFF  8C8,900
11C90:  MOVFF  8C7,8FF
11C94:  CALL   C8F0
11C98:  MOVFF  03,8CE
11C9C:  MOVFF  02,8CD
11CA0:  MOVFF  01,8CC
11CA4:  MOVFF  00,8CB
....................       NH4_abs_array[0] = log10(ratio); 
11CA8:  MOVFF  8CE,8D2
11CAC:  MOVFF  8CD,8D1
11CB0:  MOVFF  8CC,8D0
11CB4:  MOVFF  8CB,8CF
11CB8:  CALL   10B8E
11CBC:  MOVFF  03,3D8
11CC0:  MOVFF  02,3D7
11CC4:  MOVFF  01,3D6
11CC8:  MOVFF  00,3D5
11CCC:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
11CCE:  MOVF   x85,F
11CD0:  BNZ   11CD6
11CD2:  MOVF   x86,F
11CD4:  BZ    11D72
11CD6:  MOVF   x87,F
11CD8:  BNZ   11CDE
11CDA:  MOVF   x88,F
11CDC:  BZ    11D72
....................       blank = NH4_array[2]; 
11CDE:  MOVFF  386,918
11CE2:  MOVFF  385,917
11CE6:  MOVLB  0
11CE8:  CALL   C8BA
11CEC:  MOVFF  03,8C6
11CF0:  MOVFF  02,8C5
11CF4:  MOVFF  01,8C4
11CF8:  MOVFF  00,8C3
....................       react = NH4_array[3]; 
11CFC:  MOVFF  388,918
11D00:  MOVFF  387,917
11D04:  CALL   C8BA
11D08:  MOVFF  03,8CA
11D0C:  MOVFF  02,8C9
11D10:  MOVFF  01,8C8
11D14:  MOVFF  00,8C7
....................       ratio = blank / react;    
11D18:  MOVFF  8C6,8FE
11D1C:  MOVFF  8C5,8FD
11D20:  MOVFF  8C4,8FC
11D24:  MOVFF  8C3,8FB
11D28:  MOVFF  8CA,902
11D2C:  MOVFF  8C9,901
11D30:  MOVFF  8C8,900
11D34:  MOVFF  8C7,8FF
11D38:  CALL   C8F0
11D3C:  MOVFF  03,8CE
11D40:  MOVFF  02,8CD
11D44:  MOVFF  01,8CC
11D48:  MOVFF  00,8CB
....................       NH4_abs_array[1] = log10(ratio); 
11D4C:  MOVFF  8CE,8D2
11D50:  MOVFF  8CD,8D1
11D54:  MOVFF  8CC,8D0
11D58:  MOVFF  8CB,8CF
11D5C:  CALL   10B8E
11D60:  MOVFF  03,3DC
11D64:  MOVFF  02,3DB
11D68:  MOVFF  01,3DA
11D6C:  MOVFF  00,3D9
11D70:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11D72:  MOVF   x89,F
11D74:  BNZ   11D7A
11D76:  MOVF   x8A,F
11D78:  BZ    11E16
11D7A:  MOVF   x8B,F
11D7C:  BNZ   11D82
11D7E:  MOVF   x8C,F
11D80:  BZ    11E16
....................       blank = NH4_array[4]; 
11D82:  MOVFF  38A,918
11D86:  MOVFF  389,917
11D8A:  MOVLB  0
11D8C:  CALL   C8BA
11D90:  MOVFF  03,8C6
11D94:  MOVFF  02,8C5
11D98:  MOVFF  01,8C4
11D9C:  MOVFF  00,8C3
....................       react = NH4_array[5]; 
11DA0:  MOVFF  38C,918
11DA4:  MOVFF  38B,917
11DA8:  CALL   C8BA
11DAC:  MOVFF  03,8CA
11DB0:  MOVFF  02,8C9
11DB4:  MOVFF  01,8C8
11DB8:  MOVFF  00,8C7
....................       ratio = blank / react; 
11DBC:  MOVFF  8C6,8FE
11DC0:  MOVFF  8C5,8FD
11DC4:  MOVFF  8C4,8FC
11DC8:  MOVFF  8C3,8FB
11DCC:  MOVFF  8CA,902
11DD0:  MOVFF  8C9,901
11DD4:  MOVFF  8C8,900
11DD8:  MOVFF  8C7,8FF
11DDC:  CALL   C8F0
11DE0:  MOVFF  03,8CE
11DE4:  MOVFF  02,8CD
11DE8:  MOVFF  01,8CC
11DEC:  MOVFF  00,8CB
....................       NH4_abs_array[2] = log10(ratio); 
11DF0:  MOVFF  8CE,8D2
11DF4:  MOVFF  8CD,8D1
11DF8:  MOVFF  8CC,8D0
11DFC:  MOVFF  8CB,8CF
11E00:  CALL   10B8E
11E04:  MOVFF  03,3E0
11E08:  MOVFF  02,3DF
11E0C:  MOVFF  01,3DE
11E10:  MOVFF  00,3DD
11E14:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11E16:  MOVF   x8D,F
11E18:  BNZ   11E1E
11E1A:  MOVF   x8E,F
11E1C:  BZ    11EBA
11E1E:  MOVF   x8F,F
11E20:  BNZ   11E26
11E22:  MOVF   x90,F
11E24:  BZ    11EBA
....................       blank = NH4_array[6]; 
11E26:  MOVFF  38E,918
11E2A:  MOVFF  38D,917
11E2E:  MOVLB  0
11E30:  CALL   C8BA
11E34:  MOVFF  03,8C6
11E38:  MOVFF  02,8C5
11E3C:  MOVFF  01,8C4
11E40:  MOVFF  00,8C3
....................       react = NH4_array[7]; 
11E44:  MOVFF  390,918
11E48:  MOVFF  38F,917
11E4C:  CALL   C8BA
11E50:  MOVFF  03,8CA
11E54:  MOVFF  02,8C9
11E58:  MOVFF  01,8C8
11E5C:  MOVFF  00,8C7
....................       ratio = blank / react; 
11E60:  MOVFF  8C6,8FE
11E64:  MOVFF  8C5,8FD
11E68:  MOVFF  8C4,8FC
11E6C:  MOVFF  8C3,8FB
11E70:  MOVFF  8CA,902
11E74:  MOVFF  8C9,901
11E78:  MOVFF  8C8,900
11E7C:  MOVFF  8C7,8FF
11E80:  CALL   C8F0
11E84:  MOVFF  03,8CE
11E88:  MOVFF  02,8CD
11E8C:  MOVFF  01,8CC
11E90:  MOVFF  00,8CB
....................       NH4_abs_array[3] = log10(ratio); 
11E94:  MOVFF  8CE,8D2
11E98:  MOVFF  8CD,8D1
11E9C:  MOVFF  8CC,8D0
11EA0:  MOVFF  8CB,8CF
11EA4:  CALL   10B8E
11EA8:  MOVFF  03,3E4
11EAC:  MOVFF  02,3E3
11EB0:  MOVFF  01,3E2
11EB4:  MOVFF  00,3E1
11EB8:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11EBA:  MOVLW  04
11EBC:  MOVWF  1E
11EBE:  MOVLW  25
11EC0:  MOVWF  1D
11EC2:  MOVLW  02
11EC4:  MOVWF  FF6
11EC6:  MOVLW  1F
11EC8:  MOVWF  FF7
11ECA:  MOVLW  00
11ECC:  MOVWF  FF8
11ECE:  MOVLW  06
11ED0:  MOVLB  8
11ED2:  MOVWF  xEB
11ED4:  MOVLB  0
11ED6:  CALL   AACC
11EDA:  MOVLW  10
11EDC:  MOVWF  FE9
11EDE:  MOVFF  382,8F7
11EE2:  MOVFF  381,8F6
11EE6:  CALL   AAFE
11EEA:  MOVLW  0B
11EEC:  MOVWF  FF6
11EEE:  MOVLW  1F
11EF0:  MOVWF  FF7
11EF2:  MOVLW  00
11EF4:  MOVWF  FF8
11EF6:  MOVLW  07
11EF8:  MOVLB  8
11EFA:  MOVWF  xEB
11EFC:  MOVLB  0
11EFE:  CALL   AACC
11F02:  MOVLW  10
11F04:  MOVWF  FE9
11F06:  MOVFF  384,8F7
11F0A:  MOVFF  383,8F6
11F0E:  CALL   AAFE
11F12:  MOVLW  15
11F14:  MOVWF  FF6
11F16:  MOVLW  1F
11F18:  MOVWF  FF7
11F1A:  MOVLW  00
11F1C:  MOVWF  FF8
11F1E:  MOVLW  09
11F20:  MOVLB  8
11F22:  MOVWF  xEB
11F24:  MOVLB  0
11F26:  CALL   AACC
11F2A:  MOVLW  89
11F2C:  MOVWF  FE9
11F2E:  MOVFF  3D8,8D2
11F32:  MOVFF  3D7,8D1
11F36:  MOVFF  3D6,8D0
11F3A:  MOVFF  3D5,8CF
11F3E:  MOVLW  04
11F40:  MOVLB  8
11F42:  MOVWF  xD3
11F44:  MOVLB  0
11F46:  CALL   10BFA
11F4A:  MOVLW  23
11F4C:  MOVWF  FF6
11F4E:  MOVLW  1F
11F50:  MOVWF  FF7
11F52:  MOVLW  00
11F54:  MOVWF  FF8
11F56:  MOVLW  07
11F58:  MOVLB  8
11F5A:  MOVWF  xEB
11F5C:  MOVLB  0
11F5E:  CALL   AACC
11F62:  MOVLW  10
11F64:  MOVWF  FE9
11F66:  MOVFF  386,8F7
11F6A:  MOVFF  385,8F6
11F6E:  CALL   AAFE
11F72:  MOVLW  2D
11F74:  MOVWF  FF6
11F76:  MOVLW  1F
11F78:  MOVWF  FF7
11F7A:  MOVLW  00
11F7C:  MOVWF  FF8
11F7E:  MOVLW  07
11F80:  MOVLB  8
11F82:  MOVWF  xEB
11F84:  MOVLB  0
11F86:  CALL   AACC
11F8A:  MOVLW  10
11F8C:  MOVWF  FE9
11F8E:  MOVFF  388,8F7
11F92:  MOVFF  387,8F6
11F96:  CALL   AAFE
11F9A:  MOVLW  37
11F9C:  MOVWF  FF6
11F9E:  MOVLW  1F
11FA0:  MOVWF  FF7
11FA2:  MOVLW  00
11FA4:  MOVWF  FF8
11FA6:  MOVLW  09
11FA8:  MOVLB  8
11FAA:  MOVWF  xEB
11FAC:  MOVLB  0
11FAE:  CALL   AACC
11FB2:  MOVLW  89
11FB4:  MOVWF  FE9
11FB6:  MOVFF  3DC,8D2
11FBA:  MOVFF  3DB,8D1
11FBE:  MOVFF  3DA,8D0
11FC2:  MOVFF  3D9,8CF
11FC6:  MOVLW  04
11FC8:  MOVLB  8
11FCA:  MOVWF  xD3
11FCC:  MOVLB  0
11FCE:  CALL   10BFA
11FD2:  MOVLW  45
11FD4:  MOVWF  FF6
11FD6:  MOVLW  1F
11FD8:  MOVWF  FF7
11FDA:  MOVLW  00
11FDC:  MOVWF  FF8
11FDE:  MOVLW  07
11FE0:  MOVLB  8
11FE2:  MOVWF  xEB
11FE4:  MOVLB  0
11FE6:  CALL   AACC
11FEA:  MOVLW  10
11FEC:  MOVWF  FE9
11FEE:  MOVFF  38A,8F7
11FF2:  MOVFF  389,8F6
11FF6:  CALL   AAFE
11FFA:  MOVLW  4F
11FFC:  MOVWF  FF6
11FFE:  MOVLW  1F
12000:  MOVWF  FF7
12002:  MOVLW  00
12004:  MOVWF  FF8
12006:  MOVLW  07
12008:  MOVLB  8
1200A:  MOVWF  xEB
1200C:  MOVLB  0
1200E:  CALL   AACC
12012:  MOVLW  10
12014:  MOVWF  FE9
12016:  MOVFF  38C,8F7
1201A:  MOVFF  38B,8F6
1201E:  CALL   AAFE
12022:  MOVLW  59
12024:  MOVWF  FF6
12026:  MOVLW  1F
12028:  MOVWF  FF7
1202A:  MOVLW  00
1202C:  MOVWF  FF8
1202E:  MOVLW  09
12030:  MOVLB  8
12032:  MOVWF  xEB
12034:  MOVLB  0
12036:  CALL   AACC
1203A:  MOVLW  89
1203C:  MOVWF  FE9
1203E:  MOVFF  3E0,8D2
12042:  MOVFF  3DF,8D1
12046:  MOVFF  3DE,8D0
1204A:  MOVFF  3DD,8CF
1204E:  MOVLW  04
12050:  MOVLB  8
12052:  MOVWF  xD3
12054:  MOVLB  0
12056:  CALL   10BFA
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
1205A:  MOVF   1F,W
1205C:  SUBLW  02
1205E:  BNZ   12064
12060:  MOVF   20,F
12062:  BZ    120A4
12064:  MOVLW  68
12066:  MOVWF  FF6
12068:  MOVLW  1F
1206A:  MOVWF  FF7
1206C:  MOVLW  00
1206E:  MOVWF  FF8
12070:  CLRF   1B
12072:  BTFSC  FF2.7
12074:  BSF    1B.7
12076:  BCF    FF2.7
12078:  MOVLW  09
1207A:  MOVLB  A
1207C:  MOVWF  x40
1207E:  MOVLB  0
12080:  CALL   1024
12084:  BTFSC  1B.7
12086:  BSF    FF2.7
12088:  MOVLW  04
1208A:  MOVWF  FEA
1208C:  MOVLW  25
1208E:  MOVWF  FE9
12090:  CALL   7996
12094:  MOVLW  0D
12096:  BTFSS  F9E.4
12098:  BRA    12096
1209A:  MOVWF  FAD
1209C:  MOVLW  0A
1209E:  BTFSS  F9E.4
120A0:  BRA    1209E
120A2:  MOVWF  FAD
120A4:  GOTO   125B4 (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
120A8:  MOVLB  8
120AA:  CLRF   xC2
120AC:  MOVF   xC2,W
120AE:  SUBLW  03
120B0:  BNC   120D0
120B2:  MOVF   xC2,W
120B4:  MULLW  04
120B6:  MOVF   FF3,W
120B8:  CLRF   03
120BA:  ADDLW  E5
120BC:  MOVWF  FE9
120BE:  MOVLW  03
120C0:  ADDWFC 03,W
120C2:  MOVWF  FEA
120C4:  CLRF   FEF
120C6:  CLRF   FEC
120C8:  CLRF   FEC
120CA:  CLRF   FEC
120CC:  INCF   xC2,F
120CE:  BRA    120AC
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
120D0:  MOVLB  3
120D2:  MOVF   x93,F
120D4:  BTFSS  FD8.2
120D6:  BRA    120DC
120D8:  MOVF   x94,F
120DA:  BZ    12178
120DC:  MOVF   x95,F
120DE:  BNZ   120E4
120E0:  MOVF   x96,F
120E2:  BZ    12178
....................       blank = SiO_array[0]; 
120E4:  MOVFF  394,918
120E8:  MOVFF  393,917
120EC:  MOVLB  0
120EE:  CALL   C8BA
120F2:  MOVFF  03,8C6
120F6:  MOVFF  02,8C5
120FA:  MOVFF  01,8C4
120FE:  MOVFF  00,8C3
....................       react = SiO_array[1]; 
12102:  MOVFF  396,918
12106:  MOVFF  395,917
1210A:  CALL   C8BA
1210E:  MOVFF  03,8CA
12112:  MOVFF  02,8C9
12116:  MOVFF  01,8C8
1211A:  MOVFF  00,8C7
....................       ratio = blank / react; 
1211E:  MOVFF  8C6,8FE
12122:  MOVFF  8C5,8FD
12126:  MOVFF  8C4,8FC
1212A:  MOVFF  8C3,8FB
1212E:  MOVFF  8CA,902
12132:  MOVFF  8C9,901
12136:  MOVFF  8C8,900
1213A:  MOVFF  8C7,8FF
1213E:  CALL   C8F0
12142:  MOVFF  03,8CE
12146:  MOVFF  02,8CD
1214A:  MOVFF  01,8CC
1214E:  MOVFF  00,8CB
....................       SiO_abs_array[0] = log10(ratio); 
12152:  MOVFF  8CE,8D2
12156:  MOVFF  8CD,8D1
1215A:  MOVFF  8CC,8D0
1215E:  MOVFF  8CB,8CF
12162:  CALL   10B8E
12166:  MOVFF  03,3E8
1216A:  MOVFF  02,3E7
1216E:  MOVFF  01,3E6
12172:  MOVFF  00,3E5
12176:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
12178:  MOVF   x97,F
1217A:  BNZ   12180
1217C:  MOVF   x98,F
1217E:  BZ    1221C
12180:  MOVF   x99,F
12182:  BNZ   12188
12184:  MOVF   x9A,F
12186:  BZ    1221C
....................       blank = SiO_array[2]; 
12188:  MOVFF  398,918
1218C:  MOVFF  397,917
12190:  MOVLB  0
12192:  CALL   C8BA
12196:  MOVFF  03,8C6
1219A:  MOVFF  02,8C5
1219E:  MOVFF  01,8C4
121A2:  MOVFF  00,8C3
....................       react = SiO_array[3]; 
121A6:  MOVFF  39A,918
121AA:  MOVFF  399,917
121AE:  CALL   C8BA
121B2:  MOVFF  03,8CA
121B6:  MOVFF  02,8C9
121BA:  MOVFF  01,8C8
121BE:  MOVFF  00,8C7
....................       ratio = blank / react;    
121C2:  MOVFF  8C6,8FE
121C6:  MOVFF  8C5,8FD
121CA:  MOVFF  8C4,8FC
121CE:  MOVFF  8C3,8FB
121D2:  MOVFF  8CA,902
121D6:  MOVFF  8C9,901
121DA:  MOVFF  8C8,900
121DE:  MOVFF  8C7,8FF
121E2:  CALL   C8F0
121E6:  MOVFF  03,8CE
121EA:  MOVFF  02,8CD
121EE:  MOVFF  01,8CC
121F2:  MOVFF  00,8CB
....................       SiO_abs_array[1] = log10(ratio); 
121F6:  MOVFF  8CE,8D2
121FA:  MOVFF  8CD,8D1
121FE:  MOVFF  8CC,8D0
12202:  MOVFF  8CB,8CF
12206:  CALL   10B8E
1220A:  MOVFF  03,3EC
1220E:  MOVFF  02,3EB
12212:  MOVFF  01,3EA
12216:  MOVFF  00,3E9
1221A:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
1221C:  MOVF   x9B,F
1221E:  BNZ   12224
12220:  MOVF   x9C,F
12222:  BZ    122C0
12224:  MOVF   x9D,F
12226:  BNZ   1222C
12228:  MOVF   x9E,F
1222A:  BZ    122C0
....................       blank = SiO_array[4]; 
1222C:  MOVFF  39C,918
12230:  MOVFF  39B,917
12234:  MOVLB  0
12236:  CALL   C8BA
1223A:  MOVFF  03,8C6
1223E:  MOVFF  02,8C5
12242:  MOVFF  01,8C4
12246:  MOVFF  00,8C3
....................       react = SiO_array[5]; 
1224A:  MOVFF  39E,918
1224E:  MOVFF  39D,917
12252:  CALL   C8BA
12256:  MOVFF  03,8CA
1225A:  MOVFF  02,8C9
1225E:  MOVFF  01,8C8
12262:  MOVFF  00,8C7
....................       ratio = blank / react; 
12266:  MOVFF  8C6,8FE
1226A:  MOVFF  8C5,8FD
1226E:  MOVFF  8C4,8FC
12272:  MOVFF  8C3,8FB
12276:  MOVFF  8CA,902
1227A:  MOVFF  8C9,901
1227E:  MOVFF  8C8,900
12282:  MOVFF  8C7,8FF
12286:  CALL   C8F0
1228A:  MOVFF  03,8CE
1228E:  MOVFF  02,8CD
12292:  MOVFF  01,8CC
12296:  MOVFF  00,8CB
....................       SiO_abs_array[2] = log10(ratio); 
1229A:  MOVFF  8CE,8D2
1229E:  MOVFF  8CD,8D1
122A2:  MOVFF  8CC,8D0
122A6:  MOVFF  8CB,8CF
122AA:  CALL   10B8E
122AE:  MOVFF  03,3F0
122B2:  MOVFF  02,3EF
122B6:  MOVFF  01,3EE
122BA:  MOVFF  00,3ED
122BE:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
122C0:  MOVF   x9F,F
122C2:  BNZ   122C8
122C4:  MOVF   xA0,F
122C6:  BZ    12364
122C8:  MOVF   xA1,F
122CA:  BNZ   122D0
122CC:  MOVF   xA2,F
122CE:  BZ    12364
....................       blank = SiO_array[6]; 
122D0:  MOVFF  3A0,918
122D4:  MOVFF  39F,917
122D8:  MOVLB  0
122DA:  CALL   C8BA
122DE:  MOVFF  03,8C6
122E2:  MOVFF  02,8C5
122E6:  MOVFF  01,8C4
122EA:  MOVFF  00,8C3
....................       react = SiO_array[7]; 
122EE:  MOVFF  3A2,918
122F2:  MOVFF  3A1,917
122F6:  CALL   C8BA
122FA:  MOVFF  03,8CA
122FE:  MOVFF  02,8C9
12302:  MOVFF  01,8C8
12306:  MOVFF  00,8C7
....................       ratio = blank / react; 
1230A:  MOVFF  8C6,8FE
1230E:  MOVFF  8C5,8FD
12312:  MOVFF  8C4,8FC
12316:  MOVFF  8C3,8FB
1231A:  MOVFF  8CA,902
1231E:  MOVFF  8C9,901
12322:  MOVFF  8C8,900
12326:  MOVFF  8C7,8FF
1232A:  CALL   C8F0
1232E:  MOVFF  03,8CE
12332:  MOVFF  02,8CD
12336:  MOVFF  01,8CC
1233A:  MOVFF  00,8CB
....................       SiO_abs_array[3] = log10(ratio); 
1233E:  MOVFF  8CE,8D2
12342:  MOVFF  8CD,8D1
12346:  MOVFF  8CC,8D0
1234A:  MOVFF  8CB,8CF
1234E:  CALL   10B8E
12352:  MOVFF  03,3F4
12356:  MOVFF  02,3F3
1235A:  MOVFF  01,3F2
1235E:  MOVFF  00,3F1
12362:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
12364:  MOVLW  04
12366:  MOVWF  1E
12368:  MOVLW  25
1236A:  MOVWF  1D
1236C:  MOVLW  76
1236E:  MOVWF  FF6
12370:  MOVLW  1F
12372:  MOVWF  FF7
12374:  MOVLW  00
12376:  MOVWF  FF8
12378:  MOVLW  06
1237A:  MOVLB  8
1237C:  MOVWF  xEB
1237E:  MOVLB  0
12380:  CALL   AACC
12384:  MOVLW  10
12386:  MOVWF  FE9
12388:  MOVFF  394,8F7
1238C:  MOVFF  393,8F6
12390:  CALL   AAFE
12394:  MOVLW  7F
12396:  MOVWF  FF6
12398:  MOVLW  1F
1239A:  MOVWF  FF7
1239C:  MOVLW  00
1239E:  MOVWF  FF8
123A0:  MOVLW  07
123A2:  MOVLB  8
123A4:  MOVWF  xEB
123A6:  MOVLB  0
123A8:  CALL   AACC
123AC:  MOVLW  10
123AE:  MOVWF  FE9
123B0:  MOVFF  396,8F7
123B4:  MOVFF  395,8F6
123B8:  CALL   AAFE
123BC:  MOVLW  89
123BE:  MOVWF  FF6
123C0:  MOVLW  1F
123C2:  MOVWF  FF7
123C4:  MOVLW  00
123C6:  MOVWF  FF8
123C8:  MOVLW  09
123CA:  MOVLB  8
123CC:  MOVWF  xEB
123CE:  MOVLB  0
123D0:  CALL   AACC
123D4:  MOVLW  89
123D6:  MOVWF  FE9
123D8:  MOVFF  3E8,8D2
123DC:  MOVFF  3E7,8D1
123E0:  MOVFF  3E6,8D0
123E4:  MOVFF  3E5,8CF
123E8:  MOVLW  04
123EA:  MOVLB  8
123EC:  MOVWF  xD3
123EE:  MOVLB  0
123F0:  CALL   10BFA
123F4:  MOVLW  97
123F6:  MOVWF  FF6
123F8:  MOVLW  1F
123FA:  MOVWF  FF7
123FC:  MOVLW  00
123FE:  MOVWF  FF8
12400:  MOVLW  07
12402:  MOVLB  8
12404:  MOVWF  xEB
12406:  MOVLB  0
12408:  CALL   AACC
1240C:  MOVLW  10
1240E:  MOVWF  FE9
12410:  MOVFF  398,8F7
12414:  MOVFF  397,8F6
12418:  CALL   AAFE
1241C:  MOVLW  A1
1241E:  MOVWF  FF6
12420:  MOVLW  1F
12422:  MOVWF  FF7
12424:  MOVLW  00
12426:  MOVWF  FF8
12428:  MOVLW  07
1242A:  MOVLB  8
1242C:  MOVWF  xEB
1242E:  MOVLB  0
12430:  CALL   AACC
12434:  MOVLW  10
12436:  MOVWF  FE9
12438:  MOVFF  39A,8F7
1243C:  MOVFF  399,8F6
12440:  CALL   AAFE
12444:  MOVLW  AB
12446:  MOVWF  FF6
12448:  MOVLW  1F
1244A:  MOVWF  FF7
1244C:  MOVLW  00
1244E:  MOVWF  FF8
12450:  MOVLW  09
12452:  MOVLB  8
12454:  MOVWF  xEB
12456:  MOVLB  0
12458:  CALL   AACC
1245C:  MOVLW  89
1245E:  MOVWF  FE9
12460:  MOVFF  3EC,8D2
12464:  MOVFF  3EB,8D1
12468:  MOVFF  3EA,8D0
1246C:  MOVFF  3E9,8CF
12470:  MOVLW  04
12472:  MOVLB  8
12474:  MOVWF  xD3
12476:  MOVLB  0
12478:  CALL   10BFA
1247C:  MOVLW  B9
1247E:  MOVWF  FF6
12480:  MOVLW  1F
12482:  MOVWF  FF7
12484:  MOVLW  00
12486:  MOVWF  FF8
12488:  MOVLW  07
1248A:  MOVLB  8
1248C:  MOVWF  xEB
1248E:  MOVLB  0
12490:  CALL   AACC
12494:  MOVLW  10
12496:  MOVWF  FE9
12498:  MOVFF  39C,8F7
1249C:  MOVFF  39B,8F6
124A0:  CALL   AAFE
124A4:  MOVLW  C3
124A6:  MOVWF  FF6
124A8:  MOVLW  1F
124AA:  MOVWF  FF7
124AC:  MOVLW  00
124AE:  MOVWF  FF8
124B0:  MOVLW  07
124B2:  MOVLB  8
124B4:  MOVWF  xEB
124B6:  MOVLB  0
124B8:  CALL   AACC
124BC:  MOVLW  10
124BE:  MOVWF  FE9
124C0:  MOVFF  39E,8F7
124C4:  MOVFF  39D,8F6
124C8:  CALL   AAFE
124CC:  MOVLW  CD
124CE:  MOVWF  FF6
124D0:  MOVLW  1F
124D2:  MOVWF  FF7
124D4:  MOVLW  00
124D6:  MOVWF  FF8
124D8:  MOVLW  09
124DA:  MOVLB  8
124DC:  MOVWF  xEB
124DE:  MOVLB  0
124E0:  CALL   AACC
124E4:  MOVLW  89
124E6:  MOVWF  FE9
124E8:  MOVFF  3F0,8D2
124EC:  MOVFF  3EF,8D1
124F0:  MOVFF  3EE,8D0
124F4:  MOVFF  3ED,8CF
124F8:  MOVLW  04
124FA:  MOVLB  8
124FC:  MOVWF  xD3
124FE:  MOVLB  0
12500:  CALL   10BFA
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
12504:  MOVF   1F,W
12506:  SUBLW  02
12508:  BNZ   1250E
1250A:  MOVF   20,F
1250C:  BZ    1254E
1250E:  MOVLW  DC
12510:  MOVWF  FF6
12512:  MOVLW  1F
12514:  MOVWF  FF7
12516:  MOVLW  00
12518:  MOVWF  FF8
1251A:  CLRF   1B
1251C:  BTFSC  FF2.7
1251E:  BSF    1B.7
12520:  BCF    FF2.7
12522:  MOVLW  09
12524:  MOVLB  A
12526:  MOVWF  x40
12528:  MOVLB  0
1252A:  CALL   1024
1252E:  BTFSC  1B.7
12530:  BSF    FF2.7
12532:  MOVLW  04
12534:  MOVWF  FEA
12536:  MOVLW  25
12538:  MOVWF  FE9
1253A:  CALL   7996
1253E:  MOVLW  0D
12540:  BTFSS  F9E.4
12542:  BRA    12540
12544:  MOVWF  FAD
12546:  MOVLW  0A
12548:  BTFSS  F9E.4
1254A:  BRA    12548
1254C:  MOVWF  FAD
1254E:  GOTO   125B4 (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
12552:  MOVLW  04
12554:  MOVWF  FEA
12556:  MOVLW  25
12558:  MOVWF  FE9
1255A:  MOVLW  00
1255C:  CALL   056C
12560:  TBLRD*-
12562:  TBLRD*+
12564:  MOVF   FF5,W
12566:  MOVWF  FEE
12568:  IORLW  00
1256A:  BNZ   12562
....................     
....................    switch (chem){ 
1256C:  MOVLW  EA
1256E:  MOVWF  FF6
12570:  MOVLW  1F
12572:  MOVWF  FF7
12574:  MOVLW  00
12576:  MOVWF  FF8
12578:  MOVLW  03
1257A:  MOVWF  FEA
1257C:  MOVLW  3D
1257E:  MOVWF  FE9
12580:  CALL   FE26
12584:  MOVF   01,W
12586:  BZ    1259A
12588:  XORLW  01
1258A:  BZ    125A0
1258C:  XORLW  03
1258E:  BZ    125A6
12590:  XORLW  01
12592:  BZ    125AC
12594:  XORLW  07
12596:  BZ    125B2
12598:  BRA    125B4
....................       case "NO3" : calc_abs_NO3(); 
1259A:  GOTO   10E10
....................          break; 
1259E:  BRA    125B4
....................       case "NO2" : calc_abs_NO2 (); 
125A0:  GOTO   112AC
....................          break;    
125A4:  BRA    125B4
....................       case "PO4" : calc_abs_PO4(); 
125A6:  GOTO   11754
....................          break; 
125AA:  BRA    125B4
....................       case "NH4" : calc_abs_NH4(); 
125AC:  GOTO   11BFE
....................          break; 
125B0:  BRA    125B4
....................       case "SiO" : calc_abs_SiO(); 
125B2:  BRA    120A8
....................          break; 
....................    } 
125B4:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
125B6:  CALL   D4EC
....................     
....................    if (data_available == TRUE) { 
125BA:  MOVLB  3
125BC:  DECFSZ x3B,W
125BE:  BRA    126C2
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
125C0:  MOVLB  8
125C2:  CLRF   xF9
125C4:  MOVLW  67
125C6:  MOVWF  xF8
125C8:  MOVLW  02
125CA:  MOVWF  xFB
125CC:  MOVLW  B7
125CE:  MOVWF  xFA
125D0:  MOVLB  0
125D2:  CALL   54DE
....................       strcat(data_buffer, comma); 
125D6:  MOVLB  8
125D8:  CLRF   xF9
125DA:  MOVLW  67
125DC:  MOVWF  xF8
125DE:  MOVLW  03
125E0:  MOVWF  xFB
125E2:  MOVLW  39
125E4:  MOVWF  xFA
125E6:  MOVLB  0
125E8:  CALL   54DE
....................       strcat(data_buffer, chem); 
125EC:  MOVLB  8
125EE:  CLRF   xF9
125F0:  MOVLW  67
125F2:  MOVWF  xF8
125F4:  MOVLW  03
125F6:  MOVWF  xFB
125F8:  MOVLW  3D
125FA:  MOVWF  xFA
125FC:  MOVLB  0
125FE:  CALL   54DE
....................       strcat(data_buffer, comma); 
12602:  MOVLB  8
12604:  CLRF   xF9
12606:  MOVLW  67
12608:  MOVWF  xF8
1260A:  MOVLW  03
1260C:  MOVWF  xFB
1260E:  MOVLW  39
12610:  MOVWF  xFA
12612:  MOVLB  0
12614:  CALL   54DE
....................       strcat(data_buffer, abs_str); 
12618:  MOVLB  8
1261A:  CLRF   xF9
1261C:  MOVLW  67
1261E:  MOVWF  xF8
12620:  MOVLW  04
12622:  MOVWF  xFB
12624:  MOVLW  25
12626:  MOVWF  xFA
12628:  MOVLB  0
1262A:  CALL   54DE
....................       strcat(data_buffer, endofline); 
1262E:  MOVLB  8
12630:  CLRF   xF9
12632:  MOVLW  67
12634:  MOVWF  xF8
12636:  MOVLW  07
12638:  MOVWF  xFB
1263A:  MOVLW  CE
1263C:  MOVWF  xFA
1263E:  MOVLB  0
12640:  CALL   54DE
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
12644:  MOVF   1F,W
12646:  SUBLW  04
12648:  BNZ   12668
1264A:  MOVF   20,F
1264C:  BNZ   12668
1264E:  CLRF   FEA
12650:  MOVLW  67
12652:  MOVWF  FE9
12654:  CALL   7996
12658:  MOVLW  0D
1265A:  BTFSS  F9E.4
1265C:  BRA    1265A
1265E:  MOVWF  FAD
12660:  MOVLW  0A
12662:  BTFSS  F9E.4
12664:  BRA    12662
12666:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
12668:  MOVLB  2
1266A:  MOVF   xDC,F
1266C:  BNZ   126C0
....................        
....................          buffer_select = 0; 
1266E:  MOVLB  0
12670:  CLRF   x66
....................           
....................          heartbeat(FALSE); 
12672:  MOVLB  8
12674:  CLRF   xED
12676:  MOVLB  0
12678:  CALL   5586
....................             append_data(file_ptr_rel_all); 
1267C:  MOVLW  02
1267E:  MOVLB  8
12680:  MOVWF  xEE
12682:  MOVLW  F9
12684:  MOVWF  xED
12686:  MOVLB  0
12688:  CALL   82F8
....................          heartbeat(TRUE);          
1268C:  MOVLW  01
1268E:  MOVLB  8
12690:  MOVWF  xED
12692:  MOVLB  0
12694:  CALL   5586
....................           
....................          heartbeat(FALSE); 
12698:  MOVLB  8
1269A:  CLRF   xED
1269C:  MOVLB  0
1269E:  CALL   5586
....................             append_data(file_ptr_rel_new);    
126A2:  MOVLW  03
126A4:  MOVLB  8
126A6:  MOVWF  xEE
126A8:  MOVLW  07
126AA:  MOVWF  xED
126AC:  MOVLB  0
126AE:  CALL   82F8
....................          heartbeat(TRUE); 
126B2:  MOVLW  01
126B4:  MOVLB  8
126B6:  MOVWF  xED
126B8:  MOVLB  0
126BA:  CALL   5586
126BE:  MOVLB  2
126C0:  MOVLB  3
....................       } 
....................    } 
126C2:  MOVLB  0
126C4:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D602:  MOVLW  2C
0D604:  MOVLB  8
0D606:  MOVWF  x9E
0D608:  CLRF   x9F
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D60A:  MOVLW  0D
0D60C:  MOVWF  xA0
0D60E:  MOVLW  0A
0D610:  MOVWF  xA1
0D612:  CLRF   xA2
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D614:  MOVLB  0
0D616:  RCALL  D4EC
....................    time_stamp(); 
0D618:  CALL   541A
....................    strcat(data_buffer, time_stmp_str); 
0D61C:  MOVLB  8
0D61E:  CLRF   xF9
0D620:  MOVLW  67
0D622:  MOVWF  xF8
0D624:  MOVLW  02
0D626:  MOVWF  xFB
0D628:  MOVLW  99
0D62A:  MOVWF  xFA
0D62C:  MOVLB  0
0D62E:  CALL   54DE
....................    strcat(data_buffer, comma); 
0D632:  MOVLB  8
0D634:  CLRF   xF9
0D636:  MOVLW  67
0D638:  MOVWF  xF8
0D63A:  MOVLW  08
0D63C:  MOVWF  xFB
0D63E:  MOVLW  9E
0D640:  MOVWF  xFA
0D642:  MOVLB  0
0D644:  CALL   54DE
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D648:  MOVLW  08
0D64A:  MOVWF  1E
0D64C:  MOVLW  A3
0D64E:  MOVWF  1D
0D650:  MOVFF  89D,8ED
0D654:  MOVLW  1B
0D656:  MOVLB  8
0D658:  MOVWF  xEE
0D65A:  MOVLB  0
0D65C:  CALL   5280
0D660:  MOVLW  2C
0D662:  MOVLB  8
0D664:  MOVWF  xFF
0D666:  MOVLB  0
0D668:  CALL   509E
0D66C:  MOVLW  10
0D66E:  MOVWF  FE9
0D670:  MOVFF  2A,8F7
0D674:  MOVFF  29,8F6
0D678:  CALL   AAFE
0D67C:  MOVLW  2C
0D67E:  MOVLB  8
0D680:  MOVWF  xFF
0D682:  MOVLB  0
0D684:  CALL   509E
0D688:  MOVLW  10
0D68A:  MOVWF  FE9
0D68C:  MOVFF  24,8F7
0D690:  MOVFF  23,8F6
0D694:  CALL   AAFE
0D698:  MOVLW  2C
0D69A:  MOVLB  8
0D69C:  MOVWF  xFF
0D69E:  MOVLB  0
0D6A0:  CALL   509E
0D6A4:  MOVLW  10
0D6A6:  MOVWF  FE9
0D6A8:  MOVFF  2C,8F7
0D6AC:  MOVFF  2B,8F6
0D6B0:  CALL   AAFE
0D6B4:  MOVLW  2C
0D6B6:  MOVLB  8
0D6B8:  MOVWF  xFF
0D6BA:  MOVLB  0
0D6BC:  CALL   509E
0D6C0:  MOVLW  10
0D6C2:  MOVWF  FE9
0D6C4:  MOVFF  2E,8F7
0D6C8:  MOVFF  2D,8F6
0D6CC:  CALL   AAFE
0D6D0:  MOVLW  2C
0D6D2:  MOVLB  8
0D6D4:  MOVWF  xFF
0D6D6:  MOVLB  0
0D6D8:  CALL   509E
0D6DC:  MOVLW  10
0D6DE:  MOVWF  FE9
0D6E0:  MOVFF  22,8F7
0D6E4:  MOVFF  21,8F6
0D6E8:  CALL   AAFE
0D6EC:  MOVLW  2C
0D6EE:  MOVLB  8
0D6F0:  MOVWF  xFF
0D6F2:  MOVLB  0
0D6F4:  CALL   509E
0D6F8:  MOVLW  10
0D6FA:  MOVWF  FE9
0D6FC:  MOVFF  7C8,8F7
0D700:  MOVFF  7C7,8F6
0D704:  CALL   AAFE
0D708:  MOVLW  2C
0D70A:  MOVLB  8
0D70C:  MOVWF  xFF
0D70E:  MOVLB  0
0D710:  CALL   509E
0D714:  MOVLW  10
0D716:  MOVWF  FE9
0D718:  MOVFF  7B6,8C2
0D71C:  MOVFF  7B5,8C1
0D720:  BRA    D500
....................    strcat(data_buffer, config_str); 
0D722:  MOVLB  8
0D724:  CLRF   xF9
0D726:  MOVLW  67
0D728:  MOVWF  xF8
0D72A:  MOVLW  08
0D72C:  MOVWF  xFB
0D72E:  MOVLW  A3
0D730:  MOVWF  xFA
0D732:  MOVLB  0
0D734:  CALL   54DE
....................    strcat(data_buffer, endofline); 
0D738:  MOVLB  8
0D73A:  CLRF   xF9
0D73C:  MOVLW  67
0D73E:  MOVWF  xF8
0D740:  MOVLW  08
0D742:  MOVWF  xFB
0D744:  MOVLW  A0
0D746:  MOVWF  xFA
0D748:  MOVLB  0
0D74A:  CALL   54DE
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D74E:  CLRF   FEA
0D750:  MOVLW  67
0D752:  MOVWF  FE9
0D754:  CALL   7996
0D758:  MOVLW  0D
0D75A:  BTFSS  F9E.4
0D75C:  BRA    D75A
0D75E:  MOVWF  FAD
0D760:  MOVLW  0A
0D762:  BTFSS  F9E.4
0D764:  BRA    D762
0D766:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D768:  MOVLB  2
0D76A:  MOVF   xDC,F
0D76C:  BNZ   D7C0
....................     
....................       buffer_select = 0; 
0D76E:  MOVLB  0
0D770:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
0D772:  MOVLB  8
0D774:  CLRF   xED
0D776:  MOVLB  0
0D778:  CALL   5586
....................          append_data(file_ptr_raw_all); 
0D77C:  MOVLW  02
0D77E:  MOVLB  8
0D780:  MOVWF  xEE
0D782:  MOVLW  DD
0D784:  MOVWF  xED
0D786:  MOVLB  0
0D788:  CALL   82F8
....................       heartbeat(TRUE);          
0D78C:  MOVLW  01
0D78E:  MOVLB  8
0D790:  MOVWF  xED
0D792:  MOVLB  0
0D794:  CALL   5586
....................        
....................       heartbeat(FALSE); 
0D798:  MOVLB  8
0D79A:  CLRF   xED
0D79C:  MOVLB  0
0D79E:  CALL   5586
....................          append_data(file_ptr_raw_new);    
0D7A2:  MOVLW  02
0D7A4:  MOVLB  8
0D7A6:  MOVWF  xEE
0D7A8:  MOVLW  EB
0D7AA:  MOVWF  xED
0D7AC:  MOVLB  0
0D7AE:  CALL   82F8
....................       heartbeat(TRUE); 
0D7B2:  MOVLW  01
0D7B4:  MOVLB  8
0D7B6:  MOVWF  xED
0D7B8:  MOVLB  0
0D7BA:  CALL   5586
0D7BE:  MOVLB  2
....................    } 
0D7C0:  MOVLB  0
0D7C2:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
15250:  MOVLW  2C
15252:  MOVLB  8
15254:  MOVWF  xA0
15256:  CLRF   xA1
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
15258:  MOVLW  0D
1525A:  MOVWF  xA2
1525C:  MOVLW  0A
1525E:  MOVWF  xA3
15260:  CLRF   xA4
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
15262:  MOVLB  0
15264:  CALL   D4EC
....................    time_stamp(); 
15268:  CALL   541A
....................    strcat(data_buffer, time_stmp_str); 
1526C:  MOVLB  8
1526E:  CLRF   xF9
15270:  MOVLW  67
15272:  MOVWF  xF8
15274:  MOVLW  02
15276:  MOVWF  xFB
15278:  MOVLW  99
1527A:  MOVWF  xFA
1527C:  MOVLB  0
1527E:  CALL   54DE
....................    strcat(data_buffer, comma); 
15282:  MOVLB  8
15284:  CLRF   xF9
15286:  MOVLW  67
15288:  MOVWF  xF8
1528A:  MOVLW  08
1528C:  MOVWF  xFB
1528E:  MOVLW  A0
15290:  MOVWF  xFA
15292:  MOVLB  0
15294:  CALL   54DE
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
15298:  MOVLW  08
1529A:  MOVWF  1E
1529C:  MOVLW  A5
1529E:  MOVWF  1D
152A0:  MOVFF  89D,8ED
152A4:  MOVLW  1B
152A6:  MOVLB  8
152A8:  MOVWF  xEE
152AA:  MOVLB  0
152AC:  CALL   5280
152B0:  MOVLW  2C
152B2:  MOVLB  8
152B4:  MOVWF  xFF
152B6:  MOVLB  0
152B8:  CALL   509E
152BC:  MOVLW  10
152BE:  MOVWF  FE9
152C0:  MOVFF  89F,8F7
152C4:  MOVFF  89E,8F6
152C8:  CALL   AAFE
....................    strcat(data_buffer, config_str); 
152CC:  MOVLB  8
152CE:  CLRF   xF9
152D0:  MOVLW  67
152D2:  MOVWF  xF8
152D4:  MOVLW  08
152D6:  MOVWF  xFB
152D8:  MOVLW  A5
152DA:  MOVWF  xFA
152DC:  MOVLB  0
152DE:  CALL   54DE
....................    strcat(data_buffer, endofline); 
152E2:  MOVLB  8
152E4:  CLRF   xF9
152E6:  MOVLW  67
152E8:  MOVWF  xF8
152EA:  MOVLW  08
152EC:  MOVWF  xFB
152EE:  MOVLW  A2
152F0:  MOVWF  xFA
152F2:  MOVLB  0
152F4:  CALL   54DE
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
152F8:  MOVF   1F,W
152FA:  SUBLW  04
152FC:  BNZ   1531C
152FE:  MOVF   20,F
15300:  BNZ   1531C
15302:  CLRF   FEA
15304:  MOVLW  67
15306:  MOVWF  FE9
15308:  CALL   7996
1530C:  MOVLW  0D
1530E:  BTFSS  F9E.4
15310:  BRA    1530E
15312:  MOVWF  FAD
15314:  MOVLW  0A
15316:  BTFSS  F9E.4
15318:  BRA    15316
1531A:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
1531C:  MOVLB  2
1531E:  MOVF   xDC,F
15320:  BNZ   15374
....................     
....................       buffer_select = 0; 
15322:  MOVLB  0
15324:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
15326:  MOVLB  8
15328:  CLRF   xED
1532A:  MOVLB  0
1532C:  CALL   5586
....................          append_data(file_ptr_raw_all); 
15330:  MOVLW  02
15332:  MOVLB  8
15334:  MOVWF  xEE
15336:  MOVLW  DD
15338:  MOVWF  xED
1533A:  MOVLB  0
1533C:  CALL   82F8
....................       heartbeat(TRUE);          
15340:  MOVLW  01
15342:  MOVLB  8
15344:  MOVWF  xED
15346:  MOVLB  0
15348:  CALL   5586
....................        
....................       heartbeat(FALSE); 
1534C:  MOVLB  8
1534E:  CLRF   xED
15350:  MOVLB  0
15352:  CALL   5586
....................          append_data(file_ptr_raw_new);    
15356:  MOVLW  02
15358:  MOVLB  8
1535A:  MOVWF  xEE
1535C:  MOVLW  EB
1535E:  MOVWF  xED
15360:  MOVLB  0
15362:  CALL   82F8
....................       heartbeat(TRUE); 
15366:  MOVLW  01
15368:  MOVLB  8
1536A:  MOVWF  xED
1536C:  MOVLB  0
1536E:  CALL   5586
15372:  MOVLB  2
....................    } 
15374:  MOVLB  0
15376:  GOTO   15512 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUvY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D334:  BSF    F90.7
....................    delay_ms(500); 
0D336:  MOVLW  02
0D338:  MOVLB  8
0D33A:  MOVWF  xC2
0D33C:  MOVLW  FA
0D33E:  MOVLB  9
0D340:  MOVWF  xEC
0D342:  MOVLB  0
0D344:  CALL   2910
0D348:  MOVLB  8
0D34A:  DECFSZ xC2,F
0D34C:  BRA    D33C
....................    bus_pwr_status=1; 
0D34E:  MOVLW  01
0D350:  MOVLB  4
0D352:  MOVWF  xB6
0D354:  MOVLB  0
0D356:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D358:  BCF    F90.7
....................    delay_ms(100); 
0D35A:  MOVLW  64
0D35C:  MOVLB  9
0D35E:  MOVWF  xEC
0D360:  MOVLB  0
0D362:  CALL   2910
....................    bus_pwr_status=0; 
0D366:  MOVLB  4
0D368:  CLRF   xB6
0D36A:  MOVLB  0
0D36C:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
17F5C:  MOVLB  8
17F5E:  CLRF   x97
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
17F60:  CLRF   x97
17F62:  MOVF   x97,W
17F64:  SUBLW  31
17F66:  BNC   17F7C
....................       string_arg[i] = 0; 
17F68:  CLRF   03
17F6A:  MOVF   x97,W
17F6C:  ADDLW  25
17F6E:  MOVWF  FE9
17F70:  MOVLW  08
17F72:  ADDWFC 03,W
17F74:  MOVWF  FEA
17F76:  CLRF   FEF
17F78:  INCF   x97,F
17F7A:  BRA    17F62
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
17F7C:  CLRF   x97
17F7E:  MOVF   x97,W
17F80:  SUBLW  31
17F82:  BNC   17FFC
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
17F84:  CLRF   03
17F86:  MOVF   x97,W
17F88:  ADDLW  25
17F8A:  MOVWF  FE9
17F8C:  MOVLW  08
17F8E:  ADDWFC 03,W
17F90:  MOVWF  FEA
17F92:  MOVFF  FEA,89B
17F96:  MOVFF  FE9,89A
17F9A:  MOVLB  0
17F9C:  CALL   0E38
17FA0:  MOVFF  89B,FEA
17FA4:  MOVFF  89A,FE9
17FA8:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
17FAC:  DECFSZ 4C,W
17FAE:  BRA    17FCC
....................       { 
....................          fputc(string_arg[i],COM_A); 
17FB0:  CLRF   03
17FB2:  MOVLB  8
17FB4:  MOVF   x97,W
17FB6:  ADDLW  25
17FB8:  MOVWF  FE9
17FBA:  MOVLW  08
17FBC:  ADDWFC 03,W
17FBE:  MOVWF  FEA
17FC0:  MOVFF  FEF,898
17FC4:  MOVF   x98,W
17FC6:  MOVLB  0
17FC8:  CALL   AE7C
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
17FCC:  CLRF   03
17FCE:  MOVLB  8
17FD0:  MOVF   x97,W
17FD2:  ADDLW  25
17FD4:  MOVWF  FE9
17FD6:  MOVLW  08
17FD8:  ADDWFC 03,W
17FDA:  MOVWF  FEA
17FDC:  MOVF   FEF,W
17FDE:  SUBLW  0D
17FE0:  BZ    17FF6
17FE2:  CLRF   03
17FE4:  MOVF   x97,W
17FE6:  ADDLW  25
17FE8:  MOVWF  FE9
17FEA:  MOVLW  08
17FEC:  ADDWFC 03,W
17FEE:  MOVWF  FEA
17FF0:  MOVF   FEF,W
17FF2:  SUBLW  0A
17FF4:  BNZ   17FF8
....................       { 
....................          break; 
17FF6:  BRA    17FFC
....................       } 
17FF8:  INCF   x97,F
17FFA:  BRA    17F7E
....................    } 
17FFC:  MOVLB  0
17FFE:  GOTO   18326 (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
181A4:  MOVLB  8
181A6:  CLRF   x97
....................    macro_arg = 0; 
181A8:  CLRF   x99
181AA:  CLRF   x98
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
181AC:  MOVF   x97,W
181AE:  SUBLW  0D
181B0:  BZ    1823C
....................       number = fgetc(COM_A); 
181B2:  MOVLB  0
181B4:  CALL   0E38
181B8:  MOVFF  01,897
....................       if (com_echo == TRUE) 
181BC:  DECFSZ 4C,W
181BE:  BRA    181D0
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
181C0:  MOVLB  8
181C2:  MOVF   x97,W
181C4:  SUBLW  0D
181C6:  BZ    181D2
181C8:  MOVF   x97,W
181CA:  MOVLB  0
181CC:  CALL   AE7C
181D0:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
181D2:  MOVF   x97,W
181D4:  SUBLW  2F
181D6:  BC    1820C
181D8:  MOVF   x97,W
181DA:  SUBLW  39
181DC:  BNC   1820C
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
181DE:  MOVLW  30
181E0:  SUBWF  x97,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
181E2:  MOVFF  899,A11
181E6:  MOVFF  898,A10
181EA:  MOVLB  A
181EC:  CLRF   x13
181EE:  MOVLW  0A
181F0:  MOVWF  x12
181F2:  MOVLB  0
181F4:  CALL   5C98
181F8:  MOVFF  02,899
181FC:  MOVFF  01,898
....................          macro_arg = macro_arg + number;                // for each number 
18200:  MOVLB  8
18202:  MOVF   x97,W
18204:  ADDWF  x98,F
18206:  MOVLW  00
18208:  ADDWFC x99,F
....................       } 
1820A:  BRA    1823A
....................       else if (number == CARRIAGE_RET) 
1820C:  MOVF   x97,W
1820E:  SUBLW  0D
18210:  BNZ   18232
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
18212:  INCFSZ x98,W
18214:  BRA    1821C
18216:  INCFSZ x99,W
18218:  BRA    1821C
1821A:  BRA    18228
1821C:  MOVFF  898,01
18220:  MOVFF  899,02
18224:  BRA    1823C
18226:  BRA    18230
....................          else return(65535); 
18228:  MOVLW  FF
1822A:  MOVWF  01
1822C:  MOVWF  02
1822E:  BRA    1823C
....................       } 
18230:  BRA    1823A
....................       else 
....................       { 
....................          return(65535); 
18232:  MOVLW  FF
18234:  MOVWF  01
18236:  MOVWF  02
18238:  BRA    1823C
....................       } 
1823A:  BRA    181AC
....................    } 
1823C:  MOVLB  0
1823E:  GOTO   18350 (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
17CE6:  MOVF   2F,W
17CE8:  MOVWF  00
17CEA:  MOVF   30,W
17CEC:  MOVWF  03
17CEE:  BNZ   17CF4
17CF0:  MOVF   00,F
17CF2:  BZ    17D1A
17CF4:  MOVF   03,W
17CF6:  BNZ   17D00
17CF8:  MOVLW  03
17CFA:  SUBWF  00,W
17CFC:  BTFSC  FD8.2
17CFE:  BRA    17DDE
17D00:  MOVF   03,W
17D02:  BNZ   17D0C
17D04:  MOVLW  01
17D06:  SUBWF  00,W
17D08:  BTFSC  FD8.2
17D0A:  BRA    17DDE
17D0C:  MOVF   03,W
17D0E:  BNZ   17D18
17D10:  MOVLW  02
17D12:  SUBWF  00,W
17D14:  BTFSC  FD8.2
17D16:  BRA    17E54
17D18:  BRA    17EC2
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
17D1A:  MOVLB  8
17D1C:  MOVF   x9B,F
17D1E:  BNZ   17D4E
17D20:  MOVF   x9A,W
17D22:  SUBLW  23
17D24:  BZ    17D48
17D26:  MOVF   x9A,W
17D28:  SUBLW  25
17D2A:  BZ    17D48
17D2C:  MOVF   x9A,W
17D2E:  SUBLW  3B
17D30:  BZ    17D48
17D32:  MOVF   x9A,W
17D34:  SUBLW  4D
17D36:  BZ    17D48
17D38:  MOVF   x9A,W
17D3A:  SUBLW  5A
17D3C:  BZ    17D48
17D3E:  MOVF   x9A,W
17D40:  SUBLW  72
17D42:  BZ    17D48
17D44:  MOVLW  00
17D46:  BRA    17D4A
17D48:  MOVLW  01
17D4A:  MOVWF  x9C
17D4C:  BRA    17DDA
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
17D4E:  MOVF   x9A,W
17D50:  SUBLW  23
17D52:  BZ    17DD6
17D54:  MOVF   x9A,W
17D56:  SUBLW  25
17D58:  BZ    17DD6
17D5A:  MOVF   x9A,W
17D5C:  SUBLW  2B
17D5E:  BZ    17DD6
17D60:  MOVF   x9A,W
17D62:  SUBLW  2D
17D64:  BZ    17DD6
17D66:  MOVF   x9A,W
17D68:  SUBLW  2F
17D6A:  BZ    17DD6
17D6C:  MOVF   x9A,W
17D6E:  SUBLW  3B
17D70:  BZ    17DD6
17D72:  MOVF   x9A,W
17D74:  SUBLW  41
17D76:  BZ    17DD6
17D78:  MOVF   x9A,W
17D7A:  SUBLW  42
17D7C:  BC    17D84
17D7E:  MOVF   x9A,W
17D80:  SUBLW  44
17D82:  BC    17DD6
17D84:  MOVF   x9A,W
17D86:  SUBLW  45
17D88:  BC    17D90
17D8A:  MOVF   x9A,W
17D8C:  SUBLW  48
17D8E:  BC    17DD6
17D90:  MOVF   x9A,W
17D92:  SUBLW  4A
17D94:  BC    17D9C
17D96:  MOVF   x9A,W
17D98:  SUBLW  4C
17D9A:  BC    17DD6
17D9C:  MOVF   x9A,W
17D9E:  SUBLW  4F
17DA0:  BC    17DA8
17DA2:  MOVF   x9A,W
17DA4:  SUBLW  55
17DA6:  BC    17DD6
17DA8:  MOVF   x9A,W
17DAA:  SUBLW  59
17DAC:  BZ    17DD6
17DAE:  MOVF   x9A,W
17DB0:  SUBLW  64
17DB2:  BZ    17DD6
17DB4:  MOVF   x9A,W
17DB6:  SUBLW  69
17DB8:  BZ    17DD6
17DBA:  MOVF   x9A,W
17DBC:  SUBLW  6C
17DBE:  BZ    17DD6
17DC0:  MOVF   x9A,W
17DC2:  SUBLW  70
17DC4:  BZ    17DD6
17DC6:  MOVF   x9A,W
17DC8:  SUBLW  72
17DCA:  BZ    17DD6
17DCC:  MOVF   x9A,W
17DCE:  SUBLW  76
17DD0:  BZ    17DD6
17DD2:  MOVLW  00
17DD4:  BRA    17DD8
17DD6:  MOVLW  01
17DD8:  MOVWF  x9C
....................          break; 
17DDA:  MOVLB  0
17DDC:  BRA    17EC2
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
17DDE:  MOVLB  8
17DE0:  MOVF   x9B,F
17DE2:  BNZ   17E0C
17DE4:  MOVF   x9A,W
17DE6:  SUBLW  23
17DE8:  BZ    17E06
17DEA:  MOVF   x9A,W
17DEC:  SUBLW  3B
17DEE:  BZ    17E06
17DF0:  MOVF   x9A,W
17DF2:  SUBLW  4A
17DF4:  BZ    17E06
17DF6:  MOVF   x9A,W
17DF8:  SUBLW  4D
17DFA:  BZ    17E06
17DFC:  MOVF   x9A,W
17DFE:  SUBLW  50
17E00:  BZ    17E06
17E02:  MOVLW  00
17E04:  BRA    17E08
17E06:  MOVLW  01
17E08:  MOVWF  x9C
17E0A:  BRA    17E50
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
17E0C:  MOVF   x9A,W
17E0E:  SUBLW  23
17E10:  BZ    17E4C
17E12:  MOVF   x9A,W
17E14:  SUBLW  2B
17E16:  BZ    17E4C
17E18:  MOVF   x9A,W
17E1A:  SUBLW  2D
17E1C:  BZ    17E4C
17E1E:  MOVF   x9A,W
17E20:  SUBLW  3B
17E22:  BZ    17E4C
17E24:  MOVF   x9A,W
17E26:  SUBLW  42
17E28:  BZ    17E4C
17E2A:  MOVF   x9A,W
17E2C:  SUBLW  47
17E2E:  BZ    17E4C
17E30:  MOVF   x9A,W
17E32:  SUBLW  4F
17E34:  BC    17E3C
17E36:  MOVF   x9A,W
17E38:  SUBLW  52
17E3A:  BC    17E4C
17E3C:  MOVF   x9A,W
17E3E:  SUBLW  54
17E40:  BZ    17E4C
17E42:  MOVF   x9A,W
17E44:  SUBLW  59
17E46:  BZ    17E4C
17E48:  MOVLW  00
17E4A:  BRA    17E4E
17E4C:  MOVLW  01
17E4E:  MOVWF  x9C
....................          break;   
17E50:  MOVLB  0
17E52:  BRA    17EC2
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17E54:  MOVLB  8
17E56:  MOVF   x9B,F
17E58:  BNZ   17E7C
17E5A:  MOVF   x9A,W
17E5C:  SUBLW  23
17E5E:  BZ    17E76
17E60:  MOVF   x9A,W
17E62:  SUBLW  3B
17E64:  BZ    17E76
17E66:  MOVF   x9A,W
17E68:  SUBLW  4D
17E6A:  BZ    17E76
17E6C:  MOVF   x9A,W
17E6E:  SUBLW  50
17E70:  BZ    17E76
17E72:  MOVLW  00
17E74:  BRA    17E78
17E76:  MOVLW  01
17E78:  MOVWF  x9C
17E7A:  BRA    17EC0
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
17E7C:  MOVF   x9A,W
17E7E:  SUBLW  23
17E80:  BZ    17EBC
17E82:  MOVF   x9A,W
17E84:  SUBLW  2B
17E86:  BZ    17EBC
17E88:  MOVF   x9A,W
17E8A:  SUBLW  2D
17E8C:  BZ    17EBC
17E8E:  MOVF   x9A,W
17E90:  SUBLW  3B
17E92:  BZ    17EBC
17E94:  MOVF   x9A,W
17E96:  SUBLW  42
17E98:  BC    17EA0
17E9A:  MOVF   x9A,W
17E9C:  SUBLW  44
17E9E:  BC    17EBC
17EA0:  MOVF   x9A,W
17EA2:  SUBLW  4F
17EA4:  BC    17EAC
17EA6:  MOVF   x9A,W
17EA8:  SUBLW  51
17EAA:  BC    17EBC
17EAC:  MOVF   x9A,W
17EAE:  SUBLW  53
17EB0:  BZ    17EBC
17EB2:  MOVF   x9A,W
17EB4:  SUBLW  59
17EB6:  BZ    17EBC
17EB8:  MOVLW  00
17EBA:  BRA    17EBE
17EBC:  MOVLW  01
17EBE:  MOVWF  x9C
....................          break;   
17EC0:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17EC2:  MOVLB  8
17EC4:  MOVFF  89C,01
17EC8:  MOVLB  0
17ECA:  GOTO   17EF6 (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17ECE:  MOVLW  01
17ED0:  MOVLB  8
17ED2:  MOVWF  x99
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17ED4:  MOVLB  0
17ED6:  CALL   0E38
17EDA:  MOVFF  01,898
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17EDE:  DECFSZ 4C,W
17EE0:  BRA    17EEC
17EE2:  MOVLB  8
17EE4:  MOVF   x98,W
17EE6:  MOVLB  0
17EE8:  CALL   AE7C
....................          valid_macro = check_macro(e, macro); 
17EEC:  MOVFF  898,89A
17EF0:  MOVFF  897,89B
17EF4:  BRA    17CE6
17EF6:  MOVFF  01,899
....................       if (valid_macro == TRUE) { 
17EFA:  MOVLB  8
17EFC:  DECFSZ x99,W
17EFE:  BRA    17F08
....................          return(e); 
17F00:  MOVFF  898,01
17F04:  BRA    17F14
....................       } 
17F06:  BRA    17F0E
....................       else return(0); 
17F08:  MOVLW  00
17F0A:  MOVWF  01
17F0C:  BRA    17F14
....................    } while (valid_macro == TRUE); 
17F0E:  DECFSZ x99,W
17F10:  BRA    17F14
17F12:  BRA    17ED4
17F14:  MOVLB  0
17F16:  GOTO   18308 (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
1828E:  BCF    FD8.0
18290:  MOVLB  8
18292:  RLCF   x9A,W
18294:  CLRF   03
18296:  ADDLW  D1
18298:  MOVWF  FE9
1829A:  MOVLW  07
1829C:  ADDWFC 03,W
1829E:  MOVWF  FEA
182A0:  MOVFF  FEC,8A0
182A4:  MOVF   FED,F
182A6:  MOVFF  FEF,89F
182AA:  MOVFF  89C,A11
182AE:  MOVFF  89B,A10
182B2:  MOVLB  A
182B4:  CLRF   x13
182B6:  MOVLW  03
182B8:  MOVWF  x12
182BA:  MOVLB  0
182BC:  CALL   5C98
182C0:  MOVF   01,W
182C2:  MOVLB  8
182C4:  ADDWF  x9F,W
182C6:  MOVWF  x9D
182C8:  MOVF   02,W
182CA:  ADDWFC xA0,W
182CC:  MOVWF  x9E
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
182CE:  MOVFF  89E,8A8
182D2:  MOVFF  89D,8A7
182D6:  MOVFF  897,8A9
182DA:  MOVLB  0
182DC:  RCALL  18002
....................     
....................    ++addr; 
182DE:  MOVLB  8
182E0:  INCF   x9D,F
182E2:  BTFSC  FD8.2
182E4:  INCF   x9E,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
182E6:  MOVFF  89E,8A0
182EA:  MOVFF  89D,89F
182EE:  MOVFF  899,8A2
182F2:  MOVFF  898,8A1
182F6:  MOVLB  0
182F8:  BRA    18242
182FA:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
18062:  BCF    FD8.0
18064:  MOVLB  8
18066:  RLCF   x98,W
18068:  CLRF   03
1806A:  ADDLW  D1
1806C:  MOVWF  FE9
1806E:  MOVLW  07
18070:  ADDWFC 03,W
18072:  MOVWF  FEA
18074:  MOVFF  FEC,8A1
18078:  MOVF   FED,F
1807A:  MOVFF  FEF,8A0
1807E:  MOVFF  89A,A11
18082:  MOVFF  899,A10
18086:  MOVLB  A
18088:  CLRF   x13
1808A:  MOVLW  03
1808C:  MOVWF  x12
1808E:  MOVLB  0
18090:  CALL   5C98
18094:  MOVF   01,W
18096:  MOVLB  8
18098:  ADDWF  xA0,W
1809A:  MOVWF  x9D
1809C:  MOVF   02,W
1809E:  ADDWFC xA1,W
180A0:  MOVWF  x9E
....................    write_ext_eeprom(addr, macro_cmd); 
180A2:  MOVFF  89E,8A8
180A6:  MOVFF  89D,8A7
180AA:  MOVFF  897,8A9
180AE:  MOVLB  0
180B0:  RCALL  18002
....................     
....................    int i = 0; 
180B2:  MOVLB  8
180B4:  CLRF   x9F
....................    addr = string_address[macro] + (count*50); 
180B6:  BCF    FD8.0
180B8:  RLCF   x98,W
180BA:  CLRF   03
180BC:  ADDLW  FB
180BE:  MOVWF  FE9
180C0:  MOVLW  07
180C2:  ADDWFC 03,W
180C4:  MOVWF  FEA
180C6:  MOVFF  FEC,8A1
180CA:  MOVF   FED,F
180CC:  MOVFF  FEF,8A0
180D0:  MOVFF  89C,A11
180D4:  MOVFF  89B,A10
180D8:  MOVLB  A
180DA:  CLRF   x13
180DC:  MOVLW  32
180DE:  MOVWF  x12
180E0:  MOVLB  0
180E2:  CALL   5C98
180E6:  MOVF   01,W
180E8:  MOVLB  8
180EA:  ADDWF  xA0,W
180EC:  MOVWF  x9D
180EE:  MOVF   02,W
180F0:  ADDWFC xA1,W
180F2:  MOVWF  x9E
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
180F4:  MOVF   x9C,F
180F6:  BNZ   1814C
180F8:  MOVF   x9B,W
180FA:  SUBLW  14
180FC:  BNC   1814C
....................       for(i = 0; i<50; i++) { 
180FE:  CLRF   x9F
18100:  MOVF   x9F,W
18102:  SUBLW  31
18104:  BNC   1814A
....................          write_ext_eeprom(addr + i, string_arg[i]); 
18106:  MOVF   x9F,W
18108:  ADDWF  x9D,W
1810A:  MOVWF  xA0
1810C:  MOVLW  00
1810E:  ADDWFC x9E,W
18110:  MOVWF  xA1
18112:  CLRF   03
18114:  MOVF   x9F,W
18116:  ADDLW  25
18118:  MOVWF  FE9
1811A:  MOVLW  08
1811C:  ADDWFC 03,W
1811E:  MOVWF  FEA
18120:  MOVFF  FEF,8A9
18124:  MOVFF  8A1,8A8
18128:  MOVFF  8A0,8A7
1812C:  MOVLB  0
1812E:  RCALL  18002
....................          if(string_arg[i] == 0){ 
18130:  CLRF   03
18132:  MOVLB  8
18134:  MOVF   x9F,W
18136:  ADDLW  25
18138:  MOVWF  FE9
1813A:  MOVLW  08
1813C:  ADDWFC 03,W
1813E:  MOVWF  FEA
18140:  MOVF   FEF,F
18142:  BNZ   18146
....................             break; 
18144:  BRA    1814A
....................          } 
18146:  INCF   x9F,F
18148:  BRA    18100
....................       
....................       } 
....................    }else{ 
1814A:  BRA    1819E
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
1814C:  MOVLW  D2
1814E:  MOVWF  FF6
18150:  MOVLW  20
18152:  MOVWF  FF7
18154:  MOVLW  00
18156:  MOVWF  FF8
18158:  CLRF   1B
1815A:  BTFSC  FF2.7
1815C:  BSF    1B.7
1815E:  BCF    FF2.7
18160:  MOVLW  1E
18162:  MOVLB  A
18164:  MOVWF  x40
18166:  MOVLB  0
18168:  CALL   1024
1816C:  BTFSC  1B.7
1816E:  BSF    FF2.7
18170:  MOVLW  10
18172:  MOVWF  FE9
18174:  CLRF   1B
18176:  BTFSC  FF2.7
18178:  BSF    1B.7
1817A:  BCF    FF2.7
1817C:  MOVFF  89A,A41
18180:  MOVFF  899,A40
18184:  CALL   11A6
18188:  BTFSC  1B.7
1818A:  BSF    FF2.7
1818C:  MOVLW  0A
1818E:  BTFSS  F9E.4
18190:  BRA    1818E
18192:  MOVWF  FAD
18194:  MOVLW  0D
18196:  BTFSS  F9E.4
18198:  BRA    18196
1819A:  MOVWF  FAD
1819C:  MOVLB  8
....................    } 
1819E:  MOVLB  0
181A0:  GOTO   18340 (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
184E0:  CALL   10588
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
184E4:  MOVLW  3B
184E6:  MOVLB  8
184E8:  MOVWF  x97
184EA:  CLRF   x99
184EC:  CLRF   x98
184EE:  CLRF   x9A
184F0:  CLRF   x9C
184F2:  CLRF   x9B
184F4:  MOVLB  0
184F6:  RCALL  1828E
....................     
....................    write_macro_line(59, 0, 1, 0); 
184F8:  MOVLW  3B
184FA:  MOVLB  8
184FC:  MOVWF  x97
184FE:  CLRF   x99
18500:  CLRF   x98
18502:  MOVLW  01
18504:  MOVWF  x9A
18506:  CLRF   x9C
18508:  CLRF   x9B
1850A:  MOVLB  0
1850C:  RCALL  1828E
....................    write_macro_line(59, 0, 2, 0); 
1850E:  MOVLW  3B
18510:  MOVLB  8
18512:  MOVWF  x97
18514:  CLRF   x99
18516:  CLRF   x98
18518:  MOVLW  02
1851A:  MOVWF  x9A
1851C:  CLRF   x9C
1851E:  CLRF   x9B
18520:  MOVLB  0
18522:  RCALL  1828E
....................    write_macro_line(59, 0, 3, 0); 
18524:  MOVLW  3B
18526:  MOVLB  8
18528:  MOVWF  x97
1852A:  CLRF   x99
1852C:  CLRF   x98
1852E:  MOVLW  03
18530:  MOVWF  x9A
18532:  CLRF   x9C
18534:  CLRF   x9B
18536:  MOVLB  0
18538:  RCALL  1828E
....................    write_macro_line(59, 0, 4, 0); 
1853A:  MOVLW  3B
1853C:  MOVLB  8
1853E:  MOVWF  x97
18540:  CLRF   x99
18542:  CLRF   x98
18544:  MOVLW  04
18546:  MOVWF  x9A
18548:  CLRF   x9C
1854A:  CLRF   x9B
1854C:  MOVLB  0
1854E:  RCALL  1828E
....................    write_macro_line(59, 0, 5, 0); 
18550:  MOVLW  3B
18552:  MOVLB  8
18554:  MOVWF  x97
18556:  CLRF   x99
18558:  CLRF   x98
1855A:  MOVLW  05
1855C:  MOVWF  x9A
1855E:  CLRF   x9C
18560:  CLRF   x9B
18562:  MOVLB  0
18564:  RCALL  1828E
....................    write_macro_line(59, 0, 6, 0); 
18566:  MOVLW  3B
18568:  MOVLB  8
1856A:  MOVWF  x97
1856C:  CLRF   x99
1856E:  CLRF   x98
18570:  MOVLW  06
18572:  MOVWF  x9A
18574:  CLRF   x9C
18576:  CLRF   x9B
18578:  MOVLB  0
1857A:  RCALL  1828E
....................    write_macro_line(59, 0, 7, 0); 
1857C:  MOVLW  3B
1857E:  MOVLB  8
18580:  MOVWF  x97
18582:  CLRF   x99
18584:  CLRF   x98
18586:  MOVLW  07
18588:  MOVWF  x9A
1858A:  CLRF   x9C
1858C:  CLRF   x9B
1858E:  MOVLB  0
18590:  RCALL  1828E
....................    write_macro_line(59, 0, 8, 0); 
18592:  MOVLW  3B
18594:  MOVLB  8
18596:  MOVWF  x97
18598:  CLRF   x99
1859A:  CLRF   x98
1859C:  MOVLW  08
1859E:  MOVWF  x9A
185A0:  CLRF   x9C
185A2:  CLRF   x9B
185A4:  MOVLB  0
185A6:  RCALL  1828E
....................     
....................    write_macro_line(59, 0, 9, 0); 
185A8:  MOVLW  3B
185AA:  MOVLB  8
185AC:  MOVWF  x97
185AE:  CLRF   x99
185B0:  CLRF   x98
185B2:  MOVLW  09
185B4:  MOVWF  x9A
185B6:  CLRF   x9C
185B8:  CLRF   x9B
185BA:  MOVLB  0
185BC:  RCALL  1828E
....................    write_macro_line(59, 0, 10, 0); 
185BE:  MOVLW  3B
185C0:  MOVLB  8
185C2:  MOVWF  x97
185C4:  CLRF   x99
185C6:  CLRF   x98
185C8:  MOVLW  0A
185CA:  MOVWF  x9A
185CC:  CLRF   x9C
185CE:  CLRF   x9B
185D0:  MOVLB  0
185D2:  RCALL  1828E
....................    write_macro_line(59, 0, 11, 0); 
185D4:  MOVLW  3B
185D6:  MOVLB  8
185D8:  MOVWF  x97
185DA:  CLRF   x99
185DC:  CLRF   x98
185DE:  MOVLW  0B
185E0:  MOVWF  x9A
185E2:  CLRF   x9C
185E4:  CLRF   x9B
185E6:  MOVLB  0
185E8:  RCALL  1828E
....................    write_macro_line(59, 0, 12, 0); 
185EA:  MOVLW  3B
185EC:  MOVLB  8
185EE:  MOVWF  x97
185F0:  CLRF   x99
185F2:  CLRF   x98
185F4:  MOVLW  0C
185F6:  MOVWF  x9A
185F8:  CLRF   x9C
185FA:  CLRF   x9B
185FC:  MOVLB  0
185FE:  RCALL  1828E
....................    write_macro_line(59, 0, 13, 0); 
18600:  MOVLW  3B
18602:  MOVLB  8
18604:  MOVWF  x97
18606:  CLRF   x99
18608:  CLRF   x98
1860A:  MOVLW  0D
1860C:  MOVWF  x9A
1860E:  CLRF   x9C
18610:  CLRF   x9B
18612:  MOVLB  0
18614:  RCALL  1828E
....................    write_macro_line(59, 0, 14, 0); 
18616:  MOVLW  3B
18618:  MOVLB  8
1861A:  MOVWF  x97
1861C:  CLRF   x99
1861E:  CLRF   x98
18620:  MOVLW  0E
18622:  MOVWF  x9A
18624:  CLRF   x9C
18626:  CLRF   x9B
18628:  MOVLB  0
1862A:  RCALL  1828E
....................    write_macro_line(59, 0, 15, 0); 
1862C:  MOVLW  3B
1862E:  MOVLB  8
18630:  MOVWF  x97
18632:  CLRF   x99
18634:  CLRF   x98
18636:  MOVLW  0F
18638:  MOVWF  x9A
1863A:  CLRF   x9C
1863C:  CLRF   x9B
1863E:  MOVLB  0
18640:  RCALL  1828E
....................    write_macro_line(59, 0, 16, 0); 
18642:  MOVLW  3B
18644:  MOVLB  8
18646:  MOVWF  x97
18648:  CLRF   x99
1864A:  CLRF   x98
1864C:  MOVLW  10
1864E:  MOVWF  x9A
18650:  CLRF   x9C
18652:  CLRF   x9B
18654:  MOVLB  0
18656:  RCALL  1828E
18658:  GOTO   18690 (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
17F1A:  MOVLB  8
17F1C:  CLRF   x97
....................     
....................    heartbeat(FALSE); 
17F1E:  CLRF   xED
17F20:  MOVLB  0
17F22:  CALL   5586
....................     
....................    while(mcc != CARRIAGE_RET){ 
17F26:  MOVLB  8
17F28:  MOVF   x97,W
17F2A:  SUBLW  0D
17F2C:  BZ    17F4E
....................       if (kbhit(COM_A)) { 
17F2E:  BTFSS  F9E.5
17F30:  BRA    17F4C
....................          mcc=fgetc(COM_A); 
17F32:  MOVLB  0
17F34:  CALL   0E38
17F38:  MOVFF  01,897
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
17F3C:  DECFSZ 4C,W
17F3E:  BRA    17F4A
17F40:  MOVLB  8
17F42:  MOVF   x97,W
17F44:  MOVLB  0
17F46:  CALL   AE7C
17F4A:  MOVLB  8
....................       } 
17F4C:  BRA    17F28
....................    } 
....................     
....................    heartbeat(TRUE); 
17F4E:  MOVLW  01
17F50:  MOVWF  xED
17F52:  MOVLB  0
17F54:  CALL   5586
17F58:  GOTO   18318 (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
182FC:  MOVLB  8
182FE:  CLRF   x96
....................     
....................    macro_cmd = get_cmd(macro); 
18300:  MOVFF  88E,897
18304:  MOVLB  0
18306:  BRA    17ECE
18308:  MOVFF  01,893
....................    if (macro_cmd == 35){  
1830C:  MOVLB  8
1830E:  MOVF   x93,W
18310:  SUBLW  23
18312:  BNZ   1831C
....................       macro_comment();        // # = 35 
18314:  MOVLB  0
18316:  BRA    17F1A
....................    }else if(macro_cmd == 112){// 112 is p 
18318:  BRA    1839E
1831A:  MOVLB  8
1831C:  MOVF   x93,W
1831E:  SUBLW  70
18320:  BNZ   18348
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
18322:  MOVLB  0
18324:  BRA    17F5C
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
18326:  MOVFF  893,897
1832A:  MOVFF  88E,898
1832E:  MOVFF  890,89A
18332:  MOVFF  88F,899
18336:  MOVFF  892,89C
1833A:  MOVFF  891,89B
1833E:  BRA    18062
....................       valid_macro = TRUE; 
18340:  MOVLW  01
18342:  MOVLB  8
18344:  MOVWF  x96
....................    }else{ 
18346:  BRA    1839C
....................       if (macro_cmd != 0) { 
18348:  MOVF   x93,F
1834A:  BZ    18372
....................          macro_arg = get_arg(); 
1834C:  MOVLB  0
1834E:  BRA    181A4
18350:  MOVFF  02,895
18354:  MOVFF  01,894
....................          if (macro_arg != 65535) valid_macro = TRUE; 
18358:  MOVLB  8
1835A:  INCFSZ x94,W
1835C:  BRA    18364
1835E:  INCFSZ x95,W
18360:  BRA    18364
18362:  BRA    1836A
18364:  MOVLW  01
18366:  MOVWF  x96
18368:  BRA    18370
....................          else return(macro_cmd); 
1836A:  MOVFF  893,01
1836E:  BRA    183A4
....................       }else return(macro_cmd); 
18370:  BRA    18378
18372:  MOVFF  893,01
18376:  BRA    183A4
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
18378:  MOVFF  893,897
1837C:  MOVFF  895,899
18380:  MOVFF  894,898
18384:  MOVFF  88E,89A
18388:  MOVFF  890,89C
1838C:  MOVFF  88F,89B
18390:  MOVLB  0
18392:  RCALL  1828E
....................       return(macro_cmd); 
18394:  MOVLB  8
18396:  MOVFF  893,01
1839A:  BRA    183A4
1839C:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
1839E:  MOVLB  8
183A0:  MOVFF  893,01
183A4:  MOVLB  0
183A6:  GOTO   183EC (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
183AA:  MOVLB  8
183AC:  CLRF   x8D
183AE:  CLRF   x8C
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
183B0:  CLRF   x88
183B2:  CLRF   x87
....................    valid_macro = TRUE; 
183B4:  MOVLW  01
183B6:  MOVWF  x89
....................    macro_cmd = 1; 
183B8:  MOVWF  x8A
....................     
....................    init_ext_eeprom(); 
183BA:  MOVLB  0
183BC:  CALL   10588
....................     
....................    fprintf(COM_A, ":"); 
183C0:  MOVLW  3A
183C2:  BTFSS  F9E.4
183C4:  BRA    183C2
183C6:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
183C8:  MOVLB  8
183CA:  MOVF   x8A,W
183CC:  SUBLW  3B
183CE:  BZ    18432
183D0:  MOVF   x8A,F
183D2:  BZ    18432
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
183D4:  MOVFF  886,88E
183D8:  MOVFF  888,890
183DC:  MOVFF  887,88F
183E0:  MOVFF  88D,892
183E4:  MOVFF  88C,891
183E8:  MOVLB  0
183EA:  BRA    182FC
183EC:  MOVFF  01,88A
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
183F0:  MOVLB  8
183F2:  MOVF   x8A,W
183F4:  SUBLW  70
183F6:  BNZ   183FE
....................          count++; 
183F8:  INCF   x8C,F
183FA:  BTFSC  FD8.2
183FC:  INCF   x8D,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
183FE:  MOVF   x8A,W
18400:  SUBLW  23
18402:  BZ    1840A
18404:  INCF   x87,F
18406:  BTFSC  FD8.2
18408:  INCF   x88,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
1840A:  MOVF   x8A,W
1840C:  SUBLW  3B
1840E:  BZ    18430
18410:  MOVLW  F6
18412:  MOVWF  FF6
18414:  MOVLW  20
18416:  MOVWF  FF7
18418:  MOVLW  00
1841A:  MOVWF  FF8
1841C:  CLRF   1B
1841E:  BTFSC  FF2.7
18420:  BSF    1B.7
18422:  BCF    FF2.7
18424:  MOVLB  0
18426:  CALL   0E4E
1842A:  BTFSC  1B.7
1842C:  BSF    FF2.7
1842E:  MOVLB  8
18430:  BRA    183CA
....................    }       
....................    if (macro_cmd == 0){ 
18432:  MOVF   x8A,F
18434:  BNZ   184CA
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
18436:  MOVLW  FA
18438:  MOVWF  FF6
1843A:  MOVLW  20
1843C:  MOVWF  FF7
1843E:  MOVLW  00
18440:  MOVWF  FF8
18442:  CLRF   1B
18444:  BTFSC  FF2.7
18446:  BSF    1B.7
18448:  BCF    FF2.7
1844A:  MOVLB  0
1844C:  CALL   0E4E
18450:  BTFSC  1B.7
18452:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
18454:  MOVLW  22
18456:  MOVWF  FF6
18458:  MOVLW  21
1845A:  MOVWF  FF7
1845C:  MOVLW  00
1845E:  MOVWF  FF8
18460:  CLRF   1B
18462:  BTFSC  FF2.7
18464:  BSF    1B.7
18466:  BCF    FF2.7
18468:  MOVLW  15
1846A:  MOVLB  A
1846C:  MOVWF  x40
1846E:  MOVLB  0
18470:  CALL   1024
18474:  BTFSC  1B.7
18476:  BSF    FF2.7
18478:  MOVLW  10
1847A:  MOVWF  FE9
1847C:  MOVFF  888,8F1
18480:  MOVFF  887,8F0
18484:  CALL   8FE4
18488:  MOVLW  3A
1848A:  MOVWF  FF6
1848C:  MOVLW  21
1848E:  MOVWF  FF7
18490:  MOVLW  00
18492:  MOVWF  FF8
18494:  CLRF   1B
18496:  BTFSC  FF2.7
18498:  BSF    1B.7
1849A:  BCF    FF2.7
1849C:  MOVLW  03
1849E:  MOVLB  A
184A0:  MOVWF  x40
184A2:  MOVLB  0
184A4:  CALL   1024
184A8:  BTFSC  1B.7
184AA:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
184AC:  MOVLW  3E
184AE:  MOVWF  FF6
184B0:  MOVLW  21
184B2:  MOVWF  FF7
184B4:  MOVLW  00
184B6:  MOVWF  FF8
184B8:  CLRF   1B
184BA:  BTFSC  FF2.7
184BC:  BSF    1B.7
184BE:  BCF    FF2.7
184C0:  CALL   0E4E
184C4:  BTFSC  1B.7
184C6:  BSF    FF2.7
184C8:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
184CA:  MOVLW  0D
184CC:  BTFSS  F9E.4
184CE:  BRA    184CC
184D0:  MOVWF  FAD
184D2:  MOVLW  0A
184D4:  BTFSS  F9E.4
184D6:  BRA    184D4
184D8:  MOVWF  FAD
184DA:  MOVLB  0
184DC:  GOTO   18678 (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
1869A:  BCF    FD8.0
1869C:  MOVLB  8
1869E:  RLCF   x8B,W
186A0:  CLRF   03
186A2:  ADDLW  D1
186A4:  MOVWF  FE9
186A6:  MOVLW  07
186A8:  ADDWFC 03,W
186AA:  MOVWF  FEA
186AC:  MOVFF  FEC,894
186B0:  MOVF   FED,F
186B2:  MOVFF  FEF,893
186B6:  MOVFF  88D,A11
186BA:  MOVFF  88C,A10
186BE:  MOVLB  A
186C0:  CLRF   x13
186C2:  MOVLW  03
186C4:  MOVWF  x12
186C6:  MOVLB  0
186C8:  CALL   5C98
186CC:  MOVF   01,W
186CE:  MOVLB  8
186D0:  ADDWF  x93,W
186D2:  MOVWF  x8E
186D4:  MOVF   02,W
186D6:  ADDWFC x94,W
186D8:  MOVWF  x8F
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
186DA:  MOVFF  88F,8CC
186DE:  MOVFF  88E,8CB
186E2:  MOVLB  0
186E4:  CALL   105C0
186E8:  MOVFF  01,890
....................    ++addr; 
186EC:  MOVLB  8
186EE:  INCF   x8E,F
186F0:  BTFSC  FD8.2
186F2:  INCF   x8F,F
....................    macro_arg = read16_ext_eeprom(addr); 
186F4:  MOVFF  88F,8C3
186F8:  MOVFF  88E,8C2
186FC:  MOVLB  0
186FE:  CALL   106D4
18702:  MOVFF  02,892
18706:  MOVFF  01,891
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
1870A:  MOVLB  8
1870C:  MOVF   x90,W
1870E:  BTFSS  F9E.4
18710:  BRA    1870E
18712:  MOVWF  FAD
18714:  MOVLW  10
18716:  MOVWF  FE9
18718:  CLRF   1B
1871A:  BTFSC  FF2.7
1871C:  BSF    1B.7
1871E:  BCF    FF2.7
18720:  MOVFF  892,A41
18724:  MOVFF  891,A40
18728:  MOVLB  0
1872A:  CALL   11A6
1872E:  BTFSC  1B.7
18730:  BSF    FF2.7
18732:  MOVLW  0D
18734:  BTFSS  F9E.4
18736:  BRA    18734
18738:  MOVWF  FAD
1873A:  MOVLW  0A
1873C:  BTFSS  F9E.4
1873E:  BRA    1873C
18740:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
18742:  MOVLB  8
18744:  MOVFF  890,01
18748:  MOVLB  0
1874A:  GOTO   1877E (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
14300:  BCF    FD8.0
14302:  MOVLB  8
14304:  RLCF   xB7,W
14306:  CLRF   03
14308:  ADDLW  D1
1430A:  MOVWF  FE9
1430C:  MOVLW  07
1430E:  ADDWFC 03,W
14310:  MOVWF  FEA
14312:  MOVFF  FEC,8C0
14316:  MOVF   FED,F
14318:  MOVFF  FEF,8BF
1431C:  MOVFF  8B9,A11
14320:  MOVFF  8B8,A10
14324:  MOVLB  A
14326:  CLRF   x13
14328:  MOVLW  03
1432A:  MOVWF  x12
1432C:  MOVLB  0
1432E:  CALL   5C98
14332:  MOVF   01,W
14334:  MOVLB  8
14336:  ADDWF  xBF,W
14338:  MOVWF  xBA
1433A:  MOVF   02,W
1433C:  ADDWFC xC0,W
1433E:  MOVWF  xBB
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
14340:  MOVFF  8BB,8CC
14344:  MOVFF  8BA,8CB
14348:  MOVLB  0
1434A:  CALL   105C0
1434E:  MOVFF  01,8BC
....................    ++addr; 
14352:  MOVLB  8
14354:  INCF   xBA,F
14356:  BTFSC  FD8.2
14358:  INCF   xBB,F
....................    macro_arg = read16_ext_eeprom(addr); 
1435A:  MOVFF  8BB,8C3
1435E:  MOVFF  8BA,8C2
14362:  MOVLB  0
14364:  CALL   106D4
14368:  MOVFF  02,8BE
1436C:  MOVFF  01,8BD
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
14370:  MOVLB  8
14372:  MOVF   xBC,W
14374:  BTFSS  F9E.4
14376:  BRA    14374
14378:  MOVWF  FAD
1437A:  MOVLW  10
1437C:  MOVWF  FE9
1437E:  CLRF   1B
14380:  BTFSC  FF2.7
14382:  BSF    1B.7
14384:  BCF    FF2.7
14386:  MOVFF  8BE,A41
1438A:  MOVFF  8BD,A40
1438E:  MOVLB  0
14390:  CALL   11A6
14394:  BTFSC  1B.7
14396:  BSF    FF2.7
14398:  MOVLW  0D
1439A:  BTFSS  F9E.4
1439C:  BRA    1439A
1439E:  MOVWF  FAD
143A0:  MOVLW  0A
143A2:  BTFSS  F9E.4
143A4:  BRA    143A2
143A6:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
143A8:  MOVLB  8
143AA:  MOVFF  8BC,01
143AE:  MOVLB  0
143B0:  GOTO   14B88 (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
1061A:  BCF    FD8.0
1061C:  MOVLB  8
1061E:  RLCF   xB5,W
10620:  CLRF   03
10622:  ADDLW  FB
10624:  MOVWF  FE9
10626:  MOVLW  07
10628:  ADDWFC 03,W
1062A:  MOVWF  FEA
1062C:  MOVFF  FEC,8BE
10630:  MOVF   FED,F
10632:  MOVFF  FEF,8BD
10636:  MOVFF  8B9,A11
1063A:  MOVFF  8B8,A10
1063E:  MOVLB  A
10640:  CLRF   x13
10642:  MOVLW  32
10644:  MOVWF  x12
10646:  MOVLB  0
10648:  CALL   5C98
1064C:  MOVF   01,W
1064E:  MOVLB  8
10650:  ADDWF  xBD,W
10652:  MOVWF  xBA
10654:  MOVF   02,W
10656:  ADDWFC xBE,W
10658:  MOVWF  xBB
....................     
....................    int i = 0; 
1065A:  CLRF   xBC
....................    for(i = 0; i < 50; i++){ 
1065C:  CLRF   xBC
1065E:  MOVF   xBC,W
10660:  SUBLW  31
10662:  BNC   10678
....................       string_arg[i] = 0; 
10664:  CLRF   03
10666:  MOVF   xBC,W
10668:  ADDLW  25
1066A:  MOVWF  FE9
1066C:  MOVLW  08
1066E:  ADDWFC 03,W
10670:  MOVWF  FEA
10672:  CLRF   FEF
10674:  INCF   xBC,F
10676:  BRA    1065E
....................    }  
....................    for(i = 0; i < 50; i++){ 
10678:  CLRF   xBC
1067A:  MOVF   xBC,W
1067C:  SUBLW  31
1067E:  BNC   106D0
....................       string_arg[i] = read_ext_eeprom(addr + i); 
10680:  CLRF   03
10682:  MOVF   xBC,W
10684:  ADDLW  25
10686:  MOVWF  01
10688:  MOVLW  08
1068A:  ADDWFC 03,F
1068C:  MOVFF  01,8BD
10690:  MOVFF  03,8BE
10694:  MOVF   xBC,W
10696:  ADDWF  xBA,W
10698:  MOVWF  xBF
1069A:  MOVLW  00
1069C:  ADDWFC xBB,W
1069E:  MOVWF  xC0
106A0:  MOVWF  xCC
106A2:  MOVFF  8BF,8CB
106A6:  MOVLB  0
106A8:  RCALL  105C0
106AA:  MOVFF  8BE,FEA
106AE:  MOVFF  8BD,FE9
106B2:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
106B6:  CLRF   03
106B8:  MOVLB  8
106BA:  MOVF   xBC,W
106BC:  ADDLW  25
106BE:  MOVWF  FE9
106C0:  MOVLW  08
106C2:  ADDWFC 03,W
106C4:  MOVWF  FEA
106C6:  MOVF   FEF,F
106C8:  BNZ   106CC
....................          break; 
106CA:  BRA    106D0
....................       } 
106CC:  INCF   xBC,F
106CE:  BRA    1067A
....................    }   
106D0:  MOVLB  0
106D2:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
1874E:  MOVLB  8
18750:  CLRF   x8A
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
18752:  CLRF   x88
18754:  CLRF   x87
....................    macro_cmd = 1; 
18756:  MOVLW  01
18758:  MOVWF  x89
....................     
....................    init_ext_eeprom(); 
1875A:  MOVLB  0
1875C:  CALL   10588
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
18760:  MOVLB  8
18762:  MOVF   x88,W
18764:  SUBLW  03
18766:  BNC   187AE
18768:  MOVF   x89,W
1876A:  SUBLW  3B
1876C:  BZ    187AE
....................       macro_cmd = read_macro_line(macro, line); 
1876E:  MOVFF  886,88B
18772:  MOVFF  888,88D
18776:  MOVFF  887,88C
1877A:  MOVLB  0
1877C:  BRA    1869A
1877E:  MOVFF  01,889
....................       if(macro_cmd == 'p'){ 
18782:  MOVLB  8
18784:  MOVF   x89,W
18786:  SUBLW  70
18788:  BNZ   187A6
....................          read_macro_line_string(macro,line,count); 
1878A:  MOVFF  886,8B5
1878E:  MOVFF  888,8B7
18792:  MOVFF  887,8B6
18796:  CLRF   xB9
18798:  MOVFF  88A,8B8
1879C:  MOVLB  0
1879E:  CALL   1061A
....................          count++; 
187A2:  MOVLB  8
187A4:  INCF   x8A,F
....................       } 
....................       ++line; 
187A6:  INCF   x87,F
187A8:  BTFSC  FD8.2
187AA:  INCF   x88,F
187AC:  BRA    18762
....................    } 
187AE:  MOVLB  0
187B0:  GOTO   187D0 (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D2FE:  MOVLB  8
0D300:  CLRF   xC5
0D302:  CLRF   xC4
0D304:  MOVF   xC5,W
0D306:  SUBWF  xC3,W
0D308:  BNC   D330
0D30A:  BNZ   D312
0D30C:  MOVF   xC2,W
0D30E:  SUBWF  xC4,W
0D310:  BC    D330
....................       delay_ms(1000); 
0D312:  MOVLW  04
0D314:  MOVWF  xC6
0D316:  MOVLW  FA
0D318:  MOVLB  9
0D31A:  MOVWF  xEC
0D31C:  MOVLB  0
0D31E:  CALL   2910
0D322:  MOVLB  8
0D324:  DECFSZ xC6,F
0D326:  BRA    D316
0D328:  INCF   xC4,F
0D32A:  BTFSC  FD8.2
0D32C:  INCF   xC5,F
0D32E:  BRA    D304
....................    }  
0D330:  MOVLB  0
0D332:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0D2C6:  BCF    FD8.0
0D2C8:  MOVLB  7
0D2CA:  RLCF   x40,W
0D2CC:  CLRF   03
0D2CE:  ADDLW  96
0D2D0:  MOVWF  FE9
0D2D2:  MOVLW  07
0D2D4:  ADDWFC 03,W
0D2D6:  MOVWF  FEA
0D2D8:  MOVFF  FEC,8C4
0D2DC:  MOVF   FED,F
0D2DE:  MOVFF  FEF,8C3
0D2E2:  MOVLB  8
0D2E4:  DECFSZ xC3,W
0D2E6:  BRA    D2F2
0D2E8:  MOVF   xC4,F
0D2EA:  BNZ   D2F2
....................    { 
....................       macro_status = 'e'; 
0D2EC:  MOVLW  65
0D2EE:  MOVWF  xC2
....................    } 
0D2F0:  BRA    D2F6
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D2F2:  MOVLW  61
0D2F4:  MOVWF  xC2
....................    } 
....................    return(macro_status); 
0D2F6:  MOVFF  8C2,01
0D2FA:  MOVLB  0
0D2FC:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
1381C:  DECFSZ 45,W
1381E:  BRA    13832
13820:  MOVF   46,F
13822:  BNZ   13832
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
13824:  MOVLW  01
13826:  MOVLB  8
13828:  MOVWF  xC2
1382A:  MOVWF  xC3
1382C:  MOVLB  0
1382E:  RCALL  136E6
....................    } 
13830:  BRA    1385C
....................    else if(nv_det_type==2 || nv_det_type==3) 
13832:  MOVF   45,W
13834:  SUBLW  02
13836:  BNZ   1383C
13838:  MOVF   46,F
1383A:  BZ    13846
1383C:  MOVF   45,W
1383E:  SUBLW  03
13840:  BNZ   1385C
13842:  MOVF   46,F
13844:  BNZ   1385C
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
13846:  MOVLB  8
13848:  CLRF   xC3
1384A:  MOVLW  C8
1384C:  MOVWF  xC2
1384E:  MOVLW  01
13850:  MOVWF  xC4
13852:  MOVWF  xC5
13854:  CLRF   xC6
13856:  MOVLB  0
13858:  CALL   10000
....................    } 
1385C:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
1273A:  DECFSZ 45,W
1273C:  BRA    12758
1273E:  MOVF   46,F
12740:  BNZ   12758
....................       cmd = macro_cmd; 
12742:  MOVFF  8C2,47
....................       arg = macro_arg; 
12746:  CLRF   4B
12748:  CLRF   4A
1274A:  MOVFF  8C4,49
1274E:  MOVFF  8C3,48
....................       det_cmd(); 
12752:  CALL   F3C6
....................    } 
12756:  BRA    12772
....................    else if(nv_det_type==2 || nv_det_type==3) { 
12758:  MOVF   45,W
1275A:  SUBLW  02
1275C:  BNZ   12762
1275E:  MOVF   46,F
12760:  BZ    1276C
12762:  MOVF   45,W
12764:  SUBLW  03
12766:  BNZ   12772
12768:  MOVF   46,F
1276A:  BNZ   12772
....................       set_heaters(macro_arg); 
1276C:  MOVFF  8C3,8C5
12770:  RCALL  126C6
....................    } 
12772:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
12774:  DECFSZ 45,W
12776:  BRA    12792
12778:  MOVF   46,F
1277A:  BNZ   12792
....................       cmd = macro_cmd; 
1277C:  MOVFF  8C2,47
....................       arg = macro_arg; 
12780:  CLRF   4B
12782:  CLRF   4A
12784:  MOVFF  8C4,49
12788:  MOVFF  8C3,48
....................       det_cmd(); 
1278C:  CALL   F3C6
....................    } 
12790:  BRA    127B2
....................    else if(nv_det_type==2 || nv_det_type==3) { 
12792:  MOVF   45,W
12794:  SUBLW  02
12796:  BNZ   1279C
12798:  MOVF   46,F
1279A:  BZ    127A6
1279C:  MOVF   45,W
1279E:  SUBLW  03
127A0:  BNZ   127B2
127A2:  MOVF   46,F
127A4:  BNZ   127B2
....................       set_LED(macro_arg); 
127A6:  MOVFF  8C4,8C6
127AA:  MOVFF  8C3,8C5
127AE:  CALL   F88A
....................    } 
127B2:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13EF0:  MOVLW  65
13EF2:  MOVLB  8
13EF4:  MOVWF  xC1
....................     
....................    addr = macro_address[macro] + (line*3); 
13EF6:  BCF    FD8.0
13EF8:  RLCF   xB7,W
13EFA:  CLRF   03
13EFC:  ADDLW  D1
13EFE:  MOVWF  FE9
13F00:  MOVLW  07
13F02:  ADDWFC 03,W
13F04:  MOVWF  FEA
13F06:  MOVFF  FEC,8C3
13F0A:  MOVF   FED,F
13F0C:  MOVFF  FEF,8C2
13F10:  MOVFF  8B9,A11
13F14:  MOVFF  8B8,A10
13F18:  MOVLB  A
13F1A:  CLRF   x13
13F1C:  MOVLW  03
13F1E:  MOVWF  x12
13F20:  MOVLB  0
13F22:  CALL   5C98
13F26:  MOVF   01,W
13F28:  MOVLB  8
13F2A:  ADDWF  xC2,W
13F2C:  MOVWF  xBC
13F2E:  MOVF   02,W
13F30:  ADDWFC xC3,W
13F32:  MOVWF  xBD
....................  
....................    init_ext_eeprom(); 
13F34:  MOVLB  0
13F36:  CALL   10588
....................    macro_cmd = read_ext_eeprom(addr); 
13F3A:  MOVFF  8BD,8CC
13F3E:  MOVFF  8BC,8CB
13F42:  CALL   105C0
13F46:  MOVFF  01,8BE
....................    ++addr; 
13F4A:  MOVLB  8
13F4C:  INCF   xBC,F
13F4E:  BTFSC  FD8.2
13F50:  INCF   xBD,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13F52:  MOVFF  8BD,8C3
13F56:  MOVFF  8BC,8C2
13F5A:  MOVLB  0
13F5C:  CALL   106D4
13F60:  MOVFF  02,8C0
13F64:  MOVFF  01,8BF
....................    //} 
....................    heartbeat(TRUE); 
13F68:  MOVLW  01
13F6A:  MOVLB  8
13F6C:  MOVWF  xED
13F6E:  MOVLB  0
13F70:  CALL   5586
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13F74:  MOVF   2F,F
13F76:  BTFSS  FD8.2
13F78:  BRA    1423C
13F7A:  MOVF   30,F
13F7C:  BTFSS  FD8.2
13F7E:  BRA    1423C
....................       switch(macro_cmd) 
13F80:  MOVLW  2B
13F82:  MOVLB  8
13F84:  SUBWF  xBE,W
13F86:  ADDLW  B4
13F88:  BTFSC  FD8.0
13F8A:  BRA    1423E
13F8C:  ADDLW  4C
13F8E:  MOVLB  0
13F90:  GOTO   14248
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13F94:  CALL   12552
....................             store_rel_data(); 
13F98:  CALL   125B6
....................             macro_status = 'a'; 
13F9C:  MOVLW  61
13F9E:  MOVLB  8
13FA0:  MOVWF  xC1
....................             break; 
13FA2:  BRA    1423E
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
13FA4:  MOVLW  08
13FA6:  MOVWF  FEA
13FA8:  MOVLW  25
13FAA:  MOVWF  FE9
13FAC:  CALL   7996
13FB0:  MOVLW  0D
13FB2:  BTFSS  F9E.4
13FB4:  BRA    13FB2
13FB6:  MOVWF  FAD
13FB8:  MOVLW  0A
13FBA:  BTFSS  F9E.4
13FBC:  BRA    13FBA
13FBE:  MOVWF  FAD
....................             macro_status = 'a'; 
13FC0:  MOVLW  61
13FC2:  MOVLB  8
13FC4:  MOVWF  xC1
....................             break; 
13FC6:  BRA    1423E
....................          case 'C' : 
....................             calc_abs_data(); 
13FC8:  CALL   12552
....................             break; 
13FCC:  MOVLB  8
13FCE:  BRA    1423E
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
13FD0:  MOVFF  8C0,8C3
13FD4:  MOVFF  8BF,8C2
13FD8:  CALL   D2FE
....................             macro_status = 'a'; 
13FDC:  MOVLW  61
13FDE:  MOVLB  8
13FE0:  MOVWF  xC1
....................             break; 
13FE2:  BRA    1423E
....................          case 'F' : macro_flag = macro_arg; 
13FE4:  MOVFF  8C0,324
13FE8:  MOVFF  8BF,323
....................                     macro_status = 'a'; 
13FEC:  MOVLW  61
13FEE:  MOVLB  8
13FF0:  MOVWF  xC1
....................             break ; 
13FF2:  BRA    1423E
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
13FF4:  MOVFF  8BF,2D5
....................                     macro_status = 'a'; 
13FF8:  MOVLW  61
13FFA:  MOVLB  8
13FFC:  MOVWF  xC1
....................             break ; 
13FFE:  BRA    1423E
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14000:  MOVFF  8BE,8C2
14004:  MOVFF  8C0,8C4
14008:  MOVFF  8BF,8C3
1400C:  CALL   1273A
....................                     macro_status = 'a'; 
14010:  MOVLW  61
14012:  MOVLB  8
14014:  MOVWF  xC1
....................             break; 
14016:  BRA    1423E
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14018:  MOVFF  8BE,8C2
1401C:  MOVFF  8C0,8C4
14020:  MOVFF  8BF,8C3
14024:  CALL   1273A
....................                     macro_status = 'a'; 
14028:  MOVLW  61
1402A:  MOVLB  8
1402C:  MOVWF  xC1
....................             break; 
1402E:  BRA    1423E
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14030:  MOVFF  8C0,8DC
14034:  MOVFF  8BF,8DB
14038:  MOVLB  8
1403A:  CLRF   xDE
1403C:  MOVLW  64
1403E:  MOVWF  xDD
14040:  MOVLB  0
14042:  CALL   2CD4
14046:  MOVFF  02,74D
1404A:  MOVFF  01,74C
....................                     macro_status = 'a'; 
1404E:  MOVLW  61
14050:  MOVLB  8
14052:  MOVWF  xC1
....................             break;    
14054:  BRA    1423E
....................          case 'l' : LightTargetFlag = 1; 
14056:  MOVLW  01
14058:  MOVLB  2
1405A:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
1405C:  MOVFF  8BE,8C2
14060:  MOVFF  8C0,8C4
14064:  MOVFF  8BF,8C3
14068:  MOVLB  0
1406A:  CALL   12774
....................                     delay_ms(10000); 
1406E:  MOVLW  28
14070:  MOVLB  8
14072:  MOVWF  xC2
14074:  MOVLW  FA
14076:  MOVLB  9
14078:  MOVWF  xEC
1407A:  MOVLB  0
1407C:  CALL   2910
14080:  MOVLB  8
14082:  DECFSZ xC2,F
14084:  BRA    14074
....................                     macro_status = 'a'; 
14086:  MOVLW  61
14088:  MOVWF  xC1
....................             break;        
1408A:  BRA    1423E
....................          case 'L' : LightTargetFlag = 0; 
1408C:  MOVLB  2
1408E:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
14090:  MOVFF  8BE,8C2
14094:  MOVFF  8C0,8C4
14098:  MOVFF  8BF,8C3
1409C:  MOVLB  0
1409E:  CALL   12774
....................                     macro_status = 'a'; 
140A2:  MOVLW  61
140A4:  MOVLB  8
140A6:  MOVWF  xC1
....................             break; 
140A8:  BRA    1423E
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
140AA:  MOVFF  8BE,47
....................                     arg = macro_arg; 
140AE:  CLRF   4B
140B0:  CLRF   4A
140B2:  MOVFF  8C0,49
140B6:  MOVFF  8BF,48
....................                     det_cmd(); 
140BA:  CALL   F3C6
....................                     macro_status = 'a'; 
140BE:  MOVLW  61
140C0:  MOVLB  8
140C2:  MOVWF  xC1
....................             break ; 
140C4:  BRA    1423E
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
140C6:  MOVLB  8
140C8:  DECFSZ xBF,W
140CA:  BRA    140D8
140CC:  MOVF   xC0,F
140CE:  BNZ   140D8
140D0:  MOVLB  0
140D2:  CALL   1381C
140D6:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
140D8:  MOVF   xBF,W
140DA:  SUBLW  02
140DC:  BNZ   140EE
140DE:  MOVF   xC0,F
140E0:  BNZ   140EE
140E2:  MOVLW  01
140E4:  MOVWF  xC2
140E6:  MOVWF  xC3
140E8:  MOVLB  0
140EA:  RCALL  139E8
140EC:  MOVLB  8
....................                     macro_status = 'a'; 
140EE:  MOVLW  61
140F0:  MOVWF  xC1
....................             break ;  
140F2:  BRA    1423E
....................          case 'T' : det_temp(); 
140F4:  RCALL  13BA8
....................                     macro_status = 'a'; 
140F6:  MOVLW  61
140F8:  MOVLB  8
140FA:  MOVWF  xC1
....................             break; 
140FC:  BRA    1423E
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
140FE:  MOVLW  01
14100:  MOVLB  7
14102:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14104:  MOVLB  8
14106:  CLRF   xC7
14108:  CLRF   xC8
1410A:  CLRF   xCC
1410C:  CLRF   xCB
1410E:  MOVFF  8C0,8CA
14112:  MOVFF  8BF,8C9
14116:  MOVWF  xCD
14118:  MOVLB  0
1411A:  CALL   9D78
....................                     macro_status=step_err_status(); 
1411E:  CALL   D2C6
14122:  MOVFF  01,8C1
....................             break; 
14126:  MOVLB  8
14128:  BRA    1423E
....................          case '-' : motor=1; 
1412A:  MOVLW  01
1412C:  MOVLB  7
1412E:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14130:  MOVLB  8
14132:  CLRF   xC7
14134:  MOVWF  xC8
14136:  CLRF   xCC
14138:  CLRF   xCB
1413A:  MOVFF  8C0,8CA
1413E:  MOVFF  8BF,8C9
14142:  MOVWF  xCD
14144:  MOVLB  0
14146:  CALL   9D78
....................                     macro_status=step_err_status(); 
1414A:  CALL   D2C6
1414E:  MOVFF  01,8C1
....................             break; 
14152:  MOVLB  8
14154:  BRA    1423E
....................          case 'G' : motor=0; 
14156:  MOVLB  7
14158:  CLRF   x40
....................                     align(0); 
1415A:  MOVLB  8
1415C:  CLRF   xC2
1415E:  MOVLB  0
14160:  CALL   A8B4
....................                     macro_status=step_err_status(); 
14164:  CALL   D2C6
14168:  MOVFF  01,8C1
....................             break ;           
1416C:  MOVLB  8
1416E:  BRA    1423E
....................          case 'P' : motor=0; 
14170:  MOVLB  7
14172:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
14174:  MOVLW  01
14176:  MOVLB  8
14178:  MOVWF  xC7
1417A:  CLRF   xC8
1417C:  CLRF   xCC
1417E:  CLRF   xCB
14180:  MOVFF  8C0,8CA
14184:  MOVFF  8BF,8C9
14188:  MOVWF  xCD
1418A:  MOVLB  0
1418C:  CALL   9D78
....................                     macro_status=step_err_status(); 
14190:  CALL   D2C6
14194:  MOVFF  01,8C1
....................             break; 
14198:  MOVLB  8
1419A:  BRA    1423E
....................          case 'Q' : motor=0; 
1419C:  MOVLB  7
1419E:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
141A0:  MOVLB  8
141A2:  CLRF   xC7
141A4:  CLRF   xC8
141A6:  CLRF   xCC
141A8:  CLRF   xCB
141AA:  MOVFF  8C0,8CA
141AE:  MOVFF  8BF,8C9
141B2:  MOVLW  01
141B4:  MOVWF  xCD
141B6:  MOVLB  0
141B8:  CALL   9D78
....................                     macro_status=step_err_status(); 
141BC:  CALL   D2C6
141C0:  MOVFF  01,8C1
....................             break; 
141C4:  MOVLB  8
141C6:  BRA    1423E
....................          case 'R' : motor=0; 
141C8:  MOVLB  7
141CA:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
141CC:  MOVLB  8
141CE:  CLRF   xC7
141D0:  MOVLW  01
141D2:  MOVWF  xC8
141D4:  CLRF   xCC
141D6:  CLRF   xCB
141D8:  MOVFF  8C0,8CA
141DC:  MOVFF  8BF,8C9
141E0:  MOVWF  xCD
141E2:  MOVLB  0
141E4:  CALL   9D78
....................                     macro_status=step_err_status(); 
141E8:  CALL   D2C6
141EC:  MOVFF  01,8C1
....................             break; 
141F0:  MOVLB  8
141F2:  BRA    1423E
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
141F4:  MOVLB  8
141F6:  DECFSZ xBF,W
141F8:  BRA    14208
141FA:  MOVF   xC0,F
141FC:  BNZ   14208
141FE:  MOVLB  0
14200:  CALL   D334
14204:  BRA    14216
14206:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14208:  MOVF   xBF,F
1420A:  BNZ   14218
1420C:  MOVF   xC0,F
1420E:  BNZ   14218
14210:  MOVLB  0
14212:  CALL   D358
14216:  MOVLB  8
....................                     macro_status = 'a'; 
14218:  MOVLW  61
1421A:  MOVWF  xC1
....................             break; 
1421C:  BRA    1423E
....................          case 'v': 
....................             arg = macro_arg; 
1421E:  CLRF   4B
14220:  CLRF   4A
14222:  MOVFF  8C0,49
14226:  MOVFF  8BF,48
....................             command_v(); 
1422A:  RCALL  13D94
....................             macro_status = 'a'; 
1422C:  MOVLW  61
1422E:  MOVLB  8
14230:  MOVWF  xC1
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
14232:  BRA    1423E
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14234:  MOVLW  66
14236:  MOVLB  8
14238:  MOVWF  xC1
....................             break ; 
1423A:  BRA    1423E
1423C:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
1423E:  MOVFF  8C1,01
14242:  MOVLB  0
14244:  GOTO   14B50 (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
149AC:  MOVLW  65
149AE:  MOVLB  8
149B0:  MOVWF  xA7
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
149B2:  BCF    FD8.0
149B4:  RLCF   x9D,W
149B6:  CLRF   03
149B8:  ADDLW  D1
149BA:  MOVWF  FE9
149BC:  MOVLW  07
149BE:  ADDWFC 03,W
149C0:  MOVWF  FEA
149C2:  MOVFF  FEC,8B6
149C6:  MOVF   FED,F
149C8:  MOVFF  FEF,8B5
149CC:  MOVFF  89F,03
149D0:  MOVFF  89E,FE9
149D4:  MOVFF  89F,FEA
149D8:  MOVFF  FEC,A11
149DC:  MOVF   FED,F
149DE:  MOVFF  FEF,A10
149E2:  MOVLB  A
149E4:  CLRF   x13
149E6:  MOVLW  03
149E8:  MOVWF  x12
149EA:  MOVLB  0
149EC:  CALL   5C98
149F0:  MOVF   01,W
149F2:  MOVLB  8
149F4:  ADDWF  xB5,W
149F6:  MOVWF  xA2
149F8:  MOVF   02,W
149FA:  ADDWFC xB6,W
149FC:  MOVWF  xA3
....................  
....................    init_ext_eeprom(); 
149FE:  MOVLB  0
14A00:  CALL   10588
....................    macro_cmd = read_ext_eeprom(addr); 
14A04:  MOVFF  8A3,8CC
14A08:  MOVFF  8A2,8CB
14A0C:  CALL   105C0
14A10:  MOVFF  01,8A4
....................    ++addr; 
14A14:  MOVLB  8
14A16:  INCF   xA2,F
14A18:  BTFSC  FD8.2
14A1A:  INCF   xA3,F
....................    if(macro_cmd == 'p'){ 
14A1C:  MOVF   xA4,W
14A1E:  SUBLW  70
14A20:  BNZ   14A46
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
14A22:  MOVFF  89D,8B5
14A26:  MOVFF  89F,8B7
14A2A:  MOVFF  89E,8B6
14A2E:  MOVFF  858,8B9
14A32:  MOVFF  857,8B8
14A36:  MOVLB  0
14A38:  CALL   1061A
....................       count1++; 
14A3C:  MOVLB  8
14A3E:  INCF   x57,F
14A40:  BTFSC  FD8.2
14A42:  INCF   x58,F
....................    }else{ 
14A44:  BRA    14A5E
....................    macro_arg = read16_ext_eeprom(addr); 
14A46:  MOVFF  8A3,8C3
14A4A:  MOVFF  8A2,8C2
14A4E:  MOVLB  0
14A50:  CALL   106D4
14A54:  MOVFF  02,8A6
14A58:  MOVFF  01,8A5
14A5C:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
14A5E:  MOVLW  01
14A60:  MOVWF  xED
14A62:  MOVLB  0
14A64:  CALL   5586
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
14A68:  MOVF   2F,F
14A6A:  BTFSS  FD8.2
14A6C:  BRA    14ED2
14A6E:  MOVF   30,F
14A70:  BTFSS  FD8.2
14A72:  BRA    14ED2
....................       switch(macro_cmd){ 
14A74:  MOVLW  2B
14A76:  MOVLB  8
14A78:  SUBWF  xA4,W
14A7A:  ADDLW  B4
14A7C:  BTFSC  FD8.0
14A7E:  BRA    14ECE
14A80:  ADDLW  4C
14A82:  MOVLB  0
14A84:  GOTO   15198
....................          case 'A' : 
....................             calc_abs_data(); 
14A88:  CALL   12552
....................             store_rel_data(); 
14A8C:  CALL   125B6
....................             macro_status = 'a'; 
14A90:  MOVLW  61
14A92:  MOVLB  8
14A94:  MOVWF  xA7
....................             break; 
14A96:  BRA    14ECE
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
14A98:  MOVLW  08
14A9A:  MOVWF  FEA
14A9C:  MOVLW  25
14A9E:  MOVWF  FE9
14AA0:  CALL   7996
14AA4:  MOVLW  0D
14AA6:  BTFSS  F9E.4
14AA8:  BRA    14AA6
14AAA:  MOVWF  FAD
14AAC:  MOVLW  0A
14AAE:  BTFSS  F9E.4
14AB0:  BRA    14AAE
14AB2:  MOVWF  FAD
....................             macro_status = 'a'; 
14AB4:  MOVLW  61
14AB6:  MOVLB  8
14AB8:  MOVWF  xA7
....................             break; 
14ABA:  BRA    14ECE
....................          case 'C' : 
....................             calc_abs_data(); 
14ABC:  CALL   12552
....................             break; 
14AC0:  MOVLB  8
14AC2:  BRA    14ECE
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
14AC4:  MOVLB  8
14AC6:  CLRF   xAB
14AC8:  CLRF   xAA
14ACA:  CLRF   xA9
14ACC:  CLRF   xA8
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14ACE:  MOVFF  89F,03
14AD2:  MOVFF  89E,FE9
14AD6:  MOVFF  89F,FEA
14ADA:  MOVLW  01
14ADC:  ADDWF  FEE,F
14ADE:  BNC   14AE2
14AE0:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
14AE2:  MOVFF  89E,FE9
14AE6:  MOVFF  89F,FEA
14AEA:  CLRF   xAF
14AEC:  CLRF   xAE
14AEE:  MOVFF  FEC,8AD
14AF2:  MOVF   FED,F
14AF4:  MOVFF  FEF,8AC
14AF8:  CLRF   xB3
14AFA:  CLRF   xB2
14AFC:  CLRF   xB1
14AFE:  CLRF   xB0
....................                    
....................                   while(count < macro_arg){ 
14B00:  MOVF   xAB,F
14B02:  BTFSS  FD8.2
14B04:  BRA    14C40
14B06:  MOVF   xAA,F
14B08:  BTFSS  FD8.2
14B0A:  BRA    14C40
14B0C:  MOVF   xA9,W
14B0E:  SUBWF  xA6,W
14B10:  BTFSS  FD8.0
14B12:  BRA    14C40
14B14:  BNZ   14B1E
14B16:  MOVF   xA5,W
14B18:  SUBWF  xA8,W
14B1A:  BTFSC  FD8.0
14B1C:  BRA    14C40
....................                      char curr = 'A'; 
14B1E:  MOVLW  41
14B20:  MOVWF  xB4
....................                      while(curr != '%'){ 
14B22:  MOVF   xB4,W
14B24:  SUBLW  25
14B26:  BZ    14B92
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
14B28:  MOVFF  89F,03
14B2C:  MOVFF  89E,FE9
14B30:  MOVFF  89F,FEA
14B34:  MOVFF  FEC,8B9
14B38:  MOVF   FED,F
14B3A:  MOVFF  FEF,8B8
14B3E:  MOVFF  89D,8B7
14B42:  MOVFF  8A1,8BB
14B46:  MOVFF  8A0,8BA
14B4A:  MOVLB  0
14B4C:  GOTO   13EF0
....................                         (*line)++; 
14B50:  MOVFF  89F,03
14B54:  MOVLB  8
14B56:  MOVF   x9E,W
14B58:  MOVWF  FE9
14B5A:  MOVFF  03,FEA
14B5E:  MOVLW  01
14B60:  ADDWF  FEE,F
14B62:  BNC   14B66
14B64:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
14B66:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
14B68:  MOVFF  89F,03
14B6C:  MOVFF  89E,FE9
14B70:  MOVFF  89F,FEA
14B74:  MOVFF  FEC,8B9
14B78:  MOVF   FED,F
14B7A:  MOVFF  FEF,8B8
14B7E:  MOVFF  89D,8B7
14B82:  MOVLB  0
14B84:  GOTO   14300
14B88:  MOVFF  01,8B4
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14B8C:  BSF    F91.5
14B8E:  MOVLB  8
14B90:  BRA    14B22
....................                      } 
....................                      end_line = (*line); 
14B92:  MOVFF  89E,FE9
14B96:  MOVFF  89F,FEA
14B9A:  CLRF   xB3
14B9C:  CLRF   xB2
14B9E:  MOVFF  FEC,8B1
14BA2:  MOVF   FED,F
14BA4:  MOVFF  FEF,8B0
....................                      count++; 
14BA8:  MOVLW  01
14BAA:  ADDWF  xA8,F
14BAC:  BTFSC  FD8.0
14BAE:  INCF   xA9,F
14BB0:  BTFSC  FD8.2
14BB2:  INCF   xAA,F
14BB4:  BTFSC  FD8.2
14BB6:  INCF   xAB,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
14BB8:  MOVF   xA8,W
14BBA:  SUBWF  xA5,W
14BBC:  MOVWF  xB5
14BBE:  MOVF   xA9,W
14BC0:  SUBWFB xA6,W
14BC2:  MOVWF  xB6
14BC4:  MOVLW  00
14BC6:  SUBFWB xAA,W
14BC8:  MOVWF  xB7
14BCA:  MOVLW  00
14BCC:  SUBFWB xAB,W
14BCE:  MOVWF  xB8
14BD0:  MOVLW  56
14BD2:  MOVWF  FF6
14BD4:  MOVLW  21
14BD6:  MOVWF  FF7
14BD8:  MOVLW  00
14BDA:  MOVWF  FF8
14BDC:  CLRF   1B
14BDE:  BTFSC  FF2.7
14BE0:  BSF    1B.7
14BE2:  BCF    FF2.7
14BE4:  MOVLW  11
14BE6:  MOVLB  A
14BE8:  MOVWF  x40
14BEA:  MOVLB  0
14BEC:  CALL   1024
14BF0:  BTFSC  1B.7
14BF2:  BSF    FF2.7
14BF4:  MOVLW  41
14BF6:  MOVWF  FE9
14BF8:  CLRF   1B
14BFA:  BTFSC  FF2.7
14BFC:  BSF    1B.7
14BFE:  BCF    FF2.7
14C00:  MOVFF  8B8,A43
14C04:  MOVFF  8B7,A42
14C08:  MOVFF  8B6,A41
14C0C:  MOVFF  8B5,A40
14C10:  CALL   10EA
14C14:  BTFSC  1B.7
14C16:  BSF    FF2.7
14C18:  MOVLW  0D
14C1A:  BTFSS  F9E.4
14C1C:  BRA    14C1A
14C1E:  MOVWF  FAD
14C20:  MOVLW  0A
14C22:  BTFSS  F9E.4
14C24:  BRA    14C22
14C26:  MOVWF  FAD
....................                      (*line) = start_line; 
14C28:  MOVFF  89F,03
14C2C:  MOVLB  8
14C2E:  MOVFF  89E,FE9
14C32:  MOVFF  89F,FEA
14C36:  MOVFF  8AC,FEF
14C3A:  MOVFF  8AD,FEC
14C3E:  BRA    14B00
....................                   } 
....................                   (*line) = end_line + 1; 
14C40:  MOVFF  89E,FE9
14C44:  MOVFF  89F,FEA
14C48:  MOVLW  01
14C4A:  ADDWF  xB0,W
14C4C:  MOVWF  FEF
14C4E:  MOVLW  00
14C50:  ADDWFC xB1,W
14C52:  MOVWF  FEC
....................                   macro_status = 'a'; 
14C54:  MOVLW  61
14C56:  MOVWF  xA7
....................             break; 
14C58:  BRA    14ECE
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
14C5A:  MOVFF  8A6,8C3
14C5E:  MOVFF  8A5,8C2
14C62:  CALL   D2FE
....................                     macro_status = 'a'; 
14C66:  MOVLW  61
14C68:  MOVLB  8
14C6A:  MOVWF  xA7
....................             break; 
14C6C:  BRA    14ECE
....................          case 'F' : macro_flag = macro_arg; 
14C6E:  MOVFF  8A6,324
14C72:  MOVFF  8A5,323
....................                     macro_status = 'a'; 
14C76:  MOVLW  61
14C78:  MOVLB  8
14C7A:  MOVWF  xA7
....................             break ; 
14C7C:  BRA    14ECE
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14C7E:  MOVFF  8A5,2D5
....................                     macro_status = 'a'; 
14C82:  MOVLW  61
14C84:  MOVLB  8
14C86:  MOVWF  xA7
....................             break ; 
14C88:  BRA    14ECE
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14C8A:  MOVFF  8A4,8C2
14C8E:  MOVFF  8A6,8C4
14C92:  MOVFF  8A5,8C3
14C96:  CALL   1273A
....................                     macro_status = 'a'; 
14C9A:  MOVLW  61
14C9C:  MOVLB  8
14C9E:  MOVWF  xA7
....................             break; 
14CA0:  BRA    14ECE
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14CA2:  MOVFF  8A4,8C2
14CA6:  MOVFF  8A6,8C4
14CAA:  MOVFF  8A5,8C3
14CAE:  CALL   1273A
....................                     macro_status = 'a'; 
14CB2:  MOVLW  61
14CB4:  MOVLB  8
14CB6:  MOVWF  xA7
....................             break; 
14CB8:  BRA    14ECE
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14CBA:  MOVFF  8A6,8DC
14CBE:  MOVFF  8A5,8DB
14CC2:  MOVLB  8
14CC4:  CLRF   xDE
14CC6:  MOVLW  64
14CC8:  MOVWF  xDD
14CCA:  MOVLB  0
14CCC:  CALL   2CD4
14CD0:  MOVFF  02,74D
14CD4:  MOVFF  01,74C
....................                     macro_status = 'a'; 
14CD8:  MOVLW  61
14CDA:  MOVLB  8
14CDC:  MOVWF  xA7
....................             break;    
14CDE:  BRA    14ECE
....................          case 'l' : LightTargetFlag = 1; 
14CE0:  MOVLW  01
14CE2:  MOVLB  2
14CE4:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
14CE6:  MOVFF  8A4,8C2
14CEA:  MOVFF  8A6,8C4
14CEE:  MOVFF  8A5,8C3
14CF2:  MOVLB  0
14CF4:  CALL   12774
....................                     delay_ms(10000); 
14CF8:  MOVLW  28
14CFA:  MOVLB  8
14CFC:  MOVWF  xB5
14CFE:  MOVLW  FA
14D00:  MOVLB  9
14D02:  MOVWF  xEC
14D04:  MOVLB  0
14D06:  CALL   2910
14D0A:  MOVLB  8
14D0C:  DECFSZ xB5,F
14D0E:  BRA    14CFE
....................                     macro_status = 'a'; 
14D10:  MOVLW  61
14D12:  MOVWF  xA7
....................             break;        
14D14:  BRA    14ECE
....................          case 'L' : LightTargetFlag = 0; 
14D16:  MOVLB  2
14D18:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
14D1A:  MOVFF  8A4,8C2
14D1E:  MOVFF  8A6,8C4
14D22:  MOVFF  8A5,8C3
14D26:  MOVLB  0
14D28:  CALL   12774
....................                     macro_status = 'a'; 
14D2C:  MOVLW  61
14D2E:  MOVLB  8
14D30:  MOVWF  xA7
....................             break; 
14D32:  BRA    14ECE
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
14D34:  MOVFF  8A4,47
....................                     arg = macro_arg; 
14D38:  CLRF   4B
14D3A:  CLRF   4A
14D3C:  MOVFF  8A6,49
14D40:  MOVFF  8A5,48
....................                     det_cmd(); 
14D44:  CALL   F3C6
....................                     macro_status = 'a'; 
14D48:  MOVLW  61
14D4A:  MOVLB  8
14D4C:  MOVWF  xA7
....................             break ; 
14D4E:  BRA    14ECE
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
14D50:  MOVLB  8
14D52:  DECFSZ xA5,W
14D54:  BRA    14D62
14D56:  MOVF   xA6,F
14D58:  BNZ   14D62
14D5A:  MOVLB  0
14D5C:  CALL   1381C
14D60:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14D62:  MOVF   xA5,W
14D64:  SUBLW  02
14D66:  BNZ   14D7A
14D68:  MOVF   xA6,F
14D6A:  BNZ   14D7A
14D6C:  MOVLW  01
14D6E:  MOVWF  xC2
14D70:  MOVWF  xC3
14D72:  MOVLB  0
14D74:  CALL   139E8
14D78:  MOVLB  8
....................                     macro_status = 'a'; 
14D7A:  MOVLW  61
14D7C:  MOVWF  xA7
....................             break ;  
14D7E:  BRA    14ECE
....................          case 'T' : det_temp(); 
14D80:  CALL   13BA8
....................                     macro_status = 'a'; 
14D84:  MOVLW  61
14D86:  MOVLB  8
14D88:  MOVWF  xA7
....................             break; 
14D8A:  BRA    14ECE
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14D8C:  MOVLW  01
14D8E:  MOVLB  7
14D90:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14D92:  MOVLB  8
14D94:  CLRF   xC7
14D96:  CLRF   xC8
14D98:  CLRF   xCC
14D9A:  CLRF   xCB
14D9C:  MOVFF  8A6,8CA
14DA0:  MOVFF  8A5,8C9
14DA4:  MOVWF  xCD
14DA6:  MOVLB  0
14DA8:  CALL   9D78
....................                     macro_status=step_err_status(); 
14DAC:  CALL   D2C6
14DB0:  MOVFF  01,8A7
....................             break; 
14DB4:  MOVLB  8
14DB6:  BRA    14ECE
....................          case '-' : motor=1; 
14DB8:  MOVLW  01
14DBA:  MOVLB  7
14DBC:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14DBE:  MOVLB  8
14DC0:  CLRF   xC7
14DC2:  MOVWF  xC8
14DC4:  CLRF   xCC
14DC6:  CLRF   xCB
14DC8:  MOVFF  8A6,8CA
14DCC:  MOVFF  8A5,8C9
14DD0:  MOVWF  xCD
14DD2:  MOVLB  0
14DD4:  CALL   9D78
....................                     macro_status=step_err_status(); 
14DD8:  CALL   D2C6
14DDC:  MOVFF  01,8A7
....................             break; 
14DE0:  MOVLB  8
14DE2:  BRA    14ECE
....................          case 'G' : motor=0; 
14DE4:  MOVLB  7
14DE6:  CLRF   x40
....................                     align(0); 
14DE8:  MOVLB  8
14DEA:  CLRF   xC2
14DEC:  MOVLB  0
14DEE:  CALL   A8B4
....................                     macro_status=step_err_status(); 
14DF2:  CALL   D2C6
14DF6:  MOVFF  01,8A7
....................             break ;           
14DFA:  MOVLB  8
14DFC:  BRA    14ECE
....................          case 'P' : motor=0; 
14DFE:  MOVLB  7
14E00:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
14E02:  MOVLW  01
14E04:  MOVLB  8
14E06:  MOVWF  xC7
14E08:  CLRF   xC8
14E0A:  CLRF   xCC
14E0C:  CLRF   xCB
14E0E:  MOVFF  8A6,8CA
14E12:  MOVFF  8A5,8C9
14E16:  MOVWF  xCD
14E18:  MOVLB  0
14E1A:  CALL   9D78
....................                     macro_status=step_err_status(); 
14E1E:  CALL   D2C6
14E22:  MOVFF  01,8A7
....................             break; 
14E26:  MOVLB  8
14E28:  BRA    14ECE
....................          case 'Q' : motor=0; 
14E2A:  MOVLB  7
14E2C:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
14E2E:  MOVLB  8
14E30:  CLRF   xC7
14E32:  CLRF   xC8
14E34:  CLRF   xCC
14E36:  CLRF   xCB
14E38:  MOVFF  8A6,8CA
14E3C:  MOVFF  8A5,8C9
14E40:  MOVLW  01
14E42:  MOVWF  xCD
14E44:  MOVLB  0
14E46:  CALL   9D78
....................                     macro_status=step_err_status(); 
14E4A:  CALL   D2C6
14E4E:  MOVFF  01,8A7
....................             break; 
14E52:  MOVLB  8
14E54:  BRA    14ECE
....................          case 'R' : motor=0; 
14E56:  MOVLB  7
14E58:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
14E5A:  MOVLB  8
14E5C:  CLRF   xC7
14E5E:  MOVLW  01
14E60:  MOVWF  xC8
14E62:  CLRF   xCC
14E64:  CLRF   xCB
14E66:  MOVFF  8A6,8CA
14E6A:  MOVFF  8A5,8C9
14E6E:  MOVWF  xCD
14E70:  MOVLB  0
14E72:  CALL   9D78
....................                     macro_status=step_err_status(); 
14E76:  CALL   D2C6
14E7A:  MOVFF  01,8A7
....................             break; 
14E7E:  MOVLB  8
14E80:  BRA    14ECE
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14E82:  MOVLB  8
14E84:  DECFSZ xA5,W
14E86:  BRA    14E96
14E88:  MOVF   xA6,F
14E8A:  BNZ   14E96
14E8C:  MOVLB  0
14E8E:  CALL   D334
14E92:  BRA    14EA4
14E94:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14E96:  MOVF   xA5,F
14E98:  BNZ   14EA6
14E9A:  MOVF   xA6,F
14E9C:  BNZ   14EA6
14E9E:  MOVLB  0
14EA0:  CALL   D358
14EA4:  MOVLB  8
....................                     macro_status = 'a'; 
14EA6:  MOVLW  61
14EA8:  MOVWF  xA7
....................             break; 
14EAA:  BRA    14ECE
....................          case 'v':  
....................             arg = macro_arg; 
14EAC:  CLRF   4B
14EAE:  CLRF   4A
14EB0:  MOVFF  8A6,49
14EB4:  MOVFF  8A5,48
....................             command_v(); 
14EB8:  CALL   13D94
....................             macro_status = 'a'; 
14EBC:  MOVLW  61
14EBE:  MOVLB  8
14EC0:  MOVWF  xA7
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
14EC2:  BRA    14ECE
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14EC4:  MOVLW  66
14EC6:  MOVLB  8
14EC8:  MOVWF  xA7
....................             break ; 
14ECA:  BRA    14ECE
14ECC:  MOVLB  8
....................       } 
....................    } 
14ECE:  BRA    1518E
14ED0:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14ED2:  DECFSZ 2F,W
14ED4:  BRA    14EDA
14ED6:  MOVF   30,F
14ED8:  BZ    14EE8
14EDA:  MOVF   2F,W
14EDC:  SUBLW  03
14EDE:  BTFSS  FD8.2
14EE0:  BRA    15066
14EE2:  MOVF   30,F
14EE4:  BTFSS  FD8.2
14EE6:  BRA    15066
....................       switch(macro_cmd){ 
14EE8:  MOVLB  8
14EEA:  MOVF   xA4,W
14EEC:  XORLW  2B
14EEE:  MOVLB  0
14EF0:  BZ    14F1E
14EF2:  XORLW  06
14EF4:  BZ    14F48
14EF6:  XORLW  6F
14EF8:  BZ    14F72
14EFA:  XORLW  05
14EFC:  BZ    14F84
14EFE:  XORLW  17
14F00:  BZ    14F9C
14F02:  XORLW  01
14F04:  BZ    14FC6
14F06:  XORLW  03
14F08:  BZ    14FF0
14F0A:  XORLW  06
14F0C:  BTFSC  FD8.2
14F0E:  BRA    1501A
14F10:  XORLW  0D
14F12:  BTFSC  FD8.2
14F14:  BRA    15030
14F16:  XORLW  62
14F18:  BTFSC  FD8.2
14F1A:  BRA    1505C
14F1C:  BRA    15064
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14F1E:  MOVLW  01
14F20:  MOVLB  7
14F22:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14F24:  MOVLB  8
14F26:  CLRF   xC7
14F28:  CLRF   xC8
14F2A:  CLRF   xCC
14F2C:  CLRF   xCB
14F2E:  MOVFF  8A6,8CA
14F32:  MOVFF  8A5,8C9
14F36:  MOVWF  xCD
14F38:  MOVLB  0
14F3A:  CALL   9D78
....................                     macro_status=step_err_status(); 
14F3E:  CALL   D2C6
14F42:  MOVFF  01,8A7
....................             break; 
14F46:  BRA    15064
....................          case '-' : motor=1; 
14F48:  MOVLW  01
14F4A:  MOVLB  7
14F4C:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14F4E:  MOVLB  8
14F50:  CLRF   xC7
14F52:  MOVWF  xC8
14F54:  CLRF   xCC
14F56:  CLRF   xCB
14F58:  MOVFF  8A6,8CA
14F5C:  MOVFF  8A5,8C9
14F60:  MOVWF  xCD
14F62:  MOVLB  0
14F64:  CALL   9D78
....................                     macro_status=step_err_status(); 
14F68:  CALL   D2C6
14F6C:  MOVFF  01,8A7
....................             break; 
14F70:  BRA    15064
....................          case 'B' : h_bridge(macro_arg); 
14F72:  MOVFF  8A5,8B5
14F76:  CALL   C214
....................                     macro_status = 'a'; 
14F7A:  MOVLW  61
14F7C:  MOVLB  8
14F7E:  MOVWF  xA7
....................             break;             
14F80:  MOVLB  0
14F82:  BRA    15064
....................          case 'G' : motor=0; 
14F84:  MOVLB  7
14F86:  CLRF   x40
....................                     align(0); 
14F88:  MOVLB  8
14F8A:  CLRF   xC2
14F8C:  MOVLB  0
14F8E:  CALL   A8B4
....................                     macro_status=step_err_status(); 
14F92:  CALL   D2C6
14F96:  MOVFF  01,8A7
....................             break ;           
14F9A:  BRA    15064
....................          case 'P' : motor=0; 
14F9C:  MOVLB  7
14F9E:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1);   
14FA0:  MOVLB  8
14FA2:  CLRF   xC7
14FA4:  CLRF   xC8
14FA6:  CLRF   xCC
14FA8:  CLRF   xCB
14FAA:  MOVFF  8A1,8CA
14FAE:  MOVFF  8A0,8C9
14FB2:  MOVLW  01
14FB4:  MOVWF  xCD
14FB6:  MOVLB  0
14FB8:  CALL   9D78
....................                     macro_status=step_err_status(); 
14FBC:  CALL   D2C6
14FC0:  MOVFF  01,8A7
....................             break; 
14FC4:  BRA    15064
....................          case 'Q' : motor=0; 
14FC6:  MOVLB  7
14FC8:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1); 
14FCA:  MOVLB  8
14FCC:  CLRF   xC7
14FCE:  CLRF   xC8
14FD0:  CLRF   xCC
14FD2:  CLRF   xCB
14FD4:  MOVFF  8A1,8CA
14FD8:  MOVFF  8A0,8C9
14FDC:  MOVLW  01
14FDE:  MOVWF  xCD
14FE0:  MOVLB  0
14FE2:  CALL   9D78
....................                     macro_status=step_err_status(); 
14FE6:  CALL   D2C6
14FEA:  MOVFF  01,8A7
....................             break; 
14FEE:  BRA    15064
....................          case 'R' : motor=0; 
14FF0:  MOVLB  7
14FF2:  CLRF   x40
....................                     move_motor(0,1,mmacro_var,1); 
14FF4:  MOVLB  8
14FF6:  CLRF   xC7
14FF8:  MOVLW  01
14FFA:  MOVWF  xC8
14FFC:  CLRF   xCC
14FFE:  CLRF   xCB
15000:  MOVFF  8A1,8CA
15004:  MOVFF  8A0,8C9
15008:  MOVWF  xCD
1500A:  MOVLB  0
1500C:  CALL   9D78
....................                     macro_status=step_err_status(); 
15010:  CALL   D2C6
15014:  MOVFF  01,8A7
....................             break; 
15018:  BRA    15064
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
1501A:  MOVFF  8A6,8C3
1501E:  MOVFF  8A5,8C2
15022:  CALL   D2FE
....................                     macro_status = 'a'; 
15026:  MOVLW  61
15028:  MOVLB  8
1502A:  MOVWF  xA7
....................             break; 
1502C:  MOVLB  0
1502E:  BRA    15064
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
15030:  MOVLB  8
15032:  DECFSZ xA5,W
15034:  BRA    15044
15036:  MOVF   xA6,F
15038:  BNZ   15044
1503A:  MOVLB  0
1503C:  CALL   D334
15040:  BRA    15052
15042:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
15044:  MOVF   xA5,F
15046:  BNZ   15054
15048:  MOVF   xA6,F
1504A:  BNZ   15054
1504C:  MOVLB  0
1504E:  CALL   D358
15052:  MOVLB  8
....................                     macro_status = 'a'; 
15054:  MOVLW  61
15056:  MOVWF  xA7
....................             break; 
15058:  MOVLB  0
1505A:  BRA    15064
....................          case ';' : macro_status = 'f'; 
1505C:  MOVLW  66
1505E:  MOVLB  8
15060:  MOVWF  xA7
....................             break;            
15062:  MOVLB  0
....................       } 
....................    } 
15064:  BRA    1518C
....................    else if (nv_product==AWS){ 
15066:  MOVF   2F,W
15068:  SUBLW  02
1506A:  BTFSS  FD8.2
1506C:  BRA    1518C
1506E:  MOVF   30,F
15070:  BTFSS  FD8.2
15072:  BRA    1518C
....................       switch(macro_cmd){ 
15074:  MOVLB  8
15076:  MOVF   xA4,W
15078:  XORLW  2B
1507A:  MOVLB  0
1507C:  BZ    150A2
1507E:  XORLW  06
15080:  BZ    150CC
15082:  XORLW  6E
15084:  BZ    150F6
15086:  XORLW  07
15088:  BZ    15108
1508A:  XORLW  14
1508C:  BZ    1511E
1508E:  XORLW  01
15090:  BZ    15130
15092:  XORLW  02
15094:  BZ    15142
15096:  XORLW  0A
15098:  BZ    15158
1509A:  XORLW  62
1509C:  BTFSC  FD8.2
1509E:  BRA    15184
150A0:  BRA    1518C
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
150A2:  MOVLW  01
150A4:  MOVLB  7
150A6:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
150A8:  MOVLB  8
150AA:  CLRF   xC7
150AC:  CLRF   xC8
150AE:  CLRF   xCC
150B0:  CLRF   xCB
150B2:  MOVFF  8A6,8CA
150B6:  MOVFF  8A5,8C9
150BA:  MOVWF  xCD
150BC:  MOVLB  0
150BE:  CALL   9D78
....................                     macro_status=step_err_status(); 
150C2:  CALL   D2C6
150C6:  MOVFF  01,8A7
....................             break; 
150CA:  BRA    1518C
....................          case '-' : motor=1; 
150CC:  MOVLW  01
150CE:  MOVLB  7
150D0:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
150D2:  MOVLB  8
150D4:  CLRF   xC7
150D6:  MOVWF  xC8
150D8:  CLRF   xCC
150DA:  CLRF   xCB
150DC:  MOVFF  8A6,8CA
150E0:  MOVFF  8A5,8C9
150E4:  MOVWF  xCD
150E6:  MOVLB  0
150E8:  CALL   9D78
....................                     macro_status=step_err_status(); 
150EC:  CALL   D2C6
150F0:  MOVFF  01,8A7
....................             break; 
150F4:  BRA    1518C
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
150F6:  MOVFF  8A5,8B6
150FA:  CALL   DB7A
....................                     macro_status = 'a';  
150FE:  MOVLW  61
15100:  MOVLB  8
15102:  MOVWF  xA7
....................             break;          
15104:  MOVLB  0
15106:  BRA    1518C
....................          case 'D' : delay_sec(macro_arg); 
15108:  MOVFF  8A6,8C3
1510C:  MOVFF  8A5,8C2
15110:  CALL   D2FE
....................                     macro_status = 'a'; 
15114:  MOVLW  61
15116:  MOVLB  8
15118:  MOVWF  xA7
....................             break; 
1511A:  MOVLB  0
1511C:  BRA    1518C
....................          case 'P' : sol_switch(mmacro_var); 
1511E:  MOVFF  8A0,8B5
15122:  CALL   14524
....................                     macro_status = 'a'; 
15126:  MOVLW  61
15128:  MOVLB  8
1512A:  MOVWF  xA7
....................             break;              
1512C:  MOVLB  0
1512E:  BRA    1518C
....................          case 'Q' : sol_switch(macro_arg); 
15130:  MOVFF  8A5,8B5
15134:  CALL   14524
....................                     macro_status = 'a'; 
15138:  MOVLW  61
1513A:  MOVLB  8
1513C:  MOVWF  xA7
....................             break;             
1513E:  MOVLB  0
15140:  BRA    1518C
....................          case 'S' : sol_switch_cmd(macro_arg); 
15142:  MOVFF  8A6,8B7
15146:  MOVFF  8A5,8B6
1514A:  CALL   1446E
....................                     macro_status = 'a'; 
1514E:  MOVLW  61
15150:  MOVLB  8
15152:  MOVWF  xA7
....................             break; 
15154:  MOVLB  0
15156:  BRA    1518C
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
15158:  MOVLB  8
1515A:  DECFSZ xA5,W
1515C:  BRA    1516C
1515E:  MOVF   xA6,F
15160:  BNZ   1516C
15162:  MOVLB  0
15164:  CALL   D334
15168:  BRA    1517A
1516A:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
1516C:  MOVF   xA5,F
1516E:  BNZ   1517C
15170:  MOVF   xA6,F
15172:  BNZ   1517C
15174:  MOVLB  0
15176:  CALL   D358
1517A:  MOVLB  8
....................                     macro_status = 'a'; 
1517C:  MOVLW  61
1517E:  MOVWF  xA7
....................             break;               
15180:  MOVLB  0
15182:  BRA    1518C
....................          case ';' : macro_status = 'f'; 
15184:  MOVLW  66
15186:  MOVLB  8
15188:  MOVWF  xA7
....................             break;            
1518A:  MOVLB  0
1518C:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
1518E:  MOVFF  8A7,01
15192:  MOVLB  0
15194:  GOTO   154AC (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
1537A:  MOVLB  8
1537C:  CLRF   x58
1537E:  CLRF   x57
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
15380:  MOVLB  0
15382:  CALL   50E6
....................    clear_data_arrays(); 
15386:  GOTO   104C2
....................     
....................    line = 0;  
1538A:  MOVLB  8
1538C:  CLRF   x9B
1538E:  CLRF   x9A
....................    macro_status = 'a'; 
15390:  MOVLW  61
15392:  MOVWF  x9C
....................    data_available = FALSE; 
15394:  MOVLB  3
15396:  CLRF   x3B
....................    macro_flag = 900; 
15398:  MOVLW  03
1539A:  MOVWF  x24
1539C:  MOVLW  84
1539E:  MOVWF  x23
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
153A0:  MOVLW  01
153A2:  MOVWF  1E
153A4:  MOVLW  A7
153A6:  MOVWF  1D
153A8:  MOVLW  6E
153AA:  MOVWF  FF6
153AC:  MOVLW  21
153AE:  MOVWF  FF7
153B0:  MOVLW  00
153B2:  MOVWF  FF8
153B4:  MOVLW  07
153B6:  MOVLB  8
153B8:  MOVWF  xEB
153BA:  MOVLB  0
153BC:  CALL   AACC
153C0:  MOVFF  897,8ED
153C4:  MOVLW  1B
153C6:  MOVLB  8
153C8:  MOVWF  xEE
153CA:  MOVLB  0
153CC:  CALL   5280
153D0:  MOVLW  77
153D2:  MOVWF  FF6
153D4:  MOVLW  21
153D6:  MOVWF  FF7
153D8:  MOVLW  00
153DA:  MOVWF  FF8
153DC:  MOVLW  09
153DE:  MOVLB  8
153E0:  MOVWF  xEB
153E2:  MOVLB  0
153E4:  CALL   AACC
....................    record_event();    
153E8:  CALL   84DA
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
153EC:  MOVLB  8
153EE:  MOVF   x9B,W
153F0:  SUBLW  03
153F2:  BNC   154C4
153F4:  MOVF   x9C,W
153F6:  SUBLW  61
153F8:  BNZ   154C4
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
153FA:  MOVF   1F,W
153FC:  SUBLW  04
153FE:  BNZ   15492
15400:  MOVF   20,F
15402:  BNZ   15492
....................                                                macro_status, (line + 1)); 
15404:  MOVLW  01
15406:  ADDWF  x9A,W
15408:  MOVWF  x9D
1540A:  MOVLW  00
1540C:  ADDWFC x9B,W
1540E:  MOVWF  x9E
15410:  MOVLW  82
15412:  MOVWF  FF6
15414:  MOVLW  21
15416:  MOVWF  FF7
15418:  MOVLW  00
1541A:  MOVWF  FF8
1541C:  CLRF   1B
1541E:  BTFSC  FF2.7
15420:  BSF    1B.7
15422:  BCF    FF2.7
15424:  MOVLW  05
15426:  MOVLB  A
15428:  MOVWF  x40
1542A:  MOVLB  0
1542C:  CALL   1024
15430:  BTFSC  1B.7
15432:  BSF    FF2.7
15434:  MOVLB  8
15436:  MOVF   x9C,W
15438:  BTFSS  F9E.4
1543A:  BRA    15438
1543C:  MOVWF  FAD
1543E:  MOVLW  5D
15440:  BTFSS  F9E.4
15442:  BRA    15440
15444:  MOVWF  FAD
15446:  MOVLW  5B
15448:  BTFSS  F9E.4
1544A:  BRA    15448
1544C:  MOVWF  FAD
1544E:  MOVLW  10
15450:  MOVWF  FE9
15452:  CLRF   1B
15454:  BTFSC  FF2.7
15456:  BSF    1B.7
15458:  BCF    FF2.7
1545A:  MOVFF  89E,A41
1545E:  MOVFF  89D,A40
15462:  MOVLB  0
15464:  CALL   11A6
15468:  BTFSC  1B.7
1546A:  BSF    FF2.7
1546C:  MOVLW  8E
1546E:  MOVWF  FF6
15470:  MOVLW  21
15472:  MOVWF  FF7
15474:  MOVLW  00
15476:  MOVWF  FF8
15478:  CLRF   1B
1547A:  BTFSC  FF2.7
1547C:  BSF    1B.7
1547E:  BCF    FF2.7
15480:  MOVLW  03
15482:  MOVLB  A
15484:  MOVWF  x40
15486:  MOVLB  0
15488:  CALL   1024
1548C:  BTFSC  1B.7
1548E:  BSF    FF2.7
15490:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
15492:  MOVFF  897,89D
15496:  MOVLW  08
15498:  MOVWF  x9F
1549A:  MOVLW  9A
1549C:  MOVWF  x9E
1549E:  MOVFF  899,8A1
154A2:  MOVFF  898,8A0
154A6:  MOVLB  0
154A8:  GOTO   149AC
154AC:  MOVFF  01,89C
....................       ++line; 
154B0:  MOVLB  8
154B2:  INCF   x9A,F
154B4:  BTFSC  FD8.2
154B6:  INCF   x9B,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
154B8:  DECFSZ 50,W
154BA:  BRA    154C2
....................          macro_status = 'g'; 
154BC:  MOVLW  67
154BE:  MOVWF  x9C
....................          break;    
154C0:  BRA    154C4
....................       } 
154C2:  BRA    153EE
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
154C4:  MOVF   2F,W
154C6:  MOVWF  00
154C8:  MOVF   30,W
154CA:  MOVWF  03
154CC:  MOVF   03,W
154CE:  BNZ   154DA
154D0:  MOVLW  01
154D2:  SUBWF  00,W
154D4:  MOVLB  0
154D6:  BZ    154F8
154D8:  MOVLB  8
154DA:  MOVF   03,W
154DC:  BNZ   154E8
154DE:  MOVLW  03
154E0:  SUBWF  00,W
154E2:  MOVLB  0
154E4:  BZ    154F8
154E6:  MOVLB  8
154E8:  MOVF   03,W
154EA:  BNZ   154F6
154EC:  MOVLW  02
154EE:  SUBWF  00,W
154F0:  MOVLB  0
154F2:  BZ    15504
154F4:  MOVLB  8
154F6:  BRA    15514
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
154F8:  MOVFF  897,89D
154FC:  CALL   D602
....................          break; 
15500:  MOVLB  8
15502:  BRA    15514
....................       case AWS : store_aws_data(macro,mmacro_var); 
15504:  MOVFF  897,89D
15508:  MOVFF  899,89F
1550C:  MOVFF  898,89E
15510:  BRA    15250
....................          break; 
15512:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
15514:  MOVLW  61
15516:  SUBWF  x9C,W
15518:  ADDLW  F9
1551A:  BC    15606
1551C:  ADDLW  07
1551E:  MOVLB  0
15520:  GOTO   156B2
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
15524:  MOVLW  92
15526:  MOVWF  FF6
15528:  MOVLW  21
1552A:  MOVWF  FF7
1552C:  MOVLW  00
1552E:  MOVWF  FF8
15530:  CLRF   1B
15532:  BTFSC  FF2.7
15534:  BSF    1B.7
15536:  BCF    FF2.7
15538:  CALL   0E4E
1553C:  BTFSC  1B.7
1553E:  BSF    FF2.7
....................          break; 
15540:  MOVLB  8
15542:  BRA    15606
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
15544:  MOVLW  9A
15546:  MOVWF  FF6
15548:  MOVLW  21
1554A:  MOVWF  FF7
1554C:  MOVLW  00
1554E:  MOVWF  FF8
15550:  CLRF   1B
15552:  BTFSC  FF2.7
15554:  BSF    1B.7
15556:  BCF    FF2.7
15558:  CALL   0E4E
1555C:  BTFSC  1B.7
1555E:  BSF    FF2.7
....................          break; 
15560:  MOVLB  8
15562:  BRA    15606
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
15564:  MOVLW  A2
15566:  MOVWF  FF6
15568:  MOVLW  21
1556A:  MOVWF  FF7
1556C:  MOVLW  00
1556E:  MOVWF  FF8
15570:  CLRF   1B
15572:  BTFSC  FF2.7
15574:  BSF    1B.7
15576:  BCF    FF2.7
15578:  CALL   0E4E
1557C:  BTFSC  1B.7
1557E:  BSF    FF2.7
....................          break; 
15580:  MOVLB  8
15582:  BRA    15606
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
15584:  MOVLW  AA
15586:  MOVWF  FF6
15588:  MOVLW  21
1558A:  MOVWF  FF7
1558C:  MOVLW  00
1558E:  MOVWF  FF8
15590:  CLRF   1B
15592:  BTFSC  FF2.7
15594:  BSF    1B.7
15596:  BCF    FF2.7
15598:  CALL   0E4E
1559C:  BTFSC  1B.7
1559E:  BSF    FF2.7
....................          break; 
155A0:  MOVLB  8
155A2:  BRA    15606
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
155A4:  MOVLW  B2
155A6:  MOVWF  FF6
155A8:  MOVLW  21
155AA:  MOVWF  FF7
155AC:  MOVLW  00
155AE:  MOVWF  FF8
155B0:  CLRF   1B
155B2:  BTFSC  FF2.7
155B4:  BSF    1B.7
155B6:  BCF    FF2.7
155B8:  CALL   0E4E
155BC:  BTFSC  1B.7
155BE:  BSF    FF2.7
....................          break;    
155C0:  MOVLB  8
155C2:  BRA    15606
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
155C4:  MOVLW  BA
155C6:  MOVWF  FF6
155C8:  MOVLW  21
155CA:  MOVWF  FF7
155CC:  MOVLW  00
155CE:  MOVWF  FF8
155D0:  CLRF   1B
155D2:  BTFSC  FF2.7
155D4:  BSF    1B.7
155D6:  BCF    FF2.7
155D8:  CALL   0E4E
155DC:  BTFSC  1B.7
155DE:  BSF    FF2.7
....................          break;    
155E0:  MOVLB  8
155E2:  BRA    15606
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
155E4:  MOVLW  C2
155E6:  MOVWF  FF6
155E8:  MOVLW  21
155EA:  MOVWF  FF7
155EC:  MOVLW  00
155EE:  MOVWF  FF8
155F0:  CLRF   1B
155F2:  BTFSC  FF2.7
155F4:  BSF    1B.7
155F6:  BCF    FF2.7
155F8:  CALL   0E4E
155FC:  BTFSC  1B.7
155FE:  BSF    FF2.7
....................          break;           
15600:  MOVLB  8
15602:  BRA    15606
15604:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
15606:  MOVLW  01
15608:  MOVWF  1E
1560A:  MOVLW  A7
1560C:  MOVWF  1D
1560E:  MOVLW  CA
15610:  MOVWF  FF6
15612:  MOVLW  21
15614:  MOVWF  FF7
15616:  MOVLW  00
15618:  MOVWF  FF8
1561A:  MOVLW  07
1561C:  MOVWF  xEB
1561E:  MOVLB  0
15620:  CALL   AACC
15624:  MOVFF  897,8ED
15628:  MOVLW  1B
1562A:  MOVLB  8
1562C:  MOVWF  xEE
1562E:  MOVLB  0
15630:  CALL   5280
15634:  MOVLW  D3
15636:  MOVWF  FF6
15638:  MOVLW  21
1563A:  MOVWF  FF7
1563C:  MOVLW  00
1563E:  MOVWF  FF8
15640:  MOVLW  09
15642:  MOVLB  8
15644:  MOVWF  xEB
15646:  MOVLB  0
15648:  CALL   AACC
1564C:  MOVFF  89C,8FF
15650:  CALL   509E
15654:  MOVLW  DE
15656:  MOVWF  FF6
15658:  MOVLW  21
1565A:  MOVWF  FF7
1565C:  MOVLW  00
1565E:  MOVWF  FF8
15660:  MOVLW  07
15662:  MOVLB  8
15664:  MOVWF  xEB
15666:  MOVLB  0
15668:  CALL   AACC
1566C:  MOVLW  10
1566E:  MOVWF  FE9
15670:  MOVFF  89B,8F7
15674:  MOVFF  89A,8F6
15678:  CALL   AAFE
1567C:  MOVLW  E8
1567E:  MOVWF  FF6
15680:  MOVLW  21
15682:  MOVWF  FF7
15684:  MOVLW  00
15686:  MOVWF  FF8
15688:  MOVLW  03
1568A:  MOVLB  8
1568C:  MOVWF  xEB
1568E:  MOVLB  0
15690:  CALL   AACC
....................    record_event(); 
15694:  CALL   84DA
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
15698:  MOVLB  8
1569A:  MOVF   x9C,W
1569C:  SUBLW  66
1569E:  BZ    156AE
156A0:  MOVF   x9C,W
156A2:  SUBLW  67
156A4:  BZ    156AE
156A6:  MOVLB  0
156A8:  CALL   AA58
156AC:  MOVLB  8
156AE:  MOVLB  0
156B0:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15F52:  MOVLW  01
15F54:  MOVLB  8
15F56:  MOVWF  x8F
....................    while (macro_batch == TRUE){ 
15F58:  DECFSZ x8F,W
15F5A:  BRA    161E0
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15F5C:  MOVFF  38,A11
15F60:  MOVFF  37,A10
15F64:  MOVLB  A
15F66:  CLRF   x13
15F68:  MOVLW  03
15F6A:  MOVWF  x12
15F6C:  MOVLB  0
15F6E:  CALL   5C98
15F72:  MOVF   01,W
15F74:  MOVLB  7
15F76:  ADDWF  xD1,W
15F78:  MOVLB  8
15F7A:  MOVWF  x8A
15F7C:  MOVF   02,W
15F7E:  MOVLB  7
15F80:  ADDWFC xD2,W
15F82:  MOVLB  8
15F84:  MOVWF  x8B
....................       init_ext_eeprom(); 
15F86:  MOVLB  0
15F88:  CALL   10588
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
15F8C:  MOVFF  88B,8CC
15F90:  MOVFF  88A,8CB
15F94:  CALL   105C0
15F98:  MOVFF  01,88C
....................       ++addr; 
15F9C:  MOVLB  8
15F9E:  INCF   x8A,F
15FA0:  BTFSC  FD8.2
15FA2:  INCF   x8B,F
....................       macro_arg = read16_ext_eeprom(addr); 
15FA4:  MOVFF  88B,8C3
15FA8:  MOVFF  88A,8C2
15FAC:  MOVLB  0
15FAE:  CALL   106D4
15FB2:  MOVFF  02,88E
15FB6:  MOVFF  01,88D
....................       ++addr; 
15FBA:  MOVLB  8
15FBC:  INCF   x8A,F
15FBE:  BTFSC  FD8.2
15FC0:  INCF   x8B,F
....................       ++addr;      
15FC2:  INCF   x8A,F
15FC4:  BTFSC  FD8.2
15FC6:  INCF   x8B,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
15FC8:  MOVF   x8C,W
15FCA:  SUBLW  4D
15FCC:  BTFSS  FD8.2
15FCE:  BRA    160F8
15FD0:  MOVF   x8D,F
15FD2:  BNZ   15FDA
15FD4:  MOVF   x8E,F
15FD6:  BTFSC  FD8.2
15FD8:  BRA    160F8
....................          { 
....................          RTC_reset_HT(); 
15FDA:  MOVLB  0
15FDC:  CALL   34B2
....................          RTC_read(); 
15FE0:  CALL   3344
....................          RTC_display(); 
15FE4:  CALL   E24E
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
15FE8:  MOVLW  EC
15FEA:  MOVWF  FF6
15FEC:  MOVLW  21
15FEE:  MOVWF  FF7
15FF0:  MOVLW  00
15FF2:  MOVWF  FF8
15FF4:  CLRF   1B
15FF6:  BTFSC  FF2.7
15FF8:  BSF    1B.7
15FFA:  BCF    FF2.7
15FFC:  MOVLW  09
15FFE:  MOVLB  A
16000:  MOVWF  x40
16002:  MOVLB  0
16004:  CALL   1024
16008:  BTFSC  1B.7
1600A:  BSF    FF2.7
1600C:  MOVLB  8
1600E:  MOVF   x8C,W
16010:  BTFSS  F9E.4
16012:  BRA    16010
16014:  MOVWF  FAD
16016:  MOVLW  10
16018:  MOVWF  FE9
1601A:  CLRF   1B
1601C:  BTFSC  FF2.7
1601E:  BSF    1B.7
16020:  BCF    FF2.7
16022:  MOVFF  88E,A41
16026:  MOVFF  88D,A40
1602A:  MOVLB  0
1602C:  CALL   11A6
16030:  BTFSC  1B.7
16032:  BSF    FF2.7
16034:  MOVLW  FA
16036:  MOVWF  FF6
16038:  MOVLW  21
1603A:  MOVWF  FF7
1603C:  MOVLW  00
1603E:  MOVWF  FF8
16040:  CLRF   1B
16042:  BTFSC  FF2.7
16044:  BSF    1B.7
16046:  BCF    FF2.7
16048:  MOVLW  03
1604A:  MOVLB  A
1604C:  MOVWF  x40
1604E:  MOVLB  0
16050:  CALL   1024
16054:  BTFSC  1B.7
16056:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
16058:  MOVLW  01
1605A:  ADDWF  21,W
1605C:  MOVLB  8
1605E:  MOVWF  x90
16060:  MOVLW  00
16062:  ADDWFC 22,W
16064:  MOVWF  x91
16066:  MOVLW  FE
16068:  MOVWF  FF6
1606A:  MOVLW  21
1606C:  MOVWF  FF7
1606E:  MOVLW  00
16070:  MOVWF  FF8
16072:  CLRF   1B
16074:  BTFSC  FF2.7
16076:  BSF    1B.7
16078:  BCF    FF2.7
1607A:  MOVLW  07
1607C:  MOVLB  A
1607E:  MOVWF  x40
16080:  MOVLB  0
16082:  CALL   1024
16086:  BTFSC  1B.7
16088:  BSF    FF2.7
1608A:  MOVLW  09
1608C:  MOVWF  FE9
1608E:  CLRF   1B
16090:  BTFSC  FF2.7
16092:  BSF    1B.7
16094:  BCF    FF2.7
16096:  MOVFF  891,A41
1609A:  MOVFF  890,A40
1609E:  CALL   11A6
160A2:  BTFSC  1B.7
160A4:  BSF    FF2.7
160A6:  MOVLW  0A
160A8:  MOVWF  FF6
160AA:  MOVLW  22
160AC:  MOVWF  FF7
160AE:  MOVLW  00
160B0:  MOVWF  FF8
160B2:  CLRF   1B
160B4:  BTFSC  FF2.7
160B6:  BSF    1B.7
160B8:  BCF    FF2.7
160BA:  MOVLW  04
160BC:  MOVLB  A
160BE:  MOVWF  x40
160C0:  MOVLB  0
160C2:  CALL   1024
160C6:  BTFSC  1B.7
160C8:  BSF    FF2.7
160CA:  MOVLW  09
160CC:  MOVWF  FE9
160CE:  CLRF   1B
160D0:  BTFSC  FF2.7
160D2:  BSF    1B.7
160D4:  BCF    FF2.7
160D6:  MOVFF  28,A41
160DA:  MOVFF  27,A40
160DE:  CALL   11A6
160E2:  BTFSC  1B.7
160E4:  BSF    FF2.7
160E6:  MOVLW  0D
160E8:  BTFSS  F9E.4
160EA:  BRA    160E8
160EC:  MOVWF  FAD
160EE:  MOVLW  0A
160F0:  BTFSS  F9E.4
160F2:  BRA    160F0
160F4:  MOVWF  FAD
160F6:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
160F8:  MOVF   28,W
160FA:  SUBWF  22,W
160FC:  BNC   1610A
160FE:  BNZ   16106
16100:  MOVF   27,W
16102:  SUBWF  21,W
16104:  BNC   1610A
....................          {macro_cmd = 'Z';} 
16106:  MOVLW  5A
16108:  MOVWF  x8C
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
1610A:  MOVF   x8C,W
1610C:  XORLW  72
1610E:  MOVLB  0
16110:  BZ    16124
16112:  XORLW  57
16114:  BZ    16146
16116:  XORLW  68
16118:  BZ    1617C
1611A:  XORLW  17
1611C:  BZ    161B2
1611E:  XORLW  61
16120:  BZ    161BE
16122:  BRA    161C8
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
16124:  INCF   37,F
16126:  BTFSC  FD8.2
16128:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
1612A:  MOVLB  8
1612C:  CLRF   x60
1612E:  CLRF   x5F
16130:  MOVFF  38,85E
16134:  MOVFF  37,85D
....................                master_macro_loop_count = macro_arg; 
16138:  CLRF   x5C
1613A:  CLRF   x5B
1613C:  MOVFF  88E,85A
16140:  MOVFF  88D,859
....................             break; 
16144:  BRA    161D4
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
16146:  MOVLB  8
16148:  MOVF   x5C,F
1614A:  BNZ   1615A
1614C:  MOVF   x5B,F
1614E:  BNZ   1615A
16150:  MOVF   x5A,F
16152:  BNZ   1615A
16154:  MOVF   x59,W
16156:  SUBLW  01
16158:  BC    16174
....................                   nv_macro_step = master_macro_loop_start; 
1615A:  MOVFF  85E,38
1615E:  MOVFF  85D,37
....................                   master_macro_loop_count--; 
16162:  MOVLW  FF
16164:  ADDWF  x59,F
16166:  BTFSS  FD8.0
16168:  ADDWF  x5A,F
1616A:  BTFSS  FD8.0
1616C:  ADDWF  x5B,F
1616E:  BTFSS  FD8.0
16170:  ADDWF  x5C,F
....................                }else{ 
16172:  BRA    1617A
....................                   nv_macro_step++; 
16174:  INCF   37,F
16176:  BTFSC  FD8.2
16178:  INCF   38,F
....................                } 
....................             break; 
1617A:  BRA    161D4
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
1617C:  MOVLB  8
1617E:  MOVF   x8E,F
16180:  BNZ   161B0
16182:  MOVF   x8D,W
16184:  SUBLW  14
16186:  BNC   161B0
....................                   play_macro(macro_arg,0);     // casts to int8 
16188:  MOVFF  88D,897
1618C:  CLRF   x99
1618E:  CLRF   x98
16190:  MOVLB  0
16192:  CALL   1537A
....................                   delay_ms(100); 
16196:  MOVLW  64
16198:  MOVLB  9
1619A:  MOVWF  xEC
1619C:  MOVLB  0
1619E:  CALL   2910
....................                   ++nv_sample; 
161A2:  INCF   21,F
161A4:  BTFSC  FD8.2
161A6:  INCF   22,F
....................                   ++nv_macro_step; 
161A8:  INCF   37,F
161AA:  BTFSC  FD8.2
161AC:  INCF   38,F
161AE:  MOVLB  8
....................                } 
....................                break; 
161B0:  BRA    161D4
....................             case 'Z' : ++nv_macro_step; 
161B2:  INCF   37,F
161B4:  BTFSC  FD8.2
161B6:  INCF   38,F
....................                        macro_batch = FALSE; 
161B8:  MOVLB  8
161BA:  CLRF   x8F
....................                break; 
161BC:  BRA    161D4
....................             case ';' : nv_macro_step = 0; 
161BE:  CLRF   38
161C0:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
161C2:  MOVLB  8
161C4:  BRA    161D4
161C6:  MOVLB  0
....................             default  : cmd_err(); 
161C8:  CALL   BF84
....................                        macro_cmd = 'e'; 
161CC:  MOVLW  65
161CE:  MOVLB  8
161D0:  MOVWF  x8C
....................                        macro_batch = FALSE; 
161D2:  CLRF   x8F
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
161D4:  DECFSZ 50,W
161D6:  BRA    161DE
....................             macro_cmd = ';'; 
161D8:  MOVLW  3B
161DA:  MOVWF  x8C
....................             break;         // 17 = CTRL-Q (quit) 
161DC:  BRA    161E0
....................          } 
161DE:  BRA    15F58
....................    } 
....................    return (macro_cmd); 
161E0:  MOVFF  88C,01
161E4:  MOVLB  0
161E6:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D36E:  MOVLB  8
0D370:  MOVF   x8C,W
0D372:  XORLW  2B
0D374:  MOVLB  0
0D376:  BZ    D3A6
0D378:  XORLW  06
0D37A:  BZ    D3CE
0D37C:  XORLW  6F
0D37E:  BZ    D3F6
0D380:  XORLW  05
0D382:  BZ    D408
0D384:  XORLW  17
0D386:  BZ    D41E
0D388:  XORLW  01
0D38A:  BZ    D44E
0D38C:  XORLW  03
0D38E:  BTFSC  FD8.2
0D390:  BRA    D476
0D392:  XORLW  06
0D394:  BTFSC  FD8.2
0D396:  BRA    D49E
0D398:  XORLW  0D
0D39A:  BTFSC  FD8.2
0D39C:  BRA    D4B2
0D39E:  XORLW  62
0D3A0:  BTFSC  FD8.2
0D3A2:  BRA    D4DA
0D3A4:  BRA    D4E2
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D3A6:  MOVLW  01
0D3A8:  MOVLB  7
0D3AA:  MOVWF  x40
....................                  move_motor(0,0,macro_arg,1); 
0D3AC:  MOVLB  8
0D3AE:  CLRF   xC7
0D3B0:  CLRF   xC8
0D3B2:  CLRF   xCC
0D3B4:  CLRF   xCB
0D3B6:  MOVFF  88E,8CA
0D3BA:  MOVFF  88D,8C9
0D3BE:  MOVWF  xCD
0D3C0:  MOVLB  0
0D3C2:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D3C6:  RCALL  D2C6
0D3C8:  MOVFF  01,88F
....................          break; 
0D3CC:  BRA    D4E2
....................       case '-' : motor=1; 
0D3CE:  MOVLW  01
0D3D0:  MOVLB  7
0D3D2:  MOVWF  x40
....................                  move_motor(0,1,macro_arg,1); 
0D3D4:  MOVLB  8
0D3D6:  CLRF   xC7
0D3D8:  MOVWF  xC8
0D3DA:  CLRF   xCC
0D3DC:  CLRF   xCB
0D3DE:  MOVFF  88E,8CA
0D3E2:  MOVFF  88D,8C9
0D3E6:  MOVWF  xCD
0D3E8:  MOVLB  0
0D3EA:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D3EE:  RCALL  D2C6
0D3F0:  MOVFF  01,88F
....................          break; 
0D3F4:  BRA    D4E2
....................       case 'B' : h_bridge(macro_arg); 
0D3F6:  MOVFF  88D,8B5
0D3FA:  CALL   C214
....................                  macro_status = 'a'; 
0D3FE:  MOVLW  61
0D400:  MOVLB  8
0D402:  MOVWF  x8F
....................          break; 
0D404:  MOVLB  0
0D406:  BRA    D4E2
....................       case 'G' : motor=0; 
0D408:  MOVLB  7
0D40A:  CLRF   x40
....................                  align(0); 
0D40C:  MOVLB  8
0D40E:  CLRF   xC2
0D410:  MOVLB  0
0D412:  CALL   A8B4
....................                  macro_status=step_err_status(); 
0D416:  RCALL  D2C6
0D418:  MOVFF  01,88F
....................          break ;           
0D41C:  BRA    D4E2
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D41E:  MOVFF  88E,2E
0D422:  MOVFF  88D,2D
....................                  motor=0; 
0D426:  MOVLB  7
0D428:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1);   
0D42A:  MOVLB  8
0D42C:  CLRF   xC7
0D42E:  CLRF   xC8
0D430:  CLRF   xCC
0D432:  CLRF   xCB
0D434:  MOVFF  88E,8CA
0D438:  MOVFF  88D,8C9
0D43C:  MOVLW  01
0D43E:  MOVWF  xCD
0D440:  MOVLB  0
0D442:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D446:  RCALL  D2C6
0D448:  MOVFF  01,88F
....................          break; 
0D44C:  BRA    D4E2
....................       case 'Q' : motor=0; 
0D44E:  MOVLB  7
0D450:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1); 
0D452:  MOVLB  8
0D454:  CLRF   xC7
0D456:  CLRF   xC8
0D458:  CLRF   xCC
0D45A:  CLRF   xCB
0D45C:  MOVFF  88E,8CA
0D460:  MOVFF  88D,8C9
0D464:  MOVLW  01
0D466:  MOVWF  xCD
0D468:  MOVLB  0
0D46A:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D46E:  RCALL  D2C6
0D470:  MOVFF  01,88F
....................          break; 
0D474:  BRA    D4E2
....................       case 'R' : motor=0; 
0D476:  MOVLB  7
0D478:  CLRF   x40
....................                  move_motor(0,1,macro_arg,1); 
0D47A:  MOVLB  8
0D47C:  CLRF   xC7
0D47E:  MOVLW  01
0D480:  MOVWF  xC8
0D482:  CLRF   xCC
0D484:  CLRF   xCB
0D486:  MOVFF  88E,8CA
0D48A:  MOVFF  88D,8C9
0D48E:  MOVWF  xCD
0D490:  MOVLB  0
0D492:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D496:  RCALL  D2C6
0D498:  MOVFF  01,88F
....................          break; 
0D49C:  BRA    D4E2
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D49E:  MOVFF  88E,8C3
0D4A2:  MOVFF  88D,8C2
0D4A6:  RCALL  D2FE
....................                  macro_status = 'a'; 
0D4A8:  MOVLW  61
0D4AA:  MOVLB  8
0D4AC:  MOVWF  x8F
....................          break; 
0D4AE:  MOVLB  0
0D4B0:  BRA    D4E2
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D4B2:  MOVLB  8
0D4B4:  DECFSZ x8D,W
0D4B6:  BRA    D4C4
0D4B8:  MOVF   x8E,F
0D4BA:  BNZ   D4C4
0D4BC:  MOVLB  0
0D4BE:  RCALL  D334
0D4C0:  BRA    D4D0
0D4C2:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D4C4:  MOVF   x8D,F
0D4C6:  BNZ   D4D2
0D4C8:  MOVF   x8E,F
0D4CA:  BNZ   D4D2
0D4CC:  MOVLB  0
0D4CE:  RCALL  D358
0D4D0:  MOVLB  8
....................                  macro_status = 'a'; 
0D4D2:  MOVLW  61
0D4D4:  MOVWF  x8F
....................          break;           
0D4D6:  MOVLB  0
0D4D8:  BRA    D4E2
....................       case ';' : macro_status = 'f'; 
0D4DA:  MOVLW  66
0D4DC:  MOVLB  8
0D4DE:  MOVWF  x8F
....................          break;            
0D4E0:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D4E2:  MOVLB  8
0D4E4:  MOVFF  88F,01
0D4E8:  MOVLB  0
0D4EA:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D7C4:  MOVF   2E,F
0D7C6:  BNZ   D7CE
0D7C8:  MOVF   2D,W
0D7CA:  SUBLW  01
0D7CC:  BC    D7E0
0D7CE:  MOVF   2E,F
0D7D0:  BNZ   D7E0
0D7D2:  MOVF   2D,W
0D7D4:  SUBLW  30
0D7D6:  BNC   D7E0
0D7D8:  DECFSZ 2F,W
0D7DA:  BRA    D7E0
0D7DC:  MOVF   30,F
0D7DE:  BZ    D7FE
0D7E0:  MOVF   2E,F
0D7E2:  BNZ   D7EA
0D7E4:  MOVF   2D,W
0D7E6:  SUBLW  01
0D7E8:  BC    D808
0D7EA:  MOVF   2E,F
0D7EC:  BNZ   D808
0D7EE:  MOVF   2D,W
0D7F0:  SUBLW  32
0D7F2:  BNC   D808
0D7F4:  MOVF   2F,W
0D7F6:  SUBLW  03
0D7F8:  BNZ   D808
0D7FA:  MOVF   30,F
0D7FC:  BNZ   D808
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D7FE:  MOVLW  61
0D800:  MOVLB  8
0D802:  MOVWF  x8B
....................    } 
0D804:  BRA    D810
0D806:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D808:  MOVLW  65
0D80A:  MOVLB  8
0D80C:  MOVWF  x8B
....................       goto end_macro;       
0D80E:  BRA    D8C0
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D810:  MOVLW  59
0D812:  MOVWF  x8C
0D814:  CLRF   x8E
0D816:  MOVLW  01
0D818:  MOVWF  x8D
0D81A:  MOVLB  0
0D81C:  RCALL  D36E
0D81E:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D822:  MOVLB  8
0D824:  MOVF   x8B,W
0D826:  SUBLW  61
0D828:  BTFSS  FD8.2
0D82A:  BRA    D8C0
....................    macro_status = play_wms_macro_cmd('G',1); 
0D82C:  MOVLW  47
0D82E:  MOVWF  x8C
0D830:  CLRF   x8E
0D832:  MOVLW  01
0D834:  MOVWF  x8D
0D836:  MOVLB  0
0D838:  RCALL  D36E
0D83A:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D83E:  MOVLB  8
0D840:  MOVF   x8B,W
0D842:  SUBLW  61
0D844:  BTFSS  FD8.2
0D846:  BRA    D8C0
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D848:  MOVLW  2D
0D84A:  MOVWF  x8C
0D84C:  MOVFF  2C,88E
0D850:  MOVFF  2B,88D
0D854:  MOVLB  0
0D856:  RCALL  D36E
0D858:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D85C:  MOVLB  8
0D85E:  MOVF   x8B,W
0D860:  SUBLW  61
0D862:  BTFSS  FD8.2
0D864:  BRA    D8C0
....................    macro_status = play_wms_macro_cmd('P',port); 
0D866:  MOVLW  50
0D868:  MOVWF  x8C
0D86A:  MOVFF  88A,88E
0D86E:  MOVFF  889,88D
0D872:  MOVLB  0
0D874:  RCALL  D36E
0D876:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro;    
0D87A:  MOVLB  8
0D87C:  MOVF   x8B,W
0D87E:  SUBLW  61
0D880:  BTFSS  FD8.2
0D882:  BRA    D8C0
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D884:  MOVLW  2B
0D886:  MOVWF  x8C
0D888:  MOVFF  2C,88E
0D88C:  MOVFF  2B,88D
0D890:  MOVLB  0
0D892:  RCALL  D36E
0D894:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D898:  MOVLB  8
0D89A:  MOVF   x8B,W
0D89C:  SUBLW  61
0D89E:  BTFSS  FD8.2
0D8A0:  BRA    D8C0
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D8A2:  MOVLW  59
0D8A4:  MOVWF  x8C
0D8A6:  CLRF   x8E
0D8A8:  CLRF   x8D
0D8AA:  MOVLB  0
0D8AC:  RCALL  D36E
0D8AE:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8B2:  MOVLB  8
0D8B4:  MOVF   x8B,W
0D8B6:  SUBLW  61
0D8B8:  BTFSS  FD8.2
0D8BA:  BRA    D8C0
....................    macro_status='f';  
0D8BC:  MOVLW  66
0D8BE:  MOVWF  x8B
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D8C0:  CLRF   x9D
0D8C2:  MOVLB  0
0D8C4:  RCALL  D602
....................    
....................    switch(macro_status){ 
0D8C6:  MOVLW  61
0D8C8:  MOVLB  8
0D8CA:  SUBWF  x8B,W
0D8CC:  ADDLW  FA
0D8CE:  BC    D9A2
0D8D0:  ADDLW  06
0D8D2:  MOVLB  0
0D8D4:  GOTO   D9A6
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D8D8:  MOVF   1F,F
0D8DA:  BNZ   D8E0
0D8DC:  MOVF   20,F
0D8DE:  BZ    D8FC
0D8E0:  MOVLW  16
0D8E2:  MOVWF  FF6
0D8E4:  MOVLW  22
0D8E6:  MOVWF  FF7
0D8E8:  MOVLW  00
0D8EA:  MOVWF  FF8
0D8EC:  CLRF   1B
0D8EE:  BTFSC  FF2.7
0D8F0:  BSF    1B.7
0D8F2:  BCF    FF2.7
0D8F4:  CALL   0E4E
0D8F8:  BTFSC  1B.7
0D8FA:  BSF    FF2.7
....................          break; 
0D8FC:  MOVLB  8
0D8FE:  BRA    D9A2
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D900:  MOVLW  1E
0D902:  MOVWF  FF6
0D904:  MOVLW  22
0D906:  MOVWF  FF7
0D908:  MOVLW  00
0D90A:  MOVWF  FF8
0D90C:  CLRF   1B
0D90E:  BTFSC  FF2.7
0D910:  BSF    1B.7
0D912:  BCF    FF2.7
0D914:  CALL   0E4E
0D918:  BTFSC  1B.7
0D91A:  BSF    FF2.7
....................          break; 
0D91C:  MOVLB  8
0D91E:  BRA    D9A2
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D920:  MOVLW  26
0D922:  MOVWF  FF6
0D924:  MOVLW  22
0D926:  MOVWF  FF7
0D928:  MOVLW  00
0D92A:  MOVWF  FF8
0D92C:  CLRF   1B
0D92E:  BTFSC  FF2.7
0D930:  BSF    1B.7
0D932:  BCF    FF2.7
0D934:  CALL   0E4E
0D938:  BTFSC  1B.7
0D93A:  BSF    FF2.7
....................          break; 
0D93C:  MOVLB  8
0D93E:  BRA    D9A2
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D940:  MOVLW  2E
0D942:  MOVWF  FF6
0D944:  MOVLW  22
0D946:  MOVWF  FF7
0D948:  MOVLW  00
0D94A:  MOVWF  FF8
0D94C:  CLRF   1B
0D94E:  BTFSC  FF2.7
0D950:  BSF    1B.7
0D952:  BCF    FF2.7
0D954:  CALL   0E4E
0D958:  BTFSC  1B.7
0D95A:  BSF    FF2.7
....................          break; 
0D95C:  MOVLB  8
0D95E:  BRA    D9A2
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D960:  MOVLW  36
0D962:  MOVWF  FF6
0D964:  MOVLW  22
0D966:  MOVWF  FF7
0D968:  MOVLW  00
0D96A:  MOVWF  FF8
0D96C:  CLRF   1B
0D96E:  BTFSC  FF2.7
0D970:  BSF    1B.7
0D972:  BCF    FF2.7
0D974:  CALL   0E4E
0D978:  BTFSC  1B.7
0D97A:  BSF    FF2.7
....................          break;    
0D97C:  MOVLB  8
0D97E:  BRA    D9A2
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D980:  MOVLW  3E
0D982:  MOVWF  FF6
0D984:  MOVLW  22
0D986:  MOVWF  FF7
0D988:  MOVLW  00
0D98A:  MOVWF  FF8
0D98C:  CLRF   1B
0D98E:  BTFSC  FF2.7
0D990:  BSF    1B.7
0D992:  BCF    FF2.7
0D994:  CALL   0E4E
0D998:  BTFSC  1B.7
0D99A:  BSF    FF2.7
....................          break;           
0D99C:  MOVLB  8
0D99E:  BRA    D9A2
0D9A0:  MOVLB  8
....................    } 
0D9A2:  MOVLB  0
0D9A4:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
16428:  MOVLB  8
1642A:  MOVF   x88,W
1642C:  BTFSC  FD8.2
1642E:  DECF   x89,F
16430:  DECF   x88,F
....................    addr = macro_address[0] + (step*9); 
16432:  MOVFF  889,A11
16436:  MOVFF  888,A10
1643A:  MOVLB  A
1643C:  CLRF   x13
1643E:  MOVLW  09
16440:  MOVWF  x12
16442:  MOVLB  0
16444:  CALL   5C98
16448:  MOVF   01,W
1644A:  MOVLB  7
1644C:  ADDWF  xD1,W
1644E:  MOVLB  8
16450:  MOVWF  x8A
16452:  MOVF   02,W
16454:  MOVLB  7
16456:  ADDWFC xD2,W
16458:  MOVLB  8
1645A:  MOVWF  x8B
....................     
....................    init_ext_eeprom(); 
1645C:  MOVLB  0
1645E:  CALL   10588
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
16462:  MOVFF  88B,8CC
16466:  MOVFF  88A,8CB
1646A:  CALL   105C0
1646E:  MOVFF  01,88C
....................    ++addr; 
16472:  MOVLB  8
16474:  INCF   x8A,F
16476:  BTFSC  FD8.2
16478:  INCF   x8B,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
1647A:  MOVFF  88B,8C3
1647E:  MOVFF  88A,8C2
16482:  MOVLB  0
16484:  CALL   106D4
16488:  MOVFF  02,890
1648C:  MOVFF  01,88F
....................    ++addr; 
16490:  MOVLB  8
16492:  INCF   x8A,F
16494:  BTFSC  FD8.2
16496:  INCF   x8B,F
....................    ++addr; 
16498:  INCF   x8A,F
1649A:  BTFSC  FD8.2
1649C:  INCF   x8B,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
1649E:  MOVFF  88B,8CC
164A2:  MOVFF  88A,8CB
164A6:  MOVLB  0
164A8:  CALL   105C0
164AC:  MOVFF  01,88D
....................    ++addr; 
164B0:  MOVLB  8
164B2:  INCF   x8A,F
164B4:  BTFSC  FD8.2
164B6:  INCF   x8B,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
164B8:  MOVFF  88B,8C3
164BC:  MOVFF  88A,8C2
164C0:  MOVLB  0
164C2:  CALL   106D4
164C6:  MOVFF  02,892
164CA:  MOVFF  01,891
....................    ++addr; 
164CE:  MOVLB  8
164D0:  INCF   x8A,F
164D2:  BTFSC  FD8.2
164D4:  INCF   x8B,F
....................    ++addr; 
164D6:  INCF   x8A,F
164D8:  BTFSC  FD8.2
164DA:  INCF   x8B,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
164DC:  MOVFF  88B,8CC
164E0:  MOVFF  88A,8CB
164E4:  MOVLB  0
164E6:  CALL   105C0
164EA:  MOVFF  01,88E
....................    ++addr; 
164EE:  MOVLB  8
164F0:  INCF   x8A,F
164F2:  BTFSC  FD8.2
164F4:  INCF   x8B,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
164F6:  MOVFF  88B,8C3
164FA:  MOVFF  88A,8C2
164FE:  MOVLB  0
16500:  CALL   106D4
16504:  MOVFF  02,894
16508:  MOVFF  01,893
....................    ++addr; 
1650C:  MOVLB  8
1650E:  INCF   x8A,F
16510:  BTFSC  FD8.2
16512:  INCF   x8B,F
....................    ++addr; 
16514:  INCF   x8A,F
16516:  BTFSC  FD8.2
16518:  INCF   x8B,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
1651A:  MOVFF  88B,8CC
1651E:  MOVFF  88A,8CB
16522:  MOVLB  0
16524:  CALL   105C0
16528:  MOVFF  01,895
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
1652C:  MOVLB  8
1652E:  MOVF   x8C,W
16530:  SUBLW  4A
16532:  BTFSS  FD8.2
16534:  BRA    1660A
16536:  MOVF   x8D,W
16538:  SUBLW  50
1653A:  BNZ   1660A
1653C:  MOVF   x8E,W
1653E:  SUBLW  4D
16540:  BNZ   1660A
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
16542:  MOVF   x8C,W
16544:  BTFSS  F9E.4
16546:  BRA    16544
16548:  MOVWF  FAD
1654A:  MOVLW  10
1654C:  MOVWF  FE9
1654E:  CLRF   1B
16550:  BTFSC  FF2.7
16552:  BSF    1B.7
16554:  BCF    FF2.7
16556:  MOVFF  890,A41
1655A:  MOVFF  88F,A40
1655E:  MOVLB  0
16560:  CALL   11A6
16564:  BTFSC  1B.7
16566:  BSF    FF2.7
16568:  MOVLW  2C
1656A:  BTFSS  F9E.4
1656C:  BRA    1656A
1656E:  MOVWF  FAD
16570:  MOVLB  8
16572:  MOVF   x8D,W
16574:  BTFSS  F9E.4
16576:  BRA    16574
16578:  MOVWF  FAD
1657A:  MOVLW  10
1657C:  MOVWF  FE9
1657E:  CLRF   1B
16580:  BTFSC  FF2.7
16582:  BSF    1B.7
16584:  BCF    FF2.7
16586:  MOVFF  892,A41
1658A:  MOVFF  891,A40
1658E:  MOVLB  0
16590:  CALL   11A6
16594:  BTFSC  1B.7
16596:  BSF    FF2.7
16598:  MOVLW  2C
1659A:  BTFSS  F9E.4
1659C:  BRA    1659A
1659E:  MOVWF  FAD
165A0:  MOVLB  8
165A2:  MOVF   x8E,W
165A4:  BTFSS  F9E.4
165A6:  BRA    165A4
165A8:  MOVWF  FAD
165AA:  MOVLW  10
165AC:  MOVWF  FE9
165AE:  CLRF   1B
165B0:  BTFSC  FF2.7
165B2:  BSF    1B.7
165B4:  BCF    FF2.7
165B6:  MOVFF  894,A41
165BA:  MOVFF  893,A40
165BE:  MOVLB  0
165C0:  CALL   11A6
165C4:  BTFSC  1B.7
165C6:  BSF    FF2.7
165C8:  MOVLW  0D
165CA:  BTFSS  F9E.4
165CC:  BRA    165CA
165CE:  MOVWF  FAD
165D0:  MOVLW  0A
165D2:  BTFSS  F9E.4
165D4:  BRA    165D2
165D6:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
165D8:  MOVFF  890,24
165DC:  MOVFF  88F,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
165E0:  MOVLB  8
165E2:  MOVF   x93,F
165E4:  BNZ   165EA
165E6:  MOVF   x94,F
165E8:  BZ    16608
165EA:  MOVF   x94,F
165EC:  BNZ   16608
165EE:  MOVF   x93,W
165F0:  SUBLW  10
165F2:  BNC   16608
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
165F4:  MOVFF  893,897
165F8:  MOVFF  892,899
165FC:  MOVFF  891,898
16600:  MOVLB  0
16602:  CALL   1537A
16606:  MOVLB  8
....................       } 
....................    } 
16608:  BRA    16616
....................    else { 
....................       cmd_err(); 
1660A:  MOVLB  0
1660C:  CALL   BF84
....................       macro_end = 59; 
16610:  MOVLW  3B
16612:  MOVLB  8
16614:  MOVWF  x95
....................    } 
....................     
....................    return (macro_end); 
16616:  MOVFF  895,01
1661A:  MOVLB  0
1661C:  GOTO   16706 (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
16808:  MOVLB  8
1680A:  MOVF   x8C,W
1680C:  BTFSC  FD8.2
1680E:  DECF   x8D,F
16810:  DECF   x8C,F
....................    addr = macro_address[0] + (step*6); 
16812:  MOVFF  88D,A11
16816:  MOVFF  88C,A10
1681A:  MOVLB  A
1681C:  CLRF   x13
1681E:  MOVLW  06
16820:  MOVWF  x12
16822:  MOVLB  0
16824:  CALL   5C98
16828:  MOVF   01,W
1682A:  MOVLB  7
1682C:  ADDWF  xD1,W
1682E:  MOVLB  8
16830:  MOVWF  x8E
16832:  MOVF   02,W
16834:  MOVLB  7
16836:  ADDWFC xD2,W
16838:  MOVLB  8
1683A:  MOVWF  x8F
....................     
....................    init_ext_eeprom(); 
1683C:  MOVLB  0
1683E:  CALL   10588
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
16842:  MOVFF  88F,8CC
16846:  MOVFF  88E,8CB
1684A:  CALL   105C0
1684E:  MOVFF  01,890
....................    ++addr; 
16852:  MOVLB  8
16854:  INCF   x8E,F
16856:  BTFSC  FD8.2
16858:  INCF   x8F,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
1685A:  MOVFF  88F,8C3
1685E:  MOVFF  88E,8C2
16862:  MOVLB  0
16864:  CALL   106D4
16868:  MOVFF  02,893
1686C:  MOVFF  01,892
....................    ++addr; 
16870:  MOVLB  8
16872:  INCF   x8E,F
16874:  BTFSC  FD8.2
16876:  INCF   x8F,F
....................    ++addr; 
16878:  INCF   x8E,F
1687A:  BTFSC  FD8.2
1687C:  INCF   x8F,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
1687E:  MOVFF  88F,8CC
16882:  MOVFF  88E,8CB
16886:  MOVLB  0
16888:  CALL   105C0
1688C:  MOVFF  01,891
....................    ++addr; 
16890:  MOVLB  8
16892:  INCF   x8E,F
16894:  BTFSC  FD8.2
16896:  INCF   x8F,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
16898:  MOVFF  88F,8C3
1689C:  MOVFF  88E,8C2
168A0:  MOVLB  0
168A2:  CALL   106D4
168A6:  MOVFF  02,895
168AA:  MOVFF  01,894
....................    ++addr; 
168AE:  MOVLB  8
168B0:  INCF   x8E,F
168B2:  BTFSC  FD8.2
168B4:  INCF   x8F,F
....................    ++addr; 
168B6:  INCF   x8E,F
168B8:  BTFSC  FD8.2
168BA:  INCF   x8F,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
168BC:  MOVFF  88F,8CC
168C0:  MOVFF  88E,8CB
168C4:  MOVLB  0
168C6:  CALL   105C0
168CA:  MOVFF  01,896
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
168CE:  MOVLB  8
168D0:  MOVF   x90,W
168D2:  SUBLW  50
168D4:  BNZ   16978
168D6:  MOVF   x91,W
168D8:  SUBLW  4D
168DA:  BNZ   16978
....................        
....................       RTC_read(); 
168DC:  MOVLB  0
168DE:  CALL   3344
....................       RTC_display(); 
168E2:  CALL   E24E
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
168E6:  MOVLB  8
168E8:  MOVF   x90,W
168EA:  BTFSS  F9E.4
168EC:  BRA    168EA
168EE:  MOVWF  FAD
168F0:  MOVLW  10
168F2:  MOVWF  FE9
168F4:  CLRF   1B
168F6:  BTFSC  FF2.7
168F8:  BSF    1B.7
168FA:  BCF    FF2.7
168FC:  MOVFF  893,A41
16900:  MOVFF  892,A40
16904:  MOVLB  0
16906:  CALL   11A6
1690A:  BTFSC  1B.7
1690C:  BSF    FF2.7
1690E:  MOVLW  2C
16910:  BTFSS  F9E.4
16912:  BRA    16910
16914:  MOVWF  FAD
16916:  MOVLB  8
16918:  MOVF   x91,W
1691A:  BTFSS  F9E.4
1691C:  BRA    1691A
1691E:  MOVWF  FAD
16920:  MOVLW  10
16922:  MOVWF  FE9
16924:  CLRF   1B
16926:  BTFSC  FF2.7
16928:  BSF    1B.7
1692A:  BCF    FF2.7
1692C:  MOVFF  895,A41
16930:  MOVFF  894,A40
16934:  MOVLB  0
16936:  CALL   11A6
1693A:  BTFSC  1B.7
1693C:  BSF    FF2.7
1693E:  MOVLW  0D
16940:  BTFSS  F9E.4
16942:  BRA    16940
16944:  MOVWF  FAD
16946:  MOVLW  0A
16948:  BTFSS  F9E.4
1694A:  BRA    16948
1694C:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
1694E:  MOVLB  8
16950:  MOVF   x94,F
16952:  BNZ   16958
16954:  MOVF   x95,F
16956:  BZ    16976
16958:  MOVF   x95,F
1695A:  BNZ   16976
1695C:  MOVF   x94,W
1695E:  SUBLW  10
16960:  BNC   16976
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
16962:  MOVFF  894,897
16966:  MOVFF  893,899
1696A:  MOVFF  892,898
1696E:  MOVLB  0
16970:  CALL   1537A
16974:  MOVLB  8
....................       } 
....................    } 
16976:  BRA    16984
....................    else { 
....................       cmd_err(); 
16978:  MOVLB  0
1697A:  CALL   BF84
....................       macro_end = 59; 
1697E:  MOVLW  3B
16980:  MOVLB  8
16982:  MOVWF  x96
....................    } 
....................     
....................    return (macro_end); 
16984:  MOVFF  896,01
16988:  MOVLB  0
1698A:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
16206:  MOVF   24,W
16208:  SUBWF  36,W
1620A:  BTFSS  FD8.0
1620C:  BRA    16414
1620E:  BNZ   16218
16210:  MOVF   23,W
16212:  SUBWF  35,W
16214:  BTFSS  FD8.0
16216:  BRA    16414
16218:  MOVF   33,F
1621A:  BTFSS  FD8.2
1621C:  BRA    16414
1621E:  MOVF   34,F
16220:  BTFSS  FD8.2
16222:  BRA    16414
....................       { 
....................          nv_elapsed = 0; 
16224:  CLRF   36
16226:  CLRF   35
....................  
....................          init_hardware(); 
16228:  CALL   293A
....................          sd_status = init_sdcard(); 
1622C:  CALL   503A
16230:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
16234:  MOVLB  2
16236:  MOVF   xDC,F
16238:  BZ    16242
1623A:  MOVLB  0
1623C:  CALL   5080
16240:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16242:  MOVLW  01
16244:  MOVWF  1E
16246:  MOVLW  A7
16248:  MOVWF  1D
1624A:  MOVLW  46
1624C:  MOVWF  FF6
1624E:  MOVLW  22
16250:  MOVWF  FF7
16252:  MOVLW  00
16254:  MOVWF  FF8
16256:  MOVLW  14
16258:  MOVLB  8
1625A:  MOVWF  xEB
1625C:  MOVLB  0
1625E:  CALL   AACC
16262:  MOVLW  10
16264:  MOVWF  FE9
16266:  MOVFF  22,8F7
1626A:  MOVFF  21,8F6
1626E:  CALL   AAFE
16272:  MOVLW  5D
16274:  MOVWF  FF6
16276:  MOVLW  22
16278:  MOVWF  FF7
1627A:  MOVLW  00
1627C:  MOVWF  FF8
1627E:  MOVLW  09
16280:  MOVLB  8
16282:  MOVWF  xEB
16284:  MOVLB  0
16286:  CALL   AACC
....................          record_event();          
1628A:  CALL   84DA
....................              
....................          macro_cmd = master_macro_eco(); 
1628E:  RCALL  15F52
16290:  MOVFF  01,887
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
16294:  MOVLW  16
16296:  MOVLB  8
16298:  MOVWF  xEE
1629A:  MOVFF  22,8F0
1629E:  MOVFF  21,8EF
162A2:  MOVLB  0
162A4:  CALL   4FD4
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
162A8:  MOVLW  3A
162AA:  MOVLB  8
162AC:  MOVWF  xEE
162AE:  MOVFF  38,8F0
162B2:  MOVFF  37,8EF
162B6:  MOVLB  0
162B8:  CALL   4FD4
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
162BC:  DECFSZ 50,W
162BE:  BRA    162E2
....................          { 
....................             disable_interrupts (INT_EXT); 
162C0:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
162C2:  CLRF   32
162C4:  MOVLW  01
162C6:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
162C8:  MOVLW  02
162CA:  MOVLB  8
162CC:  MOVWF  x89
162CE:  MOVFF  31,88A
162D2:  MOVLB  0
162D4:  CALL   3412
....................             busy_clear(); 
162D8:  CALL   AE74
....................             return (user_quit); 
162DC:  MOVFF  50,01
162E0:  BRA    16424
....................          } 
....................  
....................          motor_sleep_rdy(); 
162E2:  CALL   2998
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
162E6:  MOVLW  01
162E8:  MOVWF  1E
162EA:  MOVLW  A7
162EC:  MOVWF  1D
162EE:  MOVLW  68
162F0:  MOVWF  FF6
162F2:  MOVLW  22
162F4:  MOVWF  FF7
162F6:  MOVLW  00
162F8:  MOVWF  FF8
162FA:  MOVLW  14
162FC:  MOVLB  8
162FE:  MOVWF  xEB
16300:  MOVLB  0
16302:  CALL   AACC
16306:  MOVLW  10
16308:  MOVWF  FE9
1630A:  MOVFF  22,8F7
1630E:  MOVFF  21,8F6
16312:  CALL   AAFE
16316:  MOVLW  7F
16318:  MOVWF  FF6
1631A:  MOVLW  22
1631C:  MOVWF  FF7
1631E:  MOVLW  00
16320:  MOVWF  FF8
16322:  MOVLW  0C
16324:  MOVLB  8
16326:  MOVWF  xEB
16328:  MOVLB  0
1632A:  CALL   AACC
....................          record_event();  
1632E:  CALL   84DA
....................           
....................          if (macro_cmd == 'e') 
16332:  MOVLB  8
16334:  MOVF   x87,W
16336:  SUBLW  65
16338:  BNZ   1638C
....................          { 
....................             disable_interrupts (INT_EXT); 
1633A:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
1633C:  MOVLW  01
1633E:  MOVWF  1E
16340:  MOVLW  A7
16342:  MOVWF  1D
16344:  MOVLW  8C
16346:  MOVWF  FF6
16348:  MOVLW  22
1634A:  MOVWF  FF7
1634C:  MOVLW  00
1634E:  MOVWF  FF8
16350:  MOVLW  14
16352:  MOVWF  xEB
16354:  MOVLB  0
16356:  CALL   AACC
1635A:  MOVLW  10
1635C:  MOVWF  FE9
1635E:  MOVFF  22,8F7
16362:  MOVFF  21,8F6
16366:  CALL   AAFE
1636A:  MOVLW  A3
1636C:  MOVWF  FF6
1636E:  MOVLW  22
16370:  MOVWF  FF7
16372:  MOVLW  00
16374:  MOVWF  FF8
16376:  MOVLW  09
16378:  MOVLB  8
1637A:  MOVWF  xEB
1637C:  MOVLB  0
1637E:  CALL   AACC
....................             record_event();  
16382:  CALL   84DA
....................             cmd_err(); 
16386:  CALL   BF84
1638A:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
1638C:  MOVF   28,W
1638E:  SUBWF  22,W
16390:  BNC   16416
16392:  BNZ   1639A
16394:  MOVF   27,W
16396:  SUBWF  21,W
16398:  BNC   16416
....................          { 
....................             disable_interrupts (INT_EXT); 
1639A:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
1639C:  MOVLW  01
1639E:  MOVWF  1E
163A0:  MOVLW  A7
163A2:  MOVWF  1D
163A4:  MOVLW  AE
163A6:  MOVWF  FF6
163A8:  MOVLW  22
163AA:  MOVWF  FF7
163AC:  MOVLW  00
163AE:  MOVWF  FF8
163B0:  MOVLW  14
163B2:  MOVWF  xEB
163B4:  MOVLB  0
163B6:  CALL   AACC
163BA:  MOVLW  10
163BC:  MOVWF  FE9
163BE:  MOVFF  22,8F7
163C2:  MOVFF  21,8F6
163C6:  CALL   AAFE
163CA:  MOVLW  C5
163CC:  MOVWF  FF6
163CE:  MOVLW  22
163D0:  MOVWF  FF7
163D2:  MOVLW  00
163D4:  MOVWF  FF8
163D6:  MOVLW  0F
163D8:  MOVLB  8
163DA:  MOVWF  xEB
163DC:  MOVLB  0
163DE:  CALL   AACC
....................             record_event();   
163E2:  CALL   84DA
....................             msg_max(); 
163E6:  RCALL  161E8
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
163E8:  CLRF   34
163EA:  MOVLW  01
163EC:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
163EE:  MOVLW  28
163F0:  MOVLB  8
163F2:  MOVWF  x89
163F4:  MOVFF  33,88A
163F8:  MOVLB  0
163FA:  CALL   3412
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
163FE:  CLRF   32
16400:  MOVLW  01
16402:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16404:  MOVLW  02
16406:  MOVLB  8
16408:  MOVWF  x89
1640A:  MOVFF  31,88A
1640E:  MOVLB  0
16410:  CALL   3412
16414:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
16416:  MOVLB  0
16418:  RCALL  15E8C
1641A:  BRA    16206
....................    } 
....................     
....................    busy_clear(); 
1641C:  CALL   AE74
....................    return (user_quit); 
16420:  MOVFF  50,01
16424:  GOTO   16D48 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16620:  MOVF   24,W
16622:  SUBWF  36,W
16624:  BTFSS  FD8.0
16626:  BRA    167F6
16628:  BNZ   16632
1662A:  MOVF   23,W
1662C:  SUBWF  35,W
1662E:  BTFSS  FD8.0
16630:  BRA    167F6
....................       { 
....................          nv_elapsed = 0; 
16632:  CLRF   36
16634:  CLRF   35
....................  
....................          init_hardware(); 
16636:  CALL   293A
....................          sd_status = init_sdcard(); 
1663A:  CALL   503A
1663E:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
16642:  MOVLB  2
16644:  MOVF   xDC,F
16646:  BZ    16650
16648:  MOVLB  0
1664A:  CALL   5080
1664E:  MOVLB  2
....................  
....................          ++nv_sample; 
16650:  INCF   21,F
16652:  BTFSC  FD8.2
16654:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
16656:  MOVLW  40
16658:  BTFSS  F9E.4
1665A:  BRA    16658
1665C:  MOVWF  FAD
1665E:  MOVLW  53
16660:  BTFSS  F9E.4
16662:  BRA    16660
16664:  MOVWF  FAD
16666:  MOVLW  09
16668:  MOVWF  FE9
1666A:  CLRF   1B
1666C:  BTFSC  FF2.7
1666E:  BSF    1B.7
16670:  BCF    FF2.7
16672:  MOVFF  22,A41
16676:  MOVFF  21,A40
1667A:  MOVLB  0
1667C:  CALL   11A6
16680:  BTFSC  1B.7
16682:  BSF    FF2.7
16684:  MOVLW  0D
16686:  BTFSS  F9E.4
16688:  BRA    16686
1668A:  MOVWF  FAD
1668C:  MOVLW  0A
1668E:  BTFSS  F9E.4
16690:  BRA    1668E
16692:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16694:  MOVLW  01
16696:  MOVWF  1E
16698:  MOVLW  A7
1669A:  MOVWF  1D
1669C:  MOVLW  D6
1669E:  MOVWF  FF6
166A0:  MOVLW  22
166A2:  MOVWF  FF7
166A4:  MOVLW  00
166A6:  MOVWF  FF8
166A8:  MOVLW  14
166AA:  MOVLB  8
166AC:  MOVWF  xEB
166AE:  MOVLB  0
166B0:  CALL   AACC
166B4:  MOVLW  10
166B6:  MOVWF  FE9
166B8:  MOVFF  22,8F7
166BC:  MOVFF  21,8F6
166C0:  CALL   AAFE
166C4:  MOVLW  ED
166C6:  MOVWF  FF6
166C8:  MOVLW  22
166CA:  MOVWF  FF7
166CC:  MOVLW  00
166CE:  MOVWF  FF8
166D0:  MOVLW  09
166D2:  MOVLB  8
166D4:  MOVWF  xEB
166D6:  MOVLB  0
166D8:  CALL   AACC
....................          record_event();   
166DC:  CALL   84DA
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
166E0:  MOVLW  16
166E2:  MOVLB  8
166E4:  MOVWF  xEE
166E6:  MOVFF  22,8F0
166EA:  MOVFF  21,8EF
166EE:  MOVLB  0
166F0:  CALL   4FD4
....................  
....................          if (nv_macro_mode==TRUE) 
166F4:  DECFSZ 29,W
166F6:  BRA    1670C
166F8:  MOVF   2A,F
166FA:  BNZ   1670C
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
166FC:  MOVFF  22,889
16700:  MOVFF  21,888
16704:  BRA    16428
16706:  MOVFF  01,887
....................          } 
1670A:  BRA    16774
....................          else 
....................          { 
....................             time_stamp(); 
1670C:  CALL   541A
....................             play_wms_hard_macro(nv_port); 
16710:  MOVFF  2E,88A
16714:  MOVFF  2D,889
16718:  CALL   D7C4
....................             ++nv_port; 
1671C:  INCF   2D,F
1671E:  BTFSC  FD8.2
16720:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
16722:  MOVF   2E,F
16724:  BNZ   1672C
16726:  MOVF   2D,W
16728:  SUBLW  01
1672A:  BC    1673E
1672C:  MOVF   2E,F
1672E:  BNZ   1673E
16730:  MOVF   2D,W
16732:  SUBLW  30
16734:  BNC   1673E
16736:  DECFSZ 2F,W
16738:  BRA    1673E
1673A:  MOVF   30,F
1673C:  BZ    1675C
1673E:  MOVF   2E,F
16740:  BNZ   16748
16742:  MOVF   2D,W
16744:  SUBLW  01
16746:  BC    16772
16748:  MOVF   2E,F
1674A:  BNZ   16772
1674C:  MOVF   2D,W
1674E:  SUBLW  32
16750:  BNC   16772
16752:  MOVF   2F,W
16754:  SUBLW  03
16756:  BNZ   16772
16758:  MOVF   30,F
1675A:  BNZ   16772
....................             { 
....................                write16(ADDR_PORT, nv_port);             
1675C:  MOVLW  24
1675E:  MOVLB  8
16760:  MOVWF  xEE
16762:  MOVFF  2E,8F0
16766:  MOVFF  2D,8EF
1676A:  MOVLB  0
1676C:  CALL   4FD4
....................             } 
16770:  BRA    16774
....................             else disable_interrupts (INT_EXT); 
16772:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
16774:  DECFSZ 50,W
16776:  BRA    1679A
....................          { 
....................             disable_interrupts (INT_EXT); 
16778:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
1677A:  CLRF   32
1677C:  MOVLW  01
1677E:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16780:  MOVLW  02
16782:  MOVLB  8
16784:  MOVWF  x89
16786:  MOVFF  31,88A
1678A:  MOVLB  0
1678C:  CALL   3412
....................             busy_clear(); 
16790:  CALL   AE74
....................             return (user_quit); 
16794:  MOVFF  50,01
16798:  BRA    16804
....................          } 
....................           
....................          motor_sleep_rdy(); 
1679A:  CALL   2998
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
1679E:  MOVLW  01
167A0:  MOVWF  1E
167A2:  MOVLW  A7
167A4:  MOVWF  1D
167A6:  MOVLW  F8
167A8:  MOVWF  FF6
167AA:  MOVLW  22
167AC:  MOVWF  FF7
167AE:  MOVLW  00
167B0:  MOVWF  FF8
167B2:  MOVLW  14
167B4:  MOVLB  8
167B6:  MOVWF  xEB
167B8:  MOVLB  0
167BA:  CALL   AACC
167BE:  MOVLW  10
167C0:  MOVWF  FE9
167C2:  MOVFF  22,8F7
167C6:  MOVFF  21,8F6
167CA:  CALL   AAFE
167CE:  MOVLW  0F
167D0:  MOVWF  FF6
167D2:  MOVLW  23
167D4:  MOVWF  FF7
167D6:  MOVLW  00
167D8:  MOVWF  FF8
167DA:  MOVLW  0C
167DC:  MOVLB  8
167DE:  MOVWF  xEB
167E0:  MOVLB  0
167E2:  CALL   AACC
....................          record_event();  
167E6:  CALL   84DA
....................           
....................          if (macro_end == ';') 
167EA:  MOVLB  8
167EC:  MOVF   x87,W
167EE:  SUBLW  3B
167F0:  BNZ   167F4
....................          { 
....................             disable_interrupts (INT_EXT); 
167F2:  BCF    FF2.4
167F4:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
167F6:  CALL   15E8C
167FA:  BRA    16620
....................    } 
....................    busy_clear(); 
167FC:  CALL   AE74
....................    return (user_quit); 
16800:  MOVFF  50,01
16804:  GOTO   16D50 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
1698C:  MOVF   24,W
1698E:  SUBWF  36,W
16990:  BTFSS  FD8.0
16992:  BRA    16B4C
16994:  BNZ   1699E
16996:  MOVF   23,W
16998:  SUBWF  35,W
1699A:  BTFSS  FD8.0
1699C:  BRA    16B4C
....................       { 
....................          nv_elapsed = 0; 
1699E:  CLRF   36
169A0:  CLRF   35
....................  
....................          init_hardware(); 
169A2:  CALL   293A
....................          sd_status = init_sdcard(); 
169A6:  CALL   503A
169AA:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
169AE:  MOVLB  2
169B0:  MOVF   xDC,F
169B2:  BZ    169BC
169B4:  MOVLB  0
169B6:  CALL   5080
169BA:  MOVLB  2
....................  
....................          ++nv_sample; 
169BC:  INCF   21,F
169BE:  BTFSC  FD8.2
169C0:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
169C2:  MOVLW  40
169C4:  BTFSS  F9E.4
169C6:  BRA    169C4
169C8:  MOVWF  FAD
169CA:  MOVLW  53
169CC:  BTFSS  F9E.4
169CE:  BRA    169CC
169D0:  MOVWF  FAD
169D2:  MOVLW  09
169D4:  MOVWF  FE9
169D6:  CLRF   1B
169D8:  BTFSC  FF2.7
169DA:  BSF    1B.7
169DC:  BCF    FF2.7
169DE:  MOVFF  22,A41
169E2:  MOVFF  21,A40
169E6:  MOVLB  0
169E8:  CALL   11A6
169EC:  BTFSC  1B.7
169EE:  BSF    FF2.7
169F0:  MOVLW  0D
169F2:  BTFSS  F9E.4
169F4:  BRA    169F2
169F6:  MOVWF  FAD
169F8:  MOVLW  0A
169FA:  BTFSS  F9E.4
169FC:  BRA    169FA
169FE:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16A00:  MOVLW  01
16A02:  MOVWF  1E
16A04:  MOVLW  A7
16A06:  MOVWF  1D
16A08:  MOVLW  1C
16A0A:  MOVWF  FF6
16A0C:  MOVLW  23
16A0E:  MOVWF  FF7
16A10:  MOVLW  00
16A12:  MOVWF  FF8
16A14:  MOVLW  14
16A16:  MOVLB  8
16A18:  MOVWF  xEB
16A1A:  MOVLB  0
16A1C:  CALL   AACC
16A20:  MOVLW  10
16A22:  MOVWF  FE9
16A24:  MOVFF  22,8F7
16A28:  MOVFF  21,8F6
16A2C:  CALL   AAFE
16A30:  MOVLW  33
16A32:  MOVWF  FF6
16A34:  MOVLW  23
16A36:  MOVWF  FF7
16A38:  MOVLW  00
16A3A:  MOVWF  FF8
16A3C:  MOVLW  09
16A3E:  MOVLB  8
16A40:  MOVWF  xEB
16A42:  MOVLB  0
16A44:  CALL   AACC
....................          record_event();   
16A48:  CALL   84DA
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16A4C:  MOVLW  16
16A4E:  MOVLB  8
16A50:  MOVWF  xEE
16A52:  MOVFF  22,8F0
16A56:  MOVFF  21,8EF
16A5A:  MOVLB  0
16A5C:  CALL   4FD4
....................  
....................          macro_end = master_macro_aws(nv_sample); 
16A60:  MOVFF  22,88D
16A64:  MOVFF  21,88C
16A68:  RCALL  16808
16A6A:  MOVFF  01,887
....................           
....................          if (user_quit == TRUE) 
16A6E:  DECFSZ 50,W
16A70:  BRA    16A94
....................          { 
....................             disable_interrupts (INT_EXT); 
16A72:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
16A74:  CLRF   32
16A76:  MOVLW  01
16A78:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16A7A:  MOVLW  02
16A7C:  MOVLB  8
16A7E:  MOVWF  x89
16A80:  MOVFF  31,88A
16A84:  MOVLB  0
16A86:  CALL   3412
....................             busy_clear(); 
16A8A:  CALL   AE74
....................             return (user_quit); 
16A8E:  MOVFF  50,01
16A92:  BRA    16B5E
....................          } 
....................           
....................          motor_sleep_rdy(); 
16A94:  CALL   2998
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16A98:  MOVLW  01
16A9A:  MOVWF  1E
16A9C:  MOVLW  A7
16A9E:  MOVWF  1D
16AA0:  MOVLW  3E
16AA2:  MOVWF  FF6
16AA4:  MOVLW  23
16AA6:  MOVWF  FF7
16AA8:  MOVLW  00
16AAA:  MOVWF  FF8
16AAC:  MOVLW  14
16AAE:  MOVLB  8
16AB0:  MOVWF  xEB
16AB2:  MOVLB  0
16AB4:  CALL   AACC
16AB8:  MOVLW  10
16ABA:  MOVWF  FE9
16ABC:  MOVFF  22,8F7
16AC0:  MOVFF  21,8F6
16AC4:  CALL   AAFE
16AC8:  MOVLW  55
16ACA:  MOVWF  FF6
16ACC:  MOVLW  23
16ACE:  MOVWF  FF7
16AD0:  MOVLW  00
16AD2:  MOVWF  FF8
16AD4:  MOVLW  0C
16AD6:  MOVLB  8
16AD8:  MOVWF  xEB
16ADA:  MOVLB  0
16ADC:  CALL   AACC
....................          record_event();  
16AE0:  CALL   84DA
....................           
....................          if (macro_end == ';') 
16AE4:  MOVLB  8
16AE6:  MOVF   x87,W
16AE8:  SUBLW  3B
16AEA:  BNZ   16AEE
....................          { 
....................             disable_interrupts (INT_EXT); 
16AEC:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16AEE:  MOVF   28,W
16AF0:  SUBWF  22,W
16AF2:  BNC   16B4E
16AF4:  BNZ   16AFC
16AF6:  MOVF   27,W
16AF8:  SUBWF  21,W
16AFA:  BNC   16B4E
....................          { 
....................             disable_interrupts (INT_EXT); 
16AFC:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16AFE:  MOVLW  01
16B00:  MOVWF  1E
16B02:  MOVLW  A7
16B04:  MOVWF  1D
16B06:  MOVLW  62
16B08:  MOVWF  FF6
16B0A:  MOVLW  23
16B0C:  MOVWF  FF7
16B0E:  MOVLW  00
16B10:  MOVWF  FF8
16B12:  MOVLW  14
16B14:  MOVWF  xEB
16B16:  MOVLB  0
16B18:  CALL   AACC
16B1C:  MOVLW  10
16B1E:  MOVWF  FE9
16B20:  MOVFF  22,8F7
16B24:  MOVFF  21,8F6
16B28:  CALL   AAFE
16B2C:  MOVLW  79
16B2E:  MOVWF  FF6
16B30:  MOVLW  23
16B32:  MOVWF  FF7
16B34:  MOVLW  00
16B36:  MOVWF  FF8
16B38:  MOVLW  0F
16B3A:  MOVLB  8
16B3C:  MOVWF  xEB
16B3E:  MOVLB  0
16B40:  CALL   AACC
....................             record_event();   
16B44:  CALL   84DA
....................             msg_max(); 
16B48:  CALL   161E8
16B4C:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
16B4E:  MOVLB  0
16B50:  CALL   15E8C
16B54:  BRA    1698C
....................    } 
....................    busy_clear(); 
16B56:  CALL   AE74
....................    return (user_quit); 
16B5A:  MOVFF  50,01
16B5E:  GOTO   16D58 (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
16B62:  CALL   29C0
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
16B66:  MOVLW  01
16B68:  MOVWF  1E
16B6A:  MOVLW  A7
16B6C:  MOVWF  1D
16B6E:  MOVLW  8A
16B70:  MOVWF  FF6
16B72:  MOVLW  23
16B74:  MOVWF  FF7
16B76:  MOVLW  00
16B78:  MOVWF  FF8
16B7A:  CALL   50BE
....................    record_event(); 
16B7E:  CALL   84DA
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
16B82:  MOVLW  01
16B84:  MOVWF  1E
16B86:  MOVLW  A7
16B88:  MOVWF  1D
16B8A:  MOVLW  A4
16B8C:  MOVWF  FF6
16B8E:  MOVLW  23
16B90:  MOVWF  FF7
16B92:  MOVLW  00
16B94:  MOVWF  FF8
16B96:  MOVLW  0C
16B98:  MOVLB  8
16B9A:  MOVWF  xEB
16B9C:  MOVLB  0
16B9E:  CALL   AACC
16BA2:  MOVLW  10
16BA4:  MOVWF  FE9
16BA6:  MOVFF  26,8F7
16BAA:  MOVFF  25,8F6
16BAE:  CALL   AAFE
16BB2:  MOVLW  B3
16BB4:  MOVWF  FF6
16BB6:  MOVLW  23
16BB8:  MOVWF  FF7
16BBA:  MOVLW  00
16BBC:  MOVWF  FF8
16BBE:  MOVLW  06
16BC0:  MOVLB  8
16BC2:  MOVWF  xEB
16BC4:  MOVLB  0
16BC6:  CALL   AACC
16BCA:  MOVLW  10
16BCC:  MOVWF  FE9
16BCE:  MOVFF  24,8F7
16BD2:  MOVFF  23,8F6
16BD6:  CALL   AAFE
16BDA:  MOVLW  BC
16BDC:  MOVWF  FF6
16BDE:  MOVLW  23
16BE0:  MOVWF  FF7
16BE2:  MOVLW  00
16BE4:  MOVWF  FF8
16BE6:  MOVLW  06
16BE8:  MOVLB  8
16BEA:  MOVWF  xEB
16BEC:  MOVLB  0
16BEE:  CALL   AACC
16BF2:  MOVLW  10
16BF4:  MOVWF  FE9
16BF6:  MOVFF  28,8F7
16BFA:  MOVFF  27,8F6
16BFE:  CALL   AAFE
16C02:  MOVLW  C5
16C04:  MOVWF  FF6
16C06:  MOVLW  23
16C08:  MOVWF  FF7
16C0A:  MOVLW  00
16C0C:  MOVWF  FF8
16C0E:  MOVLW  03
16C10:  MOVLB  8
16C12:  MOVWF  xEB
16C14:  MOVLB  0
16C16:  CALL   AACC
....................    record_event(); 
16C1A:  CALL   84DA
....................     
....................    user_quit = FALSE; 
16C1E:  CLRF   50
....................     
....................    nv_cmd_mode = FALSE; 
16C20:  CLRF   32
16C22:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
16C24:  MOVLW  02
16C26:  MOVLB  8
16C28:  MOVWF  x89
16C2A:  MOVFF  31,88A
16C2E:  MOVLB  0
16C30:  CALL   3412
....................  
....................    RTC_set_AFE(); 
16C34:  GOTO   156E0
....................    // check if start is earlier than now 
....................    RTC_late(); 
16C38:  CALL   15738
....................    // show clock 
....................    RTC_display(); 
16C3C:  CALL   E24E
....................    // show alarm 
....................    RTC_display_alarm(); 
16C40:  CALL   E4AE
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
16C44:  CALL   15BFE
....................  
....................    if (alarm_passed == FALSE){ 
16C48:  BTFSC  4D.3
16C4A:  BRA    16C4C
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
16C4C:  MOVLW  00
16C4E:  BTFSC  4D.3
16C50:  MOVLW  01
16C52:  MOVLB  8
16C54:  MOVWF  x87
16C56:  MOVLW  01
16C58:  MOVWF  1E
16C5A:  MOVLW  A7
16C5C:  MOVWF  1D
16C5E:  MOVLW  CA
16C60:  MOVWF  FF6
16C62:  MOVLW  23
16C64:  MOVWF  FF7
16C66:  MOVLW  00
16C68:  MOVWF  FF8
16C6A:  MOVLW  14
16C6C:  MOVWF  xEB
16C6E:  MOVLB  0
16C70:  CALL   AACC
16C74:  MOVLW  10
16C76:  MOVWF  FE9
16C78:  MOVFF  22,8F7
16C7C:  MOVFF  21,8F6
16C80:  CALL   AAFE
16C84:  MOVLW  E1
16C86:  MOVWF  FF6
16C88:  MOVLW  23
16C8A:  MOVWF  FF7
16C8C:  MOVLW  00
16C8E:  MOVWF  FF8
16C90:  MOVLW  08
16C92:  MOVLB  8
16C94:  MOVWF  xEB
16C96:  MOVLB  0
16C98:  CALL   AACC
16C9C:  MOVFF  887,8ED
16CA0:  MOVLW  1B
16CA2:  MOVLB  8
16CA4:  MOVWF  xEE
16CA6:  MOVLB  0
16CA8:  CALL   5280
16CAC:  MOVLW  EB
16CAE:  MOVWF  FF6
16CB0:  MOVLW  23
16CB2:  MOVWF  FF7
16CB4:  MOVLW  00
16CB6:  MOVWF  FF8
16CB8:  MOVLW  03
16CBA:  MOVLB  8
16CBC:  MOVWF  xEB
16CBE:  MOVLB  0
16CC0:  CALL   AACC
....................    record_event();  
16CC4:  CALL   84DA
....................  
....................    while (TRUE == RTC_read_flags_running) 
16CC8:  BTFSS  4D.2
16CCA:  BRA    16CCE
....................    { 
....................       ; 
16CCC:  BRA    16CC8
....................    } 
....................    RTC_read_flags_running = TRUE; 
16CCE:  BSF    4D.2
16CD0:  CLRF   1B
16CD2:  BTFSC  FF2.7
16CD4:  BSF    1B.7
16CD6:  BCF    FF2.7
....................    RTC_read_flags(); 
16CD8:  CALL   0DD8
16CDC:  BTFSC  1B.7
16CDE:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
16CE0:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
16CE2:  CALL   2998
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
16CE6:  BTFSC  4D.3
16CE8:  BRA    16D0A
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16CEA:  MOVLW  01
16CEC:  MOVWF  1E
16CEE:  MOVLW  A7
16CF0:  MOVWF  1D
16CF2:  MOVLW  F0
16CF4:  MOVWF  FF6
16CF6:  MOVLW  23
16CF8:  MOVWF  FF7
16CFA:  MOVLW  00
16CFC:  MOVWF  FF8
16CFE:  CALL   50BE
....................       record_event(); 
16D02:  CALL   84DA
....................       go_to_sleep(); 
16D06:  CALL   15E8C
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16D0A:  GOTO   15EA2
....................    nv_elapsed = nv_interval; 
16D0E:  MOVFF  24,36
16D12:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
16D16:  MOVFF  2F,00
16D1A:  MOVF   30,W
16D1C:  MOVWF  03
16D1E:  BNZ   16D24
16D20:  MOVF   00,F
16D22:  BZ    16D44
16D24:  MOVF   03,W
16D26:  BNZ   16D2E
16D28:  MOVLW  01
16D2A:  SUBWF  00,W
16D2C:  BZ    16D4E
16D2E:  MOVF   03,W
16D30:  BNZ   16D38
16D32:  MOVLW  03
16D34:  SUBWF  00,W
16D36:  BZ    16D4E
16D38:  MOVF   03,W
16D3A:  BNZ   16D42
16D3C:  MOVLW  02
16D3E:  SUBWF  00,W
16D40:  BZ    16D56
16D42:  BRA    16D5C
....................       case ECO: user_quit = auto_sample_eco(); 
16D44:  GOTO   16206
16D48:  MOVFF  01,50
....................          break; 
16D4C:  BRA    16D5C
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
16D4E:  BRA    16620
16D50:  MOVFF  01,50
....................          break; 
16D54:  BRA    16D5C
....................       case AWS: user_quit = auto_sample_aws(); 
16D56:  BRA    1698C
16D58:  MOVFF  01,50
....................          break;          
....................    } 
....................    return(user_quit); 
16D5C:  MOVFF  50,01
16D60:  GOTO   16E72 (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BF54:  MOVF   48,F
0BF56:  BNZ   BF64
0BF58:  MOVF   49,F
0BF5A:  BNZ   BF64
0BF5C:  MOVF   4A,F
0BF5E:  BNZ   BF64
0BF60:  MOVF   4B,F
0BF62:  BZ    BF7C
0BF64:  MOVF   4B,F
0BF66:  BNZ   BF7C
0BF68:  MOVF   4A,F
0BF6A:  BNZ   BF7C
0BF6C:  MOVF   49,F
0BF6E:  BNZ   BF7C
0BF70:  MOVF   48,W
0BF72:  SUBLW  02
0BF74:  BNC   BF7C
....................       detector = arg; 
0BF76:  MOVFF  48,2D5
....................    } 
0BF7A:  BRA    BF80
....................    else cmd_arg(); 
0BF7C:  CALL   B2C2
0BF80:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0BFA2:  MOVF   48,F
0BFA4:  BNZ   BFB2
0BFA6:  MOVF   49,F
0BFA8:  BNZ   BFB2
0BFAA:  MOVF   4A,F
0BFAC:  BNZ   BFB2
0BFAE:  MOVF   4B,F
0BFB0:  BZ    C00C
0BFB2:  MOVF   4B,F
0BFB4:  BNZ   C00C
0BFB6:  MOVF   4A,W
0BFB8:  SUBLW  00
0BFBA:  BNC   C00C
....................       switch (detector){ 
0BFBC:  MOVLB  2
0BFBE:  MOVF   xD5,W
0BFC0:  XORLW  01
0BFC2:  MOVLB  0
0BFC4:  BZ    BFCC
0BFC6:  XORLW  03
0BFC8:  BZ    BFEA
0BFCA:  BRA    C008
....................          case 1 : nv_d1_temp = arg; 
0BFCC:  MOVFF  49,42
0BFD0:  MOVFF  48,41
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0BFD4:  MOVLW  40
0BFD6:  MOVLB  8
0BFD8:  MOVWF  xEE
0BFDA:  MOVFF  42,8F0
0BFDE:  MOVFF  41,8EF
0BFE2:  MOVLB  0
0BFE4:  CALL   4FD4
....................             break; 
0BFE8:  BRA    C00A
....................          case 2 : nv_d2_temp = arg; 
0BFEA:  MOVFF  49,44
0BFEE:  MOVFF  48,43
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0BFF2:  MOVLW  42
0BFF4:  MOVLB  8
0BFF6:  MOVWF  xEE
0BFF8:  MOVFF  44,8F0
0BFFC:  MOVFF  43,8EF
0C000:  MOVLB  0
0C002:  CALL   4FD4
....................             break; 
0C006:  BRA    C00A
....................          default : cmd_err(); 
0C008:  RCALL  BF84
....................             break; 
....................       } 
....................    } 
0C00A:  BRA    C0B2
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0C00C:  MOVF   48,F
0C00E:  BNZ   C0AE
0C010:  MOVF   49,F
0C012:  BNZ   C0AE
0C014:  MOVF   4A,F
0C016:  BNZ   C0AE
0C018:  MOVF   4B,F
0C01A:  BNZ   C0AE
0C01C:  MOVLW  06
0C01E:  MOVWF  FF6
0C020:  MOVLW  24
0C022:  MOVWF  FF7
0C024:  MOVLW  00
0C026:  MOVWF  FF8
0C028:  CLRF   1B
0C02A:  BTFSC  FF2.7
0C02C:  BSF    1B.7
0C02E:  BCF    FF2.7
0C030:  MOVLW  03
0C032:  MOVLB  A
0C034:  MOVWF  x40
0C036:  MOVLB  0
0C038:  CALL   1024
0C03C:  BTFSC  1B.7
0C03E:  BSF    FF2.7
0C040:  MOVLW  10
0C042:  MOVWF  FE9
0C044:  CLRF   1B
0C046:  BTFSC  FF2.7
0C048:  BSF    1B.7
0C04A:  BCF    FF2.7
0C04C:  MOVFF  42,A41
0C050:  MOVFF  41,A40
0C054:  CALL   11A6
0C058:  BTFSC  1B.7
0C05A:  BSF    FF2.7
0C05C:  MOVLW  0C
0C05E:  MOVWF  FF6
0C060:  MOVLW  24
0C062:  MOVWF  FF7
0C064:  MOVLW  00
0C066:  MOVWF  FF8
0C068:  CLRF   1B
0C06A:  BTFSC  FF2.7
0C06C:  BSF    1B.7
0C06E:  BCF    FF2.7
0C070:  MOVLW  04
0C072:  MOVLB  A
0C074:  MOVWF  x40
0C076:  MOVLB  0
0C078:  CALL   1024
0C07C:  BTFSC  1B.7
0C07E:  BSF    FF2.7
0C080:  MOVLW  10
0C082:  MOVWF  FE9
0C084:  CLRF   1B
0C086:  BTFSC  FF2.7
0C088:  BSF    1B.7
0C08A:  BCF    FF2.7
0C08C:  MOVFF  44,A41
0C090:  MOVFF  43,A40
0C094:  CALL   11A6
0C098:  BTFSC  1B.7
0C09A:  BSF    FF2.7
0C09C:  MOVLW  0D
0C09E:  BTFSS  F9E.4
0C0A0:  BRA    C09E
0C0A2:  MOVWF  FAD
0C0A4:  MOVLW  0A
0C0A6:  BTFSS  F9E.4
0C0A8:  BRA    C0A6
0C0AA:  MOVWF  FAD
0C0AC:  BRA    C0B2
....................    else cmd_arg(); 
0C0AE:  CALL   B2C2
0C0B2:  GOTO   C118 (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0C0B6:  MOVF   4B,F
0C0B8:  BNZ   C0E6
0C0BA:  MOVF   4A,F
0C0BC:  BNZ   C0E6
0C0BE:  MOVF   49,F
0C0C0:  BNZ   C0E6
0C0C2:  MOVF   48,W
0C0C4:  SUBLW  01
0C0C6:  BNC   C0E6
....................       nv_macro_mode = arg; 
0C0C8:  MOVFF  49,2A
0C0CC:  MOVFF  48,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0C0D0:  MOVLW  20
0C0D2:  MOVLB  8
0C0D4:  MOVWF  xEE
0C0D6:  MOVFF  2A,8F0
0C0DA:  MOVFF  29,8EF
0C0DE:  MOVLB  0
0C0E0:  CALL   4FD4
....................    } 
0C0E4:  BRA    C0EA
....................    else cmd_arg(); 
0C0E6:  CALL   B2C2
0C0EA:  GOTO   C118 (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0C0EE:  MOVF   2F,W
0C0F0:  MOVWF  00
0C0F2:  MOVF   30,W
0C0F4:  MOVWF  03
0C0F6:  BNZ   C0FC
0C0F8:  MOVF   00,F
0C0FA:  BZ    C112
0C0FC:  MOVF   03,W
0C0FE:  BNZ   C106
0C100:  MOVLW  01
0C102:  SUBWF  00,W
0C104:  BZ    C116
0C106:  MOVF   03,W
0C108:  BNZ   C110
0C10A:  MOVLW  03
0C10C:  SUBWF  00,W
0C10E:  BZ    C116
0C110:  BRA    C118
....................       case ECO : commandAe(); 
0C112:  BRA    BFA2
....................          break; 
0C114:  BRA    C118
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0C116:  BRA    C0B6
....................          break; 
....................    } 
0C118:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0C11C:  MOVF   48,F
0C11E:  BNZ   C12C
0C120:  MOVF   49,F
0C122:  BNZ   C12C
0C124:  MOVF   4A,F
0C126:  BNZ   C12C
0C128:  MOVF   4B,F
0C12A:  BZ    C15C
0C12C:  MOVF   4B,F
0C12E:  BNZ   C15C
0C130:  MOVF   4A,F
0C132:  BNZ   C15C
0C134:  MOVF   49,F
0C136:  BNZ   C15C
0C138:  MOVF   48,W
0C13A:  SUBLW  03
0C13C:  BNC   C15C
....................       nv_det_type = arg; 
0C13E:  MOVFF  49,46
0C142:  MOVFF  48,45
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0C146:  MOVLW  26
0C148:  MOVLB  8
0C14A:  MOVWF  xEE
0C14C:  MOVFF  46,8F0
0C150:  MOVFF  45,8EF
0C154:  MOVLB  0
0C156:  CALL   4FD4
....................    } 
0C15A:  BRA    C1C2
....................    else if(arg==0) { 
0C15C:  MOVF   48,F
0C15E:  BNZ   C1BE
0C160:  MOVF   49,F
0C162:  BNZ   C1BE
0C164:  MOVF   4A,F
0C166:  BNZ   C1BE
0C168:  MOVF   4B,F
0C16A:  BNZ   C1BE
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0C16C:  MOVLW  16
0C16E:  MOVWF  FF6
0C170:  MOVLW  24
0C172:  MOVWF  FF7
0C174:  MOVLW  00
0C176:  MOVWF  FF8
0C178:  CLRF   1B
0C17A:  BTFSC  FF2.7
0C17C:  BSF    1B.7
0C17E:  BCF    FF2.7
0C180:  MOVLW  05
0C182:  MOVLB  A
0C184:  MOVWF  x40
0C186:  MOVLB  0
0C188:  CALL   1024
0C18C:  BTFSC  1B.7
0C18E:  BSF    FF2.7
0C190:  MOVLW  10
0C192:  MOVWF  FE9
0C194:  CLRF   1B
0C196:  BTFSC  FF2.7
0C198:  BSF    1B.7
0C19A:  BCF    FF2.7
0C19C:  MOVFF  46,A41
0C1A0:  MOVFF  45,A40
0C1A4:  CALL   11A6
0C1A8:  BTFSC  1B.7
0C1AA:  BSF    FF2.7
0C1AC:  MOVLW  0D
0C1AE:  BTFSS  F9E.4
0C1B0:  BRA    C1AE
0C1B2:  MOVWF  FAD
0C1B4:  MOVLW  0A
0C1B6:  BTFSS  F9E.4
0C1B8:  BRA    C1B6
0C1BA:  MOVWF  FAD
....................    } 
0C1BC:  BRA    C1C2
....................    else cmd_arg(); 
0C1BE:  CALL   B2C2
0C1C2:  GOTO   C284 (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0C234:  MOVF   4B,F
0C236:  BNZ   C252
0C238:  MOVF   4A,F
0C23A:  BNZ   C252
0C23C:  MOVF   49,F
0C23E:  BNZ   C252
0C240:  MOVF   48,W
0C242:  SUBLW  03
0C244:  BNC   C252
....................       hb_cmd=arg; 
0C246:  MOVFF  48,885
....................       h_bridge(hb_cmd); 
0C24A:  MOVFF  885,8B5
0C24E:  RCALL  C214
....................    } 
0C250:  BRA    C256
....................    else cmd_arg(); 
0C252:  CALL   B2C2
0C256:  GOTO   C284 (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0C25A:  MOVF   2F,W
0C25C:  MOVWF  00
0C25E:  MOVF   30,W
0C260:  MOVWF  03
0C262:  BNZ   C268
0C264:  MOVF   00,F
0C266:  BZ    C27E
0C268:  MOVF   03,W
0C26A:  BNZ   C272
0C26C:  MOVLW  01
0C26E:  SUBWF  00,W
0C270:  BZ    C282
0C272:  MOVF   03,W
0C274:  BNZ   C27C
0C276:  MOVLW  03
0C278:  SUBWF  00,W
0C27A:  BZ    C282
0C27C:  BRA    C284
....................       case ECO : commandBe(); 
0C27E:  BRA    C11C
....................          break; 
0C280:  BRA    C284
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0C282:  BRA    C234
....................          break; 
....................    } 
0C284:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CD7E:  MOVF   48,W
0CD80:  MOVWF  00
0CD82:  MOVF   49,W
0CD84:  MOVWF  03
0CD86:  BNZ   CD8C
0CD88:  MOVF   00,F
0CD8A:  BZ    CDEE
0CD8C:  MOVF   03,W
0CD8E:  BNZ   CD98
0CD90:  MOVLW  01
0CD92:  SUBWF  00,W
0CD94:  BTFSC  FD8.2
0CD96:  BRA    CFDE
0CD98:  MOVF   03,W
0CD9A:  BNZ   CDA4
0CD9C:  MOVLW  02
0CD9E:  SUBWF  00,W
0CDA0:  BTFSC  FD8.2
0CDA2:  BRA    D03A
0CDA4:  MOVF   03,W
0CDA6:  BNZ   CDB0
0CDA8:  MOVLW  03
0CDAA:  SUBWF  00,W
0CDAC:  BTFSC  FD8.2
0CDAE:  BRA    D096
0CDB0:  MOVF   03,W
0CDB2:  BNZ   CDBC
0CDB4:  MOVLW  04
0CDB6:  SUBWF  00,W
0CDB8:  BTFSC  FD8.2
0CDBA:  BRA    D0F2
0CDBC:  MOVF   03,W
0CDBE:  BNZ   CDC8
0CDC0:  MOVLW  05
0CDC2:  SUBWF  00,W
0CDC4:  BTFSC  FD8.2
0CDC6:  BRA    D14E
0CDC8:  MOVF   03,W
0CDCA:  BNZ   CDD4
0CDCC:  MOVLW  06
0CDCE:  SUBWF  00,W
0CDD0:  BTFSC  FD8.2
0CDD2:  BRA    D1AA
0CDD4:  MOVF   03,W
0CDD6:  BNZ   CDE0
0CDD8:  MOVLW  07
0CDDA:  SUBWF  00,W
0CDDC:  BTFSC  FD8.2
0CDDE:  BRA    D206
0CDE0:  MOVF   03,W
0CDE2:  BNZ   CDEC
0CDE4:  MOVLW  08
0CDE6:  SUBWF  00,W
0CDE8:  BTFSC  FD8.2
0CDEA:  BRA    D262
0CDEC:  BRA    D2BE
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CDEE:  MOVLW  22
0CDF0:  MOVWF  FF6
0CDF2:  MOVLW  24
0CDF4:  MOVWF  FF7
0CDF6:  MOVLW  00
0CDF8:  MOVWF  FF8
0CDFA:  CLRF   1B
0CDFC:  BTFSC  FF2.7
0CDFE:  BSF    1B.7
0CE00:  BCF    FF2.7
0CE02:  MOVLW  04
0CE04:  MOVLB  A
0CE06:  MOVWF  x40
0CE08:  MOVLB  0
0CE0A:  CALL   1024
0CE0E:  BTFSC  1B.7
0CE10:  BSF    FF2.7
0CE12:  MOVLW  89
0CE14:  MOVWF  FE9
0CE16:  MOVFF  3F8,888
0CE1A:  MOVFF  3F7,887
0CE1E:  MOVFF  3F6,886
0CE22:  MOVFF  3F5,885
0CE26:  MOVLW  05
0CE28:  MOVLB  8
0CE2A:  MOVWF  x89
0CE2C:  MOVLB  0
0CE2E:  RCALL  C638
0CE30:  MOVLW  2C
0CE32:  BTFSS  F9E.4
0CE34:  BRA    CE32
0CE36:  MOVWF  FAD
0CE38:  MOVLW  89
0CE3A:  MOVWF  FE9
0CE3C:  MOVFF  3FC,888
0CE40:  MOVFF  3FB,887
0CE44:  MOVFF  3FA,886
0CE48:  MOVFF  3F9,885
0CE4C:  MOVLW  05
0CE4E:  MOVLB  8
0CE50:  MOVWF  x89
0CE52:  MOVLB  0
0CE54:  CALL   C638
0CE58:  MOVLW  0D
0CE5A:  BTFSS  F9E.4
0CE5C:  BRA    CE5A
0CE5E:  MOVWF  FAD
0CE60:  MOVLW  0A
0CE62:  BTFSS  F9E.4
0CE64:  BRA    CE62
0CE66:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CE68:  MOVLW  34
0CE6A:  MOVWF  FF6
0CE6C:  MOVLW  24
0CE6E:  MOVWF  FF7
0CE70:  MOVLW  00
0CE72:  MOVWF  FF8
0CE74:  CLRF   1B
0CE76:  BTFSC  FF2.7
0CE78:  BSF    1B.7
0CE7A:  BCF    FF2.7
0CE7C:  MOVLW  04
0CE7E:  MOVLB  A
0CE80:  MOVWF  x40
0CE82:  MOVLB  0
0CE84:  CALL   1024
0CE88:  BTFSC  1B.7
0CE8A:  BSF    FF2.7
0CE8C:  MOVLW  89
0CE8E:  MOVWF  FE9
0CE90:  MOVFF  400,888
0CE94:  MOVFF  3FF,887
0CE98:  MOVFF  3FE,886
0CE9C:  MOVFF  3FD,885
0CEA0:  MOVLW  05
0CEA2:  MOVLB  8
0CEA4:  MOVWF  x89
0CEA6:  MOVLB  0
0CEA8:  CALL   C638
0CEAC:  MOVLW  2C
0CEAE:  BTFSS  F9E.4
0CEB0:  BRA    CEAE
0CEB2:  MOVWF  FAD
0CEB4:  MOVLW  89
0CEB6:  MOVWF  FE9
0CEB8:  MOVFF  404,888
0CEBC:  MOVFF  403,887
0CEC0:  MOVFF  402,886
0CEC4:  MOVFF  401,885
0CEC8:  MOVLW  05
0CECA:  MOVLB  8
0CECC:  MOVWF  x89
0CECE:  MOVLB  0
0CED0:  CALL   C638
0CED4:  MOVLW  0D
0CED6:  BTFSS  F9E.4
0CED8:  BRA    CED6
0CEDA:  MOVWF  FAD
0CEDC:  MOVLW  0A
0CEDE:  BTFSS  F9E.4
0CEE0:  BRA    CEDE
0CEE2:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CEE4:  MOVLW  46
0CEE6:  MOVWF  FF6
0CEE8:  MOVLW  24
0CEEA:  MOVWF  FF7
0CEEC:  MOVLW  00
0CEEE:  MOVWF  FF8
0CEF0:  CLRF   1B
0CEF2:  BTFSC  FF2.7
0CEF4:  BSF    1B.7
0CEF6:  BCF    FF2.7
0CEF8:  MOVLW  04
0CEFA:  MOVLB  A
0CEFC:  MOVWF  x40
0CEFE:  MOVLB  0
0CF00:  CALL   1024
0CF04:  BTFSC  1B.7
0CF06:  BSF    FF2.7
0CF08:  MOVLW  89
0CF0A:  MOVWF  FE9
0CF0C:  MOVFF  408,888
0CF10:  MOVFF  407,887
0CF14:  MOVFF  406,886
0CF18:  MOVFF  405,885
0CF1C:  MOVLW  05
0CF1E:  MOVLB  8
0CF20:  MOVWF  x89
0CF22:  MOVLB  0
0CF24:  CALL   C638
0CF28:  MOVLW  2C
0CF2A:  BTFSS  F9E.4
0CF2C:  BRA    CF2A
0CF2E:  MOVWF  FAD
0CF30:  MOVLW  89
0CF32:  MOVWF  FE9
0CF34:  MOVFF  40C,888
0CF38:  MOVFF  40B,887
0CF3C:  MOVFF  40A,886
0CF40:  MOVFF  409,885
0CF44:  MOVLW  05
0CF46:  MOVLB  8
0CF48:  MOVWF  x89
0CF4A:  MOVLB  0
0CF4C:  CALL   C638
0CF50:  MOVLW  0D
0CF52:  BTFSS  F9E.4
0CF54:  BRA    CF52
0CF56:  MOVWF  FAD
0CF58:  MOVLW  0A
0CF5A:  BTFSS  F9E.4
0CF5C:  BRA    CF5A
0CF5E:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CF60:  MOVLW  58
0CF62:  MOVWF  FF6
0CF64:  MOVLW  24
0CF66:  MOVWF  FF7
0CF68:  MOVLW  00
0CF6A:  MOVWF  FF8
0CF6C:  CLRF   1B
0CF6E:  BTFSC  FF2.7
0CF70:  BSF    1B.7
0CF72:  BCF    FF2.7
0CF74:  MOVLW  05
0CF76:  MOVLB  A
0CF78:  MOVWF  x40
0CF7A:  MOVLB  0
0CF7C:  CALL   1024
0CF80:  BTFSC  1B.7
0CF82:  BSF    FF2.7
0CF84:  MOVLW  89
0CF86:  MOVWF  FE9
0CF88:  MOVFF  410,888
0CF8C:  MOVFF  40F,887
0CF90:  MOVFF  40E,886
0CF94:  MOVFF  40D,885
0CF98:  MOVLW  05
0CF9A:  MOVLB  8
0CF9C:  MOVWF  x89
0CF9E:  MOVLB  0
0CFA0:  CALL   C638
0CFA4:  MOVLW  2C
0CFA6:  BTFSS  F9E.4
0CFA8:  BRA    CFA6
0CFAA:  MOVWF  FAD
0CFAC:  MOVLW  89
0CFAE:  MOVWF  FE9
0CFB0:  MOVFF  414,888
0CFB4:  MOVFF  413,887
0CFB8:  MOVFF  412,886
0CFBC:  MOVFF  411,885
0CFC0:  MOVLW  05
0CFC2:  MOVLB  8
0CFC4:  MOVWF  x89
0CFC6:  MOVLB  0
0CFC8:  CALL   C638
0CFCC:  MOVLW  0D
0CFCE:  BTFSS  F9E.4
0CFD0:  BRA    CFCE
0CFD2:  MOVWF  FAD
0CFD4:  MOVLW  0A
0CFD6:  BTFSS  F9E.4
0CFD8:  BRA    CFD6
0CFDA:  MOVWF  FAD
....................                   break; 
0CFDC:  BRA    D2C2
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0CFDE:  MOVLW  6C
0CFE0:  MOVWF  FF6
0CFE2:  MOVLW  24
0CFE4:  MOVWF  FF7
0CFE6:  MOVLW  00
0CFE8:  MOVWF  FF8
0CFEA:  CLRF   1B
0CFEC:  BTFSC  FF2.7
0CFEE:  BSF    1B.7
0CFF0:  BCF    FF2.7
0CFF2:  CALL   0E4E
0CFF6:  BTFSC  1B.7
0CFF8:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0CFFA:  RCALL  CCCA
0CFFC:  MOVFF  03,3F8
0D000:  MOVFF  02,3F7
0D004:  MOVFF  01,3F6
0D008:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");   
0D00C:  MOVLW  0D
0D00E:  BTFSS  F9E.4
0D010:  BRA    D00E
0D012:  MOVWF  FAD
0D014:  MOVLW  0A
0D016:  BTFSS  F9E.4
0D018:  BRA    D016
0D01A:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0D01C:  MOVLB  8
0D01E:  CLRF   x86
0D020:  MOVLW  44
0D022:  MOVWF  x85
0D024:  MOVFF  3F8,88A
0D028:  MOVFF  3F7,889
0D02C:  MOVFF  3F6,888
0D030:  MOVFF  3F5,887
0D034:  MOVLB  0
0D036:  RCALL  CD10
....................          break; 
0D038:  BRA    D2C2
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0D03A:  MOVLW  74
0D03C:  MOVWF  FF6
0D03E:  MOVLW  24
0D040:  MOVWF  FF7
0D042:  MOVLW  00
0D044:  MOVWF  FF8
0D046:  CLRF   1B
0D048:  BTFSC  FF2.7
0D04A:  BSF    1B.7
0D04C:  BCF    FF2.7
0D04E:  CALL   0E4E
0D052:  BTFSC  1B.7
0D054:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0D056:  RCALL  CCCA
0D058:  MOVFF  03,3FC
0D05C:  MOVFF  02,3FB
0D060:  MOVFF  01,3FA
0D064:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n");  
0D068:  MOVLW  0D
0D06A:  BTFSS  F9E.4
0D06C:  BRA    D06A
0D06E:  MOVWF  FAD
0D070:  MOVLW  0A
0D072:  BTFSS  F9E.4
0D074:  BRA    D072
0D076:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0D078:  MOVLB  8
0D07A:  CLRF   x86
0D07C:  MOVLW  48
0D07E:  MOVWF  x85
0D080:  MOVFF  3FC,88A
0D084:  MOVFF  3FB,889
0D088:  MOVFF  3FA,888
0D08C:  MOVFF  3F9,887
0D090:  MOVLB  0
0D092:  RCALL  CD10
....................          break; 
0D094:  BRA    D2C2
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0D096:  MOVLW  7C
0D098:  MOVWF  FF6
0D09A:  MOVLW  24
0D09C:  MOVWF  FF7
0D09E:  MOVLW  00
0D0A0:  MOVWF  FF8
0D0A2:  CLRF   1B
0D0A4:  BTFSC  FF2.7
0D0A6:  BSF    1B.7
0D0A8:  BCF    FF2.7
0D0AA:  CALL   0E4E
0D0AE:  BTFSC  1B.7
0D0B0:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0D0B2:  RCALL  CCCA
0D0B4:  MOVFF  03,400
0D0B8:  MOVFF  02,3FF
0D0BC:  MOVFF  01,3FE
0D0C0:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n"); 
0D0C4:  MOVLW  0D
0D0C6:  BTFSS  F9E.4
0D0C8:  BRA    D0C6
0D0CA:  MOVWF  FAD
0D0CC:  MOVLW  0A
0D0CE:  BTFSS  F9E.4
0D0D0:  BRA    D0CE
0D0D2:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0D0D4:  MOVLB  8
0D0D6:  CLRF   x86
0D0D8:  MOVLW  4C
0D0DA:  MOVWF  x85
0D0DC:  MOVFF  400,88A
0D0E0:  MOVFF  3FF,889
0D0E4:  MOVFF  3FE,888
0D0E8:  MOVFF  3FD,887
0D0EC:  MOVLB  0
0D0EE:  RCALL  CD10
....................          break; 
0D0F0:  BRA    D2C2
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0D0F2:  MOVLW  84
0D0F4:  MOVWF  FF6
0D0F6:  MOVLW  24
0D0F8:  MOVWF  FF7
0D0FA:  MOVLW  00
0D0FC:  MOVWF  FF8
0D0FE:  CLRF   1B
0D100:  BTFSC  FF2.7
0D102:  BSF    1B.7
0D104:  BCF    FF2.7
0D106:  CALL   0E4E
0D10A:  BTFSC  1B.7
0D10C:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0D10E:  RCALL  CCCA
0D110:  MOVFF  03,404
0D114:  MOVFF  02,403
0D118:  MOVFF  01,402
0D11C:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");  
0D120:  MOVLW  0D
0D122:  BTFSS  F9E.4
0D124:  BRA    D122
0D126:  MOVWF  FAD
0D128:  MOVLW  0A
0D12A:  BTFSS  F9E.4
0D12C:  BRA    D12A
0D12E:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0D130:  MOVLB  8
0D132:  CLRF   x86
0D134:  MOVLW  52
0D136:  MOVWF  x85
0D138:  MOVFF  3FC,88A
0D13C:  MOVFF  3FB,889
0D140:  MOVFF  3FA,888
0D144:  MOVFF  3F9,887
0D148:  MOVLB  0
0D14A:  RCALL  CD10
....................          break; 
0D14C:  BRA    D2C2
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0D14E:  MOVLW  8C
0D150:  MOVWF  FF6
0D152:  MOVLW  24
0D154:  MOVWF  FF7
0D156:  MOVLW  00
0D158:  MOVWF  FF8
0D15A:  CLRF   1B
0D15C:  BTFSC  FF2.7
0D15E:  BSF    1B.7
0D160:  BCF    FF2.7
0D162:  CALL   0E4E
0D166:  BTFSC  1B.7
0D168:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0D16A:  RCALL  CCCA
0D16C:  MOVFF  03,408
0D170:  MOVFF  02,407
0D174:  MOVFF  01,406
0D178:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");   
0D17C:  MOVLW  0D
0D17E:  BTFSS  F9E.4
0D180:  BRA    D17E
0D182:  MOVWF  FAD
0D184:  MOVLW  0A
0D186:  BTFSS  F9E.4
0D188:  BRA    D186
0D18A:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0D18C:  MOVLB  8
0D18E:  CLRF   x86
0D190:  MOVLW  56
0D192:  MOVWF  x85
0D194:  MOVFF  408,88A
0D198:  MOVFF  407,889
0D19C:  MOVFF  406,888
0D1A0:  MOVFF  405,887
0D1A4:  MOVLB  0
0D1A6:  RCALL  CD10
....................          break; 
0D1A8:  BRA    D2C2
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0D1AA:  MOVLW  94
0D1AC:  MOVWF  FF6
0D1AE:  MOVLW  24
0D1B0:  MOVWF  FF7
0D1B2:  MOVLW  00
0D1B4:  MOVWF  FF8
0D1B6:  CLRF   1B
0D1B8:  BTFSC  FF2.7
0D1BA:  BSF    1B.7
0D1BC:  BCF    FF2.7
0D1BE:  CALL   0E4E
0D1C2:  BTFSC  1B.7
0D1C4:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0D1C6:  RCALL  CCCA
0D1C8:  MOVFF  03,40C
0D1CC:  MOVFF  02,40B
0D1D0:  MOVFF  01,40A
0D1D4:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");  
0D1D8:  MOVLW  0D
0D1DA:  BTFSS  F9E.4
0D1DC:  BRA    D1DA
0D1DE:  MOVWF  FAD
0D1E0:  MOVLW  0A
0D1E2:  BTFSS  F9E.4
0D1E4:  BRA    D1E2
0D1E6:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0D1E8:  MOVLB  8
0D1EA:  CLRF   x86
0D1EC:  MOVLW  5A
0D1EE:  MOVWF  x85
0D1F0:  MOVFF  40C,88A
0D1F4:  MOVFF  40B,889
0D1F8:  MOVFF  40A,888
0D1FC:  MOVFF  409,887
0D200:  MOVLB  0
0D202:  RCALL  CD10
....................          break; 
0D204:  BRA    D2C2
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0D206:  MOVLW  9C
0D208:  MOVWF  FF6
0D20A:  MOVLW  24
0D20C:  MOVWF  FF7
0D20E:  MOVLW  00
0D210:  MOVWF  FF8
0D212:  CLRF   1B
0D214:  BTFSC  FF2.7
0D216:  BSF    1B.7
0D218:  BCF    FF2.7
0D21A:  CALL   0E4E
0D21E:  BTFSC  1B.7
0D220:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0D222:  RCALL  CCCA
0D224:  MOVFF  03,410
0D228:  MOVFF  02,40F
0D22C:  MOVFF  01,40E
0D230:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");   
0D234:  MOVLW  0D
0D236:  BTFSS  F9E.4
0D238:  BRA    D236
0D23A:  MOVWF  FAD
0D23C:  MOVLW  0A
0D23E:  BTFSS  F9E.4
0D240:  BRA    D23E
0D242:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0D244:  MOVLB  8
0D246:  CLRF   x86
0D248:  MOVLW  5E
0D24A:  MOVWF  x85
0D24C:  MOVFF  410,88A
0D250:  MOVFF  40F,889
0D254:  MOVFF  40E,888
0D258:  MOVFF  40D,887
0D25C:  MOVLB  0
0D25E:  RCALL  CD10
....................          break; 
0D260:  BRA    D2C2
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0D262:  MOVLW  A6
0D264:  MOVWF  FF6
0D266:  MOVLW  24
0D268:  MOVWF  FF7
0D26A:  MOVLW  00
0D26C:  MOVWF  FF8
0D26E:  CLRF   1B
0D270:  BTFSC  FF2.7
0D272:  BSF    1B.7
0D274:  BCF    FF2.7
0D276:  CALL   0E4E
0D27A:  BTFSC  1B.7
0D27C:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0D27E:  RCALL  CCCA
0D280:  MOVFF  03,414
0D284:  MOVFF  02,413
0D288:  MOVFF  01,412
0D28C:  MOVFF  00,411
....................                fprintf(COM_A,"\r\n");  
0D290:  MOVLW  0D
0D292:  BTFSS  F9E.4
0D294:  BRA    D292
0D296:  MOVWF  FAD
0D298:  MOVLW  0A
0D29A:  BTFSS  F9E.4
0D29C:  BRA    D29A
0D29E:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0D2A0:  MOVLB  8
0D2A2:  CLRF   x86
0D2A4:  MOVLW  62
0D2A6:  MOVWF  x85
0D2A8:  MOVFF  414,88A
0D2AC:  MOVFF  413,889
0D2B0:  MOVFF  412,888
0D2B4:  MOVFF  411,887
0D2B8:  MOVLB  0
0D2BA:  RCALL  CD10
....................          break;         
0D2BC:  BRA    D2C2
....................       default: cmd_arg(); 
0D2BE:  CALL   B2C2
....................          break; 
....................    } 
0D2C2:  GOTO   DCB8 (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0D9D2:  MOVF   4B,F
0D9D4:  BNZ   D9E4
0D9D6:  MOVF   4A,F
0D9D8:  BNZ   D9E4
0D9DA:  MOVF   49,F
0D9DC:  BNZ   D9E4
0D9DE:  MOVF   48,W
0D9E0:  SUBLW  01
0D9E2:  BC    DA34
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0D9E4:  MOVF   4B,F
0D9E6:  BNZ   D9FE
0D9E8:  MOVF   4A,F
0D9EA:  BNZ   D9FE
0D9EC:  MOVF   49,F
0D9EE:  BNZ   D9FE
0D9F0:  MOVF   48,W
0D9F2:  SUBLW  30
0D9F4:  BNC   D9FE
0D9F6:  DECFSZ 2F,W
0D9F8:  BRA    D9FE
0D9FA:  MOVF   30,F
0D9FC:  BZ    DA1A
0D9FE:  MOVF   4B,F
0DA00:  BNZ   DA2E
0DA02:  MOVF   4A,F
0DA04:  BNZ   DA2E
0DA06:  MOVF   49,F
0DA08:  BNZ   DA2E
0DA0A:  MOVF   48,W
0DA0C:  SUBLW  32
0DA0E:  BNC   DA2E
0DA10:  MOVF   2F,W
0DA12:  SUBLW  03
0DA14:  BNZ   DA2E
0DA16:  MOVF   30,F
0DA18:  BNZ   DA2E
....................          port=arg; 
0DA1A:  MOVFF  49,886
0DA1E:  MOVFF  48,885
....................          play_wms_hard_macro(port);    
0DA22:  MOVFF  886,88A
0DA26:  MOVFF  885,889
0DA2A:  RCALL  D7C4
....................       } 
0DA2C:  BRA    DA32
....................       else cmd_arg(); 
0DA2E:  CALL   B2C2
....................    } 
0DA32:  BRA    DA38
....................    else cmd_arg(); 
0DA34:  CALL   B2C2
0DA38:  GOTO   DCB8 (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0DC48:  MOVF   48,F
0DC4A:  BNZ   DC58
0DC4C:  MOVF   49,F
0DC4E:  BNZ   DC58
0DC50:  MOVF   4A,F
0DC52:  BNZ   DC58
0DC54:  MOVF   4B,F
0DC56:  BZ    DC76
0DC58:  MOVF   4B,F
0DC5A:  BNZ   DC76
0DC5C:  MOVF   4A,F
0DC5E:  BNZ   DC76
0DC60:  MOVF   49,F
0DC62:  BNZ   DC76
0DC64:  MOVF   48,W
0DC66:  SUBLW  04
0DC68:  BNC   DC76
....................       chip=arg; 
0DC6A:  MOVFF  48,885
....................       sol_chip_cmd(chip); 
0DC6E:  MOVFF  885,8B6
0DC72:  RCALL  DB7A
....................    } 
0DC74:  BRA    DC7A
....................    else cmd_arg();    
0DC76:  CALL   B2C2
0DC7A:  GOTO   DCB8 (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0DC7E:  MOVF   2F,W
0DC80:  MOVWF  00
0DC82:  MOVF   30,W
0DC84:  MOVWF  03
0DC86:  BNZ   DC8C
0DC88:  MOVF   00,F
0DC8A:  BZ    DCAC
0DC8C:  MOVF   03,W
0DC8E:  BNZ   DC96
0DC90:  MOVLW  01
0DC92:  SUBWF  00,W
0DC94:  BZ    DCB2
0DC96:  MOVF   03,W
0DC98:  BNZ   DCA0
0DC9A:  MOVLW  03
0DC9C:  SUBWF  00,W
0DC9E:  BZ    DCB2
0DCA0:  MOVF   03,W
0DCA2:  BNZ   DCAA
0DCA4:  MOVLW  02
0DCA6:  SUBWF  00,W
0DCA8:  BZ    DCB6
0DCAA:  BRA    DCB8
....................       case ECO : commandCe(); 
0DCAC:  GOTO   CD7E
....................          break; 
0DCB0:  BRA    DCB8
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0DCB2:  BRA    D9D2
....................          break; 
0DCB4:  BRA    DCB8
....................       case AWS : commandCa(); 
0DCB6:  BRA    DC48
....................          break;          
....................    } 
0DCB8:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0DCBC:  MOVF   48,W
0DCBE:  MOVWF  00
0DCC0:  MOVF   49,W
0DCC2:  MOVWF  03
0DCC4:  BNZ   DCCA
0DCC6:  MOVF   00,F
0DCC8:  BZ    DCEA
0DCCA:  MOVF   03,W
0DCCC:  BNZ   DCD4
0DCCE:  MOVLW  01
0DCD0:  SUBWF  00,W
0DCD2:  BZ    DCFC
0DCD4:  MOVF   03,W
0DCD6:  BNZ   DCDE
0DCD8:  MOVLW  02
0DCDA:  SUBWF  00,W
0DCDC:  BZ    DD1E
0DCDE:  MOVF   03,W
0DCE0:  BNZ   DCE8
0DCE2:  MOVLW  03
0DCE4:  SUBWF  00,W
0DCE6:  BZ    DD30
0DCE8:  BRA    DD52
....................       case 0 : file_list(file_ptr_raw_all); 
0DCEA:  MOVLW  02
0DCEC:  MOVLB  8
0DCEE:  MOVWF  x8A
0DCF0:  MOVLW  DD
0DCF2:  MOVWF  x89
0DCF4:  MOVLB  0
0DCF6:  CALL   BAE8
....................          break; 
0DCFA:  BRA    DD56
....................       case 1 : file_list(file_ptr_raw_new); 
0DCFC:  MOVLW  02
0DCFE:  MOVLB  8
0DD00:  MOVWF  x8A
0DD02:  MOVLW  EB
0DD04:  MOVWF  x89
0DD06:  MOVLB  0
0DD08:  CALL   BAE8
....................                f_unlink(file_ptr_raw_new); 
0DD0C:  MOVLW  02
0DD0E:  MOVLB  8
0DD10:  MOVWF  x8A
0DD12:  MOVLW  EB
0DD14:  MOVWF  x89
0DD16:  MOVLB  0
0DD18:  CALL   BC62
....................          break; 
0DD1C:  BRA    DD56
....................       case 2 : file_list(file_ptr_rel_all); 
0DD1E:  MOVLW  02
0DD20:  MOVLB  8
0DD22:  MOVWF  x8A
0DD24:  MOVLW  F9
0DD26:  MOVWF  x89
0DD28:  MOVLB  0
0DD2A:  CALL   BAE8
....................          break; 
0DD2E:  BRA    DD56
....................       case 3 : file_list(file_ptr_rel_new); 
0DD30:  MOVLW  03
0DD32:  MOVLB  8
0DD34:  MOVWF  x8A
0DD36:  MOVLW  07
0DD38:  MOVWF  x89
0DD3A:  MOVLB  0
0DD3C:  CALL   BAE8
....................                f_unlink(file_ptr_rel_new); 
0DD40:  MOVLW  03
0DD42:  MOVLB  8
0DD44:  MOVWF  x8A
0DD46:  MOVLW  07
0DD48:  MOVWF  x89
0DD4A:  MOVLB  0
0DD4C:  CALL   BC62
....................          break;  
0DD50:  BRA    DD56
....................       default : cmd_arg(); 
0DD52:  CALL   B2C2
....................          break; 
....................    } 
0DD56:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DD5A:  MOVF   48,W
0DD5C:  MOVWF  00
0DD5E:  MOVF   49,W
0DD60:  MOVWF  03
0DD62:  BNZ   DD68
0DD64:  MOVF   00,F
0DD66:  BZ    DD74
0DD68:  MOVF   03,W
0DD6A:  BNZ   DD72
0DD6C:  MOVLW  02
0DD6E:  SUBWF  00,W
0DD70:  BZ    DDEE
0DD72:  BRA    DE68
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DD74:  MOVLW  B0
0DD76:  MOVWF  FF6
0DD78:  MOVLW  24
0DD7A:  MOVWF  FF7
0DD7C:  MOVLW  00
0DD7E:  MOVWF  FF8
0DD80:  CLRF   1B
0DD82:  BTFSC  FF2.7
0DD84:  BSF    1B.7
0DD86:  BCF    FF2.7
0DD88:  CALL   0E4E
0DD8C:  BTFSC  1B.7
0DD8E:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DD90:  CALL   0E38
0DD94:  MOVFF  01,885
....................       if(result == 'Y'){ 
0DD98:  MOVLB  8
0DD9A:  MOVF   x85,W
0DD9C:  SUBLW  59
0DD9E:  BNZ   DDCE
....................       f_unlink(file_ptr_raw_all); 
0DDA0:  MOVLW  02
0DDA2:  MOVWF  x8A
0DDA4:  MOVLW  DD
0DDA6:  MOVWF  x89
0DDA8:  MOVLB  0
0DDAA:  CALL   BC62
....................       printf("File deleted!\n\r"); 
0DDAE:  MOVLW  EC
0DDB0:  MOVWF  FF6
0DDB2:  MOVLW  24
0DDB4:  MOVWF  FF7
0DDB6:  MOVLW  00
0DDB8:  MOVWF  FF8
0DDBA:  CLRF   1B
0DDBC:  BTFSC  FF2.7
0DDBE:  BSF    1B.7
0DDC0:  BCF    FF2.7
0DDC2:  CALL   0E4E
0DDC6:  BTFSC  1B.7
0DDC8:  BSF    FF2.7
....................       }else{ 
0DDCA:  BRA    DDEC
0DDCC:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DDCE:  MOVLW  FC
0DDD0:  MOVWF  FF6
0DDD2:  MOVLW  24
0DDD4:  MOVWF  FF7
0DDD6:  MOVLW  00
0DDD8:  MOVWF  FF8
0DDDA:  CLRF   1B
0DDDC:  BTFSC  FF2.7
0DDDE:  BSF    1B.7
0DDE0:  BCF    FF2.7
0DDE2:  MOVLB  0
0DDE4:  CALL   0E4E
0DDE8:  BTFSC  1B.7
0DDEA:  BSF    FF2.7
....................       } 
....................          break; 
0DDEC:  BRA    DE6C
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DDEE:  MOVLW  12
0DDF0:  MOVWF  FF6
0DDF2:  MOVLW  25
0DDF4:  MOVWF  FF7
0DDF6:  MOVLW  00
0DDF8:  MOVWF  FF8
0DDFA:  CLRF   1B
0DDFC:  BTFSC  FF2.7
0DDFE:  BSF    1B.7
0DE00:  BCF    FF2.7
0DE02:  CALL   0E4E
0DE06:  BTFSC  1B.7
0DE08:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DE0A:  CALL   0E38
0DE0E:  MOVFF  01,885
....................          if(result == 'Y'){ 
0DE12:  MOVLB  8
0DE14:  MOVF   x85,W
0DE16:  SUBLW  59
0DE18:  BNZ   DE48
....................             f_unlink(file_ptr_rel_all); 
0DE1A:  MOVLW  02
0DE1C:  MOVWF  x8A
0DE1E:  MOVLW  F9
0DE20:  MOVWF  x89
0DE22:  MOVLB  0
0DE24:  CALL   BC62
....................             printf("File deleted!\n\r"); 
0DE28:  MOVLW  56
0DE2A:  MOVWF  FF6
0DE2C:  MOVLW  25
0DE2E:  MOVWF  FF7
0DE30:  MOVLW  00
0DE32:  MOVWF  FF8
0DE34:  CLRF   1B
0DE36:  BTFSC  FF2.7
0DE38:  BSF    1B.7
0DE3A:  BCF    FF2.7
0DE3C:  CALL   0E4E
0DE40:  BTFSC  1B.7
0DE42:  BSF    FF2.7
....................          }else{ 
0DE44:  BRA    DE66
0DE46:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DE48:  MOVLW  66
0DE4A:  MOVWF  FF6
0DE4C:  MOVLW  25
0DE4E:  MOVWF  FF7
0DE50:  MOVLW  00
0DE52:  MOVWF  FF8
0DE54:  CLRF   1B
0DE56:  BTFSC  FF2.7
0DE58:  BSF    1B.7
0DE5A:  BCF    FF2.7
0DE5C:  MOVLB  0
0DE5E:  CALL   0E4E
0DE62:  BTFSC  1B.7
0DE64:  BSF    FF2.7
....................          } 
....................          break; 
0DE66:  BRA    DE6C
....................       default : cmd_arg(); 
0DE68:  CALL   B2C2
....................          break;          
....................    } 
0DE6C:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0E058:  MOVF   48,W
0E05A:  SUBLW  95
0E05C:  BNZ   E070
0E05E:  MOVF   49,W
0E060:  SUBLW  15
0E062:  BNZ   E070
0E064:  MOVF   4A,F
0E066:  BNZ   E070
0E068:  MOVF   4B,F
0E06A:  BNZ   E070
....................       reset_nv_vars(); 
0E06C:  BRA    DE70
....................    } 
0E06E:  BRA    E074
....................    else cmd_arg(); 
0E070:  CALL   B2C2
0E074:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0E0C2:  MOVF   2F,F
0E0C4:  BNZ   E0CA
0E0C6:  MOVF   30,F
0E0C8:  BZ    E0DC
0E0CA:  DECFSZ 2F,W
0E0CC:  BRA    E0D2
0E0CE:  MOVF   30,F
0E0D0:  BZ    E0DC
0E0D2:  MOVF   2F,W
0E0D4:  SUBLW  03
0E0D6:  BNZ   E14E
0E0D8:  MOVF   30,F
0E0DA:  BNZ   E14E
....................    { 
....................       busy_set(); 
0E0DC:  CALL   29C0
....................  
....................       switch(arg) 
0E0E0:  MOVFF  48,00
0E0E4:  MOVF   49,W
0E0E6:  MOVWF  03
0E0E8:  BNZ   E0F0
0E0EA:  MOVLW  01
0E0EC:  SUBWF  00,W
0E0EE:  BZ    E106
0E0F0:  MOVF   03,W
0E0F2:  BNZ   E0FA
0E0F4:  MOVLW  02
0E0F6:  SUBWF  00,W
0E0F8:  BZ    E116
0E0FA:  MOVF   03,W
0E0FC:  BNZ   E104
0E0FE:  MOVLW  03
0E100:  SUBWF  00,W
0E102:  BZ    E140
0E104:  BRA    E146
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0E106:  MOVLB  7
0E108:  CLRF   x40
....................             align(0); 
0E10A:  MOVLB  8
0E10C:  CLRF   xC2
0E10E:  MOVLB  0
0E110:  CALL   A8B4
....................             break; 
0E114:  BRA    E14A
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0E116:  MOVF   48,W
0E118:  SUBLW  02
0E11A:  BNZ   E13E
0E11C:  MOVF   49,F
0E11E:  BNZ   E13E
0E120:  MOVF   4A,F
0E122:  BNZ   E13E
0E124:  MOVF   4B,F
0E126:  BNZ   E13E
0E128:  MOVF   1F,W
0E12A:  SUBLW  04
0E12C:  BNZ   E13E
0E12E:  MOVF   20,F
0E130:  BNZ   E13E
....................             { 
....................                motor=0; 
0E132:  MOVLB  7
0E134:  CLRF   x40
....................                cal_disk(0); 
0E136:  MOVLB  8
0E138:  CLRF   x85
0E13A:  MOVLB  0
0E13C:  BRA    E078
....................             } 
....................             break; 
0E13E:  BRA    E14A
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0E140:  CALL   AA58
....................             break; 
0E144:  BRA    E14A
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0E146:  CALL   B2C2
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0E14A:  CALL   AE74
....................    } 
0E14E:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E628:  DECFSZ 48,W
0E62A:  BRA    EA48
0E62C:  MOVF   49,F
0E62E:  BTFSS  FD8.2
0E630:  BRA    EA48
0E632:  MOVF   4A,F
0E634:  BTFSS  FD8.2
0E636:  BRA    EA48
0E638:  MOVF   4B,F
0E63A:  BTFSS  FD8.2
0E63C:  BRA    EA48
....................       v_supply = read_supply(); 
0E63E:  CALL   50FC
0E642:  MOVFF  02,886
0E646:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0E64A:  CALL   34B2
....................       RTC_read(); 
0E64E:  CALL   3344
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E652:  MOVLW  7C
0E654:  MOVWF  FF6
0E656:  MOVLW  25
0E658:  MOVWF  FF7
0E65A:  MOVLW  00
0E65C:  MOVWF  FF8
0E65E:  CLRF   1B
0E660:  BTFSC  FF2.7
0E662:  BSF    1B.7
0E664:  BCF    FF2.7
0E666:  MOVLW  04
0E668:  MOVLB  A
0E66A:  MOVWF  x40
0E66C:  MOVLB  0
0E66E:  CALL   1024
0E672:  BTFSC  1B.7
0E674:  BSF    FF2.7
0E676:  MOVLW  10
0E678:  MOVWF  FE9
0E67A:  CLRF   1B
0E67C:  BTFSC  FF2.7
0E67E:  BSF    1B.7
0E680:  BCF    FF2.7
0E682:  MOVFF  26,A41
0E686:  MOVFF  25,A40
0E68A:  CALL   11A6
0E68E:  BTFSC  1B.7
0E690:  BSF    FF2.7
0E692:  MOVLW  20
0E694:  BTFSS  F9E.4
0E696:  BRA    E694
0E698:  MOVWF  FAD
0E69A:  MOVLW  49
0E69C:  BTFSS  F9E.4
0E69E:  BRA    E69C
0E6A0:  MOVWF  FAD
0E6A2:  MOVLW  10
0E6A4:  MOVWF  FE9
0E6A6:  CLRF   1B
0E6A8:  BTFSC  FF2.7
0E6AA:  BSF    1B.7
0E6AC:  BCF    FF2.7
0E6AE:  MOVFF  24,A41
0E6B2:  MOVFF  23,A40
0E6B6:  CALL   11A6
0E6BA:  BTFSC  1B.7
0E6BC:  BSF    FF2.7
0E6BE:  MOVLW  20
0E6C0:  BTFSS  F9E.4
0E6C2:  BRA    E6C0
0E6C4:  MOVWF  FAD
0E6C6:  MOVLW  4E
0E6C8:  BTFSS  F9E.4
0E6CA:  BRA    E6C8
0E6CC:  MOVWF  FAD
0E6CE:  MOVLW  10
0E6D0:  MOVWF  FE9
0E6D2:  CLRF   1B
0E6D4:  BTFSC  FF2.7
0E6D6:  BSF    1B.7
0E6D8:  BCF    FF2.7
0E6DA:  MOVFF  22,A41
0E6DE:  MOVFF  21,A40
0E6E2:  CALL   11A6
0E6E6:  BTFSC  1B.7
0E6E8:  BSF    FF2.7
0E6EA:  MOVLW  2F
0E6EC:  BTFSS  F9E.4
0E6EE:  BRA    E6EC
0E6F0:  MOVWF  FAD
0E6F2:  MOVLW  10
0E6F4:  MOVWF  FE9
0E6F6:  CLRF   1B
0E6F8:  BTFSC  FF2.7
0E6FA:  BSF    1B.7
0E6FC:  BCF    FF2.7
0E6FE:  MOVFF  28,A41
0E702:  MOVFF  27,A40
0E706:  CALL   11A6
0E70A:  BTFSC  1B.7
0E70C:  BSF    FF2.7
0E70E:  MOVLW  20
0E710:  BTFSS  F9E.4
0E712:  BRA    E710
0E714:  MOVWF  FAD
0E716:  MOVLW  58
0E718:  BTFSS  F9E.4
0E71A:  BRA    E718
0E71C:  MOVWF  FAD
0E71E:  MOVLW  10
0E720:  MOVWF  FE9
0E722:  CLRF   1B
0E724:  BTFSC  FF2.7
0E726:  BSF    1B.7
0E728:  BCF    FF2.7
0E72A:  MOVFF  20,A41
0E72E:  MOVFF  1F,A40
0E732:  CALL   11A6
0E736:  BTFSC  1B.7
0E738:  BSF    FF2.7
0E73A:  MOVLW  20
0E73C:  BTFSS  F9E.4
0E73E:  BRA    E73C
0E740:  MOVWF  FAD
0E742:  MOVLW  55
0E744:  BTFSS  F9E.4
0E746:  BRA    E744
0E748:  MOVWF  FAD
0E74A:  CLRF   1B
0E74C:  BTFSC  FF2.7
0E74E:  BSF    1B.7
0E750:  BCF    FF2.7
0E752:  MOVFF  740,A40
0E756:  MOVLW  1B
0E758:  MOVLB  A
0E75A:  MOVWF  x41
0E75C:  MOVLB  0
0E75E:  CALL   0FA6
0E762:  BTFSC  1B.7
0E764:  BSF    FF2.7
0E766:  MOVLW  20
0E768:  BTFSS  F9E.4
0E76A:  BRA    E768
0E76C:  MOVWF  FAD
0E76E:  MOVLW  04
0E770:  MOVWF  FE9
0E772:  MOVLB  8
0E774:  CLRF   x8A
0E776:  CLRF   x89
0E778:  MOVFF  886,888
0E77C:  MOVFF  885,887
0E780:  MOVLW  02
0E782:  MOVWF  x8B
0E784:  MOVLB  0
0E786:  RCALL  E152
0E788:  MOVLW  A0
0E78A:  MOVWF  FF6
0E78C:  MOVLW  25
0E78E:  MOVWF  FF7
0E790:  MOVLW  00
0E792:  MOVWF  FF8
0E794:  CLRF   1B
0E796:  BTFSC  FF2.7
0E798:  BSF    1B.7
0E79A:  BCF    FF2.7
0E79C:  MOVLW  03
0E79E:  MOVLB  A
0E7A0:  MOVWF  x40
0E7A2:  MOVLB  0
0E7A4:  CALL   1024
0E7A8:  BTFSC  1B.7
0E7AA:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E7AC:  MOVLW  A4
0E7AE:  MOVWF  FF6
0E7B0:  MOVLW  25
0E7B2:  MOVWF  FF7
0E7B4:  MOVLW  00
0E7B6:  MOVWF  FF8
0E7B8:  CLRF   1B
0E7BA:  BTFSC  FF2.7
0E7BC:  BSF    1B.7
0E7BE:  BCF    FF2.7
0E7C0:  MOVLW  09
0E7C2:  MOVLB  A
0E7C4:  MOVWF  x40
0E7C6:  MOVLB  0
0E7C8:  CALL   1024
0E7CC:  BTFSC  1B.7
0E7CE:  BSF    FF2.7
0E7D0:  MOVLW  10
0E7D2:  MOVWF  FE9
0E7D4:  CLRF   1B
0E7D6:  BTFSC  FF2.7
0E7D8:  BSF    1B.7
0E7DA:  BCF    FF2.7
0E7DC:  MOVFF  7C4,A41
0E7E0:  MOVFF  7C3,A40
0E7E4:  CALL   11A6
0E7E8:  BTFSC  1B.7
0E7EA:  BSF    FF2.7
0E7EC:  MOVLW  B0
0E7EE:  MOVWF  FF6
0E7F0:  MOVLW  25
0E7F2:  MOVWF  FF7
0E7F4:  MOVLW  00
0E7F6:  MOVWF  FF8
0E7F8:  CLRF   1B
0E7FA:  BTFSC  FF2.7
0E7FC:  BSF    1B.7
0E7FE:  BCF    FF2.7
0E800:  MOVLW  05
0E802:  MOVLB  A
0E804:  MOVWF  x40
0E806:  MOVLB  0
0E808:  CALL   1024
0E80C:  BTFSC  1B.7
0E80E:  BSF    FF2.7
0E810:  MOVLW  10
0E812:  MOVWF  FE9
0E814:  MOVFF  7B6,8F1
0E818:  MOVFF  7B5,8F0
0E81C:  CALL   8FE4
0E820:  MOVLW  0D
0E822:  BTFSS  F9E.4
0E824:  BRA    E822
0E826:  MOVWF  FAD
0E828:  MOVLW  0A
0E82A:  BTFSS  F9E.4
0E82C:  BRA    E82A
0E82E:  MOVWF  FAD
....................       RTC_display(); 
0E830:  RCALL  E24E
....................       if (RTCfmt == 0) 
0E832:  MOVF   4F,F
0E834:  BTFSS  FD8.2
0E836:  BRA    E93C
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E838:  MOVLW  BC
0E83A:  MOVWF  FF6
0E83C:  MOVLW  25
0E83E:  MOVWF  FF7
0E840:  MOVLW  00
0E842:  MOVWF  FF8
0E844:  CLRF   1B
0E846:  BTFSC  FF2.7
0E848:  BSF    1B.7
0E84A:  BCF    FF2.7
0E84C:  MOVLW  05
0E84E:  MOVLB  A
0E850:  MOVWF  x40
0E852:  MOVLB  0
0E854:  CALL   1024
0E858:  BTFSC  1B.7
0E85A:  BSF    FF2.7
0E85C:  CLRF   1B
0E85E:  BTFSC  FF2.7
0E860:  BSF    1B.7
0E862:  BCF    FF2.7
0E864:  MOVFF  73A,A40
0E868:  MOVLW  01
0E86A:  MOVLB  A
0E86C:  MOVWF  x41
0E86E:  MOVLB  0
0E870:  CALL   0FA6
0E874:  BTFSC  1B.7
0E876:  BSF    FF2.7
0E878:  MOVLW  2F
0E87A:  BTFSS  F9E.4
0E87C:  BRA    E87A
0E87E:  MOVWF  FAD
0E880:  CLRF   1B
0E882:  BTFSC  FF2.7
0E884:  BSF    1B.7
0E886:  BCF    FF2.7
0E888:  MOVFF  73B,A40
0E88C:  MOVLW  01
0E88E:  MOVLB  A
0E890:  MOVWF  x41
0E892:  MOVLB  0
0E894:  CALL   0FA6
0E898:  BTFSC  1B.7
0E89A:  BSF    FF2.7
0E89C:  MOVLW  2F
0E89E:  BTFSS  F9E.4
0E8A0:  BRA    E89E
0E8A2:  MOVWF  FAD
0E8A4:  CLRF   1B
0E8A6:  BTFSC  FF2.7
0E8A8:  BSF    1B.7
0E8AA:  BCF    FF2.7
0E8AC:  MOVFF  73C,A40
0E8B0:  MOVLW  01
0E8B2:  MOVLB  A
0E8B4:  MOVWF  x41
0E8B6:  MOVLB  0
0E8B8:  CALL   0FA6
0E8BC:  BTFSC  1B.7
0E8BE:  BSF    FF2.7
0E8C0:  MOVLW  20
0E8C2:  BTFSS  F9E.4
0E8C4:  BRA    E8C2
0E8C6:  MOVWF  FAD
0E8C8:  CLRF   1B
0E8CA:  BTFSC  FF2.7
0E8CC:  BSF    1B.7
0E8CE:  BCF    FF2.7
0E8D0:  MOVFF  73D,A40
0E8D4:  MOVLW  01
0E8D6:  MOVLB  A
0E8D8:  MOVWF  x41
0E8DA:  MOVLB  0
0E8DC:  CALL   0FA6
0E8E0:  BTFSC  1B.7
0E8E2:  BSF    FF2.7
0E8E4:  MOVLW  3A
0E8E6:  BTFSS  F9E.4
0E8E8:  BRA    E8E6
0E8EA:  MOVWF  FAD
0E8EC:  CLRF   1B
0E8EE:  BTFSC  FF2.7
0E8F0:  BSF    1B.7
0E8F2:  BCF    FF2.7
0E8F4:  MOVFF  73E,A40
0E8F8:  MOVLW  01
0E8FA:  MOVLB  A
0E8FC:  MOVWF  x41
0E8FE:  MOVLB  0
0E900:  CALL   0FA6
0E904:  BTFSC  1B.7
0E906:  BSF    FF2.7
0E908:  MOVLW  3A
0E90A:  BTFSS  F9E.4
0E90C:  BRA    E90A
0E90E:  MOVWF  FAD
0E910:  CLRF   1B
0E912:  BTFSC  FF2.7
0E914:  BSF    1B.7
0E916:  BCF    FF2.7
0E918:  MOVFF  73F,A40
0E91C:  MOVLW  01
0E91E:  MOVLB  A
0E920:  MOVWF  x41
0E922:  MOVLB  0
0E924:  CALL   0FA6
0E928:  BTFSC  1B.7
0E92A:  BSF    FF2.7
0E92C:  MOVLW  0D
0E92E:  BTFSS  F9E.4
0E930:  BRA    E92E
0E932:  MOVWF  FAD
0E934:  MOVLW  0A
0E936:  BTFSS  F9E.4
0E938:  BRA    E936
0E93A:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E93C:  DECFSZ 4F,W
0E93E:  BRA    EA44
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E940:  MOVLW  E2
0E942:  MOVWF  FF6
0E944:  MOVLW  25
0E946:  MOVWF  FF7
0E948:  MOVLW  00
0E94A:  MOVWF  FF8
0E94C:  CLRF   1B
0E94E:  BTFSC  FF2.7
0E950:  BSF    1B.7
0E952:  BCF    FF2.7
0E954:  MOVLW  05
0E956:  MOVLB  A
0E958:  MOVWF  x40
0E95A:  MOVLB  0
0E95C:  CALL   1024
0E960:  BTFSC  1B.7
0E962:  BSF    FF2.7
0E964:  CLRF   1B
0E966:  BTFSC  FF2.7
0E968:  BSF    1B.7
0E96A:  BCF    FF2.7
0E96C:  MOVFF  73B,A40
0E970:  MOVLW  01
0E972:  MOVLB  A
0E974:  MOVWF  x41
0E976:  MOVLB  0
0E978:  CALL   0FA6
0E97C:  BTFSC  1B.7
0E97E:  BSF    FF2.7
0E980:  MOVLW  2F
0E982:  BTFSS  F9E.4
0E984:  BRA    E982
0E986:  MOVWF  FAD
0E988:  CLRF   1B
0E98A:  BTFSC  FF2.7
0E98C:  BSF    1B.7
0E98E:  BCF    FF2.7
0E990:  MOVFF  73A,A40
0E994:  MOVLW  01
0E996:  MOVLB  A
0E998:  MOVWF  x41
0E99A:  MOVLB  0
0E99C:  CALL   0FA6
0E9A0:  BTFSC  1B.7
0E9A2:  BSF    FF2.7
0E9A4:  MOVLW  2F
0E9A6:  BTFSS  F9E.4
0E9A8:  BRA    E9A6
0E9AA:  MOVWF  FAD
0E9AC:  CLRF   1B
0E9AE:  BTFSC  FF2.7
0E9B0:  BSF    1B.7
0E9B2:  BCF    FF2.7
0E9B4:  MOVFF  73C,A40
0E9B8:  MOVLW  01
0E9BA:  MOVLB  A
0E9BC:  MOVWF  x41
0E9BE:  MOVLB  0
0E9C0:  CALL   0FA6
0E9C4:  BTFSC  1B.7
0E9C6:  BSF    FF2.7
0E9C8:  MOVLW  20
0E9CA:  BTFSS  F9E.4
0E9CC:  BRA    E9CA
0E9CE:  MOVWF  FAD
0E9D0:  CLRF   1B
0E9D2:  BTFSC  FF2.7
0E9D4:  BSF    1B.7
0E9D6:  BCF    FF2.7
0E9D8:  MOVFF  73D,A40
0E9DC:  MOVLW  01
0E9DE:  MOVLB  A
0E9E0:  MOVWF  x41
0E9E2:  MOVLB  0
0E9E4:  CALL   0FA6
0E9E8:  BTFSC  1B.7
0E9EA:  BSF    FF2.7
0E9EC:  MOVLW  3A
0E9EE:  BTFSS  F9E.4
0E9F0:  BRA    E9EE
0E9F2:  MOVWF  FAD
0E9F4:  CLRF   1B
0E9F6:  BTFSC  FF2.7
0E9F8:  BSF    1B.7
0E9FA:  BCF    FF2.7
0E9FC:  MOVFF  73E,A40
0EA00:  MOVLW  01
0EA02:  MOVLB  A
0EA04:  MOVWF  x41
0EA06:  MOVLB  0
0EA08:  CALL   0FA6
0EA0C:  BTFSC  1B.7
0EA0E:  BSF    FF2.7
0EA10:  MOVLW  3A
0EA12:  BTFSS  F9E.4
0EA14:  BRA    EA12
0EA16:  MOVWF  FAD
0EA18:  CLRF   1B
0EA1A:  BTFSC  FF2.7
0EA1C:  BSF    1B.7
0EA1E:  BCF    FF2.7
0EA20:  MOVFF  73F,A40
0EA24:  MOVLW  01
0EA26:  MOVLB  A
0EA28:  MOVWF  x41
0EA2A:  MOVLB  0
0EA2C:  CALL   0FA6
0EA30:  BTFSC  1B.7
0EA32:  BSF    FF2.7
0EA34:  MOVLW  0D
0EA36:  BTFSS  F9E.4
0EA38:  BRA    EA36
0EA3A:  MOVWF  FAD
0EA3C:  MOVLW  0A
0EA3E:  BTFSS  F9E.4
0EA40:  BRA    EA3E
0EA42:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0EA44:  RCALL  E3D8
....................       RTC_display_alarm(); 
0EA46:  RCALL  E4AE
....................    } 
0EA48:  GOTO   F25C (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0EA4C:  DECFSZ 48,W
0EA4E:  BRA    ED26
0EA50:  MOVF   49,F
0EA52:  BTFSS  FD8.2
0EA54:  BRA    ED26
0EA56:  MOVF   4A,F
0EA58:  BTFSS  FD8.2
0EA5A:  BRA    ED26
0EA5C:  MOVF   4B,F
0EA5E:  BTFSS  FD8.2
0EA60:  BRA    ED26
....................       v_supply = read_supply(); 
0EA62:  CALL   50FC
0EA66:  MOVFF  02,886
0EA6A:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0EA6E:  CALL   34B2
....................       RTC_read(); 
0EA72:  CALL   3344
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0EA76:  MOVLW  41
0EA78:  BTFSS  F9E.4
0EA7A:  BRA    EA78
0EA7C:  MOVWF  FAD
0EA7E:  MOVLW  10
0EA80:  MOVWF  FE9
0EA82:  CLRF   1B
0EA84:  BTFSC  FF2.7
0EA86:  BSF    1B.7
0EA88:  BCF    FF2.7
0EA8A:  MOVFF  2A,A41
0EA8E:  MOVFF  29,A40
0EA92:  CALL   11A6
0EA96:  BTFSC  1B.7
0EA98:  BSF    FF2.7
0EA9A:  MOVLW  20
0EA9C:  BTFSS  F9E.4
0EA9E:  BRA    EA9C
0EAA0:  MOVWF  FAD
0EAA2:  MOVLW  49
0EAA4:  BTFSS  F9E.4
0EAA6:  BRA    EAA4
0EAA8:  MOVWF  FAD
0EAAA:  MOVLW  10
0EAAC:  MOVWF  FE9
0EAAE:  CLRF   1B
0EAB0:  BTFSC  FF2.7
0EAB2:  BSF    1B.7
0EAB4:  BCF    FF2.7
0EAB6:  MOVFF  24,A41
0EABA:  MOVFF  23,A40
0EABE:  CALL   11A6
0EAC2:  BTFSC  1B.7
0EAC4:  BSF    FF2.7
0EAC6:  MOVLW  20
0EAC8:  BTFSS  F9E.4
0EACA:  BRA    EAC8
0EACC:  MOVWF  FAD
0EACE:  MOVLW  4C
0EAD0:  BTFSS  F9E.4
0EAD2:  BRA    EAD0
0EAD4:  MOVWF  FAD
0EAD6:  MOVLW  10
0EAD8:  MOVWF  FE9
0EADA:  CLRF   1B
0EADC:  BTFSC  FF2.7
0EADE:  BSF    1B.7
0EAE0:  BCF    FF2.7
0EAE2:  MOVFF  2C,A41
0EAE6:  MOVFF  2B,A40
0EAEA:  CALL   11A6
0EAEE:  BTFSC  1B.7
0EAF0:  BSF    FF2.7
0EAF2:  MOVLW  20
0EAF4:  BTFSS  F9E.4
0EAF6:  BRA    EAF4
0EAF8:  MOVWF  FAD
0EAFA:  MOVLW  51
0EAFC:  BTFSS  F9E.4
0EAFE:  BRA    EAFC
0EB00:  MOVWF  FAD
0EB02:  MOVLW  10
0EB04:  MOVWF  FE9
0EB06:  CLRF   1B
0EB08:  BTFSC  FF2.7
0EB0A:  BSF    1B.7
0EB0C:  BCF    FF2.7
0EB0E:  MOVFF  2E,A41
0EB12:  MOVFF  2D,A40
0EB16:  CALL   11A6
0EB1A:  BTFSC  1B.7
0EB1C:  BSF    FF2.7
0EB1E:  MOVLW  20
0EB20:  BTFSS  F9E.4
0EB22:  BRA    EB20
0EB24:  MOVWF  FAD
0EB26:  MOVLW  53
0EB28:  BTFSS  F9E.4
0EB2A:  BRA    EB28
0EB2C:  MOVWF  FAD
0EB2E:  MOVLW  10
0EB30:  MOVWF  FE9
0EB32:  CLRF   1B
0EB34:  BTFSC  FF2.7
0EB36:  BSF    1B.7
0EB38:  BCF    FF2.7
0EB3A:  MOVFF  22,A41
0EB3E:  MOVFF  21,A40
0EB42:  CALL   11A6
0EB46:  BTFSC  1B.7
0EB48:  BSF    FF2.7
0EB4A:  MOVLW  20
0EB4C:  BTFSS  F9E.4
0EB4E:  BRA    EB4C
0EB50:  MOVWF  FAD
0EB52:  MOVLW  04
0EB54:  MOVWF  FE9
0EB56:  MOVLB  8
0EB58:  CLRF   x8A
0EB5A:  CLRF   x89
0EB5C:  MOVFF  886,888
0EB60:  MOVFF  885,887
0EB64:  MOVLW  02
0EB66:  MOVWF  x8B
0EB68:  MOVLB  0
0EB6A:  CALL   E152
0EB6E:  MOVLW  26
0EB70:  MOVWF  FF6
0EB72:  MOVLW  26
0EB74:  MOVWF  FF7
0EB76:  MOVLW  00
0EB78:  MOVWF  FF8
0EB7A:  CLRF   1B
0EB7C:  BTFSC  FF2.7
0EB7E:  BSF    1B.7
0EB80:  BCF    FF2.7
0EB82:  MOVLW  03
0EB84:  MOVLB  A
0EB86:  MOVWF  x40
0EB88:  MOVLB  0
0EB8A:  CALL   1024
0EB8E:  BTFSC  1B.7
0EB90:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0EB92:  MOVLW  2A
0EB94:  MOVWF  FF6
0EB96:  MOVLW  26
0EB98:  MOVWF  FF7
0EB9A:  MOVLW  00
0EB9C:  MOVWF  FF8
0EB9E:  CLRF   1B
0EBA0:  BTFSC  FF2.7
0EBA2:  BSF    1B.7
0EBA4:  BCF    FF2.7
0EBA6:  MOVLW  09
0EBA8:  MOVLB  A
0EBAA:  MOVWF  x40
0EBAC:  MOVLB  0
0EBAE:  CALL   1024
0EBB2:  BTFSC  1B.7
0EBB4:  BSF    FF2.7
0EBB6:  MOVLW  10
0EBB8:  MOVWF  FE9
0EBBA:  CLRF   1B
0EBBC:  BTFSC  FF2.7
0EBBE:  BSF    1B.7
0EBC0:  BCF    FF2.7
0EBC2:  MOVFF  7C4,A41
0EBC6:  MOVFF  7C3,A40
0EBCA:  CALL   11A6
0EBCE:  BTFSC  1B.7
0EBD0:  BSF    FF2.7
0EBD2:  MOVLW  36
0EBD4:  MOVWF  FF6
0EBD6:  MOVLW  26
0EBD8:  MOVWF  FF7
0EBDA:  MOVLW  00
0EBDC:  MOVWF  FF8
0EBDE:  CLRF   1B
0EBE0:  BTFSC  FF2.7
0EBE2:  BSF    1B.7
0EBE4:  BCF    FF2.7
0EBE6:  MOVLW  05
0EBE8:  MOVLB  A
0EBEA:  MOVWF  x40
0EBEC:  MOVLB  0
0EBEE:  CALL   1024
0EBF2:  BTFSC  1B.7
0EBF4:  BSF    FF2.7
0EBF6:  MOVLW  10
0EBF8:  MOVWF  FE9
0EBFA:  MOVFF  7B6,8F1
0EBFE:  MOVFF  7B5,8F0
0EC02:  CALL   8FE4
0EC06:  MOVLW  0D
0EC08:  BTFSS  F9E.4
0EC0A:  BRA    EC08
0EC0C:  MOVWF  FAD
0EC0E:  MOVLW  0A
0EC10:  BTFSS  F9E.4
0EC12:  BRA    EC10
0EC14:  MOVWF  FAD
....................       RTC_display(); 
0EC16:  CALL   E24E
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EC1A:  MOVLW  42
0EC1C:  MOVWF  FF6
0EC1E:  MOVLW  26
0EC20:  MOVWF  FF7
0EC22:  MOVLW  00
0EC24:  MOVWF  FF8
0EC26:  CLRF   1B
0EC28:  BTFSC  FF2.7
0EC2A:  BSF    1B.7
0EC2C:  BCF    FF2.7
0EC2E:  MOVLW  05
0EC30:  MOVLB  A
0EC32:  MOVWF  x40
0EC34:  MOVLB  0
0EC36:  CALL   1024
0EC3A:  BTFSC  1B.7
0EC3C:  BSF    FF2.7
0EC3E:  CLRF   1B
0EC40:  BTFSC  FF2.7
0EC42:  BSF    1B.7
0EC44:  BCF    FF2.7
0EC46:  MOVFF  73A,A40
0EC4A:  MOVLW  01
0EC4C:  MOVLB  A
0EC4E:  MOVWF  x41
0EC50:  MOVLB  0
0EC52:  CALL   0FA6
0EC56:  BTFSC  1B.7
0EC58:  BSF    FF2.7
0EC5A:  MOVLW  2F
0EC5C:  BTFSS  F9E.4
0EC5E:  BRA    EC5C
0EC60:  MOVWF  FAD
0EC62:  CLRF   1B
0EC64:  BTFSC  FF2.7
0EC66:  BSF    1B.7
0EC68:  BCF    FF2.7
0EC6A:  MOVFF  73B,A40
0EC6E:  MOVLW  01
0EC70:  MOVLB  A
0EC72:  MOVWF  x41
0EC74:  MOVLB  0
0EC76:  CALL   0FA6
0EC7A:  BTFSC  1B.7
0EC7C:  BSF    FF2.7
0EC7E:  MOVLW  2F
0EC80:  BTFSS  F9E.4
0EC82:  BRA    EC80
0EC84:  MOVWF  FAD
0EC86:  CLRF   1B
0EC88:  BTFSC  FF2.7
0EC8A:  BSF    1B.7
0EC8C:  BCF    FF2.7
0EC8E:  MOVFF  73C,A40
0EC92:  MOVLW  01
0EC94:  MOVLB  A
0EC96:  MOVWF  x41
0EC98:  MOVLB  0
0EC9A:  CALL   0FA6
0EC9E:  BTFSC  1B.7
0ECA0:  BSF    FF2.7
0ECA2:  MOVLW  20
0ECA4:  BTFSS  F9E.4
0ECA6:  BRA    ECA4
0ECA8:  MOVWF  FAD
0ECAA:  CLRF   1B
0ECAC:  BTFSC  FF2.7
0ECAE:  BSF    1B.7
0ECB0:  BCF    FF2.7
0ECB2:  MOVFF  73D,A40
0ECB6:  MOVLW  01
0ECB8:  MOVLB  A
0ECBA:  MOVWF  x41
0ECBC:  MOVLB  0
0ECBE:  CALL   0FA6
0ECC2:  BTFSC  1B.7
0ECC4:  BSF    FF2.7
0ECC6:  MOVLW  3A
0ECC8:  BTFSS  F9E.4
0ECCA:  BRA    ECC8
0ECCC:  MOVWF  FAD
0ECCE:  CLRF   1B
0ECD0:  BTFSC  FF2.7
0ECD2:  BSF    1B.7
0ECD4:  BCF    FF2.7
0ECD6:  MOVFF  73E,A40
0ECDA:  MOVLW  01
0ECDC:  MOVLB  A
0ECDE:  MOVWF  x41
0ECE0:  MOVLB  0
0ECE2:  CALL   0FA6
0ECE6:  BTFSC  1B.7
0ECE8:  BSF    FF2.7
0ECEA:  MOVLW  3A
0ECEC:  BTFSS  F9E.4
0ECEE:  BRA    ECEC
0ECF0:  MOVWF  FAD
0ECF2:  CLRF   1B
0ECF4:  BTFSC  FF2.7
0ECF6:  BSF    1B.7
0ECF8:  BCF    FF2.7
0ECFA:  MOVFF  73F,A40
0ECFE:  MOVLW  01
0ED00:  MOVLB  A
0ED02:  MOVWF  x41
0ED04:  MOVLB  0
0ED06:  CALL   0FA6
0ED0A:  BTFSC  1B.7
0ED0C:  BSF    FF2.7
0ED0E:  MOVLW  0D
0ED10:  BTFSS  F9E.4
0ED12:  BRA    ED10
0ED14:  MOVWF  FAD
0ED16:  MOVLW  0A
0ED18:  BTFSS  F9E.4
0ED1A:  BRA    ED18
0ED1C:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0ED1E:  CALL   E3D8
....................       RTC_display_alarm(); 
0ED22:  CALL   E4AE
....................    } 
0ED26:  GOTO   F25C (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0EFB4:  DECFSZ 48,W
0EFB6:  BRA    F21C
0EFB8:  MOVF   49,F
0EFBA:  BTFSS  FD8.2
0EFBC:  BRA    F21C
0EFBE:  MOVF   4A,F
0EFC0:  BTFSS  FD8.2
0EFC2:  BRA    F21C
0EFC4:  MOVF   4B,F
0EFC6:  BTFSS  FD8.2
0EFC8:  BRA    F21C
....................       v_supply = read_supply(); 
0EFCA:  CALL   50FC
0EFCE:  MOVFF  02,886
0EFD2:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0EFD6:  CALL   34B2
....................       RTC_read(); 
0EFDA:  CALL   3344
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0EFDE:  MOVLW  49
0EFE0:  BTFSS  F9E.4
0EFE2:  BRA    EFE0
0EFE4:  MOVWF  FAD
0EFE6:  MOVLW  10
0EFE8:  MOVWF  FE9
0EFEA:  CLRF   1B
0EFEC:  BTFSC  FF2.7
0EFEE:  BSF    1B.7
0EFF0:  BCF    FF2.7
0EFF2:  MOVFF  24,A41
0EFF6:  MOVFF  23,A40
0EFFA:  CALL   11A6
0EFFE:  BTFSC  1B.7
0F000:  BSF    FF2.7
0F002:  MOVLW  20
0F004:  BTFSS  F9E.4
0F006:  BRA    F004
0F008:  MOVWF  FAD
0F00A:  MOVLW  4E
0F00C:  BTFSS  F9E.4
0F00E:  BRA    F00C
0F010:  MOVWF  FAD
0F012:  MOVLW  10
0F014:  MOVWF  FE9
0F016:  CLRF   1B
0F018:  BTFSC  FF2.7
0F01A:  BSF    1B.7
0F01C:  BCF    FF2.7
0F01E:  MOVFF  22,A41
0F022:  MOVFF  21,A40
0F026:  CALL   11A6
0F02A:  BTFSC  1B.7
0F02C:  BSF    FF2.7
0F02E:  MOVLW  2F
0F030:  BTFSS  F9E.4
0F032:  BRA    F030
0F034:  MOVWF  FAD
0F036:  MOVLW  10
0F038:  MOVWF  FE9
0F03A:  CLRF   1B
0F03C:  BTFSC  FF2.7
0F03E:  BSF    1B.7
0F040:  BCF    FF2.7
0F042:  MOVFF  28,A41
0F046:  MOVFF  27,A40
0F04A:  CALL   11A6
0F04E:  BTFSC  1B.7
0F050:  BSF    FF2.7
0F052:  MOVLW  20
0F054:  BTFSS  F9E.4
0F056:  BRA    F054
0F058:  MOVWF  FAD
0F05A:  MOVLW  50
0F05C:  BTFSS  F9E.4
0F05E:  BRA    F05C
0F060:  MOVWF  FAD
0F062:  MOVLW  10
0F064:  MOVWF  FE9
0F066:  CLRF   1B
0F068:  BTFSC  FF2.7
0F06A:  BSF    1B.7
0F06C:  BCF    FF2.7
0F06E:  MOVFF  2E,A41
0F072:  MOVFF  2D,A40
0F076:  CALL   11A6
0F07A:  BTFSC  1B.7
0F07C:  BSF    FF2.7
0F07E:  MOVLW  20
0F080:  BTFSS  F9E.4
0F082:  BRA    F080
0F084:  MOVWF  FAD
0F086:  MOVLW  04
0F088:  MOVWF  FE9
0F08A:  MOVLB  8
0F08C:  CLRF   x8A
0F08E:  CLRF   x89
0F090:  MOVFF  886,888
0F094:  MOVFF  885,887
0F098:  MOVLW  02
0F09A:  MOVWF  x8B
0F09C:  MOVLB  0
0F09E:  CALL   E152
0F0A2:  MOVLW  80
0F0A4:  MOVWF  FF6
0F0A6:  MOVLW  26
0F0A8:  MOVWF  FF7
0F0AA:  MOVLW  00
0F0AC:  MOVWF  FF8
0F0AE:  CLRF   1B
0F0B0:  BTFSC  FF2.7
0F0B2:  BSF    1B.7
0F0B4:  BCF    FF2.7
0F0B6:  MOVLW  03
0F0B8:  MOVLB  A
0F0BA:  MOVWF  x40
0F0BC:  MOVLB  0
0F0BE:  CALL   1024
0F0C2:  BTFSC  1B.7
0F0C4:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0F0C6:  MOVLW  84
0F0C8:  MOVWF  FF6
0F0CA:  MOVLW  26
0F0CC:  MOVWF  FF7
0F0CE:  MOVLW  00
0F0D0:  MOVWF  FF8
0F0D2:  CLRF   1B
0F0D4:  BTFSC  FF2.7
0F0D6:  BSF    1B.7
0F0D8:  BCF    FF2.7
0F0DA:  MOVLW  09
0F0DC:  MOVLB  A
0F0DE:  MOVWF  x40
0F0E0:  MOVLB  0
0F0E2:  CALL   1024
0F0E6:  BTFSC  1B.7
0F0E8:  BSF    FF2.7
0F0EA:  MOVLW  10
0F0EC:  MOVWF  FE9
0F0EE:  MOVFF  7B6,8F1
0F0F2:  MOVFF  7B5,8F0
0F0F6:  CALL   8FE4
0F0FA:  MOVLW  0D
0F0FC:  BTFSS  F9E.4
0F0FE:  BRA    F0FC
0F100:  MOVWF  FAD
0F102:  MOVLW  0A
0F104:  BTFSS  F9E.4
0F106:  BRA    F104
0F108:  MOVWF  FAD
....................       display_valve_status(); 
0F10A:  RCALL  ED2A
....................       RTC_display(); 
0F10C:  CALL   E24E
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0F110:  MOVLW  94
0F112:  MOVWF  FF6
0F114:  MOVLW  26
0F116:  MOVWF  FF7
0F118:  MOVLW  00
0F11A:  MOVWF  FF8
0F11C:  CLRF   1B
0F11E:  BTFSC  FF2.7
0F120:  BSF    1B.7
0F122:  BCF    FF2.7
0F124:  MOVLW  05
0F126:  MOVLB  A
0F128:  MOVWF  x40
0F12A:  MOVLB  0
0F12C:  CALL   1024
0F130:  BTFSC  1B.7
0F132:  BSF    FF2.7
0F134:  CLRF   1B
0F136:  BTFSC  FF2.7
0F138:  BSF    1B.7
0F13A:  BCF    FF2.7
0F13C:  MOVFF  73A,A40
0F140:  MOVLW  01
0F142:  MOVLB  A
0F144:  MOVWF  x41
0F146:  MOVLB  0
0F148:  CALL   0FA6
0F14C:  BTFSC  1B.7
0F14E:  BSF    FF2.7
0F150:  MOVLW  2F
0F152:  BTFSS  F9E.4
0F154:  BRA    F152
0F156:  MOVWF  FAD
0F158:  CLRF   1B
0F15A:  BTFSC  FF2.7
0F15C:  BSF    1B.7
0F15E:  BCF    FF2.7
0F160:  MOVFF  73B,A40
0F164:  MOVLW  01
0F166:  MOVLB  A
0F168:  MOVWF  x41
0F16A:  MOVLB  0
0F16C:  CALL   0FA6
0F170:  BTFSC  1B.7
0F172:  BSF    FF2.7
0F174:  MOVLW  2F
0F176:  BTFSS  F9E.4
0F178:  BRA    F176
0F17A:  MOVWF  FAD
0F17C:  CLRF   1B
0F17E:  BTFSC  FF2.7
0F180:  BSF    1B.7
0F182:  BCF    FF2.7
0F184:  MOVFF  73C,A40
0F188:  MOVLW  01
0F18A:  MOVLB  A
0F18C:  MOVWF  x41
0F18E:  MOVLB  0
0F190:  CALL   0FA6
0F194:  BTFSC  1B.7
0F196:  BSF    FF2.7
0F198:  MOVLW  20
0F19A:  BTFSS  F9E.4
0F19C:  BRA    F19A
0F19E:  MOVWF  FAD
0F1A0:  CLRF   1B
0F1A2:  BTFSC  FF2.7
0F1A4:  BSF    1B.7
0F1A6:  BCF    FF2.7
0F1A8:  MOVFF  73D,A40
0F1AC:  MOVLW  01
0F1AE:  MOVLB  A
0F1B0:  MOVWF  x41
0F1B2:  MOVLB  0
0F1B4:  CALL   0FA6
0F1B8:  BTFSC  1B.7
0F1BA:  BSF    FF2.7
0F1BC:  MOVLW  3A
0F1BE:  BTFSS  F9E.4
0F1C0:  BRA    F1BE
0F1C2:  MOVWF  FAD
0F1C4:  CLRF   1B
0F1C6:  BTFSC  FF2.7
0F1C8:  BSF    1B.7
0F1CA:  BCF    FF2.7
0F1CC:  MOVFF  73E,A40
0F1D0:  MOVLW  01
0F1D2:  MOVLB  A
0F1D4:  MOVWF  x41
0F1D6:  MOVLB  0
0F1D8:  CALL   0FA6
0F1DC:  BTFSC  1B.7
0F1DE:  BSF    FF2.7
0F1E0:  MOVLW  3A
0F1E2:  BTFSS  F9E.4
0F1E4:  BRA    F1E2
0F1E6:  MOVWF  FAD
0F1E8:  CLRF   1B
0F1EA:  BTFSC  FF2.7
0F1EC:  BSF    1B.7
0F1EE:  BCF    FF2.7
0F1F0:  MOVFF  73F,A40
0F1F4:  MOVLW  01
0F1F6:  MOVLB  A
0F1F8:  MOVWF  x41
0F1FA:  MOVLB  0
0F1FC:  CALL   0FA6
0F200:  BTFSC  1B.7
0F202:  BSF    FF2.7
0F204:  MOVLW  0D
0F206:  BTFSS  F9E.4
0F208:  BRA    F206
0F20A:  MOVWF  FAD
0F20C:  MOVLW  0A
0F20E:  BTFSS  F9E.4
0F210:  BRA    F20E
0F212:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0F214:  CALL   E3D8
....................       RTC_display_alarm(); 
0F218:  CALL   E4AE
....................    } 
0F21C:  GOTO   F25C (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0F220:  MOVF   2F,W
0F222:  MOVWF  00
0F224:  MOVF   30,W
0F226:  MOVWF  03
0F228:  BNZ   F22E
0F22A:  MOVF   00,F
0F22C:  BZ    F24E
0F22E:  MOVF   03,W
0F230:  BNZ   F238
0F232:  MOVLW  01
0F234:  SUBWF  00,W
0F236:  BZ    F254
0F238:  MOVF   03,W
0F23A:  BNZ   F242
0F23C:  MOVLW  03
0F23E:  SUBWF  00,W
0F240:  BZ    F254
0F242:  MOVF   03,W
0F244:  BNZ   F24C
0F246:  MOVLW  02
0F248:  SUBWF  00,W
0F24A:  BZ    F25A
0F24C:  BRA    F25C
....................       case ECO : commandHe(); 
0F24E:  GOTO   E628
....................          break; 
0F252:  BRA    F25C
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0F254:  GOTO   EA4C
....................          break; 
0F258:  BRA    F25C
....................       case AWS : commandHa(); 
0F25A:  BRA    EFB4
....................          break;          
....................    } 
0F25C:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0F260:  MOVF   48,F
0F262:  BNZ   F270
0F264:  MOVF   49,F
0F266:  BNZ   F270
0F268:  MOVF   4A,F
0F26A:  BNZ   F270
0F26C:  MOVF   4B,F
0F26E:  BZ    F2A4
0F270:  MOVF   4B,F
0F272:  BNZ   F2A4
0F274:  MOVF   4A,F
0F276:  BNZ   F2A4
0F278:  MOVF   49,W
0F27A:  SUBLW  FD
0F27C:  BNC   F2A4
0F27E:  BNZ   F286
0F280:  MOVF   48,W
0F282:  SUBLW  20
0F284:  BNC   F2A4
....................       nv_interval = arg; 
0F286:  MOVFF  49,24
0F28A:  MOVFF  48,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0F28E:  MOVLW  14
0F290:  MOVLB  8
0F292:  MOVWF  xEE
0F294:  MOVFF  24,8F0
0F298:  MOVFF  23,8EF
0F29C:  MOVLB  0
0F29E:  CALL   4FD4
....................    } 
0F2A2:  BRA    F2A8
....................    else cmd_arg(); 
0F2A4:  CALL   B2C2
0F2A8:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0F2AC:  MOVF   4B,F
0F2AE:  BNZ   F2DE
0F2B0:  MOVF   4A,F
0F2B2:  BNZ   F2DE
0F2B4:  MOVF   49,W
0F2B6:  SUBLW  27
0F2B8:  BNC   F2DE
0F2BA:  BNZ   F2C2
0F2BC:  MOVF   48,W
0F2BE:  SUBLW  0F
0F2C0:  BNC   F2DE
....................       nv_serial = arg; 
0F2C2:  MOVFF  49,26
0F2C6:  MOVFF  48,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0F2CA:  MOVLB  8
0F2CC:  CLRF   xEE
0F2CE:  MOVFF  26,8F0
0F2D2:  MOVFF  25,8EF
0F2D6:  MOVLB  0
0F2D8:  CALL   4FD4
....................    } 
0F2DC:  BRA    F2E2
....................    else cmd_arg(); 
0F2DE:  CALL   B2C2
0F2E2:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F506:  MOVF   2F,F
0F508:  BNZ   F538
0F50A:  MOVF   30,F
0F50C:  BNZ   F538
....................        
....................       if (arg > 0 && arg < 3){ 
0F50E:  MOVF   48,F
0F510:  BNZ   F51E
0F512:  MOVF   49,F
0F514:  BNZ   F51E
0F516:  MOVF   4A,F
0F518:  BNZ   F51E
0F51A:  MOVF   4B,F
0F51C:  BZ    F534
0F51E:  MOVF   4B,F
0F520:  BNZ   F534
0F522:  MOVF   4A,F
0F524:  BNZ   F534
0F526:  MOVF   49,F
0F528:  BNZ   F534
0F52A:  MOVF   48,W
0F52C:  SUBLW  02
0F52E:  BNC   F534
....................          det_cmd(); 
0F530:  RCALL  F3C6
....................       } 
0F532:  BRA    F538
....................       else cmd_arg(); 
0F534:  CALL   B2C2
....................        
....................    } 
0F538:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
103B6:  MOVF   4B,F
103B8:  BNZ   10424
103BA:  MOVF   4A,F
103BC:  BNZ   10424
103BE:  MOVF   49,W
103C0:  SUBLW  0F
103C2:  BNC   10424
....................       switch (nv_det_type){ 
103C4:  MOVFF  45,00
103C8:  MOVF   46,W
103CA:  MOVWF  03
103CC:  BNZ   103D4
103CE:  MOVLW  01
103D0:  SUBWF  00,W
103D2:  BZ    103EA
103D4:  MOVF   03,W
103D6:  BNZ   103DE
103D8:  MOVLW  02
103DA:  SUBWF  00,W
103DC:  BZ    103F0
103DE:  MOVF   03,W
103E0:  BNZ   103E8
103E2:  MOVLW  03
103E4:  SUBWF  00,W
103E6:  BZ    1040E
103E8:  BRA    10422
....................          case 1 : det_cmd(); 
103EA:  CALL   F3C6
....................             break; 
103EE:  BRA    10422
....................          case 2 : DAC_set(1,arg); 
103F0:  MOVFF  49,886
103F4:  MOVFF  48,885
103F8:  MOVLW  01
103FA:  MOVLB  8
103FC:  MOVWF  xD3
103FE:  MOVFF  49,8D5
10402:  MOVFF  48,8D4
10406:  MOVLB  0
10408:  CALL   F53C
....................             break; 
1040C:  BRA    10422
....................          case 3 : set_LED(arg); 
1040E:  MOVFF  49,886
10412:  MOVFF  48,885
10416:  MOVFF  49,8C6
1041A:  MOVFF  48,8C5
1041E:  CALL   F88A
....................             break; 
....................       } 
....................    } 
10422:  BRA    10482
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
10424:  MOVF   4B,F
10426:  BNZ   1043C
10428:  MOVF   4A,F
1042A:  BNZ   1043C
1042C:  MOVF   49,W
1042E:  SUBLW  4D
10430:  BC    10466
10432:  XORLW  FF
10434:  BNZ   1043C
10436:  MOVF   48,W
10438:  SUBLW  20
1043A:  BC    10466
1043C:  MOVF   4B,F
1043E:  BNZ   10466
10440:  MOVF   4A,F
10442:  BNZ   10466
10444:  MOVF   49,W
10446:  SUBLW  4E
10448:  BNC   10466
1044A:  BNZ   10452
1044C:  MOVF   48,W
1044E:  SUBLW  22
10450:  BNC   10466
10452:  MOVFF  49,886
10456:  MOVFF  48,885
1045A:  MOVFF  49,888
1045E:  MOVFF  48,887
10462:  BRA    1026E
10464:  BRA    10482
....................    else if(arg==30001)set_LED_test(); 
10466:  MOVF   48,W
10468:  SUBLW  31
1046A:  BNZ   1047E
1046C:  MOVF   49,W
1046E:  SUBLW  75
10470:  BNZ   1047E
10472:  MOVF   4A,F
10474:  BNZ   1047E
10476:  MOVF   4B,F
10478:  BNZ   1047E
1047A:  BRA    1032A
1047C:  BRA    10482
....................    else cmd_arg(); 
1047E:  CALL   B2C2
10482:  GOTO   FFF6 (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
10486:  MOVF   4B,F
10488:  BNZ   104BA
1048A:  MOVF   4A,F
1048C:  BNZ   104BA
1048E:  MOVF   49,W
10490:  SUBLW  57
10492:  BNC   104BA
10494:  BNZ   1049C
10496:  MOVF   48,W
10498:  SUBLW  E4
1049A:  BNC   104BA
....................       nv_volume = arg; 
1049C:  MOVFF  49,2C
104A0:  MOVFF  48,2B
....................       write16(ADDR_VOLUME, nv_volume); 
104A4:  MOVLW  22
104A6:  MOVLB  8
104A8:  MOVWF  xEE
104AA:  MOVFF  2C,8F0
104AE:  MOVFF  2B,8EF
104B2:  MOVLB  0
104B4:  CALL   4FD4
....................    } 
104B8:  BRA    104BE
....................    else cmd_arg(); 
104BA:  CALL   B2C2
104BE:  GOTO   FFF6 (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
*
0FFCC:  MOVF   2F,W
0FFCE:  MOVWF  00
0FFD0:  MOVF   30,W
0FFD2:  MOVWF  03
0FFD4:  BNZ   FFDA
0FFD6:  MOVF   00,F
0FFD8:  BZ    FFF0
0FFDA:  MOVF   03,W
0FFDC:  BNZ   FFE4
0FFDE:  MOVLW  01
0FFE0:  SUBWF  00,W
0FFE2:  BZ    FFF4
0FFE4:  MOVF   03,W
0FFE6:  BNZ   FFEE
0FFE8:  MOVLW  03
0FFEA:  SUBWF  00,W
0FFEC:  BZ    FFF4
0FFEE:  BRA    FFF6
....................       case ECO : commandLe(); 
0FFF0:  BRA    103B6
....................          break; 
0FFF2:  BRA    FFF6
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
0FFF4:  BRA    10486
....................          break; 
....................    } 
0FFF6:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
16D64:  CALL   29C0
....................     
....................    user_quit = FALSE; 
16D68:  CLRF   50
....................     
....................    if(arg > 0 && arg < 21) 
16D6A:  MOVF   48,F
16D6C:  BNZ   16D7A
16D6E:  MOVF   49,F
16D70:  BNZ   16D7A
16D72:  MOVF   4A,F
16D74:  BNZ   16D7A
16D76:  MOVF   4B,F
16D78:  BZ    16DF6
16D7A:  MOVF   4B,F
16D7C:  BNZ   16DF6
16D7E:  MOVF   4A,F
16D80:  BNZ   16DF6
16D82:  MOVF   49,F
16D84:  BNZ   16DF6
16D86:  MOVF   48,W
16D88:  SUBLW  14
16D8A:  BNC   16DF6
....................    { 
....................       macro = arg; 
16D8C:  MOVFF  48,886
....................       switch(nv_product){ 
16D90:  MOVFF  2F,00
16D94:  MOVF   30,W
16D96:  MOVWF  03
16D98:  BNZ   16D9E
16D9A:  MOVF   00,F
16D9C:  BZ    16DBE
16D9E:  MOVF   03,W
16DA0:  BNZ   16DA8
16DA2:  MOVLW  01
16DA4:  SUBWF  00,W
16DA6:  BZ    16DBE
16DA8:  MOVF   03,W
16DAA:  BNZ   16DB2
16DAC:  MOVLW  03
16DAE:  SUBWF  00,W
16DB0:  BZ    16DBE
16DB2:  MOVF   03,W
16DB4:  BNZ   16DBC
16DB6:  MOVLW  02
16DB8:  SUBWF  00,W
16DBA:  BZ    16DE4
16DBC:  BRA    16DF4
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
16DBE:  MOVLW  01
16DC0:  MOVLB  7
16DC2:  ADDWF  xC3,W
16DC4:  MOVLB  8
16DC6:  MOVWF  x87
16DC8:  MOVLW  00
16DCA:  MOVLB  7
16DCC:  ADDWFC xC4,W
16DCE:  MOVLB  8
16DD0:  MOVWF  x88
16DD2:  MOVFF  886,897
16DD6:  MOVWF  x99
16DD8:  MOVFF  887,898
16DDC:  MOVLB  0
16DDE:  CALL   1537A
....................             break; 
16DE2:  BRA    16DF4
....................          case AWS : play_macro(macro,nv_port); 
16DE4:  MOVFF  886,897
16DE8:  MOVFF  2E,899
16DEC:  MOVFF  2D,898
16DF0:  CALL   1537A
....................             break; 
....................       } 
....................    }    
16DF4:  BRA    16E7C
....................    else if (arg == 0) 
16DF6:  MOVF   48,F
16DF8:  BNZ   16E78
16DFA:  MOVF   49,F
16DFC:  BNZ   16E78
16DFE:  MOVF   4A,F
16E00:  BNZ   16E78
16E02:  MOVF   4B,F
16E04:  BNZ   16E78
....................    { 
....................       //start watchdog at beginning of logging mode 
....................       //RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
16E06:  BCF    F91.0
....................       spi_write(0x89); 
16E08:  MOVF   FC9,W
16E0A:  MOVLW  89
16E0C:  MOVWF  FC9
16E0E:  RRCF   FC7,W
16E10:  BNC   16E0E
....................       spi_write(0b11111111); 
16E12:  MOVF   FC9,W
16E14:  SETF   FC9
16E16:  RRCF   FC7,W
16E18:  BNC   16E16
....................       spi_read(0x00); 
16E1A:  MOVF   FC9,W
16E1C:  CLRF   FC9
16E1E:  RRCF   FC7,W
16E20:  BNC   16E1E
....................       output_bit(RTC_CS, DISABLE); 
16E22:  BSF    F91.0
....................        
....................       MaxSamples=FALSE; 
16E24:  CLRF   34
16E26:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
16E28:  MOVLW  28
16E2A:  MOVLB  8
16E2C:  MOVWF  x89
16E2E:  MOVFF  33,88A
16E32:  MOVLB  0
16E34:  CALL   3412
....................       if (LoggingReentry != TRUE) 
16E38:  MOVLB  8
16E3A:  DECFSZ x85,W
16E3C:  BRA    16E40
16E3E:  BRA    16E58
....................       { 
....................          nv_sample = 0; 
16E40:  CLRF   22
16E42:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
16E44:  MOVLW  16
16E46:  MOVWF  xEE
16E48:  MOVFF  22,8F0
16E4C:  MOVFF  21,8EF
16E50:  MOVLB  0
16E52:  CALL   4FD4
16E56:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
16E58:  CLRF   x85
....................       nv_macro_step = 0; 
16E5A:  CLRF   38
16E5C:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
16E5E:  MOVLW  3A
16E60:  MOVWF  xEE
16E62:  MOVFF  38,8F0
16E66:  MOVFF  37,8EF
16E6A:  MOVLB  0
16E6C:  CALL   4FD4
....................       user_quit = auto_sample_ready(); 
16E70:  BRA    16B62
16E72:  MOVFF  01,50
....................    } 
16E76:  BRA    16E7C
....................    else cmd_arg(); 
16E78:  CALL   B2C2
....................     
....................    busy_clear(); 
16E7C:  CALL   AE74
16E80:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
16E82:  MOVF   48,F
16E84:  BNZ   16E92
16E86:  MOVF   49,F
16E88:  BNZ   16E92
16E8A:  MOVF   4A,F
16E8C:  BNZ   16E92
16E8E:  MOVF   4B,F
16E90:  BZ    16EC6
16E92:  MOVF   4B,F
16E94:  BNZ   16EC6
16E96:  MOVF   4A,F
16E98:  BNZ   16EC6
16E9A:  MOVF   49,W
16E9C:  SUBLW  0D
16E9E:  BNC   16EC6
16EA0:  BNZ   16EA8
16EA2:  MOVF   48,W
16EA4:  SUBLW  AC
16EA6:  BNC   16EC6
....................       nv_max_samples = arg; 
16EA8:  MOVFF  49,28
16EAC:  MOVFF  48,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
16EB0:  MOVLW  18
16EB2:  MOVLB  8
16EB4:  MOVWF  xEE
16EB6:  MOVFF  28,8F0
16EBA:  MOVFF  27,8EF
16EBE:  MOVLB  0
16EC0:  CALL   4FD4
....................    } 
16EC4:  BRA    16F0C
....................    else if(arg == 0) { 
16EC6:  MOVF   48,F
16EC8:  BNZ   16F08
16ECA:  MOVF   49,F
16ECC:  BNZ   16F08
16ECE:  MOVF   4A,F
16ED0:  BNZ   16F08
16ED2:  MOVF   4B,F
16ED4:  BNZ   16F08
....................       nv_sample = 0; 
16ED6:  CLRF   22
16ED8:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16EDA:  MOVLW  16
16EDC:  MOVLB  8
16EDE:  MOVWF  xEE
16EE0:  MOVFF  22,8F0
16EE4:  MOVFF  21,8EF
16EE8:  MOVLB  0
16EEA:  CALL   4FD4
....................       nv_macro_step = 0; 
16EEE:  CLRF   38
16EF0:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16EF2:  MOVLW  3A
16EF4:  MOVLB  8
16EF6:  MOVWF  xEE
16EF8:  MOVFF  38,8F0
16EFC:  MOVFF  37,8EF
16F00:  MOVLB  0
16F02:  CALL   4FD4
....................    } 
16F06:  BRA    16F0C
....................    else cmd_arg(); 
16F08:  CALL   B2C2
16F0C:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
17032:  DECFSZ 48,W
17034:  BRA    1704E
17036:  MOVF   49,F
17038:  BNZ   1704E
1703A:  MOVF   4A,F
1703C:  BNZ   1704E
1703E:  MOVF   4B,F
17040:  BNZ   1704E
....................    { 
....................       bus_on(); 
17042:  CALL   D334
....................       open_pipe(); 
17046:  BRA    16F28
....................       bus_off(); 
17048:  CALL   D358
....................    } 
1704C:  BRA    17052
....................    else cmd_arg(); 
1704E:  CALL   B2C2
17052:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
17110:  MOVLB  7
17112:  DECFSZ x41,W
17114:  BRA    17118
17116:  CLRF   x40
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
17118:  MOVF   48,F
1711A:  BNZ   1712A
1711C:  MOVF   49,F
1711E:  BNZ   1712A
17120:  MOVF   4A,F
17122:  BNZ   1712A
17124:  MOVF   4B,F
17126:  BTFSC  FD8.2
17128:  BRA    171F2
1712A:  BCF    FD8.0
1712C:  RLCF   x40,W
1712E:  CLRF   03
17130:  ADDLW  62
17132:  MOVWF  FE9
17134:  MOVLW  07
17136:  ADDWFC 03,W
17138:  MOVWF  FEA
1713A:  MOVFF  FEC,03
1713E:  MOVF   FED,F
17140:  MOVFF  FEF,01
17144:  MOVF   4B,F
17146:  BNZ   171F2
17148:  MOVF   4A,F
1714A:  BNZ   171F2
1714C:  MOVF   49,W
1714E:  SUBWF  03,W
17150:  BNC   171F2
17152:  BNZ   1715A
17154:  MOVF   48,W
17156:  SUBWF  01,W
17158:  BNC   171F2
....................       if(e_mode[motor]==2){     // if port mode then move 
1715A:  BCF    FD8.0
1715C:  RLCF   x40,W
1715E:  CLRF   03
17160:  ADDLW  66
17162:  MOVWF  FE9
17164:  MOVLW  07
17166:  ADDWFC 03,W
17168:  MOVWF  FEA
1716A:  MOVFF  FEC,886
1716E:  MOVF   FED,F
17170:  MOVFF  FEF,885
17174:  MOVLB  8
17176:  MOVF   x85,W
17178:  SUBLW  02
1717A:  BNZ   171E8
1717C:  MOVF   x86,F
1717E:  BNZ   171E8
....................          switch (nv_product){ 
17180:  MOVF   2F,W
17182:  MOVWF  00
17184:  MOVF   30,W
17186:  MOVWF  03
17188:  MOVF   03,W
1718A:  BNZ   17194
1718C:  MOVF   00,F
1718E:  MOVLB  0
17190:  BZ    171B2
17192:  MOVLB  8
17194:  MOVF   03,W
17196:  BNZ   171A2
17198:  MOVLW  01
1719A:  SUBWF  00,W
1719C:  MOVLB  0
1719E:  BZ    171C4
171A0:  MOVLB  8
171A2:  MOVF   03,W
171A4:  BNZ   171B0
171A6:  MOVLW  03
171A8:  SUBWF  00,W
171AA:  MOVLB  0
171AC:  BZ    171D6
171AE:  MOVLB  8
171B0:  BRA    171E6
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
171B2:  MOVLW  01
171B4:  MOVLB  8
171B6:  MOVWF  x85
171B8:  CLRF   x86
171BA:  MOVWF  x87
171BC:  MOVLB  0
171BE:  RCALL  17056
....................                break;             
171C0:  MOVLB  8
171C2:  BRA    171E6
....................             case WMS4: command_move(0,0,1); 
171C4:  MOVLB  8
171C6:  CLRF   x85
171C8:  CLRF   x86
171CA:  MOVLW  01
171CC:  MOVWF  x87
171CE:  MOVLB  0
171D0:  RCALL  17056
....................                break; 
171D2:  MOVLB  8
171D4:  BRA    171E6
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
171D6:  MOVLB  8
171D8:  CLRF   x85
171DA:  CLRF   x86
171DC:  MOVLW  01
171DE:  MOVWF  x87
171E0:  MOVLB  0
171E2:  RCALL  17056
....................                break; 
171E4:  MOVLB  8
....................          } 
....................       } 
171E6:  BRA    171F0
....................       else cmd_err();                           // else error 
171E8:  MOVLB  0
171EA:  CALL   BF84
171EE:  MOVLB  8
....................    } 
171F0:  BRA    171FA
....................    else cmd_arg(); 
171F2:  MOVLB  0
171F4:  CALL   B2C2
171F8:  MOVLB  8
171FA:  MOVLB  0
171FC:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
171FE:  MOVF   4B,F
17200:  BNZ   1722E
17202:  MOVF   4A,F
17204:  BNZ   1722E
17206:  MOVF   49,F
17208:  BNZ   1722E
1720A:  MOVF   48,W
1720C:  SUBLW  30
1720E:  BNC   1722E
....................       nv_port = arg; 
17210:  MOVFF  49,2E
17214:  MOVFF  48,2D
....................       write16(ADDR_PORT, nv_port); 
17218:  MOVLW  24
1721A:  MOVLB  8
1721C:  MOVWF  xEE
1721E:  MOVFF  2E,8F0
17222:  MOVFF  2D,8EF
17226:  MOVLB  0
17228:  CALL   4FD4
....................    } 
1722C:  BRA    17232
....................    else cmd_arg(); 
1722E:  CALL   B2C2
17232:  GOTO   1726E (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
17236:  MOVF   2F,W
17238:  MOVWF  00
1723A:  MOVF   30,W
1723C:  MOVWF  03
1723E:  BNZ   17244
17240:  MOVF   00,F
17242:  BZ    17264
17244:  MOVF   03,W
17246:  BNZ   1724E
17248:  MOVLW  01
1724A:  SUBWF  00,W
1724C:  BZ    17268
1724E:  MOVF   03,W
17250:  BNZ   17258
17252:  MOVLW  03
17254:  SUBWF  00,W
17256:  BZ    17268
17258:  MOVF   03,W
1725A:  BNZ   17262
1725C:  MOVLW  02
1725E:  SUBWF  00,W
17260:  BZ    1726C
17262:  BRA    1726E
....................       case ECO : commandPe(); 
17264:  RCALL  17110
....................          break; 
17266:  BRA    1726E
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
17268:  RCALL  17110
....................          break; 
1726A:  BRA    1726E
....................       case AWS : commandPa(); 
1726C:  BRA    171FE
....................          break;          
....................    } 
1726E:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
172BA:  MOVLB  4
172BC:  DECFSZ xB6,W
172BE:  BRA    172EA
....................     
....................       if(arg<33){ 
172C0:  MOVF   4B,F
172C2:  BNZ   172E2
172C4:  MOVF   4A,F
172C6:  BNZ   172E2
172C8:  MOVF   49,F
172CA:  BNZ   172E2
172CC:  MOVF   48,W
172CE:  SUBLW  20
172D0:  BNC   172E2
....................          valve=arg;    
172D2:  MOVFF  48,885
....................          sol_switch(valve); 
172D6:  MOVFF  885,8B5
172DA:  MOVLB  0
172DC:  CALL   14524
....................       }  
172E0:  BRA    172E8
....................       else cmd_arg(); 
172E2:  MOVLB  0
172E4:  CALL   B2C2
....................    } 
172E8:  BRA    172F0
....................    else cmd_err(); 
172EA:  MOVLB  0
172EC:  CALL   BF84
172F0:  GOTO   17320 (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
17272:  MOVF   48,F
17274:  BNZ   17282
17276:  MOVF   49,F
17278:  BNZ   17282
1727A:  MOVF   4A,F
1727C:  BNZ   17282
1727E:  MOVF   4B,F
17280:  BZ    172B2
17282:  MOVF   4B,F
17284:  BNZ   172B2
17286:  MOVF   4A,F
17288:  BNZ   172B2
1728A:  MOVF   49,F
1728C:  BNZ   172B2
1728E:  MOVF   48,W
17290:  SUBLW  32
17292:  BNC   172B2
....................       nv_port = arg; 
17294:  MOVFF  49,2E
17298:  MOVFF  48,2D
....................       write16(ADDR_SAMPLE, nv_port); 
1729C:  MOVLW  16
1729E:  MOVLB  8
172A0:  MOVWF  xEE
172A2:  MOVFF  2E,8F0
172A6:  MOVFF  2D,8EF
172AA:  MOVLB  0
172AC:  CALL   4FD4
....................    } 
172B0:  BRA    172B6
....................    else cmd_arg(); 
172B2:  CALL   B2C2
172B6:  GOTO   17320 (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
172F4:  MOVF   2F,W
172F6:  MOVWF  00
172F8:  MOVF   30,W
172FA:  MOVWF  03
172FC:  BNZ   17304
172FE:  MOVLW  01
17300:  SUBWF  00,W
17302:  BZ    1731A
17304:  MOVF   03,W
17306:  BNZ   1730E
17308:  MOVLW  03
1730A:  SUBWF  00,W
1730C:  BZ    1731A
1730E:  MOVF   03,W
17310:  BNZ   17318
17312:  MOVLW  02
17314:  SUBWF  00,W
17316:  BZ    1731E
17318:  BRA    17320
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
1731A:  BRA    17272
....................          break; 
1731C:  BRA    17320
....................       case AWS : commandQa(); 
1731E:  BRA    172BA
....................          break;          
....................    } 
17320:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
17324:  CALL   29C0
....................     
....................    nv_macro_step = 0; 
17328:  CLRF   38
1732A:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
1732C:  MOVLW  3A
1732E:  MOVLB  8
17330:  MOVWF  xEE
17332:  MOVFF  38,8F0
17336:  MOVFF  37,8EF
1733A:  MOVLB  0
1733C:  CALL   4FD4
....................     
....................    user_quit = FALSE; 
17340:  CLRF   50
....................     
....................    if (arg > 0 && arg < 3501){ 
17342:  MOVF   48,F
17344:  BNZ   17352
17346:  MOVF   49,F
17348:  BNZ   17352
1734A:  MOVF   4A,F
1734C:  BNZ   17352
1734E:  MOVF   4B,F
17350:  BZ    173FE
17352:  MOVF   4B,F
17354:  BNZ   173FE
17356:  MOVF   4A,F
17358:  BNZ   173FE
1735A:  MOVF   49,W
1735C:  SUBLW  0D
1735E:  BNC   173FE
17360:  BNZ   17368
17362:  MOVF   48,W
17364:  SUBLW  AC
17366:  BNC   173FE
....................       samples = arg; 
17368:  MOVFF  49,887
1736C:  MOVFF  48,886
....................       user_quit = FALSE; 
17370:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
17372:  MOVLB  8
17374:  CLRF   x89
17376:  CLRF   x88
17378:  MOVF   x89,W
1737A:  SUBWF  x87,W
1737C:  BNC   173FC
1737E:  BNZ   17386
17380:  MOVF   x86,W
17382:  SUBWF  x88,W
17384:  BC    173FC
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
17386:  MOVLW  01
17388:  ADDWF  x88,W
1738A:  MOVWF  x8A
1738C:  MOVLW  00
1738E:  ADDWFC x89,W
17390:  MOVWF  x8B
17392:  MOVLW  BA
17394:  MOVWF  FF6
17396:  MOVLW  26
17398:  MOVWF  FF7
1739A:  MOVLW  00
1739C:  MOVWF  FF8
1739E:  CLRF   1B
173A0:  BTFSC  FF2.7
173A2:  BSF    1B.7
173A4:  BCF    FF2.7
173A6:  MOVLW  05
173A8:  MOVLB  A
173AA:  MOVWF  x40
173AC:  MOVLB  0
173AE:  CALL   1024
173B2:  BTFSC  1B.7
173B4:  BSF    FF2.7
173B6:  MOVLW  09
173B8:  MOVWF  FE9
173BA:  CLRF   1B
173BC:  BTFSC  FF2.7
173BE:  BSF    1B.7
173C0:  BCF    FF2.7
173C2:  MOVFF  88B,A41
173C6:  MOVFF  88A,A40
173CA:  CALL   11A6
173CE:  BTFSC  1B.7
173D0:  BSF    FF2.7
173D2:  MOVLW  0D
173D4:  BTFSS  F9E.4
173D6:  BRA    173D4
173D8:  MOVWF  FAD
173DA:  MOVLW  0A
173DC:  BTFSS  F9E.4
173DE:  BRA    173DC
173E0:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
173E2:  CALL   15F52
173E6:  MOVFF  01,885
....................          if (macro_cmd == ';') break; 
173EA:  MOVLB  8
173EC:  MOVF   x85,W
173EE:  SUBLW  3B
173F0:  BTFSC  FD8.2
173F2:  BRA    173FC
173F4:  INCF   x88,F
173F6:  BTFSC  FD8.2
173F8:  INCF   x89,F
173FA:  BRA    17378
173FC:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
173FE:  CALL   AE74
17402:  GOTO   175C2 (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
17406:  MOVF   48,F
17408:  BNZ   17416
1740A:  MOVF   49,F
1740C:  BNZ   17416
1740E:  MOVF   4A,F
17410:  BNZ   17416
17412:  MOVF   4B,F
17414:  BZ    1745A
17416:  MOVF   4B,F
17418:  BNZ   1745A
1741A:  MOVF   4A,F
1741C:  BNZ   1745A
1741E:  MOVF   49,F
17420:  BNZ   1745A
17422:  MOVF   48,W
17424:  SUBLW  2F
17426:  BNC   1745A
....................       n=arg; 
17428:  MOVFF  48,888
....................       port=2; 
1742C:  MOVLB  8
1742E:  CLRF   x86
17430:  MOVLW  02
17432:  MOVWF  x85
....................       for(i=0;i<n;++i){ 
17434:  CLRF   x87
17436:  MOVF   x88,W
17438:  SUBWF  x87,W
1743A:  BC    17456
....................          play_wms_hard_macro(port); 
1743C:  MOVFF  886,88A
17440:  MOVFF  885,889
17444:  MOVLB  0
17446:  CALL   D7C4
....................          ++port; 
1744A:  MOVLB  8
1744C:  INCF   x85,F
1744E:  BTFSC  FD8.2
17450:  INCF   x86,F
17452:  INCF   x87,F
17454:  BRA    17436
....................       } 
....................    } 
17456:  BRA    17460
17458:  MOVLB  0
....................    else cmd_arg(); 
1745A:  CALL   B2C2
1745E:  MOVLB  8
17460:  MOVLB  0
17462:  GOTO   175C2 (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
17466:  CALL   29C0
....................     
....................    nv_macro_step = 0; 
1746A:  CLRF   38
1746C:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
1746E:  MOVLW  3A
17470:  MOVLB  8
17472:  MOVWF  xEE
17474:  MOVFF  38,8F0
17478:  MOVFF  37,8EF
1747C:  MOVLB  0
1747E:  CALL   4FD4
....................     
....................    user_quit = FALSE; 
17482:  CLRF   50
....................     
....................    if (arg > 0 && arg < 241){ 
17484:  MOVF   48,F
17486:  BNZ   17496
17488:  MOVF   49,F
1748A:  BNZ   17496
1748C:  MOVF   4A,F
1748E:  BNZ   17496
17490:  MOVF   4B,F
17492:  BTFSC  FD8.2
17494:  BRA    17582
17496:  MOVF   4B,F
17498:  BTFSS  FD8.2
1749A:  BRA    17582
1749C:  MOVF   4A,F
1749E:  BTFSS  FD8.2
174A0:  BRA    17582
174A2:  MOVF   49,F
174A4:  BTFSS  FD8.2
174A6:  BRA    17582
174A8:  MOVF   48,W
174AA:  SUBLW  F0
174AC:  BNC   17582
....................       samples = arg; 
174AE:  MOVFF  49,887
174B2:  MOVFF  48,886
....................       user_quit = FALSE; 
174B6:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
174B8:  MOVLB  8
174BA:  CLRF   x89
174BC:  CLRF   x88
174BE:  MOVF   x89,W
174C0:  SUBWF  x87,W
174C2:  BNC   17580
174C4:  BNZ   174CC
174C6:  MOVF   x86,W
174C8:  SUBWF  x88,W
174CA:  BC    17580
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
174CC:  MOVLW  01
174CE:  ADDWF  x88,W
174D0:  MOVWF  x8A
174D2:  MOVLW  00
174D4:  ADDWFC x89,W
174D6:  MOVWF  x8B
174D8:  MOVLW  C8
174DA:  MOVWF  FF6
174DC:  MOVLW  26
174DE:  MOVWF  FF7
174E0:  MOVLW  00
174E2:  MOVWF  FF8
174E4:  CLRF   1B
174E6:  BTFSC  FF2.7
174E8:  BSF    1B.7
174EA:  BCF    FF2.7
174EC:  MOVLW  05
174EE:  MOVLB  A
174F0:  MOVWF  x40
174F2:  MOVLB  0
174F4:  CALL   1024
174F8:  BTFSC  1B.7
174FA:  BSF    FF2.7
174FC:  MOVLW  09
174FE:  MOVWF  FE9
17500:  CLRF   1B
17502:  BTFSC  FF2.7
17504:  BSF    1B.7
17506:  BCF    FF2.7
17508:  MOVFF  88B,A41
1750C:  MOVFF  88A,A40
17510:  CALL   11A6
17514:  BTFSC  1B.7
17516:  BSF    FF2.7
17518:  MOVLW  0D
1751A:  BTFSS  F9E.4
1751C:  BRA    1751A
1751E:  MOVWF  FAD
17520:  MOVLW  0A
17522:  BTFSS  F9E.4
17524:  BRA    17522
17526:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
17528:  MOVLW  01
1752A:  MOVLB  8
1752C:  ADDWF  x88,W
1752E:  MOVWF  x8A
17530:  MOVLW  00
17532:  ADDWFC x89,W
17534:  MOVWF  x8B
17536:  MOVWF  x8D
17538:  MOVFF  88A,88C
1753C:  MOVLB  0
1753E:  CALL   16808
17542:  MOVFF  01,885
....................          ++nv_sample;                     // increment sample number 
17546:  INCF   21,F
17548:  BTFSC  FD8.2
1754A:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
1754C:  MOVLW  16
1754E:  MOVLB  8
17550:  MOVWF  xEE
17552:  MOVFF  22,8F0
17556:  MOVFF  21,8EF
1755A:  MOVLB  0
1755C:  CALL   4FD4
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
17560:  MOVF   27,W
17562:  SUBWF  21,W
17564:  BNZ   1756C
17566:  MOVF   28,W
17568:  SUBWF  22,W
1756A:  BZ    17574
1756C:  MOVLB  8
1756E:  MOVF   x85,W
17570:  SUBLW  3B
17572:  BNZ   17578
17574:  MOVLB  8
17576:  BRA    17580
17578:  INCF   x88,F
1757A:  BTFSC  FD8.2
1757C:  INCF   x89,F
1757E:  BRA    174BE
17580:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
17582:  CALL   AE74
17586:  GOTO   175C2 (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
1758A:  MOVF   2F,W
1758C:  MOVWF  00
1758E:  MOVF   30,W
17590:  MOVWF  03
17592:  BNZ   17598
17594:  MOVF   00,F
17596:  BZ    175B8
17598:  MOVF   03,W
1759A:  BNZ   175A2
1759C:  MOVLW  01
1759E:  SUBWF  00,W
175A0:  BZ    175BC
175A2:  MOVF   03,W
175A4:  BNZ   175AC
175A6:  MOVLW  03
175A8:  SUBWF  00,W
175AA:  BZ    175BC
175AC:  MOVF   03,W
175AE:  BNZ   175B6
175B0:  MOVLW  02
175B2:  SUBWF  00,W
175B4:  BZ    175C0
175B6:  BRA    175C2
....................       case ECO : commandRe(); 
175B8:  BRA    17324
....................          break; 
175BA:  BRA    175C2
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
175BC:  BRA    17406
....................          break; 
175BE:  BRA    175C2
....................       case AWS : commandRa(); 
175C0:  BRA    17466
....................          break;          
....................    } 
175C2:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
175C6:  CALL   29C0
....................     
....................    switch(arg){ 
175CA:  MOVFF  48,00
175CE:  MOVF   49,W
175D0:  MOVWF  03
175D2:  BNZ   175DA
175D4:  MOVLW  01
175D6:  SUBWF  00,W
175D8:  BZ    175E6
175DA:  MOVF   03,W
175DC:  BNZ   175E4
175DE:  MOVLW  02
175E0:  SUBWF  00,W
175E2:  BZ    1762A
175E4:  BRA    1763A
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
175E6:  DECFSZ 45,W
175E8:  BRA    175FE
175EA:  MOVF   46,F
175EC:  BNZ   175FE
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
175EE:  MOVLB  8
175F0:  CLRF   xC2
175F2:  MOVLW  01
175F4:  MOVWF  xC3
175F6:  MOVLB  0
175F8:  CALL   136E6
....................       } 
175FC:  BRA    17628
....................       else if(nv_det_type==2 || nv_det_type==3) 
175FE:  MOVF   45,W
17600:  SUBLW  02
17602:  BNZ   17608
17604:  MOVF   46,F
17606:  BZ    17612
17608:  MOVF   45,W
1760A:  SUBLW  03
1760C:  BNZ   17628
1760E:  MOVF   46,F
17610:  BNZ   17628
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
17612:  MOVLB  8
17614:  CLRF   xC3
17616:  MOVLW  C8
17618:  MOVWF  xC2
1761A:  CLRF   xC4
1761C:  MOVLW  01
1761E:  MOVWF  xC5
17620:  CLRF   xC6
17622:  MOVLB  0
17624:  CALL   10000
....................       } 
....................       break;                                                        //200 scans,don't store,display 
17628:  BRA    1763E
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
1762A:  MOVLB  8
1762C:  CLRF   xC2
1762E:  MOVLW  01
17630:  MOVWF  xC3
17632:  MOVLB  0
17634:  CALL   139E8
....................       break; 
17638:  BRA    1763E
....................    default: cmd_arg(); 
1763A:  CALL   B2C2
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
1763E:  CALL   AE74
17642:  GOTO   176EE (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
17646:  MOVF   4B,F
17648:  BNZ   1767A
1764A:  MOVF   4A,F
1764C:  BNZ   1767A
1764E:  MOVF   49,W
17650:  SUBLW  04
17652:  BNC   1767A
17654:  BNZ   1765C
17656:  MOVF   48,W
17658:  SUBLW  00
1765A:  BNC   1767A
....................       nv_sample = arg; 
1765C:  MOVFF  49,22
17660:  MOVFF  48,21
....................       write16(ADDR_SAMPLE, nv_sample); 
17664:  MOVLW  16
17666:  MOVLB  8
17668:  MOVWF  xEE
1766A:  MOVFF  22,8F0
1766E:  MOVFF  21,8EF
17672:  MOVLB  0
17674:  CALL   4FD4
....................    } 
17678:  BRA    1767E
....................    else cmd_arg(); 
1767A:  CALL   B2C2
1767E:  GOTO   176EE (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
17682:  MOVF   4B,F
17684:  BNZ   176AE
17686:  MOVF   4A,F
17688:  BNZ   176AE
1768A:  MOVF   49,W
1768C:  SUBLW  01
1768E:  BNC   176AE
17690:  BNZ   17698
17692:  MOVF   48,W
17694:  SUBLW  02
17696:  BNC   176AE
....................       setting = arg; 
17698:  MOVFF  49,886
1769C:  MOVFF  48,885
....................       sol_switch_cmd(setting); 
176A0:  MOVFF  886,8B7
176A4:  MOVFF  885,8B6
176A8:  CALL   1446E
....................    } 
176AC:  BRA    176B2
....................    else cmd_arg(); 
176AE:  CALL   B2C2
176B2:  GOTO   176EE (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
176B6:  MOVF   2F,W
176B8:  MOVWF  00
176BA:  MOVF   30,W
176BC:  MOVWF  03
176BE:  BNZ   176C4
176C0:  MOVF   00,F
176C2:  BZ    176E4
176C4:  MOVF   03,W
176C6:  BNZ   176CE
176C8:  MOVLW  01
176CA:  SUBWF  00,W
176CC:  BZ    176E8
176CE:  MOVF   03,W
176D0:  BNZ   176D8
176D2:  MOVLW  03
176D4:  SUBWF  00,W
176D6:  BZ    176E8
176D8:  MOVF   03,W
176DA:  BNZ   176E2
176DC:  MOVLW  02
176DE:  SUBWF  00,W
176E0:  BZ    176EC
176E2:  BRA    176EE
....................       case ECO : commandSe(); 
176E4:  BRA    175C6
....................          break; 
176E6:  BRA    176EE
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
176E8:  BRA    17646
....................          break; 
176EA:  BRA    176EE
....................       case AWS : commandSa(); 
176EC:  BRA    17682
....................          break;          
....................    } 
176EE:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
17C54:  MOVLW  D6
17C56:  MOVWF  FF6
17C58:  MOVLW  26
17C5A:  MOVWF  FF7
17C5C:  MOVLW  00
17C5E:  MOVWF  FF8
17C60:  CLRF   1B
17C62:  BTFSC  FF2.7
17C64:  BSF    1B.7
17C66:  BCF    FF2.7
17C68:  CALL   0E4E
17C6C:  BTFSC  1B.7
17C6E:  BSF    FF2.7
....................    fputc('>',COM_A); 
17C70:  MOVLW  3E
17C72:  CALL   AE7C
....................    RTCfmt=fgetc(COM_A); 
17C76:  CALL   0E38
17C7A:  MOVFF  01,4F
....................    if (com_echo == TRUE) 
17C7E:  DECFSZ 4C,W
17C80:  BRA    17C88
....................       { 
....................       fputc(RTCfmt,COM_A); 
17C82:  MOVF   4F,W
17C84:  CALL   AE7C
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
17C88:  MOVLW  30
17C8A:  SUBWF  4F,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
17C8C:  MOVF   4F,W
17C8E:  SUBLW  01
17C90:  BNC   17CC6
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
17C92:  MOVLW  02
17C94:  MOVWF  FF6
17C96:  MOVLW  27
17C98:  MOVWF  FF7
17C9A:  MOVLW  00
17C9C:  MOVWF  FF8
17C9E:  CALL   AE4A
17CA2:  MOVLW  0D
17CA4:  BTFSS  F9E.4
17CA6:  BRA    17CA4
17CA8:  MOVWF  FAD
17CAA:  MOVLW  0A
17CAC:  BTFSS  F9E.4
17CAE:  BRA    17CAC
17CB0:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
17CB2:  MOVLW  1A
17CB4:  MOVLB  8
17CB6:  MOVWF  xEE
17CB8:  CLRF   xF0
17CBA:  MOVFF  4F,8EF
17CBE:  MOVLB  0
17CC0:  CALL   4FD4
....................       }  
17CC4:  BRA    17CCA
....................    else cmd_arg(); 
17CC6:  CALL   B2C2
....................     
....................    if(arg == 1) 
17CCA:  DECFSZ 48,W
17CCC:  BRA    17CDE
17CCE:  MOVF   49,F
17CD0:  BNZ   17CDE
17CD2:  MOVF   4A,F
17CD4:  BNZ   17CDE
17CD6:  MOVF   4B,F
17CD8:  BNZ   17CDE
....................    { 
....................       RTC_Set(); 
17CDA:  BRA    17B0A
....................    } 
17CDC:  BRA    17CE2
....................    else cmd_arg(); 
17CDE:  CALL   B2C2
17CE2:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
1865C:  MOVF   4B,F
1865E:  BNZ   1867A
18660:  MOVF   4A,F
18662:  BNZ   1867A
18664:  MOVF   49,F
18666:  BNZ   1867A
18668:  MOVF   48,W
1866A:  SUBLW  14
1866C:  BNC   1867A
....................       macro = arg; 
1866E:  MOVFF  48,885
....................       upload_macro(macro);    
18672:  MOVFF  885,886
18676:  BRA    183AA
....................    }    
18678:  BRA    18696
....................    else if (arg == 5525){ 
1867A:  MOVF   48,W
1867C:  SUBLW  95
1867E:  BNZ   18692
18680:  MOVF   49,W
18682:  SUBLW  15
18684:  BNZ   18692
18686:  MOVF   4A,F
18688:  BNZ   18692
1868A:  MOVF   4B,F
1868C:  BNZ   18692
....................       write_blank_macros(); 
1868E:  BRA    184E0
....................    } 
18690:  BRA    18696
....................    else cmd_arg(); 
18692:  CALL   B2C2
18696:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
187B4:  MOVF   4B,F
187B6:  BNZ   187D2
187B8:  MOVF   4A,F
187BA:  BNZ   187D2
187BC:  MOVF   49,F
187BE:  BNZ   187D2
187C0:  MOVF   48,W
187C2:  SUBLW  14
187C4:  BNC   187D2
....................       macro = arg;  
187C6:  MOVFF  48,885
....................       read_macro(macro); 
187CA:  MOVFF  885,886
187CE:  BRA    1874E
....................    }    
187D0:  BRA    187D6
....................    else cmd_arg(); 
187D2:  CALL   B2C2
187D6:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
18A4A:  DECFSZ 48,W
18A4C:  BRA    18A66
18A4E:  MOVF   49,F
18A50:  BNZ   18A66
18A52:  MOVF   4A,F
18A54:  BNZ   18A66
18A56:  MOVF   4B,F
18A58:  BNZ   18A66
....................       //fprintf(COM_A,"1\r\n"); 
....................       RTC_alarm(); 
18A5A:  BRA    188BA
....................       //fprintf(COM_A,"2\r\n"); 
....................       RTC_late(); 
18A5C:  CALL   15738
....................       //fprintf(COM_A,"3\r\n"); 
....................       RTC_alarm_status(); 
18A60:  CALL   15BFE
....................       //fprintf(COM_A,"4\r\n"); 
....................    } 
18A64:  BRA    18A6A
....................    else cmd_arg(); 
18A66:  CALL   B2C2
18A6A:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
18A6E:  MOVF   48,W
18A70:  MOVWF  00
18A72:  MOVF   49,W
18A74:  MOVWF  03
18A76:  BNZ   18A7C
18A78:  MOVF   00,F
18A7A:  BZ    18AB0
18A7C:  MOVF   03,W
18A7E:  BNZ   18A86
18A80:  MOVLW  02
18A82:  SUBWF  00,W
18A84:  BZ    18AB0
18A86:  MOVF   03,W
18A88:  BNZ   18A90
18A8A:  MOVLW  03
18A8C:  SUBWF  00,W
18A8E:  BZ    18AB0
18A90:  MOVF   03,W
18A92:  BNZ   18A9A
18A94:  MOVLW  04
18A96:  SUBWF  00,W
18A98:  BZ    18AB0
18A9A:  MOVF   03,W
18A9C:  BNZ   18AA4
18A9E:  MOVLW  05
18AA0:  SUBWF  00,W
18AA2:  BZ    18AB0
18AA4:  MOVF   03,W
18AA6:  BNZ   18AAE
18AA8:  MOVLW  06
18AAA:  SUBWF  00,W
18AAC:  BZ    18AB0
18AAE:  BRA    18ACE
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
18AB0:  MOVFF  49,20
18AB4:  MOVFF  48,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
18AB8:  MOVLW  1C
18ABA:  MOVLB  8
18ABC:  MOVWF  xEE
18ABE:  MOVFF  20,8F0
18AC2:  MOVFF  1F,8EF
18AC6:  MOVLB  0
18AC8:  CALL   4FD4
....................          break; 
18ACC:  BRA    18AD2
....................       default: cmd_arg(); 
18ACE:  CALL   B2C2
....................          break; 
....................    } 
18AD2:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
18AD6:  CALL   29C0
....................     
....................    switch(arg){ 
18ADA:  MOVFF  48,00
18ADE:  MOVF   49,W
18AE0:  MOVWF  03
18AE2:  BNZ   18AE8
18AE4:  MOVF   00,F
18AE6:  BZ    18B6C
18AE8:  MOVF   03,W
18AEA:  BNZ   18AF2
18AEC:  MOVLW  0A
18AEE:  SUBWF  00,W
18AF0:  BZ    18B6C
18AF2:  MOVF   03,W
18AF4:  BNZ   18AFC
18AF6:  MOVLW  01
18AF8:  SUBWF  00,W
18AFA:  BZ    18B74
18AFC:  MOVF   03,W
18AFE:  BNZ   18B06
18B00:  MOVLW  0B
18B02:  SUBWF  00,W
18B04:  BZ    18B74
18B06:  MOVF   03,W
18B08:  BNZ   18B10
18B0A:  MOVLW  14
18B0C:  SUBWF  00,W
18B0E:  BZ    18B7E
18B10:  MOVF   03,W
18B12:  BNZ   18B1A
18B14:  MOVLW  15
18B16:  SUBWF  00,W
18B18:  BZ    18B84
18B1A:  MOVF   03,W
18B1C:  BNZ   18B24
18B1E:  MOVLW  1E
18B20:  SUBWF  00,W
18B22:  BZ    18B8A
18B24:  MOVF   03,W
18B26:  BNZ   18B2E
18B28:  MOVLW  1F
18B2A:  SUBWF  00,W
18B2C:  BZ    18B90
18B2E:  MOVF   03,W
18B30:  BNZ   18B38
18B32:  MOVLW  28
18B34:  SUBWF  00,W
18B36:  BZ    18B96
18B38:  MOVF   03,W
18B3A:  BNZ   18B42
18B3C:  MOVLW  29
18B3E:  SUBWF  00,W
18B40:  BZ    18B9C
18B42:  MOVF   03,W
18B44:  BNZ   18B4C
18B46:  MOVLW  32
18B48:  SUBWF  00,W
18B4A:  BZ    18BA2
18B4C:  MOVF   03,W
18B4E:  BNZ   18B56
18B50:  MOVLW  33
18B52:  SUBWF  00,W
18B54:  BZ    18BA8
18B56:  MOVF   03,W
18B58:  BNZ   18B60
18B5A:  MOVLW  3C
18B5C:  SUBWF  00,W
18B5E:  BZ    18BAE
18B60:  MOVF   03,W
18B62:  BNZ   18B6A
18B64:  MOVLW  3D
18B66:  SUBWF  00,W
18B68:  BZ    18BBC
18B6A:  BRA    18BCE
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
18B6C:  BCF    F90.7
....................                bus_pwr_status=0; 
18B6E:  MOVLB  4
18B70:  CLRF   xB6
....................          break; 
18B72:  BRA    18BD4
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18B74:  BSF    F90.7
....................                bus_pwr_status=1; 
18B76:  MOVLW  01
18B78:  MOVLB  4
18B7A:  MOVWF  xB6
....................          break; 
18B7C:  BRA    18BD4
....................       case 20: output_bit(VMOT,OFF); 
18B7E:  BCF    F8E.1
....................          break; 
18B80:  MOVLB  4
18B82:  BRA    18BD4
....................       case 21: output_bit(VMOT,ON); 
18B84:  BSF    F8E.1
....................          break; 
18B86:  MOVLB  4
18B88:  BRA    18BD4
....................       case 30: output_bit(VENC1,OFF); 
18B8A:  BCF    F8E.6
....................          break; 
18B8C:  MOVLB  4
18B8E:  BRA    18BD4
....................       case 31: output_bit(VENC1,ON); 
18B90:  BSF    F8E.6
....................          break; 
18B92:  MOVLB  4
18B94:  BRA    18BD4
....................       case 40: output_bit(VENC2,OFF); 
18B96:  BCF    F8E.7
....................          break; 
18B98:  MOVLB  4
18B9A:  BRA    18BD4
....................       case 41: output_bit(VENC2,ON); 
18B9C:  BSF    F8E.7
....................          break; 
18B9E:  MOVLB  4
18BA0:  BRA    18BD4
....................       case 50: output_bit(VHBRDG,OFF); 
18BA2:  BCF    F8E.2
....................          break; 
18BA4:  MOVLB  4
18BA6:  BRA    18BD4
....................       case 51: output_bit(VHBRDG,ON); 
18BA8:  BSF    F8E.2
....................          break;          
18BAA:  MOVLB  4
18BAC:  BRA    18BD4
....................       case 60: set_heaters(0); 
18BAE:  MOVLB  8
18BB0:  CLRF   xC5
18BB2:  MOVLB  0
18BB4:  CALL   126C6
....................          break; 
18BB8:  MOVLB  4
18BBA:  BRA    18BD4
....................       case 61: set_heaters(3); 
18BBC:  MOVLW  03
18BBE:  MOVLB  8
18BC0:  MOVWF  xC5
18BC2:  MOVLB  0
18BC4:  CALL   126C6
....................          break; 
18BC8:  MOVLB  4
18BCA:  BRA    18BD4
18BCC:  MOVLB  0
....................       default : cmd_arg(); 
18BCE:  CALL   B2C2
....................          break;          
18BD2:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
18BD4:  MOVLB  0
18BD6:  CALL   AE74
18BDA:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
18BDE:  MOVF   48,F
18BE0:  BNZ   18BFC
18BE2:  MOVF   49,F
18BE4:  BNZ   18BFC
18BE6:  MOVF   4A,F
18BE8:  BNZ   18BFC
18BEA:  MOVF   4B,F
18BEC:  BNZ   18BFC
....................       motor_sleep_rdy(); 
18BEE:  CALL   2998
....................       shutdown(); 
18BF2:  CALL   15C20
....................       go_to_sleep(); 
18BF6:  CALL   15E8C
....................    } 
18BFA:  BRA    18C00
....................    else cmd_arg(); 
18BFC:  CALL   B2C2
18C00:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
18D2E:  DECFSZ 48,W
18D30:  BRA    18D42
18D32:  MOVF   49,F
18D34:  BNZ   18D42
18D36:  MOVF   4A,F
18D38:  BNZ   18D42
18D3A:  MOVF   4B,F
18D3C:  BNZ   18D42
18D3E:  BRA    18C28
18D40:  BRA    18D46
....................    else cmd_arg(); 
18D42:  CALL   B2C2
18D46:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
18D4A:  MOVF   4B,F
18D4C:  BNZ   18DDC
18D4E:  MOVF   4A,F
18D50:  BNZ   18DDC
18D52:  MOVF   49,W
18D54:  SUBLW  27
18D56:  BNC   18DDC
18D58:  BNZ   18D60
18D5A:  MOVF   48,W
18D5C:  SUBLW  10
18D5E:  BNC   18DDC
....................       m_bklsh[motor] = arg; 
18D60:  BCF    FD8.0
18D62:  MOVLB  7
18D64:  RLCF   x40,W
18D66:  CLRF   03
18D68:  ADDLW  72
18D6A:  MOVWF  FE9
18D6C:  MOVLW  07
18D6E:  ADDWFC 03,W
18D70:  MOVWF  FEA
18D72:  MOVFF  48,FEF
18D76:  MOVFF  49,FEC
....................       switch(motor){ 
18D7A:  MOVF   x40,W
18D7C:  XORLW  00
18D7E:  MOVLB  0
18D80:  BZ    18D88
18D82:  XORLW  01
18D84:  BZ    18DB2
18D86:  BRA    18DDA
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
18D88:  BCF    FD8.0
18D8A:  MOVLB  7
18D8C:  RLCF   x40,W
18D8E:  CLRF   03
18D90:  ADDLW  72
18D92:  MOVWF  FE9
18D94:  MOVLW  07
18D96:  ADDWFC 03,W
18D98:  MOVWF  FEA
18D9A:  MOVFF  FEC,8F0
18D9E:  MOVF   FED,F
18DA0:  MOVFF  FEF,8EF
18DA4:  MOVLW  72
18DA6:  MOVLB  8
18DA8:  MOVWF  xEE
18DAA:  MOVLB  0
18DAC:  CALL   4FD4
....................             break; 
18DB0:  BRA    18DDA
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
18DB2:  BCF    FD8.0
18DB4:  MOVLB  7
18DB6:  RLCF   x40,W
18DB8:  CLRF   03
18DBA:  ADDLW  72
18DBC:  MOVWF  FE9
18DBE:  MOVLW  07
18DC0:  ADDWFC 03,W
18DC2:  MOVWF  FEA
18DC4:  MOVFF  FEC,8F0
18DC8:  MOVF   FED,F
18DCA:  MOVFF  FEF,8EF
18DCE:  MOVLW  74
18DD0:  MOVLB  8
18DD2:  MOVWF  xEE
18DD4:  MOVLB  0
18DD6:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
18DDA:  BRA    18DE0
....................    else cmd_arg();    
18DDC:  CALL   B2C2
18DE0:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_c(){ 
....................    if(arg == 0){ 
18DE4:  MOVF   48,F
18DE6:  BNZ   18DF8
18DE8:  MOVF   49,F
18DEA:  BNZ   18DF8
18DEC:  MOVF   4A,F
18DEE:  BNZ   18DF8
18DF0:  MOVF   4B,F
18DF2:  BNZ   18DF8
....................       output_bit(PIN_J7,0); 
18DF4:  BCF    F91.7
....................    }else if(arg == 1){ 
18DF6:  BRA    18E28
18DF8:  DECFSZ 48,W
18DFA:  BRA    18E0C
18DFC:  MOVF   49,F
18DFE:  BNZ   18E0C
18E00:  MOVF   4A,F
18E02:  BNZ   18E0C
18E04:  MOVF   4B,F
18E06:  BNZ   18E0C
....................       output_bit(PIN_J7,1); 
18E08:  BSF    F91.7
....................    }else{ 
18E0A:  BRA    18E28
....................       RTC_reset_HT(); 
18E0C:  CALL   34B2
....................       output_bit(RTC_CS, ENABLE); 
18E10:  BCF    F91.0
....................       spi_write(0x89); 
18E12:  MOVF   FC9,W
18E14:  MOVLW  89
18E16:  MOVWF  FC9
18E18:  RRCF   FC7,W
18E1A:  BNC   18E18
....................       spi_write(arg); 
18E1C:  MOVF   FC9,W
18E1E:  MOVFF  48,FC9
18E22:  RRCF   FC7,W
18E24:  BNC   18E22
....................       output_bit(RTC_CS, DISABLE); 
18E26:  BSF    F91.0
....................    } 
18E28:  GOTO   1B2FE (RETURN)
.................... } 
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
18E2C:  MOVF   4B,F
18E2E:  BNZ   18EBA
18E30:  MOVF   4A,F
18E32:  BNZ   18EBA
18E34:  MOVF   49,F
18E36:  BNZ   18EBA
18E38:  MOVF   48,W
18E3A:  SUBLW  01
18E3C:  BNC   18EBA
....................       m_pos_dir[motor] = arg; 
18E3E:  BCF    FD8.0
18E40:  MOVLB  7
18E42:  RLCF   x40,W
18E44:  CLRF   03
18E46:  ADDLW  4E
18E48:  MOVWF  FE9
18E4A:  MOVLW  07
18E4C:  ADDWFC 03,W
18E4E:  MOVWF  FEA
18E50:  MOVFF  48,FEF
18E54:  MOVFF  49,FEC
....................       switch(motor){ 
18E58:  MOVF   x40,W
18E5A:  XORLW  00
18E5C:  MOVLB  0
18E5E:  BZ    18E66
18E60:  XORLW  01
18E62:  BZ    18E90
18E64:  BRA    18EB8
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
18E66:  BCF    FD8.0
18E68:  MOVLB  7
18E6A:  RLCF   x40,W
18E6C:  CLRF   03
18E6E:  ADDLW  4E
18E70:  MOVWF  FE9
18E72:  MOVLW  07
18E74:  ADDWFC 03,W
18E76:  MOVWF  FEA
18E78:  MOVFF  FEC,8F0
18E7C:  MOVF   FED,F
18E7E:  MOVFF  FEF,8EF
18E82:  MOVLW  92
18E84:  MOVLB  8
18E86:  MOVWF  xEE
18E88:  MOVLB  0
18E8A:  CALL   4FD4
....................             break; 
18E8E:  BRA    18EB8
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
18E90:  BCF    FD8.0
18E92:  MOVLB  7
18E94:  RLCF   x40,W
18E96:  CLRF   03
18E98:  ADDLW  4E
18E9A:  MOVWF  FE9
18E9C:  MOVLW  07
18E9E:  ADDWFC 03,W
18EA0:  MOVWF  FEA
18EA2:  MOVFF  FEC,8F0
18EA6:  MOVF   FED,F
18EA8:  MOVFF  FEF,8EF
18EAC:  MOVLW  94
18EAE:  MOVLB  8
18EB0:  MOVWF  xEE
18EB2:  MOVLB  0
18EB4:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
18EB8:  BRA    18EBE
....................    else cmd_arg();    
18EBA:  CALL   B2C2
18EBE:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
18EC2:  MOVF   4B,F
18EC4:  BNZ   18F54
18EC6:  MOVF   4A,F
18EC8:  BNZ   18F54
18ECA:  MOVF   49,W
18ECC:  SUBLW  27
18ECE:  BNC   18F54
18ED0:  BNZ   18ED8
18ED2:  MOVF   48,W
18ED4:  SUBLW  10
18ED6:  BNC   18F54
....................       e_cpr[motor] = arg; 
18ED8:  BCF    FD8.0
18EDA:  MOVLB  7
18EDC:  RLCF   x40,W
18EDE:  CLRF   03
18EE0:  ADDLW  5E
18EE2:  MOVWF  FE9
18EE4:  MOVLW  07
18EE6:  ADDWFC 03,W
18EE8:  MOVWF  FEA
18EEA:  MOVFF  48,FEF
18EEE:  MOVFF  49,FEC
....................       switch(motor){ 
18EF2:  MOVF   x40,W
18EF4:  XORLW  00
18EF6:  MOVLB  0
18EF8:  BZ    18F00
18EFA:  XORLW  01
18EFC:  BZ    18F2A
18EFE:  BRA    18F52
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
18F00:  BCF    FD8.0
18F02:  MOVLB  7
18F04:  RLCF   x40,W
18F06:  CLRF   03
18F08:  ADDLW  5E
18F0A:  MOVWF  FE9
18F0C:  MOVLW  07
18F0E:  ADDWFC 03,W
18F10:  MOVWF  FEA
18F12:  MOVFF  FEC,8F0
18F16:  MOVF   FED,F
18F18:  MOVFF  FEF,8EF
18F1C:  MOVLW  A2
18F1E:  MOVLB  8
18F20:  MOVWF  xEE
18F22:  MOVLB  0
18F24:  CALL   4FD4
....................             break; 
18F28:  BRA    18F52
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
18F2A:  BCF    FD8.0
18F2C:  MOVLB  7
18F2E:  RLCF   x40,W
18F30:  CLRF   03
18F32:  ADDLW  5E
18F34:  MOVWF  FE9
18F36:  MOVLW  07
18F38:  ADDWFC 03,W
18F3A:  MOVWF  FEA
18F3C:  MOVFF  FEC,8F0
18F40:  MOVF   FED,F
18F42:  MOVFF  FEF,8EF
18F46:  MOVLW  A4
18F48:  MOVLB  8
18F4A:  MOVWF  xEE
18F4C:  MOVLB  0
18F4E:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
18F52:  BRA    18F58
....................    else cmd_arg();    
18F54:  CALL   B2C2
18F58:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18F5C:  MOVF   4B,F
18F5E:  BNZ   18F74
18F60:  MOVF   4A,F
18F62:  BNZ   18F74
18F64:  MOVF   49,F
18F66:  BNZ   18F74
18F68:  MOVF   48,W
18F6A:  SUBLW  01
18F6C:  BNC   18F74
18F6E:  MOVFF  48,741
18F72:  BRA    18F78
....................    else cmd_arg();    
18F74:  CALL   B2C2
18F78:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18F7C:  MOVF   4B,F
18F7E:  BNZ   1900E
18F80:  MOVF   4A,F
18F82:  BNZ   1900E
18F84:  MOVF   49,W
18F86:  SUBLW  EA
18F88:  BNC   1900E
18F8A:  BNZ   18F92
18F8C:  MOVF   48,W
18F8E:  SUBLW  60
18F90:  BNC   1900E
....................       m_gb_err[motor] = arg; 
18F92:  BCF    FD8.0
18F94:  MOVLB  7
18F96:  RLCF   x40,W
18F98:  CLRF   03
18F9A:  ADDLW  5A
18F9C:  MOVWF  FE9
18F9E:  MOVLW  07
18FA0:  ADDWFC 03,W
18FA2:  MOVWF  FEA
18FA4:  MOVFF  48,FEF
18FA8:  MOVFF  49,FEC
....................       switch(motor){ 
18FAC:  MOVF   x40,W
18FAE:  XORLW  00
18FB0:  MOVLB  0
18FB2:  BZ    18FBA
18FB4:  XORLW  01
18FB6:  BZ    18FE4
18FB8:  BRA    1900C
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18FBA:  BCF    FD8.0
18FBC:  MOVLB  7
18FBE:  RLCF   x40,W
18FC0:  CLRF   03
18FC2:  ADDLW  5A
18FC4:  MOVWF  FE9
18FC6:  MOVLW  07
18FC8:  ADDWFC 03,W
18FCA:  MOVWF  FEA
18FCC:  MOVFF  FEC,8F0
18FD0:  MOVF   FED,F
18FD2:  MOVFF  FEF,8EF
18FD6:  MOVLW  9E
18FD8:  MOVLB  8
18FDA:  MOVWF  xEE
18FDC:  MOVLB  0
18FDE:  CALL   4FD4
....................             break; 
18FE2:  BRA    1900C
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
18FE4:  BCF    FD8.0
18FE6:  MOVLB  7
18FE8:  RLCF   x40,W
18FEA:  CLRF   03
18FEC:  ADDLW  5A
18FEE:  MOVWF  FE9
18FF0:  MOVLW  07
18FF2:  ADDWFC 03,W
18FF4:  MOVWF  FEA
18FF6:  MOVFF  FEC,8F0
18FFA:  MOVF   FED,F
18FFC:  MOVFF  FEF,8EF
19000:  MOVLW  A0
19002:  MOVLB  8
19004:  MOVWF  xEE
19006:  MOVLB  0
19008:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1900C:  BRA    19012
....................    else cmd_arg();    
1900E:  CALL   B2C2
19012:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
19016:  MOVF   4B,F
19018:  BNZ   190E2
1901A:  MOVF   4A,F
1901C:  BNZ   190E2
1901E:  MOVF   49,F
19020:  BNZ   190E2
19022:  MOVF   48,W
19024:  SUBLW  64
19026:  BNC   190E2
....................       hold_pc=arg; 
19028:  MOVFF  49,886
1902C:  MOVFF  48,885
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
19030:  BCF    FD8.0
19032:  MOVLB  7
19034:  RLCF   x40,W
19036:  CLRF   03
19038:  ADDLW  52
1903A:  MOVWF  FE9
1903C:  MOVLW  07
1903E:  ADDWFC 03,W
19040:  MOVWF  FEA
19042:  MOVFF  886,A11
19046:  MOVFF  885,A10
1904A:  MOVLW  01
1904C:  MOVLB  A
1904E:  MOVWF  x13
19050:  SETF   x12
19052:  MOVLB  0
19054:  CALL   5C98
19058:  MOVFF  02,88A
1905C:  MOVFF  01,889
19060:  MOVFF  02,8DC
19064:  MOVFF  01,8DB
19068:  MOVLB  8
1906A:  CLRF   xDE
1906C:  MOVLW  64
1906E:  MOVWF  xDD
19070:  MOVLB  0
19072:  CALL   2CD4
19076:  MOVFF  01,FEF
1907A:  MOVFF  02,FEC
....................       switch(motor){ 
1907E:  MOVLB  7
19080:  MOVF   x40,W
19082:  XORLW  00
19084:  MOVLB  0
19086:  BZ    1908E
19088:  XORLW  01
1908A:  BZ    190B8
1908C:  BRA    190E0
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
1908E:  BCF    FD8.0
19090:  MOVLB  7
19092:  RLCF   x40,W
19094:  CLRF   03
19096:  ADDLW  52
19098:  MOVWF  FE9
1909A:  MOVLW  07
1909C:  ADDWFC 03,W
1909E:  MOVWF  FEA
190A0:  MOVFF  FEC,8F0
190A4:  MOVF   FED,F
190A6:  MOVFF  FEF,8EF
190AA:  MOVLW  96
190AC:  MOVLB  8
190AE:  MOVWF  xEE
190B0:  MOVLB  0
190B2:  CALL   4FD4
....................             break; 
190B6:  BRA    190E0
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
190B8:  BCF    FD8.0
190BA:  MOVLB  7
190BC:  RLCF   x40,W
190BE:  CLRF   03
190C0:  ADDLW  52
190C2:  MOVWF  FE9
190C4:  MOVLW  07
190C6:  ADDWFC 03,W
190C8:  MOVWF  FEA
190CA:  MOVFF  FEC,8F0
190CE:  MOVF   FED,F
190D0:  MOVFF  FEF,8EF
190D4:  MOVLW  98
190D6:  MOVLB  8
190D8:  MOVWF  xEE
190DA:  MOVLB  0
190DC:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
190E0:  BRA    190E6
....................    else cmd_arg();    
190E2:  CALL   B2C2
190E6:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
190EA:  MOVF   4B,F
190EC:  BNZ   191BE
190EE:  MOVF   4A,F
190F0:  BNZ   191BE
190F2:  MOVF   49,W
190F4:  SUBLW  EA
190F6:  BNC   191BE
190F8:  BNZ   19100
190FA:  MOVF   48,W
190FC:  SUBLW  60
190FE:  BNC   191BE
....................       m_stp_int[motor] = (arg/100); 
19100:  BCF    FD8.0
19102:  MOVLB  7
19104:  RLCF   x40,W
19106:  CLRF   03
19108:  ADDLW  4A
1910A:  MOVWF  FE9
1910C:  MOVLW  07
1910E:  ADDWFC 03,W
19110:  MOVWF  FEA
19112:  MOVFF  FEA,888
19116:  MOVFF  FE9,887
1911A:  BCF    FD8.1
1911C:  CLRF   1B
1911E:  BTFSC  FF2.7
19120:  BSF    1B.7
19122:  BCF    FF2.7
19124:  MOVFF  4B,A4F
19128:  MOVFF  4A,A4E
1912C:  MOVFF  49,A4D
19130:  MOVFF  48,A4C
19134:  MOVLB  A
19136:  CLRF   x53
19138:  CLRF   x52
1913A:  CLRF   x51
1913C:  MOVLW  64
1913E:  MOVWF  x50
19140:  MOVLB  0
19142:  CALL   1056
19146:  BTFSC  1B.7
19148:  BSF    FF2.7
1914A:  MOVFF  888,FEA
1914E:  MOVFF  887,FE9
19152:  MOVFF  00,FEF
19156:  MOVFF  01,FEC
....................       switch(motor){ 
1915A:  MOVLB  7
1915C:  MOVF   x40,W
1915E:  XORLW  00
19160:  MOVLB  0
19162:  BZ    1916A
19164:  XORLW  01
19166:  BZ    19194
19168:  BRA    191BC
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
1916A:  BCF    FD8.0
1916C:  MOVLB  7
1916E:  RLCF   x40,W
19170:  CLRF   03
19172:  ADDLW  4A
19174:  MOVWF  FE9
19176:  MOVLW  07
19178:  ADDWFC 03,W
1917A:  MOVWF  FEA
1917C:  MOVFF  FEC,8F0
19180:  MOVF   FED,F
19182:  MOVFF  FEF,8EF
19186:  MOVLW  8E
19188:  MOVLB  8
1918A:  MOVWF  xEE
1918C:  MOVLB  0
1918E:  CALL   4FD4
....................             break; 
19192:  BRA    191BC
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
19194:  BCF    FD8.0
19196:  MOVLB  7
19198:  RLCF   x40,W
1919A:  CLRF   03
1919C:  ADDLW  4A
1919E:  MOVWF  FE9
191A0:  MOVLW  07
191A2:  ADDWFC 03,W
191A4:  MOVWF  FEA
191A6:  MOVFF  FEC,8F0
191AA:  MOVF   FED,F
191AC:  MOVFF  FEF,8EF
191B0:  MOVLW  90
191B2:  MOVLB  8
191B4:  MOVWF  xEE
191B6:  MOVLB  0
191B8:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
191BC:  BRA    191C2
....................    else cmd_arg();    
191BE:  CALL   B2C2
191C2:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
191C6:  MOVF   4B,F
191C8:  BNZ   19258
191CA:  MOVF   4A,F
191CC:  BNZ   19258
191CE:  MOVF   49,W
191D0:  SUBLW  27
191D2:  BNC   19258
191D4:  BNZ   191DC
191D6:  MOVF   48,W
191D8:  SUBLW  10
191DA:  BNC   19258
....................       m_run[motor] = arg; 
191DC:  BCF    FD8.0
191DE:  MOVLB  7
191E0:  RLCF   x40,W
191E2:  CLRF   03
191E4:  ADDLW  6E
191E6:  MOVWF  FE9
191E8:  MOVLW  07
191EA:  ADDWFC 03,W
191EC:  MOVWF  FEA
191EE:  MOVFF  48,FEF
191F2:  MOVFF  49,FEC
....................       switch(motor){ 
191F6:  MOVF   x40,W
191F8:  XORLW  00
191FA:  MOVLB  0
191FC:  BZ    19204
191FE:  XORLW  01
19200:  BZ    1922E
19202:  BRA    19256
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
19204:  BCF    FD8.0
19206:  MOVLB  7
19208:  RLCF   x40,W
1920A:  CLRF   03
1920C:  ADDLW  6E
1920E:  MOVWF  FE9
19210:  MOVLW  07
19212:  ADDWFC 03,W
19214:  MOVWF  FEA
19216:  MOVFF  FEC,8F0
1921A:  MOVF   FED,F
1921C:  MOVFF  FEF,8EF
19220:  MOVLW  76
19222:  MOVLB  8
19224:  MOVWF  xEE
19226:  MOVLB  0
19228:  CALL   4FD4
....................             break; 
1922C:  BRA    19256
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
1922E:  BCF    FD8.0
19230:  MOVLB  7
19232:  RLCF   x40,W
19234:  CLRF   03
19236:  ADDLW  6E
19238:  MOVWF  FE9
1923A:  MOVLW  07
1923C:  ADDWFC 03,W
1923E:  MOVWF  FEA
19240:  MOVFF  FEC,8F0
19244:  MOVF   FED,F
19246:  MOVFF  FEF,8EF
1924A:  MOVLW  78
1924C:  MOVLB  8
1924E:  MOVWF  xEE
19250:  MOVLB  0
19252:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
19256:  BRA    1925C
....................    else cmd_arg();    
19258:  CALL   B2C2
1925C:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
19260:  MOVF   4B,F
19262:  BNZ   192EE
19264:  MOVF   4A,F
19266:  BNZ   192EE
19268:  MOVF   49,F
1926A:  BNZ   192EE
1926C:  MOVF   48,W
1926E:  SUBLW  03
19270:  BNC   192EE
....................       e_mode[motor] = arg; 
19272:  BCF    FD8.0
19274:  MOVLB  7
19276:  RLCF   x40,W
19278:  CLRF   03
1927A:  ADDLW  66
1927C:  MOVWF  FE9
1927E:  MOVLW  07
19280:  ADDWFC 03,W
19282:  MOVWF  FEA
19284:  MOVFF  48,FEF
19288:  MOVFF  49,FEC
....................       switch(motor){ 
1928C:  MOVF   x40,W
1928E:  XORLW  00
19290:  MOVLB  0
19292:  BZ    1929A
19294:  XORLW  01
19296:  BZ    192C4
19298:  BRA    192EC
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
1929A:  BCF    FD8.0
1929C:  MOVLB  7
1929E:  RLCF   x40,W
192A0:  CLRF   03
192A2:  ADDLW  66
192A4:  MOVWF  FE9
192A6:  MOVLW  07
192A8:  ADDWFC 03,W
192AA:  MOVWF  FEA
192AC:  MOVFF  FEC,8F0
192B0:  MOVF   FED,F
192B2:  MOVFF  FEF,8EF
192B6:  MOVLW  82
192B8:  MOVLB  8
192BA:  MOVWF  xEE
192BC:  MOVLB  0
192BE:  CALL   4FD4
....................             break; 
192C2:  BRA    192EC
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
192C4:  BCF    FD8.0
192C6:  MOVLB  7
192C8:  RLCF   x40,W
192CA:  CLRF   03
192CC:  ADDLW  66
192CE:  MOVWF  FE9
192D0:  MOVLW  07
192D2:  ADDWFC 03,W
192D4:  MOVWF  FEA
192D6:  MOVFF  FEC,8F0
192DA:  MOVF   FED,F
192DC:  MOVFF  FEF,8EF
192E0:  MOVLW  84
192E2:  MOVLB  8
192E4:  MOVWF  xEE
192E6:  MOVLB  0
192E8:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
192EC:  BRA    192F2
....................    else cmd_arg();    
192EE:  CALL   B2C2
192F2:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
19F56:  MOVF   4B,F
19F58:  BNZ   19FE4
19F5A:  MOVF   4A,F
19F5C:  BNZ   19FE4
19F5E:  MOVF   49,F
19F60:  BNZ   19FE4
19F62:  MOVF   48,W
19F64:  SUBLW  01
19F66:  BNC   19FE4
....................       m_mode[motor] = arg; 
19F68:  BCF    FD8.0
19F6A:  MOVLB  7
19F6C:  RLCF   x40,W
19F6E:  CLRF   03
19F70:  ADDLW  46
19F72:  MOVWF  FE9
19F74:  MOVLW  07
19F76:  ADDWFC 03,W
19F78:  MOVWF  FEA
19F7A:  MOVFF  48,FEF
19F7E:  MOVFF  49,FEC
....................       switch(motor){ 
19F82:  MOVF   x40,W
19F84:  XORLW  00
19F86:  MOVLB  0
19F88:  BZ    19F90
19F8A:  XORLW  01
19F8C:  BZ    19FBA
19F8E:  BRA    19FE2
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19F90:  BCF    FD8.0
19F92:  MOVLB  7
19F94:  RLCF   x40,W
19F96:  CLRF   03
19F98:  ADDLW  46
19F9A:  MOVWF  FE9
19F9C:  MOVLW  07
19F9E:  ADDWFC 03,W
19FA0:  MOVWF  FEA
19FA2:  MOVFF  FEC,8F0
19FA6:  MOVF   FED,F
19FA8:  MOVFF  FEF,8EF
19FAC:  MOVLW  8A
19FAE:  MOVLB  8
19FB0:  MOVWF  xEE
19FB2:  MOVLB  0
19FB4:  CALL   4FD4
....................             break; 
19FB8:  BRA    19FE2
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19FBA:  BCF    FD8.0
19FBC:  MOVLB  7
19FBE:  RLCF   x40,W
19FC0:  CLRF   03
19FC2:  ADDLW  46
19FC4:  MOVWF  FE9
19FC6:  MOVLW  07
19FC8:  ADDWFC 03,W
19FCA:  MOVWF  FEA
19FCC:  MOVFF  FEC,8F0
19FD0:  MOVF   FED,F
19FD2:  MOVFF  FEF,8EF
19FD6:  MOVLW  8C
19FD8:  MOVLB  8
19FDA:  MOVWF  xEE
19FDC:  MOVLB  0
19FDE:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
19FE2:  BRA    19FE8
....................    else cmd_arg();    
19FE4:  CALL   B2C2
19FE8:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19FEC:  MOVF   4B,F
19FEE:  BNZ   1A07A
19FF0:  MOVF   4A,F
19FF2:  BNZ   1A07A
19FF4:  MOVF   49,F
19FF6:  BNZ   1A07A
19FF8:  MOVF   48,W
19FFA:  SUBLW  01
19FFC:  BNC   1A07A
....................       e_index[motor] = arg; 
19FFE:  BCF    FD8.0
1A000:  MOVLB  7
1A002:  RLCF   x40,W
1A004:  CLRF   03
1A006:  ADDLW  7A
1A008:  MOVWF  FE9
1A00A:  MOVLW  07
1A00C:  ADDWFC 03,W
1A00E:  MOVWF  FEA
1A010:  MOVFF  48,FEF
1A014:  MOVFF  49,FEC
....................       switch(motor){ 
1A018:  MOVF   x40,W
1A01A:  XORLW  00
1A01C:  MOVLB  0
1A01E:  BZ    1A026
1A020:  XORLW  01
1A022:  BZ    1A050
1A024:  BRA    1A078
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
1A026:  BCF    FD8.0
1A028:  MOVLB  7
1A02A:  RLCF   x40,W
1A02C:  CLRF   03
1A02E:  ADDLW  7A
1A030:  MOVWF  FE9
1A032:  MOVLW  07
1A034:  ADDWFC 03,W
1A036:  MOVWF  FEA
1A038:  MOVFF  FEC,8F0
1A03C:  MOVF   FED,F
1A03E:  MOVFF  FEF,8EF
1A042:  MOVLW  BA
1A044:  MOVLB  8
1A046:  MOVWF  xEE
1A048:  MOVLB  0
1A04A:  CALL   4FD4
....................             break; 
1A04E:  BRA    1A078
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
1A050:  BCF    FD8.0
1A052:  MOVLB  7
1A054:  RLCF   x40,W
1A056:  CLRF   03
1A058:  ADDLW  7A
1A05A:  MOVWF  FE9
1A05C:  MOVLW  07
1A05E:  ADDWFC 03,W
1A060:  MOVWF  FEA
1A062:  MOVFF  FEC,8F0
1A066:  MOVF   FED,F
1A068:  MOVFF  FEF,8EF
1A06C:  MOVLW  BC
1A06E:  MOVLB  8
1A070:  MOVWF  xEE
1A072:  MOVLB  0
1A074:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1A078:  BRA    1A07E
....................    else cmd_arg();    
1A07A:  CALL   B2C2
1A07E:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
1A082:  MOVF   4B,F
1A084:  BNZ   1A114
1A086:  MOVF   4A,F
1A088:  BNZ   1A114
1A08A:  MOVF   49,W
1A08C:  SUBLW  01
1A08E:  BNC   1A114
1A090:  BNZ   1A098
1A092:  MOVF   48,W
1A094:  SUBLW  0A
1A096:  BNC   1A114
....................        evn_so[motor] = arg; 
1A098:  BCF    FD8.0
1A09A:  MOVLB  7
1A09C:  RLCF   x40,W
1A09E:  CLRF   03
1A0A0:  ADDLW  7E
1A0A2:  MOVWF  FE9
1A0A4:  MOVLW  07
1A0A6:  ADDWFC 03,W
1A0A8:  MOVWF  FEA
1A0AA:  MOVFF  48,FEF
1A0AE:  MOVFF  49,FEC
....................        switch(motor){ 
1A0B2:  MOVF   x40,W
1A0B4:  XORLW  00
1A0B6:  MOVLB  0
1A0B8:  BZ    1A0C0
1A0BA:  XORLW  01
1A0BC:  BZ    1A0EA
1A0BE:  BRA    1A112
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
1A0C0:  BCF    FD8.0
1A0C2:  MOVLB  7
1A0C4:  RLCF   x40,W
1A0C6:  CLRF   03
1A0C8:  ADDLW  7E
1A0CA:  MOVWF  FE9
1A0CC:  MOVLW  07
1A0CE:  ADDWFC 03,W
1A0D0:  MOVWF  FEA
1A0D2:  MOVFF  FEC,8F0
1A0D6:  MOVF   FED,F
1A0D8:  MOVFF  FEF,8EF
1A0DC:  MOVLW  BE
1A0DE:  MOVLB  8
1A0E0:  MOVWF  xEE
1A0E2:  MOVLB  0
1A0E4:  CALL   4FD4
....................             break; 
1A0E8:  BRA    1A112
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
1A0EA:  BCF    FD8.0
1A0EC:  MOVLB  7
1A0EE:  RLCF   x40,W
1A0F0:  CLRF   03
1A0F2:  ADDLW  7E
1A0F4:  MOVWF  FE9
1A0F6:  MOVLW  07
1A0F8:  ADDWFC 03,W
1A0FA:  MOVWF  FEA
1A0FC:  MOVFF  FEC,8F0
1A100:  MOVF   FED,F
1A102:  MOVFF  FEF,8EF
1A106:  MOVLW  C0
1A108:  MOVLB  8
1A10A:  MOVWF  xEE
1A10C:  MOVLB  0
1A10E:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1A112:  BRA    1A118
....................    else cmd_arg();    
1A114:  CALL   B2C2
1A118:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
1A11C:  MOVF   4B,F
1A11E:  BNZ   1A1AE
1A120:  MOVF   4A,F
1A122:  BNZ   1A1AE
1A124:  MOVF   49,W
1A126:  SUBLW  03
1A128:  BNC   1A1AE
1A12A:  BNZ   1A132
1A12C:  MOVF   48,W
1A12E:  SUBLW  E8
1A130:  BNC   1A1AE
....................       e_ppr[motor] = arg; 
1A132:  BCF    FD8.0
1A134:  MOVLB  7
1A136:  RLCF   x40,W
1A138:  CLRF   03
1A13A:  ADDLW  62
1A13C:  MOVWF  FE9
1A13E:  MOVLW  07
1A140:  ADDWFC 03,W
1A142:  MOVWF  FEA
1A144:  MOVFF  48,FEF
1A148:  MOVFF  49,FEC
....................       switch(motor){ 
1A14C:  MOVF   x40,W
1A14E:  XORLW  00
1A150:  MOVLB  0
1A152:  BZ    1A15A
1A154:  XORLW  01
1A156:  BZ    1A184
1A158:  BRA    1A1AC
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
1A15A:  BCF    FD8.0
1A15C:  MOVLB  7
1A15E:  RLCF   x40,W
1A160:  CLRF   03
1A162:  ADDLW  62
1A164:  MOVWF  FE9
1A166:  MOVLW  07
1A168:  ADDWFC 03,W
1A16A:  MOVWF  FEA
1A16C:  MOVFF  FEC,8F0
1A170:  MOVF   FED,F
1A172:  MOVFF  FEF,8EF
1A176:  MOVLW  A6
1A178:  MOVLB  8
1A17A:  MOVWF  xEE
1A17C:  MOVLB  0
1A17E:  CALL   4FD4
....................             break; 
1A182:  BRA    1A1AC
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
1A184:  BCF    FD8.0
1A186:  MOVLB  7
1A188:  RLCF   x40,W
1A18A:  CLRF   03
1A18C:  ADDLW  62
1A18E:  MOVWF  FE9
1A190:  MOVLW  07
1A192:  ADDWFC 03,W
1A194:  MOVWF  FEA
1A196:  MOVFF  FEC,8F0
1A19A:  MOVF   FED,F
1A19C:  MOVFF  FEF,8EF
1A1A0:  MOVLW  A8
1A1A2:  MOVLB  8
1A1A4:  MOVWF  xEE
1A1A6:  MOVLB  0
1A1A8:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1A1AC:  BRA    1A1B2
....................    else cmd_arg();    
1A1AE:  CALL   B2C2
1A1B2:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
1A1B6:  MOVF   48,F
1A1B8:  BNZ   1A1CA
1A1BA:  MOVF   49,F
1A1BC:  BNZ   1A1CA
1A1BE:  MOVF   4A,F
1A1C0:  BNZ   1A1CA
1A1C2:  MOVF   4B,F
1A1C4:  BNZ   1A1CA
1A1C6:  BCF    F8E.1
1A1C8:  BRA    1A1CE
....................    else cmd_arg();    
1A1CA:  CALL   B2C2
1A1CE:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1ACB2:  MOVF   48,F
1ACB4:  BNZ   1AD04
1ACB6:  MOVF   49,F
1ACB8:  BNZ   1AD04
1ACBA:  MOVF   4A,F
1ACBC:  BNZ   1AD04
1ACBE:  MOVF   4B,F
1ACC0:  BNZ   1AD04
....................       switch (nv_product) { 
1ACC2:  MOVFF  2F,00
1ACC6:  MOVF   30,W
1ACC8:  MOVWF  03
1ACCA:  BNZ   1ACD0
1ACCC:  MOVF   00,F
1ACCE:  BZ    1ACF0
1ACD0:  MOVF   03,W
1ACD2:  BNZ   1ACDA
1ACD4:  MOVLW  01
1ACD6:  SUBWF  00,W
1ACD8:  BZ    1ACF6
1ACDA:  MOVF   03,W
1ACDC:  BNZ   1ACE4
1ACDE:  MOVLW  02
1ACE0:  SUBWF  00,W
1ACE2:  BZ    1ACFC
1ACE4:  MOVF   03,W
1ACE6:  BNZ   1ACEE
1ACE8:  MOVLW  03
1ACEA:  SUBWF  00,W
1ACEC:  BZ    1AD00
1ACEE:  BRA    1AD02
....................          case ECO : rst_step_vars_eco(); 
1ACF0:  GOTO   1A1D2
....................             break; 
1ACF4:  BRA    1AD02
....................          case WMS4 : rst_step_vars_wms4(); 
1ACF6:  GOTO   1A4BC
....................             break; 
1ACFA:  BRA    1AD02
....................          case AWS : rst_step_vars_aws(); 
1ACFC:  BRA    1A768
....................             break;             
1ACFE:  BRA    1AD02
....................          case WMS2 : rst_step_vars_wms2(); 
1AD00:  BRA    1AA02
....................             break; 
....................       } 
....................    }  
1AD02:  BRA    1AD08
....................    else cmd_arg(); 
1AD04:  CALL   B2C2
1AD08:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1AD0C:  MOVF   4B,F
1AD0E:  BTFSS  FD8.2
1AD10:  BRA    1AE12
1AD12:  MOVF   4A,W
1AD14:  SUBLW  00
1AD16:  BTFSS  FD8.0
1AD18:  BRA    1AE12
....................       m_spr[motor] = arg; 
1AD1A:  BCF    FD8.0
1AD1C:  MOVLB  7
1AD1E:  RLCF   x40,W
1AD20:  CLRF   03
1AD22:  ADDLW  76
1AD24:  MOVWF  FE9
1AD26:  MOVLW  07
1AD28:  ADDWFC 03,W
1AD2A:  MOVWF  FEA
1AD2C:  MOVFF  48,FEF
1AD30:  MOVFF  49,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1AD34:  BCF    FD8.0
1AD36:  RLCF   x40,W
1AD38:  CLRF   03
1AD3A:  ADDLW  AB
1AD3C:  MOVWF  01
1AD3E:  MOVLW  07
1AD40:  ADDWFC 03,F
1AD42:  MOVFF  01,885
1AD46:  MOVLB  8
1AD48:  MOVFF  03,886
1AD4C:  BCF    FD8.0
1AD4E:  MOVLB  7
1AD50:  RLCF   x40,W
1AD52:  CLRF   03
1AD54:  ADDLW  76
1AD56:  MOVWF  FE9
1AD58:  MOVLW  07
1AD5A:  ADDWFC 03,W
1AD5C:  MOVWF  FEA
1AD5E:  MOVFF  FEC,8DC
1AD62:  MOVF   FED,F
1AD64:  MOVFF  FEF,8DB
1AD68:  BCF    FD8.0
1AD6A:  RLCF   x40,W
1AD6C:  CLRF   03
1AD6E:  ADDLW  62
1AD70:  MOVWF  FE9
1AD72:  MOVLW  07
1AD74:  ADDWFC 03,W
1AD76:  MOVWF  FEA
1AD78:  MOVFF  FEC,03
1AD7C:  MOVF   FED,F
1AD7E:  MOVFF  FEF,8DD
1AD82:  MOVFF  03,88A
1AD86:  MOVFF  03,8DE
1AD8A:  MOVLB  0
1AD8C:  CALL   2CD4
1AD90:  MOVFF  02,888
1AD94:  BCF    FD8.0
1AD96:  MOVLB  8
1AD98:  RLCF   01,W
1AD9A:  MOVWF  02
1AD9C:  RLCF   x88,W
1AD9E:  MOVFF  886,FEA
1ADA2:  MOVFF  885,FE9
1ADA6:  MOVWF  FEC
1ADA8:  MOVF   FED,F
1ADAA:  MOVFF  02,FEF
....................       switch(motor){ 
1ADAE:  MOVLB  7
1ADB0:  MOVF   x40,W
1ADB2:  XORLW  00
1ADB4:  MOVLB  0
1ADB6:  BZ    1ADBE
1ADB8:  XORLW  01
1ADBA:  BZ    1ADE8
1ADBC:  BRA    1AE10
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1ADBE:  BCF    FD8.0
1ADC0:  MOVLB  7
1ADC2:  RLCF   x40,W
1ADC4:  CLRF   03
1ADC6:  ADDLW  76
1ADC8:  MOVWF  FE9
1ADCA:  MOVLW  07
1ADCC:  ADDWFC 03,W
1ADCE:  MOVWF  FEA
1ADD0:  MOVFF  FEC,8F0
1ADD4:  MOVF   FED,F
1ADD6:  MOVFF  FEF,8EF
1ADDA:  MOVLW  AE
1ADDC:  MOVLB  8
1ADDE:  MOVWF  xEE
1ADE0:  MOVLB  0
1ADE2:  CALL   4FD4
....................             break; 
1ADE6:  BRA    1AE10
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1ADE8:  BCF    FD8.0
1ADEA:  MOVLB  7
1ADEC:  RLCF   x40,W
1ADEE:  CLRF   03
1ADF0:  ADDLW  76
1ADF2:  MOVWF  FE9
1ADF4:  MOVLW  07
1ADF6:  ADDWFC 03,W
1ADF8:  MOVWF  FEA
1ADFA:  MOVFF  FEC,8F0
1ADFE:  MOVF   FED,F
1AE00:  MOVFF  FEF,8EF
1AE04:  MOVLW  B0
1AE06:  MOVLB  8
1AE08:  MOVWF  xEE
1AE0A:  MOVLB  0
1AE0C:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1AE10:  BRA    1AE16
....................    else cmd_arg();    
1AE12:  CALL   B2C2
1AE16:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1AE1A:  MOVF   4B,F
1AE1C:  BNZ   1AEA8
1AE1E:  MOVF   4A,F
1AE20:  BNZ   1AEA8
1AE22:  MOVF   49,F
1AE24:  BNZ   1AEA8
1AE26:  MOVF   48,W
1AE28:  SUBLW  02
1AE2A:  BNC   1AEA8
....................       e_type[motor] = arg; 
1AE2C:  BCF    FD8.0
1AE2E:  MOVLB  7
1AE30:  RLCF   x40,W
1AE32:  CLRF   03
1AE34:  ADDLW  6A
1AE36:  MOVWF  FE9
1AE38:  MOVLW  07
1AE3A:  ADDWFC 03,W
1AE3C:  MOVWF  FEA
1AE3E:  MOVFF  48,FEF
1AE42:  MOVFF  49,FEC
....................       switch(motor){ 
1AE46:  MOVF   x40,W
1AE48:  XORLW  00
1AE4A:  MOVLB  0
1AE4C:  BZ    1AE54
1AE4E:  XORLW  01
1AE50:  BZ    1AE7E
1AE52:  BRA    1AEA6
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1AE54:  BCF    FD8.0
1AE56:  MOVLB  7
1AE58:  RLCF   x40,W
1AE5A:  CLRF   03
1AE5C:  ADDLW  6A
1AE5E:  MOVWF  FE9
1AE60:  MOVLW  07
1AE62:  ADDWFC 03,W
1AE64:  MOVWF  FEA
1AE66:  MOVFF  FEC,8F0
1AE6A:  MOVF   FED,F
1AE6C:  MOVFF  FEF,8EF
1AE70:  MOVLW  7A
1AE72:  MOVLB  8
1AE74:  MOVWF  xEE
1AE76:  MOVLB  0
1AE78:  CALL   4FD4
....................             break; 
1AE7C:  BRA    1AEA6
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1AE7E:  BCF    FD8.0
1AE80:  MOVLB  7
1AE82:  RLCF   x40,W
1AE84:  CLRF   03
1AE86:  ADDLW  6A
1AE88:  MOVWF  FE9
1AE8A:  MOVLW  07
1AE8C:  ADDWFC 03,W
1AE8E:  MOVWF  FEA
1AE90:  MOVFF  FEC,8F0
1AE94:  MOVF   FED,F
1AE96:  MOVFF  FEF,8EF
1AE9A:  MOVLW  7C
1AE9C:  MOVLB  8
1AE9E:  MOVWF  xEE
1AEA0:  MOVLB  0
1AEA2:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1AEA6:  BRA    1AEAC
....................    else cmd_arg();    
1AEA8:  CALL   B2C2
1AEAC:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... //currently used to test dio pins 
.................... void command_v(){ 
....................    if(arg == 00){ 
*
13D94:  MOVF   48,F
13D96:  BNZ   13DA8
13D98:  MOVF   49,F
13D9A:  BNZ   13DA8
13D9C:  MOVF   4A,F
13D9E:  BNZ   13DA8
13DA0:  MOVF   4B,F
13DA2:  BNZ   13DA8
....................       output_bit(PIN_D0,0); 
13DA4:  BCF    F8C.0
....................    }else if(arg == 01){ 
13DA6:  BRA    13EEE
13DA8:  DECFSZ 48,W
13DAA:  BRA    13DBC
13DAC:  MOVF   49,F
13DAE:  BNZ   13DBC
13DB0:  MOVF   4A,F
13DB2:  BNZ   13DBC
13DB4:  MOVF   4B,F
13DB6:  BNZ   13DBC
....................       output_bit(PIN_D0,1); 
13DB8:  BSF    F8C.0
....................    }else if(arg == 10){ 
13DBA:  BRA    13EEE
13DBC:  MOVF   48,W
13DBE:  SUBLW  0A
13DC0:  BNZ   13DD2
13DC2:  MOVF   49,F
13DC4:  BNZ   13DD2
13DC6:  MOVF   4A,F
13DC8:  BNZ   13DD2
13DCA:  MOVF   4B,F
13DCC:  BNZ   13DD2
....................       output_bit(PIN_D1,0); 
13DCE:  BCF    F8C.1
....................    }else if(arg == 11){ 
13DD0:  BRA    13EEE
13DD2:  MOVF   48,W
13DD4:  SUBLW  0B
13DD6:  BNZ   13DE8
13DD8:  MOVF   49,F
13DDA:  BNZ   13DE8
13DDC:  MOVF   4A,F
13DDE:  BNZ   13DE8
13DE0:  MOVF   4B,F
13DE2:  BNZ   13DE8
....................       output_bit(PIN_D1,1); 
13DE4:  BSF    F8C.1
....................    }else if(arg == 20){ 
13DE6:  BRA    13EEE
13DE8:  MOVF   48,W
13DEA:  SUBLW  14
13DEC:  BNZ   13DFE
13DEE:  MOVF   49,F
13DF0:  BNZ   13DFE
13DF2:  MOVF   4A,F
13DF4:  BNZ   13DFE
13DF6:  MOVF   4B,F
13DF8:  BNZ   13DFE
....................       output_bit(PIN_D2,0); 
13DFA:  BCF    F8C.2
....................    }else if(arg == 21){ 
13DFC:  BRA    13EEE
13DFE:  MOVF   48,W
13E00:  SUBLW  15
13E02:  BNZ   13E14
13E04:  MOVF   49,F
13E06:  BNZ   13E14
13E08:  MOVF   4A,F
13E0A:  BNZ   13E14
13E0C:  MOVF   4B,F
13E0E:  BNZ   13E14
....................       output_bit(PIN_D2,1); 
13E10:  BSF    F8C.2
....................    }else if(arg == 30){ 
13E12:  BRA    13EEE
13E14:  MOVF   48,W
13E16:  SUBLW  1E
13E18:  BNZ   13E2A
13E1A:  MOVF   49,F
13E1C:  BNZ   13E2A
13E1E:  MOVF   4A,F
13E20:  BNZ   13E2A
13E22:  MOVF   4B,F
13E24:  BNZ   13E2A
....................       output_bit(PIN_D3,0); 
13E26:  BCF    F8C.3
....................    }else if(arg == 31){ 
13E28:  BRA    13EEE
13E2A:  MOVF   48,W
13E2C:  SUBLW  1F
13E2E:  BNZ   13E40
13E30:  MOVF   49,F
13E32:  BNZ   13E40
13E34:  MOVF   4A,F
13E36:  BNZ   13E40
13E38:  MOVF   4B,F
13E3A:  BNZ   13E40
....................       output_bit(PIN_D3,1); 
13E3C:  BSF    F8C.3
....................    }else if(arg == 40){ 
13E3E:  BRA    13EEE
13E40:  MOVF   48,W
13E42:  SUBLW  28
13E44:  BNZ   13E56
13E46:  MOVF   49,F
13E48:  BNZ   13E56
13E4A:  MOVF   4A,F
13E4C:  BNZ   13E56
13E4E:  MOVF   4B,F
13E50:  BNZ   13E56
....................       output_bit(PIN_D4,0); 
13E52:  BCF    F8C.4
....................    }else if(arg == 41){ 
13E54:  BRA    13EEE
13E56:  MOVF   48,W
13E58:  SUBLW  29
13E5A:  BNZ   13E6C
13E5C:  MOVF   49,F
13E5E:  BNZ   13E6C
13E60:  MOVF   4A,F
13E62:  BNZ   13E6C
13E64:  MOVF   4B,F
13E66:  BNZ   13E6C
....................       output_bit(PIN_D4,1); 
13E68:  BSF    F8C.4
....................    }else if(arg == 50){ 
13E6A:  BRA    13EEE
13E6C:  MOVF   48,W
13E6E:  SUBLW  32
13E70:  BNZ   13E82
13E72:  MOVF   49,F
13E74:  BNZ   13E82
13E76:  MOVF   4A,F
13E78:  BNZ   13E82
13E7A:  MOVF   4B,F
13E7C:  BNZ   13E82
....................       output_bit(PIN_D5,0); 
13E7E:  BCF    F8C.5
....................    }else if(arg == 51){ 
13E80:  BRA    13EEE
13E82:  MOVF   48,W
13E84:  SUBLW  33
13E86:  BNZ   13E98
13E88:  MOVF   49,F
13E8A:  BNZ   13E98
13E8C:  MOVF   4A,F
13E8E:  BNZ   13E98
13E90:  MOVF   4B,F
13E92:  BNZ   13E98
....................       output_bit(PIN_D5,1); 
13E94:  BSF    F8C.5
....................    }else if(arg == 60){ 
13E96:  BRA    13EEE
13E98:  MOVF   48,W
13E9A:  SUBLW  3C
13E9C:  BNZ   13EAE
13E9E:  MOVF   49,F
13EA0:  BNZ   13EAE
13EA2:  MOVF   4A,F
13EA4:  BNZ   13EAE
13EA6:  MOVF   4B,F
13EA8:  BNZ   13EAE
....................       output_bit(PIN_D6,0); 
13EAA:  BCF    F8C.6
....................    }else if(arg == 61){ 
13EAC:  BRA    13EEE
13EAE:  MOVF   48,W
13EB0:  SUBLW  3D
13EB2:  BNZ   13EC4
13EB4:  MOVF   49,F
13EB6:  BNZ   13EC4
13EB8:  MOVF   4A,F
13EBA:  BNZ   13EC4
13EBC:  MOVF   4B,F
13EBE:  BNZ   13EC4
....................       output_bit(PIN_D6,1); 
13EC0:  BSF    F8C.6
....................    }else if(arg == 70){ 
13EC2:  BRA    13EEE
13EC4:  MOVF   48,W
13EC6:  SUBLW  46
13EC8:  BNZ   13EDA
13ECA:  MOVF   49,F
13ECC:  BNZ   13EDA
13ECE:  MOVF   4A,F
13ED0:  BNZ   13EDA
13ED2:  MOVF   4B,F
13ED4:  BNZ   13EDA
....................       output_bit(PIN_D7,0); 
13ED6:  BCF    F8C.7
....................    }else if(arg == 71){ 
13ED8:  BRA    13EEE
13EDA:  MOVF   48,W
13EDC:  SUBLW  47
13EDE:  BNZ   13EEE
13EE0:  MOVF   49,F
13EE2:  BNZ   13EEE
13EE4:  MOVF   4A,F
13EE6:  BNZ   13EEE
13EE8:  MOVF   4B,F
13EEA:  BNZ   13EEE
....................       output_bit(PIN_D7,1); 
13EEC:  BSF    F8C.7
....................    } 
13EEE:  RETURN 0
.................... } 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1AEE8:  MOVF   4B,F
1AEEA:  BNZ   1AFB4
1AEEC:  MOVF   4A,F
1AEEE:  BNZ   1AFB4
1AEF0:  MOVF   49,F
1AEF2:  BNZ   1AFB4
1AEF4:  MOVF   48,W
1AEF6:  SUBLW  64
1AEF8:  BNC   1AFB4
....................       drive_pc=arg; 
1AEFA:  MOVFF  49,886
1AEFE:  MOVFF  48,885
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1AF02:  BCF    FD8.0
1AF04:  MOVLB  7
1AF06:  RLCF   x40,W
1AF08:  CLRF   03
1AF0A:  ADDLW  56
1AF0C:  MOVWF  FE9
1AF0E:  MOVLW  07
1AF10:  ADDWFC 03,W
1AF12:  MOVWF  FEA
1AF14:  MOVFF  886,A11
1AF18:  MOVFF  885,A10
1AF1C:  MOVLW  01
1AF1E:  MOVLB  A
1AF20:  MOVWF  x13
1AF22:  SETF   x12
1AF24:  MOVLB  0
1AF26:  CALL   5C98
1AF2A:  MOVFF  02,88A
1AF2E:  MOVFF  01,889
1AF32:  MOVFF  02,8DC
1AF36:  MOVFF  01,8DB
1AF3A:  MOVLB  8
1AF3C:  CLRF   xDE
1AF3E:  MOVLW  64
1AF40:  MOVWF  xDD
1AF42:  MOVLB  0
1AF44:  CALL   2CD4
1AF48:  MOVFF  01,FEF
1AF4C:  MOVFF  02,FEC
....................       switch(motor){ 
1AF50:  MOVLB  7
1AF52:  MOVF   x40,W
1AF54:  XORLW  00
1AF56:  MOVLB  0
1AF58:  BZ    1AF60
1AF5A:  XORLW  01
1AF5C:  BZ    1AF8A
1AF5E:  BRA    1AFB2
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1AF60:  BCF    FD8.0
1AF62:  MOVLB  7
1AF64:  RLCF   x40,W
1AF66:  CLRF   03
1AF68:  ADDLW  56
1AF6A:  MOVWF  FE9
1AF6C:  MOVLW  07
1AF6E:  ADDWFC 03,W
1AF70:  MOVWF  FEA
1AF72:  MOVFF  FEC,8F0
1AF76:  MOVF   FED,F
1AF78:  MOVFF  FEF,8EF
1AF7C:  MOVLW  9A
1AF7E:  MOVLB  8
1AF80:  MOVWF  xEE
1AF82:  MOVLB  0
1AF84:  CALL   4FD4
....................             break; 
1AF88:  BRA    1AFB2
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1AF8A:  BCF    FD8.0
1AF8C:  MOVLB  7
1AF8E:  RLCF   x40,W
1AF90:  CLRF   03
1AF92:  ADDLW  56
1AF94:  MOVWF  FE9
1AF96:  MOVLW  07
1AF98:  ADDWFC 03,W
1AF9A:  MOVWF  FEA
1AF9C:  MOVFF  FEC,8F0
1AFA0:  MOVF   FED,F
1AFA2:  MOVFF  FEF,8EF
1AFA6:  MOVLW  9C
1AFA8:  MOVLB  8
1AFAA:  MOVWF  xEE
1AFAC:  MOVLB  0
1AFAE:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1AFB2:  BRA    1AFB8
....................    else cmd_arg();    
1AFB4:  CALL   B2C2
1AFB8:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1AFBC:  MOVF   4B,F
1AFBE:  BNZ   1B04E
1AFC0:  MOVF   4A,F
1AFC2:  BNZ   1B04E
1AFC4:  MOVF   49,W
1AFC6:  SUBLW  27
1AFC8:  BNC   1B04E
1AFCA:  BNZ   1AFD2
1AFCC:  MOVF   48,W
1AFCE:  SUBLW  0F
1AFD0:  BNC   1B04E
....................        align_os[motor] = arg; 
1AFD2:  BCF    FD8.0
1AFD4:  MOVLB  7
1AFD6:  RLCF   x40,W
1AFD8:  CLRF   03
1AFDA:  ADDLW  82
1AFDC:  MOVWF  FE9
1AFDE:  MOVLW  07
1AFE0:  ADDWFC 03,W
1AFE2:  MOVWF  FEA
1AFE4:  MOVFF  48,FEF
1AFE8:  MOVFF  49,FEC
....................        switch(motor){ 
1AFEC:  MOVF   x40,W
1AFEE:  XORLW  00
1AFF0:  MOVLB  0
1AFF2:  BZ    1AFFA
1AFF4:  XORLW  01
1AFF6:  BZ    1B024
1AFF8:  BRA    1B04C
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1AFFA:  BCF    FD8.0
1AFFC:  MOVLB  7
1AFFE:  RLCF   x40,W
1B000:  CLRF   03
1B002:  ADDLW  82
1B004:  MOVWF  FE9
1B006:  MOVLW  07
1B008:  ADDWFC 03,W
1B00A:  MOVWF  FEA
1B00C:  MOVFF  FEC,8F0
1B010:  MOVF   FED,F
1B012:  MOVFF  FEF,8EF
1B016:  MOVLW  C2
1B018:  MOVLB  8
1B01A:  MOVWF  xEE
1B01C:  MOVLB  0
1B01E:  CALL   4FD4
....................             break; 
1B022:  BRA    1B04C
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1B024:  BCF    FD8.0
1B026:  MOVLB  7
1B028:  RLCF   x40,W
1B02A:  CLRF   03
1B02C:  ADDLW  82
1B02E:  MOVWF  FE9
1B030:  MOVLW  07
1B032:  ADDWFC 03,W
1B034:  MOVWF  FEA
1B036:  MOVFF  FEC,8F0
1B03A:  MOVF   FED,F
1B03C:  MOVFF  FEF,8EF
1B040:  MOVLW  C4
1B042:  MOVLB  8
1B044:  MOVWF  xEE
1B046:  MOVLB  0
1B048:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1B04C:  BRA    1B052
....................    else cmd_arg();    
1B04E:  CALL   B2C2
1B052:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1B056:  MOVF   4B,F
1B058:  BNZ   1B0E4
1B05A:  MOVF   4A,F
1B05C:  BNZ   1B0E4
1B05E:  MOVF   49,F
1B060:  BNZ   1B0E4
1B062:  MOVF   48,W
1B064:  SUBLW  01
1B066:  BNC   1B0E4
....................       m_ctrl[motor] = arg; 
1B068:  BCF    FD8.0
1B06A:  MOVLB  7
1B06C:  RLCF   x40,W
1B06E:  CLRF   03
1B070:  ADDLW  42
1B072:  MOVWF  FE9
1B074:  MOVLW  07
1B076:  ADDWFC 03,W
1B078:  MOVWF  FEA
1B07A:  MOVFF  48,FEF
1B07E:  MOVFF  49,FEC
....................       switch(motor){ 
1B082:  MOVF   x40,W
1B084:  XORLW  00
1B086:  MOVLB  0
1B088:  BZ    1B090
1B08A:  XORLW  01
1B08C:  BZ    1B0BA
1B08E:  BRA    1B0E2
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1B090:  BCF    FD8.0
1B092:  MOVLB  7
1B094:  RLCF   x40,W
1B096:  CLRF   03
1B098:  ADDLW  42
1B09A:  MOVWF  FE9
1B09C:  MOVLW  07
1B09E:  ADDWFC 03,W
1B0A0:  MOVWF  FEA
1B0A2:  MOVFF  FEC,8F0
1B0A6:  MOVF   FED,F
1B0A8:  MOVFF  FEF,8EF
1B0AC:  MOVLW  86
1B0AE:  MOVLB  8
1B0B0:  MOVWF  xEE
1B0B2:  MOVLB  0
1B0B4:  CALL   4FD4
....................             break; 
1B0B8:  BRA    1B0E2
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1B0BA:  BCF    FD8.0
1B0BC:  MOVLB  7
1B0BE:  RLCF   x40,W
1B0C0:  CLRF   03
1B0C2:  ADDLW  42
1B0C4:  MOVWF  FE9
1B0C6:  MOVLW  07
1B0C8:  ADDWFC 03,W
1B0CA:  MOVWF  FEA
1B0CC:  MOVFF  FEC,8F0
1B0D0:  MOVF   FED,F
1B0D2:  MOVFF  FEF,8EF
1B0D6:  MOVLW  88
1B0D8:  MOVLB  8
1B0DA:  MOVWF  xEE
1B0DC:  MOVLB  0
1B0DE:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1B0E2:  BRA    1B0E8
....................    else cmd_arg();    
1B0E4:  CALL   B2C2
1B0E8:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1AEB0:  MOVF   48,W
1AEB2:  MOVWF  00
1AEB4:  MOVF   49,W
1AEB6:  MOVWF  03
1AEB8:  BNZ   1AEC0
1AEBA:  MOVLW  01
1AEBC:  SUBWF  00,W
1AEBE:  BZ    1AECC
1AEC0:  MOVF   03,W
1AEC2:  BNZ   1AECA
1AEC4:  MOVLW  02
1AEC6:  SUBWF  00,W
1AEC8:  BZ    1AED2
1AECA:  BRA    1AEDC
....................       case 1: motor = 0; 
1AECC:  MOVLB  7
1AECE:  CLRF   x40
....................          break; 
1AED0:  BRA    1AEE2
....................       case 2: motor = 1; 
1AED2:  MOVLW  01
1AED4:  MOVLB  7
1AED6:  MOVWF  x40
....................          break; 
1AED8:  BRA    1AEE2
1AEDA:  MOVLB  0
....................       default : cmd_arg(); 
1AEDC:  CALL   B2C2
....................          break; 
1AEE0:  MOVLB  7
....................    } 
1AEE2:  MOVLB  0
1AEE4:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1B0EC:  MOVF   48,F
1B0EE:  BNZ   1B0FC
1B0F0:  MOVF   49,F
1B0F2:  BNZ   1B0FC
1B0F4:  MOVF   4A,F
1B0F6:  BNZ   1B0FC
1B0F8:  MOVF   4B,F
1B0FA:  BZ    1B15A
1B0FC:  MOVF   4B,F
1B0FE:  BNZ   1B15A
1B100:  MOVF   4A,F
1B102:  BNZ   1B15A
1B104:  MOVF   49,F
1B106:  BNZ   1B15A
1B108:  MOVF   48,W
1B10A:  SUBLW  02
1B10C:  BNC   1B15A
....................       switch(arg){ 
1B10E:  MOVFF  48,00
1B112:  MOVF   49,W
1B114:  MOVWF  03
1B116:  BNZ   1B11E
1B118:  MOVLW  01
1B11A:  SUBWF  00,W
1B11C:  BZ    1B12A
1B11E:  MOVF   03,W
1B120:  BNZ   1B128
1B122:  MOVLW  02
1B124:  SUBWF  00,W
1B126:  BZ    1B142
1B128:  BRA    1B158
....................          case 1 : e_pos[0] = 0; 
1B12A:  MOVLB  7
1B12C:  CLRF   xC0
1B12E:  CLRF   xBF
....................                   write16(ADDR_E1_POS, 0); 
1B130:  MOVLW  7E
1B132:  MOVLB  8
1B134:  MOVWF  xEE
1B136:  CLRF   xF0
1B138:  CLRF   xEF
1B13A:  MOVLB  0
1B13C:  CALL   4FD4
....................             break; 
1B140:  BRA    1B158
....................          case 2 : e_pos[1] = 0; 
1B142:  MOVLB  7
1B144:  CLRF   xC2
1B146:  CLRF   xC1
....................                   write16(ADDR_E2_POS, 0); 
1B148:  MOVLW  80
1B14A:  MOVLB  8
1B14C:  MOVWF  xEE
1B14E:  CLRF   xF0
1B150:  CLRF   xEF
1B152:  MOVLB  0
1B154:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1B158:  BRA    1B15E
....................    else cmd_arg();  
1B15A:  CALL   B2C2
1B15E:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
192F6:  DECFSZ 48,W
192F8:  GOTO   19F4E
192FC:  MOVF   49,F
192FE:  BTFSS  FD8.2
19300:  GOTO   19F4E
19304:  MOVF   4A,F
19306:  BTFSS  FD8.2
19308:  GOTO   19F4E
1930C:  MOVF   4B,F
1930E:  BTFSS  FD8.2
19310:  GOTO   19F4E
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
19314:  MOVFF  753,A11
19318:  MOVFF  752,A10
1931C:  MOVLB  A
1931E:  CLRF   x13
19320:  MOVLW  64
19322:  MOVWF  x12
19324:  MOVLB  0
19326:  CALL   5C98
1932A:  MOVFF  02,88C
1932E:  MOVFF  01,88B
19332:  MOVFF  02,8DC
19336:  MOVFF  01,8DB
1933A:  MOVLW  01
1933C:  MOVLB  8
1933E:  MOVWF  xDE
19340:  SETF   xDD
19342:  MOVLB  0
19344:  CALL   2CD4
19348:  MOVFF  02,886
1934C:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
19350:  MOVFF  757,A11
19354:  MOVFF  756,A10
19358:  MOVLB  A
1935A:  CLRF   x13
1935C:  MOVLW  64
1935E:  MOVWF  x12
19360:  MOVLB  0
19362:  CALL   5C98
19366:  MOVFF  02,88C
1936A:  MOVFF  01,88B
1936E:  MOVFF  02,8DC
19372:  MOVFF  01,8DB
19376:  MOVLW  01
19378:  MOVLB  8
1937A:  MOVWF  xDE
1937C:  SETF   xDD
1937E:  MOVLB  0
19380:  CALL   2CD4
19384:  MOVFF  02,888
19388:  MOVFF  01,887
....................       step_us  =   m_stp_int[0]*100; 
1938C:  MOVFF  74B,A11
19390:  MOVFF  74A,A10
19394:  MOVLB  A
19396:  CLRF   x13
19398:  MOVLW  64
1939A:  MOVWF  x12
1939C:  MOVLB  0
1939E:  CALL   5C98
193A2:  MOVFF  02,88A
193A6:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
193AA:  MOVLW  1A
193AC:  MOVWF  FF6
193AE:  MOVLW  27
193B0:  MOVWF  FF7
193B2:  MOVLW  00
193B4:  MOVWF  FF8
193B6:  CLRF   1B
193B8:  BTFSC  FF2.7
193BA:  BSF    1B.7
193BC:  BCF    FF2.7
193BE:  CALL   0E4E
193C2:  BTFSC  1B.7
193C4:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
193C6:  MOVLW  62
193C8:  BTFSS  F9E.4
193CA:  BRA    193C8
193CC:  MOVWF  FAD
193CE:  MOVLW  3A
193D0:  BTFSS  F9E.4
193D2:  BRA    193D0
193D4:  MOVWF  FAD
193D6:  MOVLW  10
193D8:  MOVWF  FE9
193DA:  CLRF   1B
193DC:  BTFSC  FF2.7
193DE:  BSF    1B.7
193E0:  BCF    FF2.7
193E2:  MOVFF  773,A41
193E6:  MOVFF  772,A40
193EA:  CALL   11A6
193EE:  BTFSC  1B.7
193F0:  BSF    FF2.7
193F2:  MOVLW  0D
193F4:  BTFSS  F9E.4
193F6:  BRA    193F4
193F8:  MOVWF  FAD
193FA:  MOVLW  0A
193FC:  BTFSS  F9E.4
193FE:  BRA    193FC
19400:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
19402:  MOVLW  63
19404:  BTFSS  F9E.4
19406:  BRA    19404
19408:  MOVWF  FAD
1940A:  MOVLW  3A
1940C:  BTFSS  F9E.4
1940E:  BRA    1940C
19410:  MOVWF  FAD
19412:  MOVLW  41
19414:  MOVWF  FE9
19416:  CLRF   1B
19418:  BTFSC  FF2.7
1941A:  BSF    1B.7
1941C:  BCF    FF2.7
1941E:  MOVFF  7A5,A43
19422:  MOVFF  7A4,A42
19426:  MOVFF  7A3,A41
1942A:  MOVFF  7A2,A40
1942E:  CALL   10EA
19432:  BTFSC  1B.7
19434:  BSF    FF2.7
19436:  MOVLW  2F
19438:  BTFSS  F9E.4
1943A:  BRA    19438
1943C:  MOVWF  FAD
1943E:  MOVLW  10
19440:  MOVWF  FE9
19442:  CLRF   1B
19444:  BTFSC  FF2.7
19446:  BSF    1B.7
19448:  BCF    FF2.7
1944A:  MOVFF  7BC,A41
1944E:  MOVFF  7BB,A40
19452:  CALL   11A6
19456:  BTFSC  1B.7
19458:  BSF    FF2.7
1945A:  MOVLW  2F
1945C:  BTFSS  F9E.4
1945E:  BRA    1945C
19460:  MOVWF  FAD
19462:  MOVLW  10
19464:  MOVWF  FE9
19466:  CLRF   1B
19468:  BTFSC  FF2.7
1946A:  BSF    1B.7
1946C:  BCF    FF2.7
1946E:  MOVFF  7C0,A41
19472:  MOVFF  7BF,A40
19476:  CALL   11A6
1947A:  BTFSC  1B.7
1947C:  BSF    FF2.7
1947E:  MOVLW  0D
19480:  BTFSS  F9E.4
19482:  BRA    19480
19484:  MOVWF  FAD
19486:  MOVLW  0A
19488:  BTFSS  F9E.4
1948A:  BRA    19488
1948C:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
1948E:  MOVLW  64
19490:  BTFSS  F9E.4
19492:  BRA    19490
19494:  MOVWF  FAD
19496:  MOVLW  3A
19498:  BTFSS  F9E.4
1949A:  BRA    19498
1949C:  MOVWF  FAD
1949E:  MOVLW  10
194A0:  MOVWF  FE9
194A2:  CLRF   1B
194A4:  BTFSC  FF2.7
194A6:  BSF    1B.7
194A8:  BCF    FF2.7
194AA:  MOVFF  74F,A41
194AE:  MOVFF  74E,A40
194B2:  CALL   11A6
194B6:  BTFSC  1B.7
194B8:  BSF    FF2.7
194BA:  MOVLW  0D
194BC:  BTFSS  F9E.4
194BE:  BRA    194BC
194C0:  MOVWF  FAD
194C2:  MOVLW  0A
194C4:  BTFSS  F9E.4
194C6:  BRA    194C4
194C8:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
194CA:  MOVLW  65
194CC:  BTFSS  F9E.4
194CE:  BRA    194CC
194D0:  MOVWF  FAD
194D2:  MOVLW  3A
194D4:  BTFSS  F9E.4
194D6:  BRA    194D4
194D8:  MOVWF  FAD
194DA:  MOVLW  10
194DC:  MOVWF  FE9
194DE:  CLRF   1B
194E0:  BTFSC  FF2.7
194E2:  BSF    1B.7
194E4:  BCF    FF2.7
194E6:  MOVFF  75F,A41
194EA:  MOVFF  75E,A40
194EE:  CALL   11A6
194F2:  BTFSC  1B.7
194F4:  BSF    FF2.7
194F6:  MOVLW  0D
194F8:  BTFSS  F9E.4
194FA:  BRA    194F8
194FC:  MOVWF  FAD
194FE:  MOVLW  0A
19500:  BTFSS  F9E.4
19502:  BRA    19500
19504:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19506:  MOVLW  66
19508:  BTFSS  F9E.4
1950A:  BRA    19508
1950C:  MOVWF  FAD
1950E:  MOVLW  3A
19510:  BTFSS  F9E.4
19512:  BRA    19510
19514:  MOVWF  FAD
19516:  CLRF   1B
19518:  BTFSC  FF2.7
1951A:  BSF    1B.7
1951C:  BCF    FF2.7
1951E:  MOVFF  741,A40
19522:  MOVLW  1B
19524:  MOVLB  A
19526:  MOVWF  x41
19528:  MOVLB  0
1952A:  CALL   0FA6
1952E:  BTFSC  1B.7
19530:  BSF    FF2.7
19532:  MOVLW  0D
19534:  BTFSS  F9E.4
19536:  BRA    19534
19538:  MOVWF  FAD
1953A:  MOVLW  0A
1953C:  BTFSS  F9E.4
1953E:  BRA    1953C
19540:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
19542:  MOVLW  67
19544:  BTFSS  F9E.4
19546:  BRA    19544
19548:  MOVWF  FAD
1954A:  MOVLW  3A
1954C:  BTFSS  F9E.4
1954E:  BRA    1954C
19550:  MOVWF  FAD
19552:  MOVLW  10
19554:  MOVWF  FE9
19556:  CLRF   1B
19558:  BTFSC  FF2.7
1955A:  BSF    1B.7
1955C:  BCF    FF2.7
1955E:  MOVFF  75B,A41
19562:  MOVFF  75A,A40
19566:  CALL   11A6
1956A:  BTFSC  1B.7
1956C:  BSF    FF2.7
1956E:  MOVLW  0D
19570:  BTFSS  F9E.4
19572:  BRA    19570
19574:  MOVWF  FAD
19576:  MOVLW  0A
19578:  BTFSS  F9E.4
1957A:  BRA    19578
1957C:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
1957E:  MOVLW  68
19580:  BTFSS  F9E.4
19582:  BRA    19580
19584:  MOVWF  FAD
19586:  MOVLW  3A
19588:  BTFSS  F9E.4
1958A:  BRA    19588
1958C:  MOVWF  FAD
1958E:  MOVLW  10
19590:  MOVWF  FE9
19592:  CLRF   1B
19594:  BTFSC  FF2.7
19596:  BSF    1B.7
19598:  BCF    FF2.7
1959A:  MOVFF  886,A41
1959E:  MOVFF  885,A40
195A2:  CALL   11A6
195A6:  BTFSC  1B.7
195A8:  BSF    FF2.7
195AA:  MOVLW  0D
195AC:  BTFSS  F9E.4
195AE:  BRA    195AC
195B0:  MOVWF  FAD
195B2:  MOVLW  0A
195B4:  BTFSS  F9E.4
195B6:  BRA    195B4
195B8:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
195BA:  MOVLW  69
195BC:  BTFSS  F9E.4
195BE:  BRA    195BC
195C0:  MOVWF  FAD
195C2:  MOVLW  3A
195C4:  BTFSS  F9E.4
195C6:  BRA    195C4
195C8:  MOVWF  FAD
195CA:  MOVLW  10
195CC:  MOVWF  FE9
195CE:  CLRF   1B
195D0:  BTFSC  FF2.7
195D2:  BSF    1B.7
195D4:  BCF    FF2.7
195D6:  MOVFF  88A,A41
195DA:  MOVFF  889,A40
195DE:  CALL   11A6
195E2:  BTFSC  1B.7
195E4:  BSF    FF2.7
195E6:  MOVLW  0D
195E8:  BTFSS  F9E.4
195EA:  BRA    195E8
195EC:  MOVWF  FAD
195EE:  MOVLW  0A
195F0:  BTFSS  F9E.4
195F2:  BRA    195F0
195F4:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
195F6:  MOVLW  6A
195F8:  BTFSS  F9E.4
195FA:  BRA    195F8
195FC:  MOVWF  FAD
195FE:  MOVLW  3A
19600:  BTFSS  F9E.4
19602:  BRA    19600
19604:  MOVWF  FAD
19606:  MOVLW  10
19608:  MOVWF  FE9
1960A:  CLRF   1B
1960C:  BTFSC  FF2.7
1960E:  BSF    1B.7
19610:  BCF    FF2.7
19612:  MOVFF  76F,A41
19616:  MOVFF  76E,A40
1961A:  CALL   11A6
1961E:  BTFSC  1B.7
19620:  BSF    FF2.7
19622:  MOVLW  0D
19624:  BTFSS  F9E.4
19626:  BRA    19624
19628:  MOVWF  FAD
1962A:  MOVLW  0A
1962C:  BTFSS  F9E.4
1962E:  BRA    1962C
19630:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
19632:  MOVLW  6B
19634:  BTFSS  F9E.4
19636:  BRA    19634
19638:  MOVWF  FAD
1963A:  MOVLW  3A
1963C:  BTFSS  F9E.4
1963E:  BRA    1963C
19640:  MOVWF  FAD
19642:  MOVLW  10
19644:  MOVWF  FE9
19646:  CLRF   1B
19648:  BTFSC  FF2.7
1964A:  BSF    1B.7
1964C:  BCF    FF2.7
1964E:  MOVFF  767,A41
19652:  MOVFF  766,A40
19656:  CALL   11A6
1965A:  BTFSC  1B.7
1965C:  BSF    FF2.7
1965E:  MOVLW  0D
19660:  BTFSS  F9E.4
19662:  BRA    19660
19664:  MOVWF  FAD
19666:  MOVLW  0A
19668:  BTFSS  F9E.4
1966A:  BRA    19668
1966C:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
1966E:  MOVLW  6D
19670:  BTFSS  F9E.4
19672:  BRA    19670
19674:  MOVWF  FAD
19676:  MOVLW  3A
19678:  BTFSS  F9E.4
1967A:  BRA    19678
1967C:  MOVWF  FAD
1967E:  MOVLW  10
19680:  MOVWF  FE9
19682:  CLRF   1B
19684:  BTFSC  FF2.7
19686:  BSF    1B.7
19688:  BCF    FF2.7
1968A:  MOVFF  747,A41
1968E:  MOVFF  746,A40
19692:  CALL   11A6
19696:  BTFSC  1B.7
19698:  BSF    FF2.7
1969A:  MOVLW  0D
1969C:  BTFSS  F9E.4
1969E:  BRA    1969C
196A0:  MOVWF  FAD
196A2:  MOVLW  0A
196A4:  BTFSS  F9E.4
196A6:  BRA    196A4
196A8:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
196AA:  MOVLW  6E
196AC:  BTFSS  F9E.4
196AE:  BRA    196AC
196B0:  MOVWF  FAD
196B2:  MOVLW  3A
196B4:  BTFSS  F9E.4
196B6:  BRA    196B4
196B8:  MOVWF  FAD
196BA:  MOVLW  10
196BC:  MOVWF  FE9
196BE:  CLRF   1B
196C0:  BTFSC  FF2.7
196C2:  BSF    1B.7
196C4:  BCF    FF2.7
196C6:  MOVFF  77B,A41
196CA:  MOVFF  77A,A40
196CE:  CALL   11A6
196D2:  BTFSC  1B.7
196D4:  BSF    FF2.7
196D6:  MOVLW  0D
196D8:  BTFSS  F9E.4
196DA:  BRA    196D8
196DC:  MOVWF  FAD
196DE:  MOVLW  0A
196E0:  BTFSS  F9E.4
196E2:  BRA    196E0
196E4:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
196E6:  MOVLW  6F
196E8:  BTFSS  F9E.4
196EA:  BRA    196E8
196EC:  MOVWF  FAD
196EE:  MOVLW  3A
196F0:  BTFSS  F9E.4
196F2:  BRA    196F0
196F4:  MOVWF  FAD
196F6:  MOVLW  10
196F8:  MOVWF  FE9
196FA:  CLRF   1B
196FC:  BTFSC  FF2.7
196FE:  BSF    1B.7
19700:  BCF    FF2.7
19702:  MOVFF  77F,A41
19706:  MOVFF  77E,A40
1970A:  CALL   11A6
1970E:  BTFSC  1B.7
19710:  BSF    FF2.7
19712:  MOVLW  0D
19714:  BTFSS  F9E.4
19716:  BRA    19714
19718:  MOVWF  FAD
1971A:  MOVLW  0A
1971C:  BTFSS  F9E.4
1971E:  BRA    1971C
19720:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
19722:  MOVLW  70
19724:  BTFSS  F9E.4
19726:  BRA    19724
19728:  MOVWF  FAD
1972A:  MOVLW  3A
1972C:  BTFSS  F9E.4
1972E:  BRA    1972C
19730:  MOVWF  FAD
19732:  MOVLW  10
19734:  MOVWF  FE9
19736:  CLRF   1B
19738:  BTFSC  FF2.7
1973A:  BSF    1B.7
1973C:  BCF    FF2.7
1973E:  MOVFF  7C4,A41
19742:  MOVFF  7C3,A40
19746:  CALL   11A6
1974A:  BTFSC  1B.7
1974C:  BSF    FF2.7
1974E:  MOVLW  2F
19750:  BTFSS  F9E.4
19752:  BRA    19750
19754:  MOVWF  FAD
19756:  MOVLW  10
19758:  MOVWF  FE9
1975A:  CLRF   1B
1975C:  BTFSC  FF2.7
1975E:  BSF    1B.7
19760:  BCF    FF2.7
19762:  MOVFF  763,A41
19766:  MOVFF  762,A40
1976A:  CALL   11A6
1976E:  BTFSC  1B.7
19770:  BSF    FF2.7
19772:  MOVLW  0D
19774:  BTFSS  F9E.4
19776:  BRA    19774
19778:  MOVWF  FAD
1977A:  MOVLW  0A
1977C:  BTFSS  F9E.4
1977E:  BRA    1977C
19780:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
19782:  MOVLW  71
19784:  BTFSS  F9E.4
19786:  BRA    19784
19788:  MOVWF  FAD
1978A:  MOVLW  3A
1978C:  BTFSS  F9E.4
1978E:  BRA    1978C
19790:  MOVWF  FAD
19792:  MOVLW  10
19794:  MOVWF  FE9
19796:  CLRF   1B
19798:  BTFSC  FF2.7
1979A:  BSF    1B.7
1979C:  BCF    FF2.7
1979E:  MOVFF  797,A41
197A2:  MOVFF  796,A40
197A6:  CALL   11A6
197AA:  BTFSC  1B.7
197AC:  BSF    FF2.7
197AE:  MOVLW  0D
197B0:  BTFSS  F9E.4
197B2:  BRA    197B0
197B4:  MOVWF  FAD
197B6:  MOVLW  0A
197B8:  BTFSS  F9E.4
197BA:  BRA    197B8
197BC:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
197BE:  MOVLW  73
197C0:  BTFSS  F9E.4
197C2:  BRA    197C0
197C4:  MOVWF  FAD
197C6:  MOVLW  3A
197C8:  BTFSS  F9E.4
197CA:  BRA    197C8
197CC:  MOVWF  FAD
197CE:  MOVLW  10
197D0:  MOVWF  FE9
197D2:  CLRF   1B
197D4:  BTFSC  FF2.7
197D6:  BSF    1B.7
197D8:  BCF    FF2.7
197DA:  MOVFF  777,A41
197DE:  MOVFF  776,A40
197E2:  CALL   11A6
197E6:  BTFSC  1B.7
197E8:  BSF    FF2.7
197EA:  MOVLW  0D
197EC:  BTFSS  F9E.4
197EE:  BRA    197EC
197F0:  MOVWF  FAD
197F2:  MOVLW  0A
197F4:  BTFSS  F9E.4
197F6:  BRA    197F4
197F8:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
197FA:  MOVLW  74
197FC:  BTFSS  F9E.4
197FE:  BRA    197FC
19800:  MOVWF  FAD
19802:  MOVLW  3A
19804:  BTFSS  F9E.4
19806:  BRA    19804
19808:  MOVWF  FAD
1980A:  MOVLW  10
1980C:  MOVWF  FE9
1980E:  CLRF   1B
19810:  BTFSC  FF2.7
19812:  BSF    1B.7
19814:  BCF    FF2.7
19816:  MOVFF  76B,A41
1981A:  MOVFF  76A,A40
1981E:  CALL   11A6
19822:  BTFSC  1B.7
19824:  BSF    FF2.7
19826:  MOVLW  0D
19828:  BTFSS  F9E.4
1982A:  BRA    19828
1982C:  MOVWF  FAD
1982E:  MOVLW  0A
19830:  BTFSS  F9E.4
19832:  BRA    19830
19834:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19836:  MOVLW  01
19838:  MOVLB  7
1983A:  ADDWF  x40,W
1983C:  MOVLB  8
1983E:  MOVWF  x8B
19840:  MOVLW  75
19842:  BTFSS  F9E.4
19844:  BRA    19842
19846:  MOVWF  FAD
19848:  MOVLW  3A
1984A:  BTFSS  F9E.4
1984C:  BRA    1984A
1984E:  MOVWF  FAD
19850:  CLRF   1B
19852:  BTFSC  FF2.7
19854:  BSF    1B.7
19856:  BCF    FF2.7
19858:  MOVFF  88B,A40
1985C:  MOVLW  1B
1985E:  MOVLB  A
19860:  MOVWF  x41
19862:  MOVLB  0
19864:  CALL   0FA6
19868:  BTFSC  1B.7
1986A:  BSF    FF2.7
1986C:  MOVLW  0D
1986E:  BTFSS  F9E.4
19870:  BRA    1986E
19872:  MOVWF  FAD
19874:  MOVLW  0A
19876:  BTFSS  F9E.4
19878:  BRA    19876
1987A:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
1987C:  MOVLW  77
1987E:  BTFSS  F9E.4
19880:  BRA    1987E
19882:  MOVWF  FAD
19884:  MOVLW  3A
19886:  BTFSS  F9E.4
19888:  BRA    19886
1988A:  MOVWF  FAD
1988C:  MOVLW  10
1988E:  MOVWF  FE9
19890:  CLRF   1B
19892:  BTFSC  FF2.7
19894:  BSF    1B.7
19896:  BCF    FF2.7
19898:  MOVFF  888,A41
1989C:  MOVFF  887,A40
198A0:  CALL   11A6
198A4:  BTFSC  1B.7
198A6:  BSF    FF2.7
198A8:  MOVLW  0D
198AA:  BTFSS  F9E.4
198AC:  BRA    198AA
198AE:  MOVWF  FAD
198B0:  MOVLW  0A
198B2:  BTFSS  F9E.4
198B4:  BRA    198B2
198B6:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
198B8:  MOVLW  78
198BA:  BTFSS  F9E.4
198BC:  BRA    198BA
198BE:  MOVWF  FAD
198C0:  MOVLW  3A
198C2:  BTFSS  F9E.4
198C4:  BRA    198C2
198C6:  MOVWF  FAD
198C8:  MOVLW  10
198CA:  MOVWF  FE9
198CC:  CLRF   1B
198CE:  BTFSC  FF2.7
198D0:  BSF    1B.7
198D2:  BCF    FF2.7
198D4:  MOVFF  783,A41
198D8:  MOVFF  782,A40
198DC:  CALL   11A6
198E0:  BTFSC  1B.7
198E2:  BSF    FF2.7
198E4:  MOVLW  0D
198E6:  BTFSS  F9E.4
198E8:  BRA    198E6
198EA:  MOVWF  FAD
198EC:  MOVLW  0A
198EE:  BTFSS  F9E.4
198F0:  BRA    198EE
198F2:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
198F4:  MOVLW  79
198F6:  BTFSS  F9E.4
198F8:  BRA    198F6
198FA:  MOVWF  FAD
198FC:  MOVLW  3A
198FE:  BTFSS  F9E.4
19900:  BRA    198FE
19902:  MOVWF  FAD
19904:  MOVLW  10
19906:  MOVWF  FE9
19908:  CLRF   1B
1990A:  BTFSC  FF2.7
1990C:  BSF    1B.7
1990E:  BCF    FF2.7
19910:  MOVFF  743,A41
19914:  MOVFF  742,A40
19918:  CALL   11A6
1991C:  BTFSC  1B.7
1991E:  BSF    FF2.7
19920:  MOVLW  0D
19922:  BTFSS  F9E.4
19924:  BRA    19922
19926:  MOVWF  FAD
19928:  MOVLW  0A
1992A:  BTFSS  F9E.4
1992C:  BRA    1992A
1992E:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19930:  MOVFF  755,A11
19934:  MOVFF  754,A10
19938:  MOVLB  A
1993A:  CLRF   x13
1993C:  MOVLW  64
1993E:  MOVWF  x12
19940:  MOVLB  0
19942:  CALL   5C98
19946:  MOVFF  02,88C
1994A:  MOVFF  01,88B
1994E:  MOVFF  02,8DC
19952:  MOVFF  01,8DB
19956:  MOVLW  01
19958:  MOVLB  8
1995A:  MOVWF  xDE
1995C:  SETF   xDD
1995E:  MOVLB  0
19960:  CALL   2CD4
19964:  MOVFF  02,886
19968:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
1996C:  MOVFF  759,A11
19970:  MOVFF  758,A10
19974:  MOVLB  A
19976:  CLRF   x13
19978:  MOVLW  64
1997A:  MOVWF  x12
1997C:  MOVLB  0
1997E:  CALL   5C98
19982:  MOVFF  02,88C
19986:  MOVFF  01,88B
1998A:  MOVFF  02,8DC
1998E:  MOVFF  01,8DB
19992:  MOVLW  01
19994:  MOVLB  8
19996:  MOVWF  xDE
19998:  SETF   xDD
1999A:  MOVLB  0
1999C:  CALL   2CD4
199A0:  MOVFF  02,888
199A4:  MOVFF  01,887
....................       step_us  =   m_stp_int[1]*100; 
199A8:  MOVFF  74D,A11
199AC:  MOVFF  74C,A10
199B0:  MOVLB  A
199B2:  CLRF   x13
199B4:  MOVLW  64
199B6:  MOVWF  x12
199B8:  MOVLB  0
199BA:  CALL   5C98
199BE:  MOVFF  02,88A
199C2:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
199C6:  MOVLW  26
199C8:  MOVWF  FF6
199CA:  MOVLW  27
199CC:  MOVWF  FF7
199CE:  MOVLW  00
199D0:  MOVWF  FF8
199D2:  CLRF   1B
199D4:  BTFSC  FF2.7
199D6:  BSF    1B.7
199D8:  BCF    FF2.7
199DA:  CALL   0E4E
199DE:  BTFSC  1B.7
199E0:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
199E2:  MOVLW  62
199E4:  BTFSS  F9E.4
199E6:  BRA    199E4
199E8:  MOVWF  FAD
199EA:  MOVLW  3A
199EC:  BTFSS  F9E.4
199EE:  BRA    199EC
199F0:  MOVWF  FAD
199F2:  MOVLW  10
199F4:  MOVWF  FE9
199F6:  CLRF   1B
199F8:  BTFSC  FF2.7
199FA:  BSF    1B.7
199FC:  BCF    FF2.7
199FE:  MOVFF  775,A41
19A02:  MOVFF  774,A40
19A06:  CALL   11A6
19A0A:  BTFSC  1B.7
19A0C:  BSF    FF2.7
19A0E:  MOVLW  0D
19A10:  BTFSS  F9E.4
19A12:  BRA    19A10
19A14:  MOVWF  FAD
19A16:  MOVLW  0A
19A18:  BTFSS  F9E.4
19A1A:  BRA    19A18
19A1C:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
19A1E:  MOVLW  63
19A20:  BTFSS  F9E.4
19A22:  BRA    19A20
19A24:  MOVWF  FAD
19A26:  MOVLW  3A
19A28:  BTFSS  F9E.4
19A2A:  BRA    19A28
19A2C:  MOVWF  FAD
19A2E:  MOVLW  41
19A30:  MOVWF  FE9
19A32:  CLRF   1B
19A34:  BTFSC  FF2.7
19A36:  BSF    1B.7
19A38:  BCF    FF2.7
19A3A:  MOVFF  7A9,A43
19A3E:  MOVFF  7A8,A42
19A42:  MOVFF  7A7,A41
19A46:  MOVFF  7A6,A40
19A4A:  CALL   10EA
19A4E:  BTFSC  1B.7
19A50:  BSF    FF2.7
19A52:  MOVLW  2F
19A54:  BTFSS  F9E.4
19A56:  BRA    19A54
19A58:  MOVWF  FAD
19A5A:  MOVLW  10
19A5C:  MOVWF  FE9
19A5E:  CLRF   1B
19A60:  BTFSC  FF2.7
19A62:  BSF    1B.7
19A64:  BCF    FF2.7
19A66:  MOVFF  7BE,A41
19A6A:  MOVFF  7BD,A40
19A6E:  CALL   11A6
19A72:  BTFSC  1B.7
19A74:  BSF    FF2.7
19A76:  MOVLW  2F
19A78:  BTFSS  F9E.4
19A7A:  BRA    19A78
19A7C:  MOVWF  FAD
19A7E:  MOVLW  10
19A80:  MOVWF  FE9
19A82:  CLRF   1B
19A84:  BTFSC  FF2.7
19A86:  BSF    1B.7
19A88:  BCF    FF2.7
19A8A:  MOVFF  7C2,A41
19A8E:  MOVFF  7C1,A40
19A92:  CALL   11A6
19A96:  BTFSC  1B.7
19A98:  BSF    FF2.7
19A9A:  MOVLW  0D
19A9C:  BTFSS  F9E.4
19A9E:  BRA    19A9C
19AA0:  MOVWF  FAD
19AA2:  MOVLW  0A
19AA4:  BTFSS  F9E.4
19AA6:  BRA    19AA4
19AA8:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
19AAA:  MOVLW  64
19AAC:  BTFSS  F9E.4
19AAE:  BRA    19AAC
19AB0:  MOVWF  FAD
19AB2:  MOVLW  3A
19AB4:  BTFSS  F9E.4
19AB6:  BRA    19AB4
19AB8:  MOVWF  FAD
19ABA:  MOVLW  10
19ABC:  MOVWF  FE9
19ABE:  CLRF   1B
19AC0:  BTFSC  FF2.7
19AC2:  BSF    1B.7
19AC4:  BCF    FF2.7
19AC6:  MOVFF  751,A41
19ACA:  MOVFF  750,A40
19ACE:  CALL   11A6
19AD2:  BTFSC  1B.7
19AD4:  BSF    FF2.7
19AD6:  MOVLW  0D
19AD8:  BTFSS  F9E.4
19ADA:  BRA    19AD8
19ADC:  MOVWF  FAD
19ADE:  MOVLW  0A
19AE0:  BTFSS  F9E.4
19AE2:  BRA    19AE0
19AE4:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
19AE6:  MOVLW  65
19AE8:  BTFSS  F9E.4
19AEA:  BRA    19AE8
19AEC:  MOVWF  FAD
19AEE:  MOVLW  3A
19AF0:  BTFSS  F9E.4
19AF2:  BRA    19AF0
19AF4:  MOVWF  FAD
19AF6:  MOVLW  10
19AF8:  MOVWF  FE9
19AFA:  CLRF   1B
19AFC:  BTFSC  FF2.7
19AFE:  BSF    1B.7
19B00:  BCF    FF2.7
19B02:  MOVFF  761,A41
19B06:  MOVFF  760,A40
19B0A:  CALL   11A6
19B0E:  BTFSC  1B.7
19B10:  BSF    FF2.7
19B12:  MOVLW  0D
19B14:  BTFSS  F9E.4
19B16:  BRA    19B14
19B18:  MOVWF  FAD
19B1A:  MOVLW  0A
19B1C:  BTFSS  F9E.4
19B1E:  BRA    19B1C
19B20:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19B22:  MOVLW  66
19B24:  BTFSS  F9E.4
19B26:  BRA    19B24
19B28:  MOVWF  FAD
19B2A:  MOVLW  3A
19B2C:  BTFSS  F9E.4
19B2E:  BRA    19B2C
19B30:  MOVWF  FAD
19B32:  CLRF   1B
19B34:  BTFSC  FF2.7
19B36:  BSF    1B.7
19B38:  BCF    FF2.7
19B3A:  MOVFF  741,A40
19B3E:  MOVLW  1B
19B40:  MOVLB  A
19B42:  MOVWF  x41
19B44:  MOVLB  0
19B46:  CALL   0FA6
19B4A:  BTFSC  1B.7
19B4C:  BSF    FF2.7
19B4E:  MOVLW  0D
19B50:  BTFSS  F9E.4
19B52:  BRA    19B50
19B54:  MOVWF  FAD
19B56:  MOVLW  0A
19B58:  BTFSS  F9E.4
19B5A:  BRA    19B58
19B5C:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
19B5E:  MOVLW  67
19B60:  BTFSS  F9E.4
19B62:  BRA    19B60
19B64:  MOVWF  FAD
19B66:  MOVLW  3A
19B68:  BTFSS  F9E.4
19B6A:  BRA    19B68
19B6C:  MOVWF  FAD
19B6E:  MOVLW  10
19B70:  MOVWF  FE9
19B72:  CLRF   1B
19B74:  BTFSC  FF2.7
19B76:  BSF    1B.7
19B78:  BCF    FF2.7
19B7A:  MOVFF  75D,A41
19B7E:  MOVFF  75C,A40
19B82:  CALL   11A6
19B86:  BTFSC  1B.7
19B88:  BSF    FF2.7
19B8A:  MOVLW  0D
19B8C:  BTFSS  F9E.4
19B8E:  BRA    19B8C
19B90:  MOVWF  FAD
19B92:  MOVLW  0A
19B94:  BTFSS  F9E.4
19B96:  BRA    19B94
19B98:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19B9A:  MOVLW  68
19B9C:  BTFSS  F9E.4
19B9E:  BRA    19B9C
19BA0:  MOVWF  FAD
19BA2:  MOVLW  3A
19BA4:  BTFSS  F9E.4
19BA6:  BRA    19BA4
19BA8:  MOVWF  FAD
19BAA:  MOVLW  10
19BAC:  MOVWF  FE9
19BAE:  CLRF   1B
19BB0:  BTFSC  FF2.7
19BB2:  BSF    1B.7
19BB4:  BCF    FF2.7
19BB6:  MOVFF  886,A41
19BBA:  MOVFF  885,A40
19BBE:  CALL   11A6
19BC2:  BTFSC  1B.7
19BC4:  BSF    FF2.7
19BC6:  MOVLW  0D
19BC8:  BTFSS  F9E.4
19BCA:  BRA    19BC8
19BCC:  MOVWF  FAD
19BCE:  MOVLW  0A
19BD0:  BTFSS  F9E.4
19BD2:  BRA    19BD0
19BD4:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
19BD6:  MOVLW  69
19BD8:  BTFSS  F9E.4
19BDA:  BRA    19BD8
19BDC:  MOVWF  FAD
19BDE:  MOVLW  3A
19BE0:  BTFSS  F9E.4
19BE2:  BRA    19BE0
19BE4:  MOVWF  FAD
19BE6:  MOVLW  10
19BE8:  MOVWF  FE9
19BEA:  CLRF   1B
19BEC:  BTFSC  FF2.7
19BEE:  BSF    1B.7
19BF0:  BCF    FF2.7
19BF2:  MOVFF  88A,A41
19BF6:  MOVFF  889,A40
19BFA:  CALL   11A6
19BFE:  BTFSC  1B.7
19C00:  BSF    FF2.7
19C02:  MOVLW  0D
19C04:  BTFSS  F9E.4
19C06:  BRA    19C04
19C08:  MOVWF  FAD
19C0A:  MOVLW  0A
19C0C:  BTFSS  F9E.4
19C0E:  BRA    19C0C
19C10:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
19C12:  MOVLW  6A
19C14:  BTFSS  F9E.4
19C16:  BRA    19C14
19C18:  MOVWF  FAD
19C1A:  MOVLW  3A
19C1C:  BTFSS  F9E.4
19C1E:  BRA    19C1C
19C20:  MOVWF  FAD
19C22:  MOVLW  10
19C24:  MOVWF  FE9
19C26:  CLRF   1B
19C28:  BTFSC  FF2.7
19C2A:  BSF    1B.7
19C2C:  BCF    FF2.7
19C2E:  MOVFF  771,A41
19C32:  MOVFF  770,A40
19C36:  CALL   11A6
19C3A:  BTFSC  1B.7
19C3C:  BSF    FF2.7
19C3E:  MOVLW  0D
19C40:  BTFSS  F9E.4
19C42:  BRA    19C40
19C44:  MOVWF  FAD
19C46:  MOVLW  0A
19C48:  BTFSS  F9E.4
19C4A:  BRA    19C48
19C4C:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
19C4E:  MOVLW  6B
19C50:  BTFSS  F9E.4
19C52:  BRA    19C50
19C54:  MOVWF  FAD
19C56:  MOVLW  3A
19C58:  BTFSS  F9E.4
19C5A:  BRA    19C58
19C5C:  MOVWF  FAD
19C5E:  MOVLW  10
19C60:  MOVWF  FE9
19C62:  CLRF   1B
19C64:  BTFSC  FF2.7
19C66:  BSF    1B.7
19C68:  BCF    FF2.7
19C6A:  MOVFF  769,A41
19C6E:  MOVFF  768,A40
19C72:  CALL   11A6
19C76:  BTFSC  1B.7
19C78:  BSF    FF2.7
19C7A:  MOVLW  0D
19C7C:  BTFSS  F9E.4
19C7E:  BRA    19C7C
19C80:  MOVWF  FAD
19C82:  MOVLW  0A
19C84:  BTFSS  F9E.4
19C86:  BRA    19C84
19C88:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
19C8A:  MOVLW  6D
19C8C:  BTFSS  F9E.4
19C8E:  BRA    19C8C
19C90:  MOVWF  FAD
19C92:  MOVLW  3A
19C94:  BTFSS  F9E.4
19C96:  BRA    19C94
19C98:  MOVWF  FAD
19C9A:  MOVLW  10
19C9C:  MOVWF  FE9
19C9E:  CLRF   1B
19CA0:  BTFSC  FF2.7
19CA2:  BSF    1B.7
19CA4:  BCF    FF2.7
19CA6:  MOVFF  749,A41
19CAA:  MOVFF  748,A40
19CAE:  CALL   11A6
19CB2:  BTFSC  1B.7
19CB4:  BSF    FF2.7
19CB6:  MOVLW  0D
19CB8:  BTFSS  F9E.4
19CBA:  BRA    19CB8
19CBC:  MOVWF  FAD
19CBE:  MOVLW  0A
19CC0:  BTFSS  F9E.4
19CC2:  BRA    19CC0
19CC4:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
19CC6:  MOVLW  6E
19CC8:  BTFSS  F9E.4
19CCA:  BRA    19CC8
19CCC:  MOVWF  FAD
19CCE:  MOVLW  3A
19CD0:  BTFSS  F9E.4
19CD2:  BRA    19CD0
19CD4:  MOVWF  FAD
19CD6:  MOVLW  10
19CD8:  MOVWF  FE9
19CDA:  CLRF   1B
19CDC:  BTFSC  FF2.7
19CDE:  BSF    1B.7
19CE0:  BCF    FF2.7
19CE2:  MOVFF  77D,A41
19CE6:  MOVFF  77C,A40
19CEA:  CALL   11A6
19CEE:  BTFSC  1B.7
19CF0:  BSF    FF2.7
19CF2:  MOVLW  0D
19CF4:  BTFSS  F9E.4
19CF6:  BRA    19CF4
19CF8:  MOVWF  FAD
19CFA:  MOVLW  0A
19CFC:  BTFSS  F9E.4
19CFE:  BRA    19CFC
19D00:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
19D02:  MOVLW  6F
19D04:  BTFSS  F9E.4
19D06:  BRA    19D04
19D08:  MOVWF  FAD
19D0A:  MOVLW  3A
19D0C:  BTFSS  F9E.4
19D0E:  BRA    19D0C
19D10:  MOVWF  FAD
19D12:  MOVLW  10
19D14:  MOVWF  FE9
19D16:  CLRF   1B
19D18:  BTFSC  FF2.7
19D1A:  BSF    1B.7
19D1C:  BCF    FF2.7
19D1E:  MOVFF  781,A41
19D22:  MOVFF  780,A40
19D26:  CALL   11A6
19D2A:  BTFSC  1B.7
19D2C:  BSF    FF2.7
19D2E:  MOVLW  0D
19D30:  BTFSS  F9E.4
19D32:  BRA    19D30
19D34:  MOVWF  FAD
19D36:  MOVLW  0A
19D38:  BTFSS  F9E.4
19D3A:  BRA    19D38
19D3C:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
19D3E:  MOVLW  70
19D40:  BTFSS  F9E.4
19D42:  BRA    19D40
19D44:  MOVWF  FAD
19D46:  MOVLW  3A
19D48:  BTFSS  F9E.4
19D4A:  BRA    19D48
19D4C:  MOVWF  FAD
19D4E:  MOVLW  10
19D50:  MOVWF  FE9
19D52:  CLRF   1B
19D54:  BTFSC  FF2.7
19D56:  BSF    1B.7
19D58:  BCF    FF2.7
19D5A:  MOVFF  7C6,A41
19D5E:  MOVFF  7C5,A40
19D62:  CALL   11A6
19D66:  BTFSC  1B.7
19D68:  BSF    FF2.7
19D6A:  MOVLW  2F
19D6C:  BTFSS  F9E.4
19D6E:  BRA    19D6C
19D70:  MOVWF  FAD
19D72:  MOVLW  10
19D74:  MOVWF  FE9
19D76:  CLRF   1B
19D78:  BTFSC  FF2.7
19D7A:  BSF    1B.7
19D7C:  BCF    FF2.7
19D7E:  MOVFF  765,A41
19D82:  MOVFF  764,A40
19D86:  CALL   11A6
19D8A:  BTFSC  1B.7
19D8C:  BSF    FF2.7
19D8E:  MOVLW  0D
19D90:  BTFSS  F9E.4
19D92:  BRA    19D90
19D94:  MOVWF  FAD
19D96:  MOVLW  0A
19D98:  BTFSS  F9E.4
19D9A:  BRA    19D98
19D9C:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
19D9E:  MOVLW  71
19DA0:  BTFSS  F9E.4
19DA2:  BRA    19DA0
19DA4:  MOVWF  FAD
19DA6:  MOVLW  3A
19DA8:  BTFSS  F9E.4
19DAA:  BRA    19DA8
19DAC:  MOVWF  FAD
19DAE:  MOVLW  10
19DB0:  MOVWF  FE9
19DB2:  CLRF   1B
19DB4:  BTFSC  FF2.7
19DB6:  BSF    1B.7
19DB8:  BCF    FF2.7
19DBA:  MOVFF  799,A41
19DBE:  MOVFF  798,A40
19DC2:  CALL   11A6
19DC6:  BTFSC  1B.7
19DC8:  BSF    FF2.7
19DCA:  MOVLW  0D
19DCC:  BTFSS  F9E.4
19DCE:  BRA    19DCC
19DD0:  MOVWF  FAD
19DD2:  MOVLW  0A
19DD4:  BTFSS  F9E.4
19DD6:  BRA    19DD4
19DD8:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
19DDA:  MOVLW  73
19DDC:  BTFSS  F9E.4
19DDE:  BRA    19DDC
19DE0:  MOVWF  FAD
19DE2:  MOVLW  3A
19DE4:  BTFSS  F9E.4
19DE6:  BRA    19DE4
19DE8:  MOVWF  FAD
19DEA:  MOVLW  10
19DEC:  MOVWF  FE9
19DEE:  CLRF   1B
19DF0:  BTFSC  FF2.7
19DF2:  BSF    1B.7
19DF4:  BCF    FF2.7
19DF6:  MOVFF  779,A41
19DFA:  MOVFF  778,A40
19DFE:  CALL   11A6
19E02:  BTFSC  1B.7
19E04:  BSF    FF2.7
19E06:  MOVLW  0D
19E08:  BTFSS  F9E.4
19E0A:  BRA    19E08
19E0C:  MOVWF  FAD
19E0E:  MOVLW  0A
19E10:  BTFSS  F9E.4
19E12:  BRA    19E10
19E14:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
19E16:  MOVLW  74
19E18:  BTFSS  F9E.4
19E1A:  BRA    19E18
19E1C:  MOVWF  FAD
19E1E:  MOVLW  3A
19E20:  BTFSS  F9E.4
19E22:  BRA    19E20
19E24:  MOVWF  FAD
19E26:  MOVLW  10
19E28:  MOVWF  FE9
19E2A:  CLRF   1B
19E2C:  BTFSC  FF2.7
19E2E:  BSF    1B.7
19E30:  BCF    FF2.7
19E32:  MOVFF  76D,A41
19E36:  MOVFF  76C,A40
19E3A:  CALL   11A6
19E3E:  BTFSC  1B.7
19E40:  BSF    FF2.7
19E42:  MOVLW  0D
19E44:  BTFSS  F9E.4
19E46:  BRA    19E44
19E48:  MOVWF  FAD
19E4A:  MOVLW  0A
19E4C:  BTFSS  F9E.4
19E4E:  BRA    19E4C
19E50:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19E52:  MOVLW  01
19E54:  MOVLB  7
19E56:  ADDWF  x40,W
19E58:  MOVLB  8
19E5A:  MOVWF  x8B
19E5C:  MOVLW  75
19E5E:  BTFSS  F9E.4
19E60:  BRA    19E5E
19E62:  MOVWF  FAD
19E64:  MOVLW  3A
19E66:  BTFSS  F9E.4
19E68:  BRA    19E66
19E6A:  MOVWF  FAD
19E6C:  CLRF   1B
19E6E:  BTFSC  FF2.7
19E70:  BSF    1B.7
19E72:  BCF    FF2.7
19E74:  MOVFF  88B,A40
19E78:  MOVLW  1B
19E7A:  MOVLB  A
19E7C:  MOVWF  x41
19E7E:  MOVLB  0
19E80:  CALL   0FA6
19E84:  BTFSC  1B.7
19E86:  BSF    FF2.7
19E88:  MOVLW  0D
19E8A:  BTFSS  F9E.4
19E8C:  BRA    19E8A
19E8E:  MOVWF  FAD
19E90:  MOVLW  0A
19E92:  BTFSS  F9E.4
19E94:  BRA    19E92
19E96:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19E98:  MOVLW  77
19E9A:  BTFSS  F9E.4
19E9C:  BRA    19E9A
19E9E:  MOVWF  FAD
19EA0:  MOVLW  3A
19EA2:  BTFSS  F9E.4
19EA4:  BRA    19EA2
19EA6:  MOVWF  FAD
19EA8:  MOVLW  10
19EAA:  MOVWF  FE9
19EAC:  CLRF   1B
19EAE:  BTFSC  FF2.7
19EB0:  BSF    1B.7
19EB2:  BCF    FF2.7
19EB4:  MOVFF  888,A41
19EB8:  MOVFF  887,A40
19EBC:  CALL   11A6
19EC0:  BTFSC  1B.7
19EC2:  BSF    FF2.7
19EC4:  MOVLW  0D
19EC6:  BTFSS  F9E.4
19EC8:  BRA    19EC6
19ECA:  MOVWF  FAD
19ECC:  MOVLW  0A
19ECE:  BTFSS  F9E.4
19ED0:  BRA    19ECE
19ED2:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
19ED4:  MOVLW  78
19ED6:  BTFSS  F9E.4
19ED8:  BRA    19ED6
19EDA:  MOVWF  FAD
19EDC:  MOVLW  3A
19EDE:  BTFSS  F9E.4
19EE0:  BRA    19EDE
19EE2:  MOVWF  FAD
19EE4:  MOVLW  10
19EE6:  MOVWF  FE9
19EE8:  CLRF   1B
19EEA:  BTFSC  FF2.7
19EEC:  BSF    1B.7
19EEE:  BCF    FF2.7
19EF0:  MOVFF  785,A41
19EF4:  MOVFF  784,A40
19EF8:  CALL   11A6
19EFC:  BTFSC  1B.7
19EFE:  BSF    FF2.7
19F00:  MOVLW  0D
19F02:  BTFSS  F9E.4
19F04:  BRA    19F02
19F06:  MOVWF  FAD
19F08:  MOVLW  0A
19F0A:  BTFSS  F9E.4
19F0C:  BRA    19F0A
19F0E:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
19F10:  MOVLW  79
19F12:  BTFSS  F9E.4
19F14:  BRA    19F12
19F16:  MOVWF  FAD
19F18:  MOVLW  3A
19F1A:  BTFSS  F9E.4
19F1C:  BRA    19F1A
19F1E:  MOVWF  FAD
19F20:  MOVLW  10
19F22:  MOVWF  FE9
19F24:  CLRF   1B
19F26:  BTFSC  FF2.7
19F28:  BSF    1B.7
19F2A:  BCF    FF2.7
19F2C:  MOVFF  745,A41
19F30:  MOVFF  744,A40
19F34:  CALL   11A6
19F38:  BTFSC  1B.7
19F3A:  BSF    FF2.7
19F3C:  MOVLW  0D
19F3E:  BTFSS  F9E.4
19F40:  BRA    19F3E
19F42:  MOVWF  FAD
19F44:  MOVLW  0A
19F46:  BTFSS  F9E.4
19F48:  BRA    19F46
19F4A:  MOVWF  FAD
....................    } 
19F4C:  BRA    19F52
....................    else cmd_arg(); 
19F4E:  CALL   B2C2
19F52:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BF0A:  MOVF   48,W
0BF0C:  SUBLW  0D
0BF0E:  BNZ   BF2E
0BF10:  MOVF   49,W
0BF12:  SUBLW  07
0BF14:  BNZ   BF2E
0BF16:  MOVF   4A,F
0BF18:  BNZ   BF2E
0BF1A:  MOVF   4B,F
0BF1C:  BNZ   BF2E
0BF1E:  MOVLW  03
0BF20:  MOVLB  8
0BF22:  MOVWF  x8A
0BF24:  MOVLW  15
0BF26:  MOVWF  x89
0BF28:  MOVLB  0
0BF2A:  RCALL  BAE8
0BF2C:  BRA    BF50
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BF2E:  MOVF   48,W
0BF30:  SUBLW  98
0BF32:  BNZ   BF50
0BF34:  MOVF   49,W
0BF36:  SUBLW  07
0BF38:  BNZ   BF50
0BF3A:  MOVF   4A,F
0BF3C:  BNZ   BF50
0BF3E:  MOVF   4B,F
0BF40:  BNZ   BF50
0BF42:  MOVLW  03
0BF44:  MOVLB  8
0BF46:  MOVWF  x8A
0BF48:  MOVLW  15
0BF4A:  MOVWF  x89
0BF4C:  MOVLB  0
0BF4E:  RCALL  BC62
0BF50:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0B31C:  MOVF   48,W
0B31E:  MOVWF  00
0B320:  MOVFF  49,03
0B324:  MOVLW  15
0B326:  SUBWF  49,W
0B328:  BNZ   B330
0B32A:  MOVLW  95
0B32C:  SUBWF  00,W
0B32E:  BZ    B356
0B330:  MOVLW  15
0B332:  SUBWF  03,W
0B334:  BNZ   B33C
0B336:  MOVLW  96
0B338:  SUBWF  00,W
0B33A:  BZ    B388
0B33C:  MOVLW  15
0B33E:  SUBWF  03,W
0B340:  BNZ   B348
0B342:  MOVLW  97
0B344:  SUBWF  00,W
0B346:  BZ    B3BE
0B348:  MOVLW  15
0B34A:  SUBWF  03,W
0B34C:  BNZ   B354
0B34E:  MOVLW  98
0B350:  SUBWF  00,W
0B352:  BZ    B3F4
0B354:  BRA    B428
....................       case 5525 : nv_product = ECO; 
0B356:  CLRF   30
0B358:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B35A:  MOVLW  1E
0B35C:  MOVLB  8
0B35E:  MOVWF  xEE
0B360:  CLRF   xF0
0B362:  CLRF   xEF
0B364:  MOVLB  0
0B366:  CALL   4FD4
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B36A:  MOVLW  01
0B36C:  MOVWF  1E
0B36E:  MOVLW  A7
0B370:  MOVWF  1D
0B372:  MOVLW  32
0B374:  MOVWF  FF6
0B376:  MOVLW  27
0B378:  MOVWF  FF7
0B37A:  MOVLW  00
0B37C:  MOVWF  FF8
0B37E:  CALL   50BE
....................                   record_event(); 
0B382:  CALL   84DA
....................          break; 
0B386:  BRA    B428
....................       case 5526 : nv_product = WMS4; 
0B388:  CLRF   30
0B38A:  MOVLW  01
0B38C:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B38E:  MOVLW  1E
0B390:  MOVLB  8
0B392:  MOVWF  xEE
0B394:  CLRF   xF0
0B396:  MOVLW  01
0B398:  MOVWF  xEF
0B39A:  MOVLB  0
0B39C:  CALL   4FD4
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B3A0:  MOVLW  01
0B3A2:  MOVWF  1E
0B3A4:  MOVLW  A7
0B3A6:  MOVWF  1D
0B3A8:  MOVLW  42
0B3AA:  MOVWF  FF6
0B3AC:  MOVLW  27
0B3AE:  MOVWF  FF7
0B3B0:  MOVLW  00
0B3B2:  MOVWF  FF8
0B3B4:  CALL   50BE
....................                   record_event();                   
0B3B8:  CALL   84DA
....................          break;    
0B3BC:  BRA    B428
....................       case 5527 : nv_product = AWS; 
0B3BE:  CLRF   30
0B3C0:  MOVLW  02
0B3C2:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B3C4:  MOVLW  1E
0B3C6:  MOVLB  8
0B3C8:  MOVWF  xEE
0B3CA:  CLRF   xF0
0B3CC:  MOVLW  02
0B3CE:  MOVWF  xEF
0B3D0:  MOVLB  0
0B3D2:  CALL   4FD4
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B3D6:  MOVLW  01
0B3D8:  MOVWF  1E
0B3DA:  MOVLW  A7
0B3DC:  MOVWF  1D
0B3DE:  MOVLW  58
0B3E0:  MOVWF  FF6
0B3E2:  MOVLW  27
0B3E4:  MOVWF  FF7
0B3E6:  MOVLW  00
0B3E8:  MOVWF  FF8
0B3EA:  CALL   50BE
....................                   record_event();                   
0B3EE:  CALL   84DA
....................          break;   
0B3F2:  BRA    B428
....................       case 5528 : nv_product = WMS2; 
0B3F4:  CLRF   30
0B3F6:  MOVLW  03
0B3F8:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B3FA:  MOVLW  1E
0B3FC:  MOVLB  8
0B3FE:  MOVWF  xEE
0B400:  CLRF   xF0
0B402:  MOVLW  03
0B404:  MOVWF  xEF
0B406:  MOVLB  0
0B408:  CALL   4FD4
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B40C:  MOVLW  01
0B40E:  MOVWF  1E
0B410:  MOVLW  A7
0B412:  MOVWF  1D
0B414:  MOVLW  68
0B416:  MOVWF  FF6
0B418:  MOVLW  27
0B41A:  MOVWF  FF7
0B41C:  MOVLW  00
0B41E:  MOVWF  FF8
0B420:  CALL   50BE
....................                   record_event();                   
0B424:  CALL   84DA
....................          break;            
....................    } 
0B428:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0B2E0:  MOVF   48,W
0B2E2:  MOVWF  00
0B2E4:  MOVF   49,W
0B2E6:  MOVWF  03
0B2E8:  BNZ   B2EE
0B2EA:  MOVF   00,F
0B2EC:  BZ    B304
0B2EE:  MOVF   03,W
0B2F0:  BNZ   B2F8
0B2F2:  MOVLW  01
0B2F4:  SUBWF  00,W
0B2F6:  BZ    B30A
0B2F8:  MOVF   03,W
0B2FA:  BNZ   B302
0B2FC:  MOVLW  02
0B2FE:  SUBWF  00,W
0B300:  BZ    B310
0B302:  BRA    B316
....................       case 0 : kill_wd(); 
0B304:  CALL   30F6
....................          break; 
0B308:  BRA    B318
....................       case 1 : start_heartbeat(); 
0B30A:  CALL   2900
....................          break; 
0B30E:  BRA    B318
....................       case 2 : suspend_heartbeat(); 
0B310:  CALL   5554
....................          break; 
0B314:  BRA    B318
....................       default : cmd_arg(); 
0B316:  RCALL  B2C2
....................          break; 
....................    } 
0B318:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0B220:  MOVF   48,W
0B222:  MOVWF  00
0B224:  MOVF   49,W
0B226:  MOVWF  03
0B228:  BNZ   B22E
0B22A:  MOVF   00,F
0B22C:  BZ    B23C
0B22E:  MOVLW  15
0B230:  SUBWF  03,W
0B232:  BNZ   B23A
0B234:  MOVLW  95
0B236:  SUBWF  00,W
0B238:  BZ    B29A
0B23A:  BRA    B2BE
....................       case 0:     signon(); 
0B23C:  CALL   3148
....................                   fprintf(COM_A, __DATE__); 
0B240:  MOVLW  7E
0B242:  MOVWF  FF6
0B244:  MOVLW  27
0B246:  MOVWF  FF7
0B248:  MOVLW  00
0B24A:  MOVWF  FF8
0B24C:  CLRF   1B
0B24E:  BTFSC  FF2.7
0B250:  BSF    1B.7
0B252:  BCF    FF2.7
0B254:  CALL   0E4E
0B258:  BTFSC  1B.7
0B25A:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B25C:  MOVLW  0D
0B25E:  BTFSS  F9E.4
0B260:  BRA    B25E
0B262:  MOVWF  FAD
0B264:  MOVLW  0A
0B266:  BTFSS  F9E.4
0B268:  BRA    B266
0B26A:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0B26C:  MOVLW  88
0B26E:  MOVWF  FF6
0B270:  MOVLW  27
0B272:  MOVWF  FF7
0B274:  MOVLW  00
0B276:  MOVWF  FF8
0B278:  CLRF   1B
0B27A:  BTFSC  FF2.7
0B27C:  BSF    1B.7
0B27E:  BCF    FF2.7
0B280:  CALL   0E4E
0B284:  BTFSC  1B.7
0B286:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B288:  MOVLW  0D
0B28A:  BTFSS  F9E.4
0B28C:  BRA    B28A
0B28E:  MOVWF  FAD
0B290:  MOVLW  0A
0B292:  BTFSS  F9E.4
0B294:  BRA    B292
0B296:  MOVWF  FAD
....................          break; 
0B298:  BRA    B2BE
....................       case 5525 : kill_wd(); 
0B29A:  CALL   30F6
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0B29E:  MOVLW  92
0B2A0:  MOVWF  FF6
0B2A2:  MOVLW  27
0B2A4:  MOVWF  FF7
0B2A6:  MOVLW  00
0B2A8:  MOVWF  FF8
0B2AA:  CLRF   1B
0B2AC:  BTFSC  FF2.7
0B2AE:  BSF    1B.7
0B2B0:  BCF    FF2.7
0B2B2:  CALL   0E4E
0B2B6:  BTFSC  1B.7
0B2B8:  BSF    FF2.7
....................                   load_program(); 
0B2BA:  CALL   1F800
....................          break; 
....................    } 
0B2BE:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
18C02:  MOVF   48,W
18C04:  MOVWF  00
18C06:  MOVF   49,W
18C08:  MOVWF  03
18C0A:  BNZ   18C10
18C0C:  MOVF   00,F
18C0E:  BZ    18C1C
18C10:  MOVF   03,W
18C12:  BNZ   18C1A
18C14:  MOVLW  01
18C16:  SUBWF  00,W
18C18:  BZ    18C20
18C1A:  BRA    18C24
....................       case 0 : cmd_set=0;  // user 
18C1C:  CLRF   51
....................          break; 
18C1E:  BRA    18C24
....................       case 1 : cmd_set=1;  // full 
18C20:  MOVLW  01
18C22:  MOVWF  51
....................          break; 
....................    } 
18C24:  GOTO   1B2FE (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1B162:  CALL   AE74
....................     
....................    switch (cmd) 
1B166:  MOVLW  23
1B168:  SUBWF  47,W
1B16A:  ADDLW  A8
1B16C:  BTFSC  FD8.0
1B16E:  BRA    1B2FE
1B170:  ADDLW  58
1B172:  GOTO   1B302
....................    { 
....................       case '&': commandFW(); 
1B176:  GOTO   B220
....................          break; 
1B17A:  BRA    1B2FE
....................       case '#': command_hash(); 
1B17C:  GOTO   B2E0
....................          break;          
1B180:  BRA    1B2FE
....................       case '%': command_prod(); 
1B182:  GOTO   B31C
....................          break; 
1B186:  BRA    1B2FE
....................       case '*': command_star(); 
1B188:  GOTO   BF0A
....................          break;       
1B18C:  BRA    1B2FE
....................       // standard commands 
....................       case '/': command_addr(); 
1B18E:  GOTO   BF54
....................          break; 
1B192:  BRA    1B2FE
....................       case 'A': commandA(); 
1B194:  GOTO   C0EE
....................          break; 
1B198:  BRA    1B2FE
....................       case 'B': commandB(); 
1B19A:  GOTO   C25A
....................          break; 
1B19E:  BRA    1B2FE
....................       case 'C': commandC(); 
1B1A0:  GOTO   DC7E
....................          break; 
1B1A4:  BRA    1B2FE
....................       case 'D': commandD(); 
1B1A6:  GOTO   DCBC
....................          break; 
1B1AA:  BRA    1B2FE
....................       case 'E': commandE(); 
1B1AC:  GOTO   DD5A
....................          break;          
1B1B0:  BRA    1B2FE
....................       case 'F': commandF(); 
1B1B2:  GOTO   E058
....................          break;          
1B1B6:  BRA    1B2FE
....................       case 'G': commandG(); 
1B1B8:  GOTO   E0C2
....................          break; 
1B1BC:  BRA    1B2FE
....................       case 'H': commandH(); 
1B1BE:  GOTO   F220
....................          break; 
1B1C2:  BRA    1B2FE
....................       case 'I': commandI(); 
1B1C4:  GOTO   F260
....................          break;    
1B1C8:  BRA    1B2FE
....................       case 'J': commandJ(); 
1B1CA:  GOTO   F2AC
....................          break;      
1B1CE:  BRA    1B2FE
....................       case 'K': commandK(); 
1B1D0:  GOTO   F506
....................          break;    
1B1D4:  BRA    1B2FE
....................       case 'L': commandL(); 
1B1D6:  GOTO   FFCC
....................          break;             
1B1DA:  BRA    1B2FE
....................       case 'M': commandM(FALSE); 
1B1DC:  MOVLB  8
1B1DE:  CLRF   x85
1B1E0:  MOVLB  0
1B1E2:  CALL   16D64
....................          break;   
1B1E6:  BRA    1B2FE
....................       case 'N': commandN(); 
1B1E8:  GOTO   16E82
....................          break;          
1B1EC:  BRA    1B2FE
....................       case 'O': commandO(); 
1B1EE:  GOTO   17032
....................          break;    
1B1F2:  BRA    1B2FE
....................       case 'P': commandP(); 
1B1F4:  GOTO   17236
....................          break;  
1B1F8:  BRA    1B2FE
....................       case 'Q': commandQ(); 
1B1FA:  GOTO   172F4
....................          break;              
1B1FE:  BRA    1B2FE
....................       case 'R': commandR(); 
1B200:  GOTO   1758A
....................          break;    
1B204:  BRA    1B2FE
....................       case 'S': commandS(); 
1B206:  GOTO   176B6
....................          break;  
1B20A:  BRA    1B2FE
....................       case 'T': commandT(); 
1B20C:  GOTO   17C54
....................          break;            
1B210:  BRA    1B2FE
....................       case 'U': commandU(); 
1B212:  GOTO   1865C
....................          break;           
1B216:  BRA    1B2FE
....................       case 'V': commandV(); 
1B218:  GOTO   187B4
....................          break; 
1B21C:  BRA    1B2FE
....................       case 'W': commandW(); 
1B21E:  GOTO   18A4A
....................          break; 
1B222:  BRA    1B2FE
....................       case 'X': commandX(); 
1B224:  GOTO   18A6E
....................          break; 
1B228:  BRA    1B2FE
....................       case 'Y': commandY(); 
1B22A:  GOTO   18AD6
....................          break;  
1B22E:  BRA    1B2FE
....................       case 'Z': commandZ(); 
1B230:  CALL   18BDE
....................          break;    
1B234:  BRA    1B2FE
....................       // stepper 
....................       case '^': command_set(); 
1B236:  GOTO   18C02
....................          break;       
1B23A:  BRA    1B2FE
....................       case '+': if(m_fixed==1) motor=1; 
1B23C:  MOVLB  7
1B23E:  DECFSZ x41,W
1B240:  BRA    1B246
1B242:  MOVLW  01
1B244:  MOVWF  x40
....................                 command_move(0,0,1); 
1B246:  MOVLB  8
1B248:  CLRF   x85
1B24A:  CLRF   x86
1B24C:  MOVLW  01
1B24E:  MOVWF  x87
1B250:  MOVLB  0
1B252:  CALL   17056
....................          break; 
1B256:  BRA    1B2FE
....................       case '-': if(m_fixed==1) motor=1; 
1B258:  MOVLB  7
1B25A:  DECFSZ x41,W
1B25C:  BRA    1B262
1B25E:  MOVLW  01
1B260:  MOVWF  x40
....................                 command_move(0,1,1); 
1B262:  MOVLB  8
1B264:  CLRF   x85
1B266:  MOVLW  01
1B268:  MOVWF  x86
1B26A:  MOVWF  x87
1B26C:  MOVLB  0
1B26E:  CALL   17056
....................          break; 
1B272:  BRA    1B2FE
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1B274:  GOTO   18D2E
....................          break;     
1B278:  BRA    1B2FE
....................       case 'b': command_b(); 
1B27A:  GOTO   18D4A
....................          break; 
1B27E:  BRA    1B2FE
....................       case 'c': command_c(); 
1B280:  GOTO   18DE4
....................          break; 
1B284:  BRA    1B2FE
....................       case 'd': command_d(); 
1B286:  GOTO   18E2C
....................          break;          
1B28A:  BRA    1B2FE
....................       case 'e': command_e(); 
1B28C:  GOTO   18EC2
....................          break;       
1B290:  BRA    1B2FE
....................       case 'f': command_f(); 
1B292:  GOTO   18F5C
....................          break; 
1B296:  BRA    1B2FE
....................       case 'g': command_g(); 
1B298:  GOTO   18F7C
....................          break;          
1B29C:  BRA    1B2FE
....................       case 'h': command_h(); 
1B29E:  GOTO   19016
....................          break; 
1B2A2:  BRA    1B2FE
....................       case 'i': command_i(); 
1B2A4:  GOTO   190EA
....................          break;   
1B2A8:  BRA    1B2FE
....................       case 'j': command_j(); 
1B2AA:  GOTO   191C6
....................          break;           
1B2AE:  BRA    1B2FE
....................       case 'k': command_k(); 
1B2B0:  GOTO   19260
....................          break;          
1B2B4:  BRA    1B2FE
....................       case 'l': step_var_list(); 
1B2B6:  GOTO   192F6
....................          break;          
1B2BA:  BRA    1B2FE
....................       case 'm': command_m(); 
1B2BC:  GOTO   19F56
....................          break;    
1B2C0:  BRA    1B2FE
....................       case 'n': command_n(); 
1B2C2:  GOTO   19FEC
....................          break; 
1B2C6:  BRA    1B2FE
....................       case 'o': command_o(); 
1B2C8:  GOTO   1A082
....................          break;    
1B2CC:  BRA    1B2FE
....................       case 'p': command_p(); 
1B2CE:  GOTO   1A11C
....................          break;   
1B2D2:  BRA    1B2FE
....................       case 'q': command_q(); 
1B2D4:  GOTO   1A1B6
....................          break; 
1B2D8:  BRA    1B2FE
....................       case 'r': command_r(); 
1B2DA:  BRA    1ACB2
....................          break;    
1B2DC:  BRA    1B2FE
....................       case 's': command_s(); 
1B2DE:  BRA    1AD0C
....................          break;           
1B2E0:  BRA    1B2FE
....................       case 't': command_t(); 
1B2E2:  BRA    1AE1A
....................          break;          
1B2E4:  BRA    1B2FE
....................       case 'u': command_u(); 
1B2E6:  BRA    1AEB0
....................          break; 
1B2E8:  BRA    1B2FE
....................       case 'v': command_v(); 
1B2EA:  CALL   13D94
....................          break; 
1B2EE:  BRA    1B2FE
....................       case 'w': command_w(); 
1B2F0:  BRA    1AEE8
....................          break; 
1B2F2:  BRA    1B2FE
....................       case 'x': command_x(); 
1B2F4:  BRA    1AFBC
....................          break;    
1B2F6:  BRA    1B2FE
....................       case 'y': command_y(); 
1B2F8:  BRA    1B056
....................          break;  
1B2FA:  BRA    1B2FE
....................       case 'z': command_z(); 
1B2FC:  BRA    1B0EC
....................          break;           
....................    } 
1B2FE:  GOTO   1B422 (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg2() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0B15C:  MOVF   51,F
0B15E:  BNZ   B1B0
0B160:  MOVLB  8
0B162:  MOVF   x85,W
0B164:  SUBLW  24
0B166:  BC    B16E
0B168:  MOVF   x85,W
0B16A:  SUBLW  26
0B16C:  BC    B1A8
0B16E:  MOVF   x85,W
0B170:  SUBLW  29
0B172:  BC    B17A
0B174:  MOVF   x85,W
0B176:  SUBLW  2B
0B178:  BC    B1A8
0B17A:  MOVF   x85,W
0B17C:  SUBLW  2D
0B17E:  BZ    B1A8
0B180:  MOVF   x85,W
0B182:  SUBLW  2F
0B184:  BZ    B1A8
0B186:  MOVF   x85,W
0B188:  SUBLW  40
0B18A:  BC    B192
0B18C:  MOVF   x85,W
0B18E:  SUBLW  42
0B190:  BC    B1A8
0B192:  MOVF   x85,W
0B194:  SUBLW  43
0B196:  BC    B19E
0B198:  MOVF   x85,W
0B19A:  SUBLW  5A
0B19C:  BC    B1A8
0B19E:  MOVF   x85,W
0B1A0:  SUBLW  5E
0B1A2:  BZ    B1A8
0B1A4:  MOVLW  00
0B1A6:  BRA    B1AA
0B1A8:  MOVLW  01
0B1AA:  MOVWF  x86
0B1AC:  BRA    B212
0B1AE:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0B1B0:  DECFSZ 51,W
0B1B2:  BRA    B214
0B1B4:  MOVLB  8
0B1B6:  MOVF   x85,W
0B1B8:  SUBLW  23
0B1BA:  BZ    B20E
0B1BC:  MOVF   x85,W
0B1BE:  SUBLW  24
0B1C0:  BC    B1C8
0B1C2:  MOVF   x85,W
0B1C4:  SUBLW  26
0B1C6:  BC    B20E
0B1C8:  MOVF   x85,W
0B1CA:  SUBLW  29
0B1CC:  BC    B1D4
0B1CE:  MOVF   x85,W
0B1D0:  SUBLW  2B
0B1D2:  BC    B20E
0B1D4:  MOVF   x85,W
0B1D6:  SUBLW  2D
0B1D8:  BZ    B20E
0B1DA:  MOVF   x85,W
0B1DC:  SUBLW  2F
0B1DE:  BZ    B20E
0B1E0:  MOVF   x85,W
0B1E2:  SUBLW  40
0B1E4:  BC    B1EC
0B1E6:  MOVF   x85,W
0B1E8:  SUBLW  42
0B1EA:  BC    B20E
0B1EC:  MOVF   x85,W
0B1EE:  SUBLW  43
0B1F0:  BC    B1F8
0B1F2:  MOVF   x85,W
0B1F4:  SUBLW  5A
0B1F6:  BC    B20E
0B1F8:  MOVF   x85,W
0B1FA:  SUBLW  5E
0B1FC:  BZ    B20E
0B1FE:  MOVF   x85,W
0B200:  SUBLW  60
0B202:  BC    B20A
0B204:  MOVF   x85,W
0B206:  SUBLW  7A
0B208:  BC    B20E
0B20A:  MOVLW  00
0B20C:  BRA    B210
0B20E:  MOVLW  01
0B210:  MOVWF  x86
0B212:  MOVLB  0
....................    return(valid); 
0B214:  MOVLB  8
0B216:  MOVFF  886,01
0B21A:  MOVLB  0
0B21C:  GOTO   1B3DA (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(!check_cmd(cmd)) 
*
1B3D2:  MOVFF  47,885
1B3D6:  GOTO   B15C
1B3DA:  MOVF   01,F
1B3DC:  BNZ   1B400
....................       fputs("\r\n@INV", COM_A); 
1B3DE:  MOVLW  D0
1B3E0:  MOVWF  FF6
1B3E2:  MOVLW  27
1B3E4:  MOVWF  FF7
1B3E6:  MOVLW  00
1B3E8:  MOVWF  FF8
1B3EA:  CALL   AE4A
1B3EE:  MOVLW  0D
1B3F0:  BTFSS  F9E.4
1B3F2:  BRA    1B3F0
1B3F4:  MOVWF  FAD
1B3F6:  MOVLW  0A
1B3F8:  BTFSS  F9E.4
1B3FA:  BRA    1B3F8
1B3FC:  MOVWF  FAD
1B3FE:  BRA    1B422
....................    else{ 
....................       fputs("\r\n@OK! ", COM_A); 
1B400:  MOVLW  D8
1B402:  MOVWF  FF6
1B404:  MOVLW  27
1B406:  MOVWF  FF7
1B408:  MOVLW  00
1B40A:  MOVWF  FF8
1B40C:  CALL   AE4A
1B410:  MOVLW  0D
1B412:  BTFSS  F9E.4
1B414:  BRA    1B412
1B416:  MOVWF  FAD
1B418:  MOVLW  0A
1B41A:  BTFSS  F9E.4
1B41C:  BRA    1B41A
1B41E:  MOVWF  FAD
....................       select_cmd(); 
1B420:  BRA    1B162
....................    } 
1B422:  GOTO   1B5E8 (RETURN)
.................... } 
.................... void proc_cmd2() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
....................    else fputs("@INV", COM_A); 
.................... } 
....................  
.................... void command_prompt(){ 
1B426:  MOVLB  8
1B428:  CLRF   x64
1B42A:  CLRF   x65
1B42C:  CLRF   x66
....................    int8 good_val = FALSE; 
....................    int8 i = 0; 
....................    char temp = 0; 
....................    char input_string[30]; 
....................     
....................     
....................    nv_cmd_mode = TRUE; 
1B42E:  CLRF   32
1B430:  MOVLW  01
1B432:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1B434:  MOVLW  02
1B436:  MOVWF  x89
1B438:  MOVFF  31,88A
1B43C:  MOVLB  0
1B43E:  CALL   3412
....................     
....................    fputs("@CMD", COM_A); 
1B442:  MOVLW  E6
1B444:  MOVWF  FF6
1B446:  MOVLW  27
1B448:  MOVWF  FF7
1B44A:  MOVLW  00
1B44C:  MOVWF  FF8
1B44E:  CALL   AE4A
1B452:  MOVLW  0D
1B454:  BTFSS  F9E.4
1B456:  BRA    1B454
1B458:  MOVWF  FAD
1B45A:  MOVLW  0A
1B45C:  BTFSS  F9E.4
1B45E:  BRA    1B45C
1B460:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1B462:  MOVLW  01
1B464:  MOVWF  1E
1B466:  MOVLW  A7
1B468:  MOVWF  1D
1B46A:  MOVLW  EC
1B46C:  MOVWF  FF6
1B46E:  MOVLW  27
1B470:  MOVWF  FF7
1B472:  MOVLW  00
1B474:  MOVWF  FF8
1B476:  CALL   50BE
....................    record_event(); 
1B47A:  CALL   84DA
....................     
....................    busy_clear(); 
1B47E:  CALL   AE74
....................     
....................    cmd_set=0; // user 
1B482:  CLRF   51
....................     
....................    do { 
....................       for(i = 0; i<30; i++){ 
1B484:  MOVLB  8
1B486:  CLRF   x65
1B488:  MOVF   x65,W
1B48A:  SUBLW  1D
1B48C:  BNC   1B4A2
....................          input_string[i] = 0; 
1B48E:  CLRF   03
1B490:  MOVF   x65,W
1B492:  ADDLW  67
1B494:  MOVWF  FE9
1B496:  MOVLW  08
1B498:  ADDWFC 03,W
1B49A:  MOVWF  FEA
1B49C:  CLRF   FEF
1B49E:  INCF   x65,F
1B4A0:  BRA    1B488
....................    
....................       } 
....................       i = 0; 
1B4A2:  CLRF   x65
....................       fputc('>',COM_A); 
1B4A4:  MOVLW  3E
1B4A6:  MOVLB  0
1B4A8:  CALL   AE7C
....................       temp = 0; 
1B4AC:  MOVLB  8
1B4AE:  CLRF   x66
....................       while(temp != CARRIAGE_RET){ 
1B4B0:  MOVF   x66,W
1B4B2:  SUBLW  0D
1B4B4:  BZ    1B54C
....................          temp = fgetc(COM_A); 
1B4B6:  MOVLB  0
1B4B8:  CALL   0E38
1B4BC:  MOVFF  01,866
....................          //Backspace character 
....................          if(temp != 8){ 
1B4C0:  MOVLB  8
1B4C2:  MOVF   x66,W
1B4C4:  SUBLW  08
1B4C6:  BZ    1B4F2
....................             if (com_echo == TRUE) 
1B4C8:  DECFSZ 4C,W
1B4CA:  BRA    1B4D6
....................             { 
....................                fputc(temp,COM_A); 
1B4CC:  MOVF   x66,W
1B4CE:  MOVLB  0
1B4D0:  CALL   AE7C
1B4D4:  MOVLB  8
....................             } 
....................             if(temp!= CARRIAGE_RET){ 
1B4D6:  MOVF   x66,W
1B4D8:  SUBLW  0D
1B4DA:  BZ    1B4F0
....................                input_string[i] = temp; 
1B4DC:  CLRF   03
1B4DE:  MOVF   x65,W
1B4E0:  ADDLW  67
1B4E2:  MOVWF  FE9
1B4E4:  MOVLW  08
1B4E6:  ADDWFC 03,W
1B4E8:  MOVWF  FEA
1B4EA:  MOVFF  866,FEF
....................                i++; 
1B4EE:  INCF   x65,F
....................             } 
....................          }else{ 
1B4F0:  BRA    1B54A
....................             if(i != 0){ 
1B4F2:  MOVF   x65,F
1B4F4:  BZ    1B54A
....................                input_string[i-1] = 0; 
1B4F6:  MOVLW  01
1B4F8:  SUBWF  x65,W
1B4FA:  CLRF   03
1B4FC:  ADDLW  67
1B4FE:  MOVWF  FE9
1B500:  MOVLW  08
1B502:  ADDWFC 03,W
1B504:  MOVWF  FEA
1B506:  CLRF   FEF
....................                i--; 
1B508:  DECF   x65,F
....................                //Clear buffer and overwrite with previous minus one character 
....................                fputc('\r',COM_A); 
1B50A:  MOVLW  0D
1B50C:  MOVLB  0
1B50E:  CALL   AE7C
....................                fprintf(COM_A,"                                       "); 
1B512:  MOVLW  FE
1B514:  MOVWF  FF6
1B516:  MOVLW  27
1B518:  MOVWF  FF7
1B51A:  MOVLW  00
1B51C:  MOVWF  FF8
1B51E:  CLRF   1B
1B520:  BTFSC  FF2.7
1B522:  BSF    1B.7
1B524:  BCF    FF2.7
1B526:  CALL   0E4E
1B52A:  BTFSC  1B.7
1B52C:  BSF    FF2.7
....................                fputc('\r',COM_A); 
1B52E:  MOVLW  0D
1B530:  CALL   AE7C
....................                fprintf(COM_A,">"); 
1B534:  MOVLW  3E
1B536:  BTFSS  F9E.4
1B538:  BRA    1B536
1B53A:  MOVWF  FAD
....................                fprintf(COM_A,input_string); 
1B53C:  MOVLW  08
1B53E:  MOVWF  FEA
1B540:  MOVLW  67
1B542:  MOVWF  FE9
1B544:  CALL   7996
1B548:  MOVLB  8
....................                 
....................             } 
....................          } 
1B54A:  BRA    1B4B0
....................       } 
....................       cmd = input_string[0]; 
1B54C:  MOVFF  867,47
....................       i = 1; 
1B550:  MOVLW  01
1B552:  MOVWF  x65
....................       //fputs("\r\n",COM_A); 
....................       while(input_string[i] != 0){ 
1B554:  CLRF   03
1B556:  MOVF   x65,W
1B558:  ADDLW  67
1B55A:  MOVWF  FE9
1B55C:  MOVLW  08
1B55E:  ADDWFC 03,W
1B560:  MOVWF  FEA
1B562:  MOVF   FEF,F
1B564:  BZ    1B5B6
....................       //fputc(input_string[i],COM_A); 
....................          if(!isdigit(input_string[i])){ 
1B566:  CLRF   03
1B568:  MOVF   x65,W
1B56A:  ADDLW  67
1B56C:  MOVWF  FE9
1B56E:  MOVLW  08
1B570:  ADDWFC 03,W
1B572:  MOVWF  FEA
1B574:  MOVFF  FEF,885
1B578:  MOVF   x85,W
1B57A:  SUBLW  2F
1B57C:  BC    1B584
1B57E:  MOVF   x85,W
1B580:  SUBLW  39
1B582:  BC    1B5AE
....................             fputs("\r\n@ARG ", COM_A); 
1B584:  MOVLW  26
1B586:  MOVWF  FF6
1B588:  MOVLW  28
1B58A:  MOVWF  FF7
1B58C:  MOVLW  00
1B58E:  MOVWF  FF8
1B590:  MOVLB  0
1B592:  CALL   AE4A
1B596:  MOVLW  0D
1B598:  BTFSS  F9E.4
1B59A:  BRA    1B598
1B59C:  MOVWF  FAD
1B59E:  MOVLW  0A
1B5A0:  BTFSS  F9E.4
1B5A2:  BRA    1B5A0
1B5A4:  MOVWF  FAD
....................             good_val = FALSE; 
1B5A6:  MOVLB  8
1B5A8:  CLRF   x64
....................             break; 
1B5AA:  BRA    1B5B6
....................          }else{ 
1B5AC:  BRA    1B5B2
....................             good_val = TRUE; 
1B5AE:  MOVLW  01
1B5B0:  MOVWF  x64
....................          } 
....................          i++; 
1B5B2:  INCF   x65,F
1B5B4:  BRA    1B554
....................       } 
....................       if(!good_val){ 
1B5B6:  MOVF   x64,F
1B5B8:  BNZ   1B5BC
....................          continue; 
1B5BA:  BRA    1B5EA
....................       } 
....................        
....................       arg = atoi32(input_string+1); 
1B5BC:  MOVLW  08
1B5BE:  MOVWF  x86
1B5C0:  MOVLW  68
1B5C2:  MOVWF  x85
1B5C4:  MOVLB  0
1B5C6:  GOTO   AE84
1B5CA:  MOVFF  03,4B
1B5CE:  MOVFF  02,4A
1B5D2:  MOVFF  01,49
1B5D6:  MOVFF  00,48
....................        
....................       //proc_cmd(); 
....................       //fputs("\r\n@OK! ", COM_A); 
....................       //select_cmd(); 
....................        
....................       if (cmd == '?') msg_busy(); 
1B5DA:  MOVF   47,W
1B5DC:  SUBLW  3F
1B5DE:  BNZ   1B5E6
1B5E0:  GOTO   B11A
1B5E4:  BRA    1B5E8
....................       else{  
....................             proc_cmd(); 
1B5E6:  BRA    1B3D2
1B5E8:  MOVLB  8
....................              
....................       } 
....................        
....................        
....................        
....................           
....................       /*if(cmd != 8){ 
....................          temp_cmd = cmd; 
....................          if (com_echo == TRUE) 
....................          { 
....................             fputc(cmd,COM_A); 
....................          } 
....................          if (cmd == '?') msg_busy(); 
....................          else proc_cmd(); 
....................       }else{ 
....................          if(temp_cmd != 0){ 
....................             fprintf(COM_A,"\r\n>%c",temp_cmd); 
....................          } 
....................       } 
....................       //restart_wdt();*/ 
....................    } while(nv_cmd_mode == TRUE); 
1B5EA:  DECFSZ 31,W
1B5EC:  BRA    1B5F4
1B5EE:  MOVF   32,F
1B5F0:  BTFSC  FD8.2
1B5F2:  BRA    1B486
1B5F4:  MOVLB  0
1B5F6:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void command_prompt2() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................    char temp_cmd = 0; 
....................    nv_cmd_mode = TRUE; 
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
....................     
....................    fputs("@CMD", COM_A); 
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
....................    record_event(); 
....................     
....................    busy_clear(); 
....................     
....................    cmd_set=0; // user 
....................     
....................    do { 
....................       fputc('>',COM_A); 
....................       cmd=fgetc(COM_A); 
....................          temp_cmd = cmd; 
....................          if (com_echo == TRUE) 
....................          { 
....................             fputc(cmd,COM_A); 
....................          } 
....................          if (cmd == '?') msg_busy(); 
....................          else proc_cmd(); 
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
.................... } 
....................  
....................  
.................... void main() 
1B5F8:  CLRF   FF8
1B5FA:  BCF    FD0.7
1B5FC:  BSF    07.7
1B5FE:  MOVLW  70
1B600:  MOVWF  FD3
1B602:  MOVLW  40
1B604:  MOVWF  F9B
1B606:  CLRF   F64
1B608:  CLRF   1C
1B60A:  BSF    F65.3
1B60C:  MOVWF  FAF
1B60E:  MOVLW  03
1B610:  MOVWF  FD4
1B612:  MOVLW  A6
1B614:  MOVWF  FAC
1B616:  MOVLW  90
1B618:  MOVWF  FAB
1B61A:  MOVLB  F
1B61C:  BSF    x20.3
1B61E:  MOVLW  82
1B620:  MOVWF  x1E
1B622:  MOVLW  06
1B624:  MOVWF  x1F
1B626:  MOVLW  A6
1B628:  MOVWF  x21
1B62A:  MOVLW  90
1B62C:  MOVWF  x22
1B62E:  BSF    F65.3
1B630:  MOVLW  40
1B632:  MOVWF  FAF
1B634:  MOVLW  03
1B636:  MOVWF  FD4
1B638:  MOVLW  A6
1B63A:  MOVWF  FAC
1B63C:  MOVLW  90
1B63E:  MOVWF  FAB
1B640:  CLRF   1E
1B642:  CLRF   1D
1B644:  SETF   3A
1B646:  SETF   39
1B648:  SETF   3C
1B64A:  SETF   3B
1B64C:  CLRF   46
1B64E:  MOVLW  01
1B650:  MOVWF  45
1B652:  MOVWF  4C
1B654:  BCF    4D.0
1B656:  BCF    4D.1
1B658:  BCF    4D.2
1B65A:  MOVLB  0
1B65C:  CLRF   x66
1B65E:  MOVLB  2
1B660:  MOVWF  xD9
1B662:  MOVLB  3
1B664:  CLRF   x3B
1B666:  MOVLB  4
1B668:  CLRF   xE7
1B66A:  MOVWF  xED
1B66C:  MOVLW  04
1B66E:  MOVLB  7
1B670:  MOVWF  x13
1B672:  MOVLW  EE
1B674:  MOVWF  x12
1B676:  CLRF   xCD
1B678:  MOVLB  8
1B67A:  CLRF   x58
1B67C:  CLRF   x57
1B67E:  CLRF   x5C
1B680:  CLRF   x5B
1B682:  CLRF   x5A
1B684:  CLRF   x59
1B686:  CLRF   x60
1B688:  CLRF   x5F
1B68A:  CLRF   x5E
1B68C:  CLRF   x5D
1B68E:  MOVLW  00
1B690:  MOVLB  F
1B692:  MOVWF  x23
1B694:  MOVWF  x24
1B696:  MOVWF  x25
1B698:  BCF    FC1.3
1B69A:  BCF    FC1.4
1B69C:  BCF    FC1.5
1B69E:  CLRF   x2E
1B6A0:  CLRF   x2F
1B6A2:  CLRF   x54
1B6A4:  BRA    1B766
1B6A6:  DATA 44,02
1B6A8:  DATA DD,20
1B6AA:  DATA 64,72
1B6AC:  DATA 61,77
1B6AE:  DATA 5F,61
1B6B0:  DATA 6C,6C
1B6B2:  DATA 2E,63
1B6B4:  DATA 73,76
1B6B6:  DATA 00,20
1B6B8:  DATA 64,72
1B6BA:  DATA 61,77
1B6BC:  DATA 5F,6E
1B6BE:  DATA 65,77
1B6C0:  DATA 2E,63
1B6C2:  DATA 73,76
1B6C4:  DATA 00,20
1B6C6:  DATA 64,72
1B6C8:  DATA 65,6C
1B6CA:  DATA 5F,61
1B6CC:  DATA 6C,6C
1B6CE:  DATA 2E,63
1B6D0:  DATA 73,76
1B6D2:  DATA 00,20
1B6D4:  DATA 64,72
1B6D6:  DATA 65,6C
1B6D8:  DATA 5F,6E
1B6DA:  DATA 65,77
1B6DC:  DATA 2E,63
1B6DE:  DATA 73,76
1B6E0:  DATA 00,20
1B6E2:  DATA 65,76
1B6E4:  DATA 65,6E
1B6E6:  DATA 74,73
1B6E8:  DATA 2E,74
1B6EA:  DATA 78,74
1B6EC:  DATA 00,02
1B6EE:  DATA 03,39
1B6F0:  DATA 2C,00
1B6F2:  DATA 02,04
1B6F4:  DATA D8,00
1B6F6:  DATA 00,10
1B6F8:  DATA 07,14
1B6FA:  DATA 46,41
1B6FC:  DATA 54,31
1B6FE:  DATA 32,46
1B700:  DATA 41,54
1B702:  DATA 31,36
1B704:  DATA 46,41
1B706:  DATA 54,33
1B708:  DATA 32,00
1B70A:  DATA 57,07
1B70C:  DATA CE,0D
1B70E:  DATA 0A,00
1B710:  DATA 00,03
1B712:  DATA 00,0F
1B714:  DATA 00,1B
1B716:  DATA 00,27
1B718:  DATA 00,33
1B71A:  DATA 00,3F
1B71C:  DATA 00,4B
1B71E:  DATA 00,57
1B720:  DATA 00,63
1B722:  DATA 00,6F
1B724:  DATA 00,7B
1B726:  DATA 00,87
1B728:  DATA 00,93
1B72A:  DATA 00,9F
1B72C:  DATA 00,AB
1B72E:  DATA 00,B7
1B730:  DATA 00,C3
1B732:  DATA 48,B1
1B734:  DATA 70,D4
1B736:  DATA 98,F7
1B738:  DATA C0,1A
1B73A:  DATA 00,CF
1B73C:  DATA 28,F2
1B73E:  DATA 50,15
1B740:  DATA 78,38
1B742:  DATA A0,5B
1B744:  DATA C8,7E
1B746:  DATA F0,A1
1B748:  DATA 18,C5
1B74A:  DATA 40,E8
1B74C:  DATA 68,0B
1B74E:  DATA 90,2E
1B750:  DATA B8,51
1B752:  DATA E0,74
1B754:  DATA 08,98
1B756:  DATA 30,BB
1B758:  DATA 58,DE
1B75A:  DATA 80,01
1B75C:  DATA A8,24
1B75E:  DATA D0,47
1B760:  DATA F8,6A
1B762:  DATA 20,8E
1B764:  DATA 00,00
1B766:  MOVLW  01
1B768:  MOVWF  FF8
1B76A:  MOVLW  B6
1B76C:  MOVWF  FF7
1B76E:  MOVLW  A6
1B770:  MOVWF  FF6
1B772:  TBLRD*+
1B774:  MOVF   FF5,W
1B776:  MOVWF  00
1B778:  XORLW  00
1B77A:  BZ    1B7A2
1B77C:  TBLRD*+
1B77E:  MOVF   FF5,W
1B780:  MOVWF  01
1B782:  BTFSC  FE8.7
1B784:  BRA    1B790
1B786:  ANDLW  0F
1B788:  MOVWF  FEA
1B78A:  TBLRD*+
1B78C:  MOVFF  FF5,FE9
1B790:  BTFSC  01.6
1B792:  TBLRD*+
1B794:  BTFSS  01.6
1B796:  TBLRD*+
1B798:  MOVFF  FF5,FEE
1B79C:  DCFSNZ 00,F
1B79E:  BRA    1B772
1B7A0:  BRA    1B794
1B7A2:  CLRF   FF8
1B7A4:  MOVLB  8
1B7A6:  CLRF   x61
1B7A8:  CLRF   x63
1B7AA:  CLRF   x62
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B7AC:  BCF    FF2.6
1B7AE:  BCF    FF2.7
1B7B0:  BTFSC  FF2.7
1B7B2:  BRA    1B7AE
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B7B4:  BCF    FC6.5
1B7B6:  MOVLW  21
1B7B8:  MOVWF  FC6
1B7BA:  MOVLW  40
1B7BC:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B7BE:  BCF    F67.5
1B7C0:  MOVLW  21
1B7C2:  MOVWF  F67
1B7C4:  MOVLW  40
1B7C6:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B7C8:  MOVLW  00
1B7CA:  MOVLB  F
1B7CC:  MOVWF  x23
1B7CE:  MOVWF  x24
1B7D0:  MOVLW  1F
1B7D2:  MOVWF  x25
1B7D4:  BCF    FC1.3
1B7D6:  BSF    FC1.4
1B7D8:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B7DA:  MOVF   FC0,W
1B7DC:  ANDLW  C0
1B7DE:  IORLW  07
1B7E0:  MOVWF  FC0
1B7E2:  BSF    FC0.7
1B7E4:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B7E6:  MOVLW  87
1B7E8:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B7EA:  MOVLW  37
1B7EC:  MOVWF  FCD
1B7EE:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B7F0:  MOVLB  0
1B7F2:  GOTO   28C4
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B7F6:  CLRF   FB0
1B7F8:  MOVLW  07
1B7FA:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B7FC:  MOVLW  04
1B7FE:  MOVLB  F
1B800:  MOVWF  x2E
1B802:  MOVWF  x2F
1B804:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B806:  MOVLW  70
1B808:  MOVWF  FD3
1B80A:  MOVLW  40
1B80C:  MOVWF  F9B
1B80E:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B810:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B812:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B814:  MOVLB  0
1B816:  CALL   2900
....................  
....................    enable_interrupts(GLOBAL); 
1B81A:  MOVLW  C0
1B81C:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
1B81E:  CALL   293A
....................    motor_sleep_rdy(); 
1B822:  CALL   2998
....................  
....................    sleep_mode = FALSE;    
1B826:  BCF    4D.1
....................    busy_set(); 
1B828:  CALL   29C0
....................     
....................    init_nv_vars(); 
1B82C:  CALL   2AB8
....................    get_step_vars(); 
1B830:  CALL   2D1A
....................    init_aws(); 
1B834:  GOTO   30DC
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B838:  CALL   30F6
....................    blink(); 
1B83C:  GOTO   30FC
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B840:  CALL   3148
....................     
....................    RTC_read(); 
1B844:  CALL   3344
....................    RTC_last_power(); 
1B848:  GOTO   3442
....................    RTC_reset_HT();   
1B84C:  CALL   34B2
....................    RTC_read(); 
1B850:  CALL   3344
1B854:  CLRF   1B
1B856:  BTFSC  FF2.7
1B858:  BSF    1B.7
1B85A:  BCF    FF2.7
....................    RTC_read_flags(); 
1B85C:  CALL   0DD8
1B860:  BTFSC  1B.7
1B862:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B864:  MOVF   3F,F
1B866:  BNZ   1B86C
1B868:  MOVF   40,F
1B86A:  BZ    1B8BC
1B86C:  MOVLW  46
1B86E:  MOVWF  FF6
1B870:  MOVLW  28
1B872:  MOVWF  FF7
1B874:  MOVLW  00
1B876:  MOVWF  FF8
1B878:  CLRF   1B
1B87A:  BTFSC  FF2.7
1B87C:  BSF    1B.7
1B87E:  BCF    FF2.7
1B880:  MOVLW  04
1B882:  MOVLB  A
1B884:  MOVWF  x40
1B886:  MOVLB  0
1B888:  CALL   1024
1B88C:  BTFSC  1B.7
1B88E:  BSF    FF2.7
1B890:  MOVLW  10
1B892:  MOVWF  FE9
1B894:  CLRF   1B
1B896:  BTFSC  FF2.7
1B898:  BSF    1B.7
1B89A:  BCF    FF2.7
1B89C:  MOVFF  40,A41
1B8A0:  MOVFF  3F,A40
1B8A4:  CALL   11A6
1B8A8:  BTFSC  1B.7
1B8AA:  BSF    FF2.7
1B8AC:  MOVLW  0D
1B8AE:  BTFSS  F9E.4
1B8B0:  BRA    1B8AE
1B8B2:  MOVWF  FAD
1B8B4:  MOVLW  0A
1B8B6:  BTFSS  F9E.4
1B8B8:  BRA    1B8B6
1B8BA:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B8BC:  CALL   3508
....................    sd_status = init_sdcard(); 
1B8C0:  CALL   503A
1B8C4:  MOVFF  01,2DC
....................    if(sd_status>0) msg_card_fail(); 
1B8C8:  MOVLB  2
1B8CA:  MOVF   xDC,F
1B8CC:  BZ    1B8D6
1B8CE:  MOVLB  0
1B8D0:  CALL   5080
1B8D4:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
1B8D6:  MOVLB  0
1B8D8:  GOTO   ABC6
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B8DC:  MOVLB  7
1B8DE:  MOVF   x96,F
1B8E0:  BNZ   1B8EE
1B8E2:  MOVF   x97,F
1B8E4:  BNZ   1B8EE
1B8E6:  MOVF   x98,F
1B8E8:  BNZ   1B8EE
1B8EA:  MOVF   x99,F
1B8EC:  BZ    1B8F6
1B8EE:  MOVLB  0
1B8F0:  CALL   9D02
1B8F4:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B8F6:  MOVF   xAF,F
1B8F8:  BNZ   1B97C
1B8FA:  MOVF   xB0,F
1B8FC:  BNZ   1B97C
....................       e_port[0]=0; 
1B8FE:  CLRF   xC4
1B900:  CLRF   xC3
....................       write16(ADDR_E1_PORT,0); 
1B902:  MOVLW  AA
1B904:  MOVLB  8
1B906:  MOVWF  xEE
1B908:  CLRF   xF0
1B90A:  CLRF   xEF
1B90C:  MOVLB  0
1B90E:  CALL   4FD4
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B912:  MOVLW  50
1B914:  MOVWF  FF6
1B916:  MOVLW  28
1B918:  MOVWF  FF7
1B91A:  MOVLW  00
1B91C:  MOVWF  FF8
1B91E:  CLRF   1B
1B920:  BTFSC  FF2.7
1B922:  BSF    1B.7
1B924:  BCF    FF2.7
1B926:  MOVLW  05
1B928:  MOVLB  A
1B92A:  MOVWF  x40
1B92C:  MOVLB  0
1B92E:  CALL   1024
1B932:  BTFSC  1B.7
1B934:  BSF    FF2.7
1B936:  MOVLW  10
1B938:  MOVWF  FE9
1B93A:  CLRF   1B
1B93C:  BTFSC  FF2.7
1B93E:  BSF    1B.7
1B940:  BCF    FF2.7
1B942:  MOVFF  7B0,A41
1B946:  MOVFF  7AF,A40
1B94A:  CALL   11A6
1B94E:  BTFSC  1B.7
1B950:  BSF    FF2.7
1B952:  MOVLW  2C
1B954:  BTFSS  F9E.4
1B956:  BRA    1B954
1B958:  MOVWF  FAD
1B95A:  MOVLW  10
1B95C:  MOVWF  FE9
1B95E:  MOVFF  7C4,8F1
1B962:  MOVFF  7C3,8F0
1B966:  CALL   8FE4
1B96A:  MOVLW  0D
1B96C:  BTFSS  F9E.4
1B96E:  BRA    1B96C
1B970:  MOVWF  FAD
1B972:  MOVLW  0A
1B974:  BTFSS  F9E.4
1B976:  BRA    1B974
1B978:  MOVWF  FAD
1B97A:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B97C:  MOVF   xB1,F
1B97E:  BNZ   1BA02
1B980:  MOVF   xB2,F
1B982:  BNZ   1BA02
....................       m_lin_pos[1]=-1; 
1B984:  SETF   xB6
1B986:  SETF   xB5
....................       write16(ADDR_M2_LIN_POS, -1); 
1B988:  MOVLW  B8
1B98A:  MOVLB  8
1B98C:  MOVWF  xEE
1B98E:  SETF   xF0
1B990:  SETF   xEF
1B992:  MOVLB  0
1B994:  CALL   4FD4
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B998:  MOVLW  60
1B99A:  MOVWF  FF6
1B99C:  MOVLW  28
1B99E:  MOVWF  FF7
1B9A0:  MOVLW  00
1B9A2:  MOVWF  FF8
1B9A4:  CLRF   1B
1B9A6:  BTFSC  FF2.7
1B9A8:  BSF    1B.7
1B9AA:  BCF    FF2.7
1B9AC:  MOVLW  05
1B9AE:  MOVLB  A
1B9B0:  MOVWF  x40
1B9B2:  MOVLB  0
1B9B4:  CALL   1024
1B9B8:  BTFSC  1B.7
1B9BA:  BSF    FF2.7
1B9BC:  MOVLW  10
1B9BE:  MOVWF  FE9
1B9C0:  CLRF   1B
1B9C2:  BTFSC  FF2.7
1B9C4:  BSF    1B.7
1B9C6:  BCF    FF2.7
1B9C8:  MOVFF  7B2,A41
1B9CC:  MOVFF  7B1,A40
1B9D0:  CALL   11A6
1B9D4:  BTFSC  1B.7
1B9D6:  BSF    FF2.7
1B9D8:  MOVLW  2C
1B9DA:  BTFSS  F9E.4
1B9DC:  BRA    1B9DA
1B9DE:  MOVWF  FAD
1B9E0:  MOVLW  10
1B9E2:  MOVWF  FE9
1B9E4:  MOVFF  7B6,8F1
1B9E8:  MOVFF  7B5,8F0
1B9EC:  CALL   8FE4
1B9F0:  MOVLW  0D
1B9F2:  BTFSS  F9E.4
1B9F4:  BRA    1B9F2
1B9F6:  MOVWF  FAD
1B9F8:  MOVLW  0A
1B9FA:  BTFSS  F9E.4
1B9FC:  BRA    1B9FA
1B9FE:  MOVWF  FAD
1BA00:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1BA02:  MOVF   31,F
1BA04:  BNZ   1BAA8
1BA06:  MOVF   32,F
1BA08:  BNZ   1BAA8
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1BA0A:  MOVLW  70
1BA0C:  MOVWF  FF6
1BA0E:  MOVLW  28
1BA10:  MOVWF  FF7
1BA12:  MOVLW  00
1BA14:  MOVWF  FF8
1BA16:  CLRF   1B
1BA18:  BTFSC  FF2.7
1BA1A:  BSF    1B.7
1BA1C:  BCF    FF2.7
1BA1E:  MOVLB  0
1BA20:  CALL   0E4E
1BA24:  BTFSC  1B.7
1BA26:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1BA28:  MOVLB  8
1BA2A:  MOVF   x63,F
1BA2C:  BNZ   1BA5A
1BA2E:  MOVF   x62,W
1BA30:  SUBLW  63
1BA32:  BNC   1BA5A
1BA34:  MOVF   x61,W
1BA36:  SUBLW  1B
1BA38:  BZ    1BA5A
....................       { 
....................          EscNum=TestForEsc(); 
1BA3A:  MOVLB  0
1BA3C:  GOTO   ADF0
1BA40:  MOVFF  01,861
....................          if(EscNum == ESCAPE) command_prompt(); 
1BA44:  MOVLB  8
1BA46:  MOVF   x61,W
1BA48:  SUBLW  1B
1BA4A:  BNZ   1BA52
1BA4C:  MOVLB  0
1BA4E:  RCALL  1B426
1BA50:  MOVLB  8
....................          EscCount++; 
1BA52:  INCF   x62,F
1BA54:  BTFSC  FD8.2
1BA56:  INCF   x63,F
1BA58:  BRA    1BA2A
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1BA5A:  DECFSZ 33,W
1BA5C:  BRA    1BA72
1BA5E:  MOVF   34,F
1BA60:  BNZ   1BA72
....................       { 
....................          arg=0; 
1BA62:  CLRF   4B
1BA64:  CLRF   4A
1BA66:  CLRF   49
1BA68:  CLRF   48
....................          commandZ(); 
1BA6A:  MOVLB  0
1BA6C:  CALL   18BDE
1BA70:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1BA72:  MOVLW  A8
1BA74:  MOVWF  FF6
1BA76:  MOVLW  28
1BA78:  MOVWF  FF7
1BA7A:  MOVLW  00
1BA7C:  MOVWF  FF8
1BA7E:  CLRF   1B
1BA80:  BTFSC  FF2.7
1BA82:  BSF    1B.7
1BA84:  BCF    FF2.7
1BA86:  MOVLB  0
1BA88:  CALL   0E4E
1BA8C:  BTFSC  1B.7
1BA8E:  BSF    FF2.7
....................       arg = 0; 
1BA90:  CLRF   4B
1BA92:  CLRF   4A
1BA94:  CLRF   49
1BA96:  CLRF   48
....................       commandM(TRUE); 
1BA98:  MOVLW  01
1BA9A:  MOVLB  8
1BA9C:  MOVWF  x85
1BA9E:  MOVLB  0
1BAA0:  CALL   16D64
....................    } 
1BAA4:  BRA    1BAAC
1BAA6:  MOVLB  7
....................    else 
....................    { 
....................       /*int8 RTC_buffer = 0; 
....................       unsigned int8 a0 = 0; 
....................       unsigned int8 a1 = 0; 
....................       unsigned int8 a2 = 0; 
....................       unsigned int8 a3 = 0; 
....................       unsigned int8 a4 = 0; 
....................       unsigned int8 a5 = 0; 
....................       unsigned int8 a6 = 0; 
....................       unsigned int8 a7 = 0; 
....................       unsigned int8 a8 = 0; 
....................       unsigned int8 a9 = 0; 
....................       unsigned int8 a10 = 0; 
....................       unsigned int8 a11 = 0; 
....................        
....................       RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
....................       spi_write(0x89); 
....................       spi_write(0b11000011); 
....................       output_bit(RTC_CS, DISABLE); 
....................        
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x00); 
....................       a0 = RTC_buffer; 
....................       fprintf(COM_A,"crap: %u\r\n",RTC_buffer); 
....................       a1 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg0: %u\r\n",a1); 
....................       a2 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg1: %u\r\n",a2); 
....................       a3 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg2: %u\r\n",a3); 
....................       a4 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg3: %u\r\n",a4); 
....................       a5 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg4: %u\r\n",a5); 
....................       a6 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg5: %u\r\n",a6); 
....................       a7 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg6: %u\r\n",a7); 
....................       a8 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg7: %u\r\n",a8); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg8: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg9: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regA: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regB: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regC: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regD: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regE: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regF: %u\r\n",a9); 
....................        
....................       output_bit(RTC_CS, DISABLE);*/ 
....................     
....................       command_prompt(); 
1BAA8:  MOVLB  0
1BAAA:  RCALL  1B426
....................    } 
....................  
....................    reset_cpu(); 
1BAAC:  RESET
.................... } 
....................  
1BAAE:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 2878   PUT NOBROWNOUT BORV18 ZPBORM NOWDT WDT1024
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
