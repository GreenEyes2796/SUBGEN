CCS PCH C Compiler, Version 5.071d, 1               03-Jul-17 12:45
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   115172 bytes (88%)
                           Largest free fragment is 15530
               RAM used:   2157 (56%) at main() level
                           2622 (68%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1B02A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0EE2
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0F0C
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   1902
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E2A
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   16E4
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   175A
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E72
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 3F,40
00668:  DATA 42,53
0066A:  DATA 59,0D
0066C:  DATA 0A,00
0066E:  DATA 40,52
00670:  DATA 44,59
00672:  DATA 0D,0A
00674:  DATA 00,00
00676:  DATA 40,46
00678:  DATA 53,3A
0067A:  DATA 44,69
0067C:  DATA 73,63
0067E:  DATA 6F,76
00680:  DATA 65,72
00682:  DATA 79,0D
00684:  DATA 0A,00
00686:  DATA 40,46
00688:  DATA 53,3A
0068A:  DATA 55,6E
0068C:  DATA 61,62
0068E:  DATA 6C,65
00690:  DATA 20,74
00692:  DATA 6F,20
00694:  DATA 70,75
00696:  DATA 74,20
00698:  DATA 63,61
0069A:  DATA 72,64
0069C:  DATA 20,69
0069E:  DATA 6E,20
006A0:  DATA 69,64
006A2:  DATA 6C,65
006A4:  DATA 20,73
006A6:  DATA 74,61
006A8:  DATA 74,65
006AA:  DATA 2C,20
006AC:  DATA 72,65
006AE:  DATA 73,70
006B0:  DATA 6F,6E
006B2:  DATA 73,65
006B4:  DATA 20,3D
006B6:  DATA 20,25
006B8:  DATA 30,32
006BA:  DATA 78,0D
006BC:  DATA 0A,00
006BE:  DATA 40,46
006C0:  DATA 53,3A
006C2:  DATA 43,61
006C4:  DATA 72,64
006C6:  DATA 20,69
006C8:  DATA 64,6C
006CA:  DATA 65,2C
006CC:  DATA 20,72
006CE:  DATA 65,73
006D0:  DATA 70,6F
006D2:  DATA 6E,73
006D4:  DATA 65,20
006D6:  DATA 3D,20
006D8:  DATA 25,30
006DA:  DATA 32,78
006DC:  DATA 0D,0A
006DE:  DATA 00,00
006E0:  DATA 40,46
006E2:  DATA 53,3A
006E4:  DATA 52,65
006E6:  DATA 73,70
006E8:  DATA 6F,6E
006EA:  DATA 73,65
006EC:  DATA 20,74
006EE:  DATA 6F,20
006F0:  DATA 53,44
006F2:  DATA 20,76
006F4:  DATA 65,72
006F6:  DATA 20,32
006F8:  DATA 20,74
006FA:  DATA 65,73
006FC:  DATA 74,20
006FE:  DATA 43,4D
00700:  DATA 44,38
00702:  DATA 20,3D
00704:  DATA 20,25
00706:  DATA 78,0D
00708:  DATA 0A,00
0070A:  DATA 40,46
0070C:  DATA 53,3A
0070E:  DATA 50,6F
00710:  DATA 73,73
00712:  DATA 69,62
00714:  DATA 6C,65
00716:  DATA 20,53
00718:  DATA 44,76
0071A:  DATA 32,20
0071C:  DATA 63,61
0071E:  DATA 72,64
00720:  DATA 20,64
00722:  DATA 65,74
00724:  DATA 65,63
00726:  DATA 74,65
00728:  DATA 64,0D
0072A:  DATA 0A,00
0072C:  DATA 40,46
0072E:  DATA 53,3A
00730:  DATA 56,6F
00732:  DATA 6C,74
00734:  DATA 61,67
00736:  DATA 65,20
00738:  DATA 72,61
0073A:  DATA 6E,67
0073C:  DATA 65,20
0073E:  DATA 63,68
00740:  DATA 65,63
00742:  DATA 6B,2C
00744:  DATA 20,6F
00746:  DATA 63,72
00748:  DATA 20,3D
0074A:  DATA 20,25
0074C:  DATA 30,32
0074E:  DATA 78,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,0D
0075C:  DATA 0A,00
0075E:  DATA 40,46
00760:  DATA 53,3A
00762:  DATA 43,61
00764:  DATA 72,64
00766:  DATA 20,56
00768:  DATA 64,64
0076A:  DATA 20,72
0076C:  DATA 61,6E
0076E:  DATA 67,65
00770:  DATA 20,3D
00772:  DATA 20,32
00774:  DATA 2E,37
00776:  DATA 2D,33
00778:  DATA 2E,36
0077A:  DATA 20,76
0077C:  DATA 6F,6C
0077E:  DATA 74,73
00780:  DATA 0D,0A
00782:  DATA 00,00
00784:  DATA 40,46
00786:  DATA 53,3A
00788:  DATA 53,65
0078A:  DATA 6E,64
0078C:  DATA 69,6E
0078E:  DATA 67,20
00790:  DATA 41,43
00792:  DATA 4D,44
00794:  DATA 34,31
00796:  DATA 20,63
00798:  DATA 6F,6D
0079A:  DATA 6D,61
0079C:  DATA 6E,64
0079E:  DATA 20,74
007A0:  DATA 6F,20
007A2:  DATA 53,44
007A4:  DATA 20,76
007A6:  DATA 65,72
007A8:  DATA 20,32
007AA:  DATA 20,63
007AC:  DATA 61,72
007AE:  DATA 64,0D
007B0:  DATA 0A,00
007B2:  DATA 40,46
007B4:  DATA 53,3A
007B6:  DATA 52,65
007B8:  DATA 73,70
007BA:  DATA 6F,6E
007BC:  DATA 73,65
007BE:  DATA 20,66
007C0:  DATA 72,6F
007C2:  DATA 6D,20
007C4:  DATA 73,65
007C6:  DATA 6E,64
007C8:  DATA 69,6E
007CA:  DATA 67,20
007CC:  DATA 41,43
007CE:  DATA 4D,44
007D0:  DATA 34,31
007D2:  DATA 20,3D
007D4:  DATA 20,25
007D6:  DATA 30,32
007D8:  DATA 78,2C
007DA:  DATA 20,54
007DC:  DATA 69,6D
007DE:  DATA 65,72
007E0:  DATA 20,3D
007E2:  DATA 20,25
007E4:  DATA 6C,75
007E6:  DATA 0D,0A
007E8:  DATA 00,00
007EA:  DATA 40,46
007EC:  DATA 53,3A
007EE:  DATA 52,65
007F0:  DATA 73,70
007F2:  DATA 6F,6E
007F4:  DATA 73,65
007F6:  DATA 20,74
007F8:  DATA 6F,20
007FA:  DATA 43,4D
007FC:  DATA 44,35
007FE:  DATA 38,20
00800:  DATA 3D,20
00802:  DATA 25,78
00804:  DATA 0D,0A
00806:  DATA 00,00
00808:  DATA 40,46
0080A:  DATA 53,3A
0080C:  DATA 53,65
0080E:  DATA 6E,74
00810:  DATA 20,43
00812:  DATA 4D,44
00814:  DATA 20,35
00816:  DATA 38,2C
00818:  DATA 20,54
0081A:  DATA 69,6D
0081C:  DATA 65,72
0081E:  DATA 20,76
00820:  DATA 61,6C
00822:  DATA 75,65
00824:  DATA 20,3D
00826:  DATA 20,25
00828:  DATA 6C,75
0082A:  DATA 2C,20
0082C:  DATA 6F,63
0082E:  DATA 72,20
00830:  DATA 3D,20
00832:  DATA 25,30
00834:  DATA 32,78
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 0D,0A
00844:  DATA 00,00
00846:  DATA 40,46
00848:  DATA 53,3A
0084A:  DATA 43,61
0084C:  DATA 72,64
0084E:  DATA 20,43
00850:  DATA 41,4E
00852:  DATA 4E,4F
00854:  DATA 54,20
00856:  DATA 77,6F
00858:  DATA 72,6B
0085A:  DATA 20,56
0085C:  DATA 64,64
0085E:  DATA 20,72
00860:  DATA 61,6E
00862:  DATA 67,65
00864:  DATA 20,6F
00866:  DATA 66,20
00868:  DATA 32,2E
0086A:  DATA 37,2D
0086C:  DATA 33,2E
0086E:  DATA 36,20
00870:  DATA 76,6F
00872:  DATA 6C,74
00874:  DATA 73,0D
00876:  DATA 0A,00
00878:  DATA 40,46
0087A:  DATA 53,3A
0087C:  DATA 4E,6F
0087E:  DATA 74,20
00880:  DATA 61,6E
00882:  DATA 20,53
00884:  DATA 44,53
00886:  DATA 43,20
00888:  DATA 6F,72
0088A:  DATA 20,53
0088C:  DATA 44,48
0088E:  DATA 43,20
00890:  DATA 63,61
00892:  DATA 72,64
00894:  DATA 2C,20
00896:  DATA 54,65
00898:  DATA 73,74
0089A:  DATA 69,6E
0089C:  DATA 67,20
0089E:  DATA 66,6F
008A0:  DATA 72,20
008A2:  DATA 53,44
008A4:  DATA 20,56
008A6:  DATA 65,72
008A8:  DATA 31,20
008AA:  DATA 6F,72
008AC:  DATA 20,4D
008AE:  DATA 4D,43
008B0:  DATA 20,43
008B2:  DATA 61,72
008B4:  DATA 64,0D
008B6:  DATA 0A,00
008B8:  DATA 40,46
008BA:  DATA 53,3A
008BC:  DATA 52,65
008BE:  DATA 73,70
008C0:  DATA 6F,6E
008C2:  DATA 73,65
008C4:  DATA 20,66
008C6:  DATA 72,6F
008C8:  DATA 6D,20
008CA:  DATA 47,4F
008CC:  DATA 5F,49
008CE:  DATA 44,4C
008D0:  DATA 45,20
008D2:  DATA 3D,20
008D4:  DATA 25,30
008D6:  DATA 32,78
008D8:  DATA 0D,0A
008DA:  DATA 00,00
008DC:  DATA 40,46
008DE:  DATA 53,3A
008E0:  DATA 52,65
008E2:  DATA 73,70
008E4:  DATA 6F,6E
008E6:  DATA 73,65
008E8:  DATA 20,66
008EA:  DATA 72,6F
008EC:  DATA 6D,20
008EE:  DATA 53,44
008F0:  DATA 5F,43
008F2:  DATA 4D,44
008F4:  DATA 5F,53
008F6:  DATA 45,4E
008F8:  DATA 44,5F
008FA:  DATA 4F,50
008FC:  DATA 5F,43
008FE:  DATA 4F,4E
00900:  DATA 44,20
00902:  DATA 3D,20
00904:  DATA 25,30
00906:  DATA 32,78
00908:  DATA 2C,20
0090A:  DATA 54,69
0090C:  DATA 6D,65
0090E:  DATA 72,20
00910:  DATA 3D,20
00912:  DATA 25,6C
00914:  DATA 75,0D
00916:  DATA 0A,00
00918:  DATA 40,46
0091A:  DATA 53,3A
0091C:  DATA 41,74
0091E:  DATA 74,65
00920:  DATA 6D,70
00922:  DATA 74,69
00924:  DATA 6E,67
00926:  DATA 20,53
00928:  DATA 44,76
0092A:  DATA 31,20
0092C:  DATA 76,65
0092E:  DATA 72,73
00930:  DATA 75,73
00932:  DATA 20,4D
00934:  DATA 4D,43
00936:  DATA 20,49
00938:  DATA 44,2C
0093A:  DATA 20,52
0093C:  DATA 65,73
0093E:  DATA 70,6F
00940:  DATA 6E,73
00942:  DATA 65,20
00944:  DATA 66,72
00946:  DATA 6F,6D
00948:  DATA 20,53
0094A:  DATA 44,5F
0094C:  DATA 43,4D
0094E:  DATA 44,5F
00950:  DATA 41,50
00952:  DATA 50,4C
00954:  DATA 5F,43
00956:  DATA 4D,44
00958:  DATA 20,3D
0095A:  DATA 20,25
0095C:  DATA 30,32
0095E:  DATA 78,0D
00960:  DATA 0A,00
00962:  DATA 40,46
00964:  DATA 53,3A
00966:  DATA 49,6E
00968:  DATA 76,61
0096A:  DATA 6C,69
0096C:  DATA 64,20
0096E:  DATA 72,65
00970:  DATA 73,70
00972:  DATA 6F,6E
00974:  DATA 73,65
00976:  DATA 20,74
00978:  DATA 6F,20
0097A:  DATA 53,44
0097C:  DATA 5F,41
0097E:  DATA 43,4D
00980:  DATA 44,34
00982:  DATA 31,2C
00984:  DATA 20,72
00986:  DATA 65,73
00988:  DATA 70,6F
0098A:  DATA 6E,73
0098C:  DATA 65,20
0098E:  DATA 3D,20
00990:  DATA 25,30
00992:  DATA 32,58
00994:  DATA 2C,20
00996:  DATA 72,65
00998:  DATA 69,6E
0099A:  DATA 69,74
0099C:  DATA 69,61
0099E:  DATA 6C,69
009A0:  DATA 7A,69
009A2:  DATA 6E,67
009A4:  DATA 20,61
009A6:  DATA 73,20
009A8:  DATA 4D,4D
009AA:  DATA 43,0D
009AC:  DATA 0A,00
009AE:  DATA 40,46
009B0:  DATA 53,3A
009B2:  DATA 46,61
009B4:  DATA 69,6C
009B6:  DATA 65,64
009B8:  DATA 20,74
009BA:  DATA 6F,20
009BC:  DATA 69,6E
009BE:  DATA 69,74
009C0:  DATA 69,61
009C2:  DATA 6C,69
009C4:  DATA 7A,65
009C6:  DATA 20,61
009C8:  DATA 73,20
009CA:  DATA 4D,4D
009CC:  DATA 43,2C
009CE:  DATA 20,72
009D0:  DATA 65,73
009D2:  DATA 70,6F
009D4:  DATA 6E,73
009D6:  DATA 65,20
009D8:  DATA 3D,20
009DA:  DATA 25,30
009DC:  DATA 32,58
009DE:  DATA 2C,20
009E0:  DATA 65,78
009E2:  DATA 69,74
009E4:  DATA 69,6E
009E6:  DATA 67,0D
009E8:  DATA 0A,00
009EA:  DATA 40,46
009EC:  DATA 53,3A
009EE:  DATA 43,61
009F0:  DATA 72,64
009F2:  DATA 20,66
009F4:  DATA 61,69
009F6:  DATA 6C,65
009F8:  DATA 64,20
009FA:  DATA 74,6F
009FC:  DATA 20,72
009FE:  DATA 65,73
00A00:  DATA 70,6F
00A02:  DATA 6E,64
00A04:  DATA 20,63
00A06:  DATA 6F,72
00A08:  DATA 72,65
00A0A:  DATA 63,6C
00A0C:  DATA 79,20
00A0E:  DATA 61,66
00A10:  DATA 74,65
00A12:  DATA 72,20
00A14:  DATA 53,44
00A16:  DATA 5F,43
00A18:  DATA 4D,44
00A1A:  DATA 5F,53
00A1C:  DATA 45,4E
00A1E:  DATA 44,5F
00A20:  DATA 4F,50
00A22:  DATA 5F,43
00A24:  DATA 4F,4E
00A26:  DATA 44,2C
00A28:  DATA 20,72
00A2A:  DATA 65,73
00A2C:  DATA 70,6F
00A2E:  DATA 6E,73
00A30:  DATA 65,20
00A32:  DATA 3D,20
00A34:  DATA 25,30
00A36:  DATA 32,58
00A38:  DATA 2C,20
00A3A:  DATA 54,69
00A3C:  DATA 6D,65
00A3E:  DATA 72,20
00A40:  DATA 3D,20
00A42:  DATA 25,6C
00A44:  DATA 75,0D
00A46:  DATA 0A,00
00A48:  DATA 40,46
00A4A:  DATA 53,3A
00A4C:  DATA 53,65
00A4E:  DATA 74,74
00A50:  DATA 69,6E
00A52:  DATA 67,20
00A54:  DATA 62,6C
00A56:  DATA 6F,63
00A58:  DATA 6B,20
00A5A:  DATA 6C,65
00A5C:  DATA 6E,67
00A5E:  DATA 74,68
00A60:  DATA 0D,0A
00A62:  DATA 00,00
00A64:  DATA 40,46
00A66:  DATA 53,3A
00A68:  DATA 45,72
00A6A:  DATA 72,6F
00A6C:  DATA 72,20
00A6E:  DATA 73,65
00A70:  DATA 74,74
00A72:  DATA 69,6E
00A74:  DATA 67,20
00A76:  DATA 62,6C
00A78:  DATA 6F,63
00A7A:  DATA 6B,20
00A7C:  DATA 6C,65
00A7E:  DATA 6E,67
00A80:  DATA 74,68
00A82:  DATA 2C,20
00A84:  DATA 72,65
00A86:  DATA 73,70
00A88:  DATA 6F,6E
00A8A:  DATA 73,65
00A8C:  DATA 20,3D
00A8E:  DATA 20,25
00A90:  DATA 30,32
00A92:  DATA 78,2C
00A94:  DATA 20,74
00A96:  DATA 69,6D
00A98:  DATA 65,72
00A9A:  DATA 20,3D
00A9C:  DATA 20,25
00A9E:  DATA 6C,75
00AA0:  DATA 0D,0A
00AA2:  DATA 00,00
00AA4:  DATA 40,46
00AA6:  DATA 53,3A
00AA8:  DATA 43,61
00AAA:  DATA 72,64
00AAC:  DATA 20,54
00AAE:  DATA 79,70
00AB0:  DATA 65,20
00AB2:  DATA 44,69
00AB4:  DATA 73,63
00AB6:  DATA 6F,76
00AB8:  DATA 65,72
00ABA:  DATA 79,20
00ABC:  DATA 45,72
00ABE:  DATA 72,6F
00AC0:  DATA 72,0D
00AC2:  DATA 0A,00
00AC4:  DATA 40,46
00AC6:  DATA 53,3A
00AC8:  DATA 4D,4D
00ACA:  DATA 43,20
00ACC:  DATA 43,61
00ACE:  DATA 72,64
00AD0:  DATA 20,66
00AD2:  DATA 6F,75
00AD4:  DATA 6E,64
00AD6:  DATA 0D,0A
00AD8:  DATA 00,00
00ADA:  DATA 40,46
00ADC:  DATA 53,3A
00ADE:  DATA 53,44
00AE0:  DATA 76,31
00AE2:  DATA 20,43
00AE4:  DATA 61,72
00AE6:  DATA 64,20
00AE8:  DATA 66,6F
00AEA:  DATA 75,6E
00AEC:  DATA 64,0D
00AEE:  DATA 0A,00
00AF0:  DATA 40,46
00AF2:  DATA 53,3A
00AF4:  DATA 53,44
00AF6:  DATA 53,43
00AF8:  DATA 20,43
00AFA:  DATA 61,72
00AFC:  DATA 64,20
00AFE:  DATA 66,6F
00B00:  DATA 75,6E
00B02:  DATA 64,0D
00B04:  DATA 0A,00
00B06:  DATA 40,46
00B08:  DATA 53,3A
00B0A:  DATA 53,44
00B0C:  DATA 48,43
00B0E:  DATA 20,43
00B10:  DATA 61,72
00B12:  DATA 64,20
00B14:  DATA 66,6F
00B16:  DATA 75,6E
00B18:  DATA 64,0D
00B1A:  DATA 0A,00
00B1C:  DATA 40,46
00B1E:  DATA 53,3A
00B20:  DATA 43,61
00B22:  DATA 72,64
00B24:  DATA 20,54
00B26:  DATA 79,70
00B28:  DATA 65,20
00B2A:  DATA 44,69
00B2C:  DATA 73,63
00B2E:  DATA 6F,76
00B30:  DATA 65,72
00B32:  DATA 79,20
00B34:  DATA 45,72
00B36:  DATA 72,6F
00B38:  DATA 72,2C
00B3A:  DATA 20,43
00B3C:  DATA 61,72
00B3E:  DATA 64,20
00B40:  DATA 3D,20
00B42:  DATA 25,30
00B44:  DATA 32,58
00B46:  DATA 0D,0A
00B48:  DATA 00,00
00B4A:  DATA 40,46
00B4C:  DATA 53,3A
00B4E:  DATA 43,61
00B50:  DATA 72,64
00B52:  DATA 20,72
00B54:  DATA 65,73
00B56:  DATA 65,74
00B58:  DATA 20,73
00B5A:  DATA 75,63
00B5C:  DATA 63,65
00B5E:  DATA 73,73
00B60:  DATA 20,2D
00B62:  DATA 20,43
00B64:  DATA 6D,64
00B66:  DATA 20,74
00B68:  DATA 6F,20
00B6A:  DATA 52,65
00B6C:  DATA 61,64
00B6E:  DATA 79,20
00B70:  DATA 63,6F
00B72:  DATA 75,6E
00B74:  DATA 74,20
00B76:  DATA 3D,20
00B78:  DATA 25,6C
00B7A:  DATA 75,0D
00B7C:  DATA 0A,00
00B7E:  DATA 40,46
00B80:  DATA 53,3A
00B82:  DATA 53,50
00B84:  DATA 49,20
00B86:  DATA 62,75
00B88:  DATA 73,20
00B8A:  DATA 73,70
00B8C:  DATA 65,65
00B8E:  DATA 64,20
00B90:  DATA 73,65
00B92:  DATA 74,20
00B94:  DATA 74,6F
00B96:  DATA 20,68
00B98:  DATA 69,67
00B9A:  DATA 68,0D
00B9C:  DATA 0A,00
00B9E:  DATA 40,46
00BA0:  DATA 53,3A
00BA2:  DATA 43,61
00BA4:  DATA 72,64
00BA6:  DATA 20,61
00BA8:  DATA 63,74
00BAA:  DATA 69,76
00BAC:  DATA 61,74
00BAE:  DATA 65,20
00BB0:  DATA 66,61
00BB2:  DATA 69,6C
00BB4:  DATA 75,72
00BB6:  DATA 65,2C
00BB8:  DATA 20,72
00BBA:  DATA 65,73
00BBC:  DATA 70,6F
00BBE:  DATA 6E,73
00BC0:  DATA 65,20
00BC2:  DATA 3D,20
00BC4:  DATA 25,30
00BC6:  DATA 32,58
00BC8:  DATA 2C,20
00BCA:  DATA 54,69
00BCC:  DATA 6D,65
00BCE:  DATA 72,20
00BD0:  DATA 3D,20
00BD2:  DATA 25,6C
00BD4:  DATA 75,0D
00BD6:  DATA 0A,00
00BD8:  DATA 40,46
00BDA:  DATA 53,3A
00BDC:  DATA 43,61
00BDE:  DATA 72,64
00BE0:  DATA 20,61
00BE2:  DATA 63,74
00BE4:  DATA 69,76
00BE6:  DATA 61,74
00BE8:  DATA 65,20
00BEA:  DATA 73,75
00BEC:  DATA 63,63
00BEE:  DATA 65,73
00BF0:  DATA 73,20
00BF2:  DATA 6F,6E
00BF4:  DATA 20,61
00BF6:  DATA 74,74
00BF8:  DATA 65,6D
00BFA:  DATA 70,74
00BFC:  DATA 20,25
00BFE:  DATA 6C,75
00C00:  DATA 0D,0A
00C02:  DATA 00,00
00C04:  DATA 46,41
00C06:  DATA 54,20
00C08:  DATA 61,74
00C0A:  DATA 20,73
00C0C:  DATA 65,63
00C0E:  DATA 74,6F
00C10:  DATA 72,20
00C12:  DATA 30,0D
00C14:  DATA 0A,00
00C16:  DATA 54,59
00C18:  DATA 50,45
00C1A:  DATA 20,63
00C1C:  DATA 6F,6D
00C1E:  DATA 6D,61
00C20:  DATA 6E,64
00C22:  DATA 20,45
00C24:  DATA 52,52
00C26:  DATA 4F,52
00C28:  DATA 0D,0A
00C2A:  DATA 00,00
00C2C:  DATA 40,46
00C2E:  DATA 53,3A
00C30:  DATA 20,25
00C32:  DATA 73,0D
00C34:  DATA 0A,00
00C36:  DATA 40,46
00C38:  DATA 53,3A
00C3A:  DATA 20,25
00C3C:  DATA 73,0D
00C3E:  DATA 0A,00
00C40:  DATA 2A,2A
00C42:  DATA 20,40
00C44:  DATA 46,53
00C46:  DATA 3A,20
00C48:  DATA 45,52
00C4A:  DATA 52,4F
00C4C:  DATA 52,0D
00C4E:  DATA 0A,00
00C50:  DATA 20,20
00C52:  DATA 20,4E
00C54:  DATA 6F,45
00C56:  DATA 72,72
00C58:  DATA 6F,72
00C5A:  DATA 0D,0A
00C5C:  DATA 00,00
00C5E:  DATA 20,20
00C60:  DATA 20,4D
00C62:  DATA 65,64
00C64:  DATA 69,61
00C66:  DATA 20,4E
00C68:  DATA 6F,74
00C6A:  DATA 20,52
00C6C:  DATA 65,61
00C6E:  DATA 64,79
00C70:  DATA 0D,0A
00C72:  DATA 00,00
00C74:  DATA 20,20
00C76:  DATA 20,46
00C78:  DATA 69,6C
00C7A:  DATA 65,20
00C7C:  DATA 4E,6F
00C7E:  DATA 74,20
00C80:  DATA 46,6F
00C82:  DATA 75,6E
00C84:  DATA 64,0D
00C86:  DATA 0A,00
00C88:  DATA 20,20
00C8A:  DATA 20,49
00C8C:  DATA 6E,76
00C8E:  DATA 61,6C
00C90:  DATA 69,64
00C92:  DATA 20,50
00C94:  DATA 61,74
00C96:  DATA 68,0D
00C98:  DATA 0A,00
00C9A:  DATA 20,20
00C9C:  DATA 20,49
00C9E:  DATA 6E,76
00CA0:  DATA 61,6C
00CA2:  DATA 69,64
00CA4:  DATA 20,4E
00CA6:  DATA 61,6D
00CA8:  DATA 65,0D
00CAA:  DATA 0A,00
00CAC:  DATA 20,20
00CAE:  DATA 20,41
00CB0:  DATA 63,63
00CB2:  DATA 65,73
00CB4:  DATA 73,20
00CB6:  DATA 44,65
00CB8:  DATA 6E,69
00CBA:  DATA 65,64
00CBC:  DATA 0D,0A
00CBE:  DATA 00,00
00CC0:  DATA 20,20
00CC2:  DATA 20,44
00CC4:  DATA 69,73
00CC6:  DATA 6B,20
00CC8:  DATA 46,75
00CCA:  DATA 6C,6C
00CCC:  DATA 0D,0A
00CCE:  DATA 00,00
00CD0:  DATA 20,20
00CD2:  DATA 20,52
00CD4:  DATA 65,61
00CD6:  DATA 64,2F
00CD8:  DATA 57,72
00CDA:  DATA 69,74
00CDC:  DATA 65,20
00CDE:  DATA 45,72
00CE0:  DATA 72,6F
00CE2:  DATA 72,0D
00CE4:  DATA 0A,00
00CE6:  DATA 20,20
00CE8:  DATA 20,49
00CEA:  DATA 6E,63
00CEC:  DATA 6F,72
00CEE:  DATA 72,65
00CF0:  DATA 63,74
00CF2:  DATA 20,4D
00CF4:  DATA 65,64
00CF6:  DATA 69,61
00CF8:  DATA 20,43
00CFA:  DATA 68,61
00CFC:  DATA 6E,67
00CFE:  DATA 65,0D
00D00:  DATA 0A,00
00D02:  DATA 20,20
00D04:  DATA 20,57
00D06:  DATA 72,69
00D08:  DATA 74,65
00D0A:  DATA 20,50
00D0C:  DATA 72,6F
00D0E:  DATA 74,65
00D10:  DATA 63,74
00D12:  DATA 65,64
00D14:  DATA 0D,0A
00D16:  DATA 00,00
00D18:  DATA 20,20
00D1A:  DATA 20,4E
00D1C:  DATA 6F,74
00D1E:  DATA 20,45
00D20:  DATA 6E,61
00D22:  DATA 62,6C
00D24:  DATA 65,64
00D26:  DATA 0D,0A
00D28:  DATA 00,00
00D2A:  DATA 20,20
00D2C:  DATA 20,4E
00D2E:  DATA 6F,20
00D30:  DATA 46,69
00D32:  DATA 6C,65
00D34:  DATA 20,53
00D36:  DATA 79,73
00D38:  DATA 74,65
00D3A:  DATA 6D,0D
00D3C:  DATA 0A,00
00D3E:  DATA 61,70
00D40:  DATA 70,65
00D42:  DATA 6E,64
00D44:  DATA 3A,20
00D46:  DATA 46,53
00D48:  DATA 20,45
00D4A:  DATA 52,52
00D4C:  DATA 4F,52
00D4E:  DATA 20,6F
00D50:  DATA 6E,20
00D52:  DATA 66,69
00D54:  DATA 6C,65
00D56:  DATA 5F,6F
00D58:  DATA 70,65
00D5A:  DATA 6E,0D
00D5C:  DATA 0A,00
00D5E:  DATA 40,46
00D60:  DATA 53,3A
00D62:  DATA 57,72
00D64:  DATA 69,74
00D66:  DATA 69,6E
00D68:  DATA 67,0D
00D6A:  DATA 0A,5B
00D6C:  DATA 25,73
00D6E:  DATA 5D,0D
00D70:  DATA 0A,00
00D72:  DATA 40,46
00D74:  DATA 53,3A
00D76:  DATA 45,52
00D78:  DATA 52,4F
00D7A:  DATA 52,5B
00D7C:  DATA 61,70
00D7E:  DATA 70,65
00D80:  DATA 6E,64
00D82:  DATA 5D,0D
00D84:  DATA 0A,00
00D86:  DATA 40,46
00D88:  DATA 53,3A
00D8A:  DATA 43,6C
00D8C:  DATA 6F,73
00D8E:  DATA 69,6E
00D90:  DATA 67,0D
00D92:  DATA 0A,00
00D94:  DATA 40,52
00D96:  DATA 54,43
00D98:  DATA 3A,25
00D9A:  DATA 30,32
00D9C:  DATA 75,2F
00D9E:  DATA 00,00
00DA0:  DATA 40,52
00DA2:  DATA 54,43
00DA4:  DATA 3A,25
00DA6:  DATA 30,32
00DA8:  DATA 75,2F
00DAA:  DATA 00,00
00DAC:  DATA 40,41
00DAE:  DATA 4C,4D
00DB0:  DATA 3A,25
00DB2:  DATA 30,32
00DB4:  DATA 75,2F
00DB6:  DATA 00,00
00DB8:  DATA 40,41
00DBA:  DATA 4C,4D
00DBC:  DATA 3A,25
00DBE:  DATA 30,32
00DC0:  DATA 75,2F
00DC2:  DATA 00,00
00DC4:  DATA 40,41
00DC6:  DATA 4C,4D
00DC8:  DATA 0D,0A
00DCA:  DATA 00,00
00DCC:  TBLRD*+
00DCE:  MOVF   FF5,F
00DD0:  BZ    0DF4
00DD2:  MOVFF  FF6,A1D
00DD6:  MOVFF  FF7,A1E
00DDA:  MOVFF  FF8,A1F
00DDE:  MOVF   FF5,W
00DE0:  BTFSS  F9E.4
00DE2:  BRA    0DE0
00DE4:  MOVWF  FAD
00DE6:  MOVFF  A1D,FF6
00DEA:  MOVFF  A1E,FF7
00DEE:  MOVFF  A1F,FF8
00DF2:  BRA    0DCC
00DF4:  RETURN 0
*
00E52:  DATA 74,65
00E54:  DATA 73,74
00E56:  DATA 31,32
00E58:  DATA 33,0D
00E5A:  DATA 0A,00
*
00ED2:  DATA 3F,40
00ED4:  DATA 42,53
00ED6:  DATA 59,0D
00ED8:  DATA 0A,00
00EDA:  DATA 40,52
00EDC:  DATA 44,59
00EDE:  DATA 0D,0A
00EE0:  DATA 00,00
*
00F22:  DATA 40,5B
00F24:  DATA 4F,5D
00F26:  DATA 0D,0A
00F28:  DATA 00,00
00F2A:  DATA 40,43
00F2C:  DATA 4D,44
00F2E:  DATA 20,74
00F30:  DATA 6F,6F
00F32:  DATA 20,6C
00F34:  DATA 6F,6E
00F36:  DATA 67,0D
00F38:  DATA 0A,00
00F3A:  DATA 40,5B
00F3C:  DATA 43,5D
00F3E:  DATA 0D,0A
00F40:  DATA 00,00
00F42:  DATA 40,53
00F44:  DATA 4C,45
00F46:  DATA 45,50
00F48:  DATA 0D,0A
00F4A:  DATA 00,00
00F4C:  DATA 40,4D
00F4E:  DATA 45,52
00F50:  DATA 2C,25
00F52:  DATA 4C,75
00F54:  DATA 2C,25
00F56:  DATA 4C,75
00F58:  DATA 0D,0A
00F5A:  DATA 00,00
00F5C:  DATA 6D,3A
00F5E:  DATA 25,75
00F60:  DATA 2C,25
00F62:  DATA 75,20
00F64:  DATA 63,3A
00F66:  DATA 25,4C
00F68:  DATA 75,2C
00F6A:  DATA 25,4C
00F6C:  DATA 75,2C
00F6E:  DATA 25,4C
00F70:  DATA 75,0D
00F72:  DATA 0A,00
00F74:  MOVLB  A
00F76:  MOVF   x28,W
00F78:  CLRF   01
00F7A:  SUBWF  x27,W
00F7C:  BC    0F84
00F7E:  MOVFF  A27,00
00F82:  BRA    0F9C
00F84:  CLRF   00
00F86:  MOVLW  08
00F88:  MOVWF  x29
00F8A:  RLCF   x27,F
00F8C:  RLCF   00,F
00F8E:  MOVF   x28,W
00F90:  SUBWF  00,W
00F92:  BTFSC  FD8.0
00F94:  MOVWF  00
00F96:  RLCF   01,F
00F98:  DECFSZ x29,F
00F9A:  BRA    0F8A
00F9C:  MOVLB  0
00F9E:  RETURN 0
00FA0:  MOVF   01,W
00FA2:  MOVFF  A25,A27
00FA6:  MOVLW  64
00FA8:  MOVLB  A
00FAA:  MOVWF  x28
00FAC:  MOVLB  0
00FAE:  RCALL  0F74
00FB0:  MOVFF  00,A25
00FB4:  MOVF   01,W
00FB6:  MOVLW  30
00FB8:  BNZ   0FCA
00FBA:  MOVLB  A
00FBC:  BTFSS  x26.1
00FBE:  BRA    0FDC
00FC0:  BTFSC  x26.3
00FC2:  BRA    0FDC
00FC4:  BTFSC  x26.4
00FC6:  MOVLW  20
00FC8:  BRA    0FD2
00FCA:  MOVLB  A
00FCC:  BCF    x26.3
00FCE:  BCF    x26.4
00FD0:  BSF    x26.0
00FD2:  ADDWF  01,F
00FD4:  MOVF   01,W
00FD6:  BTFSS  F9E.4
00FD8:  BRA    0FD6
00FDA:  MOVWF  FAD
00FDC:  MOVFF  A25,A27
00FE0:  MOVLW  0A
00FE2:  MOVWF  x28
00FE4:  MOVLB  0
00FE6:  RCALL  0F74
00FE8:  MOVFF  00,A25
00FEC:  MOVF   01,W
00FEE:  MOVLW  30
00FF0:  BNZ   1002
00FF2:  MOVLB  A
00FF4:  BTFSC  x26.3
00FF6:  BRA    100E
00FF8:  BTFSS  x26.0
00FFA:  BRA    100E
00FFC:  BTFSC  x26.4
00FFE:  MOVLW  20
01000:  MOVLB  0
01002:  ADDWF  01,F
01004:  MOVF   01,W
01006:  BTFSS  F9E.4
01008:  BRA    1006
0100A:  MOVWF  FAD
0100C:  MOVLB  A
0100E:  MOVLW  30
01010:  ADDWF  x25,F
01012:  MOVF   x25,W
01014:  BTFSS  F9E.4
01016:  BRA    1014
01018:  MOVWF  FAD
0101A:  MOVLB  0
0101C:  RETURN 0
0101E:  TBLRD*+
01020:  MOVFF  FF6,A26
01024:  MOVFF  FF7,A27
01028:  MOVFF  FF8,A28
0102C:  MOVF   FF5,W
0102E:  BTFSS  F9E.4
01030:  BRA    102E
01032:  MOVWF  FAD
01034:  MOVFF  A26,FF6
01038:  MOVFF  A27,FF7
0103C:  MOVFF  A28,FF8
01040:  MOVLB  A
01042:  DECFSZ x25,F
01044:  BRA    1048
01046:  BRA    104C
01048:  MOVLB  0
0104A:  BRA    101E
0104C:  MOVLB  0
0104E:  RETURN 0
01050:  BTFSC  FD8.1
01052:  BRA    105C
01054:  MOVLW  0A
01056:  MOVWF  FEA
01058:  MOVLW  39
0105A:  MOVWF  FE9
0105C:  CLRF   00
0105E:  CLRF   01
01060:  CLRF   02
01062:  CLRF   03
01064:  MOVLB  A
01066:  CLRF   x39
01068:  CLRF   x3A
0106A:  CLRF   x3B
0106C:  CLRF   x3C
0106E:  MOVF   x38,W
01070:  IORWF  x37,W
01072:  IORWF  x36,W
01074:  IORWF  x35,W
01076:  BZ    10D0
01078:  MOVLW  20
0107A:  MOVWF  x3D
0107C:  BCF    FD8.0
0107E:  RLCF   x31,F
01080:  RLCF   x32,F
01082:  RLCF   x33,F
01084:  RLCF   x34,F
01086:  RLCF   x39,F
01088:  RLCF   x3A,F
0108A:  RLCF   x3B,F
0108C:  RLCF   x3C,F
0108E:  MOVF   x38,W
01090:  SUBWF  x3C,W
01092:  BNZ   10A4
01094:  MOVF   x37,W
01096:  SUBWF  x3B,W
01098:  BNZ   10A4
0109A:  MOVF   x36,W
0109C:  SUBWF  x3A,W
0109E:  BNZ   10A4
010A0:  MOVF   x35,W
010A2:  SUBWF  x39,W
010A4:  BNC   10C4
010A6:  MOVF   x35,W
010A8:  SUBWF  x39,F
010AA:  MOVF   x36,W
010AC:  BTFSS  FD8.0
010AE:  INCFSZ x36,W
010B0:  SUBWF  x3A,F
010B2:  MOVF   x37,W
010B4:  BTFSS  FD8.0
010B6:  INCFSZ x37,W
010B8:  SUBWF  x3B,F
010BA:  MOVF   x38,W
010BC:  BTFSS  FD8.0
010BE:  INCFSZ x38,W
010C0:  SUBWF  x3C,F
010C2:  BSF    FD8.0
010C4:  RLCF   00,F
010C6:  RLCF   01,F
010C8:  RLCF   02,F
010CA:  RLCF   03,F
010CC:  DECFSZ x3D,F
010CE:  BRA    107C
010D0:  MOVFF  A39,FEF
010D4:  MOVFF  A3A,FEC
010D8:  MOVFF  A3B,FEC
010DC:  MOVFF  A3C,FEC
010E0:  MOVLB  0
010E2:  RETURN 0
010E4:  MOVF   FE9,W
010E6:  MOVLB  A
010E8:  MOVWF  x29
010EA:  MOVLW  3B
010EC:  MOVWF  x30
010EE:  MOVLW  9A
010F0:  MOVWF  x2F
010F2:  MOVLW  CA
010F4:  MOVWF  x2E
010F6:  CLRF   x2D
010F8:  MOVLW  0A
010FA:  MOVWF  x2B
010FC:  BSF    FD8.1
010FE:  MOVLW  0A
01100:  MOVWF  FEA
01102:  MOVLW  25
01104:  MOVWF  FE9
01106:  MOVFF  A28,A34
0110A:  MOVFF  A27,A33
0110E:  MOVFF  A26,A32
01112:  MOVFF  A25,A31
01116:  MOVFF  A30,A38
0111A:  MOVFF  A2F,A37
0111E:  MOVFF  A2E,A36
01122:  MOVFF  A2D,A35
01126:  MOVLB  0
01128:  RCALL  1050
0112A:  MOVF   01,W
0112C:  MOVF   00,F
0112E:  BNZ   1156
01130:  MOVLB  A
01132:  MOVF   x2B,W
01134:  XORLW  01
01136:  BTFSS  FD8.2
01138:  BRA    113E
0113A:  MOVLB  0
0113C:  BRA    1156
0113E:  MOVF   x29,W
01140:  BZ    115A
01142:  ANDLW  0F
01144:  SUBWF  x2B,W
01146:  BZ    114A
01148:  BC    1166
0114A:  BTFSC  x29.7
0114C:  BRA    1166
0114E:  BTFSC  x29.6
01150:  BRA    115A
01152:  MOVLW  20
01154:  BRA    115C
01156:  MOVLB  A
01158:  CLRF   x29
0115A:  MOVLW  30
0115C:  ADDWF  00,F
0115E:  MOVF   00,W
01160:  BTFSS  F9E.4
01162:  BRA    1160
01164:  MOVWF  FAD
01166:  BCF    FD8.1
01168:  MOVFF  A30,A34
0116C:  MOVFF  A2F,A33
01170:  MOVFF  A2E,A32
01174:  MOVFF  A2D,A31
01178:  CLRF   x38
0117A:  CLRF   x37
0117C:  CLRF   x36
0117E:  MOVLW  0A
01180:  MOVWF  x35
01182:  MOVLB  0
01184:  RCALL  1050
01186:  MOVFF  03,A30
0118A:  MOVFF  02,A2F
0118E:  MOVFF  01,A2E
01192:  MOVFF  00,A2D
01196:  MOVLB  A
01198:  DECFSZ x2B,F
0119A:  BRA    10FC
0119C:  MOVLB  0
0119E:  RETURN 0
011A0:  MOVFF  FEA,A2D
011A4:  MOVFF  FE9,A2C
011A8:  MOVLB  A
011AA:  SWAPF  x26,W
011AC:  IORLW  F0
011AE:  MOVWF  x28
011B0:  ADDWF  x28,F
011B2:  ADDLW  E2
011B4:  MOVWF  x29
011B6:  ADDLW  32
011B8:  MOVWF  x2B
011BA:  MOVF   x26,W
011BC:  ANDLW  0F
011BE:  ADDWF  x29,F
011C0:  ADDWF  x29,F
011C2:  ADDWF  x2B,F
011C4:  ADDLW  E9
011C6:  MOVWF  x2A
011C8:  ADDWF  x2A,F
011CA:  ADDWF  x2A,F
011CC:  SWAPF  x25,W
011CE:  ANDLW  0F
011D0:  ADDWF  x2A,F
011D2:  ADDWF  x2B,F
011D4:  RLCF   x2A,F
011D6:  RLCF   x2B,F
011D8:  COMF   x2B,F
011DA:  RLCF   x2B,F
011DC:  MOVF   x25,W
011DE:  ANDLW  0F
011E0:  ADDWF  x2B,F
011E2:  RLCF   x28,F
011E4:  MOVLW  07
011E6:  MOVWF  x27
011E8:  MOVLW  0A
011EA:  DECF   x2A,F
011EC:  ADDWF  x2B,F
011EE:  BNC   11EA
011F0:  DECF   x29,F
011F2:  ADDWF  x2A,F
011F4:  BNC   11F0
011F6:  DECF   x28,F
011F8:  ADDWF  x29,F
011FA:  BNC   11F6
011FC:  DECF   x27,F
011FE:  ADDWF  x28,F
01200:  BNC   11FC
01202:  MOVLW  0A
01204:  MOVWF  FEA
01206:  MOVLW  27
01208:  MOVWF  FE9
0120A:  MOVLW  07
0120C:  ANDWF  x2C,W
0120E:  BCF    x2C.6
01210:  ADDWF  FE9,F
01212:  MOVLW  00
01214:  ADDWFC FEA,F
01216:  MOVF   FE9,W
01218:  SUBLW  2B
0121A:  BNZ   1224
0121C:  MOVF   FEA,W
0121E:  SUBLW  0A
01220:  BNZ   1224
01222:  BSF    x2C.6
01224:  MOVF   FEF,W
01226:  MOVWF  00
01228:  BNZ   123A
0122A:  BTFSC  x2C.6
0122C:  BRA    123A
0122E:  BTFSC  x2C.4
01230:  BRA    124A
01232:  BTFSC  x2C.3
01234:  BRA    123A
01236:  MOVLW  20
01238:  BRA    1240
0123A:  BSF    x2C.3
0123C:  BCF    x2C.4
0123E:  MOVLW  30
01240:  ADDWF  00,F
01242:  MOVF   00,W
01244:  BTFSS  F9E.4
01246:  BRA    1244
01248:  MOVWF  FAD
0124A:  MOVF   FEE,W
0124C:  BTFSS  x2C.6
0124E:  BRA    1216
01250:  MOVLB  0
01252:  RETURN 0
*
01A58:  DATA 40,4C
01A5A:  DATA 50,43
01A5C:  DATA 2C,25
01A5E:  DATA 4C,75
01A60:  DATA 2C,25
01A62:  DATA 4C,64
01A64:  DATA 0D,0A
01A66:  DATA 00,00
01A68:  DATA 40,4D
01A6A:  DATA 4D,45
01A6C:  DATA 2C,25
01A6E:  DATA 75,2C
01A70:  DATA 25,4C
01A72:  DATA 64,2C
01A74:  DATA 25,4C
01A76:  DATA 75,2C
01A78:  DATA 25,4C
01A7A:  DATA 75,2C
01A7C:  DATA 25,4C
01A7E:  DATA 64,2C
01A80:  DATA 25,4C
01A82:  DATA 64,0D
01A84:  DATA 0A,00
01A86:  DATA 56,41
01A88:  DATA 4C,56
01A8A:  DATA 45,20
01A8C:  DATA 53,54
01A8E:  DATA 4F,50
01A90:  DATA 20,25
01A92:  DATA 4C,75
01A94:  DATA 2C,25
01A96:  DATA 4C,75
01A98:  DATA 0D,0A
01A9A:  DATA 00,00
01A9C:  DATA 69,6E
01A9E:  DATA 64,3A
01AA0:  DATA 25,75
01AA2:  DATA 20,2F
01AA4:  DATA 20,70
01AA6:  DATA 68,61
01AA8:  DATA 3A,25
01AAA:  DATA 75,0D
01AAC:  DATA 0A,00
01AAE:  DATA 40,52
01AB0:  DATA 45,43
01AB2:  DATA 20,2D
01AB4:  DATA 20,68
01AB6:  DATA 6F,6D
01AB8:  DATA 69,6E
01ABA:  DATA 67,20
01ABC:  DATA 73,79
01ABE:  DATA 72,69
01AC0:  DATA 6E,67
01AC2:  DATA 65,20
01AC4:  DATA 61,6E
01AC6:  DATA 64,20
01AC8:  DATA 61,6C
01ACA:  DATA 69,67
01ACC:  DATA 6E,69
01ACE:  DATA 6E,67
01AD0:  DATA 20,76
01AD2:  DATA 61,6C
01AD4:  DATA 76,65
01AD6:  DATA 20,74
01AD8:  DATA 6F,20
01ADA:  DATA 70,6F
01ADC:  DATA 72,74
01ADE:  DATA 20,31
01AE0:  DATA 0D,0A
01AE2:  DATA 00,00
01AE4:  DATA 2C,73
01AE6:  DATA 65,72
01AE8:  DATA 69,61
01AEA:  DATA 6C,20
01AEC:  DATA 77,61
01AEE:  DATA 6B,65
01AF0:  DATA 2D,75
01AF2:  DATA 70,2C
01AF4:  DATA 53,44
01AF6:  DATA 20,69
01AF8:  DATA 6E,69
01AFA:  DATA 74,69
01AFC:  DATA 61,6C
01AFE:  DATA 69,7A
01B00:  DATA 65,64
01B02:  DATA 0D,0A
01B04:  DATA 00,00
01B06:  DATA 40,52
01B08:  DATA 53,54
01B0A:  DATA 0D,0A
01B0C:  DATA 00,00
01B0E:  DATA 40,57
01B10:  DATA 44,54
01B12:  DATA 0D,0A
01B14:  DATA 00,00
01B16:  DATA 2C,72
01B18:  DATA 65,73
01B1A:  DATA 74,61
01B1C:  DATA 72,74
01B1E:  DATA 20,63
01B20:  DATA 61,75
01B22:  DATA 73,65
01B24:  DATA 2C,57
01B26:  DATA 44,20
01B28:  DATA 74,69
01B2A:  DATA 6D,65
01B2C:  DATA 2D,6F
01B2E:  DATA 75,74
01B30:  DATA 0D,0A
01B32:  DATA 00,00
01B34:  DATA 40,57
01B36:  DATA 44,53
01B38:  DATA 0D,0A
01B3A:  DATA 00,00
01B3C:  DATA 2C,72
01B3E:  DATA 65,73
01B40:  DATA 74,61
01B42:  DATA 72,74
01B44:  DATA 20,63
01B46:  DATA 61,75
01B48:  DATA 73,65
01B4A:  DATA 2C,57
01B4C:  DATA 44,20
01B4E:  DATA 66,72
01B50:  DATA 6F,6D
01B52:  DATA 20,73
01B54:  DATA 6C,65
01B56:  DATA 65,70
01B58:  DATA 0D,0A
01B5A:  DATA 00,00
01B5C:  DATA 40,4E
01B5E:  DATA 50,55
01B60:  DATA 0D,0A
01B62:  DATA 00,00
01B64:  DATA 2C,69
01B66:  DATA 64,23
01B68:  DATA 5B,25
01B6A:  DATA 4C,75
01B6C:  DATA 5D,2C
01B6E:  DATA 70,6F
01B70:  DATA 77,65
01B72:  DATA 72,20
01B74:  DATA 61,70
01B76:  DATA 70,6C
01B78:  DATA 69,65
01B7A:  DATA 64,2C
01B7C:  DATA 53,44
01B7E:  DATA 20,69
01B80:  DATA 6E,69
01B82:  DATA 74,69
01B84:  DATA 61,6C
01B86:  DATA 69,7A
01B88:  DATA 65,64
01B8A:  DATA 0D,0A
01B8C:  DATA 00,00
01B8E:  DATA 40,52
01B90:  DATA 53,54
01B92:  DATA 0D,0A
01B94:  DATA 00,00
01B96:  DATA 2C,72
01B98:  DATA 65,73
01B9A:  DATA 74,61
01B9C:  DATA 72,74
01B9E:  DATA 20,63
01BA0:  DATA 61,75
01BA2:  DATA 73,65
01BA4:  DATA 2C,72
01BA6:  DATA 65,73
01BA8:  DATA 65,74
01BAA:  DATA 20,69
01BAC:  DATA 6E,73
01BAE:  DATA 74,72
01BB0:  DATA 75,63
01BB2:  DATA 74,69
01BB4:  DATA 6F,6E
01BB6:  DATA 0D,0A
01BB8:  DATA 00,00
01BBA:  DATA 40,42
01BBC:  DATA 4F,52
01BBE:  DATA 0D,0A
01BC0:  DATA 00,00
01BC2:  DATA 2C,72
01BC4:  DATA 65,73
01BC6:  DATA 74,61
01BC8:  DATA 72,74
01BCA:  DATA 20,63
01BCC:  DATA 61,75
01BCE:  DATA 73,65
01BD0:  DATA 2C,62
01BD2:  DATA 72,6F
01BD4:  DATA 77,6E
01BD6:  DATA 2D,6F
01BD8:  DATA 75,74
01BDA:  DATA 0D,0A
01BDC:  DATA 00,00
01BDE:  DATA 40,4D
01BE0:  DATA 52,53
01BE2:  DATA 0D,0A
01BE4:  DATA 00,00
01BE6:  DATA 2C,72
01BE8:  DATA 65,73
01BEA:  DATA 74,61
01BEC:  DATA 72,74
01BEE:  DATA 20,63
01BF0:  DATA 61,75
01BF2:  DATA 73,65
01BF4:  DATA 2C,4D
01BF6:  DATA 43,4C
01BF8:  DATA 52,20
01BFA:  DATA 66,72
01BFC:  DATA 6F,6D
01BFE:  DATA 20,73
01C00:  DATA 6C,65
01C02:  DATA 65,70
01C04:  DATA 0D,0A
01C06:  DATA 00,00
01C08:  DATA 40,4D
01C0A:  DATA 52,52
01C0C:  DATA 0D,0A
01C0E:  DATA 00,00
01C10:  DATA 2C,72
01C12:  DATA 65,73
01C14:  DATA 74,61
01C16:  DATA 72,74
01C18:  DATA 20,63
01C1A:  DATA 61,75
01C1C:  DATA 73,65
01C1E:  DATA 2C,4D
01C20:  DATA 43,4C
01C22:  DATA 52,20
01C24:  DATA 77,68
01C26:  DATA 65,6E
01C28:  DATA 20,72
01C2A:  DATA 75,6E
01C2C:  DATA 6E,69
01C2E:  DATA 6E,67
01C30:  DATA 0D,0A
01C32:  DATA 00,00
01C34:  DATA 4E,4F
01C36:  DATA 33,00
01C38:  DATA 4E,4F
01C3A:  DATA 32,00
01C3C:  DATA 50,4F
01C3E:  DATA 34,00
01C40:  DATA 4E,48
01C42:  DATA 34,00
01C44:  DATA 53,69
01C46:  DATA 4F,00
01C48:  DATA 00,00
01C4A:  DATA 40,44
01C4C:  DATA 45,54
01C4E:  DATA 5B,2F
01C50:  DATA 25,75
01C52:  DATA 5D,5B
01C54:  DATA 25,63
01C56:  DATA 5D,41
01C58:  DATA 52,47
01C5A:  DATA 5B,25
01C5C:  DATA 4C,75
01C5E:  DATA 5D,0D
01C60:  DATA 0A,00
01C62:  DATA 20,74
01C64:  DATA 69,6D
01C66:  DATA 65,2D
01C68:  DATA 6F,75
01C6A:  DATA 74,00
01C6C:  DATA 20,64
01C6E:  DATA 61,74
01C70:  DATA 61,20
01C72:  DATA 74,6F
01C74:  DATA 6F,20
01C76:  DATA 73,68
01C78:  DATA 6F,72
01C7A:  DATA 74,00
01C7C:  DATA 20,64
01C7E:  DATA 61,74
01C80:  DATA 61,20
01C82:  DATA 74,6F
01C84:  DATA 6F,20
01C86:  DATA 6C,6F
01C88:  DATA 6E,67
01C8A:  DATA 00,00
01C8C:  DATA 2C,64
01C8E:  DATA 65,74
01C90:  DATA 65,63
01C92:  DATA 74,6F
01C94:  DATA 72,5B
01C96:  DATA 25,73
01C98:  DATA 5D,2C
01C9A:  DATA 6C,65
01C9C:  DATA 6E,5B
01C9E:  DATA 25,75
01CA0:  DATA 5D,00
01CA2:  DATA 40,52
01CA4:  DATA 54,59
01CA6:  DATA 2C,25
01CA8:  DATA 75,0D
01CAA:  DATA 0A,00
01CAC:  DATA 2C,73
01CAE:  DATA 74,61
01CB0:  DATA 72,74
01CB2:  DATA 20,68
01CB4:  DATA 65,61
01CB6:  DATA 74,69
01CB8:  DATA 6E,67
01CBA:  DATA 2C,74
01CBC:  DATA 61,72
01CBE:  DATA 67,65
01CC0:  DATA 74,5B
01CC2:  DATA 25,4C
01CC4:  DATA 75,5D
01CC6:  DATA 2C,61
01CC8:  DATA 63,74
01CCA:  DATA 75,61
01CCC:  DATA 6C,5B
01CCE:  DATA 25,4C
01CD0:  DATA 75,5D
01CD2:  DATA 2C,72
01CD4:  DATA 65,61
01CD6:  DATA 64,69
01CD8:  DATA 6E,67
01CDA:  DATA 73,5B
01CDC:  DATA 25,4C
01CDE:  DATA 75,5D
01CE0:  DATA 0D,0A
01CE2:  DATA 00,00
01CE4:  DATA 2C,65
01CE6:  DATA 6E,64
01CE8:  DATA 20,68
01CEA:  DATA 65,61
01CEC:  DATA 74,69
01CEE:  DATA 6E,67
01CF0:  DATA 2C,74
01CF2:  DATA 61,72
01CF4:  DATA 67,65
01CF6:  DATA 74,5B
01CF8:  DATA 25,4C
01CFA:  DATA 75,5D
01CFC:  DATA 2C,61
01CFE:  DATA 63,74
01D00:  DATA 75,61
01D02:  DATA 6C,5B
01D04:  DATA 25,4C
01D06:  DATA 75,5D
01D08:  DATA 2C,72
01D0A:  DATA 65,61
01D0C:  DATA 64,69
01D0E:  DATA 6E,67
01D10:  DATA 73,5B
01D12:  DATA 25,4C
01D14:  DATA 75,5D
01D16:  DATA 0D,0A
01D18:  DATA 00,00
01D1A:  DATA 4E,4F
01D1C:  DATA 33,00
01D1E:  DATA 4E,4F
01D20:  DATA 32,00
01D22:  DATA 50,4F
01D24:  DATA 34,00
01D26:  DATA 4E,48
01D28:  DATA 34,00
01D2A:  DATA 53,69
01D2C:  DATA 4F,00
01D2E:  DATA 00,00
01D30:  DATA 40,44
01D32:  DATA 41,43
01D34:  DATA 2C,25
01D36:  DATA 4C,75
01D38:  DATA 2C,25
01D3A:  DATA 4C,75
01D3C:  DATA 2C,00
01D3E:  DATA 40,53
01D40:  DATA 41,52
01D42:  DATA 2C,31
01D44:  DATA 2C,25
01D46:  DATA 4C,75
01D48:  DATA 2C,00
01D4A:  DATA 40,56
01D4C:  DATA 41,4C
01D4E:  DATA 20,00
01D50:  DATA 40,56
01D52:  DATA 41,4C
01D54:  DATA 20,00
01D56:  DATA 40,56
01D58:  DATA 41,4C
01D5A:  DATA 20,00
01D5C:  DATA 40,56
01D5E:  DATA 41,4C
01D60:  DATA 20,00
01D62:  DATA 40,53
01D64:  DATA 4F,4C
01D66:  DATA 5B,2F
01D68:  DATA 31,5D
01D6A:  DATA 5B,73
01D6C:  DATA 5D,5B
01D6E:  DATA 25,4C
01D70:  DATA 75,5D
01D72:  DATA 0D,0A
01D74:  DATA 00,00
01D76:  DATA 2F,31
01D78:  DATA 73,25
01D7A:  DATA 4C,75
01D7C:  DATA 0D,00
01D7E:  DATA 40,53
01D80:  DATA 4F,4C
01D82:  DATA 5B,2F
01D84:  DATA 31,5D
01D86:  DATA 5B,63
01D88:  DATA 5D,5B
01D8A:  DATA 25,75
01D8C:  DATA 5D,0D
01D8E:  DATA 0A,00
01D90:  DATA 2F,31
01D92:  DATA 63,25
01D94:  DATA 75,0D
01D96:  DATA 00,00
01D98:  DATA 2F,31
01D9A:  DATA 73,32
01D9C:  DATA 35,36
01D9E:  DATA 0D,00
01DA0:  DATA 28,49
01DA2:  DATA 30,73
01DA4:  DATA 29,2C
01DA6:  DATA 25,4C
01DA8:  DATA 75,2C
01DAA:  DATA 28,49
01DAC:  DATA 31,73
01DAE:  DATA 29,2C
01DB0:  DATA 25,4C
01DB2:  DATA 75,2C
01DB4:  DATA 28,41
01DB6:  DATA 62,73
01DB8:  DATA 2D,73
01DBA:  DATA 29,2C
01DBC:  DATA 25,31
01DBE:  DATA 2E,34
01DC0:  DATA 67,2C
01DC2:  DATA 28,49
01DC4:  DATA 30,74
01DC6:  DATA 29,2C
01DC8:  DATA 25,4C
01DCA:  DATA 75,2C
01DCC:  DATA 28,49
01DCE:  DATA 31,74
01DD0:  DATA 29,2C
01DD2:  DATA 25,4C
01DD4:  DATA 75,2C
01DD6:  DATA 28,41
01DD8:  DATA 62,73
01DDA:  DATA 2D,74
01DDC:  DATA 29,2C
01DDE:  DATA 25,31
01DE0:  DATA 2E,34
01DE2:  DATA 67,2C
01DE4:  DATA 28,49
01DE6:  DATA 30,72
01DE8:  DATA 29,2C
01DEA:  DATA 25,4C
01DEC:  DATA 75,2C
01DEE:  DATA 28,49
01DF0:  DATA 31,72
01DF2:  DATA 29,2C
01DF4:  DATA 25,4C
01DF6:  DATA 75,2C
01DF8:  DATA 28,41
01DFA:  DATA 62,73
01DFC:  DATA 2D,72
01DFE:  DATA 29,2C
01E00:  DATA 25,31
01E02:  DATA 2E,34
01E04:  DATA 67,00
01E06:  DATA 40,41
01E08:  DATA 62,73
01E0A:  DATA 2C,4E
01E0C:  DATA 4F,33
01E0E:  DATA 2C,25
01E10:  DATA 73,0D
01E12:  DATA 0A,00
01E14:  DATA 28,49
01E16:  DATA 30,73
01E18:  DATA 29,2C
01E1A:  DATA 25,4C
01E1C:  DATA 75,2C
01E1E:  DATA 28,49
01E20:  DATA 31,73
01E22:  DATA 29,2C
01E24:  DATA 25,4C
01E26:  DATA 75,2C
01E28:  DATA 28,41
01E2A:  DATA 62,73
01E2C:  DATA 2D,73
01E2E:  DATA 29,2C
01E30:  DATA 25,31
01E32:  DATA 2E,34
01E34:  DATA 67,2C
01E36:  DATA 28,49
01E38:  DATA 30,74
01E3A:  DATA 29,2C
01E3C:  DATA 25,4C
01E3E:  DATA 75,2C
01E40:  DATA 28,49
01E42:  DATA 31,74
01E44:  DATA 29,2C
01E46:  DATA 25,4C
01E48:  DATA 75,2C
01E4A:  DATA 28,41
01E4C:  DATA 62,73
01E4E:  DATA 2D,74
01E50:  DATA 29,2C
01E52:  DATA 25,31
01E54:  DATA 2E,34
01E56:  DATA 67,2C
01E58:  DATA 28,49
01E5A:  DATA 30,72
01E5C:  DATA 29,2C
01E5E:  DATA 25,4C
01E60:  DATA 75,2C
01E62:  DATA 28,49
01E64:  DATA 31,72
01E66:  DATA 29,2C
01E68:  DATA 25,4C
01E6A:  DATA 75,2C
01E6C:  DATA 28,41
01E6E:  DATA 62,73
01E70:  DATA 2D,72
01E72:  DATA 29,2C
01E74:  DATA 25,31
01E76:  DATA 2E,34
01E78:  DATA 67,00
01E7A:  DATA 40,41
01E7C:  DATA 62,73
01E7E:  DATA 2C,4E
01E80:  DATA 4F,32
01E82:  DATA 2C,25
01E84:  DATA 73,0D
01E86:  DATA 0A,00
01E88:  DATA 28,49
01E8A:  DATA 30,73
01E8C:  DATA 29,2C
01E8E:  DATA 25,4C
01E90:  DATA 75,2C
01E92:  DATA 28,49
01E94:  DATA 31,73
01E96:  DATA 29,2C
01E98:  DATA 25,4C
01E9A:  DATA 75,2C
01E9C:  DATA 28,41
01E9E:  DATA 62,73
01EA0:  DATA 2D,73
01EA2:  DATA 29,2C
01EA4:  DATA 25,31
01EA6:  DATA 2E,34
01EA8:  DATA 67,2C
01EAA:  DATA 28,49
01EAC:  DATA 30,74
01EAE:  DATA 29,2C
01EB0:  DATA 25,4C
01EB2:  DATA 75,2C
01EB4:  DATA 28,49
01EB6:  DATA 31,74
01EB8:  DATA 29,2C
01EBA:  DATA 25,4C
01EBC:  DATA 75,2C
01EBE:  DATA 28,41
01EC0:  DATA 62,73
01EC2:  DATA 2D,74
01EC4:  DATA 29,2C
01EC6:  DATA 25,31
01EC8:  DATA 2E,34
01ECA:  DATA 67,2C
01ECC:  DATA 28,49
01ECE:  DATA 30,72
01ED0:  DATA 29,2C
01ED2:  DATA 25,4C
01ED4:  DATA 75,2C
01ED6:  DATA 28,49
01ED8:  DATA 31,72
01EDA:  DATA 29,2C
01EDC:  DATA 25,4C
01EDE:  DATA 75,2C
01EE0:  DATA 28,41
01EE2:  DATA 62,73
01EE4:  DATA 2D,72
01EE6:  DATA 29,2C
01EE8:  DATA 25,31
01EEA:  DATA 2E,34
01EEC:  DATA 67,00
01EEE:  DATA 40,41
01EF0:  DATA 62,73
01EF2:  DATA 2C,50
01EF4:  DATA 4F,34
01EF6:  DATA 2C,25
01EF8:  DATA 73,0D
01EFA:  DATA 0A,00
01EFC:  DATA 28,49
01EFE:  DATA 30,73
01F00:  DATA 29,2C
01F02:  DATA 25,4C
01F04:  DATA 75,2C
01F06:  DATA 28,49
01F08:  DATA 31,73
01F0A:  DATA 29,2C
01F0C:  DATA 25,4C
01F0E:  DATA 75,2C
01F10:  DATA 28,41
01F12:  DATA 62,73
01F14:  DATA 2D,73
01F16:  DATA 29,2C
01F18:  DATA 25,31
01F1A:  DATA 2E,34
01F1C:  DATA 67,2C
01F1E:  DATA 28,49
01F20:  DATA 30,74
01F22:  DATA 29,2C
01F24:  DATA 25,4C
01F26:  DATA 75,2C
01F28:  DATA 28,49
01F2A:  DATA 31,74
01F2C:  DATA 29,2C
01F2E:  DATA 25,4C
01F30:  DATA 75,2C
01F32:  DATA 28,41
01F34:  DATA 62,73
01F36:  DATA 2D,74
01F38:  DATA 29,2C
01F3A:  DATA 25,31
01F3C:  DATA 2E,34
01F3E:  DATA 67,2C
01F40:  DATA 28,49
01F42:  DATA 30,72
01F44:  DATA 29,2C
01F46:  DATA 25,4C
01F48:  DATA 75,2C
01F4A:  DATA 28,49
01F4C:  DATA 31,72
01F4E:  DATA 29,2C
01F50:  DATA 25,4C
01F52:  DATA 75,2C
01F54:  DATA 28,41
01F56:  DATA 62,73
01F58:  DATA 2D,72
01F5A:  DATA 29,2C
01F5C:  DATA 25,31
01F5E:  DATA 2E,34
01F60:  DATA 67,00
01F62:  DATA 40,41
01F64:  DATA 62,73
01F66:  DATA 2C,4E
01F68:  DATA 48,34
01F6A:  DATA 2C,25
01F6C:  DATA 73,0D
01F6E:  DATA 0A,00
01F70:  DATA 28,49
01F72:  DATA 30,73
01F74:  DATA 29,2C
01F76:  DATA 25,4C
01F78:  DATA 75,2C
01F7A:  DATA 28,49
01F7C:  DATA 31,73
01F7E:  DATA 29,2C
01F80:  DATA 25,4C
01F82:  DATA 75,2C
01F84:  DATA 28,41
01F86:  DATA 62,73
01F88:  DATA 2D,73
01F8A:  DATA 29,2C
01F8C:  DATA 25,31
01F8E:  DATA 2E,34
01F90:  DATA 67,2C
01F92:  DATA 28,49
01F94:  DATA 30,74
01F96:  DATA 29,2C
01F98:  DATA 25,4C
01F9A:  DATA 75,2C
01F9C:  DATA 28,49
01F9E:  DATA 31,74
01FA0:  DATA 29,2C
01FA2:  DATA 25,4C
01FA4:  DATA 75,2C
01FA6:  DATA 28,41
01FA8:  DATA 62,73
01FAA:  DATA 2D,74
01FAC:  DATA 29,2C
01FAE:  DATA 25,31
01FB0:  DATA 2E,34
01FB2:  DATA 67,2C
01FB4:  DATA 28,49
01FB6:  DATA 30,72
01FB8:  DATA 29,2C
01FBA:  DATA 25,4C
01FBC:  DATA 75,2C
01FBE:  DATA 28,49
01FC0:  DATA 31,72
01FC2:  DATA 29,2C
01FC4:  DATA 25,4C
01FC6:  DATA 75,2C
01FC8:  DATA 28,41
01FCA:  DATA 62,73
01FCC:  DATA 2D,72
01FCE:  DATA 29,2C
01FD0:  DATA 25,31
01FD2:  DATA 2E,34
01FD4:  DATA 67,00
01FD6:  DATA 40,41
01FD8:  DATA 42,53
01FDA:  DATA 2C,53
01FDC:  DATA 69,4F
01FDE:  DATA 2C,25
01FE0:  DATA 73,0D
01FE2:  DATA 0A,00
01FE4:  DATA 4E,4F
01FE6:  DATA 33,00
01FE8:  DATA 4E,4F
01FEA:  DATA 32,00
01FEC:  DATA 50,4F
01FEE:  DATA 34,00
01FF0:  DATA 4E,48
01FF2:  DATA 34,00
01FF4:  DATA 53,69
01FF6:  DATA 4F,00
01FF8:  DATA 00,00
01FFA:  DATA 28,6D
01FFC:  DATA 29,2C
01FFE:  DATA 25,33
02000:  DATA 2E,33
02002:  DATA 67,2C
02004:  DATA 28,63
02006:  DATA 29,2C
02008:  DATA 25,33
0200A:  DATA 2E,33
0200C:  DATA 67,00
0200E:  DATA 28,43
02010:  DATA 73,29
02012:  DATA 2C,25
02014:  DATA 33,2E
02016:  DATA 33,67
02018:  DATA 0D,0A
0201A:  DATA 00,00
0201C:  DATA 40,43
0201E:  DATA 4F,4E
02020:  DATA 2C,4E
02022:  DATA 4F,33
02024:  DATA 2C,25
02026:  DATA 73,0D
02028:  DATA 0A,00
0202A:  DATA 28,6D
0202C:  DATA 29,2C
0202E:  DATA 25,33
02030:  DATA 2E,33
02032:  DATA 67,2C
02034:  DATA 28,63
02036:  DATA 29,2C
02038:  DATA 25,33
0203A:  DATA 2E,33
0203C:  DATA 67,00
0203E:  DATA 28,43
02040:  DATA 73,29
02042:  DATA 2C,25
02044:  DATA 33,2E
02046:  DATA 33,67
02048:  DATA 0D,0A
0204A:  DATA 00,00
0204C:  DATA 40,43
0204E:  DATA 4F,4E
02050:  DATA 2C,50
02052:  DATA 4F,34
02054:  DATA 2C,25
02056:  DATA 73,0D
02058:  DATA 0A,00
0205A:  DATA 28,6D
0205C:  DATA 29,2C
0205E:  DATA 25,33
02060:  DATA 2E,33
02062:  DATA 67,2C
02064:  DATA 28,63
02066:  DATA 29,2C
02068:  DATA 25,33
0206A:  DATA 2E,33
0206C:  DATA 67,00
0206E:  DATA 28,43
02070:  DATA 73,29
02072:  DATA 2C,25
02074:  DATA 33,2E
02076:  DATA 33,67
02078:  DATA 0D,0A
0207A:  DATA 00,00
0207C:  DATA 40,43
0207E:  DATA 4F,4E
02080:  DATA 2C,4E
02082:  DATA 48,34
02084:  DATA 2C,25
02086:  DATA 73,0D
02088:  DATA 0A,00
0208A:  DATA 28,6D
0208C:  DATA 29,2C
0208E:  DATA 25,33
02090:  DATA 2E,33
02092:  DATA 67,2C
02094:  DATA 28,63
02096:  DATA 29,2C
02098:  DATA 25,33
0209A:  DATA 2E,33
0209C:  DATA 67,00
0209E:  DATA 28,43
020A0:  DATA 73,29
020A2:  DATA 2C,25
020A4:  DATA 33,2E
020A6:  DATA 33,67
020A8:  DATA 0D,0A
020AA:  DATA 00,00
020AC:  DATA 40,43
020AE:  DATA 4F,4E
020B0:  DATA 2C,53
020B2:  DATA 69,4F
020B4:  DATA 2C,25
020B6:  DATA 73,0D
020B8:  DATA 0A,00
020BA:  DATA 4E,4F
020BC:  DATA 33,00
020BE:  DATA 50,4F
020C0:  DATA 34,00
020C2:  DATA 4E,48
020C4:  DATA 34,00
020C6:  DATA 53,69
020C8:  DATA 4F,00
020CA:  DATA 00,00
020CC:  DATA 4D,45
020CE:  DATA 4D,4F
020D0:  DATA 52,59
020D2:  DATA 20,4F
020D4:  DATA 56,45
020D6:  DATA 52,46
020D8:  DATA 4C,4F
020DA:  DATA 57,20
020DC:  DATA 45,52
020DE:  DATA 52,4F
020E0:  DATA 52,20
020E2:  DATA 40,20
020E4:  DATA 4C,69
020E6:  DATA 6E,65
020E8:  DATA 20,3A
020EA:  DATA 25,4C
020EC:  DATA 75,0A
020EE:  DATA 0D,00
020F0:  DATA 0D,0A
020F2:  DATA 3A,00
020F4:  DATA 0D,0A
020F6:  DATA 57,41
020F8:  DATA 52,4E
020FA:  DATA 49,4E
020FC:  DATA 47,3A
020FE:  DATA 20,49
02100:  DATA 4E,56
02102:  DATA 41,4C
02104:  DATA 49,44
02106:  DATA 20,43
02108:  DATA 4F,4D
0210A:  DATA 4D,41
0210C:  DATA 4E,44
0210E:  DATA 20,49
02110:  DATA 4E,20
02112:  DATA 4D,41
02114:  DATA 43,52
02116:  DATA 4F,21
02118:  DATA 0D,0A
0211A:  DATA 00,00
0211C:  DATA 42,61
0211E:  DATA 64,20
02120:  DATA 63,6F
02122:  DATA 6D,6D
02124:  DATA 61,6E
02126:  DATA 64,20
02128:  DATA 61,74
0212A:  DATA 20,6C
0212C:  DATA 69,6E
0212E:  DATA 65,3A
02130:  DATA 20,25
02132:  DATA 4C,64
02134:  DATA 20,0D
02136:  DATA 0A,00
02138:  DATA 50,6C
0213A:  DATA 65,61
0213C:  DATA 73,65
0213E:  DATA 20,72
02140:  DATA 65,2D
02142:  DATA 75,70
02144:  DATA 6C,6F
02146:  DATA 61,64
02148:  DATA 20,6D
0214A:  DATA 61,63
0214C:  DATA 72,6F
0214E:  DATA 00,00
02150:  DATA 49,74
02152:  DATA 65,72
02154:  DATA 61,74
02156:  DATA 69,6F
02158:  DATA 6E,73
0215A:  DATA 20,6C
0215C:  DATA 65,66
0215E:  DATA 74,3A
02160:  DATA 20,25
02162:  DATA 4C,75
02164:  DATA 0D,0A
02166:  DATA 00,00
02168:  DATA 2C,6D
0216A:  DATA 61,63
0216C:  DATA 72,6F
0216E:  DATA 5B,25
02170:  DATA 75,5D
02172:  DATA 2C,73
02174:  DATA 74,61
02176:  DATA 72,74
02178:  DATA 0D,0A
0217A:  DATA 00,00
0217C:  DATA 40,4D
0217E:  DATA 43,4C
02180:  DATA 5B,25
02182:  DATA 63,5D
02184:  DATA 5B,25
02186:  DATA 4C,75
02188:  DATA 5D,0D
0218A:  DATA 0A,00
0218C:  DATA 40,4C
0218E:  DATA 4E,45
02190:  DATA 0D,0A
02192:  DATA 00,00
02194:  DATA 40,52
02196:  DATA 55,4E
02198:  DATA 0D,0A
0219A:  DATA 00,00
0219C:  DATA 40,42
0219E:  DATA 41,44
021A0:  DATA 0D,0A
021A2:  DATA 00,00
021A4:  DATA 40,54
021A6:  DATA 2F,4F
021A8:  DATA 0D,0A
021AA:  DATA 00,00
021AC:  DATA 40,45
021AE:  DATA 52,52
021B0:  DATA 0D,0A
021B2:  DATA 00,00
021B4:  DATA 40,45
021B6:  DATA 4E,44
021B8:  DATA 0D,0A
021BA:  DATA 00,00
021BC:  DATA 40,48
021BE:  DATA 4C,54
021C0:  DATA 0D,0A
021C2:  DATA 00,00
021C4:  DATA 2C,6D
021C6:  DATA 61,63
021C8:  DATA 72,6F
021CA:  DATA 5B,25
021CC:  DATA 75,5D
021CE:  DATA 2C,73
021D0:  DATA 74,61
021D2:  DATA 74,75
021D4:  DATA 73,5B
021D6:  DATA 25,63
021D8:  DATA 5D,2C
021DA:  DATA 6C,69
021DC:  DATA 6E,65
021DE:  DATA 5B,25
021E0:  DATA 4C,75
021E2:  DATA 5D,0D
021E4:  DATA 0A,00
021E6:  DATA 40,52
021E8:  DATA 75,6E
021EA:  DATA 6E,69
021EC:  DATA 6E,67
021EE:  DATA 20,25
021F0:  DATA 63,25
021F2:  DATA 4C,75
021F4:  DATA 20,0D
021F6:  DATA 0A,00
021F8:  DATA 40,4D
021FA:  DATA 61,63
021FC:  DATA 72,6F
021FE:  DATA 20,25
02200:  DATA 30,34
02202:  DATA 4C,75
02204:  DATA 20,6F
02206:  DATA 66,20
02208:  DATA 25,30
0220A:  DATA 34,4C
0220C:  DATA 75,0D
0220E:  DATA 0A,00
02210:  DATA 40,4C
02212:  DATA 4E,45
02214:  DATA 0D,0A
02216:  DATA 00,00
02218:  DATA 40,52
0221A:  DATA 55,4E
0221C:  DATA 0D,0A
0221E:  DATA 00,00
02220:  DATA 40,42
02222:  DATA 41,44
02224:  DATA 0D,0A
02226:  DATA 00,00
02228:  DATA 40,54
0222A:  DATA 2F,4F
0222C:  DATA 0D,0A
0222E:  DATA 00,00
02230:  DATA 40,45
02232:  DATA 52,52
02234:  DATA 0D,0A
02236:  DATA 00,00
02238:  DATA 40,45
0223A:  DATA 4E,44
0223C:  DATA 0D,0A
0223E:  DATA 00,00
02240:  DATA 2C,61
02242:  DATA 75,74
02244:  DATA 6F,2D
02246:  DATA 73,61
02248:  DATA 6D,70
0224A:  DATA 6C,65
0224C:  DATA 2C,73
0224E:  DATA 61,6D
02250:  DATA 70,6C
02252:  DATA 65,5B
02254:  DATA 25,4C
02256:  DATA 75,5D
02258:  DATA 2C,73
0225A:  DATA 74,61
0225C:  DATA 72,74
0225E:  DATA 0D,0A
02260:  DATA 00,00
02262:  DATA 2C,61
02264:  DATA 75,74
02266:  DATA 6F,2D
02268:  DATA 73,61
0226A:  DATA 6D,70
0226C:  DATA 6C,65
0226E:  DATA 2C,73
02270:  DATA 61,6D
02272:  DATA 70,6C
02274:  DATA 65,5B
02276:  DATA 25,4C
02278:  DATA 75,5D
0227A:  DATA 2C,63
0227C:  DATA 6F,6D
0227E:  DATA 70,6C
02280:  DATA 65,74
02282:  DATA 65,0D
02284:  DATA 0A,00
02286:  DATA 2C,61
02288:  DATA 75,74
0228A:  DATA 6F,2D
0228C:  DATA 73,61
0228E:  DATA 6D,70
02290:  DATA 6C,65
02292:  DATA 2C,73
02294:  DATA 61,6D
02296:  DATA 70,6C
02298:  DATA 65,5B
0229A:  DATA 25,4C
0229C:  DATA 75,5D
0229E:  DATA 2C,65
022A0:  DATA 72,72
022A2:  DATA 6F,72
022A4:  DATA 0D,0A
022A6:  DATA 00,00
022A8:  DATA 2C,61
022AA:  DATA 75,74
022AC:  DATA 6F,2D
022AE:  DATA 73,61
022B0:  DATA 6D,70
022B2:  DATA 6C,65
022B4:  DATA 2C,73
022B6:  DATA 61,6D
022B8:  DATA 70,6C
022BA:  DATA 65,5B
022BC:  DATA 25,4C
022BE:  DATA 75,5D
022C0:  DATA 2C,6D
022C2:  DATA 61,78
022C4:  DATA 20,73
022C6:  DATA 61,6D
022C8:  DATA 70,6C
022CA:  DATA 65,73
022CC:  DATA 0D,0A
022CE:  DATA 00,00
022D0:  DATA 2C,61
022D2:  DATA 75,74
022D4:  DATA 6F,2D
022D6:  DATA 73,61
022D8:  DATA 6D,70
022DA:  DATA 6C,65
022DC:  DATA 2C,73
022DE:  DATA 61,6D
022E0:  DATA 70,6C
022E2:  DATA 65,5B
022E4:  DATA 25,4C
022E6:  DATA 75,5D
022E8:  DATA 2C,73
022EA:  DATA 74,61
022EC:  DATA 72,74
022EE:  DATA 0D,0A
022F0:  DATA 00,00
022F2:  DATA 2C,61
022F4:  DATA 75,74
022F6:  DATA 6F,2D
022F8:  DATA 73,61
022FA:  DATA 6D,70
022FC:  DATA 6C,65
022FE:  DATA 2C,73
02300:  DATA 61,6D
02302:  DATA 70,6C
02304:  DATA 65,5B
02306:  DATA 25,4C
02308:  DATA 75,5D
0230A:  DATA 2C,63
0230C:  DATA 6F,6D
0230E:  DATA 70,6C
02310:  DATA 65,74
02312:  DATA 65,0D
02314:  DATA 0A,00
02316:  DATA 2C,61
02318:  DATA 75,74
0231A:  DATA 6F,2D
0231C:  DATA 73,61
0231E:  DATA 6D,70
02320:  DATA 6C,65
02322:  DATA 2C,73
02324:  DATA 61,6D
02326:  DATA 70,6C
02328:  DATA 65,5B
0232A:  DATA 25,4C
0232C:  DATA 75,5D
0232E:  DATA 2C,73
02330:  DATA 74,61
02332:  DATA 72,74
02334:  DATA 0D,0A
02336:  DATA 00,00
02338:  DATA 2C,61
0233A:  DATA 75,74
0233C:  DATA 6F,2D
0233E:  DATA 73,61
02340:  DATA 6D,70
02342:  DATA 6C,65
02344:  DATA 2C,73
02346:  DATA 61,6D
02348:  DATA 70,6C
0234A:  DATA 65,5B
0234C:  DATA 25,4C
0234E:  DATA 75,5D
02350:  DATA 2C,63
02352:  DATA 6F,6D
02354:  DATA 70,6C
02356:  DATA 65,74
02358:  DATA 65,0D
0235A:  DATA 0A,00
0235C:  DATA 2C,61
0235E:  DATA 75,74
02360:  DATA 6F,2D
02362:  DATA 73,61
02364:  DATA 6D,70
02366:  DATA 6C,65
02368:  DATA 2C,73
0236A:  DATA 61,6D
0236C:  DATA 70,6C
0236E:  DATA 65,5B
02370:  DATA 25,4C
02372:  DATA 75,5D
02374:  DATA 2C,6D
02376:  DATA 61,78
02378:  DATA 20,73
0237A:  DATA 61,6D
0237C:  DATA 70,6C
0237E:  DATA 65,73
02380:  DATA 0D,0A
02382:  DATA 00,00
02384:  DATA 2C,61
02386:  DATA 75,74
02388:  DATA 6F,2D
0238A:  DATA 73,61
0238C:  DATA 6D,70
0238E:  DATA 6C,65
02390:  DATA 2C,69
02392:  DATA 6E,69
02394:  DATA 74,69
02396:  DATA 61,6C
02398:  DATA 69,7A
0239A:  DATA 65,0D
0239C:  DATA 0A,00
0239E:  DATA 2C,68
023A0:  DATA 65,61
023A2:  DATA 64,65
023A4:  DATA 72,2C
023A6:  DATA 69,64
023A8:  DATA 23,5B
023AA:  DATA 25,4C
023AC:  DATA 75,5D
023AE:  DATA 2C,69
023B0:  DATA 6E,74
023B2:  DATA 5B,25
023B4:  DATA 4C,75
023B6:  DATA 5D,2C
023B8:  DATA 6D,61
023BA:  DATA 78,5B
023BC:  DATA 25,4C
023BE:  DATA 75,5D
023C0:  DATA 0D,0A
023C2:  DATA 00,00
023C4:  DATA 2C,61
023C6:  DATA 75,74
023C8:  DATA 6F,2D
023CA:  DATA 73,61
023CC:  DATA 6D,70
023CE:  DATA 6C,65
023D0:  DATA 2C,73
023D2:  DATA 61,6D
023D4:  DATA 70,6C
023D6:  DATA 65,5B
023D8:  DATA 25,4C
023DA:  DATA 75,5D
023DC:  DATA 2C,61
023DE:  DATA 6C,61
023E0:  DATA 72,6D
023E2:  DATA 5B,25
023E4:  DATA 75,5D
023E6:  DATA 0D,0A
023E8:  DATA 00,00
023EA:  DATA 2C,61
023EC:  DATA 75,74
023EE:  DATA 6F,2D
023F0:  DATA 73,61
023F2:  DATA 6D,70
023F4:  DATA 6C,65
023F6:  DATA 2C,73
023F8:  DATA 6C,65
023FA:  DATA 65,70
023FC:  DATA 0D,0A
023FE:  DATA 00,00
02400:  DATA 74,31
02402:  DATA 3A,25
02404:  DATA 4C,75
02406:  DATA 20,74
02408:  DATA 32,3A
0240A:  DATA 25,4C
0240C:  DATA 75,0D
0240E:  DATA 0A,00
02410:  DATA 40,44
02412:  DATA 45,54
02414:  DATA 2C,25
02416:  DATA 4C,75
02418:  DATA 0D,0A
0241A:  DATA 00,00
0241C:  DATA 4E,4F
0241E:  DATA 33,2C
02420:  DATA 25,31
02422:  DATA 2E,35
02424:  DATA 67,2C
02426:  DATA 25,31
02428:  DATA 2E,35
0242A:  DATA 67,0D
0242C:  DATA 0A,00
0242E:  DATA 50,4F
02430:  DATA 34,2C
02432:  DATA 25,31
02434:  DATA 2E,35
02436:  DATA 67,2C
02438:  DATA 25,31
0243A:  DATA 2E,35
0243C:  DATA 67,0D
0243E:  DATA 0A,00
02440:  DATA 4E,48
02442:  DATA 34,2C
02444:  DATA 25,31
02446:  DATA 2E,35
02448:  DATA 67,2C
0244A:  DATA 25,31
0244C:  DATA 2E,35
0244E:  DATA 67,0D
02450:  DATA 0A,00
02452:  DATA 53,69
02454:  DATA 4F,34
02456:  DATA 2C,25
02458:  DATA 31,2E
0245A:  DATA 35,67
0245C:  DATA 2C,25
0245E:  DATA 31,2E
02460:  DATA 35,67
02462:  DATA 0D,0A
02464:  DATA 00,00
02466:  DATA 4E,4F
02468:  DATA 33,28
0246A:  DATA 6D,29
0246C:  DATA 3A,00
0246E:  DATA 4E,4F
02470:  DATA 33,28
02472:  DATA 63,29
02474:  DATA 3A,00
02476:  DATA 50,4F
02478:  DATA 34,28
0247A:  DATA 6D,29
0247C:  DATA 3A,00
0247E:  DATA 50,4F
02480:  DATA 34,28
02482:  DATA 63,29
02484:  DATA 3A,00
02486:  DATA 4E,48
02488:  DATA 34,28
0248A:  DATA 6D,29
0248C:  DATA 3A,00
0248E:  DATA 4E,48
02490:  DATA 34,28
02492:  DATA 63,29
02494:  DATA 3A,00
02496:  DATA 53,69
02498:  DATA 4F,34
0249A:  DATA 28,6D
0249C:  DATA 29,3A
0249E:  DATA 00,00
024A0:  DATA 53,69
024A2:  DATA 4F,34
024A4:  DATA 28,63
024A6:  DATA 29,3A
024A8:  DATA 00,00
024AA:  DATA 41,72
024AC:  DATA 65,20
024AE:  DATA 79,6F
024B0:  DATA 75,20
024B2:  DATA 73,75
024B4:  DATA 72,65
024B6:  DATA 20,79
024B8:  DATA 6F,75
024BA:  DATA 20,77
024BC:  DATA 61,6E
024BE:  DATA 74,20
024C0:  DATA 74,6F
024C2:  DATA 20,65
024C4:  DATA 72,61
024C6:  DATA 73,65
024C8:  DATA 20,74
024CA:  DATA 68,65
024CC:  DATA 20,72
024CE:  DATA 61,77
024D0:  DATA 20,64
024D2:  DATA 61,74
024D4:  DATA 61,20
024D6:  DATA 66,69
024D8:  DATA 6C,65
024DA:  DATA 3F,20
024DC:  DATA 59,20
024DE:  DATA 6F,72
024E0:  DATA 20,4E
024E2:  DATA 21,0D
024E4:  DATA 0A,00
024E6:  DATA 46,69
024E8:  DATA 6C,65
024EA:  DATA 20,64
024EC:  DATA 65,6C
024EE:  DATA 65,74
024F0:  DATA 65,64
024F2:  DATA 21,0A
024F4:  DATA 0D,00
024F6:  DATA 4F,70
024F8:  DATA 65,72
024FA:  DATA 61,74
024FC:  DATA 69,6F
024FE:  DATA 6E,20
02500:  DATA 63,61
02502:  DATA 6E,63
02504:  DATA 65,6C
02506:  DATA 65,64
02508:  DATA 21,0D
0250A:  DATA 0A,00
0250C:  DATA 41,72
0250E:  DATA 65,20
02510:  DATA 79,6F
02512:  DATA 75,20
02514:  DATA 73,75
02516:  DATA 72,65
02518:  DATA 20,79
0251A:  DATA 6F,75
0251C:  DATA 20,77
0251E:  DATA 61,6E
02520:  DATA 74,20
02522:  DATA 74,6F
02524:  DATA 20,65
02526:  DATA 72,61
02528:  DATA 73,65
0252A:  DATA 20,74
0252C:  DATA 68,65
0252E:  DATA 20,63
02530:  DATA 61,6C
02532:  DATA 63,75
02534:  DATA 6C,61
02536:  DATA 74,65
02538:  DATA 64,20
0253A:  DATA 64,61
0253C:  DATA 74,61
0253E:  DATA 20,66
02540:  DATA 69,6C
02542:  DATA 65,3F
02544:  DATA 20,59
02546:  DATA 20,6F
02548:  DATA 72,20
0254A:  DATA 4E,21
0254C:  DATA 0D,0A
0254E:  DATA 00,00
02550:  DATA 46,69
02552:  DATA 6C,65
02554:  DATA 20,64
02556:  DATA 65,6C
02558:  DATA 65,74
0255A:  DATA 65,64
0255C:  DATA 21,0A
0255E:  DATA 0D,00
02560:  DATA 4F,70
02562:  DATA 65,72
02564:  DATA 61,74
02566:  DATA 69,6F
02568:  DATA 6E,20
0256A:  DATA 63,61
0256C:  DATA 6E,63
0256E:  DATA 65,6C
02570:  DATA 65,64
02572:  DATA 21,0D
02574:  DATA 0A,00
02576:  DATA 40,49
02578:  DATA 44,23
0257A:  DATA 25,4C
0257C:  DATA 75,20
0257E:  DATA 49,25
02580:  DATA 4C,75
02582:  DATA 20,4E
02584:  DATA 25,4C
02586:  DATA 75,2F
02588:  DATA 25,4C
0258A:  DATA 75,20
0258C:  DATA 58,25
0258E:  DATA 4C,75
02590:  DATA 20,55
02592:  DATA 25,75
02594:  DATA 20,25
02596:  DATA 34,2E
02598:  DATA 32,77
0259A:  DATA 56,0D
0259C:  DATA 0A,00
0259E:  DATA 40,4D
025A0:  DATA 4F,54
025A2:  DATA 3A,56
025A4:  DATA 41,4C
025A6:  DATA 3D,25
025A8:  DATA 4C,75
025AA:  DATA 20,53
025AC:  DATA 59,52
025AE:  DATA 3D,25
025B0:  DATA 4C,64
025B2:  DATA 0D,0A
025B4:  DATA 00,00
025B6:  DATA 40,50
025B8:  DATA 57,52
025BA:  DATA 3A,25
025BC:  DATA 30,32
025BE:  DATA 75,2F
025C0:  DATA 25,30
025C2:  DATA 32,75
025C4:  DATA 2F,25
025C6:  DATA 30,32
025C8:  DATA 75,20
025CA:  DATA 25,30
025CC:  DATA 32,75
025CE:  DATA 3A,25
025D0:  DATA 30,32
025D2:  DATA 75,3A
025D4:  DATA 25,30
025D6:  DATA 32,75
025D8:  DATA 0D,0A
025DA:  DATA 00,00
025DC:  DATA 40,50
025DE:  DATA 57,52
025E0:  DATA 3A,25
025E2:  DATA 30,32
025E4:  DATA 75,2F
025E6:  DATA 25,30
025E8:  DATA 32,75
025EA:  DATA 2F,25
025EC:  DATA 30,32
025EE:  DATA 75,20
025F0:  DATA 25,30
025F2:  DATA 32,75
025F4:  DATA 3A,25
025F6:  DATA 30,32
025F8:  DATA 75,3A
025FA:  DATA 25,30
025FC:  DATA 32,75
025FE:  DATA 0D,0A
02600:  DATA 00,00
02602:  DATA 41,25
02604:  DATA 4C,75
02606:  DATA 20,49
02608:  DATA 25,4C
0260A:  DATA 75,20
0260C:  DATA 4C,25
0260E:  DATA 4C,75
02610:  DATA 20,51
02612:  DATA 25,4C
02614:  DATA 75,20
02616:  DATA 53,25
02618:  DATA 4C,75
0261A:  DATA 20,25
0261C:  DATA 34,2E
0261E:  DATA 32,77
02620:  DATA 56,0D
02622:  DATA 0A,00
02624:  DATA 40,4D
02626:  DATA 4F,54
02628:  DATA 3A,56
0262A:  DATA 41,4C
0262C:  DATA 3D,25
0262E:  DATA 4C,75
02630:  DATA 20,53
02632:  DATA 59,52
02634:  DATA 3D,25
02636:  DATA 4C,64
02638:  DATA 0D,0A
0263A:  DATA 00,00
0263C:  DATA 40,50
0263E:  DATA 57,52
02640:  DATA 3A,25
02642:  DATA 30,32
02644:  DATA 75,2F
02646:  DATA 25,30
02648:  DATA 32,75
0264A:  DATA 2F,25
0264C:  DATA 30,32
0264E:  DATA 75,20
02650:  DATA 25,30
02652:  DATA 32,75
02654:  DATA 3A,25
02656:  DATA 30,32
02658:  DATA 75,3A
0265A:  DATA 25,30
0265C:  DATA 32,75
0265E:  DATA 0D,0A
02660:  DATA 00,00
02662:  DATA 49,25
02664:  DATA 4C,75
02666:  DATA 20,4E
02668:  DATA 25,4C
0266A:  DATA 75,2F
0266C:  DATA 25,4C
0266E:  DATA 75,20
02670:  DATA 50,25
02672:  DATA 4C,75
02674:  DATA 20,25
02676:  DATA 34,2E
02678:  DATA 32,77
0267A:  DATA 56,0D
0267C:  DATA 0A,00
0267E:  DATA 40,4D
02680:  DATA 4F,54
02682:  DATA 3A,53
02684:  DATA 59,52
02686:  DATA 3D,25
02688:  DATA 4C,64
0268A:  DATA 0D,0A
0268C:  DATA 00,00
0268E:  DATA 40,50
02690:  DATA 57,52
02692:  DATA 3A,25
02694:  DATA 30,32
02696:  DATA 75,2F
02698:  DATA 25,30
0269A:  DATA 32,75
0269C:  DATA 2F,25
0269E:  DATA 30,32
026A0:  DATA 75,20
026A2:  DATA 25,30
026A4:  DATA 32,75
026A6:  DATA 3A,25
026A8:  DATA 30,32
026AA:  DATA 75,3A
026AC:  DATA 25,30
026AE:  DATA 32,75
026B0:  DATA 0D,0A
026B2:  DATA 00,00
026B4:  DATA 40,53
026B6:  DATA 4D,50
026B8:  DATA 20,25
026BA:  DATA 30,34
026BC:  DATA 4C,75
026BE:  DATA 0D,0A
026C0:  DATA 00,00
026C2:  DATA 40,53
026C4:  DATA 4D,50
026C6:  DATA 20,25
026C8:  DATA 30,34
026CA:  DATA 4C,75
026CC:  DATA 0D,0A
026CE:  DATA 00,00
026D0:  DATA 45,6E
026D2:  DATA 74,65
026D4:  DATA 72,20
026D6:  DATA 64,61
026D8:  DATA 74,65
026DA:  DATA 20,66
026DC:  DATA 6F,72
026DE:  DATA 6D,61
026E0:  DATA 74,20
026E2:  DATA 30,3D
026E4:  DATA 4D,4D
026E6:  DATA 2F,44
026E8:  DATA 44,2F
026EA:  DATA 59,59
026EC:  DATA 20,20
026EE:  DATA 31,3D
026F0:  DATA 44,44
026F2:  DATA 2F,4D
026F4:  DATA 4D,2F
026F6:  DATA 59,59
026F8:  DATA 0D,0A
026FA:  DATA 00,00
026FC:  DATA 40,4F
026FE:  DATA 4B,21
02700:  DATA 0D,0A
02702:  DATA 20,00
02704:  DATA 40,45
02706:  DATA 52,52
02708:  DATA 0D,0A
0270A:  DATA 00,00
0270C:  DATA 40,52
0270E:  DATA 55,4E
02710:  DATA 0D,0A
02712:  DATA 00,00
02714:  DATA 5B,6D
02716:  DATA 6F,74
02718:  DATA 6F,72
0271A:  DATA 3A,31
0271C:  DATA 5D,0D
0271E:  DATA 0A,00
02720:  DATA 5B,6D
02722:  DATA 6F,74
02724:  DATA 6F,72
02726:  DATA 3A,32
02728:  DATA 5D,0D
0272A:  DATA 0A,00
0272C:  DATA 2C,45
0272E:  DATA 43,4F
02730:  DATA 20,6D
02732:  DATA 6F,64
02734:  DATA 65,20
02736:  DATA 73,65
02738:  DATA 74,0D
0273A:  DATA 0A,00
0273C:  DATA 2C,57
0273E:  DATA 4D,53
02740:  DATA 2D,34
02742:  DATA 2D,53
02744:  DATA 44,20
02746:  DATA 6D,6F
02748:  DATA 64,65
0274A:  DATA 20,73
0274C:  DATA 65,74
0274E:  DATA 0D,0A
02750:  DATA 00,00
02752:  DATA 2C,41
02754:  DATA 57,53
02756:  DATA 20,6D
02758:  DATA 6F,64
0275A:  DATA 65,20
0275C:  DATA 73,65
0275E:  DATA 74,0D
02760:  DATA 0A,00
02762:  DATA 2C,57
02764:  DATA 4D,53
02766:  DATA 2D,34
02768:  DATA 2D,51
0276A:  DATA 45,20
0276C:  DATA 6D,6F
0276E:  DATA 64,65
02770:  DATA 20,73
02772:  DATA 65,74
02774:  DATA 0D,0A
02776:  DATA 00,00
02778:  DATA 30,33
0277A:  DATA 2D,4A
0277C:  DATA 75,6C
0277E:  DATA 2D,31
02780:  DATA 37,00
02782:  DATA 31,32
02784:  DATA 3A,34
02786:  DATA 35,3A
02788:  DATA 33,30
0278A:  DATA 00,00
0278C:  DATA 53,45
0278E:  DATA 4E,44
02790:  DATA 20,48
02792:  DATA 45,58
02794:  DATA 20,46
02796:  DATA 49,4C
02798:  DATA 45,20
0279A:  DATA 28,31
0279C:  DATA 39,32
0279E:  DATA 30,30
027A0:  DATA 2C,4E
027A2:  DATA 38,31
027A4:  DATA 2C,58
027A6:  DATA 4F,4E
027A8:  DATA 2D,58
027AA:  DATA 4F,46
027AC:  DATA 46,29
027AE:  DATA 0D,0A
027B0:  DATA 00,00
027B2:  DATA 40,4F
027B4:  DATA 4B,21
027B6:  DATA 20,00
027B8:  DATA 40,41
027BA:  DATA 52,47
027BC:  DATA 20,00
027BE:  DATA 40,49
027C0:  DATA 4E,56
027C2:  DATA 00,00
027C4:  DATA 40,43
027C6:  DATA 4D,44
027C8:  DATA 00,00
027CA:  DATA 2C,63
027CC:  DATA 6F,6D
027CE:  DATA 6D,61
027D0:  DATA 6E,64
027D2:  DATA 20,70
027D4:  DATA 72,6F
027D6:  DATA 6D,70
027D8:  DATA 74,0D
027DA:  DATA 0A,00
027DC:  DATA 40,53
027DE:  DATA 44,3D
027E0:  DATA 25,4C
027E2:  DATA 75,0D
027E4:  DATA 0A,00
027E6:  DATA 40,4D
027E8:  DATA 43,31
027EA:  DATA 2C,25
027EC:  DATA 4C,75
027EE:  DATA 2C,25
027F0:  DATA 4C,64
027F2:  DATA 0D,0A
027F4:  DATA 00,00
027F6:  DATA 40,4D
027F8:  DATA 43,32
027FA:  DATA 2C,25
027FC:  DATA 4C,75
027FE:  DATA 2C,25
02800:  DATA 4C,64
02802:  DATA 0D,0A
02804:  DATA 00,00
02806:  DATA 50,72
02808:  DATA 65,73
0280A:  DATA 73,20
0280C:  DATA 61,6E
0280E:  DATA 64,20
02810:  DATA 68,6F
02812:  DATA 6C,64
02814:  DATA 20,74
02816:  DATA 68,65
02818:  DATA 20,45
0281A:  DATA 73,63
0281C:  DATA 20,6B
0281E:  DATA 65,79
02820:  DATA 20,74
02822:  DATA 6F,20
02824:  DATA 72,65
02826:  DATA 74,75
02828:  DATA 72,6E
0282A:  DATA 20,74
0282C:  DATA 6F,20
0282E:  DATA 43,6F
02830:  DATA 6D,6D
02832:  DATA 61,6E
02834:  DATA 64,20
02836:  DATA 4D,6F
02838:  DATA 64,65
0283A:  DATA 0D,0A
0283C:  DATA 00,00
0283E:  DATA 52,65
02840:  DATA 74,75
02842:  DATA 72,6E
02844:  DATA 69,6E
02846:  DATA 67,20
02848:  DATA 74,6F
0284A:  DATA 20,4C
0284C:  DATA 6F,67
0284E:  DATA 67,69
02850:  DATA 6E,67
02852:  DATA 20,4D
02854:  DATA 6F,64
02856:  DATA 65,0D
02858:  DATA 0A,00
0285A:  DATA 63,72
0285C:  DATA 61,70
0285E:  DATA 3A,20
02860:  DATA 25,75
02862:  DATA 0D,0A
02864:  DATA 00,00
02866:  DATA 72,65
02868:  DATA 67,30
0286A:  DATA 3A,20
0286C:  DATA 25,75
0286E:  DATA 0D,0A
02870:  DATA 00,00
02872:  DATA 72,65
02874:  DATA 67,31
02876:  DATA 3A,20
02878:  DATA 25,75
0287A:  DATA 0D,0A
0287C:  DATA 00,00
0287E:  DATA 72,65
02880:  DATA 67,32
02882:  DATA 3A,20
02884:  DATA 25,75
02886:  DATA 0D,0A
02888:  DATA 00,00
0288A:  DATA 72,65
0288C:  DATA 67,33
0288E:  DATA 3A,20
02890:  DATA 25,75
02892:  DATA 0D,0A
02894:  DATA 00,00
02896:  DATA 72,65
02898:  DATA 67,34
0289A:  DATA 3A,20
0289C:  DATA 25,75
0289E:  DATA 0D,0A
028A0:  DATA 00,00
028A2:  DATA 72,65
028A4:  DATA 67,35
028A6:  DATA 3A,20
028A8:  DATA 25,75
028AA:  DATA 0D,0A
028AC:  DATA 00,00
028AE:  DATA 72,65
028B0:  DATA 67,36
028B2:  DATA 3A,20
028B4:  DATA 25,75
028B6:  DATA 0D,0A
028B8:  DATA 00,00
028BA:  DATA 72,65
028BC:  DATA 67,37
028BE:  DATA 3A,20
028C0:  DATA 25,75
028C2:  DATA 0D,0A
028C4:  DATA 00,00
028C6:  DATA 72,65
028C8:  DATA 67,38
028CA:  DATA 3A,20
028CC:  DATA 25,75
028CE:  DATA 0D,0A
028D0:  DATA 00,00
028D2:  DATA 72,65
028D4:  DATA 67,39
028D6:  DATA 3A,20
028D8:  DATA 25,75
028DA:  DATA 0D,0A
028DC:  DATA 00,00
028DE:  DATA 72,65
028E0:  DATA 67,41
028E2:  DATA 3A,20
028E4:  DATA 25,75
028E6:  DATA 0D,0A
028E8:  DATA 00,00
028EA:  DATA 72,65
028EC:  DATA 67,42
028EE:  DATA 3A,20
028F0:  DATA 25,75
028F2:  DATA 0D,0A
028F4:  DATA 00,00
028F6:  DATA 72,65
028F8:  DATA 67,43
028FA:  DATA 3A,20
028FC:  DATA 25,75
028FE:  DATA 0D,0A
02900:  DATA 00,00
02902:  DATA 72,65
02904:  DATA 67,44
02906:  DATA 3A,20
02908:  DATA 25,75
0290A:  DATA 0D,0A
0290C:  DATA 00,00
0290E:  DATA 72,65
02910:  DATA 67,45
02912:  DATA 3A,20
02914:  DATA 25,75
02916:  DATA 0D,0A
02918:  DATA 00,00
0291A:  DATA 72,65
0291C:  DATA 67,46
0291E:  DATA 3A,20
02920:  DATA 25,75
02922:  DATA 0D,0A
02924:  DATA 00,00
*
02D36:  CLRF   01
02D38:  CLRF   02
02D3A:  CLRF   00
02D3C:  CLRF   03
02D3E:  MOVLB  8
02D40:  MOVF   xC8,W
02D42:  BNZ   2D48
02D44:  MOVF   xC7,W
02D46:  BZ    2D78
02D48:  MOVLW  10
02D4A:  MOVWF  xC9
02D4C:  BCF    FD8.0
02D4E:  RLCF   xC5,F
02D50:  RLCF   xC6,F
02D52:  RLCF   00,F
02D54:  RLCF   03,F
02D56:  MOVF   xC8,W
02D58:  SUBWF  03,W
02D5A:  BNZ   2D60
02D5C:  MOVF   xC7,W
02D5E:  SUBWF  00,W
02D60:  BNC   2D70
02D62:  MOVF   xC7,W
02D64:  SUBWF  00,F
02D66:  BTFSS  FD8.0
02D68:  DECF   03,F
02D6A:  MOVF   xC8,W
02D6C:  SUBWF  03,F
02D6E:  BSF    FD8.0
02D70:  RLCF   01,F
02D72:  RLCF   02,F
02D74:  DECFSZ xC9,F
02D76:  BRA    2D4C
02D78:  MOVLB  0
02D7A:  RETURN 0
*
03588:  TSTFSZ 01
0358A:  BRA    3592
0358C:  TSTFSZ 02
0358E:  BRA    3594
03590:  BRA    35A0
03592:  INCF   02,F
03594:  MOVFF  00,FEE
03598:  DECFSZ 01,F
0359A:  BRA    3594
0359C:  DECFSZ 02,F
0359E:  BRA    3594
035A0:  RETURN 0
*
03672:  MOVLB  9
03674:  BTFSC  xD7.7
03676:  BRA    3698
03678:  MOVLW  0F
0367A:  MOVWF  00
0367C:  SWAPF  xD6,W
0367E:  ANDWF  00,F
03680:  MOVLW  0A
03682:  SUBWF  00,W
03684:  BC    368C
03686:  MOVLW  30
03688:  ADDWF  00,F
0368A:  BRA    3690
0368C:  MOVF   xD7,W
0368E:  ADDWF  00,F
03690:  MOVF   00,W
03692:  BTFSS  F9E.4
03694:  BRA    3692
03696:  MOVWF  FAD
03698:  MOVLW  0F
0369A:  ANDWF  xD6,F
0369C:  MOVLW  0A
0369E:  SUBWF  xD6,W
036A0:  BC    36A6
036A2:  MOVLW  30
036A4:  BRA    36AA
036A6:  BCF    xD7.7
036A8:  MOVF   xD7,W
036AA:  ADDWF  xD6,F
036AC:  MOVF   xD6,W
036AE:  BTFSS  F9E.4
036B0:  BRA    36AE
036B2:  MOVWF  FAD
036B4:  MOVLB  0
036B6:  RETURN 0
*
04852:  MOVLB  9
04854:  CLRF   xE8
04856:  CLRF   xE9
04858:  MOVLW  01
0485A:  MOVWF  xEA
0485C:  CLRF   FDA
0485E:  CLRF   FD9
04860:  MOVLW  09
04862:  MOVWF  xED
04864:  MOVLW  E0
04866:  MOVWF  xEC
04868:  MOVLW  09
0486A:  MOVWF  FEA
0486C:  MOVLW  E4
0486E:  MOVWF  FE9
04870:  MOVFF  9ED,FE2
04874:  MOVFF  9EC,FE1
04878:  MOVFF  9EA,9EB
0487C:  BCF    FD8.0
0487E:  MOVF   FE5,W
04880:  MULWF  FEE
04882:  MOVF   FF3,W
04884:  ADDWFC xE8,F
04886:  MOVF   FF4,W
04888:  ADDWFC xE9,F
0488A:  DECFSZ xEB,F
0488C:  BRA    487C
0488E:  MOVFF  9E8,FDE
04892:  MOVFF  9E9,9E8
04896:  CLRF   xE9
04898:  BTFSC  FD8.0
0489A:  INCF   xE9,F
0489C:  INCF   xEC,F
0489E:  BTFSC  FD8.2
048A0:  INCF   xED,F
048A2:  INCF   xEA,F
048A4:  MOVF   xEA,W
048A6:  SUBLW  05
048A8:  BNZ   4868
048AA:  MOVLB  0
048AC:  RETURN 0
*
050F6:  MOVFF  1E,FEA
050FA:  MOVFF  1D,FE9
050FE:  MOVLB  8
05100:  MOVFF  8E9,FEF
05104:  INCF   FE9,F
05106:  BTFSC  FD8.2
05108:  INCF   FEA,F
0510A:  CLRF   FEF
0510C:  INCF   1D,F
0510E:  BTFSC  FD8.2
05110:  INCF   1E,F
05112:  MOVLB  0
05114:  RETURN 0
05116:  TBLRD*+
05118:  MOVF   FF5,F
0511A:  BZ    513C
0511C:  MOVFF  FF6,8D5
05120:  MOVFF  FF7,8D6
05124:  MOVFF  FF8,8D7
05128:  MOVFF  FF5,8E9
0512C:  RCALL  50F6
0512E:  MOVFF  8D5,FF6
05132:  MOVFF  8D6,FF7
05136:  MOVFF  8D7,FF8
0513A:  BRA    5116
0513C:  RETURN 0
*
052D8:  MOVF   01,W
052DA:  CLRF   1B
052DC:  BTFSC  FF2.7
052DE:  BSF    1B.7
052E0:  BCF    FF2.7
052E2:  MOVFF  8D7,A27
052E6:  MOVLW  64
052E8:  MOVLB  A
052EA:  MOVWF  x28
052EC:  MOVLB  0
052EE:  CALL   0F74
052F2:  BTFSC  1B.7
052F4:  BSF    FF2.7
052F6:  MOVFF  00,8D7
052FA:  MOVF   01,W
052FC:  MOVLW  30
052FE:  BNZ   5310
05300:  MOVLB  8
05302:  BTFSS  xD8.1
05304:  BRA    5324
05306:  BTFSC  xD8.3
05308:  BRA    5324
0530A:  BTFSC  xD8.4
0530C:  MOVLW  20
0530E:  BRA    5318
05310:  MOVLB  8
05312:  BCF    xD8.3
05314:  BCF    xD8.4
05316:  BSF    xD8.0
05318:  ADDWF  01,F
0531A:  MOVFF  01,8E9
0531E:  MOVLB  0
05320:  RCALL  50F6
05322:  MOVLB  8
05324:  CLRF   1B
05326:  BTFSC  FF2.7
05328:  BSF    1B.7
0532A:  BCF    FF2.7
0532C:  MOVFF  8D7,A27
05330:  MOVLW  0A
05332:  MOVLB  A
05334:  MOVWF  x28
05336:  MOVLB  0
05338:  CALL   0F74
0533C:  BTFSC  1B.7
0533E:  BSF    FF2.7
05340:  MOVFF  00,8D7
05344:  MOVF   01,W
05346:  MOVLW  30
05348:  BNZ   535A
0534A:  MOVLB  8
0534C:  BTFSC  xD8.3
0534E:  BRA    5364
05350:  BTFSS  xD8.0
05352:  BRA    5364
05354:  BTFSC  xD8.4
05356:  MOVLW  20
05358:  MOVLB  0
0535A:  ADDWF  01,F
0535C:  MOVFF  01,8E9
05360:  RCALL  50F6
05362:  MOVLB  8
05364:  MOVLW  30
05366:  ADDWF  xD7,F
05368:  MOVFF  8D7,8E9
0536C:  MOVLB  0
0536E:  RCALL  50F6
05370:  RETURN 0
05372:  MOVF   FE9,W
05374:  MOVLB  8
05376:  MOVWF  xDC
05378:  MOVLW  3B
0537A:  MOVWF  xE3
0537C:  MOVLW  9A
0537E:  MOVWF  xE2
05380:  MOVLW  CA
05382:  MOVWF  xE1
05384:  CLRF   xE0
05386:  MOVLW  0A
05388:  MOVWF  xDE
0538A:  MOVF   xDB,W
0538C:  BTFSS  FD8.2
0538E:  DECF   xDC,F
05390:  BSF    FD8.1
05392:  MOVLW  08
05394:  MOVWF  FEA
05396:  MOVLW  D7
05398:  MOVWF  FE9
0539A:  CLRF   1B
0539C:  BTFSC  FF2.7
0539E:  BSF    1B.7
053A0:  BCF    FF2.7
053A2:  MOVFF  8DA,A34
053A6:  MOVFF  8D9,A33
053AA:  MOVFF  8D8,A32
053AE:  MOVFF  8D7,A31
053B2:  MOVFF  8E3,A38
053B6:  MOVFF  8E2,A37
053BA:  MOVFF  8E1,A36
053BE:  MOVFF  8E0,A35
053C2:  MOVLB  0
053C4:  CALL   1050
053C8:  BTFSC  1B.7
053CA:  BSF    FF2.7
053CC:  MOVF   01,W
053CE:  MOVF   00,F
053D0:  BNZ   53F8
053D2:  MOVLB  8
053D4:  INCF   xDB,W
053D6:  SUBWF  xDE,W
053D8:  BTFSS  FD8.2
053DA:  BRA    53E0
053DC:  MOVLB  0
053DE:  BRA    53F8
053E0:  MOVF   xDC,W
053E2:  BZ    53FC
053E4:  ANDLW  0F
053E6:  SUBWF  xDE,W
053E8:  BZ    53EC
053EA:  BC    5428
053EC:  BTFSC  xDC.7
053EE:  BRA    5428
053F0:  BTFSC  xDC.6
053F2:  BRA    53FC
053F4:  MOVLW  20
053F6:  BRA    541C
053F8:  MOVLB  8
053FA:  CLRF   xDC
053FC:  MOVF   xDB,W
053FE:  SUBWF  xDE,W
05400:  BNZ   541A
05402:  MOVFF  00,8DC
05406:  MOVLW  2E
05408:  MOVWF  xE9
0540A:  MOVLB  0
0540C:  RCALL  50F6
0540E:  MOVLB  8
05410:  MOVFF  8DC,00
05414:  MOVLW  20
05416:  ANDWF  xDC,F
05418:  MOVLW  00
0541A:  MOVLW  30
0541C:  ADDWF  00,F
0541E:  MOVFF  00,8E9
05422:  MOVLB  0
05424:  RCALL  50F6
05426:  MOVLB  8
05428:  BCF    FD8.1
0542A:  CLRF   1B
0542C:  BTFSC  FF2.7
0542E:  BSF    1B.7
05430:  BCF    FF2.7
05432:  MOVFF  8E3,A34
05436:  MOVFF  8E2,A33
0543A:  MOVFF  8E1,A32
0543E:  MOVFF  8E0,A31
05442:  MOVLB  A
05444:  CLRF   x38
05446:  CLRF   x37
05448:  CLRF   x36
0544A:  MOVLW  0A
0544C:  MOVWF  x35
0544E:  MOVLB  0
05450:  CALL   1050
05454:  BTFSC  1B.7
05456:  BSF    FF2.7
05458:  MOVFF  03,8E3
0545C:  MOVFF  02,8E2
05460:  MOVFF  01,8E1
05464:  MOVFF  00,8E0
05468:  MOVLB  8
0546A:  DECFSZ xDE,F
0546C:  BRA    5390
0546E:  MOVLB  0
05470:  RETURN 0
*
05D14:  MOVLB  9
05D16:  MOVF   xF6,W
05D18:  MULWF  xF8
05D1A:  MOVFF  FF3,01
05D1E:  MOVFF  FF4,00
05D22:  MULWF  xF9
05D24:  MOVF   FF3,W
05D26:  ADDWF  00,F
05D28:  MOVF   xF7,W
05D2A:  MULWF  xF8
05D2C:  MOVF   FF3,W
05D2E:  ADDWFC 00,W
05D30:  MOVWF  02
05D32:  MOVLB  0
05D34:  RETURN 0
*
079DC:  MOVF   FEF,F
079DE:  BZ    7A00
079E0:  MOVFF  FEA,99B
079E4:  MOVFF  FE9,99A
079E8:  MOVF   FEF,W
079EA:  BTFSS  F9E.4
079EC:  BRA    79EA
079EE:  MOVWF  FAD
079F0:  MOVFF  99B,FEA
079F4:  MOVFF  99A,FE9
079F8:  INCF   FE9,F
079FA:  BTFSC  FD8.2
079FC:  INCF   FEA,F
079FE:  BRA    79DC
07A00:  RETURN 0
*
09024:  MOVFF  FEA,8E2
09028:  MOVFF  FE9,8E1
0902C:  MOVLB  8
0902E:  BTFSS  xDB.7
09030:  BRA    9042
09032:  BSF    xE1.7
09034:  BTFSS  xE1.4
09036:  INCF   xE1,F
09038:  COMF   xDA,F
0903A:  COMF   xDB,F
0903C:  INCF   xDA,F
0903E:  BTFSC  FD8.2
09040:  INCF   xDB,F
09042:  SWAPF  xDB,W
09044:  IORLW  F0
09046:  MOVWF  xDD
09048:  ADDWF  xDD,F
0904A:  ADDLW  E2
0904C:  MOVWF  xDE
0904E:  ADDLW  32
09050:  MOVWF  xE0
09052:  MOVF   xDB,W
09054:  ANDLW  0F
09056:  ADDWF  xDE,F
09058:  ADDWF  xDE,F
0905A:  ADDWF  xE0,F
0905C:  ADDLW  E9
0905E:  MOVWF  xDF
09060:  ADDWF  xDF,F
09062:  ADDWF  xDF,F
09064:  SWAPF  xDA,W
09066:  ANDLW  0F
09068:  ADDWF  xDF,F
0906A:  ADDWF  xE0,F
0906C:  RLCF   xDF,F
0906E:  RLCF   xE0,F
09070:  COMF   xE0,F
09072:  RLCF   xE0,F
09074:  MOVF   xDA,W
09076:  ANDLW  0F
09078:  ADDWF  xE0,F
0907A:  RLCF   xDD,F
0907C:  MOVLW  07
0907E:  MOVWF  xDC
09080:  MOVLW  0A
09082:  DECF   xDF,F
09084:  ADDWF  xE0,F
09086:  BNC   9082
09088:  DECF   xDE,F
0908A:  ADDWF  xDF,F
0908C:  BNC   9088
0908E:  DECF   xDD,F
09090:  ADDWF  xDE,F
09092:  BNC   908E
09094:  DECF   xDC,F
09096:  ADDWF  xDD,F
09098:  BNC   9094
0909A:  MOVLW  08
0909C:  MOVWF  FEA
0909E:  MOVLW  DC
090A0:  MOVWF  FE9
090A2:  MOVLW  07
090A4:  ANDWF  xE1,W
090A6:  BCF    xE1.6
090A8:  MOVF   FED,F
090AA:  ANDWF  xE1,W
090AC:  BNZ   90BC
090AE:  BTFSC  xE1.4
090B0:  MOVF   FEE,F
090B2:  BTFSC  xE1.4
090B4:  BRA    90BC
090B6:  MOVLW  20
090B8:  MOVWF  00
090BA:  BRA    90FE
090BC:  ADDWF  FE9,F
090BE:  MOVLW  00
090C0:  ADDWFC FEA,F
090C2:  MOVF   FE9,W
090C4:  SUBLW  E0
090C6:  BNZ   90D0
090C8:  MOVF   FEA,W
090CA:  SUBLW  08
090CC:  BNZ   90D0
090CE:  BSF    xE1.6
090D0:  MOVF   FEF,W
090D2:  MOVWF  00
090D4:  BNZ   90E6
090D6:  BTFSC  xE1.6
090D8:  BRA    90E6
090DA:  BTFSC  xE1.4
090DC:  BRA    9106
090DE:  BTFSC  xE1.3
090E0:  BRA    90E6
090E2:  MOVLW  20
090E4:  BRA    90FC
090E6:  BTFSS  xE1.7
090E8:  BRA    90F6
090EA:  MOVLW  2D
090EC:  MOVWF  00
090EE:  MOVF   FED,W
090F0:  BCF    xE1.6
090F2:  BCF    xE1.7
090F4:  BRA    90FE
090F6:  BSF    xE1.3
090F8:  BCF    xE1.4
090FA:  MOVLW  30
090FC:  ADDWF  00,F
090FE:  MOVF   00,W
09100:  BTFSS  F9E.4
09102:  BRA    9100
09104:  MOVWF  FAD
09106:  MOVF   FEE,W
09108:  BTFSS  xE1.6
0910A:  BRA    90C2
0910C:  MOVLB  0
0910E:  RETURN 0
*
095A4:  MOVF   FE9,W
095A6:  MOVLB  8
095A8:  MOVWF  xE0
095AA:  BTFSS  xDF.7
095AC:  BRA    95C8
095AE:  DECF   xE0,F
095B0:  BSF    xE0.5
095B2:  COMF   xDC,F
095B4:  COMF   xDD,F
095B6:  COMF   xDE,F
095B8:  COMF   xDF,F
095BA:  INCF   xDC,F
095BC:  BTFSC  FD8.2
095BE:  INCF   xDD,F
095C0:  BTFSC  FD8.2
095C2:  INCF   xDE,F
095C4:  BTFSC  FD8.2
095C6:  INCF   xDF,F
095C8:  MOVLW  3B
095CA:  MOVWF  xE7
095CC:  MOVLW  9A
095CE:  MOVWF  xE6
095D0:  MOVLW  CA
095D2:  MOVWF  xE5
095D4:  CLRF   xE4
095D6:  MOVLW  0A
095D8:  MOVWF  xE2
095DA:  BSF    FD8.1
095DC:  MOVLW  08
095DE:  MOVWF  FEA
095E0:  MOVLW  DC
095E2:  MOVWF  FE9
095E4:  CLRF   1B
095E6:  BTFSC  FF2.7
095E8:  BSF    1B.7
095EA:  BCF    FF2.7
095EC:  MOVFF  8DF,A34
095F0:  MOVFF  8DE,A33
095F4:  MOVFF  8DD,A32
095F8:  MOVFF  8DC,A31
095FC:  MOVFF  8E7,A38
09600:  MOVFF  8E6,A37
09604:  MOVFF  8E5,A36
09608:  MOVFF  8E4,A35
0960C:  MOVLB  0
0960E:  CALL   1050
09612:  BTFSC  1B.7
09614:  BSF    FF2.7
09616:  MOVF   01,W
09618:  MOVF   00,F
0961A:  BNZ   9642
0961C:  MOVLB  8
0961E:  MOVF   xE2,W
09620:  XORLW  01
09622:  BTFSS  FD8.2
09624:  BRA    962A
09626:  MOVLB  0
09628:  BRA    9642
0962A:  MOVF   xE0,W
0962C:  BZ    9648
0962E:  ANDLW  0F
09630:  SUBWF  xE2,W
09632:  BZ    9636
09634:  BC    9686
09636:  BTFSC  xE0.7
09638:  BRA    9686
0963A:  BTFSC  xE0.6
0963C:  BRA    9648
0963E:  MOVLW  20
09640:  BRA    967C
09642:  MOVLW  20
09644:  MOVLB  8
09646:  ANDWF  xE0,F
09648:  BTFSS  xE0.5
0964A:  BRA    9660
0964C:  BCF    xE0.5
0964E:  MOVFF  00,8E0
09652:  MOVLW  2D
09654:  BTFSS  F9E.4
09656:  BRA    9654
09658:  MOVWF  FAD
0965A:  MOVFF  8E0,00
0965E:  CLRF   xE0
09660:  MOVLW  30
09662:  BTFSS  xE0.5
09664:  BRA    967C
09666:  BCF    xE0.5
09668:  MOVFF  00,8E0
0966C:  MOVLW  2D
0966E:  BTFSS  F9E.4
09670:  BRA    966E
09672:  MOVWF  FAD
09674:  MOVFF  8E0,00
09678:  CLRF   xE0
0967A:  MOVLW  30
0967C:  ADDWF  00,F
0967E:  MOVF   00,W
09680:  BTFSS  F9E.4
09682:  BRA    9680
09684:  MOVWF  FAD
09686:  BCF    FD8.1
09688:  CLRF   1B
0968A:  BTFSC  FF2.7
0968C:  BSF    1B.7
0968E:  BCF    FF2.7
09690:  MOVFF  8E7,A34
09694:  MOVFF  8E6,A33
09698:  MOVFF  8E5,A32
0969C:  MOVFF  8E4,A31
096A0:  MOVLB  A
096A2:  CLRF   x38
096A4:  CLRF   x37
096A6:  CLRF   x36
096A8:  MOVLW  0A
096AA:  MOVWF  x35
096AC:  MOVLB  0
096AE:  CALL   1050
096B2:  BTFSC  1B.7
096B4:  BSF    FF2.7
096B6:  MOVFF  03,8E7
096BA:  MOVFF  02,8E6
096BE:  MOVFF  01,8E5
096C2:  MOVFF  00,8E4
096C6:  MOVLB  8
096C8:  DECFSZ xE2,F
096CA:  BRA    95DA
096CC:  MOVLB  0
096CE:  RETURN 0
*
0A798:  ADDWF  FE8,W
0A79A:  CLRF   FF7
0A79C:  RLCF   FF7,F
0A79E:  ADDLW  B9
0A7A0:  MOVWF  FF6
0A7A2:  MOVLW  A7
0A7A4:  ADDWFC FF7,F
0A7A6:  MOVLW  00
0A7A8:  MOVWF  FF8
0A7AA:  MOVWF  FFB
0A7AC:  TBLRD*-
0A7AE:  MOVF   FF5,W
0A7B0:  MOVWF  FFA
0A7B2:  TBLRD*
0A7B4:  MOVF   FF5,W
0A7B6:  MOVWF  FF9
0A7B8:  DATA F4,A0
0A7BA:  DATA 14,A1
0A7BC:  DATA 3C,A1
0A7BE:  DATA 6C,A1
0A7C0:  DATA 94,A1
*
0AB04:  TBLRD*+
0AB06:  MOVFF  FF6,8D6
0AB0A:  MOVFF  FF7,8D7
0AB0E:  MOVFF  FF8,8D8
0AB12:  MOVFF  FF5,8E9
0AB16:  CALL   50F6
0AB1A:  MOVFF  8D6,FF6
0AB1E:  MOVFF  8D7,FF7
0AB22:  MOVFF  8D8,FF8
0AB26:  MOVLB  8
0AB28:  DECFSZ xD5,F
0AB2A:  BRA    AB2E
0AB2C:  BRA    AB32
0AB2E:  MOVLB  0
0AB30:  BRA    AB04
0AB32:  MOVLB  0
0AB34:  RETURN 0
0AB36:  MOVFF  FEA,8E8
0AB3A:  MOVFF  FE9,8E7
0AB3E:  MOVLB  8
0AB40:  SWAPF  xE1,W
0AB42:  IORLW  F0
0AB44:  MOVWF  xE3
0AB46:  ADDWF  xE3,F
0AB48:  ADDLW  E2
0AB4A:  MOVWF  xE4
0AB4C:  ADDLW  32
0AB4E:  MOVWF  xE6
0AB50:  MOVF   xE1,W
0AB52:  ANDLW  0F
0AB54:  ADDWF  xE4,F
0AB56:  ADDWF  xE4,F
0AB58:  ADDWF  xE6,F
0AB5A:  ADDLW  E9
0AB5C:  MOVWF  xE5
0AB5E:  ADDWF  xE5,F
0AB60:  ADDWF  xE5,F
0AB62:  SWAPF  xE0,W
0AB64:  ANDLW  0F
0AB66:  ADDWF  xE5,F
0AB68:  ADDWF  xE6,F
0AB6A:  RLCF   xE5,F
0AB6C:  RLCF   xE6,F
0AB6E:  COMF   xE6,F
0AB70:  RLCF   xE6,F
0AB72:  MOVF   xE0,W
0AB74:  ANDLW  0F
0AB76:  ADDWF  xE6,F
0AB78:  RLCF   xE3,F
0AB7A:  MOVLW  07
0AB7C:  MOVWF  xE2
0AB7E:  MOVLW  0A
0AB80:  DECF   xE5,F
0AB82:  ADDWF  xE6,F
0AB84:  BNC   AB80
0AB86:  DECF   xE4,F
0AB88:  ADDWF  xE5,F
0AB8A:  BNC   AB86
0AB8C:  DECF   xE3,F
0AB8E:  ADDWF  xE4,F
0AB90:  BNC   AB8C
0AB92:  DECF   xE2,F
0AB94:  ADDWF  xE3,F
0AB96:  BNC   AB92
0AB98:  MOVLW  08
0AB9A:  MOVWF  FEA
0AB9C:  MOVLW  E2
0AB9E:  MOVWF  FE9
0ABA0:  MOVLW  07
0ABA2:  ANDWF  xE7,W
0ABA4:  BCF    xE7.6
0ABA6:  ADDWF  FE9,F
0ABA8:  MOVLW  00
0ABAA:  ADDWFC FEA,F
0ABAC:  MOVF   FE9,W
0ABAE:  SUBLW  E6
0ABB0:  BNZ   ABBA
0ABB2:  MOVF   FEA,W
0ABB4:  SUBLW  08
0ABB6:  BNZ   ABBA
0ABB8:  BSF    xE7.6
0ABBA:  MOVF   FEF,W
0ABBC:  MOVWF  00
0ABBE:  BNZ   ABD0
0ABC0:  BTFSC  xE7.6
0ABC2:  BRA    ABD0
0ABC4:  BTFSC  xE7.4
0ABC6:  BRA    ABF4
0ABC8:  BTFSC  xE7.3
0ABCA:  BRA    ABD0
0ABCC:  MOVLW  20
0ABCE:  BRA    ABD6
0ABD0:  BSF    xE7.3
0ABD2:  BCF    xE7.4
0ABD4:  MOVLW  30
0ABD6:  ADDWF  00,F
0ABD8:  MOVFF  FEA,8E1
0ABDC:  MOVFF  FE9,8E0
0ABE0:  MOVFF  00,8E9
0ABE4:  MOVLB  0
0ABE6:  CALL   50F6
0ABEA:  MOVFF  8E1,FEA
0ABEE:  MOVFF  8E0,FE9
0ABF2:  MOVLB  8
0ABF4:  MOVF   FEE,W
0ABF6:  BTFSS  xE7.6
0ABF8:  BRA    ABAC
0ABFA:  MOVLB  0
0ABFC:  RETURN 0
*
0ADE8:  ADDWF  FE8,W
0ADEA:  CLRF   FF7
0ADEC:  RLCF   FF7,F
0ADEE:  ADDLW  09
0ADF0:  MOVWF  FF6
0ADF2:  MOVLW  AE
0ADF4:  ADDWFC FF7,F
0ADF6:  MOVLW  00
0ADF8:  MOVWF  FF8
0ADFA:  MOVWF  FFB
0ADFC:  TBLRD*-
0ADFE:  MOVF   FF5,W
0AE00:  MOVWF  FFA
0AE02:  TBLRD*
0AE04:  MOVF   FF5,W
0AE06:  MOVWF  FF9
0AE08:  DATA F8,AC
0AE0A:  DATA E4,AD
0AE0C:  DATA E4,AD
0AE0E:  DATA 58,AC
0AE10:  DATA E4,AD
0AE12:  DATA E4,AD
0AE14:  DATA E4,AD
0AE16:  DATA 1C,AC
0AE18:  DATA E4,AD
0AE1A:  DATA E4,AD
0AE1C:  DATA E4,AD
0AE1E:  DATA 6E,AD
0AE20:  DATA 94,AC
0AE22:  DATA E4,AD
0AE24:  DATA 32,AD
0AE26:  DATA AA,AD
*
0AE82:  TBLRD*+
0AE84:  MOVF   FF5,F
0AE86:  BZ    AEAA
0AE88:  MOVFF  FF6,86F
0AE8C:  MOVFF  FF7,870
0AE90:  MOVFF  FF8,871
0AE94:  MOVF   FF5,W
0AE96:  BTFSS  F9E.4
0AE98:  BRA    AE96
0AE9A:  MOVWF  FAD
0AE9C:  MOVFF  86F,FF6
0AEA0:  MOVFF  870,FF7
0AEA4:  MOVFF  871,FF8
0AEA8:  BRA    AE82
0AEAA:  RETURN 0
*
0C036:  MOVLB  8
0C038:  MOVF   xFD,W
0C03A:  BTFSC  FD8.2
0C03C:  BRA    C152
0C03E:  MOVWF  00
0C040:  MOVLB  9
0C042:  MOVF   x01,W
0C044:  BTFSS  FD8.2
0C046:  BRA    C04C
0C048:  MOVLB  8
0C04A:  BRA    C152
0C04C:  ADDWF  00,F
0C04E:  BNC   C05E
0C050:  MOVLW  81
0C052:  ADDWF  00,F
0C054:  BTFSS  FD8.0
0C056:  BRA    C05C
0C058:  MOVLB  8
0C05A:  BRA    C152
0C05C:  BRA    C072
0C05E:  MOVLW  7F
0C060:  SUBWF  00,F
0C062:  BTFSC  FD8.0
0C064:  BRA    C06A
0C066:  MOVLB  8
0C068:  BRA    C152
0C06A:  BTFSS  FD8.2
0C06C:  BRA    C072
0C06E:  MOVLB  8
0C070:  BRA    C152
0C072:  MOVFF  8FE,905
0C076:  MOVF   x02,W
0C078:  XORWF  x05,F
0C07A:  MOVLB  8
0C07C:  BSF    xFE.7
0C07E:  MOVLB  9
0C080:  BSF    x02.7
0C082:  MOVF   x00,W
0C084:  MULWF  x04
0C086:  MOVFF  FF4,907
0C08A:  MOVLB  8
0C08C:  MOVF   xFF,W
0C08E:  MOVLB  9
0C090:  MULWF  x03
0C092:  MOVFF  FF4,03
0C096:  MOVFF  FF3,906
0C09A:  MULWF  x04
0C09C:  MOVF   FF3,W
0C09E:  ADDWF  x07,F
0C0A0:  MOVF   FF4,W
0C0A2:  ADDWFC x06,F
0C0A4:  MOVLW  00
0C0A6:  ADDWFC 03,F
0C0A8:  MOVF   x00,W
0C0AA:  MULWF  x03
0C0AC:  MOVF   FF3,W
0C0AE:  ADDWF  x07,F
0C0B0:  MOVF   FF4,W
0C0B2:  ADDWFC x06,F
0C0B4:  MOVLW  00
0C0B6:  CLRF   02
0C0B8:  ADDWFC 03,F
0C0BA:  ADDWFC 02,F
0C0BC:  MOVLB  8
0C0BE:  MOVF   xFE,W
0C0C0:  MOVLB  9
0C0C2:  MULWF  x04
0C0C4:  MOVF   FF3,W
0C0C6:  ADDWF  x06,F
0C0C8:  MOVF   FF4,W
0C0CA:  ADDWFC 03,F
0C0CC:  MOVLW  00
0C0CE:  ADDWFC 02,F
0C0D0:  MOVLB  8
0C0D2:  MOVF   xFE,W
0C0D4:  MOVLB  9
0C0D6:  MULWF  x03
0C0D8:  MOVF   FF3,W
0C0DA:  ADDWF  03,F
0C0DC:  MOVF   FF4,W
0C0DE:  ADDWFC 02,F
0C0E0:  MOVLW  00
0C0E2:  CLRF   01
0C0E4:  ADDWFC 01,F
0C0E6:  MOVF   x00,W
0C0E8:  MULWF  x02
0C0EA:  MOVF   FF3,W
0C0EC:  ADDWF  x06,F
0C0EE:  MOVF   FF4,W
0C0F0:  ADDWFC 03,F
0C0F2:  MOVLW  00
0C0F4:  ADDWFC 02,F
0C0F6:  ADDWFC 01,F
0C0F8:  MOVLB  8
0C0FA:  MOVF   xFF,W
0C0FC:  MOVLB  9
0C0FE:  MULWF  x02
0C100:  MOVF   FF3,W
0C102:  ADDWF  03,F
0C104:  MOVF   FF4,W
0C106:  ADDWFC 02,F
0C108:  MOVLW  00
0C10A:  ADDWFC 01,F
0C10C:  MOVLB  8
0C10E:  MOVF   xFE,W
0C110:  MOVLB  9
0C112:  MULWF  x02
0C114:  MOVF   FF3,W
0C116:  ADDWF  02,F
0C118:  MOVF   FF4,W
0C11A:  ADDWFC 01,F
0C11C:  INCF   00,F
0C11E:  BTFSC  01.7
0C120:  BRA    C12C
0C122:  RLCF   x06,F
0C124:  RLCF   03,F
0C126:  RLCF   02,F
0C128:  RLCF   01,F
0C12A:  DECF   00,F
0C12C:  MOVLW  00
0C12E:  BTFSS  x06.7
0C130:  BRA    C146
0C132:  INCF   03,F
0C134:  ADDWFC 02,F
0C136:  ADDWFC 01,F
0C138:  MOVF   01,W
0C13A:  BNZ   C146
0C13C:  MOVF   02,W
0C13E:  BNZ   C146
0C140:  MOVF   03,W
0C142:  BNZ   C146
0C144:  INCF   00,F
0C146:  BTFSC  x05.7
0C148:  BSF    01.7
0C14A:  BTFSS  x05.7
0C14C:  BCF    01.7
0C14E:  BRA    C15C
0C150:  MOVLB  8
0C152:  CLRF   00
0C154:  CLRF   01
0C156:  CLRF   02
0C158:  CLRF   03
0C15A:  MOVLB  9
0C15C:  MOVLB  0
0C15E:  RETURN 0
0C160:  MOVLW  80
0C162:  BTFSS  FD8.1
0C164:  BRA    C16A
0C166:  MOVLB  9
0C168:  XORWF  x06,F
0C16A:  MOVLB  9
0C16C:  CLRF   x0B
0C16E:  CLRF   x0C
0C170:  MOVFF  902,90A
0C174:  MOVF   x06,W
0C176:  XORWF  x0A,F
0C178:  MOVF   x01,W
0C17A:  BTFSC  FD8.2
0C17C:  BRA    C33C
0C17E:  MOVWF  x09
0C180:  MOVWF  00
0C182:  MOVF   x05,W
0C184:  BTFSC  FD8.2
0C186:  BRA    C34E
0C188:  SUBWF  x09,F
0C18A:  BTFSC  FD8.2
0C18C:  BRA    C294
0C18E:  BNC   C20C
0C190:  MOVFF  906,90F
0C194:  BSF    x0F.7
0C196:  MOVFF  907,90E
0C19A:  MOVFF  908,90D
0C19E:  CLRF   x0C
0C1A0:  BCF    FD8.0
0C1A2:  RRCF   x0F,F
0C1A4:  RRCF   x0E,F
0C1A6:  RRCF   x0D,F
0C1A8:  RRCF   x0C,F
0C1AA:  DECFSZ x09,F
0C1AC:  BRA    C19E
0C1AE:  BTFSS  x0A.7
0C1B0:  BRA    C1B8
0C1B2:  BSF    x0B.0
0C1B4:  BRA    C376
0C1B6:  BCF    x0B.0
0C1B8:  BCF    x09.0
0C1BA:  BSF    x0B.4
0C1BC:  MOVLW  09
0C1BE:  MOVWF  FEA
0C1C0:  MOVLW  04
0C1C2:  MOVWF  FE9
0C1C4:  BRA    C39C
0C1C6:  BCF    x0B.4
0C1C8:  BTFSC  x0A.7
0C1CA:  BRA    C1E0
0C1CC:  BTFSS  x09.0
0C1CE:  BRA    C1F6
0C1D0:  RRCF   x0F,F
0C1D2:  RRCF   x0E,F
0C1D4:  RRCF   x0D,F
0C1D6:  RRCF   x0C,F
0C1D8:  INCF   00,F
0C1DA:  BTFSC  FD8.2
0C1DC:  BRA    C36C
0C1DE:  BRA    C1F6
0C1E0:  BTFSC  x0F.7
0C1E2:  BRA    C1FC
0C1E4:  BCF    FD8.0
0C1E6:  RLCF   x0C,F
0C1E8:  RLCF   x0D,F
0C1EA:  RLCF   x0E,F
0C1EC:  RLCF   x0F,F
0C1EE:  DECF   00,F
0C1F0:  BTFSC  FD8.2
0C1F2:  BRA    C36C
0C1F4:  BRA    C1E0
0C1F6:  BSF    x0B.6
0C1F8:  BRA    C2D4
0C1FA:  BCF    x0B.6
0C1FC:  MOVFF  902,90A
0C200:  BTFSS  x02.7
0C202:  BRA    C208
0C204:  BSF    x0F.7
0C206:  BRA    C35E
0C208:  BCF    x0F.7
0C20A:  BRA    C35E
0C20C:  MOVFF  905,909
0C210:  MOVFF  905,00
0C214:  MOVF   x01,W
0C216:  SUBWF  x09,F
0C218:  MOVFF  902,90F
0C21C:  BSF    x0F.7
0C21E:  MOVFF  903,90E
0C222:  MOVFF  904,90D
0C226:  CLRF   x0C
0C228:  BCF    FD8.0
0C22A:  RRCF   x0F,F
0C22C:  RRCF   x0E,F
0C22E:  RRCF   x0D,F
0C230:  RRCF   x0C,F
0C232:  DECFSZ x09,F
0C234:  BRA    C226
0C236:  BTFSS  x0A.7
0C238:  BRA    C240
0C23A:  BSF    x0B.1
0C23C:  BRA    C376
0C23E:  BCF    x0B.1
0C240:  BCF    x09.0
0C242:  BSF    x0B.5
0C244:  MOVLW  09
0C246:  MOVWF  FEA
0C248:  MOVLW  08
0C24A:  MOVWF  FE9
0C24C:  BRA    C39C
0C24E:  BCF    x0B.5
0C250:  BTFSC  x0A.7
0C252:  BRA    C268
0C254:  BTFSS  x09.0
0C256:  BRA    C27E
0C258:  RRCF   x0F,F
0C25A:  RRCF   x0E,F
0C25C:  RRCF   x0D,F
0C25E:  RRCF   x0C,F
0C260:  INCF   00,F
0C262:  BTFSC  FD8.2
0C264:  BRA    C36C
0C266:  BRA    C27E
0C268:  BTFSC  x0F.7
0C26A:  BRA    C284
0C26C:  BCF    FD8.0
0C26E:  RLCF   x0C,F
0C270:  RLCF   x0D,F
0C272:  RLCF   x0E,F
0C274:  RLCF   x0F,F
0C276:  DECF   00,F
0C278:  BTFSC  FD8.2
0C27A:  BRA    C36C
0C27C:  BRA    C268
0C27E:  BSF    x0B.7
0C280:  BRA    C2D4
0C282:  BCF    x0B.7
0C284:  MOVFF  906,90A
0C288:  BTFSS  x06.7
0C28A:  BRA    C290
0C28C:  BSF    x0F.7
0C28E:  BRA    C35E
0C290:  BCF    x0F.7
0C292:  BRA    C35E
0C294:  MOVFF  906,90F
0C298:  BSF    x0F.7
0C29A:  MOVFF  907,90E
0C29E:  MOVFF  908,90D
0C2A2:  BTFSS  x0A.7
0C2A4:  BRA    C2AE
0C2A6:  BCF    x0F.7
0C2A8:  BSF    x0B.2
0C2AA:  BRA    C376
0C2AC:  BCF    x0B.2
0C2AE:  CLRF   x0C
0C2B0:  BCF    x09.0
0C2B2:  MOVLW  09
0C2B4:  MOVWF  FEA
0C2B6:  MOVLW  04
0C2B8:  MOVWF  FE9
0C2BA:  BRA    C39C
0C2BC:  BTFSC  x0A.7
0C2BE:  BRA    C2F8
0C2C0:  MOVFF  902,90A
0C2C4:  BTFSS  x09.0
0C2C6:  BRA    C2D4
0C2C8:  RRCF   x0F,F
0C2CA:  RRCF   x0E,F
0C2CC:  RRCF   x0D,F
0C2CE:  RRCF   x0C,F
0C2D0:  INCF   00,F
0C2D2:  BZ    C36C
0C2D4:  BTFSS  x0C.7
0C2D6:  BRA    C2EE
0C2D8:  INCF   x0D,F
0C2DA:  BNZ   C2EE
0C2DC:  INCF   x0E,F
0C2DE:  BNZ   C2EE
0C2E0:  INCF   x0F,F
0C2E2:  BNZ   C2EE
0C2E4:  RRCF   x0F,F
0C2E6:  RRCF   x0E,F
0C2E8:  RRCF   x0D,F
0C2EA:  INCF   00,F
0C2EC:  BZ    C36C
0C2EE:  BTFSC  x0B.6
0C2F0:  BRA    C1FA
0C2F2:  BTFSC  x0B.7
0C2F4:  BRA    C282
0C2F6:  BRA    C330
0C2F8:  MOVLW  80
0C2FA:  XORWF  x0F,F
0C2FC:  BTFSS  x0F.7
0C2FE:  BRA    C308
0C300:  BRA    C376
0C302:  MOVFF  906,90A
0C306:  BRA    C31C
0C308:  MOVFF  902,90A
0C30C:  MOVF   x0F,F
0C30E:  BNZ   C31C
0C310:  MOVF   x0E,F
0C312:  BNZ   C31C
0C314:  MOVF   x0D,F
0C316:  BNZ   C31C
0C318:  CLRF   00
0C31A:  BRA    C35E
0C31C:  BTFSC  x0F.7
0C31E:  BRA    C330
0C320:  BCF    FD8.0
0C322:  RLCF   x0C,F
0C324:  RLCF   x0D,F
0C326:  RLCF   x0E,F
0C328:  RLCF   x0F,F
0C32A:  DECFSZ 00,F
0C32C:  BRA    C31C
0C32E:  BRA    C36C
0C330:  BTFSS  x0A.7
0C332:  BRA    C338
0C334:  BSF    x0F.7
0C336:  BRA    C35E
0C338:  BCF    x0F.7
0C33A:  BRA    C35E
0C33C:  MOVFF  905,00
0C340:  MOVFF  906,90F
0C344:  MOVFF  907,90E
0C348:  MOVFF  908,90D
0C34C:  BRA    C35E
0C34E:  MOVFF  901,00
0C352:  MOVFF  902,90F
0C356:  MOVFF  903,90E
0C35A:  MOVFF  904,90D
0C35E:  MOVFF  90F,01
0C362:  MOVFF  90E,02
0C366:  MOVFF  90D,03
0C36A:  BRA    C3D4
0C36C:  CLRF   00
0C36E:  CLRF   01
0C370:  CLRF   02
0C372:  CLRF   03
0C374:  BRA    C3D4
0C376:  CLRF   x0C
0C378:  COMF   x0D,F
0C37A:  COMF   x0E,F
0C37C:  COMF   x0F,F
0C37E:  COMF   x0C,F
0C380:  INCF   x0C,F
0C382:  BNZ   C38E
0C384:  INCF   x0D,F
0C386:  BNZ   C38E
0C388:  INCF   x0E,F
0C38A:  BNZ   C38E
0C38C:  INCF   x0F,F
0C38E:  BTFSC  x0B.0
0C390:  BRA    C1B6
0C392:  BTFSC  x0B.1
0C394:  BRA    C23E
0C396:  BTFSC  x0B.2
0C398:  BRA    C2AC
0C39A:  BRA    C302
0C39C:  MOVF   FEF,W
0C39E:  ADDWF  x0D,F
0C3A0:  BNC   C3AC
0C3A2:  INCF   x0E,F
0C3A4:  BNZ   C3AC
0C3A6:  INCF   x0F,F
0C3A8:  BTFSC  FD8.2
0C3AA:  BSF    x09.0
0C3AC:  MOVF   FED,F
0C3AE:  MOVF   FEF,W
0C3B0:  ADDWF  x0E,F
0C3B2:  BNC   C3BA
0C3B4:  INCF   x0F,F
0C3B6:  BTFSC  FD8.2
0C3B8:  BSF    x09.0
0C3BA:  MOVF   FED,F
0C3BC:  MOVF   FEF,W
0C3BE:  BTFSC  FEF.7
0C3C0:  BRA    C3C4
0C3C2:  XORLW  80
0C3C4:  ADDWF  x0F,F
0C3C6:  BTFSC  FD8.0
0C3C8:  BSF    x09.0
0C3CA:  BTFSC  x0B.4
0C3CC:  BRA    C1C6
0C3CE:  BTFSC  x0B.5
0C3D0:  BRA    C24E
0C3D2:  BRA    C2BC
0C3D4:  MOVLB  0
0C3D6:  RETURN 0
0C3D8:  MOVLB  8
0C3DA:  MOVF   xC6,W
0C3DC:  SUBLW  B6
0C3DE:  MOVWF  xC6
0C3E0:  CLRF   03
0C3E2:  MOVFF  8C7,8CA
0C3E6:  BSF    xC7.7
0C3E8:  BCF    FD8.0
0C3EA:  RRCF   xC7,F
0C3EC:  RRCF   xC8,F
0C3EE:  RRCF   xC9,F
0C3F0:  RRCF   03,F
0C3F2:  RRCF   02,F
0C3F4:  RRCF   01,F
0C3F6:  RRCF   00,F
0C3F8:  DECFSZ xC6,F
0C3FA:  BRA    C3E8
0C3FC:  BTFSS  xCA.7
0C3FE:  BRA    C416
0C400:  COMF   00,F
0C402:  COMF   01,F
0C404:  COMF   02,F
0C406:  COMF   03,F
0C408:  INCF   00,F
0C40A:  BTFSC  FD8.2
0C40C:  INCF   01,F
0C40E:  BTFSC  FD8.2
0C410:  INCF   02,F
0C412:  BTFSC  FD8.2
0C414:  INCF   03,F
0C416:  MOVLB  0
0C418:  RETURN 0
0C41A:  MOVF   FE9,W
0C41C:  MOVLB  8
0C41E:  MOVWF  x74
0C420:  MOVF   x73,W
0C422:  MOVWF  x76
0C424:  BZ    C45E
0C426:  MOVFF  872,900
0C42A:  MOVFF  871,8FF
0C42E:  MOVFF  870,8FE
0C432:  MOVFF  86F,8FD
0C436:  MOVLB  9
0C438:  CLRF   x04
0C43A:  CLRF   x03
0C43C:  MOVLW  20
0C43E:  MOVWF  x02
0C440:  MOVLW  82
0C442:  MOVWF  x01
0C444:  MOVLB  0
0C446:  RCALL  C036
0C448:  MOVFF  03,872
0C44C:  MOVFF  02,871
0C450:  MOVFF  01,870
0C454:  MOVFF  00,86F
0C458:  MOVLB  8
0C45A:  DECFSZ x76,F
0C45C:  BRA    C426
0C45E:  MOVLW  7E
0C460:  MOVWF  00
0C462:  CLRF   01
0C464:  BTFSC  x70.7
0C466:  BSF    01.7
0C468:  CLRF   02
0C46A:  CLRF   03
0C46C:  BCF    FD8.1
0C46E:  MOVFF  872,904
0C472:  MOVFF  871,903
0C476:  MOVFF  870,902
0C47A:  MOVFF  86F,901
0C47E:  MOVFF  03,908
0C482:  MOVFF  02,907
0C486:  MOVFF  01,906
0C48A:  MOVFF  FE8,905
0C48E:  MOVLB  0
0C490:  RCALL  C160
0C492:  MOVFF  03,872
0C496:  MOVFF  02,871
0C49A:  MOVFF  01,870
0C49E:  MOVFF  00,86F
0C4A2:  MOVFF  872,8C9
0C4A6:  MOVFF  871,8C8
0C4AA:  MOVFF  870,8C7
0C4AE:  MOVFF  86F,8C6
0C4B2:  RCALL  C3D8
0C4B4:  MOVFF  03,872
0C4B8:  MOVFF  02,871
0C4BC:  MOVFF  01,870
0C4C0:  MOVFF  00,86F
0C4C4:  MOVLB  8
0C4C6:  BTFSS  x72.7
0C4C8:  BRA    C4E4
0C4CA:  DECF   x74,F
0C4CC:  BSF    x74.5
0C4CE:  COMF   x6F,F
0C4D0:  COMF   x70,F
0C4D2:  COMF   x71,F
0C4D4:  COMF   x72,F
0C4D6:  INCF   x6F,F
0C4D8:  BTFSC  FD8.2
0C4DA:  INCF   x70,F
0C4DC:  BTFSC  FD8.2
0C4DE:  INCF   x71,F
0C4E0:  BTFSC  FD8.2
0C4E2:  INCF   x72,F
0C4E4:  MOVLW  3B
0C4E6:  MOVWF  x7B
0C4E8:  MOVLW  9A
0C4EA:  MOVWF  x7A
0C4EC:  MOVLW  CA
0C4EE:  MOVWF  x79
0C4F0:  CLRF   x78
0C4F2:  MOVLW  0A
0C4F4:  MOVWF  x76
0C4F6:  MOVF   x73,W
0C4F8:  BTFSC  FD8.2
0C4FA:  INCF   x74,F
0C4FC:  BSF    FD8.1
0C4FE:  MOVLW  08
0C500:  MOVWF  FEA
0C502:  MOVLW  6F
0C504:  MOVWF  FE9
0C506:  CLRF   1B
0C508:  BTFSC  FF2.7
0C50A:  BSF    1B.7
0C50C:  BCF    FF2.7
0C50E:  MOVFF  872,A34
0C512:  MOVFF  871,A33
0C516:  MOVFF  870,A32
0C51A:  MOVFF  86F,A31
0C51E:  MOVFF  87B,A38
0C522:  MOVFF  87A,A37
0C526:  MOVFF  879,A36
0C52A:  MOVFF  878,A35
0C52E:  MOVLB  0
0C530:  CALL   1050
0C534:  BTFSC  1B.7
0C536:  BSF    FF2.7
0C538:  MOVF   01,W
0C53A:  MOVF   00,F
0C53C:  BNZ   C564
0C53E:  MOVLB  8
0C540:  INCF   x73,W
0C542:  SUBWF  x76,W
0C544:  BTFSS  FD8.2
0C546:  BRA    C54C
0C548:  MOVLB  0
0C54A:  BRA    C564
0C54C:  MOVF   x74,W
0C54E:  BZ    C56A
0C550:  ANDLW  0F
0C552:  SUBWF  x76,W
0C554:  BZ    C558
0C556:  BC    C5D0
0C558:  BTFSC  x74.7
0C55A:  BRA    C5D0
0C55C:  BTFSC  x74.6
0C55E:  BRA    C56A
0C560:  MOVLW  20
0C562:  BRA    C5C6
0C564:  MOVLW  20
0C566:  MOVLB  8
0C568:  ANDWF  x74,F
0C56A:  BTFSS  x74.5
0C56C:  BRA    C588
0C56E:  BCF    x74.5
0C570:  MOVF   x73,W
0C572:  BTFSS  FD8.2
0C574:  DECF   x74,F
0C576:  MOVF   00,W
0C578:  MOVWF  x74
0C57A:  MOVLW  2D
0C57C:  BTFSS  F9E.4
0C57E:  BRA    C57C
0C580:  MOVWF  FAD
0C582:  MOVF   x74,W
0C584:  MOVWF  00
0C586:  CLRF   x74
0C588:  MOVF   x73,W
0C58A:  SUBWF  x76,W
0C58C:  BNZ   C5A4
0C58E:  MOVF   00,W
0C590:  MOVWF  x74
0C592:  MOVLW  2E
0C594:  BTFSS  F9E.4
0C596:  BRA    C594
0C598:  MOVWF  FAD
0C59A:  MOVF   x74,W
0C59C:  MOVWF  00
0C59E:  MOVLW  20
0C5A0:  ANDWF  x74,F
0C5A2:  MOVLW  00
0C5A4:  MOVLW  30
0C5A6:  BTFSS  x74.5
0C5A8:  BRA    C5C6
0C5AA:  BCF    x74.5
0C5AC:  MOVF   x73,W
0C5AE:  BTFSS  FD8.2
0C5B0:  DECF   x74,F
0C5B2:  MOVF   00,W
0C5B4:  MOVWF  x74
0C5B6:  MOVLW  2D
0C5B8:  BTFSS  F9E.4
0C5BA:  BRA    C5B8
0C5BC:  MOVWF  FAD
0C5BE:  MOVF   x74,W
0C5C0:  MOVWF  00
0C5C2:  CLRF   x74
0C5C4:  MOVLW  30
0C5C6:  ADDWF  00,F
0C5C8:  MOVF   00,W
0C5CA:  BTFSS  F9E.4
0C5CC:  BRA    C5CA
0C5CE:  MOVWF  FAD
0C5D0:  BCF    FD8.1
0C5D2:  CLRF   1B
0C5D4:  BTFSC  FF2.7
0C5D6:  BSF    1B.7
0C5D8:  BCF    FF2.7
0C5DA:  MOVFF  87B,A34
0C5DE:  MOVFF  87A,A33
0C5E2:  MOVFF  879,A32
0C5E6:  MOVFF  878,A31
0C5EA:  MOVLB  A
0C5EC:  CLRF   x38
0C5EE:  CLRF   x37
0C5F0:  CLRF   x36
0C5F2:  MOVLW  0A
0C5F4:  MOVWF  x35
0C5F6:  MOVLB  0
0C5F8:  CALL   1050
0C5FC:  BTFSC  1B.7
0C5FE:  BSF    FF2.7
0C600:  MOVFF  03,87B
0C604:  MOVFF  02,87A
0C608:  MOVFF  01,879
0C60C:  MOVFF  00,878
0C610:  MOVLB  8
0C612:  DECFSZ x76,F
0C614:  BRA    C4FC
0C616:  MOVLB  0
0C618:  RETURN 0
*
0C69C:  MOVLW  8E
0C69E:  MOVWF  00
0C6A0:  MOVFF  902,01
0C6A4:  MOVFF  901,02
0C6A8:  CLRF   03
0C6AA:  MOVF   01,F
0C6AC:  BNZ   C6C0
0C6AE:  MOVFF  02,01
0C6B2:  CLRF   02
0C6B4:  MOVLW  08
0C6B6:  SUBWF  00,F
0C6B8:  MOVF   01,F
0C6BA:  BNZ   C6C0
0C6BC:  CLRF   00
0C6BE:  BRA    C6D0
0C6C0:  BCF    FD8.0
0C6C2:  BTFSC  01.7
0C6C4:  BRA    C6CE
0C6C6:  RLCF   02,F
0C6C8:  RLCF   01,F
0C6CA:  DECF   00,F
0C6CC:  BRA    C6C0
0C6CE:  BCF    01.7
0C6D0:  RETURN 0
0C6D2:  MOVLB  8
0C6D4:  MOVF   xE5,W
0C6D6:  BTFSC  FD8.2
0C6D8:  BRA    C824
0C6DA:  MOVWF  xF1
0C6DC:  MOVF   xE9,W
0C6DE:  BTFSC  FD8.2
0C6E0:  BRA    C824
0C6E2:  SUBWF  xF1,F
0C6E4:  BNC   C6F0
0C6E6:  MOVLW  7F
0C6E8:  ADDWF  xF1,F
0C6EA:  BTFSC  FD8.0
0C6EC:  BRA    C824
0C6EE:  BRA    C6FC
0C6F0:  MOVLW  81
0C6F2:  SUBWF  xF1,F
0C6F4:  BTFSS  FD8.0
0C6F6:  BRA    C824
0C6F8:  BTFSC  FD8.2
0C6FA:  BRA    C824
0C6FC:  MOVFF  8F1,00
0C700:  CLRF   01
0C702:  CLRF   02
0C704:  CLRF   03
0C706:  CLRF   xF0
0C708:  MOVFF  8E6,8EF
0C70C:  BSF    xEF.7
0C70E:  MOVFF  8E7,8EE
0C712:  MOVFF  8E8,8ED
0C716:  MOVLW  19
0C718:  MOVWF  xF1
0C71A:  MOVF   xEC,W
0C71C:  SUBWF  xED,F
0C71E:  BC    C73A
0C720:  MOVLW  01
0C722:  SUBWF  xEE,F
0C724:  BC    C73A
0C726:  SUBWF  xEF,F
0C728:  BC    C73A
0C72A:  SUBWF  xF0,F
0C72C:  BC    C73A
0C72E:  INCF   xF0,F
0C730:  INCF   xEF,F
0C732:  INCF   xEE,F
0C734:  MOVF   xEC,W
0C736:  ADDWF  xED,F
0C738:  BRA    C78A
0C73A:  MOVF   xEB,W
0C73C:  SUBWF  xEE,F
0C73E:  BC    C764
0C740:  MOVLW  01
0C742:  SUBWF  xEF,F
0C744:  BC    C764
0C746:  SUBWF  xF0,F
0C748:  BC    C764
0C74A:  INCF   xF0,F
0C74C:  INCF   xEF,F
0C74E:  MOVF   xEB,W
0C750:  ADDWF  xEE,F
0C752:  MOVF   xEC,W
0C754:  ADDWF  xED,F
0C756:  BNC   C78A
0C758:  INCF   xEE,F
0C75A:  BNZ   C78A
0C75C:  INCF   xEF,F
0C75E:  BNZ   C78A
0C760:  INCF   xF0,F
0C762:  BRA    C78A
0C764:  MOVF   xEA,W
0C766:  IORLW  80
0C768:  SUBWF  xEF,F
0C76A:  BC    C788
0C76C:  MOVLW  01
0C76E:  SUBWF  xF0,F
0C770:  BC    C788
0C772:  INCF   xF0,F
0C774:  MOVF   xEA,W
0C776:  IORLW  80
0C778:  ADDWF  xEF,F
0C77A:  MOVF   xEB,W
0C77C:  ADDWF  xEE,F
0C77E:  BNC   C752
0C780:  INCF   xEF,F
0C782:  BNZ   C752
0C784:  INCF   xF0,F
0C786:  BRA    C752
0C788:  BSF    03.0
0C78A:  DECFSZ xF1,F
0C78C:  BRA    C790
0C78E:  BRA    C7A6
0C790:  BCF    FD8.0
0C792:  RLCF   xED,F
0C794:  RLCF   xEE,F
0C796:  RLCF   xEF,F
0C798:  RLCF   xF0,F
0C79A:  BCF    FD8.0
0C79C:  RLCF   03,F
0C79E:  RLCF   02,F
0C7A0:  RLCF   01,F
0C7A2:  RLCF   xF2,F
0C7A4:  BRA    C71A
0C7A6:  BTFSS  xF2.0
0C7A8:  BRA    C7B6
0C7AA:  BCF    FD8.0
0C7AC:  RRCF   01,F
0C7AE:  RRCF   02,F
0C7B0:  RRCF   03,F
0C7B2:  RRCF   xF2,F
0C7B4:  BRA    C7BA
0C7B6:  DECF   00,F
0C7B8:  BZ    C824
0C7BA:  BTFSC  xF2.7
0C7BC:  BRA    C7FA
0C7BE:  BCF    FD8.0
0C7C0:  RLCF   xED,F
0C7C2:  RLCF   xEE,F
0C7C4:  RLCF   xEF,F
0C7C6:  RLCF   xF0,F
0C7C8:  MOVF   xEC,W
0C7CA:  SUBWF  xED,F
0C7CC:  BC    C7DC
0C7CE:  MOVLW  01
0C7D0:  SUBWF  xEE,F
0C7D2:  BC    C7DC
0C7D4:  SUBWF  xEF,F
0C7D6:  BC    C7DC
0C7D8:  SUBWF  xF0,F
0C7DA:  BNC   C810
0C7DC:  MOVF   xEB,W
0C7DE:  SUBWF  xEE,F
0C7E0:  BC    C7EC
0C7E2:  MOVLW  01
0C7E4:  SUBWF  xEF,F
0C7E6:  BC    C7EC
0C7E8:  SUBWF  xF0,F
0C7EA:  BNC   C810
0C7EC:  MOVF   xEA,W
0C7EE:  IORLW  80
0C7F0:  SUBWF  xEF,F
0C7F2:  BC    C7FA
0C7F4:  MOVLW  01
0C7F6:  SUBWF  xF0,F
0C7F8:  BNC   C810
0C7FA:  INCF   03,F
0C7FC:  BNZ   C810
0C7FE:  INCF   02,F
0C800:  BNZ   C810
0C802:  INCF   01,F
0C804:  BNZ   C810
0C806:  INCF   00,F
0C808:  BZ    C824
0C80A:  RRCF   01,F
0C80C:  RRCF   02,F
0C80E:  RRCF   03,F
0C810:  MOVFF  8E6,8F1
0C814:  MOVF   xEA,W
0C816:  XORWF  xF1,F
0C818:  BTFSS  xF1.7
0C81A:  BRA    C820
0C81C:  BSF    01.7
0C81E:  BRA    C82C
0C820:  BCF    01.7
0C822:  BRA    C82C
0C824:  CLRF   00
0C826:  CLRF   01
0C828:  CLRF   02
0C82A:  CLRF   03
0C82C:  MOVLB  0
0C82E:  RETURN 0
*
0D2C2:  MOVFF  FEA,8B3
0D2C6:  MOVFF  FE9,8B2
0D2CA:  MOVLB  8
0D2CC:  BTFSS  xAC.7
0D2CE:  BRA    D2E0
0D2D0:  BSF    xB2.7
0D2D2:  BTFSS  xB2.4
0D2D4:  INCF   xB2,F
0D2D6:  COMF   xAB,F
0D2D8:  COMF   xAC,F
0D2DA:  INCF   xAB,F
0D2DC:  BTFSC  FD8.2
0D2DE:  INCF   xAC,F
0D2E0:  SWAPF  xAC,W
0D2E2:  IORLW  F0
0D2E4:  MOVWF  xAE
0D2E6:  ADDWF  xAE,F
0D2E8:  ADDLW  E2
0D2EA:  MOVWF  xAF
0D2EC:  ADDLW  32
0D2EE:  MOVWF  xB1
0D2F0:  MOVF   xAC,W
0D2F2:  ANDLW  0F
0D2F4:  ADDWF  xAF,F
0D2F6:  ADDWF  xAF,F
0D2F8:  ADDWF  xB1,F
0D2FA:  ADDLW  E9
0D2FC:  MOVWF  xB0
0D2FE:  ADDWF  xB0,F
0D300:  ADDWF  xB0,F
0D302:  SWAPF  xAB,W
0D304:  ANDLW  0F
0D306:  ADDWF  xB0,F
0D308:  ADDWF  xB1,F
0D30A:  RLCF   xB0,F
0D30C:  RLCF   xB1,F
0D30E:  COMF   xB1,F
0D310:  RLCF   xB1,F
0D312:  MOVF   xAB,W
0D314:  ANDLW  0F
0D316:  ADDWF  xB1,F
0D318:  RLCF   xAE,F
0D31A:  MOVLW  07
0D31C:  MOVWF  xAD
0D31E:  MOVLW  0A
0D320:  DECF   xB0,F
0D322:  ADDWF  xB1,F
0D324:  BNC   D320
0D326:  DECF   xAF,F
0D328:  ADDWF  xB0,F
0D32A:  BNC   D326
0D32C:  DECF   xAE,F
0D32E:  ADDWF  xAF,F
0D330:  BNC   D32C
0D332:  DECF   xAD,F
0D334:  ADDWF  xAE,F
0D336:  BNC   D332
0D338:  MOVLW  08
0D33A:  MOVWF  FEA
0D33C:  MOVLW  AD
0D33E:  MOVWF  FE9
0D340:  MOVLW  07
0D342:  ANDWF  xB2,W
0D344:  BCF    xB2.6
0D346:  MOVF   FED,F
0D348:  ANDWF  xB2,W
0D34A:  BNZ   D35A
0D34C:  BTFSC  xB2.4
0D34E:  MOVF   FEE,F
0D350:  BTFSC  xB2.4
0D352:  BRA    D35A
0D354:  MOVLW  20
0D356:  MOVWF  00
0D358:  BRA    D39C
0D35A:  ADDWF  FE9,F
0D35C:  MOVLW  00
0D35E:  ADDWFC FEA,F
0D360:  MOVF   FE9,W
0D362:  SUBLW  B1
0D364:  BNZ   D36E
0D366:  MOVF   FEA,W
0D368:  SUBLW  08
0D36A:  BNZ   D36E
0D36C:  BSF    xB2.6
0D36E:  MOVF   FEF,W
0D370:  MOVWF  00
0D372:  BNZ   D384
0D374:  BTFSC  xB2.6
0D376:  BRA    D384
0D378:  BTFSC  xB2.4
0D37A:  BRA    D3B8
0D37C:  BTFSC  xB2.3
0D37E:  BRA    D384
0D380:  MOVLW  20
0D382:  BRA    D39A
0D384:  BTFSS  xB2.7
0D386:  BRA    D394
0D388:  MOVLW  2D
0D38A:  MOVWF  00
0D38C:  MOVF   FED,W
0D38E:  BCF    xB2.6
0D390:  BCF    xB2.7
0D392:  BRA    D39C
0D394:  BSF    xB2.3
0D396:  BCF    xB2.4
0D398:  MOVLW  30
0D39A:  ADDWF  00,F
0D39C:  MOVFF  FEA,8AC
0D3A0:  MOVFF  FE9,8AB
0D3A4:  MOVFF  00,8E9
0D3A8:  MOVLB  0
0D3AA:  CALL   50F6
0D3AE:  MOVFF  8AC,FEA
0D3B2:  MOVFF  8AB,FE9
0D3B6:  MOVLB  8
0D3B8:  MOVF   FEE,W
0D3BA:  BTFSS  xB2.6
0D3BC:  BRA    D360
0D3BE:  MOVLB  0
0D3C0:  GOTO   D4E4 (RETURN)
*
0D768:  ADDWF  FE8,W
0D76A:  CLRF   FF7
0D76C:  RLCF   FF7,F
0D76E:  ADDLW  89
0D770:  MOVWF  FF6
0D772:  MOVLW  D7
0D774:  ADDWFC FF7,F
0D776:  MOVLW  00
0D778:  MOVWF  FF8
0D77A:  MOVWF  FFB
0D77C:  TBLRD*-
0D77E:  MOVF   FF5,W
0D780:  MOVWF  FFA
0D782:  TBLRD*
0D784:  MOVF   FF5,W
0D786:  MOVWF  FF9
0D788:  DATA 9A,D6
0D78A:  DATA C2,D6
0D78C:  DATA E2,D6
0D78E:  DATA 02,D7
0D790:  DATA 22,D7
0D792:  DATA 42,D7
*
0D812:  TBLRD*+
0D814:  MOVFF  FF6,8A3
0D818:  MOVFF  FF7,8A4
0D81C:  MOVFF  FF8,8A5
0D820:  MOVF   FF5,W
0D822:  BTFSS  FA4.4
0D824:  BRA    D822
0D826:  MOVLB  F
0D828:  MOVWF  x1C
0D82A:  MOVFF  8A3,FF6
0D82E:  MOVFF  8A4,FF7
0D832:  MOVFF  8A5,FF8
0D836:  MOVLB  8
0D838:  DECFSZ xA2,F
0D83A:  BRA    D83E
0D83C:  BRA    D842
0D83E:  MOVLB  0
0D840:  BRA    D812
0D842:  MOVLB  0
0D844:  RETURN 0
0D846:  MOVF   01,W
0D848:  CLRF   1B
0D84A:  BTFSC  FF2.7
0D84C:  BSF    1B.7
0D84E:  BCF    FF2.7
0D850:  MOVFF  8DD,A27
0D854:  MOVLW  64
0D856:  MOVLB  A
0D858:  MOVWF  x28
0D85A:  MOVLB  0
0D85C:  CALL   0F74
0D860:  BTFSC  1B.7
0D862:  BSF    FF2.7
0D864:  MOVFF  00,8DD
0D868:  MOVF   01,W
0D86A:  MOVLW  30
0D86C:  BNZ   D87E
0D86E:  MOVLB  8
0D870:  BTFSS  xDE.1
0D872:  BRA    D894
0D874:  BTFSC  xDE.3
0D876:  BRA    D894
0D878:  BTFSC  xDE.4
0D87A:  MOVLW  20
0D87C:  BRA    D886
0D87E:  MOVLB  8
0D880:  BCF    xDE.3
0D882:  BCF    xDE.4
0D884:  BSF    xDE.0
0D886:  ADDWF  01,F
0D888:  MOVF   01,W
0D88A:  BTFSS  FA4.4
0D88C:  BRA    D88A
0D88E:  MOVLB  F
0D890:  MOVWF  x1C
0D892:  MOVLB  8
0D894:  CLRF   1B
0D896:  BTFSC  FF2.7
0D898:  BSF    1B.7
0D89A:  BCF    FF2.7
0D89C:  MOVFF  8DD,A27
0D8A0:  MOVLW  0A
0D8A2:  MOVLB  A
0D8A4:  MOVWF  x28
0D8A6:  MOVLB  0
0D8A8:  CALL   0F74
0D8AC:  BTFSC  1B.7
0D8AE:  BSF    FF2.7
0D8B0:  MOVFF  00,8DD
0D8B4:  MOVF   01,W
0D8B6:  MOVLW  30
0D8B8:  BNZ   D8CA
0D8BA:  MOVLB  8
0D8BC:  BTFSC  xDE.3
0D8BE:  BRA    D8D8
0D8C0:  BTFSS  xDE.0
0D8C2:  BRA    D8D8
0D8C4:  BTFSC  xDE.4
0D8C6:  MOVLW  20
0D8C8:  MOVLB  0
0D8CA:  ADDWF  01,F
0D8CC:  MOVF   01,W
0D8CE:  BTFSS  FA4.4
0D8D0:  BRA    D8CE
0D8D2:  MOVLB  F
0D8D4:  MOVWF  x1C
0D8D6:  MOVLB  8
0D8D8:  MOVLW  30
0D8DA:  ADDWF  xDD,F
0D8DC:  MOVF   xDD,W
0D8DE:  BTFSS  FA4.4
0D8E0:  BRA    D8DE
0D8E2:  MOVLB  F
0D8E4:  MOVWF  x1C
0D8E6:  MOVLB  0
0D8E8:  RETURN 0
*
0D90C:  TBLRD*+
0D90E:  MOVF   FF5,F
0D910:  BZ    D938
0D912:  MOVFF  FF6,8A1
0D916:  MOVFF  FF7,8A2
0D91A:  MOVFF  FF8,8A3
0D91E:  MOVF   FF5,W
0D920:  BTFSS  FA4.4
0D922:  BRA    D920
0D924:  MOVLB  F
0D926:  MOVWF  x1C
0D928:  MOVFF  8A1,FF6
0D92C:  MOVFF  8A2,FF7
0D930:  MOVFF  8A3,FF8
0D934:  MOVLB  0
0D936:  BRA    D90C
0D938:  GOTO   D9FA (RETURN)
*
0DF10:  MOVF   FE9,W
0DF12:  MOVLB  8
0DF14:  MOVWF  x76
0DF16:  MOVLW  3B
0DF18:  MOVWF  x7D
0DF1A:  MOVLW  9A
0DF1C:  MOVWF  x7C
0DF1E:  MOVLW  CA
0DF20:  MOVWF  x7B
0DF22:  CLRF   x7A
0DF24:  MOVLW  0A
0DF26:  MOVWF  x78
0DF28:  MOVF   x75,W
0DF2A:  BTFSS  FD8.2
0DF2C:  DECF   x76,F
0DF2E:  BSF    FD8.1
0DF30:  MOVLW  08
0DF32:  MOVWF  FEA
0DF34:  MOVLW  71
0DF36:  MOVWF  FE9
0DF38:  CLRF   1B
0DF3A:  BTFSC  FF2.7
0DF3C:  BSF    1B.7
0DF3E:  BCF    FF2.7
0DF40:  MOVFF  874,A34
0DF44:  MOVFF  873,A33
0DF48:  MOVFF  872,A32
0DF4C:  MOVFF  871,A31
0DF50:  MOVFF  87D,A38
0DF54:  MOVFF  87C,A37
0DF58:  MOVFF  87B,A36
0DF5C:  MOVFF  87A,A35
0DF60:  MOVLB  0
0DF62:  CALL   1050
0DF66:  BTFSC  1B.7
0DF68:  BSF    FF2.7
0DF6A:  MOVF   01,W
0DF6C:  MOVF   00,F
0DF6E:  BNZ   DF96
0DF70:  MOVLB  8
0DF72:  INCF   x75,W
0DF74:  SUBWF  x78,W
0DF76:  BTFSS  FD8.2
0DF78:  BRA    DF7E
0DF7A:  MOVLB  0
0DF7C:  BRA    DF96
0DF7E:  MOVF   x76,W
0DF80:  BZ    DF9A
0DF82:  ANDLW  0F
0DF84:  SUBWF  x78,W
0DF86:  BZ    DF8A
0DF88:  BC    DFC2
0DF8A:  BTFSC  x76.7
0DF8C:  BRA    DFC2
0DF8E:  BTFSC  x76.6
0DF90:  BRA    DF9A
0DF92:  MOVLW  20
0DF94:  BRA    DFB8
0DF96:  MOVLB  8
0DF98:  CLRF   x76
0DF9A:  MOVF   x75,W
0DF9C:  SUBWF  x78,W
0DF9E:  BNZ   DFB6
0DFA0:  MOVFF  00,876
0DFA4:  MOVLW  2E
0DFA6:  BTFSS  F9E.4
0DFA8:  BRA    DFA6
0DFAA:  MOVWF  FAD
0DFAC:  MOVFF  876,00
0DFB0:  MOVLW  20
0DFB2:  ANDWF  x76,F
0DFB4:  MOVLW  00
0DFB6:  MOVLW  30
0DFB8:  ADDWF  00,F
0DFBA:  MOVF   00,W
0DFBC:  BTFSS  F9E.4
0DFBE:  BRA    DFBC
0DFC0:  MOVWF  FAD
0DFC2:  BCF    FD8.1
0DFC4:  CLRF   1B
0DFC6:  BTFSC  FF2.7
0DFC8:  BSF    1B.7
0DFCA:  BCF    FF2.7
0DFCC:  MOVFF  87D,A34
0DFD0:  MOVFF  87C,A33
0DFD4:  MOVFF  87B,A32
0DFD8:  MOVFF  87A,A31
0DFDC:  MOVLB  A
0DFDE:  CLRF   x38
0DFE0:  CLRF   x37
0DFE2:  CLRF   x36
0DFE4:  MOVLW  0A
0DFE6:  MOVWF  x35
0DFE8:  MOVLB  0
0DFEA:  CALL   1050
0DFEE:  BTFSC  1B.7
0DFF0:  BSF    FF2.7
0DFF2:  MOVFF  03,87D
0DFF6:  MOVFF  02,87C
0DFFA:  MOVFF  01,87B
0DFFE:  MOVFF  00,87A
0E002:  MOVLB  8
0E004:  DECFSZ x78,F
0E006:  BRA    DF2E
0E008:  MOVLB  0
0E00A:  RETURN 0
*
0F0A4:  MOVF   FE9,W
0F0A6:  MOVLB  8
0F0A8:  MOVWF  xE1
0F0AA:  MOVLW  3B
0F0AC:  MOVWF  xE8
0F0AE:  MOVLW  9A
0F0B0:  MOVWF  xE7
0F0B2:  MOVLW  CA
0F0B4:  MOVWF  xE6
0F0B6:  CLRF   xE5
0F0B8:  MOVLW  0A
0F0BA:  MOVWF  xE3
0F0BC:  BSF    FD8.1
0F0BE:  MOVLW  08
0F0C0:  MOVWF  FEA
0F0C2:  MOVLW  DD
0F0C4:  MOVWF  FE9
0F0C6:  CLRF   1B
0F0C8:  BTFSC  FF2.7
0F0CA:  BSF    1B.7
0F0CC:  BCF    FF2.7
0F0CE:  MOVFF  8E0,A34
0F0D2:  MOVFF  8DF,A33
0F0D6:  MOVFF  8DE,A32
0F0DA:  MOVFF  8DD,A31
0F0DE:  MOVFF  8E8,A38
0F0E2:  MOVFF  8E7,A37
0F0E6:  MOVFF  8E6,A36
0F0EA:  MOVFF  8E5,A35
0F0EE:  MOVLB  0
0F0F0:  CALL   1050
0F0F4:  BTFSC  1B.7
0F0F6:  BSF    FF2.7
0F0F8:  MOVF   01,W
0F0FA:  MOVF   00,F
0F0FC:  BNZ   F124
0F0FE:  MOVLB  8
0F100:  MOVF   xE3,W
0F102:  XORLW  01
0F104:  BTFSS  FD8.2
0F106:  BRA    F10C
0F108:  MOVLB  0
0F10A:  BRA    F124
0F10C:  MOVF   xE1,W
0F10E:  BZ    F128
0F110:  ANDLW  0F
0F112:  SUBWF  xE3,W
0F114:  BZ    F118
0F116:  BC    F138
0F118:  BTFSC  xE1.7
0F11A:  BRA    F138
0F11C:  BTFSC  xE1.6
0F11E:  BRA    F128
0F120:  MOVLW  20
0F122:  BRA    F12A
0F124:  MOVLB  8
0F126:  CLRF   xE1
0F128:  MOVLW  30
0F12A:  ADDWF  00,F
0F12C:  MOVF   00,W
0F12E:  BTFSS  FA4.4
0F130:  BRA    F12E
0F132:  MOVLB  F
0F134:  MOVWF  x1C
0F136:  MOVLB  8
0F138:  BCF    FD8.1
0F13A:  CLRF   1B
0F13C:  BTFSC  FF2.7
0F13E:  BSF    1B.7
0F140:  BCF    FF2.7
0F142:  MOVFF  8E8,A34
0F146:  MOVFF  8E7,A33
0F14A:  MOVFF  8E6,A32
0F14E:  MOVFF  8E5,A31
0F152:  MOVLB  A
0F154:  CLRF   x38
0F156:  CLRF   x37
0F158:  CLRF   x36
0F15A:  MOVLW  0A
0F15C:  MOVWF  x35
0F15E:  MOVLB  0
0F160:  CALL   1050
0F164:  BTFSC  1B.7
0F166:  BSF    FF2.7
0F168:  MOVFF  03,8E8
0F16C:  MOVFF  02,8E7
0F170:  MOVFF  01,8E6
0F174:  MOVFF  00,8E5
0F178:  MOVLB  8
0F17A:  DECFSZ xE3,F
0F17C:  BRA    F0BC
0F17E:  MOVLB  0
0F180:  GOTO   F2AA (RETURN)
*
0F37A:  ADDWF  FE8,W
0F37C:  CLRF   FF7
0F37E:  RLCF   FF7,F
0F380:  ADDLW  9B
0F382:  MOVWF  FF6
0F384:  MOVLW  F3
0F386:  ADDWFC FF7,F
0F388:  MOVLW  00
0F38A:  MOVWF  FF8
0F38C:  MOVWF  FFB
0F38E:  TBLRD*-
0F390:  MOVF   FF5,W
0F392:  MOVWF  FFA
0F394:  TBLRD*
0F396:  MOVF   FF5,W
0F398:  MOVWF  FF9
0F39A:  DATA 3A,F3
0F39C:  DATA 42,F3
0F39E:  DATA 4A,F3
0F3A0:  DATA 52,F3
*
0FBBE:  MOVF   FEF,F
0FBC0:  BZ    FBE2
0FBC2:  MOVFF  FEA,8D6
0FBC6:  MOVFF  FE9,8D5
0FBCA:  MOVFF  FEF,8E9
0FBCE:  CALL   50F6
0FBD2:  MOVFF  8D6,FEA
0FBD6:  MOVFF  8D5,FE9
0FBDA:  INCF   FE9,F
0FBDC:  BTFSC  FD8.2
0FBDE:  INCF   FEA,F
0FBE0:  BRA    FBBE
0FBE2:  RETURN 0
0FBE4:  MOVFF  FEA,FE2
0FBE8:  MOVFF  FE9,FE1
0FBEC:  CLRF   01
0FBEE:  BSF    00.0
0FBF0:  TBLRD*+
0FBF2:  MOVF   FF5,W
0FBF4:  BTFSS  00.0
0FBF6:  BRA    FC02
0FBF8:  SUBWF  FEE,W
0FBFA:  BNZ   FC02
0FBFC:  MOVF   FF5,F
0FBFE:  BNZ   FBF0
0FC00:  BRA    FC1C
0FC02:  BCF    00.0
0FC04:  MOVF   FF5,F
0FC06:  BNZ   FBF0
0FC08:  INCF   01,F
0FC0A:  BSF    00.0
0FC0C:  MOVFF  FE2,FEA
0FC10:  MOVFF  FE1,FE9
0FC14:  TBLRD*
0FC16:  MOVF   FF5,F
0FC18:  BNZ   FBF0
0FC1A:  SETF   01
0FC1C:  RETURN 0
*
104EC:  MOVFF  8FE,905
104F0:  MOVLB  9
104F2:  MOVF   x02,W
104F4:  XORWF  x05,F
104F6:  BTFSS  x05.7
104F8:  BRA    10506
104FA:  BCF    FD8.2
104FC:  BCF    FD8.0
104FE:  MOVLB  8
10500:  BTFSC  xFE.7
10502:  BSF    FD8.0
10504:  BRA    1058E
10506:  MOVFF  8FE,905
1050A:  MOVFF  901,906
1050E:  MOVLB  8
10510:  MOVF   xFD,W
10512:  MOVLB  9
10514:  SUBWF  x06,F
10516:  BZ    1052A
10518:  BTFSC  x05.7
1051A:  BRA    10520
1051C:  MOVLB  8
1051E:  BRA    1058E
10520:  MOVF   FD8,W
10522:  XORLW  01
10524:  MOVWF  FD8
10526:  MOVLB  8
10528:  BRA    1058E
1052A:  MOVFF  902,906
1052E:  MOVLB  8
10530:  MOVF   xFE,W
10532:  MOVLB  9
10534:  SUBWF  x06,F
10536:  BZ    1054A
10538:  BTFSC  x05.7
1053A:  BRA    10540
1053C:  MOVLB  8
1053E:  BRA    1058E
10540:  MOVF   FD8,W
10542:  XORLW  01
10544:  MOVWF  FD8
10546:  MOVLB  8
10548:  BRA    1058E
1054A:  MOVFF  903,906
1054E:  MOVLB  8
10550:  MOVF   xFF,W
10552:  MOVLB  9
10554:  SUBWF  x06,F
10556:  BZ    1056C
10558:  BTFSC  x05.7
1055A:  BRA    10560
1055C:  MOVLB  8
1055E:  BRA    1058E
10560:  MOVF   FD8,W
10562:  XORLW  01
10564:  MOVWF  FD8
10566:  MOVLB  8
10568:  BRA    1058E
1056A:  MOVLB  9
1056C:  MOVFF  904,906
10570:  MOVF   x00,W
10572:  SUBWF  x06,F
10574:  BZ    1058A
10576:  BTFSC  x05.7
10578:  BRA    1057E
1057A:  MOVLB  8
1057C:  BRA    1058E
1057E:  MOVF   FD8,W
10580:  XORLW  01
10582:  MOVWF  FD8
10584:  MOVLB  8
10586:  BRA    1058E
10588:  MOVLB  9
1058A:  BCF    FD8.0
1058C:  MOVLB  8
1058E:  MOVLB  0
10590:  RETURN 0
10592:  MOVLW  8E
10594:  MOVWF  00
10596:  MOVFF  8D7,01
1059A:  MOVFF  8D6,02
1059E:  CLRF   03
105A0:  BTFSS  01.7
105A2:  BRA    105AE
105A4:  COMF   01,F
105A6:  COMF   02,F
105A8:  INCF   02,F
105AA:  BNZ   105AE
105AC:  INCF   01,F
105AE:  MOVF   01,F
105B0:  BNZ   105C4
105B2:  MOVFF  02,01
105B6:  CLRF   02
105B8:  MOVLW  08
105BA:  SUBWF  00,F
105BC:  MOVF   01,F
105BE:  BNZ   105C4
105C0:  CLRF   00
105C2:  BRA    105E0
105C4:  BCF    FD8.0
105C6:  BTFSC  01.7
105C8:  BRA    105D2
105CA:  RLCF   02,F
105CC:  RLCF   01,F
105CE:  DECF   00,F
105D0:  BRA    105C4
105D2:  MOVLB  8
105D4:  BTFSS  xD7.7
105D6:  BRA    105DC
105D8:  MOVLB  0
105DA:  BRA    105E0
105DC:  BCF    01.7
105DE:  MOVLB  0
105E0:  RETURN 0
*
109E6:  MOVF   FE9,W
109E8:  MOVLB  8
109EA:  MOVWF  xBE
109EC:  MOVF   xBD,W
109EE:  MOVWF  xC0
109F0:  BZ    10A2C
109F2:  MOVFF  8BC,900
109F6:  MOVFF  8BB,8FF
109FA:  MOVFF  8BA,8FE
109FE:  MOVFF  8B9,8FD
10A02:  MOVLB  9
10A04:  CLRF   x04
10A06:  CLRF   x03
10A08:  MOVLW  20
10A0A:  MOVWF  x02
10A0C:  MOVLW  82
10A0E:  MOVWF  x01
10A10:  MOVLB  0
10A12:  CALL   C036
10A16:  MOVFF  03,8BC
10A1A:  MOVFF  02,8BB
10A1E:  MOVFF  01,8BA
10A22:  MOVFF  00,8B9
10A26:  MOVLB  8
10A28:  DECFSZ xC0,F
10A2A:  BRA    109F2
10A2C:  MOVLW  7E
10A2E:  MOVWF  00
10A30:  CLRF   01
10A32:  BTFSC  xBA.7
10A34:  BSF    01.7
10A36:  CLRF   02
10A38:  CLRF   03
10A3A:  BCF    FD8.1
10A3C:  MOVFF  8BC,904
10A40:  MOVFF  8BB,903
10A44:  MOVFF  8BA,902
10A48:  MOVFF  8B9,901
10A4C:  MOVFF  03,908
10A50:  MOVFF  02,907
10A54:  MOVFF  01,906
10A58:  MOVFF  FE8,905
10A5C:  MOVLB  0
10A5E:  CALL   C160
10A62:  MOVFF  03,8BC
10A66:  MOVFF  02,8BB
10A6A:  MOVFF  01,8BA
10A6E:  MOVFF  00,8B9
10A72:  MOVFF  8BC,8C9
10A76:  MOVFF  8BB,8C8
10A7A:  MOVFF  8BA,8C7
10A7E:  MOVFF  8B9,8C6
10A82:  CALL   C3D8
10A86:  MOVFF  03,8BC
10A8A:  MOVFF  02,8BB
10A8E:  MOVFF  01,8BA
10A92:  MOVFF  00,8B9
10A96:  MOVLB  8
10A98:  BTFSS  xBC.7
10A9A:  BRA    10AB6
10A9C:  DECF   xBE,F
10A9E:  BSF    xBE.5
10AA0:  COMF   xB9,F
10AA2:  COMF   xBA,F
10AA4:  COMF   xBB,F
10AA6:  COMF   xBC,F
10AA8:  INCF   xB9,F
10AAA:  BTFSC  FD8.2
10AAC:  INCF   xBA,F
10AAE:  BTFSC  FD8.2
10AB0:  INCF   xBB,F
10AB2:  BTFSC  FD8.2
10AB4:  INCF   xBC,F
10AB6:  MOVLW  3B
10AB8:  MOVWF  xC5
10ABA:  MOVLW  9A
10ABC:  MOVWF  xC4
10ABE:  MOVLW  CA
10AC0:  MOVWF  xC3
10AC2:  CLRF   xC2
10AC4:  MOVLW  0A
10AC6:  MOVWF  xC0
10AC8:  MOVF   xBD,W
10ACA:  BTFSC  FD8.2
10ACC:  INCF   xBE,F
10ACE:  BSF    FD8.1
10AD0:  MOVLW  08
10AD2:  MOVWF  FEA
10AD4:  MOVLW  B9
10AD6:  MOVWF  FE9
10AD8:  CLRF   1B
10ADA:  BTFSC  FF2.7
10ADC:  BSF    1B.7
10ADE:  BCF    FF2.7
10AE0:  MOVFF  8BC,A34
10AE4:  MOVFF  8BB,A33
10AE8:  MOVFF  8BA,A32
10AEC:  MOVFF  8B9,A31
10AF0:  MOVFF  8C5,A38
10AF4:  MOVFF  8C4,A37
10AF8:  MOVFF  8C3,A36
10AFC:  MOVFF  8C2,A35
10B00:  MOVLB  0
10B02:  CALL   1050
10B06:  BTFSC  1B.7
10B08:  BSF    FF2.7
10B0A:  MOVF   01,W
10B0C:  MOVF   00,F
10B0E:  BNZ   10B36
10B10:  MOVLB  8
10B12:  INCF   xBD,W
10B14:  SUBWF  xC0,W
10B16:  BTFSS  FD8.2
10B18:  BRA    10B1E
10B1A:  MOVLB  0
10B1C:  BRA    10B36
10B1E:  MOVF   xBE,W
10B20:  BZ    10B3C
10B22:  ANDLW  0F
10B24:  SUBWF  xC0,W
10B26:  BZ    10B2A
10B28:  BC    10BB2
10B2A:  BTFSC  xBE.7
10B2C:  BRA    10BB2
10B2E:  BTFSC  xBE.6
10B30:  BRA    10B3C
10B32:  MOVLW  20
10B34:  BRA    10BA4
10B36:  MOVLW  20
10B38:  MOVLB  8
10B3A:  ANDWF  xBE,F
10B3C:  BTFSS  xBE.5
10B3E:  BRA    10B5E
10B40:  BCF    xBE.5
10B42:  MOVF   xBD,W
10B44:  BTFSS  FD8.2
10B46:  DECF   xBE,F
10B48:  MOVF   00,W
10B4A:  MOVWF  xBE
10B4C:  MOVLW  2D
10B4E:  MOVWF  xE9
10B50:  MOVLB  0
10B52:  CALL   50F6
10B56:  MOVLB  8
10B58:  MOVF   xBE,W
10B5A:  MOVWF  00
10B5C:  CLRF   xBE
10B5E:  MOVF   xBD,W
10B60:  SUBWF  xC0,W
10B62:  BNZ   10B7E
10B64:  MOVF   00,W
10B66:  MOVWF  xBE
10B68:  MOVLW  2E
10B6A:  MOVWF  xE9
10B6C:  MOVLB  0
10B6E:  CALL   50F6
10B72:  MOVLB  8
10B74:  MOVF   xBE,W
10B76:  MOVWF  00
10B78:  MOVLW  20
10B7A:  ANDWF  xBE,F
10B7C:  MOVLW  00
10B7E:  MOVLW  30
10B80:  BTFSS  xBE.5
10B82:  BRA    10BA4
10B84:  BCF    xBE.5
10B86:  MOVF   xBD,W
10B88:  BTFSS  FD8.2
10B8A:  DECF   xBE,F
10B8C:  MOVF   00,W
10B8E:  MOVWF  xBE
10B90:  MOVLW  2D
10B92:  MOVWF  xE9
10B94:  MOVLB  0
10B96:  CALL   50F6
10B9A:  MOVLB  8
10B9C:  MOVF   xBE,W
10B9E:  MOVWF  00
10BA0:  CLRF   xBE
10BA2:  MOVLW  30
10BA4:  ADDWF  00,F
10BA6:  MOVFF  00,8E9
10BAA:  MOVLB  0
10BAC:  CALL   50F6
10BB0:  MOVLB  8
10BB2:  BCF    FD8.1
10BB4:  CLRF   1B
10BB6:  BTFSC  FF2.7
10BB8:  BSF    1B.7
10BBA:  BCF    FF2.7
10BBC:  MOVFF  8C5,A34
10BC0:  MOVFF  8C4,A33
10BC4:  MOVFF  8C3,A32
10BC8:  MOVFF  8C2,A31
10BCC:  MOVLB  A
10BCE:  CLRF   x38
10BD0:  CLRF   x37
10BD2:  CLRF   x36
10BD4:  MOVLW  0A
10BD6:  MOVWF  x35
10BD8:  MOVLB  0
10BDA:  CALL   1050
10BDE:  BTFSC  1B.7
10BE0:  BSF    FF2.7
10BE2:  MOVFF  03,8C5
10BE6:  MOVFF  02,8C4
10BEA:  MOVFF  01,8C3
10BEE:  MOVFF  00,8C2
10BF2:  MOVLB  8
10BF4:  DECFSZ xC0,F
10BF6:  BRA    10ACE
10BF8:  MOVLB  0
10BFA:  RETURN 0
*
124FC:  ADDWF  FE8,W
124FE:  CLRF   FF7
12500:  RLCF   FF7,F
12502:  ADDLW  1D
12504:  MOVWF  FF6
12506:  MOVLW  25
12508:  ADDWFC FF7,F
1250A:  MOVLW  01
1250C:  MOVWF  FF8
1250E:  MOVWF  FFB
12510:  TBLRD*-
12512:  MOVF   FF5,W
12514:  MOVWF  FFA
12516:  TBLRD*
12518:  MOVF   FF5,W
1251A:  MOVWF  FF9
1251C:  DATA C0,24
1251E:  DATA C8,24
12520:  DATA CE,24
12522:  DATA D4,24
*
125B4:  MOVLW  8E
125B6:  MOVWF  00
125B8:  MOVLB  8
125BA:  MOVF   xFD,W
125BC:  SUBWF  00,F
125BE:  MOVFF  8FE,02
125C2:  MOVFF  8FF,01
125C6:  BSF    02.7
125C8:  MOVF   00,F
125CA:  BZ    125DE
125CC:  BCF    FD8.0
125CE:  MOVF   02,F
125D0:  BNZ   125D6
125D2:  MOVF   01,F
125D4:  BZ    125DE
125D6:  RRCF   02,F
125D8:  RRCF   01,F
125DA:  DECFSZ 00,F
125DC:  BRA    125CC
125DE:  BTFSS  xFE.7
125E0:  BRA    125EC
125E2:  COMF   01,F
125E4:  COMF   02,F
125E6:  INCF   01,F
125E8:  BTFSC  FD8.2
125EA:  INCF   02,F
125EC:  MOVLB  0
125EE:  RETURN 0
*
130BC:  ADDWF  FE8,W
130BE:  CLRF   FF7
130C0:  RLCF   FF7,F
130C2:  ADDLW  DD
130C4:  MOVWF  FF6
130C6:  MOVLW  30
130C8:  ADDWFC FF7,F
130CA:  MOVLW  01
130CC:  MOVWF  FF8
130CE:  MOVWF  FFB
130D0:  TBLRD*-
130D2:  MOVF   FF5,W
130D4:  MOVWF  FFA
130D6:  TBLRD*
130D8:  MOVF   FF5,W
130DA:  MOVWF  FF9
130DC:  DATA F8,2E
130DE:  DATA FE,2E
130E0:  DATA 1C,2F
130E2:  DATA 3A,2F
*
13154:  MOVLB  8
13156:  MOVF   xC7,W
13158:  XORWF  xC9,W
1315A:  ANDLW  80
1315C:  MOVWF  xCB
1315E:  BTFSS  xC7.7
13160:  BRA    1316C
13162:  COMF   xC6,F
13164:  COMF   xC7,F
13166:  INCF   xC6,F
13168:  BTFSC  FD8.2
1316A:  INCF   xC7,F
1316C:  BTFSS  xC9.7
1316E:  BRA    1317A
13170:  COMF   xC8,F
13172:  COMF   xC9,F
13174:  INCF   xC8,F
13176:  BTFSC  FD8.2
13178:  INCF   xC9,F
1317A:  MOVF   xC6,W
1317C:  MULWF  xC8
1317E:  MOVFF  FF3,01
13182:  MOVFF  FF4,00
13186:  MULWF  xC9
13188:  MOVF   FF3,W
1318A:  ADDWF  00,F
1318C:  MOVF   xC7,W
1318E:  MULWF  xC8
13190:  MOVF   FF3,W
13192:  ADDWFC 00,W
13194:  MOVWF  02
13196:  BTFSS  xCB.7
13198:  BRA    131A4
1319A:  COMF   01,F
1319C:  COMF   02,F
1319E:  INCF   01,F
131A0:  BTFSC  FD8.2
131A2:  INCF   02,F
131A4:  MOVLB  0
131A6:  GOTO   13284 (RETURN)
*
13ECE:  ADDWF  FE8,W
13ED0:  CLRF   FF7
13ED2:  RLCF   FF7,F
13ED4:  ADDLW  EF
13ED6:  MOVWF  FF6
13ED8:  MOVLW  3E
13EDA:  ADDWFC FF7,F
13EDC:  MOVLW  01
13EDE:  MOVWF  FF8
13EE0:  MOVWF  FFB
13EE2:  TBLRD*-
13EE4:  MOVF   FF5,W
13EE6:  MOVWF  FFA
13EE8:  TBLRD*
13EEA:  MOVF   FF5,W
13EEC:  MOVWF  FF9
13EEE:  DATA 9A,3D
13EF0:  DATA C2,3E
13EF2:  DATA C6,3D
13EF4:  DATA C2,3E
13EF6:  DATA 92,3C
13EF8:  DATA C2,3E
13EFA:  DATA C2,3E
13EFC:  DATA C2,3E
13EFE:  DATA C2,3E
13F00:  DATA C2,3E
13F02:  DATA C2,3E
13F04:  DATA C2,3E
13F06:  DATA C2,3E
13F08:  DATA C2,3E
13F0A:  DATA C2,3E
13F0C:  DATA C2,3E
13F0E:  DATA BA,3E
13F10:  DATA C2,3E
13F12:  DATA C2,3E
13F14:  DATA C2,3E
13F16:  DATA C2,3E
13F18:  DATA C2,3E
13F1A:  DATA 32,3C
13F1C:  DATA C2,3E
13F1E:  DATA 66,3C
13F20:  DATA 6E,3C
13F22:  DATA C2,3E
13F24:  DATA 82,3C
13F26:  DATA F2,3D
13F28:  DATA B6,3C
13F2A:  DATA C2,3E
13F2C:  DATA C2,3E
13F2E:  DATA 48,3D
13F30:  DATA 2A,3D
13F32:  DATA C2,3E
13F34:  DATA C2,3E
13F36:  DATA C2,3E
13F38:  DATA 0C,3E
13F3A:  DATA 38,3E
13F3C:  DATA 64,3E
13F3E:  DATA 64,3D
13F40:  DATA 90,3D
13F42:  DATA C2,3E
13F44:  DATA C2,3E
13F46:  DATA C2,3E
13F48:  DATA C2,3E
13F4A:  DATA 90,3E
13F4C:  DATA C2,3E
13F4E:  DATA C2,3E
13F50:  DATA C2,3E
13F52:  DATA C2,3E
13F54:  DATA C2,3E
13F56:  DATA C2,3E
13F58:  DATA C2,3E
13F5A:  DATA C2,3E
13F5C:  DATA C2,3E
13F5E:  DATA C2,3E
13F60:  DATA 9E,3C
13F62:  DATA C2,3E
13F64:  DATA C2,3E
13F66:  DATA C2,3E
13F68:  DATA C2,3E
13F6A:  DATA CE,3C
13F6C:  DATA C2,3E
13F6E:  DATA C2,3E
13F70:  DATA F4,3C
13F72:  DATA C2,3E
13F74:  DATA C2,3E
13F76:  DATA C2,3E
13F78:  DATA 42,3C
*
1402E:  MOVFF  FEA,8AA
14032:  MOVFF  FE9,8A9
14036:  MOVLB  8
14038:  SWAPF  xA3,W
1403A:  IORLW  F0
1403C:  MOVWF  xA5
1403E:  ADDWF  xA5,F
14040:  ADDLW  E2
14042:  MOVWF  xA6
14044:  ADDLW  32
14046:  MOVWF  xA8
14048:  MOVF   xA3,W
1404A:  ANDLW  0F
1404C:  ADDWF  xA6,F
1404E:  ADDWF  xA6,F
14050:  ADDWF  xA8,F
14052:  ADDLW  E9
14054:  MOVWF  xA7
14056:  ADDWF  xA7,F
14058:  ADDWF  xA7,F
1405A:  SWAPF  xA2,W
1405C:  ANDLW  0F
1405E:  ADDWF  xA7,F
14060:  ADDWF  xA8,F
14062:  RLCF   xA7,F
14064:  RLCF   xA8,F
14066:  COMF   xA8,F
14068:  RLCF   xA8,F
1406A:  MOVF   xA2,W
1406C:  ANDLW  0F
1406E:  ADDWF  xA8,F
14070:  RLCF   xA5,F
14072:  MOVLW  07
14074:  MOVWF  xA4
14076:  MOVLW  0A
14078:  DECF   xA7,F
1407A:  ADDWF  xA8,F
1407C:  BNC   14078
1407E:  DECF   xA6,F
14080:  ADDWF  xA7,F
14082:  BNC   1407E
14084:  DECF   xA5,F
14086:  ADDWF  xA6,F
14088:  BNC   14084
1408A:  DECF   xA4,F
1408C:  ADDWF  xA5,F
1408E:  BNC   1408A
14090:  MOVLW  08
14092:  MOVWF  FEA
14094:  MOVLW  A4
14096:  MOVWF  FE9
14098:  MOVLW  07
1409A:  ANDWF  xA9,W
1409C:  BCF    xA9.6
1409E:  ADDWF  FE9,F
140A0:  MOVLW  00
140A2:  ADDWFC FEA,F
140A4:  MOVF   FE9,W
140A6:  SUBLW  A8
140A8:  BNZ   140B2
140AA:  MOVF   FEA,W
140AC:  SUBLW  08
140AE:  BNZ   140B2
140B0:  BSF    xA9.6
140B2:  MOVF   FEF,W
140B4:  MOVWF  00
140B6:  BNZ   140C8
140B8:  BTFSC  xA9.6
140BA:  BRA    140C8
140BC:  BTFSC  xA9.4
140BE:  BRA    140DC
140C0:  BTFSC  xA9.3
140C2:  BRA    140C8
140C4:  MOVLW  20
140C6:  BRA    140CE
140C8:  BSF    xA9.3
140CA:  BCF    xA9.4
140CC:  MOVLW  30
140CE:  ADDWF  00,F
140D0:  MOVF   00,W
140D2:  BTFSS  FA4.4
140D4:  BRA    140D2
140D6:  MOVLB  F
140D8:  MOVWF  x1C
140DA:  MOVLB  8
140DC:  MOVF   FEE,W
140DE:  BTFSS  xA9.6
140E0:  BRA    140A4
140E2:  MOVLB  0
140E4:  GOTO   14180 (RETURN)
*
145C4:  ADDWF  FE8,W
145C6:  CLRF   FF7
145C8:  RLCF   FF7,F
145CA:  ADDLW  E5
145CC:  MOVWF  FF6
145CE:  MOVLW  45
145D0:  ADDWFC FF7,F
145D2:  MOVLW  01
145D4:  MOVWF  FF8
145D6:  MOVWF  FFB
145D8:  TBLRD*-
145DA:  MOVF   FF5,W
145DC:  MOVWF  FFA
145DE:  TBLRD*
145E0:  MOVF   FF5,W
145E2:  MOVWF  FF9
145E4:  DATA B0,41
145E6:  DATA 10,42
145E8:  DATA 2C,42
145EA:  DATA 48,42
145EC:  DATA 64,42
145EE:  DATA 80,42
145F0:  DATA 9C,42
145F2:  DATA B8,42
145F4:  DATA D4,42
145F6:  DATA F0,42
145F8:  DATA 0C,43
145FA:  DATA 28,43
145FC:  DATA 44,43
145FE:  DATA 60,43
14600:  DATA 7C,43
14602:  DATA 98,43
14604:  DATA B4,43
14606:  DATA D0,43
14608:  DATA EC,43
1460A:  DATA 08,44
1460C:  DATA 24,44
1460E:  DATA 40,44
14610:  DATA 5C,44
14612:  DATA 78,44
14614:  DATA 94,44
14616:  DATA B0,44
14618:  DATA CC,44
1461A:  DATA E8,44
1461C:  DATA 04,45
1461E:  DATA 20,45
14620:  DATA 3C,45
14622:  DATA 58,45
14624:  DATA 74,45
*
14DFA:  ADDWF  FE8,W
14DFC:  CLRF   FF7
14DFE:  RLCF   FF7,F
14E00:  ADDLW  1B
14E02:  MOVWF  FF6
14E04:  MOVLW  4E
14E06:  ADDWFC FF7,F
14E08:  MOVLW  01
14E0A:  MOVWF  FF8
14E0C:  MOVWF  FFB
14E0E:  TBLRD*-
14E10:  MOVF   FF5,W
14E12:  MOVWF  FFA
14E14:  TBLRD*
14E16:  MOVF   FF5,W
14E18:  MOVWF  FF9
14E1A:  DATA 06,4A
14E1C:  DATA 2E,4B
14E1E:  DATA 32,4A
14E20:  DATA 2E,4B
14E22:  DATA F8,48
14E24:  DATA 2E,4B
14E26:  DATA 2E,4B
14E28:  DATA 2E,4B
14E2A:  DATA 2E,4B
14E2C:  DATA 2E,4B
14E2E:  DATA 2E,4B
14E30:  DATA 2E,4B
14E32:  DATA 2E,4B
14E34:  DATA 2E,4B
14E36:  DATA 2E,4B
14E38:  DATA 2E,4B
14E3A:  DATA 26,4B
14E3C:  DATA 2E,4B
14E3E:  DATA 2E,4B
14E40:  DATA 2E,4B
14E42:  DATA 2E,4B
14E44:  DATA 2E,4B
14E46:  DATA 02,47
14E48:  DATA 2E,4B
14E4A:  DATA 36,47
14E4C:  DATA D4,48
14E4E:  DATA 2E,4B
14E50:  DATA E8,48
14E52:  DATA 5E,4A
14E54:  DATA 1C,49
14E56:  DATA 2E,4B
14E58:  DATA 2E,4B
14E5A:  DATA AE,49
14E5C:  DATA 90,49
14E5E:  DATA 2E,4B
14E60:  DATA 2E,4B
14E62:  DATA 2E,4B
14E64:  DATA 78,4A
14E66:  DATA A4,4A
14E68:  DATA D0,4A
14E6A:  DATA CA,49
14E6C:  DATA FA,49
14E6E:  DATA 2E,4B
14E70:  DATA 2E,4B
14E72:  DATA 2E,4B
14E74:  DATA 2E,4B
14E76:  DATA FC,4A
14E78:  DATA 2E,4B
14E7A:  DATA 2E,4B
14E7C:  DATA 2E,4B
14E7E:  DATA 2E,4B
14E80:  DATA 2E,4B
14E82:  DATA 2E,4B
14E84:  DATA 2E,4B
14E86:  DATA 2E,4B
14E88:  DATA 2E,4B
14E8A:  DATA 2E,4B
14E8C:  DATA 04,49
14E8E:  DATA 2E,4B
14E90:  DATA 2E,4B
14E92:  DATA 2E,4B
14E94:  DATA 2E,4B
14E96:  DATA 34,49
14E98:  DATA 2E,4B
14E9A:  DATA 2E,4B
14E9C:  DATA 5A,49
14E9E:  DATA 2E,4B
14EA0:  DATA 2E,4B
14EA2:  DATA 2E,4B
14EA4:  DATA 12,47
14EA6:  DATA 2E,4B
14EA8:  DATA 3E,47
*
1530C:  ADDWF  FE8,W
1530E:  CLRF   FF7
15310:  RLCF   FF7,F
15312:  ADDLW  2D
15314:  MOVWF  FF6
15316:  MOVLW  53
15318:  ADDWFC FF7,F
1531A:  MOVLW  01
1531C:  MOVWF  FF8
1531E:  MOVWF  FFB
15320:  TBLRD*-
15322:  MOVF   FF5,W
15324:  MOVWF  FFA
15326:  TBLRD*
15328:  MOVF   FF5,W
1532A:  MOVWF  FF9
1532C:  DATA 7E,51
1532E:  DATA 9E,51
15330:  DATA BE,51
15332:  DATA DE,51
15334:  DATA FE,51
15336:  DATA 1E,52
15338:  DATA 3E,52
*
1ADB2:  ADDWF  FE8,W
1ADB4:  CLRF   FF7
1ADB6:  RLCF   FF7,F
1ADB8:  ADDLW  D3
1ADBA:  MOVWF  FF6
1ADBC:  MOVLW  AD
1ADBE:  ADDWFC FF7,F
1ADC0:  MOVLW  01
1ADC2:  MOVWF  FF8
1ADC4:  MOVWF  FFB
1ADC6:  TBLRD*-
1ADC8:  MOVF   FF5,W
1ADCA:  MOVWF  FFA
1ADCC:  TBLRD*
1ADCE:  MOVF   FF5,W
1ADD0:  MOVWF  FF9
1ADD2:  DATA 38,AC
1ADD4:  DATA AE,AD
1ADD6:  DATA 3E,AC
1ADD8:  DATA 32,AC
1ADDA:  DATA AE,AD
1ADDC:  DATA AE,AD
1ADDE:  DATA AE,AD
1ADE0:  DATA 44,AC
1ADE2:  DATA F8,AC
1ADE4:  DATA AE,AD
1ADE6:  DATA 14,AD
1ADE8:  DATA AE,AD
1ADEA:  DATA 4A,AC
1ADEC:  DATA AE,AD
1ADEE:  DATA AE,AD
1ADF0:  DATA AE,AD
1ADF2:  DATA AE,AD
1ADF4:  DATA AE,AD
1ADF6:  DATA AE,AD
1ADF8:  DATA AE,AD
1ADFA:  DATA AE,AD
1ADFC:  DATA AE,AD
1ADFE:  DATA AE,AD
1AE00:  DATA AE,AD
1AE02:  DATA AE,AD
1AE04:  DATA AE,AD
1AE06:  DATA AE,AD
1AE08:  DATA AE,AD
1AE0A:  DATA AE,AD
1AE0C:  DATA AE,AD
1AE0E:  DATA 50,AC
1AE10:  DATA 56,AC
1AE12:  DATA 5C,AC
1AE14:  DATA 62,AC
1AE16:  DATA 68,AC
1AE18:  DATA 6E,AC
1AE1A:  DATA 74,AC
1AE1C:  DATA 7A,AC
1AE1E:  DATA 80,AC
1AE20:  DATA 86,AC
1AE22:  DATA 8C,AC
1AE24:  DATA 92,AC
1AE26:  DATA 98,AC
1AE28:  DATA A4,AC
1AE2A:  DATA AA,AC
1AE2C:  DATA B0,AC
1AE2E:  DATA B6,AC
1AE30:  DATA BC,AC
1AE32:  DATA C2,AC
1AE34:  DATA C8,AC
1AE36:  DATA CE,AC
1AE38:  DATA D4,AC
1AE3A:  DATA DA,AC
1AE3C:  DATA E0,AC
1AE3E:  DATA E6,AC
1AE40:  DATA EC,AC
1AE42:  DATA AE,AD
1AE44:  DATA AE,AD
1AE46:  DATA AE,AD
1AE48:  DATA F2,AC
1AE4A:  DATA AE,AD
1AE4C:  DATA AE,AD
1AE4E:  DATA 30,AD
1AE50:  DATA 36,AD
1AE52:  DATA AE,AD
1AE54:  DATA 3C,AD
1AE56:  DATA 42,AD
1AE58:  DATA 48,AD
1AE5A:  DATA 4E,AD
1AE5C:  DATA 54,AD
1AE5E:  DATA 5A,AD
1AE60:  DATA 60,AD
1AE62:  DATA 66,AD
1AE64:  DATA 6C,AD
1AE66:  DATA 72,AD
1AE68:  DATA 78,AD
1AE6A:  DATA 7E,AD
1AE6C:  DATA 84,AD
1AE6E:  DATA 8A,AD
1AE70:  DATA 90,AD
1AE72:  DATA 94,AD
1AE74:  DATA 98,AD
1AE76:  DATA 9C,AD
1AE78:  DATA AE,AD
1AE7A:  DATA A0,AD
1AE7C:  DATA A4,AD
1AE7E:  DATA A8,AD
1AE80:  DATA AC,AD
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8DE
1F8BA:  MOVFF  FF7,8DF
1F8BE:  MOVFF  FF8,8E0
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8DE,FF6
1F8CE:  MOVFF  8DF,FF7
1F8D2:  MOVFF  8E0,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8DF
1F8E0:  MOVFF  FF7,8E0
1F8E4:  MOVFF  FF8,8E1
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8DF,FF6
1F8F4:  MOVFF  8E0,FF7
1F8F8:  MOVFF  8E1,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xDE,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xDF.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xDE,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xDF,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xDE,F
1F936:  MOVLW  0A
1F938:  SUBWF  xDE,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xDF.7
1F942:  MOVF   xDF,W
1F944:  ADDWF  xDE,F
1F946:  MOVF   xDE,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xE1,W
1F956:  CLRF   01
1F958:  SUBWF  xE0,W
1F95A:  BC    1F962
1F95C:  MOVFF  8E0,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xE2
1F968:  RLCF   xE0,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xE1,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xE2,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8DE,8E0
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xE1
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8DE
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xDF.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xDF.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xDF.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xDF.3
1F9AC:  BCF    xDF.4
1F9AE:  BSF    xDF.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8DE,8E0
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xE1
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8DE
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xDF.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xDF.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xDF.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xDE,F
1F9F0:  MOVF   xDE,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8DE,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8DF,01
1FA60:  MOVFF  8DE,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... //#FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... //#FUSES WDT_SW   
.................... //#fuses WDT//, WDT16 
.................... //#fuses WDT// WDT is s/w controlled 
.................... //#use delay(clock=2000000) 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
02972:  MOVLW  09
02974:  MOVWF  FEA
02976:  MOVLW  D6
02978:  MOVWF  FE9
0297A:  MOVF   FEF,W
0297C:  BZ    299A
0297E:  MOVLW  14
02980:  MOVWF  01
02982:  CLRF   00
02984:  DECFSZ 00,F
02986:  BRA    2984
02988:  DECFSZ 01,F
0298A:  BRA    2982
0298C:  MOVLW  BF
0298E:  MOVWF  00
02990:  DECFSZ 00,F
02992:  BRA    2990
02994:  BRA    2996
02996:  DECFSZ FEF,F
02998:  BRA    297E
0299A:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E5C:  BTFSS  F9E.5
00E5E:  BRA    0E5C
00E60:  MOVFF  FAB,1C
00E64:  MOVFF  FAE,01
00E68:  BTFSS  1C.1
00E6A:  BRA    0E70
00E6C:  BCF    FAB.4
00E6E:  BSF    FAB.4
00E70:  RETURN 0
*
0AEB4:  BTFSS  F9E.4
0AEB6:  BRA    AEB4
0AEB8:  MOVWF  FAD
0AEBA:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12BE8:  BTFSS  FA4.5
12BEA:  BRA    12BE8
12BEC:  MOVLB  F
12BEE:  MOVFF  F22,1C
12BF2:  MOVFF  F1D,01
12BF6:  BTFSS  1C.1
12BF8:  BRA    12BFE
12BFA:  BCF    x22.4
12BFC:  BSF    x22.4
12BFE:  MOVLB  0
12C00:  RETURN 0
*
16B3C:  BTFSS  FA4.4
16B3E:  BRA    16B3C
16B40:  MOVLB  F
16B42:  MOVWF  x1C
16B44:  MOVLB  0
16B46:  GOTO   16BEA (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xE4
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xE5
1F850:  MOVF   xE5,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8E3,03
1F85A:  MOVFF  8E2,FE9
1F85E:  MOVFF  8E3,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xE4,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8E6
1F870:  MOVFF  8E2,FE9
1F874:  MOVFF  8E3,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xE6,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xE4
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xE4,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8E6
1F88C:  MOVFF  8E2,FE9
1F890:  MOVFF  8E3,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xE6,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xE4
....................       }  
1F89C:  MOVF   xE5,W
1F89E:  INCF   xE5,F
1F8A0:  INCF   xE2,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xE3,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8E4,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xE2,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8DF,03
1FA84:  MOVFF  8DE,FE9
1FA88:  MOVFF  8DF,FEA
1FA8C:  MOVFF  FEF,8E3
1FA90:  MOVFF  8E1,03
1FA94:  MOVFF  8E0,FE9
1FA98:  MOVFF  8E1,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xE3,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8DF,03
1FAA6:  MOVFF  8DE,FE9
1FAAA:  MOVFF  8DF,FEA
1FAAE:  MOVFF  FEF,8E3
1FAB2:  MOVFF  8E1,03
1FAB6:  MOVFF  8E0,FE9
1FABA:  MOVFF  8E1,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xE3,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8DF,03
1FAD4:  MOVFF  8DE,FE9
1FAD8:  MOVFF  8DF,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8DF,03
1FAEA:  MOVF   xDE,W
1FAEC:  INCF   xDE,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xDF,F
1FAF2:  MOVFF  8E1,03
1FAF6:  MOVF   xE0,W
1FAF8:  INCF   xE0,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xE1,F
1FAFE:  DECF   xE2,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x6F.1
1FB0E:  CLRF   x79
1FB10:  CLRF   x78
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xD6
1FB2A:  MOVLB  0
1FB2C:  CALL   2972
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x6F.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x75
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x75,W
1FB3C:  ADDLW  9E
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x75,W
1FB50:  INCF   x75,F
1FB52:  CLRF   03
1FB54:  ADDLW  9E
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x75,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x6F.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   x9E,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xE3
1FB80:  MOVLW  9F
1FB82:  MOVWF  xE2
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,874
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xE3
1FB92:  MOVLW  A1
1FB94:  MOVWF  xE2
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8DE
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xE3
1FBA4:  MOVLW  A3
1FBA6:  MOVWF  xE2
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8DE,877
1FBB0:  MOVFF  01,876
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xE3
1FBBA:  MOVLW  A5
1FBBC:  MOVWF  xE2
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,871
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  878,87C
1FBCA:  MOVFF  879,87D
1FBCE:  MOVFF  876,87A
1FBD2:  MOVFF  877,87B
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x71,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x6F.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x6F.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x7D,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x7C,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x7B,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x7D,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x7C,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x7D,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x7C,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x70
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x73
1FC26:  MOVLW  03
1FC28:  SUBWF  x75,W
1FC2A:  SUBWF  x73,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x73,W
1FC32:  ADDLW  9E
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8DE
1FC3E:  MOVFF  03,8DF
1FC42:  MOVFF  03,8E3
1FC46:  MOVFF  01,8E2
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x70,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x73,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x70,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x70
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x75,W
1FC68:  CLRF   03
1FC6A:  ADDLW  9E
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8DE
1FC76:  MOVFF  03,8DF
1FC7A:  MOVFF  03,8E3
1FC7E:  MOVFF  01,8E2
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x70,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x6F.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x71,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x73
1FCAE:  CLRF   x72
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x75,W
1FCB4:  SUBWF  x73,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x72,W
1FCBA:  INCF   x72,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  7E
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8DE
1FCCA:  MOVFF  03,8DF
1FCCE:  CLRF   03
1FCD0:  MOVF   x73,W
1FCD2:  ADDLW  9E
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8E0
1FCDE:  MOVFF  03,8E1
1FCE2:  MOVFF  03,8E3
1FCE6:  MOVFF  01,8E2
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8DF,FEA
1FCF2:  MOVFF  8DE,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x73,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xDE
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  87D,8DE
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xDF
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  87C,8DE
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xDF
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  87B,8DE
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xDF
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  87A,8DE
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xDF
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  874,8DE
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xDF
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  87C,FF8
1FD80:  MOVFF  87B,FF7
1FD84:  MOVFF  87A,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  7E
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  874,8DE
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  87C,FF8
1FD9A:  MOVFF  87B,FF7
1FD9E:  MOVFF  87A,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  9E
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xDF
1FDAE:  MOVFF  874,8DE
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xDF
1FDBC:  MOVLW  7E
1FDBE:  MOVWF  xDE
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xE1
1FDC4:  MOVLW  9E
1FDC6:  MOVWF  xE0
1FDC8:  MOVFF  874,8E2
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x6F.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x71,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xE3
1FE02:  MOVLW  A7
1FE04:  MOVWF  xE2
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8DE
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xE3
1FE14:  MOVLW  A9
1FE16:  MOVWF  xE2
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8DE,879
1FE20:  MOVFF  01,878
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xDE
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  878,8DE
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xDF
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x6F.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x6F.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xDE
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xD6
1FE8E:  MOVLB  0
1FE90:  CALL   2972
1FE94:  MOVLB  8
1FE96:  DECFSZ xDE,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
055A8:  BCF    FF2.5
....................    restart_wdt(); 
055AA:  CLRWDT
055AC:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
055AE:  CLRF   FCF
055B0:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
055B2:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
055B4:  MOVF   2F,W
055B6:  SUBLW  02
055B8:  BNZ   55C0
055BA:  MOVF   30,F
055BC:  BNZ   55C0
055BE:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
055C0:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
055C2:  BSF    F9D.0
055C4:  GOTO   55D8 (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
055C8:  MOVLW  0B
055CA:  MOVWF  FD7
055CC:  MOVLW  DC
055CE:  MOVWF  FD6
....................    restart_wdt(); 
055D0:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
055D2:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
055D4:  BSF    FF2.5
....................    setup_led_pulse(); 
055D6:  BRA    55AE
055D8:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
055DA:  MOVLB  8
055DC:  MOVF   xD7,W
055DE:  XORLW  00
055E0:  MOVLB  0
055E2:  BZ    55EA
055E4:  XORLW  01
055E6:  BZ    55EE
055E8:  BRA    55F0
....................       case 0 : suspend_heartbeat(); 
055EA:  RCALL  55A8
....................          break; 
055EC:  BRA    55F0
....................       case 1 : restart_heartbeat(); 
055EE:  RCALL  55C8
....................          break; 
....................    } 
055F0:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
03158:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
0315A:  BCF    FD1.0
0315C:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
02962:  MOVLW  0B
02964:  MOVWF  FD7
02966:  MOVLW  DC
02968:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
0296A:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
0296C:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
0296E:  BSF    FD1.0
02970:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0794E:  MOVFF  99B,9A1
07952:  MOVFF  99A,9A0
07956:  MOVLB  9
07958:  MOVF   x9E,F
0795A:  BNZ   7960
0795C:  MOVF   x9F,F
0795E:  BZ    79AA
07960:  MOVFF  99D,03
07964:  MOVFF  99C,FE9
07968:  MOVFF  99D,FEA
0796C:  MOVF   FEF,F
0796E:  BZ    79AA
....................      *s++ = *s2++; 
07970:  MOVFF  9A1,9A3
07974:  MOVF   xA0,W
07976:  INCF   xA0,F
07978:  BTFSC  FD8.2
0797A:  INCF   xA1,F
0797C:  MOVWF  xA2
0797E:  MOVFF  99D,03
07982:  MOVF   x9C,W
07984:  INCF   x9C,F
07986:  BTFSC  FD8.2
07988:  INCF   x9D,F
0798A:  MOVWF  FE9
0798C:  MOVFF  03,FEA
07990:  MOVFF  FEF,9A4
07994:  MOVFF  9A3,FEA
07998:  MOVFF  9A2,FE9
0799C:  MOVFF  9A4,FEF
079A0:  MOVF   x9E,W
079A2:  BTFSC  FD8.2
079A4:  DECF   x9F,F
079A6:  DECF   x9E,F
079A8:  BRA    7958
....................   for (; n > 0; n--) 
079AA:  MOVF   x9E,F
079AC:  BNZ   79B2
079AE:  MOVF   x9F,F
079B0:  BZ    79D0
....................      *s++ = '\0'; 
079B2:  MOVFF  9A1,03
079B6:  MOVF   xA0,W
079B8:  INCF   xA0,F
079BA:  BTFSC  FD8.2
079BC:  INCF   xA1,F
079BE:  MOVWF  FE9
079C0:  MOVFF  03,FEA
079C4:  CLRF   FEF
079C6:  MOVF   x9E,W
079C8:  BTFSC  FD8.2
079CA:  DECF   x9F,F
079CC:  DECF   x9E,F
079CE:  BRA    79AA
....................  
....................   return(s1); 
079D0:  MOVFF  99A,01
079D4:  MOVFF  99B,02
079D8:  MOVLB  0
079DA:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05536:  MOVFF  8E3,8E7
0553A:  MOVFF  8E2,8E6
0553E:  MOVFF  8E7,03
05542:  MOVLB  8
05544:  MOVFF  8E6,FE9
05548:  MOVFF  8E7,FEA
0554C:  MOVF   FEF,F
0554E:  BZ    555C
05550:  INCF   xE6,F
05552:  BTFSC  FD8.2
05554:  INCF   xE7,F
05556:  MOVLB  0
05558:  BRA    553E
0555A:  MOVLB  8
....................    while(*s2 != '\0') 
0555C:  MOVFF  8E5,03
05560:  MOVFF  8E4,FE9
05564:  MOVFF  8E5,FEA
05568:  MOVF   FEF,F
0556A:  BZ    5592
....................    { 
....................       *s = *s2; 
0556C:  MOVFF  8E4,FE9
05570:  MOVFF  8E5,FEA
05574:  MOVFF  FEF,8EA
05578:  MOVFF  8E7,FEA
0557C:  MOVFF  8E6,FE9
05580:  MOVFF  8EA,FEF
....................       ++s; 
05584:  INCF   xE6,F
05586:  BTFSC  FD8.2
05588:  INCF   xE7,F
....................       ++s2; 
0558A:  INCF   xE4,F
0558C:  BTFSC  FD8.2
0558E:  INCF   xE5,F
05590:  BRA    555C
....................    } 
....................  
....................    *s = '\0'; 
05592:  MOVFF  8E6,FE9
05596:  MOVFF  8E7,FEA
0559A:  CLRF   FEF
....................    return(s1); 
0559C:  MOVFF  8E2,01
055A0:  MOVFF  8E3,02
055A4:  MOVLB  0
055A6:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12B64:  MOVFF  8D8,8DE
12B68:  MOVFF  8D7,8DD
12B6C:  MOVFF  8DE,03
12B70:  MOVLB  8
12B72:  MOVFF  8DD,FE9
12B76:  MOVFF  8DE,FEA
12B7A:  MOVF   FEF,F
12B7C:  BZ    12B8A
12B7E:  INCF   xDD,F
12B80:  BTFSC  FD8.2
12B82:  INCF   xDE,F
12B84:  MOVLB  0
12B86:  BRA    12B6C
12B88:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12B8A:  MOVFF  8DA,03
12B8E:  MOVFF  8D9,FE9
12B92:  MOVFF  8DA,FEA
12B96:  MOVF   FEF,F
12B98:  BZ    12BD2
12B9A:  MOVF   xDC,F
12B9C:  BNZ   12BA4
12B9E:  MOVF   xDB,W
12BA0:  SUBLW  00
12BA2:  BC    12BD2
....................    { 
....................       *s = *s2; 
12BA4:  MOVFF  8D9,FE9
12BA8:  MOVFF  8DA,FEA
12BAC:  MOVFF  FEF,8E1
12BB0:  MOVFF  8DE,FEA
12BB4:  MOVFF  8DD,FE9
12BB8:  MOVFF  8E1,FEF
....................       ++s; 
12BBC:  INCF   xDD,F
12BBE:  BTFSC  FD8.2
12BC0:  INCF   xDE,F
....................       ++s2; 
12BC2:  INCF   xD9,F
12BC4:  BTFSC  FD8.2
12BC6:  INCF   xDA,F
....................       --n; 
12BC8:  MOVF   xDB,W
12BCA:  BTFSC  FD8.2
12BCC:  DECF   xDC,F
12BCE:  DECF   xDB,F
12BD0:  BRA    12B8A
....................    } 
....................  
....................    *s = '\0'; 
12BD2:  MOVFF  8DD,FE9
12BD6:  MOVFF  8DE,FEA
12BDA:  CLRF   FEF
....................    return(s1); 
12BDC:  MOVFF  8D7,01
12BE0:  MOVFF  8D8,02
12BE4:  MOVLB  0
12BE6:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
0466E:  MOVFF  9D4,9DA
04672:  MOVFF  9D3,9D9
04676:  MOVFF  9D6,9DC
0467A:  MOVFF  9D5,9DB
0467E:  MOVLB  9
04680:  MOVF   xD8,F
04682:  BNZ   468A
04684:  MOVF   xD7,W
04686:  SUBLW  00
04688:  BC    46EA
.................... { 
....................    if(*su1!=*su2) 
0468A:  MOVFF  9D9,FE9
0468E:  MOVFF  9DA,FEA
04692:  MOVFF  FEF,9DD
04696:  MOVFF  9DC,03
0469A:  MOVFF  9DB,FE9
0469E:  MOVFF  9DC,FEA
046A2:  MOVF   FEF,W
046A4:  SUBWF  xDD,W
046A6:  BZ    46D4
....................       return ((*su1<*su2)?-1:1); 
046A8:  MOVFF  9DA,03
046AC:  MOVFF  9D9,FE9
046B0:  MOVFF  03,FEA
046B4:  MOVFF  FEF,9DD
046B8:  MOVFF  9DC,03
046BC:  MOVFF  9DB,FE9
046C0:  MOVFF  9DC,FEA
046C4:  MOVF   FEF,W
046C6:  SUBWF  xDD,W
046C8:  BC    46CE
046CA:  MOVLW  FF
046CC:  BRA    46D0
046CE:  MOVLW  01
046D0:  MOVWF  01
046D2:  BRA    46EE
046D4:  INCF   xD9,F
046D6:  BTFSC  FD8.2
046D8:  INCF   xDA,F
046DA:  INCF   xDB,F
046DC:  BTFSC  FD8.2
046DE:  INCF   xDC,F
046E0:  MOVF   xD7,W
046E2:  BTFSC  FD8.2
046E4:  DECF   xD8,F
046E6:  DECF   xD7,F
046E8:  BRA    4680
.................... } 
.................... return 0; 
046EA:  MOVLW  00
046EC:  MOVWF  01
046EE:  MOVLB  0
046F0:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12B28:  MOVFF  8D6,8D8
12B2C:  MOVFF  8D5,8D7
12B30:  MOVFF  8D8,03
12B34:  MOVLB  8
12B36:  MOVFF  8D7,FE9
12B3A:  MOVFF  8D8,FEA
12B3E:  MOVF   FEF,F
12B40:  BZ    12B4E
12B42:  INCF   xD7,F
12B44:  BTFSC  FD8.2
12B46:  INCF   xD8,F
12B48:  MOVLB  0
12B4A:  BRA    12B30
12B4C:  MOVLB  8
....................    return(sc - s); 
12B4E:  MOVF   xD5,W
12B50:  SUBWF  xD7,W
12B52:  MOVWF  00
12B54:  MOVF   xD6,W
12B56:  SUBWFB xD8,W
12B58:  MOVWF  03
12B5A:  MOVFF  00,01
12B5E:  MOVWF  02
12B60:  MOVLB  0
12B62:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
131AA:  MOVLB  8
131AC:  CLRF   xC4
....................    sign = 0; 
131AE:  CLRF   xC2
....................    base = 10; 
131B0:  MOVLW  0A
131B2:  MOVWF  xC3
....................    result = 0; 
131B4:  CLRF   xC1
131B6:  CLRF   xC0
....................  
....................    if (!s) 
131B8:  MOVF   xBE,W
131BA:  IORWF  xBF,W
131BC:  BNZ   131C6
....................       return 0; 
131BE:  MOVLW  00
131C0:  MOVWF  01
131C2:  MOVWF  02
131C4:  BRA    1338A
....................    c = s[index++]; 
131C6:  MOVF   xC4,W
131C8:  INCF   xC4,F
131CA:  ADDWF  xBE,W
131CC:  MOVWF  FE9
131CE:  MOVLW  00
131D0:  ADDWFC xBF,W
131D2:  MOVWF  FEA
131D4:  MOVFF  FEF,8C5
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
131D8:  MOVF   xC5,W
131DA:  SUBLW  2D
131DC:  BNZ   131F6
....................    { 
....................       sign = 1;         // Set the sign to negative 
131DE:  MOVLW  01
131E0:  MOVWF  xC2
....................       c = s[index++]; 
131E2:  MOVF   xC4,W
131E4:  INCF   xC4,F
131E6:  ADDWF  xBE,W
131E8:  MOVWF  FE9
131EA:  MOVLW  00
131EC:  ADDWFC xBF,W
131EE:  MOVWF  FEA
131F0:  MOVFF  FEF,8C5
....................    } 
131F4:  BRA    1320E
....................    else if (c == '+') 
131F6:  MOVF   xC5,W
131F8:  SUBLW  2B
131FA:  BNZ   1320E
....................    { 
....................       c = s[index++]; 
131FC:  MOVF   xC4,W
131FE:  INCF   xC4,F
13200:  ADDWF  xBE,W
13202:  MOVWF  FE9
13204:  MOVLW  00
13206:  ADDWFC xBF,W
13208:  MOVWF  FEA
1320A:  MOVFF  FEF,8C5
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1320E:  MOVF   xC5,W
13210:  SUBLW  2F
13212:  BTFSC  FD8.0
13214:  BRA    1336E
13216:  MOVF   xC5,W
13218:  SUBLW  39
1321A:  BTFSS  FD8.0
1321C:  BRA    1336E
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1321E:  MOVF   xC5,W
13220:  SUBLW  30
13222:  BNZ   13260
13224:  MOVF   xC4,W
13226:  ADDWF  xBE,W
13228:  MOVWF  FE9
1322A:  MOVLW  00
1322C:  ADDWFC xBF,W
1322E:  MOVWF  FEA
13230:  MOVF   FEF,W
13232:  SUBLW  78
13234:  BZ    13248
13236:  MOVF   xC4,W
13238:  ADDWF  xBE,W
1323A:  MOVWF  FE9
1323C:  MOVLW  00
1323E:  ADDWFC xBF,W
13240:  MOVWF  FEA
13242:  MOVF   FEF,W
13244:  SUBLW  58
13246:  BNZ   13260
....................       { 
....................          base = 16; 
13248:  MOVLW  10
1324A:  MOVWF  xC3
....................          index++; 
1324C:  INCF   xC4,F
....................          c = s[index++]; 
1324E:  MOVF   xC4,W
13250:  INCF   xC4,F
13252:  ADDWF  xBE,W
13254:  MOVWF  FE9
13256:  MOVLW  00
13258:  ADDWFC xBF,W
1325A:  MOVWF  FEA
1325C:  MOVFF  FEF,8C5
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
13260:  MOVF   xC3,W
13262:  SUBLW  0A
13264:  BNZ   132AA
....................       { 
....................          while (c >= '0' && c <= '9') 
13266:  MOVF   xC5,W
13268:  SUBLW  2F
1326A:  BC    132A8
1326C:  MOVF   xC5,W
1326E:  SUBLW  39
13270:  BNC   132A8
....................          { 
....................             result = 10*result + (c - '0'); 
13272:  CLRF   xC7
13274:  MOVLW  0A
13276:  MOVWF  xC6
13278:  MOVFF  8C1,8C9
1327C:  MOVFF  8C0,8C8
13280:  MOVLB  0
13282:  BRA    13154
13284:  MOVLW  30
13286:  MOVLB  8
13288:  SUBWF  xC5,W
1328A:  ADDWF  01,W
1328C:  MOVWF  xC0
1328E:  MOVLW  00
13290:  ADDWFC 02,W
13292:  MOVWF  xC1
....................             c = s[index++]; 
13294:  MOVF   xC4,W
13296:  INCF   xC4,F
13298:  ADDWF  xBE,W
1329A:  MOVWF  FE9
1329C:  MOVLW  00
1329E:  ADDWFC xBF,W
132A0:  MOVWF  FEA
132A2:  MOVFF  FEF,8C5
132A6:  BRA    13266
....................          } 
....................       } 
132A8:  BRA    1336E
....................       else if (base == 16)    // The number is a hexa number 
132AA:  MOVF   xC3,W
132AC:  SUBLW  10
132AE:  BNZ   1336E
....................       { 
....................          c = toupper(c); 
132B0:  MOVF   xC5,W
132B2:  SUBLW  60
132B4:  BC    132C2
132B6:  MOVF   xC5,W
132B8:  SUBLW  7A
132BA:  BNC   132C2
132BC:  MOVF   xC5,W
132BE:  ANDLW  DF
132C0:  BRA    132C4
132C2:  MOVF   xC5,W
132C4:  MOVWF  xC5
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
132C6:  MOVF   xC5,W
132C8:  SUBLW  2F
132CA:  BC    132D2
132CC:  MOVF   xC5,W
132CE:  SUBLW  39
132D0:  BC    132DE
132D2:  MOVF   xC5,W
132D4:  SUBLW  40
132D6:  BC    1336E
132D8:  MOVF   xC5,W
132DA:  SUBLW  46
132DC:  BNC   1336E
....................          { 
....................             if (c >= '0' && c <= '9') 
132DE:  MOVF   xC5,W
132E0:  SUBLW  2F
132E2:  BC    13318
132E4:  MOVF   xC5,W
132E6:  SUBLW  39
132E8:  BNC   13318
....................                result = (result << 4) + (c - '0'); 
132EA:  RLCF   xC0,W
132EC:  MOVWF  xC6
132EE:  RLCF   xC1,W
132F0:  MOVWF  xC7
132F2:  RLCF   xC6,F
132F4:  RLCF   xC7,F
132F6:  RLCF   xC6,F
132F8:  RLCF   xC7,F
132FA:  RLCF   xC6,F
132FC:  RLCF   xC7,F
132FE:  MOVLW  F0
13300:  ANDWF  xC6,F
13302:  MOVLW  30
13304:  SUBWF  xC5,W
13306:  ADDWF  xC6,W
13308:  MOVWF  01
1330A:  MOVLW  00
1330C:  ADDWFC xC7,W
1330E:  MOVWF  03
13310:  MOVFF  01,8C0
13314:  MOVWF  xC1
13316:  BRA    13344
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
13318:  RLCF   xC0,W
1331A:  MOVWF  xC6
1331C:  RLCF   xC1,W
1331E:  MOVWF  xC7
13320:  RLCF   xC6,F
13322:  RLCF   xC7,F
13324:  RLCF   xC6,F
13326:  RLCF   xC7,F
13328:  RLCF   xC6,F
1332A:  RLCF   xC7,F
1332C:  MOVLW  F0
1332E:  ANDWF  xC6,F
13330:  MOVLW  41
13332:  SUBWF  xC5,W
13334:  ADDLW  0A
13336:  ADDWF  xC6,W
13338:  MOVWF  01
1333A:  MOVLW  00
1333C:  ADDWFC xC7,W
1333E:  MOVFF  01,8C0
13342:  MOVWF  xC1
....................  
....................             c = s[index++];c = toupper(c); 
13344:  MOVF   xC4,W
13346:  INCF   xC4,F
13348:  ADDWF  xBE,W
1334A:  MOVWF  FE9
1334C:  MOVLW  00
1334E:  ADDWFC xBF,W
13350:  MOVWF  FEA
13352:  MOVFF  FEF,8C5
13356:  MOVF   xC5,W
13358:  SUBLW  60
1335A:  BC    13368
1335C:  MOVF   xC5,W
1335E:  SUBLW  7A
13360:  BNC   13368
13362:  MOVF   xC5,W
13364:  ANDLW  DF
13366:  BRA    1336A
13368:  MOVF   xC5,W
1336A:  MOVWF  xC5
1336C:  BRA    132C6
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1336E:  MOVF   xC3,W
13370:  SUBLW  0A
13372:  BNZ   13382
13374:  DECFSZ xC2,W
13376:  BRA    13382
....................       result = -result; 
13378:  COMF   xC0,F
1337A:  COMF   xC1,F
1337C:  INCF   xC0,F
1337E:  BTFSC  FD8.2
13380:  INCF   xC1,F
....................  
....................    return(result); 
13382:  MOVFF  8C0,01
13386:  MOVFF  8C1,02
1338A:  MOVLB  0
1338C:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0C830:  MOVLB  8
0C832:  CLRF   x8E
0C834:  CLRF   x8D
0C836:  CLRF   x8C
0C838:  MOVLW  7F
0C83A:  MOVWF  x8B
0C83C:  CLRF   x92
0C83E:  CLRF   x91
0C840:  CLRF   x90
0C842:  CLRF   x8F
0C844:  BSF    x93.0
0C846:  BCF    x93.1
0C848:  BCF    x93.2
0C84A:  CLRF   x95
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0C84C:  MOVF   x87,W
0C84E:  IORWF  x88,W
0C850:  BNZ   C85C
....................       return 0; 
0C852:  CLRF   00
0C854:  CLRF   01
0C856:  CLRF   02
0C858:  CLRF   03
0C85A:  BRA    CA88
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0C85C:  MOVF   x95,W
0C85E:  INCF   x95,F
0C860:  ADDWF  x87,W
0C862:  MOVWF  FE9
0C864:  MOVLW  00
0C866:  ADDWFC x88,W
0C868:  MOVWF  FEA
0C86A:  MOVFF  FEF,894
0C86E:  MOVF   x94,F
0C870:  BTFSC  FD8.2
0C872:  BRA    CA08
....................    { 
....................       if (skip && !isspace(c)) 
0C874:  BTFSS  x93.0
0C876:  BRA    C896
0C878:  MOVF   x94,W
0C87A:  SUBLW  20
0C87C:  BZ    C896
....................       { 
....................          skip = 0; 
0C87E:  BCF    x93.0
....................          if (c == '+') 
0C880:  MOVF   x94,W
0C882:  SUBLW  2B
0C884:  BNZ   C88C
....................          { 
....................             sign = 0; 
0C886:  BCF    x93.1
....................             continue; 
0C888:  BRA    C9F0
....................          }             
0C88A:  BRA    C896
....................          else if (c == '-') 
0C88C:  MOVF   x94,W
0C88E:  SUBLW  2D
0C890:  BNZ   C896
....................          { 
....................             sign = 1; 
0C892:  BSF    x93.1
....................             continue; 
0C894:  BRA    C9F0
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0C896:  BTFSC  x93.0
0C898:  BRA    C8A8
0C89A:  MOVF   x94,W
0C89C:  SUBLW  2E
0C89E:  BNZ   C8A8
0C8A0:  BTFSC  x93.2
0C8A2:  BRA    C8A8
....................          point = 1; 
0C8A4:  BSF    x93.2
0C8A6:  BRA    C9F0
....................       else if (!skip && isdigit(c)) 
0C8A8:  BTFSC  x93.0
0C8AA:  BRA    C9EA
0C8AC:  MOVF   x94,W
0C8AE:  SUBLW  2F
0C8B0:  BTFSC  FD8.0
0C8B2:  BRA    C9EA
0C8B4:  MOVF   x94,W
0C8B6:  SUBLW  39
0C8B8:  BTFSS  FD8.0
0C8BA:  BRA    C9EA
....................       { 
....................          c -= '0'; 
0C8BC:  MOVLW  30
0C8BE:  SUBWF  x94,F
....................          if (point) 
0C8C0:  BTFSS  x93.2
0C8C2:  BRA    C96E
....................          { 
....................             pow10 = pow10 * 10.0; 
0C8C4:  MOVFF  88E,900
0C8C8:  MOVFF  88D,8FF
0C8CC:  MOVFF  88C,8FE
0C8D0:  MOVFF  88B,8FD
0C8D4:  MOVLB  9
0C8D6:  CLRF   x04
0C8D8:  CLRF   x03
0C8DA:  MOVLW  20
0C8DC:  MOVWF  x02
0C8DE:  MOVLW  82
0C8E0:  MOVWF  x01
0C8E2:  MOVLB  0
0C8E4:  CALL   C036
0C8E8:  MOVFF  03,88E
0C8EC:  MOVFF  02,88D
0C8F0:  MOVFF  01,88C
0C8F4:  MOVFF  00,88B
....................             result += (float)c / pow10;    
0C8F8:  MOVLB  9
0C8FA:  CLRF   x02
0C8FC:  MOVFF  894,901
0C900:  MOVLB  0
0C902:  RCALL  C69C
0C904:  MOVFF  03,899
0C908:  MOVFF  02,898
0C90C:  MOVFF  01,897
0C910:  MOVFF  00,896
0C914:  MOVFF  03,8E8
0C918:  MOVFF  02,8E7
0C91C:  MOVFF  01,8E6
0C920:  MOVFF  00,8E5
0C924:  MOVFF  88E,8EC
0C928:  MOVFF  88D,8EB
0C92C:  MOVFF  88C,8EA
0C930:  MOVFF  88B,8E9
0C934:  RCALL  C6D2
0C936:  BCF    FD8.1
0C938:  MOVFF  892,904
0C93C:  MOVFF  891,903
0C940:  MOVFF  890,902
0C944:  MOVFF  88F,901
0C948:  MOVFF  03,908
0C94C:  MOVFF  02,907
0C950:  MOVFF  01,906
0C954:  MOVFF  00,905
0C958:  RCALL  C160
0C95A:  MOVFF  03,892
0C95E:  MOVFF  02,891
0C962:  MOVFF  01,890
0C966:  MOVFF  00,88F
....................          } 
0C96A:  BRA    C9E6
0C96C:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0C96E:  MOVLB  9
0C970:  CLRF   x00
0C972:  MOVLB  8
0C974:  CLRF   xFF
0C976:  MOVLW  20
0C978:  MOVWF  xFE
0C97A:  MOVLW  82
0C97C:  MOVWF  xFD
0C97E:  MOVFF  892,904
0C982:  MOVFF  891,903
0C986:  MOVFF  890,902
0C98A:  MOVFF  88F,901
0C98E:  MOVLB  0
0C990:  CALL   C036
0C994:  MOVFF  03,899
0C998:  MOVFF  02,898
0C99C:  MOVFF  01,897
0C9A0:  MOVFF  00,896
0C9A4:  MOVLB  9
0C9A6:  CLRF   x02
0C9A8:  MOVFF  894,901
0C9AC:  MOVLB  0
0C9AE:  RCALL  C69C
0C9B0:  BCF    FD8.1
0C9B2:  MOVFF  899,904
0C9B6:  MOVFF  898,903
0C9BA:  MOVFF  897,902
0C9BE:  MOVFF  896,901
0C9C2:  MOVFF  03,908
0C9C6:  MOVFF  02,907
0C9CA:  MOVFF  01,906
0C9CE:  MOVFF  00,905
0C9D2:  CALL   C160
0C9D6:  MOVFF  03,892
0C9DA:  MOVFF  02,891
0C9DE:  MOVFF  01,890
0C9E2:  MOVFF  00,88F
....................          } 
....................       } 
0C9E6:  BRA    C9F2
0C9E8:  MOVLB  8
....................       else if (!skip) 
0C9EA:  BTFSC  x93.0
0C9EC:  BRA    C9F0
....................          break; 
0C9EE:  BRA    CA08
0C9F0:  MOVLB  0
0C9F2:  MOVLB  8
0C9F4:  MOVF   x95,W
0C9F6:  INCF   x95,F
0C9F8:  ADDWF  x87,W
0C9FA:  MOVWF  FE9
0C9FC:  MOVLW  00
0C9FE:  ADDWFC x88,W
0CA00:  MOVWF  FEA
0CA02:  MOVFF  FEF,894
0CA06:  BRA    C86E
....................    } 
....................  
....................    if (sign) 
0CA08:  BTFSS  x93.1
0CA0A:  BRA    CA44
....................       result = -1*result; 
0CA0C:  MOVLB  9
0CA0E:  CLRF   x00
0CA10:  MOVLB  8
0CA12:  CLRF   xFF
0CA14:  MOVLW  80
0CA16:  MOVWF  xFE
0CA18:  MOVLW  7F
0CA1A:  MOVWF  xFD
0CA1C:  MOVFF  892,904
0CA20:  MOVFF  891,903
0CA24:  MOVFF  890,902
0CA28:  MOVFF  88F,901
0CA2C:  MOVLB  0
0CA2E:  CALL   C036
0CA32:  MOVFF  03,892
0CA36:  MOVFF  02,891
0CA3A:  MOVFF  01,890
0CA3E:  MOVFF  00,88F
0CA42:  MOVLB  8
....................        
....................    if(endptr) 
0CA44:  MOVF   x89,W
0CA46:  IORWF  x8A,W
0CA48:  BZ    CA78
....................    { 
....................       if (ptr) { 
0CA4A:  MOVF   x95,F
0CA4C:  BZ    CA66
....................          ptr--; 
0CA4E:  DECF   x95,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0CA50:  MOVFF  889,FE9
0CA54:  MOVFF  88A,FEA
0CA58:  MOVF   x95,W
0CA5A:  ADDWF  x87,W
0CA5C:  MOVWF  FEF
0CA5E:  MOVLW  00
0CA60:  ADDWFC x88,W
0CA62:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0CA64:  BRA    CA78
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0CA66:  MOVFF  889,FE9
0CA6A:  MOVFF  88A,FEA
0CA6E:  MOVFF  888,FEC
0CA72:  MOVF   FED,F
0CA74:  MOVFF  887,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0CA78:  MOVFF  88F,00
0CA7C:  MOVFF  890,01
0CA80:  MOVFF  891,02
0CA84:  MOVFF  892,03
0CA88:  MOVLB  0
0CA8A:  GOTO   CAB2 (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
125F0:  MOVLB  8
125F2:  BCF    xFC.0
....................    y = x; 
125F4:  MOVFF  8F0,8F5
125F8:  MOVFF  8EF,8F4
125FC:  MOVFF  8EE,8F3
12600:  MOVFF  8ED,8F2
....................  
....................    if (x < 0) 
12604:  MOVFF  8F0,900
12608:  MOVFF  8EF,8FF
1260C:  MOVFF  8EE,8FE
12610:  MOVFF  8ED,8FD
12614:  MOVLB  9
12616:  CLRF   x04
12618:  CLRF   x03
1261A:  CLRF   x02
1261C:  CLRF   x01
1261E:  MOVLB  0
12620:  CALL   104EC
12624:  BNC   12632
....................    { 
....................       s = 1; 
12626:  MOVLB  8
12628:  BSF    xFC.0
....................       y = -y; 
1262A:  MOVF   xF3,W
1262C:  XORLW  80
1262E:  MOVWF  xF3
12630:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
12632:  MOVFF  8F5,900
12636:  MOVFF  8F4,8FF
1263A:  MOVFF  8F3,8FE
1263E:  MOVFF  8F2,8FD
12642:  MOVLB  9
12644:  CLRF   x04
12646:  CLRF   x03
12648:  CLRF   x02
1264A:  MOVLW  8E
1264C:  MOVWF  x01
1264E:  MOVLB  0
12650:  CALL   104EC
12654:  BC    12658
12656:  BNZ   12688
....................       res = (float32)(unsigned int16)y; 
12658:  MOVFF  8F5,900
1265C:  MOVFF  8F4,8FF
12660:  MOVFF  8F3,8FE
12664:  MOVFF  8F2,8FD
12668:  RCALL  125B4
1266A:  MOVFF  02,902
1266E:  MOVFF  01,901
12672:  CALL   C69C
12676:  MOVFF  03,8F9
1267A:  MOVFF  02,8F8
1267E:  MOVFF  01,8F7
12682:  MOVFF  00,8F6
12686:  BRA    1282E
....................  
....................  else if (y < 10000000.0) 
12688:  MOVFF  8F5,900
1268C:  MOVFF  8F4,8FF
12690:  MOVFF  8F3,8FE
12694:  MOVFF  8F2,8FD
12698:  MOVLW  80
1269A:  MOVLB  9
1269C:  MOVWF  x04
1269E:  MOVLW  96
126A0:  MOVWF  x03
126A2:  MOVLW  18
126A4:  MOVWF  x02
126A6:  MOVLW  96
126A8:  MOVWF  x01
126AA:  MOVLB  0
126AC:  CALL   104EC
126B0:  BTFSS  FD8.0
126B2:  BRA    1281E
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
126B4:  MOVFF  8F5,900
126B8:  MOVFF  8F4,8FF
126BC:  MOVFF  8F3,8FE
126C0:  MOVFF  8F2,8FD
126C4:  MOVLB  9
126C6:  CLRF   x04
126C8:  CLRF   x03
126CA:  CLRF   x02
126CC:  MOVLW  70
126CE:  MOVWF  x01
126D0:  MOVLB  0
126D2:  CALL   C036
126D6:  MOVFF  03,900
126DA:  MOVFF  02,8FF
126DE:  MOVFF  01,8FE
126E2:  MOVFF  00,8FD
126E6:  RCALL  125B4
126E8:  MOVFF  02,8FB
126EC:  MOVFF  01,8FA
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
126F0:  MOVFF  8F5,900
126F4:  MOVFF  8F4,8FF
126F8:  MOVFF  8F3,8FE
126FC:  MOVFF  8F2,8FD
12700:  MOVLB  9
12702:  CLRF   x04
12704:  CLRF   x03
12706:  CLRF   x02
12708:  MOVLW  70
1270A:  MOVWF  x01
1270C:  MOVLB  0
1270E:  CALL   C036
12712:  MOVFF  03,900
12716:  MOVFF  02,8FF
1271A:  MOVFF  01,8FE
1271E:  MOVFF  00,8FD
12722:  MOVFF  8FB,902
12726:  MOVFF  8FA,901
1272A:  CALL   C69C
1272E:  BSF    FD8.1
12730:  MOVFF  900,904
12734:  MOVFF  8FF,903
12738:  MOVFF  8FE,902
1273C:  MOVFF  8FD,901
12740:  MOVFF  03,908
12744:  MOVFF  02,907
12748:  MOVFF  01,906
1274C:  MOVFF  00,905
12750:  CALL   C160
12754:  MOVLB  9
12756:  CLRF   x00
12758:  MOVLB  8
1275A:  CLRF   xFF
1275C:  CLRF   xFE
1275E:  MOVLW  8E
12760:  MOVWF  xFD
12762:  MOVFF  03,904
12766:  MOVFF  02,903
1276A:  MOVFF  01,902
1276E:  MOVFF  00,901
12772:  MOVLB  0
12774:  CALL   C036
12778:  MOVFF  03,8F5
1277C:  MOVFF  02,8F4
12780:  MOVFF  01,8F3
12784:  MOVFF  00,8F2
....................       res = 32768.0*(float32)l; 
12788:  MOVFF  8FB,902
1278C:  MOVFF  8FA,901
12790:  CALL   C69C
12794:  MOVLB  9
12796:  CLRF   x00
12798:  MOVLB  8
1279A:  CLRF   xFF
1279C:  CLRF   xFE
1279E:  MOVLW  8E
127A0:  MOVWF  xFD
127A2:  MOVFF  03,904
127A6:  MOVFF  02,903
127AA:  MOVFF  01,902
127AE:  MOVFF  00,901
127B2:  MOVLB  0
127B4:  CALL   C036
127B8:  MOVFF  03,8F9
127BC:  MOVFF  02,8F8
127C0:  MOVFF  01,8F7
127C4:  MOVFF  00,8F6
....................       res += (float32)(unsigned int16)y; 
127C8:  MOVFF  8F5,900
127CC:  MOVFF  8F4,8FF
127D0:  MOVFF  8F3,8FE
127D4:  MOVFF  8F2,8FD
127D8:  RCALL  125B4
127DA:  MOVFF  02,902
127DE:  MOVFF  01,901
127E2:  CALL   C69C
127E6:  BCF    FD8.1
127E8:  MOVFF  8F9,904
127EC:  MOVFF  8F8,903
127F0:  MOVFF  8F7,902
127F4:  MOVFF  8F6,901
127F8:  MOVFF  03,908
127FC:  MOVFF  02,907
12800:  MOVFF  01,906
12804:  MOVFF  00,905
12808:  CALL   C160
1280C:  MOVFF  03,8F9
12810:  MOVFF  02,8F8
12814:  MOVFF  01,8F7
12818:  MOVFF  00,8F6
....................    } 
1281C:  BRA    1282E
....................  
....................  else 
....................   res = y; 
1281E:  MOVFF  8F5,8F9
12822:  MOVFF  8F4,8F8
12826:  MOVFF  8F3,8F7
1282A:  MOVFF  8F2,8F6
....................  
....................  y = y - (float32)(unsigned int16)y; 
1282E:  MOVFF  8F5,900
12832:  MOVFF  8F4,8FF
12836:  MOVFF  8F3,8FE
1283A:  MOVFF  8F2,8FD
1283E:  RCALL  125B4
12840:  MOVFF  02,902
12844:  MOVFF  01,901
12848:  CALL   C69C
1284C:  BSF    FD8.1
1284E:  MOVFF  8F5,904
12852:  MOVFF  8F4,903
12856:  MOVFF  8F3,902
1285A:  MOVFF  8F2,901
1285E:  MOVFF  03,908
12862:  MOVFF  02,907
12866:  MOVFF  01,906
1286A:  MOVFF  00,905
1286E:  CALL   C160
12872:  MOVFF  03,8F5
12876:  MOVFF  02,8F4
1287A:  MOVFF  01,8F3
1287E:  MOVFF  00,8F2
....................  
....................  if (s) 
12882:  MOVLB  8
12884:  BTFSS  xFC.0
12886:  BRA    1288E
....................   res = -res; 
12888:  MOVF   xF7,W
1288A:  XORLW  80
1288C:  MOVWF  xF7
....................  
....................  if (y != 0) 
1288E:  MOVFF  8F5,900
12892:  MOVFF  8F4,8FF
12896:  MOVFF  8F3,8FE
1289A:  MOVFF  8F2,8FD
1289E:  MOVLB  9
128A0:  CLRF   x04
128A2:  CLRF   x03
128A4:  CLRF   x02
128A6:  CLRF   x01
128A8:  MOVLB  0
128AA:  CALL   104EC
128AE:  BZ    1292C
....................  { 
....................   if (s == 1 && n == 0) 
128B0:  MOVLB  8
128B2:  BTFSS  xFC.0
128B4:  BRA    128F0
128B6:  MOVF   xF1,F
128B8:  BNZ   128F0
....................    res -= 1.0; 
128BA:  BSF    FD8.1
128BC:  MOVFF  8F9,904
128C0:  MOVFF  8F8,903
128C4:  MOVFF  8F7,902
128C8:  MOVFF  8F6,901
128CC:  MOVLB  9
128CE:  CLRF   x08
128D0:  CLRF   x07
128D2:  CLRF   x06
128D4:  MOVLW  7F
128D6:  MOVWF  x05
128D8:  MOVLB  0
128DA:  CALL   C160
128DE:  MOVFF  03,8F9
128E2:  MOVFF  02,8F8
128E6:  MOVFF  01,8F7
128EA:  MOVFF  00,8F6
128EE:  MOVLB  8
....................  
....................   if (s == 0 && n == 1) 
128F0:  BTFSC  xFC.0
128F2:  BRA    1292E
128F4:  DECFSZ xF1,W
128F6:  BRA    1292E
....................    res += 1.0; 
128F8:  BCF    FD8.1
128FA:  MOVFF  8F9,904
128FE:  MOVFF  8F8,903
12902:  MOVFF  8F7,902
12906:  MOVFF  8F6,901
1290A:  MOVLB  9
1290C:  CLRF   x08
1290E:  CLRF   x07
12910:  CLRF   x06
12912:  MOVLW  7F
12914:  MOVWF  x05
12916:  MOVLB  0
12918:  CALL   C160
1291C:  MOVFF  03,8F9
12920:  MOVFF  02,8F8
12924:  MOVFF  01,8F7
12928:  MOVFF  00,8F6
1292C:  MOVLB  8
....................  } 
....................  if (x == 0) 
1292E:  MOVFF  8F0,900
12932:  MOVFF  8EF,8FF
12936:  MOVFF  8EE,8FE
1293A:  MOVFF  8ED,8FD
1293E:  MOVLB  9
12940:  CLRF   x04
12942:  CLRF   x03
12944:  CLRF   x02
12946:  CLRF   x01
12948:  MOVLB  0
1294A:  CALL   104EC
1294E:  BNZ   1295C
....................     res = 0; 
12950:  MOVLB  8
12952:  CLRF   xF9
12954:  CLRF   xF8
12956:  CLRF   xF7
12958:  CLRF   xF6
1295A:  MOVLB  0
....................  
....................  return (res); 
1295C:  MOVFF  8F6,00
12960:  MOVFF  8F7,01
12964:  MOVFF  8F8,02
12968:  MOVFF  8F9,03
1296C:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
1298C:  MOVFF  8EC,8F0
12990:  MOVFF  8EB,8EF
12994:  MOVFF  8EA,8EE
12998:  MOVFF  8E9,8ED
1299C:  MOVLB  8
1299E:  CLRF   xF1
129A0:  MOVLB  0
129A2:  RCALL  125F0
129A4:  GOTO   12AB0 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
1296E:  MOVFF  8EC,8F0
12972:  MOVFF  8EB,8EF
12976:  MOVFF  8EA,8EE
1297A:  MOVFF  8E9,8ED
1297E:  MOVLW  01
12980:  MOVLB  8
12982:  MOVWF  xF1
12984:  MOVLB  0
12986:  RCALL  125F0
12988:  GOTO   12A68 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
129A8:  MOVFF  8E0,900
129AC:  MOVFF  8DF,8FF
129B0:  MOVFF  8DE,8FE
129B4:  MOVFF  8DD,8FD
129B8:  MOVLB  9
129BA:  CLRF   x04
129BC:  CLRF   x03
129BE:  CLRF   x02
129C0:  CLRF   x01
129C2:  MOVLB  0
129C4:  CALL   104EC
129C8:  BTFSC  FD8.2
129CA:  BRA    12B0C
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
129CC:  MOVFF  8DC,8E8
129D0:  MOVFF  8DB,8E7
129D4:  MOVFF  8DA,8E6
129D8:  MOVFF  8D9,8E5
129DC:  MOVFF  8E0,8EC
129E0:  MOVFF  8DF,8EB
129E4:  MOVFF  8DE,8EA
129E8:  MOVFF  8DD,8E9
129EC:  CALL   C6D2
129F0:  MOVFF  03,8E8
129F4:  MOVFF  02,8E7
129F8:  MOVFF  01,8E6
129FC:  MOVFF  00,8E5
12A00:  MOVFF  03,900
12A04:  MOVFF  02,8FF
12A08:  MOVFF  01,8FE
12A0C:  MOVFF  00,8FD
12A10:  MOVLB  9
12A12:  CLRF   x04
12A14:  CLRF   x03
12A16:  CLRF   x02
12A18:  CLRF   x01
12A1A:  MOVLB  0
12A1C:  CALL   104EC
12A20:  BNC   12A6A
12A22:  MOVFF  8DC,8E8
12A26:  MOVFF  8DB,8E7
12A2A:  MOVFF  8DA,8E6
12A2E:  MOVFF  8D9,8E5
12A32:  MOVFF  8E0,8EC
12A36:  MOVFF  8DF,8EB
12A3A:  MOVFF  8DE,8EA
12A3E:  MOVFF  8DD,8E9
12A42:  CALL   C6D2
12A46:  MOVFF  03,8E8
12A4A:  MOVFF  02,8E7
12A4E:  MOVFF  01,8E6
12A52:  MOVFF  00,8E5
12A56:  MOVFF  03,8EC
12A5A:  MOVFF  02,8EB
12A5E:  MOVFF  01,8EA
12A62:  MOVFF  00,8E9
12A66:  BRA    1296E
12A68:  BRA    12AB0
12A6A:  MOVFF  8DC,8E8
12A6E:  MOVFF  8DB,8E7
12A72:  MOVFF  8DA,8E6
12A76:  MOVFF  8D9,8E5
12A7A:  MOVFF  8E0,8EC
12A7E:  MOVFF  8DF,8EB
12A82:  MOVFF  8DE,8EA
12A86:  MOVFF  8DD,8E9
12A8A:  CALL   C6D2
12A8E:  MOVFF  03,8E8
12A92:  MOVFF  02,8E7
12A96:  MOVFF  01,8E6
12A9A:  MOVFF  00,8E5
12A9E:  MOVFF  03,8EC
12AA2:  MOVFF  02,8EB
12AA6:  MOVFF  01,8EA
12AAA:  MOVFF  00,8E9
12AAE:  BRA    1298C
12AB0:  MOVFF  03,8E4
12AB4:  MOVFF  02,8E3
12AB8:  MOVFF  01,8E2
12ABC:  MOVFF  00,8E1
....................       return(x-(i*y)); 
12AC0:  MOVFF  8E4,900
12AC4:  MOVFF  8E3,8FF
12AC8:  MOVFF  8E2,8FE
12ACC:  MOVFF  8E1,8FD
12AD0:  MOVFF  8E0,904
12AD4:  MOVFF  8DF,903
12AD8:  MOVFF  8DE,902
12ADC:  MOVFF  8DD,901
12AE0:  CALL   C036
12AE4:  BSF    FD8.1
12AE6:  MOVFF  8DC,904
12AEA:  MOVFF  8DB,903
12AEE:  MOVFF  8DA,902
12AF2:  MOVFF  8D9,901
12AF6:  MOVFF  03,908
12AFA:  MOVFF  02,907
12AFE:  MOVFF  01,906
12B02:  MOVFF  00,905
12B06:  CALL   C160
12B0A:  BRA    12B0C
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12B0C:  GOTO   12DA4 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
105E2:  MOVFF  8C4,8C8
105E6:  MOVFF  8C3,8C7
105EA:  MOVFF  8C2,8C6
105EE:  MOVFF  8C1,8C5
....................  
....................    if (y != 1.0) 
105F2:  MOVFF  8C8,900
105F6:  MOVFF  8C7,8FF
105FA:  MOVFF  8C6,8FE
105FE:  MOVFF  8C5,8FD
10602:  MOVLB  9
10604:  CLRF   x04
10606:  CLRF   x03
10608:  CLRF   x02
1060A:  MOVLW  7F
1060C:  MOVWF  x01
1060E:  MOVLB  0
10610:  RCALL  104EC
10612:  BTFSC  FD8.2
10614:  BRA    1095A
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
10616:  MOVLW  08
10618:  MOVLB  8
1061A:  MOVWF  xD7
1061C:  MOVLW  C5
1061E:  MOVWF  FE9
10620:  MOVFF  8D7,FEA
10624:  MOVLW  7E
10626:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
10628:  BSF    FD8.1
1062A:  MOVFF  8C8,904
1062E:  MOVFF  8C7,903
10632:  MOVFF  8C6,902
10636:  MOVFF  8C5,901
1063A:  MOVLB  9
1063C:  CLRF   x08
1063E:  CLRF   x07
10640:  CLRF   x06
10642:  MOVLW  7F
10644:  MOVWF  x05
10646:  MOVLB  0
10648:  CALL   C160
1064C:  MOVFF  03,8D9
10650:  MOVFF  02,8D8
10654:  MOVFF  01,8D7
10658:  MOVFF  00,8D6
1065C:  BCF    FD8.1
1065E:  MOVFF  8C8,904
10662:  MOVFF  8C7,903
10666:  MOVFF  8C6,902
1066A:  MOVFF  8C5,901
1066E:  MOVLB  9
10670:  CLRF   x08
10672:  CLRF   x07
10674:  CLRF   x06
10676:  MOVLW  7F
10678:  MOVWF  x05
1067A:  MOVLB  0
1067C:  CALL   C160
10680:  MOVFF  8D9,8E8
10684:  MOVFF  8D8,8E7
10688:  MOVFF  8D7,8E6
1068C:  MOVFF  8D6,8E5
10690:  MOVFF  03,8EC
10694:  MOVFF  02,8EB
10698:  MOVFF  01,8EA
1069C:  MOVFF  00,8E9
106A0:  CALL   C6D2
106A4:  MOVFF  03,8C8
106A8:  MOVFF  02,8C7
106AC:  MOVFF  01,8C6
106B0:  MOVFF  00,8C5
....................  
....................       y2=y*y; 
106B4:  MOVFF  8C8,900
106B8:  MOVFF  8C7,8FF
106BC:  MOVFF  8C6,8FE
106C0:  MOVFF  8C5,8FD
106C4:  MOVFF  8C8,904
106C8:  MOVFF  8C7,903
106CC:  MOVFF  8C6,902
106D0:  MOVFF  8C5,901
106D4:  CALL   C036
106D8:  MOVFF  03,8D4
106DC:  MOVFF  02,8D3
106E0:  MOVFF  01,8D2
106E4:  MOVFF  00,8D1
....................  
....................       res = pl[0]*y2 + pl[1]; 
106E8:  MOVLW  99
106EA:  MOVLB  9
106EC:  MOVWF  x00
106EE:  MOVLW  47
106F0:  MOVLB  8
106F2:  MOVWF  xFF
106F4:  MOVLW  8A
106F6:  MOVWF  xFE
106F8:  MOVLW  7F
106FA:  MOVWF  xFD
106FC:  MOVFF  8D4,904
10700:  MOVFF  8D3,903
10704:  MOVFF  8D2,902
10708:  MOVFF  8D1,901
1070C:  MOVLB  0
1070E:  CALL   C036
10712:  MOVFF  03,8D9
10716:  MOVFF  02,8D8
1071A:  MOVFF  01,8D7
1071E:  MOVFF  00,8D6
10722:  BCF    FD8.1
10724:  MOVFF  03,904
10728:  MOVFF  02,903
1072C:  MOVFF  01,902
10730:  MOVFF  00,901
10734:  MOVLB  9
10736:  CLRF   x08
10738:  CLRF   x07
1073A:  CLRF   x06
1073C:  MOVLW  80
1073E:  MOVWF  x05
10740:  MOVLB  0
10742:  CALL   C160
10746:  MOVFF  03,8CC
1074A:  MOVFF  02,8CB
1074E:  MOVFF  01,8CA
10752:  MOVFF  00,8C9
....................  
....................       r = ql[0]*y2 + ql[1]; 
10756:  MOVLW  4C
10758:  MOVLB  9
1075A:  MOVWF  x00
1075C:  MOVLW  F3
1075E:  MOVLB  8
10760:  MOVWF  xFF
10762:  MOVLW  3A
10764:  MOVWF  xFE
10766:  MOVLW  7B
10768:  MOVWF  xFD
1076A:  MOVFF  8D4,904
1076E:  MOVFF  8D3,903
10772:  MOVFF  8D2,902
10776:  MOVFF  8D1,901
1077A:  MOVLB  0
1077C:  CALL   C036
10780:  MOVFF  03,8D9
10784:  MOVFF  02,8D8
10788:  MOVFF  01,8D7
1078C:  MOVFF  00,8D6
10790:  BCF    FD8.1
10792:  MOVFF  03,904
10796:  MOVFF  02,903
1079A:  MOVFF  01,902
1079E:  MOVFF  00,901
107A2:  MOVLW  2B
107A4:  MOVLB  9
107A6:  MOVWF  x08
107A8:  MOVLW  9D
107AA:  MOVWF  x07
107AC:  MOVLW  DF
107AE:  MOVWF  x06
107B0:  MOVLW  7E
107B2:  MOVWF  x05
107B4:  MOVLB  0
107B6:  CALL   C160
107BA:  MOVFF  03,8D0
107BE:  MOVFF  02,8CF
107C2:  MOVFF  01,8CE
107C6:  MOVFF  00,8CD
....................       r = r*y2 + 1.0; 
107CA:  MOVFF  8D0,900
107CE:  MOVFF  8CF,8FF
107D2:  MOVFF  8CE,8FE
107D6:  MOVFF  8CD,8FD
107DA:  MOVFF  8D4,904
107DE:  MOVFF  8D3,903
107E2:  MOVFF  8D2,902
107E6:  MOVFF  8D1,901
107EA:  CALL   C036
107EE:  MOVFF  03,8D9
107F2:  MOVFF  02,8D8
107F6:  MOVFF  01,8D7
107FA:  MOVFF  00,8D6
107FE:  BCF    FD8.1
10800:  MOVFF  03,904
10804:  MOVFF  02,903
10808:  MOVFF  01,902
1080C:  MOVFF  00,901
10810:  MOVLB  9
10812:  CLRF   x08
10814:  CLRF   x07
10816:  CLRF   x06
10818:  MOVLW  7F
1081A:  MOVWF  x05
1081C:  MOVLB  0
1081E:  CALL   C160
10822:  MOVFF  03,8D0
10826:  MOVFF  02,8CF
1082A:  MOVFF  01,8CE
1082E:  MOVFF  00,8CD
....................  
....................       res = y*res/r; 
10832:  MOVFF  8C8,900
10836:  MOVFF  8C7,8FF
1083A:  MOVFF  8C6,8FE
1083E:  MOVFF  8C5,8FD
10842:  MOVFF  8CC,904
10846:  MOVFF  8CB,903
1084A:  MOVFF  8CA,902
1084E:  MOVFF  8C9,901
10852:  CALL   C036
10856:  MOVFF  03,8D9
1085A:  MOVFF  02,8D8
1085E:  MOVFF  01,8D7
10862:  MOVFF  00,8D6
10866:  MOVFF  03,8E8
1086A:  MOVFF  02,8E7
1086E:  MOVFF  01,8E6
10872:  MOVFF  00,8E5
10876:  MOVFF  8D0,8EC
1087A:  MOVFF  8CF,8EB
1087E:  MOVFF  8CE,8EA
10882:  MOVFF  8CD,8E9
10886:  CALL   C6D2
1088A:  MOVFF  03,8CC
1088E:  MOVFF  02,8CB
10892:  MOVFF  01,8CA
10896:  MOVFF  00,8C9
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
1089A:  MOVLW  08
1089C:  MOVLB  8
1089E:  MOVWF  xD7
108A0:  MOVLW  C1
108A2:  MOVWF  FE9
108A4:  MOVFF  8D7,FEA
108A8:  MOVLW  7E
108AA:  SUBWF  FEF,W
108AC:  MOVWF  xD5
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
108AE:  BTFSS  xD5.7
108B0:  BRA    108DA
....................          r = -(float32)-n; 
108B2:  MOVLW  00
108B4:  BSF    FD8.0
108B6:  SUBFWB xD5,W
108B8:  CLRF   xD7
108BA:  MOVWF  xD6
108BC:  BTFSC  xD6.7
108BE:  DECF   xD7,F
108C0:  MOVLB  0
108C2:  RCALL  10592
108C4:  MOVFF  00,8CD
108C8:  MOVF   01,W
108CA:  XORLW  80
108CC:  MOVLB  8
108CE:  MOVWF  xCE
108D0:  MOVFF  02,8CF
108D4:  MOVFF  03,8D0
108D8:  BRA    108FA
....................       else 
....................          r = (float32)n; 
108DA:  CLRF   xD7
108DC:  MOVFF  8D5,8D6
108E0:  BTFSC  xD6.7
108E2:  DECF   xD7,F
108E4:  MOVLB  0
108E6:  RCALL  10592
108E8:  MOVFF  03,8D0
108EC:  MOVFF  02,8CF
108F0:  MOVFF  01,8CE
108F4:  MOVFF  00,8CD
108F8:  MOVLB  8
....................  
....................       res += r*LN2; 
108FA:  MOVFF  8D0,900
108FE:  MOVFF  8CF,8FF
10902:  MOVFF  8CE,8FE
10906:  MOVFF  8CD,8FD
1090A:  MOVLW  18
1090C:  MOVLB  9
1090E:  MOVWF  x04
10910:  MOVLW  72
10912:  MOVWF  x03
10914:  MOVLW  31
10916:  MOVWF  x02
10918:  MOVLW  7E
1091A:  MOVWF  x01
1091C:  MOVLB  0
1091E:  CALL   C036
10922:  BCF    FD8.1
10924:  MOVFF  8CC,904
10928:  MOVFF  8CB,903
1092C:  MOVFF  8CA,902
10930:  MOVFF  8C9,901
10934:  MOVFF  03,908
10938:  MOVFF  02,907
1093C:  MOVFF  01,906
10940:  MOVFF  00,905
10944:  CALL   C160
10948:  MOVFF  03,8CC
1094C:  MOVFF  02,8CB
10950:  MOVFF  01,8CA
10954:  MOVFF  00,8C9
....................    } 
10958:  BRA    10966
....................  
....................    else 
....................       res = 0.0; 
1095A:  MOVLB  8
1095C:  CLRF   xCC
1095E:  CLRF   xCB
10960:  CLRF   xCA
10962:  CLRF   xC9
10964:  MOVLB  0
....................  
....................    return(res); 
10966:  MOVFF  8C9,00
1096A:  MOVFF  8CA,01
1096E:  MOVFF  8CB,02
10972:  MOVFF  8CC,03
10976:  GOTO   1098C (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
1097A:  MOVFF  8BC,8C4
1097E:  MOVFF  8BB,8C3
10982:  MOVFF  8BA,8C2
10986:  MOVFF  8B9,8C1
1098A:  BRA    105E2
1098C:  MOVFF  03,8C0
10990:  MOVFF  02,8BF
10994:  MOVFF  01,8BE
10998:  MOVFF  00,8BD
....................    r = r*LN10_INV; 
1099C:  MOVFF  8C0,900
109A0:  MOVFF  8BF,8FF
109A4:  MOVFF  8BE,8FE
109A8:  MOVFF  8BD,8FD
109AC:  MOVLW  D9
109AE:  MOVLB  9
109B0:  MOVWF  x04
109B2:  MOVLW  5B
109B4:  MOVWF  x03
109B6:  MOVLW  5E
109B8:  MOVWF  x02
109BA:  MOVLW  7D
109BC:  MOVWF  x01
109BE:  MOVLB  0
109C0:  CALL   C036
109C4:  MOVFF  03,8C0
109C8:  MOVFF  02,8BF
109CC:  MOVFF  01,8BE
109D0:  MOVFF  00,8BD
....................    return(r); 
109D4:  MOVFF  8BD,00
109D8:  MOVFF  8BE,01
109DC:  MOVFF  8BF,02
109E0:  MOVFF  8C0,03
109E4:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
0FFE8:  BCF    FC6.5
0FFEA:  MOVLW  21
0FFEC:  MOVWF  FC6
0FFEE:  MOVLW  40
0FFF0:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
0FFF2:  BSF    F91.2
....................    output_high(EEP_WP); 
0FFF4:  BSF    F91.3
0FFF6:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
*
10354:  BCF    F91.2
....................    spi_write(0x05);  
10356:  MOVF   FC9,W
10358:  MOVLW  05
1035A:  MOVWF  FC9
1035C:  RRCF   FC7,W
1035E:  BNC   1035C
....................    data = spi_read(0);  
10360:  MOVF   FC9,W
10362:  CLRF   FC9
10364:  RRCF   FC7,W
10366:  BNC   10364
10368:  MOVFF  FC9,8B8
....................    output_high(EEP_CS);  
1036C:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
1036E:  MOVLW  00
10370:  MOVLB  8
10372:  BTFSS  xB8.0
10374:  MOVLW  01
10376:  MOVWF  01
10378:  MOVLB  0
1037A:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
17C28:  MOVLB  8
17C2A:  CLRF   xD7
17C2C:  MOVLB  0
17C2E:  CALL   55DA
....................       while(!ext_eeprom_ready()); 
17C32:  CALL   10354
17C36:  MOVF   01,F
17C38:  BZ    17C32
....................     
....................       output_low(EEP_CS);  
17C3A:  BCF    F91.2
....................       spi_write(0x06);  
17C3C:  MOVF   FC9,W
17C3E:  MOVLW  06
17C40:  MOVWF  FC9
17C42:  RRCF   FC7,W
17C44:  BNC   17C42
....................       output_high(EEP_CS);  
17C46:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
17C48:  BCF    F91.2
....................       spi_write(0x02);  
17C4A:  MOVF   FC9,W
17C4C:  MOVLW  02
17C4E:  MOVWF  FC9
17C50:  RRCF   FC7,W
17C52:  BNC   17C50
....................       spi_write(address >> 8);  
17C54:  MOVFF  892,894
17C58:  MOVLB  8
17C5A:  CLRF   x95
17C5C:  MOVF   FC9,W
17C5E:  MOVFF  892,FC9
17C62:  RRCF   FC7,W
17C64:  BNC   17C62
....................       spi_write(address);  
17C66:  MOVF   FC9,W
17C68:  MOVFF  891,FC9
17C6C:  RRCF   FC7,W
17C6E:  BNC   17C6C
....................       spi_write(data);  
17C70:  MOVF   FC9,W
17C72:  MOVFF  893,FC9
17C76:  RRCF   FC7,W
17C78:  BNC   17C76
....................       output_high(EEP_CS);  
17C7A:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
17C7C:  MOVLW  01
17C7E:  MOVWF  xD7
17C80:  MOVLB  0
17C82:  CALL   55DA
17C86:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
1037C:  MOVLB  8
1037E:  CLRF   xD7
10380:  MOVLB  0
10382:  CALL   55DA
....................     
....................       while(!ext_eeprom_ready()); 
10386:  RCALL  10354
10388:  MOVF   01,F
1038A:  BZ    10386
....................        
....................       output_low(EEP_CS);  
1038C:  BCF    F91.2
....................       spi_write(0x03);  
1038E:  MOVF   FC9,W
10390:  MOVLW  03
10392:  MOVWF  FC9
10394:  RRCF   FC7,W
10396:  BNC   10394
....................       spi_write(address >> 8);  
10398:  MOVFF  8B6,8B8
1039C:  MOVLB  8
1039E:  CLRF   xB9
103A0:  MOVF   FC9,W
103A2:  MOVFF  8B6,FC9
103A6:  RRCF   FC7,W
103A8:  BNC   103A6
....................       spi_write(address);  
103AA:  MOVF   FC9,W
103AC:  MOVFF  8B5,FC9
103B0:  RRCF   FC7,W
103B2:  BNC   103B0
....................        
....................       data = spi_read(0);  
103B4:  MOVF   FC9,W
103B6:  CLRF   FC9
103B8:  RRCF   FC7,W
103BA:  BNC   103B8
103BC:  MOVFF  FC9,8B7
....................       output_high(EEP_CS);  
103C0:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
103C2:  MOVLW  01
103C4:  MOVWF  xD7
103C6:  MOVLB  0
103C8:  CALL   55DA
....................     
....................    return(data);  
103CC:  MOVLB  8
103CE:  MOVFF  8B7,01
103D2:  MOVLB  0
103D4:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
03474:  MOVF   FF2,W
03476:  MOVWF  00
03478:  BCF    FF2.7
0347A:  CLRF   F63
0347C:  MOVFF  873,F62
03480:  MOVFF  874,F61
03484:  BCF    F7F.6
03486:  BCF    F7F.7
03488:  BSF    F7F.2
0348A:  MOVLB  F
0348C:  MOVLW  55
0348E:  MOVWF  F7E
03490:  MOVLW  AA
03492:  MOVWF  F7E
03494:  BSF    F7F.1
03496:  BTFSC  F7F.1
03498:  BRA    3496
0349A:  BCF    F7F.2
0349C:  MOVF   00,W
0349E:  IORWF  FF2,F
034A0:  MOVLB  0
034A2:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
02A86:  MOVLB  8
02A88:  CLRF   xA2
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
02A8A:  MOVFF  FF2,8A3
02A8E:  BCF    FF2.7
02A90:  CLRF   F63
02A92:  MOVFF  8A1,F62
02A96:  BCF    F7F.6
02A98:  BCF    F7F.7
02A9A:  BSF    F7F.0
02A9C:  MOVF   F61,W
02A9E:  BTFSC  xA3.7
02AA0:  BSF    FF2.7
02AA2:  MOVWF  xA2
....................    return(data); 
02AA4:  MOVFF  8A2,01
02AA8:  MOVLB  0
02AAA:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
0502C:  MOVLB  8
0502E:  CLRF   xDB
05030:  MOVF   xDB,W
05032:  SUBLW  01
05034:  BNC   508E
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
05036:  MOVF   xD8,W
05038:  ADDWF  xDB,W
0503A:  MOVWF  xDC
0503C:  MOVLW  08
0503E:  MOVWF  xDE
05040:  MOVLW  D9
05042:  MOVWF  xDD
05044:  MOVF   xDB,W
05046:  ADDWF  xDD,W
05048:  MOVWF  01
0504A:  MOVLW  00
0504C:  ADDWFC xDE,W
0504E:  MOVWF  03
05050:  MOVF   01,W
05052:  MOVWF  FE9
05054:  MOVFF  03,FEA
05058:  MOVFF  FEF,8DD
0505C:  MOVF   FF2,W
0505E:  MOVWF  00
05060:  BCF    FF2.7
05062:  CLRF   F63
05064:  MOVFF  8DC,F62
05068:  MOVFF  8DD,F61
0506C:  BCF    F7F.6
0506E:  BCF    F7F.7
05070:  BSF    F7F.2
05072:  MOVLB  F
05074:  MOVLW  55
05076:  MOVWF  F7E
05078:  MOVLW  AA
0507A:  MOVWF  F7E
0507C:  BSF    F7F.1
0507E:  BTFSC  F7F.1
05080:  BRA    507E
05082:  BCF    F7F.2
05084:  MOVF   00,W
05086:  IORWF  FF2,F
05088:  MOVLB  8
0508A:  INCF   xDB,F
0508C:  BRA    5030
....................     }  
0508E:  MOVLB  0
05090:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
02A2C:  MOVLB  8
02A2E:  CLRF   x84
02A30:  CLRF   x83
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
02A32:  CLRF   x82
02A34:  MOVF   x82,W
02A36:  SUBLW  01
02A38:  BNC   2A7A
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A3A:  MOVLW  08
02A3C:  MOVWF  x86
02A3E:  MOVLW  83
02A40:  MOVWF  x85
02A42:  MOVF   x82,W
02A44:  ADDWF  x85,W
02A46:  MOVWF  01
02A48:  MOVLW  00
02A4A:  ADDWFC x86,W
02A4C:  MOVWF  03
02A4E:  MOVF   01,W
02A50:  MOVWF  FE9
02A52:  MOVFF  03,FEA
02A56:  MOVF   x81,W
02A58:  ADDWF  x82,W
02A5A:  MOVWF  x87
02A5C:  MOVFF  FF2,888
02A60:  BCF    FF2.7
02A62:  CLRF   F63
02A64:  MOVFF  887,F62
02A68:  BCF    F7F.6
02A6A:  BCF    F7F.7
02A6C:  BSF    F7F.0
02A6E:  MOVF   F61,W
02A70:  BTFSC  x88.7
02A72:  BSF    FF2.7
02A74:  MOVWF  FEF
02A76:  INCF   x82,F
02A78:  BRA    2A34
....................    } 
....................  
....................    return(data);  
02A7A:  MOVFF  883,01
02A7E:  MOVFF  884,02
02A82:  MOVLB  0
02A84:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CAD4:  MOVLB  8
0CAD6:  CLRF   x75
0CAD8:  MOVF   x75,W
0CADA:  SUBLW  03
0CADC:  BNC   CB3E
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CADE:  MOVF   x75,W
0CAE0:  ADDWF  x6F,W
0CAE2:  MOVWF  x76
0CAE4:  MOVLW  00
0CAE6:  ADDWFC x70,W
0CAE8:  MOVWF  x77
0CAEA:  MOVLW  08
0CAEC:  MOVWF  x79
0CAEE:  MOVLW  71
0CAF0:  MOVWF  x78
0CAF2:  MOVF   x75,W
0CAF4:  ADDWF  x78,W
0CAF6:  MOVWF  01
0CAF8:  MOVLW  00
0CAFA:  ADDWFC x79,W
0CAFC:  MOVWF  03
0CAFE:  MOVF   01,W
0CB00:  MOVWF  FE9
0CB02:  MOVFF  03,FEA
0CB06:  MOVFF  FEF,878
0CB0A:  MOVF   FF2,W
0CB0C:  MOVWF  00
0CB0E:  BCF    FF2.7
0CB10:  MOVFF  877,F63
0CB14:  MOVFF  876,F62
0CB18:  MOVFF  878,F61
0CB1C:  BCF    F7F.6
0CB1E:  BCF    F7F.7
0CB20:  BSF    F7F.2
0CB22:  MOVLB  F
0CB24:  MOVLW  55
0CB26:  MOVWF  F7E
0CB28:  MOVLW  AA
0CB2A:  MOVWF  F7E
0CB2C:  BSF    F7F.1
0CB2E:  BTFSC  F7F.1
0CB30:  BRA    CB2E
0CB32:  BCF    F7F.2
0CB34:  MOVF   00,W
0CB36:  IORWF  FF2,F
0CB38:  MOVLB  8
0CB3A:  INCF   x75,F
0CB3C:  BRA    CAD8
....................    } 
0CB3E:  MOVLB  0
0CB40:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
02AAC:  MOVLB  8
02AAE:  CLRF   x75
02AB0:  CLRF   x74
02AB2:  CLRF   x73
02AB4:  CLRF   x72
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
02AB6:  CLRF   x71
02AB8:  MOVF   x71,W
02ABA:  SUBLW  03
02ABC:  BNC   2B06
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02ABE:  MOVLW  08
02AC0:  MOVWF  x77
02AC2:  MOVLW  72
02AC4:  MOVWF  x76
02AC6:  MOVF   x71,W
02AC8:  ADDWF  x76,W
02ACA:  MOVWF  01
02ACC:  MOVLW  00
02ACE:  ADDWFC x77,W
02AD0:  MOVWF  03
02AD2:  MOVF   01,W
02AD4:  MOVWF  FE9
02AD6:  MOVFF  03,FEA
02ADA:  MOVF   x71,W
02ADC:  ADDWF  x6F,W
02ADE:  MOVWF  x78
02AE0:  MOVLW  00
02AE2:  ADDWFC x70,W
02AE4:  MOVWF  x79
02AE6:  MOVFF  FF2,87A
02AEA:  BCF    FF2.7
02AEC:  MOVFF  879,F63
02AF0:  MOVFF  878,F62
02AF4:  BCF    F7F.6
02AF6:  BCF    F7F.7
02AF8:  BSF    F7F.0
02AFA:  MOVF   F61,W
02AFC:  BTFSC  x7A.7
02AFE:  BSF    FF2.7
02B00:  MOVWF  FEF
02B02:  INCF   x71,F
02B04:  BRA    2AB8
....................    } 
....................  
....................    return(data);  
02B06:  MOVFF  872,00
02B0A:  MOVFF  873,01
02B0E:  MOVFF  874,02
02B12:  MOVFF  875,03
02B16:  MOVLB  0
02B18:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
17E68:  MOVLB  8
17E6A:  CLRF   x8D
17E6C:  MOVF   x8D,W
17E6E:  SUBLW  01
17E70:  BNC   17EAE
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
17E72:  MOVF   x8D,W
17E74:  ADDWF  x89,W
17E76:  MOVWF  x8E
17E78:  MOVLW  00
17E7A:  ADDWFC x8A,W
17E7C:  MOVWF  x8F
17E7E:  MOVLW  08
17E80:  MOVWF  x91
17E82:  MOVLW  8B
17E84:  MOVWF  x90
17E86:  MOVF   x8D,W
17E88:  ADDWF  x90,W
17E8A:  MOVWF  01
17E8C:  MOVLW  00
17E8E:  ADDWFC x91,W
17E90:  MOVWF  03
17E92:  MOVFF  01,FE9
17E96:  MOVWF  FEA
17E98:  MOVFF  FEF,893
17E9C:  MOVFF  88F,892
17EA0:  MOVFF  88E,891
17EA4:  MOVLB  0
17EA6:  RCALL  17C28
17EA8:  MOVLB  8
17EAA:  INCF   x8D,F
17EAC:  BRA    17E6C
....................     }  
17EAE:  MOVLB  0
17EB0:  GOTO   17F20 (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
10490:  MOVLB  8
10492:  CLRF   xB0
10494:  CLRF   xAF
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
10496:  CLRF   xAE
10498:  MOVF   xAE,W
1049A:  SUBLW  01
1049C:  BNC   104E0
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
1049E:  MOVLW  08
104A0:  MOVWF  xB2
104A2:  MOVLW  AF
104A4:  MOVWF  xB1
104A6:  MOVF   xAE,W
104A8:  ADDWF  xB1,W
104AA:  MOVWF  01
104AC:  MOVLW  00
104AE:  ADDWFC xB2,W
104B0:  MOVWF  03
104B2:  MOVFF  01,8B1
104B6:  MOVWF  xB2
104B8:  MOVF   xAE,W
104BA:  ADDWF  xAC,W
104BC:  MOVWF  xB3
104BE:  MOVLW  00
104C0:  ADDWFC xAD,W
104C2:  MOVWF  xB4
104C4:  MOVWF  xB6
104C6:  MOVFF  8B3,8B5
104CA:  MOVLB  0
104CC:  RCALL  1037C
104CE:  MOVFF  8B2,FEA
104D2:  MOVFF  8B1,FE9
104D6:  MOVFF  01,FEF
104DA:  MOVLB  8
104DC:  INCF   xAE,F
104DE:  BRA    10498
....................    } 
....................    return(data);  
104E0:  MOVFF  8AF,01
104E4:  MOVFF  8B0,02
104E8:  MOVLB  0
104EA:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
1590A:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
1590C:  MOVF   2F,W
1590E:  SUBLW  02
15910:  BNZ   15918
15912:  MOVF   30,F
15914:  BNZ   15918
15916:  BSF    F90.6
....................    delay_ms(32); 
15918:  MOVLW  20
1591A:  MOVLB  9
1591C:  MOVWF  xD6
1591E:  MOVLB  0
15920:  CALL   2972
....................    output_bit(BOARD_LED, OFF); 
15924:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15926:  MOVF   2F,W
15928:  SUBLW  02
1592A:  BNZ   15932
1592C:  MOVF   30,F
1592E:  BNZ   15932
15930:  BCF    F90.6
....................    delay_ms(32); 
15932:  MOVLW  20
15934:  MOVLB  9
15936:  MOVWF  xD6
15938:  MOVLB  0
1593A:  CALL   2972
1593E:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
031AA:  MOVF   2F,W
031AC:  MOVWF  00
031AE:  MOVF   30,W
031B0:  MOVWF  03
031B2:  BNZ   31B8
031B4:  MOVF   00,F
031B6:  BZ    31DA
031B8:  MOVF   03,W
031BA:  BNZ   31C2
031BC:  MOVLW  01
031BE:  SUBWF  00,W
031C0:  BZ    322C
031C2:  MOVF   03,W
031C4:  BNZ   31CC
031C6:  MOVLW  02
031C8:  SUBWF  00,W
031CA:  BZ    327E
031CC:  MOVF   03,W
031CE:  BNZ   31D8
031D0:  MOVLW  03
031D2:  SUBWF  00,W
031D4:  BTFSC  FD8.2
031D6:  BRA    32D0
031D8:  BRA    3322
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
031DA:  MOVLW  BE
031DC:  MOVWF  FF6
031DE:  MOVLW  05
031E0:  MOVWF  FF7
031E2:  MOVLW  00
031E4:  MOVWF  FF8
031E6:  CLRF   1B
031E8:  BTFSC  FF2.7
031EA:  BSF    1B.7
031EC:  BCF    FF2.7
031EE:  MOVLW  06
031F0:  MOVLB  A
031F2:  MOVWF  x25
031F4:  MOVLB  0
031F6:  CALL   101E
031FA:  BTFSC  1B.7
031FC:  BSF    FF2.7
031FE:  MOVLW  CA
03200:  MOVWF  FF6
03202:  MOVLW  05
03204:  MOVWF  FF7
03206:  MOVLW  00
03208:  MOVWF  FF8
0320A:  CLRF   1B
0320C:  BTFSC  FF2.7
0320E:  BSF    1B.7
03210:  BCF    FF2.7
03212:  CALL   0DCC
03216:  BTFSC  1B.7
03218:  BSF    FF2.7
0321A:  MOVLW  0D
0321C:  BTFSS  F9E.4
0321E:  BRA    321C
03220:  MOVWF  FAD
03222:  MOVLW  0A
03224:  BTFSS  F9E.4
03226:  BRA    3224
03228:  MOVWF  FAD
....................          break; 
0322A:  BRA    3372
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
0322C:  MOVLW  D2
0322E:  MOVWF  FF6
03230:  MOVLW  05
03232:  MOVWF  FF7
03234:  MOVLW  00
03236:  MOVWF  FF8
03238:  CLRF   1B
0323A:  BTFSC  FF2.7
0323C:  BSF    1B.7
0323E:  BCF    FF2.7
03240:  MOVLW  09
03242:  MOVLB  A
03244:  MOVWF  x25
03246:  MOVLB  0
03248:  CALL   101E
0324C:  BTFSC  1B.7
0324E:  BSF    FF2.7
03250:  MOVLW  E0
03252:  MOVWF  FF6
03254:  MOVLW  05
03256:  MOVWF  FF7
03258:  MOVLW  00
0325A:  MOVWF  FF8
0325C:  CLRF   1B
0325E:  BTFSC  FF2.7
03260:  BSF    1B.7
03262:  BCF    FF2.7
03264:  CALL   0DCC
03268:  BTFSC  1B.7
0326A:  BSF    FF2.7
0326C:  MOVLW  0D
0326E:  BTFSS  F9E.4
03270:  BRA    326E
03272:  MOVWF  FAD
03274:  MOVLW  0A
03276:  BTFSS  F9E.4
03278:  BRA    3276
0327A:  MOVWF  FAD
....................          break;  
0327C:  BRA    3372
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
0327E:  MOVLW  E8
03280:  MOVWF  FF6
03282:  MOVLW  05
03284:  MOVWF  FF7
03286:  MOVLW  00
03288:  MOVWF  FF8
0328A:  CLRF   1B
0328C:  BTFSC  FF2.7
0328E:  BSF    1B.7
03290:  BCF    FF2.7
03292:  MOVLW  06
03294:  MOVLB  A
03296:  MOVWF  x25
03298:  MOVLB  0
0329A:  CALL   101E
0329E:  BTFSC  1B.7
032A0:  BSF    FF2.7
032A2:  MOVLW  F4
032A4:  MOVWF  FF6
032A6:  MOVLW  05
032A8:  MOVWF  FF7
032AA:  MOVLW  00
032AC:  MOVWF  FF8
032AE:  CLRF   1B
032B0:  BTFSC  FF2.7
032B2:  BSF    1B.7
032B4:  BCF    FF2.7
032B6:  CALL   0DCC
032BA:  BTFSC  1B.7
032BC:  BSF    FF2.7
032BE:  MOVLW  0D
032C0:  BTFSS  F9E.4
032C2:  BRA    32C0
032C4:  MOVWF  FAD
032C6:  MOVLW  0A
032C8:  BTFSS  F9E.4
032CA:  BRA    32C8
032CC:  MOVWF  FAD
....................          break; 
032CE:  BRA    3372
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
032D0:  MOVLW  FC
032D2:  MOVWF  FF6
032D4:  MOVLW  05
032D6:  MOVWF  FF7
032D8:  MOVLW  00
032DA:  MOVWF  FF8
032DC:  CLRF   1B
032DE:  BTFSC  FF2.7
032E0:  BSF    1B.7
032E2:  BCF    FF2.7
032E4:  MOVLW  09
032E6:  MOVLB  A
032E8:  MOVWF  x25
032EA:  MOVLB  0
032EC:  CALL   101E
032F0:  BTFSC  1B.7
032F2:  BSF    FF2.7
032F4:  MOVLW  0A
032F6:  MOVWF  FF6
032F8:  MOVLW  06
032FA:  MOVWF  FF7
032FC:  MOVLW  00
032FE:  MOVWF  FF8
03300:  CLRF   1B
03302:  BTFSC  FF2.7
03304:  BSF    1B.7
03306:  BCF    FF2.7
03308:  CALL   0DCC
0330C:  BTFSC  1B.7
0330E:  BSF    FF2.7
03310:  MOVLW  0D
03312:  BTFSS  F9E.4
03314:  BRA    3312
03316:  MOVWF  FAD
03318:  MOVLW  0A
0331A:  BTFSS  F9E.4
0331C:  BRA    331A
0331E:  MOVWF  FAD
....................          break;           
03320:  BRA    3372
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
03322:  MOVLW  12
03324:  MOVWF  FF6
03326:  MOVLW  06
03328:  MOVWF  FF7
0332A:  MOVLW  00
0332C:  MOVWF  FF8
0332E:  CLRF   1B
03330:  BTFSC  FF2.7
03332:  BSF    1B.7
03334:  BCF    FF2.7
03336:  MOVLW  06
03338:  MOVLB  A
0333A:  MOVWF  x25
0333C:  MOVLB  0
0333E:  CALL   101E
03342:  BTFSC  1B.7
03344:  BSF    FF2.7
03346:  MOVLW  1E
03348:  MOVWF  FF6
0334A:  MOVLW  06
0334C:  MOVWF  FF7
0334E:  MOVLW  00
03350:  MOVWF  FF8
03352:  CLRF   1B
03354:  BTFSC  FF2.7
03356:  BSF    1B.7
03358:  BCF    FF2.7
0335A:  CALL   0DCC
0335E:  BTFSC  1B.7
03360:  BSF    FF2.7
03362:  MOVLW  0D
03364:  BTFSS  F9E.4
03366:  BRA    3364
03368:  MOVWF  FAD
0336A:  MOVLW  0A
0336C:  BTFSS  F9E.4
0336E:  BRA    336C
03370:  MOVWF  FAD
....................          break; 
....................    } 
03372:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
1731E:  MOVLW  26
17320:  MOVWF  FF6
17322:  MOVLW  06
17324:  MOVWF  FF7
17326:  MOVLW  00
17328:  MOVWF  FF8
1732A:  CLRF   1B
1732C:  BTFSC  FF2.7
1732E:  BSF    1B.7
17330:  BCF    FF2.7
17332:  CALL   0DCC
17336:  BTFSC  1B.7
17338:  BSF    FF2.7
1733A:  GOTO   176E4 (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0B070:  MOVLW  2E
0B072:  MOVWF  FF6
0B074:  MOVLW  06
0B076:  MOVWF  FF7
0B078:  MOVLW  00
0B07A:  MOVWF  FF8
0B07C:  CLRF   1B
0B07E:  BTFSC  FF2.7
0B080:  BSF    1B.7
0B082:  BCF    FF2.7
0B084:  CALL   0DCC
0B088:  BTFSC  1B.7
0B08A:  BSF    FF2.7
0B08C:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BD32:  MOVLW  36
0BD34:  MOVWF  FF6
0BD36:  MOVLW  06
0BD38:  MOVWF  FF7
0BD3A:  MOVLW  00
0BD3C:  MOVWF  FF8
0BD3E:  CLRF   1B
0BD40:  BTFSC  FF2.7
0BD42:  BSF    1B.7
0BD44:  BCF    FF2.7
0BD46:  CALL   0DCC
0BD4A:  BTFSC  1B.7
0BD4C:  BSF    FF2.7
0BD4E:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
036B8:  MOVLW  4E
036BA:  MOVWF  FF6
036BC:  MOVLW  06
036BE:  MOVWF  FF7
036C0:  MOVLW  00
036C2:  MOVWF  FF8
036C4:  CLRF   1B
036C6:  BTFSC  FF2.7
036C8:  BSF    1B.7
036CA:  BCF    FF2.7
036CC:  CALL   0DCC
036D0:  BTFSC  1B.7
036D2:  BSF    FF2.7
036D4:  GOTO   442A (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
050D8:  MOVLW  56
050DA:  MOVWF  FF6
050DC:  MOVLW  06
050DE:  MOVWF  FF7
050E0:  MOVLW  00
050E2:  MOVWF  FF8
050E4:  CLRF   1B
050E6:  BTFSC  FF2.7
050E8:  BSF    1B.7
050EA:  BCF    FF2.7
050EC:  CALL   0DCC
050F0:  BTFSC  1B.7
050F2:  BSF    FF2.7
050F4:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
15E32:  MOVLW  5E
15E34:  MOVWF  FF6
15E36:  MOVLW  06
15E38:  MOVWF  FF7
15E3A:  MOVLW  00
15E3C:  MOVWF  FF8
15E3E:  CLRF   1B
15E40:  BTFSC  FF2.7
15E42:  BSF    1B.7
15E44:  BCF    FF2.7
15E46:  CALL   0DCC
15E4A:  BTFSC  1B.7
15E4C:  BSF    FF2.7
15E4E:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
*
0AEBC:  DECFSZ 4A,W
0AEBE:  BRA    AEDE
0AEC0:  MOVLW  66
0AEC2:  MOVWF  FF6
0AEC4:  MOVLW  06
0AEC6:  MOVWF  FF7
0AEC8:  MOVLW  00
0AECA:  MOVWF  FF8
0AECC:  CLRF   1B
0AECE:  BTFSC  FF2.7
0AED0:  BSF    1B.7
0AED2:  BCF    FF2.7
0AED4:  CALL   0DCC
0AED8:  BTFSC  1B.7
0AEDA:  BSF    FF2.7
0AEDC:  BRA    AEFA
....................    else fprintf(COM_A, "@RDY\r\n"); 
0AEDE:  MOVLW  6E
0AEE0:  MOVWF  FF6
0AEE2:  MOVLW  06
0AEE4:  MOVWF  FF7
0AEE6:  MOVLW  00
0AEE8:  MOVWF  FF8
0AEEA:  CLRF   1B
0AEEC:  BTFSC  FF2.7
0AEEE:  BSF    1B.7
0AEF0:  BCF    FF2.7
0AEF2:  CALL   0DCC
0AEF6:  BTFSC  1B.7
0AEF8:  BSF    FF2.7
0AEFA:  GOTO   1B020 (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
035A2:  MOVLW  0A
035A4:  MOVLB  A
035A6:  MOVWF  x1B
035A8:  MOVLW  12
035AA:  MOVFF  A1B,A19
035AE:  MOVWF  x18
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
035B0:  MOVF   FC9,W
035B2:  SETF   FC9
035B4:  RRCF   FC7,W
035B6:  BNC   35B4
....................    SD_spi_read(sdcmd); 
035B8:  MOVF   FC9,W
035BA:  MOVFF  A11,FC9
035BE:  RRCF   FC7,W
035C0:  BNC   35BE
....................    SD_spi_read(value[3]); 
035C2:  MOVLW  03
035C4:  ADDWF  x18,W
035C6:  MOVWF  FE9
035C8:  MOVLW  00
035CA:  ADDWFC x19,W
035CC:  MOVWF  FEA
035CE:  MOVFF  FEF,A1A
035D2:  MOVF   FC9,W
035D4:  MOVFF  A1A,FC9
035D8:  RRCF   FC7,W
035DA:  BNC   35D8
....................    SD_spi_read(value[2]); 
035DC:  MOVLW  02
035DE:  ADDWF  x18,W
035E0:  MOVWF  FE9
035E2:  MOVLW  00
035E4:  ADDWFC x19,W
035E6:  MOVWF  FEA
035E8:  MOVFF  FEF,A1A
035EC:  MOVF   FC9,W
035EE:  MOVFF  A1A,FC9
035F2:  RRCF   FC7,W
035F4:  BNC   35F2
....................    SD_spi_read(value[1]); 
035F6:  MOVLW  01
035F8:  ADDWF  x18,W
035FA:  MOVWF  FE9
035FC:  MOVLW  00
035FE:  ADDWFC x19,W
03600:  MOVWF  FEA
03602:  MOVFF  FEF,A1A
03606:  MOVF   FC9,W
03608:  MOVFF  A1A,FC9
0360C:  RRCF   FC7,W
0360E:  BNC   360C
....................    SD_spi_read(value[0]); 
03610:  MOVFF  A18,FE9
03614:  MOVFF  A19,FEA
03618:  MOVFF  FEF,A1A
0361C:  MOVF   FC9,W
0361E:  MOVFF  A1A,FC9
03622:  RRCF   FC7,W
03624:  BNC   3622
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
03626:  MOVF   x11,W
03628:  SUBLW  48
0362A:  BNZ   3638
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
0362C:  MOVF   FC9,W
0362E:  MOVLW  87
03630:  MOVWF  FC9
03632:  RRCF   FC7,W
03634:  BNC   3632
03636:  BRA    3642
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
03638:  MOVF   FC9,W
0363A:  MOVLW  95
0363C:  MOVWF  FC9
0363E:  RRCF   FC7,W
03640:  BNC   363E
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
03642:  CLRF   x16
....................    response = SD_spi_read(0xFF); 
03644:  MOVF   FC9,W
03646:  SETF   FC9
03648:  RRCF   FC7,W
0364A:  BNC   3648
0364C:  MOVFF  FC9,A17
....................    while ((response == 0xFF) && (i < 100)) 
03650:  INCFSZ x17,W
03652:  BRA    366A
03654:  MOVF   x16,W
03656:  SUBLW  63
03658:  BNC   366A
....................       { 
....................       i++; 
0365A:  INCF   x16,F
....................       response = SD_spi_read(0xFF); 
0365C:  MOVF   FC9,W
0365E:  SETF   FC9
03660:  RRCF   FC7,W
03662:  BNC   3660
03664:  MOVFF  FC9,A17
03668:  BRA    3650
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
0366A:  MOVFF  A17,01
0366E:  MOVLB  0
03670:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
04436:  MOVLW  50
04438:  MOVLB  A
0443A:  MOVWF  x11
0443C:  MOVFF  A10,A15
04440:  MOVFF  A0F,A14
04444:  MOVFF  A0E,A13
04448:  MOVFF  A0D,A12
0444C:  MOVLB  0
0444E:  CALL   35A2
04452:  MOVF   01,W
04454:  BZ    445C
04456:  XORLW  40
04458:  BZ    4472
0445A:  BRA    4478
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
0445C:  MOVFF  A10,4E8
04460:  MOVFF  A0F,4E7
04464:  MOVFF  A0E,4E6
04468:  MOVFF  A0D,4E5
....................          return(TRUE); 
0446C:  MOVLW  01
0446E:  MOVWF  01
04470:  BRA    447C
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
04472:  MOVLW  00
04474:  MOVWF  01
04476:  BRA    447C
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
04478:  MOVLW  00
0447A:  MOVWF  01
....................       } 
0447C:  GOTO   4560 (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
04480:  MOVF   FC9,W
04482:  SETF   FC9
04484:  RRCF   FC7,W
04486:  BNC   4484
04488:  MOVFF  FC9,A15
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
0448C:  MOVLB  A
0448E:  CLRF   x14
04490:  CLRF   x13
04492:  MOVF   x14,W
04494:  SUBLW  27
04496:  BNC   44C0
04498:  BNZ   44A0
0449A:  MOVF   x13,W
0449C:  SUBLW  0F
0449E:  BNC   44C0
044A0:  INCFSZ x15,W
044A2:  BRA    44C0
....................       { 
....................       delay_us(10); 
044A4:  MOVLW  35
044A6:  MOVWF  00
044A8:  DECFSZ 00,F
044AA:  BRA    44A8
....................       response = SD_spi_read(0xFF);  
044AC:  MOVF   FC9,W
044AE:  SETF   FC9
044B0:  RRCF   FC7,W
044B2:  BNC   44B0
044B4:  MOVFF  FC9,A15
044B8:  INCF   x13,F
044BA:  BTFSC  FD8.2
044BC:  INCF   x14,F
044BE:  BRA    4492
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
044C0:  MOVF   x15,W
044C2:  SUBLW  FE
044C4:  BZ    44D4
....................       { 
....................       if (!response) 
044C6:  MOVF   x15,F
044C8:  BNZ   44CE
....................          response = 0xFE; 
044CA:  MOVLW  FE
044CC:  MOVWF  x15
....................       return(response); 
044CE:  MOVFF  A15,01
044D2:  BRA    452A
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
044D4:  CLRF   x14
044D6:  CLRF   x13
044D8:  MOVF   x12,F
044DA:  BNZ   44EE
044DC:  MOVF   x11,F
044DE:  BNZ   44EE
044E0:  MOVF   x14,W
044E2:  SUBWF  x10,W
044E4:  BNC   450E
044E6:  BNZ   44EE
044E8:  MOVF   x0F,W
044EA:  SUBWF  x13,W
044EC:  BC    450E
....................       ptr[i]=SD_spi_read(0xFF); 
044EE:  MOVF   x0D,W
044F0:  ADDWF  x13,W
044F2:  MOVWF  FE9
044F4:  MOVF   x0E,W
044F6:  ADDWFC x14,W
044F8:  MOVWF  FEA
044FA:  MOVF   FC9,W
044FC:  SETF   FC9
044FE:  RRCF   FC7,W
04500:  BNC   44FE
04502:  MOVFF  FC9,FEF
04506:  INCF   x13,F
04508:  BTFSC  FD8.2
0450A:  INCF   x14,F
0450C:  BRA    44D8
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
0450E:  MOVF   FC9,W
04510:  SETF   FC9
04512:  RRCF   FC7,W
04514:  BNC   4512
....................    SD_spi_read(0xFF); 
04516:  MOVF   FC9,W
04518:  SETF   FC9
0451A:  RRCF   FC7,W
0451C:  BNC   451A
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
0451E:  MOVF   FC9,W
04520:  SETF   FC9
04522:  RRCF   FC7,W
04524:  BNC   4522
....................    return(0); 
04526:  MOVLW  00
04528:  MOVWF  01
0452A:  MOVLB  0
0452C:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
0589A:  MOVLW  C3
0589C:  MOVLB  A
0589E:  MOVWF  x15
058A0:  MOVLW  50
058A2:  MOVWF  x14
....................    SD_spi_read(0xFF); 
058A4:  MOVF   FC9,W
058A6:  SETF   FC9
058A8:  RRCF   FC7,W
058AA:  BNC   58A8
....................    do 
....................       { 
....................       delay_us(10); 
058AC:  MOVLW  35
058AE:  MOVWF  00
058B0:  DECFSZ 00,F
058B2:  BRA    58B0
....................       response = SD_spi_read(0xFF); 
058B4:  MOVF   FC9,W
058B6:  SETF   FC9
058B8:  RRCF   FC7,W
058BA:  BNC   58B8
058BC:  MOVFF  FC9,A13
....................       Timer--; 
058C0:  MOVF   x14,W
058C2:  BTFSC  FD8.2
058C4:  DECF   x15,F
058C6:  DECF   x14,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
058C8:  INCFSZ x13,W
058CA:  BRA    58CE
058CC:  BRA    58D4
058CE:  MOVF   x14,W
058D0:  IORWF  x15,W
058D2:  BNZ   58AC
....................       ; 
....................  
....................    return (response); 
058D4:  MOVFF  A13,01
058D8:  MOVLB  0
058DA:  GOTO   58EA (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
058DE:  MOVLW  02
058E0:  MOVLB  A
058E2:  MOVWF  x12
058E4:  CLRF   x11
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
058E6:  MOVLB  0
058E8:  BRA    589A
058EA:  INCFSZ 01,W
058EC:  BRA    58F0
058EE:  BRA    58F6
....................       return (FALSE); 
058F0:  MOVLW  00
058F2:  MOVWF  01
058F4:  BRA    5990
....................  
....................    SD_spi_write(token);               // transmit data token 
058F6:  MOVF   FC9,W
058F8:  MOVFF  A0F,FC9
058FC:  RRCF   FC7,W
058FE:  BNC   58FC
....................    if (token != 0xFD) 
05900:  MOVLB  A
05902:  MOVF   x0F,W
05904:  SUBLW  FD
05906:  BZ    598A
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
05908:  MOVFF  A12,03
0590C:  MOVF   x11,W
0590E:  BTFSC  FD8.2
05910:  DECF   x12,F
05912:  DECF   x11,F
05914:  IORWF  03,W
05916:  BZ    593A
....................          SD_spi_write(*ptr++); 
05918:  MOVFF  A0E,03
0591C:  MOVF   x0D,W
0591E:  INCF   x0D,F
05920:  BTFSC  FD8.2
05922:  INCF   x0E,F
05924:  MOVWF  FE9
05926:  MOVFF  03,FEA
0592A:  MOVFF  FEF,A13
0592E:  MOVF   FC9,W
05930:  MOVFF  A13,FC9
05934:  RRCF   FC7,W
05936:  BNC   5934
05938:  BRA    5908
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
0593A:  MOVF   FC9,W
0593C:  SETF   FC9
0593E:  RRCF   FC7,W
05940:  BNC   593E
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
05942:  MOVF   FC9,W
05944:  SETF   FC9
05946:  RRCF   FC7,W
05948:  BNC   5946
....................       response = SD_spi_read(0xFF);      // Receive data response 
0594A:  MOVF   FC9,W
0594C:  SETF   FC9
0594E:  RRCF   FC7,W
05950:  BNC   594E
05952:  MOVFF  FC9,A10
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
05956:  CLRF   x12
05958:  CLRF   x11
0595A:  MOVF   x12,W
0595C:  SUBLW  C3
0595E:  BNC   598A
05960:  BNZ   5968
05962:  MOVF   x11,W
05964:  SUBLW  4F
05966:  BNC   598A
....................          { 
....................          delay_us(10); 
05968:  MOVLW  35
0596A:  MOVWF  00
0596C:  DECFSZ 00,F
0596E:  BRA    596C
....................          response = SD_spi_read(0xFF);   // digest prior operation 
05970:  MOVF   FC9,W
05972:  SETF   FC9
05974:  RRCF   FC7,W
05976:  BNC   5974
05978:  MOVFF  FC9,A10
....................          if (response != 0x00) 
0597C:  MOVF   x10,F
0597E:  BZ    5982
....................             break; 
05980:  BRA    598A
05982:  INCF   x11,F
05984:  BTFSC  FD8.2
05986:  INCF   x12,F
05988:  BRA    595A
....................          } 
....................  
....................       } 
....................    return(TRUE); 
0598A:  MOVLW  01
0598C:  MOVWF  01
0598E:  MOVLB  0
05990:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
05992:  MOVLB  4
05994:  BTFSS  xE9.0
05996:  BRA    599E
....................       return (RES_NOTRDY); 
05998:  MOVLW  03
0599A:  MOVWF  01
0599C:  BRA    5AD2
....................  
....................    if (Media_Status & STA_PROTECT) 
0599E:  BTFSS  xE9.2
059A0:  BRA    59A8
....................       return (RES_WRPRT); 
059A2:  MOVLW  02
059A4:  MOVWF  01
059A6:  BRA    5AD2
....................  
....................    if (!SectorCount) 
059A8:  MOVLB  A
059AA:  MOVF   x0C,F
059AC:  BNZ   59B8
....................       return (RES_PARERR); 
059AE:  MOVLW  04
059B0:  MOVWF  01
059B2:  MOVLB  4
059B4:  BRA    5AD2
059B6:  MOVLB  A
....................  
....................    SelectSD; 
059B8:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
059BA:  MOVLB  4
059BC:  MOVF   xE3,W
059BE:  SUBLW  05
059C0:  BZ    59DC
....................       SectorNumber *= 512; 
059C2:  BCF    FD8.0
059C4:  MOVFF  A0A,A0B
059C8:  MOVFF  A09,A0A
059CC:  MOVFF  A08,A09
059D0:  MOVLB  A
059D2:  CLRF   x08
059D4:  RLCF   x09,F
059D6:  RLCF   x0A,F
059D8:  RLCF   x0B,F
059DA:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
059DC:  MOVLB  A
059DE:  DECFSZ x0C,W
059E0:  BRA    5A20
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
059E2:  MOVLW  58
059E4:  MOVWF  x11
059E6:  MOVFF  A0B,A15
059EA:  MOVFF  A0A,A14
059EE:  MOVFF  A09,A13
059F2:  MOVFF  A08,A12
059F6:  MOVLB  0
059F8:  CALL   35A2
059FC:  MOVF   01,F
059FE:  BNZ   5A1C
....................          if (SD_write_data(Buffer, 0xFE)) 
05A00:  MOVFF  A07,A0E
05A04:  MOVFF  A06,A0D
05A08:  MOVLW  FE
05A0A:  MOVLB  A
05A0C:  MOVWF  x0F
05A0E:  MOVLB  0
05A10:  RCALL  58DE
05A12:  MOVF   01,F
05A14:  BZ    5A1C
....................             SectorCount = 0; 
05A16:  MOVLB  A
05A18:  CLRF   x0C
05A1A:  MOVLB  0
....................       } 
05A1C:  BRA    5AB8
05A1E:  MOVLB  A
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
05A20:  MOVLB  4
05A22:  MOVF   xE3,W
05A24:  ANDLW  03
05A26:  BZ    5A54
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
05A28:  MOVLW  77
05A2A:  MOVLB  A
05A2C:  MOVWF  x11
05A2E:  CLRF   x15
05A30:  CLRF   x14
05A32:  CLRF   x13
05A34:  CLRF   x12
05A36:  MOVLB  0
05A38:  CALL   35A2
....................          SD_cmd(SD_ACMD23, SectorCount); 
05A3C:  MOVLW  57
05A3E:  MOVLB  A
05A40:  MOVWF  x11
05A42:  CLRF   x15
05A44:  CLRF   x14
05A46:  CLRF   x13
05A48:  MOVFF  A0C,A12
05A4C:  MOVLB  0
05A4E:  CALL   35A2
05A52:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05A54:  MOVLW  59
05A56:  MOVLB  A
05A58:  MOVWF  x11
05A5A:  MOVFF  A0B,A15
05A5E:  MOVFF  A0A,A14
05A62:  MOVFF  A09,A13
05A66:  MOVFF  A08,A12
05A6A:  MOVLB  0
05A6C:  CALL   35A2
05A70:  MOVF   01,F
05A72:  BNZ   5AB8
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
05A74:  MOVFF  A07,A0E
05A78:  MOVFF  A06,A0D
05A7C:  MOVLW  FC
05A7E:  MOVLB  A
05A80:  MOVWF  x0F
05A82:  MOVLB  0
05A84:  RCALL  58DE
05A86:  MOVF   01,F
05A88:  BNZ   5A8C
....................                break; 
05A8A:  BRA    5A9E
....................             Buffer += 512; 
05A8C:  MOVLW  02
05A8E:  MOVLB  A
05A90:  ADDWF  x07,F
....................             } while (--SectorCount); 
05A92:  DECF   x0C,F
05A94:  BTFSC  FD8.2
05A96:  BRA    5A9C
05A98:  MOVLB  0
05A9A:  BRA    5A74
05A9C:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
05A9E:  MOVLB  A
05AA0:  CLRF   x0E
05AA2:  CLRF   x0D
05AA4:  MOVLW  FD
05AA6:  MOVWF  x0F
05AA8:  MOVLB  0
05AAA:  RCALL  58DE
05AAC:  MOVF   01,F
05AAE:  BNZ   5AB8
....................             SectorCount = 1; 
05AB0:  MOVLW  01
05AB2:  MOVLB  A
05AB4:  MOVWF  x0C
05AB6:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
05AB8:  BSF    F91.1
....................    SD_spi_read(0xFF); 
05ABA:  MOVF   FC9,W
05ABC:  SETF   FC9
05ABE:  RRCF   FC7,W
05AC0:  BNC   5ABE
....................    return SectorCount ? RES_ERROR : RES_OK; 
05AC2:  MOVLB  A
05AC4:  MOVF   x0C,F
05AC6:  BZ    5ACC
05AC8:  MOVLW  01
05ACA:  BRA    5ACE
05ACC:  MOVLW  00
05ACE:  MOVWF  01
05AD0:  MOVLB  4
05AD2:  MOVLB  0
05AD4:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
0452E:  MOVLB  4
04530:  BTFSS  xE9.0
04532:  BRA    453A
....................       return (RES_NOTRDY); 
04534:  MOVLW  03
04536:  MOVWF  01
04538:  BRA    466A
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
0453A:  MOVLB  A
0453C:  MOVF   x0C,W
0453E:  SUBLW  01
04540:  BNC   4546
04542:  MOVF   x0C,F
04544:  BNZ   4550
....................       return(RES_PARERR); 
04546:  MOVLW  04
04548:  MOVWF  01
0454A:  MOVLB  4
0454C:  BRA    466A
0454E:  MOVLB  A
....................  
....................    SelectSD; 
04550:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
04552:  CLRF   x10
04554:  CLRF   x0F
04556:  MOVLW  02
04558:  MOVWF  x0E
0455A:  CLRF   x0D
0455C:  MOVLB  0
0455E:  BRA    4436
04560:  MOVF   01,F
04562:  BNZ   4570
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
04564:  BSF    F91.1
....................       return(RES_ERROR); 
04566:  MOVLW  01
04568:  MOVWF  01
0456A:  MOVLB  4
0456C:  BRA    466A
0456E:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
04570:  MOVLB  4
04572:  MOVF   xE3,W
04574:  SUBLW  05
04576:  BZ    4592
....................       SectorNumber *= 512; 
04578:  BCF    FD8.0
0457A:  MOVFF  A0A,A0B
0457E:  MOVFF  A09,A0A
04582:  MOVFF  A08,A09
04586:  MOVLB  A
04588:  CLRF   x08
0458A:  RLCF   x09,F
0458C:  RLCF   x0A,F
0458E:  RLCF   x0B,F
04590:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
04592:  MOVLB  A
04594:  DECFSZ x0C,W
04596:  BRA    45EE
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
04598:  MOVLW  51
0459A:  MOVWF  x11
0459C:  MOVFF  A0B,A15
045A0:  MOVFF  A0A,A14
045A4:  MOVFF  A09,A13
045A8:  MOVFF  A08,A12
045AC:  MOVLB  0
045AE:  CALL   35A2
045B2:  MOVF   01,F
045B4:  BZ    45C2
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
045B6:  BSF    F91.1
....................          return(RES_PARERR); 
045B8:  MOVLW  04
045BA:  MOVWF  01
045BC:  MOVLB  4
045BE:  BRA    466A
045C0:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
045C2:  MOVFF  A07,A0E
045C6:  MOVFF  A06,A0D
045CA:  MOVLB  A
045CC:  CLRF   x12
045CE:  CLRF   x11
045D0:  MOVLW  02
045D2:  MOVWF  x10
045D4:  CLRF   x0F
045D6:  MOVLB  0
045D8:  RCALL  4480
045DA:  MOVF   01,F
045DC:  BZ    45EA
....................          { 
....................          DeselectSD; 
045DE:  BSF    F91.1
....................          return(RES_ERROR); 
045E0:  MOVLW  01
045E2:  MOVWF  01
045E4:  MOVLB  4
045E6:  BRA    466A
045E8:  MOVLB  0
....................          } 
....................       } 
045EA:  BRA    4662
045EC:  MOVLB  A
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
045EE:  MOVLW  52
045F0:  MOVWF  x11
045F2:  MOVFF  A0B,A15
045F6:  MOVFF  A0A,A14
045FA:  MOVFF  A09,A13
045FE:  MOVFF  A08,A12
04602:  MOVLB  0
04604:  CALL   35A2
04608:  MOVF   01,F
0460A:  BZ    4618
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
0460C:  BSF    F91.1
....................          return(RES_PARERR); 
0460E:  MOVLW  04
04610:  MOVWF  01
04612:  MOVLB  4
04614:  BRA    466A
04616:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
04618:  MOVFF  A07,A0E
0461C:  MOVFF  A06,A0D
04620:  MOVLB  A
04622:  CLRF   x12
04624:  CLRF   x11
04626:  MOVLW  02
04628:  MOVWF  x10
0462A:  CLRF   x0F
0462C:  MOVLB  0
0462E:  RCALL  4480
04630:  MOVF   01,F
04632:  BZ    4640
....................             { 
....................             DeselectSD; 
04634:  BSF    F91.1
....................             return(RES_ERROR); 
04636:  MOVLW  01
04638:  MOVWF  01
0463A:  MOVLB  4
0463C:  BRA    466A
0463E:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
04640:  MOVLW  02
04642:  MOVLB  A
04644:  ADDWF  x07,F
....................          } while (--SectorCount); 
04646:  DECF   x0C,F
04648:  BTFSC  FD8.2
0464A:  BRA    4650
0464C:  MOVLB  0
0464E:  BRA    4618
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
04650:  MOVLW  4C
04652:  MOVWF  x11
04654:  CLRF   x15
04656:  CLRF   x14
04658:  CLRF   x13
0465A:  CLRF   x12
0465C:  MOVLB  0
0465E:  CALL   35A2
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
04662:  BSF    F91.1
....................    return(RES_OK); 
04664:  MOVLW  00
04666:  MOVWF  01
04668:  MOVLB  4
0466A:  MOVLB  0
0466C:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
055F2:  MOVLB  4
055F4:  BCF    xE9.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
055F6:  BCF    xE9.2
....................  
....................    return(Media_Status); 
055F8:  MOVFF  4E9,01
055FC:  MOVLB  0
055FE:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
036D8:  MOVLB  9
036DA:  CLRF   xD5
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
036DC:  MOVLB  4
036DE:  CLRF   xE3
....................  
....................    DeselectSD; 
036E0:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
036E2:  MOVLW  0A
036E4:  MOVLB  9
036E6:  MOVWF  xD6
036E8:  MOVLB  0
036EA:  CALL   2972
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
036EE:  BCF    FC6.5
036F0:  MOVLW  22
036F2:  MOVWF  FC6
036F4:  MOVLW  40
036F6:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
036F8:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
036FA:  MOVLB  9
036FC:  CLRF   xCD
036FE:  MOVF   xCD,W
03700:  SUBLW  09
03702:  BNC   3710
....................       SD_spi_read(0xFF); 
03704:  MOVF   FC9,W
03706:  SETF   FC9
03708:  RRCF   FC7,W
0370A:  BNC   3708
0370C:  INCF   xCD,F
0370E:  BRA    36FE
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
03710:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
03712:  MOVF   1F,W
03714:  SUBLW  04
03716:  BNZ   373C
03718:  MOVF   20,F
0371A:  BNZ   373C
0371C:  MOVLW  76
0371E:  MOVWF  FF6
03720:  MOVLW  06
03722:  MOVWF  FF7
03724:  MOVLW  00
03726:  MOVWF  FF8
03728:  CLRF   1B
0372A:  BTFSC  FF2.7
0372C:  BSF    1B.7
0372E:  BCF    FF2.7
03730:  MOVLB  0
03732:  CALL   0DCC
03736:  BTFSC  1B.7
03738:  BSF    FF2.7
0373A:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
0373C:  MOVLW  40
0373E:  MOVLB  A
03740:  MOVWF  x11
03742:  CLRF   x15
03744:  CLRF   x14
03746:  CLRF   x13
03748:  CLRF   x12
0374A:  MOVLB  0
0374C:  RCALL  35A2
0374E:  MOVFF  01,9CE
....................    if (response > 1 ) 
03752:  MOVLB  9
03754:  MOVF   xCE,W
03756:  SUBLW  01
03758:  BC    37AE
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
0375A:  MOVF   1F,W
0375C:  SUBLW  04
0375E:  BNZ   37A8
03760:  MOVF   20,F
03762:  BNZ   37A8
03764:  MOVLW  86
03766:  MOVWF  FF6
03768:  MOVLW  06
0376A:  MOVWF  FF7
0376C:  MOVLW  00
0376E:  MOVWF  FF8
03770:  CLRF   1B
03772:  BTFSC  FF2.7
03774:  BSF    1B.7
03776:  BCF    FF2.7
03778:  MOVLW  31
0377A:  MOVLB  A
0377C:  MOVWF  x25
0377E:  MOVLB  0
03780:  CALL   101E
03784:  BTFSC  1B.7
03786:  BSF    FF2.7
03788:  MOVFF  9CE,9D6
0378C:  MOVLW  57
0378E:  MOVLB  9
03790:  MOVWF  xD7
03792:  MOVLB  0
03794:  RCALL  3672
03796:  MOVLW  0D
03798:  BTFSS  F9E.4
0379A:  BRA    3798
0379C:  MOVWF  FAD
0379E:  MOVLW  0A
037A0:  BTFSS  F9E.4
037A2:  BRA    37A0
037A4:  MOVWF  FAD
037A6:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
037A8:  BSF    xD5.0
....................       goto Exit_disk_initialize; 
037AA:  GOTO   442C
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
037AE:  MOVF   1F,W
037B0:  SUBLW  04
037B2:  BNZ   37FC
037B4:  MOVF   20,F
037B6:  BNZ   37FC
037B8:  MOVLW  BE
037BA:  MOVWF  FF6
037BC:  MOVLW  06
037BE:  MOVWF  FF7
037C0:  MOVLW  00
037C2:  MOVWF  FF8
037C4:  CLRF   1B
037C6:  BTFSC  FF2.7
037C8:  BSF    1B.7
037CA:  BCF    FF2.7
037CC:  MOVLW  1A
037CE:  MOVLB  A
037D0:  MOVWF  x25
037D2:  MOVLB  0
037D4:  CALL   101E
037D8:  BTFSC  1B.7
037DA:  BSF    FF2.7
037DC:  MOVFF  9CE,9D6
037E0:  MOVLW  57
037E2:  MOVLB  9
037E4:  MOVWF  xD7
037E6:  MOVLB  0
037E8:  RCALL  3672
037EA:  MOVLW  0D
037EC:  BTFSS  F9E.4
037EE:  BRA    37EC
037F0:  MOVWF  FAD
037F2:  MOVLW  0A
037F4:  BTFSS  F9E.4
037F6:  BRA    37F4
037F8:  MOVWF  FAD
037FA:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
037FC:  MOVLW  48
037FE:  MOVLB  A
03800:  MOVWF  x11
03802:  CLRF   x15
03804:  CLRF   x14
03806:  MOVLW  01
03808:  MOVWF  x13
0380A:  MOVLW  AA
0380C:  MOVWF  x12
0380E:  MOVLB  0
03810:  RCALL  35A2
03812:  MOVFF  01,9CE
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
03816:  MOVF   1F,W
03818:  SUBLW  04
0381A:  BNZ   3862
0381C:  MOVF   20,F
0381E:  BNZ   3862
03820:  MOVLW  E0
03822:  MOVWF  FF6
03824:  MOVLW  06
03826:  MOVWF  FF7
03828:  MOVLW  00
0382A:  MOVWF  FF8
0382C:  CLRF   1B
0382E:  BTFSC  FF2.7
03830:  BSF    1B.7
03832:  BCF    FF2.7
03834:  MOVLW  25
03836:  MOVLB  A
03838:  MOVWF  x25
0383A:  MOVLB  0
0383C:  CALL   101E
03840:  BTFSC  1B.7
03842:  BSF    FF2.7
03844:  MOVFF  9CE,9D6
03848:  MOVLW  57
0384A:  MOVLB  9
0384C:  MOVWF  xD7
0384E:  MOVLB  0
03850:  RCALL  3672
03852:  MOVLW  0D
03854:  BTFSS  F9E.4
03856:  BRA    3854
03858:  MOVWF  FAD
0385A:  MOVLW  0A
0385C:  BTFSS  F9E.4
0385E:  BRA    385C
03860:  MOVWF  FAD
....................    if (response == 1)  
03862:  MOVLB  9
03864:  DECFSZ xCE,W
03866:  BRA    3C38
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
03868:  MOVF   1F,W
0386A:  SUBLW  04
0386C:  BNZ   3892
0386E:  MOVF   20,F
03870:  BNZ   3892
03872:  MOVLW  0A
03874:  MOVWF  FF6
03876:  MOVLW  07
03878:  MOVWF  FF7
0387A:  MOVLW  00
0387C:  MOVWF  FF8
0387E:  CLRF   1B
03880:  BTFSC  FF2.7
03882:  BSF    1B.7
03884:  BCF    FF2.7
03886:  MOVLB  0
03888:  CALL   0DCC
0388C:  BTFSC  1B.7
0388E:  BSF    FF2.7
03890:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
03892:  CLRF   xCD
03894:  MOVF   xCD,W
03896:  SUBLW  03
03898:  BNC   38B8
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
0389A:  CLRF   03
0389C:  MOVF   xCD,W
0389E:  ADDLW  CF
038A0:  MOVWF  FE9
038A2:  MOVLW  09
038A4:  ADDWFC 03,W
038A6:  MOVWF  FEA
038A8:  MOVF   FC9,W
038AA:  SETF   FC9
038AC:  RRCF   FC7,W
038AE:  BNC   38AC
038B0:  MOVFF  FC9,FEF
038B4:  INCF   xCD,F
038B6:  BRA    3894
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
038B8:  MOVF   1F,W
038BA:  SUBLW  04
038BC:  BNZ   3930
038BE:  MOVF   20,F
038C0:  BNZ   3930
038C2:  MOVLW  2C
038C4:  MOVWF  FF6
038C6:  MOVLW  07
038C8:  MOVWF  FF7
038CA:  MOVLW  00
038CC:  MOVWF  FF8
038CE:  CLRF   1B
038D0:  BTFSC  FF2.7
038D2:  BSF    1B.7
038D4:  BCF    FF2.7
038D6:  MOVLW  1F
038D8:  MOVLB  A
038DA:  MOVWF  x25
038DC:  MOVLB  0
038DE:  CALL   101E
038E2:  BTFSC  1B.7
038E4:  BSF    FF2.7
038E6:  MOVFF  9CF,9D6
038EA:  MOVLW  57
038EC:  MOVLB  9
038EE:  MOVWF  xD7
038F0:  MOVLB  0
038F2:  RCALL  3672
038F4:  MOVFF  9D0,9D6
038F8:  MOVLW  57
038FA:  MOVLB  9
038FC:  MOVWF  xD7
038FE:  MOVLB  0
03900:  RCALL  3672
03902:  MOVFF  9D1,9D6
03906:  MOVLW  57
03908:  MOVLB  9
0390A:  MOVWF  xD7
0390C:  MOVLB  0
0390E:  RCALL  3672
03910:  MOVFF  9D2,9D6
03914:  MOVLW  57
03916:  MOVLB  9
03918:  MOVWF  xD7
0391A:  MOVLB  0
0391C:  RCALL  3672
0391E:  MOVLW  0D
03920:  BTFSS  F9E.4
03922:  BRA    3920
03924:  MOVWF  FAD
03926:  MOVLW  0A
03928:  BTFSS  F9E.4
0392A:  BRA    3928
0392C:  MOVWF  FAD
0392E:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
03930:  DECFSZ xD1,W
03932:  BRA    3C0E
03934:  MOVF   xD2,W
03936:  SUBLW  AA
03938:  BTFSS  FD8.2
0393A:  BRA    3C0E
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
0393C:  MOVF   1F,W
0393E:  SUBLW  04
03940:  BNZ   3966
03942:  MOVF   20,F
03944:  BNZ   3966
03946:  MOVLW  5E
03948:  MOVWF  FF6
0394A:  MOVLW  07
0394C:  MOVWF  FF7
0394E:  MOVLW  00
03950:  MOVWF  FF8
03952:  CLRF   1B
03954:  BTFSC  FF2.7
03956:  BSF    1B.7
03958:  BCF    FF2.7
0395A:  MOVLB  0
0395C:  CALL   0DCC
03960:  BTFSC  1B.7
03962:  BSF    FF2.7
03964:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
03966:  MOVF   1F,W
03968:  SUBLW  04
0396A:  BNZ   3990
0396C:  MOVF   20,F
0396E:  BNZ   3990
03970:  MOVLW  84
03972:  MOVWF  FF6
03974:  MOVLW  07
03976:  MOVWF  FF7
03978:  MOVLW  00
0397A:  MOVWF  FF8
0397C:  CLRF   1B
0397E:  BTFSC  FF2.7
03980:  BSF    1B.7
03982:  BCF    FF2.7
03984:  MOVLB  0
03986:  CALL   0DCC
0398A:  BTFSC  1B.7
0398C:  BSF    FF2.7
0398E:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
03990:  CLRF   xD4
03992:  CLRF   xD3
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
03994:  MOVLW  77
03996:  MOVLB  A
03998:  MOVWF  x11
0399A:  CLRF   x15
0399C:  CLRF   x14
0399E:  CLRF   x13
039A0:  CLRF   x12
039A2:  MOVLB  0
039A4:  RCALL  35A2
039A6:  MOVFF  01,9CE
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
039AA:  MOVLW  69
039AC:  MOVLB  A
039AE:  MOVWF  x11
039B0:  MOVLW  40
039B2:  MOVWF  x15
039B4:  CLRF   x14
039B6:  CLRF   x13
039B8:  CLRF   x12
039BA:  MOVLB  0
039BC:  RCALL  35A2
039BE:  MOVFF  01,9CE
....................          while (response && (Timer < 50000)) 
039C2:  MOVLB  9
039C4:  MOVF   xCE,F
039C6:  BZ    3A18
039C8:  MOVF   xD4,W
039CA:  SUBLW  C3
039CC:  BNC   3A18
039CE:  BNZ   39D6
039D0:  MOVF   xD3,W
039D2:  SUBLW  4F
039D4:  BNC   3A18
....................          { 
....................             delay_us(20); 
039D6:  MOVLW  6A
039D8:  MOVWF  00
039DA:  DECFSZ 00,F
039DC:  BRA    39DA
039DE:  NOP   
....................             Timer++; 
039E0:  INCF   xD3,F
039E2:  BTFSC  FD8.2
039E4:  INCF   xD4,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
039E6:  MOVLW  77
039E8:  MOVLB  A
039EA:  MOVWF  x11
039EC:  CLRF   x15
039EE:  CLRF   x14
039F0:  CLRF   x13
039F2:  CLRF   x12
039F4:  MOVLB  0
039F6:  RCALL  35A2
039F8:  MOVFF  01,9CE
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
039FC:  MOVLW  69
039FE:  MOVLB  A
03A00:  MOVWF  x11
03A02:  MOVLW  40
03A04:  MOVWF  x15
03A06:  CLRF   x14
03A08:  CLRF   x13
03A0A:  CLRF   x12
03A0C:  MOVLB  0
03A0E:  RCALL  35A2
03A10:  MOVFF  01,9CE
03A14:  BRA    39C2
03A16:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
03A18:  MOVF   1F,W
03A1A:  SUBLW  04
03A1C:  BNZ   3AA6
03A1E:  MOVF   20,F
03A20:  BNZ   3AA6
03A22:  MOVLW  B2
03A24:  MOVWF  FF6
03A26:  MOVLW  07
03A28:  MOVWF  FF7
03A2A:  MOVLW  00
03A2C:  MOVWF  FF8
03A2E:  CLRF   1B
03A30:  BTFSC  FF2.7
03A32:  BSF    1B.7
03A34:  BCF    FF2.7
03A36:  MOVLW  23
03A38:  MOVLB  A
03A3A:  MOVWF  x25
03A3C:  MOVLB  0
03A3E:  CALL   101E
03A42:  BTFSC  1B.7
03A44:  BSF    FF2.7
03A46:  MOVFF  9CE,9D6
03A4A:  MOVLW  57
03A4C:  MOVLB  9
03A4E:  MOVWF  xD7
03A50:  MOVLB  0
03A52:  RCALL  3672
03A54:  MOVLW  D9
03A56:  MOVWF  FF6
03A58:  MOVLW  07
03A5A:  MOVWF  FF7
03A5C:  MOVLW  00
03A5E:  MOVWF  FF8
03A60:  CLRF   1B
03A62:  BTFSC  FF2.7
03A64:  BSF    1B.7
03A66:  BCF    FF2.7
03A68:  MOVLW  0A
03A6A:  MOVLB  A
03A6C:  MOVWF  x25
03A6E:  MOVLB  0
03A70:  CALL   101E
03A74:  BTFSC  1B.7
03A76:  BSF    FF2.7
03A78:  MOVLW  10
03A7A:  MOVWF  FE9
03A7C:  CLRF   1B
03A7E:  BTFSC  FF2.7
03A80:  BSF    1B.7
03A82:  BCF    FF2.7
03A84:  MOVFF  9D4,A26
03A88:  MOVFF  9D3,A25
03A8C:  CALL   11A0
03A90:  BTFSC  1B.7
03A92:  BSF    FF2.7
03A94:  MOVLW  0D
03A96:  BTFSS  F9E.4
03A98:  BRA    3A96
03A9A:  MOVWF  FAD
03A9C:  MOVLW  0A
03A9E:  BTFSS  F9E.4
03AA0:  BRA    3A9E
03AA2:  MOVWF  FAD
03AA4:  MOVLB  9
....................          if (!response) 
03AA6:  MOVF   xCE,F
03AA8:  BTFSS  FD8.2
03AAA:  BRA    3C0C
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
03AAC:  MOVLW  7A
03AAE:  MOVLB  A
03AB0:  MOVWF  x11
03AB2:  MOVLW  40
03AB4:  MOVWF  x15
03AB6:  CLRF   x14
03AB8:  CLRF   x13
03ABA:  CLRF   x12
03ABC:  MOVLB  0
03ABE:  RCALL  35A2
03AC0:  MOVFF  01,9CE
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
03AC4:  MOVF   1F,W
03AC6:  SUBLW  04
03AC8:  BNZ   3B10
03ACA:  MOVF   20,F
03ACC:  BNZ   3B10
03ACE:  MOVLW  EA
03AD0:  MOVWF  FF6
03AD2:  MOVLW  07
03AD4:  MOVWF  FF7
03AD6:  MOVLW  00
03AD8:  MOVWF  FF8
03ADA:  CLRF   1B
03ADC:  BTFSC  FF2.7
03ADE:  BSF    1B.7
03AE0:  BCF    FF2.7
03AE2:  MOVLW  18
03AE4:  MOVLB  A
03AE6:  MOVWF  x25
03AE8:  MOVLB  0
03AEA:  CALL   101E
03AEE:  BTFSC  1B.7
03AF0:  BSF    FF2.7
03AF2:  MOVFF  9CE,9D6
03AF6:  MOVLW  57
03AF8:  MOVLB  9
03AFA:  MOVWF  xD7
03AFC:  MOVLB  0
03AFE:  RCALL  3672
03B00:  MOVLW  0D
03B02:  BTFSS  F9E.4
03B04:  BRA    3B02
03B06:  MOVWF  FAD
03B08:  MOVLW  0A
03B0A:  BTFSS  F9E.4
03B0C:  BRA    3B0A
03B0E:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03B10:  MOVLB  9
03B12:  MOVF   xCE,F
03B14:  BTFSS  FD8.2
03B16:  BRA    3C0C
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03B18:  CLRF   xCD
03B1A:  MOVF   xCD,W
03B1C:  SUBLW  03
03B1E:  BNC   3B3E
....................                   ocr[i] = SD_spi_read(0xFF); 
03B20:  CLRF   03
03B22:  MOVF   xCD,W
03B24:  ADDLW  CF
03B26:  MOVWF  FE9
03B28:  MOVLW  09
03B2A:  ADDWFC 03,W
03B2C:  MOVWF  FEA
03B2E:  MOVF   FC9,W
03B30:  SETF   FC9
03B32:  RRCF   FC7,W
03B34:  BNC   3B32
03B36:  MOVFF  FC9,FEF
03B3A:  INCF   xCD,F
03B3C:  BRA    3B1A
....................                if (ocr[0] & 0x40) 
03B3E:  BTFSS  xCF.6
03B40:  BRA    3B4C
....................                   Card = SDHC; 
03B42:  MOVLW  05
03B44:  MOVLB  4
03B46:  MOVWF  xE3
03B48:  BRA    3B52
03B4A:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03B4C:  MOVLW  04
03B4E:  MOVLB  4
03B50:  MOVWF  xE3
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03B52:  MOVF   1F,W
03B54:  SUBLW  04
03B56:  BNZ   3C0A
03B58:  MOVF   20,F
03B5A:  BNZ   3C0A
03B5C:  MOVLW  08
03B5E:  MOVWF  FF6
03B60:  MOVLW  08
03B62:  MOVWF  FF7
03B64:  MOVLW  00
03B66:  MOVWF  FF8
03B68:  CLRF   1B
03B6A:  BTFSC  FF2.7
03B6C:  BSF    1B.7
03B6E:  BCF    FF2.7
03B70:  MOVLW  1F
03B72:  MOVLB  A
03B74:  MOVWF  x25
03B76:  MOVLB  0
03B78:  CALL   101E
03B7C:  BTFSC  1B.7
03B7E:  BSF    FF2.7
03B80:  MOVLW  10
03B82:  MOVWF  FE9
03B84:  CLRF   1B
03B86:  BTFSC  FF2.7
03B88:  BSF    1B.7
03B8A:  BCF    FF2.7
03B8C:  MOVFF  9D4,A26
03B90:  MOVFF  9D3,A25
03B94:  CALL   11A0
03B98:  BTFSC  1B.7
03B9A:  BSF    FF2.7
03B9C:  MOVLW  2A
03B9E:  MOVWF  FF6
03BA0:  MOVLW  08
03BA2:  MOVWF  FF7
03BA4:  MOVLW  00
03BA6:  MOVWF  FF8
03BA8:  CLRF   1B
03BAA:  BTFSC  FF2.7
03BAC:  BSF    1B.7
03BAE:  BCF    FF2.7
03BB0:  MOVLW  08
03BB2:  MOVLB  A
03BB4:  MOVWF  x25
03BB6:  MOVLB  0
03BB8:  CALL   101E
03BBC:  BTFSC  1B.7
03BBE:  BSF    FF2.7
03BC0:  MOVFF  9CF,9D6
03BC4:  MOVLW  57
03BC6:  MOVLB  9
03BC8:  MOVWF  xD7
03BCA:  MOVLB  0
03BCC:  RCALL  3672
03BCE:  MOVFF  9D0,9D6
03BD2:  MOVLW  57
03BD4:  MOVLB  9
03BD6:  MOVWF  xD7
03BD8:  MOVLB  0
03BDA:  RCALL  3672
03BDC:  MOVFF  9D1,9D6
03BE0:  MOVLW  57
03BE2:  MOVLB  9
03BE4:  MOVWF  xD7
03BE6:  MOVLB  0
03BE8:  RCALL  3672
03BEA:  MOVFF  9D2,9D6
03BEE:  MOVLW  57
03BF0:  MOVLB  9
03BF2:  MOVWF  xD7
03BF4:  MOVLB  0
03BF6:  RCALL  3672
03BF8:  MOVLW  0D
03BFA:  BTFSS  F9E.4
03BFC:  BRA    3BFA
03BFE:  MOVWF  FAD
03C00:  MOVLW  0A
03C02:  BTFSS  F9E.4
03C04:  BRA    3C02
03C06:  MOVWF  FAD
03C08:  MOVLB  4
03C0A:  MOVLB  9
....................             } 
....................          } 
....................       } 
03C0C:  BRA    3C38
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03C0E:  MOVF   1F,W
03C10:  SUBLW  04
03C12:  BNZ   3C38
03C14:  MOVF   20,F
03C16:  BNZ   3C38
03C18:  MOVLW  46
03C1A:  MOVWF  FF6
03C1C:  MOVLW  08
03C1E:  MOVWF  FF7
03C20:  MOVLW  00
03C22:  MOVWF  FF8
03C24:  CLRF   1B
03C26:  BTFSC  FF2.7
03C28:  BSF    1B.7
03C2A:  BCF    FF2.7
03C2C:  MOVLB  0
03C2E:  CALL   0DCC
03C32:  BTFSC  1B.7
03C34:  BSF    FF2.7
03C36:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03C38:  MOVLB  4
03C3A:  MOVF   xE3,F
03C3C:  BTFSS  FD8.2
03C3E:  BRA    410E
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03C40:  MOVF   1F,W
03C42:  SUBLW  04
03C44:  BNZ   3C6A
03C46:  MOVF   20,F
03C48:  BNZ   3C6A
03C4A:  MOVLW  78
03C4C:  MOVWF  FF6
03C4E:  MOVLW  08
03C50:  MOVWF  FF7
03C52:  MOVLW  00
03C54:  MOVWF  FF8
03C56:  CLRF   1B
03C58:  BTFSC  FF2.7
03C5A:  BSF    1B.7
03C5C:  BCF    FF2.7
03C5E:  MOVLB  0
03C60:  CALL   0DCC
03C64:  BTFSC  1B.7
03C66:  BSF    FF2.7
03C68:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03C6A:  MOVLW  40
03C6C:  MOVLB  A
03C6E:  MOVWF  x11
03C70:  CLRF   x15
03C72:  CLRF   x14
03C74:  CLRF   x13
03C76:  CLRF   x12
03C78:  MOVLB  0
03C7A:  RCALL  35A2
03C7C:  MOVFF  01,9CE
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03C80:  MOVF   1F,W
03C82:  SUBLW  04
03C84:  BNZ   3CCC
03C86:  MOVF   20,F
03C88:  BNZ   3CCC
03C8A:  MOVLW  B8
03C8C:  MOVWF  FF6
03C8E:  MOVLW  08
03C90:  MOVWF  FF7
03C92:  MOVLW  00
03C94:  MOVWF  FF8
03C96:  CLRF   1B
03C98:  BTFSC  FF2.7
03C9A:  BSF    1B.7
03C9C:  BCF    FF2.7
03C9E:  MOVLW  1C
03CA0:  MOVLB  A
03CA2:  MOVWF  x25
03CA4:  MOVLB  0
03CA6:  CALL   101E
03CAA:  BTFSC  1B.7
03CAC:  BSF    FF2.7
03CAE:  MOVFF  9CE,9D6
03CB2:  MOVLW  57
03CB4:  MOVLB  9
03CB6:  MOVWF  xD7
03CB8:  MOVLB  0
03CBA:  RCALL  3672
03CBC:  MOVLW  0D
03CBE:  BTFSS  F9E.4
03CC0:  BRA    3CBE
03CC2:  MOVWF  FAD
03CC4:  MOVLW  0A
03CC6:  BTFSS  F9E.4
03CC8:  BRA    3CC6
03CCA:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03CCC:  MOVLB  9
03CCE:  DECFSZ xCE,W
03CD0:  BRA    3CD4
03CD2:  BRA    3CDE
03CD4:  MOVF   xCE,F
03CD6:  BZ    3CDE
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03CD8:  BSF    xD5.0
....................          goto Exit_disk_initialize; 
03CDA:  GOTO   442C
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03CDE:  CLRF   xD4
03CE0:  CLRF   xD3
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03CE2:  MOVLW  41
03CE4:  MOVLB  A
03CE6:  MOVWF  x11
03CE8:  CLRF   x15
03CEA:  CLRF   x14
03CEC:  CLRF   x13
03CEE:  CLRF   x12
03CF0:  MOVLB  0
03CF2:  RCALL  35A2
03CF4:  MOVFF  01,9CE
....................          if (response != 0x00 ) 
03CF8:  MOVLB  9
03CFA:  MOVF   xCE,F
03CFC:  BZ    3D06
....................             delay_us(10); 
03CFE:  MOVLW  35
03D00:  MOVWF  00
03D02:  DECFSZ 00,F
03D04:  BRA    3D02
....................          Timer++; 
03D06:  INCF   xD3,F
03D08:  BTFSC  FD8.2
03D0A:  INCF   xD4,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03D0C:  MOVF   xCE,F
03D0E:  BZ    3D1E
03D10:  MOVF   xD4,W
03D12:  SUBLW  C3
03D14:  BNC   3D1E
03D16:  BNZ   3CE2
03D18:  MOVF   xD3,W
03D1A:  SUBLW  4F
03D1C:  BC    3CE2
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03D1E:  MOVF   1F,W
03D20:  SUBLW  04
03D22:  BNZ   3DAC
03D24:  MOVF   20,F
03D26:  BNZ   3DAC
03D28:  MOVLW  DC
03D2A:  MOVWF  FF6
03D2C:  MOVLW  08
03D2E:  MOVWF  FF7
03D30:  MOVLW  00
03D32:  MOVWF  FF8
03D34:  CLRF   1B
03D36:  BTFSC  FF2.7
03D38:  BSF    1B.7
03D3A:  BCF    FF2.7
03D3C:  MOVLW  28
03D3E:  MOVLB  A
03D40:  MOVWF  x25
03D42:  MOVLB  0
03D44:  CALL   101E
03D48:  BTFSC  1B.7
03D4A:  BSF    FF2.7
03D4C:  MOVFF  9CE,9D6
03D50:  MOVLW  57
03D52:  MOVLB  9
03D54:  MOVWF  xD7
03D56:  MOVLB  0
03D58:  RCALL  3672
03D5A:  MOVLW  08
03D5C:  MOVWF  FF6
03D5E:  MOVLW  09
03D60:  MOVWF  FF7
03D62:  MOVLW  00
03D64:  MOVWF  FF8
03D66:  CLRF   1B
03D68:  BTFSC  FF2.7
03D6A:  BSF    1B.7
03D6C:  BCF    FF2.7
03D6E:  MOVLW  0A
03D70:  MOVLB  A
03D72:  MOVWF  x25
03D74:  MOVLB  0
03D76:  CALL   101E
03D7A:  BTFSC  1B.7
03D7C:  BSF    FF2.7
03D7E:  MOVLW  10
03D80:  MOVWF  FE9
03D82:  CLRF   1B
03D84:  BTFSC  FF2.7
03D86:  BSF    1B.7
03D88:  BCF    FF2.7
03D8A:  MOVFF  9D4,A26
03D8E:  MOVFF  9D3,A25
03D92:  CALL   11A0
03D96:  BTFSC  1B.7
03D98:  BSF    FF2.7
03D9A:  MOVLW  0D
03D9C:  BTFSS  F9E.4
03D9E:  BRA    3D9C
03DA0:  MOVWF  FAD
03DA2:  MOVLW  0A
03DA4:  BTFSS  F9E.4
03DA6:  BRA    3DA4
03DA8:  MOVWF  FAD
03DAA:  MOVLB  9
....................       if(response) 
03DAC:  MOVF   xCE,F
03DAE:  BZ    3DB4
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03DB0:  BSF    xD5.0
....................          goto Exit_disk_initialize; 
03DB2:  BRA    442C
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03DB4:  MOVLW  77
03DB6:  MOVLB  A
03DB8:  MOVWF  x11
03DBA:  CLRF   x15
03DBC:  CLRF   x14
03DBE:  CLRF   x13
03DC0:  CLRF   x12
03DC2:  MOVLB  0
03DC4:  CALL   35A2
03DC8:  MOVFF  01,9CE
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03DCC:  MOVF   1F,W
03DCE:  SUBLW  04
03DD0:  BNZ   3E18
03DD2:  MOVF   20,F
03DD4:  BNZ   3E18
03DD6:  MOVLW  18
03DD8:  MOVWF  FF6
03DDA:  MOVLW  09
03DDC:  MOVWF  FF7
03DDE:  MOVLW  00
03DE0:  MOVWF  FF8
03DE2:  CLRF   1B
03DE4:  BTFSC  FF2.7
03DE6:  BSF    1B.7
03DE8:  BCF    FF2.7
03DEA:  MOVLW  43
03DEC:  MOVLB  A
03DEE:  MOVWF  x25
03DF0:  MOVLB  0
03DF2:  CALL   101E
03DF6:  BTFSC  1B.7
03DF8:  BSF    FF2.7
03DFA:  MOVFF  9CE,9D6
03DFE:  MOVLW  57
03E00:  MOVLB  9
03E02:  MOVWF  xD7
03E04:  MOVLB  0
03E06:  RCALL  3672
03E08:  MOVLW  0D
03E0A:  BTFSS  F9E.4
03E0C:  BRA    3E0A
03E0E:  MOVWF  FAD
03E10:  MOVLW  0A
03E12:  BTFSS  F9E.4
03E14:  BRA    3E12
03E16:  MOVWF  FAD
....................       if (response) 
03E18:  MOVLB  9
03E1A:  MOVF   xCE,F
03E1C:  BZ    3E28
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03E1E:  MOVLW  02
03E20:  MOVLB  4
03E22:  MOVWF  xE3
....................          } 
03E24:  BRA    4022
03E26:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03E28:  MOVLW  69
03E2A:  MOVLB  A
03E2C:  MOVWF  x11
03E2E:  CLRF   x15
03E30:  CLRF   x14
03E32:  CLRF   x13
03E34:  CLRF   x12
03E36:  MOVLB  0
03E38:  CALL   35A2
03E3C:  MOVFF  01,9CE
....................          if (response <= 1 ) 
03E40:  MOVLB  9
03E42:  MOVF   xCE,W
03E44:  SUBLW  01
03E46:  BNC   3E52
....................             Card = SDv1; 
03E48:  MOVLW  03
03E4A:  MOVLB  4
03E4C:  MOVWF  xE3
03E4E:  BRA    4022
03E50:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03E52:  MOVF   1F,W
03E54:  SUBLW  04
03E56:  BNZ   3EB6
03E58:  MOVF   20,F
03E5A:  BNZ   3EB6
03E5C:  MOVLW  62
03E5E:  MOVWF  FF6
03E60:  MOVLW  09
03E62:  MOVWF  FF7
03E64:  MOVLW  00
03E66:  MOVWF  FF8
03E68:  CLRF   1B
03E6A:  BTFSC  FF2.7
03E6C:  BSF    1B.7
03E6E:  BCF    FF2.7
03E70:  MOVLW  2E
03E72:  MOVLB  A
03E74:  MOVWF  x25
03E76:  MOVLB  0
03E78:  CALL   101E
03E7C:  BTFSC  1B.7
03E7E:  BSF    FF2.7
03E80:  MOVFF  9CE,9D6
03E84:  MOVLW  37
03E86:  MOVLB  9
03E88:  MOVWF  xD7
03E8A:  MOVLB  0
03E8C:  CALL   3672
03E90:  MOVLW  94
03E92:  MOVWF  FF6
03E94:  MOVLW  09
03E96:  MOVWF  FF7
03E98:  MOVLW  00
03E9A:  MOVWF  FF8
03E9C:  CLRF   1B
03E9E:  BTFSC  FF2.7
03EA0:  BSF    1B.7
03EA2:  BCF    FF2.7
03EA4:  MOVLW  19
03EA6:  MOVLB  A
03EA8:  MOVWF  x25
03EAA:  MOVLB  0
03EAC:  CALL   101E
03EB0:  BTFSC  1B.7
03EB2:  BSF    FF2.7
03EB4:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03EB6:  MOVLW  40
03EB8:  MOVLB  A
03EBA:  MOVWF  x11
03EBC:  CLRF   x15
03EBE:  CLRF   x14
03EC0:  CLRF   x13
03EC2:  CLRF   x12
03EC4:  MOVLB  0
03EC6:  CALL   35A2
03ECA:  MOVFF  01,9CE
....................             if ((response !=0x01) && (response != 0)) 
03ECE:  MOVLB  9
03ED0:  DECFSZ xCE,W
03ED2:  BRA    3ED6
03ED4:  BRA    3F42
03ED6:  MOVF   xCE,F
03ED8:  BZ    3F42
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03EDA:  MOVF   1F,W
03EDC:  SUBLW  04
03EDE:  BNZ   3F3E
03EE0:  MOVF   20,F
03EE2:  BNZ   3F3E
03EE4:  MOVLW  AE
03EE6:  MOVWF  FF6
03EE8:  MOVLW  09
03EEA:  MOVWF  FF7
03EEC:  MOVLW  00
03EEE:  MOVWF  FF8
03EF0:  CLRF   1B
03EF2:  BTFSC  FF2.7
03EF4:  BSF    1B.7
03EF6:  BCF    FF2.7
03EF8:  MOVLW  2C
03EFA:  MOVLB  A
03EFC:  MOVWF  x25
03EFE:  MOVLB  0
03F00:  CALL   101E
03F04:  BTFSC  1B.7
03F06:  BSF    FF2.7
03F08:  MOVFF  9CE,9D6
03F0C:  MOVLW  37
03F0E:  MOVLB  9
03F10:  MOVWF  xD7
03F12:  MOVLB  0
03F14:  CALL   3672
03F18:  MOVLW  DE
03F1A:  MOVWF  FF6
03F1C:  MOVLW  09
03F1E:  MOVWF  FF7
03F20:  MOVLW  00
03F22:  MOVWF  FF8
03F24:  CLRF   1B
03F26:  BTFSC  FF2.7
03F28:  BSF    1B.7
03F2A:  BCF    FF2.7
03F2C:  MOVLW  0B
03F2E:  MOVLB  A
03F30:  MOVWF  x25
03F32:  MOVLB  0
03F34:  CALL   101E
03F38:  BTFSC  1B.7
03F3A:  BSF    FF2.7
03F3C:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03F3E:  BSF    xD5.0
....................                goto Exit_disk_initialize; 
03F40:  BRA    442C
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03F42:  CLRF   xD4
03F44:  CLRF   xD3
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03F46:  MOVLW  41
03F48:  MOVLB  A
03F4A:  MOVWF  x11
03F4C:  CLRF   x15
03F4E:  CLRF   x14
03F50:  CLRF   x13
03F52:  CLRF   x12
03F54:  MOVLB  0
03F56:  CALL   35A2
03F5A:  MOVFF  01,9CE
....................                if (response != 0x00 ) 
03F5E:  MOVLB  9
03F60:  MOVF   xCE,F
03F62:  BZ    3F6C
....................                   delay_us(10); 
03F64:  MOVLW  35
03F66:  MOVWF  00
03F68:  DECFSZ 00,F
03F6A:  BRA    3F68
....................                Timer++; 
03F6C:  INCF   xD3,F
03F6E:  BTFSC  FD8.2
03F70:  INCF   xD4,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03F72:  MOVF   xCE,F
03F74:  BZ    3F84
03F76:  MOVF   xD4,W
03F78:  SUBLW  C3
03F7A:  BNC   3F84
03F7C:  BNZ   3F46
03F7E:  MOVF   xD3,W
03F80:  SUBLW  4F
03F82:  BC    3F46
....................     
....................             if(response) 
03F84:  MOVF   xCE,F
03F86:  BZ    401C
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03F88:  MOVF   1F,W
03F8A:  SUBLW  04
03F8C:  BNZ   4018
03F8E:  MOVF   20,F
03F90:  BNZ   4018
03F92:  MOVLW  EA
03F94:  MOVWF  FF6
03F96:  MOVLW  09
03F98:  MOVWF  FF7
03F9A:  MOVLW  00
03F9C:  MOVWF  FF8
03F9E:  CLRF   1B
03FA0:  BTFSC  FF2.7
03FA2:  BSF    1B.7
03FA4:  BCF    FF2.7
03FA6:  MOVLW  4A
03FA8:  MOVLB  A
03FAA:  MOVWF  x25
03FAC:  MOVLB  0
03FAE:  CALL   101E
03FB2:  BTFSC  1B.7
03FB4:  BSF    FF2.7
03FB6:  MOVFF  9CE,9D6
03FBA:  MOVLW  37
03FBC:  MOVLB  9
03FBE:  MOVWF  xD7
03FC0:  MOVLB  0
03FC2:  CALL   3672
03FC6:  MOVLW  38
03FC8:  MOVWF  FF6
03FCA:  MOVLW  0A
03FCC:  MOVWF  FF7
03FCE:  MOVLW  00
03FD0:  MOVWF  FF8
03FD2:  CLRF   1B
03FD4:  BTFSC  FF2.7
03FD6:  BSF    1B.7
03FD8:  BCF    FF2.7
03FDA:  MOVLW  0A
03FDC:  MOVLB  A
03FDE:  MOVWF  x25
03FE0:  MOVLB  0
03FE2:  CALL   101E
03FE6:  BTFSC  1B.7
03FE8:  BSF    FF2.7
03FEA:  MOVLW  10
03FEC:  MOVWF  FE9
03FEE:  CLRF   1B
03FF0:  BTFSC  FF2.7
03FF2:  BSF    1B.7
03FF4:  BCF    FF2.7
03FF6:  MOVFF  9D4,A26
03FFA:  MOVFF  9D3,A25
03FFE:  CALL   11A0
04002:  BTFSC  1B.7
04004:  BSF    FF2.7
04006:  MOVLW  0D
04008:  BTFSS  F9E.4
0400A:  BRA    4008
0400C:  MOVWF  FAD
0400E:  MOVLW  0A
04010:  BTFSS  F9E.4
04012:  BRA    4010
04014:  MOVWF  FAD
04016:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
04018:  BSF    xD5.0
....................                goto Exit_disk_initialize; 
0401A:  BRA    442C
....................                } 
....................  
....................             Card = MMC; 
0401C:  MOVLW  02
0401E:  MOVLB  4
04020:  MOVWF  xE3
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
04022:  MOVF   1F,W
04024:  SUBLW  04
04026:  BNZ   404C
04028:  MOVF   20,F
0402A:  BNZ   404C
0402C:  MOVLW  48
0402E:  MOVWF  FF6
04030:  MOVLW  0A
04032:  MOVWF  FF7
04034:  MOVLW  00
04036:  MOVWF  FF8
04038:  CLRF   1B
0403A:  BTFSC  FF2.7
0403C:  BSF    1B.7
0403E:  BCF    FF2.7
04040:  MOVLB  0
04042:  CALL   0DCC
04046:  BTFSC  1B.7
04048:  BSF    FF2.7
0404A:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
0404C:  MOVLW  50
0404E:  MOVLB  A
04050:  MOVWF  x11
04052:  CLRF   x15
04054:  CLRF   x14
04056:  MOVLW  02
04058:  MOVWF  x13
0405A:  CLRF   x12
0405C:  MOVLB  0
0405E:  CALL   35A2
04062:  MOVFF  01,9CE
....................       if ((Timer == 50000) || (response > 1))    
04066:  MOVLB  9
04068:  MOVF   xD3,W
0406A:  SUBLW  50
0406C:  BNZ   4074
0406E:  MOVF   xD4,W
04070:  SUBLW  C3
04072:  BZ    407A
04074:  MOVF   xCE,W
04076:  SUBLW  01
04078:  BC    4110
....................       { 
....................          Card = None; 
0407A:  MOVLB  4
0407C:  CLRF   xE3
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
0407E:  MOVF   1F,W
04080:  SUBLW  04
04082:  BNZ   410E
04084:  MOVF   20,F
04086:  BNZ   410E
04088:  MOVLW  64
0408A:  MOVWF  FF6
0408C:  MOVLW  0A
0408E:  MOVWF  FF7
04090:  MOVLW  00
04092:  MOVWF  FF8
04094:  CLRF   1B
04096:  BTFSC  FF2.7
04098:  BSF    1B.7
0409A:  BCF    FF2.7
0409C:  MOVLW  2B
0409E:  MOVLB  A
040A0:  MOVWF  x25
040A2:  MOVLB  0
040A4:  CALL   101E
040A8:  BTFSC  1B.7
040AA:  BSF    FF2.7
040AC:  MOVFF  9CE,9D6
040B0:  MOVLW  57
040B2:  MOVLB  9
040B4:  MOVWF  xD7
040B6:  MOVLB  0
040B8:  CALL   3672
040BC:  MOVLW  93
040BE:  MOVWF  FF6
040C0:  MOVLW  0A
040C2:  MOVWF  FF7
040C4:  MOVLW  00
040C6:  MOVWF  FF8
040C8:  CLRF   1B
040CA:  BTFSC  FF2.7
040CC:  BSF    1B.7
040CE:  BCF    FF2.7
040D0:  MOVLW  0A
040D2:  MOVLB  A
040D4:  MOVWF  x25
040D6:  MOVLB  0
040D8:  CALL   101E
040DC:  BTFSC  1B.7
040DE:  BSF    FF2.7
040E0:  MOVLW  10
040E2:  MOVWF  FE9
040E4:  CLRF   1B
040E6:  BTFSC  FF2.7
040E8:  BSF    1B.7
040EA:  BCF    FF2.7
040EC:  MOVFF  9D4,A26
040F0:  MOVFF  9D3,A25
040F4:  CALL   11A0
040F8:  BTFSC  1B.7
040FA:  BSF    FF2.7
040FC:  MOVLW  0D
040FE:  BTFSS  F9E.4
04100:  BRA    40FE
04102:  MOVWF  FAD
04104:  MOVLW  0A
04106:  BTFSS  F9E.4
04108:  BRA    4106
0410A:  MOVWF  FAD
0410C:  MOVLB  4
0410E:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
04110:  MOVLB  4
04112:  MOVF   xE3,F
04114:  BNZ   4148
....................    { 
....................       if (nv_report_mode == 4) 
04116:  MOVF   1F,W
04118:  SUBLW  04
0411A:  BNZ   4140
0411C:  MOVF   20,F
0411E:  BNZ   4140
....................          printf("@FS:Card Type Discovery Error\r\n"); 
04120:  MOVLW  A4
04122:  MOVWF  FF6
04124:  MOVLW  0A
04126:  MOVWF  FF7
04128:  MOVLW  00
0412A:  MOVWF  FF8
0412C:  CLRF   1B
0412E:  BTFSC  FF2.7
04130:  BSF    1B.7
04132:  BCF    FF2.7
04134:  MOVLB  0
04136:  CALL   0DCC
0413A:  BTFSC  1B.7
0413C:  BSF    FF2.7
0413E:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
04140:  MOVLB  9
04142:  BSF    xD5.0
....................       goto Exit_disk_initialize; 
04144:  BRA    442C
04146:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
04148:  MOVF   xE3,W
0414A:  XORLW  02
0414C:  MOVLB  0
0414E:  BZ    415E
04150:  XORLW  01
04152:  BZ    4186
04154:  XORLW  07
04156:  BZ    41AE
04158:  XORLW  01
0415A:  BZ    41D6
0415C:  BRA    41FE
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
0415E:  MOVF   1F,W
04160:  SUBLW  04
04162:  BNZ   4184
04164:  MOVF   20,F
04166:  BNZ   4184
04168:  MOVLW  C4
0416A:  MOVWF  FF6
0416C:  MOVLW  0A
0416E:  MOVWF  FF7
04170:  MOVLW  00
04172:  MOVWF  FF8
04174:  CLRF   1B
04176:  BTFSC  FF2.7
04178:  BSF    1B.7
0417A:  BCF    FF2.7
0417C:  CALL   0DCC
04180:  BTFSC  1B.7
04182:  BSF    FF2.7
....................          break; 
04184:  BRA    4254
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
04186:  MOVF   1F,W
04188:  SUBLW  04
0418A:  BNZ   41AC
0418C:  MOVF   20,F
0418E:  BNZ   41AC
04190:  MOVLW  DA
04192:  MOVWF  FF6
04194:  MOVLW  0A
04196:  MOVWF  FF7
04198:  MOVLW  00
0419A:  MOVWF  FF8
0419C:  CLRF   1B
0419E:  BTFSC  FF2.7
041A0:  BSF    1B.7
041A2:  BCF    FF2.7
041A4:  CALL   0DCC
041A8:  BTFSC  1B.7
041AA:  BSF    FF2.7
....................          break; 
041AC:  BRA    4254
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
041AE:  MOVF   1F,W
041B0:  SUBLW  04
041B2:  BNZ   41D4
041B4:  MOVF   20,F
041B6:  BNZ   41D4
041B8:  MOVLW  F0
041BA:  MOVWF  FF6
041BC:  MOVLW  0A
041BE:  MOVWF  FF7
041C0:  MOVLW  00
041C2:  MOVWF  FF8
041C4:  CLRF   1B
041C6:  BTFSC  FF2.7
041C8:  BSF    1B.7
041CA:  BCF    FF2.7
041CC:  CALL   0DCC
041D0:  BTFSC  1B.7
041D2:  BSF    FF2.7
....................          break; 
041D4:  BRA    4254
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
041D6:  MOVF   1F,W
041D8:  SUBLW  04
041DA:  BNZ   41FC
041DC:  MOVF   20,F
041DE:  BNZ   41FC
041E0:  MOVLW  06
041E2:  MOVWF  FF6
041E4:  MOVLW  0B
041E6:  MOVWF  FF7
041E8:  MOVLW  00
041EA:  MOVWF  FF8
041EC:  CLRF   1B
041EE:  BTFSC  FF2.7
041F0:  BSF    1B.7
041F2:  BCF    FF2.7
041F4:  CALL   0DCC
041F8:  BTFSC  1B.7
041FA:  BSF    FF2.7
....................          break; 
041FC:  BRA    4254
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
041FE:  MOVF   1F,W
04200:  SUBLW  04
04202:  BNZ   424C
04204:  MOVF   20,F
04206:  BNZ   424C
04208:  MOVLW  1C
0420A:  MOVWF  FF6
0420C:  MOVLW  0B
0420E:  MOVWF  FF7
04210:  MOVLW  00
04212:  MOVWF  FF8
04214:  CLRF   1B
04216:  BTFSC  FF2.7
04218:  BSF    1B.7
0421A:  BCF    FF2.7
0421C:  MOVLW  26
0421E:  MOVLB  A
04220:  MOVWF  x25
04222:  MOVLB  0
04224:  CALL   101E
04228:  BTFSC  1B.7
0422A:  BSF    FF2.7
0422C:  MOVFF  4E3,9D6
04230:  MOVLW  37
04232:  MOVLB  9
04234:  MOVWF  xD7
04236:  MOVLB  0
04238:  CALL   3672
0423C:  MOVLW  0D
0423E:  BTFSS  F9E.4
04240:  BRA    423E
04242:  MOVWF  FAD
04244:  MOVLW  0A
04246:  BTFSS  F9E.4
04248:  BRA    4246
0424A:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
0424C:  MOVLB  9
0424E:  BSF    xD5.0
....................          goto Exit_disk_initialize; 
04250:  BRA    442C
04252:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
04254:  MOVLB  9
04256:  BCF    xD5.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
04258:  MOVF   1F,W
0425A:  SUBLW  04
0425C:  BNZ   42B4
0425E:  MOVF   20,F
04260:  BNZ   42B4
04262:  MOVLW  4A
04264:  MOVWF  FF6
04266:  MOVLW  0B
04268:  MOVWF  FF7
0426A:  MOVLW  00
0426C:  MOVWF  FF8
0426E:  CLRF   1B
04270:  BTFSC  FF2.7
04272:  BSF    1B.7
04274:  BCF    FF2.7
04276:  MOVLW  2E
04278:  MOVLB  A
0427A:  MOVWF  x25
0427C:  MOVLB  0
0427E:  CALL   101E
04282:  BTFSC  1B.7
04284:  BSF    FF2.7
04286:  MOVLW  10
04288:  MOVWF  FE9
0428A:  CLRF   1B
0428C:  BTFSC  FF2.7
0428E:  BSF    1B.7
04290:  BCF    FF2.7
04292:  MOVFF  9D4,A26
04296:  MOVFF  9D3,A25
0429A:  CALL   11A0
0429E:  BTFSC  1B.7
042A0:  BSF    FF2.7
042A2:  MOVLW  0D
042A4:  BTFSS  F9E.4
042A6:  BRA    42A4
042A8:  MOVWF  FAD
042AA:  MOVLW  0A
042AC:  BTFSS  F9E.4
042AE:  BRA    42AC
042B0:  MOVWF  FAD
042B2:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
042B4:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
042B6:  BCF    FC6.5
042B8:  MOVLW  20
042BA:  MOVWF  FC6
042BC:  MOVLW  40
042BE:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
042C0:  BCF    F9E.3
....................    SelectSD; 
042C2:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
042C4:  MOVF   1F,W
042C6:  SUBLW  04
042C8:  BNZ   42EE
042CA:  MOVF   20,F
042CC:  BNZ   42EE
042CE:  MOVLW  7E
042D0:  MOVWF  FF6
042D2:  MOVLW  0B
042D4:  MOVWF  FF7
042D6:  MOVLW  00
042D8:  MOVWF  FF8
042DA:  CLRF   1B
042DC:  BTFSC  FF2.7
042DE:  BSF    1B.7
042E0:  BCF    FF2.7
042E2:  MOVLB  0
042E4:  CALL   0DCC
042E8:  BTFSC  1B.7
042EA:  BSF    FF2.7
042EC:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
042EE:  CLRF   xD4
042F0:  CLRF   xD3
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
042F2:  MOVLW  41
042F4:  MOVLB  A
042F6:  MOVWF  x11
042F8:  CLRF   x15
042FA:  CLRF   x14
042FC:  CLRF   x13
042FE:  CLRF   x12
04300:  MOVLB  0
04302:  CALL   35A2
04306:  MOVFF  01,9CE
....................       if (response != 0x00 ) 
0430A:  MOVLB  9
0430C:  MOVF   xCE,F
0430E:  BZ    4318
....................          delay_us(10); 
04310:  MOVLW  35
04312:  MOVWF  00
04314:  DECFSZ 00,F
04316:  BRA    4314
....................  
....................       Timer++; 
04318:  INCF   xD3,F
0431A:  BTFSC  FD8.2
0431C:  INCF   xD4,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
0431E:  MOVF   xCE,F
04320:  BZ    4330
04322:  MOVF   xD4,W
04324:  SUBLW  C3
04326:  BNC   4330
04328:  BNZ   42F2
0432A:  MOVF   xD3,W
0432C:  SUBLW  4F
0432E:  BC    42F2
....................  
....................    if (response != 0x00) 
04330:  MOVF   xCE,F
04332:  BZ    43C8
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
04334:  MOVF   1F,W
04336:  SUBLW  04
04338:  BNZ   43C4
0433A:  MOVF   20,F
0433C:  BNZ   43C4
0433E:  MOVLW  9E
04340:  MOVWF  FF6
04342:  MOVLW  0B
04344:  MOVWF  FF7
04346:  MOVLW  00
04348:  MOVWF  FF8
0434A:  CLRF   1B
0434C:  BTFSC  FF2.7
0434E:  BSF    1B.7
04350:  BCF    FF2.7
04352:  MOVLW  26
04354:  MOVLB  A
04356:  MOVWF  x25
04358:  MOVLB  0
0435A:  CALL   101E
0435E:  BTFSC  1B.7
04360:  BSF    FF2.7
04362:  MOVFF  9CE,9D6
04366:  MOVLW  37
04368:  MOVLB  9
0436A:  MOVWF  xD7
0436C:  MOVLB  0
0436E:  CALL   3672
04372:  MOVLW  C8
04374:  MOVWF  FF6
04376:  MOVLW  0B
04378:  MOVWF  FF7
0437A:  MOVLW  00
0437C:  MOVWF  FF8
0437E:  CLRF   1B
04380:  BTFSC  FF2.7
04382:  BSF    1B.7
04384:  BCF    FF2.7
04386:  MOVLW  0A
04388:  MOVLB  A
0438A:  MOVWF  x25
0438C:  MOVLB  0
0438E:  CALL   101E
04392:  BTFSC  1B.7
04394:  BSF    FF2.7
04396:  MOVLW  10
04398:  MOVWF  FE9
0439A:  CLRF   1B
0439C:  BTFSC  FF2.7
0439E:  BSF    1B.7
043A0:  BCF    FF2.7
043A2:  MOVFF  9D4,A26
043A6:  MOVFF  9D3,A25
043AA:  CALL   11A0
043AE:  BTFSC  1B.7
043B0:  BSF    FF2.7
043B2:  MOVLW  0D
043B4:  BTFSS  F9E.4
043B6:  BRA    43B4
043B8:  MOVWF  FAD
043BA:  MOVLW  0A
043BC:  BTFSS  F9E.4
043BE:  BRA    43BC
043C0:  MOVWF  FAD
043C2:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
043C4:  BSF    xD5.0
....................       goto Exit_disk_initialize; 
043C6:  BRA    442C
....................    } 
....................  
....................    if (nv_report_mode == 4) 
043C8:  MOVF   1F,W
043CA:  SUBLW  04
043CC:  BNZ   4424
043CE:  MOVF   20,F
043D0:  BNZ   4424
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
043D2:  MOVLW  D8
043D4:  MOVWF  FF6
043D6:  MOVLW  0B
043D8:  MOVWF  FF7
043DA:  MOVLW  00
043DC:  MOVWF  FF8
043DE:  CLRF   1B
043E0:  BTFSC  FF2.7
043E2:  BSF    1B.7
043E4:  BCF    FF2.7
043E6:  MOVLW  25
043E8:  MOVLB  A
043EA:  MOVWF  x25
043EC:  MOVLB  0
043EE:  CALL   101E
043F2:  BTFSC  1B.7
043F4:  BSF    FF2.7
043F6:  MOVLW  10
043F8:  MOVWF  FE9
043FA:  CLRF   1B
043FC:  BTFSC  FF2.7
043FE:  BSF    1B.7
04400:  BCF    FF2.7
04402:  MOVFF  9D4,A26
04406:  MOVFF  9D3,A25
0440A:  CALL   11A0
0440E:  BTFSC  1B.7
04410:  BSF    FF2.7
04412:  MOVLW  0D
04414:  BTFSS  F9E.4
04416:  BRA    4414
04418:  MOVWF  FAD
0441A:  MOVLW  0A
0441C:  BTFSS  F9E.4
0441E:  BRA    441C
04420:  MOVWF  FAD
04422:  MOVLB  9
....................  
....................    msg_card_ok(); 
04424:  MOVLB  0
04426:  GOTO   36B8
0442A:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
0442C:  BSF    F91.1
....................    return(SDCardStatus); 
0442E:  MOVFF  9D5,01
04432:  MOVLB  0
04434:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05AD6:  MOVLW  20
05AD8:  MOVLB  7
05ADA:  ADDWF  x0E,W
05ADC:  MOVWF  FE9
05ADE:  MOVLW  00
05AE0:  ADDWFC x0F,W
05AE2:  MOVWF  FEA
05AE4:  MOVFF  FEF,9FE
05AE8:  MOVFF  FEC,9FF
05AEC:  MOVFF  FEC,A00
05AF0:  MOVFF  FEC,A01
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05AF4:  MOVLB  9
05AF6:  MOVF   xFA,W
05AF8:  SUBWF  xFE,W
05AFA:  BNZ   5B1E
05AFC:  MOVF   xFB,W
05AFE:  SUBWF  xFF,W
05B00:  BNZ   5B1E
05B02:  MOVF   xFC,W
05B04:  MOVLB  A
05B06:  SUBWF  x00,W
05B08:  BTFSC  FD8.2
05B0A:  BRA    5B10
05B0C:  MOVLB  9
05B0E:  BRA    5B1E
05B10:  MOVLB  9
05B12:  MOVF   xFD,W
05B14:  MOVLB  A
05B16:  SUBWF  x01,W
05B18:  BTFSC  FD8.2
05B1A:  BRA    5D0C
05B1C:  MOVLB  9
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05B1E:  MOVLW  06
05B20:  MOVLB  7
05B22:  ADDWF  x0E,W
05B24:  MOVWF  FE9
05B26:  MOVLW  00
05B28:  ADDWFC x0F,W
05B2A:  MOVWF  FEA
05B2C:  MOVF   FEF,F
05B2E:  BTFSC  FD8.2
05B30:  BRA    5C94
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05B32:  MOVLW  24
05B34:  ADDWF  x0E,W
05B36:  MOVWF  01
05B38:  MOVLW  00
05B3A:  ADDWFC x0F,W
05B3C:  MOVWF  03
05B3E:  MOVFF  01,A04
05B42:  MOVLB  A
05B44:  MOVWF  x05
05B46:  MOVWF  x07
05B48:  MOVFF  01,A06
05B4C:  MOVFF  A01,A0B
05B50:  MOVFF  A00,A0A
05B54:  MOVFF  9FF,A09
05B58:  MOVFF  9FE,A08
05B5C:  MOVLW  01
05B5E:  MOVWF  x0C
05B60:  MOVLB  0
05B62:  RCALL  5992
05B64:  MOVFF  01,A02
....................             if (response != RES_OK) 
05B68:  MOVLB  A
05B6A:  MOVF   x02,F
05B6C:  BZ    5B74
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05B6E:  MOVLW  00
05B70:  MOVWF  01
05B72:  BRA    5D10
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05B74:  MOVLW  06
05B76:  MOVLB  7
05B78:  ADDWF  x0E,W
05B7A:  MOVWF  FE9
05B7C:  MOVLW  00
05B7E:  ADDWFC x0F,W
05B80:  MOVWF  FEA
05B82:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05B84:  MOVLW  10
05B86:  ADDWF  x0E,W
05B88:  MOVWF  FE9
05B8A:  MOVLW  00
05B8C:  ADDWFC x0F,W
05B8E:  MOVWF  FEA
05B90:  MOVFF  FEF,A04
05B94:  MOVFF  FEC,A05
05B98:  MOVFF  FEC,A06
05B9C:  MOVFF  FEC,A07
05BA0:  MOVLW  08
05BA2:  ADDWF  x0E,W
05BA4:  MOVWF  FE9
05BA6:  MOVLW  00
05BA8:  ADDWFC x0F,W
05BAA:  MOVWF  FEA
05BAC:  MOVFF  FEF,00
05BB0:  MOVFF  FEC,01
05BB4:  MOVFF  FEC,02
05BB8:  MOVFF  FEC,03
05BBC:  MOVLB  A
05BBE:  MOVF   x04,W
05BC0:  ADDWF  00,F
05BC2:  MOVF   x05,W
05BC4:  ADDWFC 01,F
05BC6:  MOVF   x06,W
05BC8:  ADDWFC 02,F
05BCA:  MOVF   x07,W
05BCC:  ADDWFC 03,F
05BCE:  MOVF   x01,W
05BD0:  SUBWF  03,W
05BD2:  BNC   5C92
05BD4:  BNZ   5C02
05BD6:  MOVF   x00,W
05BD8:  SUBWF  02,W
05BDA:  BNC   5C92
05BDC:  BNZ   5C02
05BDE:  MOVLB  9
05BE0:  MOVF   xFF,W
05BE2:  SUBWF  01,W
05BE4:  BTFSC  FD8.0
05BE6:  BRA    5BEC
05BE8:  MOVLB  A
05BEA:  BRA    5C92
05BEC:  BTFSC  FD8.2
05BEE:  BRA    5BF4
05BF0:  MOVLB  A
05BF2:  BRA    5C02
05BF4:  MOVF   00,W
05BF6:  SUBWF  xFE,W
05BF8:  BTFSS  FD8.0
05BFA:  BRA    5C00
05BFC:  MOVLB  A
05BFE:  BRA    5C92
05C00:  MOVLB  A
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05C02:  MOVLW  03
05C04:  MOVLB  7
05C06:  ADDWF  x0E,W
05C08:  MOVWF  FE9
05C0A:  MOVLW  00
05C0C:  ADDWFC x0F,W
05C0E:  MOVWF  FEA
05C10:  MOVFF  FEF,A03
05C14:  MOVLB  A
05C16:  MOVF   x03,W
05C18:  SUBLW  01
05C1A:  BC    5C92
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05C1C:  MOVLW  08
05C1E:  MOVLB  7
05C20:  ADDWF  x0E,W
05C22:  MOVWF  FE9
05C24:  MOVLW  00
05C26:  ADDWFC x0F,W
05C28:  MOVWF  FEA
05C2A:  MOVFF  FEF,00
05C2E:  MOVFF  FEC,01
05C32:  MOVFF  FEC,02
05C36:  MOVFF  FEC,03
05C3A:  MOVF   00,W
05C3C:  MOVLB  9
05C3E:  ADDWF  xFE,F
05C40:  MOVF   01,W
05C42:  ADDWFC xFF,F
05C44:  MOVF   02,W
05C46:  MOVLB  A
05C48:  ADDWFC x00,F
05C4A:  MOVF   03,W
05C4C:  ADDWFC x01,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05C4E:  MOVLW  24
05C50:  MOVLB  7
05C52:  ADDWF  x0E,W
05C54:  MOVWF  01
05C56:  MOVLW  00
05C58:  ADDWFC x0F,W
05C5A:  MOVWF  03
05C5C:  MOVFF  01,A04
05C60:  MOVLB  A
05C62:  MOVWF  x05
05C64:  MOVWF  x07
05C66:  MOVFF  01,A06
05C6A:  MOVFF  A01,A0B
05C6E:  MOVFF  A00,A0A
05C72:  MOVFF  9FF,A09
05C76:  MOVFF  9FE,A08
05C7A:  MOVLW  01
05C7C:  MOVWF  x0C
05C7E:  MOVLB  0
05C80:  RCALL  5992
05C82:  MOVF   01,F
05C84:  BZ    5C8C
....................                      break; 
05C86:  MOVLB  A
05C88:  BRA    5C92
05C8A:  MOVLB  0
05C8C:  MOVLB  A
05C8E:  DECF   x03,F
05C90:  BRA    5C16
05C92:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05C94:  MOVLB  9
05C96:  MOVF   xFA,F
05C98:  BNZ   5CA6
05C9A:  MOVF   xFB,F
05C9C:  BNZ   5CA6
05C9E:  MOVF   xFC,F
05CA0:  BNZ   5CA6
05CA2:  MOVF   xFD,F
05CA4:  BZ    5D0A
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05CA6:  MOVLW  24
05CA8:  MOVLB  7
05CAA:  ADDWF  x0E,W
05CAC:  MOVWF  01
05CAE:  MOVLW  00
05CB0:  ADDWFC x0F,W
05CB2:  MOVWF  03
05CB4:  MOVFF  01,A04
05CB8:  MOVLB  A
05CBA:  MOVWF  x05
05CBC:  MOVWF  x07
05CBE:  MOVFF  01,A06
05CC2:  MOVFF  9FD,A0B
05CC6:  MOVFF  9FC,A0A
05CCA:  MOVFF  9FB,A09
05CCE:  MOVFF  9FA,A08
05CD2:  MOVLW  01
05CD4:  MOVWF  x0C
05CD6:  MOVLB  0
05CD8:  CALL   452E
05CDC:  MOVF   01,F
05CDE:  BZ    5CEA
....................             return FALSE; 
05CE0:  MOVLW  00
05CE2:  MOVWF  01
05CE4:  MOVLB  A
05CE6:  BRA    5D10
05CE8:  MOVLB  0
....................          fs->winsect = sector; 
05CEA:  MOVLW  20
05CEC:  MOVLB  7
05CEE:  ADDWF  x0E,W
05CF0:  MOVWF  FE9
05CF2:  MOVLW  00
05CF4:  ADDWFC x0F,W
05CF6:  MOVWF  FEA
05CF8:  MOVFF  9FA,FEF
05CFC:  MOVFF  9FB,FEC
05D00:  MOVFF  9FC,FEC
05D04:  MOVFF  9FD,FEC
05D08:  MOVLB  9
05D0A:  MOVLB  A
....................          } 
....................       } 
....................    return (TRUE); 
05D0C:  MOVLW  01
05D0E:  MOVWF  01
05D10:  MOVLB  0
05D12:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05D36:  MOVLB  9
05D38:  MOVF   xE9,F
05D3A:  BNZ   5D4C
05D3C:  MOVF   xE8,F
05D3E:  BNZ   5D4C
05D40:  MOVF   xE7,F
05D42:  BNZ   5D4C
05D44:  MOVF   xE6,W
05D46:  SUBLW  01
05D48:  BTFSC  FD8.0
05D4A:  BRA    605C
05D4C:  MOVLW  0C
05D4E:  MOVLB  7
05D50:  ADDWF  x0E,W
05D52:  MOVWF  FE9
05D54:  MOVLW  00
05D56:  ADDWFC x0F,W
05D58:  MOVWF  FEA
05D5A:  MOVFF  FEF,00
05D5E:  MOVFF  FEC,01
05D62:  MOVFF  FEC,02
05D66:  MOVFF  FEC,03
05D6A:  MOVLB  9
05D6C:  MOVF   xE9,W
05D6E:  SUBWF  03,W
05D70:  BTFSS  FD8.0
05D72:  BRA    605C
05D74:  BNZ   5D92
05D76:  MOVF   xE8,W
05D78:  SUBWF  02,W
05D7A:  BTFSS  FD8.0
05D7C:  BRA    605C
05D7E:  BNZ   5D92
05D80:  MOVF   xE7,W
05D82:  SUBWF  01,W
05D84:  BTFSS  FD8.0
05D86:  BRA    605C
05D88:  BNZ   5D92
05D8A:  MOVF   00,W
05D8C:  SUBWF  xE6,W
05D8E:  BTFSC  FD8.0
05D90:  BRA    605C
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05D92:  MOVLW  10
05D94:  MOVLB  7
05D96:  ADDWF  x0E,W
05D98:  MOVWF  FE9
05D9A:  MOVLW  00
05D9C:  ADDWFC x0F,W
05D9E:  MOVWF  FEA
05DA0:  MOVFF  FEF,9EE
05DA4:  MOVFF  FEC,9EF
05DA8:  MOVFF  FEC,9F0
05DAC:  MOVFF  FEC,9F1
....................       switch (fs->fs_type)  
05DB0:  MOVF   x0E,W
05DB2:  MOVWF  FE9
05DB4:  MOVF   x0F,W
05DB6:  MOVWF  FEA
05DB8:  MOVF   FEF,W
05DBA:  XORLW  01
05DBC:  MOVLB  0
05DBE:  BZ    5DCE
05DC0:  XORLW  03
05DC2:  BTFSC  FD8.2
05DC4:  BRA    5F14
05DC6:  XORLW  01
05DC8:  BTFSC  FD8.2
05DCA:  BRA    5F96
05DCC:  BRA    605E
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05DCE:  MOVFF  9E7,9F7
05DD2:  MOVFF  9E6,9F6
05DD6:  MOVLB  9
05DD8:  CLRF   xF9
05DDA:  MOVLW  03
05DDC:  MOVWF  xF8
05DDE:  MOVLB  0
05DE0:  RCALL  5D14
05DE2:  BCF    FD8.0
05DE4:  MOVLB  9
05DE6:  RRCF   02,W
05DE8:  MOVWF  xED
05DEA:  RRCF   01,W
05DEC:  MOVWF  xEC
....................             if (!move_window(fatsect + bc / 512))  
05DEE:  BCF    FD8.0
05DF0:  CLRF   03
05DF2:  RRCF   xED,W
05DF4:  MOVWF  02
05DF6:  ADDWF  xEE,W
05DF8:  MOVWF  xF2
05DFA:  MOVF   03,W
05DFC:  ADDWFC xEF,W
05DFE:  MOVWF  xF3
05E00:  MOVLW  00
05E02:  ADDWFC xF0,W
05E04:  MOVWF  xF4
05E06:  MOVLW  00
05E08:  ADDWFC xF1,W
05E0A:  MOVWF  xF5
05E0C:  MOVWF  xFD
05E0E:  MOVFF  9F4,9FC
05E12:  MOVFF  9F3,9FB
05E16:  MOVFF  9F2,9FA
05E1A:  MOVLB  0
05E1C:  RCALL  5AD6
05E1E:  MOVF   01,F
05E20:  BNZ   5E24
....................                break; 
05E22:  BRA    605E
....................             wc = fs->win[bc % 512]; 
05E24:  MOVLB  9
05E26:  MOVF   xED,W
05E28:  ANDLW  01
05E2A:  MOVWF  xF3
05E2C:  MOVLW  24
05E2E:  ADDWF  xEC,W
05E30:  MOVWF  01
05E32:  MOVLW  00
05E34:  ADDWFC xF3,W
05E36:  MOVWF  03
05E38:  MOVF   01,W
05E3A:  MOVLB  7
05E3C:  ADDWF  x0E,W
05E3E:  MOVWF  FE9
05E40:  MOVF   x0F,W
05E42:  ADDWFC 03,W
05E44:  MOVWF  FEA
05E46:  MOVLB  9
05E48:  CLRF   xEB
05E4A:  MOVFF  FEF,9EA
....................             bc++; 
05E4E:  INCF   xEC,F
05E50:  BTFSC  FD8.2
05E52:  INCF   xED,F
....................             if (!move_window(fatsect + bc / 512))  
05E54:  BCF    FD8.0
05E56:  CLRF   03
05E58:  RRCF   xED,W
05E5A:  MOVWF  02
05E5C:  ADDWF  xEE,W
05E5E:  MOVWF  xF2
05E60:  MOVF   03,W
05E62:  ADDWFC xEF,W
05E64:  MOVWF  xF3
05E66:  MOVLW  00
05E68:  ADDWFC xF0,W
05E6A:  MOVWF  xF4
05E6C:  MOVLW  00
05E6E:  ADDWFC xF1,W
05E70:  MOVWF  xF5
05E72:  MOVWF  xFD
05E74:  MOVFF  9F4,9FC
05E78:  MOVFF  9F3,9FB
05E7C:  MOVFF  9F2,9FA
05E80:  MOVLB  0
05E82:  RCALL  5AD6
05E84:  MOVF   01,F
05E86:  BNZ   5E8A
....................                break; 
05E88:  BRA    605E
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05E8A:  MOVLB  9
05E8C:  MOVF   xED,W
05E8E:  ANDLW  01
05E90:  MOVWF  xF3
05E92:  MOVLW  24
05E94:  ADDWF  xEC,W
05E96:  MOVWF  01
05E98:  MOVLW  00
05E9A:  ADDWFC xF3,W
05E9C:  MOVWF  03
05E9E:  MOVF   01,W
05EA0:  MOVLB  7
05EA2:  ADDWF  x0E,W
05EA4:  MOVWF  FE9
05EA6:  MOVF   x0F,W
05EA8:  ADDWFC 03,W
05EAA:  MOVWF  FEA
05EAC:  MOVF   FEF,W
05EAE:  MOVLB  9
05EB0:  MOVWF  xF4
05EB2:  MOVLW  00
05EB4:  IORWF  xEA,F
05EB6:  MOVF   xF4,W
05EB8:  IORWF  xEB,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05EBA:  MOVF   xE6,W
05EBC:  ANDLW  01
05EBE:  MOVWF  00
05EC0:  CLRF   01
05EC2:  CLRF   02
05EC4:  CLRF   03
05EC6:  MOVF   00,F
05EC8:  BNZ   5ED6
05ECA:  MOVF   01,F
05ECC:  BNZ   5ED6
05ECE:  MOVF   02,F
05ED0:  BNZ   5ED6
05ED2:  MOVF   03,F
05ED4:  BZ    5EFC
05ED6:  RRCF   xEB,W
05ED8:  MOVWF  03
05EDA:  RRCF   xEA,W
05EDC:  MOVWF  02
05EDE:  RRCF   03,F
05EE0:  RRCF   02,F
05EE2:  RRCF   03,F
05EE4:  RRCF   02,F
05EE6:  RRCF   03,F
05EE8:  RRCF   02,F
05EEA:  MOVLW  0F
05EEC:  ANDWF  03,F
05EEE:  MOVFF  02,00
05EF2:  MOVFF  03,01
05EF6:  CLRF   02
05EF8:  CLRF   03
05EFA:  BRA    5F10
05EFC:  MOVFF  9EA,00
05F00:  MOVF   xEB,W
05F02:  ANDLW  0F
05F04:  MOVWF  03
05F06:  MOVF   xEA,W
05F08:  MOVFF  03,01
05F0C:  CLRF   02
05F0E:  CLRF   03
05F10:  BRA    606A
05F12:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05F14:  MOVFF  9E7,00
05F18:  MOVFF  9E8,01
05F1C:  MOVFF  9E9,02
05F20:  CLRF   03
05F22:  MOVF   00,W
05F24:  MOVLB  9
05F26:  ADDWF  xEE,W
05F28:  MOVWF  xF2
05F2A:  MOVF   xE8,W
05F2C:  ADDWFC xEF,W
05F2E:  MOVWF  xF3
05F30:  MOVF   xE9,W
05F32:  ADDWFC xF0,W
05F34:  MOVWF  xF4
05F36:  MOVF   03,W
05F38:  ADDWFC xF1,W
05F3A:  MOVWF  xF5
05F3C:  MOVWF  xFD
05F3E:  MOVFF  9F4,9FC
05F42:  MOVFF  9F3,9FB
05F46:  MOVFF  9F2,9FA
05F4A:  MOVLB  0
05F4C:  RCALL  5AD6
05F4E:  MOVF   01,F
05F50:  BNZ   5F54
....................                break; 
05F52:  BRA    605E
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05F54:  BCF    FD8.0
05F56:  MOVLB  9
05F58:  RLCF   xE6,W
05F5A:  MOVWF  xF2
05F5C:  RLCF   xE7,W
05F5E:  MOVWF  xF3
05F60:  MOVLW  01
05F62:  ANDWF  xF3,F
05F64:  MOVLW  24
05F66:  ADDWF  xF2,W
05F68:  MOVWF  01
05F6A:  MOVLW  00
05F6C:  ADDWFC xF3,W
05F6E:  MOVWF  03
05F70:  MOVF   01,W
05F72:  MOVLB  7
05F74:  ADDWF  x0E,W
05F76:  MOVWF  01
05F78:  MOVF   x0F,W
05F7A:  ADDWFC 03,F
05F7C:  MOVFF  01,FE9
05F80:  MOVFF  03,FEA
05F84:  MOVFF  FEF,00
05F88:  MOVFF  FEC,01
05F8C:  CLRF   02
05F8E:  CLRF   03
05F90:  MOVLB  9
05F92:  BRA    606A
05F94:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05F96:  MOVLB  9
05F98:  RRCF   xE9,W
05F9A:  MOVWF  03
05F9C:  RRCF   xE8,W
05F9E:  MOVWF  02
05FA0:  RRCF   xE7,W
05FA2:  MOVWF  01
05FA4:  RRCF   xE6,W
05FA6:  MOVWF  00
05FA8:  RRCF   03,F
05FAA:  RRCF   02,F
05FAC:  RRCF   01,F
05FAE:  RRCF   00,F
05FB0:  RRCF   03,F
05FB2:  RRCF   02,F
05FB4:  RRCF   01,F
05FB6:  RRCF   00,F
05FB8:  RRCF   03,F
05FBA:  RRCF   02,F
05FBC:  RRCF   01,F
05FBE:  RRCF   00,F
05FC0:  RRCF   03,F
05FC2:  RRCF   02,F
05FC4:  RRCF   01,F
05FC6:  RRCF   00,F
05FC8:  RRCF   03,F
05FCA:  RRCF   02,F
05FCC:  RRCF   01,F
05FCE:  RRCF   00,F
05FD0:  RRCF   03,F
05FD2:  RRCF   02,F
05FD4:  RRCF   01,F
05FD6:  RRCF   00,F
05FD8:  MOVLW  01
05FDA:  ANDWF  03,F
05FDC:  MOVF   00,W
05FDE:  ADDWF  xEE,W
05FE0:  MOVWF  xF2
05FE2:  MOVF   01,W
05FE4:  ADDWFC xEF,W
05FE6:  MOVWF  xF3
05FE8:  MOVF   02,W
05FEA:  ADDWFC xF0,W
05FEC:  MOVWF  xF4
05FEE:  MOVF   03,W
05FF0:  ADDWFC xF1,W
05FF2:  MOVWF  xF5
05FF4:  MOVWF  xFD
05FF6:  MOVFF  9F4,9FC
05FFA:  MOVFF  9F3,9FB
05FFE:  MOVFF  9F2,9FA
06002:  MOVLB  0
06004:  RCALL  5AD6
06006:  MOVF   01,F
06008:  BNZ   600C
....................                break; 
0600A:  BRA    605E
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
0600C:  MOVLB  9
0600E:  RLCF   xE6,W
06010:  MOVWF  xF2
06012:  RLCF   xE7,W
06014:  MOVWF  xF3
06016:  RLCF   xF2,F
06018:  RLCF   xF3,F
0601A:  MOVLW  FC
0601C:  ANDWF  xF2,F
0601E:  MOVLW  01
06020:  ANDWF  xF3,F
06022:  MOVLW  24
06024:  ADDWF  xF2,W
06026:  MOVWF  01
06028:  MOVLW  00
0602A:  ADDWFC xF3,W
0602C:  MOVWF  03
0602E:  MOVF   01,W
06030:  MOVLB  7
06032:  ADDWF  x0E,W
06034:  MOVWF  01
06036:  MOVF   x0F,W
06038:  ADDWFC 03,F
0603A:  MOVFF  01,FE9
0603E:  MOVFF  03,FEA
06042:  MOVFF  FEF,00
06046:  MOVFF  FEC,01
0604A:  MOVFF  FEC,02
0604E:  MOVFF  FEC,9F7
06052:  MOVLB  9
06054:  MOVF   xF7,W
06056:  ANDLW  0F
06058:  MOVWF  03
0605A:  BRA    606A
0605C:  MOVLB  0
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
0605E:  MOVLW  01
06060:  MOVWF  00
06062:  CLRF   01
06064:  CLRF   02
06066:  CLRF   03
06068:  MOVLB  9
0606A:  MOVLB  0
0606C:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
06630:  MOVLW  10
06632:  MOVLB  7
06634:  ADDWF  x0E,W
06636:  MOVWF  FE9
06638:  MOVLW  00
0663A:  ADDWFC x0F,W
0663C:  MOVWF  FEA
0663E:  MOVFF  FEF,9F2
06642:  MOVFF  FEC,9F3
06646:  MOVFF  FEC,9F4
0664A:  MOVFF  FEC,9F5
....................    switch (fs->fs_type)  
0664E:  MOVF   x0E,W
06650:  MOVWF  FE9
06652:  MOVF   x0F,W
06654:  MOVWF  FEA
06656:  MOVF   FEF,W
06658:  XORLW  01
0665A:  MOVLB  0
0665C:  BZ    666C
0665E:  XORLW  03
06660:  BTFSC  FD8.2
06662:  BRA    6844
06664:  XORLW  01
06666:  BTFSC  FD8.2
06668:  BRA    68C8
0666A:  BRA    6990
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
0666C:  MOVFF  9E7,9F7
06670:  MOVFF  9E6,9F6
06674:  MOVLB  9
06676:  CLRF   xF9
06678:  MOVLW  03
0667A:  MOVWF  xF8
0667C:  MOVLB  0
0667E:  CALL   5D14
06682:  BCF    FD8.0
06684:  MOVLB  9
06686:  RRCF   02,W
06688:  MOVWF  xEF
0668A:  RRCF   01,W
0668C:  MOVWF  xEE
....................          if (!move_window(fatsect + bc / 512)) 
0668E:  BCF    FD8.0
06690:  CLRF   03
06692:  RRCF   xEF,W
06694:  MOVWF  02
06696:  ADDWF  xF2,W
06698:  MOVWF  xF6
0669A:  MOVF   03,W
0669C:  ADDWFC xF3,W
0669E:  MOVWF  xF7
066A0:  MOVLW  00
066A2:  ADDWFC xF4,W
066A4:  MOVWF  xF8
066A6:  MOVLW  00
066A8:  ADDWFC xF5,W
066AA:  MOVWF  xF9
066AC:  MOVWF  xFD
066AE:  MOVFF  9F8,9FC
066B2:  MOVFF  9F7,9FB
066B6:  MOVFF  9F6,9FA
066BA:  MOVLB  0
066BC:  CALL   5AD6
066C0:  MOVF   01,F
066C2:  BNZ   66CA
....................             return (FALSE); 
066C4:  MOVLW  00
066C6:  MOVWF  01
066C8:  BRA    69AE
....................          p = &fs->win[bc % 512]; 
066CA:  MOVLB  9
066CC:  MOVF   xEF,W
066CE:  ANDLW  01
066D0:  MOVWF  xF7
066D2:  MOVLW  24
066D4:  ADDWF  xEE,W
066D6:  MOVWF  01
066D8:  MOVLW  00
066DA:  ADDWFC xF7,W
066DC:  MOVWF  03
066DE:  MOVF   01,W
066E0:  MOVLB  7
066E2:  ADDWF  x0E,W
066E4:  MOVWF  01
066E6:  MOVF   x0F,W
066E8:  ADDWFC 03,F
066EA:  MOVFF  01,9F0
066EE:  MOVLB  9
066F0:  MOVFF  03,9F1
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
066F4:  MOVFF  9F0,9F6
066F8:  MOVFF  9F1,9F7
066FC:  MOVF   xE6,W
066FE:  ANDLW  01
06700:  MOVWF  00
06702:  CLRF   01
06704:  CLRF   02
06706:  CLRF   03
06708:  MOVF   00,F
0670A:  BNZ   6718
0670C:  MOVF   01,F
0670E:  BNZ   6718
06710:  MOVF   02,F
06712:  BNZ   6718
06714:  MOVF   03,F
06716:  BZ    6738
06718:  MOVFF  9F1,03
0671C:  MOVFF  9F0,FE9
06720:  MOVFF  9F1,FEA
06724:  MOVF   FEF,W
06726:  ANDLW  0F
06728:  MOVWF  xF8
0672A:  SWAPF  xEA,W
0672C:  MOVWF  00
0672E:  MOVLW  F0
06730:  ANDWF  00,F
06732:  MOVF   00,W
06734:  IORWF  xF8,W
06736:  BRA    673A
06738:  MOVF   xEA,W
0673A:  MOVFF  9F7,FEA
0673E:  MOVFF  9F6,FE9
06742:  MOVWF  FEF
....................          fs->winflag = 1; 
06744:  MOVLW  06
06746:  MOVLB  7
06748:  ADDWF  x0E,W
0674A:  MOVWF  FE9
0674C:  MOVLW  00
0674E:  ADDWFC x0F,W
06750:  MOVWF  FEA
06752:  MOVLW  01
06754:  MOVWF  FEF
....................          bc++; 
06756:  MOVLB  9
06758:  INCF   xEE,F
0675A:  BTFSC  FD8.2
0675C:  INCF   xEF,F
....................          if (!move_window(fatsect + bc / 512)) 
0675E:  BCF    FD8.0
06760:  CLRF   03
06762:  RRCF   xEF,W
06764:  MOVWF  02
06766:  ADDWF  xF2,W
06768:  MOVWF  xF6
0676A:  MOVF   03,W
0676C:  ADDWFC xF3,W
0676E:  MOVWF  xF7
06770:  MOVLW  00
06772:  ADDWFC xF4,W
06774:  MOVWF  xF8
06776:  MOVLW  00
06778:  ADDWFC xF5,W
0677A:  MOVWF  xF9
0677C:  MOVWF  xFD
0677E:  MOVFF  9F8,9FC
06782:  MOVFF  9F7,9FB
06786:  MOVFF  9F6,9FA
0678A:  MOVLB  0
0678C:  CALL   5AD6
06790:  MOVF   01,F
06792:  BNZ   679A
....................             return (FALSE); 
06794:  MOVLW  00
06796:  MOVWF  01
06798:  BRA    69AE
....................          p = &fs->win[bc % 512]; 
0679A:  MOVLB  9
0679C:  MOVF   xEF,W
0679E:  ANDLW  01
067A0:  MOVWF  xF7
067A2:  MOVLW  24
067A4:  ADDWF  xEE,W
067A6:  MOVWF  01
067A8:  MOVLW  00
067AA:  ADDWFC xF7,W
067AC:  MOVWF  03
067AE:  MOVF   01,W
067B0:  MOVLB  7
067B2:  ADDWF  x0E,W
067B4:  MOVWF  01
067B6:  MOVF   x0F,W
067B8:  ADDWFC 03,F
067BA:  MOVFF  01,9F0
067BE:  MOVLB  9
067C0:  MOVFF  03,9F1
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
067C4:  MOVFF  9F0,9F6
067C8:  MOVFF  9F1,9F7
067CC:  MOVF   xE6,W
067CE:  ANDLW  01
067D0:  MOVWF  00
067D2:  CLRF   01
067D4:  CLRF   02
067D6:  CLRF   03
067D8:  MOVF   00,F
067DA:  BNZ   67E8
067DC:  MOVF   01,F
067DE:  BNZ   67E8
067E0:  MOVF   02,F
067E2:  BNZ   67E8
067E4:  MOVF   03,F
067E6:  BZ    6818
067E8:  RRCF   xED,W
067EA:  MOVWF  03
067EC:  RRCF   xEC,W
067EE:  MOVWF  02
067F0:  RRCF   xEB,W
067F2:  MOVWF  01
067F4:  RRCF   xEA,W
067F6:  MOVWF  00
067F8:  RRCF   03,F
067FA:  RRCF   02,F
067FC:  RRCF   01,F
067FE:  RRCF   00,F
06800:  RRCF   03,F
06802:  RRCF   02,F
06804:  RRCF   01,F
06806:  RRCF   00,F
06808:  RRCF   03,F
0680A:  RRCF   02,F
0680C:  RRCF   01,F
0680E:  RRCF   00,F
06810:  MOVLW  0F
06812:  ANDWF  03,F
06814:  MOVF   00,W
06816:  BRA    6838
06818:  MOVFF  9F0,FE9
0681C:  MOVFF  9F1,FEA
06820:  MOVF   FEF,W
06822:  ANDLW  F0
06824:  MOVWF  xF9
06826:  MOVFF  9EB,00
0682A:  MOVFF  9EC,01
0682E:  MOVFF  9ED,02
06832:  MOVF   xEB,W
06834:  ANDLW  0F
06836:  IORWF  xF9,W
06838:  MOVFF  9F7,FEA
0683C:  MOVFF  9F6,FE9
06840:  MOVWF  FEF
....................          break; 
06842:  BRA    6998
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
06844:  MOVFF  9E7,00
06848:  MOVFF  9E8,01
0684C:  MOVFF  9E9,02
06850:  CLRF   03
06852:  MOVF   00,W
06854:  MOVLB  9
06856:  ADDWF  xF2,W
06858:  MOVWF  xF6
0685A:  MOVF   xE8,W
0685C:  ADDWFC xF3,W
0685E:  MOVWF  xF7
06860:  MOVF   xE9,W
06862:  ADDWFC xF4,W
06864:  MOVWF  xF8
06866:  MOVF   03,W
06868:  ADDWFC xF5,W
0686A:  MOVWF  xF9
0686C:  MOVWF  xFD
0686E:  MOVFF  9F8,9FC
06872:  MOVFF  9F7,9FB
06876:  MOVFF  9F6,9FA
0687A:  MOVLB  0
0687C:  CALL   5AD6
06880:  MOVF   01,F
06882:  BNZ   688A
....................             return (FALSE); 
06884:  MOVLW  00
06886:  MOVWF  01
06888:  BRA    69AE
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
0688A:  BCF    FD8.0
0688C:  MOVLB  9
0688E:  RLCF   xE6,W
06890:  MOVWF  xF6
06892:  RLCF   xE7,W
06894:  MOVWF  xF7
06896:  MOVLW  01
06898:  ANDWF  xF7,F
0689A:  MOVLW  24
0689C:  ADDWF  xF6,W
0689E:  MOVWF  01
068A0:  MOVLW  00
068A2:  ADDWFC xF7,W
068A4:  MOVWF  03
068A6:  MOVF   01,W
068A8:  MOVLB  7
068AA:  ADDWF  x0E,W
068AC:  MOVWF  01
068AE:  MOVF   x0F,W
068B0:  ADDWFC 03,F
068B2:  MOVFF  01,FE9
068B6:  MOVFF  03,FEA
068BA:  MOVFF  9EB,FEC
068BE:  MOVF   FED,F
068C0:  MOVFF  9EA,FEF
....................          break; 
068C4:  MOVLB  9
068C6:  BRA    6998
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
068C8:  MOVLB  9
068CA:  RRCF   xE9,W
068CC:  MOVWF  03
068CE:  RRCF   xE8,W
068D0:  MOVWF  02
068D2:  RRCF   xE7,W
068D4:  MOVWF  01
068D6:  RRCF   xE6,W
068D8:  MOVWF  00
068DA:  RRCF   03,F
068DC:  RRCF   02,F
068DE:  RRCF   01,F
068E0:  RRCF   00,F
068E2:  RRCF   03,F
068E4:  RRCF   02,F
068E6:  RRCF   01,F
068E8:  RRCF   00,F
068EA:  RRCF   03,F
068EC:  RRCF   02,F
068EE:  RRCF   01,F
068F0:  RRCF   00,F
068F2:  RRCF   03,F
068F4:  RRCF   02,F
068F6:  RRCF   01,F
068F8:  RRCF   00,F
068FA:  RRCF   03,F
068FC:  RRCF   02,F
068FE:  RRCF   01,F
06900:  RRCF   00,F
06902:  RRCF   03,F
06904:  RRCF   02,F
06906:  RRCF   01,F
06908:  RRCF   00,F
0690A:  MOVLW  01
0690C:  ANDWF  03,F
0690E:  MOVF   00,W
06910:  ADDWF  xF2,W
06912:  MOVWF  xF6
06914:  MOVF   01,W
06916:  ADDWFC xF3,W
06918:  MOVWF  xF7
0691A:  MOVF   02,W
0691C:  ADDWFC xF4,W
0691E:  MOVWF  xF8
06920:  MOVF   03,W
06922:  ADDWFC xF5,W
06924:  MOVWF  xF9
06926:  MOVWF  xFD
06928:  MOVFF  9F8,9FC
0692C:  MOVFF  9F7,9FB
06930:  MOVFF  9F6,9FA
06934:  MOVLB  0
06936:  CALL   5AD6
0693A:  MOVF   01,F
0693C:  BNZ   6944
....................             return (FALSE); 
0693E:  MOVLW  00
06940:  MOVWF  01
06942:  BRA    69AE
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
06944:  MOVLB  9
06946:  RLCF   xE6,W
06948:  MOVWF  xF6
0694A:  RLCF   xE7,W
0694C:  MOVWF  xF7
0694E:  RLCF   xF6,F
06950:  RLCF   xF7,F
06952:  MOVLW  FC
06954:  ANDWF  xF6,F
06956:  MOVLW  01
06958:  ANDWF  xF7,F
0695A:  MOVLW  24
0695C:  ADDWF  xF6,W
0695E:  MOVWF  01
06960:  MOVLW  00
06962:  ADDWFC xF7,W
06964:  MOVWF  03
06966:  MOVF   01,W
06968:  MOVLB  7
0696A:  ADDWF  x0E,W
0696C:  MOVWF  01
0696E:  MOVF   x0F,W
06970:  ADDWFC 03,F
06972:  MOVFF  01,FE9
06976:  MOVFF  03,FEA
0697A:  MOVFF  9EA,FEF
0697E:  MOVFF  9EB,FEC
06982:  MOVFF  9EC,FEC
06986:  MOVFF  9ED,FEC
....................          break; 
0698A:  MOVLB  9
0698C:  BRA    6998
0698E:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
06990:  MOVLW  00
06992:  MOVWF  01
06994:  BRA    69AE
06996:  MOVLB  9
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
06998:  MOVLW  06
0699A:  MOVLB  7
0699C:  ADDWF  x0E,W
0699E:  MOVWF  FE9
069A0:  MOVLW  00
069A2:  ADDWFC x0F,W
069A4:  MOVWF  FEA
069A6:  MOVLW  01
069A8:  MOVWF  FEF
....................    return (TRUE); 
069AA:  MOVWF  01
069AC:  MOVLB  0
069AE:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06F8E:  MOVFF  9C8,9E9
06F92:  MOVFF  9C7,9E8
06F96:  MOVFF  9C6,9E7
06F9A:  MOVFF  9C5,9E6
06F9E:  CALL   5D36
06FA2:  MOVFF  03,9CC
06FA6:  MOVFF  02,9CB
06FAA:  MOVFF  01,9CA
06FAE:  MOVFF  00,9C9
06FB2:  MOVLB  9
06FB4:  MOVF   xCC,F
06FB6:  BNZ   6FC6
06FB8:  MOVF   xCB,F
06FBA:  BNZ   6FC6
06FBC:  MOVF   xCA,F
06FBE:  BNZ   6FC6
06FC0:  MOVF   xC9,W
06FC2:  SUBLW  01
06FC4:  BC    7026
....................       { 
....................       if (!put_cluster(clust, 0)) 
06FC6:  MOVFF  9C8,9E9
06FCA:  MOVFF  9C7,9E8
06FCE:  MOVFF  9C6,9E7
06FD2:  MOVFF  9C5,9E6
06FD6:  CLRF   xED
06FD8:  CLRF   xEC
06FDA:  CLRF   xEB
06FDC:  CLRF   xEA
06FDE:  MOVLB  0
06FE0:  CALL   6630
06FE4:  MOVF   01,F
06FE6:  BNZ   6FEE
....................          return FALSE; 
06FE8:  MOVLW  00
06FEA:  MOVWF  01
06FEC:  BRA    702C
....................       clust = nxt; 
06FEE:  MOVFF  9CC,9C8
06FF2:  MOVFF  9CB,9C7
06FF6:  MOVFF  9CA,9C6
06FFA:  MOVFF  9C9,9C5
06FFE:  MOVFF  9C8,9E9
07002:  MOVFF  9C7,9E8
07006:  MOVFF  9C6,9E7
0700A:  MOVFF  9C5,9E6
0700E:  CALL   5D36
07012:  MOVFF  03,9CC
07016:  MOVFF  02,9CB
0701A:  MOVFF  01,9CA
0701E:  MOVFF  00,9C9
07022:  BRA    6FB2
07024:  MOVLB  9
....................       } 
....................    return TRUE; 
07026:  MOVLW  01
07028:  MOVWF  01
0702A:  MOVLB  0
0702C:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
069B0:  MOVLW  0C
069B2:  MOVLB  7
069B4:  ADDWF  x0E,W
069B6:  MOVWF  FE9
069B8:  MOVLW  00
069BA:  ADDWFC x0F,W
069BC:  MOVWF  FEA
069BE:  MOVFF  FEF,9E2
069C2:  MOVFF  FEC,9E3
069C6:  MOVFF  FEC,9E4
069CA:  MOVFF  FEC,9E5
....................    if (clust == 0)  
069CE:  MOVLB  9
069D0:  MOVF   xD2,F
069D2:  BNZ   6A3C
069D4:  MOVF   xD3,F
069D6:  BNZ   6A3C
069D8:  MOVF   xD4,F
069DA:  BNZ   6A3C
069DC:  MOVF   xD5,F
069DE:  BNZ   6A3C
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
069E0:  MOVLW  1C
069E2:  MOVLB  7
069E4:  ADDWF  x0E,W
069E6:  MOVWF  FE9
069E8:  MOVLW  00
069EA:  ADDWFC x0F,W
069EC:  MOVWF  FEA
069EE:  MOVFF  FEF,9DE
069F2:  MOVFF  FEC,9DF
069F6:  MOVFF  FEC,9E0
069FA:  MOVFF  FEC,9E1
....................       if (scl < 2 || scl >= mcl) scl = 1; 
069FE:  MOVLB  9
06A00:  MOVF   xE1,F
06A02:  BNZ   6A12
06A04:  MOVF   xE0,F
06A06:  BNZ   6A12
06A08:  MOVF   xDF,F
06A0A:  BNZ   6A12
06A0C:  MOVF   xDE,W
06A0E:  SUBLW  01
06A10:  BC    6A30
06A12:  MOVF   xE5,W
06A14:  SUBWF  xE1,W
06A16:  BNC   6A3A
06A18:  BNZ   6A30
06A1A:  MOVF   xE4,W
06A1C:  SUBWF  xE0,W
06A1E:  BNC   6A3A
06A20:  BNZ   6A30
06A22:  MOVF   xE3,W
06A24:  SUBWF  xDF,W
06A26:  BNC   6A3A
06A28:  BNZ   6A30
06A2A:  MOVF   xE2,W
06A2C:  SUBWF  xDE,W
06A2E:  BNC   6A3A
06A30:  CLRF   xE1
06A32:  CLRF   xE0
06A34:  CLRF   xDF
06A36:  MOVLW  01
06A38:  MOVWF  xDE
....................       } 
06A3A:  BRA    6AC0
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
06A3C:  MOVFF  9D5,9E9
06A40:  MOVFF  9D4,9E8
06A44:  MOVFF  9D3,9E7
06A48:  MOVFF  9D2,9E6
06A4C:  MOVLB  0
06A4E:  CALL   5D36
06A52:  MOVFF  03,9D9
06A56:  MOVFF  02,9D8
06A5A:  MOVFF  01,9D7
06A5E:  MOVFF  00,9D6
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06A62:  MOVLB  9
06A64:  MOVF   xD9,F
06A66:  BNZ   6A80
06A68:  MOVF   xD8,F
06A6A:  BNZ   6A80
06A6C:  MOVF   xD7,F
06A6E:  BNZ   6A80
06A70:  MOVF   xD6,W
06A72:  SUBLW  01
06A74:  BNC   6A80
06A76:  CLRF   00
06A78:  CLRF   01
06A7A:  CLRF   02
06A7C:  CLRF   03
06A7E:  BRA    6C42
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
06A80:  MOVF   xD9,W
06A82:  SUBWF  xE5,W
06A84:  BNC   6AB0
06A86:  BNZ   6A9E
06A88:  MOVF   xD8,W
06A8A:  SUBWF  xE4,W
06A8C:  BNC   6AB0
06A8E:  BNZ   6A9E
06A90:  MOVF   xD7,W
06A92:  SUBWF  xE3,W
06A94:  BNC   6AB0
06A96:  BNZ   6A9E
06A98:  MOVF   xE2,W
06A9A:  SUBWF  xD6,W
06A9C:  BC    6AB0
06A9E:  MOVFF  9D6,00
06AA2:  MOVFF  9D7,01
06AA6:  MOVFF  9D8,02
06AAA:  MOVFF  9D9,03
06AAE:  BRA    6C42
....................       scl = clust; 
06AB0:  MOVFF  9D5,9E1
06AB4:  MOVFF  9D4,9E0
06AB8:  MOVFF  9D3,9DF
06ABC:  MOVFF  9D2,9DE
....................       } 
....................       ncl = scl;                  // Scan start cluster 
06AC0:  MOVFF  9E1,9DD
06AC4:  MOVFF  9E0,9DC
06AC8:  MOVFF  9DF,9DB
06ACC:  MOVFF  9DE,9DA
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
06AD0:  MOVLW  01
06AD2:  ADDWF  xDA,F
06AD4:  BTFSC  FD8.0
06AD6:  INCF   xDB,F
06AD8:  BTFSC  FD8.2
06ADA:  INCF   xDC,F
06ADC:  BTFSC  FD8.2
06ADE:  INCF   xDD,F
....................       if (ncl >= mcl)  
06AE0:  MOVF   xE5,W
06AE2:  SUBWF  xDD,W
06AE4:  BNC   6B22
06AE6:  BNZ   6AFE
06AE8:  MOVF   xE4,W
06AEA:  SUBWF  xDC,W
06AEC:  BNC   6B22
06AEE:  BNZ   6AFE
06AF0:  MOVF   xE3,W
06AF2:  SUBWF  xDB,W
06AF4:  BNC   6B22
06AF6:  BNZ   6AFE
06AF8:  MOVF   xE2,W
06AFA:  SUBWF  xDA,W
06AFC:  BNC   6B22
....................          {         // Wrap around 
....................          ncl = 2; 
06AFE:  CLRF   xDD
06B00:  CLRF   xDC
06B02:  CLRF   xDB
06B04:  MOVLW  02
06B06:  MOVWF  xDA
....................          if (scl == 1) return 0;      // No free custer was found 
06B08:  DECFSZ xDE,W
06B0A:  BRA    6B22
06B0C:  MOVF   xDF,F
06B0E:  BNZ   6B22
06B10:  MOVF   xE0,F
06B12:  BNZ   6B22
06B14:  MOVF   xE1,F
06B16:  BNZ   6B22
06B18:  CLRF   00
06B1A:  CLRF   01
06B1C:  CLRF   02
06B1E:  CLRF   03
06B20:  BRA    6C42
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06B22:  MOVF   xDE,W
06B24:  SUBWF  xDA,W
06B26:  BNZ   6B44
06B28:  MOVF   xDF,W
06B2A:  SUBWF  xDB,W
06B2C:  BNZ   6B44
06B2E:  MOVF   xE0,W
06B30:  SUBWF  xDC,W
06B32:  BNZ   6B44
06B34:  MOVF   xE1,W
06B36:  SUBWF  xDD,W
06B38:  BNZ   6B44
06B3A:  CLRF   00
06B3C:  CLRF   01
06B3E:  CLRF   02
06B40:  CLRF   03
06B42:  BRA    6C42
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06B44:  MOVFF  9DD,9E9
06B48:  MOVFF  9DC,9E8
06B4C:  MOVFF  9DB,9E7
06B50:  MOVFF  9DA,9E6
06B54:  MOVLB  0
06B56:  CALL   5D36
06B5A:  MOVFF  03,9D9
06B5E:  MOVFF  02,9D8
06B62:  MOVFF  01,9D7
06B66:  MOVFF  00,9D6
....................       if (cstat == 1) return 0;      // Any error occured 
06B6A:  MOVLB  9
06B6C:  DECFSZ xD6,W
06B6E:  BRA    6B86
06B70:  MOVF   xD7,F
06B72:  BNZ   6B86
06B74:  MOVF   xD8,F
06B76:  BNZ   6B86
06B78:  MOVF   xD9,F
06B7A:  BNZ   6B86
06B7C:  CLRF   00
06B7E:  CLRF   01
06B80:  CLRF   02
06B82:  CLRF   03
06B84:  BRA    6C42
....................       } while (cstat);            // Repeat until find a free cluster 
06B86:  MOVF   xD6,F
06B88:  BNZ   6AD0
06B8A:  MOVF   xD7,F
06B8C:  BNZ   6AD0
06B8E:  MOVF   xD8,F
06B90:  BNZ   6AD0
06B92:  MOVF   xD9,F
06B94:  BNZ   6AD0
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06B96:  MOVFF  9DD,9E9
06B9A:  MOVFF  9DC,9E8
06B9E:  MOVFF  9DB,9E7
06BA2:  MOVFF  9DA,9E6
06BA6:  MOVLW  0F
06BA8:  MOVWF  xED
06BAA:  SETF   xEC
06BAC:  SETF   xEB
06BAE:  SETF   xEA
06BB0:  MOVLB  0
06BB2:  RCALL  6630
06BB4:  MOVF   01,F
06BB6:  BNZ   6BC6
06BB8:  CLRF   00
06BBA:  CLRF   01
06BBC:  CLRF   02
06BBE:  CLRF   03
06BC0:  MOVLB  9
06BC2:  BRA    6C42
06BC4:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06BC6:  MOVLB  9
06BC8:  MOVF   xD2,F
06BCA:  BNZ   6BD8
06BCC:  MOVF   xD3,F
06BCE:  BNZ   6BD8
06BD0:  MOVF   xD4,F
06BD2:  BNZ   6BD8
06BD4:  MOVF   xD5,F
06BD6:  BZ    6C12
06BD8:  MOVFF  9D5,9E9
06BDC:  MOVFF  9D4,9E8
06BE0:  MOVFF  9D3,9E7
06BE4:  MOVFF  9D2,9E6
06BE8:  MOVFF  9DD,9ED
06BEC:  MOVFF  9DC,9EC
06BF0:  MOVFF  9DB,9EB
06BF4:  MOVFF  9DA,9EA
06BF8:  MOVLB  0
06BFA:  RCALL  6630
06BFC:  MOVF   01,F
06BFE:  BTFSC  FD8.2
06C00:  BRA    6C06
06C02:  MOVLB  9
06C04:  BRA    6C12
06C06:  CLRF   00
06C08:  CLRF   01
06C0A:  CLRF   02
06C0C:  CLRF   03
06C0E:  MOVLB  9
06C10:  BRA    6C42
....................    fs->last_clust = ncl; 
06C12:  MOVLW  1C
06C14:  MOVLB  7
06C16:  ADDWF  x0E,W
06C18:  MOVWF  FE9
06C1A:  MOVLW  00
06C1C:  ADDWFC x0F,W
06C1E:  MOVWF  FEA
06C20:  MOVFF  9DA,FEF
06C24:  MOVFF  9DB,FEC
06C28:  MOVFF  9DC,FEC
06C2C:  MOVFF  9DD,FEC
....................  
....................    return ncl;      // Return new cluster number 
06C30:  MOVFF  9DA,00
06C34:  MOVFF  9DB,01
06C38:  MOVFF  9DC,02
06C3C:  MOVFF  9DD,03
06C40:  MOVLB  9
06C42:  MOVLB  0
06C44:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
05662:  MOVLW  02
05664:  MOVLB  9
05666:  SUBWF  xD9,F
05668:  MOVLW  00
0566A:  SUBWFB xDA,F
0566C:  SUBWFB xDB,F
0566E:  SUBWFB xDC,F
....................    if (clust >= fs->max_clust)  
05670:  MOVLW  0C
05672:  MOVLB  7
05674:  ADDWF  x0E,W
05676:  MOVWF  FE9
05678:  MOVLW  00
0567A:  ADDWFC x0F,W
0567C:  MOVWF  FEA
0567E:  MOVFF  FEF,00
05682:  MOVFF  FEC,01
05686:  MOVFF  FEC,02
0568A:  MOVFF  FEC,03
0568E:  MOVF   03,W
05690:  MOVLB  9
05692:  SUBWF  xDC,W
05694:  BNC   56B8
05696:  BNZ   56AE
05698:  MOVF   02,W
0569A:  SUBWF  xDB,W
0569C:  BNC   56B8
0569E:  BNZ   56AE
056A0:  MOVF   01,W
056A2:  SUBWF  xDA,W
056A4:  BNC   56B8
056A6:  BNZ   56AE
056A8:  MOVF   00,W
056AA:  SUBWF  xD9,W
056AC:  BNC   56B8
....................       return 0;      // Invalid cluster#  
056AE:  CLRF   00
056B0:  CLRF   01
056B2:  CLRF   02
056B4:  CLRF   03
056B6:  BRA    5738
....................    return (clust * fs->sects_clust + fs->database); 
056B8:  MOVLW  02
056BA:  MOVLB  7
056BC:  ADDWF  x0E,W
056BE:  MOVWF  FE9
056C0:  MOVLW  00
056C2:  ADDWFC x0F,W
056C4:  MOVWF  FEA
056C6:  MOVFF  FEF,9E4
056CA:  MOVLB  9
056CC:  MOVFF  FEA,9DF
056D0:  MOVFF  FE9,9DE
056D4:  MOVFF  9DC,9E3
056D8:  MOVFF  9DB,9E2
056DC:  MOVFF  9DA,9E1
056E0:  MOVFF  9D9,9E0
056E4:  CLRF   xE7
056E6:  CLRF   xE6
056E8:  CLRF   xE5
056EA:  MOVLB  0
056EC:  CALL   4852
056F0:  MOVFF  9DF,FEA
056F4:  MOVFF  9DE,FE9
056F8:  MOVFF  03,9E0
056FC:  MOVFF  02,9DF
05700:  MOVFF  01,9DE
05704:  MOVFF  00,9DD
05708:  MOVLW  18
0570A:  MOVLB  7
0570C:  ADDWF  x0E,W
0570E:  MOVWF  FE9
05710:  MOVLW  00
05712:  ADDWFC x0F,W
05714:  MOVWF  FEA
05716:  MOVFF  FEF,00
0571A:  MOVFF  FEC,01
0571E:  MOVFF  FEC,02
05722:  MOVFF  FEC,03
05726:  MOVLB  9
05728:  MOVF   xDD,W
0572A:  ADDWF  00,F
0572C:  MOVF   xDE,W
0572E:  ADDWFC 01,F
05730:  MOVF   xDF,W
05732:  ADDWFC 02,F
05734:  MOVF   xE0,W
05736:  ADDWFC 03,F
05738:  MOVLB  0
0573A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
046F2:  MOVLW  24
046F4:  MOVLB  7
046F6:  ADDWF  x0E,W
046F8:  MOVWF  01
046FA:  MOVLW  00
046FC:  ADDWFC x0F,W
046FE:  MOVWF  03
04700:  MOVFF  01,9D1
04704:  MOVLB  9
04706:  MOVWF  xD2
04708:  MOVWF  FEA
0470A:  MOVFF  01,FE9
0470E:  CLRF   00
04710:  MOVLW  02
04712:  MOVWF  02
04714:  CLRF   01
04716:  MOVLB  0
04718:  CALL   3588
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
0471C:  MOVLW  24
0471E:  MOVLB  7
04720:  ADDWF  x0E,W
04722:  MOVWF  01
04724:  MOVLW  00
04726:  ADDWFC x0F,W
04728:  MOVWF  03
0472A:  MOVFF  01,9D1
0472E:  MOVLB  9
04730:  MOVWF  xD2
04732:  MOVFF  FE8,A07
04736:  MOVFF  01,A06
0473A:  MOVFF  9D0,A0B
0473E:  MOVFF  9CF,A0A
04742:  MOVFF  9CE,A09
04746:  MOVFF  9CD,A08
0474A:  MOVLW  01
0474C:  MOVLB  A
0474E:  MOVWF  x0C
04750:  MOVLB  0
04752:  RCALL  452E
04754:  MOVF   01,F
04756:  BTFSS  FD8.2
04758:  BRA    4848
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
0475A:  MOVLW  22
0475C:  MOVLB  7
0475E:  ADDWF  x0E,W
04760:  MOVWF  01
04762:  MOVLW  02
04764:  ADDWFC x0F,W
04766:  MOVWF  03
04768:  MOVFF  01,FE9
0476C:  MOVWF  FEA
0476E:  MOVFF  FEC,9D2
04772:  MOVF   FED,F
04774:  MOVFF  FEF,9D1
04778:  MOVLB  9
0477A:  MOVF   xD1,W
0477C:  SUBLW  55
0477E:  BNZ   484A
04780:  MOVF   xD2,W
04782:  SUBLW  AA
04784:  BNZ   484A
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
04786:  MOVLW  5A
04788:  MOVLB  7
0478A:  ADDWF  x0E,W
0478C:  MOVWF  01
0478E:  MOVLW  00
04790:  ADDWFC x0F,W
04792:  MOVWF  03
04794:  MOVFF  01,9D1
04798:  MOVLB  9
0479A:  MOVWF  xD2
0479C:  MOVWF  xD4
0479E:  MOVFF  01,9D3
047A2:  MOVLW  07
047A4:  MOVWF  xD6
047A6:  MOVLW  10
047A8:  MOVWF  xD5
047AA:  CLRF   xD8
047AC:  MOVLW  05
047AE:  MOVWF  xD7
047B0:  MOVLB  0
047B2:  RCALL  466E
047B4:  MOVF   01,F
047B6:  BNZ   47BE
....................             return (FS_FAT12); 
047B8:  MOVLW  01
047BA:  MOVWF  01
047BC:  BRA    4850
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
047BE:  MOVLW  5A
047C0:  MOVLB  7
047C2:  ADDWF  x0E,W
047C4:  MOVWF  01
047C6:  MOVLW  00
047C8:  ADDWFC x0F,W
047CA:  MOVWF  03
047CC:  MOVFF  01,9D1
047D0:  MOVLB  9
047D2:  MOVWF  xD2
047D4:  MOVWF  xD4
047D6:  MOVFF  01,9D3
047DA:  MOVLW  07
047DC:  MOVWF  xD6
047DE:  MOVLW  15
047E0:  MOVWF  xD5
047E2:  CLRF   xD8
047E4:  MOVLW  05
047E6:  MOVWF  xD7
047E8:  MOVLB  0
047EA:  RCALL  466E
047EC:  MOVF   01,F
047EE:  BNZ   47F6
....................             return (FS_FAT16); 
047F0:  MOVLW  02
047F2:  MOVWF  01
047F4:  BRA    4850
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
047F6:  MOVLW  76
047F8:  MOVLB  7
047FA:  ADDWF  x0E,W
047FC:  MOVWF  01
047FE:  MOVLW  00
04800:  ADDWFC x0F,W
04802:  MOVWF  03
04804:  MOVFF  01,9D1
04808:  MOVLB  9
0480A:  MOVWF  xD2
0480C:  MOVWF  xD4
0480E:  MOVFF  01,9D3
04812:  MOVLW  07
04814:  MOVWF  xD6
04816:  MOVLW  1A
04818:  MOVWF  xD5
0481A:  CLRF   xD8
0481C:  MOVLW  05
0481E:  MOVWF  xD7
04820:  MOVLB  0
04822:  RCALL  466E
04824:  MOVF   01,F
04826:  BNZ   4848
04828:  MOVLW  4C
0482A:  MOVLB  7
0482C:  ADDWF  x0E,W
0482E:  MOVWF  FE9
04830:  MOVLW  00
04832:  ADDWFC x0F,W
04834:  MOVWF  FEA
04836:  MOVF   FEF,F
04838:  BTFSC  FD8.2
0483A:  BRA    4840
0483C:  MOVLB  0
0483E:  BRA    4848
....................             return (FS_FAT32); 
04840:  MOVLW  03
04842:  MOVWF  01
04844:  MOVLB  0
04846:  BRA    4850
04848:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
0484A:  MOVLW  00
0484C:  MOVWF  01
0484E:  MOVLB  0
04850:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
0606E:  MOVLW  0C
06070:  MOVLB  9
06072:  ADDWF  xCF,W
06074:  MOVWF  FE9
06076:  MOVLW  00
06078:  ADDWFC xD0,W
0607A:  MOVWF  FEA
0607C:  MOVFF  FEC,9D8
06080:  MOVF   FED,F
06082:  MOVFF  FEF,9D7
06086:  MOVLW  01
06088:  ADDWF  xD7,W
0608A:  MOVWF  xD5
0608C:  MOVLW  00
0608E:  ADDWFC xD8,W
06090:  MOVWF  xD6
....................    if ((idx & 15) == 0)  
06092:  MOVF   xD5,W
06094:  ANDLW  0F
06096:  MOVWF  xD7
06098:  CLRF   xD8
0609A:  MOVF   xD7,F
0609C:  BTFSS  FD8.2
0609E:  BRA    622A
060A0:  MOVF   xD8,F
060A2:  BTFSS  FD8.2
060A4:  BRA    622A
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
060A6:  MOVLW  08
060A8:  ADDWF  xCF,W
060AA:  MOVWF  FE9
060AC:  MOVLW  00
060AE:  ADDWFC xD0,W
060B0:  MOVWF  FEA
060B2:  MOVLW  01
060B4:  ADDWF  FEE,F
060B6:  MOVLW  00
060B8:  ADDWFC FEE,F
060BA:  ADDWFC FEE,F
060BC:  ADDWFC FED,F
....................       if (!scan->clust)  
060BE:  MOVLW  04
060C0:  ADDWF  xCF,W
060C2:  MOVWF  FE9
060C4:  MOVLW  00
060C6:  ADDWFC xD0,W
060C8:  MOVWF  FEA
060CA:  MOVF   FEF,F
060CC:  BNZ   610A
060CE:  MOVF   FEC,F
060D0:  BNZ   610A
060D2:  MOVF   FEC,F
060D4:  BNZ   610A
060D6:  MOVF   FEC,F
060D8:  BNZ   610A
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
060DA:  MOVLW  04
060DC:  MOVLB  7
060DE:  ADDWF  x0E,W
060E0:  MOVWF  FE9
060E2:  MOVLW  00
060E4:  ADDWFC x0F,W
060E6:  MOVWF  FEA
060E8:  MOVFF  FEC,03
060EC:  MOVF   FED,F
060EE:  MOVFF  FEF,01
060F2:  MOVF   03,W
060F4:  MOVLB  9
060F6:  SUBWF  xD6,W
060F8:  BNC   6108
060FA:  BNZ   6102
060FC:  MOVF   01,W
060FE:  SUBWF  xD5,W
06100:  BNC   6108
....................             return (FALSE);   // Reached to end of table  
06102:  MOVLW  00
06104:  MOVWF  01
06106:  BRA    6244
....................          }  
06108:  BRA    622A
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
0610A:  RRCF   xD6,W
0610C:  MOVWF  xD8
0610E:  RRCF   xD5,W
06110:  MOVWF  xD7
06112:  RRCF   xD8,F
06114:  RRCF   xD7,F
06116:  RRCF   xD8,F
06118:  RRCF   xD7,F
0611A:  RRCF   xD8,F
0611C:  RRCF   xD7,F
0611E:  MOVLW  0F
06120:  ANDWF  xD8,F
06122:  MOVLW  02
06124:  MOVLB  7
06126:  ADDWF  x0E,W
06128:  MOVWF  FE9
0612A:  MOVLW  00
0612C:  ADDWFC x0F,W
0612E:  MOVWF  FEA
06130:  MOVLW  01
06132:  SUBWF  FEF,W
06134:  MOVLB  9
06136:  ANDWF  xD7,F
06138:  CLRF   xD8
0613A:  MOVF   xD7,F
0613C:  BTFSS  FD8.2
0613E:  BRA    622A
06140:  MOVF   xD8,F
06142:  BTFSS  FD8.2
06144:  BRA    622A
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
06146:  MOVLW  04
06148:  ADDWF  xCF,W
0614A:  MOVWF  FE9
0614C:  MOVLW  00
0614E:  ADDWFC xD0,W
06150:  MOVWF  FEA
06152:  MOVFF  FEF,9E6
06156:  MOVFF  FEC,9E7
0615A:  MOVFF  FEC,9E8
0615E:  MOVFF  FEC,9E9
06162:  MOVLB  0
06164:  RCALL  5D36
06166:  MOVFF  03,9D4
0616A:  MOVFF  02,9D3
0616E:  MOVFF  01,9D2
06172:  MOVFF  00,9D1
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06176:  MOVLW  0C
06178:  MOVLB  7
0617A:  ADDWF  x0E,W
0617C:  MOVWF  FE9
0617E:  MOVLW  00
06180:  ADDWFC x0F,W
06182:  MOVWF  FEA
06184:  MOVFF  FEF,00
06188:  MOVFF  FEC,01
0618C:  MOVFF  FEC,02
06190:  MOVFF  FEC,03
06194:  MOVF   03,W
06196:  MOVLB  9
06198:  SUBWF  xD4,W
0619A:  BNC   61B4
0619C:  BNZ   61C6
0619E:  MOVF   02,W
061A0:  SUBWF  xD3,W
061A2:  BNC   61B4
061A4:  BNZ   61C6
061A6:  MOVF   01,W
061A8:  SUBWF  xD2,W
061AA:  BNC   61B4
061AC:  BNZ   61C6
061AE:  MOVF   00,W
061B0:  SUBWF  xD1,W
061B2:  BC    61C6
061B4:  MOVF   xD4,F
061B6:  BNZ   61CC
061B8:  MOVF   xD3,F
061BA:  BNZ   61CC
061BC:  MOVF   xD2,F
061BE:  BNZ   61CC
061C0:  MOVF   xD1,W
061C2:  SUBLW  01
061C4:  BNC   61CC
....................                return (FALSE); 
061C6:  MOVLW  00
061C8:  MOVWF  01
061CA:  BRA    6244
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
061CC:  MOVLW  04
061CE:  ADDWF  xCF,W
061D0:  MOVWF  FE9
061D2:  MOVLW  00
061D4:  ADDWFC xD0,W
061D6:  MOVWF  FEA
061D8:  MOVFF  9D1,FEF
061DC:  MOVFF  9D2,FEC
061E0:  MOVFF  9D3,FEC
061E4:  MOVFF  9D4,FEC
....................             scan->sect = clust2sect(clust); 
061E8:  MOVLW  08
061EA:  ADDWF  xCF,W
061EC:  MOVWF  01
061EE:  MOVLW  00
061F0:  ADDWFC xD0,W
061F2:  MOVWF  03
061F4:  MOVFF  01,9D7
061F8:  MOVWF  xD8
061FA:  MOVFF  9D4,9DC
061FE:  MOVFF  9D3,9DB
06202:  MOVFF  9D2,9DA
06206:  MOVFF  9D1,9D9
0620A:  MOVLB  0
0620C:  CALL   5662
06210:  MOVFF  9D8,FEA
06214:  MOVFF  9D7,FE9
06218:  MOVFF  00,FEF
0621C:  MOVFF  01,FEC
06220:  MOVFF  02,FEC
06224:  MOVFF  03,FEC
06228:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
0622A:  MOVLW  0C
0622C:  ADDWF  xCF,W
0622E:  MOVWF  FE9
06230:  MOVLW  00
06232:  ADDWFC xD0,W
06234:  MOVWF  FEA
06236:  MOVFF  9D6,FEC
0623A:  MOVF   FED,F
0623C:  MOVFF  9D5,FEF
....................    return (TRUE); 
06240:  MOVLW  01
06242:  MOVWF  01
06244:  MOVLB  0
06246:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
0573C:  MOVFF  9D2,FEA
05740:  MOVFF  9D1,FE9
05744:  MOVLW  20
05746:  MOVWF  00
05748:  CLRF   02
0574A:  MOVLW  0B
0574C:  MOVWF  01
0574E:  CALL   3588
....................    a = 0; b = 0x18;            // NT flag 
05752:  MOVLB  9
05754:  CLRF   xD6
05756:  MOVLW  18
05758:  MOVWF  xD7
....................    n = 0; t = 8; 
0575A:  CLRF   xD3
0575C:  MOVLW  08
0575E:  MOVWF  xD4
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
05760:  MOVFF  9CF,FE9
05764:  MOVFF  9D0,FEA
05768:  MOVFF  FEC,9D9
0576C:  MOVF   FED,F
0576E:  MOVFF  FEF,9D8
....................       c = *ptr; 
05772:  MOVFF  9D8,FE9
05776:  MOVFF  9D9,FEA
0577A:  MOVFF  FEF,9D5
....................       (*path)++; 
0577E:  MOVFF  9D0,03
05782:  MOVFF  9CF,FE9
05786:  MOVFF  9D0,FEA
0578A:  MOVLW  01
0578C:  ADDWF  FEE,F
0578E:  BNC   5792
05790:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
05792:  MOVF   xD5,W
05794:  SUBLW  20
05796:  BNC   579A
....................          c = 0; 
05798:  CLRF   xD5
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
0579A:  MOVF   xD5,F
0579C:  BZ    57AA
0579E:  MOVF   xD5,W
057A0:  SUBLW  2F
057A2:  BZ    57AA
057A4:  MOVF   xD5,W
057A6:  SUBLW  5C
057A8:  BNZ   57C8
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
057AA:  MOVF   xD3,F
057AC:  BNZ   57B0
....................             break; 
057AE:  BRA    5890
....................          dirname[11] = a & b;  
057B0:  MOVLW  0B
057B2:  ADDWF  xD1,W
057B4:  MOVWF  FE9
057B6:  MOVLW  00
057B8:  ADDWFC xD2,W
057BA:  MOVWF  FEA
057BC:  MOVF   xD6,W
057BE:  ANDWF  xD7,W
057C0:  MOVWF  FEF
....................             return (c); 
057C2:  MOVFF  9D5,01
057C6:  BRA    5894
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
057C8:  MOVF   xD5,W
057CA:  SUBLW  20
057CC:  BC    57D4
057CE:  MOVF   xD5,W
057D0:  SUBLW  7F
057D2:  BNZ   57D6
....................          break;   // reject invisible characters 
057D4:  BRA    5890
....................       if (c == '.')  
057D6:  MOVF   xD5,W
057D8:  SUBLW  2E
057DA:  BNZ   57F8
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
057DC:  BTFSC  xD6.0
057DE:  BRA    57F6
057E0:  MOVF   xD3,W
057E2:  SUBLW  00
057E4:  BC    57F6
057E6:  MOVF   xD3,W
057E8:  SUBLW  08
057EA:  BNC   57F6
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
057EC:  MOVLW  08
057EE:  MOVWF  xD3
057F0:  MOVLW  0B
057F2:  MOVWF  xD4
....................             continue; 
057F4:  BRA    588E
....................             } 
....................          break; 
057F6:  BRA    5890
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
057F8:  MOVF   xD5,W
057FA:  SUBLW  22
057FC:  BNZ   5800
....................          break;               // Reject "  
057FE:  BRA    5890
....................  
....................       if (c <= ')')  
05800:  MOVF   xD5,W
05802:  SUBLW  29
05804:  BNC   5808
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
05806:  BRA    5872
....................  
....................       if (c <= ',') 
05808:  MOVF   xD5,W
0580A:  SUBLW  2C
0580C:  BNC   5810
....................          break;               // Reject * + ,  
0580E:  BRA    5890
....................  
....................       if (c <= '9')  
05810:  MOVF   xD5,W
05812:  SUBLW  39
05814:  BNC   5818
....................          goto md_l1;            // Accept - 0-9  
05816:  BRA    5872
....................  
....................       if (c <= '?')  
05818:  MOVF   xD5,W
0581A:  SUBLW  3F
0581C:  BNC   5820
....................          break;               // Reject : ; < = > ?  
0581E:  BRA    5890
....................  
....................       if (!(a & 1))  
05820:  BTFSC  xD6.0
05822:  BRA    5872
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
05824:  MOVF   xD5,W
05826:  SUBLW  7C
05828:  BNZ   582C
....................             break;            // Reject |  
0582A:  BRA    5890
....................  
....................          if ((c >= '[') && (c <= ']')) 
0582C:  MOVF   xD5,W
0582E:  SUBLW  5A
05830:  BC    583A
05832:  MOVF   xD5,W
05834:  SUBLW  5D
05836:  BNC   583A
....................             break;// Reject [ \ ]  
05838:  BRA    5890
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
0583A:  MOVF   xD5,W
0583C:  SUBLW  40
0583E:  BC    5854
05840:  MOVF   xD5,W
05842:  SUBLW  5A
05844:  BNC   5854
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
05846:  MOVF   xD4,W
05848:  SUBLW  08
0584A:  BNZ   5852
0584C:  BCF    xD7.3
0584E:  MOVF   xD7,W
05850:  BRA    5854
05852:  BCF    xD7.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
05854:  MOVF   xD5,W
05856:  SUBLW  60
05858:  BC    5872
0585A:  MOVF   xD5,W
0585C:  SUBLW  7A
0585E:  BNC   5872
....................             {      // Convert to upper case  
....................             c -= 0x20; 
05860:  MOVLW  20
05862:  SUBWF  xD5,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
05864:  MOVF   xD4,W
05866:  SUBLW  08
05868:  BNZ   5870
0586A:  BSF    xD6.3
0586C:  MOVF   xD6,W
0586E:  BRA    5872
05870:  BSF    xD6.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
05872:  BCF    xD6.0
....................    md_l2: 
....................       if (n >= t)  
05874:  MOVF   xD4,W
05876:  SUBWF  xD3,W
05878:  BNC   587C
....................          break; 
0587A:  BRA    5890
....................       dirname[n++] = c; 
0587C:  MOVF   xD3,W
0587E:  INCF   xD3,F
05880:  ADDWF  xD1,W
05882:  MOVWF  FE9
05884:  MOVLW  00
05886:  ADDWFC xD2,W
05888:  MOVWF  FEA
0588A:  MOVFF  9D5,FEF
0588E:  BRA    5760
....................       } 
....................    return 1; 
05890:  MOVLW  01
05892:  MOVWF  01
05894:  MOVLB  0
05896:  GOTO   63EA (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
06248:  MOVLB  9
0624A:  CLRF   xCE
0624C:  CLRF   xCD
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
0624E:  MOVLW  14
06250:  MOVLB  7
06252:  ADDWF  x0E,W
06254:  MOVWF  FE9
06256:  MOVLW  00
06258:  ADDWFC x0F,W
0625A:  MOVWF  FEA
0625C:  MOVFF  FEF,9C8
06260:  MOVFF  FEC,9C9
06264:  MOVFF  FEC,9CA
06268:  MOVFF  FEC,9CB
....................    if (fs->fs_type == FS_FAT32)  
0626C:  MOVFF  70E,FE9
06270:  MOVFF  70F,FEA
06274:  MOVF   FEF,W
06276:  SUBLW  03
06278:  BNZ   62FC
....................       { 
....................       scan->clust = scan->sclust = clust; 
0627A:  MOVLW  04
0627C:  MOVLB  9
0627E:  ADDWF  xC0,W
06280:  MOVWF  01
06282:  MOVLW  00
06284:  ADDWFC xC1,W
06286:  MOVFF  01,9CF
0628A:  MOVFF  9C0,FE9
0628E:  MOVFF  9C1,FEA
06292:  MOVFF  9C8,FEF
06296:  MOVFF  9C9,FEC
0629A:  MOVFF  9CA,FEC
0629E:  MOVFF  9CB,FEC
062A2:  MOVWF  FEA
062A4:  MOVFF  9CF,FE9
062A8:  MOVFF  9C8,FEF
062AC:  MOVFF  9C9,FEC
062B0:  MOVFF  9CA,FEC
062B4:  MOVFF  9CB,FEC
....................       scan->sect = clust2sect(clust); 
062B8:  MOVLW  08
062BA:  ADDWF  xC0,W
062BC:  MOVWF  01
062BE:  MOVLW  00
062C0:  ADDWFC xC1,W
062C2:  MOVWF  03
062C4:  MOVFF  01,9CF
062C8:  MOVWF  xD0
062CA:  MOVFF  9CB,9DC
062CE:  MOVFF  9CA,9DB
062D2:  MOVFF  9C9,9DA
062D6:  MOVFF  9C8,9D9
062DA:  MOVLB  0
062DC:  CALL   5662
062E0:  MOVFF  9D0,FEA
062E4:  MOVFF  9CF,FE9
062E8:  MOVFF  00,FEF
062EC:  MOVFF  01,FEC
062F0:  MOVFF  02,FEC
062F4:  MOVFF  03,FEC
....................       } 
062F8:  BRA    635C
062FA:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
062FC:  MOVLW  04
062FE:  MOVLB  9
06300:  ADDWF  xC0,W
06302:  MOVWF  01
06304:  MOVLW  00
06306:  ADDWFC xC1,W
06308:  MOVWF  03
0630A:  MOVFF  9C0,FE9
0630E:  MOVFF  9C1,FEA
06312:  MOVF   FEE,F
06314:  MOVF   FEE,F
06316:  CLRF   FEC
06318:  MOVF   FED,F
0631A:  CLRF   FEF
0631C:  MOVF   FED,F
0631E:  CLRF   FEF
06320:  MOVF   FED,F
06322:  CLRF   FEF
06324:  MOVLW  00
06326:  MOVFF  03,FEA
0632A:  MOVFF  01,FE9
0632E:  MOVFF  00,FEF
06332:  MOVFF  01,FEC
06336:  MOVFF  02,FEC
0633A:  MOVFF  03,FEC
....................       scan->sect = clust; 
0633E:  MOVLW  08
06340:  ADDWF  xC0,W
06342:  MOVWF  FE9
06344:  MOVLW  00
06346:  ADDWFC xC1,W
06348:  MOVWF  FEA
0634A:  MOVFF  9C8,FEF
0634E:  MOVFF  9C9,FEC
06352:  MOVFF  9CA,FEC
06356:  MOVFF  9CB,FEC
0635A:  MOVLB  0
....................       } 
....................    scan->index = 0; 
0635C:  MOVLW  0C
0635E:  MOVLB  9
06360:  ADDWF  xC0,W
06362:  MOVWF  FE9
06364:  MOVLW  00
06366:  ADDWFC xC1,W
06368:  MOVWF  FEA
0636A:  CLRF   FEC
0636C:  MOVF   FED,F
0636E:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
06370:  MOVFF  9C5,03
06374:  MOVFF  9C4,FE9
06378:  MOVFF  9C5,FEA
0637C:  MOVF   FEF,W
0637E:  SUBLW  20
06380:  BZ    63A6
06382:  MOVFF  9C5,03
06386:  MOVFF  9C4,FE9
0638A:  MOVFF  9C5,FEA
0638E:  MOVF   FEF,W
06390:  SUBLW  2F
06392:  BZ    63A6
06394:  MOVFF  9C5,03
06398:  MOVFF  9C4,FE9
0639C:  MOVFF  9C5,FEA
063A0:  MOVF   FEF,W
063A2:  SUBLW  5C
063A4:  BNZ   63AE
....................        path++; 
063A6:  INCF   xC4,F
063A8:  BTFSC  FD8.2
063AA:  INCF   xC5,F
063AC:  BRA    6370
....................  
....................    if ((BYTE)*path < ' ')  
063AE:  MOVFF  9C5,03
063B2:  MOVFF  9C4,FE9
063B6:  MOVFF  9C5,FEA
063BA:  MOVF   FEF,W
063BC:  SUBLW  1F
063BE:  BNC   63D4
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
063C0:  MOVFF  9C6,FE9
063C4:  MOVFF  9C7,FEA
063C8:  CLRF   FEC
063CA:  MOVF   FED,F
063CC:  CLRF   FEF
....................       return (FR_OK); 
063CE:  MOVLW  00
063D0:  MOVWF  01
063D2:  BRA    662C
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
063D4:  MOVLW  09
063D6:  MOVWF  xD0
063D8:  MOVLW  C4
063DA:  MOVWF  xCF
063DC:  MOVFF  9C3,9D2
063E0:  MOVFF  9C2,9D1
063E4:  MOVLB  0
063E6:  GOTO   573C
063EA:  MOVFF  01,9CC
....................       if (ds == 1)  
063EE:  MOVLB  9
063F0:  DECFSZ xCC,W
063F2:  BRA    63FA
....................          return (FR_INVALID_NAME); 
063F4:  MOVLW  04
063F6:  MOVWF  01
063F8:  BRA    662C
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
063FA:  MOVLW  08
063FC:  ADDWF  xC0,W
063FE:  MOVWF  FE9
06400:  MOVLW  00
06402:  ADDWFC xC1,W
06404:  MOVWF  FEA
06406:  MOVFF  FEF,9FA
0640A:  MOVFF  FEC,9FB
0640E:  MOVFF  FEC,9FC
06412:  MOVFF  FEC,9FD
06416:  MOVLB  0
06418:  CALL   5AD6
0641C:  MOVF   01,F
0641E:  BNZ   642A
....................             return (FR_RW_ERROR); 
06420:  MOVLW  07
06422:  MOVWF  01
06424:  MOVLB  9
06426:  BRA    662C
06428:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
0642A:  MOVLW  0C
0642C:  MOVLB  9
0642E:  ADDWF  xC0,W
06430:  MOVWF  FE9
06432:  MOVLW  00
06434:  ADDWFC xC1,W
06436:  MOVWF  FEA
06438:  MOVFF  FEC,9D0
0643C:  MOVF   FED,F
0643E:  MOVFF  FEF,9CF
06442:  MOVLW  0F
06444:  ANDWF  xCF,F
06446:  CLRF   xD0
06448:  RLCF   xCF,F
0644A:  RLCF   xD0,F
0644C:  RLCF   xCF,F
0644E:  RLCF   xD0,F
06450:  RLCF   xCF,F
06452:  RLCF   xD0,F
06454:  RLCF   xCF,F
06456:  RLCF   xD0,F
06458:  RLCF   xCF,F
0645A:  RLCF   xD0,F
0645C:  MOVLW  E0
0645E:  ANDWF  xCF,F
06460:  MOVLW  24
06462:  ADDWF  xCF,W
06464:  MOVWF  01
06466:  MOVLW  00
06468:  ADDWFC xD0,W
0646A:  MOVWF  03
0646C:  MOVF   01,W
0646E:  MOVLB  7
06470:  ADDWF  x0E,W
06472:  MOVWF  01
06474:  MOVF   x0F,W
06476:  ADDWFC 03,F
06478:  MOVFF  01,9CD
0647C:  MOVLB  9
0647E:  MOVFF  03,9CE
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
06482:  MOVFF  9CE,03
06486:  MOVFF  9CD,FE9
0648A:  MOVFF  9CE,FEA
0648E:  MOVF   FEF,F
06490:  BNZ   64A0
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06492:  MOVF   xCC,F
06494:  BNZ   649A
06496:  MOVLW  02
06498:  BRA    649C
0649A:  MOVLW  03
0649C:  MOVWF  01
0649E:  BRA    662C
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
064A0:  MOVFF  9CE,03
064A4:  MOVFF  9CD,FE9
064A8:  MOVFF  9CE,FEA
064AC:  MOVF   FEF,W
064AE:  SUBLW  E5
064B0:  BZ    64F2
064B2:  MOVLW  0B
064B4:  ADDWF  xCD,W
064B6:  MOVWF  01
064B8:  MOVLW  00
064BA:  ADDWFC xCE,W
064BC:  MOVWF  03
064BE:  MOVFF  01,FE9
064C2:  MOVWF  FEA
064C4:  BTFSC  FEF.3
064C6:  BRA    64F2
064C8:  MOVFF  9CE,9D4
064CC:  MOVFF  9CD,9D3
064D0:  MOVFF  9C3,9D6
064D4:  MOVFF  9C2,9D5
064D8:  CLRF   xD8
064DA:  MOVLW  0B
064DC:  MOVWF  xD7
064DE:  MOVLB  0
064E0:  CALL   466E
064E4:  MOVF   01,F
064E6:  BTFSC  FD8.2
064E8:  BRA    64EE
064EA:  MOVLB  9
064EC:  BRA    64F2
....................              break; 
064EE:  BRA    651A
064F0:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
064F2:  MOVFF  9C1,9D0
064F6:  MOVFF  9C0,9CF
064FA:  MOVLB  0
064FC:  RCALL  606E
064FE:  MOVF   01,F
06500:  BNZ   6514
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06502:  MOVLB  9
06504:  MOVF   xCC,F
06506:  BNZ   650C
06508:  MOVLW  02
0650A:  BRA    650E
0650C:  MOVLW  03
0650E:  MOVWF  01
06510:  BRA    662C
06512:  MOVLB  0
06514:  MOVLB  9
06516:  BRA    63FA
06518:  MOVLB  0
....................          } 
....................       if (!ds)  
0651A:  MOVLB  9
0651C:  MOVF   xCC,F
0651E:  BNZ   6538
....................          {  
....................          *win_dir = dptr;  
06520:  MOVFF  9C6,FE9
06524:  MOVFF  9C7,FEA
06528:  MOVFF  9CE,FEC
0652C:  MOVF   FED,F
0652E:  MOVFF  9CD,FEF
....................          return (FR_OK); 
06532:  MOVLW  00
06534:  MOVWF  01
06536:  BRA    662C
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
06538:  MOVLW  0B
0653A:  ADDWF  xCD,W
0653C:  MOVWF  01
0653E:  MOVLW  00
06540:  ADDWFC xCE,W
06542:  MOVWF  03
06544:  MOVFF  01,FE9
06548:  MOVWF  FEA
0654A:  BTFSC  FEF.4
0654C:  BRA    6554
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
0654E:  MOVLW  03
06550:  MOVWF  01
06552:  BRA    662C
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
06554:  MOVLW  14
06556:  ADDWF  xCD,W
06558:  MOVWF  01
0655A:  MOVLW  00
0655C:  ADDWFC xCE,W
0655E:  MOVWF  03
06560:  MOVFF  01,FE9
06564:  MOVWF  FEA
06566:  MOVFF  FEC,9CB
0656A:  MOVF   FED,F
0656C:  MOVFF  FEF,9CF
06570:  MOVFF  9CF,9CA
06574:  CLRF   xCF
06576:  CLRF   xD0
06578:  MOVLW  1A
0657A:  ADDWF  xCD,W
0657C:  MOVWF  01
0657E:  MOVLW  00
06580:  ADDWFC xCE,W
06582:  MOVFF  01,FE9
06586:  MOVWF  FEA
06588:  MOVFF  FEC,03
0658C:  MOVF   FED,F
0658E:  MOVF   FEF,W
06590:  IORWF  xCF,W
06592:  MOVWF  xC8
06594:  MOVF   03,W
06596:  IORWF  xD0,W
06598:  MOVWF  xC9
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
0659A:  MOVLW  04
0659C:  ADDWF  xC0,W
0659E:  MOVWF  01
065A0:  MOVLW  00
065A2:  ADDWFC xC1,W
065A4:  MOVFF  01,9CF
065A8:  MOVFF  9C0,FE9
065AC:  MOVFF  9C1,FEA
065B0:  MOVFF  9C8,FEF
065B4:  MOVFF  9C9,FEC
065B8:  MOVFF  9CA,FEC
065BC:  MOVFF  9CB,FEC
065C0:  MOVWF  FEA
065C2:  MOVFF  9CF,FE9
065C6:  MOVFF  9C8,FEF
065CA:  MOVFF  9C9,FEC
065CE:  MOVFF  9CA,FEC
065D2:  MOVFF  9CB,FEC
....................       scan->sect = clust2sect(clust); 
065D6:  MOVLW  08
065D8:  ADDWF  xC0,W
065DA:  MOVWF  01
065DC:  MOVLW  00
065DE:  ADDWFC xC1,W
065E0:  MOVWF  03
065E2:  MOVFF  01,9CF
065E6:  MOVWF  xD0
065E8:  MOVFF  9CB,9DC
065EC:  MOVFF  9CA,9DB
065F0:  MOVFF  9C9,9DA
065F4:  MOVFF  9C8,9D9
065F8:  MOVLB  0
065FA:  CALL   5662
065FE:  MOVFF  9D0,FEA
06602:  MOVFF  9CF,FE9
06606:  MOVFF  00,FEF
0660A:  MOVFF  01,FEC
0660E:  MOVFF  02,FEC
06612:  MOVFF  03,FEC
....................       scan->index = 0; 
06616:  MOVLW  0C
06618:  MOVLB  9
0661A:  ADDWF  xC0,W
0661C:  MOVWF  FE9
0661E:  MOVLW  00
06620:  ADDWFC xC1,W
06622:  MOVWF  FEA
06624:  CLRF   FEC
06626:  MOVF   FED,F
06628:  CLRF   FEF
0662A:  BRA    63D4
....................       } 
0662C:  MOVLB  0
0662E:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06C46:  MOVLB  9
06C48:  MOVFF  9C0,FE9
06C4C:  MOVFF  9C1,FEA
06C50:  MOVFF  FEF,9C2
06C54:  MOVFF  FEC,9C3
06C58:  MOVFF  FEC,9C4
06C5C:  MOVFF  FEC,9C5
....................    if (clust) {   // Dyanmic directory table  
06C60:  MOVF   xC2,F
06C62:  BNZ   6C70
06C64:  MOVF   xC3,F
06C66:  BNZ   6C70
06C68:  MOVF   xC4,F
06C6A:  BNZ   6C70
06C6C:  MOVF   xC5,F
06C6E:  BZ    6CD0
....................       scan->clust = clust; 
06C70:  MOVLW  04
06C72:  ADDWF  xC0,W
06C74:  MOVWF  FE9
06C76:  MOVLW  00
06C78:  ADDWFC xC1,W
06C7A:  MOVWF  FEA
06C7C:  MOVFF  9C2,FEF
06C80:  MOVFF  9C3,FEC
06C84:  MOVFF  9C4,FEC
06C88:  MOVFF  9C5,FEC
....................       scan->sect = clust2sect(clust); 
06C8C:  MOVLW  08
06C8E:  ADDWF  xC0,W
06C90:  MOVWF  01
06C92:  MOVLW  00
06C94:  ADDWFC xC1,W
06C96:  MOVWF  03
06C98:  MOVFF  01,9CE
06C9C:  MOVWF  xCF
06C9E:  MOVFF  9C5,9DC
06CA2:  MOVFF  9C4,9DB
06CA6:  MOVFF  9C3,9DA
06CAA:  MOVFF  9C2,9D9
06CAE:  MOVLB  0
06CB0:  CALL   5662
06CB4:  MOVFF  9CF,FEA
06CB8:  MOVFF  9CE,FE9
06CBC:  MOVFF  00,FEF
06CC0:  MOVFF  01,FEC
06CC4:  MOVFF  02,FEC
06CC8:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06CCC:  BRA    6D1A
06CCE:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06CD0:  MOVLW  08
06CD2:  ADDWF  xC0,W
06CD4:  MOVWF  01
06CD6:  MOVLW  00
06CD8:  ADDWFC xC1,W
06CDA:  MOVWF  03
06CDC:  MOVFF  01,9CE
06CE0:  MOVWF  xCF
06CE2:  MOVLW  14
06CE4:  MOVLB  7
06CE6:  ADDWF  x0E,W
06CE8:  MOVWF  FE9
06CEA:  MOVLW  00
06CEC:  ADDWFC x0F,W
06CEE:  MOVWF  FEA
06CF0:  MOVFF  FEF,00
06CF4:  MOVFF  FEC,01
06CF8:  MOVFF  FEC,02
06CFC:  MOVFF  FEC,03
06D00:  MOVFF  9CF,FEA
06D04:  MOVFF  9CE,FE9
06D08:  MOVFF  00,FEF
06D0C:  MOVFF  01,FEC
06D10:  MOVFF  02,FEC
06D14:  MOVFF  03,FEC
06D18:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06D1A:  MOVLW  0C
06D1C:  MOVLB  9
06D1E:  ADDWF  xC0,W
06D20:  MOVWF  FE9
06D22:  MOVLW  00
06D24:  ADDWFC xC1,W
06D26:  MOVWF  FEA
06D28:  CLRF   FEC
06D2A:  MOVF   FED,F
06D2C:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06D2E:  MOVLW  08
06D30:  ADDWF  xC0,W
06D32:  MOVWF  FE9
06D34:  MOVLW  00
06D36:  ADDWFC xC1,W
06D38:  MOVWF  FEA
06D3A:  MOVFF  FEF,9FA
06D3E:  MOVFF  FEC,9FB
06D42:  MOVFF  FEC,9FC
06D46:  MOVFF  FEC,9FD
06D4A:  MOVLB  0
06D4C:  CALL   5AD6
06D50:  MOVF   01,F
06D52:  BNZ   6D5C
....................          return (NULL); 
06D54:  MOVLW  00
06D56:  MOVWF  01
06D58:  MOVWF  02
06D5A:  BRA    6F88
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06D5C:  MOVLW  0C
06D5E:  MOVLB  9
06D60:  ADDWF  xC0,W
06D62:  MOVWF  FE9
06D64:  MOVLW  00
06D66:  ADDWFC xC1,W
06D68:  MOVWF  FEA
06D6A:  MOVFF  FEC,9CF
06D6E:  MOVF   FED,F
06D70:  MOVFF  FEF,9CE
06D74:  MOVLW  0F
06D76:  ANDWF  xCE,F
06D78:  CLRF   xCF
06D7A:  RLCF   xCE,F
06D7C:  RLCF   xCF,F
06D7E:  RLCF   xCE,F
06D80:  RLCF   xCF,F
06D82:  RLCF   xCE,F
06D84:  RLCF   xCF,F
06D86:  RLCF   xCE,F
06D88:  RLCF   xCF,F
06D8A:  RLCF   xCE,F
06D8C:  RLCF   xCF,F
06D8E:  MOVLW  E0
06D90:  ANDWF  xCE,F
06D92:  MOVLW  24
06D94:  ADDWF  xCE,W
06D96:  MOVWF  01
06D98:  MOVLW  00
06D9A:  ADDWFC xCF,W
06D9C:  MOVWF  03
06D9E:  MOVF   01,W
06DA0:  MOVLB  7
06DA2:  ADDWF  x0E,W
06DA4:  MOVWF  01
06DA6:  MOVF   x0F,W
06DA8:  ADDWFC 03,F
06DAA:  MOVFF  01,9CC
06DAE:  MOVLB  9
06DB0:  MOVFF  03,9CD
....................       c = *dptr; 
06DB4:  MOVFF  9CC,FE9
06DB8:  MOVFF  9CD,FEA
06DBC:  MOVFF  FEF,9CA
....................       if ((c == 0) || (c == 0xE5))  
06DC0:  MOVF   xCA,F
06DC2:  BZ    6DCA
06DC4:  MOVF   xCA,W
06DC6:  SUBLW  E5
06DC8:  BNZ   6DD8
....................          return (dptr);      // Found an empty entry!  
06DCA:  MOVFF  9CC,01
06DCE:  MOVFF  9CD,02
06DD2:  MOVLB  0
06DD4:  BRA    6F88
06DD6:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06DD8:  MOVFF  9C1,9D0
06DDC:  MOVFF  9C0,9CF
06DE0:  MOVLB  0
06DE2:  CALL   606E
06DE6:  MOVF   01,F
06DE8:  BTFSC  FD8.2
06DEA:  BRA    6DF0
06DEC:  MOVLB  9
06DEE:  BRA    6D2E
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06DF0:  MOVLB  9
06DF2:  MOVF   xC2,F
06DF4:  BNZ   6E0E
06DF6:  MOVF   xC3,F
06DF8:  BNZ   6E0E
06DFA:  MOVF   xC4,F
06DFC:  BNZ   6E0E
06DFE:  MOVF   xC5,F
06E00:  BNZ   6E0E
....................        return (NULL); 
06E02:  MOVLW  00
06E04:  MOVWF  01
06E06:  MOVWF  02
06E08:  MOVLB  0
06E0A:  BRA    6F88
06E0C:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06E0E:  MOVLW  04
06E10:  ADDWF  xC0,W
06E12:  MOVWF  FE9
06E14:  MOVLW  00
06E16:  ADDWFC xC1,W
06E18:  MOVWF  FEA
06E1A:  MOVFF  FEF,9D2
06E1E:  MOVFF  FEC,9D3
06E22:  MOVFF  FEC,9D4
06E26:  MOVFF  FEC,9D5
06E2A:  MOVLB  0
06E2C:  RCALL  69B0
06E2E:  MOVFF  03,9C5
06E32:  MOVFF  02,9C4
06E36:  MOVFF  01,9C3
06E3A:  MOVFF  00,9C2
....................    if (!(clust))  
06E3E:  MOVLB  9
06E40:  MOVF   xC2,F
06E42:  BNZ   6E5C
06E44:  MOVF   xC3,F
06E46:  BNZ   6E5C
06E48:  MOVF   xC4,F
06E4A:  BNZ   6E5C
06E4C:  MOVF   xC5,F
06E4E:  BNZ   6E5C
....................       return (NULL); 
06E50:  MOVLW  00
06E52:  MOVWF  01
06E54:  MOVWF  02
06E56:  MOVLB  0
06E58:  BRA    6F88
06E5A:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06E5C:  CLRF   xFD
06E5E:  CLRF   xFC
06E60:  CLRF   xFB
06E62:  CLRF   xFA
06E64:  MOVLB  0
06E66:  CALL   5AD6
06E6A:  MOVF   01,F
06E6C:  BNZ   6E76
....................       return (0); 
06E6E:  MOVLW  00
06E70:  MOVWF  01
06E72:  MOVWF  02
06E74:  BRA    6F88
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06E76:  MOVLW  20
06E78:  MOVLB  7
06E7A:  ADDWF  x0E,W
06E7C:  MOVWF  01
06E7E:  MOVLW  00
06E80:  ADDWFC x0F,W
06E82:  MOVWF  03
06E84:  MOVFF  01,9CE
06E88:  MOVLB  9
06E8A:  MOVWF  xCF
06E8C:  MOVFF  9C5,9DC
06E90:  MOVFF  9C4,9DB
06E94:  MOVFF  9C3,9DA
06E98:  MOVFF  9C2,9D9
06E9C:  MOVLB  0
06E9E:  CALL   5662
06EA2:  MOVFF  03,9C9
06EA6:  MOVFF  02,9C8
06EAA:  MOVFF  01,9C7
06EAE:  MOVFF  00,9C6
06EB2:  MOVFF  9CF,FEA
06EB6:  MOVFF  9CE,FE9
06EBA:  MOVFF  9C6,FEF
06EBE:  MOVFF  9C7,FEC
06EC2:  MOVFF  9C8,FEC
06EC6:  MOVFF  9C9,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06ECA:  MOVLW  24
06ECC:  MOVLB  7
06ECE:  ADDWF  x0E,W
06ED0:  MOVWF  01
06ED2:  MOVLW  00
06ED4:  ADDWFC x0F,W
06ED6:  MOVWF  03
06ED8:  MOVFF  01,9CE
06EDC:  MOVLB  9
06EDE:  MOVWF  xCF
06EE0:  MOVWF  FEA
06EE2:  MOVFF  01,FE9
06EE6:  CLRF   00
06EE8:  MOVLW  02
06EEA:  MOVWF  02
06EEC:  CLRF   01
06EEE:  MOVLB  0
06EF0:  CALL   3588
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06EF4:  MOVLW  02
06EF6:  MOVLB  7
06EF8:  ADDWF  x0E,W
06EFA:  MOVWF  FE9
06EFC:  MOVLW  00
06EFE:  ADDWFC x0F,W
06F00:  MOVWF  FEA
06F02:  MOVFF  FEF,9CB
06F06:  MOVLB  9
06F08:  MOVF   xCB,F
06F0A:  BZ    6F68
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06F0C:  MOVLW  24
06F0E:  MOVLB  7
06F10:  ADDWF  x0E,W
06F12:  MOVWF  01
06F14:  MOVLW  00
06F16:  ADDWFC x0F,W
06F18:  MOVWF  03
06F1A:  MOVFF  01,9CE
06F1E:  MOVLB  9
06F20:  MOVWF  xCF
06F22:  MOVFF  FE8,A07
06F26:  MOVFF  01,A06
06F2A:  MOVFF  9C9,A0B
06F2E:  MOVFF  9C8,A0A
06F32:  MOVFF  9C7,A09
06F36:  MOVFF  9C6,A08
06F3A:  MOVLW  01
06F3C:  MOVLB  A
06F3E:  MOVWF  x0C
06F40:  MOVLB  0
06F42:  CALL   5992
06F46:  MOVF   01,F
06F48:  BZ    6F52
....................          return (NULL); 
06F4A:  MOVLW  00
06F4C:  MOVWF  01
06F4E:  MOVWF  02
06F50:  BRA    6F88
....................       sector++; 
06F52:  MOVLW  01
06F54:  MOVLB  9
06F56:  ADDWF  xC6,F
06F58:  BTFSC  FD8.0
06F5A:  INCF   xC7,F
06F5C:  BTFSC  FD8.2
06F5E:  INCF   xC8,F
06F60:  BTFSC  FD8.2
06F62:  INCF   xC9,F
06F64:  DECF   xCB,F
06F66:  BRA    6F08
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06F68:  MOVLW  06
06F6A:  MOVLB  7
06F6C:  ADDWF  x0E,W
06F6E:  MOVWF  FE9
06F70:  MOVLW  00
06F72:  ADDWFC x0F,W
06F74:  MOVWF  FEA
06F76:  MOVLW  01
06F78:  MOVWF  FEF
....................    return (fs->win); 
06F7A:  MOVLW  24
06F7C:  ADDWF  x0E,W
06F7E:  MOVWF  01
06F80:  MOVLW  00
06F82:  ADDWFC x0F,W
06F84:  MOVWF  03
06F86:  MOVWF  02
06F88:  MOVLB  0
06F8A:  GOTO   7220 (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
05600:  MOVLB  7
05602:  MOVF   x0E,W
05604:  IORWF  x0F,W
05606:  BNZ   560E
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
05608:  MOVLW  0B
0560A:  MOVWF  01
0560C:  BRA    565E
....................  
....................    if (disk_status() & STA_NOINIT)  
0560E:  MOVLB  0
05610:  RCALL  55F2
05612:  BTFSS  01.0
05614:  BRA    5640
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
05616:  MOVLW  01
05618:  MOVLB  7
0561A:  ADDWF  x0E,W
0561C:  MOVWF  FE9
0561E:  MOVLW  00
05620:  ADDWFC x0F,W
05622:  MOVWF  FEA
05624:  MOVF   FEF,F
05626:  BZ    5630
....................          return (FR_INCORRECT_DISK_CHANGE); 
05628:  MOVLW  09
0562A:  MOVWF  01
0562C:  BRA    565E
0562E:  BRA    563C
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
05630:  MOVLB  0
05632:  CALL   48AE
05636:  MOVF   01,W
05638:  MOVLB  7
0563A:  BRA    565E
....................       }  
0563C:  BRA    565A
0563E:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
05640:  MOVLB  7
05642:  MOVFF  70E,FE9
05646:  MOVFF  70F,FEA
0564A:  MOVF   FEF,F
0564C:  BNZ   565A
....................          return (f_mountdrv());      // Initialize file system and return resulut  
0564E:  MOVLB  0
05650:  CALL   48AE
05654:  MOVF   01,W
05656:  MOVLB  7
05658:  BRA    565E
....................       } 
....................    return FR_OK;                  // File system is valid  
0565A:  MOVLW  00
0565C:  MOVWF  01
0565E:  MOVLB  0
05660:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B6E8:  MOVLB  8
0B6EA:  MOVF   xB6,W
0B6EC:  XORLW  00
0B6EE:  MOVLB  0
0B6F0:  BZ    B72A
0B6F2:  XORLW  04
0B6F4:  BZ    B746
0B6F6:  XORLW  05
0B6F8:  BZ    B762
0B6FA:  XORLW  03
0B6FC:  BZ    B77E
0B6FE:  XORLW  01
0B700:  BZ    B79A
0B702:  XORLW  06
0B704:  BZ    B7B6
0B706:  XORLW  03
0B708:  BZ    B7D2
0B70A:  XORLW  01
0B70C:  BTFSC  FD8.2
0B70E:  BRA    B7EE
0B710:  XORLW  0E
0B712:  BTFSC  FD8.2
0B714:  BRA    B80A
0B716:  XORLW  03
0B718:  BTFSC  FD8.2
0B71A:  BRA    B826
0B71C:  XORLW  01
0B71E:  BTFSC  FD8.2
0B720:  BRA    B842
0B722:  XORLW  07
0B724:  BTFSC  FD8.2
0B726:  BRA    B85E
0B728:  BRA    B87A
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B72A:  MOVFF  8B8,FEA
0B72E:  MOVFF  8B7,FE9
0B732:  MOVLW  00
0B734:  CALL   0106
0B738:  TBLRD*-
0B73A:  TBLRD*+
0B73C:  MOVF   FF5,W
0B73E:  MOVWF  FEE
0B740:  IORLW  00
0B742:  BNZ   B73A
....................          break; 
0B744:  BRA    B894
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B746:  MOVFF  8B8,FEA
0B74A:  MOVFF  8B7,FE9
0B74E:  MOVLW  00
0B750:  CALL   0124
0B754:  TBLRD*-
0B756:  TBLRD*+
0B758:  MOVF   FF5,W
0B75A:  MOVWF  FEE
0B75C:  IORLW  00
0B75E:  BNZ   B756
....................          break; 
0B760:  BRA    B894
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B762:  MOVFF  8B8,FEA
0B766:  MOVFF  8B7,FE9
0B76A:  MOVLW  00
0B76C:  CALL   014A
0B770:  TBLRD*-
0B772:  TBLRD*+
0B774:  MOVF   FF5,W
0B776:  MOVWF  FEE
0B778:  IORLW  00
0B77A:  BNZ   B772
....................          break; 
0B77C:  BRA    B894
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0B77E:  MOVFF  8B8,FEA
0B782:  MOVFF  8B7,FE9
0B786:  MOVLW  00
0B788:  CALL   016E
0B78C:  TBLRD*-
0B78E:  TBLRD*+
0B790:  MOVF   FF5,W
0B792:  MOVWF  FEE
0B794:  IORLW  00
0B796:  BNZ   B78E
....................          break; 
0B798:  BRA    B894
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0B79A:  MOVFF  8B8,FEA
0B79E:  MOVFF  8B7,FE9
0B7A2:  MOVLW  00
0B7A4:  CALL   0192
0B7A8:  TBLRD*-
0B7AA:  TBLRD*+
0B7AC:  MOVF   FF5,W
0B7AE:  MOVWF  FEE
0B7B0:  IORLW  00
0B7B2:  BNZ   B7AA
....................          break; 
0B7B4:  BRA    B894
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0B7B6:  MOVFF  8B8,FEA
0B7BA:  MOVFF  8B7,FE9
0B7BE:  MOVLW  00
0B7C0:  CALL   01B6
0B7C4:  TBLRD*-
0B7C6:  TBLRD*+
0B7C8:  MOVF   FF5,W
0B7CA:  MOVWF  FEE
0B7CC:  IORLW  00
0B7CE:  BNZ   B7C6
....................          break; 
0B7D0:  BRA    B894
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0B7D2:  MOVFF  8B8,FEA
0B7D6:  MOVFF  8B7,FE9
0B7DA:  MOVLW  00
0B7DC:  CALL   01D8
0B7E0:  TBLRD*-
0B7E2:  TBLRD*+
0B7E4:  MOVF   FF5,W
0B7E6:  MOVWF  FEE
0B7E8:  IORLW  00
0B7EA:  BNZ   B7E2
....................          break; 
0B7EC:  BRA    B894
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0B7EE:  MOVFF  8B8,FEA
0B7F2:  MOVFF  8B7,FE9
0B7F6:  MOVLW  00
0B7F8:  CALL   01F8
0B7FC:  TBLRD*-
0B7FE:  TBLRD*+
0B800:  MOVF   FF5,W
0B802:  MOVWF  FEE
0B804:  IORLW  00
0B806:  BNZ   B7FE
....................          break; 
0B808:  BRA    B894
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0B80A:  MOVFF  8B8,FEA
0B80E:  MOVFF  8B7,FE9
0B812:  MOVLW  00
0B814:  CALL   0216
0B818:  TBLRD*-
0B81A:  TBLRD*+
0B81C:  MOVF   FF5,W
0B81E:  MOVWF  FEE
0B820:  IORLW  00
0B822:  BNZ   B81A
....................          break; 
0B824:  BRA    B894
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0B826:  MOVFF  8B8,FEA
0B82A:  MOVFF  8B7,FE9
0B82E:  MOVLW  00
0B830:  CALL   0242
0B834:  TBLRD*-
0B836:  TBLRD*+
0B838:  MOVF   FF5,W
0B83A:  MOVWF  FEE
0B83C:  IORLW  00
0B83E:  BNZ   B836
....................          break; 
0B840:  BRA    B894
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0B842:  MOVFF  8B8,FEA
0B846:  MOVFF  8B7,FE9
0B84A:  MOVLW  00
0B84C:  CALL   0266
0B850:  TBLRD*-
0B852:  TBLRD*+
0B854:  MOVF   FF5,W
0B856:  MOVWF  FEE
0B858:  IORLW  00
0B85A:  BNZ   B852
....................          break; 
0B85C:  BRA    B894
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0B85E:  MOVFF  8B8,FEA
0B862:  MOVFF  8B7,FE9
0B866:  MOVLW  00
0B868:  CALL   028A
0B86C:  TBLRD*-
0B86E:  TBLRD*+
0B870:  MOVF   FF5,W
0B872:  MOVWF  FEE
0B874:  IORLW  00
0B876:  BNZ   B86E
....................          break; 
0B878:  BRA    B894
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0B87A:  MOVFF  8B8,FEA
0B87E:  MOVFF  8B7,FE9
0B882:  MOVLW  00
0B884:  CALL   02AC
0B888:  TBLRD*-
0B88A:  TBLRD*+
0B88C:  MOVF   FF5,W
0B88E:  MOVWF  FEE
0B890:  IORLW  00
0B892:  BNZ   B88A
....................       } 
0B894:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
048AE:  MOVLB  7
048B0:  MOVF   x0E,W
048B2:  IORWF  x0F,W
048B4:  BNZ   48BC
....................       return (FR_NOT_ENABLED); 
048B6:  MOVLW  0B
048B8:  MOVWF  01
048BA:  BRA    4E48
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
048BC:  MOVFF  70F,FEA
048C0:  MOVFF  70E,FE9
048C4:  CLRF   00
048C6:  MOVLW  02
048C8:  MOVWF  02
048CA:  MOVLW  24
048CC:  MOVWF  01
048CE:  MOVLB  0
048D0:  CALL   3588
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
048D4:  CALL   36D8
048D8:  MOVFF  01,4E9
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
048DC:  MOVLB  4
048DE:  BTFSS  xE9.0
048E0:  BRA    48EE
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
048E2:  MOVLB  0
048E4:  CALL   36D8
048E8:  MOVFF  01,4E9
048EC:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
048EE:  BTFSS  xE9.0
048F0:  BRA    48FC
048F2:  MOVLW  01
048F4:  MOVWF  01
048F6:  MOVLB  7
048F8:  BRA    4E48
048FA:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
048FC:  MOVLB  9
048FE:  CLRF   xC4
04900:  CLRF   xC3
04902:  CLRF   xC2
04904:  CLRF   xC1
04906:  MOVFF  9C4,9D0
0490A:  MOVFF  9C3,9CF
0490E:  MOVFF  9C2,9CE
04912:  MOVFF  9C1,9CD
04916:  MOVLB  0
04918:  RCALL  46F2
0491A:  MOVFF  01,9C0
....................    if (!fat)  
0491E:  MOVLB  9
04920:  MOVF   xC0,F
04922:  BNZ   4992
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
04924:  MOVLW  E6
04926:  MOVLB  7
04928:  ADDWF  x0E,W
0492A:  MOVWF  FE9
0492C:  MOVLW  01
0492E:  ADDWFC x0F,W
04930:  MOVWF  FEA
04932:  MOVF   FEF,F
04934:  BZ    4972
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
04936:  MOVLW  EA
04938:  ADDWF  x0E,W
0493A:  MOVWF  01
0493C:  MOVLW  01
0493E:  ADDWFC x0F,W
04940:  MOVFF  01,FE9
04944:  MOVWF  FEA
04946:  MOVFF  FEF,9C1
0494A:  MOVFF  FEC,9C2
0494E:  MOVFF  FEC,9C3
04952:  MOVFF  FEC,9C4
....................          fat = check_fs(sect);            // Check the partition  
04956:  MOVFF  9C4,9D0
0495A:  MOVFF  9C3,9CF
0495E:  MOVFF  9C2,9CE
04962:  MOVFF  9C1,9CD
04966:  MOVLB  0
04968:  RCALL  46F2
0496A:  MOVFF  01,9C0
....................          } 
0496E:  BRA    4990
04970:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
04972:  MOVLW  04
04974:  MOVWF  FF6
04976:  MOVLW  0C
04978:  MOVWF  FF7
0497A:  MOVLW  00
0497C:  MOVWF  FF8
0497E:  CLRF   1B
04980:  BTFSC  FF2.7
04982:  BSF    1B.7
04984:  BCF    FF2.7
04986:  MOVLB  0
04988:  CALL   0DCC
0498C:  BTFSC  1B.7
0498E:  BSF    FF2.7
04990:  MOVLB  9
....................       } 
....................    if (!fat)  
04992:  MOVF   xC0,F
04994:  BNZ   49A0
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
04996:  MOVLW  0C
04998:  MOVWF  01
0499A:  MOVLB  7
0499C:  BRA    4E48
0499E:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
049A0:  MOVLB  7
049A2:  MOVFF  70E,FE9
049A6:  MOVFF  70F,FEA
049AA:  MOVFF  9C0,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
049AE:  MOVLB  9
049B0:  MOVF   xC0,W
049B2:  SUBLW  03
049B4:  BNZ   4A1A
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
049B6:  MOVLW  08
049B8:  MOVLB  7
049BA:  ADDWF  x0E,W
049BC:  MOVWF  01
049BE:  MOVLW  00
049C0:  ADDWFC x0F,W
049C2:  MOVWF  03
049C4:  MOVFF  01,9CD
049C8:  MOVLB  9
049CA:  MOVWF  xCE
049CC:  MOVLW  48
049CE:  MOVLB  7
049D0:  ADDWF  x0E,W
049D2:  MOVWF  01
049D4:  MOVLW  00
049D6:  ADDWFC x0F,W
049D8:  MOVFF  01,FE9
049DC:  MOVWF  FEA
049DE:  MOVFF  FEF,00
049E2:  MOVFF  FEC,01
049E6:  MOVFF  FEC,02
049EA:  MOVFF  FEC,03
049EE:  MOVFF  03,9D2
049F2:  MOVFF  02,9D1
049F6:  MOVFF  01,9D0
049FA:  MOVFF  00,9CF
049FE:  MOVFF  9CE,FEA
04A02:  MOVFF  9CD,FE9
04A06:  MOVFF  00,FEF
04A0A:  MOVFF  01,FEC
04A0E:  MOVFF  02,FEC
04A12:  MOVFF  03,FEC
04A16:  BRA    4A72
04A18:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
04A1A:  MOVLW  08
04A1C:  MOVLB  7
04A1E:  ADDWF  x0E,W
04A20:  MOVWF  01
04A22:  MOVLW  00
04A24:  ADDWFC x0F,W
04A26:  MOVWF  03
04A28:  MOVFF  01,9CD
04A2C:  MOVLB  9
04A2E:  MOVWF  xCE
04A30:  MOVLW  3A
04A32:  MOVLB  7
04A34:  ADDWF  x0E,W
04A36:  MOVWF  01
04A38:  MOVLW  00
04A3A:  ADDWFC x0F,W
04A3C:  MOVFF  01,FE9
04A40:  MOVWF  FEA
04A42:  MOVFF  FEC,03
04A46:  MOVF   FED,F
04A48:  MOVFF  FEF,9CF
04A4C:  MOVLB  9
04A4E:  MOVFF  03,9D0
04A52:  MOVFF  9CE,FEA
04A56:  MOVFF  9CD,FE9
04A5A:  MOVF   FEE,F
04A5C:  MOVF   FEE,F
04A5E:  CLRF   FEC
04A60:  MOVF   FED,F
04A62:  CLRF   FEF
04A64:  MOVF   FED,F
04A66:  MOVFF  03,FEF
04A6A:  MOVF   FED,F
04A6C:  MOVFF  9CF,FEF
04A70:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
04A72:  MOVLW  02
04A74:  ADDWF  x0E,W
04A76:  MOVWF  01
04A78:  MOVLW  00
04A7A:  ADDWFC x0F,W
04A7C:  MOVWF  03
04A7E:  MOVLW  31
04A80:  MOVLB  7
04A82:  ADDWF  x0E,W
04A84:  MOVWF  FE9
04A86:  MOVLW  00
04A88:  ADDWFC x0F,W
04A8A:  MOVWF  FEA
04A8C:  MOVFF  FEF,9CF
04A90:  MOVLB  9
04A92:  MOVFF  03,FEA
04A96:  MOVFF  01,FE9
04A9A:  MOVFF  9CF,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
04A9E:  MOVLW  03
04AA0:  MOVLB  7
04AA2:  ADDWF  x0E,W
04AA4:  MOVWF  01
04AA6:  MOVLW  00
04AA8:  ADDWFC x0F,W
04AAA:  MOVWF  03
04AAC:  MOVLW  34
04AAE:  MOVLB  7
04AB0:  ADDWF  x0E,W
04AB2:  MOVWF  FE9
04AB4:  MOVLW  00
04AB6:  ADDWFC x0F,W
04AB8:  MOVWF  FEA
04ABA:  MOVFF  FEF,9CF
04ABE:  MOVLB  9
04AC0:  MOVFF  03,FEA
04AC4:  MOVFF  01,FE9
04AC8:  MOVFF  9CF,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
04ACC:  MOVLW  10
04ACE:  MOVLB  7
04AD0:  ADDWF  x0E,W
04AD2:  MOVWF  01
04AD4:  MOVLW  00
04AD6:  ADDWFC x0F,W
04AD8:  MOVWF  03
04ADA:  MOVFF  01,9CD
04ADE:  MOVLB  9
04AE0:  MOVWF  xCE
04AE2:  MOVLW  32
04AE4:  MOVLB  7
04AE6:  ADDWF  x0E,W
04AE8:  MOVWF  01
04AEA:  MOVLW  00
04AEC:  ADDWFC x0F,W
04AEE:  MOVFF  01,FE9
04AF2:  MOVWF  FEA
04AF4:  MOVFF  FEC,03
04AF8:  MOVF   FED,F
04AFA:  MOVF   FEF,W
04AFC:  MOVLB  9
04AFE:  ADDWF  xC1,W
04B00:  MOVWF  00
04B02:  MOVF   03,W
04B04:  ADDWFC xC2,W
04B06:  MOVWF  01
04B08:  MOVLW  00
04B0A:  ADDWFC xC3,W
04B0C:  MOVWF  02
04B0E:  MOVLW  00
04B10:  ADDWFC xC4,W
04B12:  MOVFF  9CE,FEA
04B16:  MOVFF  9CD,FE9
04B1A:  MOVFF  00,FEF
04B1E:  MOVFF  01,FEC
04B22:  MOVFF  02,FEC
04B26:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04B28:  MOVLW  04
04B2A:  MOVLB  7
04B2C:  ADDWF  x0E,W
04B2E:  MOVWF  01
04B30:  MOVLW  00
04B32:  ADDWFC x0F,W
04B34:  MOVWF  03
04B36:  MOVFF  01,9CD
04B3A:  MOVLB  9
04B3C:  MOVWF  xCE
04B3E:  MOVLW  35
04B40:  MOVLB  7
04B42:  ADDWF  x0E,W
04B44:  MOVWF  01
04B46:  MOVLW  00
04B48:  ADDWFC x0F,W
04B4A:  MOVFF  01,FE9
04B4E:  MOVWF  FEA
04B50:  MOVFF  FEC,03
04B54:  MOVF   FED,F
04B56:  MOVFF  FEF,9CF
04B5A:  MOVLB  9
04B5C:  MOVFF  9CE,FEA
04B60:  MOVFF  9CD,FE9
04B64:  MOVFF  03,FEC
04B68:  MOVF   FED,F
04B6A:  MOVFF  9CF,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04B6E:  MOVLW  08
04B70:  MOVLB  7
04B72:  ADDWF  x0E,W
04B74:  MOVWF  FE9
04B76:  MOVLW  00
04B78:  ADDWFC x0F,W
04B7A:  MOVWF  FEA
04B7C:  MOVFF  FEF,9E0
04B80:  MOVFF  FEC,9E1
04B84:  MOVFF  FEC,9E2
04B88:  MOVFF  FEC,9E3
04B8C:  MOVLW  03
04B8E:  ADDWF  x0E,W
04B90:  MOVWF  FE9
04B92:  MOVLW  00
04B94:  ADDWFC x0F,W
04B96:  MOVWF  FEA
04B98:  MOVFF  FEF,9E4
04B9C:  MOVLB  9
04B9E:  MOVFF  FEA,9D3
04BA2:  MOVFF  FE9,9D2
04BA6:  CLRF   xE7
04BA8:  CLRF   xE6
04BAA:  CLRF   xE5
04BAC:  MOVLB  0
04BAE:  RCALL  4852
04BB0:  MOVFF  9D3,FEA
04BB4:  MOVFF  9D2,FE9
04BB8:  MOVFF  03,9D0
04BBC:  MOVFF  02,9CF
04BC0:  MOVFF  01,9CE
04BC4:  MOVFF  00,9CD
04BC8:  MOVLW  10
04BCA:  MOVLB  7
04BCC:  ADDWF  x0E,W
04BCE:  MOVWF  FE9
04BD0:  MOVLW  00
04BD2:  ADDWFC x0F,W
04BD4:  MOVWF  FEA
04BD6:  MOVFF  FEF,00
04BDA:  MOVFF  FEC,01
04BDE:  MOVFF  FEC,02
04BE2:  MOVFF  FEC,03
04BE6:  MOVF   00,W
04BE8:  MOVLB  9
04BEA:  ADDWF  xCD,W
04BEC:  MOVWF  xC5
04BEE:  MOVF   01,W
04BF0:  ADDWFC xCE,W
04BF2:  MOVWF  xC6
04BF4:  MOVF   02,W
04BF6:  ADDWFC xCF,W
04BF8:  MOVWF  xC7
04BFA:  MOVF   03,W
04BFC:  ADDWFC xD0,W
04BFE:  MOVWF  xC8
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04C00:  MOVF   xC0,W
04C02:  SUBLW  03
04C04:  BNZ   4C76
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04C06:  MOVLW  14
04C08:  MOVLB  7
04C0A:  ADDWF  x0E,W
04C0C:  MOVWF  01
04C0E:  MOVLW  00
04C10:  ADDWFC x0F,W
04C12:  MOVWF  03
04C14:  MOVFF  01,9CD
04C18:  MOVLB  9
04C1A:  MOVWF  xCE
04C1C:  MOVLW  50
04C1E:  MOVLB  7
04C20:  ADDWF  x0E,W
04C22:  MOVWF  01
04C24:  MOVLW  00
04C26:  ADDWFC x0F,W
04C28:  MOVFF  01,FE9
04C2C:  MOVWF  FEA
04C2E:  MOVFF  FEF,00
04C32:  MOVFF  FEC,01
04C36:  MOVFF  FEC,02
04C3A:  MOVFF  FEC,03
04C3E:  MOVFF  9CE,FEA
04C42:  MOVFF  9CD,FE9
04C46:  MOVFF  00,FEF
04C4A:  MOVFF  01,FEC
04C4E:  MOVFF  02,FEC
04C52:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04C56:  MOVLW  18
04C58:  ADDWF  x0E,W
04C5A:  MOVWF  FE9
04C5C:  MOVLW  00
04C5E:  ADDWFC x0F,W
04C60:  MOVWF  FEA
04C62:  MOVFF  9C5,FEF
04C66:  MOVFF  9C6,FEC
04C6A:  MOVFF  9C7,FEC
04C6E:  MOVFF  9C8,FEC
....................       }  
04C72:  BRA    4D02
04C74:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04C76:  MOVLW  14
04C78:  MOVLB  7
04C7A:  ADDWF  x0E,W
04C7C:  MOVWF  FE9
04C7E:  MOVLW  00
04C80:  ADDWFC x0F,W
04C82:  MOVWF  FEA
04C84:  MOVFF  9C5,FEF
04C88:  MOVFF  9C6,FEC
04C8C:  MOVFF  9C7,FEC
04C90:  MOVFF  9C8,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04C94:  MOVLW  18
04C96:  ADDWF  x0E,W
04C98:  MOVWF  01
04C9A:  MOVLW  00
04C9C:  ADDWFC x0F,W
04C9E:  MOVFF  01,9CD
04CA2:  MOVLB  9
04CA4:  MOVWF  xCE
04CA6:  MOVLW  04
04CA8:  MOVLB  7
04CAA:  ADDWF  x0E,W
04CAC:  MOVWF  FE9
04CAE:  MOVLW  00
04CB0:  ADDWFC x0F,W
04CB2:  MOVWF  FEA
04CB4:  MOVFF  FEC,9D0
04CB8:  MOVF   FED,F
04CBA:  MOVFF  FEF,9CF
04CBE:  MOVLB  9
04CC0:  RRCF   xD0,F
04CC2:  RRCF   xCF,F
04CC4:  RRCF   xD0,F
04CC6:  RRCF   xCF,F
04CC8:  RRCF   xD0,F
04CCA:  RRCF   xCF,F
04CCC:  RRCF   xD0,F
04CCE:  RRCF   xCF,F
04CD0:  MOVLW  0F
04CD2:  ANDWF  xD0,F
04CD4:  MOVF   xCF,W
04CD6:  ADDWF  xC5,W
04CD8:  MOVWF  00
04CDA:  MOVF   xD0,W
04CDC:  ADDWFC xC6,W
04CDE:  MOVWF  01
04CE0:  MOVLW  00
04CE2:  ADDWFC xC7,W
04CE4:  MOVWF  02
04CE6:  MOVLW  00
04CE8:  ADDWFC xC8,W
04CEA:  MOVFF  9CE,FEA
04CEE:  MOVFF  9CD,FE9
04CF2:  MOVFF  00,FEF
04CF6:  MOVFF  01,FEC
04CFA:  MOVFF  02,FEC
04CFE:  MOVWF  FEC
04D00:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04D02:  MOVLW  44
04D04:  ADDWF  x0E,W
04D06:  MOVWF  01
04D08:  MOVLW  00
04D0A:  ADDWFC x0F,W
04D0C:  MOVFF  01,FE9
04D10:  MOVWF  FEA
04D12:  MOVFF  FEF,9C9
04D16:  MOVFF  FEC,9CA
04D1A:  MOVFF  FEC,9CB
04D1E:  MOVFF  FEC,9CC
....................    if (!maxsect)  
04D22:  MOVLB  9
04D24:  MOVF   xC9,F
04D26:  BNZ   4D56
04D28:  MOVF   xCA,F
04D2A:  BNZ   4D56
04D2C:  MOVF   xCB,F
04D2E:  BNZ   4D56
04D30:  MOVF   xCC,F
04D32:  BNZ   4D56
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04D34:  MOVLW  37
04D36:  MOVLB  7
04D38:  ADDWF  x0E,W
04D3A:  MOVWF  01
04D3C:  MOVLW  00
04D3E:  ADDWFC x0F,W
04D40:  MOVFF  01,FE9
04D44:  MOVWF  FEA
04D46:  MOVLB  9
04D48:  CLRF   xCC
04D4A:  CLRF   xCB
04D4C:  MOVFF  FEC,9CA
04D50:  MOVF   FED,F
04D52:  MOVFF  FEF,9C9
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04D56:  MOVLW  0C
04D58:  MOVLB  7
04D5A:  ADDWF  x0E,W
04D5C:  MOVWF  01
04D5E:  MOVLW  00
04D60:  ADDWFC x0F,W
04D62:  MOVWF  03
04D64:  MOVFF  01,9CD
04D68:  MOVLB  9
04D6A:  MOVWF  xCE
04D6C:  MOVLW  18
04D6E:  MOVLB  7
04D70:  ADDWF  x0E,W
04D72:  MOVWF  FE9
04D74:  MOVLW  00
04D76:  ADDWFC x0F,W
04D78:  MOVWF  FEA
04D7A:  MOVFF  FEF,00
04D7E:  MOVFF  FEC,01
04D82:  MOVFF  FEC,02
04D86:  MOVFF  FEC,03
04D8A:  MOVF   00,W
04D8C:  MOVLB  9
04D8E:  SUBWF  xC9,W
04D90:  MOVWF  xCF
04D92:  MOVF   01,W
04D94:  SUBWFB xCA,W
04D96:  MOVWF  xD0
04D98:  MOVF   02,W
04D9A:  SUBWFB xCB,W
04D9C:  MOVWF  xD1
04D9E:  MOVF   03,W
04DA0:  SUBWFB xCC,W
04DA2:  MOVWF  xD2
04DA4:  MOVF   xC1,W
04DA6:  ADDWF  xCF,F
04DA8:  MOVF   xC2,W
04DAA:  ADDWFC xD0,F
04DAC:  MOVF   xC3,W
04DAE:  ADDWFC xD1,F
04DB0:  MOVF   xC4,W
04DB2:  ADDWFC xD2,F
04DB4:  MOVLW  02
04DB6:  MOVLB  7
04DB8:  ADDWF  x0E,W
04DBA:  MOVWF  FE9
04DBC:  MOVLW  00
04DBE:  ADDWFC x0F,W
04DC0:  MOVWF  FEA
04DC2:  MOVFF  FEF,A35
04DC6:  MOVLB  9
04DC8:  MOVFF  FEA,9D5
04DCC:  MOVFF  FE9,9D4
04DD0:  BCF    FD8.1
04DD2:  CLRF   1B
04DD4:  BTFSC  FF2.7
04DD6:  BSF    1B.7
04DD8:  BCF    FF2.7
04DDA:  MOVFF  9D2,A34
04DDE:  MOVFF  9D1,A33
04DE2:  MOVFF  9D0,A32
04DE6:  MOVFF  9CF,A31
04DEA:  MOVLB  A
04DEC:  CLRF   x38
04DEE:  CLRF   x37
04DF0:  CLRF   x36
04DF2:  MOVLB  0
04DF4:  CALL   1050
04DF8:  BTFSC  1B.7
04DFA:  BSF    FF2.7
04DFC:  MOVFF  9D5,FEA
04E00:  MOVFF  9D4,FE9
04E04:  MOVFF  03,9D2
04E08:  MOVFF  02,9D1
04E0C:  MOVFF  01,9D0
04E10:  MOVFF  00,9CF
04E14:  MOVLW  02
04E16:  MOVLB  9
04E18:  ADDWF  00,W
04E1A:  MOVWF  00
04E1C:  MOVLW  00
04E1E:  ADDWFC 01,W
04E20:  MOVWF  01
04E22:  MOVLW  00
04E24:  ADDWFC 02,W
04E26:  MOVWF  02
04E28:  MOVLW  00
04E2A:  ADDWFC 03,W
04E2C:  MOVFF  9CE,FEA
04E30:  MOVFF  9CD,FE9
04E34:  MOVFF  00,FEF
04E38:  MOVFF  01,FEC
04E3C:  MOVFF  02,FEC
04E40:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04E42:  MOVLW  00
04E44:  MOVWF  01
04E46:  MOVLB  7
04E48:  MOVLB  0
04E4A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
0719E:  CALL   5600
071A2:  MOVFF  01,9AD
....................    if (result != FR_OK)  
071A6:  MOVLB  9
071A8:  MOVF   xAD,F
071AA:  BZ    71B2
....................       return (result); 
071AC:  MOVFF  9AD,01
071B0:  BRA    75E2
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
071B2:  MOVF   x9E,W
071B4:  ANDLW  0A
071B6:  BZ    71CE
071B8:  MOVLB  0
071BA:  CALL   55F2
071BE:  BTFSC  01.2
071C0:  BRA    71C6
071C2:  MOVLB  9
071C4:  BRA    71CE
....................          return (FR_WRITE_PROTECTED); 
071C6:  MOVLW  0A
071C8:  MOVWF  01
071CA:  MOVLB  9
071CC:  BRA    75E2
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
071CE:  MOVLW  09
071D0:  MOVWF  xC1
071D2:  MOVLW  9F
071D4:  MOVWF  xC0
071D6:  MOVLW  09
071D8:  MOVWF  xC3
071DA:  MOVLW  B0
071DC:  MOVWF  xC2
071DE:  MOVFF  99D,9C5
071E2:  MOVFF  99C,9C4
071E6:  MOVLW  09
071E8:  MOVWF  xC7
071EA:  MOVLW  AE
071EC:  MOVWF  xC6
071EE:  MOVLB  0
071F0:  CALL   6248
071F4:  MOVFF  01,9AD
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
071F8:  MOVLB  9
071FA:  MOVF   x9E,W
071FC:  ANDLW  18
071FE:  BTFSC  FD8.2
07200:  BRA    7424
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
07202:  MOVF   xAD,F
07204:  BZ    728C
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
07206:  BSF    x9E.3
....................          if (result != FR_NO_FILE) 
07208:  MOVF   xAD,W
0720A:  SUBLW  02
0720C:  BZ    7214
....................             return (result); 
0720E:  MOVFF  9AD,01
07212:  BRA    75E2
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
07214:  MOVLW  09
07216:  MOVWF  xC1
07218:  MOVLW  9F
0721A:  MOVWF  xC0
0721C:  MOVLB  0
0721E:  BRA    6C46
07220:  MOVFF  02,9AF
07224:  MOVFF  01,9AE
....................          if (dir_ptr == NULL) 
07228:  MOVLB  9
0722A:  MOVF   xAE,F
0722C:  BNZ   7238
0722E:  MOVF   xAF,F
07230:  BNZ   7238
....................             return (FR_DENIED); 
07232:  MOVLW  05
07234:  MOVWF  01
07236:  BRA    75E2
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
07238:  MOVFF  9AF,FEA
0723C:  MOVFF  9AE,FE9
07240:  MOVLW  09
07242:  MOVWF  FE2
07244:  MOVLW  B0
07246:  MOVWF  FE1
07248:  MOVLW  0B
0724A:  MOVWF  01
0724C:  MOVFF  FE6,FEE
07250:  DECFSZ 01,F
07252:  BRA    724C
....................          *(dir_ptr+12) = fn[11]; 
07254:  MOVLW  0C
07256:  ADDWF  xAE,W
07258:  MOVWF  01
0725A:  MOVLW  00
0725C:  ADDWFC xAF,W
0725E:  MOVFF  01,FE9
07262:  MOVWF  FEA
07264:  MOVFF  9BB,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
07268:  MOVLW  0D
0726A:  ADDWF  xAE,W
0726C:  MOVWF  xC0
0726E:  MOVLW  00
07270:  ADDWFC xAF,W
07272:  MOVWF  xC1
07274:  MOVWF  FEA
07276:  MOVFF  9C0,FE9
0727A:  CLRF   00
0727C:  CLRF   02
0727E:  MOVLW  13
07280:  MOVWF  01
07282:  MOVLB  0
07284:  CALL   3588
....................       }  
07288:  BRA    739E
0728A:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
0728C:  MOVF   xAE,F
0728E:  BNZ   7294
07290:  MOVF   xAF,F
07292:  BZ    72AC
07294:  MOVLW  0B
07296:  ADDWF  xAE,W
07298:  MOVWF  01
0729A:  MOVLW  00
0729C:  ADDWFC xAF,W
0729E:  MOVWF  03
072A0:  MOVFF  01,FE9
072A4:  MOVWF  FEA
072A6:  MOVF   FEF,W
072A8:  ANDLW  11
072AA:  BZ    72B2
....................             return (FR_DENIED); 
072AC:  MOVLW  05
072AE:  MOVWF  01
072B0:  BRA    75E2
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
072B2:  BTFSS  x9E.3
072B4:  BRA    739C
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
072B6:  MOVLW  20
072B8:  MOVLB  7
072BA:  ADDWF  x0E,W
072BC:  MOVWF  FE9
072BE:  MOVLW  00
072C0:  ADDWFC x0F,W
072C2:  MOVWF  FEA
072C4:  MOVFF  FEF,9BC
072C8:  MOVFF  FEC,9BD
072CC:  MOVFF  FEC,9BE
072D0:  MOVFF  FEC,9BF
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
072D4:  MOVLW  14
072D6:  MOVLB  9
072D8:  ADDWF  xAE,W
072DA:  MOVWF  01
072DC:  MOVLW  00
072DE:  ADDWFC xAF,W
072E0:  MOVWF  03
072E2:  MOVFF  01,FE9
072E6:  MOVWF  FEA
072E8:  MOVFF  FEC,9C8
072EC:  MOVF   FED,F
072EE:  MOVFF  FEF,9C0
072F2:  CLRF   xC2
072F4:  MOVFF  9C0,9C7
072F8:  CLRF   xC0
072FA:  CLRF   xC1
072FC:  MOVLW  1A
072FE:  ADDWF  xAE,W
07300:  MOVWF  01
07302:  MOVLW  00
07304:  ADDWFC xAF,W
07306:  MOVFF  01,FE9
0730A:  MOVWF  FEA
0730C:  MOVFF  FEC,03
07310:  MOVF   FED,F
07312:  MOVF   FEF,W
07314:  IORWF  xC0,F
07316:  MOVF   03,W
07318:  IORWF  xC1,F
0731A:  MOVFF  9C1,9C6
0731E:  MOVFF  9C0,9C5
07322:  MOVLB  0
07324:  RCALL  6F8E
07326:  MOVF   01,F
07328:  BZ    7342
0732A:  MOVFF  9BF,9FD
0732E:  MOVFF  9BE,9FC
07332:  MOVFF  9BD,9FB
07336:  MOVFF  9BC,9FA
0733A:  CALL   5AD6
0733E:  MOVF   01,F
07340:  BNZ   734C
....................                return (FR_RW_ERROR); 
07342:  MOVLW  07
07344:  MOVWF  01
07346:  MOVLB  9
07348:  BRA    75E2
0734A:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
0734C:  MOVLW  14
0734E:  MOVLB  9
07350:  ADDWF  xAE,W
07352:  MOVWF  01
07354:  MOVLW  00
07356:  ADDWFC xAF,W
07358:  MOVFF  01,FE9
0735C:  MOVWF  FEA
0735E:  CLRF   FEC
07360:  MOVF   FED,F
07362:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
07364:  MOVLW  1A
07366:  ADDWF  xAE,W
07368:  MOVWF  01
0736A:  MOVLW  00
0736C:  ADDWFC xAF,W
0736E:  MOVFF  01,FE9
07372:  MOVWF  FEA
07374:  CLRF   FEC
07376:  MOVF   FED,F
07378:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
0737A:  MOVLW  1C
0737C:  ADDWF  xAE,W
0737E:  MOVWF  01
07380:  MOVLW  00
07382:  ADDWFC xAF,W
07384:  MOVFF  01,FE9
07388:  MOVWF  FEA
0738A:  MOVF   FEE,F
0738C:  MOVF   FEE,F
0738E:  CLRF   FEC
07390:  MOVF   FED,F
07392:  CLRF   FEF
07394:  MOVF   FED,F
07396:  CLRF   FEF
07398:  MOVF   FED,F
0739A:  CLRF   FEF
0739C:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
0739E:  MOVLB  9
073A0:  BTFSS  x9E.3
073A2:  BRA    7422
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
073A4:  MOVLW  0B
073A6:  ADDWF  xAE,W
073A8:  MOVWF  01
073AA:  MOVLW  00
073AC:  ADDWFC xAF,W
073AE:  MOVFF  01,FE9
073B2:  MOVWF  FEA
073B4:  MOVLW  20
073B6:  MOVWF  FEF
....................          dw = get_fattime(); 
073B8:  MOVLB  0
073BA:  RCALL  702E
073BC:  MOVFF  03,9BF
073C0:  MOVFF  02,9BE
073C4:  MOVFF  01,9BD
073C8:  MOVFF  00,9BC
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
073CC:  MOVLW  0E
073CE:  MOVLB  9
073D0:  ADDWF  xAE,W
073D2:  MOVWF  01
073D4:  MOVLW  00
073D6:  ADDWFC xAF,W
073D8:  MOVFF  01,FE9
073DC:  MOVWF  FEA
073DE:  MOVFF  9BC,FEF
073E2:  MOVFF  9BD,FEC
073E6:  MOVFF  9BE,FEC
073EA:  MOVFF  9BF,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
073EE:  MOVLW  16
073F0:  ADDWF  xAE,W
073F2:  MOVWF  01
073F4:  MOVLW  00
073F6:  ADDWFC xAF,W
073F8:  MOVFF  01,FE9
073FC:  MOVWF  FEA
073FE:  MOVFF  9BC,FEF
07402:  MOVFF  9BD,FEC
07406:  MOVFF  9BE,FEC
0740A:  MOVFF  9BF,FEC
....................          fs->winflag = 1; 
0740E:  MOVLW  06
07410:  MOVLB  7
07412:  ADDWF  x0E,W
07414:  MOVWF  FE9
07416:  MOVLW  00
07418:  ADDWFC x0F,W
0741A:  MOVWF  FEA
0741C:  MOVLW  01
0741E:  MOVWF  FEF
07420:  MOVLB  9
....................       } 
....................    } 
07422:  BRA    7472
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
07424:  MOVF   xAD,F
07426:  BZ    742E
....................          return (result);      // Trace failed  
07428:  MOVFF  9AD,01
0742C:  BRA    75E2
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
0742E:  MOVF   xAE,F
07430:  BNZ   7436
07432:  MOVF   xAF,F
07434:  BZ    744C
07436:  MOVLW  0B
07438:  ADDWF  xAE,W
0743A:  MOVWF  01
0743C:  MOVLW  00
0743E:  ADDWFC xAF,W
07440:  MOVWF  03
07442:  MOVFF  01,FE9
07446:  MOVWF  FEA
07448:  BTFSS  FEF.4
0744A:  BRA    7452
....................          return (FR_NO_FILE); 
0744C:  MOVLW  02
0744E:  MOVWF  01
07450:  BRA    75E2
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
07452:  BTFSS  x9E.1
07454:  BRA    7472
07456:  MOVLW  0B
07458:  ADDWF  xAE,W
0745A:  MOVWF  01
0745C:  MOVLW  00
0745E:  ADDWFC xAF,W
07460:  MOVWF  03
07462:  MOVFF  01,FE9
07466:  MOVWF  FEA
07468:  BTFSS  FEF.0
0746A:  BRA    7472
....................          return (FR_DENIED); 
0746C:  MOVLW  05
0746E:  MOVWF  01
07470:  BRA    75E2
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
07472:  MOVLW  1A
07474:  ADDWF  x9A,W
07476:  MOVWF  FE9
07478:  MOVLW  00
0747A:  ADDWFC x9B,W
0747C:  MOVWF  FEA
0747E:  MOVF   x9E,W
07480:  ANDLW  03
07482:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
07484:  MOVLW  14
07486:  ADDWF  x9A,W
07488:  MOVWF  01
0748A:  MOVLW  00
0748C:  ADDWFC x9B,W
0748E:  MOVWF  03
07490:  MOVFF  01,9C0
07494:  MOVWF  xC1
07496:  MOVLW  20
07498:  MOVLB  7
0749A:  ADDWF  x0E,W
0749C:  MOVWF  FE9
0749E:  MOVLW  00
074A0:  ADDWFC x0F,W
074A2:  MOVWF  FEA
074A4:  MOVFF  FEF,00
074A8:  MOVFF  FEC,01
074AC:  MOVFF  FEC,02
074B0:  MOVFF  FEC,03
074B4:  MOVFF  9C1,FEA
074B8:  MOVFF  9C0,FE9
074BC:  MOVFF  00,FEF
074C0:  MOVFF  01,FEC
074C4:  MOVFF  02,FEC
074C8:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
074CC:  MOVLW  18
074CE:  MOVLB  9
074D0:  ADDWF  x9A,W
074D2:  MOVWF  FE9
074D4:  MOVLW  00
074D6:  ADDWFC x9B,W
074D8:  MOVWF  FEA
074DA:  MOVFF  9AF,FEC
074DE:  MOVF   FED,F
074E0:  MOVFF  9AE,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
074E4:  MOVLW  08
074E6:  ADDWF  x9A,W
074E8:  MOVWF  01
074EA:  MOVLW  00
074EC:  ADDWFC x9B,W
074EE:  MOVWF  03
074F0:  MOVFF  01,9C0
074F4:  MOVWF  xC1
074F6:  MOVLW  14
074F8:  ADDWF  xAE,W
074FA:  MOVWF  01
074FC:  MOVLW  00
074FE:  ADDWFC xAF,W
07500:  MOVWF  03
07502:  MOVFF  01,FE9
07506:  MOVWF  FEA
07508:  MOVFF  FEC,9C5
0750C:  MOVF   FED,F
0750E:  MOVFF  FEF,9C2
07512:  CLRF   xC4
07514:  MOVFF  9C2,9C4
07518:  CLRF   xC2
0751A:  CLRF   xC3
0751C:  MOVLW  1A
0751E:  ADDWF  xAE,W
07520:  MOVWF  01
07522:  MOVLW  00
07524:  ADDWFC xAF,W
07526:  MOVFF  01,FE9
0752A:  MOVWF  FEA
0752C:  MOVFF  FEC,03
07530:  MOVF   FED,F
07532:  MOVF   FEF,W
07534:  IORWF  xC2,W
07536:  MOVWF  00
07538:  MOVF   03,W
0753A:  IORWF  xC3,W
0753C:  MOVFF  9C4,02
07540:  MOVFF  9C5,03
07544:  MOVFF  9C1,FEA
07548:  MOVFF  9C0,FE9
0754C:  MOVFF  00,FEF
07550:  MOVWF  FEC
07552:  MOVFF  9C4,FEC
07556:  MOVFF  9C5,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
0755A:  MOVLW  04
0755C:  ADDWF  x9A,W
0755E:  MOVWF  01
07560:  MOVLW  00
07562:  ADDWFC x9B,W
07564:  MOVWF  03
07566:  MOVFF  01,9C0
0756A:  MOVWF  xC1
0756C:  MOVLW  1C
0756E:  ADDWF  xAE,W
07570:  MOVWF  01
07572:  MOVLW  00
07574:  ADDWFC xAF,W
07576:  MOVFF  01,FE9
0757A:  MOVWF  FEA
0757C:  MOVFF  FEF,00
07580:  MOVFF  FEC,01
07584:  MOVFF  FEC,02
07588:  MOVFF  FEC,03
0758C:  MOVFF  9C1,FEA
07590:  MOVFF  9C0,FE9
07594:  MOVFF  00,FEF
07598:  MOVFF  01,FEC
0759C:  MOVFF  02,FEC
075A0:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
075A4:  MOVFF  99A,FE9
075A8:  MOVFF  99B,FEA
075AC:  MOVF   FEE,F
075AE:  MOVF   FEE,F
075B0:  CLRF   FEC
075B2:  MOVF   FED,F
075B4:  CLRF   FEF
075B6:  MOVF   FED,F
075B8:  CLRF   FEF
075BA:  MOVF   FED,F
075BC:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
075BE:  MOVLW  1B
075C0:  ADDWF  x9A,W
075C2:  MOVWF  FE9
075C4:  MOVLW  00
075C6:  ADDWFC x9B,W
075C8:  MOVWF  FEA
075CA:  MOVLW  01
075CC:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
075CE:  MOVLB  7
075D0:  ADDWF  x0E,W
075D2:  MOVWF  FE9
075D4:  MOVLW  00
075D6:  ADDWFC x0F,W
075D8:  MOVWF  FEA
075DA:  INCF   FEF,F
....................    return (FR_OK); 
075DC:  MOVLW  00
075DE:  MOVWF  01
075E0:  MOVLB  9
075E2:  MOVLB  0
075E4:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B1DA:  MOVFF  8B9,8CE
0B1DE:  MOVFF  8B8,8CD
....................       *br = 0; 
0B1E2:  MOVLB  8
0B1E4:  MOVFF  8BC,FE9
0B1E8:  MOVFF  8BD,FEA
0B1EC:  CLRF   FEC
0B1EE:  MOVF   FED,F
0B1F0:  CLRF   FEF
....................       if (!fs)  
0B1F2:  MOVLB  7
0B1F4:  MOVF   x0E,W
0B1F6:  IORWF  x0F,W
0B1F8:  BNZ   B200
....................          return (FR_NOT_ENABLED); 
0B1FA:  MOVLW  0B
0B1FC:  MOVWF  01
0B1FE:  BRA    B6E2
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B200:  MOVLB  0
0B202:  CALL   55F2
0B206:  BTFSC  01.0
0B208:  BRA    B21A
0B20A:  MOVLB  7
0B20C:  MOVFF  70E,FE9
0B210:  MOVFF  70F,FEA
0B214:  MOVF   FEF,F
0B216:  BNZ   B222
0B218:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B21A:  MOVLW  01
0B21C:  MOVWF  01
0B21E:  MOVLB  7
0B220:  BRA    B6E2
....................     
....................       if (fp->flag & FA__ERROR) 
0B222:  MOVLW  1A
0B224:  MOVLB  8
0B226:  ADDWF  xB6,W
0B228:  MOVWF  FE9
0B22A:  MOVLW  00
0B22C:  ADDWFC xB7,W
0B22E:  MOVWF  FEA
0B230:  BTFSS  FEF.7
0B232:  BRA    B23E
....................          return (FR_RW_ERROR);   // Check error flag  
0B234:  MOVLW  07
0B236:  MOVWF  01
0B238:  MOVLB  7
0B23A:  BRA    B6E2
0B23C:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B23E:  MOVLW  1A
0B240:  ADDWF  xB6,W
0B242:  MOVWF  FE9
0B244:  MOVLW  00
0B246:  ADDWFC xB7,W
0B248:  MOVWF  FEA
0B24A:  BTFSC  FEF.0
0B24C:  BRA    B258
....................          return (FR_DENIED);      // Check access mode  
0B24E:  MOVLW  05
0B250:  MOVWF  01
0B252:  MOVLB  7
0B254:  BRA    B6E2
0B256:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B258:  MOVLW  04
0B25A:  ADDWF  xB6,W
0B25C:  MOVWF  FE9
0B25E:  MOVLW  00
0B260:  ADDWFC xB7,W
0B262:  MOVWF  FEA
0B264:  MOVFF  FEF,8CF
0B268:  MOVFF  FEC,8D0
0B26C:  MOVFF  FEC,8D1
0B270:  MOVFF  FEC,8D2
0B274:  MOVFF  8B6,FE9
0B278:  MOVFF  8B7,FEA
0B27C:  MOVFF  FEF,00
0B280:  MOVFF  FEC,01
0B284:  MOVFF  FEC,02
0B288:  MOVFF  FEC,03
0B28C:  MOVF   00,W
0B28E:  SUBWF  xCF,W
0B290:  MOVWF  xC6
0B292:  MOVF   01,W
0B294:  SUBWFB xD0,W
0B296:  MOVWF  xC7
0B298:  MOVF   02,W
0B29A:  SUBWFB xD1,W
0B29C:  MOVWF  xC8
0B29E:  MOVF   03,W
0B2A0:  SUBWFB xD2,W
0B2A2:  MOVWF  xC9
....................       if (btr > ln) 
0B2A4:  MOVF   xC9,F
0B2A6:  BNZ   B2C2
0B2A8:  MOVF   xC8,F
0B2AA:  BNZ   B2C2
0B2AC:  MOVF   xC7,W
0B2AE:  SUBWF  xBB,W
0B2B0:  BNC   B2C2
0B2B2:  BNZ   B2BA
0B2B4:  MOVF   xBA,W
0B2B6:  SUBWF  xC6,W
0B2B8:  BC    B2C2
....................          btr = ln;            // Truncate read count by number of bytes left  
0B2BA:  MOVFF  8C7,8BB
0B2BE:  MOVFF  8C6,8BA
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B2C2:  MOVF   xBA,W
0B2C4:  IORWF  xBB,W
0B2C6:  BTFSC  FD8.2
0B2C8:  BRA    B6C0
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B2CA:  MOVFF  8B6,FE9
0B2CE:  MOVFF  8B7,FEA
0B2D2:  MOVFF  FEF,8CF
0B2D6:  MOVFF  FEC,8D0
0B2DA:  MOVFF  FEC,8D1
0B2DE:  MOVFF  FEC,8D2
0B2E2:  MOVLW  01
0B2E4:  ANDWF  xD0,F
0B2E6:  CLRF   xD1
0B2E8:  CLRF   xD2
0B2EA:  MOVF   xCF,F
0B2EC:  BTFSS  FD8.2
0B2EE:  BRA    B568
0B2F0:  MOVF   xD0,F
0B2F2:  BTFSS  FD8.2
0B2F4:  BRA    B568
0B2F6:  MOVF   xD1,F
0B2F8:  BTFSS  FD8.2
0B2FA:  BRA    B568
0B2FC:  MOVF   xD2,F
0B2FE:  BTFSS  FD8.2
0B300:  BRA    B568
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B302:  MOVLW  1B
0B304:  ADDWF  xB6,W
0B306:  MOVWF  FE9
0B308:  MOVLW  00
0B30A:  ADDWFC xB7,W
0B30C:  MOVWF  FEA
0B30E:  DECF   FEF,F
0B310:  BZ    B348
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B312:  MOVLW  10
0B314:  ADDWF  xB6,W
0B316:  MOVWF  FE9
0B318:  MOVLW  00
0B31A:  ADDWFC xB7,W
0B31C:  MOVWF  FEA
0B31E:  MOVFF  FEF,8CF
0B322:  MOVFF  FEC,8D0
0B326:  MOVFF  FEC,8D1
0B32A:  MOVFF  FEC,8D2
0B32E:  MOVLW  01
0B330:  ADDWF  xCF,W
0B332:  MOVWF  xC2
0B334:  MOVLW  00
0B336:  ADDWFC xD0,W
0B338:  MOVWF  xC3
0B33A:  MOVLW  00
0B33C:  ADDWFC xD1,W
0B33E:  MOVWF  xC4
0B340:  MOVLW  00
0B342:  ADDWFC xD2,W
0B344:  MOVWF  xC5
....................                }  
0B346:  BRA    B484
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B348:  MOVFF  8B6,FE9
0B34C:  MOVFF  8B7,FEA
0B350:  MOVFF  FEF,8CF
0B354:  MOVFF  FEC,8D0
0B358:  MOVFF  FEC,8D1
0B35C:  MOVFF  FEC,8D2
0B360:  MOVF   xCF,F
0B362:  BNZ   B38E
0B364:  MOVF   xD0,F
0B366:  BNZ   B38E
0B368:  MOVF   xD1,F
0B36A:  BNZ   B38E
0B36C:  MOVF   xD2,F
0B36E:  BNZ   B38E
0B370:  MOVLW  08
0B372:  ADDWF  xB6,W
0B374:  MOVWF  FE9
0B376:  MOVLW  00
0B378:  ADDWFC xB7,W
0B37A:  MOVWF  FEA
0B37C:  MOVFF  FEF,00
0B380:  MOVFF  FEC,01
0B384:  MOVFF  FEC,02
0B388:  MOVFF  FEC,03
0B38C:  BRA    B3B2
0B38E:  MOVLW  0C
0B390:  ADDWF  xB6,W
0B392:  MOVWF  FE9
0B394:  MOVLW  00
0B396:  ADDWFC xB7,W
0B398:  MOVWF  FEA
0B39A:  MOVFF  FEF,9E6
0B39E:  MOVFF  FEC,9E7
0B3A2:  MOVFF  FEC,9E8
0B3A6:  MOVFF  FEC,9E9
0B3AA:  MOVLB  0
0B3AC:  CALL   5D36
0B3B0:  MOVLB  8
0B3B2:  MOVFF  03,8C1
0B3B6:  MOVFF  02,8C0
0B3BA:  MOVFF  01,8BF
0B3BE:  MOVFF  00,8BE
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B3C2:  MOVF   xC1,F
0B3C4:  BNZ   B3D4
0B3C6:  MOVF   xC0,F
0B3C8:  BNZ   B3D4
0B3CA:  MOVF   xBF,F
0B3CC:  BNZ   B3D4
0B3CE:  MOVF   xBE,W
0B3D0:  SUBLW  01
0B3D2:  BC    B412
0B3D4:  MOVLW  0C
0B3D6:  MOVLB  7
0B3D8:  ADDWF  x0E,W
0B3DA:  MOVWF  FE9
0B3DC:  MOVLW  00
0B3DE:  ADDWFC x0F,W
0B3E0:  MOVWF  FEA
0B3E2:  MOVFF  FEF,00
0B3E6:  MOVFF  FEC,01
0B3EA:  MOVFF  FEC,02
0B3EE:  MOVFF  FEC,03
0B3F2:  MOVF   03,W
0B3F4:  MOVLB  8
0B3F6:  SUBWF  xC1,W
0B3F8:  BNC   B414
0B3FA:  BNZ   B412
0B3FC:  MOVF   02,W
0B3FE:  SUBWF  xC0,W
0B400:  BNC   B414
0B402:  BNZ   B412
0B404:  MOVF   01,W
0B406:  SUBWF  xBF,W
0B408:  BNC   B414
0B40A:  BNZ   B412
0B40C:  MOVF   00,W
0B40E:  SUBWF  xBE,W
0B410:  BNC   B414
....................                   goto fr_error; 
0B412:  BRA    B6CA
....................                fp->curr_clust = clust;            // Current cluster  
0B414:  MOVLW  0C
0B416:  ADDWF  xB6,W
0B418:  MOVWF  FE9
0B41A:  MOVLW  00
0B41C:  ADDWFC xB7,W
0B41E:  MOVWF  FEA
0B420:  MOVFF  8BE,FEF
0B424:  MOVFF  8BF,FEC
0B428:  MOVFF  8C0,FEC
0B42C:  MOVFF  8C1,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B430:  MOVFF  8C1,9DC
0B434:  MOVFF  8C0,9DB
0B438:  MOVFF  8BF,9DA
0B43C:  MOVFF  8BE,9D9
0B440:  MOVLB  0
0B442:  CALL   5662
0B446:  MOVFF  03,8C5
0B44A:  MOVFF  02,8C4
0B44E:  MOVFF  01,8C3
0B452:  MOVFF  00,8C2
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B456:  MOVLW  1B
0B458:  MOVLB  8
0B45A:  ADDWF  xB6,W
0B45C:  MOVWF  01
0B45E:  MOVLW  00
0B460:  ADDWFC xB7,W
0B462:  MOVWF  03
0B464:  MOVLW  02
0B466:  MOVLB  7
0B468:  ADDWF  x0E,W
0B46A:  MOVWF  FE9
0B46C:  MOVLW  00
0B46E:  ADDWFC x0F,W
0B470:  MOVWF  FEA
0B472:  MOVFF  FEF,8D1
0B476:  MOVLB  8
0B478:  MOVFF  03,FEA
0B47C:  MOVFF  01,FE9
0B480:  MOVFF  8D1,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B484:  MOVLW  10
0B486:  ADDWF  xB6,W
0B488:  MOVWF  FE9
0B48A:  MOVLW  00
0B48C:  ADDWFC xB7,W
0B48E:  MOVWF  FEA
0B490:  MOVFF  8C2,FEF
0B494:  MOVFF  8C3,FEC
0B498:  MOVFF  8C4,FEC
0B49C:  MOVFF  8C5,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B4A0:  BCF    FD8.0
0B4A2:  RRCF   xBB,W
0B4A4:  MOVWF  xCC
....................             if (cc)  
0B4A6:  MOVF   xCC,F
0B4A8:  BZ    B568
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B4AA:  MOVLW  1B
0B4AC:  ADDWF  xB6,W
0B4AE:  MOVWF  FE9
0B4B0:  MOVLW  00
0B4B2:  ADDWFC xB7,W
0B4B4:  MOVWF  FEA
0B4B6:  MOVF   FEF,W
0B4B8:  SUBWF  xCC,W
0B4BA:  BZ    B4CE
0B4BC:  BNC   B4CE
....................                   cc = fp->sect_clust; 
0B4BE:  MOVLW  1B
0B4C0:  ADDWF  xB6,W
0B4C2:  MOVWF  FE9
0B4C4:  MOVLW  00
0B4C6:  ADDWFC xB7,W
0B4C8:  MOVWF  FEA
0B4CA:  MOVFF  FEF,8CC
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B4CE:  MOVFF  8CE,A07
0B4D2:  MOVFF  8CD,A06
0B4D6:  MOVFF  8C5,A0B
0B4DA:  MOVFF  8C4,A0A
0B4DE:  MOVFF  8C3,A09
0B4E2:  MOVFF  8C2,A08
0B4E6:  MOVFF  8CC,A0C
0B4EA:  MOVLB  0
0B4EC:  CALL   452E
0B4F0:  MOVF   01,F
0B4F2:  BZ    B4FA
....................                   goto fr_error; 
0B4F4:  MOVLB  8
0B4F6:  BRA    B6CA
0B4F8:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B4FA:  MOVLW  1B
0B4FC:  MOVLB  8
0B4FE:  ADDWF  xB6,W
0B500:  MOVWF  FE9
0B502:  MOVLW  00
0B504:  ADDWFC xB7,W
0B506:  MOVWF  FEA
0B508:  MOVLW  01
0B50A:  SUBWF  xCC,W
0B50C:  SUBWF  FEF,W
0B50E:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B510:  MOVLW  10
0B512:  ADDWF  xB6,W
0B514:  MOVWF  FE9
0B516:  MOVLW  00
0B518:  ADDWFC xB7,W
0B51A:  MOVWF  FEA
0B51C:  MOVLW  01
0B51E:  SUBWF  xCC,W
0B520:  ADDWF  FEF,W
0B522:  MOVWF  00
0B524:  MOVLW  00
0B526:  ADDWFC FEC,W
0B528:  MOVWF  01
0B52A:  MOVLW  00
0B52C:  ADDWFC FEC,W
0B52E:  MOVWF  02
0B530:  MOVLW  00
0B532:  ADDWFC FEC,W
0B534:  MOVF   FED,F
0B536:  MOVF   FED,F
0B538:  MOVF   FED,F
0B53A:  MOVFF  00,FEF
0B53E:  MOVFF  01,FEC
0B542:  MOVFF  02,FEC
0B546:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B548:  MOVLB  9
0B54A:  CLRF   xF7
0B54C:  MOVFF  8CC,9F6
0B550:  MOVLW  02
0B552:  MOVWF  xF9
0B554:  CLRF   xF8
0B556:  MOVLB  0
0B558:  CALL   5D14
0B55C:  MOVFF  02,8CB
0B560:  MOVFF  01,8CA
....................                continue; 
0B564:  BRA    B65C
0B566:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B568:  MOVLW  10
0B56A:  ADDWF  xB6,W
0B56C:  MOVWF  FE9
0B56E:  MOVLW  00
0B570:  ADDWFC xB7,W
0B572:  MOVWF  FEA
0B574:  MOVFF  FEF,9FA
0B578:  MOVFF  FEC,9FB
0B57C:  MOVFF  FEC,9FC
0B580:  MOVFF  FEC,9FD
0B584:  MOVLB  0
0B586:  CALL   5AD6
0B58A:  MOVF   01,F
0B58C:  BNZ   B594
....................                goto fr_error; 
0B58E:  MOVLB  8
0B590:  BRA    B6CA
0B592:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B594:  MOVLB  8
0B596:  MOVFF  8B6,FE9
0B59A:  MOVFF  8B7,FEA
0B59E:  MOVFF  FEF,8CF
0B5A2:  MOVFF  FEC,8D0
0B5A6:  MOVFF  FEC,8D1
0B5AA:  MOVFF  FEC,8D2
0B5AE:  MOVF   xD0,W
0B5B0:  ANDLW  01
0B5B2:  MOVWF  01
0B5B4:  MOVLW  00
0B5B6:  BSF    FD8.0
0B5B8:  SUBFWB xCF,W
0B5BA:  MOVWF  xCA
0B5BC:  MOVLW  02
0B5BE:  SUBFWB 01,W
0B5C0:  MOVWF  xCB
....................          if (rcnt > btr) 
0B5C2:  MOVF   xBB,W
0B5C4:  SUBWF  xCB,W
0B5C6:  BNC   B5D8
0B5C8:  BNZ   B5D0
0B5CA:  MOVF   xCA,W
0B5CC:  SUBWF  xBA,W
0B5CE:  BC    B5D8
....................             rcnt = btr; 
0B5D0:  MOVFF  8BB,8CB
0B5D4:  MOVFF  8BA,8CA
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B5D8:  MOVFF  8B6,FE9
0B5DC:  MOVFF  8B7,FEA
0B5E0:  MOVFF  FEF,8CF
0B5E4:  MOVFF  FEC,8D0
0B5E8:  MOVFF  FEC,8D1
0B5EC:  MOVFF  FEC,8D2
0B5F0:  MOVLW  01
0B5F2:  ANDWF  xD0,F
0B5F4:  CLRF   xD1
0B5F6:  CLRF   xD2
0B5F8:  MOVLW  24
0B5FA:  ADDWF  xCF,W
0B5FC:  MOVWF  00
0B5FE:  MOVLW  00
0B600:  ADDWFC xD0,W
0B602:  MOVWF  01
0B604:  MOVLW  00
0B606:  ADDWFC xD1,W
0B608:  MOVWF  02
0B60A:  MOVLW  00
0B60C:  ADDWFC xD2,W
0B60E:  MOVWF  03
0B610:  MOVFF  01,03
0B614:  MOVF   00,W
0B616:  MOVLB  7
0B618:  ADDWF  x0E,W
0B61A:  MOVWF  01
0B61C:  MOVF   x0F,W
0B61E:  ADDWFC 03,F
0B620:  MOVFF  01,8D3
0B624:  MOVLB  8
0B626:  MOVFF  03,8D4
0B62A:  MOVFF  8CE,FEA
0B62E:  MOVFF  8CD,FE9
0B632:  MOVFF  03,FE2
0B636:  MOVFF  01,FE1
0B63A:  MOVFF  8CB,02
0B63E:  MOVFF  8CA,01
0B642:  MOVF   01,F
0B644:  BZ    B64A
0B646:  INCF   02,F
0B648:  BRA    B64E
0B64A:  MOVF   02,F
0B64C:  BZ    B65A
0B64E:  MOVFF  FE6,FEE
0B652:  DECFSZ 01,F
0B654:  BRA    B64E
0B656:  DECFSZ 02,F
0B658:  BRA    B64E
0B65A:  MOVLB  0
0B65C:  MOVLB  8
0B65E:  MOVF   xCA,W
0B660:  ADDWF  xCD,F
0B662:  MOVF   xCB,W
0B664:  ADDWFC xCE,F
0B666:  MOVFF  8B6,FE9
0B66A:  MOVFF  8B7,FEA
0B66E:  MOVF   xCA,W
0B670:  ADDWF  FEF,W
0B672:  MOVWF  00
0B674:  MOVF   xCB,W
0B676:  ADDWFC FEC,W
0B678:  MOVWF  01
0B67A:  MOVLW  00
0B67C:  ADDWFC FEC,W
0B67E:  MOVWF  02
0B680:  MOVLW  00
0B682:  ADDWFC FEC,W
0B684:  MOVWF  03
0B686:  MOVF   FED,F
0B688:  MOVF   FED,F
0B68A:  MOVF   FED,F
0B68C:  MOVFF  00,FEF
0B690:  MOVFF  01,FEC
0B694:  MOVFF  02,FEC
0B698:  MOVWF  FEC
0B69A:  MOVFF  8BC,FE9
0B69E:  MOVFF  8BD,FEA
0B6A2:  MOVF   xCA,W
0B6A4:  ADDWF  FEF,W
0B6A6:  MOVWF  01
0B6A8:  MOVF   xCB,W
0B6AA:  ADDWFC FEC,W
0B6AC:  MOVWF  03
0B6AE:  MOVF   FED,F
0B6B0:  MOVFF  01,FEF
0B6B4:  MOVWF  FEC
0B6B6:  MOVF   xCA,W
0B6B8:  SUBWF  xBA,F
0B6BA:  MOVF   xCB,W
0B6BC:  SUBWFB xBB,F
0B6BE:  BRA    B2C2
....................          } 
....................       return (FR_OK); 
0B6C0:  MOVLW  00
0B6C2:  MOVWF  01
0B6C4:  MOVLB  7
0B6C6:  BRA    B6E2
0B6C8:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B6CA:  MOVLW  1A
0B6CC:  ADDWF  xB6,W
0B6CE:  MOVWF  FE9
0B6D0:  MOVLW  00
0B6D2:  ADDWFC xB7,W
0B6D4:  MOVWF  FEA
0B6D6:  MOVF   FEF,W
0B6D8:  IORLW  80
0B6DA:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B6DC:  MOVLW  07
0B6DE:  MOVWF  01
0B6E0:  MOVLB  7
0B6E2:  MOVLB  0
0B6E4:  GOTO   B8E0 (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
07A40:  MOVFF  99D,9AE
07A44:  MOVFF  99C,9AD
....................       *bw = 0; 
07A48:  MOVLB  9
07A4A:  MOVFF  9A0,FE9
07A4E:  MOVFF  9A1,FEA
07A52:  CLRF   FEC
07A54:  MOVF   FED,F
07A56:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07A58:  CLRF   xAB
07A5A:  CLRF   xAA
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07A5C:  MOVLB  7
07A5E:  MOVF   x0E,W
07A60:  IORWF  x0F,W
07A62:  BNZ   7A6A
....................          return (FR_NOT_ENABLED); 
07A64:  MOVLW  0B
07A66:  MOVWF  01
07A68:  BRA    8106
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07A6A:  MOVLB  0
07A6C:  CALL   55F2
07A70:  BTFSC  01.0
07A72:  BRA    7A84
07A74:  MOVLB  7
07A76:  MOVFF  70E,FE9
07A7A:  MOVFF  70F,FEA
07A7E:  MOVF   FEF,F
07A80:  BNZ   7A8C
07A82:  MOVLB  0
....................          return (FR_NOT_READY); 
07A84:  MOVLW  01
07A86:  MOVWF  01
07A88:  MOVLB  7
07A8A:  BRA    8106
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
07A8C:  MOVLW  1A
07A8E:  MOVLB  9
07A90:  ADDWF  x9A,W
07A92:  MOVWF  FE9
07A94:  MOVLW  00
07A96:  ADDWFC x9B,W
07A98:  MOVWF  FEA
07A9A:  BTFSS  FEF.7
07A9C:  BRA    7AA8
....................          return (FR_RW_ERROR);         // Check error flag  
07A9E:  MOVLW  07
07AA0:  MOVWF  01
07AA2:  MOVLB  7
07AA4:  BRA    8106
07AA6:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
07AA8:  MOVLW  1A
07AAA:  ADDWF  x9A,W
07AAC:  MOVWF  FE9
07AAE:  MOVLW  00
07AB0:  ADDWFC x9B,W
07AB2:  MOVWF  FEA
07AB4:  BTFSC  FEF.1
07AB6:  BRA    7AC2
....................          return (FR_DENIED);            // Check access mode  
07AB8:  MOVLW  05
07ABA:  MOVWF  01
07ABC:  MOVLB  7
07ABE:  BRA    8106
07AC0:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
07AC2:  MOVLW  04
07AC4:  ADDWF  x9A,W
07AC6:  MOVWF  FE9
07AC8:  MOVLW  00
07ACA:  ADDWFC x9B,W
07ACC:  MOVWF  FEA
07ACE:  MOVFF  FEF,9AF
07AD2:  MOVFF  FEC,9B0
07AD6:  MOVFF  FEC,9B1
07ADA:  MOVFF  FEC,9B2
07ADE:  MOVF   x9E,W
07AE0:  ADDWF  xAF,F
07AE2:  MOVF   x9F,W
07AE4:  ADDWFC xB0,F
07AE6:  MOVLW  00
07AE8:  ADDWFC xB1,F
07AEA:  ADDWFC xB2,F
07AEC:  MOVLW  04
07AEE:  ADDWF  x9A,W
07AF0:  MOVWF  FE9
07AF2:  MOVLW  00
07AF4:  ADDWFC x9B,W
07AF6:  MOVWF  FEA
07AF8:  MOVFF  FEF,00
07AFC:  MOVFF  FEC,01
07B00:  MOVFF  FEC,02
07B04:  MOVFF  FEC,03
07B08:  MOVF   xB2,W
07B0A:  SUBWF  03,W
07B0C:  BNC   7B2A
07B0E:  BNZ   7B26
07B10:  MOVF   xB1,W
07B12:  SUBWF  02,W
07B14:  BNC   7B2A
07B16:  BNZ   7B26
07B18:  MOVF   xB0,W
07B1A:  SUBWF  01,W
07B1C:  BNC   7B2A
07B1E:  BNZ   7B26
07B20:  MOVF   00,W
07B22:  SUBWF  xAF,W
07B24:  BC    7B2A
....................          btw = 0;                  // File size cannot reach 4GB  
07B26:  CLRF   x9F
07B28:  CLRF   x9E
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07B2A:  MOVF   x9E,W
07B2C:  IORWF  x9F,W
07B2E:  BTFSC  FD8.2
07B30:  BRA    803A
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07B32:  MOVFF  99A,FE9
07B36:  MOVFF  99B,FEA
07B3A:  MOVFF  FEF,9AF
07B3E:  MOVFF  FEC,9B0
07B42:  MOVFF  FEC,9B1
07B46:  MOVFF  FEC,9B2
07B4A:  MOVLW  01
07B4C:  ANDWF  xB0,F
07B4E:  CLRF   xB1
07B50:  CLRF   xB2
07B52:  MOVF   xAF,F
07B54:  BTFSS  FD8.2
07B56:  BRA    7ED4
07B58:  MOVF   xB0,F
07B5A:  BTFSS  FD8.2
07B5C:  BRA    7ED4
07B5E:  MOVF   xB1,F
07B60:  BTFSS  FD8.2
07B62:  BRA    7ED4
07B64:  MOVF   xB2,F
07B66:  BTFSS  FD8.2
07B68:  BRA    7ED4
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07B6A:  MOVLW  1B
07B6C:  ADDWF  x9A,W
07B6E:  MOVWF  FE9
07B70:  MOVLW  00
07B72:  ADDWFC x9B,W
07B74:  MOVWF  FEA
07B76:  DECF   FEF,F
07B78:  BZ    7BB0
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07B7A:  MOVLW  10
07B7C:  ADDWF  x9A,W
07B7E:  MOVWF  FE9
07B80:  MOVLW  00
07B82:  ADDWFC x9B,W
07B84:  MOVWF  FEA
07B86:  MOVFF  FEF,9AF
07B8A:  MOVFF  FEC,9B0
07B8E:  MOVFF  FEC,9B1
07B92:  MOVFF  FEC,9B2
07B96:  MOVLW  01
07B98:  ADDWF  xAF,W
07B9A:  MOVWF  xA6
07B9C:  MOVLW  00
07B9E:  ADDWFC xB0,W
07BA0:  MOVWF  xA7
07BA2:  MOVLW  00
07BA4:  ADDWFC xB1,W
07BA6:  MOVWF  xA8
07BA8:  MOVLW  00
07BAA:  ADDWFC xB2,W
07BAC:  MOVWF  xA9
....................                }  
07BAE:  BRA    7D46
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07BB0:  MOVFF  99A,FE9
07BB4:  MOVFF  99B,FEA
07BB8:  MOVFF  FEF,9AF
07BBC:  MOVFF  FEC,9B0
07BC0:  MOVFF  FEC,9B1
07BC4:  MOVFF  FEC,9B2
07BC8:  MOVF   xAF,F
07BCA:  BNZ   7C50
07BCC:  MOVF   xB0,F
07BCE:  BNZ   7C50
07BD0:  MOVF   xB1,F
07BD2:  BNZ   7C50
07BD4:  MOVF   xB2,F
07BD6:  BNZ   7C50
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07BD8:  MOVLW  08
07BDA:  ADDWF  x9A,W
07BDC:  MOVWF  FE9
07BDE:  MOVLW  00
07BE0:  ADDWFC x9B,W
07BE2:  MOVWF  FEA
07BE4:  MOVFF  FEF,9A2
07BE8:  MOVFF  FEC,9A3
07BEC:  MOVFF  FEC,9A4
07BF0:  MOVFF  FEC,9A5
....................                   if (clust == 0)            // No cluster is created  
07BF4:  MOVF   xA2,F
07BF6:  BNZ   7C4E
07BF8:  MOVF   xA3,F
07BFA:  BNZ   7C4E
07BFC:  MOVF   xA4,F
07BFE:  BNZ   7C4E
07C00:  MOVF   xA5,F
07C02:  BNZ   7C4E
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07C04:  MOVLW  08
07C06:  ADDWF  x9A,W
07C08:  MOVWF  01
07C0A:  MOVLW  00
07C0C:  ADDWFC x9B,W
07C0E:  MOVWF  03
07C10:  MOVFF  01,9AF
07C14:  MOVWF  xB0
07C16:  CLRF   xD5
07C18:  CLRF   xD4
07C1A:  CLRF   xD3
07C1C:  CLRF   xD2
07C1E:  MOVLB  0
07C20:  CALL   69B0
07C24:  MOVFF  03,9A5
07C28:  MOVFF  02,9A4
07C2C:  MOVFF  01,9A3
07C30:  MOVFF  00,9A2
07C34:  MOVFF  9B0,FEA
07C38:  MOVFF  9AF,FE9
07C3C:  MOVFF  9A2,FEF
07C40:  MOVFF  9A3,FEC
07C44:  MOVFF  9A4,FEC
07C48:  MOVFF  9A5,FEC
07C4C:  MOVLB  9
....................                   } 
07C4E:  BRA    7C84
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07C50:  MOVLW  0C
07C52:  ADDWF  x9A,W
07C54:  MOVWF  FE9
07C56:  MOVLW  00
07C58:  ADDWFC x9B,W
07C5A:  MOVWF  FEA
07C5C:  MOVFF  FEF,9D2
07C60:  MOVFF  FEC,9D3
07C64:  MOVFF  FEC,9D4
07C68:  MOVFF  FEC,9D5
07C6C:  MOVLB  0
07C6E:  CALL   69B0
07C72:  MOVFF  03,9A5
07C76:  MOVFF  02,9A4
07C7A:  MOVFF  01,9A3
07C7E:  MOVFF  00,9A2
07C82:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07C84:  MOVF   xA5,F
07C86:  BNZ   7C96
07C88:  MOVF   xA4,F
07C8A:  BNZ   7C96
07C8C:  MOVF   xA3,F
07C8E:  BNZ   7C96
07C90:  MOVF   xA2,W
07C92:  SUBLW  01
07C94:  BC    7CD4
07C96:  MOVLW  0C
07C98:  MOVLB  7
07C9A:  ADDWF  x0E,W
07C9C:  MOVWF  FE9
07C9E:  MOVLW  00
07CA0:  ADDWFC x0F,W
07CA2:  MOVWF  FEA
07CA4:  MOVFF  FEF,00
07CA8:  MOVFF  FEC,01
07CAC:  MOVFF  FEC,02
07CB0:  MOVFF  FEC,03
07CB4:  MOVF   03,W
07CB6:  MOVLB  9
07CB8:  SUBWF  xA5,W
07CBA:  BNC   7CD6
07CBC:  BNZ   7CD4
07CBE:  MOVF   02,W
07CC0:  SUBWF  xA4,W
07CC2:  BNC   7CD6
07CC4:  BNZ   7CD4
07CC6:  MOVF   01,W
07CC8:  SUBWF  xA3,W
07CCA:  BNC   7CD6
07CCC:  BNZ   7CD4
07CCE:  MOVF   00,W
07CD0:  SUBWF  xA2,W
07CD2:  BNC   7CD6
....................                   break; 
07CD4:  BRA    803A
....................                fp->curr_clust = clust;            // Current cluster  
07CD6:  MOVLW  0C
07CD8:  ADDWF  x9A,W
07CDA:  MOVWF  FE9
07CDC:  MOVLW  00
07CDE:  ADDWFC x9B,W
07CE0:  MOVWF  FEA
07CE2:  MOVFF  9A2,FEF
07CE6:  MOVFF  9A3,FEC
07CEA:  MOVFF  9A4,FEC
07CEE:  MOVFF  9A5,FEC
....................                sect = clust2sect(clust);         // Current sector  
07CF2:  MOVFF  9A5,9DC
07CF6:  MOVFF  9A4,9DB
07CFA:  MOVFF  9A3,9DA
07CFE:  MOVFF  9A2,9D9
07D02:  MOVLB  0
07D04:  CALL   5662
07D08:  MOVFF  03,9A9
07D0C:  MOVFF  02,9A8
07D10:  MOVFF  01,9A7
07D14:  MOVFF  00,9A6
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07D18:  MOVLW  1B
07D1A:  MOVLB  9
07D1C:  ADDWF  x9A,W
07D1E:  MOVWF  01
07D20:  MOVLW  00
07D22:  ADDWFC x9B,W
07D24:  MOVWF  03
07D26:  MOVLW  02
07D28:  MOVLB  7
07D2A:  ADDWF  x0E,W
07D2C:  MOVWF  FE9
07D2E:  MOVLW  00
07D30:  ADDWFC x0F,W
07D32:  MOVWF  FEA
07D34:  MOVFF  FEF,9B1
07D38:  MOVLB  9
07D3A:  MOVFF  03,FEA
07D3E:  MOVFF  01,FE9
07D42:  MOVFF  9B1,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07D46:  MOVLW  10
07D48:  ADDWF  x9A,W
07D4A:  MOVWF  FE9
07D4C:  MOVLW  00
07D4E:  ADDWFC x9B,W
07D50:  MOVWF  FEA
07D52:  MOVFF  9A6,FEF
07D56:  MOVFF  9A7,FEC
07D5A:  MOVFF  9A8,FEC
07D5E:  MOVFF  9A9,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07D62:  BCF    FD8.0
07D64:  RRCF   x9F,W
07D66:  MOVWF  xAC
....................             if (cc)  
07D68:  MOVF   xAC,F
07D6A:  BZ    7E24
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07D6C:  MOVLW  1B
07D6E:  ADDWF  x9A,W
07D70:  MOVWF  FE9
07D72:  MOVLW  00
07D74:  ADDWFC x9B,W
07D76:  MOVWF  FEA
07D78:  MOVF   FEF,W
07D7A:  SUBWF  xAC,W
07D7C:  BZ    7D90
07D7E:  BNC   7D90
....................                   cc = fp->sect_clust; 
07D80:  MOVLW  1B
07D82:  ADDWF  x9A,W
07D84:  MOVWF  FE9
07D86:  MOVLW  00
07D88:  ADDWFC x9B,W
07D8A:  MOVWF  FEA
07D8C:  MOVFF  FEF,9AC
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07D90:  MOVFF  9AE,A07
07D94:  MOVFF  9AD,A06
07D98:  MOVFF  9A9,A0B
07D9C:  MOVFF  9A8,A0A
07DA0:  MOVFF  9A7,A09
07DA4:  MOVFF  9A6,A08
07DA8:  MOVFF  9AC,A0C
07DAC:  MOVLB  0
07DAE:  CALL   5992
07DB2:  MOVF   01,F
07DB4:  BZ    7DB8
....................                   goto fw_error; 
07DB6:  BRA    80EC
....................                fp->sect_clust -= cc - 1; 
07DB8:  MOVLW  1B
07DBA:  MOVLB  9
07DBC:  ADDWF  x9A,W
07DBE:  MOVWF  FE9
07DC0:  MOVLW  00
07DC2:  ADDWFC x9B,W
07DC4:  MOVWF  FEA
07DC6:  MOVLW  01
07DC8:  SUBWF  xAC,W
07DCA:  SUBWF  FEF,W
07DCC:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07DCE:  MOVLW  10
07DD0:  ADDWF  x9A,W
07DD2:  MOVWF  FE9
07DD4:  MOVLW  00
07DD6:  ADDWFC x9B,W
07DD8:  MOVWF  FEA
07DDA:  MOVLW  01
07DDC:  SUBWF  xAC,W
07DDE:  ADDWF  FEF,W
07DE0:  MOVWF  00
07DE2:  MOVLW  00
07DE4:  ADDWFC FEC,W
07DE6:  MOVWF  01
07DE8:  MOVLW  00
07DEA:  ADDWFC FEC,W
07DEC:  MOVWF  02
07DEE:  MOVLW  00
07DF0:  ADDWFC FEC,W
07DF2:  MOVF   FED,F
07DF4:  MOVF   FED,F
07DF6:  MOVF   FED,F
07DF8:  MOVFF  00,FEF
07DFC:  MOVFF  01,FEC
07E00:  MOVFF  02,FEC
07E04:  MOVWF  FEC
....................                wcnt = cc * 512; 
07E06:  CLRF   xF7
07E08:  MOVFF  9AC,9F6
07E0C:  MOVLW  02
07E0E:  MOVWF  xF9
07E10:  CLRF   xF8
07E12:  MOVLB  0
07E14:  CALL   5D14
07E18:  MOVFF  02,9AB
07E1C:  MOVFF  01,9AA
....................                continue; 
07E20:  BRA    7FD6
07E22:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07E24:  MOVFF  99A,FE9
07E28:  MOVFF  99B,FEA
07E2C:  MOVFF  FEF,9AF
07E30:  MOVFF  FEC,9B0
07E34:  MOVFF  FEC,9B1
07E38:  MOVFF  FEC,9B2
07E3C:  MOVLW  04
07E3E:  ADDWF  x9A,W
07E40:  MOVWF  FE9
07E42:  MOVLW  00
07E44:  ADDWFC x9B,W
07E46:  MOVWF  FEA
07E48:  MOVFF  FEF,00
07E4C:  MOVFF  FEC,01
07E50:  MOVFF  FEC,02
07E54:  MOVFF  FEC,03
07E58:  MOVF   03,W
07E5A:  SUBWF  xB2,W
07E5C:  BNC   7ED4
07E5E:  BNZ   7E76
07E60:  MOVF   02,W
07E62:  SUBWF  xB1,W
07E64:  BNC   7ED4
07E66:  BNZ   7E76
07E68:  MOVF   01,W
07E6A:  SUBWF  xB0,W
07E6C:  BNC   7ED4
07E6E:  BNZ   7E76
07E70:  MOVF   00,W
07E72:  SUBWF  xAF,W
07E74:  BNC   7ED4
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07E76:  CLRF   xFD
07E78:  CLRF   xFC
07E7A:  CLRF   xFB
07E7C:  CLRF   xFA
07E7E:  MOVLB  0
07E80:  CALL   5AD6
07E84:  MOVF   01,F
07E86:  BNZ   7E8A
....................                   goto fw_error; 
07E88:  BRA    80EC
....................                fs->winsect = fp->curr_sect; 
07E8A:  MOVLW  20
07E8C:  MOVLB  7
07E8E:  ADDWF  x0E,W
07E90:  MOVWF  01
07E92:  MOVLW  00
07E94:  ADDWFC x0F,W
07E96:  MOVWF  03
07E98:  MOVFF  01,9AF
07E9C:  MOVLB  9
07E9E:  MOVWF  xB0
07EA0:  MOVLW  10
07EA2:  ADDWF  x9A,W
07EA4:  MOVWF  FE9
07EA6:  MOVLW  00
07EA8:  ADDWFC x9B,W
07EAA:  MOVWF  FEA
07EAC:  MOVFF  FEF,00
07EB0:  MOVFF  FEC,01
07EB4:  MOVFF  FEC,02
07EB8:  MOVFF  FEC,03
07EBC:  MOVFF  9B0,FEA
07EC0:  MOVFF  9AF,FE9
07EC4:  MOVFF  00,FEF
07EC8:  MOVFF  01,FEC
07ECC:  MOVFF  02,FEC
07ED0:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07ED4:  MOVLW  10
07ED6:  ADDWF  x9A,W
07ED8:  MOVWF  FE9
07EDA:  MOVLW  00
07EDC:  ADDWFC x9B,W
07EDE:  MOVWF  FEA
07EE0:  MOVFF  FEF,9FA
07EE4:  MOVFF  FEC,9FB
07EE8:  MOVFF  FEC,9FC
07EEC:  MOVFF  FEC,9FD
07EF0:  MOVLB  0
07EF2:  CALL   5AD6
07EF6:  MOVF   01,F
07EF8:  BNZ   7EFC
....................             goto fw_error;               // Move sector window 
07EFA:  BRA    80EC
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07EFC:  MOVLB  9
07EFE:  MOVFF  99A,FE9
07F02:  MOVFF  99B,FEA
07F06:  MOVFF  FEF,9AF
07F0A:  MOVFF  FEC,9B0
07F0E:  MOVFF  FEC,9B1
07F12:  MOVFF  FEC,9B2
07F16:  MOVF   xB0,W
07F18:  ANDLW  01
07F1A:  MOVWF  01
07F1C:  MOVLW  00
07F1E:  BSF    FD8.0
07F20:  SUBFWB xAF,W
07F22:  MOVWF  xAA
07F24:  MOVLW  02
07F26:  SUBFWB 01,W
07F28:  MOVWF  xAB
....................          if (wcnt > btw) 
07F2A:  MOVF   x9F,W
07F2C:  SUBWF  xAB,W
07F2E:  BNC   7F40
07F30:  BNZ   7F38
07F32:  MOVF   xAA,W
07F34:  SUBWF  x9E,W
07F36:  BC    7F40
....................             wcnt = btw; 
07F38:  MOVFF  99F,9AB
07F3C:  MOVFF  99E,9AA
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07F40:  MOVFF  99A,FE9
07F44:  MOVFF  99B,FEA
07F48:  MOVFF  FEF,9AF
07F4C:  MOVFF  FEC,9B0
07F50:  MOVFF  FEC,9B1
07F54:  MOVFF  FEC,9B2
07F58:  MOVLW  01
07F5A:  ANDWF  xB0,F
07F5C:  CLRF   xB1
07F5E:  CLRF   xB2
07F60:  MOVLW  24
07F62:  ADDWF  xAF,W
07F64:  MOVWF  00
07F66:  MOVLW  00
07F68:  ADDWFC xB0,W
07F6A:  MOVWF  01
07F6C:  MOVLW  00
07F6E:  ADDWFC xB1,W
07F70:  MOVWF  02
07F72:  MOVLW  00
07F74:  ADDWFC xB2,W
07F76:  MOVWF  03
07F78:  MOVFF  01,03
07F7C:  MOVF   00,W
07F7E:  MOVLB  7
07F80:  ADDWF  x0E,W
07F82:  MOVWF  01
07F84:  MOVF   x0F,W
07F86:  ADDWFC 03,F
07F88:  MOVFF  01,9B3
07F8C:  MOVLB  9
07F8E:  MOVFF  03,9B4
07F92:  MOVFF  03,FEA
07F96:  MOVFF  01,FE9
07F9A:  MOVFF  9AE,FE2
07F9E:  MOVFF  9AD,FE1
07FA2:  MOVFF  9AB,02
07FA6:  MOVFF  9AA,01
07FAA:  MOVF   01,F
07FAC:  BZ    7FB2
07FAE:  INCF   02,F
07FB0:  BRA    7FB6
07FB2:  MOVF   02,F
07FB4:  BZ    7FC2
07FB6:  MOVFF  FE6,FEE
07FBA:  DECFSZ 01,F
07FBC:  BRA    7FB6
07FBE:  DECFSZ 02,F
07FC0:  BRA    7FB6
....................          fs->winflag = 1; 
07FC2:  MOVLW  06
07FC4:  MOVLB  7
07FC6:  ADDWF  x0E,W
07FC8:  MOVWF  FE9
07FCA:  MOVLW  00
07FCC:  ADDWFC x0F,W
07FCE:  MOVWF  FEA
07FD0:  MOVLW  01
07FD2:  MOVWF  FEF
07FD4:  MOVLB  0
07FD6:  MOVLB  9
07FD8:  MOVF   xAA,W
07FDA:  ADDWF  xAD,F
07FDC:  MOVF   xAB,W
07FDE:  ADDWFC xAE,F
07FE0:  MOVFF  99A,FE9
07FE4:  MOVFF  99B,FEA
07FE8:  MOVF   xAA,W
07FEA:  ADDWF  FEF,W
07FEC:  MOVWF  00
07FEE:  MOVF   xAB,W
07FF0:  ADDWFC FEC,W
07FF2:  MOVWF  01
07FF4:  MOVLW  00
07FF6:  ADDWFC FEC,W
07FF8:  MOVWF  02
07FFA:  MOVLW  00
07FFC:  ADDWFC FEC,W
07FFE:  MOVWF  03
08000:  MOVF   FED,F
08002:  MOVF   FED,F
08004:  MOVF   FED,F
08006:  MOVFF  00,FEF
0800A:  MOVFF  01,FEC
0800E:  MOVFF  02,FEC
08012:  MOVWF  FEC
08014:  MOVFF  9A0,FE9
08018:  MOVFF  9A1,FEA
0801C:  MOVF   xAA,W
0801E:  ADDWF  FEF,W
08020:  MOVWF  01
08022:  MOVF   xAB,W
08024:  ADDWFC FEC,W
08026:  MOVWF  03
08028:  MOVF   FED,F
0802A:  MOVFF  01,FEF
0802E:  MOVWF  FEC
08030:  MOVF   xAA,W
08032:  SUBWF  x9E,F
08034:  MOVF   xAB,W
08036:  SUBWFB x9F,F
08038:  BRA    7B2A
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
0803A:  MOVFF  99A,FE9
0803E:  MOVFF  99B,FEA
08042:  MOVFF  FEF,9AF
08046:  MOVFF  FEC,9B0
0804A:  MOVFF  FEC,9B1
0804E:  MOVFF  FEC,9B2
08052:  MOVLW  04
08054:  ADDWF  x9A,W
08056:  MOVWF  FE9
08058:  MOVLW  00
0805A:  ADDWFC x9B,W
0805C:  MOVWF  FEA
0805E:  MOVFF  FEF,00
08062:  MOVFF  FEC,01
08066:  MOVFF  FEC,02
0806A:  MOVFF  FEC,03
0806E:  MOVF   03,W
08070:  SUBWF  xB2,W
08072:  BNC   80D0
08074:  BNZ   808C
08076:  MOVF   02,W
08078:  SUBWF  xB1,W
0807A:  BNC   80D0
0807C:  BNZ   808C
0807E:  MOVF   01,W
08080:  SUBWF  xB0,W
08082:  BNC   80D0
08084:  BNZ   808C
08086:  MOVF   xAF,W
08088:  SUBWF  00,W
0808A:  BC    80D0
....................          fp->fsize = fp->fptr;      // Update file size if needed  
0808C:  MOVLW  04
0808E:  ADDWF  x9A,W
08090:  MOVWF  01
08092:  MOVLW  00
08094:  ADDWFC x9B,W
08096:  MOVWF  03
08098:  MOVFF  01,9AF
0809C:  MOVFF  03,9B0
080A0:  MOVFF  99A,FE9
080A4:  MOVFF  99B,FEA
080A8:  MOVFF  FEF,00
080AC:  MOVFF  FEC,01
080B0:  MOVFF  FEC,02
080B4:  MOVFF  FEC,03
080B8:  MOVFF  9B0,FEA
080BC:  MOVFF  9AF,FE9
080C0:  MOVFF  00,FEF
080C4:  MOVFF  01,FEC
080C8:  MOVFF  02,FEC
080CC:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
080D0:  MOVLW  1A
080D2:  ADDWF  x9A,W
080D4:  MOVWF  FE9
080D6:  MOVLW  00
080D8:  ADDWFC x9B,W
080DA:  MOVWF  FEA
080DC:  MOVF   FEF,W
080DE:  IORLW  20
080E0:  MOVWF  FEF
....................       return (FR_OK); 
080E2:  MOVLW  00
080E4:  MOVWF  01
080E6:  MOVLB  7
080E8:  BRA    8106
080EA:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
080EC:  MOVLW  1A
080EE:  MOVLB  9
080F0:  ADDWF  x9A,W
080F2:  MOVWF  FE9
080F4:  MOVLW  00
080F6:  ADDWFC x9B,W
080F8:  MOVWF  FEA
080FA:  MOVF   FEF,W
080FC:  IORLW  80
080FE:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
08100:  MOVLW  07
08102:  MOVWF  01
08104:  MOVLB  7
08106:  MOVLB  0
08108:  GOTO   84AC (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
075E6:  MOVLB  7
075E8:  MOVF   x0E,W
075EA:  IORWF  x0F,W
075EC:  BNZ   75F4
....................          return (FR_NOT_ENABLED); 
075EE:  MOVLW  0B
075F0:  MOVWF  01
075F2:  BRA    7948
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
075F4:  MOVLB  0
075F6:  CALL   55F2
075FA:  BTFSC  01.0
075FC:  BRA    760E
075FE:  MOVLB  7
07600:  MOVFF  70E,FE9
07604:  MOVFF  70F,FEA
07608:  MOVF   FEF,F
0760A:  BNZ   7616
0760C:  MOVLB  0
....................          return (FR_NOT_READY); 
0760E:  MOVLW  01
07610:  MOVWF  01
07612:  MOVLB  7
07614:  BRA    7948
....................     
....................       if (fp->flag & FA__ERROR) 
07616:  MOVLW  1A
07618:  MOVLB  9
0761A:  ADDWF  x9A,W
0761C:  MOVWF  FE9
0761E:  MOVLW  00
07620:  ADDWFC x9B,W
07622:  MOVWF  FEA
07624:  BTFSS  FEF.7
07626:  BRA    7632
....................          return (FR_RW_ERROR); 
07628:  MOVLW  07
0762A:  MOVWF  01
0762C:  MOVLB  7
0762E:  BRA    7948
07630:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
07632:  MOVLW  04
07634:  ADDWF  x9A,W
07636:  MOVWF  FE9
07638:  MOVLW  00
0763A:  ADDWFC x9B,W
0763C:  MOVWF  FEA
0763E:  MOVFF  FEF,00
07642:  MOVFF  FEC,01
07646:  MOVFF  FEC,02
0764A:  MOVFF  FEC,03
0764E:  MOVF   03,W
07650:  SUBWF  x9F,W
07652:  BNC   7688
07654:  BNZ   766C
07656:  MOVF   02,W
07658:  SUBWF  x9E,W
0765A:  BNC   7688
0765C:  BNZ   766C
0765E:  MOVF   01,W
07660:  SUBWF  x9D,W
07662:  BNC   7688
07664:  BNZ   766C
07666:  MOVF   x9C,W
07668:  SUBWF  00,W
0766A:  BC    7688
....................          ofs = fp->fsize;               // Clip offset by file size  
0766C:  MOVLW  04
0766E:  ADDWF  x9A,W
07670:  MOVWF  FE9
07672:  MOVLW  00
07674:  ADDWFC x9B,W
07676:  MOVWF  FEA
07678:  MOVFF  FEF,99C
0767C:  MOVFF  FEC,99D
07680:  MOVFF  FEC,99E
07684:  MOVFF  FEC,99F
....................       fp->fptr = ofs;  
07688:  MOVFF  99A,FE9
0768C:  MOVF   x9B,W
0768E:  MOVWF  FEA
07690:  MOVFF  99C,FEF
07694:  MOVFF  99D,FEC
07698:  MOVFF  99E,FEC
0769C:  MOVFF  99F,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
076A0:  MOVLW  1B
076A2:  ADDWF  x9A,W
076A4:  MOVWF  FE9
076A6:  MOVLW  00
076A8:  ADDWFC x9B,W
076AA:  MOVWF  FEA
076AC:  MOVLW  01
076AE:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
076B0:  MOVF   x9C,F
076B2:  BNZ   76C2
076B4:  MOVF   x9D,F
076B6:  BNZ   76C2
076B8:  MOVF   x9E,F
076BA:  BNZ   76C2
076BC:  MOVF   x9F,F
076BE:  BTFSC  FD8.2
076C0:  BRA    7926
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
076C2:  MOVLW  01
076C4:  SUBWF  x9C,W
076C6:  MOVLW  00
076C8:  SUBWFB x9D,W
076CA:  MOVWF  xA6
076CC:  MOVLW  00
076CE:  SUBWFB x9E,W
076D0:  MOVWF  xA7
076D2:  MOVLW  00
076D4:  SUBWFB x9F,W
076D6:  MOVWF  xA8
076D8:  BCF    FD8.0
076DA:  CLRF   x9F
076DC:  RRCF   xA8,W
076DE:  MOVWF  x9E
076E0:  RRCF   xA7,W
076E2:  MOVWF  x9D
076E4:  RRCF   xA6,W
076E6:  MOVWF  x9C
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
076E8:  MOVLW  02
076EA:  MOVLB  7
076EC:  ADDWF  x0E,W
076EE:  MOVWF  FE9
076F0:  MOVLW  00
076F2:  ADDWFC x0F,W
076F4:  MOVWF  FEA
076F6:  MOVFF  FEF,9A4
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
076FA:  MOVLW  1B
076FC:  MOVLB  9
076FE:  ADDWF  x9A,W
07700:  MOVWF  01
07702:  MOVLW  00
07704:  ADDWFC x9B,W
07706:  MOVWF  03
07708:  MOVFF  01,9A5
0770C:  MOVWF  xA6
0770E:  MOVFF  FEA,9A8
07712:  MOVFF  FE9,9A7
07716:  BSF    FD8.1
07718:  MOVLW  09
0771A:  MOVWF  FEA
0771C:  MOVLW  A9
0771E:  MOVWF  FE9
07720:  CLRF   1B
07722:  BTFSC  FF2.7
07724:  BSF    1B.7
07726:  BCF    FF2.7
07728:  MOVFF  99F,A34
0772C:  MOVFF  99E,A33
07730:  MOVFF  99D,A32
07734:  MOVFF  99C,A31
07738:  MOVLB  A
0773A:  CLRF   x38
0773C:  CLRF   x37
0773E:  CLRF   x36
07740:  MOVFF  9A4,A35
07744:  MOVLB  0
07746:  CALL   1050
0774A:  BTFSC  1B.7
0774C:  BSF    FF2.7
0774E:  MOVFF  9A9,00
07752:  MOVFF  9AA,01
07756:  MOVFF  9AB,02
0775A:  MOVFF  9AC,03
0775E:  MOVFF  9A8,FEA
07762:  MOVFF  9A7,FE9
07766:  MOVF   00,W
07768:  MOVLB  9
0776A:  SUBWF  xA4,W
0776C:  MOVWF  00
0776E:  MOVLW  00
07770:  SUBFWB 01,F
07772:  SUBFWB 02,F
07774:  SUBFWB 03,F
07776:  MOVFF  9A6,FEA
0777A:  MOVFF  9A5,FE9
0777E:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
07782:  BCF    FD8.1
07784:  CLRF   1B
07786:  BTFSC  FF2.7
07788:  BSF    1B.7
0778A:  BCF    FF2.7
0778C:  MOVFF  99F,A34
07790:  MOVFF  99E,A33
07794:  MOVFF  99D,A32
07798:  MOVFF  99C,A31
0779C:  MOVLB  A
0779E:  CLRF   x38
077A0:  CLRF   x37
077A2:  CLRF   x36
077A4:  MOVFF  9A4,A35
077A8:  MOVLB  0
077AA:  CALL   1050
077AE:  BTFSC  1B.7
077B0:  BSF    FF2.7
077B2:  MOVFF  03,99F
077B6:  MOVFF  02,99E
077BA:  MOVFF  01,99D
077BE:  MOVFF  00,99C
....................          clust = fp->org_clust;            // Seek to current cluster  
077C2:  MOVLW  08
077C4:  MOVLB  9
077C6:  ADDWF  x9A,W
077C8:  MOVWF  FE9
077CA:  MOVLW  00
077CC:  ADDWFC x9B,W
077CE:  MOVWF  FEA
077D0:  MOVFF  FEF,9A0
077D4:  MOVFF  FEC,9A1
077D8:  MOVFF  FEC,9A2
077DC:  MOVFF  FEC,9A3
....................     
....................          while (ofs--) 
077E0:  MOVFF  99F,03
077E4:  MOVFF  99E,02
077E8:  MOVFF  99D,01
077EC:  MOVFF  99C,00
077F0:  MOVLW  FF
077F2:  ADDWF  x9C,F
077F4:  BTFSS  FD8.0
077F6:  ADDWF  x9D,F
077F8:  BTFSS  FD8.0
077FA:  ADDWF  x9E,F
077FC:  BTFSS  FD8.0
077FE:  ADDWF  x9F,F
07800:  MOVF   00,F
07802:  BNZ   7810
07804:  MOVF   01,F
07806:  BNZ   7810
07808:  MOVF   02,F
0780A:  BNZ   7810
0780C:  MOVF   03,F
0780E:  BZ    783A
....................             clust = get_cluster(clust); 
07810:  MOVFF  9A3,9E9
07814:  MOVFF  9A2,9E8
07818:  MOVFF  9A1,9E7
0781C:  MOVFF  9A0,9E6
07820:  MOVLB  0
07822:  CALL   5D36
07826:  MOVFF  03,9A3
0782A:  MOVFF  02,9A2
0782E:  MOVFF  01,9A1
07832:  MOVFF  00,9A0
07836:  MOVLB  9
07838:  BRA    77E0
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
0783A:  MOVF   xA3,F
0783C:  BNZ   784C
0783E:  MOVF   xA2,F
07840:  BNZ   784C
07842:  MOVF   xA1,F
07844:  BNZ   784C
07846:  MOVF   xA0,W
07848:  SUBLW  01
0784A:  BC    788A
0784C:  MOVLW  0C
0784E:  MOVLB  7
07850:  ADDWF  x0E,W
07852:  MOVWF  FE9
07854:  MOVLW  00
07856:  ADDWFC x0F,W
07858:  MOVWF  FEA
0785A:  MOVFF  FEF,00
0785E:  MOVFF  FEC,01
07862:  MOVFF  FEC,02
07866:  MOVFF  FEC,03
0786A:  MOVF   03,W
0786C:  MOVLB  9
0786E:  SUBWF  xA3,W
07870:  BNC   788C
07872:  BNZ   788A
07874:  MOVF   02,W
07876:  SUBWF  xA2,W
07878:  BNC   788C
0787A:  BNZ   788A
0787C:  MOVF   01,W
0787E:  SUBWF  xA1,W
07880:  BNC   788C
07882:  BNZ   788A
07884:  MOVF   00,W
07886:  SUBWF  xA0,W
07888:  BNC   788C
....................             goto fk_error; 
0788A:  BRA    7930
....................     
....................          fp->curr_clust = clust; 
0788C:  MOVLW  0C
0788E:  ADDWF  x9A,W
07890:  MOVWF  FE9
07892:  MOVLW  00
07894:  ADDWFC x9B,W
07896:  MOVWF  FEA
07898:  MOVFF  9A0,FEF
0789C:  MOVFF  9A1,FEC
078A0:  MOVFF  9A2,FEC
078A4:  MOVFF  9A3,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
078A8:  MOVLW  10
078AA:  ADDWF  x9A,W
078AC:  MOVWF  01
078AE:  MOVLW  00
078B0:  ADDWFC x9B,W
078B2:  MOVWF  03
078B4:  MOVFF  01,9A5
078B8:  MOVWF  xA6
078BA:  MOVFF  9A3,9DC
078BE:  MOVFF  9A2,9DB
078C2:  MOVFF  9A1,9DA
078C6:  MOVFF  9A0,9D9
078CA:  MOVLB  0
078CC:  CALL   5662
078D0:  MOVFF  03,9AA
078D4:  MOVFF  02,9A9
078D8:  MOVFF  01,9A8
078DC:  MOVFF  00,9A7
078E0:  MOVLB  9
078E2:  MOVF   xA4,W
078E4:  ADDWF  xA7,F
078E6:  MOVLW  00
078E8:  ADDWFC xA8,F
078EA:  ADDWFC xA9,F
078EC:  ADDWFC xAA,F
078EE:  MOVLW  1B
078F0:  ADDWF  x9A,W
078F2:  MOVWF  FE9
078F4:  MOVLW  00
078F6:  ADDWFC x9B,W
078F8:  MOVWF  FEA
078FA:  MOVF   FEF,W
078FC:  SUBWF  xA7,W
078FE:  MOVWF  00
07900:  MOVLW  00
07902:  SUBWFB xA8,W
07904:  MOVWF  01
07906:  MOVLW  00
07908:  SUBWFB xA9,W
0790A:  MOVWF  02
0790C:  MOVLW  00
0790E:  SUBWFB xAA,W
07910:  MOVFF  9A6,FEA
07914:  MOVFF  9A5,FE9
07918:  MOVFF  00,FEF
0791C:  MOVFF  01,FEC
07920:  MOVFF  02,FEC
07924:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
07926:  MOVLW  00
07928:  MOVWF  01
0792A:  MOVLB  7
0792C:  BRA    7948
0792E:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07930:  MOVLW  1A
07932:  ADDWF  x9A,W
07934:  MOVWF  FE9
07936:  MOVLW  00
07938:  ADDWFC x9B,W
0793A:  MOVWF  FEA
0793C:  MOVF   FEF,W
0793E:  IORLW  80
07940:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
07942:  MOVLW  07
07944:  MOVWF  01
07946:  MOVLB  7
07948:  MOVLB  0
0794A:  GOTO   83C4 (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
0810C:  MOVLB  7
0810E:  MOVF   x0E,W
08110:  IORWF  x0F,W
08112:  BNZ   811A
....................       return (FR_NOT_ENABLED); 
08114:  MOVLW  0B
08116:  MOVWF  01
08118:  BRA    82E6
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
0811A:  MOVLB  0
0811C:  CALL   55F2
08120:  BTFSC  01.0
08122:  BRA    8134
08124:  MOVLB  7
08126:  MOVFF  70E,FE9
0812A:  MOVFF  70F,FEA
0812E:  MOVF   FEF,F
08130:  BNZ   813C
08132:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
08134:  MOVLW  09
08136:  MOVWF  01
08138:  MOVLB  7
0813A:  BRA    82E6
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
0813C:  MOVLW  1A
0813E:  MOVLB  9
08140:  ADDWF  x9D,W
08142:  MOVWF  FE9
08144:  MOVLW  00
08146:  ADDWFC x9E,W
08148:  MOVWF  FEA
0814A:  BTFSS  FEF.5
0814C:  BRA    82C4
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
0814E:  MOVLW  14
08150:  ADDWF  x9D,W
08152:  MOVWF  FE9
08154:  MOVLW  00
08156:  ADDWFC x9E,W
08158:  MOVWF  FEA
0815A:  MOVFF  FEF,9FA
0815E:  MOVFF  FEC,9FB
08162:  MOVFF  FEC,9FC
08166:  MOVFF  FEC,9FD
0816A:  MOVLB  0
0816C:  CALL   5AD6
08170:  MOVF   01,F
08172:  BNZ   817E
....................          return (FR_RW_ERROR); 
08174:  MOVLW  07
08176:  MOVWF  01
08178:  MOVLB  7
0817A:  BRA    82E6
0817C:  MOVLB  0
....................       ptr = fp->dir_ptr; 
0817E:  MOVLW  18
08180:  MOVLB  9
08182:  ADDWF  x9D,W
08184:  MOVWF  FE9
08186:  MOVLW  00
08188:  ADDWFC x9E,W
0818A:  MOVWF  FEA
0818C:  MOVFF  FEC,9A0
08190:  MOVF   FED,F
08192:  MOVFF  FEF,99F
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
08196:  MOVLW  0B
08198:  ADDWF  x9F,W
0819A:  MOVWF  01
0819C:  MOVLW  00
0819E:  ADDWFC xA0,W
081A0:  MOVFF  01,FE9
081A4:  MOVWF  FEA
081A6:  MOVF   FEF,W
081A8:  IORLW  20
081AA:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
081AC:  MOVLW  1C
081AE:  ADDWF  x9F,W
081B0:  MOVWF  01
081B2:  MOVLW  00
081B4:  ADDWFC xA0,W
081B6:  MOVWF  03
081B8:  MOVFF  01,9A1
081BC:  MOVWF  xA2
081BE:  MOVLW  04
081C0:  ADDWF  x9D,W
081C2:  MOVWF  FE9
081C4:  MOVLW  00
081C6:  ADDWFC x9E,W
081C8:  MOVWF  FEA
081CA:  MOVFF  FEF,00
081CE:  MOVFF  FEC,01
081D2:  MOVFF  FEC,02
081D6:  MOVFF  FEC,03
081DA:  MOVFF  9A2,FEA
081DE:  MOVFF  9A1,FE9
081E2:  MOVFF  00,FEF
081E6:  MOVFF  01,FEC
081EA:  MOVFF  02,FEC
081EE:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
081F2:  MOVLW  1A
081F4:  ADDWF  x9F,W
081F6:  MOVWF  01
081F8:  MOVLW  00
081FA:  ADDWFC xA0,W
081FC:  MOVWF  03
081FE:  MOVFF  01,9A1
08202:  MOVWF  xA2
08204:  MOVLW  08
08206:  ADDWF  x9D,W
08208:  MOVWF  FE9
0820A:  MOVLW  00
0820C:  ADDWFC x9E,W
0820E:  MOVWF  FEA
08210:  MOVFF  FEF,00
08214:  MOVFF  FEC,01
08218:  MOVFF  FEC,02
0821C:  MOVFF  FEC,03
08220:  MOVFF  9A2,FEA
08224:  MOVFF  9A1,FE9
08228:  MOVFF  00,FEF
0822C:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
08230:  MOVLW  14
08232:  ADDWF  x9F,W
08234:  MOVWF  01
08236:  MOVLW  00
08238:  ADDWFC xA0,W
0823A:  MOVWF  03
0823C:  MOVFF  01,9A1
08240:  MOVWF  xA2
08242:  MOVLW  08
08244:  ADDWF  x9D,W
08246:  MOVWF  FE9
08248:  MOVLW  00
0824A:  ADDWFC x9E,W
0824C:  MOVWF  FEA
0824E:  MOVFF  FEF,9A3
08252:  MOVFF  FEC,9A4
08256:  MOVFF  FEC,00
0825A:  MOVFF  FEC,01
0825E:  MOVFF  9A2,FEA
08262:  MOVFF  9A1,FE9
08266:  MOVFF  00,FEF
0826A:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
0826E:  MOVLW  16
08270:  ADDWF  x9F,W
08272:  MOVWF  01
08274:  MOVLW  00
08276:  ADDWFC xA0,W
08278:  MOVWF  03
0827A:  MOVFF  01,9A1
0827E:  MOVWF  xA2
08280:  MOVLB  0
08282:  CALL   702E
08286:  MOVFF  9A2,FEA
0828A:  MOVFF  9A1,FE9
0828E:  MOVFF  00,FEF
08292:  MOVFF  01,FEC
08296:  MOVFF  02,FEC
0829A:  MOVFF  03,FEC
....................       fs->winflag = 1; 
0829E:  MOVLW  06
082A0:  MOVLB  7
082A2:  ADDWF  x0E,W
082A4:  MOVWF  FE9
082A6:  MOVLW  00
082A8:  ADDWFC x0F,W
082AA:  MOVWF  FEA
082AC:  MOVLW  01
082AE:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
082B0:  MOVLW  1A
082B2:  MOVLB  9
082B4:  ADDWF  x9D,W
082B6:  MOVWF  FE9
082B8:  MOVLW  00
082BA:  ADDWFC x9E,W
082BC:  MOVWF  FEA
082BE:  MOVF   FEF,W
082C0:  ANDLW  DF
082C2:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
082C4:  CLRF   xFD
082C6:  CLRF   xFC
082C8:  CLRF   xFB
082CA:  CLRF   xFA
082CC:  MOVLB  0
082CE:  CALL   5AD6
082D2:  MOVF   01,F
082D4:  BNZ   82E0
....................       return (FR_RW_ERROR); 
082D6:  MOVLW  07
082D8:  MOVWF  01
082DA:  MOVLB  7
082DC:  BRA    82E6
082DE:  MOVLB  0
....................  
....................    return (FR_OK); 
082E0:  MOVLW  00
082E2:  MOVWF  01
082E4:  MOVLB  7
082E6:  MOVLB  0
082E8:  GOTO   82F6 (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
082EC:  MOVFF  99B,99E
082F0:  MOVFF  99A,99D
082F4:  BRA    810C
082F6:  MOVFF  01,99C
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
082FA:  MOVLB  9
082FC:  MOVF   x9C,F
082FE:  BNZ   8330
....................       { 
....................       fp->flag = 0; 
08300:  MOVLW  1A
08302:  ADDWF  x9A,W
08304:  MOVWF  FE9
08306:  MOVLW  00
08308:  ADDWFC x9B,W
0830A:  MOVWF  FEA
0830C:  CLRF   FEF
....................       if (fs->files) 
0830E:  MOVLW  01
08310:  MOVLB  7
08312:  ADDWF  x0E,W
08314:  MOVWF  FE9
08316:  MOVLW  00
08318:  ADDWFC x0F,W
0831A:  MOVWF  FEA
0831C:  MOVF   FEF,F
0831E:  BZ    832E
....................          fs->files--; 
08320:  MOVLW  01
08322:  ADDWF  x0E,W
08324:  MOVWF  FE9
08326:  MOVLW  00
08328:  ADDWFC x0F,W
0832A:  MOVWF  FEA
0832C:  DECF   FEF,F
0832E:  MOVLB  9
....................       } 
....................    return (res); 
08330:  MOVFF  99C,01
08334:  MOVLB  0
08336:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0BA10:  CALL   5600
0BA14:  MOVFF  01,875
....................    if (res != FR_OK)  
0BA18:  MOVLB  8
0BA1A:  MOVF   x75,F
0BA1C:  BZ    BA24
....................       return (res); 
0BA1E:  MOVFF  875,01
0BA22:  BRA    BCB4
....................  
....................    if (disk_status() & STA_PROTECT) 
0BA24:  MOVLB  0
0BA26:  CALL   55F2
0BA2A:  BTFSS  01.2
0BA2C:  BRA    BA38
....................       return (FR_WRITE_PROTECTED); 
0BA2E:  MOVLW  0A
0BA30:  MOVWF  01
0BA32:  MOVLB  8
0BA34:  BRA    BCB4
0BA36:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0BA38:  MOVLW  08
0BA3A:  MOVLB  9
0BA3C:  MOVWF  xC1
0BA3E:  MOVLW  82
0BA40:  MOVWF  xC0
0BA42:  MOVLW  08
0BA44:  MOVWF  xC3
0BA46:  MOVLW  90
0BA48:  MOVWF  xC2
0BA4A:  MOVFF  874,9C5
0BA4E:  MOVFF  873,9C4
0BA52:  MOVLW  08
0BA54:  MOVWF  xC7
0BA56:  MOVLW  76
0BA58:  MOVWF  xC6
0BA5A:  MOVLB  0
0BA5C:  CALL   6248
0BA60:  MOVFF  01,875
....................  
....................    if (res != FR_OK)  
0BA64:  MOVLB  8
0BA66:  MOVF   x75,F
0BA68:  BZ    BA70
....................       return (res);            // Trace failed  
0BA6A:  MOVFF  875,01
0BA6E:  BRA    BCB4
....................  
....................    if (dir_ptr == NULL)  
0BA70:  MOVF   x76,F
0BA72:  BNZ   BA7E
0BA74:  MOVF   x77,F
0BA76:  BNZ   BA7E
....................       return (FR_NO_FILE);      // It is a root directory  
0BA78:  MOVLW  02
0BA7A:  MOVWF  01
0BA7C:  BRA    BCB4
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0BA7E:  MOVLW  0B
0BA80:  ADDWF  x76,W
0BA82:  MOVWF  01
0BA84:  MOVLW  00
0BA86:  ADDWFC x77,W
0BA88:  MOVWF  03
0BA8A:  MOVFF  01,FE9
0BA8E:  MOVWF  FEA
0BA90:  BTFSS  FEF.0
0BA92:  BRA    BA9A
....................       return (FR_DENIED);         // It is a R/O item  
0BA94:  MOVLW  05
0BA96:  MOVWF  01
0BA98:  BRA    BCB4
....................  
....................    dsect = fs->winsect; 
0BA9A:  MOVLW  20
0BA9C:  MOVLB  7
0BA9E:  ADDWF  x0E,W
0BAA0:  MOVWF  FE9
0BAA2:  MOVLW  00
0BAA4:  ADDWFC x0F,W
0BAA6:  MOVWF  FEA
0BAA8:  MOVFF  FEF,87E
0BAAC:  MOVFF  FEC,87F
0BAB0:  MOVFF  FEC,880
0BAB4:  MOVFF  FEC,881
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0BAB8:  MOVLW  14
0BABA:  MOVLB  8
0BABC:  ADDWF  x76,W
0BABE:  MOVWF  01
0BAC0:  MOVLW  00
0BAC2:  ADDWFC x77,W
0BAC4:  MOVWF  03
0BAC6:  MOVFF  01,FE9
0BACA:  MOVWF  FEA
0BACC:  MOVFF  FEC,87D
0BAD0:  MOVF   FED,F
0BAD2:  MOVFF  FEF,89C
0BAD6:  MOVFF  89C,87C
0BADA:  CLRF   x9C
0BADC:  CLRF   x9D
0BADE:  MOVLW  1A
0BAE0:  ADDWF  x76,W
0BAE2:  MOVWF  01
0BAE4:  MOVLW  00
0BAE6:  ADDWFC x77,W
0BAE8:  MOVFF  01,FE9
0BAEC:  MOVWF  FEA
0BAEE:  MOVFF  FEC,03
0BAF2:  MOVF   FED,F
0BAF4:  MOVF   FEF,W
0BAF6:  IORWF  x9C,W
0BAF8:  MOVWF  x7A
0BAFA:  MOVF   03,W
0BAFC:  IORWF  x9D,W
0BAFE:  MOVWF  x7B
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BB00:  MOVLW  0B
0BB02:  ADDWF  x76,W
0BB04:  MOVWF  01
0BB06:  MOVLW  00
0BB08:  ADDWFC x77,W
0BB0A:  MOVWF  03
0BB0C:  MOVFF  01,FE9
0BB10:  MOVWF  FEA
0BB12:  BTFSS  FEF.4
0BB14:  BRA    BC28
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BB16:  MOVFF  87D,889
0BB1A:  MOVFF  87C,888
0BB1E:  MOVFF  87B,887
0BB22:  MOVFF  87A,886
....................       dirscan.sect = clust2sect(dclust); 
0BB26:  MOVFF  87D,9DC
0BB2A:  MOVFF  87C,9DB
0BB2E:  MOVFF  87B,9DA
0BB32:  MOVFF  87A,9D9
0BB36:  MOVLB  0
0BB38:  CALL   5662
0BB3C:  MOVFF  03,88D
0BB40:  MOVFF  02,88C
0BB44:  MOVFF  01,88B
0BB48:  MOVFF  00,88A
....................       dirscan.index = 0; 
0BB4C:  MOVLB  8
0BB4E:  CLRF   x8F
0BB50:  CLRF   x8E
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BB52:  MOVFF  88D,9FD
0BB56:  MOVFF  88C,9FC
0BB5A:  MOVFF  88B,9FB
0BB5E:  MOVFF  88A,9FA
0BB62:  MOVLB  0
0BB64:  CALL   5AD6
0BB68:  MOVF   01,F
0BB6A:  BNZ   BB76
....................             return (FR_RW_ERROR); 
0BB6C:  MOVLW  07
0BB6E:  MOVWF  01
0BB70:  MOVLB  8
0BB72:  BRA    BCB4
0BB74:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BB76:  MOVLB  8
0BB78:  MOVF   x8E,W
0BB7A:  ANDLW  0F
0BB7C:  MOVWF  x9C
0BB7E:  CLRF   x9D
0BB80:  RLCF   x9C,F
0BB82:  RLCF   x9D,F
0BB84:  RLCF   x9C,F
0BB86:  RLCF   x9D,F
0BB88:  RLCF   x9C,F
0BB8A:  RLCF   x9D,F
0BB8C:  RLCF   x9C,F
0BB8E:  RLCF   x9D,F
0BB90:  RLCF   x9C,F
0BB92:  RLCF   x9D,F
0BB94:  MOVLW  E0
0BB96:  ANDWF  x9C,F
0BB98:  MOVLW  24
0BB9A:  ADDWF  x9C,W
0BB9C:  MOVWF  01
0BB9E:  MOVLW  00
0BBA0:  ADDWFC x9D,W
0BBA2:  MOVWF  03
0BBA4:  MOVF   01,W
0BBA6:  MOVLB  7
0BBA8:  ADDWF  x0E,W
0BBAA:  MOVWF  01
0BBAC:  MOVF   x0F,W
0BBAE:  ADDWFC 03,F
0BBB0:  MOVFF  01,878
0BBB4:  MOVLB  8
0BBB6:  MOVFF  03,879
....................          if (*sdir == 0) 
0BBBA:  MOVFF  879,03
0BBBE:  MOVFF  878,FE9
0BBC2:  MOVFF  879,FEA
0BBC6:  MOVF   FEF,F
0BBC8:  BNZ   BBCC
....................             break; 
0BBCA:  BRA    BC28
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BBCC:  MOVFF  879,03
0BBD0:  MOVFF  878,FE9
0BBD4:  MOVFF  879,FEA
0BBD8:  MOVF   FEF,W
0BBDA:  SUBLW  E5
0BBDC:  BZ    BC0C
0BBDE:  MOVFF  879,03
0BBE2:  MOVFF  878,FE9
0BBE6:  MOVFF  879,FEA
0BBEA:  MOVF   FEF,W
0BBEC:  SUBLW  2E
0BBEE:  BZ    BC0C
0BBF0:  MOVLW  0B
0BBF2:  ADDWF  x78,W
0BBF4:  MOVWF  01
0BBF6:  MOVLW  00
0BBF8:  ADDWFC x79,W
0BBFA:  MOVWF  03
0BBFC:  MOVFF  01,FE9
0BC00:  MOVWF  FEA
0BC02:  BTFSC  FEF.3
0BC04:  BRA    BC0C
....................             return (FR_DENIED);   // The directory is not empty  
0BC06:  MOVLW  05
0BC08:  MOVWF  01
0BC0A:  BRA    BCB4
....................          } while (next_dir_ptr(&dirscan)); 
0BC0C:  MOVLW  08
0BC0E:  MOVLB  9
0BC10:  MOVWF  xD0
0BC12:  MOVLW  82
0BC14:  MOVWF  xCF
0BC16:  MOVLB  0
0BC18:  CALL   606E
0BC1C:  MOVF   01,F
0BC1E:  BTFSC  FD8.2
0BC20:  BRA    BC26
0BC22:  MOVLB  8
0BC24:  BRA    BB52
0BC26:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BC28:  MOVFF  881,9FD
0BC2C:  MOVFF  880,9FC
0BC30:  MOVFF  87F,9FB
0BC34:  MOVFF  87E,9FA
0BC38:  MOVLB  0
0BC3A:  CALL   5AD6
0BC3E:  MOVF   01,F
0BC40:  BNZ   BC4C
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BC42:  MOVLW  07
0BC44:  MOVWF  01
0BC46:  MOVLB  8
0BC48:  BRA    BCB4
0BC4A:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BC4C:  MOVLB  8
0BC4E:  MOVFF  876,FE9
0BC52:  MOVFF  877,FEA
0BC56:  MOVLW  E5
0BC58:  MOVWF  FEF
....................    fs->winflag = 1; 
0BC5A:  MOVLW  06
0BC5C:  MOVLB  7
0BC5E:  ADDWF  x0E,W
0BC60:  MOVWF  FE9
0BC62:  MOVLW  00
0BC64:  ADDWFC x0F,W
0BC66:  MOVWF  FEA
0BC68:  MOVLW  01
0BC6A:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BC6C:  MOVFF  87D,9C8
0BC70:  MOVFF  87C,9C7
0BC74:  MOVFF  87B,9C6
0BC78:  MOVFF  87A,9C5
0BC7C:  MOVLB  0
0BC7E:  CALL   6F8E
0BC82:  MOVF   01,F
0BC84:  BNZ   BC90
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BC86:  MOVLW  07
0BC88:  MOVWF  01
0BC8A:  MOVLB  8
0BC8C:  BRA    BCB4
0BC8E:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BC90:  MOVLB  9
0BC92:  CLRF   xFD
0BC94:  CLRF   xFC
0BC96:  CLRF   xFB
0BC98:  CLRF   xFA
0BC9A:  MOVLB  0
0BC9C:  CALL   5AD6
0BCA0:  MOVF   01,F
0BCA2:  BNZ   BCAE
....................       return (FR_RW_ERROR); 
0BCA4:  MOVLW  07
0BCA6:  MOVWF  01
0BCA8:  MOVLB  8
0BCAA:  BRA    BCB4
0BCAC:  MOVLB  0
....................  
....................    return (FR_OK); 
0BCAE:  MOVLW  00
0BCB0:  MOVWF  01
0BCB2:  MOVLB  8
0BCB4:  MOVLB  0
0BCB6:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
07A02:  MOVFF  99B,99D
07A06:  MOVFF  99A,99C
07A0A:  MOVFF  99D,03
07A0E:  MOVLB  9
07A10:  MOVFF  99C,FE9
07A14:  MOVFF  99D,FEA
07A18:  MOVF   FEF,F
07A1A:  BZ    7A28
07A1C:  INCF   x9C,F
07A1E:  BTFSC  FD8.2
07A20:  INCF   x9D,F
07A22:  MOVLB  0
07A24:  BRA    7A0A
07A26:  MOVLB  9
....................    return(sc - s); 
07A28:  MOVF   x9A,W
07A2A:  SUBWF  x9C,W
07A2C:  MOVWF  00
07A2E:  MOVF   x9B,W
07A30:  SUBWFB x9D,W
07A32:  MOVWF  03
07A34:  MOVFF  00,01
07A38:  MOVWF  02
07A3A:  MOVLB  0
07A3C:  GOTO   847C (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
0356A:  MOVLB  4
0356C:  CLRF   xE2
0356E:  MOVLW  01
03570:  MOVWF  xE1
....................    rtc.year=10; 
03572:  MOVLW  0A
03574:  MOVWF  xE0
....................    rtc.month=1; 
03576:  MOVLW  01
03578:  MOVWF  xDF
....................    rtc.day=1; 
0357A:  MOVWF  xDE
....................    rtc.hour=0; 
0357C:  CLRF   xDD
....................    rtc.min=0; 
0357E:  CLRF   xDC
....................    rtc.sec=0; 
03580:  CLRF   xDB
....................    rtc.ms100=0; 
03582:  CLRF   xDA
03584:  MOVLB  0
03586:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
0702E:  MOVLB  9
07030:  CLRF   xC7
07032:  CLRF   xC6
07034:  CLRF   xC5
07036:  MOVFF  4E0,9C4
0703A:  MOVLW  14
0703C:  ADDWF  xC4,F
0703E:  MOVLW  00
07040:  ADDWFC xC5,F
07042:  ADDWFC xC6,F
07044:  ADDWFC xC7,F
07046:  BCF    FD8.0
07048:  CLRF   xC0
0704A:  CLRF   xC1
0704C:  CLRF   xC2
0704E:  RLCF   xC4,W
07050:  MOVWF  xC3
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
07052:  CLRF   xC7
07054:  CLRF   xC6
07056:  CLRF   xC5
07058:  MOVFF  4DF,9C4
0705C:  MOVLW  0F
0705E:  ANDWF  xC4,F
07060:  CLRF   xC5
07062:  CLRF   xC6
07064:  CLRF   xC7
07066:  CLRF   00
07068:  CLRF   01
0706A:  RLCF   xC4,W
0706C:  MOVWF  02
0706E:  RLCF   xC5,W
07070:  MOVWF  03
07072:  RLCF   02,F
07074:  RLCF   03,F
07076:  RLCF   02,F
07078:  RLCF   03,F
0707A:  RLCF   02,F
0707C:  RLCF   03,F
0707E:  RLCF   02,F
07080:  RLCF   03,F
07082:  MOVLW  E0
07084:  ANDWF  02,F
07086:  MOVF   00,W
07088:  IORWF  xC0,F
0708A:  MOVF   01,W
0708C:  IORWF  xC1,F
0708E:  MOVF   02,W
07090:  IORWF  xC2,F
07092:  MOVF   03,W
07094:  IORWF  xC3,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
07096:  CLRF   xC7
07098:  CLRF   xC6
0709A:  CLRF   xC5
0709C:  MOVFF  4DE,9C4
070A0:  MOVLW  1F
070A2:  ANDWF  xC4,F
070A4:  CLRF   xC5
070A6:  CLRF   xC6
070A8:  CLRF   xC7
070AA:  CLRF   00
070AC:  CLRF   01
070AE:  MOVF   00,W
070B0:  IORWF  xC0,F
070B2:  MOVF   01,W
070B4:  IORWF  xC1,F
070B6:  MOVF   xC4,W
070B8:  IORWF  xC2,F
070BA:  MOVF   xC5,W
070BC:  IORWF  xC3,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
070BE:  CLRF   xC7
070C0:  CLRF   xC6
070C2:  CLRF   xC5
070C4:  MOVFF  4DD,9C4
070C8:  MOVLW  1F
070CA:  ANDWF  xC4,F
070CC:  CLRF   xC5
070CE:  CLRF   xC6
070D0:  CLRF   xC7
070D2:  CLRF   00
070D4:  RLCF   xC4,W
070D6:  MOVWF  01
070D8:  RLCF   xC5,W
070DA:  MOVWF  02
070DC:  RLCF   xC6,W
070DE:  MOVWF  03
070E0:  RLCF   01,F
070E2:  RLCF   02,F
070E4:  RLCF   03,F
070E6:  RLCF   01,F
070E8:  RLCF   02,F
070EA:  RLCF   03,F
070EC:  MOVLW  F8
070EE:  ANDWF  01,F
070F0:  MOVF   00,W
070F2:  IORWF  xC0,F
070F4:  MOVF   01,W
070F6:  IORWF  xC1,F
070F8:  MOVF   02,W
070FA:  IORWF  xC2,F
070FC:  MOVF   03,W
070FE:  IORWF  xC3,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
07100:  CLRF   xC7
07102:  CLRF   xC6
07104:  CLRF   xC5
07106:  MOVFF  4DC,9C4
0710A:  MOVLW  3F
0710C:  ANDWF  xC4,F
0710E:  CLRF   xC5
07110:  CLRF   xC6
07112:  CLRF   xC7
07114:  RLCF   xC4,W
07116:  MOVWF  00
07118:  RLCF   xC5,W
0711A:  MOVWF  01
0711C:  RLCF   xC6,W
0711E:  MOVWF  02
07120:  RLCF   xC7,W
07122:  MOVWF  03
07124:  RLCF   00,F
07126:  RLCF   01,F
07128:  RLCF   02,F
0712A:  RLCF   03,F
0712C:  RLCF   00,F
0712E:  RLCF   01,F
07130:  RLCF   02,F
07132:  RLCF   03,F
07134:  RLCF   00,F
07136:  RLCF   01,F
07138:  RLCF   02,F
0713A:  RLCF   03,F
0713C:  RLCF   00,F
0713E:  RLCF   01,F
07140:  RLCF   02,F
07142:  RLCF   03,F
07144:  MOVLW  E0
07146:  ANDWF  00,F
07148:  MOVF   00,W
0714A:  IORWF  xC0,F
0714C:  MOVF   01,W
0714E:  IORWF  xC1,F
07150:  MOVF   02,W
07152:  IORWF  xC2,F
07154:  MOVF   03,W
07156:  IORWF  xC3,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
07158:  CLRF   xC7
0715A:  CLRF   xC6
0715C:  CLRF   xC5
0715E:  MOVFF  4DB,9C4
07162:  MOVLW  3F
07164:  ANDWF  xC4,F
07166:  CLRF   xC5
07168:  CLRF   xC6
0716A:  CLRF   xC7
0716C:  BCF    FD8.0
0716E:  RRCF   xC7,W
07170:  MOVWF  03
07172:  RRCF   xC6,W
07174:  MOVWF  02
07176:  RRCF   xC5,W
07178:  MOVWF  01
0717A:  RRCF   xC4,W
0717C:  IORWF  xC0,F
0717E:  MOVF   01,W
07180:  IORWF  xC1,F
07182:  MOVF   02,W
07184:  IORWF  xC2,F
07186:  MOVF   03,W
07188:  IORWF  xC3,F
....................    return (work); 
0718A:  MOVFF  9C0,00
0718E:  MOVFF  9C1,01
07192:  MOVFF  9C2,02
07196:  MOVFF  9C3,03
0719A:  MOVLB  0
0719C:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0B896:  MOVLW  08
0B898:  MOVLB  9
0B89A:  MOVWF  x9B
0B89C:  MOVLW  75
0B89E:  MOVWF  x9A
0B8A0:  MOVFF  874,99D
0B8A4:  MOVFF  873,99C
0B8A8:  MOVLW  01
0B8AA:  MOVWF  x9E
0B8AC:  MOVLB  0
0B8AE:  CALL   719E
0B8B2:  MOVFF  01,891
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0B8B6:  MOVLB  8
0B8B8:  MOVF   x91,F
0B8BA:  BTFSS  FD8.2
0B8BC:  BRA    B9BE
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0B8BE:  MOVLW  08
0B8C0:  MOVWF  xB7
0B8C2:  MOVLW  75
0B8C4:  MOVWF  xB6
0B8C6:  MOVLW  08
0B8C8:  MOVWF  xB9
0B8CA:  MOVLW  92
0B8CC:  MOVWF  xB8
0B8CE:  CLRF   xBB
0B8D0:  MOVLW  20
0B8D2:  MOVWF  xBA
0B8D4:  MOVLW  08
0B8D6:  MOVWF  xBD
0B8D8:  MOVLW  B4
0B8DA:  MOVWF  xBC
0B8DC:  MOVLB  0
0B8DE:  BRA    B1DA
0B8E0:  MOVFF  01,891
....................          for (i = 0; i < br; i++) 
0B8E4:  MOVLB  8
0B8E6:  CLRF   xB3
0B8E8:  CLRF   xB2
0B8EA:  MOVF   xB3,W
0B8EC:  SUBWF  xB5,W
0B8EE:  BNC   B91A
0B8F0:  BNZ   B8F8
0B8F2:  MOVF   xB4,W
0B8F4:  SUBWF  xB2,W
0B8F6:  BC    B91A
....................          { 
....................             putc(mesg[i]); 
0B8F8:  MOVLW  92
0B8FA:  ADDWF  xB2,W
0B8FC:  MOVWF  FE9
0B8FE:  MOVLW  08
0B900:  ADDWFC xB3,W
0B902:  MOVWF  FEA
0B904:  MOVFF  FEF,8B6
0B908:  MOVF   xB6,W
0B90A:  MOVLB  0
0B90C:  CALL   AEB4
0B910:  MOVLB  8
0B912:  INCF   xB2,F
0B914:  BTFSC  FD8.2
0B916:  INCF   xB3,F
0B918:  BRA    B8EA
....................          } 
....................       } while ((result == FR_OK) && br); 
0B91A:  MOVF   x91,F
0B91C:  BNZ   B924
0B91E:  MOVF   xB4,W
0B920:  IORWF  xB5,W
0B922:  BNZ   B8BE
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0B924:  MOVF   x91,F
0B926:  BZ    B99A
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0B928:  MOVLW  16
0B92A:  MOVWF  FF6
0B92C:  MOVLW  0C
0B92E:  MOVWF  FF7
0B930:  MOVLW  00
0B932:  MOVWF  FF8
0B934:  CLRF   1B
0B936:  BTFSC  FF2.7
0B938:  BSF    1B.7
0B93A:  BCF    FF2.7
0B93C:  MOVLB  0
0B93E:  CALL   0DCC
0B942:  BTFSC  1B.7
0B944:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0B946:  MOVFF  891,8B6
0B94A:  MOVLW  08
0B94C:  MOVLB  8
0B94E:  MOVWF  xB8
0B950:  MOVLW  92
0B952:  MOVWF  xB7
0B954:  MOVLB  0
0B956:  RCALL  B6E8
....................          printf("@FS: %s\r\n",mesg); 
0B958:  MOVLW  2C
0B95A:  MOVWF  FF6
0B95C:  MOVLW  0C
0B95E:  MOVWF  FF7
0B960:  MOVLW  00
0B962:  MOVWF  FF8
0B964:  CLRF   1B
0B966:  BTFSC  FF2.7
0B968:  BSF    1B.7
0B96A:  BCF    FF2.7
0B96C:  MOVLW  05
0B96E:  MOVLB  A
0B970:  MOVWF  x25
0B972:  MOVLB  0
0B974:  CALL   101E
0B978:  BTFSC  1B.7
0B97A:  BSF    FF2.7
0B97C:  MOVLW  08
0B97E:  MOVWF  FEA
0B980:  MOVLW  92
0B982:  MOVWF  FE9
0B984:  CALL   79DC
0B988:  MOVLW  0D
0B98A:  BTFSS  F9E.4
0B98C:  BRA    B98A
0B98E:  MOVWF  FAD
0B990:  MOVLW  0A
0B992:  BTFSS  F9E.4
0B994:  BRA    B992
0B996:  MOVWF  FAD
0B998:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0B99A:  MOVLW  08
0B99C:  MOVLB  9
0B99E:  MOVWF  x9B
0B9A0:  MOVLW  75
0B9A2:  MOVWF  x9A
0B9A4:  MOVLB  0
0B9A6:  CALL   82EC
....................       printf("\r\n");       
0B9AA:  MOVLW  0D
0B9AC:  BTFSS  F9E.4
0B9AE:  BRA    B9AC
0B9B0:  MOVWF  FAD
0B9B2:  MOVLW  0A
0B9B4:  BTFSS  F9E.4
0B9B6:  BRA    B9B4
0B9B8:  MOVWF  FAD
....................    } 
0B9BA:  BRA    BA0E
0B9BC:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0B9BE:  MOVFF  891,8B6
0B9C2:  MOVLW  08
0B9C4:  MOVWF  xB8
0B9C6:  MOVLW  92
0B9C8:  MOVWF  xB7
0B9CA:  MOVLB  0
0B9CC:  RCALL  B6E8
....................       printf("@FS: %s\r\n",mesg); 
0B9CE:  MOVLW  36
0B9D0:  MOVWF  FF6
0B9D2:  MOVLW  0C
0B9D4:  MOVWF  FF7
0B9D6:  MOVLW  00
0B9D8:  MOVWF  FF8
0B9DA:  CLRF   1B
0B9DC:  BTFSC  FF2.7
0B9DE:  BSF    1B.7
0B9E0:  BCF    FF2.7
0B9E2:  MOVLW  05
0B9E4:  MOVLB  A
0B9E6:  MOVWF  x25
0B9E8:  MOVLB  0
0B9EA:  CALL   101E
0B9EE:  BTFSC  1B.7
0B9F0:  BSF    FF2.7
0B9F2:  MOVLW  08
0B9F4:  MOVWF  FEA
0B9F6:  MOVLW  92
0B9F8:  MOVWF  FE9
0B9FA:  CALL   79DC
0B9FE:  MOVLW  0D
0BA00:  BTFSS  F9E.4
0BA02:  BRA    BA00
0BA04:  MOVWF  FAD
0BA06:  MOVLW  0A
0BA08:  BTFSS  F9E.4
0BA0A:  BRA    BA08
0BA0C:  MOVWF  FAD
....................    } 
0BA0E:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04E4C:  MOVLW  40
04E4E:  MOVWF  FF6
04E50:  MOVLW  0C
04E52:  MOVWF  FF7
04E54:  MOVLW  00
04E56:  MOVWF  FF8
04E58:  CLRF   1B
04E5A:  BTFSC  FF2.7
04E5C:  BSF    1B.7
04E5E:  BCF    FF2.7
04E60:  CALL   0DCC
04E64:  BTFSC  1B.7
04E66:  BSF    FF2.7
....................    if (status & FR_OK) 
04E68:  ANDLW  00
04E6A:  BZ    4E88
....................       printf("   NoError\r\n"); 
04E6C:  MOVLW  50
04E6E:  MOVWF  FF6
04E70:  MOVLW  0C
04E72:  MOVWF  FF7
04E74:  MOVLW  00
04E76:  MOVWF  FF8
04E78:  CLRF   1B
04E7A:  BTFSC  FF2.7
04E7C:  BSF    1B.7
04E7E:  BCF    FF2.7
04E80:  CALL   0DCC
04E84:  BTFSC  1B.7
04E86:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04E88:  MOVLB  8
04E8A:  BTFSS  x74.0
04E8C:  BRA    4EAE
....................       printf("   Media Not Ready\r\n"); 
04E8E:  MOVLW  5E
04E90:  MOVWF  FF6
04E92:  MOVLW  0C
04E94:  MOVWF  FF7
04E96:  MOVLW  00
04E98:  MOVWF  FF8
04E9A:  CLRF   1B
04E9C:  BTFSC  FF2.7
04E9E:  BSF    1B.7
04EA0:  BCF    FF2.7
04EA2:  MOVLB  0
04EA4:  CALL   0DCC
04EA8:  BTFSC  1B.7
04EAA:  BSF    FF2.7
04EAC:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04EAE:  BTFSS  x74.1
04EB0:  BRA    4ED2
....................       printf("   File Not Found\r\n"); 
04EB2:  MOVLW  74
04EB4:  MOVWF  FF6
04EB6:  MOVLW  0C
04EB8:  MOVWF  FF7
04EBA:  MOVLW  00
04EBC:  MOVWF  FF8
04EBE:  CLRF   1B
04EC0:  BTFSC  FF2.7
04EC2:  BSF    1B.7
04EC4:  BCF    FF2.7
04EC6:  MOVLB  0
04EC8:  CALL   0DCC
04ECC:  BTFSC  1B.7
04ECE:  BSF    FF2.7
04ED0:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04ED2:  MOVF   x74,W
04ED4:  ANDLW  03
04ED6:  BZ    4EF8
....................       printf("   Invalid Path\r\n"); 
04ED8:  MOVLW  88
04EDA:  MOVWF  FF6
04EDC:  MOVLW  0C
04EDE:  MOVWF  FF7
04EE0:  MOVLW  00
04EE2:  MOVWF  FF8
04EE4:  CLRF   1B
04EE6:  BTFSC  FF2.7
04EE8:  BSF    1B.7
04EEA:  BCF    FF2.7
04EEC:  MOVLB  0
04EEE:  CALL   0DCC
04EF2:  BTFSC  1B.7
04EF4:  BSF    FF2.7
04EF6:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04EF8:  BTFSS  x74.2
04EFA:  BRA    4F1C
....................       printf("   Invalid Name\r\n"); 
04EFC:  MOVLW  9A
04EFE:  MOVWF  FF6
04F00:  MOVLW  0C
04F02:  MOVWF  FF7
04F04:  MOVLW  00
04F06:  MOVWF  FF8
04F08:  CLRF   1B
04F0A:  BTFSC  FF2.7
04F0C:  BSF    1B.7
04F0E:  BCF    FF2.7
04F10:  MOVLB  0
04F12:  CALL   0DCC
04F16:  BTFSC  1B.7
04F18:  BSF    FF2.7
04F1A:  MOVLB  8
....................    if (status & FR_DENIED) 
04F1C:  MOVF   x74,W
04F1E:  ANDLW  05
04F20:  BZ    4F42
....................       printf("   Access Denied\r\n"); 
04F22:  MOVLW  AC
04F24:  MOVWF  FF6
04F26:  MOVLW  0C
04F28:  MOVWF  FF7
04F2A:  MOVLW  00
04F2C:  MOVWF  FF8
04F2E:  CLRF   1B
04F30:  BTFSC  FF2.7
04F32:  BSF    1B.7
04F34:  BCF    FF2.7
04F36:  MOVLB  0
04F38:  CALL   0DCC
04F3C:  BTFSC  1B.7
04F3E:  BSF    FF2.7
04F40:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04F42:  MOVF   x74,W
04F44:  ANDLW  06
04F46:  BZ    4F68
....................       printf("   Disk Full\r\n"); 
04F48:  MOVLW  C0
04F4A:  MOVWF  FF6
04F4C:  MOVLW  0C
04F4E:  MOVWF  FF7
04F50:  MOVLW  00
04F52:  MOVWF  FF8
04F54:  CLRF   1B
04F56:  BTFSC  FF2.7
04F58:  BSF    1B.7
04F5A:  BCF    FF2.7
04F5C:  MOVLB  0
04F5E:  CALL   0DCC
04F62:  BTFSC  1B.7
04F64:  BSF    FF2.7
04F66:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04F68:  MOVF   x74,W
04F6A:  ANDLW  07
04F6C:  BZ    4F8E
....................       printf("   Read/Write Error\r\n"); 
04F6E:  MOVLW  D0
04F70:  MOVWF  FF6
04F72:  MOVLW  0C
04F74:  MOVWF  FF7
04F76:  MOVLW  00
04F78:  MOVWF  FF8
04F7A:  CLRF   1B
04F7C:  BTFSC  FF2.7
04F7E:  BSF    1B.7
04F80:  BCF    FF2.7
04F82:  MOVLB  0
04F84:  CALL   0DCC
04F88:  BTFSC  1B.7
04F8A:  BSF    FF2.7
04F8C:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04F8E:  MOVF   x74,W
04F90:  ANDLW  09
04F92:  BZ    4FB4
....................       printf("   Incorrect Media Change\r\n"); 
04F94:  MOVLW  E6
04F96:  MOVWF  FF6
04F98:  MOVLW  0C
04F9A:  MOVWF  FF7
04F9C:  MOVLW  00
04F9E:  MOVWF  FF8
04FA0:  CLRF   1B
04FA2:  BTFSC  FF2.7
04FA4:  BSF    1B.7
04FA6:  BCF    FF2.7
04FA8:  MOVLB  0
04FAA:  CALL   0DCC
04FAE:  BTFSC  1B.7
04FB0:  BSF    FF2.7
04FB2:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04FB4:  MOVF   x74,W
04FB6:  ANDLW  0A
04FB8:  BZ    4FDA
....................       printf("   Write Protected\r\n"); 
04FBA:  MOVLW  02
04FBC:  MOVWF  FF6
04FBE:  MOVLW  0D
04FC0:  MOVWF  FF7
04FC2:  MOVLW  00
04FC4:  MOVWF  FF8
04FC6:  CLRF   1B
04FC8:  BTFSC  FF2.7
04FCA:  BSF    1B.7
04FCC:  BCF    FF2.7
04FCE:  MOVLB  0
04FD0:  CALL   0DCC
04FD4:  BTFSC  1B.7
04FD6:  BSF    FF2.7
04FD8:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04FDA:  MOVF   x74,W
04FDC:  ANDLW  0B
04FDE:  BZ    5000
....................       printf("   Not Enabled\r\n"); 
04FE0:  MOVLW  18
04FE2:  MOVWF  FF6
04FE4:  MOVLW  0D
04FE6:  MOVWF  FF7
04FE8:  MOVLW  00
04FEA:  MOVWF  FF8
04FEC:  CLRF   1B
04FEE:  BTFSC  FF2.7
04FF0:  BSF    1B.7
04FF2:  BCF    FF2.7
04FF4:  MOVLB  0
04FF6:  CALL   0DCC
04FFA:  BTFSC  1B.7
04FFC:  BSF    FF2.7
04FFE:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
05000:  MOVF   x74,W
05002:  ANDLW  0C
05004:  BZ    5026
....................       printf("   No File System\r\n"); 
05006:  MOVLW  2A
05008:  MOVWF  FF6
0500A:  MOVLW  0D
0500C:  MOVWF  FF7
0500E:  MOVLW  00
05010:  MOVWF  FF8
05012:  CLRF   1B
05014:  BTFSC  FF2.7
05016:  BSF    1B.7
05018:  BCF    FF2.7
0501A:  MOVLB  0
0501C:  CALL   0DCC
05020:  BTFSC  1B.7
05022:  BSF    FF2.7
05024:  MOVLB  8
05026:  MOVLB  0
05028:  GOTO   50B2 (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
08338:  MOVLW  08
0833A:  MOVWF  FEA
0833C:  MOVLW  FA
0833E:  MOVWF  FE9
08340:  CLRF   00
08342:  CLRF   02
08344:  MOVLW  A0
08346:  MOVWF  01
08348:  CALL   3588
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
0834C:  MOVLW  08
0834E:  MOVLB  9
08350:  MOVWF  x9B
08352:  MOVLW  D9
08354:  MOVWF  x9A
08356:  MOVFF  8D8,99D
0835A:  MOVFF  8D7,99C
0835E:  MOVLW  12
08360:  MOVWF  x9E
08362:  MOVLB  0
08364:  CALL   719E
08368:  MOVFF  01,8F5
....................    if (result) 
0836C:  MOVLB  8
0836E:  MOVF   xF5,F
08370:  BZ    8394
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
08372:  MOVLW  3E
08374:  MOVWF  FF6
08376:  MOVLW  0D
08378:  MOVWF  FF7
0837A:  MOVLW  00
0837C:  MOVWF  FF8
0837E:  CLRF   1B
08380:  BTFSC  FF2.7
08382:  BSF    1B.7
08384:  BCF    FF2.7
08386:  MOVLB  0
08388:  CALL   0DCC
0838C:  BTFSC  1B.7
0838E:  BSF    FF2.7
....................    } 
08390:  BRA    8510
08392:  MOVLB  8
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
08394:  MOVF   xDD,F
08396:  BNZ   83A4
08398:  MOVF   xDE,F
0839A:  BNZ   83A4
0839C:  MOVF   xDF,F
0839E:  BNZ   83A4
083A0:  MOVF   xE0,F
083A2:  BZ    83CA
....................          result = f_lseek(&fdst, fdst.fsize);  
083A4:  MOVLW  08
083A6:  MOVLB  9
083A8:  MOVWF  x9B
083AA:  MOVLW  D9
083AC:  MOVWF  x9A
083AE:  MOVFF  8E0,99F
083B2:  MOVFF  8DF,99E
083B6:  MOVFF  8DE,99D
083BA:  MOVFF  8DD,99C
083BE:  MOVLB  0
083C0:  GOTO   75E6
083C4:  MOVFF  01,8F5
083C8:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
083CA:  MOVLB  0
083CC:  MOVF   x62,F
083CE:  BNZ   83EC
083D0:  MOVLW  08
083D2:  MOVLB  9
083D4:  MOVWF  x9B
083D6:  MOVLW  FA
083D8:  MOVWF  x9A
083DA:  CLRF   x9D
083DC:  MOVLW  63
083DE:  MOVWF  x9C
083E0:  CLRF   x9F
083E2:  MOVLW  9F
083E4:  MOVWF  x9E
083E6:  MOVLB  0
083E8:  CALL   794E
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
083EC:  DECFSZ x62,W
083EE:  BRA    840E
083F0:  MOVLW  08
083F2:  MOVLB  9
083F4:  MOVWF  x9B
083F6:  MOVLW  FA
083F8:  MOVWF  x9A
083FA:  MOVLW  01
083FC:  MOVWF  x9D
083FE:  MOVLW  03
08400:  MOVWF  x9C
08402:  CLRF   x9F
08404:  MOVLW  9F
08406:  MOVWF  x9E
08408:  MOVLB  0
0840A:  CALL   794E
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
0840E:  MOVF   20,F
08410:  BNZ   8418
08412:  MOVF   1F,W
08414:  SUBLW  04
08416:  BC    846C
08418:  MOVLW  5E
0841A:  MOVWF  FF6
0841C:  MOVLW  0D
0841E:  MOVWF  FF7
08420:  MOVLW  00
08422:  MOVWF  FF8
08424:  CLRF   1B
08426:  BTFSC  FF2.7
08428:  BSF    1B.7
0842A:  BCF    FF2.7
0842C:  MOVLW  0E
0842E:  MOVLB  A
08430:  MOVWF  x25
08432:  MOVLB  0
08434:  CALL   101E
08438:  BTFSC  1B.7
0843A:  BSF    FF2.7
0843C:  MOVLW  08
0843E:  MOVWF  FEA
08440:  MOVLW  FA
08442:  MOVWF  FE9
08444:  CALL   79DC
08448:  MOVLW  6E
0844A:  MOVWF  FF6
0844C:  MOVLW  0D
0844E:  MOVWF  FF7
08450:  MOVLW  00
08452:  MOVWF  FF8
08454:  CLRF   1B
08456:  BTFSC  FF2.7
08458:  BSF    1B.7
0845A:  BCF    FF2.7
0845C:  MOVLW  03
0845E:  MOVLB  A
08460:  MOVWF  x25
08462:  MOVLB  0
08464:  CALL   101E
08468:  BTFSC  1B.7
0846A:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
0846C:  MOVLW  08
0846E:  MOVLB  9
08470:  MOVWF  x9B
08472:  MOVLW  FA
08474:  MOVWF  x9A
08476:  MOVLB  0
08478:  GOTO   7A02
0847C:  MOVFF  02,8F7
08480:  MOVFF  01,8F6
....................       result = f_write(&fdst, mesg, btw, &bw); 
08484:  MOVLW  08
08486:  MOVLB  9
08488:  MOVWF  x9B
0848A:  MOVLW  D9
0848C:  MOVWF  x9A
0848E:  MOVLW  08
08490:  MOVWF  x9D
08492:  MOVLW  FA
08494:  MOVWF  x9C
08496:  MOVFF  8F7,99F
0849A:  MOVFF  8F6,99E
0849E:  MOVLW  08
084A0:  MOVWF  xA1
084A2:  MOVLW  F8
084A4:  MOVWF  xA0
084A6:  MOVLB  0
084A8:  GOTO   7A40
084AC:  MOVFF  01,8F5
....................       if (result) 
084B0:  MOVLB  8
084B2:  MOVF   xF5,F
084B4:  BZ    84D8
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
084B6:  MOVLW  72
084B8:  MOVWF  FF6
084BA:  MOVLW  0D
084BC:  MOVWF  FF7
084BE:  MOVLW  00
084C0:  MOVWF  FF8
084C2:  CLRF   1B
084C4:  BTFSC  FF2.7
084C6:  BSF    1B.7
084C8:  BCF    FF2.7
084CA:  MOVLB  0
084CC:  CALL   0DCC
084D0:  BTFSC  1B.7
084D2:  BSF    FF2.7
....................       } 
084D4:  BRA    8500
084D6:  MOVLB  8
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
084D8:  MOVF   20,F
084DA:  BNZ   84E2
084DC:  MOVF   1F,W
084DE:  SUBLW  04
084E0:  BC    8502
084E2:  MOVLW  86
084E4:  MOVWF  FF6
084E6:  MOVLW  0D
084E8:  MOVWF  FF7
084EA:  MOVLW  00
084EC:  MOVWF  FF8
084EE:  CLRF   1B
084F0:  BTFSC  FF2.7
084F2:  BSF    1B.7
084F4:  BCF    FF2.7
084F6:  MOVLB  0
084F8:  CALL   0DCC
084FC:  BTFSC  1B.7
084FE:  BSF    FF2.7
08500:  MOVLB  8
....................       } 
....................  
....................       f_close(&fdst); 
08502:  MOVLW  08
08504:  MOVLB  9
08506:  MOVWF  x9B
08508:  MOVLW  D9
0850A:  MOVWF  x9A
0850C:  MOVLB  0
0850E:  RCALL  82EC
....................    } 
....................  
....................    return (result); 
08510:  MOVLB  8
08512:  MOVFF  8F5,01
08516:  MOVLB  0
08518:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
176F8:  CLRF   1B
176FA:  BTFSC  FF2.7
176FC:  BSF    1B.7
176FE:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
17700:  MOVFF  871,A27
17704:  MOVLW  0A
17706:  MOVLB  A
17708:  MOVWF  x28
1770A:  MOVLB  0
1770C:  CALL   0F74
17710:  BTFSC  1B.7
17712:  BSF    FF2.7
17714:  MOVFF  01,872
....................    nibl=data-(nibh*10); 
17718:  MOVLB  8
1771A:  MOVF   x72,W
1771C:  MULLW  0A
1771E:  MOVF   FF3,W
17720:  SUBWF  x71,W
17722:  MOVWF  x73
....................  
....................    return((nibh<<4)|nibl); 
17724:  SWAPF  x72,W
17726:  MOVWF  00
17728:  MOVLW  F0
1772A:  ANDWF  00,F
1772C:  MOVF   00,W
1772E:  IORWF  x73,W
17730:  MOVWF  01
17732:  MOVLB  0
17734:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
03374:  MOVFF  8D8,8D9
....................    data=(i>>4)*10; 
03378:  MOVLB  8
0337A:  SWAPF  xD9,W
0337C:  MOVWF  00
0337E:  MOVLW  0F
03380:  ANDWF  00,F
03382:  MOVF   00,W
03384:  MULLW  0A
03386:  MOVFF  FF3,8D8
....................    data=data+(i<<4>>4); 
0338A:  SWAPF  xD9,W
0338C:  MOVWF  00
0338E:  MOVLW  F0
03390:  ANDWF  00,F
03392:  MOVF   00,W
03394:  SWAPF  00,F
03396:  MOVLW  0F
03398:  ANDWF  00,F
0339A:  MOVF   00,W
0339C:  ADDWF  xD8,F
....................  
....................    return data; 
0339E:  MOVFF  8D8,01
033A2:  MOVLB  0
033A4:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03514:  MOVLB  8
03516:  CLRF   xB5
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
03518:  BCF    FC6.5
0351A:  MOVLW  21
0351C:  MOVWF  FC6
0351E:  MOVLW  40
03520:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
03522:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
03524:  MOVF   FC9,W
03526:  MOVLW  0C
03528:  MOVWF  FC9
0352A:  RRCF   FC7,W
0352C:  BNC   352A
0352E:  MOVFF  FC9,8B5
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
03532:  MOVF   FC9,W
03534:  MOVFF  8B5,FC9
03538:  RRCF   FC7,W
0353A:  BNC   3538
0353C:  MOVFF  FC9,72C
....................    output_bit(RTC_CS, DISABLE); 
03540:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
03542:  MOVLB  7
03544:  BCF    x2C.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
03546:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
03548:  MOVF   FC9,W
0354A:  MOVLW  8C
0354C:  MOVWF  FC9
0354E:  RRCF   FC7,W
03550:  BNC   354E
03552:  MOVFF  FC9,8B5
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
03556:  MOVF   FC9,W
03558:  MOVFF  72C,FC9
0355C:  RRCF   FC7,W
0355E:  BNC   355C
03560:  MOVFF  FC9,8B5
....................    output_bit(RTC_CS, DISABLE); 
03564:  BSF    F91.0
03566:  MOVLB  0
03568:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0E00C:  MOVLW  1A
0E00E:  MOVLB  8
0E010:  MOVWF  x81
0E012:  MOVLB  0
0E014:  CALL   2A2C
0E018:  MOVFF  01,4B
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0E01C:  MOVF   4B,F
0E01E:  BNZ   E08C
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0E020:  MOVLW  94
0E022:  MOVWF  FF6
0E024:  MOVLW  0D
0E026:  MOVWF  FF7
0E028:  MOVLW  00
0E02A:  MOVWF  FF8
0E02C:  CLRF   1B
0E02E:  BTFSC  FF2.7
0E030:  BSF    1B.7
0E032:  BCF    FF2.7
0E034:  MOVLW  05
0E036:  MOVLB  A
0E038:  MOVWF  x25
0E03A:  MOVLB  0
0E03C:  CALL   101E
0E040:  BTFSC  1B.7
0E042:  BSF    FF2.7
0E044:  CLRF   1B
0E046:  BTFSC  FF2.7
0E048:  BSF    1B.7
0E04A:  BCF    FF2.7
0E04C:  MOVFF  726,A25
0E050:  MOVLW  01
0E052:  MOVLB  A
0E054:  MOVWF  x26
0E056:  MOVLB  0
0E058:  CALL   0FA0
0E05C:  BTFSC  1B.7
0E05E:  BSF    FF2.7
0E060:  MOVLW  2F
0E062:  BTFSS  F9E.4
0E064:  BRA    E062
0E066:  MOVWF  FAD
0E068:  CLRF   1B
0E06A:  BTFSC  FF2.7
0E06C:  BSF    1B.7
0E06E:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0E070:  MOVFF  725,A25
0E074:  MOVLW  01
0E076:  MOVLB  A
0E078:  MOVWF  x26
0E07A:  MOVLB  0
0E07C:  CALL   0FA0
0E080:  BTFSC  1B.7
0E082:  BSF    FF2.7
0E084:  MOVLW  2F
0E086:  BTFSS  F9E.4
0E088:  BRA    E086
0E08A:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E08C:  DECFSZ 4B,W
0E08E:  BRA    E0FC
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E090:  MOVLW  A0
0E092:  MOVWF  FF6
0E094:  MOVLW  0D
0E096:  MOVWF  FF7
0E098:  MOVLW  00
0E09A:  MOVWF  FF8
0E09C:  CLRF   1B
0E09E:  BTFSC  FF2.7
0E0A0:  BSF    1B.7
0E0A2:  BCF    FF2.7
0E0A4:  MOVLW  05
0E0A6:  MOVLB  A
0E0A8:  MOVWF  x25
0E0AA:  MOVLB  0
0E0AC:  CALL   101E
0E0B0:  BTFSC  1B.7
0E0B2:  BSF    FF2.7
0E0B4:  CLRF   1B
0E0B6:  BTFSC  FF2.7
0E0B8:  BSF    1B.7
0E0BA:  BCF    FF2.7
0E0BC:  MOVFF  725,A25
0E0C0:  MOVLW  01
0E0C2:  MOVLB  A
0E0C4:  MOVWF  x26
0E0C6:  MOVLB  0
0E0C8:  CALL   0FA0
0E0CC:  BTFSC  1B.7
0E0CE:  BSF    FF2.7
0E0D0:  MOVLW  2F
0E0D2:  BTFSS  F9E.4
0E0D4:  BRA    E0D2
0E0D6:  MOVWF  FAD
0E0D8:  CLRF   1B
0E0DA:  BTFSC  FF2.7
0E0DC:  BSF    1B.7
0E0DE:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E0E0:  MOVFF  726,A25
0E0E4:  MOVLW  01
0E0E6:  MOVLB  A
0E0E8:  MOVWF  x26
0E0EA:  MOVLB  0
0E0EC:  CALL   0FA0
0E0F0:  BTFSC  1B.7
0E0F2:  BSF    FF2.7
0E0F4:  MOVLW  2F
0E0F6:  BTFSS  F9E.4
0E0F8:  BRA    E0F6
0E0FA:  MOVWF  FAD
0E0FC:  CLRF   1B
0E0FE:  BTFSC  FF2.7
0E100:  BSF    1B.7
0E102:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E104:  MOVFF  727,A25
0E108:  MOVLW  01
0E10A:  MOVLB  A
0E10C:  MOVWF  x26
0E10E:  MOVLB  0
0E110:  CALL   0FA0
0E114:  BTFSC  1B.7
0E116:  BSF    FF2.7
0E118:  MOVLW  20
0E11A:  BTFSS  F9E.4
0E11C:  BRA    E11A
0E11E:  MOVWF  FAD
0E120:  CLRF   1B
0E122:  BTFSC  FF2.7
0E124:  BSF    1B.7
0E126:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E128:  MOVFF  723,A25
0E12C:  MOVLW  01
0E12E:  MOVLB  A
0E130:  MOVWF  x26
0E132:  MOVLB  0
0E134:  CALL   0FA0
0E138:  BTFSC  1B.7
0E13A:  BSF    FF2.7
0E13C:  MOVLW  3A
0E13E:  BTFSS  F9E.4
0E140:  BRA    E13E
0E142:  MOVWF  FAD
0E144:  CLRF   1B
0E146:  BTFSC  FF2.7
0E148:  BSF    1B.7
0E14A:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E14C:  MOVFF  722,A25
0E150:  MOVLW  01
0E152:  MOVLB  A
0E154:  MOVWF  x26
0E156:  MOVLB  0
0E158:  CALL   0FA0
0E15C:  BTFSC  1B.7
0E15E:  BSF    FF2.7
0E160:  MOVLW  3A
0E162:  BTFSS  F9E.4
0E164:  BRA    E162
0E166:  MOVWF  FAD
0E168:  CLRF   1B
0E16A:  BTFSC  FF2.7
0E16C:  BSF    1B.7
0E16E:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E170:  MOVFF  721,A25
0E174:  MOVLW  01
0E176:  MOVLB  A
0E178:  MOVWF  x26
0E17A:  MOVLB  0
0E17C:  CALL   0FA0
0E180:  BTFSC  1B.7
0E182:  BSF    FF2.7
0E184:  MOVLW  0A
0E186:  BTFSS  F9E.4
0E188:  BRA    E186
0E18A:  MOVWF  FAD
0E18C:  MOVLW  0D
0E18E:  BTFSS  F9E.4
0E190:  BRA    E18E
0E192:  MOVWF  FAD
0E194:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
033A6:  MOVLB  8
033A8:  CLRF   xD7
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
033AA:  BCF    FC6.5
033AC:  MOVLW  21
033AE:  MOVWF  FC6
033B0:  MOVLW  40
033B2:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
033B4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
033B6:  MOVF   FC9,W
033B8:  CLRF   FC9
033BA:  RRCF   FC7,W
033BC:  BNC   33BA
033BE:  MOVFF  FC9,8D7
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
033C2:  MOVF   FC9,W
033C4:  MOVFF  8D7,FC9
033C8:  RRCF   FC7,W
033CA:  BNC   33C8
033CC:  MOVFF  FC9,728
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
033D0:  MOVF   FC9,W
033D2:  MOVFF  8D7,FC9
033D6:  RRCF   FC7,W
033D8:  BNC   33D6
033DA:  MOVFF  FC9,721
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
033DE:  MOVF   FC9,W
033E0:  MOVFF  8D7,FC9
033E4:  RRCF   FC7,W
033E6:  BNC   33E4
033E8:  MOVFF  FC9,722
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
033EC:  MOVF   FC9,W
033EE:  MOVFF  8D7,FC9
033F2:  RRCF   FC7,W
033F4:  BNC   33F2
033F6:  MOVFF  FC9,723
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
033FA:  MOVF   FC9,W
033FC:  MOVFF  8D7,FC9
03400:  RRCF   FC7,W
03402:  BNC   3400
03404:  MOVFF  FC9,724
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
03408:  MOVF   FC9,W
0340A:  MOVFF  8D7,FC9
0340E:  RRCF   FC7,W
03410:  BNC   340E
03412:  MOVFF  FC9,725
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
03416:  MOVF   FC9,W
03418:  MOVFF  8D7,FC9
0341C:  RRCF   FC7,W
0341E:  BNC   341C
03420:  MOVFF  FC9,726
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
03424:  MOVF   FC9,W
03426:  MOVFF  8D7,FC9
0342A:  RRCF   FC7,W
0342C:  BNC   342A
0342E:  MOVFF  FC9,727
....................    output_bit(RTC_CS, DISABLE); 
03432:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
03434:  MOVFF  721,8D8
03438:  MOVLB  0
0343A:  RCALL  3374
0343C:  MOVFF  01,721
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
03440:  MOVFF  722,8D8
03444:  RCALL  3374
03446:  MOVFF  01,722
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
0344A:  MOVFF  723,8D8
0344E:  RCALL  3374
03450:  MOVFF  01,723
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
03454:  MOVFF  725,8D8
03458:  RCALL  3374
0345A:  MOVFF  01,725
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
0345E:  MOVFF  726,8D8
03462:  RCALL  3374
03464:  MOVFF  01,726
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
03468:  MOVFF  727,8D8
0346C:  RCALL  3374
0346E:  MOVFF  01,727
03472:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DF6:  MOVLB  A
00DF8:  CLRF   x1C
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DFA:  BCF    FC6.5
00DFC:  MOVLW  21
00DFE:  MOVWF  FC6
00E00:  MOVLW  40
00E02:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00E04:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00E06:  MOVF   FC9,W
00E08:  MOVLW  0F
00E0A:  MOVWF  FC9
00E0C:  RRCF   FC7,W
00E0E:  BNC   0E0C
00E10:  MOVFF  FC9,A1C
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00E14:  MOVF   FC9,W
00E16:  MOVFF  A1C,FC9
00E1A:  RRCF   FC7,W
00E1C:  BNC   0E1A
00E1E:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
00E22:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00E24:  BCF    49.2
00E26:  MOVLB  0
00E28:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E26C:  MOVF   4B,F
0E26E:  BNZ   E2DC
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E270:  MOVLW  AC
0E272:  MOVWF  FF6
0E274:  MOVLW  0D
0E276:  MOVWF  FF7
0E278:  MOVLW  00
0E27A:  MOVWF  FF8
0E27C:  CLRF   1B
0E27E:  BTFSC  FF2.7
0E280:  BSF    1B.7
0E282:  BCF    FF2.7
0E284:  MOVLW  05
0E286:  MOVLB  A
0E288:  MOVWF  x25
0E28A:  MOVLB  0
0E28C:  CALL   101E
0E290:  BTFSC  1B.7
0E292:  BSF    FF2.7
0E294:  CLRF   1B
0E296:  BTFSC  FF2.7
0E298:  BSF    1B.7
0E29A:  BCF    FF2.7
0E29C:  MOVFF  72A,A25
0E2A0:  MOVLW  01
0E2A2:  MOVLB  A
0E2A4:  MOVWF  x26
0E2A6:  MOVLB  0
0E2A8:  CALL   0FA0
0E2AC:  BTFSC  1B.7
0E2AE:  BSF    FF2.7
0E2B0:  MOVLW  2F
0E2B2:  BTFSS  F9E.4
0E2B4:  BRA    E2B2
0E2B6:  MOVWF  FAD
0E2B8:  CLRF   1B
0E2BA:  BTFSC  FF2.7
0E2BC:  BSF    1B.7
0E2BE:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E2C0:  MOVFF  72B,A25
0E2C4:  MOVLW  01
0E2C6:  MOVLB  A
0E2C8:  MOVWF  x26
0E2CA:  MOVLB  0
0E2CC:  CALL   0FA0
0E2D0:  BTFSC  1B.7
0E2D2:  BSF    FF2.7
0E2D4:  MOVLW  2F
0E2D6:  BTFSS  F9E.4
0E2D8:  BRA    E2D6
0E2DA:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E2DC:  DECFSZ 4B,W
0E2DE:  BRA    E34C
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E2E0:  MOVLW  B8
0E2E2:  MOVWF  FF6
0E2E4:  MOVLW  0D
0E2E6:  MOVWF  FF7
0E2E8:  MOVLW  00
0E2EA:  MOVWF  FF8
0E2EC:  CLRF   1B
0E2EE:  BTFSC  FF2.7
0E2F0:  BSF    1B.7
0E2F2:  BCF    FF2.7
0E2F4:  MOVLW  05
0E2F6:  MOVLB  A
0E2F8:  MOVWF  x25
0E2FA:  MOVLB  0
0E2FC:  CALL   101E
0E300:  BTFSC  1B.7
0E302:  BSF    FF2.7
0E304:  CLRF   1B
0E306:  BTFSC  FF2.7
0E308:  BSF    1B.7
0E30A:  BCF    FF2.7
0E30C:  MOVFF  72B,A25
0E310:  MOVLW  01
0E312:  MOVLB  A
0E314:  MOVWF  x26
0E316:  MOVLB  0
0E318:  CALL   0FA0
0E31C:  BTFSC  1B.7
0E31E:  BSF    FF2.7
0E320:  MOVLW  2F
0E322:  BTFSS  F9E.4
0E324:  BRA    E322
0E326:  MOVWF  FAD
0E328:  CLRF   1B
0E32A:  BTFSC  FF2.7
0E32C:  BSF    1B.7
0E32E:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E330:  MOVFF  72A,A25
0E334:  MOVLW  01
0E336:  MOVLB  A
0E338:  MOVWF  x26
0E33A:  MOVLB  0
0E33C:  CALL   0FA0
0E340:  BTFSC  1B.7
0E342:  BSF    FF2.7
0E344:  MOVLW  2F
0E346:  BTFSS  F9E.4
0E348:  BRA    E346
0E34A:  MOVWF  FAD
0E34C:  CLRF   1B
0E34E:  BTFSC  FF2.7
0E350:  BSF    1B.7
0E352:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E354:  MOVFF  729,A25
0E358:  MOVLW  01
0E35A:  MOVLB  A
0E35C:  MOVWF  x26
0E35E:  MOVLB  0
0E360:  CALL   0FA0
0E364:  BTFSC  1B.7
0E366:  BSF    FF2.7
0E368:  MOVLW  20
0E36A:  BTFSS  F9E.4
0E36C:  BRA    E36A
0E36E:  MOVWF  FAD
0E370:  CLRF   1B
0E372:  BTFSC  FF2.7
0E374:  BSF    1B.7
0E376:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E378:  MOVFF  72C,A25
0E37C:  MOVLW  01
0E37E:  MOVLB  A
0E380:  MOVWF  x26
0E382:  MOVLB  0
0E384:  CALL   0FA0
0E388:  BTFSC  1B.7
0E38A:  BSF    FF2.7
0E38C:  MOVLW  3A
0E38E:  BTFSS  F9E.4
0E390:  BRA    E38E
0E392:  MOVWF  FAD
0E394:  CLRF   1B
0E396:  BTFSC  FF2.7
0E398:  BSF    1B.7
0E39A:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E39C:  MOVFF  72D,A25
0E3A0:  MOVLW  01
0E3A2:  MOVLB  A
0E3A4:  MOVWF  x26
0E3A6:  MOVLB  0
0E3A8:  CALL   0FA0
0E3AC:  BTFSC  1B.7
0E3AE:  BSF    FF2.7
0E3B0:  MOVLW  3A
0E3B2:  BTFSS  F9E.4
0E3B4:  BRA    E3B2
0E3B6:  MOVWF  FAD
0E3B8:  CLRF   1B
0E3BA:  BTFSC  FF2.7
0E3BC:  BSF    1B.7
0E3BE:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E3C0:  MOVFF  72E,A25
0E3C4:  MOVLW  01
0E3C6:  MOVLB  A
0E3C8:  MOVWF  x26
0E3CA:  MOVLB  0
0E3CC:  CALL   0FA0
0E3D0:  BTFSC  1B.7
0E3D2:  BSF    FF2.7
0E3D4:  MOVLW  0A
0E3D6:  BTFSS  F9E.4
0E3D8:  BRA    E3D6
0E3DA:  MOVWF  FAD
0E3DC:  MOVLW  0D
0E3DE:  BTFSS  F9E.4
0E3E0:  BRA    E3DE
0E3E2:  MOVWF  FAD
0E3E4:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E196:  MOVLB  8
0E198:  CLRF   xA1
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E19A:  BCF    FC6.5
0E19C:  MOVLW  21
0E19E:  MOVWF  FC6
0E1A0:  MOVLW  40
0E1A2:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E1A4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E1A6:  MOVF   FC9,W
0E1A8:  MOVLW  0A
0E1AA:  MOVWF  FC9
0E1AC:  RRCF   FC7,W
0E1AE:  BNC   E1AC
0E1B0:  MOVFF  FC9,8A1
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E1B4:  MOVF   FC9,W
0E1B6:  MOVFF  8A1,FC9
0E1BA:  RRCF   FC7,W
0E1BC:  BNC   E1BA
0E1BE:  MOVFF  FC9,72A
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E1C2:  MOVF   FC9,W
0E1C4:  MOVFF  8A1,FC9
0E1C8:  RRCF   FC7,W
0E1CA:  BNC   E1C8
0E1CC:  MOVFF  FC9,72B
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E1D0:  MOVF   FC9,W
0E1D2:  MOVFF  8A1,FC9
0E1D6:  RRCF   FC7,W
0E1D8:  BNC   E1D6
0E1DA:  MOVFF  FC9,72C
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E1DE:  MOVF   FC9,W
0E1E0:  MOVFF  8A1,FC9
0E1E4:  RRCF   FC7,W
0E1E6:  BNC   E1E4
0E1E8:  MOVFF  FC9,72D
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E1EC:  MOVF   FC9,W
0E1EE:  MOVFF  8A1,FC9
0E1F2:  RRCF   FC7,W
0E1F4:  BNC   E1F2
0E1F6:  MOVFF  FC9,72E
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E1FA:  MOVF   FC9,W
0E1FC:  MOVFF  8A1,FC9
0E200:  RRCF   FC7,W
0E202:  BNC   E200
0E204:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
0E208:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E20A:  MOVLW  1F
0E20C:  MOVLB  7
0E20E:  ANDWF  x2A,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E210:  MOVFF  72A,8D8
0E214:  MOVLB  0
0E216:  CALL   3374
0E21A:  MOVFF  01,72A
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E21E:  MOVLW  3F
0E220:  MOVLB  7
0E222:  ANDWF  x2B,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E224:  MOVFF  72B,8D8
0E228:  MOVLB  0
0E22A:  CALL   3374
0E22E:  MOVFF  01,72B
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E232:  MOVLW  3F
0E234:  MOVLB  7
0E236:  ANDWF  x2C,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E238:  MOVFF  72C,8D8
0E23C:  MOVLB  0
0E23E:  CALL   3374
0E242:  MOVFF  01,72C
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E246:  MOVLB  7
0E248:  BCF    x2D.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E24A:  MOVFF  72D,8D8
0E24E:  MOVLB  0
0E250:  CALL   3374
0E254:  MOVFF  01,72D
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E258:  MOVLB  7
0E25A:  BCF    x2E.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E25C:  MOVFF  72E,8D8
0E260:  MOVLB  0
0E262:  CALL   3374
0E266:  MOVFF  01,72E
0E26A:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
1733E:  MOVLW  08
17340:  MOVWF  FEA
17342:  MOVLW  73
17344:  MOVWF  FE9
17346:  CLRF   00
17348:  CLRF   02
1734A:  MOVLW  0C
1734C:  MOVWF  01
1734E:  CALL   3588
....................  
....................    time_error = 0; 
17352:  MOVLB  8
17354:  CLRF   x7F
....................     
....................    fputc('[', COM_A); 
17356:  MOVLW  5B
17358:  MOVLB  0
1735A:  CALL   AEB4
....................     
....................    for (n=0; n<12; ++n){ 
1735E:  MOVLB  8
17360:  CLRF   x72
17362:  MOVF   x72,W
17364:  SUBLW  0B
17366:  BNC   173AC
....................       c = fgetc(COM_A); 
17368:  MOVLB  0
1736A:  CALL   0E5C
1736E:  MOVFF  01,871
....................       if (com_echo == TRUE) 
17372:  DECFSZ 48,W
17374:  BRA    17380
....................       { 
....................          fputc(c, COM_A); 
17376:  MOVLB  8
17378:  MOVF   x71,W
1737A:  MOVLB  0
1737C:  CALL   AEB4
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
17380:  MOVLB  8
17382:  MOVF   x71,W
17384:  SUBLW  2F
17386:  BC    173A2
17388:  MOVF   x71,W
1738A:  SUBLW  39
1738C:  BNC   173A2
1738E:  CLRF   03
17390:  MOVF   x72,W
17392:  ADDLW  73
17394:  MOVWF  FE9
17396:  MOVLW  08
17398:  ADDWFC 03,W
1739A:  MOVWF  FEA
1739C:  MOVFF  871,FEF
173A0:  BRA    173A8
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
173A2:  MOVLW  01
173A4:  MOVWF  x7F
....................          break; 
173A6:  BRA    173AC
....................       } 
173A8:  INCF   x72,F
173AA:  BRA    17362
....................    } 
....................     
....................    if (time_error == 0){ 
173AC:  MOVF   x7F,F
173AE:  BTFSS  FD8.2
173B0:  BRA    176E8
....................     
....................       fputc(']', COM_A); 
173B2:  MOVLW  5D
173B4:  MOVLB  0
173B6:  CALL   AEB4
....................        
....................       for (n=0; n<12; ++n){ 
173BA:  MOVLB  8
173BC:  CLRF   x72
173BE:  MOVF   x72,W
173C0:  SUBLW  0B
173C2:  BNC   173F4
....................          t_entry[n] = (t_entry[n] - 48); 
173C4:  CLRF   03
173C6:  MOVF   x72,W
173C8:  ADDLW  73
173CA:  MOVWF  01
173CC:  MOVLW  08
173CE:  ADDWFC 03,F
173D0:  MOVFF  03,881
173D4:  CLRF   03
173D6:  MOVF   x72,W
173D8:  ADDLW  73
173DA:  MOVWF  FE9
173DC:  MOVLW  08
173DE:  ADDWFC 03,W
173E0:  MOVWF  FEA
173E2:  MOVLW  30
173E4:  SUBWF  FEF,W
173E6:  MOVFF  881,FEA
173EA:  MOVFF  01,FE9
173EE:  MOVWF  FEF
173F0:  INCF   x72,F
173F2:  BRA    173BE
....................       } 
....................        
....................       if (RTCfmt == 0) 
173F4:  MOVF   4B,F
173F6:  BNZ   17434
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
173F8:  MOVF   x73,W
173FA:  MULLW  0A
173FC:  MOVF   FF3,W
173FE:  ADDWF  x74,W
17400:  MOVLB  7
17402:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17404:  MOVF   x34,F
17406:  BZ    1740E
17408:  MOVF   x34,W
1740A:  SUBLW  0C
1740C:  BC    17416
1740E:  MOVLW  02
17410:  MOVLB  8
17412:  MOVWF  x7F
17414:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
17416:  MOVLB  8
17418:  MOVF   x75,W
1741A:  MULLW  0A
1741C:  MOVF   FF3,W
1741E:  ADDWF  x76,W
17420:  MOVLB  7
17422:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17424:  MOVF   x33,F
17426:  BZ    1742E
17428:  MOVF   x33,W
1742A:  SUBLW  1F
1742C:  BC    17436
1742E:  MOVLW  02
17430:  MOVLB  8
17432:  MOVWF  x7F
17434:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17436:  DECFSZ 4B,W
17438:  BRA    1747A
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
1743A:  MOVLB  8
1743C:  MOVF   x73,W
1743E:  MULLW  0A
17440:  MOVF   FF3,W
17442:  ADDWF  x74,W
17444:  MOVLB  7
17446:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17448:  MOVF   x33,F
1744A:  BZ    17452
1744C:  MOVF   x33,W
1744E:  SUBLW  1F
17450:  BC    1745A
17452:  MOVLW  02
17454:  MOVLB  8
17456:  MOVWF  x7F
17458:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
1745A:  MOVLB  8
1745C:  MOVF   x75,W
1745E:  MULLW  0A
17460:  MOVF   FF3,W
17462:  ADDWF  x76,W
17464:  MOVLB  7
17466:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17468:  MOVF   x34,F
1746A:  BZ    17472
1746C:  MOVF   x34,W
1746E:  SUBLW  0C
17470:  BC    1747A
17472:  MOVLW  02
17474:  MOVLB  8
17476:  MOVWF  x7F
17478:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
1747A:  MOVLB  8
1747C:  MOVF   x77,W
1747E:  MULLW  0A
17480:  MOVF   FF3,W
17482:  ADDWF  x78,W
17484:  MOVLB  7
17486:  MOVWF  x35
....................       if (RTC_Yr_Data > 99) time_error = 2;  
17488:  MOVF   x35,W
1748A:  SUBLW  63
1748C:  BC    17496
1748E:  MOVLW  02
17490:  MOVLB  8
17492:  MOVWF  x7F
17494:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
17496:  MOVLB  8
17498:  MOVF   x79,W
1749A:  MULLW  0A
1749C:  MOVF   FF3,W
1749E:  ADDWF  x7A,W
174A0:  MOVLB  7
174A2:  MOVWF  x32
....................       if (RTC_Hr_Data > 24) time_error = 2;  
174A4:  MOVF   x32,W
174A6:  SUBLW  18
174A8:  BC    174B2
174AA:  MOVLW  02
174AC:  MOVLB  8
174AE:  MOVWF  x7F
174B0:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
174B2:  MOVLB  8
174B4:  MOVF   x7B,W
174B6:  MULLW  0A
174B8:  MOVF   FF3,W
174BA:  ADDWF  x7C,W
174BC:  MOVLB  7
174BE:  MOVWF  x31
....................       if (RTC_Min_Data > 60) time_error = 2;  
174C0:  MOVF   x31,W
174C2:  SUBLW  3C
174C4:  BC    174CE
174C6:  MOVLW  02
174C8:  MOVLB  8
174CA:  MOVWF  x7F
174CC:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
174CE:  MOVLB  8
174D0:  MOVF   x7D,W
174D2:  MULLW  0A
174D4:  MOVF   FF3,W
174D6:  ADDWF  x7E,W
174D8:  MOVLB  7
174DA:  MOVWF  x30
....................       if (RTC_Sec_Data > 60) time_error = 2; 
174DC:  MOVF   x30,W
174DE:  SUBLW  3C
174E0:  BC    174EA
174E2:  MOVLW  02
174E4:  MOVLB  8
174E6:  MOVWF  x7F
174E8:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
174EA:  MOVF   4B,F
174EC:  BTFSS  FD8.2
174EE:  BRA    175E2
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
174F0:  MOVLW  0A
174F2:  BTFSS  F9E.4
174F4:  BRA    174F2
174F6:  MOVWF  FAD
174F8:  MOVLW  0D
174FA:  BTFSS  F9E.4
174FC:  BRA    174FA
174FE:  MOVWF  FAD
17500:  CLRF   1B
17502:  BTFSC  FF2.7
17504:  BSF    1B.7
17506:  BCF    FF2.7
17508:  MOVFF  734,A25
1750C:  MOVLW  01
1750E:  MOVLB  A
17510:  MOVWF  x26
17512:  MOVLB  0
17514:  CALL   0FA0
17518:  BTFSC  1B.7
1751A:  BSF    FF2.7
1751C:  MOVLW  2F
1751E:  BTFSS  F9E.4
17520:  BRA    1751E
17522:  MOVWF  FAD
17524:  CLRF   1B
17526:  BTFSC  FF2.7
17528:  BSF    1B.7
1752A:  BCF    FF2.7
1752C:  MOVFF  733,A25
17530:  MOVLW  01
17532:  MOVLB  A
17534:  MOVWF  x26
17536:  MOVLB  0
17538:  CALL   0FA0
1753C:  BTFSC  1B.7
1753E:  BSF    FF2.7
17540:  MOVLW  2F
17542:  BTFSS  F9E.4
17544:  BRA    17542
17546:  MOVWF  FAD
17548:  CLRF   1B
1754A:  BTFSC  FF2.7
1754C:  BSF    1B.7
1754E:  BCF    FF2.7
17550:  MOVFF  735,A25
17554:  MOVLW  01
17556:  MOVLB  A
17558:  MOVWF  x26
1755A:  MOVLB  0
1755C:  CALL   0FA0
17560:  BTFSC  1B.7
17562:  BSF    FF2.7
17564:  MOVLW  20
17566:  BTFSS  F9E.4
17568:  BRA    17566
1756A:  MOVWF  FAD
1756C:  CLRF   1B
1756E:  BTFSC  FF2.7
17570:  BSF    1B.7
17572:  BCF    FF2.7
17574:  MOVFF  732,A25
17578:  MOVLW  01
1757A:  MOVLB  A
1757C:  MOVWF  x26
1757E:  MOVLB  0
17580:  CALL   0FA0
17584:  BTFSC  1B.7
17586:  BSF    FF2.7
17588:  MOVLW  3A
1758A:  BTFSS  F9E.4
1758C:  BRA    1758A
1758E:  MOVWF  FAD
17590:  CLRF   1B
17592:  BTFSC  FF2.7
17594:  BSF    1B.7
17596:  BCF    FF2.7
17598:  MOVFF  731,A25
1759C:  MOVLW  01
1759E:  MOVLB  A
175A0:  MOVWF  x26
175A2:  MOVLB  0
175A4:  CALL   0FA0
175A8:  BTFSC  1B.7
175AA:  BSF    FF2.7
175AC:  MOVLW  3A
175AE:  BTFSS  F9E.4
175B0:  BRA    175AE
175B2:  MOVWF  FAD
175B4:  CLRF   1B
175B6:  BTFSC  FF2.7
175B8:  BSF    1B.7
175BA:  BCF    FF2.7
175BC:  MOVFF  730,A25
175C0:  MOVLW  01
175C2:  MOVLB  A
175C4:  MOVWF  x26
175C6:  MOVLB  0
175C8:  CALL   0FA0
175CC:  BTFSC  1B.7
175CE:  BSF    FF2.7
175D0:  MOVLW  0A
175D2:  BTFSS  F9E.4
175D4:  BRA    175D2
175D6:  MOVWF  FAD
175D8:  MOVLW  0D
175DA:  BTFSS  F9E.4
175DC:  BRA    175DA
175DE:  MOVWF  FAD
175E0:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
175E2:  DECFSZ 4B,W
175E4:  BRA    176D8
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
175E6:  MOVLW  0A
175E8:  BTFSS  F9E.4
175EA:  BRA    175E8
175EC:  MOVWF  FAD
175EE:  MOVLW  0D
175F0:  BTFSS  F9E.4
175F2:  BRA    175F0
175F4:  MOVWF  FAD
175F6:  CLRF   1B
175F8:  BTFSC  FF2.7
175FA:  BSF    1B.7
175FC:  BCF    FF2.7
175FE:  MOVFF  733,A25
17602:  MOVLW  01
17604:  MOVLB  A
17606:  MOVWF  x26
17608:  MOVLB  0
1760A:  CALL   0FA0
1760E:  BTFSC  1B.7
17610:  BSF    FF2.7
17612:  MOVLW  2F
17614:  BTFSS  F9E.4
17616:  BRA    17614
17618:  MOVWF  FAD
1761A:  CLRF   1B
1761C:  BTFSC  FF2.7
1761E:  BSF    1B.7
17620:  BCF    FF2.7
17622:  MOVFF  734,A25
17626:  MOVLW  01
17628:  MOVLB  A
1762A:  MOVWF  x26
1762C:  MOVLB  0
1762E:  CALL   0FA0
17632:  BTFSC  1B.7
17634:  BSF    FF2.7
17636:  MOVLW  2F
17638:  BTFSS  F9E.4
1763A:  BRA    17638
1763C:  MOVWF  FAD
1763E:  CLRF   1B
17640:  BTFSC  FF2.7
17642:  BSF    1B.7
17644:  BCF    FF2.7
17646:  MOVFF  735,A25
1764A:  MOVLW  01
1764C:  MOVLB  A
1764E:  MOVWF  x26
17650:  MOVLB  0
17652:  CALL   0FA0
17656:  BTFSC  1B.7
17658:  BSF    FF2.7
1765A:  MOVLW  20
1765C:  BTFSS  F9E.4
1765E:  BRA    1765C
17660:  MOVWF  FAD
17662:  CLRF   1B
17664:  BTFSC  FF2.7
17666:  BSF    1B.7
17668:  BCF    FF2.7
1766A:  MOVFF  732,A25
1766E:  MOVLW  01
17670:  MOVLB  A
17672:  MOVWF  x26
17674:  MOVLB  0
17676:  CALL   0FA0
1767A:  BTFSC  1B.7
1767C:  BSF    FF2.7
1767E:  MOVLW  3A
17680:  BTFSS  F9E.4
17682:  BRA    17680
17684:  MOVWF  FAD
17686:  CLRF   1B
17688:  BTFSC  FF2.7
1768A:  BSF    1B.7
1768C:  BCF    FF2.7
1768E:  MOVFF  731,A25
17692:  MOVLW  01
17694:  MOVLB  A
17696:  MOVWF  x26
17698:  MOVLB  0
1769A:  CALL   0FA0
1769E:  BTFSC  1B.7
176A0:  BSF    FF2.7
176A2:  MOVLW  3A
176A4:  BTFSS  F9E.4
176A6:  BRA    176A4
176A8:  MOVWF  FAD
176AA:  CLRF   1B
176AC:  BTFSC  FF2.7
176AE:  BSF    1B.7
176B0:  BCF    FF2.7
176B2:  MOVFF  730,A25
176B6:  MOVLW  01
176B8:  MOVLB  A
176BA:  MOVWF  x26
176BC:  MOVLB  0
176BE:  CALL   0FA0
176C2:  BTFSC  1B.7
176C4:  BSF    FF2.7
176C6:  MOVLW  0A
176C8:  BTFSS  F9E.4
176CA:  BRA    176C8
176CC:  MOVWF  FAD
176CE:  MOVLW  0D
176D0:  BTFSS  F9E.4
176D2:  BRA    176D0
176D4:  MOVWF  FAD
176D6:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
176D8:  MOVLB  8
176DA:  MOVF   x7F,W
176DC:  SUBLW  02
176DE:  BNZ   176E6
176E0:  MOVLB  0
176E2:  BRA    1731E
176E4:  MOVLB  8
....................  
....................    } 
176E6:  BRA    176F0
....................    else cmd_arg(); 
176E8:  MOVLB  0
176EA:  CALL   B070
176EE:  MOVLB  8
....................     
....................    return time_error; 
176F0:  MOVFF  87F,01
176F4:  MOVLB  0
176F6:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
17736:  RCALL  1733E
17738:  MOVFF  01,86F
....................     
....................    if (time_error ==0 ){ 
1773C:  MOVLB  8
1773E:  MOVF   x6F,F
17740:  BTFSS  FD8.2
17742:  BRA    1787A
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
17744:  BCF    FC6.5
17746:  MOVLW  21
17748:  MOVWF  FC6
1774A:  MOVLW  40
1774C:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
1774E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
17750:  MOVF   FC9,W
17752:  MOVLW  86
17754:  MOVWF  FC9
17756:  RRCF   FC7,W
17758:  BNC   17756
1775A:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
1775E:  MOVFF  734,871
17762:  MOVLB  0
17764:  RCALL  176F8
17766:  MOVFF  01,871
1776A:  MOVF   FC9,W
1776C:  MOVFF  01,FC9
17770:  RRCF   FC7,W
17772:  BNC   17770
17774:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
17778:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
1777A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
1777C:  MOVF   FC9,W
1777E:  MOVLW  85
17780:  MOVWF  FC9
17782:  RRCF   FC7,W
17784:  BNC   17782
17786:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
1778A:  MOVFF  733,871
1778E:  RCALL  176F8
17790:  MOVFF  01,871
17794:  MOVF   FC9,W
17796:  MOVFF  01,FC9
1779A:  RRCF   FC7,W
1779C:  BNC   1779A
1779E:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
177A2:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
177A4:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
177A6:  MOVF   FC9,W
177A8:  MOVLW  87
177AA:  MOVWF  FC9
177AC:  RRCF   FC7,W
177AE:  BNC   177AC
177B0:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
177B4:  MOVFF  735,871
177B8:  RCALL  176F8
177BA:  MOVFF  01,871
177BE:  MOVF   FC9,W
177C0:  MOVFF  01,FC9
177C4:  RRCF   FC7,W
177C6:  BNC   177C4
177C8:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
177CC:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
177CE:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
177D0:  MOVF   FC9,W
177D2:  MOVLW  83
177D4:  MOVWF  FC9
177D6:  RRCF   FC7,W
177D8:  BNC   177D6
177DA:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
177DE:  MOVFF  732,871
177E2:  RCALL  176F8
177E4:  MOVFF  01,871
177E8:  MOVF   FC9,W
177EA:  MOVFF  01,FC9
177EE:  RRCF   FC7,W
177F0:  BNC   177EE
177F2:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
177F6:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
177F8:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
177FA:  MOVF   FC9,W
177FC:  MOVLW  82
177FE:  MOVWF  FC9
17800:  RRCF   FC7,W
17802:  BNC   17800
17804:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
17808:  MOVFF  731,871
1780C:  RCALL  176F8
1780E:  MOVFF  01,871
17812:  MOVF   FC9,W
17814:  MOVFF  01,FC9
17818:  RRCF   FC7,W
1781A:  BNC   17818
1781C:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
17820:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17822:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
17824:  MOVF   FC9,W
17826:  MOVLW  81
17828:  MOVWF  FC9
1782A:  RRCF   FC7,W
1782C:  BNC   1782A
1782E:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
17832:  MOVFF  730,871
17836:  RCALL  176F8
17838:  MOVFF  01,871
1783C:  MOVF   FC9,W
1783E:  MOVFF  01,FC9
17842:  RRCF   FC7,W
17844:  BNC   17842
17846:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
1784A:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
1784C:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
1784E:  MOVF   FC9,W
17850:  MOVLW  80
17852:  MOVWF  FC9
17854:  RRCF   FC7,W
17856:  BNC   17854
17858:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
1785C:  MOVLB  8
1785E:  CLRF   x71
17860:  MOVLB  0
17862:  RCALL  176F8
17864:  MOVFF  01,871
17868:  MOVF   FC9,W
1786A:  MOVFF  01,FC9
1786E:  RRCF   FC7,W
17870:  BNC   1786E
17872:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
17876:  BSF    F91.0
17878:  MOVLB  8
....................    } 
1787A:  MOVLB  0
1787C:  GOTO   17908 (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
18400:  CALL   E196
....................     
....................    time_error = get_time(); 
18404:  CALL   1733E
18408:  MOVFF  01,86F
....................     
....................    if (time_error == 0 ){ 
1840C:  MOVLB  8
1840E:  MOVF   x6F,F
18410:  BTFSS  FD8.2
18412:  BRA    18548
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
18414:  MOVFF  735,729
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
18418:  MOVLW  04
1841A:  MOVWF  x73
1841C:  MOVFF  729,874
18420:  MOVLB  0
18422:  CALL   3474
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
18426:  MOVFF  734,871
1842A:  CALL   176F8
1842E:  MOVFF  01,734
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
18432:  MOVLB  7
18434:  BSF    x34.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
18436:  BCF    FC6.5
18438:  MOVLW  21
1843A:  MOVWF  FC6
1843C:  MOVLW  40
1843E:  MOVWF  FC7
....................       delay_us(10); 
18440:  MOVLW  35
18442:  MOVWF  00
18444:  DECFSZ 00,F
18446:  BRA    18444
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
18448:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
1844A:  MOVF   FC9,W
1844C:  MOVLW  8E
1844E:  MOVWF  FC9
18450:  RRCF   FC7,W
18452:  BNC   18450
18454:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
18458:  MOVFF  730,871
1845C:  MOVLB  0
1845E:  CALL   176F8
18462:  MOVFF  01,871
18466:  MOVF   FC9,W
18468:  MOVFF  01,FC9
1846C:  RRCF   FC7,W
1846E:  BNC   1846C
18470:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
18474:  BSF    F91.0
....................       delay_us(1);            // Delays added 1.020A 
18476:  MOVLW  05
18478:  MOVWF  00
1847A:  DECFSZ 00,F
1847C:  BRA    1847A
....................        
....................       output_bit(RTC_CS, ENABLE); 
1847E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
18480:  MOVF   FC9,W
18482:  MOVLW  8D
18484:  MOVWF  FC9
18486:  RRCF   FC7,W
18488:  BNC   18486
1848A:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
1848E:  MOVFF  731,871
18492:  CALL   176F8
18496:  MOVFF  01,871
1849A:  MOVF   FC9,W
1849C:  MOVFF  01,FC9
184A0:  RRCF   FC7,W
184A2:  BNC   184A0
184A4:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
184A8:  BSF    F91.0
....................       delay_us(1); 
184AA:  MOVLW  05
184AC:  MOVWF  00
184AE:  DECFSZ 00,F
184B0:  BRA    184AE
....................        
....................       output_bit(RTC_CS, ENABLE); 
184B2:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
184B4:  MOVF   FC9,W
184B6:  MOVLW  8C
184B8:  MOVWF  FC9
184BA:  RRCF   FC7,W
184BC:  BNC   184BA
184BE:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
184C2:  MOVFF  732,871
184C6:  CALL   176F8
184CA:  MOVFF  01,871
184CE:  MOVF   FC9,W
184D0:  MOVFF  01,FC9
184D4:  RRCF   FC7,W
184D6:  BNC   184D4
184D8:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
184DC:  BSF    F91.0
....................       delay_us(1);    
184DE:  MOVLW  05
184E0:  MOVWF  00
184E2:  DECFSZ 00,F
184E4:  BRA    184E2
....................        
....................       output_bit(RTC_CS, ENABLE); 
184E6:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
184E8:  MOVF   FC9,W
184EA:  MOVLW  8B
184EC:  MOVWF  FC9
184EE:  RRCF   FC7,W
184F0:  BNC   184EE
184F2:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
184F6:  MOVFF  733,871
184FA:  CALL   176F8
184FE:  MOVFF  01,871
18502:  MOVF   FC9,W
18504:  MOVFF  01,FC9
18508:  RRCF   FC7,W
1850A:  BNC   18508
1850C:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE);  
18510:  BSF    F91.0
....................       delay_us(1); 
18512:  MOVLW  05
18514:  MOVWF  00
18516:  DECFSZ 00,F
18518:  BRA    18516
....................        
....................       output_bit(RTC_CS, ENABLE); 
1851A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8A);        // address - Month 
1851C:  MOVF   FC9,W
1851E:  MOVLW  8A
18520:  MOVWF  FC9
18522:  RRCF   FC7,W
18524:  BNC   18522
18526:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
1852A:  MOVF   FC9,W
1852C:  MOVFF  734,FC9
18530:  RRCF   FC7,W
18532:  BNC   18530
18534:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
18538:  BSF    F91.0
....................       delay_us(1); 
1853A:  MOVLW  05
1853C:  MOVWF  00
1853E:  DECFSZ 00,F
18540:  BRA    1853E
....................     
....................    RTC_read_alarm(); 
18542:  CALL   E196
18546:  MOVLB  8
....................    } 
18548:  MOVLB  0
1854A:  GOTO   18560 (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15AEC:  BCF    FC6.5
15AEE:  MOVLW  21
15AF0:  MOVWF  FC6
15AF2:  MOVLW  40
15AF4:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15AF6:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15AF8:  MOVF   FC9,W
15AFA:  MOVLW  8E
15AFC:  MOVWF  FC9
15AFE:  RRCF   FC7,W
15B00:  BNC   15AFE
15B02:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b00000000);  // data 
15B06:  MOVF   FC9,W
15B08:  CLRF   FC9
15B0A:  RRCF   FC7,W
15B0C:  BNC   15B0A
15B0E:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
15B12:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15B14:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15B16:  MOVF   FC9,W
15B18:  MOVLW  8D
15B1A:  MOVWF  FC9
15B1C:  RRCF   FC7,W
15B1E:  BNC   15B1C
15B20:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b10000000);  // data 
15B24:  MOVF   FC9,W
15B26:  MOVLW  80
15B28:  MOVWF  FC9
15B2A:  RRCF   FC7,W
15B2C:  BNC   15B2A
15B2E:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
15B32:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15B34:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15B36:  MOVF   FC9,W
15B38:  MOVLW  8C
15B3A:  MOVWF  FC9
15B3C:  RRCF   FC7,W
15B3E:  BNC   15B3C
15B40:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b10000000);  // data 
15B44:  MOVF   FC9,W
15B46:  MOVLW  80
15B48:  MOVWF  FC9
15B4A:  RRCF   FC7,W
15B4C:  BNC   15B4A
15B4E:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
15B52:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15B54:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15B56:  MOVF   FC9,W
15B58:  MOVLW  8B
15B5A:  MOVWF  FC9
15B5C:  RRCF   FC7,W
15B5E:  BNC   15B5C
15B60:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b11000000);  // data 
15B64:  MOVF   FC9,W
15B66:  MOVLW  C0
15B68:  MOVWF  FC9
15B6A:  RRCF   FC7,W
15B6C:  BNC   15B6A
15B6E:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE);    
15B72:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15B74:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15B76:  MOVF   FC9,W
15B78:  MOVLW  8A
15B7A:  MOVWF  FC9
15B7C:  RRCF   FC7,W
15B7E:  BNC   15B7C
15B80:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b10000000);  // data 
15B84:  MOVF   FC9,W
15B86:  MOVLW  80
15B88:  MOVWF  FC9
15B8A:  RRCF   FC7,W
15B8C:  BNC   15B8A
15B8E:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
15B92:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15B94:  CALL   E196
15B98:  GOTO   16958 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
1533A:  MOVLB  8
1533C:  CLRF   x71
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1533E:  BCF    FC6.5
15340:  MOVLW  21
15342:  MOVWF  FC6
15344:  MOVLW  40
15346:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15348:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
1534A:  MOVF   FC9,W
1534C:  MOVLW  0A
1534E:  MOVWF  FC9
15350:  RRCF   FC7,W
15352:  BNC   15350
15354:  MOVFF  FC9,871
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
15358:  MOVF   FC9,W
1535A:  MOVFF  871,FC9
1535E:  RRCF   FC7,W
15360:  BNC   1535E
15362:  MOVFF  FC9,72A
....................    output_bit(RTC_CS, DISABLE); 
15366:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
15368:  MOVLB  7
1536A:  BSF    x2A.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
1536C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
1536E:  MOVF   FC9,W
15370:  MOVLW  8A
15372:  MOVWF  FC9
15374:  RRCF   FC7,W
15376:  BNC   15374
15378:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
1537C:  MOVF   FC9,W
1537E:  MOVFF  72A,FC9
15382:  RRCF   FC7,W
15384:  BNC   15382
15386:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
1538A:  BSF    F91.0
1538C:  MOVLB  0
1538E:  GOTO   16882 (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
034A4:  MOVFF  721,73B
....................    rtc_last_min   = RTC_Min_Reg; 
034A8:  MOVFF  722,73A
....................    rtc_last_hour  = RTC_Hr_Reg; 
034AC:  MOVFF  723,739
....................    rtc_last_day   = RTC_DOM_Reg; 
034B0:  MOVFF  725,737
....................    rtc_last_month = RTC_Mon_Reg; 
034B4:  MOVFF  726,736
....................    rtc_last_year  = RTC_Yr_Reg; 
034B8:  MOVFF  727,738
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
034BC:  MOVLW  06
034BE:  MOVLB  8
034C0:  MOVWF  x73
034C2:  MOVFF  736,874
034C6:  MOVLB  0
034C8:  RCALL  3474
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
034CA:  MOVLW  08
034CC:  MOVLB  8
034CE:  MOVWF  x73
034D0:  MOVFF  737,874
034D4:  MOVLB  0
034D6:  RCALL  3474
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
034D8:  MOVLW  0A
034DA:  MOVLB  8
034DC:  MOVWF  x73
034DE:  MOVFF  738,874
034E2:  MOVLB  0
034E4:  RCALL  3474
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
034E6:  MOVLW  0C
034E8:  MOVLB  8
034EA:  MOVWF  x73
034EC:  MOVFF  739,874
034F0:  MOVLB  0
034F2:  RCALL  3474
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
034F4:  MOVLW  0E
034F6:  MOVLB  8
034F8:  MOVWF  x73
034FA:  MOVFF  73A,874
034FE:  MOVLB  0
03500:  RCALL  3474
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
03502:  MOVLW  10
03504:  MOVLB  8
03506:  MOVWF  x73
03508:  MOVFF  73B,874
0350C:  MOVLB  0
0350E:  RCALL  3474
03510:  GOTO   1B276 (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
15392:  MOVLB  8
15394:  CLRF   x74
15396:  CLRF   x73
15398:  CLRF   x72
1539A:  CLRF   x71
1539C:  CLRF   x78
1539E:  CLRF   x77
153A0:  CLRF   x76
153A2:  CLRF   x75
153A4:  CLRF   x7C
153A6:  CLRF   x7B
153A8:  CLRF   x7A
153AA:  CLRF   x79
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
153AC:  CLRF   x89
153AE:  CLRF   x8A
153B0:  MOVLW  1F
153B2:  MOVWF  x8B
153B4:  CLRF   x8C
153B6:  MOVLW  3B
153B8:  MOVWF  x8D
153BA:  CLRF   x8E
153BC:  MOVLW  5A
153BE:  MOVWF  x8F
153C0:  CLRF   x90
153C2:  MOVLW  78
153C4:  MOVWF  x91
153C6:  CLRF   x92
153C8:  MOVLW  97
153CA:  MOVWF  x93
153CC:  CLRF   x94
153CE:  MOVLW  B5
153D0:  MOVWF  x95
153D2:  CLRF   x96
153D4:  MOVLW  D4
153D6:  MOVWF  x97
153D8:  CLRF   x98
153DA:  MOVLW  F3
153DC:  MOVWF  x99
153DE:  CLRF   x9A
153E0:  MOVLW  11
153E2:  MOVWF  x9B
153E4:  MOVLW  01
153E6:  MOVWF  x9C
153E8:  MOVLW  30
153EA:  MOVWF  x9D
153EC:  MOVLW  01
153EE:  MOVWF  x9E
153F0:  MOVLW  4E
153F2:  MOVWF  x9F
153F4:  MOVLW  01
153F6:  MOVWF  xA0
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
153F8:  BCF    49.3
....................     
....................    RTC_read(); 
153FA:  MOVLB  0
153FC:  CALL   33A6
....................    RTC_read_alarm(); 
15400:  CALL   E196
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
15404:  MOVLW  04
15406:  MOVLB  8
15408:  MOVWF  xA1
1540A:  MOVLB  0
1540C:  CALL   2A86
15410:  MOVFF  01,729
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
15414:  MOVLB  7
15416:  MOVF   x27,W
15418:  SUBWF  x29,W
1541A:  BC    15420
1541C:  BSF    49.3
1541E:  BRA    15848
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
15420:  MOVF   x29,W
15422:  SUBWF  x27,W
15424:  BTFSS  FD8.2
15426:  BRA    15848
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
15428:  MOVLW  01
1542A:  SUBWF  x26,W
1542C:  MOVWF  00
1542E:  BCF    FD8.0
15430:  RLCF   00,F
15432:  MOVF   00,W
15434:  CLRF   03
15436:  ADDLW  89
15438:  MOVWF  FE9
1543A:  MOVLW  08
1543C:  ADDWFC 03,W
1543E:  MOVWF  FEA
15440:  MOVFF  FEC,03
15444:  MOVF   FED,F
15446:  MOVFF  FEF,901
1544A:  MOVFF  03,902
1544E:  MOVLB  0
15450:  CALL   C69C
15454:  MOVFF  03,874
15458:  MOVFF  02,873
1545C:  MOVFF  01,872
15460:  MOVFF  00,871
....................          time_now = time_now + RTC_DOM_Reg; 
15464:  MOVLB  9
15466:  CLRF   x02
15468:  MOVFF  725,901
1546C:  MOVLB  0
1546E:  CALL   C69C
15472:  BCF    FD8.1
15474:  MOVFF  874,904
15478:  MOVFF  873,903
1547C:  MOVFF  872,902
15480:  MOVFF  871,901
15484:  MOVFF  03,908
15488:  MOVFF  02,907
1548C:  MOVFF  01,906
15490:  MOVFF  00,905
15494:  CALL   C160
15498:  MOVFF  03,874
1549C:  MOVFF  02,873
154A0:  MOVFF  01,872
154A4:  MOVFF  00,871
....................           
....................          hour = RTC_Hr_Reg; 
154A8:  MOVLB  9
154AA:  CLRF   x02
154AC:  MOVFF  723,901
154B0:  MOVLB  0
154B2:  CALL   C69C
154B6:  MOVFF  03,880
154BA:  MOVFF  02,87F
154BE:  MOVFF  01,87E
154C2:  MOVFF  00,87D
....................          minute = RTC_Min_Reg; 
154C6:  MOVLB  9
154C8:  CLRF   x02
154CA:  MOVFF  722,901
154CE:  MOVLB  0
154D0:  CALL   C69C
154D4:  MOVFF  03,884
154D8:  MOVFF  02,883
154DC:  MOVFF  01,882
154E0:  MOVFF  00,881
....................          second = RTC_Sec_Reg; 
154E4:  MOVLB  9
154E6:  CLRF   x02
154E8:  MOVFF  721,901
154EC:  MOVLB  0
154EE:  CALL   C69C
154F2:  MOVFF  03,888
154F6:  MOVFF  02,887
154FA:  MOVFF  01,886
154FE:  MOVFF  00,885
....................           
....................          fraction_of_day = (hour / 24); 
15502:  MOVFF  880,8E8
15506:  MOVFF  87F,8E7
1550A:  MOVFF  87E,8E6
1550E:  MOVFF  87D,8E5
15512:  MOVLB  8
15514:  CLRF   xEC
15516:  CLRF   xEB
15518:  MOVLW  40
1551A:  MOVWF  xEA
1551C:  MOVLW  83
1551E:  MOVWF  xE9
15520:  MOVLB  0
15522:  CALL   C6D2
15526:  MOVFF  03,87C
1552A:  MOVFF  02,87B
1552E:  MOVFF  01,87A
15532:  MOVFF  00,879
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15536:  MOVFF  884,8E8
1553A:  MOVFF  883,8E7
1553E:  MOVFF  882,8E6
15542:  MOVFF  881,8E5
15546:  MOVLB  8
15548:  CLRF   xEC
1554A:  CLRF   xEB
1554C:  MOVLW  34
1554E:  MOVWF  xEA
15550:  MOVLW  89
15552:  MOVWF  xE9
15554:  MOVLB  0
15556:  CALL   C6D2
1555A:  BCF    FD8.1
1555C:  MOVFF  87C,904
15560:  MOVFF  87B,903
15564:  MOVFF  87A,902
15568:  MOVFF  879,901
1556C:  MOVFF  03,908
15570:  MOVFF  02,907
15574:  MOVFF  01,906
15578:  MOVFF  00,905
1557C:  CALL   C160
15580:  MOVFF  03,87C
15584:  MOVFF  02,87B
15588:  MOVFF  01,87A
1558C:  MOVFF  00,879
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15590:  MOVFF  888,8E8
15594:  MOVFF  887,8E7
15598:  MOVFF  886,8E6
1559C:  MOVFF  885,8E5
155A0:  MOVLB  8
155A2:  CLRF   xEC
155A4:  MOVLW  C0
155A6:  MOVWF  xEB
155A8:  MOVLW  28
155AA:  MOVWF  xEA
155AC:  MOVLW  8F
155AE:  MOVWF  xE9
155B0:  MOVLB  0
155B2:  CALL   C6D2
155B6:  BCF    FD8.1
155B8:  MOVFF  87C,904
155BC:  MOVFF  87B,903
155C0:  MOVFF  87A,902
155C4:  MOVFF  879,901
155C8:  MOVFF  03,908
155CC:  MOVFF  02,907
155D0:  MOVFF  01,906
155D4:  MOVFF  00,905
155D8:  CALL   C160
155DC:  MOVFF  03,87C
155E0:  MOVFF  02,87B
155E4:  MOVFF  01,87A
155E8:  MOVFF  00,879
....................           
....................          time_now = time_now + fraction_of_day; 
155EC:  BCF    FD8.1
155EE:  MOVFF  874,904
155F2:  MOVFF  873,903
155F6:  MOVFF  872,902
155FA:  MOVFF  871,901
155FE:  MOVFF  87C,908
15602:  MOVFF  87B,907
15606:  MOVFF  87A,906
1560A:  MOVFF  879,905
1560E:  CALL   C160
15612:  MOVFF  03,874
15616:  MOVFF  02,873
1561A:  MOVFF  01,872
1561E:  MOVFF  00,871
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
15622:  MOVLB  9
15624:  CLRF   x02
15626:  MOVFF  72C,901
1562A:  MOVLB  0
1562C:  CALL   C69C
15630:  MOVFF  03,880
15634:  MOVFF  02,87F
15638:  MOVFF  01,87E
1563C:  MOVFF  00,87D
....................          minute = RTC_Al_Min_Reg; 
15640:  MOVLB  9
15642:  CLRF   x02
15644:  MOVFF  72D,901
15648:  MOVLB  0
1564A:  CALL   C69C
1564E:  MOVFF  03,884
15652:  MOVFF  02,883
15656:  MOVFF  01,882
1565A:  MOVFF  00,881
....................          second = RTC_Al_Sec_Reg; 
1565E:  MOVLB  9
15660:  CLRF   x02
15662:  MOVFF  72E,901
15666:  MOVLB  0
15668:  CALL   C69C
1566C:  MOVFF  03,888
15670:  MOVFF  02,887
15674:  MOVFF  01,886
15678:  MOVFF  00,885
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
1567C:  MOVLW  01
1567E:  MOVLB  7
15680:  SUBWF  x2A,W
15682:  MOVWF  00
15684:  BCF    FD8.0
15686:  RLCF   00,F
15688:  MOVF   00,W
1568A:  CLRF   03
1568C:  ADDLW  89
1568E:  MOVWF  FE9
15690:  MOVLW  08
15692:  ADDWFC 03,W
15694:  MOVWF  FEA
15696:  MOVFF  FEC,03
1569A:  MOVF   FED,F
1569C:  MOVFF  FEF,901
156A0:  MOVFF  03,902
156A4:  MOVLB  0
156A6:  CALL   C69C
156AA:  MOVFF  03,878
156AE:  MOVFF  02,877
156B2:  MOVFF  01,876
156B6:  MOVFF  00,875
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
156BA:  MOVLB  9
156BC:  CLRF   x02
156BE:  MOVFF  72B,901
156C2:  MOVLB  0
156C4:  CALL   C69C
156C8:  BCF    FD8.1
156CA:  MOVFF  878,904
156CE:  MOVFF  877,903
156D2:  MOVFF  876,902
156D6:  MOVFF  875,901
156DA:  MOVFF  03,908
156DE:  MOVFF  02,907
156E2:  MOVFF  01,906
156E6:  MOVFF  00,905
156EA:  CALL   C160
156EE:  MOVFF  03,878
156F2:  MOVFF  02,877
156F6:  MOVFF  01,876
156FA:  MOVFF  00,875
....................           
....................          fraction_of_day = (hour / 24); 
156FE:  MOVFF  880,8E8
15702:  MOVFF  87F,8E7
15706:  MOVFF  87E,8E6
1570A:  MOVFF  87D,8E5
1570E:  MOVLB  8
15710:  CLRF   xEC
15712:  CLRF   xEB
15714:  MOVLW  40
15716:  MOVWF  xEA
15718:  MOVLW  83
1571A:  MOVWF  xE9
1571C:  MOVLB  0
1571E:  CALL   C6D2
15722:  MOVFF  03,87C
15726:  MOVFF  02,87B
1572A:  MOVFF  01,87A
1572E:  MOVFF  00,879
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15732:  MOVFF  884,8E8
15736:  MOVFF  883,8E7
1573A:  MOVFF  882,8E6
1573E:  MOVFF  881,8E5
15742:  MOVLB  8
15744:  CLRF   xEC
15746:  CLRF   xEB
15748:  MOVLW  34
1574A:  MOVWF  xEA
1574C:  MOVLW  89
1574E:  MOVWF  xE9
15750:  MOVLB  0
15752:  CALL   C6D2
15756:  BCF    FD8.1
15758:  MOVFF  87C,904
1575C:  MOVFF  87B,903
15760:  MOVFF  87A,902
15764:  MOVFF  879,901
15768:  MOVFF  03,908
1576C:  MOVFF  02,907
15770:  MOVFF  01,906
15774:  MOVFF  00,905
15778:  CALL   C160
1577C:  MOVFF  03,87C
15780:  MOVFF  02,87B
15784:  MOVFF  01,87A
15788:  MOVFF  00,879
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
1578C:  MOVFF  888,8E8
15790:  MOVFF  887,8E7
15794:  MOVFF  886,8E6
15798:  MOVFF  885,8E5
1579C:  MOVLB  8
1579E:  CLRF   xEC
157A0:  MOVLW  C0
157A2:  MOVWF  xEB
157A4:  MOVLW  28
157A6:  MOVWF  xEA
157A8:  MOVLW  8F
157AA:  MOVWF  xE9
157AC:  MOVLB  0
157AE:  CALL   C6D2
157B2:  BCF    FD8.1
157B4:  MOVFF  87C,904
157B8:  MOVFF  87B,903
157BC:  MOVFF  87A,902
157C0:  MOVFF  879,901
157C4:  MOVFF  03,908
157C8:  MOVFF  02,907
157CC:  MOVFF  01,906
157D0:  MOVFF  00,905
157D4:  CALL   C160
157D8:  MOVFF  03,87C
157DC:  MOVFF  02,87B
157E0:  MOVFF  01,87A
157E4:  MOVFF  00,879
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
157E8:  BCF    FD8.1
157EA:  MOVFF  878,904
157EE:  MOVFF  877,903
157F2:  MOVFF  876,902
157F6:  MOVFF  875,901
157FA:  MOVFF  87C,908
157FE:  MOVFF  87B,907
15802:  MOVFF  87A,906
15806:  MOVFF  879,905
1580A:  CALL   C160
1580E:  MOVFF  03,878
15812:  MOVFF  02,877
15816:  MOVFF  01,876
1581A:  MOVFF  00,875
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
1581E:  MOVFF  878,900
15822:  MOVFF  877,8FF
15826:  MOVFF  876,8FE
1582A:  MOVFF  875,8FD
1582E:  MOVFF  874,904
15832:  MOVFF  873,903
15836:  MOVFF  872,902
1583A:  MOVFF  871,901
1583E:  CALL   104EC
15842:  BNC   15846
15844:  BSF    49.3
15846:  MOVLB  7
....................       } 
....................    } 
15848:  MOVLB  0
1584A:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
1584C:  BTFSS  49.3
1584E:  BRA    1586C
15850:  MOVLW  C4
15852:  MOVWF  FF6
15854:  MOVLW  0D
15856:  MOVWF  FF7
15858:  MOVLW  00
1585A:  MOVWF  FF8
1585C:  CLRF   1B
1585E:  BTFSC  FF2.7
15860:  BSF    1B.7
15862:  BCF    FF2.7
15864:  CALL   0DCC
15868:  BTFSC  1B.7
1586A:  BSF    FF2.7
1586C:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F2FA:  BCF    F67.5
0F2FC:  MOVLW  32
0F2FE:  MOVWF  F67
0F300:  MOVLW  40
0F302:  MOVWF  F68
....................     
....................    data = 0; 
0F304:  MOVLB  8
0F306:  CLRF   xC1
0F308:  CLRF   xC0
....................     
....................    DAC_MS_byte = 0; 
0F30A:  CLRF   xC2
....................    DAC_LS_byte = 0; 
0F30C:  CLRF   xC3
....................     
....................    data = setting & 0b0000111100000000; 
0F30E:  CLRF   xC0
0F310:  MOVF   xBF,W
0F312:  ANDLW  0F
0F314:  MOVWF  xC1
....................    data = data >> 8; 
0F316:  MOVFF  8C1,8C0
0F31A:  CLRF   xC1
....................    DAC_MS_byte = data; 
0F31C:  MOVFF  8C0,8C2
....................     
....................    data = setting & 0b0000000011111111; 
0F320:  MOVFF  8BE,8C0
0F324:  CLRF   xC1
....................    DAC_LS_byte = data; 
0F326:  MOVFF  8C0,8C3
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F32A:  MOVLW  01
0F32C:  SUBWF  xBD,W
0F32E:  ADDLW  FC
0F330:  BC    F35C
0F332:  ADDLW  04
0F334:  MOVLB  0
0F336:  GOTO   F37A
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F33A:  MOVLW  30
0F33C:  MOVLB  8
0F33E:  IORWF  xC2,F
....................          break; 
0F340:  BRA    F35C
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F342:  MOVLW  70
0F344:  MOVLB  8
0F346:  IORWF  xC2,F
....................          break; 
0F348:  BRA    F35C
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F34A:  MOVLW  B0
0F34C:  MOVLB  8
0F34E:  IORWF  xC2,F
....................          break; 
0F350:  BRA    F35C
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F352:  MOVLW  F0
0F354:  MOVLB  8
0F356:  IORWF  xC2,F
....................          break; 
0F358:  BRA    F35C
0F35A:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F35C:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F35E:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F360:  MOVF   F6A,W
0F362:  MOVFF  8C2,F6A
0F366:  RRCF   F68,W
0F368:  BNC   F366
....................    spi_write2(DAC_LS_byte); 
0F36A:  MOVF   F6A,W
0F36C:  MOVFF  8C3,F6A
0F370:  RRCF   F68,W
0F372:  BNC   F370
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F374:  BSF    F8C.3
0F376:  MOVLB  0
0F378:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F3A2:  MOVLB  8
0F3A4:  CLRF   xC2
0F3A6:  CLRF   xC3
0F3A8:  CLRF   xC4
0F3AA:  CLRF   xC5
0F3AC:  CLRF   xC6
0F3AE:  CLRF   xC7
0F3B0:  CLRF   xC8
0F3B2:  CLRF   xC9
0F3B4:  CLRF   xCA
0F3B6:  CLRF   xCB
0F3B8:  CLRF   xCC
0F3BA:  CLRF   xCD
0F3BC:  CLRF   xCE
0F3BE:  CLRF   xCF
0F3C0:  CLRF   xD0
0F3C2:  CLRF   xD1
0F3C4:  CLRF   xD2
0F3C6:  CLRF   xD3
0F3C8:  CLRF   xD4
0F3CA:  CLRF   xD5
0F3CC:  CLRF   xD6
0F3CE:  CLRF   xD7
0F3D0:  CLRF   xD8
0F3D2:  CLRF   xD9
0F3D4:  CLRF   xDA
0F3D6:  CLRF   xDB
0F3D8:  CLRF   xDC
0F3DA:  CLRF   xDD
0F3DC:  CLRF   xDE
0F3DE:  CLRF   xDF
0F3E0:  CLRF   xE0
0F3E2:  CLRF   xE1
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F3E4:  CLRF   xE2
0F3E6:  CLRF   xE3
0F3E8:  CLRF   xE4
0F3EA:  CLRF   xE5
0F3EC:  CLRF   xE6
0F3EE:  CLRF   xE7
0F3F0:  CLRF   xE8
0F3F2:  CLRF   xE9
0F3F4:  CLRF   xEA
0F3F6:  CLRF   xEB
0F3F8:  CLRF   xEC
0F3FA:  CLRF   xED
0F3FC:  CLRF   xEE
0F3FE:  CLRF   xEF
0F400:  CLRF   xF0
0F402:  CLRF   xF1
0F404:  CLRF   xF2
0F406:  CLRF   xF3
0F408:  CLRF   xF4
0F40A:  CLRF   xF5
0F40C:  CLRF   xF6
0F40E:  CLRF   xF7
0F410:  CLRF   xF8
0F412:  CLRF   xF9
0F414:  CLRF   xFA
0F416:  CLRF   xFB
0F418:  CLRF   xFC
0F41A:  CLRF   xFD
0F41C:  CLRF   xFE
0F41E:  CLRF   xFF
0F420:  MOVLB  9
0F422:  CLRF   x00
0F424:  CLRF   x01
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F426:  MOVLB  8
0F428:  CLRF   xC1
0F42A:  MOVLW  01
0F42C:  MOVWF  xC0
0F42E:  MOVLW  01
0F430:  ADDWF  xBD,W
0F432:  MOVWF  01
0F434:  MOVLW  00
0F436:  ADDWFC xBE,W
0F438:  MOVWF  03
0F43A:  MOVF   xC1,W
0F43C:  SUBWF  03,W
0F43E:  BTFSS  FD8.0
0F440:  BRA    F52C
0F442:  BNZ   F44A
0F444:  MOVF   01,W
0F446:  SUBWF  xC0,W
0F448:  BC    F52C
....................    { 
....................       for (n=1; n<5; ++n) 
0F44A:  MOVLW  01
0F44C:  MOVWF  xBF
0F44E:  MOVF   xBF,W
0F450:  SUBLW  04
0F452:  BNC   F524
....................       { 
....................          set_adc_channel(n,VSS); 
0F454:  RLCF   xBF,W
0F456:  MOVWF  00
0F458:  RLCF   00,F
0F45A:  MOVLW  FC
0F45C:  ANDWF  00,F
0F45E:  MOVF   FC2,W
0F460:  ANDLW  83
0F462:  IORWF  00,W
0F464:  MOVWF  FC2
0F466:  MOVLW  00
0F468:  MOVWF  01
0F46A:  MOVF   FC1,W
0F46C:  ANDLW  F8
0F46E:  IORWF  01,W
0F470:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F472:  MOVF   xBF,W
0F474:  MULLW  04
0F476:  MOVF   FF3,W
0F478:  CLRF   03
0F47A:  ADDLW  E2
0F47C:  MOVWF  FE9
0F47E:  MOVLW  08
0F480:  ADDWFC 03,W
0F482:  MOVWF  FEA
0F484:  BSF    FC2.1
0F486:  BTFSC  FC2.1
0F488:  BRA    F486
0F48A:  MOVFF  FC3,FEF
0F48E:  MOVFF  FC4,FEC
0F492:  CLRF   FEC
0F494:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F496:  MOVF   xBF,W
0F498:  MULLW  04
0F49A:  MOVF   FF3,W
0F49C:  CLRF   03
0F49E:  ADDLW  C2
0F4A0:  MOVWF  01
0F4A2:  MOVLW  08
0F4A4:  ADDWFC 03,F
0F4A6:  MOVFF  01,902
0F4AA:  MOVFF  03,903
0F4AE:  MOVLB  8
0F4B0:  MOVF   xBF,W
0F4B2:  MULLW  04
0F4B4:  MOVF   FF3,W
0F4B6:  CLRF   03
0F4B8:  ADDLW  C2
0F4BA:  MOVWF  FE9
0F4BC:  MOVLW  08
0F4BE:  ADDWFC 03,W
0F4C0:  MOVWF  FEA
0F4C2:  MOVFF  FEF,904
0F4C6:  MOVFF  FEC,905
0F4CA:  MOVFF  FEC,906
0F4CE:  MOVFF  FEC,907
0F4D2:  MOVF   xBF,W
0F4D4:  MULLW  04
0F4D6:  MOVF   FF3,W
0F4D8:  CLRF   03
0F4DA:  ADDLW  E2
0F4DC:  MOVWF  FE9
0F4DE:  MOVLW  08
0F4E0:  ADDWFC 03,W
0F4E2:  MOVWF  FEA
0F4E4:  MOVFF  FEF,00
0F4E8:  MOVFF  FEC,01
0F4EC:  MOVFF  FEC,02
0F4F0:  MOVFF  FEC,03
0F4F4:  MOVLB  9
0F4F6:  MOVF   x04,W
0F4F8:  ADDWF  00,F
0F4FA:  MOVF   x05,W
0F4FC:  ADDWFC 01,F
0F4FE:  MOVF   x06,W
0F500:  ADDWFC 02,F
0F502:  MOVF   x07,W
0F504:  ADDWFC 03,F
0F506:  MOVFF  903,FEA
0F50A:  MOVFF  902,FE9
0F50E:  MOVFF  00,FEF
0F512:  MOVFF  01,FEC
0F516:  MOVFF  02,FEC
0F51A:  MOVFF  03,FEC
0F51E:  MOVLB  8
0F520:  INCF   xBF,F
0F522:  BRA    F44E
....................       } 
0F524:  INCF   xC0,F
0F526:  BTFSC  FD8.2
0F528:  INCF   xC1,F
0F52A:  BRA    F42E
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F52C:  MOVLW  01
0F52E:  MOVWF  xBF
0F530:  MOVF   xBF,W
0F532:  SUBLW  04
0F534:  BNC   F5A8
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F536:  BCF    FD8.0
0F538:  RLCF   xBF,W
0F53A:  CLRF   03
0F53C:  ADDLW  A1
0F53E:  MOVWF  01
0F540:  MOVLW  04
0F542:  ADDWFC 03,F
0F544:  MOVFF  01,902
0F548:  MOVFF  03,903
0F54C:  MOVLB  8
0F54E:  MOVF   xBF,W
0F550:  MULLW  04
0F552:  MOVF   FF3,W
0F554:  CLRF   03
0F556:  ADDLW  C2
0F558:  MOVWF  FE9
0F55A:  MOVLW  08
0F55C:  ADDWFC 03,W
0F55E:  MOVWF  FEA
0F560:  MOVFF  FEF,A31
0F564:  MOVFF  FEC,A32
0F568:  MOVFF  FEC,A33
0F56C:  MOVFF  FEC,A34
0F570:  BCF    FD8.1
0F572:  CLRF   1B
0F574:  BTFSC  FF2.7
0F576:  BSF    1B.7
0F578:  BCF    FF2.7
0F57A:  MOVLB  A
0F57C:  CLRF   x38
0F57E:  CLRF   x37
0F580:  MOVFF  8BE,A36
0F584:  MOVFF  8BD,A35
0F588:  MOVLB  0
0F58A:  CALL   1050
0F58E:  BTFSC  1B.7
0F590:  BSF    FF2.7
0F592:  MOVFF  903,FEA
0F596:  MOVFF  902,FE9
0F59A:  MOVFF  00,FEF
0F59E:  MOVFF  01,FEC
0F5A2:  MOVLB  8
0F5A4:  INCF   xBF,F
0F5A6:  BRA    F530
....................    } 
0F5A8:  MOVLB  0
0F5AA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    fprintf(COM_A,"test123\r\n"); 
*
00E2A:  MOVLW  52
00E2C:  MOVWF  FF6
00E2E:  MOVLW  0E
00E30:  MOVWF  FF7
00E32:  MOVLW  00
00E34:  MOVWF  FF8
00E36:  RCALL  0DCC
....................    rtc_alarm = TRUE; 
00E38:  BSF    49.0
....................    sleep_mode = FALSE; 
00E3A:  BCF    49.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E3C:  BTFSS  49.2
00E3E:  BRA    0E42
....................    { 
....................       ; 
00E40:  BRA    0E3C
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E42:  BSF    49.2
....................    RTC_read_flags(); 
00E44:  RCALL  0DF6
....................    ++nv_elapsed; 
00E46:  INCF   35,F
00E48:  BTFSC  FD8.2
00E4A:  INCF   36,F
.................... } 
....................  
00E4C:  BCF    FF2.1
00E4E:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E72:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E74:  BTFSC  49.1
00E76:  BRA    0EC8
....................    { 
....................       if (kbhit(COM_A)) 
00E78:  BTFSS  F9E.5
00E7A:  BRA    0EC6
....................       { 
....................          c = getc(COM_A); 
00E7C:  RCALL  0E5C
00E7E:  MOVFF  01,A1C
....................          switch (c) 
00E82:  MOVLB  A
00E84:  MOVF   x1C,W
00E86:  XORLW  3F
00E88:  MOVLB  0
00E8A:  BZ    0E96
00E8C:  XORLW  2E
00E8E:  BZ    0EBA
00E90:  XORLW  0A
00E92:  BZ    0EC0
00E94:  BRA    0EC6
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00E96:  DECFSZ 4A,W
00E98:  BRA    0EAA
00E9A:  MOVLW  D2
00E9C:  MOVWF  FF6
00E9E:  MOVLW  0E
00EA0:  MOVWF  FF7
00EA2:  MOVLW  00
00EA4:  MOVWF  FF8
00EA6:  RCALL  0DCC
00EA8:  BRA    0EB8
....................                else fprintf(COM_A, "@RDY\r\n"); 
00EAA:  MOVLW  DA
00EAC:  MOVWF  FF6
00EAE:  MOVLW  0E
00EB0:  MOVWF  FF7
00EB2:  MOVLW  00
00EB4:  MOVWF  FF8
00EB6:  RCALL  0DCC
....................                break; 
00EB8:  BRA    0EC6
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EBA:  MOVLW  01
00EBC:  MOVWF  4C
....................                break;          
00EBE:  BRA    0EC6
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EC0:  CLRF   32
00EC2:  MOVLW  01
00EC4:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EC6:  BRA    0ECC
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EC8:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00ECA:  BCF    F9E.5
....................    } 
00ECC:  BCF    F9E.5
00ECE:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0AEAC:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0AEAE:  MOVF   FAE,W
....................    busy_status = FALSE; 
0AEB0:  CLRF   4A
0AEB2:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
02A22:  MOVLW  01
02A24:  MOVWF  4A
....................    clear_interrupt(INT_RDA); 
02A26:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
02A28:  BSF    F9D.5
02A2A:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00EE2:  MOVLW  0B
00EE4:  MOVWF  FD7
00EE6:  MOVLW  DC
00EE8:  MOVWF  FD6
....................    restart_wdt(); 
00EEA:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00EEC:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00EEE:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00EF0:  CLRF   FCF
00EF2:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00EF4:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00EF6:  MOVF   2F,W
00EF8:  SUBLW  02
00EFA:  BNZ   0F02
00EFC:  MOVF   30,F
00EFE:  BNZ   0F02
00F00:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00F02:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00F04:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00F06:  BCF    FF2.2
00F08:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00F0C:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F0E:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F10:  MOVF   2F,W
00F12:  SUBLW  02
00F14:  BNZ   0F1C
00F16:  MOVF   30,F
00F18:  BNZ   0F1C
00F1A:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F1C:  BCF    F9E.0
00F1E:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
15940:  MOVLB  8
15942:  CLRF   x76
15944:  CLRF   x7A
15946:  CLRF   x79
15948:  CLRF   x78
1594A:  CLRF   x77
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
1594C:  MOVLW  01
1594E:  ADDWF  x77,F
15950:  BTFSC  FD8.0
15952:  INCF   x78,F
15954:  BTFSC  FD8.2
15956:  INCF   x79,F
15958:  BTFSC  FD8.2
1595A:  INCF   x7A,F
1595C:  MOVF   x7A,F
1595E:  BNZ   159A0
15960:  MOVF   x79,W
15962:  SUBLW  04
15964:  BNC   159A0
15966:  BNZ   15976
15968:  MOVF   x78,W
1596A:  SUBLW  93
1596C:  BNC   159A0
1596E:  BNZ   15976
15970:  MOVF   x77,W
15972:  SUBLW  DF
15974:  BNC   159A0
....................    { 
....................       if(kbhit(COM_A)) 
15976:  BTFSS  F9E.5
15978:  BRA    15996
....................       { 
....................          c = fgetc(COM_A); 
1597A:  MOVLB  0
1597C:  CALL   0E5C
15980:  MOVFF  01,876
....................          if (com_echo == TRUE) 
15984:  DECFSZ 48,W
15986:  BRA    15992
....................          { 
....................             fputc(c, COM_A); 
15988:  MOVLB  8
1598A:  MOVF   x76,W
1598C:  MOVLB  0
1598E:  CALL   AEB4
....................          } 
....................          break; 
15992:  MOVLB  8
15994:  BRA    159A0
....................       } 
....................  
....................       delay_us(10); 
15996:  MOVLW  35
15998:  MOVWF  00
1599A:  DECFSZ 00,F
1599C:  BRA    1599A
1599E:  BRA    1594C
....................    } 
....................  
....................    return(c); 
159A0:  MOVFF  876,01
159A4:  MOVLB  0
159A6:  GOTO   159B6 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AE28:  MOVLW  58
0AE2A:  MOVLB  8
0AE2C:  MOVWF  x6D
0AE2E:  CLRF   x71
0AE30:  CLRF   x70
0AE32:  CLRF   x6F
0AE34:  CLRF   x6E
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AE36:  MOVLW  01
0AE38:  ADDWF  x6E,F
0AE3A:  BTFSC  FD8.0
0AE3C:  INCF   x6F,F
0AE3E:  BTFSC  FD8.2
0AE40:  INCF   x70,F
0AE42:  BTFSC  FD8.2
0AE44:  INCF   x71,F
0AE46:  MOVF   x71,F
0AE48:  BNZ   AE78
0AE4A:  MOVF   x70,F
0AE4C:  BNZ   AE78
0AE4E:  MOVF   x6F,W
0AE50:  SUBLW  C3
0AE52:  BNC   AE78
0AE54:  BNZ   AE5C
0AE56:  MOVF   x6E,W
0AE58:  SUBLW  4F
0AE5A:  BNC   AE78
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AE5C:  MOVLW  05
0AE5E:  MOVWF  00
0AE60:  DECFSZ 00,F
0AE62:  BRA    AE60
....................  
....................       if(kbhit()) 
0AE64:  BTFSS  F9E.5
0AE66:  BRA    AE76
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AE68:  MOVLB  0
0AE6A:  CALL   0E5C
0AE6E:  MOVFF  01,86D
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AE72:  MOVLB  8
0AE74:  BRA    AE78
....................       } 
0AE76:  BRA    AE36
....................    } 
....................  
....................    return(EscChar); 
0AE78:  MOVFF  86D,01
0AE7C:  MOVLB  0
0AE7E:  GOTO   1B46A (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0D7FE:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0D800:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0D802:  BSF    F8F.3
....................    delay_ms(10); 
0D804:  MOVLW  0A
0D806:  MOVLB  9
0D808:  MOVWF  xD6
0D80A:  MOVLB  0
0D80C:  CALL   2972
0D810:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0D8EA:  MOVLB  8
0D8EC:  CLRF   xDE
0D8EE:  CLRF   xDD
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0D8F0:  MOVLB  F
0D8F2:  BTFSC  x21.1
0D8F4:  BRA    D902
....................       ++c; 
0D8F6:  MOVLB  8
0D8F8:  INCF   xDD,F
0D8FA:  BTFSC  FD8.2
0D8FC:  INCF   xDE,F
0D8FE:  BRA    D8F0
0D900:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0D902:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0D904:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0D906:  BCF    F8F.3
0D908:  MOVLB  0
0D90A:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
16B4A:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
16B4C:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
16B4E:  BCF    F8F.3
16B50:  GOTO   16C3E (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
16B54:  MOVLB  8
16B56:  CLRF   x6F
16B58:  CLRF   x70
16B5A:  CLRF   xC1
16B5C:  CLRF   xC2
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16B5E:  MOVLW  22
16B60:  MOVWF  FF6
16B62:  MOVLW  0F
16B64:  MOVWF  FF7
16B66:  MOVLW  00
16B68:  MOVWF  FF8
16B6A:  CLRF   1B
16B6C:  BTFSC  FF2.7
16B6E:  BSF    1B.7
16B70:  BCF    FF2.7
16B72:  MOVLB  0
16B74:  CALL   0DCC
16B78:  BTFSC  1B.7
16B7A:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16B7C:  MOVLB  8
16B7E:  MOVF   x70,W
16B80:  SUBLW  04
16B82:  BZ    16C3A
....................    { 
....................        if (kbhit(COM_A)) 
16B84:  BTFSS  F9E.5
16B86:  BRA    16C1E
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16B88:  MOVLB  0
16B8A:  CALL   0E5C
16B8E:  MOVFF  01,86F
....................           if (com_echo == TRUE) 
16B92:  DECFSZ 48,W
16B94:  BRA    16BA0
....................           { 
....................              fputc(charFromA, COM_A); 
16B96:  MOVLB  8
16B98:  MOVF   x6F,W
16B9A:  MOVLB  0
16B9C:  CALL   AEB4
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16BA0:  MOVLB  8
16BA2:  MOVF   xC2,W
16BA4:  SUBLW  4F
16BA6:  BNC   16BFC
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16BA8:  MOVF   xC2,W
16BAA:  INCF   xC2,F
16BAC:  CLRF   03
16BAE:  ADDLW  71
16BB0:  MOVWF  FE9
16BB2:  MOVLW  08
16BB4:  ADDWFC 03,W
16BB6:  MOVWF  FEA
16BB8:  MOVFF  86F,FEF
....................              if (CARRIAGE_RET == charFromA) 
16BBC:  MOVF   x6F,W
16BBE:  SUBLW  0D
16BC0:  BNZ   16BFA
....................              { 
....................                 multidrop_on(); 
16BC2:  MOVLB  0
16BC4:  CALL   D7FE
....................                 for (index = 0 ; index < charCount; index++) 
16BC8:  MOVLB  8
16BCA:  CLRF   xC1
16BCC:  MOVF   xC2,W
16BCE:  SUBWF  xC1,W
16BD0:  BC    16BF0
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
16BD2:  CLRF   03
16BD4:  MOVF   xC1,W
16BD6:  ADDLW  71
16BD8:  MOVWF  FE9
16BDA:  MOVLW  08
16BDC:  ADDWFC 03,W
16BDE:  MOVWF  FEA
16BE0:  MOVFF  FEF,8C3
16BE4:  MOVF   xC3,W
16BE6:  MOVLB  0
16BE8:  BRA    16B3C
16BEA:  MOVLB  8
16BEC:  INCF   xC1,F
16BEE:  BRA    16BCC
....................                 } 
....................                 charCount = 0; 
16BF0:  CLRF   xC2
....................                 multidrop_off(); 
16BF2:  MOVLB  0
16BF4:  CALL   D8EA
16BF8:  MOVLB  8
....................              } 
....................           } 
16BFA:  BRA    16C1E
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
16BFC:  MOVLW  2A
16BFE:  MOVWF  FF6
16C00:  MOVLW  0F
16C02:  MOVWF  FF7
16C04:  MOVLW  00
16C06:  MOVWF  FF8
16C08:  CLRF   1B
16C0A:  BTFSC  FF2.7
16C0C:  BSF    1B.7
16C0E:  BCF    FF2.7
16C10:  MOVLB  0
16C12:  CALL   0DCC
16C16:  BTFSC  1B.7
16C18:  BSF    FF2.7
....................              charCount = 0; 
16C1A:  MOVLB  8
16C1C:  CLRF   xC2
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
16C1E:  BTFSS  FA4.5
16C20:  BRA    16C38
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
16C22:  MOVLB  0
16C24:  CALL   12BE8
16C28:  MOVFF  01,870
....................           fputc(charFromB, COM_A);                  // send data via USART 
16C2C:  MOVLB  8
16C2E:  MOVF   x70,W
16C30:  MOVLB  0
16C32:  CALL   AEB4
16C36:  MOVLB  8
....................        } 
16C38:  BRA    16B7E
....................    } 
....................  
....................    multidrop_shdn(); 
16C3A:  MOVLB  0
16C3C:  BRA    16B4A
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
16C3E:  MOVLW  3A
16C40:  MOVWF  FF6
16C42:  MOVLW  0F
16C44:  MOVWF  FF7
16C46:  MOVLW  00
16C48:  MOVWF  FF8
16C4A:  CLRF   1B
16C4C:  BTFSC  FF2.7
16C4E:  BSF    1B.7
16C50:  BCF    FF2.7
16C52:  CALL   0DCC
16C56:  BTFSC  1B.7
16C58:  BSF    FF2.7
16C5A:  GOTO   16C74 (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C61A:  MOVLB  8
0C61C:  DECF   x89,F
....................    len=0; 
0C61E:  CLRF   x8A
....................    do { 
....................      c=getc(); 
0C620:  MOVLB  0
0C622:  CALL   0E5C
0C626:  MOVFF  01,88B
....................      if(c==8) {  // Backspace 
0C62A:  MOVLB  8
0C62C:  MOVF   x8B,W
0C62E:  SUBLW  08
0C630:  BNZ   C654
....................         if(len>0) { 
0C632:  MOVF   x8A,F
0C634:  BZ    C652
....................           len--; 
0C636:  DECF   x8A,F
....................           putc(c); 
0C638:  MOVF   x8B,W
0C63A:  MOVLB  0
0C63C:  CALL   AEB4
....................           putc(' '); 
0C640:  MOVLW  20
0C642:  CALL   AEB4
....................           putc(c); 
0C646:  MOVLB  8
0C648:  MOVF   x8B,W
0C64A:  MOVLB  0
0C64C:  CALL   AEB4
0C650:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C652:  BRA    C682
0C654:  MOVF   x8B,W
0C656:  SUBLW  1F
0C658:  BC    C682
0C65A:  MOVF   x8B,W
0C65C:  SUBLW  7E
0C65E:  BNC   C682
....................        if(len<=max) { 
0C660:  MOVF   x8A,W
0C662:  SUBWF  x89,W
0C664:  BNC   C682
....................          s[len++]=c; 
0C666:  MOVF   x8A,W
0C668:  INCF   x8A,F
0C66A:  ADDWF  x87,W
0C66C:  MOVWF  FE9
0C66E:  MOVLW  00
0C670:  ADDWFC x88,W
0C672:  MOVWF  FEA
0C674:  MOVFF  88B,FEF
....................          putc(c); 
0C678:  MOVF   x8B,W
0C67A:  MOVLB  0
0C67C:  CALL   AEB4
0C680:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C682:  MOVF   x8B,W
0C684:  SUBLW  0D
0C686:  BNZ   C620
....................    s[len]=0; 
0C688:  MOVF   x8A,W
0C68A:  ADDWF  x87,W
0C68C:  MOVWF  FE9
0C68E:  MOVLW  00
0C690:  ADDWFC x88,W
0C692:  MOVWF  FEA
0C694:  CLRF   FEF
0C696:  MOVLB  0
0C698:  GOTO   CAA0 (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CA8E:  MOVLW  08
0CA90:  MOVLB  8
0CA92:  MOVWF  x88
0CA94:  MOVLW  6F
0CA96:  MOVWF  x87
0CA98:  MOVLW  14
0CA9A:  MOVWF  x89
0CA9C:  MOVLB  0
0CA9E:  BRA    C61A
....................   f = atof(s); 
0CAA0:  MOVLW  08
0CAA2:  MOVLB  8
0CAA4:  MOVWF  x88
0CAA6:  MOVLW  6F
0CAA8:  MOVWF  x87
0CAAA:  CLRF   x8A
0CAAC:  CLRF   x89
0CAAE:  MOVLB  0
0CAB0:  BRA    C830
0CAB2:  MOVFF  03,886
0CAB6:  MOVFF  02,885
0CABA:  MOVFF  01,884
0CABE:  MOVFF  00,883
....................   return(f); 
0CAC2:  MOVFF  883,00
0CAC6:  MOVFF  884,01
0CACA:  MOVFF  885,02
0CACE:  MOVFF  886,03
0CAD2:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
0299C:  MOVLW  2F
0299E:  MOVWF  F92
....................    set_tris_b(0b00110111); 
029A0:  MOVLW  37
029A2:  MOVWF  F93
....................    set_tris_c(0b10010000); 
029A4:  MOVLW  90
029A6:  MOVWF  F94
....................    set_tris_d(0b00100000); 
029A8:  MOVLW  20
029AA:  MOVWF  F95
....................    set_tris_e(0b01000000); 
029AC:  MOVLW  40
029AE:  MOVWF  F96
....................    set_tris_f(0b00000000); 
029B0:  MOVLW  00
029B2:  MOVWF  F97
....................    set_tris_g(0b11100100); 
029B4:  MOVLW  E4
029B6:  MOVWF  F98
....................    set_tris_h(0b01000000); 
029B8:  MOVLW  40
029BA:  MOVWF  F99
....................    set_tris_j(0b00000000); 
029BC:  MOVLW  00
029BE:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
029C0:  BCF    F8E.3
....................    output_low(HB_IN1); 
029C2:  BCF    F8E.4
....................    output_low(HB_IN2); 
029C4:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
029C6:  BCF    F91.3
....................    output_high(EEP_CS);        
029C8:  BSF    F91.2
....................    output_high(RTC_CS); 
029CA:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
029CC:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
029CE:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
029D0:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
029D2:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
029D4:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
029D6:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
029D8:  BCF    F8F.3
....................    delay_ms(20);   
029DA:  MOVLW  14
029DC:  MOVLB  9
029DE:  MOVWF  xD6
029E0:  MOVLB  0
029E2:  RCALL  2972
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
029E4:  BCF    F8E.1
....................    output_low(VDET);     
029E6:  BCF    F90.7
....................    bus_pwr_status=0; 
029E8:  MOVLB  4
029EA:  CLRF   xB2
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
029EC:  BSF    F8C.2
....................    output_high(DAC_CS); 
029EE:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
029F0:  BCF    F8C.0
....................    output_low(HSW2); 
029F2:  BCF    F8C.1
....................    heater_stat=0; 
029F4:  CLRF   xB1
029F6:  MOVLB  0
029F8:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
1586E:  BSF    F91.1
....................    output_low(EEP_WP);        
15870:  BCF    F91.3
....................    output_high(EEP_CS);        
15872:  BSF    F91.2
....................    output_high(RTC_CS);  
15874:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
15876:  BCF    F8E.3
....................    output_low(HB_IN1);        
15878:  BCF    F8E.4
....................    output_low(HB_IN2); 
1587A:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
1587C:  BCF    F8C.2
....................    output_low(DAC_CS); 
1587E:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
15880:  BCF    F8C.0
....................    output_low(HSW2); 
15882:  BCF    F8C.1
....................    heater_stat=0; 
15884:  MOVLB  4
15886:  CLRF   xB1
....................    // Power switches 
....................    output_low(VMOT);         
15888:  BCF    F8E.1
....................    output_low(VDET);  
1588A:  BCF    F90.7
....................    bus_pwr_status=0; 
1588C:  CLRF   xB2
....................    output_low(VENC1);         
1588E:  BCF    F8E.6
....................    output_low(VENC2);         
15890:  BCF    F8E.7
....................    output_low(VHBRDG);  
15892:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
15894:  MOVLW  42
15896:  MOVWF  FF6
15898:  MOVLW  0F
1589A:  MOVWF  FF7
1589C:  MOVLW  00
1589E:  MOVWF  FF8
158A0:  CLRF   1B
158A2:  BTFSC  FF2.7
158A4:  BSF    1B.7
158A6:  BCF    FF2.7
158A8:  MOVLB  0
158AA:  CALL   0DCC
158AE:  BTFSC  1B.7
158B0:  BSF    FF2.7
....................    delay_ms(50); 
158B2:  MOVLW  32
158B4:  MOVLB  9
158B6:  MOVWF  xD6
158B8:  MOVLB  0
158BA:  CALL   2972
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
158BE:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
158C0:  BSF    F91.6
....................    output_low(MD1_TXEN); 
158C2:  BCF    F91.5
....................    output_low(MD2_SHDN);    
158C4:  BCF    F8F.0
....................    output_low(MD2_REN); 
158C6:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
158C8:  BCF    F8F.3
....................  
....................    delay_ms(30); 
158CA:  MOVLW  1E
158CC:  MOVLB  9
158CE:  MOVWF  xD6
158D0:  MOVLB  0
158D2:  CALL   2972
158D6:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
05092:  MOVLB  8
05094:  CLRF   x73
05096:  MOVF   x73,W
05098:  SUBLW  02
0509A:  BNC   50C0
....................       FS_Status = f_mountdrv(); 
0509C:  MOVLB  0
0509E:  RCALL  48AE
050A0:  MOVFF  01,720
....................       if (FS_Status) 
050A4:  MOVLB  7
050A6:  MOVF   x20,F
050A8:  BZ    50B4
....................          { 
....................          display_file_result(FS_Status); 
050AA:  MOVFF  720,874
050AE:  MOVLB  0
050B0:  BRA    4E4C
....................          } 
050B2:  BRA    50BA
....................       else break; 
050B4:  MOVLB  8
050B6:  BRA    50C0
050B8:  MOVLB  0
050BA:  MOVLB  8
050BC:  INCF   x73,F
050BE:  BRA    5096
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
050C0:  MOVLW  3E
050C2:  MOVWF  xD8
050C4:  CLRF   xDA
050C6:  MOVFF  720,8D9
050CA:  MOVLB  0
050CC:  RCALL  502C
....................     
....................    return(FS_Status); 
050CE:  MOVLB  7
050D0:  MOVFF  720,01
050D4:  MOVLB  0
050D6:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
0315E:  MOVLW  01
03160:  MOVLB  8
03162:  MOVWF  x6D
03164:  MOVF   x6D,W
03166:  SUBLW  03
03168:  BNC   31A4
....................    { 
....................       output_bit(BOARD_LED, ON); 
0316A:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
0316C:  MOVF   2F,W
0316E:  SUBLW  02
03170:  BNZ   3178
03172:  MOVF   30,F
03174:  BNZ   3178
03176:  BSF    F90.6
....................       delay_ms(32); 
03178:  MOVLW  20
0317A:  MOVLB  9
0317C:  MOVWF  xD6
0317E:  MOVLB  0
03180:  CALL   2972
....................       output_bit(BOARD_LED, OFF); 
03184:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
03186:  MOVF   2F,W
03188:  SUBLW  02
0318A:  BNZ   3192
0318C:  MOVF   30,F
0318E:  BNZ   3192
03190:  BCF    F90.6
....................       delay_ms(32); 
03192:  MOVLW  20
03194:  MOVLB  9
03196:  MOVWF  xD6
03198:  MOVLB  0
0319A:  CALL   2972
0319E:  MOVLB  8
031A0:  INCF   x6D,F
031A2:  BRA    3164
....................    } 
031A4:  MOVLB  0
031A6:  GOTO   1B26A (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
05154:  MOVLB  8
05156:  CLRF   xDD
05158:  CLRF   xDC
0515A:  CLRF   xDB
0515C:  CLRF   xDA
....................    set_adc_channel(0,VSS); 
0515E:  MOVLW  00
05160:  MOVWF  01
05162:  MOVF   FC2,W
05164:  ANDLW  83
05166:  IORWF  01,W
05168:  MOVWF  FC2
0516A:  MOVLW  00
0516C:  MOVWF  01
0516E:  MOVF   FC1,W
05170:  ANDLW  F8
05172:  IORWF  01,W
05174:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
05176:  MOVLW  01
05178:  MOVWF  xD7
0517A:  MOVF   xD7,W
0517C:  SUBLW  32
0517E:  BNC   51A4
....................       reading=read_adc(); 
05180:  BSF    FC2.1
05182:  BTFSC  FC2.1
05184:  BRA    5182
05186:  MOVFF  FC3,8DE
0518A:  MOVFF  FC4,8DF
0518E:  CLRF   xE0
05190:  CLRF   xE1
....................       delay_ms(5); 
05192:  MOVLW  05
05194:  MOVLB  9
05196:  MOVWF  xD6
05198:  MOVLB  0
0519A:  CALL   2972
0519E:  MOVLB  8
051A0:  INCF   xD7,F
051A2:  BRA    517A
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
051A4:  MOVLW  01
051A6:  MOVWF  xD7
051A8:  MOVF   xD7,W
051AA:  SUBLW  64
051AC:  BNC   525A
....................       reading=read_adc(); 
051AE:  BSF    FC2.1
051B0:  BTFSC  FC2.1
051B2:  BRA    51B0
051B4:  MOVFF  FC3,8DE
051B8:  MOVFF  FC4,8DF
051BC:  CLRF   xE0
051BE:  CLRF   xE1
....................       result=(((result*(i-1))+reading)/i); 
051C0:  MOVLW  01
051C2:  SUBWF  xD7,W
051C4:  MOVWF  xE2
051C6:  MOVFF  8DD,9E3
051CA:  MOVFF  8DC,9E2
051CE:  MOVFF  8DB,9E1
051D2:  MOVFF  8DA,9E0
051D6:  MOVLB  9
051D8:  CLRF   xE7
051DA:  CLRF   xE6
051DC:  CLRF   xE5
051DE:  MOVWF  xE4
051E0:  MOVLB  0
051E2:  CALL   4852
051E6:  MOVFF  03,8E5
051EA:  MOVFF  02,8E4
051EE:  MOVFF  01,8E3
051F2:  MOVFF  00,8E2
051F6:  MOVLB  8
051F8:  MOVF   xDE,W
051FA:  ADDWF  xE2,F
051FC:  MOVF   xDF,W
051FE:  ADDWFC xE3,F
05200:  MOVF   xE0,W
05202:  ADDWFC xE4,F
05204:  MOVF   xE1,W
05206:  ADDWFC xE5,F
05208:  BCF    FD8.1
0520A:  CLRF   1B
0520C:  BTFSC  FF2.7
0520E:  BSF    1B.7
05210:  BCF    FF2.7
05212:  MOVFF  8E5,A34
05216:  MOVFF  8E4,A33
0521A:  MOVFF  8E3,A32
0521E:  MOVFF  8E2,A31
05222:  MOVLB  A
05224:  CLRF   x38
05226:  CLRF   x37
05228:  CLRF   x36
0522A:  MOVFF  8D7,A35
0522E:  MOVLB  0
05230:  CALL   1050
05234:  BTFSC  1B.7
05236:  BSF    FF2.7
05238:  MOVFF  03,8DD
0523C:  MOVFF  02,8DC
05240:  MOVFF  01,8DB
05244:  MOVFF  00,8DA
....................       delay_ms(5); 
05248:  MOVLW  05
0524A:  MOVLB  9
0524C:  MOVWF  xD6
0524E:  MOVLB  0
05250:  CALL   2972
05254:  MOVLB  8
05256:  INCF   xD7,F
05258:  BRA    51A8
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
0525A:  MOVFF  8DD,9E3
0525E:  MOVFF  8DC,9E2
05262:  MOVFF  8DB,9E1
05266:  MOVFF  8DA,9E0
0526A:  MOVLB  9
0526C:  CLRF   xE7
0526E:  CLRF   xE6
05270:  CLRF   xE5
05272:  MOVLW  64
05274:  MOVWF  xE4
05276:  MOVLB  0
05278:  CALL   4852
0527C:  MOVFF  03,8E5
05280:  MOVFF  02,8E4
05284:  MOVFF  01,8E3
05288:  MOVFF  00,8E2
0528C:  BCF    FD8.1
0528E:  CLRF   1B
05290:  BTFSC  FF2.7
05292:  BSF    1B.7
05294:  BCF    FF2.7
05296:  MOVFF  03,A34
0529A:  MOVFF  02,A33
0529E:  MOVFF  01,A32
052A2:  MOVFF  00,A31
052A6:  MOVLB  A
052A8:  CLRF   x38
052AA:  CLRF   x37
052AC:  MOVLW  01
052AE:  MOVWF  x36
052B0:  MOVLW  10
052B2:  MOVWF  x35
052B4:  MOVLB  0
052B6:  CALL   1050
052BA:  BTFSC  1B.7
052BC:  BSF    FF2.7
052BE:  MOVLW  56
052C0:  MOVLB  8
052C2:  ADDWF  00,W
052C4:  MOVWF  xD8
052C6:  MOVLW  00
052C8:  ADDWFC 01,W
052CA:  MOVWF  xD9
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
052CC:  MOVFF  8D8,01
052D0:  MOVFF  8D9,02
052D4:  MOVLB  0
052D6:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
0513E:  MOVLW  02
05140:  MOVWF  FEA
05142:  MOVLW  95
05144:  MOVWF  FE9
05146:  CLRF   00
05148:  CLRF   02
0514A:  MOVLW  1E
0514C:  MOVWF  01
0514E:  CALL   3588
05152:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12B10:  MOVLW  02
12B12:  MOVWF  FEA
12B14:  MOVLW  B3
12B16:  MOVWF  FE9
12B18:  CLRF   00
12B1A:  CLRF   02
12B1C:  MOVLW  1E
12B1E:  MOVWF  01
12B20:  CALL   3588
12B24:  GOTO   12DCE (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
05472:  RCALL  513E
....................     
....................    v_supply = read_supply(); 
05474:  RCALL  5154
05476:  MOVFF  02,8D6
0547A:  MOVFF  01,8D5
....................    RTC_read(); 
0547E:  CALL   33A6
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
05482:  MOVLW  02
05484:  MOVWF  1E
05486:  MOVLW  95
05488:  MOVWF  1D
0548A:  MOVFF  726,8D7
0548E:  MOVLW  01
05490:  MOVLB  8
05492:  MOVWF  xD8
05494:  MOVLB  0
05496:  RCALL  52D8
05498:  MOVLW  2F
0549A:  MOVLB  8
0549C:  MOVWF  xE9
0549E:  MOVLB  0
054A0:  RCALL  50F6
054A2:  MOVFF  725,8D7
054A6:  MOVLW  01
054A8:  MOVLB  8
054AA:  MOVWF  xD8
054AC:  MOVLB  0
054AE:  RCALL  52D8
054B0:  MOVLW  2F
054B2:  MOVLB  8
054B4:  MOVWF  xE9
054B6:  MOVLB  0
054B8:  RCALL  50F6
054BA:  MOVFF  727,8D7
054BE:  MOVLW  01
054C0:  MOVLB  8
054C2:  MOVWF  xD8
054C4:  MOVLB  0
054C6:  RCALL  52D8
054C8:  MOVLW  20
054CA:  MOVLB  8
054CC:  MOVWF  xE9
054CE:  MOVLB  0
054D0:  RCALL  50F6
054D2:  MOVFF  723,8D7
054D6:  MOVLW  01
054D8:  MOVLB  8
054DA:  MOVWF  xD8
054DC:  MOVLB  0
054DE:  RCALL  52D8
054E0:  MOVLW  3A
054E2:  MOVLB  8
054E4:  MOVWF  xE9
054E6:  MOVLB  0
054E8:  RCALL  50F6
054EA:  MOVFF  722,8D7
054EE:  MOVLW  01
054F0:  MOVLB  8
054F2:  MOVWF  xD8
054F4:  MOVLB  0
054F6:  RCALL  52D8
054F8:  MOVLW  3A
054FA:  MOVLB  8
054FC:  MOVWF  xE9
054FE:  MOVLB  0
05500:  RCALL  50F6
05502:  MOVFF  721,8D7
05506:  MOVLW  01
05508:  MOVLB  8
0550A:  MOVWF  xD8
0550C:  MOVLB  0
0550E:  RCALL  52D8
05510:  MOVLW  2C
05512:  MOVLB  8
05514:  MOVWF  xE9
05516:  MOVLB  0
05518:  RCALL  50F6
0551A:  MOVLW  44
0551C:  MOVWF  FE9
0551E:  MOVLB  8
05520:  CLRF   xDA
05522:  CLRF   xD9
05524:  MOVFF  8D6,8D8
05528:  MOVFF  8D5,8D7
0552C:  MOVLW  02
0552E:  MOVWF  xDB
05530:  MOVLB  0
05532:  RCALL  5372
05534:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
0851A:  MOVLB  2
0851C:  MOVF   xD8,F
0851E:  BNZ   859A
....................    { 
....................       strcopy(event_buffer,""); 
08520:  MOVLW  01
08522:  MOVWF  FEA
08524:  MOVLW  03
08526:  MOVWF  FE9
08528:  MOVLW  00
0852A:  MOVLB  0
0852C:  CALL   02CE
08530:  TBLRD*-
08532:  TBLRD*+
08534:  MOVF   FF5,W
08536:  MOVWF  FEE
08538:  IORLW  00
0853A:  BNZ   8532
....................       time_stamp(); 
0853C:  CALL   5472
....................       strcat(event_buffer, time_stmp_str); 
08540:  MOVLW  01
08542:  MOVLB  8
08544:  MOVWF  xE3
08546:  MOVLW  03
08548:  MOVWF  xE2
0854A:  MOVLW  02
0854C:  MOVWF  xE5
0854E:  MOVLW  95
08550:  MOVWF  xE4
08552:  MOVLB  0
08554:  CALL   5536
....................       strcat(event_buffer, event_str); 
08558:  MOVLW  01
0855A:  MOVLB  8
0855C:  MOVWF  xE3
0855E:  MOVLW  03
08560:  MOVWF  xE2
08562:  MOVLW  01
08564:  MOVWF  xE5
08566:  MOVLW  A3
08568:  MOVWF  xE4
0856A:  MOVLB  0
0856C:  CALL   5536
....................       buffer_select = 1; 
08570:  MOVLW  01
08572:  MOVWF  x62
....................     
....................       heartbeat(FALSE); 
08574:  MOVLB  8
08576:  CLRF   xD7
08578:  MOVLB  0
0857A:  CALL   55DA
....................          append_data(file_ptr_events); 
0857E:  MOVLW  03
08580:  MOVLB  8
08582:  MOVWF  xD8
08584:  MOVLW  11
08586:  MOVWF  xD7
08588:  MOVLB  0
0858A:  RCALL  8338
....................       heartbeat(TRUE); 
0858C:  MOVLW  01
0858E:  MOVLB  8
08590:  MOVWF  xD7
08592:  MOVLB  0
08594:  CALL   55DA
08598:  MOVLB  2
....................    } 
0859A:  MOVLB  0
0859C:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
02926:  BCF    F8B.2
02928:  MOVLW  0C
0292A:  MOVWF  FBB
0292C:  CLRF   FBE
0292E:  CLRF   FBF
02930:  MOVLW  01
02932:  MOVWF  F9C
02934:  MOVLW  F8
02936:  MOVLB  F
02938:  ANDWF  x2D,F
0293A:  MOVLW  00
0293C:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
0293E:  BCF    F8B.1
02940:  MOVLW  0C
02942:  MOVWF  x4E
02944:  CLRF   x51
02946:  CLRF   x52
02948:  MOVLW  01
0294A:  MOVWF  x1B
0294C:  MOVLW  C7
0294E:  ANDWF  x2D,F
02950:  MOVLW  00
02952:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
02954:  IORLW  05
02956:  MOVWF  FCA
02958:  MOVLW  7F
0295A:  MOVWF  FCB
0295C:  MOVLB  0
0295E:  GOTO   1B220 (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09D42:  MOVLW  4C
09D44:  MOVWF  FF6
09D46:  MOVLW  0F
09D48:  MOVWF  FF7
09D4A:  MOVLW  00
09D4C:  MOVWF  FF8
09D4E:  CLRF   1B
09D50:  BTFSC  FF2.7
09D52:  BSF    1B.7
09D54:  BCF    FF2.7
09D56:  MOVLW  05
09D58:  MOVLB  A
09D5A:  MOVWF  x25
09D5C:  MOVLB  0
09D5E:  CALL   101E
09D62:  BTFSC  1B.7
09D64:  BSF    FF2.7
09D66:  MOVLW  10
09D68:  MOVWF  FE9
09D6A:  CLRF   1B
09D6C:  BTFSC  FF2.7
09D6E:  BSF    1B.7
09D70:  BCF    FF2.7
09D72:  MOVFF  793,A26
09D76:  MOVFF  792,A25
09D7A:  CALL   11A0
09D7E:  BTFSC  1B.7
09D80:  BSF    FF2.7
09D82:  MOVLW  2C
09D84:  BTFSS  F9E.4
09D86:  BRA    9D84
09D88:  MOVWF  FAD
09D8A:  MOVLW  10
09D8C:  MOVWF  FE9
09D8E:  CLRF   1B
09D90:  BTFSC  FF2.7
09D92:  BSF    1B.7
09D94:  BCF    FF2.7
09D96:  MOVFF  795,A26
09D9A:  MOVFF  794,A25
09D9E:  CALL   11A0
09DA2:  BTFSC  1B.7
09DA4:  BSF    FF2.7
09DA6:  MOVLW  0D
09DA8:  BTFSS  F9E.4
09DAA:  BRA    9DA8
09DAC:  MOVWF  FAD
09DAE:  MOVLW  0A
09DB0:  BTFSS  F9E.4
09DB2:  BRA    9DB0
09DB4:  MOVWF  FAD
09DB6:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02D7C:  MOVLW  86
02D7E:  MOVLB  8
02D80:  MOVWF  x81
02D82:  MOVLB  0
02D84:  RCALL  2A2C
02D86:  MOVFF  02,73F
02D8A:  MOVFF  01,73E
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02D8E:  MOVLW  8A
02D90:  MOVLB  8
02D92:  MOVWF  x81
02D94:  MOVLB  0
02D96:  RCALL  2A2C
02D98:  MOVFF  02,743
02D9C:  MOVFF  01,742
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02DA0:  MOVLW  8E
02DA2:  MOVLB  8
02DA4:  MOVWF  x81
02DA6:  MOVLB  0
02DA8:  RCALL  2A2C
02DAA:  MOVFF  02,747
02DAE:  MOVFF  01,746
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02DB2:  MOVLW  92
02DB4:  MOVLB  8
02DB6:  MOVWF  x81
02DB8:  MOVLB  0
02DBA:  RCALL  2A2C
02DBC:  MOVFF  02,74B
02DC0:  MOVFF  01,74A
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02DC4:  MOVLW  96
02DC6:  MOVLB  8
02DC8:  MOVWF  x81
02DCA:  MOVLB  0
02DCC:  RCALL  2A2C
02DCE:  MOVFF  02,74F
02DD2:  MOVFF  01,74E
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02DD6:  MOVLW  9A
02DD8:  MOVLB  8
02DDA:  MOVWF  x81
02DDC:  MOVLB  0
02DDE:  RCALL  2A2C
02DE0:  MOVFF  02,753
02DE4:  MOVFF  01,752
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02DE8:  MOVLW  9E
02DEA:  MOVLB  8
02DEC:  MOVWF  x81
02DEE:  MOVLB  0
02DF0:  RCALL  2A2C
02DF2:  MOVFF  02,757
02DF6:  MOVFF  01,756
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02DFA:  MOVLW  A2
02DFC:  MOVLB  8
02DFE:  MOVWF  x81
02E00:  MOVLB  0
02E02:  RCALL  2A2C
02E04:  MOVFF  02,75B
02E08:  MOVFF  01,75A
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02E0C:  MOVLW  A6
02E0E:  MOVLB  8
02E10:  MOVWF  x81
02E12:  MOVLB  0
02E14:  RCALL  2A2C
02E16:  MOVFF  02,75F
02E1A:  MOVFF  01,75E
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02E1E:  MOVLW  82
02E20:  MOVLB  8
02E22:  MOVWF  x81
02E24:  MOVLB  0
02E26:  RCALL  2A2C
02E28:  MOVFF  02,763
02E2C:  MOVFF  01,762
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02E30:  MOVLW  7E
02E32:  MOVLB  8
02E34:  MOVWF  x81
02E36:  MOVLB  0
02E38:  RCALL  2A2C
02E3A:  MOVFF  02,7BC
02E3E:  MOVFF  01,7BB
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02E42:  MOVLW  AA
02E44:  MOVLB  8
02E46:  MOVWF  x81
02E48:  MOVLB  0
02E4A:  RCALL  2A2C
02E4C:  MOVFF  02,7C0
02E50:  MOVFF  01,7BF
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02E54:  MOVLW  7A
02E56:  MOVLB  8
02E58:  MOVWF  x81
02E5A:  MOVLB  0
02E5C:  RCALL  2A2C
02E5E:  MOVFF  02,767
02E62:  MOVFF  01,766
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02E66:  MOVLW  76
02E68:  MOVLB  8
02E6A:  MOVWF  x81
02E6C:  MOVLB  0
02E6E:  RCALL  2A2C
02E70:  MOVFF  02,76B
02E74:  MOVFF  01,76A
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02E78:  MOVLW  72
02E7A:  MOVLB  8
02E7C:  MOVWF  x81
02E7E:  MOVLB  0
02E80:  RCALL  2A2C
02E82:  MOVFF  02,76F
02E86:  MOVFF  01,76E
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02E8A:  MOVLW  6E
02E8C:  MOVLB  8
02E8E:  MOVWF  x81
02E90:  MOVLB  0
02E92:  RCALL  2A2C
02E94:  MOVFF  02,793
02E98:  MOVFF  01,792
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02E9C:  MOVLW  AE
02E9E:  MOVLB  8
02EA0:  MOVWF  x81
02EA2:  MOVLB  0
02EA4:  RCALL  2A2C
02EA6:  MOVFF  02,773
02EAA:  MOVFF  01,772
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02EAE:  MOVLW  B2
02EB0:  MOVLB  8
02EB2:  MOVWF  x81
02EB4:  MOVLB  0
02EB6:  RCALL  2A2C
02EB8:  MOVFF  02,7AC
02EBC:  MOVFF  01,7AB
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02EC0:  MOVLW  B6
02EC2:  MOVLB  8
02EC4:  MOVWF  x81
02EC6:  MOVLB  0
02EC8:  RCALL  2A2C
02ECA:  MOVFF  02,7B0
02ECE:  MOVFF  01,7AF
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02ED2:  MOVLW  BA
02ED4:  MOVLB  8
02ED6:  MOVWF  x81
02ED8:  MOVLB  0
02EDA:  RCALL  2A2C
02EDC:  MOVFF  02,777
02EE0:  MOVFF  01,776
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02EE4:  MOVLW  BE
02EE6:  MOVLB  8
02EE8:  MOVWF  x81
02EEA:  MOVLB  0
02EEC:  RCALL  2A2C
02EEE:  MOVFF  02,77B
02EF2:  MOVFF  01,77A
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02EF6:  MOVLW  C2
02EF8:  MOVLB  8
02EFA:  MOVWF  x81
02EFC:  MOVLB  0
02EFE:  RCALL  2A2C
02F00:  MOVFF  02,77F
02F04:  MOVFF  01,77E
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02F08:  MOVLW  88
02F0A:  MOVLB  8
02F0C:  MOVWF  x81
02F0E:  MOVLB  0
02F10:  RCALL  2A2C
02F12:  MOVFF  02,741
02F16:  MOVFF  01,740
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02F1A:  MOVLW  8C
02F1C:  MOVLB  8
02F1E:  MOVWF  x81
02F20:  MOVLB  0
02F22:  RCALL  2A2C
02F24:  MOVFF  02,745
02F28:  MOVFF  01,744
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02F2C:  MOVLW  90
02F2E:  MOVLB  8
02F30:  MOVWF  x81
02F32:  MOVLB  0
02F34:  RCALL  2A2C
02F36:  MOVFF  02,749
02F3A:  MOVFF  01,748
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02F3E:  MOVLW  94
02F40:  MOVLB  8
02F42:  MOVWF  x81
02F44:  MOVLB  0
02F46:  RCALL  2A2C
02F48:  MOVFF  02,74D
02F4C:  MOVFF  01,74C
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02F50:  MOVLW  98
02F52:  MOVLB  8
02F54:  MOVWF  x81
02F56:  MOVLB  0
02F58:  RCALL  2A2C
02F5A:  MOVFF  02,751
02F5E:  MOVFF  01,750
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02F62:  MOVLW  9C
02F64:  MOVLB  8
02F66:  MOVWF  x81
02F68:  MOVLB  0
02F6A:  RCALL  2A2C
02F6C:  MOVFF  02,755
02F70:  MOVFF  01,754
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02F74:  MOVLW  A0
02F76:  MOVLB  8
02F78:  MOVWF  x81
02F7A:  MOVLB  0
02F7C:  RCALL  2A2C
02F7E:  MOVFF  02,759
02F82:  MOVFF  01,758
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02F86:  MOVLW  A4
02F88:  MOVLB  8
02F8A:  MOVWF  x81
02F8C:  MOVLB  0
02F8E:  RCALL  2A2C
02F90:  MOVFF  02,75D
02F94:  MOVFF  01,75C
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02F98:  MOVLW  A8
02F9A:  MOVLB  8
02F9C:  MOVWF  x81
02F9E:  MOVLB  0
02FA0:  RCALL  2A2C
02FA2:  MOVFF  02,761
02FA6:  MOVFF  01,760
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02FAA:  MOVLW  84
02FAC:  MOVLB  8
02FAE:  MOVWF  x81
02FB0:  MOVLB  0
02FB2:  RCALL  2A2C
02FB4:  MOVFF  02,765
02FB8:  MOVFF  01,764
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02FBC:  MOVLW  80
02FBE:  MOVLB  8
02FC0:  MOVWF  x81
02FC2:  MOVLB  0
02FC4:  RCALL  2A2C
02FC6:  MOVFF  02,7BE
02FCA:  MOVFF  01,7BD
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02FCE:  MOVLW  AC
02FD0:  MOVLB  8
02FD2:  MOVWF  x81
02FD4:  MOVLB  0
02FD6:  RCALL  2A2C
02FD8:  MOVFF  02,7C2
02FDC:  MOVFF  01,7C1
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02FE0:  MOVLW  7C
02FE2:  MOVLB  8
02FE4:  MOVWF  x81
02FE6:  MOVLB  0
02FE8:  RCALL  2A2C
02FEA:  MOVFF  02,769
02FEE:  MOVFF  01,768
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02FF2:  MOVLW  78
02FF4:  MOVLB  8
02FF6:  MOVWF  x81
02FF8:  MOVLB  0
02FFA:  RCALL  2A2C
02FFC:  MOVFF  02,76D
03000:  MOVFF  01,76C
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
03004:  MOVLW  74
03006:  MOVLB  8
03008:  MOVWF  x81
0300A:  MOVLB  0
0300C:  RCALL  2A2C
0300E:  MOVFF  02,771
03012:  MOVFF  01,770
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
03016:  MOVLW  70
03018:  MOVLB  8
0301A:  MOVWF  x81
0301C:  MOVLB  0
0301E:  RCALL  2A2C
03020:  MOVFF  02,795
03024:  MOVFF  01,794
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
03028:  MOVLW  B0
0302A:  MOVLB  8
0302C:  MOVWF  x81
0302E:  MOVLB  0
03030:  RCALL  2A2C
03032:  MOVFF  02,775
03036:  MOVFF  01,774
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
0303A:  MOVLW  B4
0303C:  MOVLB  8
0303E:  MOVWF  x81
03040:  MOVLB  0
03042:  RCALL  2A2C
03044:  MOVFF  02,7AE
03048:  MOVFF  01,7AD
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
0304C:  MOVLW  B8
0304E:  MOVLB  8
03050:  MOVWF  x81
03052:  MOVLB  0
03054:  RCALL  2A2C
03056:  MOVFF  02,7B2
0305A:  MOVFF  01,7B1
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
0305E:  MOVLW  BC
03060:  MOVLB  8
03062:  MOVWF  x81
03064:  MOVLB  0
03066:  RCALL  2A2C
03068:  MOVFF  02,779
0306C:  MOVFF  01,778
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
03070:  MOVLW  C0
03072:  MOVLB  8
03074:  MOVWF  x81
03076:  MOVLB  0
03078:  RCALL  2A2C
0307A:  MOVFF  02,77D
0307E:  MOVFF  01,77C
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
03082:  MOVLW  C4
03084:  MOVLB  8
03086:  MOVWF  x81
03088:  MOVLB  0
0308A:  RCALL  2A2C
0308C:  MOVFF  02,781
03090:  MOVFF  01,780
....................     
....................    motor=0; 
03094:  MOVLB  7
03096:  CLRF   x3C
....................    m_fixed=1; 
03098:  MOVLW  01
0309A:  MOVWF  x3D
....................    m_step_cnt[0]=0; 
0309C:  CLRF   xA1
0309E:  CLRF   xA0
030A0:  CLRF   x9F
030A2:  CLRF   x9E
....................    m_step_cnt[1]=0; 
030A4:  CLRF   xA5
030A6:  CLRF   xA4
030A8:  CLRF   xA3
030AA:  CLRF   xA2
....................    e_cha_cnt[0]=0; 
030AC:  CLRF   xB8
030AE:  CLRF   xB7
....................    e_cha_cnt[1]=0;  
030B0:  CLRF   xBA
030B2:  CLRF   xB9
....................    m_gb_cnt[0]=0; 
030B4:  CLRF   x97
030B6:  CLRF   x96
....................    m_gb_cnt[1]=0; 
030B8:  CLRF   x99
030BA:  CLRF   x98
....................    e_mode_rst[0]=0; 
030BC:  CLRF   x9B
030BE:  CLRF   x9A
....................    e_mode_rst[1]=0;    
030C0:  CLRF   x9D
030C2:  CLRF   x9C
....................    e_port_dist[0]=0; 
030C4:  CLRF   xB4
030C6:  CLRF   xB3
....................    e_port_dist[1]=0; 
030C8:  CLRF   xB6
030CA:  CLRF   xB5
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
030CC:  MOVFF  773,8C6
030D0:  MOVFF  772,8C5
030D4:  MOVFF  75F,8C8
030D8:  MOVFF  75E,8C7
030DC:  MOVLB  0
030DE:  RCALL  2D36
030E0:  BCF    FD8.0
030E2:  MOVLB  8
030E4:  RLCF   01,W
030E6:  MOVLB  7
030E8:  MOVWF  xA7
030EA:  MOVLB  8
030EC:  RLCF   02,W
030EE:  MOVLB  7
030F0:  MOVWF  xA8
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
030F2:  MOVFF  775,8C6
030F6:  MOVFF  774,8C5
030FA:  MOVFF  761,8C8
030FE:  MOVFF  760,8C7
03102:  MOVLB  0
03104:  RCALL  2D36
03106:  BCF    FD8.0
03108:  MOVLB  8
0310A:  RLCF   01,W
0310C:  MOVLB  7
0310E:  MOVWF  xA9
03110:  MOVLB  8
03112:  RLCF   02,W
03114:  MOVLB  7
03116:  MOVWF  xAA
03118:  MOVLB  0
0311A:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
19C8E:  MOVLW  86
19C90:  MOVLB  8
19C92:  MOVWF  xD8
19C94:  CLRF   xDA
19C96:  MOVLW  01
19C98:  MOVWF  xD9
19C9A:  MOVLB  0
19C9C:  CALL   502C
....................    write16(ADDR_M1_MODE,FULL); 
19CA0:  MOVLW  8A
19CA2:  MOVLB  8
19CA4:  MOVWF  xD8
19CA6:  CLRF   xDA
19CA8:  CLRF   xD9
19CAA:  MOVLB  0
19CAC:  CALL   502C
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
19CB0:  MOVLW  8E
19CB2:  MOVLB  8
19CB4:  MOVWF  xD8
19CB6:  CLRF   xDA
19CB8:  MOVLW  0A
19CBA:  MOVWF  xD9
19CBC:  MOVLB  0
19CBE:  CALL   502C
....................    write16(ADDR_M1_POS_DIR,0); 
19CC2:  MOVLW  92
19CC4:  MOVLB  8
19CC6:  MOVWF  xD8
19CC8:  CLRF   xDA
19CCA:  CLRF   xD9
19CCC:  MOVLB  0
19CCE:  CALL   502C
....................    write16(ADDR_M1_PWM_HLD,0); 
19CD2:  MOVLW  96
19CD4:  MOVLB  8
19CD6:  MOVWF  xD8
19CD8:  CLRF   xDA
19CDA:  CLRF   xD9
19CDC:  MOVLB  0
19CDE:  CALL   502C
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
19CE2:  MOVLW  9A
19CE4:  MOVLB  8
19CE6:  MOVWF  xD8
19CE8:  CLRF   xDA
19CEA:  MOVLW  7F
19CEC:  MOVWF  xD9
19CEE:  MOVLB  0
19CF0:  CALL   502C
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
19CF4:  MOVLW  9E
19CF6:  MOVLB  8
19CF8:  MOVWF  xD8
19CFA:  MOVLW  17
19CFC:  MOVWF  xDA
19CFE:  MOVLW  70
19D00:  MOVWF  xD9
19D02:  MOVLB  0
19D04:  CALL   502C
....................    write16(ADDR_E1_CPR,16); 
19D08:  MOVLW  A2
19D0A:  MOVLB  8
19D0C:  MOVWF  xD8
19D0E:  CLRF   xDA
19D10:  MOVLW  10
19D12:  MOVWF  xD9
19D14:  MOVLB  0
19D16:  CALL   502C
....................    write16(ADDR_E1_PPR,16); 
19D1A:  MOVLW  A6
19D1C:  MOVLB  8
19D1E:  MOVWF  xD8
19D20:  CLRF   xDA
19D22:  MOVLW  10
19D24:  MOVWF  xD9
19D26:  MOVLB  0
19D28:  CALL   502C
....................    write16(ADDR_E1_MODE,2); 
19D2C:  MOVLW  82
19D2E:  MOVLB  8
19D30:  MOVWF  xD8
19D32:  CLRF   xDA
19D34:  MOVLW  02
19D36:  MOVWF  xD9
19D38:  MOVLB  0
19D3A:  CALL   502C
....................    write16(ADDR_E1_POS,0); 
19D3E:  MOVLW  7E
19D40:  MOVLB  8
19D42:  MOVWF  xD8
19D44:  CLRF   xDA
19D46:  CLRF   xD9
19D48:  MOVLB  0
19D4A:  CALL   502C
....................    write16(ADDR_E1_PORT,0); 
19D4E:  MOVLW  AA
19D50:  MOVLB  8
19D52:  MOVWF  xD8
19D54:  CLRF   xDA
19D56:  CLRF   xD9
19D58:  MOVLB  0
19D5A:  CALL   502C
....................    write16(ADDR_E1_TYPE,2); 
19D5E:  MOVLW  7A
19D60:  MOVLB  8
19D62:  MOVWF  xD8
19D64:  CLRF   xDA
19D66:  MOVLW  02
19D68:  MOVWF  xD9
19D6A:  MOVLB  0
19D6C:  CALL   502C
....................    write16(ADDR_M1_RUN,270); 
19D70:  MOVLW  76
19D72:  MOVLB  8
19D74:  MOVWF  xD8
19D76:  MOVLW  01
19D78:  MOVWF  xDA
19D7A:  MOVLW  0E
19D7C:  MOVWF  xD9
19D7E:  MOVLB  0
19D80:  CALL   502C
....................    write16(ADDR_M1_BKLSH,0); 
19D84:  MOVLW  72
19D86:  MOVLB  8
19D88:  MOVWF  xD8
19D8A:  CLRF   xDA
19D8C:  CLRF   xD9
19D8E:  MOVLB  0
19D90:  CALL   502C
....................    write16(ADDR_M1_ERROR,0);   
19D94:  MOVLW  6E
19D96:  MOVLB  8
19D98:  MOVWF  xD8
19D9A:  CLRF   xDA
19D9C:  CLRF   xD9
19D9E:  MOVLB  0
19DA0:  CALL   502C
....................    write16(ADDR_M1_SPR,38400); 
19DA4:  MOVLW  AE
19DA6:  MOVLB  8
19DA8:  MOVWF  xD8
19DAA:  MOVLW  96
19DAC:  MOVWF  xDA
19DAE:  CLRF   xD9
19DB0:  MOVLB  0
19DB2:  CALL   502C
....................    write16(ADDR_M1_COMP,0); 
19DB6:  MOVLW  B2
19DB8:  MOVLB  8
19DBA:  MOVWF  xD8
19DBC:  CLRF   xDA
19DBE:  CLRF   xD9
19DC0:  MOVLB  0
19DC2:  CALL   502C
....................    write16(ADDR_M1_LIN_POS,0); 
19DC6:  MOVLW  B6
19DC8:  MOVLB  8
19DCA:  MOVWF  xD8
19DCC:  CLRF   xDA
19DCE:  CLRF   xD9
19DD0:  MOVLB  0
19DD2:  CALL   502C
....................    write16(ADDR_E1_INDEX,1); 
19DD6:  MOVLW  BA
19DD8:  MOVLB  8
19DDA:  MOVWF  xD8
19DDC:  CLRF   xDA
19DDE:  MOVLW  01
19DE0:  MOVWF  xD9
19DE2:  MOVLB  0
19DE4:  CALL   502C
....................    write16(ADDR_M1_EVN_SO,0); 
19DE8:  MOVLW  BE
19DEA:  MOVLB  8
19DEC:  MOVWF  xD8
19DEE:  CLRF   xDA
19DF0:  CLRF   xD9
19DF2:  MOVLB  0
19DF4:  CALL   502C
....................    write16(ADDR_M1_ALIGN_OS,0); 
19DF8:  MOVLW  C2
19DFA:  MOVLB  8
19DFC:  MOVWF  xD8
19DFE:  CLRF   xDA
19E00:  CLRF   xD9
19E02:  MOVLB  0
19E04:  CALL   502C
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
19E08:  MOVLW  88
19E0A:  MOVLB  8
19E0C:  MOVWF  xD8
19E0E:  CLRF   xDA
19E10:  MOVLW  01
19E12:  MOVWF  xD9
19E14:  MOVLB  0
19E16:  CALL   502C
....................    write16(ADDR_M2_MODE,HALF); 
19E1A:  MOVLW  8C
19E1C:  MOVLB  8
19E1E:  MOVWF  xD8
19E20:  CLRF   xDA
19E22:  MOVLW  01
19E24:  MOVWF  xD9
19E26:  MOVLB  0
19E28:  CALL   502C
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
19E2C:  MOVLW  90
19E2E:  MOVLB  8
19E30:  MOVWF  xD8
19E32:  CLRF   xDA
19E34:  MOVLW  05
19E36:  MOVWF  xD9
19E38:  MOVLB  0
19E3A:  CALL   502C
....................    write16(ADDR_M2_POS_DIR,0); 
19E3E:  MOVLW  94
19E40:  MOVLB  8
19E42:  MOVWF  xD8
19E44:  CLRF   xDA
19E46:  CLRF   xD9
19E48:  MOVLB  0
19E4A:  CALL   502C
....................    write16(ADDR_M2_PWM_HLD,0); 
19E4E:  MOVLW  98
19E50:  MOVLB  8
19E52:  MOVWF  xD8
19E54:  CLRF   xDA
19E56:  CLRF   xD9
19E58:  MOVLB  0
19E5A:  CALL   502C
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
19E5E:  MOVLW  9C
19E60:  MOVLB  8
19E62:  MOVWF  xD8
19E64:  CLRF   xDA
19E66:  MOVLW  7F
19E68:  MOVWF  xD9
19E6A:  MOVLB  0
19E6C:  CALL   502C
....................    write16(ADDR_M2_GB_ERR,0); 
19E70:  MOVLW  A0
19E72:  MOVLB  8
19E74:  MOVWF  xD8
19E76:  CLRF   xDA
19E78:  CLRF   xD9
19E7A:  MOVLB  0
19E7C:  CALL   502C
....................    write16(ADDR_E2_CPR,0); 
19E80:  MOVLW  A4
19E82:  MOVLB  8
19E84:  MOVWF  xD8
19E86:  CLRF   xDA
19E88:  CLRF   xD9
19E8A:  MOVLB  0
19E8C:  CALL   502C
....................    write16(ADDR_E2_PPR,0);   
19E90:  MOVLW  A8
19E92:  MOVLB  8
19E94:  MOVWF  xD8
19E96:  CLRF   xDA
19E98:  CLRF   xD9
19E9A:  MOVLB  0
19E9C:  CALL   502C
....................    write16(ADDR_E2_MODE,0); 
19EA0:  MOVLW  84
19EA2:  MOVLB  8
19EA4:  MOVWF  xD8
19EA6:  CLRF   xDA
19EA8:  CLRF   xD9
19EAA:  MOVLB  0
19EAC:  CALL   502C
....................    write16(ADDR_E2_POS,0); 
19EB0:  MOVLW  80
19EB2:  MOVLB  8
19EB4:  MOVWF  xD8
19EB6:  CLRF   xDA
19EB8:  CLRF   xD9
19EBA:  MOVLB  0
19EBC:  CALL   502C
....................    write16(ADDR_E2_PORT,0); 
19EC0:  MOVLW  AC
19EC2:  MOVLB  8
19EC4:  MOVWF  xD8
19EC6:  CLRF   xDA
19EC8:  CLRF   xD9
19ECA:  MOVLB  0
19ECC:  CALL   502C
....................    write16(ADDR_E2_TYPE,0); 
19ED0:  MOVLW  7C
19ED2:  MOVLB  8
19ED4:  MOVWF  xD8
19ED6:  CLRF   xDA
19ED8:  CLRF   xD9
19EDA:  MOVLB  0
19EDC:  CALL   502C
....................    write16(ADDR_M2_RUN,0); 
19EE0:  MOVLW  78
19EE2:  MOVLB  8
19EE4:  MOVWF  xD8
19EE6:  CLRF   xDA
19EE8:  CLRF   xD9
19EEA:  MOVLB  0
19EEC:  CALL   502C
....................    write16(ADDR_M2_BKLSH,0); 
19EF0:  MOVLW  74
19EF2:  MOVLB  8
19EF4:  MOVWF  xD8
19EF6:  CLRF   xDA
19EF8:  CLRF   xD9
19EFA:  MOVLB  0
19EFC:  CALL   502C
....................    write16(ADDR_M2_ERROR,0);   
19F00:  MOVLW  70
19F02:  MOVLB  8
19F04:  MOVWF  xD8
19F06:  CLRF   xDA
19F08:  CLRF   xD9
19F0A:  MOVLB  0
19F0C:  CALL   502C
....................    write16(ADDR_M2_SPR,0); 
19F10:  MOVLW  B0
19F12:  MOVLB  8
19F14:  MOVWF  xD8
19F16:  CLRF   xDA
19F18:  CLRF   xD9
19F1A:  MOVLB  0
19F1C:  CALL   502C
....................    write16(ADDR_M2_COMP,0); 
19F20:  MOVLW  B4
19F22:  MOVLB  8
19F24:  MOVWF  xD8
19F26:  CLRF   xDA
19F28:  CLRF   xD9
19F2A:  MOVLB  0
19F2C:  CALL   502C
....................    write16(ADDR_M2_LIN_POS,0);    
19F30:  MOVLW  B8
19F32:  MOVLB  8
19F34:  MOVWF  xD8
19F36:  CLRF   xDA
19F38:  CLRF   xD9
19F3A:  MOVLB  0
19F3C:  CALL   502C
....................    write16(ADDR_E2_INDEX,0); 
19F40:  MOVLW  BC
19F42:  MOVLB  8
19F44:  MOVWF  xD8
19F46:  CLRF   xDA
19F48:  CLRF   xD9
19F4A:  MOVLB  0
19F4C:  CALL   502C
....................    write16(ADDR_M2_EVN_SO,0); 
19F50:  MOVLW  C0
19F52:  MOVLB  8
19F54:  MOVWF  xD8
19F56:  CLRF   xDA
19F58:  CLRF   xD9
19F5A:  MOVLB  0
19F5C:  CALL   502C
....................    write16(ADDR_M2_ALIGN_OS,0); 
19F60:  MOVLW  C4
19F62:  MOVLB  8
19F64:  MOVWF  xD8
19F66:  CLRF   xDA
19F68:  CLRF   xD9
19F6A:  MOVLB  0
19F6C:  CALL   502C
....................     
....................    get_step_vars(); 
19F70:  CALL   2D7C
19F74:  GOTO   1A7BE (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
19F78:  MOVLW  86
19F7A:  MOVLB  8
19F7C:  MOVWF  xD8
19F7E:  CLRF   xDA
19F80:  MOVLW  01
19F82:  MOVWF  xD9
19F84:  MOVLB  0
19F86:  CALL   502C
....................    write16(ADDR_M1_MODE,FULL); 
19F8A:  MOVLW  8A
19F8C:  MOVLB  8
19F8E:  MOVWF  xD8
19F90:  CLRF   xDA
19F92:  CLRF   xD9
19F94:  MOVLB  0
19F96:  CALL   502C
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
19F9A:  MOVLW  8E
19F9C:  MOVLB  8
19F9E:  MOVWF  xD8
19FA0:  CLRF   xDA
19FA2:  MOVLW  14
19FA4:  MOVWF  xD9
19FA6:  MOVLB  0
19FA8:  CALL   502C
....................    write16(ADDR_M1_POS_DIR,1); 
19FAC:  MOVLW  92
19FAE:  MOVLB  8
19FB0:  MOVWF  xD8
19FB2:  CLRF   xDA
19FB4:  MOVLW  01
19FB6:  MOVWF  xD9
19FB8:  MOVLB  0
19FBA:  CALL   502C
....................    write16(ADDR_M1_PWM_HLD,51); 
19FBE:  MOVLW  96
19FC0:  MOVLB  8
19FC2:  MOVWF  xD8
19FC4:  CLRF   xDA
19FC6:  MOVLW  33
19FC8:  MOVWF  xD9
19FCA:  MOVLB  0
19FCC:  CALL   502C
....................    write16(ADDR_M1_PWM_DRV,511); 
19FD0:  MOVLW  9A
19FD2:  MOVLB  8
19FD4:  MOVWF  xD8
19FD6:  MOVLW  01
19FD8:  MOVWF  xDA
19FDA:  SETF   xD9
19FDC:  MOVLB  0
19FDE:  CALL   502C
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
19FE2:  MOVLW  9E
19FE4:  MOVLB  8
19FE6:  MOVWF  xD8
19FE8:  MOVLW  02
19FEA:  MOVWF  xDA
19FEC:  MOVLW  9E
19FEE:  MOVWF  xD9
19FF0:  MOVLB  0
19FF2:  CALL   502C
....................    write16(ADDR_E1_CPR,24); 
19FF6:  MOVLW  A2
19FF8:  MOVLB  8
19FFA:  MOVWF  xD8
19FFC:  CLRF   xDA
19FFE:  MOVLW  18
1A000:  MOVWF  xD9
1A002:  MOVLB  0
1A004:  CALL   502C
....................    write16(ADDR_E1_PPR,48); 
1A008:  MOVLW  A6
1A00A:  MOVLB  8
1A00C:  MOVWF  xD8
1A00E:  CLRF   xDA
1A010:  MOVLW  30
1A012:  MOVWF  xD9
1A014:  MOVLB  0
1A016:  CALL   502C
....................    write16(ADDR_E1_MODE,2); 
1A01A:  MOVLW  82
1A01C:  MOVLB  8
1A01E:  MOVWF  xD8
1A020:  CLRF   xDA
1A022:  MOVLW  02
1A024:  MOVWF  xD9
1A026:  MOVLB  0
1A028:  CALL   502C
....................    write16(ADDR_E1_POS,0); 
1A02C:  MOVLW  7E
1A02E:  MOVLB  8
1A030:  MOVWF  xD8
1A032:  CLRF   xDA
1A034:  CLRF   xD9
1A036:  MOVLB  0
1A038:  CALL   502C
....................    write16(ADDR_E1_PORT,0); 
1A03C:  MOVLW  AA
1A03E:  MOVLB  8
1A040:  MOVWF  xD8
1A042:  CLRF   xDA
1A044:  CLRF   xD9
1A046:  MOVLB  0
1A048:  CALL   502C
....................    write16(ADDR_E1_TYPE,2); 
1A04C:  MOVLW  7A
1A04E:  MOVLB  8
1A050:  MOVWF  xD8
1A052:  CLRF   xDA
1A054:  MOVLW  02
1A056:  MOVWF  xD9
1A058:  MOVLB  0
1A05A:  CALL   502C
....................    write16(ADDR_M1_RUN,34); 
1A05E:  MOVLW  76
1A060:  MOVLB  8
1A062:  MOVWF  xD8
1A064:  CLRF   xDA
1A066:  MOVLW  22
1A068:  MOVWF  xD9
1A06A:  MOVLB  0
1A06C:  CALL   502C
....................    write16(ADDR_M1_BKLSH,0); 
1A070:  MOVLW  72
1A072:  MOVLB  8
1A074:  MOVWF  xD8
1A076:  CLRF   xDA
1A078:  CLRF   xD9
1A07A:  MOVLB  0
1A07C:  CALL   502C
....................    write16(ADDR_M1_ERROR,0);   
1A080:  MOVLW  6E
1A082:  MOVLB  8
1A084:  MOVWF  xD8
1A086:  CLRF   xDA
1A088:  CLRF   xD9
1A08A:  MOVLB  0
1A08C:  CALL   502C
....................    write16(ADDR_M1_SPR,6400); 
1A090:  MOVLW  AE
1A092:  MOVLB  8
1A094:  MOVWF  xD8
1A096:  MOVLW  19
1A098:  MOVWF  xDA
1A09A:  CLRF   xD9
1A09C:  MOVLB  0
1A09E:  CALL   502C
....................    write16(ADDR_M1_COMP,0); 
1A0A2:  MOVLW  B2
1A0A4:  MOVLB  8
1A0A6:  MOVWF  xD8
1A0A8:  CLRF   xDA
1A0AA:  CLRF   xD9
1A0AC:  MOVLB  0
1A0AE:  CALL   502C
....................    write16(ADDR_M1_LIN_POS,0); 
1A0B2:  MOVLW  B6
1A0B4:  MOVLB  8
1A0B6:  MOVWF  xD8
1A0B8:  CLRF   xDA
1A0BA:  CLRF   xD9
1A0BC:  MOVLB  0
1A0BE:  CALL   502C
....................    write16(ADDR_E1_INDEX,1);    
1A0C2:  MOVLW  BA
1A0C4:  MOVLB  8
1A0C6:  MOVWF  xD8
1A0C8:  CLRF   xDA
1A0CA:  MOVLW  01
1A0CC:  MOVWF  xD9
1A0CE:  MOVLB  0
1A0D0:  CALL   502C
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A0D4:  MOVLW  88
1A0D6:  MOVLB  8
1A0D8:  MOVWF  xD8
1A0DA:  CLRF   xDA
1A0DC:  MOVLW  01
1A0DE:  MOVWF  xD9
1A0E0:  MOVLB  0
1A0E2:  CALL   502C
....................    write16(ADDR_M2_MODE,HALF); 
1A0E6:  MOVLW  8C
1A0E8:  MOVLB  8
1A0EA:  MOVWF  xD8
1A0EC:  CLRF   xDA
1A0EE:  MOVLW  01
1A0F0:  MOVWF  xD9
1A0F2:  MOVLB  0
1A0F4:  CALL   502C
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A0F8:  MOVLW  90
1A0FA:  MOVLB  8
1A0FC:  MOVWF  xD8
1A0FE:  CLRF   xDA
1A100:  MOVLW  28
1A102:  MOVWF  xD9
1A104:  MOVLB  0
1A106:  CALL   502C
....................    write16(ADDR_M2_POS_DIR,0); 
1A10A:  MOVLW  94
1A10C:  MOVLB  8
1A10E:  MOVWF  xD8
1A110:  CLRF   xDA
1A112:  CLRF   xD9
1A114:  MOVLB  0
1A116:  CALL   502C
....................    write16(ADDR_M2_PWM_HLD,0); 
1A11A:  MOVLW  98
1A11C:  MOVLB  8
1A11E:  MOVWF  xD8
1A120:  CLRF   xDA
1A122:  CLRF   xD9
1A124:  MOVLB  0
1A126:  CALL   502C
....................    write16(ADDR_M2_PWM_DRV,511); 
1A12A:  MOVLW  9C
1A12C:  MOVLB  8
1A12E:  MOVWF  xD8
1A130:  MOVLW  01
1A132:  MOVWF  xDA
1A134:  SETF   xD9
1A136:  MOVLB  0
1A138:  CALL   502C
....................    write16(ADDR_M2_GB_ERR,0); 
1A13C:  MOVLW  A0
1A13E:  MOVLB  8
1A140:  MOVWF  xD8
1A142:  CLRF   xDA
1A144:  CLRF   xD9
1A146:  MOVLB  0
1A148:  CALL   502C
....................    write16(ADDR_E2_CPR,0); 
1A14C:  MOVLW  A4
1A14E:  MOVLB  8
1A150:  MOVWF  xD8
1A152:  CLRF   xDA
1A154:  CLRF   xD9
1A156:  MOVLB  0
1A158:  CALL   502C
....................    write16(ADDR_E2_PPR,0);   
1A15C:  MOVLW  A8
1A15E:  MOVLB  8
1A160:  MOVWF  xD8
1A162:  CLRF   xDA
1A164:  CLRF   xD9
1A166:  MOVLB  0
1A168:  CALL   502C
....................    write16(ADDR_E2_MODE,0); 
1A16C:  MOVLW  84
1A16E:  MOVLB  8
1A170:  MOVWF  xD8
1A172:  CLRF   xDA
1A174:  CLRF   xD9
1A176:  MOVLB  0
1A178:  CALL   502C
....................    write16(ADDR_E2_POS,0); 
1A17C:  MOVLW  80
1A17E:  MOVLB  8
1A180:  MOVWF  xD8
1A182:  CLRF   xDA
1A184:  CLRF   xD9
1A186:  MOVLB  0
1A188:  CALL   502C
....................    write16(ADDR_E2_PORT,0); 
1A18C:  MOVLW  AC
1A18E:  MOVLB  8
1A190:  MOVWF  xD8
1A192:  CLRF   xDA
1A194:  CLRF   xD9
1A196:  MOVLB  0
1A198:  CALL   502C
....................    write16(ADDR_E2_TYPE,0); 
1A19C:  MOVLW  7C
1A19E:  MOVLB  8
1A1A0:  MOVWF  xD8
1A1A2:  CLRF   xDA
1A1A4:  CLRF   xD9
1A1A6:  MOVLB  0
1A1A8:  CALL   502C
....................    write16(ADDR_M2_RUN,0); 
1A1AC:  MOVLW  78
1A1AE:  MOVLB  8
1A1B0:  MOVWF  xD8
1A1B2:  CLRF   xDA
1A1B4:  CLRF   xD9
1A1B6:  MOVLB  0
1A1B8:  CALL   502C
....................    write16(ADDR_M2_BKLSH,0); 
1A1BC:  MOVLW  74
1A1BE:  MOVLB  8
1A1C0:  MOVWF  xD8
1A1C2:  CLRF   xDA
1A1C4:  CLRF   xD9
1A1C6:  MOVLB  0
1A1C8:  CALL   502C
....................    write16(ADDR_M2_ERROR,0);   
1A1CC:  MOVLW  70
1A1CE:  MOVLB  8
1A1D0:  MOVWF  xD8
1A1D2:  CLRF   xDA
1A1D4:  CLRF   xD9
1A1D6:  MOVLB  0
1A1D8:  CALL   502C
....................    write16(ADDR_M2_SPR,0); 
1A1DC:  MOVLW  B0
1A1DE:  MOVLB  8
1A1E0:  MOVWF  xD8
1A1E2:  CLRF   xDA
1A1E4:  CLRF   xD9
1A1E6:  MOVLB  0
1A1E8:  CALL   502C
....................    write16(ADDR_M2_COMP,0); 
1A1EC:  MOVLW  B4
1A1EE:  MOVLB  8
1A1F0:  MOVWF  xD8
1A1F2:  CLRF   xDA
1A1F4:  CLRF   xD9
1A1F6:  MOVLB  0
1A1F8:  CALL   502C
....................    write16(ADDR_M2_LIN_POS,0);   
1A1FC:  MOVLW  B8
1A1FE:  MOVLB  8
1A200:  MOVWF  xD8
1A202:  CLRF   xDA
1A204:  CLRF   xD9
1A206:  MOVLB  0
1A208:  CALL   502C
....................    write16(ADDR_E2_INDEX,0);    
1A20C:  MOVLW  BC
1A20E:  MOVLB  8
1A210:  MOVWF  xD8
1A212:  CLRF   xDA
1A214:  CLRF   xD9
1A216:  MOVLB  0
1A218:  CALL   502C
....................     
....................    get_step_vars(); 
1A21C:  CALL   2D7C
1A220:  GOTO   1A7BE (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A224:  MOVLW  86
1A226:  MOVLB  8
1A228:  MOVWF  xD8
1A22A:  CLRF   xDA
1A22C:  MOVLW  01
1A22E:  MOVWF  xD9
1A230:  MOVLB  0
1A232:  CALL   502C
....................    write16(ADDR_M1_MODE,FULL); 
1A236:  MOVLW  8A
1A238:  MOVLB  8
1A23A:  MOVWF  xD8
1A23C:  CLRF   xDA
1A23E:  CLRF   xD9
1A240:  MOVLB  0
1A242:  CALL   502C
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A246:  MOVLW  8E
1A248:  MOVLB  8
1A24A:  MOVWF  xD8
1A24C:  CLRF   xDA
1A24E:  MOVLW  0A
1A250:  MOVWF  xD9
1A252:  MOVLB  0
1A254:  CALL   502C
....................    write16(ADDR_M1_POS_DIR,0); 
1A258:  MOVLW  92
1A25A:  MOVLB  8
1A25C:  MOVWF  xD8
1A25E:  CLRF   xDA
1A260:  CLRF   xD9
1A262:  MOVLB  0
1A264:  CALL   502C
....................    write16(ADDR_M1_PWM_HLD,0); 
1A268:  MOVLW  96
1A26A:  MOVLB  8
1A26C:  MOVWF  xD8
1A26E:  CLRF   xDA
1A270:  CLRF   xD9
1A272:  MOVLB  0
1A274:  CALL   502C
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A278:  MOVLW  9A
1A27A:  MOVLB  8
1A27C:  MOVWF  xD8
1A27E:  CLRF   xDA
1A280:  MOVLW  7F
1A282:  MOVWF  xD9
1A284:  MOVLB  0
1A286:  CALL   502C
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A28A:  MOVLW  9E
1A28C:  MOVLB  8
1A28E:  MOVWF  xD8
1A290:  MOVLW  17
1A292:  MOVWF  xDA
1A294:  MOVLW  70
1A296:  MOVWF  xD9
1A298:  MOVLB  0
1A29A:  CALL   502C
....................    write16(ADDR_E1_CPR,16); 
1A29E:  MOVLW  A2
1A2A0:  MOVLB  8
1A2A2:  MOVWF  xD8
1A2A4:  CLRF   xDA
1A2A6:  MOVLW  10
1A2A8:  MOVWF  xD9
1A2AA:  MOVLB  0
1A2AC:  CALL   502C
....................    write16(ADDR_E1_PPR,16); 
1A2B0:  MOVLW  A6
1A2B2:  MOVLB  8
1A2B4:  MOVWF  xD8
1A2B6:  CLRF   xDA
1A2B8:  MOVLW  10
1A2BA:  MOVWF  xD9
1A2BC:  MOVLB  0
1A2BE:  CALL   502C
....................    write16(ADDR_E1_MODE,2); 
1A2C2:  MOVLW  82
1A2C4:  MOVLB  8
1A2C6:  MOVWF  xD8
1A2C8:  CLRF   xDA
1A2CA:  MOVLW  02
1A2CC:  MOVWF  xD9
1A2CE:  MOVLB  0
1A2D0:  CALL   502C
....................    write16(ADDR_E1_POS,0); 
1A2D4:  MOVLW  7E
1A2D6:  MOVLB  8
1A2D8:  MOVWF  xD8
1A2DA:  CLRF   xDA
1A2DC:  CLRF   xD9
1A2DE:  MOVLB  0
1A2E0:  CALL   502C
....................    write16(ADDR_E1_PORT,0); 
1A2E4:  MOVLW  AA
1A2E6:  MOVLB  8
1A2E8:  MOVWF  xD8
1A2EA:  CLRF   xDA
1A2EC:  CLRF   xD9
1A2EE:  MOVLB  0
1A2F0:  CALL   502C
....................    write16(ADDR_E1_TYPE,2); 
1A2F4:  MOVLW  7A
1A2F6:  MOVLB  8
1A2F8:  MOVWF  xD8
1A2FA:  CLRF   xDA
1A2FC:  MOVLW  02
1A2FE:  MOVWF  xD9
1A300:  MOVLB  0
1A302:  CALL   502C
....................    write16(ADDR_M1_RUN,270); 
1A306:  MOVLW  76
1A308:  MOVLB  8
1A30A:  MOVWF  xD8
1A30C:  MOVLW  01
1A30E:  MOVWF  xDA
1A310:  MOVLW  0E
1A312:  MOVWF  xD9
1A314:  MOVLB  0
1A316:  CALL   502C
....................    write16(ADDR_M1_BKLSH,0); 
1A31A:  MOVLW  72
1A31C:  MOVLB  8
1A31E:  MOVWF  xD8
1A320:  CLRF   xDA
1A322:  CLRF   xD9
1A324:  MOVLB  0
1A326:  CALL   502C
....................    write16(ADDR_M1_ERROR,0);   
1A32A:  MOVLW  6E
1A32C:  MOVLB  8
1A32E:  MOVWF  xD8
1A330:  CLRF   xDA
1A332:  CLRF   xD9
1A334:  MOVLB  0
1A336:  CALL   502C
....................    write16(ADDR_M1_SPR,38400); 
1A33A:  MOVLW  AE
1A33C:  MOVLB  8
1A33E:  MOVWF  xD8
1A340:  MOVLW  96
1A342:  MOVWF  xDA
1A344:  CLRF   xD9
1A346:  MOVLB  0
1A348:  CALL   502C
....................    write16(ADDR_M1_COMP,0); 
1A34C:  MOVLW  B2
1A34E:  MOVLB  8
1A350:  MOVWF  xD8
1A352:  CLRF   xDA
1A354:  CLRF   xD9
1A356:  MOVLB  0
1A358:  CALL   502C
....................    write16(ADDR_M1_LIN_POS,0); 
1A35C:  MOVLW  B6
1A35E:  MOVLB  8
1A360:  MOVWF  xD8
1A362:  CLRF   xDA
1A364:  CLRF   xD9
1A366:  MOVLB  0
1A368:  CALL   502C
....................    write16(ADDR_E1_INDEX,1); 
1A36C:  MOVLW  BA
1A36E:  MOVLB  8
1A370:  MOVWF  xD8
1A372:  CLRF   xDA
1A374:  MOVLW  01
1A376:  MOVWF  xD9
1A378:  MOVLB  0
1A37A:  CALL   502C
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A37E:  MOVLW  88
1A380:  MOVLB  8
1A382:  MOVWF  xD8
1A384:  CLRF   xDA
1A386:  MOVLW  01
1A388:  MOVWF  xD9
1A38A:  MOVLB  0
1A38C:  CALL   502C
....................    write16(ADDR_M2_MODE,HALF); 
1A390:  MOVLW  8C
1A392:  MOVLB  8
1A394:  MOVWF  xD8
1A396:  CLRF   xDA
1A398:  MOVLW  01
1A39A:  MOVWF  xD9
1A39C:  MOVLB  0
1A39E:  CALL   502C
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A3A2:  MOVLW  90
1A3A4:  MOVLB  8
1A3A6:  MOVWF  xD8
1A3A8:  CLRF   xDA
1A3AA:  MOVLW  64
1A3AC:  MOVWF  xD9
1A3AE:  MOVLB  0
1A3B0:  CALL   502C
....................    write16(ADDR_M2_POS_DIR,0); 
1A3B4:  MOVLW  94
1A3B6:  MOVLB  8
1A3B8:  MOVWF  xD8
1A3BA:  CLRF   xDA
1A3BC:  CLRF   xD9
1A3BE:  MOVLB  0
1A3C0:  CALL   502C
....................    write16(ADDR_M2_PWM_HLD,0); 
1A3C4:  MOVLW  98
1A3C6:  MOVLB  8
1A3C8:  MOVWF  xD8
1A3CA:  CLRF   xDA
1A3CC:  CLRF   xD9
1A3CE:  MOVLB  0
1A3D0:  CALL   502C
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A3D4:  MOVLW  9C
1A3D6:  MOVLB  8
1A3D8:  MOVWF  xD8
1A3DA:  CLRF   xDA
1A3DC:  MOVLW  7F
1A3DE:  MOVWF  xD9
1A3E0:  MOVLB  0
1A3E2:  CALL   502C
....................    write16(ADDR_M2_GB_ERR,0); 
1A3E6:  MOVLW  A0
1A3E8:  MOVLB  8
1A3EA:  MOVWF  xD8
1A3EC:  CLRF   xDA
1A3EE:  CLRF   xD9
1A3F0:  MOVLB  0
1A3F2:  CALL   502C
....................    write16(ADDR_E2_CPR,0); 
1A3F6:  MOVLW  A4
1A3F8:  MOVLB  8
1A3FA:  MOVWF  xD8
1A3FC:  CLRF   xDA
1A3FE:  CLRF   xD9
1A400:  MOVLB  0
1A402:  CALL   502C
....................    write16(ADDR_E2_PPR,0);   
1A406:  MOVLW  A8
1A408:  MOVLB  8
1A40A:  MOVWF  xD8
1A40C:  CLRF   xDA
1A40E:  CLRF   xD9
1A410:  MOVLB  0
1A412:  CALL   502C
....................    write16(ADDR_E2_MODE,0); 
1A416:  MOVLW  84
1A418:  MOVLB  8
1A41A:  MOVWF  xD8
1A41C:  CLRF   xDA
1A41E:  CLRF   xD9
1A420:  MOVLB  0
1A422:  CALL   502C
....................    write16(ADDR_E2_POS,0); 
1A426:  MOVLW  80
1A428:  MOVLB  8
1A42A:  MOVWF  xD8
1A42C:  CLRF   xDA
1A42E:  CLRF   xD9
1A430:  MOVLB  0
1A432:  CALL   502C
....................    write16(ADDR_E2_PORT,0); 
1A436:  MOVLW  AC
1A438:  MOVLB  8
1A43A:  MOVWF  xD8
1A43C:  CLRF   xDA
1A43E:  CLRF   xD9
1A440:  MOVLB  0
1A442:  CALL   502C
....................    write16(ADDR_E2_TYPE,0); 
1A446:  MOVLW  7C
1A448:  MOVLB  8
1A44A:  MOVWF  xD8
1A44C:  CLRF   xDA
1A44E:  CLRF   xD9
1A450:  MOVLB  0
1A452:  CALL   502C
....................    write16(ADDR_M2_RUN,0); 
1A456:  MOVLW  78
1A458:  MOVLB  8
1A45A:  MOVWF  xD8
1A45C:  CLRF   xDA
1A45E:  CLRF   xD9
1A460:  MOVLB  0
1A462:  CALL   502C
....................    write16(ADDR_M2_BKLSH,0); 
1A466:  MOVLW  74
1A468:  MOVLB  8
1A46A:  MOVWF  xD8
1A46C:  CLRF   xDA
1A46E:  CLRF   xD9
1A470:  MOVLB  0
1A472:  CALL   502C
....................    write16(ADDR_M2_ERROR,0);   
1A476:  MOVLW  70
1A478:  MOVLB  8
1A47A:  MOVWF  xD8
1A47C:  CLRF   xDA
1A47E:  CLRF   xD9
1A480:  MOVLB  0
1A482:  CALL   502C
....................    write16(ADDR_M2_SPR,0); 
1A486:  MOVLW  B0
1A488:  MOVLB  8
1A48A:  MOVWF  xD8
1A48C:  CLRF   xDA
1A48E:  CLRF   xD9
1A490:  MOVLB  0
1A492:  CALL   502C
....................    write16(ADDR_M2_COMP,0); 
1A496:  MOVLW  B4
1A498:  MOVLB  8
1A49A:  MOVWF  xD8
1A49C:  CLRF   xDA
1A49E:  CLRF   xD9
1A4A0:  MOVLB  0
1A4A2:  CALL   502C
....................    write16(ADDR_M2_LIN_POS,0);    
1A4A6:  MOVLW  B8
1A4A8:  MOVLB  8
1A4AA:  MOVWF  xD8
1A4AC:  CLRF   xDA
1A4AE:  CLRF   xD9
1A4B0:  MOVLB  0
1A4B2:  CALL   502C
....................     
....................    get_step_vars(); 
1A4B6:  CALL   2D7C
1A4BA:  GOTO   1A7BE (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A4BE:  MOVLW  86
1A4C0:  MOVLB  8
1A4C2:  MOVWF  xD8
1A4C4:  CLRF   xDA
1A4C6:  MOVLW  01
1A4C8:  MOVWF  xD9
1A4CA:  MOVLB  0
1A4CC:  CALL   502C
....................    write16(ADDR_M1_MODE,FULL); 
1A4D0:  MOVLW  8A
1A4D2:  MOVLB  8
1A4D4:  MOVWF  xD8
1A4D6:  CLRF   xDA
1A4D8:  CLRF   xD9
1A4DA:  MOVLB  0
1A4DC:  CALL   502C
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1A4E0:  MOVLW  8E
1A4E2:  MOVLB  8
1A4E4:  MOVWF  xD8
1A4E6:  CLRF   xDA
1A4E8:  MOVLW  28
1A4EA:  MOVWF  xD9
1A4EC:  MOVLB  0
1A4EE:  CALL   502C
....................    write16(ADDR_M1_POS_DIR,1); 
1A4F2:  MOVLW  92
1A4F4:  MOVLB  8
1A4F6:  MOVWF  xD8
1A4F8:  CLRF   xDA
1A4FA:  MOVLW  01
1A4FC:  MOVWF  xD9
1A4FE:  MOVLB  0
1A500:  CALL   502C
....................    write16(ADDR_M1_PWM_HLD,0); 
1A504:  MOVLW  96
1A506:  MOVLB  8
1A508:  MOVWF  xD8
1A50A:  CLRF   xDA
1A50C:  CLRF   xD9
1A50E:  MOVLB  0
1A510:  CALL   502C
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A514:  MOVLW  9A
1A516:  MOVLB  8
1A518:  MOVWF  xD8
1A51A:  CLRF   xDA
1A51C:  MOVLW  7F
1A51E:  MOVWF  xD9
1A520:  MOVLB  0
1A522:  CALL   502C
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1A526:  MOVLW  9E
1A528:  MOVLB  8
1A52A:  MOVWF  xD8
1A52C:  MOVLW  02
1A52E:  MOVWF  xDA
1A530:  MOVLW  9E
1A532:  MOVWF  xD9
1A534:  MOVLB  0
1A536:  CALL   502C
....................    write16(ADDR_E1_CPR,500); 
1A53A:  MOVLW  A2
1A53C:  MOVLB  8
1A53E:  MOVWF  xD8
1A540:  MOVLW  01
1A542:  MOVWF  xDA
1A544:  MOVLW  F4
1A546:  MOVWF  xD9
1A548:  MOVLB  0
1A54A:  CALL   502C
....................    write16(ADDR_E1_PPR,50); 
1A54E:  MOVLW  A6
1A550:  MOVLB  8
1A552:  MOVWF  xD8
1A554:  CLRF   xDA
1A556:  MOVLW  32
1A558:  MOVWF  xD9
1A55A:  MOVLB  0
1A55C:  CALL   502C
....................    write16(ADDR_E1_MODE,2); 
1A560:  MOVLW  82
1A562:  MOVLB  8
1A564:  MOVWF  xD8
1A566:  CLRF   xDA
1A568:  MOVLW  02
1A56A:  MOVWF  xD9
1A56C:  MOVLB  0
1A56E:  CALL   502C
....................    write16(ADDR_E1_POS,0); 
1A572:  MOVLW  7E
1A574:  MOVLB  8
1A576:  MOVWF  xD8
1A578:  CLRF   xDA
1A57A:  CLRF   xD9
1A57C:  MOVLB  0
1A57E:  CALL   502C
....................    write16(ADDR_E1_PORT,0); 
1A582:  MOVLW  AA
1A584:  MOVLB  8
1A586:  MOVWF  xD8
1A588:  CLRF   xDA
1A58A:  CLRF   xD9
1A58C:  MOVLB  0
1A58E:  CALL   502C
....................    write16(ADDR_E1_TYPE,1); 
1A592:  MOVLW  7A
1A594:  MOVLB  8
1A596:  MOVWF  xD8
1A598:  CLRF   xDA
1A59A:  MOVLW  01
1A59C:  MOVWF  xD9
1A59E:  MOVLB  0
1A5A0:  CALL   502C
....................    write16(ADDR_M1_RUN,0); 
1A5A4:  MOVLW  76
1A5A6:  MOVLB  8
1A5A8:  MOVWF  xD8
1A5AA:  CLRF   xDA
1A5AC:  CLRF   xD9
1A5AE:  MOVLB  0
1A5B0:  CALL   502C
....................    write16(ADDR_M1_BKLSH,1300); 
1A5B4:  MOVLW  72
1A5B6:  MOVLB  8
1A5B8:  MOVWF  xD8
1A5BA:  MOVLW  05
1A5BC:  MOVWF  xDA
1A5BE:  MOVLW  14
1A5C0:  MOVWF  xD9
1A5C2:  MOVLB  0
1A5C4:  CALL   502C
....................    write16(ADDR_M1_ERROR,0);   
1A5C8:  MOVLW  6E
1A5CA:  MOVLB  8
1A5CC:  MOVWF  xD8
1A5CE:  CLRF   xDA
1A5D0:  CLRF   xD9
1A5D2:  MOVLB  0
1A5D4:  CALL   502C
....................    write16(ADDR_M1_SPR,20000); 
1A5D8:  MOVLW  AE
1A5DA:  MOVLB  8
1A5DC:  MOVWF  xD8
1A5DE:  MOVLW  4E
1A5E0:  MOVWF  xDA
1A5E2:  MOVLW  20
1A5E4:  MOVWF  xD9
1A5E6:  MOVLB  0
1A5E8:  CALL   502C
....................    write16(ADDR_M1_COMP,0); 
1A5EC:  MOVLW  B2
1A5EE:  MOVLB  8
1A5F0:  MOVWF  xD8
1A5F2:  CLRF   xDA
1A5F4:  CLRF   xD9
1A5F6:  MOVLB  0
1A5F8:  CALL   502C
....................    write16(ADDR_M1_LIN_POS,0); 
1A5FC:  MOVLW  B6
1A5FE:  MOVLB  8
1A600:  MOVWF  xD8
1A602:  CLRF   xDA
1A604:  CLRF   xD9
1A606:  MOVLB  0
1A608:  CALL   502C
....................    write16(ADDR_E1_INDEX,0); 
1A60C:  MOVLW  BA
1A60E:  MOVLB  8
1A610:  MOVWF  xD8
1A612:  CLRF   xDA
1A614:  CLRF   xD9
1A616:  MOVLB  0
1A618:  CALL   502C
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A61C:  MOVLW  88
1A61E:  MOVLB  8
1A620:  MOVWF  xD8
1A622:  CLRF   xDA
1A624:  MOVLW  01
1A626:  MOVWF  xD9
1A628:  MOVLB  0
1A62A:  CALL   502C
....................    write16(ADDR_M2_MODE,HALF); 
1A62E:  MOVLW  8C
1A630:  MOVLB  8
1A632:  MOVWF  xD8
1A634:  CLRF   xDA
1A636:  MOVLW  01
1A638:  MOVWF  xD9
1A63A:  MOVLB  0
1A63C:  CALL   502C
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A640:  MOVLW  90
1A642:  MOVLB  8
1A644:  MOVWF  xD8
1A646:  CLRF   xDA
1A648:  MOVLW  28
1A64A:  MOVWF  xD9
1A64C:  MOVLB  0
1A64E:  CALL   502C
....................    write16(ADDR_M2_POS_DIR,1); 
1A652:  MOVLW  94
1A654:  MOVLB  8
1A656:  MOVWF  xD8
1A658:  CLRF   xDA
1A65A:  MOVLW  01
1A65C:  MOVWF  xD9
1A65E:  MOVLB  0
1A660:  CALL   502C
....................    write16(ADDR_M2_PWM_HLD,0); 
1A664:  MOVLW  98
1A666:  MOVLB  8
1A668:  MOVWF  xD8
1A66A:  CLRF   xDA
1A66C:  CLRF   xD9
1A66E:  MOVLB  0
1A670:  CALL   502C
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A674:  MOVLW  9C
1A676:  MOVLB  8
1A678:  MOVWF  xD8
1A67A:  CLRF   xDA
1A67C:  MOVLW  7F
1A67E:  MOVWF  xD9
1A680:  MOVLB  0
1A682:  CALL   502C
....................    write16(ADDR_M2_GB_ERR,0); 
1A686:  MOVLW  A0
1A688:  MOVLB  8
1A68A:  MOVWF  xD8
1A68C:  CLRF   xDA
1A68E:  CLRF   xD9
1A690:  MOVLB  0
1A692:  CALL   502C
....................    write16(ADDR_E2_CPR,0); 
1A696:  MOVLW  A4
1A698:  MOVLB  8
1A69A:  MOVWF  xD8
1A69C:  CLRF   xDA
1A69E:  CLRF   xD9
1A6A0:  MOVLB  0
1A6A2:  CALL   502C
....................    write16(ADDR_E2_PPR,0);   
1A6A6:  MOVLW  A8
1A6A8:  MOVLB  8
1A6AA:  MOVWF  xD8
1A6AC:  CLRF   xDA
1A6AE:  CLRF   xD9
1A6B0:  MOVLB  0
1A6B2:  CALL   502C
....................    write16(ADDR_E2_MODE,0); 
1A6B6:  MOVLW  84
1A6B8:  MOVLB  8
1A6BA:  MOVWF  xD8
1A6BC:  CLRF   xDA
1A6BE:  CLRF   xD9
1A6C0:  MOVLB  0
1A6C2:  CALL   502C
....................    write16(ADDR_E2_POS,0); 
1A6C6:  MOVLW  80
1A6C8:  MOVLB  8
1A6CA:  MOVWF  xD8
1A6CC:  CLRF   xDA
1A6CE:  CLRF   xD9
1A6D0:  MOVLB  0
1A6D2:  CALL   502C
....................    write16(ADDR_E2_PORT,0); 
1A6D6:  MOVLW  AC
1A6D8:  MOVLB  8
1A6DA:  MOVWF  xD8
1A6DC:  CLRF   xDA
1A6DE:  CLRF   xD9
1A6E0:  MOVLB  0
1A6E2:  CALL   502C
....................    write16(ADDR_E2_TYPE,0); 
1A6E6:  MOVLW  7C
1A6E8:  MOVLB  8
1A6EA:  MOVWF  xD8
1A6EC:  CLRF   xDA
1A6EE:  CLRF   xD9
1A6F0:  MOVLB  0
1A6F2:  CALL   502C
....................    write16(ADDR_M2_RUN,0); 
1A6F6:  MOVLW  78
1A6F8:  MOVLB  8
1A6FA:  MOVWF  xD8
1A6FC:  CLRF   xDA
1A6FE:  CLRF   xD9
1A700:  MOVLB  0
1A702:  CALL   502C
....................    write16(ADDR_M2_BKLSH,0); 
1A706:  MOVLW  74
1A708:  MOVLB  8
1A70A:  MOVWF  xD8
1A70C:  CLRF   xDA
1A70E:  CLRF   xD9
1A710:  MOVLB  0
1A712:  CALL   502C
....................    write16(ADDR_M2_ERROR,0);   
1A716:  MOVLW  70
1A718:  MOVLB  8
1A71A:  MOVWF  xD8
1A71C:  CLRF   xDA
1A71E:  CLRF   xD9
1A720:  MOVLB  0
1A722:  CALL   502C
....................    write16(ADDR_M2_SPR,0); 
1A726:  MOVLW  B0
1A728:  MOVLB  8
1A72A:  MOVWF  xD8
1A72C:  CLRF   xDA
1A72E:  CLRF   xD9
1A730:  MOVLB  0
1A732:  CALL   502C
....................    write16(ADDR_M2_COMP,0); 
1A736:  MOVLW  B4
1A738:  MOVLB  8
1A73A:  MOVWF  xD8
1A73C:  CLRF   xDA
1A73E:  CLRF   xD9
1A740:  MOVLB  0
1A742:  CALL   502C
....................    write16(ADDR_M2_LIN_POS,0);    
1A746:  MOVLW  B8
1A748:  MOVLB  8
1A74A:  MOVWF  xD8
1A74C:  CLRF   xDA
1A74E:  CLRF   xD9
1A750:  MOVLB  0
1A752:  CALL   502C
....................    write16(ADDR_E2_INDEX,0); 
1A756:  MOVLW  BC
1A758:  MOVLB  8
1A75A:  MOVWF  xD8
1A75C:  CLRF   xDA
1A75E:  CLRF   xD9
1A760:  MOVLB  0
1A762:  CALL   502C
....................     
....................    get_step_vars(); 
1A766:  CALL   2D7C
1A76A:  GOTO   1A7BE (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
029FA:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
029FC:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
029FE:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
02A00:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
02A02:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
02A04:  BCF    F90.5
....................    set_pwm1_duty(0);    
02A06:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
02A08:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
02A0A:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
02A0C:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
02A0E:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
02A10:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
02A12:  BCF    F8D.5
....................    set_pwm2_duty(0);  
02A14:  MOVLB  F
02A16:  CLRF   x4F
....................  
....................    output_low(VENC1); 
02A18:  BCF    F8E.6
....................    output_low(VENC2);         
02A1A:  BCF    F8E.7
....................    output_low(VHBRDG); 
02A1C:  BCF    F8E.2
02A1E:  MOVLB  0
02A20:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
01254:  BCF    FD8.0
01256:  MOVLB  7
01258:  RLCF   x3C,W
0125A:  CLRF   03
0125C:  ADDLW  4A
0125E:  MOVWF  FE9
01260:  MOVLW  07
01262:  ADDWFC 03,W
01264:  MOVWF  FEA
01266:  MOVFF  FEC,A1D
0126A:  MOVF   FED,F
0126C:  MOVFF  FEF,A1C
01270:  MOVLB  A
01272:  MOVF   x1C,F
01274:  BTFSS  FD8.2
01276:  BRA    13FE
01278:  MOVF   x1D,F
0127A:  BTFSS  FD8.2
0127C:  BRA    13FE
....................       if(m_way[motor]==POS) { 
0127E:  BCF    FD8.0
01280:  MOVLB  7
01282:  RLCF   x3C,W
01284:  CLRF   03
01286:  ADDLW  82
01288:  MOVWF  FE9
0128A:  MOVLW  07
0128C:  ADDWFC 03,W
0128E:  MOVWF  FEA
01290:  MOVFF  FEC,A1D
01294:  MOVF   FED,F
01296:  MOVFF  FEF,A1C
0129A:  MOVLB  A
0129C:  MOVF   x1C,F
0129E:  BNZ   1338
012A0:  MOVF   x1D,F
012A2:  BNZ   1338
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
012A4:  BCF    FD8.0
012A6:  MOVLB  7
012A8:  RLCF   x3C,W
012AA:  CLRF   03
012AC:  ADDLW  BB
012AE:  MOVWF  FE9
012B0:  MOVLW  07
012B2:  ADDWFC 03,W
012B4:  MOVWF  FEA
012B6:  MOVFF  FEC,A1D
012BA:  MOVF   FED,F
012BC:  MOVFF  FEF,A1C
012C0:  BCF    FD8.0
012C2:  RLCF   x3C,W
012C4:  CLRF   03
012C6:  ADDLW  5A
012C8:  MOVWF  FE9
012CA:  MOVLW  07
012CC:  ADDWFC 03,W
012CE:  MOVWF  FEA
012D0:  MOVFF  FEC,03
012D4:  MOVF   FED,F
012D6:  MOVFF  FEF,01
012DA:  MOVF   03,W
012DC:  MOVLB  A
012DE:  SUBWF  x1D,W
012E0:  BNC   1304
012E2:  BNZ   12EA
012E4:  MOVF   01,W
012E6:  SUBWF  x1C,W
012E8:  BNC   1304
012EA:  BCF    FD8.0
012EC:  MOVLB  7
012EE:  RLCF   x3C,W
012F0:  CLRF   03
012F2:  ADDLW  BB
012F4:  MOVWF  FE9
012F6:  MOVLW  07
012F8:  ADDWFC 03,W
012FA:  MOVWF  FEA
012FC:  CLRF   FEC
012FE:  MOVF   FED,F
01300:  CLRF   FEF
01302:  MOVLB  A
....................          e_pos[motor]++; 
01304:  BCF    FD8.0
01306:  MOVLB  7
01308:  RLCF   x3C,W
0130A:  CLRF   03
0130C:  ADDLW  BB
0130E:  MOVWF  FE9
01310:  MOVLW  07
01312:  ADDWFC 03,W
01314:  MOVWF  FEA
01316:  MOVLW  01
01318:  ADDWF  FEE,F
0131A:  BNC   131E
0131C:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
0131E:  BCF    FD8.0
01320:  RLCF   x3C,W
01322:  CLRF   03
01324:  ADDLW  96
01326:  MOVWF  FE9
01328:  MOVLW  07
0132A:  ADDWFC 03,W
0132C:  MOVWF  FEA
0132E:  CLRF   FEC
01330:  MOVF   FED,F
01332:  CLRF   FEF
....................       } 
01334:  BRA    13FC
01336:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
01338:  BCF    FD8.0
0133A:  MOVLB  7
0133C:  RLCF   x3C,W
0133E:  CLRF   03
01340:  ADDLW  82
01342:  MOVWF  FE9
01344:  MOVLW  07
01346:  ADDWFC 03,W
01348:  MOVWF  FEA
0134A:  MOVFF  FEC,A1D
0134E:  MOVF   FED,F
01350:  MOVFF  FEF,A1C
01354:  MOVLB  A
01356:  DECFSZ x1C,W
01358:  BRA    13FE
0135A:  MOVF   x1D,F
0135C:  BNZ   13FE
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
0135E:  BCF    FD8.0
01360:  MOVLB  7
01362:  RLCF   x3C,W
01364:  CLRF   03
01366:  ADDLW  BB
01368:  MOVWF  FE9
0136A:  MOVLW  07
0136C:  ADDWFC 03,W
0136E:  MOVWF  FEA
01370:  MOVFF  FEC,A1D
01374:  MOVF   FED,F
01376:  MOVFF  FEF,A1C
0137A:  MOVLB  A
0137C:  MOVF   x1C,F
0137E:  BNZ   13CA
01380:  MOVF   x1D,F
01382:  BNZ   13CA
01384:  BCF    FD8.0
01386:  MOVLB  7
01388:  RLCF   x3C,W
0138A:  CLRF   03
0138C:  ADDLW  BB
0138E:  MOVWF  01
01390:  MOVLW  07
01392:  ADDWFC 03,F
01394:  MOVLB  A
01396:  MOVFF  03,A1D
0139A:  BCF    FD8.0
0139C:  MOVLB  7
0139E:  RLCF   x3C,W
013A0:  CLRF   03
013A2:  ADDLW  5A
013A4:  MOVWF  FE9
013A6:  MOVLW  07
013A8:  ADDWFC 03,W
013AA:  MOVWF  FEA
013AC:  MOVFF  FEC,03
013B0:  MOVF   FED,F
013B2:  MOVFF  FEF,A1E
013B6:  MOVLB  A
013B8:  MOVFF  A1D,FEA
013BC:  MOVFF  01,FE9
013C0:  MOVFF  03,FEC
013C4:  MOVF   FED,F
013C6:  MOVFF  A1E,FEF
....................          e_pos[motor]--; 
013CA:  BCF    FD8.0
013CC:  MOVLB  7
013CE:  RLCF   x3C,W
013D0:  CLRF   03
013D2:  ADDLW  BB
013D4:  MOVWF  FE9
013D6:  MOVLW  07
013D8:  ADDWFC 03,W
013DA:  MOVWF  FEA
013DC:  MOVLW  FF
013DE:  ADDWF  FEF,F
013E0:  BC    13E6
013E2:  MOVF   FEE,F
013E4:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
013E6:  BCF    FD8.0
013E8:  RLCF   x3C,W
013EA:  CLRF   03
013EC:  ADDLW  96
013EE:  MOVWF  FE9
013F0:  MOVLW  07
013F2:  ADDWFC 03,W
013F4:  MOVWF  FEA
013F6:  CLRF   FEC
013F8:  MOVF   FED,F
013FA:  CLRF   FEF
013FC:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
013FE:  BCF    FD8.0
01400:  MOVLB  7
01402:  RLCF   x3C,W
01404:  CLRF   03
01406:  ADDLW  4A
01408:  MOVWF  FE9
0140A:  MOVLW  07
0140C:  ADDWFC 03,W
0140E:  MOVWF  FEA
01410:  MOVFF  FEC,A1D
01414:  MOVF   FED,F
01416:  MOVFF  FEF,A1C
0141A:  MOVLB  A
0141C:  DECFSZ x1C,W
0141E:  BRA    15A6
01420:  MOVF   x1D,F
01422:  BTFSS  FD8.2
01424:  BRA    15A6
....................       if(m_way[motor]==NEG) { 
01426:  BCF    FD8.0
01428:  MOVLB  7
0142A:  RLCF   x3C,W
0142C:  CLRF   03
0142E:  ADDLW  82
01430:  MOVWF  FE9
01432:  MOVLW  07
01434:  ADDWFC 03,W
01436:  MOVWF  FEA
01438:  MOVFF  FEC,A1D
0143C:  MOVF   FED,F
0143E:  MOVFF  FEF,A1C
01442:  MOVLB  A
01444:  DECFSZ x1C,W
01446:  BRA    14E0
01448:  MOVF   x1D,F
0144A:  BNZ   14E0
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
0144C:  BCF    FD8.0
0144E:  MOVLB  7
01450:  RLCF   x3C,W
01452:  CLRF   03
01454:  ADDLW  BB
01456:  MOVWF  FE9
01458:  MOVLW  07
0145A:  ADDWFC 03,W
0145C:  MOVWF  FEA
0145E:  MOVFF  FEC,A1D
01462:  MOVF   FED,F
01464:  MOVFF  FEF,A1C
01468:  BCF    FD8.0
0146A:  RLCF   x3C,W
0146C:  CLRF   03
0146E:  ADDLW  5A
01470:  MOVWF  FE9
01472:  MOVLW  07
01474:  ADDWFC 03,W
01476:  MOVWF  FEA
01478:  MOVFF  FEC,03
0147C:  MOVF   FED,F
0147E:  MOVFF  FEF,01
01482:  MOVF   03,W
01484:  MOVLB  A
01486:  SUBWF  x1D,W
01488:  BNC   14AC
0148A:  BNZ   1492
0148C:  MOVF   01,W
0148E:  SUBWF  x1C,W
01490:  BNC   14AC
01492:  BCF    FD8.0
01494:  MOVLB  7
01496:  RLCF   x3C,W
01498:  CLRF   03
0149A:  ADDLW  BB
0149C:  MOVWF  FE9
0149E:  MOVLW  07
014A0:  ADDWFC 03,W
014A2:  MOVWF  FEA
014A4:  CLRF   FEC
014A6:  MOVF   FED,F
014A8:  CLRF   FEF
014AA:  MOVLB  A
....................          e_pos[motor]++; 
014AC:  BCF    FD8.0
014AE:  MOVLB  7
014B0:  RLCF   x3C,W
014B2:  CLRF   03
014B4:  ADDLW  BB
014B6:  MOVWF  FE9
014B8:  MOVLW  07
014BA:  ADDWFC 03,W
014BC:  MOVWF  FEA
014BE:  MOVLW  01
014C0:  ADDWF  FEE,F
014C2:  BNC   14C6
014C4:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014C6:  BCF    FD8.0
014C8:  RLCF   x3C,W
014CA:  CLRF   03
014CC:  ADDLW  96
014CE:  MOVWF  FE9
014D0:  MOVLW  07
014D2:  ADDWFC 03,W
014D4:  MOVWF  FEA
014D6:  CLRF   FEC
014D8:  MOVF   FED,F
014DA:  CLRF   FEF
....................       } 
014DC:  BRA    15A4
014DE:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
014E0:  BCF    FD8.0
014E2:  MOVLB  7
014E4:  RLCF   x3C,W
014E6:  CLRF   03
014E8:  ADDLW  82
014EA:  MOVWF  FE9
014EC:  MOVLW  07
014EE:  ADDWFC 03,W
014F0:  MOVWF  FEA
014F2:  MOVFF  FEC,A1D
014F6:  MOVF   FED,F
014F8:  MOVFF  FEF,A1C
014FC:  MOVLB  A
014FE:  MOVF   x1C,F
01500:  BNZ   15A6
01502:  MOVF   x1D,F
01504:  BNZ   15A6
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01506:  BCF    FD8.0
01508:  MOVLB  7
0150A:  RLCF   x3C,W
0150C:  CLRF   03
0150E:  ADDLW  BB
01510:  MOVWF  FE9
01512:  MOVLW  07
01514:  ADDWFC 03,W
01516:  MOVWF  FEA
01518:  MOVFF  FEC,A1D
0151C:  MOVF   FED,F
0151E:  MOVFF  FEF,A1C
01522:  MOVLB  A
01524:  MOVF   x1C,F
01526:  BNZ   1572
01528:  MOVF   x1D,F
0152A:  BNZ   1572
0152C:  BCF    FD8.0
0152E:  MOVLB  7
01530:  RLCF   x3C,W
01532:  CLRF   03
01534:  ADDLW  BB
01536:  MOVWF  01
01538:  MOVLW  07
0153A:  ADDWFC 03,F
0153C:  MOVLB  A
0153E:  MOVFF  03,A1D
01542:  BCF    FD8.0
01544:  MOVLB  7
01546:  RLCF   x3C,W
01548:  CLRF   03
0154A:  ADDLW  5A
0154C:  MOVWF  FE9
0154E:  MOVLW  07
01550:  ADDWFC 03,W
01552:  MOVWF  FEA
01554:  MOVFF  FEC,03
01558:  MOVF   FED,F
0155A:  MOVFF  FEF,A1E
0155E:  MOVLB  A
01560:  MOVFF  A1D,FEA
01564:  MOVFF  01,FE9
01568:  MOVFF  03,FEC
0156C:  MOVF   FED,F
0156E:  MOVFF  A1E,FEF
....................          e_pos[motor]--; 
01572:  BCF    FD8.0
01574:  MOVLB  7
01576:  RLCF   x3C,W
01578:  CLRF   03
0157A:  ADDLW  BB
0157C:  MOVWF  FE9
0157E:  MOVLW  07
01580:  ADDWFC 03,W
01582:  MOVWF  FEA
01584:  MOVLW  FF
01586:  ADDWF  FEF,F
01588:  BC    158E
0158A:  MOVF   FEE,F
0158C:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
0158E:  BCF    FD8.0
01590:  RLCF   x3C,W
01592:  CLRF   03
01594:  ADDLW  96
01596:  MOVWF  FE9
01598:  MOVLW  07
0159A:  ADDWFC 03,W
0159C:  MOVWF  FEA
0159E:  CLRF   FEC
015A0:  MOVF   FED,F
015A2:  CLRF   FEF
015A4:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
015A6:  MOVF   1F,W
015A8:  SUBLW  04
015AA:  BTFSS  FD8.2
015AC:  BRA    16E0
015AE:  MOVF   20,F
015B0:  BTFSS  FD8.2
015B2:  BRA    16E0
015B4:  BCF    FD8.0
015B6:  MOVLB  7
015B8:  RLCF   x3C,W
015BA:  CLRF   03
015BC:  ADDLW  66
015BE:  MOVWF  FE9
015C0:  MOVLW  07
015C2:  ADDWFC 03,W
015C4:  MOVWF  FEA
015C6:  MOVFF  FEC,A1D
015CA:  MOVF   FED,F
015CC:  MOVFF  FEF,A1C
015D0:  MOVLB  A
015D2:  MOVF   x1C,W
015D4:  SUBLW  02
015D6:  BTFSS  FD8.2
015D8:  BRA    16E0
015DA:  MOVF   x1D,F
015DC:  BTFSS  FD8.2
015DE:  BRA    16E0
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
015E0:  MOVLW  01
015E2:  MOVLB  7
015E4:  ADDWF  x3C,W
015E6:  MOVLB  A
015E8:  MOVWF  x1C
015EA:  MOVLB  7
015EC:  MOVF   x3C,W
015EE:  MULLW  04
015F0:  MOVF   FF3,W
015F2:  CLRF   03
015F4:  ADDLW  9E
015F6:  MOVWF  FE9
015F8:  MOVLW  07
015FA:  ADDWFC 03,W
015FC:  MOVWF  FEA
015FE:  MOVFF  FEF,A1D
01602:  MOVFF  FEC,A1E
01606:  MOVFF  FEC,A1F
0160A:  MOVFF  FEC,A20
0160E:  BCF    FD8.0
01610:  RLCF   x3C,W
01612:  CLRF   03
01614:  ADDLW  B7
01616:  MOVWF  FE9
01618:  MOVLW  07
0161A:  ADDWFC 03,W
0161C:  MOVWF  FEA
0161E:  MOVFF  FEC,A22
01622:  MOVF   FED,F
01624:  MOVFF  FEF,A21
01628:  BCF    FD8.0
0162A:  RLCF   x3C,W
0162C:  CLRF   03
0162E:  ADDLW  BB
01630:  MOVWF  FE9
01632:  MOVLW  07
01634:  ADDWFC 03,W
01636:  MOVWF  FEA
01638:  MOVFF  FEC,A24
0163C:  MOVF   FED,F
0163E:  MOVFF  FEF,A23
01642:  MOVLW  6D
01644:  BTFSS  F9E.4
01646:  BRA    1644
01648:  MOVWF  FAD
0164A:  MOVLW  3A
0164C:  BTFSS  F9E.4
0164E:  BRA    164C
01650:  MOVWF  FAD
01652:  MOVFF  A1C,A25
01656:  MOVLW  1B
01658:  MOVLB  A
0165A:  MOVWF  x26
0165C:  MOVLB  0
0165E:  RCALL  0FA0
01660:  MOVLW  2C
01662:  BTFSS  F9E.4
01664:  BRA    1662
01666:  MOVWF  FAD
01668:  MOVFF  7A6,A25
0166C:  MOVLW  1B
0166E:  MOVLB  A
01670:  MOVWF  x26
01672:  MOVLB  0
01674:  RCALL  0FA0
01676:  MOVLW  63
01678:  MOVWF  FF6
0167A:  MOVLW  0F
0167C:  MOVWF  FF7
0167E:  MOVLW  00
01680:  MOVWF  FF8
01682:  MOVLW  03
01684:  MOVLB  A
01686:  MOVWF  x25
01688:  MOVLB  0
0168A:  RCALL  101E
0168C:  MOVLW  41
0168E:  MOVWF  FE9
01690:  MOVFF  A20,A28
01694:  MOVFF  A1F,A27
01698:  MOVFF  A1E,A26
0169C:  MOVFF  A1D,A25
016A0:  RCALL  10E4
016A2:  MOVLW  2C
016A4:  BTFSS  F9E.4
016A6:  BRA    16A4
016A8:  MOVWF  FAD
016AA:  MOVLW  10
016AC:  MOVWF  FE9
016AE:  MOVFF  A22,A26
016B2:  MOVFF  A21,A25
016B6:  RCALL  11A0
016B8:  MOVLW  2C
016BA:  BTFSS  F9E.4
016BC:  BRA    16BA
016BE:  MOVWF  FAD
016C0:  MOVLW  10
016C2:  MOVWF  FE9
016C4:  MOVFF  A24,A26
016C8:  MOVFF  A23,A25
016CC:  RCALL  11A0
016CE:  MOVLW  0D
016D0:  BTFSS  F9E.4
016D2:  BRA    16D0
016D4:  MOVWF  FAD
016D6:  MOVLW  0A
016D8:  BTFSS  F9E.4
016DA:  BRA    16D8
016DC:  MOVWF  FAD
016DE:  MOVLB  A
....................    }    
016E0:  MOVLB  0
016E2:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A7C2:  MOVLB  7
0A7C4:  MOVF   x3C,W
0A7C6:  XORLW  00
0A7C8:  MOVLB  0
0A7CA:  BZ    A7D2
0A7CC:  XORLW  01
0A7CE:  BZ    A862
0A7D0:  BRA    A8F0
....................       case 0 : if (e_type[motor]==1) { 
0A7D2:  BCF    FD8.0
0A7D4:  MOVLB  7
0A7D6:  RLCF   x3C,W
0A7D8:  CLRF   03
0A7DA:  ADDLW  66
0A7DC:  MOVWF  FE9
0A7DE:  MOVLW  07
0A7E0:  ADDWFC 03,W
0A7E2:  MOVWF  FEA
0A7E4:  MOVFF  FEC,8B2
0A7E8:  MOVF   FED,F
0A7EA:  MOVFF  FEF,8B1
0A7EE:  MOVLB  8
0A7F0:  DECFSZ xB1,W
0A7F2:  BRA    A812
0A7F4:  MOVF   xB2,F
0A7F6:  BNZ   A812
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A7F8:  CLRF   03
0A7FA:  MOVLB  7
0A7FC:  MOVF   x3C,W
0A7FE:  ADDLW  C7
0A800:  MOVWF  FE9
0A802:  MOVLW  07
0A804:  ADDWFC 03,W
0A806:  MOVWF  FEA
0A808:  MOVLW  00
0A80A:  BTFSC  F81.4
0A80C:  MOVLW  01
0A80E:  MOVWF  FEF
0A810:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A812:  BCF    FD8.0
0A814:  MOVLB  7
0A816:  RLCF   x3C,W
0A818:  CLRF   03
0A81A:  ADDLW  66
0A81C:  MOVWF  FE9
0A81E:  MOVLW  07
0A820:  ADDWFC 03,W
0A822:  MOVWF  FEA
0A824:  MOVFF  FEC,8B2
0A828:  MOVF   FED,F
0A82A:  MOVFF  FEF,8B1
0A82E:  MOVLB  8
0A830:  MOVF   xB1,W
0A832:  SUBLW  02
0A834:  BNZ   A85E
0A836:  MOVF   xB2,F
0A838:  BNZ   A85E
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A83A:  CLRF   03
0A83C:  MOVLB  7
0A83E:  MOVF   x3C,W
0A840:  ADDLW  C7
0A842:  MOVWF  FE9
0A844:  MOVLW  07
0A846:  ADDWFC 03,W
0A848:  MOVWF  FEA
0A84A:  MOVLW  00
0A84C:  BTFSC  F81.4
0A84E:  MOVLW  01
0A850:  MOVLB  8
0A852:  MOVWF  xB3
0A854:  MOVLW  00
0A856:  BTFSC  F81.1
0A858:  MOVLW  01
0A85A:  ANDWF  xB3,W
0A85C:  MOVWF  FEF
....................                } 
....................          break; 
0A85E:  MOVLB  0
0A860:  BRA    A8F0
....................       case 1 : if (e_type[motor]==1) { 
0A862:  BCF    FD8.0
0A864:  MOVLB  7
0A866:  RLCF   x3C,W
0A868:  CLRF   03
0A86A:  ADDLW  66
0A86C:  MOVWF  FE9
0A86E:  MOVLW  07
0A870:  ADDWFC 03,W
0A872:  MOVWF  FEA
0A874:  MOVFF  FEC,8B2
0A878:  MOVF   FED,F
0A87A:  MOVFF  FEF,8B1
0A87E:  MOVLB  8
0A880:  DECFSZ xB1,W
0A882:  BRA    A8A2
0A884:  MOVF   xB2,F
0A886:  BNZ   A8A2
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A888:  CLRF   03
0A88A:  MOVLB  7
0A88C:  MOVF   x3C,W
0A88E:  ADDLW  C7
0A890:  MOVWF  FE9
0A892:  MOVLW  07
0A894:  ADDWFC 03,W
0A896:  MOVWF  FEA
0A898:  MOVLW  00
0A89A:  BTFSC  F81.5
0A89C:  MOVLW  01
0A89E:  MOVWF  FEF
0A8A0:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A8A2:  BCF    FD8.0
0A8A4:  MOVLB  7
0A8A6:  RLCF   x3C,W
0A8A8:  CLRF   03
0A8AA:  ADDLW  66
0A8AC:  MOVWF  FE9
0A8AE:  MOVLW  07
0A8B0:  ADDWFC 03,W
0A8B2:  MOVWF  FEA
0A8B4:  MOVFF  FEC,8B2
0A8B8:  MOVF   FED,F
0A8BA:  MOVFF  FEF,8B1
0A8BE:  MOVLB  8
0A8C0:  MOVF   xB1,W
0A8C2:  SUBLW  02
0A8C4:  BNZ   A8EE
0A8C6:  MOVF   xB2,F
0A8C8:  BNZ   A8EE
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A8CA:  CLRF   03
0A8CC:  MOVLB  7
0A8CE:  MOVF   x3C,W
0A8D0:  ADDLW  C7
0A8D2:  MOVWF  FE9
0A8D4:  MOVLW  07
0A8D6:  ADDWFC 03,W
0A8D8:  MOVWF  FEA
0A8DA:  MOVLW  00
0A8DC:  BTFSC  F81.5
0A8DE:  MOVLW  01
0A8E0:  MOVLB  8
0A8E2:  MOVWF  xB3
0A8E4:  MOVLW  00
0A8E6:  BTFSC  F81.2
0A8E8:  MOVLW  01
0A8EA:  ANDWF  xB3,W
0A8EC:  MOVWF  FEF
....................                } 
....................          break; 
0A8EE:  MOVLB  0
....................    } 
0A8F0:  GOTO   A9AA (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017D0:  MOVLB  7
017D2:  MOVF   x3C,W
017D4:  XORLW  00
017D6:  MOVLB  0
017D8:  BZ    17E0
017DA:  XORLW  01
017DC:  BZ    1870
017DE:  BRA    18FE
....................       case 0 : if (e_type[motor]==1) { 
017E0:  BCF    FD8.0
017E2:  MOVLB  7
017E4:  RLCF   x3C,W
017E6:  CLRF   03
017E8:  ADDLW  66
017EA:  MOVWF  FE9
017EC:  MOVLW  07
017EE:  ADDWFC 03,W
017F0:  MOVWF  FEA
017F2:  MOVFF  FEC,A1D
017F6:  MOVF   FED,F
017F8:  MOVFF  FEF,A1C
017FC:  MOVLB  A
017FE:  DECFSZ x1C,W
01800:  BRA    1820
01802:  MOVF   x1D,F
01804:  BNZ   1820
....................                   e_ch_n[motor]=input(ENC1_IND); 
01806:  CLRF   03
01808:  MOVLB  7
0180A:  MOVF   x3C,W
0180C:  ADDLW  C7
0180E:  MOVWF  FE9
01810:  MOVLW  07
01812:  ADDWFC 03,W
01814:  MOVWF  FEA
01816:  MOVLW  00
01818:  BTFSC  F81.4
0181A:  MOVLW  01
0181C:  MOVWF  FEF
0181E:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01820:  BCF    FD8.0
01822:  MOVLB  7
01824:  RLCF   x3C,W
01826:  CLRF   03
01828:  ADDLW  66
0182A:  MOVWF  FE9
0182C:  MOVLW  07
0182E:  ADDWFC 03,W
01830:  MOVWF  FEA
01832:  MOVFF  FEC,A1D
01836:  MOVF   FED,F
01838:  MOVFF  FEF,A1C
0183C:  MOVLB  A
0183E:  MOVF   x1C,W
01840:  SUBLW  02
01842:  BNZ   186C
01844:  MOVF   x1D,F
01846:  BNZ   186C
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
01848:  CLRF   03
0184A:  MOVLB  7
0184C:  MOVF   x3C,W
0184E:  ADDLW  C7
01850:  MOVWF  FE9
01852:  MOVLW  07
01854:  ADDWFC 03,W
01856:  MOVWF  FEA
01858:  MOVLW  00
0185A:  BTFSC  F81.4
0185C:  MOVLW  01
0185E:  MOVLB  A
01860:  MOVWF  x1E
01862:  MOVLW  00
01864:  BTFSC  F81.1
01866:  MOVLW  01
01868:  ANDWF  x1E,W
0186A:  MOVWF  FEF
....................                } 
....................          break; 
0186C:  MOVLB  0
0186E:  BRA    18FE
....................       case 1 : if (e_type[motor]==1) { 
01870:  BCF    FD8.0
01872:  MOVLB  7
01874:  RLCF   x3C,W
01876:  CLRF   03
01878:  ADDLW  66
0187A:  MOVWF  FE9
0187C:  MOVLW  07
0187E:  ADDWFC 03,W
01880:  MOVWF  FEA
01882:  MOVFF  FEC,A1D
01886:  MOVF   FED,F
01888:  MOVFF  FEF,A1C
0188C:  MOVLB  A
0188E:  DECFSZ x1C,W
01890:  BRA    18B0
01892:  MOVF   x1D,F
01894:  BNZ   18B0
....................                   e_ch_n[motor]=input(ENC2_IND); 
01896:  CLRF   03
01898:  MOVLB  7
0189A:  MOVF   x3C,W
0189C:  ADDLW  C7
0189E:  MOVWF  FE9
018A0:  MOVLW  07
018A2:  ADDWFC 03,W
018A4:  MOVWF  FEA
018A6:  MOVLW  00
018A8:  BTFSC  F81.5
018AA:  MOVLW  01
018AC:  MOVWF  FEF
018AE:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018B0:  BCF    FD8.0
018B2:  MOVLB  7
018B4:  RLCF   x3C,W
018B6:  CLRF   03
018B8:  ADDLW  66
018BA:  MOVWF  FE9
018BC:  MOVLW  07
018BE:  ADDWFC 03,W
018C0:  MOVWF  FEA
018C2:  MOVFF  FEC,A1D
018C6:  MOVF   FED,F
018C8:  MOVFF  FEF,A1C
018CC:  MOVLB  A
018CE:  MOVF   x1C,W
018D0:  SUBLW  02
018D2:  BNZ   18FC
018D4:  MOVF   x1D,F
018D6:  BNZ   18FC
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018D8:  CLRF   03
018DA:  MOVLB  7
018DC:  MOVF   x3C,W
018DE:  ADDLW  C7
018E0:  MOVWF  FE9
018E2:  MOVLW  07
018E4:  ADDWFC 03,W
018E6:  MOVWF  FEA
018E8:  MOVLW  00
018EA:  BTFSC  F81.5
018EC:  MOVLW  01
018EE:  MOVLB  A
018F0:  MOVWF  x1E
018F2:  MOVLW  00
018F4:  BTFSC  F81.2
018F6:  MOVLW  01
018F8:  ANDWF  x1E,W
018FA:  MOVWF  FEF
....................                } 
....................          break; 
018FC:  MOVLB  0
....................    } 
018FE:  GOTO   1A4C (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
016E4:  BCF    FD8.0
016E6:  MOVLB  7
016E8:  RLCF   x3C,W
016EA:  CLRF   03
016EC:  ADDLW  B7
016EE:  MOVWF  FE9
016F0:  MOVLW  07
016F2:  ADDWFC 03,W
016F4:  MOVWF  FEA
016F6:  MOVLW  01
016F8:  ADDWF  FEE,F
016FA:  BNC   16FE
016FC:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
016FE:  MOVF   xA6,W
01700:  XORLW  00
01702:  MOVLB  0
01704:  BZ    1710
01706:  XORLW  01
01708:  BZ    1716
0170A:  XORLW  03
0170C:  BZ    1728
0170E:  BRA    1752
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
01710:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
01712:  BCF    FF0.0
....................          break; 
01714:  BRA    1752
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01716:  MOVLW  02
01718:  MOVLB  7
0171A:  MOVWF  xA6
....................                disable_interrupts(INT_EXT1_L2H); 
0171C:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
0171E:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01720:  BSF    FF0.3
01722:  BCF    FF1.5
....................          break; 
01724:  MOVLB  0
01726:  BRA    1752
....................       case 2 : edge_mode=1; 
01728:  MOVLW  01
0172A:  MOVLB  7
0172C:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
0172E:  BCF    FD8.0
01730:  RLCF   x3C,W
01732:  CLRF   03
01734:  ADDLW  B7
01736:  MOVWF  FE9
01738:  MOVLW  07
0173A:  ADDWFC 03,W
0173C:  MOVWF  FEA
0173E:  MOVLW  FF
01740:  ADDWF  FEF,F
01742:  BC    1748
01744:  MOVF   FEE,F
01746:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
01748:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
0174A:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
0174C:  BSF    FF0.3
0174E:  BSF    FF1.5
....................          break; 
01750:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
01752:  RCALL  1254
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
01754:  BCF    FF0.0
01756:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
0175A:  BCF    FD8.0
0175C:  MOVLB  7
0175E:  RLCF   x3C,W
01760:  CLRF   03
01762:  ADDLW  B7
01764:  MOVWF  FE9
01766:  MOVLW  07
01768:  ADDWFC 03,W
0176A:  MOVWF  FEA
0176C:  MOVLW  01
0176E:  ADDWF  FEE,F
01770:  BNC   1774
01772:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
01774:  MOVF   xA6,W
01776:  XORLW  00
01778:  MOVLB  0
0177A:  BZ    1786
0177C:  XORLW  01
0177E:  BZ    178C
01780:  XORLW  03
01782:  BZ    179E
01784:  BRA    17C8
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
01786:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
01788:  BCF    FF0.1
....................          break; 
0178A:  BRA    17C8
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
0178C:  MOVLW  02
0178E:  MOVLB  7
01790:  MOVWF  xA6
....................                disable_interrupts(INT_EXT2_L2H); 
01792:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
01794:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
01796:  BSF    FF0.4
01798:  BCF    FF1.4
....................          break; 
0179A:  MOVLB  0
0179C:  BRA    17C8
....................       case 2 : edge_mode=1; 
0179E:  MOVLW  01
017A0:  MOVLB  7
017A2:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
017A4:  BCF    FD8.0
017A6:  RLCF   x3C,W
017A8:  CLRF   03
017AA:  ADDLW  B7
017AC:  MOVWF  FE9
017AE:  MOVLW  07
017B0:  ADDWFC 03,W
017B2:  MOVWF  FEA
017B4:  MOVLW  FF
017B6:  ADDWF  FEF,F
017B8:  BC    17BE
017BA:  MOVF   FEE,F
017BC:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017BE:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017C0:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017C2:  BSF    FF0.4
017C4:  BSF    FF1.4
....................          break; 
017C6:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017C8:  RCALL  1254
.................... } 
....................  
.................... // motor step timer interrupt 
017CA:  BCF    FF0.1
017CC:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
01902:  MOVLW  F9
01904:  MOVWF  FB3
01906:  MOVLW  C0
01908:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
0190A:  BCF    FD8.0
0190C:  MOVLB  7
0190E:  RLCF   x3C,W
01910:  CLRF   03
01912:  ADDLW  8A
01914:  MOVWF  FE9
01916:  MOVLW  07
01918:  ADDWFC 03,W
0191A:  MOVWF  FEA
0191C:  MOVLW  01
0191E:  ADDWF  FEE,F
01920:  BNC   1924
01922:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
01924:  BCF    FD8.0
01926:  RLCF   x3C,W
01928:  CLRF   03
0192A:  ADDLW  8A
0192C:  MOVWF  FE9
0192E:  MOVLW  07
01930:  ADDWFC 03,W
01932:  MOVWF  FEA
01934:  MOVFF  FEC,A1D
01938:  MOVF   FED,F
0193A:  MOVFF  FEF,A1C
0193E:  BCF    FD8.0
01940:  RLCF   x3C,W
01942:  CLRF   03
01944:  ADDLW  46
01946:  MOVWF  FE9
01948:  MOVLW  07
0194A:  ADDWFC 03,W
0194C:  MOVWF  FEA
0194E:  MOVFF  FEC,03
01952:  MOVF   FED,F
01954:  MOVFF  FEF,01
01958:  MOVF   03,W
0195A:  MOVLB  A
0195C:  SUBWF  x1D,W
0195E:  BTFSS  FD8.0
01960:  BRA    1A4E
01962:  BNZ   196C
01964:  MOVF   01,W
01966:  SUBWF  x1C,W
01968:  BTFSS  FD8.0
0196A:  BRA    1A4E
....................    { 
....................       m_step_cnt[motor]++; 
0196C:  MOVLB  7
0196E:  MOVF   x3C,W
01970:  MULLW  04
01972:  MOVF   FF3,W
01974:  CLRF   03
01976:  ADDLW  9E
01978:  MOVWF  FE9
0197A:  MOVLW  07
0197C:  ADDWFC 03,W
0197E:  MOVWF  FEA
01980:  MOVLW  01
01982:  ADDWF  FEE,F
01984:  MOVLW  00
01986:  ADDWFC FEE,F
01988:  ADDWFC FEE,F
0198A:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
0198C:  BCF    FD8.0
0198E:  RLCF   x3C,W
01990:  CLRF   03
01992:  ADDLW  96
01994:  MOVWF  FE9
01996:  MOVLW  07
01998:  ADDWFC 03,W
0199A:  MOVWF  FEA
0199C:  MOVLW  01
0199E:  ADDWF  FEE,F
019A0:  BNC   19A4
019A2:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
019A4:  BCF    FD8.0
019A6:  RLCF   x3C,W
019A8:  CLRF   03
019AA:  ADDLW  8A
019AC:  MOVWF  FE9
019AE:  MOVLW  07
019B0:  ADDWFC 03,W
019B2:  MOVWF  FEA
019B4:  CLRF   FEC
019B6:  MOVF   FED,F
019B8:  CLRF   FEF
....................  
....................       if (motor==0) 
019BA:  MOVF   x3C,F
019BC:  BNZ   19C2
....................       { 
....................          output_toggle(M1_CLOCK); 
019BE:  BTG    F90.4
....................       } 
019C0:  BRA    1A22
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019C2:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019C4:  BCF    FD8.0
019C6:  RLCF   x3C,W
019C8:  CLRF   03
019CA:  ADDLW  82
019CC:  MOVWF  FE9
019CE:  MOVLW  07
019D0:  ADDWFC 03,W
019D2:  MOVWF  FEA
019D4:  MOVFF  FEC,A1D
019D8:  MOVF   FED,F
019DA:  MOVFF  FEF,A1C
019DE:  MOVLB  A
019E0:  MOVF   x1C,F
019E2:  BNZ   1A08
019E4:  MOVF   x1D,F
019E6:  BNZ   1A08
019E8:  BCF    FD8.0
019EA:  MOVLB  7
019EC:  RLCF   x3C,W
019EE:  CLRF   03
019F0:  ADDLW  AF
019F2:  MOVWF  FE9
019F4:  MOVLW  07
019F6:  ADDWFC 03,W
019F8:  MOVWF  FEA
019FA:  MOVLW  FF
019FC:  ADDWF  FEF,F
019FE:  BC    1A04
01A00:  MOVF   FEE,F
01A02:  DECF   FED,F
01A04:  BRA    1A22
01A06:  MOVLB  A
....................          else m_lin_pos[motor]++;          
01A08:  BCF    FD8.0
01A0A:  MOVLB  7
01A0C:  RLCF   x3C,W
01A0E:  CLRF   03
01A10:  ADDLW  AF
01A12:  MOVWF  FE9
01A14:  MOVLW  07
01A16:  ADDWFC 03,W
01A18:  MOVWF  FEA
01A1A:  MOVLW  01
01A1C:  ADDWF  FEE,F
01A1E:  BNC   1A22
01A20:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A22:  BCF    FD8.0
01A24:  RLCF   x3C,W
01A26:  CLRF   03
01A28:  ADDLW  62
01A2A:  MOVWF  FE9
01A2C:  MOVLW  07
01A2E:  ADDWFC 03,W
01A30:  MOVWF  FEA
01A32:  MOVFF  FEC,A1D
01A36:  MOVF   FED,F
01A38:  MOVFF  FEF,A1C
01A3C:  MOVLB  A
01A3E:  MOVF   x1C,W
01A40:  SUBLW  03
01A42:  BNZ   1A4E
01A44:  MOVF   x1D,F
01A46:  BNZ   1A4E
01A48:  MOVLB  0
01A4A:  BRA    17D0
01A4C:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A4E:  BCF    FA1.1
01A50:  BCF    FA1.1
01A52:  MOVLB  0
01A54:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
08A24:  BCF    FD8.0
08A26:  MOVLB  7
08A28:  RLCF   x3C,W
08A2A:  CLRF   03
08A2C:  ADDLW  4A
08A2E:  MOVWF  FE9
08A30:  MOVLW  07
08A32:  ADDWFC 03,W
08A34:  MOVWF  FEA
08A36:  MOVFF  FEC,8C3
08A3A:  MOVF   FED,F
08A3C:  MOVFF  FEF,8C2
08A40:  MOVLB  8
08A42:  DECFSZ xC2,W
08A44:  BRA    8A94
08A46:  MOVF   xC3,F
08A48:  BNZ   8A94
08A4A:  BCF    FD8.0
08A4C:  MOVLB  7
08A4E:  RLCF   x3C,W
08A50:  CLRF   03
08A52:  ADDLW  82
08A54:  MOVWF  01
08A56:  MOVLW  07
08A58:  ADDWFC 03,F
08A5A:  MOVFF  01,8C2
08A5E:  MOVLB  8
08A60:  MOVFF  03,8C3
08A64:  BCF    FD8.0
08A66:  MOVLB  7
08A68:  RLCF   x3C,W
08A6A:  CLRF   03
08A6C:  ADDLW  82
08A6E:  MOVWF  FE9
08A70:  MOVLW  07
08A72:  ADDWFC 03,W
08A74:  MOVWF  FEA
08A76:  MOVF   FEF,F
08A78:  BNZ   8A7E
08A7A:  MOVF   FEC,F
08A7C:  BZ    8A82
08A7E:  MOVLW  00
08A80:  BRA    8A84
08A82:  MOVLW  01
08A84:  MOVLB  8
08A86:  MOVFF  8C3,FEA
08A8A:  MOVFF  8C2,FE9
08A8E:  CLRF   FEC
08A90:  MOVF   FED,F
08A92:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
08A94:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
08A96:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
08A98:  BCF    FD8.0
08A9A:  MOVLB  7
08A9C:  RLCF   x3C,W
08A9E:  CLRF   03
08AA0:  ADDLW  3E
08AA2:  MOVWF  FE9
08AA4:  MOVLW  07
08AA6:  ADDWFC 03,W
08AA8:  MOVWF  FEA
08AAA:  MOVF   FEF,F
08AAC:  BNZ   8AB6
08AAE:  MOVF   FEC,F
08AB0:  BNZ   8AB6
08AB2:  BCF    F90.2
08AB4:  BRA    8AB8
08AB6:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
08AB8:  BCF    FD8.0
08ABA:  RLCF   x3C,W
08ABC:  CLRF   03
08ABE:  ADDLW  42
08AC0:  MOVWF  FE9
08AC2:  MOVLW  07
08AC4:  ADDWFC 03,W
08AC6:  MOVWF  FEA
08AC8:  MOVF   FEF,F
08ACA:  BNZ   8AD4
08ACC:  MOVF   FEC,F
08ACE:  BNZ   8AD4
08AD0:  BCF    F90.3
08AD2:  BRA    8AD6
08AD4:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
08AD6:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
08AD8:  BCF    FD8.0
08ADA:  RLCF   x3C,W
08ADC:  CLRF   03
08ADE:  ADDLW  82
08AE0:  MOVWF  FE9
08AE2:  MOVLW  07
08AE4:  ADDWFC 03,W
08AE6:  MOVWF  FEA
08AE8:  MOVF   FEF,F
08AEA:  BNZ   8AF4
08AEC:  MOVF   FEC,F
08AEE:  BNZ   8AF4
08AF0:  BCF    F90.5
08AF2:  BRA    8AF6
08AF4:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08AF6:  BCF    FD8.0
08AF8:  RLCF   x3C,W
08AFA:  CLRF   03
08AFC:  ADDLW  52
08AFE:  MOVWF  FE9
08B00:  MOVLW  07
08B02:  ADDWFC 03,W
08B04:  MOVWF  FEA
08B06:  MOVFF  FEC,8C3
08B0A:  MOVF   FED,F
08B0C:  MOVFF  FEF,8C2
08B10:  MOVLB  8
08B12:  RRCF   xC3,F
08B14:  RRCF   xC2,F
08B16:  RRCF   xC3,F
08B18:  RRCF   xC2,F
08B1A:  RRCF   xC3,F
08B1C:  MOVFF  8C2,FBC
08B20:  RRCF   xC3,F
08B22:  RRCF   xC3,W
08B24:  ANDLW  30
08B26:  MOVWF  00
08B28:  MOVF   FBB,W
08B2A:  ANDLW  CF
08B2C:  IORWF  00,W
08B2E:  MOVWF  FBB
08B30:  MOVLB  0
08B32:  GOTO   8CBC (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08B36:  BCF    FD8.0
08B38:  MOVLB  7
08B3A:  RLCF   x3C,W
08B3C:  CLRF   03
08B3E:  ADDLW  4A
08B40:  MOVWF  FE9
08B42:  MOVLW  07
08B44:  ADDWFC 03,W
08B46:  MOVWF  FEA
08B48:  MOVFF  FEC,8C3
08B4C:  MOVF   FED,F
08B4E:  MOVFF  FEF,8C2
08B52:  MOVLB  8
08B54:  DECFSZ xC2,W
08B56:  BRA    8BA6
08B58:  MOVF   xC3,F
08B5A:  BNZ   8BA6
08B5C:  BCF    FD8.0
08B5E:  MOVLB  7
08B60:  RLCF   x3C,W
08B62:  CLRF   03
08B64:  ADDLW  82
08B66:  MOVWF  01
08B68:  MOVLW  07
08B6A:  ADDWFC 03,F
08B6C:  MOVFF  01,8C2
08B70:  MOVLB  8
08B72:  MOVFF  03,8C3
08B76:  BCF    FD8.0
08B78:  MOVLB  7
08B7A:  RLCF   x3C,W
08B7C:  CLRF   03
08B7E:  ADDLW  82
08B80:  MOVWF  FE9
08B82:  MOVLW  07
08B84:  ADDWFC 03,W
08B86:  MOVWF  FEA
08B88:  MOVF   FEF,F
08B8A:  BNZ   8B90
08B8C:  MOVF   FEC,F
08B8E:  BZ    8B94
08B90:  MOVLW  00
08B92:  BRA    8B96
08B94:  MOVLW  01
08B96:  MOVLB  8
08B98:  MOVFF  8C3,FEA
08B9C:  MOVFF  8C2,FE9
08BA0:  CLRF   FEC
08BA2:  MOVF   FED,F
08BA4:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08BA6:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08BA8:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08BAA:  BCF    FD8.0
08BAC:  MOVLB  7
08BAE:  RLCF   x3C,W
08BB0:  CLRF   03
08BB2:  ADDLW  3E
08BB4:  MOVWF  FE9
08BB6:  MOVLW  07
08BB8:  ADDWFC 03,W
08BBA:  MOVWF  FEA
08BBC:  MOVF   FEF,F
08BBE:  BNZ   8BC8
08BC0:  MOVF   FEC,F
08BC2:  BNZ   8BC8
08BC4:  BCF    F8D.2
08BC6:  BRA    8BCA
08BC8:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08BCA:  BCF    FD8.0
08BCC:  RLCF   x3C,W
08BCE:  CLRF   03
08BD0:  ADDLW  42
08BD2:  MOVWF  FE9
08BD4:  MOVLW  07
08BD6:  ADDWFC 03,W
08BD8:  MOVWF  FEA
08BDA:  MOVF   FEF,F
08BDC:  BNZ   8BE6
08BDE:  MOVF   FEC,F
08BE0:  BNZ   8BE6
08BE2:  BCF    F8D.3
08BE4:  BRA    8BE8
08BE6:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08BE8:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08BEA:  BCF    FD8.0
08BEC:  RLCF   x3C,W
08BEE:  CLRF   03
08BF0:  ADDLW  82
08BF2:  MOVWF  FE9
08BF4:  MOVLW  07
08BF6:  ADDWFC 03,W
08BF8:  MOVWF  FEA
08BFA:  MOVF   FEF,F
08BFC:  BNZ   8C06
08BFE:  MOVF   FEC,F
08C00:  BNZ   8C06
08C02:  BCF    F8D.5
08C04:  BRA    8C08
08C06:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08C08:  BCF    FD8.0
08C0A:  RLCF   x3C,W
08C0C:  CLRF   03
08C0E:  ADDLW  52
08C10:  MOVWF  FE9
08C12:  MOVLW  07
08C14:  ADDWFC 03,W
08C16:  MOVWF  FEA
08C18:  MOVFF  FEC,8C3
08C1C:  MOVF   FED,F
08C1E:  MOVFF  FEF,8C2
08C22:  MOVLB  8
08C24:  RRCF   xC3,F
08C26:  RRCF   xC2,F
08C28:  RRCF   xC3,F
08C2A:  RRCF   xC2,F
08C2C:  RRCF   xC3,F
08C2E:  MOVFF  8C2,F4F
08C32:  RRCF   xC3,F
08C34:  RRCF   xC3,W
08C36:  ANDLW  30
08C38:  MOVWF  00
08C3A:  MOVLB  F
08C3C:  MOVF   x4E,W
08C3E:  ANDLW  CF
08C40:  IORWF  00,W
08C42:  MOVWF  x4E
08C44:  MOVLB  0
08C46:  GOTO   8CBC (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
08A10:  MOVLB  8
08A12:  MOVF   xD6,F
08A14:  BZ    8A1C
....................       output_bit(VENC1,ON); 
08A16:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
08A18:  BSF    F8E.7
....................    } 
08A1A:  BRA    8A20
....................    else {       
....................       output_bit(VENC1,OFF); 
08A1C:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
08A1E:  BCF    F8E.7
....................    } 
08A20:  MOVLB  0
08A22:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08DAA:  MOVLB  8
08DAC:  MOVF   xD7,F
08DAE:  BNZ   8DD6
08DB0:  MOVF   xD8,F
08DB2:  BNZ   8DD6
....................       edge_mode=0; 
08DB4:  MOVLB  7
08DB6:  CLRF   xA6
....................       switch (motor){ 
08DB8:  MOVF   x3C,W
08DBA:  XORLW  00
08DBC:  MOVLB  0
08DBE:  BZ    8DC6
08DC0:  XORLW  01
08DC2:  BZ    8DCE
08DC4:  BRA    8DD4
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08DC6:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08DC8:  BSF    FF0.3
08DCA:  BCF    FF1.5
....................             break; 
08DCC:  BRA    8DD4
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08DCE:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08DD0:  BSF    FF0.4
08DD2:  BCF    FF1.4
....................             break; 
08DD4:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08DD6:  DECFSZ xD7,W
08DD8:  BRA    8E00
08DDA:  MOVF   xD8,F
08DDC:  BNZ   8E00
....................       edge_mode=0; 
08DDE:  MOVLB  7
08DE0:  CLRF   xA6
....................       switch (motor){ 
08DE2:  MOVF   x3C,W
08DE4:  XORLW  00
08DE6:  MOVLB  0
08DE8:  BZ    8DF0
08DEA:  XORLW  01
08DEC:  BZ    8DF8
08DEE:  BRA    8DFE
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08DF0:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08DF2:  BSF    FF0.3
08DF4:  BSF    FF1.5
....................             break; 
08DF6:  BRA    8DFE
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08DF8:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08DFA:  BSF    FF0.4
08DFC:  BSF    FF1.4
....................             break; 
08DFE:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08E00:  MOVF   xD7,W
08E02:  SUBLW  02
08E04:  BNZ   8E56
08E06:  MOVF   xD8,F
08E08:  BNZ   8E56
08E0A:  BCF    FD8.0
08E0C:  MOVLB  7
08E0E:  RLCF   x3C,W
08E10:  CLRF   03
08E12:  ADDLW  66
08E14:  MOVWF  FE9
08E16:  MOVLW  07
08E18:  ADDWFC 03,W
08E1A:  MOVWF  FEA
08E1C:  MOVFF  FEC,8DA
08E20:  MOVF   FED,F
08E22:  MOVFF  FEF,8D9
08E26:  MOVLB  8
08E28:  MOVF   xD9,W
08E2A:  SUBLW  02
08E2C:  BNZ   8E56
08E2E:  MOVF   xDA,F
08E30:  BNZ   8E56
....................       edge_mode=1; 
08E32:  MOVLW  01
08E34:  MOVLB  7
08E36:  MOVWF  xA6
....................       switch (motor){ 
08E38:  MOVF   x3C,W
08E3A:  XORLW  00
08E3C:  MOVLB  0
08E3E:  BZ    8E46
08E40:  XORLW  01
08E42:  BZ    8E4E
08E44:  BRA    8E54
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08E46:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08E48:  BSF    FF0.3
08E4A:  BSF    FF1.5
....................             break; 
08E4C:  BRA    8E54
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08E4E:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08E50:  BSF    FF0.4
08E52:  BSF    FF1.4
....................             break; 
08E54:  MOVLB  8
....................       }  
....................    }     
08E56:  MOVLB  0
08E58:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08FC0:  MOVLB  7
08FC2:  MOVF   x3C,W
08FC4:  XORLW  00
08FC6:  MOVLB  0
08FC8:  BZ    8FD0
08FCA:  XORLW  01
08FCC:  BZ    8FFA
08FCE:  BRA    9022
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08FD0:  BCF    FD8.0
08FD2:  MOVLB  7
08FD4:  RLCF   x3C,W
08FD6:  CLRF   03
08FD8:  ADDLW  92
08FDA:  MOVWF  FE9
08FDC:  MOVLW  07
08FDE:  ADDWFC 03,W
08FE0:  MOVWF  FEA
08FE2:  MOVFF  FEC,8DA
08FE6:  MOVF   FED,F
08FE8:  MOVFF  FEF,8D9
08FEC:  MOVLW  6E
08FEE:  MOVLB  8
08FF0:  MOVWF  xD8
08FF2:  MOVLB  0
08FF4:  CALL   502C
....................          break; 
08FF8:  BRA    9022
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08FFA:  BCF    FD8.0
08FFC:  MOVLB  7
08FFE:  RLCF   x3C,W
09000:  CLRF   03
09002:  ADDLW  92
09004:  MOVWF  FE9
09006:  MOVLW  07
09008:  ADDWFC 03,W
0900A:  MOVWF  FEA
0900C:  MOVFF  FEC,8DA
09010:  MOVF   FED,F
09012:  MOVFF  FEF,8D9
09016:  MOVLW  70
09018:  MOVLB  8
0901A:  MOVWF  xD8
0901C:  MOVLB  0
0901E:  CALL   502C
....................          break;          
....................    } 
09022:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08E5A:  MOVLB  8
08E5C:  MOVF   xD6,F
08E5E:  BNZ   8E7C
....................    { 
....................       switch (motor) 
08E60:  MOVLB  7
08E62:  MOVF   x3C,W
08E64:  XORLW  00
08E66:  MOVLB  0
08E68:  BZ    8E70
08E6A:  XORLW  01
08E6C:  BZ    8E76
08E6E:  BRA    8E7A
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08E70:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08E72:  BCF    FF0.3
....................             break; 
08E74:  BRA    8E7A
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08E76:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08E78:  BCF    FF0.4
....................             break; 
08E7A:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08E7C:  DECFSZ xD6,W
08E7E:  BRA    8EE4
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08E80:  BCF    FD8.0
08E82:  MOVLB  7
08E84:  RLCF   x3C,W
08E86:  CLRF   03
08E88:  ADDLW  66
08E8A:  MOVWF  FE9
08E8C:  MOVLW  07
08E8E:  ADDWFC 03,W
08E90:  MOVWF  FEA
08E92:  MOVFF  FEC,8D8
08E96:  MOVF   FED,F
08E98:  MOVFF  FEF,8D7
08E9C:  MOVLB  8
08E9E:  DECFSZ xD7,W
08EA0:  BRA    8EB0
08EA2:  MOVF   xD8,F
08EA4:  BNZ   8EB0
08EA6:  CLRF   xD8
08EA8:  CLRF   xD7
08EAA:  MOVLB  0
08EAC:  RCALL  8DAA
08EAE:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08EB0:  BCF    FD8.0
08EB2:  MOVLB  7
08EB4:  RLCF   x3C,W
08EB6:  CLRF   03
08EB8:  ADDLW  66
08EBA:  MOVWF  FE9
08EBC:  MOVLW  07
08EBE:  ADDWFC 03,W
08EC0:  MOVWF  FEA
08EC2:  MOVFF  FEC,8D8
08EC6:  MOVF   FED,F
08EC8:  MOVFF  FEF,8D7
08ECC:  MOVLB  8
08ECE:  MOVF   xD7,W
08ED0:  SUBLW  02
08ED2:  BNZ   8EE4
08ED4:  MOVF   xD8,F
08ED6:  BNZ   8EE4
08ED8:  CLRF   xD8
08EDA:  MOVLW  01
08EDC:  MOVWF  xD7
08EDE:  MOVLB  0
08EE0:  RCALL  8DAA
08EE2:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08EE4:  MOVF   xD6,W
08EE6:  SUBLW  02
08EE8:  BNZ   8F1E
08EEA:  BCF    FD8.0
08EEC:  MOVLB  7
08EEE:  RLCF   x3C,W
08EF0:  CLRF   03
08EF2:  ADDLW  66
08EF4:  MOVWF  FE9
08EF6:  MOVLW  07
08EF8:  ADDWFC 03,W
08EFA:  MOVWF  FEA
08EFC:  MOVFF  FEC,8D8
08F00:  MOVF   FED,F
08F02:  MOVFF  FEF,8D7
08F06:  MOVLB  8
08F08:  MOVF   xD7,W
08F0A:  SUBLW  02
08F0C:  BNZ   8F1E
08F0E:  MOVF   xD8,F
08F10:  BNZ   8F1E
....................    { 
....................       enable_enc_isr(2);   
08F12:  CLRF   xD8
08F14:  MOVLW  02
08F16:  MOVWF  xD7
08F18:  MOVLB  0
08F1A:  RCALL  8DAA
08F1C:  MOVLB  8
....................    } 
08F1E:  MOVLB  0
08F20:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08C4A:  BCF    FD8.0
08C4C:  MOVLB  7
08C4E:  RLCF   x3C,W
08C50:  CLRF   03
08C52:  ADDLW  8A
08C54:  MOVWF  FE9
08C56:  MOVLW  07
08C58:  ADDWFC 03,W
08C5A:  MOVWF  FEA
08C5C:  CLRF   FEC
08C5E:  MOVF   FED,F
08C60:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08C62:  BCF    FD8.0
08C64:  RLCF   x3C,W
08C66:  CLRF   03
08C68:  ADDLW  B7
08C6A:  MOVWF  FE9
08C6C:  MOVLW  07
08C6E:  ADDWFC 03,W
08C70:  MOVWF  FEA
08C72:  CLRF   FEC
08C74:  MOVF   FED,F
08C76:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08C78:  BCF    FD8.0
08C7A:  RLCF   x3C,W
08C7C:  CLRF   03
08C7E:  ADDLW  96
08C80:  MOVWF  FE9
08C82:  MOVLW  07
08C84:  ADDWFC 03,W
08C86:  MOVWF  FEA
08C88:  CLRF   FEC
08C8A:  MOVF   FED,F
08C8C:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08C8E:  BSF    F8E.1
....................    enc_pwr(ON); 
08C90:  MOVLW  01
08C92:  MOVLB  8
08C94:  MOVWF  xD6
08C96:  MOVLB  0
08C98:  RCALL  8A10
....................    delay_ms(100); 
08C9A:  MOVLW  64
08C9C:  MOVLB  9
08C9E:  MOVWF  xD6
08CA0:  MOVLB  0
08CA2:  CALL   2972
....................     
....................    switch (motor){ 
08CA6:  MOVLB  7
08CA8:  MOVF   x3C,W
08CAA:  XORLW  00
08CAC:  MOVLB  0
08CAE:  BZ    8CB6
08CB0:  XORLW  01
08CB2:  BZ    8CBA
08CB4:  BRA    8CBC
....................       case 0 : motor_setup1(); 
08CB6:  BRA    8A24
....................          break; 
08CB8:  BRA    8CBC
....................       case 1 : motor_setup2(); 
08CBA:  BRA    8B36
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08CBC:  BCF    FD8.0
08CBE:  MOVLB  7
08CC0:  RLCF   x3C,W
08CC2:  CLRF   03
08CC4:  ADDLW  86
08CC6:  MOVWF  FE9
08CC8:  MOVLW  07
08CCA:  ADDWFC 03,W
08CCC:  MOVWF  FEA
08CCE:  MOVFF  FEC,8C3
08CD2:  MOVF   FED,F
08CD4:  MOVFF  FEF,8C2
08CD8:  BCF    FD8.0
08CDA:  RLCF   x3C,W
08CDC:  CLRF   03
08CDE:  ADDLW  82
08CE0:  MOVWF  FE9
08CE2:  MOVLW  07
08CE4:  ADDWFC 03,W
08CE6:  MOVWF  FEA
08CE8:  MOVFF  FEC,03
08CEC:  MOVF   FED,F
08CEE:  MOVF   FEF,W
08CF0:  MOVLB  8
08CF2:  SUBWF  xC2,W
08CF4:  BNZ   8CFC
08CF6:  MOVF   03,W
08CF8:  SUBWF  xC3,W
08CFA:  BZ    8DA4
....................       m_way_rst[motor]=m_way[motor]; 
08CFC:  BCF    FD8.0
08CFE:  MOVLB  7
08D00:  RLCF   x3C,W
08D02:  CLRF   03
08D04:  ADDLW  86
08D06:  MOVWF  01
08D08:  MOVLW  07
08D0A:  ADDWFC 03,F
08D0C:  MOVLB  8
08D0E:  MOVFF  03,8C3
08D12:  BCF    FD8.0
08D14:  MOVLB  7
08D16:  RLCF   x3C,W
08D18:  CLRF   03
08D1A:  ADDLW  82
08D1C:  MOVWF  FE9
08D1E:  MOVLW  07
08D20:  ADDWFC 03,W
08D22:  MOVWF  FEA
08D24:  MOVFF  FEC,03
08D28:  MOVF   FED,F
08D2A:  MOVFF  FEF,8C4
08D2E:  MOVLB  8
08D30:  MOVFF  8C3,FEA
08D34:  MOVFF  01,FE9
08D38:  MOVFF  03,FEC
08D3C:  MOVF   FED,F
08D3E:  MOVFF  8C4,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08D42:  BCF    FD8.0
08D44:  MOVLB  7
08D46:  RLCF   x3C,W
08D48:  CLRF   03
08D4A:  ADDLW  9A
08D4C:  MOVWF  01
08D4E:  MOVLW  07
08D50:  ADDWFC 03,F
08D52:  MOVLB  8
08D54:  MOVFF  03,8C3
08D58:  BCF    FD8.0
08D5A:  MOVLB  7
08D5C:  RLCF   x3C,W
08D5E:  CLRF   03
08D60:  ADDLW  62
08D62:  MOVWF  FE9
08D64:  MOVLW  07
08D66:  ADDWFC 03,W
08D68:  MOVWF  FEA
08D6A:  MOVFF  FEC,03
08D6E:  MOVF   FED,F
08D70:  MOVFF  FEF,8C4
08D74:  MOVLB  8
08D76:  MOVFF  8C3,FEA
08D7A:  MOVFF  01,FE9
08D7E:  MOVFF  03,FEC
08D82:  MOVF   FED,F
08D84:  MOVFF  8C4,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08D88:  BCF    FD8.0
08D8A:  MOVLB  7
08D8C:  RLCF   x3C,W
08D8E:  CLRF   03
08D90:  ADDLW  62
08D92:  MOVWF  FE9
08D94:  MOVLW  07
08D96:  ADDWFC 03,W
08D98:  MOVWF  FEA
08D9A:  CLRF   FEC
08D9C:  MOVF   FED,F
08D9E:  MOVLW  05
08DA0:  MOVWF  FEF
08DA2:  MOVLB  8
....................    } 
08DA4:  MOVLB  0
08DA6:  GOTO   8F24 (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08F22:  BRA    8C4A
....................     
....................    m_comp[motor]=FALSE; 
08F24:  BCF    FD8.0
08F26:  MOVLB  7
08F28:  RLCF   x3C,W
08F2A:  CLRF   03
08F2C:  ADDLW  AB
08F2E:  MOVWF  FE9
08F30:  MOVLW  07
08F32:  ADDWFC 03,W
08F34:  MOVWF  FEA
08F36:  CLRF   FEC
08F38:  MOVF   FED,F
08F3A:  CLRF   FEF
....................     
....................    switch (motor){ 
08F3C:  MOVF   x3C,W
08F3E:  XORLW  00
08F40:  MOVLB  0
08F42:  BZ    8F4A
08F44:  XORLW  01
08F46:  BZ    8F5C
08F48:  BRA    8F6C
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08F4A:  MOVLW  B2
08F4C:  MOVLB  8
08F4E:  MOVWF  xD8
08F50:  CLRF   xDA
08F52:  CLRF   xD9
08F54:  MOVLB  0
08F56:  CALL   502C
....................          break; 
08F5A:  BRA    8F6C
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08F5C:  MOVLW  B4
08F5E:  MOVLB  8
08F60:  MOVWF  xD8
08F62:  CLRF   xDA
08F64:  CLRF   xD9
08F66:  MOVLB  0
08F68:  CALL   502C
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08F6C:  MOVLB  7
08F6E:  MOVF   x3C,W
08F70:  XORLW  00
08F72:  MOVLB  0
08F74:  BZ    8F7C
08F76:  XORLW  01
08F78:  BZ    8F80
08F7A:  BRA    8F82
....................       case 0 : output_bit(M1_ENABLE, ON); 
08F7C:  BSF    F90.1
....................          break; 
08F7E:  BRA    8F82
....................       case 1 : output_bit(M2_ENABLE, ON); 
08F80:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08F82:  MOVLW  32
08F84:  MOVLB  9
08F86:  MOVWF  xD6
08F88:  MOVLB  0
08F8A:  CALL   2972
....................     
....................    set_timer3(STEP_INTERVAL); 
08F8E:  MOVLW  F9
08F90:  MOVWF  FB3
08F92:  MOVLW  C0
08F94:  MOVWF  FB2
....................    enc_isr(int_mode); 
08F96:  MOVFF  8C1,8D6
08F9A:  RCALL  8E5A
....................    clear_interrupt(INT_TIMER3); 
08F9C:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08F9E:  BCF    FD8.0
08FA0:  MOVLB  7
08FA2:  RLCF   x3C,W
08FA4:  CLRF   03
08FA6:  ADDLW  8E
08FA8:  MOVWF  FE9
08FAA:  MOVLW  07
08FAC:  ADDWFC 03,W
08FAE:  MOVWF  FEA
08FB0:  CLRF   FEC
08FB2:  MOVF   FED,F
08FB4:  MOVLW  01
08FB6:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08FB8:  BSF    FA0.1
08FBA:  MOVLB  0
08FBC:  GOTO   A234 (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
08646:  MOVFF  8C4,8CC
0864A:  MOVFF  8C3,8CB
0864E:  MOVFF  8C2,8CA
08652:  MOVFF  8C1,8C9
....................    enc_res    = e_cpr[motor]; 
08656:  BCF    FD8.0
08658:  MOVLB  7
0865A:  RLCF   x3C,W
0865C:  CLRF   03
0865E:  ADDLW  5A
08660:  MOVWF  FE9
08662:  MOVLW  07
08664:  ADDWFC 03,W
08666:  MOVWF  FEA
08668:  MOVLB  8
0866A:  CLRF   xD0
0866C:  CLRF   xCF
0866E:  MOVFF  FEC,8CE
08672:  MOVF   FED,F
08674:  MOVFF  FEF,8CD
....................    ports      = e_ppr[motor]; 
08678:  BCF    FD8.0
0867A:  MOVLB  7
0867C:  RLCF   x3C,W
0867E:  CLRF   03
08680:  ADDLW  5E
08682:  MOVWF  FE9
08684:  MOVLW  07
08686:  ADDWFC 03,W
08688:  MOVWF  FEA
0868A:  MOVLB  8
0868C:  CLRF   xD8
0868E:  CLRF   xD7
08690:  MOVFF  FEC,8D6
08694:  MOVF   FED,F
08696:  MOVFF  FEF,8D5
....................     
....................    enc_res = enc_res * 1000; 
0869A:  MOVFF  8D0,9E3
0869E:  MOVFF  8CF,9E2
086A2:  MOVFF  8CE,9E1
086A6:  MOVFF  8CD,9E0
086AA:  MOVLB  9
086AC:  CLRF   xE7
086AE:  CLRF   xE6
086B0:  MOVLW  03
086B2:  MOVWF  xE5
086B4:  MOVLW  E8
086B6:  MOVWF  xE4
086B8:  MOVLB  0
086BA:  CALL   4852
086BE:  MOVFF  03,8D0
086C2:  MOVFF  02,8CF
086C6:  MOVFF  01,8CE
086CA:  MOVFF  00,8CD
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
086CE:  BCF    FD8.1
086D0:  CLRF   1B
086D2:  BTFSC  FF2.7
086D4:  BSF    1B.7
086D6:  BCF    FF2.7
086D8:  MOVFF  8D0,A34
086DC:  MOVFF  8CF,A33
086E0:  MOVFF  8CE,A32
086E4:  MOVFF  8CD,A31
086E8:  MOVFF  8D8,A38
086EC:  MOVFF  8D7,A37
086F0:  MOVFF  8D6,A36
086F4:  MOVFF  8D5,A35
086F8:  CALL   1050
086FC:  BTFSC  1B.7
086FE:  BSF    FF2.7
08700:  MOVFF  03,8C8
08704:  MOVFF  02,8C7
08708:  MOVFF  01,8C6
0870C:  MOVFF  00,8C5
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
08710:  MOVFF  8C4,9E3
08714:  MOVFF  8C3,9E2
08718:  MOVFF  8C2,9E1
0871C:  MOVFF  8C1,9E0
08720:  MOVFF  8C8,9E7
08724:  MOVFF  8C7,9E6
08728:  MOVFF  8C6,9E5
0872C:  MOVFF  8C5,9E4
08730:  CALL   4852
08734:  MOVLB  8
08736:  MOVF   xC5,W
08738:  SUBWF  00,W
0873A:  MOVWF  xC9
0873C:  MOVF   xC6,W
0873E:  SUBWFB 01,W
08740:  MOVWF  xCA
08742:  MOVF   xC7,W
08744:  SUBWFB 02,W
08746:  MOVWF  xCB
08748:  MOVF   xC8,W
0874A:  SUBWFB 03,W
0874C:  MOVWF  xCC
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
0874E:  BCF    FD8.1
08750:  CLRF   1B
08752:  BTFSC  FF2.7
08754:  BSF    1B.7
08756:  BCF    FF2.7
08758:  MOVFF  8CC,A34
0875C:  MOVFF  8CB,A33
08760:  MOVFF  8CA,A32
08764:  MOVFF  8C9,A31
08768:  MOVLB  A
0876A:  CLRF   x38
0876C:  CLRF   x37
0876E:  MOVLW  03
08770:  MOVWF  x36
08772:  MOVLW  E8
08774:  MOVWF  x35
08776:  MOVLB  0
08778:  CALL   1050
0877C:  BTFSC  1B.7
0877E:  BSF    FF2.7
08780:  MOVFF  03,8D4
08784:  MOVFF  02,8D3
08788:  MOVFF  01,8D2
0878C:  MOVFF  00,8D1
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
08790:  MOVFF  8D4,9E3
08794:  MOVFF  8D3,9E2
08798:  MOVFF  8D2,9E1
0879C:  MOVFF  8D1,9E0
087A0:  MOVLB  9
087A2:  CLRF   xE7
087A4:  CLRF   xE6
087A6:  MOVLW  03
087A8:  MOVWF  xE5
087AA:  MOVLW  E8
087AC:  MOVWF  xE4
087AE:  MOVLB  0
087B0:  CALL   4852
087B4:  MOVFF  03,8D4
087B8:  MOVFF  02,8D3
087BC:  MOVFF  01,8D2
087C0:  MOVFF  00,8D1
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
087C4:  MOVLB  8
087C6:  MOVF   xD1,W
087C8:  SUBWF  xC9,F
087CA:  MOVF   xD2,W
087CC:  SUBWFB xCA,F
087CE:  MOVF   xD3,W
087D0:  SUBWFB xCB,F
087D2:  MOVF   xD4,W
087D4:  SUBWFB xCC,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
087D6:  BCF    FD8.1
087D8:  CLRF   1B
087DA:  BTFSC  FF2.7
087DC:  BSF    1B.7
087DE:  BCF    FF2.7
087E0:  MOVFF  8D4,A34
087E4:  MOVFF  8D3,A33
087E8:  MOVFF  8D2,A32
087EC:  MOVFF  8D1,A31
087F0:  MOVLB  A
087F2:  CLRF   x38
087F4:  CLRF   x37
087F6:  MOVLW  03
087F8:  MOVWF  x36
087FA:  MOVLW  E8
087FC:  MOVWF  x35
087FE:  MOVLB  0
08800:  CALL   1050
08804:  BTFSC  1B.7
08806:  BSF    FF2.7
08808:  MOVFF  03,8D4
0880C:  MOVFF  02,8D3
08810:  MOVFF  01,8D2
08814:  MOVFF  00,8D1
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
08818:  MOVLB  8
0881A:  MOVF   xCC,F
0881C:  BNZ   8832
0881E:  MOVF   xCB,F
08820:  BNZ   8832
08822:  MOVF   xCA,W
08824:  SUBLW  00
08826:  BC    8842
08828:  XORLW  FF
0882A:  BNZ   8832
0882C:  MOVF   xC9,W
0882E:  SUBLW  F3
08830:  BC    8842
08832:  MOVLW  01
08834:  ADDWF  xD1,F
08836:  BTFSC  FD8.0
08838:  INCF   xD2,F
0883A:  BTFSC  FD8.2
0883C:  INCF   xD3,F
0883E:  BTFSC  FD8.2
08840:  INCF   xD4,F
....................    return(enc_pos); 
08842:  MOVFF  8D1,00
08846:  MOVFF  8D2,01
0884A:  MOVFF  8D3,02
0884E:  MOVFF  8D4,03
08852:  MOVLB  0
08854:  GOTO   A1BC (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
08858:  BCF    FD8.0
0885A:  MOVLB  7
0885C:  RLCF   x3C,W
0885E:  CLRF   03
08860:  ADDLW  BB
08862:  MOVWF  FE9
08864:  MOVLW  07
08866:  ADDWFC 03,W
08868:  MOVWF  FEA
0886A:  MOVFF  FEC,03
0886E:  MOVF   FED,F
08870:  MOVFF  FEF,01
08874:  MOVF   03,W
08876:  MOVLB  8
08878:  SUBWF  xC4,W
0887A:  BNC   8942
0887C:  BNZ   8884
0887E:  MOVF   xC3,W
08880:  SUBWF  01,W
08882:  BC    8942
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
08884:  BCF    FD8.0
08886:  MOVLB  7
08888:  RLCF   x3C,W
0888A:  CLRF   03
0888C:  ADDLW  BB
0888E:  MOVWF  FE9
08890:  MOVLW  07
08892:  ADDWFC 03,W
08894:  MOVWF  FEA
08896:  MOVFF  FEC,03
0889A:  MOVF   FED,F
0889C:  MOVF   FEF,W
0889E:  MOVLB  8
088A0:  SUBWF  xC3,W
088A2:  MOVWF  xC5
088A4:  MOVF   03,W
088A6:  SUBWFB xC4,W
088A8:  MOVWF  xC6
....................       if (e_pos_r > (e_cpr[motor]/2)) 
088AA:  BCF    FD8.0
088AC:  MOVLB  7
088AE:  RLCF   x3C,W
088B0:  CLRF   03
088B2:  ADDLW  5A
088B4:  MOVWF  FE9
088B6:  MOVLW  07
088B8:  ADDWFC 03,W
088BA:  MOVWF  FEA
088BC:  MOVFF  FEC,8C8
088C0:  MOVF   FED,F
088C2:  MOVFF  FEF,8C7
088C6:  BCF    FD8.0
088C8:  MOVLB  8
088CA:  RRCF   xC8,W
088CC:  MOVWF  03
088CE:  RRCF   xC7,W
088D0:  MOVWF  02
088D2:  MOVWF  01
088D4:  MOVF   03,W
088D6:  SUBWF  xC6,W
088D8:  BNC   8926
088DA:  BNZ   88E2
088DC:  MOVF   xC5,W
088DE:  SUBWF  01,W
088E0:  BC    8926
....................       { 
....................          m_way[motor] = NEG; 
088E2:  BCF    FD8.0
088E4:  MOVLB  7
088E6:  RLCF   x3C,W
088E8:  CLRF   03
088EA:  ADDLW  82
088EC:  MOVWF  FE9
088EE:  MOVLW  07
088F0:  ADDWFC 03,W
088F2:  MOVWF  FEA
088F4:  CLRF   FEC
088F6:  MOVF   FED,F
088F8:  MOVLW  01
088FA:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088FC:  BCF    FD8.0
088FE:  RLCF   x3C,W
08900:  CLRF   03
08902:  ADDLW  5A
08904:  MOVWF  FE9
08906:  MOVLW  07
08908:  ADDWFC 03,W
0890A:  MOVWF  FEA
0890C:  MOVFF  FEC,8C8
08910:  MOVF   FED,F
08912:  MOVFF  FEF,8C7
08916:  MOVLB  8
08918:  MOVF   xC5,W
0891A:  SUBWF  xC7,W
0891C:  MOVWF  xC5
0891E:  MOVF   xC6,W
08920:  SUBWFB xC8,W
08922:  MOVWF  xC6
....................       } 
08924:  BRA    8940
....................       else 
....................       { 
....................          m_way[motor] = POS; 
08926:  BCF    FD8.0
08928:  MOVLB  7
0892A:  RLCF   x3C,W
0892C:  CLRF   03
0892E:  ADDLW  82
08930:  MOVWF  FE9
08932:  MOVLW  07
08934:  ADDWFC 03,W
08936:  MOVWF  FEA
08938:  CLRF   FEC
0893A:  MOVF   FED,F
0893C:  CLRF   FEF
0893E:  MOVLB  8
....................       } 
....................    } 
08940:  BRA    8A02
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
08942:  BCF    FD8.0
08944:  MOVLB  7
08946:  RLCF   x3C,W
08948:  CLRF   03
0894A:  ADDLW  BB
0894C:  MOVWF  FE9
0894E:  MOVLW  07
08950:  ADDWFC 03,W
08952:  MOVWF  FEA
08954:  MOVFF  FEC,8C8
08958:  MOVF   FED,F
0895A:  MOVFF  FEF,8C7
0895E:  MOVLB  8
08960:  MOVF   xC3,W
08962:  SUBWF  xC7,W
08964:  MOVWF  xC5
08966:  MOVF   xC4,W
08968:  SUBWFB xC8,W
0896A:  MOVWF  xC6
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0896C:  BCF    FD8.0
0896E:  MOVLB  7
08970:  RLCF   x3C,W
08972:  CLRF   03
08974:  ADDLW  5A
08976:  MOVWF  FE9
08978:  MOVLW  07
0897A:  ADDWFC 03,W
0897C:  MOVWF  FEA
0897E:  MOVFF  FEC,8C8
08982:  MOVF   FED,F
08984:  MOVFF  FEF,8C7
08988:  BCF    FD8.0
0898A:  MOVLB  8
0898C:  RRCF   xC8,W
0898E:  MOVWF  03
08990:  RRCF   xC7,W
08992:  MOVWF  02
08994:  MOVWF  01
08996:  MOVF   03,W
08998:  SUBWF  xC6,W
0899A:  BNC   89E6
0899C:  BNZ   89A4
0899E:  MOVF   xC5,W
089A0:  SUBWF  01,W
089A2:  BC    89E6
....................       { 
....................          m_way[motor] = POS; 
089A4:  BCF    FD8.0
089A6:  MOVLB  7
089A8:  RLCF   x3C,W
089AA:  CLRF   03
089AC:  ADDLW  82
089AE:  MOVWF  FE9
089B0:  MOVLW  07
089B2:  ADDWFC 03,W
089B4:  MOVWF  FEA
089B6:  CLRF   FEC
089B8:  MOVF   FED,F
089BA:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
089BC:  BCF    FD8.0
089BE:  RLCF   x3C,W
089C0:  CLRF   03
089C2:  ADDLW  5A
089C4:  MOVWF  FE9
089C6:  MOVLW  07
089C8:  ADDWFC 03,W
089CA:  MOVWF  FEA
089CC:  MOVFF  FEC,8C8
089D0:  MOVF   FED,F
089D2:  MOVFF  FEF,8C7
089D6:  MOVLB  8
089D8:  MOVF   xC5,W
089DA:  SUBWF  xC7,W
089DC:  MOVWF  xC5
089DE:  MOVF   xC6,W
089E0:  SUBWFB xC8,W
089E2:  MOVWF  xC6
....................       } 
089E4:  BRA    8A02
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
089E6:  BCF    FD8.0
089E8:  MOVLB  7
089EA:  RLCF   x3C,W
089EC:  CLRF   03
089EE:  ADDLW  82
089F0:  MOVWF  FE9
089F2:  MOVLW  07
089F4:  ADDWFC 03,W
089F6:  MOVWF  FEA
089F8:  CLRF   FEC
089FA:  MOVF   FED,F
089FC:  MOVLW  01
089FE:  MOVWF  FEF
08A00:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
08A02:  MOVFF  8C5,01
08A06:  MOVFF  8C6,02
08A0A:  MOVLB  0
08A0C:  GOTO   A1E8 (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
09110:  BCF    FD8.0
09112:  MOVLB  7
09114:  RLCF   x3C,W
09116:  CLRF   03
09118:  ADDLW  8E
0911A:  MOVWF  FE9
0911C:  MOVLW  07
0911E:  ADDWFC 03,W
09120:  MOVWF  FEA
09122:  CLRF   FEC
09124:  MOVF   FED,F
09126:  CLRF   FEF
....................           
....................    switch (motor){ 
09128:  MOVF   x3C,W
0912A:  XORLW  00
0912C:  MOVLB  0
0912E:  BZ    9136
09130:  XORLW  01
09132:  BZ    91A0
09134:  BRA    920E
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
09136:  BCF    FD8.0
09138:  MOVLB  7
0913A:  RLCF   x3C,W
0913C:  CLRF   03
0913E:  ADDLW  4E
09140:  MOVWF  FE9
09142:  MOVLW  07
09144:  ADDWFC 03,W
09146:  MOVWF  FEA
09148:  MOVFF  FEC,8D7
0914C:  MOVF   FED,F
0914E:  MOVFF  FEF,8D6
09152:  MOVLB  8
09154:  MOVF   xD6,F
09156:  BNZ   915C
09158:  MOVF   xD7,F
0915A:  BZ    919A
0915C:  BCF    FD8.0
0915E:  MOVLB  7
09160:  RLCF   x3C,W
09162:  CLRF   03
09164:  ADDLW  4E
09166:  MOVWF  FE9
09168:  MOVLW  07
0916A:  ADDWFC 03,W
0916C:  MOVWF  FEA
0916E:  MOVFF  FEC,8D7
09172:  MOVF   FED,F
09174:  MOVFF  FEF,8D6
09178:  MOVLB  8
0917A:  RRCF   xD7,F
0917C:  RRCF   xD6,F
0917E:  RRCF   xD7,F
09180:  RRCF   xD6,F
09182:  RRCF   xD7,F
09184:  MOVFF  8D6,FBC
09188:  RRCF   xD7,F
0918A:  RRCF   xD7,W
0918C:  ANDLW  30
0918E:  MOVWF  00
09190:  MOVF   FBB,W
09192:  ANDLW  CF
09194:  IORWF  00,W
09196:  MOVWF  FBB
09198:  BRA    919C
....................                else output_bit(M1_ENABLE, OFF); 
0919A:  BCF    F90.1
....................          break;   
0919C:  MOVLB  0
0919E:  BRA    920E
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
091A0:  BCF    FD8.0
091A2:  MOVLB  7
091A4:  RLCF   x3C,W
091A6:  CLRF   03
091A8:  ADDLW  4E
091AA:  MOVWF  FE9
091AC:  MOVLW  07
091AE:  ADDWFC 03,W
091B0:  MOVWF  FEA
091B2:  MOVFF  FEC,8D7
091B6:  MOVF   FED,F
091B8:  MOVFF  FEF,8D6
091BC:  MOVLB  8
091BE:  MOVF   xD6,F
091C0:  BNZ   91C6
091C2:  MOVF   xD7,F
091C4:  BZ    9208
091C6:  BCF    FD8.0
091C8:  MOVLB  7
091CA:  RLCF   x3C,W
091CC:  CLRF   03
091CE:  ADDLW  4E
091D0:  MOVWF  FE9
091D2:  MOVLW  07
091D4:  ADDWFC 03,W
091D6:  MOVWF  FEA
091D8:  MOVFF  FEC,8D7
091DC:  MOVF   FED,F
091DE:  MOVFF  FEF,8D6
091E2:  MOVLB  8
091E4:  RRCF   xD7,F
091E6:  RRCF   xD6,F
091E8:  RRCF   xD7,F
091EA:  RRCF   xD6,F
091EC:  RRCF   xD7,F
091EE:  MOVFF  8D6,F4F
091F2:  RRCF   xD7,F
091F4:  RRCF   xD7,W
091F6:  ANDLW  30
091F8:  MOVWF  00
091FA:  MOVLB  F
091FC:  MOVF   x4E,W
091FE:  ANDLW  CF
09200:  IORWF  00,W
09202:  MOVWF  x4E
09204:  BRA    920C
09206:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
09208:  BCF    F8D.1
0920A:  MOVLB  F
....................          break; 
0920C:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
0920E:  BCF    FA0.1
....................    enc_isr(OFF); 
09210:  MOVLB  8
09212:  CLRF   xD6
09214:  MOVLB  0
09216:  RCALL  8E5A
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
09218:  MOVLB  7
0921A:  MOVF   x4E,F
0921C:  BNZ   922C
0921E:  MOVF   x4F,F
09220:  BNZ   922C
09222:  MOVF   x50,F
09224:  BNZ   922C
09226:  MOVF   x51,F
09228:  BNZ   922C
....................    { 
....................       output_bit(VMOT,OFF); 
0922A:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
0922C:  MOVLB  8
0922E:  CLRF   xD6
09230:  MOVLB  0
09232:  CALL   8A10
....................  
....................    if(success==TRUE) 
09236:  MOVLB  8
09238:  DECFSZ xD5,W
0923A:  BRA    93D6
....................    { 
....................       m_error[motor]=FALSE; 
0923C:  BCF    FD8.0
0923E:  MOVLB  7
09240:  RLCF   x3C,W
09242:  CLRF   03
09244:  ADDLW  92
09246:  MOVWF  FE9
09248:  MOVLW  07
0924A:  ADDWFC 03,W
0924C:  MOVWF  FEA
0924E:  CLRF   FEC
09250:  MOVF   FED,F
09252:  CLRF   FEF
....................       wrt_m_error(); 
09254:  MOVLB  0
09256:  RCALL  8FC0
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
09258:  BCF    FD8.0
0925A:  MOVLB  7
0925C:  RLCF   x3C,W
0925E:  CLRF   03
09260:  ADDLW  62
09262:  MOVWF  FE9
09264:  MOVLW  07
09266:  ADDWFC 03,W
09268:  MOVWF  FEA
0926A:  MOVFF  FEC,8D7
0926E:  MOVF   FED,F
09270:  MOVFF  FEF,8D6
09274:  MOVLB  8
09276:  MOVF   xD6,W
09278:  SUBLW  03
0927A:  BNZ   92B2
0927C:  MOVF   xD7,F
0927E:  BNZ   92B2
....................       { 
....................          e_pos[motor] = 0; 
09280:  BCF    FD8.0
09282:  MOVLB  7
09284:  RLCF   x3C,W
09286:  CLRF   03
09288:  ADDLW  BB
0928A:  MOVWF  FE9
0928C:  MOVLW  07
0928E:  ADDWFC 03,W
09290:  MOVWF  FEA
09292:  CLRF   FEC
09294:  MOVF   FED,F
09296:  CLRF   FEF
....................          e_port[motor] = 1; 
09298:  BCF    FD8.0
0929A:  RLCF   x3C,W
0929C:  CLRF   03
0929E:  ADDLW  BF
092A0:  MOVWF  FE9
092A2:  MOVLW  07
092A4:  ADDWFC 03,W
092A6:  MOVWF  FEA
092A8:  CLRF   FEC
092AA:  MOVF   FED,F
092AC:  MOVLW  01
092AE:  MOVWF  FEF
092B0:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
092B2:  BCF    FD8.0
092B4:  MOVLB  7
092B6:  RLCF   x3C,W
092B8:  CLRF   03
092BA:  ADDLW  62
092BC:  MOVWF  FE9
092BE:  MOVLW  07
092C0:  ADDWFC 03,W
092C2:  MOVWF  FEA
092C4:  MOVFF  FEC,8D7
092C8:  MOVF   FED,F
092CA:  MOVFF  FEF,8D6
092CE:  MOVLB  8
092D0:  MOVF   xD6,W
092D2:  SUBLW  02
092D4:  BNZ   9320
092D6:  MOVF   xD7,F
092D8:  BNZ   9320
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
092DA:  BCF    FD8.0
092DC:  MOVLB  7
092DE:  RLCF   x3C,W
092E0:  CLRF   03
092E2:  ADDLW  BF
092E4:  MOVWF  01
092E6:  MOVLW  07
092E8:  ADDWFC 03,F
092EA:  MOVLB  8
092EC:  MOVFF  03,8D7
092F0:  BCF    FD8.0
092F2:  MOVLB  7
092F4:  RLCF   x3C,W
092F6:  CLRF   03
092F8:  ADDLW  C3
092FA:  MOVWF  FE9
092FC:  MOVLW  07
092FE:  ADDWFC 03,W
09300:  MOVWF  FEA
09302:  MOVFF  FEC,03
09306:  MOVF   FED,F
09308:  MOVFF  FEF,8D8
0930C:  MOVLB  8
0930E:  MOVFF  8D7,FEA
09312:  MOVFF  01,FE9
09316:  MOVFF  03,FEC
0931A:  MOVF   FED,F
0931C:  MOVFF  8D8,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
09320:  BCF    FD8.0
09322:  MOVLB  7
09324:  RLCF   x3C,W
09326:  CLRF   03
09328:  ADDLW  62
0932A:  MOVWF  FE9
0932C:  MOVLW  07
0932E:  ADDWFC 03,W
09330:  MOVWF  FEA
09332:  MOVFF  FEC,8D7
09336:  MOVF   FED,F
09338:  MOVFF  FEF,8D6
0933C:  MOVLB  8
0933E:  MOVF   xD6,W
09340:  SUBLW  02
09342:  BNZ   9348
09344:  MOVF   xD7,F
09346:  BZ    9370
09348:  BCF    FD8.0
0934A:  MOVLB  7
0934C:  RLCF   x3C,W
0934E:  CLRF   03
09350:  ADDLW  62
09352:  MOVWF  FE9
09354:  MOVLW  07
09356:  ADDWFC 03,W
09358:  MOVWF  FEA
0935A:  MOVFF  FEC,8D7
0935E:  MOVF   FED,F
09360:  MOVFF  FEF,8D6
09364:  MOVLB  8
09366:  MOVF   xD6,W
09368:  SUBLW  03
0936A:  BNZ   93D4
0936C:  MOVF   xD7,F
0936E:  BNZ   93D4
....................       { 
....................          switch(motor) 
09370:  MOVLB  7
09372:  MOVF   x3C,W
09374:  XORLW  00
09376:  MOVLB  0
09378:  BZ    9380
0937A:  XORLW  01
0937C:  BZ    93AA
0937E:  BRA    93D2
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09380:  MOVLW  7E
09382:  MOVLB  8
09384:  MOVWF  xD8
09386:  MOVFF  7BC,8DA
0938A:  MOVFF  7BB,8D9
0938E:  MOVLB  0
09390:  CALL   502C
....................                      write16(ADDR_E1_PORT,e_port[0]); 
09394:  MOVLW  AA
09396:  MOVLB  8
09398:  MOVWF  xD8
0939A:  MOVFF  7C0,8DA
0939E:  MOVFF  7BF,8D9
093A2:  MOVLB  0
093A4:  CALL   502C
....................                break; 
093A8:  BRA    93D2
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
093AA:  MOVLW  80
093AC:  MOVLB  8
093AE:  MOVWF  xD8
093B0:  MOVFF  7BE,8DA
093B4:  MOVFF  7BD,8D9
093B8:  MOVLB  0
093BA:  CALL   502C
....................                      write16(ADDR_E2_PORT,e_port[1]); 
093BE:  MOVLW  AC
093C0:  MOVLB  8
093C2:  MOVWF  xD8
093C4:  MOVFF  7C2,8DA
093C8:  MOVFF  7C1,8D9
093CC:  MOVLB  0
093CE:  CALL   502C
....................                break;             
093D2:  MOVLB  8
....................          } 
....................       } 
....................    } 
093D4:  BRA    947E
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
093D6:  BCF    FD8.0
093D8:  MOVLB  7
093DA:  RLCF   x3C,W
093DC:  CLRF   03
093DE:  ADDLW  92
093E0:  MOVWF  FE9
093E2:  MOVLW  07
093E4:  ADDWFC 03,W
093E6:  MOVWF  FEA
093E8:  CLRF   FEC
093EA:  MOVF   FED,F
093EC:  MOVLW  01
093EE:  MOVWF  FEF
....................       e_pos[motor] = 0; 
093F0:  BCF    FD8.0
093F2:  RLCF   x3C,W
093F4:  CLRF   03
093F6:  ADDLW  BB
093F8:  MOVWF  FE9
093FA:  MOVLW  07
093FC:  ADDWFC 03,W
093FE:  MOVWF  FEA
09400:  CLRF   FEC
09402:  MOVF   FED,F
09404:  CLRF   FEF
....................       e_port[motor] = 0; 
09406:  BCF    FD8.0
09408:  RLCF   x3C,W
0940A:  CLRF   03
0940C:  ADDLW  BF
0940E:  MOVWF  FE9
09410:  MOVLW  07
09412:  ADDWFC 03,W
09414:  MOVWF  FEA
09416:  CLRF   FEC
09418:  MOVF   FED,F
0941A:  CLRF   FEF
....................       switch(motor) 
0941C:  MOVF   x3C,W
0941E:  XORLW  00
09420:  MOVLB  0
09422:  BZ    942A
09424:  XORLW  01
09426:  BZ    9454
09428:  BRA    947C
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
0942A:  MOVLW  7E
0942C:  MOVLB  8
0942E:  MOVWF  xD8
09430:  MOVFF  7BC,8DA
09434:  MOVFF  7BB,8D9
09438:  MOVLB  0
0943A:  CALL   502C
....................                   write16(ADDR_E1_PORT,e_port[0]); 
0943E:  MOVLW  AA
09440:  MOVLB  8
09442:  MOVWF  xD8
09444:  MOVFF  7C0,8DA
09448:  MOVFF  7BF,8D9
0944C:  MOVLB  0
0944E:  CALL   502C
....................             break; 
09452:  BRA    947C
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
09454:  MOVLW  80
09456:  MOVLB  8
09458:  MOVWF  xD8
0945A:  MOVFF  7BE,8DA
0945E:  MOVFF  7BD,8D9
09462:  MOVLB  0
09464:  CALL   502C
....................                   write16(ADDR_E2_PORT,e_port[1]); 
09468:  MOVLW  AC
0946A:  MOVLB  8
0946C:  MOVWF  xD8
0946E:  MOVFF  7C2,8DA
09472:  MOVFF  7C1,8D9
09476:  MOVLB  0
09478:  CALL   502C
....................             break;             
0947C:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
0947E:  BCF    FD8.0
09480:  MOVLB  7
09482:  RLCF   x3C,W
09484:  CLRF   03
09486:  ADDLW  AB
09488:  MOVWF  FE9
0948A:  MOVLW  07
0948C:  ADDWFC 03,W
0948E:  MOVWF  FEA
09490:  CLRF   FEC
09492:  MOVF   FED,F
09494:  MOVLW  01
09496:  MOVWF  FEF
....................     
....................    switch (motor) 
09498:  MOVF   x3C,W
0949A:  XORLW  00
0949C:  MOVLB  0
0949E:  BZ    94A6
094A0:  XORLW  01
094A2:  BZ    94CE
094A4:  BRA    94F4
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
094A6:  MOVLW  B2
094A8:  MOVLB  8
094AA:  MOVWF  xD8
094AC:  CLRF   xDA
094AE:  MOVLW  01
094B0:  MOVWF  xD9
094B2:  MOVLB  0
094B4:  CALL   502C
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
094B8:  MOVLW  B6
094BA:  MOVLB  8
094BC:  MOVWF  xD8
094BE:  MOVFF  7B0,8DA
094C2:  MOVFF  7AF,8D9
094C6:  MOVLB  0
094C8:  CALL   502C
....................          break; 
094CC:  BRA    94F4
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
094CE:  MOVLW  B4
094D0:  MOVLB  8
094D2:  MOVWF  xD8
094D4:  CLRF   xDA
094D6:  MOVLW  01
094D8:  MOVWF  xD9
094DA:  MOVLB  0
094DC:  CALL   502C
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
094E0:  MOVLW  B8
094E2:  MOVLB  8
094E4:  MOVWF  xD8
094E6:  MOVFF  7B2,8DA
094EA:  MOVFF  7B1,8D9
094EE:  MOVLB  0
094F0:  CALL   502C
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
094F4:  MOVF   1F,W
094F6:  SUBLW  04
094F8:  BNZ   959E
094FA:  MOVF   20,F
094FC:  BNZ   959E
....................    { 
....................       if(motor==1) 
094FE:  MOVLB  7
09500:  DECFSZ x3C,W
09502:  BRA    95A0
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
09504:  BCF    FD8.0
09506:  RLCF   x3C,W
09508:  CLRF   03
0950A:  ADDLW  AB
0950C:  MOVWF  FE9
0950E:  MOVLW  07
09510:  ADDWFC 03,W
09512:  MOVWF  FEA
09514:  MOVFF  FEC,8D7
09518:  MOVF   FED,F
0951A:  MOVFF  FEF,8D6
0951E:  BCF    FD8.0
09520:  RLCF   x3C,W
09522:  CLRF   03
09524:  ADDLW  AF
09526:  MOVWF  FE9
09528:  MOVLW  07
0952A:  ADDWFC 03,W
0952C:  MOVWF  FEA
0952E:  MOVFF  FEC,8D9
09532:  MOVF   FED,F
09534:  MOVFF  FEF,8D8
09538:  MOVLW  58
0953A:  MOVWF  FF6
0953C:  MOVLW  1A
0953E:  MOVWF  FF7
09540:  MOVLW  00
09542:  MOVWF  FF8
09544:  CLRF   1B
09546:  BTFSC  FF2.7
09548:  BSF    1B.7
0954A:  BCF    FF2.7
0954C:  MOVLW  05
0954E:  MOVLB  A
09550:  MOVWF  x25
09552:  MOVLB  0
09554:  CALL   101E
09558:  BTFSC  1B.7
0955A:  BSF    FF2.7
0955C:  MOVLW  10
0955E:  MOVWF  FE9
09560:  CLRF   1B
09562:  BTFSC  FF2.7
09564:  BSF    1B.7
09566:  BCF    FF2.7
09568:  MOVFF  8D7,A26
0956C:  MOVFF  8D6,A25
09570:  CALL   11A0
09574:  BTFSC  1B.7
09576:  BSF    FF2.7
09578:  MOVLW  2C
0957A:  BTFSS  F9E.4
0957C:  BRA    957A
0957E:  MOVWF  FAD
09580:  MOVLW  10
09582:  MOVWF  FE9
09584:  MOVFF  8D9,8DB
09588:  MOVFF  8D8,8DA
0958C:  RCALL  9024
0958E:  MOVLW  0D
09590:  BTFSS  F9E.4
09592:  BRA    9590
09594:  MOVWF  FAD
09596:  MOVLW  0A
09598:  BTFSS  F9E.4
0959A:  BRA    9598
0959C:  MOVWF  FAD
0959E:  MOVLB  7
....................       } 
....................    } 
095A0:  MOVLB  0
095A2:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
096D0:  BCF    FD8.0
096D2:  MOVLB  7
096D4:  RLCF   x3C,W
096D6:  CLRF   03
096D8:  ADDLW  66
096DA:  MOVWF  FE9
096DC:  MOVLW  07
096DE:  ADDWFC 03,W
096E0:  MOVWF  FEA
096E2:  MOVFF  FEC,8D6
096E6:  MOVF   FED,F
096E8:  MOVFF  FEF,8D5
096EC:  MOVLB  8
096EE:  DECFSZ xD5,W
096F0:  BRA    9700
096F2:  MOVF   xD6,F
096F4:  BNZ   9700
096F6:  MOVLW  01
096F8:  MOVWF  xD5
096FA:  MOVLB  0
096FC:  RCALL  9110
096FE:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
09700:  BCF    FD8.0
09702:  MOVLB  7
09704:  RLCF   x3C,W
09706:  CLRF   03
09708:  ADDLW  66
0970A:  MOVWF  FE9
0970C:  MOVLW  07
0970E:  ADDWFC 03,W
09710:  MOVWF  FEA
09712:  MOVFF  FEC,8D6
09716:  MOVF   FED,F
09718:  MOVFF  FEF,8D5
0971C:  MOVLB  8
0971E:  MOVF   xD5,W
09720:  SUBLW  02
09722:  BTFSS  FD8.2
09724:  BRA    9D2E
09726:  MOVF   xD6,F
09728:  BTFSS  FD8.2
0972A:  BRA    9D2E
....................       if (e_mode[motor]==2){ 
0972C:  BCF    FD8.0
0972E:  MOVLB  7
09730:  RLCF   x3C,W
09732:  CLRF   03
09734:  ADDLW  62
09736:  MOVWF  FE9
09738:  MOVLW  07
0973A:  ADDWFC 03,W
0973C:  MOVWF  FEA
0973E:  MOVFF  FEC,8D6
09742:  MOVF   FED,F
09744:  MOVFF  FEF,8D5
09748:  MOVLB  8
0974A:  MOVF   xD5,W
0974C:  SUBLW  02
0974E:  BTFSS  FD8.2
09750:  BRA    9CAA
09752:  MOVF   xD6,F
09754:  BTFSS  FD8.2
09756:  BRA    9CAA
....................          if(nv_product==ECO || nv_product==WMS2){ 
09758:  MOVF   2F,F
0975A:  BNZ   9760
0975C:  MOVF   30,F
0975E:  BZ    976E
09760:  MOVF   2F,W
09762:  SUBLW  03
09764:  BTFSS  FD8.2
09766:  BRA    98B2
09768:  MOVF   30,F
0976A:  BTFSS  FD8.2
0976C:  BRA    98B2
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
0976E:  BCF    FD8.0
09770:  MOVLB  7
09772:  RLCF   x3C,W
09774:  CLRF   03
09776:  ADDLW  A7
09778:  MOVWF  FE9
0977A:  MOVLW  07
0977C:  ADDWFC 03,W
0977E:  MOVWF  FEA
09780:  MOVFF  FEC,9E1
09784:  MOVF   FED,F
09786:  MOVFF  FEF,9E0
0978A:  MOVFF  FEA,8D8
0978E:  MOVFF  FE9,8D7
09792:  MOVLB  9
09794:  CLRF   xE3
09796:  CLRF   xE2
09798:  MOVFF  8C6,9E7
0979C:  MOVFF  8C5,9E6
097A0:  MOVFF  8C4,9E5
097A4:  MOVFF  8C3,9E4
097A8:  MOVLB  0
097AA:  CALL   4852
097AE:  MOVFF  8D8,FEA
097B2:  MOVFF  8D7,FE9
097B6:  MOVFF  03,8D8
097BA:  MOVFF  02,8D7
097BE:  MOVFF  01,8D6
097C2:  MOVFF  00,8D5
097C6:  BCF    FD8.0
097C8:  MOVLB  7
097CA:  RLCF   x3C,W
097CC:  CLRF   03
097CE:  ADDLW  A7
097D0:  MOVWF  FE9
097D2:  MOVLW  07
097D4:  ADDWFC 03,W
097D6:  MOVWF  FEA
097D8:  MOVFF  FEC,8DA
097DC:  MOVF   FED,F
097DE:  MOVFF  FEF,8D9
097E2:  BCF    FD8.0
097E4:  MOVLB  8
097E6:  RRCF   xDA,W
097E8:  MOVWF  03
097EA:  RRCF   xD9,W
097EC:  MOVWF  02
097EE:  ADDWF  00,W
097F0:  MOVWF  00
097F2:  MOVF   03,W
097F4:  ADDWFC 01,W
097F6:  MOVWF  01
097F8:  MOVLW  00
097FA:  ADDWFC xD7,W
097FC:  MOVWF  02
097FE:  MOVLW  00
09800:  ADDWFC xD8,W
09802:  MOVWF  xD0
09804:  MOVFF  02,8CF
09808:  MOVFF  01,8CE
0980C:  MOVFF  00,8CD
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
09810:  BCF    FD8.0
09812:  MOVLB  7
09814:  RLCF   x3C,W
09816:  CLRF   03
09818:  ADDLW  A7
0981A:  MOVWF  FE9
0981C:  MOVLW  07
0981E:  ADDWFC 03,W
09820:  MOVWF  FEA
09822:  MOVFF  FEC,9E1
09826:  MOVF   FED,F
09828:  MOVFF  FEF,9E0
0982C:  MOVFF  FEA,8D8
09830:  MOVFF  FE9,8D7
09834:  MOVLB  9
09836:  CLRF   xE3
09838:  CLRF   xE2
0983A:  MOVFF  8C6,9E7
0983E:  MOVFF  8C5,9E6
09842:  MOVFF  8C4,9E5
09846:  MOVFF  8C3,9E4
0984A:  MOVLB  0
0984C:  CALL   4852
09850:  MOVFF  8D8,FEA
09854:  MOVFF  8D7,FE9
09858:  MOVFF  03,8D8
0985C:  MOVFF  02,8D7
09860:  MOVFF  01,8D6
09864:  MOVFF  00,8D5
09868:  BCF    FD8.0
0986A:  MOVLB  7
0986C:  RLCF   x3C,W
0986E:  CLRF   03
09870:  ADDLW  A7
09872:  MOVWF  FE9
09874:  MOVLW  07
09876:  ADDWFC 03,W
09878:  MOVWF  FEA
0987A:  MOVFF  FEC,8DA
0987E:  MOVF   FED,F
09880:  MOVFF  FEF,8D9
09884:  BCF    FD8.0
09886:  MOVLB  8
09888:  RRCF   xDA,W
0988A:  MOVWF  03
0988C:  RRCF   xD9,W
0988E:  MOVWF  02
09890:  SUBWF  00,W
09892:  MOVWF  00
09894:  MOVF   03,W
09896:  SUBWFB 01,W
09898:  MOVWF  01
0989A:  MOVLW  00
0989C:  SUBWFB xD7,W
0989E:  MOVWF  02
098A0:  MOVLW  00
098A2:  SUBWFB xD8,W
098A4:  MOVWF  xD4
098A6:  MOVFF  02,8D3
098AA:  MOVFF  01,8D2
098AE:  MOVFF  00,8D1
....................          } 
....................          if (nv_product==WMS4){ 
098B2:  DECFSZ 2F,W
098B4:  BRA    9ACC
098B6:  MOVF   30,F
098B8:  BTFSS  FD8.2
098BA:  BRA    9ACC
....................             if (end_even_port==FALSE){ 
098BC:  MOVLB  2
098BE:  MOVF   xD7,F
098C0:  BNZ   99B6
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
098C2:  BCF    FD8.0
098C4:  MOVLB  7
098C6:  RLCF   x3C,W
098C8:  CLRF   03
098CA:  ADDLW  A7
098CC:  MOVWF  FE9
098CE:  MOVLW  07
098D0:  ADDWFC 03,W
098D2:  MOVWF  FEA
098D4:  MOVFF  FEC,9F7
098D8:  MOVF   FED,F
098DA:  MOVFF  FEF,9F6
098DE:  MOVFF  8C8,9F9
098E2:  MOVFF  8C7,9F8
098E6:  MOVLB  0
098E8:  CALL   5D14
098EC:  MOVFF  02,8D6
098F0:  MOVFF  01,8D5
098F4:  BCF    FD8.0
098F6:  MOVLB  7
098F8:  RLCF   x3C,W
098FA:  CLRF   03
098FC:  ADDLW  A7
098FE:  MOVWF  FE9
09900:  MOVLW  07
09902:  ADDWFC 03,W
09904:  MOVWF  FEA
09906:  MOVFF  FEC,8D8
0990A:  MOVF   FED,F
0990C:  MOVFF  FEF,8D7
09910:  BCF    FD8.0
09912:  MOVLB  8
09914:  RRCF   xD8,W
09916:  MOVWF  03
09918:  RRCF   xD7,W
0991A:  MOVWF  02
0991C:  ADDWF  01,W
0991E:  MOVWF  01
09920:  MOVF   xD6,W
09922:  ADDWFC 03,F
09924:  MOVFF  01,8CD
09928:  MOVFF  03,8CE
0992C:  CLRF   02
0992E:  CLRF   03
09930:  MOVFF  03,8D0
09934:  MOVFF  02,8CF
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
09938:  BCF    FD8.0
0993A:  MOVLB  7
0993C:  RLCF   x3C,W
0993E:  CLRF   03
09940:  ADDLW  A7
09942:  MOVWF  FE9
09944:  MOVLW  07
09946:  ADDWFC 03,W
09948:  MOVWF  FEA
0994A:  MOVFF  FEC,9F7
0994E:  MOVF   FED,F
09950:  MOVFF  FEF,9F6
09954:  MOVFF  8C8,9F9
09958:  MOVFF  8C7,9F8
0995C:  MOVLB  0
0995E:  CALL   5D14
09962:  MOVFF  02,8D6
09966:  MOVFF  01,8D5
0996A:  BCF    FD8.0
0996C:  MOVLB  7
0996E:  RLCF   x3C,W
09970:  CLRF   03
09972:  ADDLW  A7
09974:  MOVWF  FE9
09976:  MOVLW  07
09978:  ADDWFC 03,W
0997A:  MOVWF  FEA
0997C:  MOVFF  FEC,8D8
09980:  MOVF   FED,F
09982:  MOVFF  FEF,8D7
09986:  BCF    FD8.0
09988:  MOVLB  8
0998A:  RRCF   xD8,W
0998C:  MOVWF  03
0998E:  RRCF   xD7,W
09990:  MOVWF  02
09992:  SUBWF  01,W
09994:  MOVWF  00
09996:  MOVF   03,W
09998:  SUBWFB xD6,W
0999A:  MOVWF  03
0999C:  MOVF   00,W
0999E:  MOVFF  03,8D2
099A2:  CLRF   02
099A4:  CLRF   03
099A6:  MOVFF  03,8D4
099AA:  MOVFF  02,8D3
099AE:  MOVFF  00,8D1
....................             } 
099B2:  BRA    9ACC
099B4:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
099B6:  DECFSZ xD7,W
099B8:  BRA    9ACE
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
099BA:  BCF    FD8.0
099BC:  MOVLB  7
099BE:  RLCF   x3C,W
099C0:  CLRF   03
099C2:  ADDLW  A7
099C4:  MOVWF  FE9
099C6:  MOVLW  07
099C8:  ADDWFC 03,W
099CA:  MOVWF  FEA
099CC:  MOVFF  FEC,9F7
099D0:  MOVF   FED,F
099D2:  MOVFF  FEF,9F6
099D6:  MOVLW  01
099D8:  MOVLB  8
099DA:  SUBWF  xC7,W
099DC:  MOVWF  00
099DE:  MOVLW  00
099E0:  SUBWFB xC8,W
099E2:  MOVWF  03
099E4:  MOVFF  00,8D7
099E8:  MOVWF  xD8
099EA:  MOVFF  FE8,9F9
099EE:  MOVFF  00,9F8
099F2:  MOVLB  0
099F4:  CALL   5D14
099F8:  MOVFF  02,8D6
099FC:  MOVFF  01,8D5
09A00:  BCF    FD8.0
09A02:  MOVLB  7
09A04:  RLCF   x3C,W
09A06:  CLRF   03
09A08:  ADDLW  A7
09A0A:  MOVWF  FE9
09A0C:  MOVLW  07
09A0E:  ADDWFC 03,W
09A10:  MOVWF  FEA
09A12:  MOVFF  FEC,8D8
09A16:  MOVF   FED,F
09A18:  MOVFF  FEF,8D7
09A1C:  BCF    FD8.0
09A1E:  MOVLB  8
09A20:  RRCF   xD8,W
09A22:  MOVWF  03
09A24:  RRCF   xD7,W
09A26:  MOVWF  02
09A28:  ADDWF  01,W
09A2A:  MOVWF  01
09A2C:  MOVF   xD6,W
09A2E:  ADDWFC 03,F
09A30:  MOVFF  01,8CD
09A34:  MOVFF  03,8CE
09A38:  CLRF   02
09A3A:  CLRF   03
09A3C:  MOVFF  03,8D0
09A40:  MOVFF  02,8CF
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
09A44:  BCF    FD8.0
09A46:  MOVLB  7
09A48:  RLCF   x3C,W
09A4A:  CLRF   03
09A4C:  ADDLW  A7
09A4E:  MOVWF  FE9
09A50:  MOVLW  07
09A52:  ADDWFC 03,W
09A54:  MOVWF  FEA
09A56:  MOVFF  FEC,9F7
09A5A:  MOVF   FED,F
09A5C:  MOVFF  FEF,9F6
09A60:  MOVLW  01
09A62:  MOVLB  8
09A64:  SUBWF  xC7,W
09A66:  MOVWF  00
09A68:  MOVLW  00
09A6A:  SUBWFB xC8,W
09A6C:  MOVWF  03
09A6E:  MOVFF  00,8D7
09A72:  MOVWF  xD8
09A74:  MOVFF  FE8,9F9
09A78:  MOVFF  00,9F8
09A7C:  MOVLB  0
09A7E:  CALL   5D14
09A82:  MOVFF  02,03
09A86:  MOVFF  01,8D1
09A8A:  MOVFF  02,8D2
09A8E:  CLRF   02
09A90:  CLRF   03
09A92:  MOVFF  03,8D4
09A96:  MOVFF  02,8D3
....................                m_pll = m_pll -(m_ppp[motor]/2); 
09A9A:  BCF    FD8.0
09A9C:  MOVLB  7
09A9E:  RLCF   x3C,W
09AA0:  CLRF   03
09AA2:  ADDLW  A7
09AA4:  MOVWF  FE9
09AA6:  MOVLW  07
09AA8:  ADDWFC 03,W
09AAA:  MOVWF  FEA
09AAC:  MOVFF  FEC,8D6
09AB0:  MOVF   FED,F
09AB2:  MOVFF  FEF,8D5
09AB6:  BCF    FD8.0
09AB8:  MOVLB  8
09ABA:  RRCF   xD6,W
09ABC:  MOVWF  03
09ABE:  RRCF   xD5,W
09AC0:  SUBWF  xD1,F
09AC2:  MOVF   03,W
09AC4:  SUBWFB xD2,F
09AC6:  MOVLW  00
09AC8:  SUBWFB xD3,F
09ACA:  SUBWFB xD4,F
09ACC:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
09ACE:  MOVLB  7
09AD0:  MOVF   x3C,W
09AD2:  MULLW  04
09AD4:  MOVF   FF3,W
09AD6:  CLRF   03
09AD8:  ADDLW  9E
09ADA:  MOVWF  FE9
09ADC:  MOVLW  07
09ADE:  ADDWFC 03,W
09AE0:  MOVWF  FEA
09AE2:  MOVFF  FEF,8D5
09AE6:  MOVFF  FEC,8D6
09AEA:  MOVFF  FEC,8D7
09AEE:  MOVFF  FEC,8D8
09AF2:  MOVLB  8
09AF4:  BTFSC  xD0.7
09AF6:  BRA    9B66
09AF8:  MOVF   xD0,W
09AFA:  SUBWF  xD8,W
09AFC:  BNC   9B16
09AFE:  BNZ   9B66
09B00:  MOVF   xCF,W
09B02:  SUBWF  xD7,W
09B04:  BNC   9B16
09B06:  BNZ   9B66
09B08:  MOVF   xCE,W
09B0A:  SUBWF  xD6,W
09B0C:  BNC   9B16
09B0E:  BNZ   9B66
09B10:  MOVF   xD5,W
09B12:  SUBWF  xCD,W
09B14:  BNC   9B66
09B16:  MOVLB  7
09B18:  MOVF   x3C,W
09B1A:  MULLW  04
09B1C:  MOVF   FF3,W
09B1E:  CLRF   03
09B20:  ADDLW  9E
09B22:  MOVWF  FE9
09B24:  MOVLW  07
09B26:  ADDWFC 03,W
09B28:  MOVWF  FEA
09B2A:  MOVFF  FEF,8D5
09B2E:  MOVFF  FEC,8D6
09B32:  MOVFF  FEC,8D7
09B36:  MOVFF  FEC,8D8
09B3A:  MOVLB  8
09B3C:  BTFSC  xD4.7
09B3E:  BRA    9CAA
09B40:  MOVF   xD8,W
09B42:  SUBWF  xD4,W
09B44:  BTFSS  FD8.0
09B46:  BRA    9CAA
09B48:  BNZ   9B66
09B4A:  MOVF   xD7,W
09B4C:  SUBWF  xD3,W
09B4E:  BTFSS  FD8.0
09B50:  BRA    9CAA
09B52:  BNZ   9B66
09B54:  MOVF   xD6,W
09B56:  SUBWF  xD2,W
09B58:  BTFSS  FD8.0
09B5A:  BRA    9CAA
09B5C:  BNZ   9B66
09B5E:  MOVF   xD1,W
09B60:  SUBWF  xD5,W
09B62:  BTFSC  FD8.0
09B64:  BRA    9CAA
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09B66:  MOVLW  01
09B68:  MOVLB  7
09B6A:  ADDWF  x3C,W
09B6C:  MOVLB  8
09B6E:  MOVWF  xD5
09B70:  BCF    FD8.0
09B72:  MOVLB  7
09B74:  RLCF   x3C,W
09B76:  CLRF   03
09B78:  ADDLW  A7
09B7A:  MOVWF  FE9
09B7C:  MOVLW  07
09B7E:  ADDWFC 03,W
09B80:  MOVWF  FEA
09B82:  MOVFF  FEC,8D7
09B86:  MOVF   FED,F
09B88:  MOVFF  FEF,8D6
09B8C:  MOVF   x3C,W
09B8E:  MULLW  04
09B90:  MOVF   FF3,W
09B92:  CLRF   03
09B94:  ADDLW  9E
09B96:  MOVWF  FE9
09B98:  MOVLW  07
09B9A:  ADDWFC 03,W
09B9C:  MOVWF  FEA
09B9E:  MOVFF  FEF,8D8
09BA2:  MOVFF  FEC,8D9
09BA6:  MOVFF  FEC,8DA
09BAA:  MOVFF  FEC,8DB
09BAE:  MOVLW  68
09BB0:  MOVWF  FF6
09BB2:  MOVLW  1A
09BB4:  MOVWF  FF7
09BB6:  MOVLW  00
09BB8:  MOVWF  FF8
09BBA:  CLRF   1B
09BBC:  BTFSC  FF2.7
09BBE:  BSF    1B.7
09BC0:  BCF    FF2.7
09BC2:  MOVLW  05
09BC4:  MOVLB  A
09BC6:  MOVWF  x25
09BC8:  MOVLB  0
09BCA:  CALL   101E
09BCE:  BTFSC  1B.7
09BD0:  BSF    FF2.7
09BD2:  CLRF   1B
09BD4:  BTFSC  FF2.7
09BD6:  BSF    1B.7
09BD8:  BCF    FF2.7
09BDA:  MOVFF  8D5,A25
09BDE:  MOVLW  1B
09BE0:  MOVLB  A
09BE2:  MOVWF  x26
09BE4:  MOVLB  0
09BE6:  CALL   0FA0
09BEA:  BTFSC  1B.7
09BEC:  BSF    FF2.7
09BEE:  MOVLW  2C
09BF0:  BTFSS  F9E.4
09BF2:  BRA    9BF0
09BF4:  MOVWF  FAD
09BF6:  MOVLW  41
09BF8:  MOVWF  FE9
09BFA:  MOVFF  8C6,8DF
09BFE:  MOVFF  8C5,8DE
09C02:  MOVFF  8C4,8DD
09C06:  MOVFF  8C3,8DC
09C0A:  RCALL  95A4
09C0C:  MOVLW  2C
09C0E:  BTFSS  F9E.4
09C10:  BRA    9C0E
09C12:  MOVWF  FAD
09C14:  MOVLW  10
09C16:  MOVWF  FE9
09C18:  CLRF   1B
09C1A:  BTFSC  FF2.7
09C1C:  BSF    1B.7
09C1E:  BCF    FF2.7
09C20:  MOVFF  8D7,A26
09C24:  MOVFF  8D6,A25
09C28:  CALL   11A0
09C2C:  BTFSC  1B.7
09C2E:  BSF    FF2.7
09C30:  MOVLW  2C
09C32:  BTFSS  F9E.4
09C34:  BRA    9C32
09C36:  MOVWF  FAD
09C38:  MOVLW  41
09C3A:  MOVWF  FE9
09C3C:  CLRF   1B
09C3E:  BTFSC  FF2.7
09C40:  BSF    1B.7
09C42:  BCF    FF2.7
09C44:  MOVFF  8DB,A28
09C48:  MOVFF  8DA,A27
09C4C:  MOVFF  8D9,A26
09C50:  MOVFF  8D8,A25
09C54:  CALL   10E4
09C58:  BTFSC  1B.7
09C5A:  BSF    FF2.7
09C5C:  MOVLW  2C
09C5E:  BTFSS  F9E.4
09C60:  BRA    9C5E
09C62:  MOVWF  FAD
09C64:  MOVLW  41
09C66:  MOVWF  FE9
09C68:  MOVFF  8D0,8DF
09C6C:  MOVFF  8CF,8DE
09C70:  MOVFF  8CE,8DD
09C74:  MOVFF  8CD,8DC
09C78:  RCALL  95A4
09C7A:  MOVLW  2C
09C7C:  BTFSS  F9E.4
09C7E:  BRA    9C7C
09C80:  MOVWF  FAD
09C82:  MOVLW  41
09C84:  MOVWF  FE9
09C86:  MOVFF  8D4,8DF
09C8A:  MOVFF  8D3,8DE
09C8E:  MOVFF  8D2,8DD
09C92:  MOVFF  8D1,8DC
09C96:  RCALL  95A4
09C98:  MOVLW  0D
09C9A:  BTFSS  F9E.4
09C9C:  BRA    9C9A
09C9E:  MOVWF  FAD
09CA0:  MOVLW  0A
09CA2:  BTFSS  F9E.4
09CA4:  BRA    9CA2
09CA6:  MOVWF  FAD
09CA8:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09CAA:  BCF    FD8.0
09CAC:  MOVLB  7
09CAE:  RLCF   x3C,W
09CB0:  CLRF   03
09CB2:  ADDLW  9A
09CB4:  MOVWF  01
09CB6:  MOVLW  07
09CB8:  ADDWFC 03,F
09CBA:  MOVLB  8
09CBC:  MOVFF  03,8D6
09CC0:  BCF    FD8.0
09CC2:  MOVLB  7
09CC4:  RLCF   x3C,W
09CC6:  CLRF   03
09CC8:  ADDLW  62
09CCA:  MOVWF  FE9
09CCC:  MOVLW  07
09CCE:  ADDWFC 03,W
09CD0:  MOVWF  FEA
09CD2:  MOVFF  FEC,03
09CD6:  MOVF   FED,F
09CD8:  MOVFF  FEF,8D7
09CDC:  MOVLB  8
09CDE:  MOVFF  8D6,FEA
09CE2:  MOVFF  01,FE9
09CE6:  MOVFF  03,FEC
09CEA:  MOVF   FED,F
09CEC:  MOVFF  8D7,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09CF0:  BCF    FD8.0
09CF2:  MOVLB  7
09CF4:  RLCF   x3C,W
09CF6:  CLRF   03
09CF8:  ADDLW  62
09CFA:  MOVWF  FE9
09CFC:  MOVLW  07
09CFE:  ADDWFC 03,W
09D00:  MOVWF  FEA
09D02:  CLRF   FEC
09D04:  MOVF   FED,F
09D06:  MOVLW  04
09D08:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09D0A:  MOVF   x3C,W
09D0C:  MULLW  04
09D0E:  MOVF   FF3,W
09D10:  CLRF   03
09D12:  ADDLW  9E
09D14:  MOVWF  FE9
09D16:  MOVLW  07
09D18:  ADDWFC 03,W
09D1A:  MOVWF  FEA
09D1C:  MOVFF  FEF,8C9
09D20:  MOVFF  FEC,8CA
09D24:  MOVFF  FEC,8CB
09D28:  MOVFF  FEC,8CC
09D2C:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09D2E:  MOVFF  8C9,00
09D32:  MOVFF  8CA,01
09D36:  MOVFF  8CB,02
09D3A:  MOVFF  8CC,03
09D3E:  MOVLB  0
09D40:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
0859E:  MOVLB  2
085A0:  CLRF   xD7
....................    start_even_port = FALSE; 
085A2:  CLRF   xD6
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
085A4:  BCF    FD8.0
085A6:  MOVLB  7
085A8:  RLCF   x3C,W
085AA:  CLRF   03
085AC:  ADDLW  C3
085AE:  MOVWF  FE9
085B0:  MOVLW  07
085B2:  ADDWFC 03,W
085B4:  MOVWF  FEA
085B6:  MOVFF  FEC,8C3
085BA:  MOVF   FED,F
085BC:  MOVFF  FEF,8C2
085C0:  MOVLW  01
085C2:  MOVLB  8
085C4:  ANDWF  xC2,F
085C6:  CLRF   xC3
085C8:  MOVF   xC2,F
085CA:  BNZ   85D8
085CC:  MOVF   xC3,F
085CE:  BNZ   85D8
....................    { 
....................       end_even_port = TRUE; 
085D0:  MOVLW  01
085D2:  MOVLB  2
085D4:  MOVWF  xD7
085D6:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
085D8:  BCF    FD8.0
085DA:  MOVLB  7
085DC:  RLCF   x3C,W
085DE:  CLRF   03
085E0:  ADDLW  BF
085E2:  MOVWF  FE9
085E4:  MOVLW  07
085E6:  ADDWFC 03,W
085E8:  MOVWF  FEA
085EA:  MOVFF  FEC,8C3
085EE:  MOVF   FED,F
085F0:  MOVFF  FEF,8C2
085F4:  MOVLW  01
085F6:  MOVLB  8
085F8:  ANDWF  xC2,F
085FA:  CLRF   xC3
085FC:  MOVF   xC2,F
085FE:  BNZ   860C
08600:  MOVF   xC3,F
08602:  BNZ   860C
....................    { 
....................       start_even_port = TRUE; 
08604:  MOVLW  01
08606:  MOVLB  2
08608:  MOVWF  xD6
0860A:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
0860C:  MOVLB  2
0860E:  MOVF   xD6,F
08610:  BNZ   8626
....................    { 
....................       evenOdd = 0; 
08612:  MOVLB  8
08614:  CLRF   xC1
....................       if (TRUE == end_even_port) 
08616:  MOVLB  2
08618:  DECFSZ xD7,W
0861A:  BRA    8624
....................       { 
....................          evenOdd = 1; 
0861C:  MOVLW  01
0861E:  MOVLB  8
08620:  MOVWF  xC1
08622:  MOVLB  2
....................       } 
....................    } 
08624:  BRA    863A
....................    else 
....................    { 
....................       evenOdd = 2; 
08626:  MOVLW  02
08628:  MOVLB  8
0862A:  MOVWF  xC1
....................       if (TRUE == end_even_port) 
0862C:  MOVLB  2
0862E:  DECFSZ xD7,W
08630:  BRA    863A
....................       { 
....................          evenOdd = 3; 
08632:  MOVLW  03
08634:  MOVLB  8
08636:  MOVWF  xC1
08638:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
0863A:  MOVLB  8
0863C:  MOVFF  8C1,01
08640:  MOVLB  0
08642:  GOTO   A090 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09DB8:  BCF    FD8.0
09DBA:  MOVLB  7
09DBC:  RLCF   x3C,W
09DBE:  CLRF   03
09DC0:  ADDLW  82
09DC2:  MOVWF  FE9
09DC4:  MOVLW  07
09DC6:  ADDWFC 03,W
09DC8:  MOVWF  FEA
09DCA:  CLRF   FEC
09DCC:  MOVF   FED,F
09DCE:  MOVFF  8B2,FEF
....................    m_step_cnt[motor] = 0; 
09DD2:  MOVF   x3C,W
09DD4:  MULLW  04
09DD6:  MOVF   FF3,W
09DD8:  CLRF   03
09DDA:  ADDLW  9E
09DDC:  MOVWF  FE9
09DDE:  MOVLW  07
09DE0:  ADDWFC 03,W
09DE2:  MOVWF  FEA
09DE4:  MOVF   FEE,F
09DE6:  MOVF   FEE,F
09DE8:  CLRF   FEC
09DEA:  MOVF   FED,F
09DEC:  CLRF   FEF
09DEE:  MOVF   FED,F
09DF0:  CLRF   FEF
09DF2:  MOVF   FED,F
09DF4:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09DF6:  BCF    FD8.0
09DF8:  RLCF   x3C,W
09DFA:  CLRF   03
09DFC:  ADDLW  6A
09DFE:  MOVWF  FE9
09E00:  MOVLW  07
09E02:  ADDWFC 03,W
09E04:  MOVWF  FEA
09E06:  MOVFF  FEC,8BF
09E0A:  MOVF   FED,F
09E0C:  MOVFF  FEF,8BE
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09E10:  BCF    FD8.0
09E12:  RLCF   x3C,W
09E14:  CLRF   03
09E16:  ADDLW  72
09E18:  MOVWF  FE9
09E1A:  MOVLW  07
09E1C:  ADDWFC 03,W
09E1E:  MOVWF  FEA
09E20:  MOVFF  FEC,8C6
09E24:  MOVF   FED,F
09E26:  MOVFF  FEF,8C5
09E2A:  BCF    FD8.0
09E2C:  RLCF   x3C,W
09E2E:  CLRF   03
09E30:  ADDLW  5A
09E32:  MOVWF  FE9
09E34:  MOVLW  07
09E36:  ADDWFC 03,W
09E38:  MOVWF  FEA
09E3A:  MOVFF  FEC,03
09E3E:  MOVF   FED,F
09E40:  MOVFF  FEF,8C7
09E44:  MOVFF  03,8C4
09E48:  MOVFF  03,8C8
09E4C:  MOVLB  0
09E4E:  CALL   2D36
09E52:  MOVFF  02,8BD
09E56:  MOVFF  01,8BC
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09E5A:  BCF    FD8.0
09E5C:  MOVLB  7
09E5E:  RLCF   x3C,W
09E60:  CLRF   03
09E62:  ADDLW  62
09E64:  MOVWF  FE9
09E66:  MOVLW  07
09E68:  ADDWFC 03,W
09E6A:  MOVWF  FEA
09E6C:  MOVFF  FEC,8C2
09E70:  MOVF   FED,F
09E72:  MOVFF  FEF,8C1
09E76:  MOVLB  8
09E78:  MOVF   xC1,W
09E7A:  SUBLW  02
09E7C:  BNZ   9EAC
09E7E:  MOVF   xC2,F
09E80:  BNZ   9EAC
09E82:  BCF    FD8.0
09E84:  MOVLB  7
09E86:  RLCF   x3C,W
09E88:  CLRF   03
09E8A:  ADDLW  BF
09E8C:  MOVWF  FE9
09E8E:  MOVLW  07
09E90:  ADDWFC 03,W
09E92:  MOVWF  FEA
09E94:  MOVFF  FEC,8C2
09E98:  MOVF   FED,F
09E9A:  MOVFF  FEF,8C1
09E9E:  MOVLB  8
09EA0:  MOVF   xC1,F
09EA2:  BNZ   9EAC
09EA4:  MOVF   xC2,F
09EA6:  BTFSC  FD8.2
09EA8:  GOTO   A74A
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09EAC:  BCF    FD8.0
09EAE:  MOVLB  7
09EB0:  RLCF   x3C,W
09EB2:  CLRF   03
09EB4:  ADDLW  62
09EB6:  MOVWF  FE9
09EB8:  MOVLW  07
09EBA:  ADDWFC 03,W
09EBC:  MOVWF  FEA
09EBE:  MOVFF  FEC,8C2
09EC2:  MOVF   FED,F
09EC4:  MOVFF  FEF,8C1
09EC8:  MOVLB  8
09ECA:  MOVF   xC1,W
09ECC:  SUBLW  02
09ECE:  BTFSS  FD8.2
09ED0:  BRA    A22A
09ED2:  MOVF   xC2,F
09ED4:  BTFSS  FD8.2
09ED6:  BRA    A22A
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09ED8:  BCF    FD8.0
09EDA:  MOVLB  7
09EDC:  RLCF   x3C,W
09EDE:  CLRF   03
09EE0:  ADDLW  C3
09EE2:  MOVWF  FE9
09EE4:  MOVLW  07
09EE6:  ADDWFC 03,W
09EE8:  MOVWF  FEA
09EEA:  MOVFF  8B3,FEF
09EEE:  MOVFF  8B4,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09EF2:  DECFSZ 2F,W
09EF4:  BRA    A1A6
09EF6:  MOVF   30,F
09EF8:  BTFSS  FD8.2
09EFA:  BRA    A1A6
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09EFC:  BCF    FD8.0
09EFE:  RLCF   x3C,W
09F00:  CLRF   03
09F02:  ADDLW  C3
09F04:  MOVWF  FE9
09F06:  MOVLW  07
09F08:  ADDWFC 03,W
09F0A:  MOVWF  FEA
09F0C:  MOVFF  FEC,8C2
09F10:  MOVF   FED,F
09F12:  MOVFF  FEF,8C1
09F16:  BCF    FD8.0
09F18:  RLCF   x3C,W
09F1A:  CLRF   03
09F1C:  ADDLW  BF
09F1E:  MOVWF  FE9
09F20:  MOVLW  07
09F22:  ADDWFC 03,W
09F24:  MOVWF  FEA
09F26:  MOVFF  FEC,03
09F2A:  MOVF   FED,F
09F2C:  MOVFF  FEF,01
09F30:  MOVF   03,W
09F32:  MOVLB  8
09F34:  SUBWF  xC2,W
09F36:  BNC   9FD2
09F38:  BNZ   9F40
09F3A:  MOVF   xC1,W
09F3C:  SUBWF  01,W
09F3E:  BC    9FD2
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09F40:  BCF    FD8.0
09F42:  MOVLB  7
09F44:  RLCF   x3C,W
09F46:  CLRF   03
09F48:  ADDLW  B3
09F4A:  MOVWF  01
09F4C:  MOVLW  07
09F4E:  ADDWFC 03,F
09F50:  MOVLB  8
09F52:  MOVFF  03,8C2
09F56:  BCF    FD8.0
09F58:  MOVLB  7
09F5A:  RLCF   x3C,W
09F5C:  CLRF   03
09F5E:  ADDLW  C3
09F60:  MOVWF  FE9
09F62:  MOVLW  07
09F64:  ADDWFC 03,W
09F66:  MOVWF  FEA
09F68:  MOVFF  FEC,8C4
09F6C:  MOVF   FED,F
09F6E:  MOVFF  FEF,8C3
09F72:  BCF    FD8.0
09F74:  RLCF   x3C,W
09F76:  CLRF   03
09F78:  ADDLW  BF
09F7A:  MOVWF  FE9
09F7C:  MOVLW  07
09F7E:  ADDWFC 03,W
09F80:  MOVWF  FEA
09F82:  MOVFF  FEC,03
09F86:  MOVF   FED,F
09F88:  MOVF   FEF,W
09F8A:  MOVLB  8
09F8C:  SUBWF  xC3,W
09F8E:  MOVWF  00
09F90:  MOVF   03,W
09F92:  SUBWFB xC4,W
09F94:  MOVFF  8C2,FEA
09F98:  MOVFF  01,FE9
09F9C:  MOVWF  FEC
09F9E:  MOVF   FED,F
09FA0:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09FA4:  BCF    FD8.0
09FA6:  MOVLB  7
09FA8:  RLCF   x3C,W
09FAA:  CLRF   03
09FAC:  ADDLW  B3
09FAE:  MOVWF  FE9
09FB0:  MOVLW  07
09FB2:  ADDWFC 03,W
09FB4:  MOVWF  FEA
09FB6:  MOVFF  FEC,8C2
09FBA:  MOVF   FED,F
09FBC:  MOVFF  FEF,8C1
09FC0:  BCF    FD8.0
09FC2:  MOVLB  8
09FC4:  CLRF   xB6
09FC6:  CLRF   xB5
09FC8:  RRCF   xC2,W
09FCA:  MOVWF  xB4
09FCC:  RRCF   xC1,W
09FCE:  MOVWF  xB3
....................             } 
09FD0:  BRA    A08A
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09FD2:  BCF    FD8.0
09FD4:  MOVLB  7
09FD6:  RLCF   x3C,W
09FD8:  CLRF   03
09FDA:  ADDLW  B3
09FDC:  MOVWF  01
09FDE:  MOVLW  07
09FE0:  ADDWFC 03,F
09FE2:  MOVFF  01,8C1
09FE6:  MOVLB  8
09FE8:  MOVFF  03,8C2
09FEC:  BCF    FD8.0
09FEE:  MOVLB  7
09FF0:  RLCF   x3C,W
09FF2:  CLRF   03
09FF4:  ADDLW  5E
09FF6:  MOVWF  FE9
09FF8:  MOVLW  07
09FFA:  ADDWFC 03,W
09FFC:  MOVWF  FEA
09FFE:  MOVFF  FEC,8C4
0A002:  MOVF   FED,F
0A004:  MOVFF  FEF,8C3
0A008:  BCF    FD8.0
0A00A:  RLCF   x3C,W
0A00C:  CLRF   03
0A00E:  ADDLW  BF
0A010:  MOVWF  FE9
0A012:  MOVLW  07
0A014:  ADDWFC 03,W
0A016:  MOVWF  FEA
0A018:  MOVFF  FEC,03
0A01C:  MOVF   FED,F
0A01E:  MOVF   FEF,W
0A020:  MOVLB  8
0A022:  SUBWF  xC3,F
0A024:  MOVF   03,W
0A026:  SUBWFB xC4,F
0A028:  BCF    FD8.0
0A02A:  MOVLB  7
0A02C:  RLCF   x3C,W
0A02E:  CLRF   03
0A030:  ADDLW  C3
0A032:  MOVWF  FE9
0A034:  MOVLW  07
0A036:  ADDWFC 03,W
0A038:  MOVWF  FEA
0A03A:  MOVFF  FEC,03
0A03E:  MOVF   FED,F
0A040:  MOVF   FEF,W
0A042:  MOVLB  8
0A044:  ADDWF  xC3,W
0A046:  MOVWF  01
0A048:  MOVF   xC4,W
0A04A:  ADDWFC 03,F
0A04C:  MOVFF  8C2,FEA
0A050:  MOVFF  8C1,FE9
0A054:  MOVFF  03,FEC
0A058:  MOVF   FED,F
0A05A:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
0A05E:  BCF    FD8.0
0A060:  MOVLB  7
0A062:  RLCF   x3C,W
0A064:  CLRF   03
0A066:  ADDLW  B3
0A068:  MOVWF  FE9
0A06A:  MOVLW  07
0A06C:  ADDWFC 03,W
0A06E:  MOVWF  FEA
0A070:  MOVFF  FEC,8C2
0A074:  MOVF   FED,F
0A076:  MOVFF  FEF,8C1
0A07A:  BCF    FD8.0
0A07C:  MOVLB  8
0A07E:  CLRF   xB6
0A080:  CLRF   xB5
0A082:  RRCF   xC2,W
0A084:  MOVWF  xB4
0A086:  RRCF   xC1,W
0A088:  MOVWF  xB3
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
0A08A:  MOVLB  0
0A08C:  GOTO   859E
0A090:  MOVFF  01,8C0
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
0A094:  BCF    FD8.0
0A096:  MOVLB  7
0A098:  RLCF   x3C,W
0A09A:  CLRF   03
0A09C:  ADDLW  C3
0A09E:  MOVWF  FE9
0A0A0:  MOVLW  07
0A0A2:  ADDWFC 03,W
0A0A4:  MOVWF  FEA
0A0A6:  MOVFF  FEC,8C2
0A0AA:  MOVF   FED,F
0A0AC:  MOVFF  FEF,8C1
0A0B0:  MOVLB  8
0A0B2:  MOVF   xC1,W
0A0B4:  SUBLW  02
0A0B6:  BNZ   A0E6
0A0B8:  MOVF   xC2,F
0A0BA:  BNZ   A0E6
0A0BC:  BCF    FD8.0
0A0BE:  MOVLB  7
0A0C0:  RLCF   x3C,W
0A0C2:  CLRF   03
0A0C4:  ADDLW  BF
0A0C6:  MOVWF  FE9
0A0C8:  MOVLW  07
0A0CA:  ADDWFC 03,W
0A0CC:  MOVWF  FEA
0A0CE:  MOVFF  FEC,8C2
0A0D2:  MOVF   FED,F
0A0D4:  MOVFF  FEF,8C1
0A0D8:  MOVLB  8
0A0DA:  DECFSZ xC1,W
0A0DC:  BRA    A0E6
0A0DE:  MOVF   xC2,F
0A0E0:  BNZ   A0E6
....................             { 
....................                port_port=4; 
0A0E2:  MOVLW  04
0A0E4:  MOVWF  xC0
....................             } 
....................              
....................             switch(port_port){ 
0A0E6:  MOVF   xC0,W
0A0E8:  ADDLW  FB
0A0EA:  BC    A1A2
0A0EC:  ADDLW  05
0A0EE:  MOVLB  0
0A0F0:  GOTO   A798
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
0A0F4:  BCF    FD8.0
0A0F6:  MOVLB  7
0A0F8:  RLCF   x3C,W
0A0FA:  CLRF   03
0A0FC:  ADDLW  6A
0A0FE:  MOVWF  FE9
0A100:  MOVLW  07
0A102:  ADDWFC 03,W
0A104:  MOVWF  FEA
0A106:  MOVFF  FEC,8BF
0A10A:  MOVF   FED,F
0A10C:  MOVFF  FEF,8BE
....................                   break; 
0A110:  MOVLB  8
0A112:  BRA    A1A2
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A114:  BCF    FD8.0
0A116:  MOVLB  7
0A118:  RLCF   x3C,W
0A11A:  CLRF   03
0A11C:  ADDLW  7A
0A11E:  MOVWF  FE9
0A120:  MOVLW  07
0A122:  ADDWFC 03,W
0A124:  MOVWF  FEA
0A126:  MOVFF  FEC,03
0A12A:  MOVF   FED,F
0A12C:  MOVF   FEF,W
0A12E:  MOVLB  8
0A130:  ADDWF  xBC,W
0A132:  MOVWF  xBE
0A134:  MOVF   03,W
0A136:  ADDWFC xBD,W
0A138:  MOVWF  xBF
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A13A:  BRA    A1A2
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A13C:  BCF    FD8.0
0A13E:  MOVLB  7
0A140:  RLCF   x3C,W
0A142:  CLRF   03
0A144:  ADDLW  6A
0A146:  MOVWF  FE9
0A148:  MOVLW  07
0A14A:  ADDWFC 03,W
0A14C:  MOVWF  FEA
0A14E:  MOVFF  FEC,8BF
0A152:  MOVF   FED,F
0A154:  MOVFF  FEF,8BE
....................                         ++m_steps; 
0A158:  MOVLW  01
0A15A:  MOVLB  8
0A15C:  ADDWF  xB3,F
0A15E:  BTFSC  FD8.0
0A160:  INCF   xB4,F
0A162:  BTFSC  FD8.2
0A164:  INCF   xB5,F
0A166:  BTFSC  FD8.2
0A168:  INCF   xB6,F
....................                   break; 
0A16A:  BRA    A1A2
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A16C:  BCF    FD8.0
0A16E:  MOVLB  7
0A170:  RLCF   x3C,W
0A172:  CLRF   03
0A174:  ADDLW  7A
0A176:  MOVWF  FE9
0A178:  MOVLW  07
0A17A:  ADDWFC 03,W
0A17C:  MOVWF  FEA
0A17E:  MOVFF  FEC,03
0A182:  MOVF   FED,F
0A184:  MOVF   FEF,W
0A186:  MOVLB  8
0A188:  ADDWF  xBC,W
0A18A:  MOVWF  xBE
0A18C:  MOVF   03,W
0A18E:  ADDWFC xBD,W
0A190:  MOVWF  xBF
....................  
....................                   break; 
0A192:  BRA    A1A2
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A194:  MOVFF  8BD,8BF
0A198:  MOVFF  8BC,8BE
....................                   break;     
0A19C:  MOVLB  8
0A19E:  BRA    A1A2
0A1A0:  MOVLB  8
....................             } 
....................          } 
0A1A2:  BRA    A1CE
0A1A4:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A1A6:  MOVFF  8B6,8C4
0A1AA:  MOVFF  8B5,8C3
0A1AE:  MOVFF  8B4,8C2
0A1B2:  MOVFF  8B3,8C1
0A1B6:  MOVLB  0
0A1B8:  GOTO   8646
0A1BC:  MOVFF  03,8B6
0A1C0:  MOVFF  02,8B5
0A1C4:  MOVFF  01,8B4
0A1C8:  MOVFF  00,8B3
0A1CC:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A1CE:  DECFSZ xB1,W
0A1D0:  BRA    A1F8
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A1D2:  MOVFF  8B4,8C2
0A1D6:  MOVFF  8B3,8C1
0A1DA:  MOVFF  8B4,8C4
0A1DE:  MOVFF  8B3,8C3
0A1E2:  MOVLB  0
0A1E4:  GOTO   8858
0A1E8:  MOVLB  8
0A1EA:  CLRF   xB6
0A1EC:  CLRF   xB5
0A1EE:  MOVFF  02,8B4
0A1F2:  MOVFF  01,8B3
....................          } 
0A1F6:  BRA    A22A
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A1F8:  MOVF   2F,W
0A1FA:  SUBLW  03
0A1FC:  BNZ   A22A
0A1FE:  MOVF   30,F
0A200:  BNZ   A22A
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A202:  BCF    FD8.0
0A204:  MOVLB  7
0A206:  RLCF   x3C,W
0A208:  CLRF   03
0A20A:  ADDLW  BB
0A20C:  MOVWF  FE9
0A20E:  MOVLW  07
0A210:  ADDWFC 03,W
0A212:  MOVWF  FEA
0A214:  MOVFF  FEC,03
0A218:  MOVF   FED,F
0A21A:  MOVF   FEF,W
0A21C:  MOVLB  8
0A21E:  SUBWF  xB3,F
0A220:  MOVF   03,W
0A222:  SUBWFB xB4,F
0A224:  MOVLW  00
0A226:  SUBWFB xB5,F
0A228:  SUBWFB xB6,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A22A:  MOVFF  8B7,8C1
0A22E:  MOVLB  0
0A230:  GOTO   8F22
....................  
....................       while (m_running[motor]) 
0A234:  BCF    FD8.0
0A236:  MOVLB  7
0A238:  RLCF   x3C,W
0A23A:  CLRF   03
0A23C:  ADDLW  8E
0A23E:  MOVWF  FE9
0A240:  MOVLW  07
0A242:  ADDWFC 03,W
0A244:  MOVWF  FEA
0A246:  MOVF   FEF,F
0A248:  BNZ   A250
0A24A:  MOVF   FEC,F
0A24C:  BTFSC  FD8.2
0A24E:  BRA    A746
....................       { 
....................          switch(e_mode[motor]) 
0A250:  BCF    FD8.0
0A252:  RLCF   x3C,W
0A254:  CLRF   03
0A256:  ADDLW  62
0A258:  MOVWF  FE9
0A25A:  MOVLW  07
0A25C:  ADDWFC 03,W
0A25E:  MOVWF  FEA
0A260:  MOVF   FEF,W
0A262:  MOVWF  00
0A264:  MOVF   FEE,F
0A266:  MOVF   FED,W
0A268:  MOVWF  03
0A26A:  MOVF   03,W
0A26C:  BNZ   A276
0A26E:  MOVF   00,F
0A270:  MOVLB  0
0A272:  BZ    A2C4
0A274:  MOVLB  7
0A276:  MOVF   03,W
0A278:  BNZ   A284
0A27A:  MOVLW  01
0A27C:  SUBWF  00,W
0A27E:  MOVLB  0
0A280:  BZ    A31A
0A282:  MOVLB  7
0A284:  MOVF   03,W
0A286:  BNZ   A292
0A288:  MOVLW  02
0A28A:  SUBWF  00,W
0A28C:  MOVLB  0
0A28E:  BZ    A31A
0A290:  MOVLB  7
0A292:  MOVF   03,W
0A294:  BNZ   A2A2
0A296:  MOVLW  03
0A298:  SUBWF  00,W
0A29A:  MOVLB  0
0A29C:  BTFSC  FD8.2
0A29E:  BRA    A3E8
0A2A0:  MOVLB  7
0A2A2:  MOVF   03,W
0A2A4:  BNZ   A2B2
0A2A6:  MOVLW  04
0A2A8:  SUBWF  00,W
0A2AA:  MOVLB  0
0A2AC:  BTFSC  FD8.2
0A2AE:  BRA    A538
0A2B0:  MOVLB  7
0A2B2:  MOVF   03,W
0A2B4:  BNZ   A2C2
0A2B6:  MOVLW  05
0A2B8:  SUBWF  00,W
0A2BA:  MOVLB  0
0A2BC:  BTFSC  FD8.2
0A2BE:  BRA    A688
0A2C0:  MOVLB  7
0A2C2:  BRA    A740
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A2C4:  MOVLB  7
0A2C6:  MOVF   x3C,W
0A2C8:  MULLW  04
0A2CA:  MOVF   FF3,W
0A2CC:  CLRF   03
0A2CE:  ADDLW  9E
0A2D0:  MOVWF  FE9
0A2D2:  MOVLW  07
0A2D4:  ADDWFC 03,W
0A2D6:  MOVWF  FEA
0A2D8:  MOVFF  FEF,8C1
0A2DC:  MOVFF  FEC,8C2
0A2E0:  MOVFF  FEC,8C3
0A2E4:  MOVFF  FEC,8C4
0A2E8:  MOVLB  8
0A2EA:  MOVF   xB6,W
0A2EC:  SUBWF  xC4,W
0A2EE:  BNC   A314
0A2F0:  BNZ   A308
0A2F2:  MOVF   xB5,W
0A2F4:  SUBWF  xC3,W
0A2F6:  BNC   A314
0A2F8:  BNZ   A308
0A2FA:  MOVF   xB4,W
0A2FC:  SUBWF  xC2,W
0A2FE:  BNC   A314
0A300:  BNZ   A308
0A302:  MOVF   xB3,W
0A304:  SUBWF  xC1,W
0A306:  BNC   A314
....................                { 
....................                   terminate(1); 
0A308:  MOVLW  01
0A30A:  MOVWF  xD5
0A30C:  MOVLB  0
0A30E:  CALL   9110
0A312:  MOVLB  8
....................                } 
....................                break; 
0A314:  MOVLB  7
0A316:  BRA    A740
0A318:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A31A:  BCF    FD8.0
0A31C:  MOVLB  7
0A31E:  RLCF   x3C,W
0A320:  CLRF   03
0A322:  ADDLW  96
0A324:  MOVWF  FE9
0A326:  MOVLW  07
0A328:  ADDWFC 03,W
0A32A:  MOVWF  FEA
0A32C:  MOVFF  FEC,8C2
0A330:  MOVF   FED,F
0A332:  MOVFF  FEF,8C1
0A336:  BCF    FD8.0
0A338:  RLCF   x3C,W
0A33A:  CLRF   03
0A33C:  ADDLW  56
0A33E:  MOVWF  FE9
0A340:  MOVLW  07
0A342:  ADDWFC 03,W
0A344:  MOVWF  FEA
0A346:  MOVFF  FEC,03
0A34A:  MOVF   FED,F
0A34C:  MOVFF  FEF,01
0A350:  MOVF   03,W
0A352:  MOVLB  8
0A354:  SUBWF  xC2,W
0A356:  BNC   A36A
0A358:  BNZ   A360
0A35A:  MOVF   01,W
0A35C:  SUBWF  xC1,W
0A35E:  BNC   A36A
....................                { 
....................                   terminate(0); 
0A360:  CLRF   xD5
0A362:  MOVLB  0
0A364:  CALL   9110
0A368:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A36A:  BCF    FD8.0
0A36C:  MOVLB  7
0A36E:  RLCF   x3C,W
0A370:  CLRF   03
0A372:  ADDLW  B7
0A374:  MOVWF  FE9
0A376:  MOVLW  07
0A378:  ADDWFC 03,W
0A37A:  MOVWF  FEA
0A37C:  MOVFF  FEC,8C2
0A380:  MOVF   FED,F
0A382:  MOVFF  FEF,8C1
0A386:  MOVLB  8
0A388:  MOVF   xB6,F
0A38A:  BNZ   A3E2
0A38C:  MOVF   xB5,F
0A38E:  BNZ   A3E2
0A390:  MOVF   xB4,W
0A392:  SUBWF  xC2,W
0A394:  BNC   A3E2
0A396:  BNZ   A39E
0A398:  MOVF   xB3,W
0A39A:  SUBWF  xC1,W
0A39C:  BNC   A3E2
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A39E:  BCF    FD8.0
0A3A0:  MOVLB  7
0A3A2:  RLCF   x3C,W
0A3A4:  CLRF   03
0A3A6:  ADDLW  B3
0A3A8:  MOVWF  FE9
0A3AA:  MOVLW  07
0A3AC:  ADDWFC 03,W
0A3AE:  MOVWF  FEA
0A3B0:  MOVFF  FEC,8C8
0A3B4:  MOVF   FED,F
0A3B6:  MOVFF  FEF,8C7
0A3BA:  MOVFF  8B6,8C6
0A3BE:  MOVFF  8B5,8C5
0A3C2:  MOVFF  8B4,8C4
0A3C6:  MOVFF  8B3,8C3
0A3CA:  MOVLB  0
0A3CC:  CALL   96D0
0A3D0:  MOVFF  03,8BB
0A3D4:  MOVFF  02,8BA
0A3D8:  MOVFF  01,8B9
0A3DC:  MOVFF  00,8B8
0A3E0:  MOVLB  8
....................                } 
....................                break; 
0A3E2:  MOVLB  7
0A3E4:  BRA    A740
0A3E6:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A3E8:  BCF    FD8.0
0A3EA:  MOVLB  7
0A3EC:  RLCF   x3C,W
0A3EE:  CLRF   03
0A3F0:  ADDLW  B7
0A3F2:  MOVWF  FE9
0A3F4:  MOVLW  07
0A3F6:  ADDWFC 03,W
0A3F8:  MOVWF  FEA
0A3FA:  MOVFF  FEC,8C2
0A3FE:  MOVF   FED,F
0A400:  MOVFF  FEF,8C1
0A404:  MOVLB  8
0A406:  MOVF   xB6,F
0A408:  BNZ   A426
0A40A:  MOVF   xB5,F
0A40C:  BNZ   A426
0A40E:  MOVF   xB4,W
0A410:  SUBWF  xC2,W
0A412:  BNC   A426
0A414:  BNZ   A41C
0A416:  MOVF   xB3,W
0A418:  SUBWF  xC1,W
0A41A:  BNC   A426
....................                { 
....................                   terminate(0); 
0A41C:  CLRF   xD5
0A41E:  MOVLB  0
0A420:  CALL   9110
0A424:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A426:  BCF    FD8.0
0A428:  MOVLB  7
0A42A:  RLCF   x3C,W
0A42C:  CLRF   03
0A42E:  ADDLW  76
0A430:  MOVWF  FE9
0A432:  MOVLW  07
0A434:  ADDWFC 03,W
0A436:  MOVWF  FEA
0A438:  MOVFF  FEC,8C2
0A43C:  MOVF   FED,F
0A43E:  MOVFF  FEF,8C1
0A442:  MOVLB  8
0A444:  MOVF   xC1,F
0A446:  BNZ   A4AC
0A448:  MOVF   xC2,F
0A44A:  BNZ   A4AC
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A44C:  CLRF   03
0A44E:  MOVLB  7
0A450:  MOVF   x3C,W
0A452:  ADDLW  C7
0A454:  MOVWF  FE9
0A456:  MOVLW  07
0A458:  ADDWFC 03,W
0A45A:  MOVWF  FEA
0A45C:  MOVF   FEF,F
0A45E:  BNZ   A4AA
....................                   { 
....................                      wrt_m_error(); 
0A460:  MOVLB  0
0A462:  CALL   8FC0
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A466:  BCF    FD8.0
0A468:  MOVLB  7
0A46A:  RLCF   x3C,W
0A46C:  CLRF   03
0A46E:  ADDLW  B3
0A470:  MOVWF  FE9
0A472:  MOVLW  07
0A474:  ADDWFC 03,W
0A476:  MOVWF  FEA
0A478:  MOVFF  FEC,8C8
0A47C:  MOVF   FED,F
0A47E:  MOVFF  FEF,8C7
0A482:  MOVFF  8B6,8C6
0A486:  MOVFF  8B5,8C5
0A48A:  MOVFF  8B4,8C4
0A48E:  MOVFF  8B3,8C3
0A492:  MOVLB  0
0A494:  CALL   96D0
0A498:  MOVFF  03,8BB
0A49C:  MOVFF  02,8BA
0A4A0:  MOVFF  01,8B9
0A4A4:  MOVFF  00,8B8
0A4A8:  MOVLB  7
0A4AA:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A4AC:  BCF    FD8.0
0A4AE:  MOVLB  7
0A4B0:  RLCF   x3C,W
0A4B2:  CLRF   03
0A4B4:  ADDLW  76
0A4B6:  MOVWF  FE9
0A4B8:  MOVLW  07
0A4BA:  ADDWFC 03,W
0A4BC:  MOVWF  FEA
0A4BE:  MOVFF  FEC,8C2
0A4C2:  MOVF   FED,F
0A4C4:  MOVFF  FEF,8C1
0A4C8:  MOVLB  8
0A4CA:  DECFSZ xC1,W
0A4CC:  BRA    A532
0A4CE:  MOVF   xC2,F
0A4D0:  BNZ   A532
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A4D2:  CLRF   03
0A4D4:  MOVLB  7
0A4D6:  MOVF   x3C,W
0A4D8:  ADDLW  C7
0A4DA:  MOVWF  FE9
0A4DC:  MOVLW  07
0A4DE:  ADDWFC 03,W
0A4E0:  MOVWF  FEA
0A4E2:  DECFSZ FEF,W
0A4E4:  BRA    A530
....................                   { 
....................                      wrt_m_error(); 
0A4E6:  MOVLB  0
0A4E8:  CALL   8FC0
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A4EC:  BCF    FD8.0
0A4EE:  MOVLB  7
0A4F0:  RLCF   x3C,W
0A4F2:  CLRF   03
0A4F4:  ADDLW  B3
0A4F6:  MOVWF  FE9
0A4F8:  MOVLW  07
0A4FA:  ADDWFC 03,W
0A4FC:  MOVWF  FEA
0A4FE:  MOVFF  FEC,8C8
0A502:  MOVF   FED,F
0A504:  MOVFF  FEF,8C7
0A508:  MOVFF  8B6,8C6
0A50C:  MOVFF  8B5,8C5
0A510:  MOVFF  8B4,8C4
0A514:  MOVFF  8B3,8C3
0A518:  MOVLB  0
0A51A:  CALL   96D0
0A51E:  MOVFF  03,8BB
0A522:  MOVFF  02,8BA
0A526:  MOVFF  01,8B9
0A52A:  MOVFF  00,8B8
0A52E:  MOVLB  7
0A530:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A532:  MOVLB  7
0A534:  BRA    A740
0A536:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A538:  MOVLB  7
0A53A:  MOVF   x3C,W
0A53C:  MULLW  04
0A53E:  MOVF   FF3,W
0A540:  CLRF   03
0A542:  ADDLW  9E
0A544:  MOVWF  FE9
0A546:  MOVLW  07
0A548:  ADDWFC 03,W
0A54A:  MOVWF  FEA
0A54C:  MOVFF  FEF,8C1
0A550:  MOVFF  FEC,8C2
0A554:  MOVFF  FEC,8C3
0A558:  MOVFF  FEC,8C4
0A55C:  MOVLB  8
0A55E:  MOVF   xB8,W
0A560:  SUBWF  xC1,F
0A562:  MOVF   xB9,W
0A564:  SUBWFB xC2,F
0A566:  MOVF   xBA,W
0A568:  SUBWFB xC3,F
0A56A:  MOVF   xBB,W
0A56C:  SUBWFB xC4,F
0A56E:  BNZ   A586
0A570:  MOVF   xC3,F
0A572:  BNZ   A586
0A574:  MOVF   xBF,W
0A576:  SUBWF  xC2,W
0A578:  BTFSS  FD8.0
0A57A:  BRA    A682
0A57C:  BNZ   A586
0A57E:  MOVF   xBE,W
0A580:  SUBWF  xC1,W
0A582:  BTFSS  FD8.0
0A584:  BRA    A682
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A586:  BCF    FD8.0
0A588:  MOVLB  7
0A58A:  RLCF   x3C,W
0A58C:  CLRF   03
0A58E:  ADDLW  62
0A590:  MOVWF  01
0A592:  MOVLW  07
0A594:  ADDWFC 03,F
0A596:  MOVLB  8
0A598:  MOVFF  03,8C2
0A59C:  BCF    FD8.0
0A59E:  MOVLB  7
0A5A0:  RLCF   x3C,W
0A5A2:  CLRF   03
0A5A4:  ADDLW  9A
0A5A6:  MOVWF  FE9
0A5A8:  MOVLW  07
0A5AA:  ADDWFC 03,W
0A5AC:  MOVWF  FEA
0A5AE:  MOVFF  FEC,03
0A5B2:  MOVF   FED,F
0A5B4:  MOVFF  FEF,8C3
0A5B8:  MOVLB  8
0A5BA:  MOVFF  8C2,FEA
0A5BE:  MOVFF  01,FE9
0A5C2:  MOVFF  03,FEC
0A5C6:  MOVF   FED,F
0A5C8:  MOVFF  8C3,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A5CC:  MOVLB  7
0A5CE:  MOVF   x3C,W
0A5D0:  MULLW  04
0A5D2:  MOVF   FF3,W
0A5D4:  CLRF   03
0A5D6:  ADDLW  9E
0A5D8:  MOVWF  FE9
0A5DA:  MOVLW  07
0A5DC:  ADDWFC 03,W
0A5DE:  MOVWF  FEA
0A5E0:  MOVFF  FEF,8C1
0A5E4:  MOVFF  FEC,8C2
0A5E8:  MOVFF  FEC,8C3
0A5EC:  MOVFF  FEC,8C4
0A5F0:  MOVLW  86
0A5F2:  MOVWF  FF6
0A5F4:  MOVLW  1A
0A5F6:  MOVWF  FF7
0A5F8:  MOVLW  00
0A5FA:  MOVWF  FF8
0A5FC:  CLRF   1B
0A5FE:  BTFSC  FF2.7
0A600:  BSF    1B.7
0A602:  BCF    FF2.7
0A604:  MOVLW  0B
0A606:  MOVLB  A
0A608:  MOVWF  x25
0A60A:  MOVLB  0
0A60C:  CALL   101E
0A610:  BTFSC  1B.7
0A612:  BSF    FF2.7
0A614:  MOVLW  41
0A616:  MOVWF  FE9
0A618:  CLRF   1B
0A61A:  BTFSC  FF2.7
0A61C:  BSF    1B.7
0A61E:  BCF    FF2.7
0A620:  MOVFF  8C4,A28
0A624:  MOVFF  8C3,A27
0A628:  MOVFF  8C2,A26
0A62C:  MOVFF  8C1,A25
0A630:  CALL   10E4
0A634:  BTFSC  1B.7
0A636:  BSF    FF2.7
0A638:  MOVLW  2C
0A63A:  BTFSS  F9E.4
0A63C:  BRA    A63A
0A63E:  MOVWF  FAD
0A640:  MOVLW  41
0A642:  MOVWF  FE9
0A644:  CLRF   1B
0A646:  BTFSC  FF2.7
0A648:  BSF    1B.7
0A64A:  BCF    FF2.7
0A64C:  MOVFF  8BB,A28
0A650:  MOVFF  8BA,A27
0A654:  MOVFF  8B9,A26
0A658:  MOVFF  8B8,A25
0A65C:  CALL   10E4
0A660:  BTFSC  1B.7
0A662:  BSF    FF2.7
0A664:  MOVLW  0D
0A666:  BTFSS  F9E.4
0A668:  BRA    A666
0A66A:  MOVWF  FAD
0A66C:  MOVLW  0A
0A66E:  BTFSS  F9E.4
0A670:  BRA    A66E
0A672:  MOVWF  FAD
....................                   terminate(1); 
0A674:  MOVLW  01
0A676:  MOVLB  8
0A678:  MOVWF  xD5
0A67A:  MOVLB  0
0A67C:  CALL   9110
0A680:  MOVLB  8
....................                } 
....................                break; 
0A682:  MOVLB  7
0A684:  BRA    A740
0A686:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A688:  MOVLB  7
0A68A:  MOVF   x3C,W
0A68C:  MULLW  04
0A68E:  MOVF   FF3,W
0A690:  CLRF   03
0A692:  ADDLW  9E
0A694:  MOVWF  FE9
0A696:  MOVLW  07
0A698:  ADDWFC 03,W
0A69A:  MOVWF  FEA
0A69C:  MOVFF  FEF,8C1
0A6A0:  MOVFF  FEC,8C2
0A6A4:  MOVFF  FEC,8C3
0A6A8:  MOVFF  FEC,8C4
0A6AC:  BCF    FD8.0
0A6AE:  RLCF   x3C,W
0A6B0:  CLRF   03
0A6B2:  ADDLW  6E
0A6B4:  MOVWF  FE9
0A6B6:  MOVLW  07
0A6B8:  ADDWFC 03,W
0A6BA:  MOVWF  FEA
0A6BC:  MOVFF  FEC,03
0A6C0:  MOVF   FED,F
0A6C2:  MOVFF  FEF,01
0A6C6:  MOVLB  8
0A6C8:  MOVF   xC4,F
0A6CA:  BNZ   A6DE
0A6CC:  MOVF   xC3,F
0A6CE:  BNZ   A6DE
0A6D0:  MOVF   03,W
0A6D2:  SUBWF  xC2,W
0A6D4:  BNC   A73E
0A6D6:  BNZ   A6DE
0A6D8:  MOVF   01,W
0A6DA:  SUBWF  xC1,W
0A6DC:  BNC   A73E
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A6DE:  BCF    FD8.0
0A6E0:  MOVLB  7
0A6E2:  RLCF   x3C,W
0A6E4:  CLRF   03
0A6E6:  ADDLW  62
0A6E8:  MOVWF  01
0A6EA:  MOVLW  07
0A6EC:  ADDWFC 03,F
0A6EE:  MOVLB  8
0A6F0:  MOVFF  03,8C2
0A6F4:  BCF    FD8.0
0A6F6:  MOVLB  7
0A6F8:  RLCF   x3C,W
0A6FA:  CLRF   03
0A6FC:  ADDLW  9A
0A6FE:  MOVWF  FE9
0A700:  MOVLW  07
0A702:  ADDWFC 03,W
0A704:  MOVWF  FEA
0A706:  MOVFF  FEC,03
0A70A:  MOVF   FED,F
0A70C:  MOVFF  FEF,8C3
0A710:  MOVLB  8
0A712:  MOVFF  8C2,FEA
0A716:  MOVFF  01,FE9
0A71A:  MOVFF  03,FEC
0A71E:  MOVF   FED,F
0A720:  MOVFF  8C3,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A724:  BCF    FD8.0
0A726:  MOVLB  7
0A728:  RLCF   x3C,W
0A72A:  CLRF   03
0A72C:  ADDLW  B7
0A72E:  MOVWF  FE9
0A730:  MOVLW  07
0A732:  ADDWFC 03,W
0A734:  MOVWF  FEA
0A736:  CLRF   FEC
0A738:  MOVF   FED,F
0A73A:  CLRF   FEF
0A73C:  MOVLB  8
....................                } 
....................                break; 
0A73E:  MOVLB  7
....................             } 
....................          } 
0A740:  MOVLB  0
0A742:  BRA    A234
0A744:  MOVLB  7
....................       } 
....................    } 
0A746:  BRA    A764
0A748:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A74A:  BCF    FD8.0
0A74C:  MOVLB  7
0A74E:  RLCF   x3C,W
0A750:  CLRF   03
0A752:  ADDLW  92
0A754:  MOVWF  FE9
0A756:  MOVLW  07
0A758:  ADDWFC 03,W
0A75A:  MOVWF  FEA
0A75C:  CLRF   FEC
0A75E:  MOVF   FED,F
0A760:  MOVLW  01
0A762:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A764:  BCF    FD8.0
0A766:  RLCF   x3C,W
0A768:  CLRF   03
0A76A:  ADDLW  92
0A76C:  MOVWF  FE9
0A76E:  MOVLW  07
0A770:  ADDWFC 03,W
0A772:  MOVWF  FEA
0A774:  MOVFF  FEC,8C2
0A778:  MOVF   FED,F
0A77A:  MOVFF  FEF,8C1
0A77E:  MOVLB  8
0A780:  DECFSZ xC1,W
0A782:  BRA    A794
0A784:  MOVF   xC2,F
0A786:  BNZ   A794
....................       wrt_m_error(); 
0A788:  MOVLB  0
0A78A:  CALL   8FC0
....................       msg_mer(); 
0A78E:  CALL   9D42
0A792:  MOVLB  8
....................    } 
0A794:  MOVLB  0
0A796:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
16C82:  MOVF   44,F
16C84:  BNZ   16C92
16C86:  MOVF   45,F
16C88:  BNZ   16C92
16C8A:  MOVF   46,F
16C8C:  BNZ   16C92
16C8E:  MOVF   47,F
16C90:  BZ    16CBE
16C92:  MOVF   47,F
16C94:  BNZ   16CBE
16C96:  MOVF   46,W
16C98:  SUBLW  00
16C9A:  BNC   16CBE
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
16C9C:  MOVFF  86F,8B1
16CA0:  MOVFF  870,8B2
16CA4:  MOVFF  47,8B6
16CA8:  MOVFF  46,8B5
16CAC:  MOVFF  45,8B4
16CB0:  MOVFF  44,8B3
16CB4:  MOVFF  871,8B7
16CB8:  CALL   9DB8
....................    } 
16CBC:  BRA    16D3A
....................    else if(arg==0) 
16CBE:  MOVF   44,F
16CC0:  BNZ   16D36
16CC2:  MOVF   45,F
16CC4:  BNZ   16D36
16CC6:  MOVF   46,F
16CC8:  BNZ   16D36
16CCA:  MOVF   47,F
16CCC:  BNZ   16D36
....................    { 
....................       m_lin_pos[motor]=0; 
16CCE:  BCF    FD8.0
16CD0:  MOVLB  7
16CD2:  RLCF   x3C,W
16CD4:  CLRF   03
16CD6:  ADDLW  AF
16CD8:  MOVWF  FE9
16CDA:  MOVLW  07
16CDC:  ADDWFC 03,W
16CDE:  MOVWF  FEA
16CE0:  CLRF   FEC
16CE2:  MOVF   FED,F
16CE4:  CLRF   FEF
....................       switch (motor){ 
16CE6:  MOVF   x3C,W
16CE8:  XORLW  00
16CEA:  MOVLB  0
16CEC:  BZ    16CF4
16CEE:  XORLW  01
16CF0:  BZ    16D06
16CF2:  BRA    16D16
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
16CF4:  MOVLW  B6
16CF6:  MOVLB  8
16CF8:  MOVWF  xD8
16CFA:  CLRF   xDA
16CFC:  CLRF   xD9
16CFE:  MOVLB  0
16D00:  CALL   502C
....................             break; 
16D04:  BRA    16D16
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
16D06:  MOVLW  B8
16D08:  MOVLB  8
16D0A:  MOVWF  xD8
16D0C:  CLRF   xDA
16D0E:  CLRF   xD9
16D10:  MOVLB  0
16D12:  CALL   502C
....................             break; 
....................       }  
....................       m_error[motor]=0; 
16D16:  BCF    FD8.0
16D18:  MOVLB  7
16D1A:  RLCF   x3C,W
16D1C:  CLRF   03
16D1E:  ADDLW  92
16D20:  MOVWF  FE9
16D22:  MOVLW  07
16D24:  ADDWFC 03,W
16D26:  MOVWF  FEA
16D28:  CLRF   FEC
16D2A:  MOVF   FED,F
16D2C:  CLRF   FEF
....................       wrt_m_error(); 
16D2E:  MOVLB  0
16D30:  CALL   8FC0
....................    } 
16D34:  BRA    16D3A
....................    else cmd_arg(); 
16D36:  CALL   B070
16D3A:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
1872C:  MOVLW  01
1872E:  MOVLB  8
18730:  MOVWF  xD6
18732:  MOVLB  0
18734:  CALL   8A10
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18738:  MOVLW  FA
1873A:  MOVLB  9
1873C:  MOVWF  xD6
1873E:  MOVLB  0
18740:  CALL   2972
....................       switch(motor) 
18744:  MOVLB  7
18746:  MOVF   x3C,W
18748:  XORLW  00
1874A:  MOVLB  0
1874C:  BZ    18754
1874E:  XORLW  01
18750:  BZ    18766
18752:  BRA    18776
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18754:  MOVLB  8
18756:  CLRF   x6F
18758:  BTFSC  F81.4
1875A:  INCF   x6F,F
....................             chanA = input(ENC1_PHA); 
1875C:  CLRF   x70
1875E:  BTFSC  F81.1
18760:  INCF   x70,F
....................             break; 
18762:  MOVLB  0
18764:  BRA    18776
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18766:  MOVLB  8
18768:  CLRF   x6F
1876A:  BTFSC  F81.5
1876C:  INCF   x6F,F
....................             chanA = input(ENC2_PHA); 
1876E:  CLRF   x70
18770:  BTFSC  F81.2
18772:  INCF   x70,F
....................             break; 
18774:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18776:  MOVLW  9C
18778:  MOVWF  FF6
1877A:  MOVLW  1A
1877C:  MOVWF  FF7
1877E:  MOVLW  00
18780:  MOVWF  FF8
18782:  CLRF   1B
18784:  BTFSC  FF2.7
18786:  BSF    1B.7
18788:  BCF    FF2.7
1878A:  MOVLW  04
1878C:  MOVLB  A
1878E:  MOVWF  x25
18790:  MOVLB  0
18792:  CALL   101E
18796:  BTFSC  1B.7
18798:  BSF    FF2.7
1879A:  CLRF   1B
1879C:  BTFSC  FF2.7
1879E:  BSF    1B.7
187A0:  BCF    FF2.7
187A2:  MOVFF  86F,A25
187A6:  MOVLW  1B
187A8:  MOVLB  A
187AA:  MOVWF  x26
187AC:  MOVLB  0
187AE:  CALL   0FA0
187B2:  BTFSC  1B.7
187B4:  BSF    FF2.7
187B6:  MOVLW  A2
187B8:  MOVWF  FF6
187BA:  MOVLW  1A
187BC:  MOVWF  FF7
187BE:  MOVLW  00
187C0:  MOVWF  FF8
187C2:  CLRF   1B
187C4:  BTFSC  FF2.7
187C6:  BSF    1B.7
187C8:  BCF    FF2.7
187CA:  MOVLW  07
187CC:  MOVLB  A
187CE:  MOVWF  x25
187D0:  MOVLB  0
187D2:  CALL   101E
187D6:  BTFSC  1B.7
187D8:  BSF    FF2.7
187DA:  CLRF   1B
187DC:  BTFSC  FF2.7
187DE:  BSF    1B.7
187E0:  BCF    FF2.7
187E2:  MOVFF  870,A25
187E6:  MOVLW  1B
187E8:  MOVLB  A
187EA:  MOVWF  x26
187EC:  MOVLB  0
187EE:  CALL   0FA0
187F2:  BTFSC  1B.7
187F4:  BSF    FF2.7
187F6:  MOVLW  0D
187F8:  BTFSS  F9E.4
187FA:  BRA    187F8
187FC:  MOVWF  FAD
187FE:  MOVLW  0A
18800:  BTFSS  F9E.4
18802:  BRA    18800
18804:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
18806:  BTFSS  F9E.5
18808:  BRA    18816
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
1880A:  CALL   0E5C
1880E:  MOVF   01,W
18810:  SUBLW  1B
18812:  BNZ   18816
....................          { 
....................             break; 
18814:  BRA    18818
....................          } 
....................       } 
18816:  BRA    18738
....................    } 
....................  
....................    delay_ms(100); 
18818:  MOVLW  64
1881A:  MOVLB  9
1881C:  MOVWF  xD6
1881E:  MOVLB  0
18820:  CALL   2972
....................    enc_pwr(OFF); 
18824:  MOVLB  8
18826:  CLRF   xD6
18828:  MOVLB  0
1882A:  CALL   8A10
1882E:  GOTO   1884A (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A8F4:  BCF    FD8.0
0A8F6:  MOVLB  7
0A8F8:  RLCF   x3C,W
0A8FA:  CLRF   03
0A8FC:  ADDLW  62
0A8FE:  MOVWF  FE9
0A900:  MOVLW  07
0A902:  ADDWFC 03,W
0A904:  MOVWF  FEA
0A906:  MOVFF  FEC,8B0
0A90A:  MOVF   FED,F
0A90C:  MOVFF  FEF,8AF
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A910:  BCF    FD8.0
0A912:  RLCF   x3C,W
0A914:  CLRF   03
0A916:  ADDLW  72
0A918:  MOVWF  FE9
0A91A:  MOVLW  07
0A91C:  ADDWFC 03,W
0A91E:  MOVWF  FEA
0A920:  MOVFF  FEC,8C6
0A924:  MOVF   FED,F
0A926:  MOVFF  FEF,8C5
0A92A:  BCF    FD8.0
0A92C:  RLCF   x3C,W
0A92E:  CLRF   03
0A930:  ADDLW  5E
0A932:  MOVWF  FE9
0A934:  MOVLW  07
0A936:  ADDWFC 03,W
0A938:  MOVWF  FEA
0A93A:  MOVFF  FEC,03
0A93E:  MOVF   FED,F
0A940:  MOVFF  FEF,8C7
0A944:  MOVFF  03,8B4
0A948:  MOVFF  03,8C8
0A94C:  MOVLB  0
0A94E:  CALL   2D36
0A952:  MOVFF  02,8AE
0A956:  MOVFF  01,8AD
....................    e_mode[motor] = 0;                          // motor steps 
0A95A:  BCF    FD8.0
0A95C:  MOVLB  7
0A95E:  RLCF   x3C,W
0A960:  CLRF   03
0A962:  ADDLW  62
0A964:  MOVWF  FE9
0A966:  MOVLW  07
0A968:  ADDWFC 03,W
0A96A:  MOVWF  FEA
0A96C:  CLRF   FEC
0A96E:  MOVF   FED,F
0A970:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A972:  MOVLB  8
0A974:  CLRF   xB1
0A976:  MOVFF  8AC,8B2
0A97A:  CLRF   xB6
0A97C:  CLRF   xB5
0A97E:  MOVFF  8AE,8B4
0A982:  MOVFF  8AD,8B3
0A986:  MOVLW  01
0A988:  MOVWF  xB7
0A98A:  MOVLB  0
0A98C:  CALL   9DB8
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A990:  MOVLW  01
0A992:  MOVLB  8
0A994:  MOVWF  xD6
0A996:  MOVLB  0
0A998:  CALL   8A10
....................    delay_ms(100); 
0A99C:  MOVLW  64
0A99E:  MOVLB  9
0A9A0:  MOVWF  xD6
0A9A2:  MOVLB  0
0A9A4:  CALL   2972
....................    poll_index(); 
0A9A8:  BRA    A7C2
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A9AA:  BCF    FD8.0
0A9AC:  MOVLB  7
0A9AE:  RLCF   x3C,W
0A9B0:  CLRF   03
0A9B2:  ADDLW  5A
0A9B4:  MOVWF  FE9
0A9B6:  MOVLW  07
0A9B8:  ADDWFC 03,W
0A9BA:  MOVWF  FEA
0A9BC:  MOVFF  FEC,8B2
0A9C0:  MOVF   FED,F
0A9C2:  MOVFF  FEF,8B1
0A9C6:  MOVLW  02
0A9C8:  MOVLB  8
0A9CA:  ADDWF  xB1,W
0A9CC:  MOVWF  xAD
0A9CE:  MOVLW  00
0A9D0:  ADDWFC xB2,W
0A9D2:  MOVWF  xAE
....................    e_mode[motor] = 3; 
0A9D4:  BCF    FD8.0
0A9D6:  MOVLB  7
0A9D8:  RLCF   x3C,W
0A9DA:  CLRF   03
0A9DC:  ADDLW  62
0A9DE:  MOVWF  FE9
0A9E0:  MOVLW  07
0A9E2:  ADDWFC 03,W
0A9E4:  MOVWF  FEA
0A9E6:  CLRF   FEC
0A9E8:  MOVF   FED,F
0A9EA:  MOVLW  03
0A9EC:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A9EE:  MOVLB  8
0A9F0:  CLRF   xB1
0A9F2:  MOVFF  8AC,8B2
0A9F6:  CLRF   xB6
0A9F8:  CLRF   xB5
0A9FA:  MOVFF  8AE,8B4
0A9FE:  MOVFF  8AD,8B3
0AA02:  MOVLW  01
0AA04:  MOVWF  xB7
0AA06:  MOVLB  0
0AA08:  CALL   9DB8
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0AA0C:  MOVFF  77F,8AE
0AA10:  MOVFF  77E,8AD
....................    e_mode[motor] = 0;                          // motor steps 
0AA14:  BCF    FD8.0
0AA16:  MOVLB  7
0AA18:  RLCF   x3C,W
0AA1A:  CLRF   03
0AA1C:  ADDLW  62
0AA1E:  MOVWF  FE9
0AA20:  MOVLW  07
0AA22:  ADDWFC 03,W
0AA24:  MOVWF  FEA
0AA26:  CLRF   FEC
0AA28:  MOVF   FED,F
0AA2A:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0AA2C:  MOVLB  8
0AA2E:  CLRF   xB1
0AA30:  MOVFF  8AC,8B2
0AA34:  CLRF   xB6
0AA36:  CLRF   xB5
0AA38:  MOVFF  8AE,8B4
0AA3C:  MOVFF  8AD,8B3
0AA40:  MOVLW  01
0AA42:  MOVWF  xB7
0AA44:  MOVLB  0
0AA46:  CALL   9DB8
....................  
....................    e_pos[motor] = 0; 
0AA4A:  BCF    FD8.0
0AA4C:  MOVLB  7
0AA4E:  RLCF   x3C,W
0AA50:  CLRF   03
0AA52:  ADDLW  BB
0AA54:  MOVWF  FE9
0AA56:  MOVLW  07
0AA58:  ADDWFC 03,W
0AA5A:  MOVWF  FEA
0AA5C:  CLRF   FEC
0AA5E:  MOVF   FED,F
0AA60:  CLRF   FEF
....................    e_port[motor] = 1; 
0AA62:  BCF    FD8.0
0AA64:  RLCF   x3C,W
0AA66:  CLRF   03
0AA68:  ADDLW  BF
0AA6A:  MOVWF  FE9
0AA6C:  MOVLW  07
0AA6E:  ADDWFC 03,W
0AA70:  MOVWF  FEA
0AA72:  CLRF   FEC
0AA74:  MOVF   FED,F
0AA76:  MOVLW  01
0AA78:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0AA7A:  BCF    FD8.0
0AA7C:  RLCF   x3C,W
0AA7E:  CLRF   03
0AA80:  ADDLW  62
0AA82:  MOVWF  FE9
0AA84:  MOVLW  07
0AA86:  ADDWFC 03,W
0AA88:  MOVWF  FEA
0AA8A:  MOVFF  8B0,FEC
0AA8E:  MOVF   FED,F
0AA90:  MOVFF  8AF,FEF
0AA94:  MOVLB  0
0AA96:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0DE36:  BCF    FD8.0
0DE38:  MOVLB  7
0DE3A:  RLCF   x3C,W
0DE3C:  CLRF   03
0DE3E:  ADDLW  5A
0DE40:  MOVWF  FE9
0DE42:  MOVLW  07
0DE44:  ADDWFC 03,W
0DE46:  MOVWF  FEA
0DE48:  MOVFF  FEC,873
0DE4C:  MOVF   FED,F
0DE4E:  MOVFF  FEF,872
0DE52:  MOVLW  02
0DE54:  MOVLB  8
0DE56:  ADDWF  x72,W
0DE58:  MOVWF  x70
0DE5A:  MOVLW  00
0DE5C:  ADDWFC x73,W
0DE5E:  MOVWF  x71
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0DE60:  CLRF   xB1
0DE62:  MOVFF  86F,8B2
0DE66:  CLRF   xB6
0DE68:  CLRF   xB5
0DE6A:  MOVFF  871,8B4
0DE6E:  MOVFF  870,8B3
0DE72:  MOVLW  02
0DE74:  MOVWF  xB7
0DE76:  MOVLB  0
0DE78:  CALL   9DB8
0DE7C:  GOTO   DEFC (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0AA98:  MOVF   2F,W
0AA9A:  SUBLW  02
0AA9C:  BNZ   AAA2
0AA9E:  MOVF   30,F
0AAA0:  BZ    AB02
....................    { 
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0AAA2:  MOVLW  AE
0AAA4:  MOVWF  FF6
0AAA6:  MOVLW  1A
0AAA8:  MOVWF  FF7
0AAAA:  MOVLW  00
0AAAC:  MOVWF  FF8
0AAAE:  CLRF   1B
0AAB0:  BTFSC  FF2.7
0AAB2:  BSF    1B.7
0AAB4:  BCF    FF2.7
0AAB6:  CALL   0DCC
0AABA:  BTFSC  1B.7
0AABC:  BSF    FF2.7
....................       motor=0; 
0AABE:  MOVLB  7
0AAC0:  CLRF   x3C
....................       align(0); 
0AAC2:  MOVLB  8
0AAC4:  CLRF   xAC
0AAC6:  MOVLB  0
0AAC8:  RCALL  A8F4
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0AACA:  MOVLW  01
0AACC:  MOVLB  7
0AACE:  MOVWF  x3C
....................       move_motor(0,0,22000,1); 
0AAD0:  MOVLB  8
0AAD2:  CLRF   xB1
0AAD4:  CLRF   xB2
0AAD6:  CLRF   xB6
0AAD8:  CLRF   xB5
0AADA:  MOVLW  55
0AADC:  MOVWF  xB4
0AADE:  MOVLW  F0
0AAE0:  MOVWF  xB3
0AAE2:  MOVLW  01
0AAE4:  MOVWF  xB7
0AAE6:  MOVLB  0
0AAE8:  CALL   9DB8
....................        
....................       m_lin_pos[1]=0; 
0AAEC:  MOVLB  7
0AAEE:  CLRF   xB2
0AAF0:  CLRF   xB1
....................       write16(ADDR_M2_LIN_POS,0); 
0AAF2:  MOVLW  B8
0AAF4:  MOVLB  8
0AAF6:  MOVWF  xD8
0AAF8:  CLRF   xDA
0AAFA:  CLRF   xD9
0AAFC:  MOVLB  0
0AAFE:  CALL   502C
....................    } 
0AB02:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0BF74:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BF76:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0BF78:  BCF    F8E.3
....................   delay_ms(20); 
0BF7A:  MOVLW  14
0BF7C:  MOVLB  9
0BF7E:  MOVWF  xD6
0BF80:  MOVLB  0
0BF82:  CALL   2972
....................   output_bit(VMOT,  OFF); 
0BF86:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0BF88:  BCF    F8E.2
0BF8A:  GOTO   BFE0 (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BF8E:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BF90:  BSF    F8E.1
....................   delay_ms(50); 
0BF92:  MOVLW  32
0BF94:  MOVLB  9
0BF96:  MOVWF  xD6
0BF98:  MOVLB  0
0BF9A:  CALL   2972
....................   output_bit(HB_IN1,ON);           
0BF9E:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BFA0:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0BFA2:  BSF    F8E.3
0BFA4:  GOTO   BFE0 (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BFA8:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BFAA:  BSF    F8E.1
....................   delay_ms(50); 
0BFAC:  MOVLW  32
0BFAE:  MOVLB  9
0BFB0:  MOVWF  xD6
0BFB2:  MOVLB  0
0BFB4:  CALL   2972
....................   output_bit(HB_IN1,OFF);           
0BFB8:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0BFBA:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0BFBC:  BSF    F8E.3
0BFBE:  GOTO   BFE0 (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0BFC2:  MOVLB  8
0BFC4:  MOVF   x9F,W
0BFC6:  XORLW  00
0BFC8:  MOVLB  0
0BFCA:  BZ    BFD6
0BFCC:  XORLW  01
0BFCE:  BZ    BFDA
0BFD0:  XORLW  03
0BFD2:  BZ    BFDE
0BFD4:  BRA    BFE0
....................       case 0:  HB_all_OFF(); 
0BFD6:  BRA    BF74
....................          break; 
0BFD8:  BRA    BFE0
....................       case 1:  HB_m1_ON(); 
0BFDA:  BRA    BF8E
....................          break; 
0BFDC:  BRA    BFE0
....................       case 2:  HB_m2_ON(); 
0BFDE:  BRA    BFA8
....................          break; 
....................    } 
0BFE0:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
159AA:  MOVLB  8
159AC:  CLRF   x73
159AE:  CLRF   x74
159B0:  CLRF   x75
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
159B2:  MOVLB  0
159B4:  BRA    15940
159B6:  MOVFF  01,874
....................       if (serChar) 
159BA:  MOVLB  8
159BC:  MOVF   x74,F
159BE:  BZ    159E8
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
159C0:  MOVF   x74,W
159C2:  SUBLW  24
159C4:  BNZ   159CE
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
159C6:  MOVLW  02
159C8:  MOVWF  x75
....................             break; 
159CA:  BRA    159F4
....................          }else if (serChar == 'D'){ 
159CC:  BRA    159E8
159CE:  MOVF   x74,W
159D0:  SUBLW  44
159D2:  BNZ   159E4
....................             wakeup_char_is_D = 1; 
159D4:  MOVLW  01
159D6:  MOVLB  7
159D8:  MOVWF  xC9
....................             wakeUpReason = WAKE_UP_GOOD; 
159DA:  MOVLW  02
159DC:  MOVLB  8
159DE:  MOVWF  x75
....................             break; 
159E0:  BRA    159F4
....................          }else 
159E2:  BRA    159E8
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
159E4:  MOVLW  01
159E6:  MOVWF  x75
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
159E8:  INCF   x73,F
159EA:  MOVF   x73,W
159EC:  SUBLW  02
159EE:  BC    159F2
....................       { 
....................          break; 
159F0:  BRA    159F4
....................       } 
159F2:  BRA    159B2
....................    } 
....................  
....................    return (wakeUpReason); 
159F4:  MOVFF  875,01
159F8:  MOVLB  0
159FA:  GOTO   15A0E (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
158D8:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
158DA:  BSF    49.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
158DC:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
158DE:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
158E0:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
158E2:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
158E4:  BSF    FF2.6
158E6:  GOTO   158F2 (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
158EA:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
158EC:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
158EE:  BCF    49.0
....................    set_usart_int(); 
158F0:  BRA    158D8
....................    kill_wd(); 
158F2:  CALL   3158
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
158F6:  BSF    FF2.4
....................    sleep();  
158F8:  MOVFF  FD3,00
158FC:  BCF    FD1.7
158FE:  BCF    FD3.7
15900:  SLEEP 
15902:  MOVFF  00,FD3
....................    delay_cycles(1); 
15906:  NOP   
15908:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
159FE:  MOVLB  8
15A00:  CLRF   x72
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
15A02:  MOVLB  0
15A04:  RCALL  1590A
....................  
....................    if (TRUE != rtc_alarm) 
15A06:  BTFSC  49.0
15A08:  BRA    15AC6
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15A0A:  RCALL  1590A
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15A0C:  BRA    159AA
15A0E:  MOVFF  01,872
....................       if (WAKE_UP_GOOD == serWakeupReason) 
15A12:  MOVLB  8
15A14:  MOVF   x72,W
15A16:  SUBLW  02
15A18:  BNZ   15ABE
....................       { 
....................          sleep_mode = FALSE; 
15A1A:  BCF    49.1
....................          start_heartbeat(); 
15A1C:  MOVLB  0
15A1E:  CALL   2962
....................          init_hardware(); 
15A22:  CALL   299C
....................          init_rtc();                      // This is the FAT RTC 
15A26:  CALL   356A
....................          sd_status = init_sdcard(); 
15A2A:  CALL   5092
15A2E:  MOVFF  01,2D8
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
15A32:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
15A34:  MOVLW  01
15A36:  MOVWF  1E
15A38:  MOVLW  A3
15A3A:  MOVWF  1D
15A3C:  MOVLW  E4
15A3E:  MOVWF  FF6
15A40:  MOVLW  1A
15A42:  MOVWF  FF7
15A44:  MOVLW  00
15A46:  MOVWF  FF8
15A48:  CALL   5116
....................          record_event(); 
15A4C:  CALL   851A
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15A50:  CLRF   32
15A52:  MOVLW  01
15A54:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
15A56:  MOVLW  02
15A58:  MOVLB  8
15A5A:  MOVWF  x73
15A5C:  MOVFF  31,874
15A60:  MOVLB  0
15A62:  CALL   3474
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
15A66:  MOVLB  7
15A68:  MOVF   xC9,F
15A6A:  BZ    15A8C
....................             file_list(file_ptr_rel_new); 
15A6C:  MOVLW  03
15A6E:  MOVLB  8
15A70:  MOVWF  x74
15A72:  MOVWF  x73
15A74:  MOVLB  0
15A76:  CALL   B896
....................             f_unlink(file_ptr_rel_new); 
15A7A:  MOVLW  03
15A7C:  MOVLB  8
15A7E:  MOVWF  x74
15A80:  MOVWF  x73
15A82:  MOVLB  0
15A84:  CALL   BA10
....................              
....................             wakeup_char_is_D = 0; 
15A88:  MOVLB  7
15A8A:  CLRF   xC9
....................          } 
....................          if(sd_status>0) 
15A8C:  MOVLB  2
15A8E:  MOVF   xD8,F
15A90:  BZ    15A9A
....................          { 
....................             msg_card_fail(); 
15A92:  MOVLB  0
15A94:  CALL   50D8
15A98:  MOVLB  2
....................          } 
....................  
....................          fprintf(COM_A, "@RST\r\n"); 
15A9A:  MOVLW  06
15A9C:  MOVWF  FF6
15A9E:  MOVLW  1B
15AA0:  MOVWF  FF7
15AA2:  MOVLW  00
15AA4:  MOVWF  FF8
15AA6:  CLRF   1B
15AA8:  BTFSC  FF2.7
15AAA:  BSF    1B.7
15AAC:  BCF    FF2.7
15AAE:  MOVLB  0
15AB0:  CALL   0DCC
15AB4:  BTFSC  1B.7
15AB6:  BSF    FF2.7
....................          reset_cpu(); 
15AB8:  RESET
....................       } 
15ABA:  BRA    15AC6
15ABC:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
15ABE:  DECFSZ x72,W
15AC0:  BRA    15AC8
....................          { 
....................             initilizeSleepState(); 
15AC2:  MOVLB  0
15AC4:  RCALL  158EA
15AC6:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
15AC8:  MOVLW  00
15ACA:  BTFSC  49.0
15ACC:  MOVLW  01
15ACE:  MOVWF  01
15AD0:  MOVLB  0
15AD2:  GOTO   15ADC (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
15AD6:  RCALL  1586E
....................    initilizeSleepState(); 
15AD8:  RCALL  158EA
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
15ADA:  BRA    159FE
15ADC:  DECFSZ 01,W
15ADE:  BRA    15AE4
....................       { 
....................          rtc_alarm = FALSE; 
15AE0:  BCF    49.0
....................          break; 
15AE2:  BRA    15AEA
....................       } 
....................  
....................       blip(); 
15AE4:  RCALL  1590A
....................       blip(); 
15AE6:  RCALL  1590A
15AE8:  BRA    15ADA
....................    } 
15AEA:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0ABFE:  MOVF   FD0,W
0AC00:  ANDLW  0F
0AC02:  BTFSS  FD0.4
0AC04:  MOVLW  00
0AC06:  BSF    FD0.0
0AC08:  BSF    FD0.1
0AC0A:  BSF    FD0.4
0AC0C:  BSF    FD8.3
0AC0E:  BSF    FD8.4
0AC10:  ADDLW  F0
0AC12:  BTFSC  FD8.0
0AC14:  BRA    ADE4
0AC16:  ADDLW  10
0AC18:  GOTO   ADE8
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0AC1C:  MOVLW  0E
0AC1E:  MOVWF  FF6
0AC20:  MOVLW  1B
0AC22:  MOVWF  FF7
0AC24:  MOVLW  00
0AC26:  MOVWF  FF8
0AC28:  CLRF   1B
0AC2A:  BTFSC  FF2.7
0AC2C:  BSF    1B.7
0AC2E:  BCF    FF2.7
0AC30:  CALL   0DCC
0AC34:  BTFSC  1B.7
0AC36:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AC38:  MOVLW  01
0AC3A:  MOVWF  1E
0AC3C:  MOVLW  A3
0AC3E:  MOVWF  1D
0AC40:  MOVLW  16
0AC42:  MOVWF  FF6
0AC44:  MOVLW  1B
0AC46:  MOVWF  FF7
0AC48:  MOVLW  00
0AC4A:  MOVWF  FF8
0AC4C:  CALL   5116
....................          record_event(); 
0AC50:  CALL   851A
....................          recovery(); 
0AC54:  RCALL  AA98
....................          break; 
0AC56:  BRA    ADE4
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AC58:  MOVLW  34
0AC5A:  MOVWF  FF6
0AC5C:  MOVLW  1B
0AC5E:  MOVWF  FF7
0AC60:  MOVLW  00
0AC62:  MOVWF  FF8
0AC64:  CLRF   1B
0AC66:  BTFSC  FF2.7
0AC68:  BSF    1B.7
0AC6A:  BCF    FF2.7
0AC6C:  CALL   0DCC
0AC70:  BTFSC  1B.7
0AC72:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AC74:  MOVLW  01
0AC76:  MOVWF  1E
0AC78:  MOVLW  A3
0AC7A:  MOVWF  1D
0AC7C:  MOVLW  3C
0AC7E:  MOVWF  FF6
0AC80:  MOVLW  1B
0AC82:  MOVWF  FF7
0AC84:  MOVLW  00
0AC86:  MOVWF  FF8
0AC88:  CALL   5116
....................          record_event(); 
0AC8C:  CALL   851A
....................          recovery(); 
0AC90:  RCALL  AA98
....................          break; 
0AC92:  BRA    ADE4
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AC94:  MOVLW  5C
0AC96:  MOVWF  FF6
0AC98:  MOVLW  1B
0AC9A:  MOVWF  FF7
0AC9C:  MOVLW  00
0AC9E:  MOVWF  FF8
0ACA0:  CLRF   1B
0ACA2:  BTFSC  FF2.7
0ACA4:  BSF    1B.7
0ACA6:  BCF    FF2.7
0ACA8:  CALL   0DCC
0ACAC:  BTFSC  1B.7
0ACAE:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0ACB0:  MOVLW  01
0ACB2:  MOVWF  1E
0ACB4:  MOVLW  A3
0ACB6:  MOVWF  1D
0ACB8:  MOVLW  64
0ACBA:  MOVWF  FF6
0ACBC:  MOVLW  1B
0ACBE:  MOVWF  FF7
0ACC0:  MOVLW  00
0ACC2:  MOVWF  FF8
0ACC4:  MOVLW  05
0ACC6:  MOVLB  8
0ACC8:  MOVWF  xD5
0ACCA:  MOVLB  0
0ACCC:  RCALL  AB04
0ACCE:  MOVLW  10
0ACD0:  MOVWF  FE9
0ACD2:  MOVFF  26,8E1
0ACD6:  MOVFF  25,8E0
0ACDA:  RCALL  AB36
0ACDC:  MOVLW  6C
0ACDE:  MOVWF  FF6
0ACE0:  MOVLW  1B
0ACE2:  MOVWF  FF7
0ACE4:  MOVLW  00
0ACE6:  MOVWF  FF8
0ACE8:  MOVLW  20
0ACEA:  MOVLB  8
0ACEC:  MOVWF  xD5
0ACEE:  MOVLB  0
0ACF0:  RCALL  AB04
....................          record_event(); 
0ACF2:  CALL   851A
....................          break; 
0ACF6:  BRA    ADE4
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0ACF8:  MOVLW  8E
0ACFA:  MOVWF  FF6
0ACFC:  MOVLW  1B
0ACFE:  MOVWF  FF7
0AD00:  MOVLW  00
0AD02:  MOVWF  FF8
0AD04:  CLRF   1B
0AD06:  BTFSC  FF2.7
0AD08:  BSF    1B.7
0AD0A:  BCF    FF2.7
0AD0C:  CALL   0DCC
0AD10:  BTFSC  1B.7
0AD12:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0AD14:  MOVLW  01
0AD16:  MOVWF  1E
0AD18:  MOVLW  A3
0AD1A:  MOVWF  1D
0AD1C:  MOVLW  96
0AD1E:  MOVWF  FF6
0AD20:  MOVLW  1B
0AD22:  MOVWF  FF7
0AD24:  MOVLW  00
0AD26:  MOVWF  FF8
0AD28:  CALL   5116
....................          record_event(); 
0AD2C:  CALL   851A
....................          break; 
0AD30:  BRA    ADE4
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0AD32:  MOVLW  BA
0AD34:  MOVWF  FF6
0AD36:  MOVLW  1B
0AD38:  MOVWF  FF7
0AD3A:  MOVLW  00
0AD3C:  MOVWF  FF8
0AD3E:  CLRF   1B
0AD40:  BTFSC  FF2.7
0AD42:  BSF    1B.7
0AD44:  BCF    FF2.7
0AD46:  CALL   0DCC
0AD4A:  BTFSC  1B.7
0AD4C:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AD4E:  MOVLW  01
0AD50:  MOVWF  1E
0AD52:  MOVLW  A3
0AD54:  MOVWF  1D
0AD56:  MOVLW  C2
0AD58:  MOVWF  FF6
0AD5A:  MOVLW  1B
0AD5C:  MOVWF  FF7
0AD5E:  MOVLW  00
0AD60:  MOVWF  FF8
0AD62:  CALL   5116
....................          record_event(); 
0AD66:  CALL   851A
....................          recovery(); 
0AD6A:  RCALL  AA98
....................          break; 
0AD6C:  BRA    ADE4
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AD6E:  MOVLW  DE
0AD70:  MOVWF  FF6
0AD72:  MOVLW  1B
0AD74:  MOVWF  FF7
0AD76:  MOVLW  00
0AD78:  MOVWF  FF8
0AD7A:  CLRF   1B
0AD7C:  BTFSC  FF2.7
0AD7E:  BSF    1B.7
0AD80:  BCF    FF2.7
0AD82:  CALL   0DCC
0AD86:  BTFSC  1B.7
0AD88:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AD8A:  MOVLW  01
0AD8C:  MOVWF  1E
0AD8E:  MOVLW  A3
0AD90:  MOVWF  1D
0AD92:  MOVLW  E6
0AD94:  MOVWF  FF6
0AD96:  MOVLW  1B
0AD98:  MOVWF  FF7
0AD9A:  MOVLW  00
0AD9C:  MOVWF  FF8
0AD9E:  CALL   5116
....................          record_event(); 
0ADA2:  CALL   851A
....................          recovery(); 
0ADA6:  RCALL  AA98
....................          break; 
0ADA8:  BRA    ADE4
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0ADAA:  MOVLW  08
0ADAC:  MOVWF  FF6
0ADAE:  MOVLW  1C
0ADB0:  MOVWF  FF7
0ADB2:  MOVLW  00
0ADB4:  MOVWF  FF8
0ADB6:  CLRF   1B
0ADB8:  BTFSC  FF2.7
0ADBA:  BSF    1B.7
0ADBC:  BCF    FF2.7
0ADBE:  CALL   0DCC
0ADC2:  BTFSC  1B.7
0ADC4:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ADC6:  MOVLW  01
0ADC8:  MOVWF  1E
0ADCA:  MOVLW  A3
0ADCC:  MOVWF  1D
0ADCE:  MOVLW  10
0ADD0:  MOVWF  FF6
0ADD2:  MOVLW  1C
0ADD4:  MOVWF  FF7
0ADD6:  MOVLW  00
0ADD8:  MOVWF  FF8
0ADDA:  CALL   5116
....................          record_event(); 
0ADDE:  CALL   851A
....................          recovery(); 
0ADE2:  RCALL  AA98
....................          break; 
....................       }         
....................    } 
0ADE4:  GOTO   1B306 (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02B1A:  MOVLW  1E
02B1C:  MOVLB  8
02B1E:  MOVWF  x81
02B20:  MOVLB  0
02B22:  RCALL  2A2C
02B24:  MOVFF  02,30
02B28:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02B2C:  MOVLW  1C
02B2E:  MOVLB  8
02B30:  MOVWF  x81
02B32:  MOVLB  0
02B34:  RCALL  2A2C
02B36:  MOVFF  02,20
02B3A:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02B3E:  MOVLW  16
02B40:  MOVLB  8
02B42:  MOVWF  x81
02B44:  MOVLB  0
02B46:  RCALL  2A2C
02B48:  MOVFF  02,22
02B4C:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02B50:  MOVLW  14
02B52:  MOVLB  8
02B54:  MOVWF  x81
02B56:  MOVLB  0
02B58:  RCALL  2A2C
02B5A:  MOVFF  02,24
02B5E:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02B62:  MOVLB  8
02B64:  CLRF   x81
02B66:  MOVLB  0
02B68:  RCALL  2A2C
02B6A:  MOVFF  02,26
02B6E:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02B72:  MOVLW  18
02B74:  MOVLB  8
02B76:  MOVWF  x81
02B78:  MOVLB  0
02B7A:  RCALL  2A2C
02B7C:  MOVFF  02,28
02B80:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02B84:  MOVLW  02
02B86:  MOVLB  8
02B88:  MOVWF  xA1
02B8A:  MOVLB  0
02B8C:  RCALL  2A86
02B8E:  CLRF   32
02B90:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02B94:  MOVLW  28
02B96:  MOVLB  8
02B98:  MOVWF  xA1
02B9A:  MOVLB  0
02B9C:  RCALL  2A86
02B9E:  CLRF   34
02BA0:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02BA4:  MOVLW  12
02BA6:  MOVLB  8
02BA8:  MOVWF  x81
02BAA:  MOVLB  0
02BAC:  RCALL  2A2C
02BAE:  MOVFF  02,36
02BB2:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02BB6:  MOVLW  3A
02BB8:  MOVLB  8
02BBA:  MOVWF  x81
02BBC:  MOVLB  0
02BBE:  RCALL  2A2C
02BC0:  MOVFF  02,38
02BC4:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02BC8:  MOVLW  3C
02BCA:  MOVLB  8
02BCC:  MOVWF  x81
02BCE:  MOVLB  0
02BD0:  RCALL  2A2C
02BD2:  MOVFF  02,3A
02BD6:  MOVFF  01,39
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02BDA:  MOVLW  3E
02BDC:  MOVLB  8
02BDE:  MOVWF  x81
02BE0:  MOVLB  0
02BE2:  RCALL  2A2C
02BE4:  MOVFF  02,3C
02BE8:  MOVFF  01,3B
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02BEC:  MOVLW  40
02BEE:  MOVLB  8
02BF0:  MOVWF  x81
02BF2:  MOVLB  0
02BF4:  RCALL  2A2C
02BF6:  MOVFF  02,3E
02BFA:  MOVFF  01,3D
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02BFE:  MOVLW  42
02C00:  MOVLB  8
02C02:  MOVWF  x81
02C04:  MOVLB  0
02C06:  RCALL  2A2C
02C08:  MOVFF  02,40
02C0C:  MOVFF  01,3F
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02C10:  MOVLW  04
02C12:  MOVLB  8
02C14:  MOVWF  xA1
02C16:  MOVLB  0
02C18:  RCALL  2A86
02C1A:  MOVFF  01,729
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02C1E:  MOVLB  8
02C20:  CLRF   x70
02C22:  MOVLW  44
02C24:  MOVWF  x6F
02C26:  MOVLB  0
02C28:  RCALL  2AAC
02C2A:  MOVFF  03,3F4
02C2E:  MOVFF  02,3F3
02C32:  MOVFF  01,3F2
02C36:  MOVFF  00,3F1
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02C3A:  MOVLB  8
02C3C:  CLRF   x70
02C3E:  MOVLW  48
02C40:  MOVWF  x6F
02C42:  MOVLB  0
02C44:  RCALL  2AAC
02C46:  MOVFF  03,3F8
02C4A:  MOVFF  02,3F7
02C4E:  MOVFF  01,3F6
02C52:  MOVFF  00,3F5
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02C56:  MOVLB  8
02C58:  CLRF   x70
02C5A:  MOVLW  4C
02C5C:  MOVWF  x6F
02C5E:  MOVLB  0
02C60:  RCALL  2AAC
02C62:  MOVFF  03,3FC
02C66:  MOVFF  02,3FB
02C6A:  MOVFF  01,3FA
02C6E:  MOVFF  00,3F9
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02C72:  MOVLB  8
02C74:  CLRF   x70
02C76:  MOVLW  52
02C78:  MOVWF  x6F
02C7A:  MOVLB  0
02C7C:  RCALL  2AAC
02C7E:  MOVFF  03,400
02C82:  MOVFF  02,3FF
02C86:  MOVFF  01,3FE
02C8A:  MOVFF  00,3FD
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02C8E:  MOVLB  8
02C90:  CLRF   x70
02C92:  MOVLW  56
02C94:  MOVWF  x6F
02C96:  MOVLB  0
02C98:  RCALL  2AAC
02C9A:  MOVFF  03,404
02C9E:  MOVFF  02,403
02CA2:  MOVFF  01,402
02CA6:  MOVFF  00,401
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02CAA:  MOVLB  8
02CAC:  CLRF   x70
02CAE:  MOVLW  5A
02CB0:  MOVWF  x6F
02CB2:  MOVLB  0
02CB4:  RCALL  2AAC
02CB6:  MOVFF  03,408
02CBA:  MOVFF  02,407
02CBE:  MOVFF  01,406
02CC2:  MOVFF  00,405
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02CC6:  MOVLB  8
02CC8:  CLRF   x70
02CCA:  MOVLW  5E
02CCC:  MOVWF  x6F
02CCE:  MOVLB  0
02CD0:  RCALL  2AAC
02CD2:  MOVFF  03,40C
02CD6:  MOVFF  02,40B
02CDA:  MOVFF  01,40A
02CDE:  MOVFF  00,409
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02CE2:  MOVLB  8
02CE4:  CLRF   x70
02CE6:  MOVLW  62
02CE8:  MOVWF  x6F
02CEA:  MOVLB  0
02CEC:  RCALL  2AAC
02CEE:  MOVFF  03,410
02CF2:  MOVFF  02,40F
02CF6:  MOVFF  01,40E
02CFA:  MOVFF  00,40D
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02CFE:  MOVLW  20
02D00:  MOVLB  8
02D02:  MOVWF  x81
02D04:  MOVLB  0
02D06:  RCALL  2A2C
02D08:  MOVFF  02,2A
02D0C:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02D10:  MOVLW  22
02D12:  MOVLB  8
02D14:  MOVWF  x81
02D16:  MOVLB  0
02D18:  RCALL  2A2C
02D1A:  MOVFF  02,2C
02D1E:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02D22:  MOVLW  24
02D24:  MOVLB  8
02D26:  MOVWF  x81
02D28:  MOVLB  0
02D2A:  RCALL  2A2C
02D2C:  MOVFF  02,2E
02D30:  MOVFF  01,2D
02D34:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DC2E:  MOVLW  1C
0DC30:  MOVLB  8
0DC32:  MOVWF  xD8
0DC34:  CLRF   xDA
0DC36:  CLRF   xD9
0DC38:  MOVLB  0
0DC3A:  CALL   502C
....................    write16(ADDR_SAMPLE,0); 
0DC3E:  MOVLW  16
0DC40:  MOVLB  8
0DC42:  MOVWF  xD8
0DC44:  CLRF   xDA
0DC46:  CLRF   xD9
0DC48:  MOVLB  0
0DC4A:  CALL   502C
....................    write16(ADDR_INTERVAL,60); 
0DC4E:  MOVLW  14
0DC50:  MOVLB  8
0DC52:  MOVWF  xD8
0DC54:  CLRF   xDA
0DC56:  MOVLW  3C
0DC58:  MOVWF  xD9
0DC5A:  MOVLB  0
0DC5C:  CALL   502C
....................    write16(ADDR_SERIALNO,9999); 
0DC60:  MOVLB  8
0DC62:  CLRF   xD8
0DC64:  MOVLW  27
0DC66:  MOVWF  xDA
0DC68:  MOVLW  0F
0DC6A:  MOVWF  xD9
0DC6C:  MOVLB  0
0DC6E:  CALL   502C
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DC72:  MOVLW  18
0DC74:  MOVLB  8
0DC76:  MOVWF  xD8
0DC78:  MOVLW  0D
0DC7A:  MOVWF  xDA
0DC7C:  MOVLW  20
0DC7E:  MOVWF  xD9
0DC80:  MOVLB  0
0DC82:  CALL   502C
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DC86:  MOVLW  02
0DC88:  MOVLB  8
0DC8A:  MOVWF  x73
0DC8C:  MOVLW  01
0DC8E:  MOVWF  x74
0DC90:  MOVLB  0
0DC92:  CALL   3474
....................    write16(ADDR_MACRO_STEP, 0); 
0DC96:  MOVLW  3A
0DC98:  MOVLB  8
0DC9A:  MOVWF  xD8
0DC9C:  CLRF   xDA
0DC9E:  CLRF   xD9
0DCA0:  MOVLB  0
0DCA2:  CALL   502C
....................    write16(ADDR_COM_ERR,3); 
0DCA6:  MOVLW  3C
0DCA8:  MOVLB  8
0DCAA:  MOVWF  xD8
0DCAC:  CLRF   xDA
0DCAE:  MOVLW  03
0DCB0:  MOVWF  xD9
0DCB2:  MOVLB  0
0DCB4:  CALL   502C
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DCB8:  MOVLW  04
0DCBA:  MOVLB  8
0DCBC:  MOVWF  x73
0DCBE:  MOVLW  0A
0DCC0:  MOVWF  x74
0DCC2:  MOVLB  0
0DCC4:  CALL   3474
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DCC8:  MOVLB  8
0DCCA:  CLRF   x70
0DCCC:  MOVLW  44
0DCCE:  MOVWF  x6F
0DCD0:  CLRF   x74
0DCD2:  CLRF   x73
0DCD4:  CLRF   x72
0DCD6:  MOVLW  7F
0DCD8:  MOVWF  x71
0DCDA:  MOVLB  0
0DCDC:  CALL   CAD4
....................    write_float(ADDR_CAL_C1,0); 
0DCE0:  MOVLB  8
0DCE2:  CLRF   x70
0DCE4:  MOVLW  48
0DCE6:  MOVWF  x6F
0DCE8:  CLRF   x74
0DCEA:  CLRF   x73
0DCEC:  CLRF   x72
0DCEE:  CLRF   x71
0DCF0:  MOVLB  0
0DCF2:  CALL   CAD4
....................    write_float(ADDR_CAL_M2,1); 
0DCF6:  MOVLB  8
0DCF8:  CLRF   x70
0DCFA:  MOVLW  4C
0DCFC:  MOVWF  x6F
0DCFE:  CLRF   x74
0DD00:  CLRF   x73
0DD02:  CLRF   x72
0DD04:  MOVLW  7F
0DD06:  MOVWF  x71
0DD08:  MOVLB  0
0DD0A:  CALL   CAD4
....................    write_float(ADDR_CAL_C2,0); 
0DD0E:  MOVLB  8
0DD10:  CLRF   x70
0DD12:  MOVLW  52
0DD14:  MOVWF  x6F
0DD16:  CLRF   x74
0DD18:  CLRF   x73
0DD1A:  CLRF   x72
0DD1C:  CLRF   x71
0DD1E:  MOVLB  0
0DD20:  CALL   CAD4
....................    write_float(ADDR_CAL_M3,1); 
0DD24:  MOVLB  8
0DD26:  CLRF   x70
0DD28:  MOVLW  56
0DD2A:  MOVWF  x6F
0DD2C:  CLRF   x74
0DD2E:  CLRF   x73
0DD30:  CLRF   x72
0DD32:  MOVLW  7F
0DD34:  MOVWF  x71
0DD36:  MOVLB  0
0DD38:  CALL   CAD4
....................    write_float(ADDR_CAL_C3,0); 
0DD3C:  MOVLB  8
0DD3E:  CLRF   x70
0DD40:  MOVLW  5A
0DD42:  MOVWF  x6F
0DD44:  CLRF   x74
0DD46:  CLRF   x73
0DD48:  CLRF   x72
0DD4A:  CLRF   x71
0DD4C:  MOVLB  0
0DD4E:  CALL   CAD4
....................    write_float(ADDR_CAL_M4,1); 
0DD52:  MOVLB  8
0DD54:  CLRF   x70
0DD56:  MOVLW  5E
0DD58:  MOVWF  x6F
0DD5A:  CLRF   x74
0DD5C:  CLRF   x73
0DD5E:  CLRF   x72
0DD60:  MOVLW  7F
0DD62:  MOVWF  x71
0DD64:  MOVLB  0
0DD66:  CALL   CAD4
....................    write_float(ADDR_CAL_C4,0);  
0DD6A:  MOVLB  8
0DD6C:  CLRF   x70
0DD6E:  MOVLW  62
0DD70:  MOVWF  x6F
0DD72:  CLRF   x74
0DD74:  CLRF   x73
0DD76:  CLRF   x72
0DD78:  CLRF   x71
0DD7A:  MOVLB  0
0DD7C:  CALL   CAD4
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0DD80:  MOVLW  40
0DD82:  MOVLB  8
0DD84:  MOVWF  xD8
0DD86:  MOVLW  4E
0DD88:  MOVWF  xDA
0DD8A:  MOVLW  20
0DD8C:  MOVWF  xD9
0DD8E:  MOVLB  0
0DD90:  CALL   502C
....................    write16(ADDR_D2_TEMP,20000); 
0DD94:  MOVLW  42
0DD96:  MOVLB  8
0DD98:  MOVWF  xD8
0DD9A:  MOVLW  4E
0DD9C:  MOVWF  xDA
0DD9E:  MOVLW  20
0DDA0:  MOVWF  xD9
0DDA2:  MOVLB  0
0DDA4:  CALL   502C
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0DDA8:  MOVLW  20
0DDAA:  MOVLB  8
0DDAC:  MOVWF  xD8
0DDAE:  CLRF   xDA
0DDB0:  CLRF   xD9
0DDB2:  MOVLB  0
0DDB4:  CALL   502C
....................    write16(ADDR_VOLUME,22500);  
0DDB8:  MOVLW  22
0DDBA:  MOVLB  8
0DDBC:  MOVWF  xD8
0DDBE:  MOVLW  57
0DDC0:  MOVWF  xDA
0DDC2:  MOVLW  E4
0DDC4:  MOVWF  xD9
0DDC6:  MOVLB  0
0DDC8:  CALL   502C
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0DDCC:  MOVF   2F,W
0DDCE:  SUBLW  02
0DDD0:  BNZ   DDD6
0DDD2:  MOVF   30,F
0DDD4:  BZ    DDEA
0DDD6:  MOVLW  24
0DDD8:  MOVLB  8
0DDDA:  MOVWF  xD8
0DDDC:  CLRF   xDA
0DDDE:  MOVLW  02
0DDE0:  MOVWF  xD9
0DDE2:  MOVLB  0
0DDE4:  CALL   502C
0DDE8:  BRA    DDFC
....................    else write16(ADDR_PORT,1); 
0DDEA:  MOVLW  24
0DDEC:  MOVLB  8
0DDEE:  MOVWF  xD8
0DDF0:  CLRF   xDA
0DDF2:  MOVLW  01
0DDF4:  MOVWF  xD9
0DDF6:  MOVLB  0
0DDF8:  CALL   502C
....................     
....................    write16(ADDR_DET_TYPE,1); 
0DDFC:  MOVLW  26
0DDFE:  MOVLB  8
0DE00:  MOVWF  xD8
0DE02:  CLRF   xDA
0DE04:  MOVLW  01
0DE06:  MOVWF  xD9
0DE08:  MOVLB  0
0DE0A:  CALL   502C
....................     
....................    init_nv_vars(); 
0DE0E:  CALL   2B1A
0DE12:  GOTO   DE2C (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
1259E:  MOVLW  02
125A0:  MOVWF  FEA
125A2:  MOVLW  43
125A4:  MOVWF  FE9
125A6:  CLRF   00
125A8:  CLRF   02
125AA:  MOVLW  51
125AC:  MOVWF  01
125AE:  CALL   3588
125B2:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F69E:  MOVLW  03
0F6A0:  MOVWF  FEA
0F6A2:  MOVLW  21
0F6A4:  MOVWF  FE9
0F6A6:  CLRF   00
0F6A8:  CLRF   02
0F6AA:  MOVLW  14
0F6AC:  MOVWF  01
0F6AE:  CALL   3588
0F6B2:  GOTO   F6D2 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
130E4:  MOVLB  8
130E6:  CLRF   xBE
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
130E8:  CLRF   FEA
130EA:  MOVLW  4E
130EC:  MOVWF  FE9
130EE:  CLRF   00
130F0:  CLRF   02
130F2:  MOVLW  14
130F4:  MOVWF  01
130F6:  MOVLB  0
130F8:  CALL   3588
....................  
....................    for(n=0; n<20; n++) { 
130FC:  MOVLB  8
130FE:  CLRF   xBF
13100:  MOVF   xBF,W
13102:  SUBLW  13
13104:  BNC   1314A
....................         c = data_buffer[string_pos];  
13106:  CLRF   03
13108:  MOVLB  2
1310A:  MOVF   x94,W
1310C:  ADDLW  63
1310E:  MOVWF  FE9
13110:  MOVLW  00
13112:  ADDWFC 03,W
13114:  MOVWF  FEA
13116:  MOVFF  FEF,8BE
....................         ++string_pos; 
1311A:  INCF   x94,F
....................         if (c == '\0') return(1); // found end 
1311C:  MOVLB  8
1311E:  MOVF   xBE,F
13120:  BNZ   13128
13122:  MOVLW  01
13124:  MOVWF  01
13126:  BRA    1314E
....................         if (c == ',')  return(0); // found seperator  
13128:  MOVF   xBE,W
1312A:  SUBLW  2C
1312C:  BNZ   13134
1312E:  MOVLW  00
13130:  MOVWF  01
13132:  BRA    1314E
....................         sub_string[n] = c; 
13134:  CLRF   03
13136:  MOVF   xBF,W
13138:  ADDLW  4E
1313A:  MOVWF  FE9
1313C:  MOVLW  00
1313E:  ADDWFC 03,W
13140:  MOVWF  FEA
13142:  MOVFF  8BE,FEF
13146:  INCF   xBF,F
13148:  BRA    13100
....................    } 
....................     
....................    return(2); // failed = bad string 
1314A:  MOVLW  02
1314C:  MOVWF  01
1314E:  MOVLB  0
13150:  GOTO   1347A (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
1338E:  MOVLW  34
13390:  MOVWF  FF6
13392:  MOVLW  1C
13394:  MOVWF  FF7
13396:  MOVLW  00
13398:  MOVWF  FF8
1339A:  MOVLW  03
1339C:  MOVWF  FEA
1339E:  MOVLW  39
133A0:  MOVWF  FE9
133A2:  CALL   FBE4
133A6:  MOVF   01,W
133A8:  BZ    133BC
133AA:  XORLW  01
133AC:  BZ    133DC
133AE:  XORLW  03
133B0:  BZ    133FC
133B2:  XORLW  01
133B4:  BZ    1341C
133B6:  XORLW  07
133B8:  BZ    1343C
133BA:  BRA    1345A
....................       case "NO3" : NO3_array[read_i] = result; 
133BC:  BCF    FD8.0
133BE:  MOVLB  3
133C0:  RLCF   x46,W
133C2:  CLRF   03
133C4:  ADDLW  47
133C6:  MOVWF  FE9
133C8:  MOVLW  03
133CA:  ADDWFC 03,W
133CC:  MOVWF  FEA
133CE:  MOVFF  8BF,FEC
133D2:  MOVF   FED,F
133D4:  MOVFF  8BE,FEF
....................          break; 
133D8:  MOVLB  0
133DA:  BRA    1345A
....................       case "NO2" : NO2_array[read_i] = result; 
133DC:  BCF    FD8.0
133DE:  MOVLB  3
133E0:  RLCF   x46,W
133E2:  CLRF   03
133E4:  ADDLW  59
133E6:  MOVWF  FE9
133E8:  MOVLW  03
133EA:  ADDWFC 03,W
133EC:  MOVWF  FEA
133EE:  MOVFF  8BF,FEC
133F2:  MOVF   FED,F
133F4:  MOVFF  8BE,FEF
....................          break;    
133F8:  MOVLB  0
133FA:  BRA    1345A
....................       case "PO4" : PO4_array[read_i] = result; 
133FC:  BCF    FD8.0
133FE:  MOVLB  3
13400:  RLCF   x46,W
13402:  CLRF   03
13404:  ADDLW  6B
13406:  MOVWF  FE9
13408:  MOVLW  03
1340A:  ADDWFC 03,W
1340C:  MOVWF  FEA
1340E:  MOVFF  8BF,FEC
13412:  MOVF   FED,F
13414:  MOVFF  8BE,FEF
....................          break; 
13418:  MOVLB  0
1341A:  BRA    1345A
....................       case "NH4" : NH4_array[read_i] = result; 
1341C:  BCF    FD8.0
1341E:  MOVLB  3
13420:  RLCF   x46,W
13422:  CLRF   03
13424:  ADDLW  7D
13426:  MOVWF  FE9
13428:  MOVLW  03
1342A:  ADDWFC 03,W
1342C:  MOVWF  FEA
1342E:  MOVFF  8BF,FEC
13432:  MOVF   FED,F
13434:  MOVFF  8BE,FEF
....................          break; 
13438:  MOVLB  0
1343A:  BRA    1345A
....................       case "SiO" : SiO_array[read_i] = result; 
1343C:  BCF    FD8.0
1343E:  MOVLB  3
13440:  RLCF   x46,W
13442:  CLRF   03
13444:  ADDLW  8F
13446:  MOVWF  FE9
13448:  MOVLW  03
1344A:  ADDWFC 03,W
1344C:  MOVWF  FEA
1344E:  MOVFF  8BF,FEC
13452:  MOVF   FED,F
13454:  MOVFF  8BE,FEF
....................          break; 
13458:  MOVLB  0
....................    } 
1345A:  GOTO   134D2 (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
1345E:  MOVLB  8
13460:  CLRF   xB9
13462:  CLRF   xB8
13464:  CLRF   xBB
13466:  CLRF   xBA
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
13468:  MOVLB  2
1346A:  CLRF   x94
....................     
....................    for (n=0; n<11; ++n){ 
1346C:  MOVLB  8
1346E:  CLRF   xBC
13470:  MOVF   xBC,W
13472:  SUBLW  0A
13474:  BNC   134C6
....................       parsed = parse_string(); 
13476:  MOVLB  0
13478:  BRA    130E4
1347A:  MOVFF  01,8BD
....................       if (parsed == 2) return(0); 
1347E:  MOVLB  8
13480:  MOVF   xBD,W
13482:  SUBLW  02
13484:  BNZ   1348E
13486:  MOVLW  00
13488:  MOVWF  01
1348A:  MOVWF  02
1348C:  BRA    134DC
....................       if (n==8) result = atol(sub_string); 
1348E:  MOVF   xBC,W
13490:  SUBLW  08
13492:  BNZ   134A8
13494:  CLRF   xBF
13496:  MOVLW  4E
13498:  MOVWF  xBE
1349A:  MOVLB  0
1349C:  RCALL  131AA
1349E:  MOVFF  02,8B9
134A2:  MOVFF  01,8B8
134A6:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
134A8:  MOVF   xBC,W
134AA:  SUBLW  0A
134AC:  BNZ   134C2
134AE:  CLRF   xBF
134B0:  MOVLW  4E
134B2:  MOVWF  xBE
134B4:  MOVLB  0
134B6:  RCALL  131AA
134B8:  MOVFF  02,8BB
134BC:  MOVFF  01,8BA
134C0:  MOVLB  8
134C2:  INCF   xBC,F
134C4:  BRA    13470
....................    } 
....................    load_parsed_data(result); 
134C6:  MOVFF  8B9,8BF
134CA:  MOVFF  8B8,8BE
134CE:  MOVLB  0
134D0:  BRA    1338E
....................    return (temp); 
134D2:  MOVLB  8
134D4:  MOVFF  8BA,01
134D8:  MOVFF  8BB,02
134DC:  MOVLB  0
134DE:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D2AE:  CLRF   FEA
0D2B0:  MOVLW  63
0D2B2:  MOVWF  FE9
0D2B4:  CLRF   00
0D2B6:  CLRF   02
0D2B8:  MOVLW  A0
0D2BA:  MOVWF  01
0D2BC:  CALL   3588
0D2C0:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F6B6:  MOVLW  03
0F6B8:  MOVWF  FEA
0F6BA:  MOVLW  39
0F6BC:  MOVWF  FE9
0F6BE:  MOVLW  00
0F6C0:  CALL   02E4
0F6C4:  TBLRD*-
0F6C6:  TBLRD*+
0F6C8:  MOVF   FF5,W
0F6CA:  MOVWF  FEE
0F6CC:  IORLW  00
0F6CE:  BNZ   F6C6
....................  
....................    clear_flag_str(); 
0F6D0:  BRA    F69E
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F6D2:  MOVLW  08
0F6D4:  MOVWF  1E
0F6D6:  MOVLW  D7
0F6D8:  MOVWF  1D
0F6DA:  MOVLW  10
0F6DC:  MOVWF  FE9
0F6DE:  MOVFF  320,8E1
0F6E2:  MOVFF  31F,8E0
0F6E6:  CALL   AB36
....................  
....................    if (macro_flag < 100) { 
0F6EA:  MOVLB  3
0F6EC:  MOVF   x20,F
0F6EE:  BNZ   F708
0F6F0:  MOVF   x1F,W
0F6F2:  SUBLW  63
0F6F4:  BNC   F708
....................       temp_str[3] = '\0'; 
0F6F6:  MOVLB  8
0F6F8:  CLRF   xDA
....................       temp_str[2] = temp_str[1]; 
0F6FA:  MOVFF  8D8,8D9
....................       temp_str[1] = temp_str[0]; 
0F6FE:  MOVFF  8D7,8D8
....................       temp_str[0] = '0'; 
0F702:  MOVLW  30
0F704:  MOVWF  xD7
0F706:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F708:  MOVLB  8
0F70A:  MOVF   xD7,W
0F70C:  XORLW  30
0F70E:  MOVLB  0
0F710:  BZ    F734
0F712:  XORLW  01
0F714:  BZ    F75A
0F716:  XORLW  03
0F718:  BZ    F780
0F71A:  XORLW  01
0F71C:  BZ    F7A6
0F71E:  XORLW  07
0F720:  BZ    F7CC
0F722:  XORLW  01
0F724:  BZ    F7F2
0F726:  XORLW  03
0F728:  BTFSC  FD8.2
0F72A:  BRA    F818
0F72C:  XORLW  01
0F72E:  BTFSC  FD8.2
0F730:  BRA    F83E
0F732:  BRA    F866
....................       case '0' : strcopy(chem,"NO3"); 
0F734:  MOVLW  03
0F736:  MOVWF  FEA
0F738:  MOVLW  39
0F73A:  MOVWF  FE9
0F73C:  MOVLW  00
0F73E:  CALL   02FC
0F742:  TBLRD*-
0F744:  TBLRD*+
0F746:  MOVF   FF5,W
0F748:  MOVWF  FEE
0F74A:  IORLW  00
0F74C:  BNZ   F744
....................                  wave_l=543; 
0F74E:  MOVLW  02
0F750:  MOVLB  8
0F752:  MOVWF  xD6
0F754:  MOVLW  1F
0F756:  MOVWF  xD5
....................          break; 
0F758:  BRA    F88A
....................       case '1' : strcopy(chem,"PO4"); 
0F75A:  MOVLW  03
0F75C:  MOVWF  FEA
0F75E:  MOVLW  39
0F760:  MOVWF  FE9
0F762:  MOVLW  00
0F764:  CALL   0314
0F768:  TBLRD*-
0F76A:  TBLRD*+
0F76C:  MOVF   FF5,W
0F76E:  MOVWF  FEE
0F770:  IORLW  00
0F772:  BNZ   F76A
....................                  wave_l=880;       
0F774:  MOVLW  03
0F776:  MOVLB  8
0F778:  MOVWF  xD6
0F77A:  MOVLW  70
0F77C:  MOVWF  xD5
....................          break; 
0F77E:  BRA    F88A
....................       case '2' : strcopy(chem,"NH4"); 
0F780:  MOVLW  03
0F782:  MOVWF  FEA
0F784:  MOVLW  39
0F786:  MOVWF  FE9
0F788:  MOVLW  00
0F78A:  CALL   032C
0F78E:  TBLRD*-
0F790:  TBLRD*+
0F792:  MOVF   FF5,W
0F794:  MOVWF  FEE
0F796:  IORLW  00
0F798:  BNZ   F790
....................                  wave_l=660;       
0F79A:  MOVLW  02
0F79C:  MOVLB  8
0F79E:  MOVWF  xD6
0F7A0:  MOVLW  94
0F7A2:  MOVWF  xD5
....................          break; 
0F7A4:  BRA    F88A
....................       case '3' : strcopy(chem,"SiO"); 
0F7A6:  MOVLW  03
0F7A8:  MOVWF  FEA
0F7AA:  MOVLW  39
0F7AC:  MOVWF  FE9
0F7AE:  MOVLW  00
0F7B0:  CALL   0344
0F7B4:  TBLRD*-
0F7B6:  TBLRD*+
0F7B8:  MOVF   FF5,W
0F7BA:  MOVWF  FEE
0F7BC:  IORLW  00
0F7BE:  BNZ   F7B6
....................                  wave_l=810;       
0F7C0:  MOVLW  03
0F7C2:  MOVLB  8
0F7C4:  MOVWF  xD6
0F7C6:  MOVLW  2A
0F7C8:  MOVWF  xD5
....................          break; 
0F7CA:  BRA    F88A
....................       case '4' : strcopy(chem,"Ure"); 
0F7CC:  MOVLW  03
0F7CE:  MOVWF  FEA
0F7D0:  MOVLW  39
0F7D2:  MOVWF  FE9
0F7D4:  MOVLW  00
0F7D6:  CALL   035C
0F7DA:  TBLRD*-
0F7DC:  TBLRD*+
0F7DE:  MOVF   FF5,W
0F7E0:  MOVWF  FEE
0F7E2:  IORLW  00
0F7E4:  BNZ   F7DC
....................                  wave_l=525;       
0F7E6:  MOVLW  02
0F7E8:  MOVLB  8
0F7EA:  MOVWF  xD6
0F7EC:  MOVLW  0D
0F7EE:  MOVWF  xD5
....................          break; 
0F7F0:  BRA    F88A
....................       case '5' : strcopy(chem,"NO2"); 
0F7F2:  MOVLW  03
0F7F4:  MOVWF  FEA
0F7F6:  MOVLW  39
0F7F8:  MOVWF  FE9
0F7FA:  MOVLW  00
0F7FC:  CALL   0374
0F800:  TBLRD*-
0F802:  TBLRD*+
0F804:  MOVF   FF5,W
0F806:  MOVWF  FEE
0F808:  IORLW  00
0F80A:  BNZ   F802
....................                  wave_l=543;       
0F80C:  MOVLW  02
0F80E:  MOVLB  8
0F810:  MOVWF  xD6
0F812:  MOVLW  1F
0F814:  MOVWF  xD5
....................          break; 
0F816:  BRA    F88A
....................       case '6' : strcopy(chem,"Fe_"); 
0F818:  MOVLW  03
0F81A:  MOVWF  FEA
0F81C:  MOVLW  39
0F81E:  MOVWF  FE9
0F820:  MOVLW  00
0F822:  CALL   038C
0F826:  TBLRD*-
0F828:  TBLRD*+
0F82A:  MOVF   FF5,W
0F82C:  MOVWF  FEE
0F82E:  IORLW  00
0F830:  BNZ   F828
....................                  wave_l=543;       
0F832:  MOVLW  02
0F834:  MOVLB  8
0F836:  MOVWF  xD6
0F838:  MOVLW  1F
0F83A:  MOVWF  xD5
....................          break; 
0F83C:  BRA    F88A
....................       case '7' : strcopy(chem,"Cl_"); 
0F83E:  MOVLW  03
0F840:  MOVWF  FEA
0F842:  MOVLW  39
0F844:  MOVWF  FE9
0F846:  MOVLW  00
0F848:  CALL   03A4
0F84C:  TBLRD*-
0F84E:  TBLRD*+
0F850:  MOVF   FF5,W
0F852:  MOVWF  FEE
0F854:  IORLW  00
0F856:  BNZ   F84E
....................                  wave_l=560;       
0F858:  MOVLW  02
0F85A:  MOVLB  8
0F85C:  MOVWF  xD6
0F85E:  MOVLW  30
0F860:  MOVWF  xD5
....................          break; 
0F862:  BRA    F88A
0F864:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0F866:  MOVLW  03
0F868:  MOVWF  FEA
0F86A:  MOVLW  39
0F86C:  MOVWF  FE9
0F86E:  MOVLW  00
0F870:  CALL   02E4
0F874:  TBLRD*-
0F876:  TBLRD*+
0F878:  MOVF   FF5,W
0F87A:  MOVWF  FEE
0F87C:  IORLW  00
0F87E:  BNZ   F876
....................                  wave_l=999;       
0F880:  MOVLW  03
0F882:  MOVLB  8
0F884:  MOVWF  xD6
0F886:  MOVLW  E7
0F888:  MOVWF  xD5
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0F88A:  MOVF   xD8,W
0F88C:  XORLW  31
0F88E:  MOVLB  0
0F890:  BZ    F8B0
0F892:  XORLW  03
0F894:  BZ    F8CC
0F896:  XORLW  01
0F898:  BZ    F8E8
0F89A:  XORLW  07
0F89C:  BZ    F904
0F89E:  XORLW  01
0F8A0:  BZ    F920
0F8A2:  XORLW  03
0F8A4:  BZ    F93C
0F8A6:  XORLW  01
0F8A8:  BZ    F958
0F8AA:  XORLW  0F
0F8AC:  BZ    F974
0F8AE:  BRA    F990
....................       case '1' : strcopy(anal,"Smp"); 
0F8B0:  MOVLW  03
0F8B2:  MOVWF  FEA
0F8B4:  MOVLW  3E
0F8B6:  MOVWF  FE9
0F8B8:  MOVLW  00
0F8BA:  CALL   03BC
0F8BE:  TBLRD*-
0F8C0:  TBLRD*+
0F8C2:  MOVF   FF5,W
0F8C4:  MOVWF  FEE
0F8C6:  IORLW  00
0F8C8:  BNZ   F8C0
....................          break; 
0F8CA:  BRA    F9AA
....................       case '2' : strcopy(anal,"Std"); 
0F8CC:  MOVLW  03
0F8CE:  MOVWF  FEA
0F8D0:  MOVLW  3E
0F8D2:  MOVWF  FE9
0F8D4:  MOVLW  00
0F8D6:  CALL   03D4
0F8DA:  TBLRD*-
0F8DC:  TBLRD*+
0F8DE:  MOVF   FF5,W
0F8E0:  MOVWF  FEE
0F8E2:  IORLW  00
0F8E4:  BNZ   F8DC
....................          break; 
0F8E6:  BRA    F9AA
....................       case '3' : strcopy(anal,"Cmb"); 
0F8E8:  MOVLW  03
0F8EA:  MOVWF  FEA
0F8EC:  MOVLW  3E
0F8EE:  MOVWF  FE9
0F8F0:  MOVLW  00
0F8F2:  CALL   03EC
0F8F6:  TBLRD*-
0F8F8:  TBLRD*+
0F8FA:  MOVF   FF5,W
0F8FC:  MOVWF  FEE
0F8FE:  IORLW  00
0F900:  BNZ   F8F8
....................          break; 
0F902:  BRA    F9AA
....................       case '4' : strcopy(anal,"Tst"); 
0F904:  MOVLW  03
0F906:  MOVWF  FEA
0F908:  MOVLW  3E
0F90A:  MOVWF  FE9
0F90C:  MOVLW  00
0F90E:  CALL   0404
0F912:  TBLRD*-
0F914:  TBLRD*+
0F916:  MOVF   FF5,W
0F918:  MOVWF  FEE
0F91A:  IORLW  00
0F91C:  BNZ   F914
....................          break; 
0F91E:  BRA    F9AA
....................       case '5' : strcopy(anal,"Rbl"); 
0F920:  MOVLW  03
0F922:  MOVWF  FEA
0F924:  MOVLW  3E
0F926:  MOVWF  FE9
0F928:  MOVLW  00
0F92A:  CALL   041C
0F92E:  TBLRD*-
0F930:  TBLRD*+
0F932:  MOVF   FF5,W
0F934:  MOVWF  FEE
0F936:  IORLW  00
0F938:  BNZ   F930
....................          break; 
0F93A:  BRA    F9AA
....................       case '6' : strcopy(anal,"Cal"); 
0F93C:  MOVLW  03
0F93E:  MOVWF  FEA
0F940:  MOVLW  3E
0F942:  MOVWF  FE9
0F944:  MOVLW  00
0F946:  CALL   0434
0F94A:  TBLRD*-
0F94C:  TBLRD*+
0F94E:  MOVF   FF5,W
0F950:  MOVWF  FEE
0F952:  IORLW  00
0F954:  BNZ   F94C
....................          break; 
0F956:  BRA    F9AA
....................       case '7' : strcopy(anal,"Fls"); 
0F958:  MOVLW  03
0F95A:  MOVWF  FEA
0F95C:  MOVLW  3E
0F95E:  MOVWF  FE9
0F960:  MOVLW  00
0F962:  CALL   044C
0F966:  TBLRD*-
0F968:  TBLRD*+
0F96A:  MOVF   FF5,W
0F96C:  MOVWF  FEE
0F96E:  IORLW  00
0F970:  BNZ   F968
....................          break; 
0F972:  BRA    F9AA
....................       case '8' : strcopy(anal,"Utl"); 
0F974:  MOVLW  03
0F976:  MOVWF  FEA
0F978:  MOVLW  3E
0F97A:  MOVWF  FE9
0F97C:  MOVLW  00
0F97E:  CALL   0464
0F982:  TBLRD*-
0F984:  TBLRD*+
0F986:  MOVF   FF5,W
0F988:  MOVWF  FEE
0F98A:  IORLW  00
0F98C:  BNZ   F984
....................          break;     
0F98E:  BRA    F9AA
....................       default  : strcopy(anal,"XXX"); 
0F990:  MOVLW  03
0F992:  MOVWF  FEA
0F994:  MOVLW  3E
0F996:  MOVWF  FE9
0F998:  MOVLW  00
0F99A:  CALL   02E4
0F99E:  TBLRD*-
0F9A0:  TBLRD*+
0F9A2:  MOVF   FF5,W
0F9A4:  MOVWF  FEE
0F9A6:  IORLW  00
0F9A8:  BNZ   F9A0
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0F9AA:  MOVLB  8
0F9AC:  MOVF   xD9,W
0F9AE:  XORLW  31
0F9B0:  MOVLB  0
0F9B2:  BZ    F9DC
0F9B4:  XORLW  03
0F9B6:  BZ    F9FC
0F9B8:  XORLW  01
0F9BA:  BZ    FA1E
0F9BC:  XORLW  07
0F9BE:  BZ    FA40
0F9C0:  XORLW  01
0F9C2:  BZ    FA62
0F9C4:  XORLW  03
0F9C6:  BZ    FA84
0F9C8:  XORLW  01
0F9CA:  BTFSC  FD8.2
0F9CC:  BRA    FAA6
0F9CE:  XORLW  0F
0F9D0:  BTFSC  FD8.2
0F9D2:  BRA    FAC8
0F9D4:  XORLW  01
0F9D6:  BTFSC  FD8.2
0F9D8:  BRA    FAEA
0F9DA:  BRA    FB0E
....................       case '1' : strcopy(read_t,"I0s"); 
0F9DC:  MOVLW  03
0F9DE:  MOVWF  FEA
0F9E0:  MOVLW  42
0F9E2:  MOVWF  FE9
0F9E4:  MOVLW  00
0F9E6:  CALL   047C
0F9EA:  TBLRD*-
0F9EC:  TBLRD*+
0F9EE:  MOVF   FF5,W
0F9F0:  MOVWF  FEE
0F9F2:  IORLW  00
0F9F4:  BNZ   F9EC
....................                  read_i = 0; 
0F9F6:  MOVLB  3
0F9F8:  CLRF   x46
....................          break; 
0F9FA:  BRA    FB2C
....................       case '2' : strcopy(read_t,"I1s"); 
0F9FC:  MOVLW  03
0F9FE:  MOVWF  FEA
0FA00:  MOVLW  42
0FA02:  MOVWF  FE9
0FA04:  MOVLW  00
0FA06:  CALL   0494
0FA0A:  TBLRD*-
0FA0C:  TBLRD*+
0FA0E:  MOVF   FF5,W
0FA10:  MOVWF  FEE
0FA12:  IORLW  00
0FA14:  BNZ   FA0C
....................                  read_i = 1;       
0FA16:  MOVLW  01
0FA18:  MOVLB  3
0FA1A:  MOVWF  x46
....................          break; 
0FA1C:  BRA    FB2C
....................       case '3' : strcopy(read_t,"I0t"); 
0FA1E:  MOVLW  03
0FA20:  MOVWF  FEA
0FA22:  MOVLW  42
0FA24:  MOVWF  FE9
0FA26:  MOVLW  00
0FA28:  CALL   04AC
0FA2C:  TBLRD*-
0FA2E:  TBLRD*+
0FA30:  MOVF   FF5,W
0FA32:  MOVWF  FEE
0FA34:  IORLW  00
0FA36:  BNZ   FA2E
....................                  read_i = 2;       
0FA38:  MOVLW  02
0FA3A:  MOVLB  3
0FA3C:  MOVWF  x46
....................          break; 
0FA3E:  BRA    FB2C
....................       case '4' : strcopy(read_t,"I1t"); 
0FA40:  MOVLW  03
0FA42:  MOVWF  FEA
0FA44:  MOVLW  42
0FA46:  MOVWF  FE9
0FA48:  MOVLW  00
0FA4A:  CALL   04C4
0FA4E:  TBLRD*-
0FA50:  TBLRD*+
0FA52:  MOVF   FF5,W
0FA54:  MOVWF  FEE
0FA56:  IORLW  00
0FA58:  BNZ   FA50
....................                  read_i = 3;       
0FA5A:  MOVLW  03
0FA5C:  MOVLB  3
0FA5E:  MOVWF  x46
....................          break; 
0FA60:  BRA    FB2C
....................       case '5' : strcopy(read_t,"I0r"); 
0FA62:  MOVLW  03
0FA64:  MOVWF  FEA
0FA66:  MOVLW  42
0FA68:  MOVWF  FE9
0FA6A:  MOVLW  00
0FA6C:  CALL   04DC
0FA70:  TBLRD*-
0FA72:  TBLRD*+
0FA74:  MOVF   FF5,W
0FA76:  MOVWF  FEE
0FA78:  IORLW  00
0FA7A:  BNZ   FA72
....................                  read_i = 4;       
0FA7C:  MOVLW  04
0FA7E:  MOVLB  3
0FA80:  MOVWF  x46
....................          break; 
0FA82:  BRA    FB2C
....................       case '6' : strcopy(read_t,"I1r"); 
0FA84:  MOVLW  03
0FA86:  MOVWF  FEA
0FA88:  MOVLW  42
0FA8A:  MOVWF  FE9
0FA8C:  MOVLW  00
0FA8E:  CALL   04F4
0FA92:  TBLRD*-
0FA94:  TBLRD*+
0FA96:  MOVF   FF5,W
0FA98:  MOVWF  FEE
0FA9A:  IORLW  00
0FA9C:  BNZ   FA94
....................                  read_i = 5;       
0FA9E:  MOVLW  05
0FAA0:  MOVLB  3
0FAA2:  MOVWF  x46
....................          break; 
0FAA4:  BRA    FB2C
....................       case '7' : strcopy(read_t,"I0u"); 
0FAA6:  MOVLW  03
0FAA8:  MOVWF  FEA
0FAAA:  MOVLW  42
0FAAC:  MOVWF  FE9
0FAAE:  MOVLW  00
0FAB0:  CALL   050C
0FAB4:  TBLRD*-
0FAB6:  TBLRD*+
0FAB8:  MOVF   FF5,W
0FABA:  MOVWF  FEE
0FABC:  IORLW  00
0FABE:  BNZ   FAB6
....................                  read_i = 6;       
0FAC0:  MOVLW  06
0FAC2:  MOVLB  3
0FAC4:  MOVWF  x46
....................          break; 
0FAC6:  BRA    FB2C
....................       case '8' : strcopy(read_t,"I1u"); 
0FAC8:  MOVLW  03
0FACA:  MOVWF  FEA
0FACC:  MOVLW  42
0FACE:  MOVWF  FE9
0FAD0:  MOVLW  00
0FAD2:  CALL   0524
0FAD6:  TBLRD*-
0FAD8:  TBLRD*+
0FADA:  MOVF   FF5,W
0FADC:  MOVWF  FEE
0FADE:  IORLW  00
0FAE0:  BNZ   FAD8
....................                  read_i = 7;       
0FAE2:  MOVLW  07
0FAE4:  MOVLB  3
0FAE6:  MOVWF  x46
....................          break; 
0FAE8:  BRA    FB2C
....................       case '9' : strcopy(read_t,"Chk"); 
0FAEA:  MOVLW  03
0FAEC:  MOVWF  FEA
0FAEE:  MOVLW  42
0FAF0:  MOVWF  FE9
0FAF2:  MOVLW  00
0FAF4:  CALL   053C
0FAF8:  TBLRD*-
0FAFA:  TBLRD*+
0FAFC:  MOVF   FF5,W
0FAFE:  MOVWF  FEE
0FB00:  IORLW  00
0FB02:  BNZ   FAFA
....................                  read_i = 8;       
0FB04:  MOVLW  08
0FB06:  MOVLB  3
0FB08:  MOVWF  x46
....................          break;        
0FB0A:  BRA    FB2C
0FB0C:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FB0E:  MOVLW  03
0FB10:  MOVWF  FEA
0FB12:  MOVLW  42
0FB14:  MOVWF  FE9
0FB16:  MOVLW  00
0FB18:  CALL   0554
0FB1C:  TBLRD*-
0FB1E:  TBLRD*+
0FB20:  MOVF   FF5,W
0FB22:  MOVWF  FEE
0FB24:  IORLW  00
0FB26:  BNZ   FB1E
....................                  read_i = 0;       
0FB28:  MOVLB  3
0FB2A:  CLRF   x46
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FB2C:  MOVLW  03
0FB2E:  MOVLB  8
0FB30:  MOVWF  xE3
0FB32:  MOVLW  21
0FB34:  MOVWF  xE2
0FB36:  MOVLW  03
0FB38:  MOVWF  xE5
0FB3A:  MOVLW  39
0FB3C:  MOVWF  xE4
0FB3E:  MOVLB  0
0FB40:  CALL   5536
....................    strcat(flag_str, (char *)","); 
0FB44:  MOVLW  2C
0FB46:  MOVLB  8
0FB48:  MOVWF  xDE
0FB4A:  CLRF   xDF
0FB4C:  MOVLW  03
0FB4E:  MOVWF  xE3
0FB50:  MOVLW  21
0FB52:  MOVWF  xE2
0FB54:  MOVLW  08
0FB56:  MOVWF  xE5
0FB58:  MOVLW  DE
0FB5A:  MOVWF  xE4
0FB5C:  MOVLB  0
0FB5E:  CALL   5536
....................    strcat(flag_str, anal); 
0FB62:  MOVLW  03
0FB64:  MOVLB  8
0FB66:  MOVWF  xE3
0FB68:  MOVLW  21
0FB6A:  MOVWF  xE2
0FB6C:  MOVLW  03
0FB6E:  MOVWF  xE5
0FB70:  MOVLW  3E
0FB72:  MOVWF  xE4
0FB74:  MOVLB  0
0FB76:  CALL   5536
....................    strcat(flag_str, (char *)","); 
0FB7A:  MOVLW  2C
0FB7C:  MOVLB  8
0FB7E:  MOVWF  xDE
0FB80:  CLRF   xDF
0FB82:  MOVLW  03
0FB84:  MOVWF  xE3
0FB86:  MOVLW  21
0FB88:  MOVWF  xE2
0FB8A:  MOVLW  08
0FB8C:  MOVWF  xE5
0FB8E:  MOVLW  DE
0FB90:  MOVWF  xE4
0FB92:  MOVLB  0
0FB94:  CALL   5536
....................    strcat(flag_str, read_t);   
0FB98:  MOVLW  03
0FB9A:  MOVLB  8
0FB9C:  MOVWF  xE3
0FB9E:  MOVLW  21
0FBA0:  MOVWF  xE2
0FBA2:  MOVLW  03
0FBA4:  MOVWF  xE5
0FBA6:  MOVLW  42
0FBA8:  MOVWF  xE4
0FBAA:  MOVLB  0
0FBAC:  CALL   5536
....................     
....................    return wave_l; 
0FBB0:  MOVLB  8
0FBB2:  MOVFF  8D5,01
0FBB6:  MOVFF  8D6,02
0FBBA:  MOVLB  0
0FBBC:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F184:  MOVF   43,W
0F186:  SUBLW  4B
0F188:  BTFSC  FD8.2
0F18A:  MOVFF  44,2D2
....................    if (cmd=='L') detector_li = arg; 
0F18E:  MOVF   43,W
0F190:  SUBLW  4C
0F192:  BNZ   F19C
0F194:  MOVFF  45,2D4
0F198:  MOVFF  44,2D3
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F19C:  MOVF   1F,W
0F19E:  SUBLW  04
0F1A0:  BNZ   F26A
0F1A2:  MOVF   20,F
0F1A4:  BNZ   F26A
0F1A6:  MOVLW  4A
0F1A8:  MOVWF  FF6
0F1AA:  MOVLW  1C
0F1AC:  MOVWF  FF7
0F1AE:  MOVLW  00
0F1B0:  MOVWF  FF8
0F1B2:  CLRF   1B
0F1B4:  BTFSC  FF2.7
0F1B6:  BSF    1B.7
0F1B8:  BCF    FF2.7
0F1BA:  MOVLW  06
0F1BC:  MOVLB  A
0F1BE:  MOVWF  x25
0F1C0:  MOVLB  0
0F1C2:  CALL   101E
0F1C6:  BTFSC  1B.7
0F1C8:  BSF    FF2.7
0F1CA:  CLRF   1B
0F1CC:  BTFSC  FF2.7
0F1CE:  BSF    1B.7
0F1D0:  BCF    FF2.7
0F1D2:  MOVFF  2D1,A25
0F1D6:  MOVLW  1B
0F1D8:  MOVLB  A
0F1DA:  MOVWF  x26
0F1DC:  MOVLB  0
0F1DE:  CALL   0FA0
0F1E2:  BTFSC  1B.7
0F1E4:  BSF    FF2.7
0F1E6:  MOVLW  5D
0F1E8:  BTFSS  F9E.4
0F1EA:  BRA    F1E8
0F1EC:  MOVWF  FAD
0F1EE:  MOVLW  5B
0F1F0:  BTFSS  F9E.4
0F1F2:  BRA    F1F0
0F1F4:  MOVWF  FAD
0F1F6:  MOVF   43,W
0F1F8:  BTFSS  F9E.4
0F1FA:  BRA    F1F8
0F1FC:  MOVWF  FAD
0F1FE:  MOVLW  56
0F200:  MOVWF  FF6
0F202:  MOVLW  1C
0F204:  MOVWF  FF7
0F206:  MOVLW  00
0F208:  MOVWF  FF8
0F20A:  CLRF   1B
0F20C:  BTFSC  FF2.7
0F20E:  BSF    1B.7
0F210:  BCF    FF2.7
0F212:  MOVLW  05
0F214:  MOVLB  A
0F216:  MOVWF  x25
0F218:  MOVLB  0
0F21A:  CALL   101E
0F21E:  BTFSC  1B.7
0F220:  BSF    FF2.7
0F222:  MOVLW  41
0F224:  MOVWF  FE9
0F226:  CLRF   1B
0F228:  BTFSC  FF2.7
0F22A:  BSF    1B.7
0F22C:  BCF    FF2.7
0F22E:  MOVFF  47,A28
0F232:  MOVFF  46,A27
0F236:  MOVFF  45,A26
0F23A:  MOVFF  44,A25
0F23E:  CALL   10E4
0F242:  BTFSC  1B.7
0F244:  BSF    FF2.7
0F246:  MOVLW  5E
0F248:  MOVWF  FF6
0F24A:  MOVLW  1C
0F24C:  MOVWF  FF7
0F24E:  MOVLW  00
0F250:  MOVWF  FF8
0F252:  CLRF   1B
0F254:  BTFSC  FF2.7
0F256:  BSF    1B.7
0F258:  BCF    FF2.7
0F25A:  MOVLW  03
0F25C:  MOVLB  A
0F25E:  MOVWF  x25
0F260:  MOVLB  0
0F262:  CALL   101E
0F266:  BTFSC  1B.7
0F268:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F26A:  CALL   D7FE
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F26E:  MOVLW  2F
0F270:  BTFSS  FA4.4
0F272:  BRA    F270
0F274:  MOVLB  F
0F276:  MOVWF  x1C
0F278:  MOVFF  2D1,8DD
0F27C:  MOVLW  1B
0F27E:  MOVLB  8
0F280:  MOVWF  xDE
0F282:  MOVLB  0
0F284:  CALL   D846
0F288:  MOVF   43,W
0F28A:  BTFSS  FA4.4
0F28C:  BRA    F28A
0F28E:  MOVLB  F
0F290:  MOVWF  x1C
0F292:  MOVLW  41
0F294:  MOVWF  FE9
0F296:  MOVFF  47,8E0
0F29A:  MOVFF  46,8DF
0F29E:  MOVFF  45,8DE
0F2A2:  MOVFF  44,8DD
0F2A6:  MOVLB  0
0F2A8:  BRA    F0A4
0F2AA:  MOVLW  0D
0F2AC:  BTFSS  FA4.4
0F2AE:  BRA    F2AC
0F2B0:  MOVLB  F
0F2B2:  MOVWF  x1C
0F2B4:  MOVLW  0A
0F2B6:  BTFSS  FA4.4
0F2B8:  BRA    F2B6
0F2BA:  MOVWF  x1C
....................    multidrop_off(); 
0F2BC:  MOVLB  0
0F2BE:  CALL   D8EA
0F2C2:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12C02:  MOVLB  8
12C04:  CLRF   xD6
12C06:  BCF    xD7.0
12C08:  CLRF   xD8
12C0A:  CLRF   xDC
12C0C:  CLRF   xDB
12C0E:  CLRF   xDA
12C10:  CLRF   xD9
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12C12:  MOVLW  02
12C14:  MOVWF  FEA
12C16:  MOVLW  43
12C18:  MOVWF  FE9
12C1A:  CLRF   00
12C1C:  CLRF   02
12C1E:  MOVLW  51
12C20:  MOVWF  01
12C22:  MOVLB  0
12C24:  CALL   3588
....................  
....................    det_cmd(); 
12C28:  CALL   F184
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12C2C:  CALL   55A8
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12C30:  MOVLB  8
12C32:  MOVF   xD8,W
12C34:  SUBLW  02
12C36:  BZ    12CCA
12C38:  MOVF   xD8,W
12C3A:  SUBLW  03
12C3C:  BZ    12CCA
12C3E:  MOVF   xD6,W
12C40:  SUBLW  50
12C42:  BNC   12CCA
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12C44:  BTFSS  FA4.5
12C46:  BRA    12C7E
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12C48:  MOVLB  0
12C4A:  RCALL  12BE8
12C4C:  MOVFF  01,8D5
....................  
....................          if(startCharacterRcvd) 
12C50:  MOVLB  8
12C52:  BTFSS  xD7.0
12C54:  BRA    12C76
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12C56:  MOVF   xD6,W
12C58:  INCF   xD6,F
12C5A:  CLRF   03
12C5C:  ADDLW  43
12C5E:  MOVWF  FE9
12C60:  MOVLW  02
12C62:  ADDWFC 03,W
12C64:  MOVWF  FEA
12C66:  MOVFF  8D5,FEF
....................             if (CARRIAGE_RET == c) 
12C6A:  MOVF   xD5,W
12C6C:  SUBLW  0D
12C6E:  BNZ   12C74
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12C70:  MOVLW  02
12C72:  MOVWF  xD8
....................             } 
....................          } 
12C74:  BRA    12C7E
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12C76:  MOVF   xD5,W
12C78:  SUBLW  40
12C7A:  BNZ   12C7E
....................             { 
....................                startCharacterRcvd = TRUE; 
12C7C:  BSF    xD7.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12C7E:  MOVLW  35
12C80:  MOVWF  00
12C82:  DECFSZ 00,F
12C84:  BRA    12C82
....................       if (tenMicroSecDelayCounter++ > 500000) 
12C86:  MOVFF  8DC,8E0
12C8A:  MOVFF  8DB,8DF
12C8E:  MOVFF  8DA,8DE
12C92:  MOVFF  8D9,8DD
12C96:  MOVLW  01
12C98:  ADDWF  xD9,F
12C9A:  BTFSC  FD8.0
12C9C:  INCF   xDA,F
12C9E:  BTFSC  FD8.2
12CA0:  INCF   xDB,F
12CA2:  BTFSC  FD8.2
12CA4:  INCF   xDC,F
12CA6:  MOVF   xE0,F
12CA8:  BNZ   12CC4
12CAA:  MOVF   xDF,W
12CAC:  SUBLW  06
12CAE:  BC    12CC8
12CB0:  XORLW  FF
12CB2:  BNZ   12CC4
12CB4:  MOVF   xDE,W
12CB6:  SUBLW  A0
12CB8:  BC    12CC8
12CBA:  XORLW  FF
12CBC:  BNZ   12CC4
12CBE:  MOVF   xDD,W
12CC0:  SUBLW  20
12CC2:  BC    12CC8
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12CC4:  MOVLW  03
12CC6:  MOVWF  xD8
....................       } 
12CC8:  BRA    12C32
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12CCA:  MOVF   xD6,W
12CCC:  SUBLW  50
12CCE:  BC    12CE0
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12CD0:  MOVF   xD8,W
12CD2:  SUBLW  03
12CD4:  BZ    12CE0
12CD6:  MOVF   xD8,W
12CD8:  SUBLW  02
12CDA:  BZ    12CE0
....................       { 
....................          rcvDataType = SOME_DATA; 
12CDC:  MOVLW  01
12CDE:  MOVWF  xD8
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12CE0:  MOVLB  0
12CE2:  CALL   55C8
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12CE6:  MOVLB  8
12CE8:  MOVFF  8D8,01
12CEC:  MOVLB  0
12CEE:  GOTO   12E68 (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
0FCEC:  MOVF   1F,F
0FCEE:  BNZ   FD0E
0FCF0:  MOVF   20,F
0FCF2:  BNZ   FD0E
0FCF4:  MOVLB  8
0FCF6:  DECFSZ xD6,W
0FCF8:  BRA    FCFC
0FCFA:  BRA    FD00
0FCFC:  MOVLB  0
0FCFE:  BRA    FD0E
0FD00:  CLRF   FEA
0FD02:  MOVLW  63
0FD04:  MOVWF  FE9
0FD06:  MOVLB  0
0FD08:  CALL   79DC
0FD0C:  BRA    FD22
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
0FD0E:  MOVF   20,F
0FD10:  BNZ   FD18
0FD12:  MOVF   1F,W
0FD14:  SUBLW  03
0FD16:  BC    FD22
0FD18:  CLRF   FEA
0FD1A:  MOVLW  63
0FD1C:  MOVWF  FE9
0FD1E:  CALL   79DC
....................  
....................    if (store==TRUE && sd_status==0) { 
0FD22:  MOVLB  8
0FD24:  DECFSZ xD5,W
0FD26:  BRA    FD86
0FD28:  MOVLB  2
0FD2A:  MOVF   xD8,F
0FD2C:  BTFSC  FD8.2
0FD2E:  BRA    FD34
0FD30:  MOVLB  8
0FD32:  BRA    FD86
....................        
....................       buffer_select = 0; 
0FD34:  MOVLB  0
0FD36:  CLRF   x62
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FD38:  MOVLB  8
0FD3A:  CLRF   xD7
0FD3C:  MOVLB  0
0FD3E:  CALL   55DA
....................          append_data(file_ptr_raw_all); 
0FD42:  MOVLW  02
0FD44:  MOVLB  8
0FD46:  MOVWF  xD8
0FD48:  MOVLW  D9
0FD4A:  MOVWF  xD7
0FD4C:  MOVLB  0
0FD4E:  CALL   8338
....................       heartbeat(TRUE); 
0FD52:  MOVLW  01
0FD54:  MOVLB  8
0FD56:  MOVWF  xD7
0FD58:  MOVLB  0
0FD5A:  CALL   55DA
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FD5E:  MOVLB  8
0FD60:  CLRF   xD7
0FD62:  MOVLB  0
0FD64:  CALL   55DA
....................          append_data(file_ptr_raw_new); 
0FD68:  MOVLW  02
0FD6A:  MOVLB  8
0FD6C:  MOVWF  xD8
0FD6E:  MOVLW  E7
0FD70:  MOVWF  xD7
0FD72:  MOVLB  0
0FD74:  CALL   8338
....................       heartbeat(TRUE); 
0FD78:  MOVLW  01
0FD7A:  MOVLB  8
0FD7C:  MOVWF  xD7
0FD7E:  MOVLB  0
0FD80:  CALL   55DA
0FD84:  MOVLB  8
....................    } 
0FD86:  MOVLB  0
0FD88:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12CFE:  CLRF   xCF
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12CF2:  MOVLW  0D
12CF4:  MOVLB  8
12CF6:  MOVWF  xB8
12CF8:  MOVLW  0A
12CFA:  MOVWF  xB9
12CFC:  CLRF   xBA
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12D00:  MOVLB  0
12D02:  RCALL  1259E
....................    clear_data_buffer(); 
12D04:  CALL   D2AE
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12D08:  MOVLW  08
12D0A:  MOVWF  FEA
12D0C:  MOVLW  BB
12D0E:  MOVWF  FE9
12D10:  CLRF   00
12D12:  CLRF   02
12D14:  MOVLW  14
12D16:  MOVWF  01
12D18:  CALL   3588
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12D1C:  MOVLW  01
12D1E:  MOVWF  FEA
12D20:  MOVLW  A3
12D22:  MOVWF  FE9
12D24:  CLRF   00
12D26:  CLRF   02
12D28:  MOVLW  A0
12D2A:  MOVWF  01
12D2C:  CALL   3588
....................  
....................    time_stamp(); 
12D30:  CALL   5472
....................    strcpy(data_buffer, time_stmp_str); 
12D34:  CLRF   FEA
12D36:  MOVLW  63
12D38:  MOVWF  FE9
12D3A:  MOVLW  02
12D3C:  MOVWF  FE2
12D3E:  MOVLW  95
12D40:  MOVWF  FE1
12D42:  MOVF   FE7,F
12D44:  MOVFF  FE6,FEE
12D48:  BNZ   12D42
....................    strcat(data_buffer, (char *)","); 
12D4A:  MOVLW  2C
12D4C:  MOVLB  8
12D4E:  MOVWF  xD3
12D50:  CLRF   xD4
12D52:  CLRF   xE3
12D54:  MOVLW  63
12D56:  MOVWF  xE2
12D58:  MOVLW  08
12D5A:  MOVWF  xE5
12D5C:  MOVLW  D3
12D5E:  MOVWF  xE4
12D60:  MOVLB  0
12D62:  CALL   5536
....................  
....................    flag_mod=fmod(macro_flag,10); 
12D66:  MOVFF  320,902
12D6A:  MOVFF  31F,901
12D6E:  CALL   C69C
12D72:  MOVFF  03,8D8
12D76:  MOVFF  02,8D7
12D7A:  MOVFF  01,8D6
12D7E:  MOVFF  00,8D5
12D82:  MOVFF  03,8DC
12D86:  MOVFF  02,8DB
12D8A:  MOVFF  01,8DA
12D8E:  MOVFF  00,8D9
12D92:  MOVLB  8
12D94:  CLRF   xE0
12D96:  CLRF   xDF
12D98:  MOVLW  20
12D9A:  MOVWF  xDE
12D9C:  MOVLW  82
12D9E:  MOVWF  xDD
12DA0:  MOVLB  0
12DA2:  BRA    129A8
12DA4:  MOVFF  03,900
12DA8:  MOVFF  02,8FF
12DAC:  MOVFF  01,8FE
12DB0:  MOVFF  00,8FD
12DB4:  CALL   125B4
12DB8:  MOVFF  01,8D2
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
12DBC:  MOVLB  8
12DBE:  DECFSZ xD2,W
12DC0:  BRA    12DC4
12DC2:  BRA    12DCA
12DC4:  MOVF   xD2,W
12DC6:  SUBLW  03
12DC8:  BNZ   12DE8
....................    { 
....................       clear_proc_time_stmp_str(); 
12DCA:  MOVLB  0
12DCC:  BRA    12B10
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
12DCE:  MOVLW  02
12DD0:  MOVWF  FEA
12DD2:  MOVLW  B3
12DD4:  MOVWF  FE9
12DD6:  MOVLW  02
12DD8:  MOVWF  FE2
12DDA:  MOVLW  95
12DDC:  MOVWF  FE1
12DDE:  MOVF   FE7,F
12DE0:  MOVFF  FE6,FEE
12DE4:  BNZ   12DDE
12DE6:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
12DE8:  MOVLB  0
12DEA:  CALL   F6B6
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12DEE:  MOVLB  8
12DF0:  CLRF   xD6
12DF2:  MOVLW  63
12DF4:  MOVWF  xD5
12DF6:  MOVLB  0
12DF8:  RCALL  12B28
12DFA:  MOVFF  02,03
12DFE:  MOVF   01,W
12E00:  XORLW  FF
12E02:  ADDLW  A1
12E04:  MOVLB  8
12E06:  MOVWF  xD5
12E08:  MOVLW  00
12E0A:  SUBFWB 02,W
12E0C:  MOVWF  xD6
12E0E:  MOVLW  01
12E10:  SUBWF  xD5,F
12E12:  MOVLW  00
12E14:  SUBWFB xD6,F
12E16:  CLRF   xD8
12E18:  MOVLW  63
12E1A:  MOVWF  xD7
12E1C:  MOVLW  03
12E1E:  MOVWF  xDA
12E20:  MOVLW  21
12E22:  MOVWF  xD9
12E24:  MOVFF  8D6,8DC
12E28:  MOVFF  8D5,8DB
12E2C:  MOVLB  0
12E2E:  RCALL  12B64
....................    strcat(data_buffer, (char *)","); 
12E30:  MOVLW  2C
12E32:  MOVLB  8
12E34:  MOVWF  xD3
12E36:  CLRF   xD4
12E38:  CLRF   xE3
12E3A:  MOVLW  63
12E3C:  MOVWF  xE2
12E3E:  MOVLW  08
12E40:  MOVWF  xE5
12E42:  MOVLW  D3
12E44:  MOVWF  xE4
12E46:  MOVLB  0
12E48:  CALL   5536
....................     
....................    cmd = 'S'; 
12E4C:  MOVLW  53
12E4E:  MOVWF  43
....................    arg = 1; 
12E50:  CLRF   47
12E52:  CLRF   46
12E54:  CLRF   45
12E56:  MOVLW  01
12E58:  MOVWF  44
....................  
....................    for(i = 0; i < 6; i++) 
12E5A:  MOVLB  8
12E5C:  CLRF   xD0
12E5E:  MOVF   xD0,W
12E60:  SUBLW  05
12E62:  BNC   12E7A
....................    { 
....................       rcvdData = get_slave_data(); 
12E64:  MOVLB  0
12E66:  BRA    12C02
12E68:  MOVFF  01,8CF
....................       if (DATA_COMPLETE == rcvdData) 
12E6C:  MOVLB  8
12E6E:  MOVF   xCF,W
12E70:  SUBLW  02
12E72:  BNZ   12E76
....................       { 
....................          break; 
12E74:  BRA    12E7A
....................       } 
12E76:  INCF   xD0,F
12E78:  BRA    12E5E
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12E7A:  CLRF   xD6
12E7C:  MOVLW  63
12E7E:  MOVWF  xD5
12E80:  MOVLB  0
12E82:  RCALL  12B28
12E84:  MOVFF  02,03
12E88:  MOVF   01,W
12E8A:  XORLW  FF
12E8C:  ADDLW  A1
12E8E:  MOVLB  8
12E90:  MOVWF  xD5
12E92:  MOVLW  00
12E94:  SUBFWB 02,W
12E96:  MOVWF  xD6
12E98:  MOVLW  01
12E9A:  SUBWF  xD5,F
12E9C:  MOVLW  00
12E9E:  SUBWFB xD6,F
12EA0:  CLRF   xD8
12EA2:  MOVLW  63
12EA4:  MOVWF  xD7
12EA6:  MOVLW  02
12EA8:  MOVWF  xDA
12EAA:  MOVLW  43
12EAC:  MOVWF  xD9
12EAE:  MOVFF  8D6,8DC
12EB2:  MOVFF  8D5,8DB
12EB6:  MOVLB  0
12EB8:  RCALL  12B64
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
12EBA:  MOVLW  02
12EBC:  MOVLB  8
12EBE:  MOVWF  xD6
12EC0:  MOVLW  43
12EC2:  MOVWF  xD5
12EC4:  MOVLB  0
12EC6:  RCALL  12B28
12EC8:  MOVFF  01,8D1
....................    if (rec_len > 0 && rec_len < 12) 
12ECC:  MOVLB  8
12ECE:  MOVF   xD1,F
12ED0:  BZ    12EDE
12ED2:  MOVF   xD1,W
12ED4:  SUBLW  0B
12ED6:  BNC   12EDE
....................    { 
....................       rcvdData = SHORT_DATA; 
12ED8:  MOVLW  04
12EDA:  MOVWF  xCF
....................    } 
12EDC:  BRA    12EE8
....................    else 
....................    { 
....................       if (rec_len > 30) 
12EDE:  MOVF   xD1,W
12EE0:  SUBLW  1E
12EE2:  BC    12EE8
....................       { 
....................          rcvdData = LONG_DATA; 
12EE4:  MOVLW  05
12EE6:  MOVWF  xCF
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
12EE8:  MOVLW  02
12EEA:  SUBWF  xCF,W
12EEC:  ADDLW  FC
12EEE:  BC    12F5A
12EF0:  ADDLW  04
12EF2:  MOVLB  0
12EF4:  GOTO   130BC
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
12EF8:  MOVLB  8
12EFA:  BRA    12F5A
12EFC:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
12EFE:  MOVLW  08
12F00:  MOVWF  1E
12F02:  MOVLW  BB
12F04:  MOVWF  1D
12F06:  MOVLW  62
12F08:  MOVWF  FF6
12F0A:  MOVLW  1C
12F0C:  MOVWF  FF7
12F0E:  MOVLW  00
12F10:  MOVWF  FF8
12F12:  CALL   5116
....................          break; 
12F16:  MOVLB  8
12F18:  BRA    12F5A
12F1A:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
12F1C:  MOVLW  08
12F1E:  MOVWF  1E
12F20:  MOVLW  BB
12F22:  MOVWF  1D
12F24:  MOVLW  6C
12F26:  MOVWF  FF6
12F28:  MOVLW  1C
12F2A:  MOVWF  FF7
12F2C:  MOVLW  00
12F2E:  MOVWF  FF8
12F30:  CALL   5116
....................          break; 
12F34:  MOVLB  8
12F36:  BRA    12F5A
12F38:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
12F3A:  MOVLW  08
12F3C:  MOVWF  1E
12F3E:  MOVLW  BB
12F40:  MOVWF  1D
12F42:  MOVLW  7C
12F44:  MOVWF  FF6
12F46:  MOVLW  1C
12F48:  MOVWF  FF7
12F4A:  MOVLW  00
12F4C:  MOVWF  FF8
12F4E:  CALL   5116
....................          break; 
12F52:  MOVLB  8
12F54:  BRA    12F5A
12F56:  MOVLB  0
12F58:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12F5A:  CLRF   xD6
12F5C:  MOVLW  63
12F5E:  MOVWF  xD5
12F60:  MOVLB  0
12F62:  RCALL  12B28
12F64:  MOVFF  02,03
12F68:  MOVF   01,W
12F6A:  XORLW  FF
12F6C:  ADDLW  A1
12F6E:  MOVLB  8
12F70:  MOVWF  xD5
12F72:  MOVLW  00
12F74:  SUBFWB 02,W
12F76:  MOVWF  xD6
12F78:  MOVLW  01
12F7A:  SUBWF  xD5,F
12F7C:  MOVLW  00
12F7E:  SUBWFB xD6,F
12F80:  CLRF   xD8
12F82:  MOVLW  63
12F84:  MOVWF  xD7
12F86:  MOVLW  08
12F88:  MOVWF  xDA
12F8A:  MOVLW  BB
12F8C:  MOVWF  xD9
12F8E:  MOVFF  8D6,8DC
12F92:  MOVFF  8D5,8DB
12F96:  MOVLB  0
12F98:  RCALL  12B64
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12F9A:  MOVLB  8
12F9C:  CLRF   xD6
12F9E:  MOVLW  63
12FA0:  MOVWF  xD5
12FA2:  MOVLB  0
12FA4:  RCALL  12B28
12FA6:  MOVFF  02,03
12FAA:  MOVF   01,W
12FAC:  XORLW  FF
12FAE:  ADDLW  A1
12FB0:  MOVLB  8
12FB2:  MOVWF  xD5
12FB4:  MOVLW  00
12FB6:  SUBFWB 02,W
12FB8:  MOVWF  xD6
12FBA:  MOVLW  01
12FBC:  SUBWF  xD5,F
12FBE:  MOVLW  00
12FC0:  SUBWFB xD6,F
12FC2:  CLRF   xD8
12FC4:  MOVLW  63
12FC6:  MOVWF  xD7
12FC8:  MOVLW  08
12FCA:  MOVWF  xDA
12FCC:  MOVLW  B8
12FCE:  MOVWF  xD9
12FD0:  MOVFF  8D6,8DC
12FD4:  MOVFF  8D5,8DB
12FD8:  MOVLB  0
12FDA:  RCALL  12B64
....................  
....................    if(DATA_COMPLETE != rcvdData) 
12FDC:  MOVLB  8
12FDE:  MOVF   xCF,W
12FE0:  SUBLW  02
12FE2:  BZ    1309E
....................    {    //housekeeping 
....................       time_stamp(); 
12FE4:  MOVLB  0
12FE6:  CALL   5472
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
12FEA:  MOVLW  01
12FEC:  MOVWF  1E
12FEE:  MOVLW  A3
12FF0:  MOVWF  1D
12FF2:  MOVLW  8C
12FF4:  MOVWF  FF6
12FF6:  MOVLW  1C
12FF8:  MOVWF  FF7
12FFA:  MOVLW  00
12FFC:  MOVWF  FF8
12FFE:  MOVLW  0A
13000:  MOVLB  8
13002:  MOVWF  xD5
13004:  MOVLB  0
13006:  CALL   AB04
1300A:  MOVFF  1E,FEA
1300E:  MOVFF  1D,FE9
13012:  CLRF   FEF
13014:  MOVLW  08
13016:  MOVWF  FEA
13018:  MOVLW  BB
1301A:  MOVWF  FE9
1301C:  CALL   FBBE
13020:  MOVLW  98
13022:  MOVWF  FF6
13024:  MOVLW  1C
13026:  MOVWF  FF7
13028:  MOVLW  00
1302A:  MOVWF  FF8
1302C:  MOVLW  06
1302E:  MOVLB  8
13030:  MOVWF  xD5
13032:  MOVLB  0
13034:  CALL   AB04
13038:  MOVFF  8D1,8D7
1303C:  MOVLW  1B
1303E:  MOVLB  8
13040:  MOVWF  xD8
13042:  MOVLB  0
13044:  CALL   52D8
13048:  MOVLW  5D
1304A:  MOVLB  8
1304C:  MOVWF  xE9
1304E:  MOVLB  0
13050:  CALL   50F6
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
13054:  MOVLW  01
13056:  MOVLB  8
13058:  MOVWF  xD6
1305A:  MOVLW  A3
1305C:  MOVWF  xD5
1305E:  MOVLB  0
13060:  RCALL  12B28
13062:  MOVFF  02,03
13066:  MOVF   01,W
13068:  XORLW  FF
1306A:  ADDLW  A1
1306C:  MOVLB  8
1306E:  MOVWF  xD5
13070:  MOVLW  00
13072:  SUBFWB 02,W
13074:  MOVWF  xD6
13076:  MOVLW  01
13078:  SUBWF  xD5,F
1307A:  MOVLW  00
1307C:  SUBWFB xD6,F
1307E:  MOVLW  01
13080:  MOVWF  xD8
13082:  MOVLW  A3
13084:  MOVWF  xD7
13086:  CLRF   xDA
13088:  MOVLW  63
1308A:  MOVWF  xD9
1308C:  MOVFF  8D6,8DC
13090:  MOVFF  8D5,8DB
13094:  MOVLB  0
13096:  RCALL  12B64
....................       record_event(); 
13098:  CALL   851A
1309C:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
1309E:  MOVFF  8B6,8D5
130A2:  MOVFF  8B7,8D6
130A6:  MOVLB  0
130A8:  CALL   FCEC
....................  
....................    return (rcvdData); 
130AC:  CLRF   03
130AE:  MOVLB  8
130B0:  MOVFF  8CF,01
130B4:  MOVFF  03,02
130B8:  MOVLB  0
130BA:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
134E0:  MOVLB  8
134E2:  CLRF   xAE
134E4:  MOVF   xAE,W
134E6:  SUBLW  02
134E8:  BTFSS  FD8.0
134EA:  BRA    13600
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
134EC:  MOVFF  8AC,8B6
134F0:  MOVFF  8AD,8B7
134F4:  MOVLB  0
134F6:  CALL   12CF2
134FA:  MOVFF  02,03
134FE:  MOVF   01,W
13500:  SUBLW  02
13502:  BNZ   13510
13504:  MOVF   03,F
13506:  BNZ   13510
....................       { 
....................          break; 
13508:  MOVLB  8
1350A:  BRA    13600
....................       } 
1350C:  BRA    135FC
1350E:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
13510:  MOVLW  01
13512:  MOVLB  8
13514:  ADDWF  xAE,W
13516:  MOVWF  xAF
13518:  MOVLW  A2
1351A:  MOVWF  FF6
1351C:  MOVLW  1C
1351E:  MOVWF  FF7
13520:  MOVLW  00
13522:  MOVWF  FF8
13524:  CLRF   1B
13526:  BTFSC  FF2.7
13528:  BSF    1B.7
1352A:  BCF    FF2.7
1352C:  MOVLW  05
1352E:  MOVLB  A
13530:  MOVWF  x25
13532:  MOVLB  0
13534:  CALL   101E
13538:  BTFSC  1B.7
1353A:  BSF    FF2.7
1353C:  CLRF   1B
1353E:  BTFSC  FF2.7
13540:  BSF    1B.7
13542:  BCF    FF2.7
13544:  MOVFF  8AF,A25
13548:  MOVLW  1B
1354A:  MOVLB  A
1354C:  MOVWF  x26
1354E:  MOVLB  0
13550:  CALL   0FA0
13554:  BTFSC  1B.7
13556:  BSF    FF2.7
13558:  MOVLW  0D
1355A:  BTFSS  F9E.4
1355C:  BRA    1355A
1355E:  MOVWF  FAD
13560:  MOVLW  0A
13562:  BTFSS  F9E.4
13564:  BRA    13562
13566:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
13568:  BCF    F90.7
....................          delay_ms(1000); 
1356A:  MOVLW  04
1356C:  MOVLB  8
1356E:  MOVWF  xAF
13570:  MOVLW  FA
13572:  MOVLB  9
13574:  MOVWF  xD6
13576:  MOVLB  0
13578:  CALL   2972
1357C:  MOVLB  8
1357E:  DECFSZ xAF,F
13580:  BRA    13570
....................          output_bit(VDET,ON); 
13582:  BSF    F90.7
....................          delay_ms(1000); 
13584:  MOVLW  04
13586:  MOVWF  xAF
13588:  MOVLW  FA
1358A:  MOVLB  9
1358C:  MOVWF  xD6
1358E:  MOVLB  0
13590:  CALL   2972
13594:  MOVLB  8
13596:  DECFSZ xAF,F
13598:  BRA    13588
....................          if (LightTargetFlag==0) 
1359A:  MOVLB  2
1359C:  MOVF   xD5,F
1359E:  BNZ   135E6
....................          { 
....................           cmd='K'; 
135A0:  MOVLW  4B
135A2:  MOVWF  43
....................           arg=detector_ch; 
135A4:  CLRF   47
135A6:  CLRF   46
135A8:  CLRF   45
135AA:  MOVFF  2D2,44
....................           det_cmd(); 
135AE:  MOVLB  0
135B0:  CALL   F184
....................           delay_ms(1000); 
135B4:  MOVLW  04
135B6:  MOVLB  8
135B8:  MOVWF  xAF
135BA:  MOVLW  FA
135BC:  MOVLB  9
135BE:  MOVWF  xD6
135C0:  MOVLB  0
135C2:  CALL   2972
135C6:  MOVLB  8
135C8:  DECFSZ xAF,F
135CA:  BRA    135BA
....................           cmd='L'; 
135CC:  MOVLW  4C
135CE:  MOVWF  43
....................           arg=detector_li; 
135D0:  CLRF   47
135D2:  CLRF   46
135D4:  MOVFF  2D4,45
135D8:  MOVFF  2D3,44
....................           det_cmd(); 
135DC:  MOVLB  0
135DE:  CALL   F184
....................          }  
135E2:  BRA    135FA
135E4:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
135E6:  MOVLW  6C
135E8:  MOVWF  43
....................           arg=1; 
135EA:  CLRF   47
135EC:  CLRF   46
135EE:  CLRF   45
135F0:  MOVLW  01
135F2:  MOVWF  44
....................           det_cmd(); 
135F4:  MOVLB  0
135F6:  CALL   F184
135FA:  MOVLB  8
....................          }  
....................       } 
135FC:  INCF   xAE,F
135FE:  BRA    134E4
....................    } 
....................  
....................    parse_data(); 
13600:  MOVLB  0
13602:  RCALL  1345E
....................    data_available = TRUE; 
13604:  MOVLW  01
13606:  MOVLB  3
13608:  MOVWF  x37
....................    macro_flag = 900; 
1360A:  MOVLW  03
1360C:  MOVWF  x20
1360E:  MOVLW  84
13610:  MOVWF  x1F
....................  
....................    return; 
13612:  MOVLB  0
13614:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
13980:  MOVLB  8
13982:  CLRF   xB7
13984:  CLRF   xB6
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
13986:  MOVLB  0
13988:  RCALL  1345E
1398A:  MOVFF  02,8B7
1398E:  MOVFF  01,8B6
....................    return (temp); 
13992:  MOVLB  8
13994:  MOVFF  8B6,01
13998:  MOVFF  8B7,02
1399C:  MOVLB  0
1399E:  GOTO   13AB0 (RETURN)
.................... } 
....................  
.................... void det_temp() 
139A2:  MOVLB  8
139A4:  CLRF   xB3
139A6:  CLRF   xB2
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
139A8:  MOVLB  2
139AA:  MOVF   xD1,W
139AC:  XORLW  01
139AE:  MOVLB  0
139B0:  BZ    139B8
139B2:  XORLW  03
139B4:  BZ    139C2
139B6:  BRA    139CC
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
139B8:  MOVFF  3E,8B5
139BC:  MOVFF  3D,8B4
....................          break; 
139C0:  BRA    139D8
....................       case 2 : target_temp = nv_d2_temp; 
139C2:  MOVFF  40,8B5
139C6:  MOVFF  3F,8B4
....................          break; 
139CA:  BRA    139D8
....................       default : target_temp = 20000; 
139CC:  MOVLW  4E
139CE:  MOVLB  8
139D0:  MOVWF  xB5
139D2:  MOVLW  20
139D4:  MOVWF  xB4
....................          break; 
139D6:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
139D8:  MOVLB  8
139DA:  CLRF   xB1
139DC:  MOVLW  3C
139DE:  MOVWF  xB0
....................    n = 0; 
139E0:  CLRF   xAF
139E2:  CLRF   xAE
....................    store=FALSE; 
139E4:  CLRF   xAC
....................    display=FALSE; 
139E6:  CLRF   xAD
....................  
....................    time_stamp(); 
139E8:  MOVLB  0
139EA:  CALL   5472
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
139EE:  MOVLW  01
139F0:  MOVWF  1E
139F2:  MOVLW  A3
139F4:  MOVWF  1D
139F6:  MOVLW  AC
139F8:  MOVWF  FF6
139FA:  MOVLW  1C
139FC:  MOVWF  FF7
139FE:  MOVLW  00
13A00:  MOVWF  FF8
13A02:  MOVLW  16
13A04:  MOVLB  8
13A06:  MOVWF  xD5
13A08:  MOVLB  0
13A0A:  CALL   AB04
13A0E:  MOVLW  10
13A10:  MOVWF  FE9
13A12:  MOVFF  8B5,8E1
13A16:  MOVFF  8B4,8E0
13A1A:  CALL   AB36
13A1E:  MOVLW  C5
13A20:  MOVWF  FF6
13A22:  MOVLW  1C
13A24:  MOVWF  FF7
13A26:  MOVLW  00
13A28:  MOVWF  FF8
13A2A:  MOVLW  09
13A2C:  MOVLB  8
13A2E:  MOVWF  xD5
13A30:  MOVLB  0
13A32:  CALL   AB04
13A36:  MOVLW  10
13A38:  MOVWF  FE9
13A3A:  MOVFF  8B3,8E1
13A3E:  MOVFF  8B2,8E0
13A42:  CALL   AB36
13A46:  MOVLW  D1
13A48:  MOVWF  FF6
13A4A:  MOVLW  1C
13A4C:  MOVWF  FF7
13A4E:  MOVLW  00
13A50:  MOVWF  FF8
13A52:  MOVLW  0B
13A54:  MOVLB  8
13A56:  MOVWF  xD5
13A58:  MOVLB  0
13A5A:  CALL   AB04
13A5E:  MOVLW  10
13A60:  MOVWF  FE9
13A62:  MOVFF  8AF,8E1
13A66:  MOVFF  8AE,8E0
13A6A:  CALL   AB36
13A6E:  MOVLW  DF
13A70:  MOVWF  FF6
13A72:  MOVLW  1C
13A74:  MOVWF  FF7
13A76:  MOVLW  00
13A78:  MOVWF  FF8
13A7A:  MOVLW  03
13A7C:  MOVLB  8
13A7E:  MOVWF  xD5
13A80:  MOVLB  0
13A82:  CALL   AB04
....................    record_event(); 
13A86:  CALL   851A
....................  
....................    for (n=1; n<t; ++n) 
13A8A:  MOVLB  8
13A8C:  CLRF   xAF
13A8E:  MOVLW  01
13A90:  MOVWF  xAE
13A92:  MOVF   xAF,W
13A94:  SUBWF  xB1,W
13A96:  BNC   13AF2
13A98:  BNZ   13AA0
13A9A:  MOVF   xB0,W
13A9C:  SUBWF  xAE,W
13A9E:  BC    13AF2
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
13AA0:  MOVFF  8AC,8B6
13AA4:  MOVFF  8AD,8B7
13AA8:  MOVLB  0
13AAA:  CALL   12CF2
....................       current_temp=parse_temp(); 
13AAE:  BRA    13980
13AB0:  MOVFF  02,8B3
13AB4:  MOVFF  01,8B2
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
13AB8:  MOVLB  8
13ABA:  MOVF   xB5,W
13ABC:  SUBWF  xB3,W
13ABE:  BNC   13AC8
13AC0:  BNZ   13AD0
13AC2:  MOVF   xB4,W
13AC4:  SUBWF  xB2,W
13AC6:  BC    13AD0
13AC8:  MOVF   xB2,F
13ACA:  BNZ   13AD4
13ACC:  MOVF   xB3,F
13ACE:  BNZ   13AD4
13AD0:  BRA    13AF2
13AD2:  BRA    13AEA
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13AD4:  MOVLW  0A
13AD6:  MOVWF  xB6
13AD8:  MOVLW  FA
13ADA:  MOVLB  9
13ADC:  MOVWF  xD6
13ADE:  MOVLB  0
13AE0:  CALL   2972
13AE4:  MOVLB  8
13AE6:  DECFSZ xB6,F
13AE8:  BRA    13AD8
13AEA:  INCF   xAE,F
13AEC:  BTFSC  FD8.2
13AEE:  INCF   xAF,F
13AF0:  BRA    13A92
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13AF2:  MOVLW  01
13AF4:  MOVWF  1E
13AF6:  MOVLW  A3
13AF8:  MOVWF  1D
13AFA:  MOVLW  E4
13AFC:  MOVWF  FF6
13AFE:  MOVLW  1C
13B00:  MOVWF  FF7
13B02:  MOVLW  00
13B04:  MOVWF  FF8
13B06:  MOVLW  14
13B08:  MOVWF  xD5
13B0A:  MOVLB  0
13B0C:  CALL   AB04
13B10:  MOVLW  10
13B12:  MOVWF  FE9
13B14:  MOVFF  8B5,8E1
13B18:  MOVFF  8B4,8E0
13B1C:  CALL   AB36
13B20:  MOVLW  FB
13B22:  MOVWF  FF6
13B24:  MOVLW  1C
13B26:  MOVWF  FF7
13B28:  MOVLW  00
13B2A:  MOVWF  FF8
13B2C:  MOVLW  09
13B2E:  MOVLB  8
13B30:  MOVWF  xD5
13B32:  MOVLB  0
13B34:  CALL   AB04
13B38:  MOVLW  10
13B3A:  MOVWF  FE9
13B3C:  MOVFF  8B3,8E1
13B40:  MOVFF  8B2,8E0
13B44:  CALL   AB36
13B48:  MOVLW  07
13B4A:  MOVWF  FF6
13B4C:  MOVLW  1D
13B4E:  MOVWF  FF7
13B50:  MOVLW  00
13B52:  MOVWF  FF8
13B54:  MOVLW  0B
13B56:  MOVLB  8
13B58:  MOVWF  xD5
13B5A:  MOVLB  0
13B5C:  CALL   AB04
13B60:  MOVLW  10
13B62:  MOVWF  FE9
13B64:  MOVFF  8AF,8E1
13B68:  MOVFF  8AE,8E0
13B6C:  CALL   AB36
13B70:  MOVLW  15
13B72:  MOVWF  FF6
13B74:  MOVLW  1D
13B76:  MOVWF  FF7
13B78:  MOVLW  00
13B7A:  MOVWF  FF8
13B7C:  MOVLW  03
13B7E:  MOVLB  8
13B80:  MOVWF  xD5
13B82:  MOVLB  0
13B84:  CALL   AB04
....................    record_event();    
13B88:  CALL   851A
13B8C:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
13658:  MOVLB  8
1365A:  CLRF   xBF
1365C:  CLRF   xBE
1365E:  CLRF   xBD
13660:  CLRF   xBC
....................    set_adc_channel(1,VSS); 
13662:  MOVLW  04
13664:  MOVWF  01
13666:  MOVF   FC2,W
13668:  ANDLW  83
1366A:  IORWF  01,W
1366C:  MOVWF  FC2
1366E:  MOVLW  00
13670:  MOVWF  01
13672:  MOVF   FC1,W
13674:  ANDLW  F8
13676:  IORWF  01,W
13678:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
1367A:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
1367C:  MOVLW  01
1367E:  MOVWF  xB9
13680:  MOVF   xB9,W
13682:  SUBLW  32
13684:  BNC   136AA
....................       reading=read_adc(); 
13686:  BSF    FC2.1
13688:  BTFSC  FC2.1
1368A:  BRA    13688
1368C:  MOVFF  FC3,8C0
13690:  MOVFF  FC4,8C1
13694:  CLRF   xC2
13696:  CLRF   xC3
....................       delay_ms(5); 
13698:  MOVLW  05
1369A:  MOVLB  9
1369C:  MOVWF  xD6
1369E:  MOVLB  0
136A0:  CALL   2972
136A4:  MOVLB  8
136A6:  INCF   xB9,F
136A8:  BRA    13680
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
136AA:  MOVLW  01
136AC:  MOVWF  xB9
136AE:  MOVF   xB9,W
136B0:  SUBLW  64
136B2:  BNC   13760
....................       reading=read_adc(); 
136B4:  BSF    FC2.1
136B6:  BTFSC  FC2.1
136B8:  BRA    136B6
136BA:  MOVFF  FC3,8C0
136BE:  MOVFF  FC4,8C1
136C2:  CLRF   xC2
136C4:  CLRF   xC3
....................       result=(((result*(i-1))+reading)/i); 
136C6:  MOVLW  01
136C8:  SUBWF  xB9,W
136CA:  MOVWF  xC4
136CC:  MOVFF  8BF,9E3
136D0:  MOVFF  8BE,9E2
136D4:  MOVFF  8BD,9E1
136D8:  MOVFF  8BC,9E0
136DC:  MOVLB  9
136DE:  CLRF   xE7
136E0:  CLRF   xE6
136E2:  CLRF   xE5
136E4:  MOVWF  xE4
136E6:  MOVLB  0
136E8:  CALL   4852
136EC:  MOVFF  03,8C7
136F0:  MOVFF  02,8C6
136F4:  MOVFF  01,8C5
136F8:  MOVFF  00,8C4
136FC:  MOVLB  8
136FE:  MOVF   xC0,W
13700:  ADDWF  xC4,F
13702:  MOVF   xC1,W
13704:  ADDWFC xC5,F
13706:  MOVF   xC2,W
13708:  ADDWFC xC6,F
1370A:  MOVF   xC3,W
1370C:  ADDWFC xC7,F
1370E:  BCF    FD8.1
13710:  CLRF   1B
13712:  BTFSC  FF2.7
13714:  BSF    1B.7
13716:  BCF    FF2.7
13718:  MOVFF  8C7,A34
1371C:  MOVFF  8C6,A33
13720:  MOVFF  8C5,A32
13724:  MOVFF  8C4,A31
13728:  MOVLB  A
1372A:  CLRF   x38
1372C:  CLRF   x37
1372E:  CLRF   x36
13730:  MOVFF  8B9,A35
13734:  MOVLB  0
13736:  CALL   1050
1373A:  BTFSC  1B.7
1373C:  BSF    FF2.7
1373E:  MOVFF  03,8BF
13742:  MOVFF  02,8BE
13746:  MOVFF  01,8BD
1374A:  MOVFF  00,8BC
....................       delay_ms(5); 
1374E:  MOVLW  05
13750:  MOVLB  9
13752:  MOVWF  xD6
13754:  MOVLB  0
13756:  CALL   2972
1375A:  MOVLB  8
1375C:  INCF   xB9,F
1375E:  BRA    136AE
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
13760:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
13762:  MOVFF  8BF,9E3
13766:  MOVFF  8BE,9E2
1376A:  MOVFF  8BD,9E1
1376E:  MOVFF  8BC,9E0
13772:  MOVLB  9
13774:  CLRF   xE7
13776:  CLRF   xE6
13778:  MOVLW  10
1377A:  MOVWF  xE5
1377C:  MOVLW  25
1377E:  MOVWF  xE4
13780:  MOVLB  0
13782:  CALL   4852
13786:  MOVFF  03,8C7
1378A:  MOVFF  02,8C6
1378E:  MOVFF  01,8C5
13792:  MOVFF  00,8C4
13796:  BCF    FD8.1
13798:  CLRF   1B
1379A:  BTFSC  FF2.7
1379C:  BSF    1B.7
1379E:  BCF    FF2.7
137A0:  MOVFF  03,A34
137A4:  MOVFF  02,A33
137A8:  MOVFF  01,A32
137AC:  MOVFF  00,A31
137B0:  MOVLB  A
137B2:  CLRF   x38
137B4:  CLRF   x37
137B6:  CLRF   x36
137B8:  MOVLW  64
137BA:  MOVWF  x35
137BC:  MOVLB  0
137BE:  CALL   1050
137C2:  BTFSC  1B.7
137C4:  BSF    FF2.7
137C6:  MOVLW  21
137C8:  MOVLB  8
137CA:  SUBWF  00,W
137CC:  MOVWF  xBA
137CE:  MOVLW  50
137D0:  SUBWFB 01,W
137D2:  MOVWF  xBB
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
137D4:  MOVFF  8BA,01
137D8:  MOVFF  8BB,02
137DC:  MOVLB  0
137DE:  GOTO   13844 (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
137EE:  CLRF   xB2
137F0:  CLRF   xB1
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
137E2:  MOVLW  0D
137E4:  MOVLB  8
137E6:  MOVWF  xAE
137E8:  MOVLW  0A
137EA:  MOVWF  xAF
137EC:  CLRF   xB0
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
137F2:  MOVLB  0
137F4:  CALL   1259E
....................    clear_data_buffer(); 
137F8:  CALL   D2AE
....................  
....................    time_stamp(); 
137FC:  CALL   5472
....................    strcpy(data_buffer, time_stmp_str); 
13800:  CLRF   FEA
13802:  MOVLW  63
13804:  MOVWF  FE9
13806:  MOVLW  02
13808:  MOVWF  FE2
1380A:  MOVLW  95
1380C:  MOVWF  FE1
1380E:  MOVF   FE7,F
13810:  MOVFF  FE6,FEE
13814:  BNZ   1380E
....................    strcat(data_buffer, (char *)",Tmp,"); 
13816:  MOVLW  2C
13818:  MOVLB  8
1381A:  MOVWF  xB3
1381C:  MOVLW  54
1381E:  MOVWF  xB4
13820:  MOVLW  6D
13822:  MOVWF  xB5
13824:  MOVLW  70
13826:  MOVWF  xB6
13828:  MOVLW  2C
1382A:  MOVWF  xB7
1382C:  CLRF   xB8
1382E:  CLRF   xE3
13830:  MOVLW  63
13832:  MOVWF  xE2
13834:  MOVLW  08
13836:  MOVWF  xE5
13838:  MOVLW  B3
1383A:  MOVWF  xE4
1383C:  MOVLB  0
1383E:  CALL   5536
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
13842:  BRA    13658
13844:  MOVFF  02,8B2
13848:  MOVFF  01,8B1
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
1384C:  MOVLW  02
1384E:  MOVWF  1E
13850:  MOVLW  43
13852:  MOVWF  1D
13854:  MOVLW  45
13856:  MOVWF  FE9
13858:  MOVLB  8
1385A:  CLRF   xDA
1385C:  CLRF   xD9
1385E:  MOVFF  8B2,8D8
13862:  MOVFF  8B1,8D7
13866:  MOVLW  03
13868:  MOVWF  xDB
1386A:  MOVLB  0
1386C:  CALL   5372
....................  
....................    strcat(slave_reply, endofline); 
13870:  MOVLW  02
13872:  MOVLB  8
13874:  MOVWF  xE3
13876:  MOVLW  43
13878:  MOVWF  xE2
1387A:  MOVLW  08
1387C:  MOVWF  xE5
1387E:  MOVLW  AE
13880:  MOVWF  xE4
13882:  MOVLB  0
13884:  CALL   5536
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13888:  MOVLB  8
1388A:  CLRF   xD6
1388C:  MOVLW  63
1388E:  MOVWF  xD5
13890:  MOVLB  0
13892:  CALL   12B28
13896:  MOVFF  02,03
1389A:  MOVF   01,W
1389C:  XORLW  FF
1389E:  ADDLW  A1
138A0:  MOVLB  8
138A2:  MOVWF  xB9
138A4:  MOVLW  00
138A6:  SUBFWB 02,W
138A8:  MOVWF  xBA
138AA:  MOVLW  01
138AC:  SUBWF  xB9,F
138AE:  MOVLW  00
138B0:  SUBWFB xBA,F
138B2:  CLRF   xD8
138B4:  MOVLW  63
138B6:  MOVWF  xD7
138B8:  MOVLW  02
138BA:  MOVWF  xDA
138BC:  MOVLW  43
138BE:  MOVWF  xD9
138C0:  MOVFF  8BA,8DC
138C4:  MOVFF  8B9,8DB
138C8:  MOVLB  0
138CA:  CALL   12B64
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
138CE:  MOVF   1F,F
138D0:  BNZ   138F0
138D2:  MOVF   20,F
138D4:  BNZ   138F0
138D6:  MOVLB  8
138D8:  DECFSZ xAD,W
138DA:  BRA    138DE
138DC:  BRA    138E2
138DE:  MOVLB  0
138E0:  BRA    138F0
138E2:  CLRF   FEA
138E4:  MOVLW  63
138E6:  MOVWF  FE9
138E8:  MOVLB  0
138EA:  CALL   79DC
138EE:  BRA    13904
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
138F0:  MOVF   20,F
138F2:  BNZ   138FA
138F4:  MOVF   1F,W
138F6:  SUBLW  03
138F8:  BC    13904
138FA:  CLRF   FEA
138FC:  MOVLW  63
138FE:  MOVWF  FE9
13900:  CALL   79DC
....................  
....................    if (store == TRUE && sd_status==0) { 
13904:  MOVLB  8
13906:  DECFSZ xAC,W
13908:  BRA    13968
1390A:  MOVLB  2
1390C:  MOVF   xD8,F
1390E:  BTFSC  FD8.2
13910:  BRA    13916
13912:  MOVLB  8
13914:  BRA    13968
....................       buffer_select = 0; 
13916:  MOVLB  0
13918:  CLRF   x62
....................       
....................       heartbeat(FALSE); 
1391A:  MOVLB  8
1391C:  CLRF   xD7
1391E:  MOVLB  0
13920:  CALL   55DA
....................          append_data(file_ptr_raw_all); 
13924:  MOVLW  02
13926:  MOVLB  8
13928:  MOVWF  xD8
1392A:  MOVLW  D9
1392C:  MOVWF  xD7
1392E:  MOVLB  0
13930:  CALL   8338
....................       heartbeat(TRUE); 
13934:  MOVLW  01
13936:  MOVLB  8
13938:  MOVWF  xD7
1393A:  MOVLB  0
1393C:  CALL   55DA
....................        
....................       heartbeat(FALSE); 
13940:  MOVLB  8
13942:  CLRF   xD7
13944:  MOVLB  0
13946:  CALL   55DA
....................          append_data(file_ptr_raw_new); 
1394A:  MOVLW  02
1394C:  MOVLB  8
1394E:  MOVWF  xD8
13950:  MOVLW  E7
13952:  MOVWF  xD7
13954:  MOVLB  0
13956:  CALL   8338
....................       heartbeat(TRUE); 
1395A:  MOVLW  01
1395C:  MOVLB  8
1395E:  MOVWF  xD7
13960:  MOVLB  0
13962:  CALL   55DA
13966:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13968:  MOVLW  03
1396A:  MOVLB  3
1396C:  MOVWF  x20
1396E:  MOVLW  84
13970:  MOVWF  x1F
....................     
....................    return (temp); 
13972:  MOVLB  8
13974:  MOVFF  8B1,01
13978:  MOVFF  8B2,02
1397C:  MOVLB  0
1397E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
124B0:  MOVLB  8
124B2:  MOVF   xAF,W
124B4:  ADDLW  FC
124B6:  BC    124F4
124B8:  ADDLW  04
124BA:  MOVLB  0
124BC:  GOTO   124FC
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
124C0:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
124C2:  BCF    F8C.1
....................          break; 
124C4:  MOVLB  8
124C6:  BRA    124F4
....................       case 1 :  
....................             output_bit(HSW1, ON); 
124C8:  BSF    F8C.0
....................          break; 
124CA:  MOVLB  8
124CC:  BRA    124F4
....................       case 2 :  
....................             output_bit(HSW2, ON); 
124CE:  BSF    F8C.1
....................          break;  
124D0:  MOVLB  8
124D2:  BRA    124F4
....................       case 3 :  
....................             output_bit(HSW1, ON); 
124D4:  BSF    F8C.0
....................             delay_ms(500); 
124D6:  MOVLW  02
124D8:  MOVLB  8
124DA:  MOVWF  xB0
124DC:  MOVLW  FA
124DE:  MOVLB  9
124E0:  MOVWF  xD6
124E2:  MOVLB  0
124E4:  CALL   2972
124E8:  MOVLB  8
124EA:  DECFSZ xB0,F
124EC:  BRA    124DC
....................             output_bit(HSW2, ON); 
124EE:  BSF    F8C.1
....................          break;             
124F0:  BRA    124F4
124F2:  MOVLB  8
....................    } 
....................    heater_stat=set; 
124F4:  MOVFF  8AF,4B1
124F8:  MOVLB  0
124FA:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F5AC:  MOVLW  08
0F5AE:  MOVLB  8
0F5B0:  MOVWF  xB6
0F5B2:  CLRF   xB5
....................    LED_level_change=2048; 
0F5B4:  MOVWF  xB8
0F5B6:  CLRF   xB7
....................     
....................    for (i=0; i<12; i++){ 
0F5B8:  CLRF   xB4
0F5BA:  MOVF   xB4,W
0F5BC:  SUBLW  0B
0F5BE:  BNC   F636
....................       DAC_set(1,LED_level); 
0F5C0:  MOVLW  01
0F5C2:  MOVWF  xBD
0F5C4:  MOVFF  8B6,8BF
0F5C8:  MOVFF  8B5,8BE
0F5CC:  MOVLB  0
0F5CE:  RCALL  F2FA
....................       LED_level_change = LED_level_change/2; 
0F5D0:  BCF    FD8.0
0F5D2:  MOVLB  8
0F5D4:  RRCF   xB8,F
0F5D6:  RRCF   xB7,F
....................       ADC_average(200); 
0F5D8:  CLRF   xBE
0F5DA:  MOVLW  C8
0F5DC:  MOVWF  xBD
0F5DE:  MOVLB  0
0F5E0:  RCALL  F3A2
....................       output = ADC_val[2]; 
0F5E2:  MOVFF  4A6,8BA
0F5E6:  MOVFF  4A5,8B9
....................       temp = ADC_val[3]; 
0F5EA:  MOVFF  4A8,8BC
0F5EE:  MOVFF  4A7,8BB
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F5F2:  MOVLB  8
0F5F4:  MOVF   xB3,W
0F5F6:  SUBWF  xBA,W
0F5F8:  BNC   F60C
0F5FA:  BNZ   F602
0F5FC:  MOVF   xB9,W
0F5FE:  SUBWF  xB2,W
0F600:  BC    F60C
....................          LED_level=LED_level-LED_level_change; 
0F602:  MOVF   xB7,W
0F604:  SUBWF  xB5,F
0F606:  MOVF   xB8,W
0F608:  SUBWFB xB6,F
....................       } 
0F60A:  BRA    F632
....................       else if(output<intensity){ 
0F60C:  MOVF   xBA,W
0F60E:  SUBWF  xB3,W
0F610:  BNC   F624
0F612:  BNZ   F61A
0F614:  MOVF   xB2,W
0F616:  SUBWF  xB9,W
0F618:  BC    F624
....................          LED_level=LED_level+LED_level_change; 
0F61A:  MOVF   xB7,W
0F61C:  ADDWF  xB5,F
0F61E:  MOVF   xB8,W
0F620:  ADDWFC xB6,F
....................       } 
0F622:  BRA    F632
....................       else if(output==intensity) break; 
0F624:  MOVF   xB2,W
0F626:  SUBWF  xB9,W
0F628:  BNZ   F632
0F62A:  MOVF   xB3,W
0F62C:  SUBWF  xBA,W
0F62E:  BTFSC  FD8.2
0F630:  BRA    F636
0F632:  INCF   xB4,F
0F634:  BRA    F5BA
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F636:  MOVLW  01
0F638:  MOVWF  xBD
0F63A:  MOVFF  8B6,8BF
0F63E:  MOVFF  8B5,8BE
0F642:  MOVLB  0
0F644:  RCALL  F2FA
0F646:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F648:  MOVLW  01
0F64A:  MOVLB  8
0F64C:  MOVWF  xB1
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F64E:  MOVF   xAF,F
0F650:  BNZ   F656
0F652:  MOVF   xB0,F
0F654:  BZ    F66A
0F656:  MOVF   xB0,W
0F658:  SUBLW  0F
0F65A:  BNC   F66A
0F65C:  MOVFF  8B0,8B3
0F660:  MOVFF  8AF,8B2
0F664:  MOVLB  0
0F666:  RCALL  F5AC
0F668:  MOVLB  8
....................   if(intensity == 0) { 
0F66A:  MOVF   xAF,F
0F66C:  BNZ   F690
0F66E:  MOVF   xB0,F
0F670:  BNZ   F690
....................       DAC_set(1, 0); 
0F672:  MOVLW  01
0F674:  MOVWF  xBD
0F676:  CLRF   xBF
0F678:  CLRF   xBE
0F67A:  MOVLB  0
0F67C:  RCALL  F2FA
....................       DAC_set(2, 0); 
0F67E:  MOVLW  02
0F680:  MOVLB  8
0F682:  MOVWF  xBD
0F684:  CLRF   xBF
0F686:  CLRF   xBE
0F688:  MOVLB  0
0F68A:  RCALL  F2FA
....................    } 
0F68C:  BRA    F694
0F68E:  MOVLB  8
....................    else valid=FALSE; 
0F690:  CLRF   xB1
0F692:  MOVLB  0
....................    return(valid); 
0F694:  MOVLB  8
0F696:  MOVFF  8B1,01
0F69A:  MOVLB  0
0F69C:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FC1E:  MOVLW  1A
0FC20:  MOVWF  FF6
0FC22:  MOVLW  1D
0FC24:  MOVWF  FF7
0FC26:  MOVLW  00
0FC28:  MOVWF  FF8
0FC2A:  MOVLW  03
0FC2C:  MOVWF  FEA
0FC2E:  MOVLW  39
0FC30:  MOVWF  FE9
0FC32:  RCALL  FBE4
0FC34:  MOVF   01,W
0FC36:  BZ    FC4A
0FC38:  XORLW  01
0FC3A:  BZ    FC6A
0FC3C:  XORLW  03
0FC3E:  BZ    FC8A
0FC40:  XORLW  01
0FC42:  BZ    FCAA
0FC44:  XORLW  07
0FC46:  BZ    FCCA
0FC48:  BRA    FCE8
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FC4A:  BCF    FD8.0
0FC4C:  MOVLB  3
0FC4E:  RLCF   x46,W
0FC50:  CLRF   03
0FC52:  ADDLW  47
0FC54:  MOVWF  FE9
0FC56:  MOVLW  03
0FC58:  ADDWFC 03,W
0FC5A:  MOVWF  FEA
0FC5C:  MOVFF  4A4,FEC
0FC60:  MOVF   FED,F
0FC62:  MOVFF  4A3,FEF
....................          break; 
0FC66:  MOVLB  0
0FC68:  BRA    FCE8
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FC6A:  BCF    FD8.0
0FC6C:  MOVLB  3
0FC6E:  RLCF   x46,W
0FC70:  CLRF   03
0FC72:  ADDLW  59
0FC74:  MOVWF  FE9
0FC76:  MOVLW  03
0FC78:  ADDWFC 03,W
0FC7A:  MOVWF  FEA
0FC7C:  MOVFF  4A4,FEC
0FC80:  MOVF   FED,F
0FC82:  MOVFF  4A3,FEF
....................          break;    
0FC86:  MOVLB  0
0FC88:  BRA    FCE8
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FC8A:  BCF    FD8.0
0FC8C:  MOVLB  3
0FC8E:  RLCF   x46,W
0FC90:  CLRF   03
0FC92:  ADDLW  6B
0FC94:  MOVWF  FE9
0FC96:  MOVLW  03
0FC98:  ADDWFC 03,W
0FC9A:  MOVWF  FEA
0FC9C:  MOVFF  4A4,FEC
0FCA0:  MOVF   FED,F
0FCA2:  MOVFF  4A3,FEF
....................          break; 
0FCA6:  MOVLB  0
0FCA8:  BRA    FCE8
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FCAA:  BCF    FD8.0
0FCAC:  MOVLB  3
0FCAE:  RLCF   x46,W
0FCB0:  CLRF   03
0FCB2:  ADDLW  7D
0FCB4:  MOVWF  FE9
0FCB6:  MOVLW  03
0FCB8:  ADDWFC 03,W
0FCBA:  MOVWF  FEA
0FCBC:  MOVFF  4A4,FEC
0FCC0:  MOVF   FED,F
0FCC2:  MOVFF  4A3,FEF
....................          break; 
0FCC6:  MOVLB  0
0FCC8:  BRA    FCE8
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FCCA:  BCF    FD8.0
0FCCC:  MOVLB  3
0FCCE:  RLCF   x46,W
0FCD0:  CLRF   03
0FCD2:  ADDLW  8F
0FCD4:  MOVWF  FE9
0FCD6:  MOVLW  03
0FCD8:  ADDWFC 03,W
0FCDA:  MOVWF  FEA
0FCDC:  MOVFF  4A4,FEC
0FCE0:  MOVF   FED,F
0FCE2:  MOVFF  4A3,FEF
....................          break; 
0FCE6:  MOVLB  0
....................    } 
0FCE8:  GOTO   FFCC (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
0FD8A:  MOVFF  8AD,8BE
0FD8E:  MOVFF  8AC,8BD
0FD92:  CALL   F3A2
....................     
....................    v_supply = read_supply(); 
0FD96:  CALL   5154
0FD9A:  MOVFF  02,8B2
0FD9E:  MOVFF  01,8B1
....................        
....................    RTC_reset_HT(); 
0FDA2:  CALL   3514
....................    RTC_read(); 
0FDA6:  CALL   33A6
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
0FDAA:  RCALL  F6B6
0FDAC:  MOVFF  02,8B4
0FDB0:  MOVFF  01,8B3
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
0FDB4:  MOVLB  8
0FDB6:  DECFSZ xB0,W
0FDB8:  BRA    FDE2
0FDBA:  MOVLW  10
0FDBC:  MOVWF  FE9
0FDBE:  CLRF   1B
0FDC0:  BTFSC  FF2.7
0FDC2:  BSF    1B.7
0FDC4:  BCF    FF2.7
0FDC6:  MOVFF  4A6,A26
0FDCA:  MOVFF  4A5,A25
0FDCE:  MOVLB  0
0FDD0:  CALL   11A0
0FDD4:  BTFSC  1B.7
0FDD6:  BSF    FF2.7
0FDD8:  MOVLW  2C
0FDDA:  BTFSS  F9E.4
0FDDC:  BRA    FDDA
0FDDE:  MOVWF  FAD
0FDE0:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
0FDE2:  CLRF   1E
0FDE4:  MOVLW  63
0FDE6:  MOVWF  1D
0FDE8:  MOVFF  726,8D7
0FDEC:  MOVLW  01
0FDEE:  MOVWF  xD8
0FDF0:  MOVLB  0
0FDF2:  CALL   52D8
0FDF6:  MOVLW  2F
0FDF8:  MOVLB  8
0FDFA:  MOVWF  xE9
0FDFC:  MOVLB  0
0FDFE:  CALL   50F6
0FE02:  MOVFF  725,8D7
0FE06:  MOVLW  01
0FE08:  MOVLB  8
0FE0A:  MOVWF  xD8
0FE0C:  MOVLB  0
0FE0E:  CALL   52D8
0FE12:  MOVLW  2F
0FE14:  MOVLB  8
0FE16:  MOVWF  xE9
0FE18:  MOVLB  0
0FE1A:  CALL   50F6
0FE1E:  MOVFF  727,8D7
0FE22:  MOVLW  01
0FE24:  MOVLB  8
0FE26:  MOVWF  xD8
0FE28:  MOVLB  0
0FE2A:  CALL   52D8
0FE2E:  MOVLW  20
0FE30:  MOVLB  8
0FE32:  MOVWF  xE9
0FE34:  MOVLB  0
0FE36:  CALL   50F6
0FE3A:  MOVFF  723,8D7
0FE3E:  MOVLW  01
0FE40:  MOVLB  8
0FE42:  MOVWF  xD8
0FE44:  MOVLB  0
0FE46:  CALL   52D8
0FE4A:  MOVLW  3A
0FE4C:  MOVLB  8
0FE4E:  MOVWF  xE9
0FE50:  MOVLB  0
0FE52:  CALL   50F6
0FE56:  MOVFF  722,8D7
0FE5A:  MOVLW  01
0FE5C:  MOVLB  8
0FE5E:  MOVWF  xD8
0FE60:  MOVLB  0
0FE62:  CALL   52D8
0FE66:  MOVLW  3A
0FE68:  MOVLB  8
0FE6A:  MOVWF  xE9
0FE6C:  MOVLB  0
0FE6E:  CALL   50F6
0FE72:  MOVFF  721,8D7
0FE76:  MOVLW  01
0FE78:  MOVLB  8
0FE7A:  MOVWF  xD8
0FE7C:  MOVLB  0
0FE7E:  CALL   52D8
0FE82:  MOVLW  2C
0FE84:  MOVLB  8
0FE86:  MOVWF  xE9
0FE88:  MOVLB  0
0FE8A:  CALL   50F6
0FE8E:  MOVLW  04
0FE90:  MOVWF  FE9
0FE92:  MOVLB  8
0FE94:  CLRF   xDA
0FE96:  CLRF   xD9
0FE98:  MOVFF  8B2,8D8
0FE9C:  MOVFF  8B1,8D7
0FEA0:  MOVLW  02
0FEA2:  MOVWF  xDB
0FEA4:  MOVLB  0
0FEA6:  CALL   5372
0FEAA:  MOVLW  2C
0FEAC:  MOVLB  8
0FEAE:  MOVWF  xE9
0FEB0:  MOVLB  0
0FEB2:  CALL   50F6
0FEB6:  MOVFF  1E,FEA
0FEBA:  MOVFF  1D,FE9
0FEBE:  CLRF   FEF
0FEC0:  MOVLW  03
0FEC2:  MOVWF  FEA
0FEC4:  MOVLW  39
0FEC6:  MOVWF  FE9
0FEC8:  RCALL  FBBE
0FECA:  MOVLW  2C
0FECC:  MOVLB  8
0FECE:  MOVWF  xE9
0FED0:  MOVLB  0
0FED2:  CALL   50F6
0FED6:  MOVFF  1E,FEA
0FEDA:  MOVFF  1D,FE9
0FEDE:  CLRF   FEF
0FEE0:  MOVLW  03
0FEE2:  MOVWF  FEA
0FEE4:  MOVLW  3E
0FEE6:  MOVWF  FE9
0FEE8:  RCALL  FBBE
0FEEA:  MOVLW  2C
0FEEC:  MOVLB  8
0FEEE:  MOVWF  xE9
0FEF0:  MOVLB  0
0FEF2:  CALL   50F6
0FEF6:  MOVFF  1E,FEA
0FEFA:  MOVFF  1D,FE9
0FEFE:  CLRF   FEF
0FF00:  MOVLW  03
0FF02:  MOVWF  FEA
0FF04:  MOVLW  42
0FF06:  MOVWF  FE9
0FF08:  RCALL  FBBE
0FF0A:  MOVLW  2C
0FF0C:  MOVLB  8
0FF0E:  MOVWF  xE9
0FF10:  MOVLB  0
0FF12:  CALL   50F6
0FF16:  MOVLW  10
0FF18:  MOVWF  FE9
0FF1A:  MOVFF  26,8E1
0FF1E:  MOVFF  25,8E0
0FF22:  CALL   AB36
0FF26:  MOVLW  2C
0FF28:  MOVLB  8
0FF2A:  MOVWF  xE9
0FF2C:  MOVLB  0
0FF2E:  CALL   50F6
0FF32:  MOVLW  10
0FF34:  MOVWF  FE9
0FF36:  MOVFF  8B4,8E1
0FF3A:  MOVFF  8B3,8E0
0FF3E:  CALL   AB36
0FF42:  MOVLW  2C
0FF44:  MOVLB  8
0FF46:  MOVWF  xE9
0FF48:  MOVLB  0
0FF4A:  CALL   50F6
0FF4E:  MOVFF  4B1,8D7
0FF52:  MOVLW  1B
0FF54:  MOVLB  8
0FF56:  MOVWF  xD8
0FF58:  MOVLB  0
0FF5A:  CALL   52D8
0FF5E:  MOVLW  2C
0FF60:  MOVLB  8
0FF62:  MOVWF  xE9
0FF64:  MOVLB  0
0FF66:  CALL   50F6
0FF6A:  MOVLW  10
0FF6C:  MOVWF  FE9
0FF6E:  MOVFF  4A4,8E1
0FF72:  MOVFF  4A3,8E0
0FF76:  CALL   AB36
0FF7A:  MOVLW  2C
0FF7C:  MOVLB  8
0FF7E:  MOVWF  xE9
0FF80:  MOVLB  0
0FF82:  CALL   50F6
0FF86:  MOVLW  10
0FF88:  MOVWF  FE9
0FF8A:  MOVFF  4AA,8E1
0FF8E:  MOVFF  4A9,8E0
0FF92:  CALL   AB36
0FF96:  MOVLW  2C
0FF98:  MOVLB  8
0FF9A:  MOVWF  xE9
0FF9C:  MOVLB  0
0FF9E:  CALL   50F6
0FFA2:  MOVLW  10
0FFA4:  MOVWF  FE9
0FFA6:  MOVFF  4A8,8E1
0FFAA:  MOVFF  4A7,8E0
0FFAE:  CALL   AB36
0FFB2:  MOVLW  0D
0FFB4:  MOVLB  8
0FFB6:  MOVWF  xE9
0FFB8:  MOVLB  0
0FFBA:  CALL   50F6
0FFBE:  MOVLW  0A
0FFC0:  MOVLB  8
0FFC2:  MOVWF  xE9
0FFC4:  MOVLB  0
0FFC6:  CALL   50F6
....................  
....................    load_scanned_data();  
0FFCA:  BRA    FC1E
....................  
....................    display_rec(store, display); 
0FFCC:  MOVFF  8AE,8D5
0FFD0:  MOVFF  8AF,8D6
0FFD4:  RCALL  FCEC
....................     
....................    data_available = TRUE; 
0FFD6:  MOVLW  01
0FFD8:  MOVLB  3
0FFDA:  MOVWF  x37
....................    macro_flag = 900; 
0FFDC:  MOVLW  03
0FFDE:  MOVWF  x20
0FFE0:  MOVLW  84
0FFE2:  MOVWF  x1F
0FFE4:  MOVLB  0
0FFE6:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
*
10000:  MOVLB  8
10002:  CLRF   x75
10004:  CLRF   x74
....................    channel=channel-20000; 
10006:  MOVLW  20
10008:  SUBWF  x71,F
1000A:  MOVLW  4E
1000C:  SUBWFB x72,F
....................     
....................    for (i=0; i<9; i++){ 
1000E:  CLRF   x73
10010:  MOVF   x73,W
10012:  SUBLW  08
10014:  BTFSS  FD8.0
10016:  GOTO   100C2
....................       DAC_set(channel, setting); 
1001A:  MOVFF  871,8BD
1001E:  MOVFF  875,8BF
10022:  MOVFF  874,8BE
10026:  MOVLB  0
10028:  CALL   F2FA
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
1002C:  MOVLW  30
1002E:  MOVWF  FF6
10030:  MOVLW  1D
10032:  MOVWF  FF7
10034:  MOVLW  00
10036:  MOVWF  FF8
10038:  CLRF   1B
1003A:  BTFSC  FF2.7
1003C:  BSF    1B.7
1003E:  BCF    FF2.7
10040:  MOVLW  05
10042:  MOVLB  A
10044:  MOVWF  x25
10046:  MOVLB  0
10048:  CALL   101E
1004C:  BTFSC  1B.7
1004E:  BSF    FF2.7
10050:  MOVLW  10
10052:  MOVWF  FE9
10054:  CLRF   1B
10056:  BTFSC  FF2.7
10058:  BSF    1B.7
1005A:  BCF    FF2.7
1005C:  MOVFF  872,A26
10060:  MOVFF  871,A25
10064:  CALL   11A0
10068:  BTFSC  1B.7
1006A:  BSF    FF2.7
1006C:  MOVLW  2C
1006E:  BTFSS  F9E.4
10070:  GOTO   1006E
10074:  MOVWF  FAD
10076:  MOVLW  10
10078:  MOVWF  FE9
1007A:  CLRF   1B
1007C:  BTFSC  FF2.7
1007E:  BSF    1B.7
10080:  BCF    FF2.7
10082:  MOVFF  875,A26
10086:  MOVFF  874,A25
1008A:  CALL   11A0
1008E:  BTFSC  1B.7
10090:  BSF    FF2.7
10092:  MOVLW  2C
10094:  BTFSS  F9E.4
10096:  GOTO   10094
1009A:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1009C:  MOVLB  8
1009E:  CLRF   xAD
100A0:  MOVLW  C8
100A2:  MOVWF  xAC
100A4:  CLRF   xAE
100A6:  MOVLW  01
100A8:  MOVWF  xAF
100AA:  MOVWF  xB0
100AC:  MOVLB  0
100AE:  CALL   FD8A
....................       setting = setting+500; 
100B2:  MOVLW  F4
100B4:  MOVLB  8
100B6:  ADDWF  x74,F
100B8:  MOVLW  01
100BA:  ADDWFC x75,F
100BC:  INCF   x73,F
100BE:  GOTO   10010
....................    } 
100C2:  MOVLB  0
100C4:  GOTO   10220 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
100C8:  MOVLB  8
100CA:  CLRF   x71
100CC:  CLRF   x70
....................     
....................    for (i=0; i<9; i++){ 
100CE:  CLRF   x6F
100D0:  MOVF   x6F,W
100D2:  SUBLW  08
100D4:  BNC   1014E
....................       LED_SAR(intensity); 
100D6:  MOVFF  871,8B3
100DA:  MOVFF  870,8B2
100DE:  MOVLB  0
100E0:  CALL   F5AC
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
100E4:  MOVLW  3E
100E6:  MOVWF  FF6
100E8:  MOVLW  1D
100EA:  MOVWF  FF7
100EC:  MOVLW  00
100EE:  MOVWF  FF8
100F0:  CLRF   1B
100F2:  BTFSC  FF2.7
100F4:  BSF    1B.7
100F6:  BCF    FF2.7
100F8:  MOVLW  07
100FA:  MOVLB  A
100FC:  MOVWF  x25
100FE:  MOVLB  0
10100:  CALL   101E
10104:  BTFSC  1B.7
10106:  BSF    FF2.7
10108:  MOVLW  10
1010A:  MOVWF  FE9
1010C:  CLRF   1B
1010E:  BTFSC  FF2.7
10110:  BSF    1B.7
10112:  BCF    FF2.7
10114:  MOVFF  871,A26
10118:  MOVFF  870,A25
1011C:  CALL   11A0
10120:  BTFSC  1B.7
10122:  BSF    FF2.7
10124:  MOVLW  2C
10126:  BTFSS  F9E.4
10128:  BRA    10126
1012A:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1012C:  MOVLB  8
1012E:  CLRF   xAD
10130:  MOVLW  C8
10132:  MOVWF  xAC
10134:  CLRF   xAE
10136:  MOVLW  01
10138:  MOVWF  xAF
1013A:  MOVWF  xB0
1013C:  MOVLB  0
1013E:  RCALL  FD8A
....................       intensity = intensity+500; 
10140:  MOVLW  F4
10142:  MOVLB  8
10144:  ADDWF  x70,F
10146:  MOVLW  01
10148:  ADDWFC x71,F
1014A:  INCF   x6F,F
1014C:  BRA    100D0
....................    } 
1014E:  MOVLB  0
10150:  GOTO   10220 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
0311C:  MOVLB  8
0311E:  CLRF   xA0
03120:  MOVF   xA0,W
03122:  SUBLW  20
03124:  BNC   313A
03126:  CLRF   03
03128:  MOVF   xA0,W
0312A:  ADDLW  B3
0312C:  MOVWF  FE9
0312E:  MOVLW  04
03130:  ADDWFC 03,W
03132:  MOVWF  FEA
03134:  CLRF   FEF
03136:  INCF   xA0,F
03138:  BRA    3120
0313A:  MOVLB  0
0313C:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
0313E:  MOVF   2F,W
03140:  SUBLW  02
03142:  BNZ   314C
03144:  MOVF   30,F
03146:  BNZ   314C
03148:  MOVLW  00
0314A:  MOVWF  F99
....................    init_valve_status(); 
0314C:  RCALL  311C
....................    bus_pwr_status=0; 
0314E:  MOVLB  4
03150:  CLRF   xB2
03152:  MOVLB  0
03154:  GOTO   1B262 (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0EAE8:  MOVLW  4A
0EAEA:  MOVWF  FF6
0EAEC:  MOVLW  1D
0EAEE:  MOVWF  FF7
0EAF0:  MOVLW  00
0EAF2:  MOVWF  FF8
0EAF4:  CLRF   1B
0EAF6:  BTFSC  FF2.7
0EAF8:  BSF    1B.7
0EAFA:  BCF    FF2.7
0EAFC:  CALL   0DCC
0EB00:  BTFSC  1B.7
0EB02:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EB04:  MOVLW  01
0EB06:  MOVLB  8
0EB08:  MOVWF  xA0
0EB0A:  MOVF   xA0,W
0EB0C:  SUBLW  08
0EB0E:  BNC   EB78
0EB10:  CLRF   03
0EB12:  MOVF   xA0,W
0EB14:  ADDLW  B3
0EB16:  MOVWF  FE9
0EB18:  MOVLW  04
0EB1A:  ADDWFC 03,W
0EB1C:  MOVWF  FEA
0EB1E:  MOVFF  FEF,8A1
0EB22:  CLRF   1B
0EB24:  BTFSC  FF2.7
0EB26:  BSF    1B.7
0EB28:  BCF    FF2.7
0EB2A:  MOVFF  8A0,A25
0EB2E:  MOVLW  01
0EB30:  MOVLB  A
0EB32:  MOVWF  x26
0EB34:  MOVLB  0
0EB36:  CALL   0FA0
0EB3A:  BTFSC  1B.7
0EB3C:  BSF    FF2.7
0EB3E:  MOVLW  5B
0EB40:  BTFSS  F9E.4
0EB42:  BRA    EB40
0EB44:  MOVWF  FAD
0EB46:  CLRF   1B
0EB48:  BTFSC  FF2.7
0EB4A:  BSF    1B.7
0EB4C:  BCF    FF2.7
0EB4E:  MOVFF  8A1,A25
0EB52:  MOVLW  1B
0EB54:  MOVLB  A
0EB56:  MOVWF  x26
0EB58:  MOVLB  0
0EB5A:  CALL   0FA0
0EB5E:  BTFSC  1B.7
0EB60:  BSF    FF2.7
0EB62:  MOVLW  5D
0EB64:  BTFSS  F9E.4
0EB66:  BRA    EB64
0EB68:  MOVWF  FAD
0EB6A:  MOVLW  20
0EB6C:  BTFSS  F9E.4
0EB6E:  BRA    EB6C
0EB70:  MOVWF  FAD
0EB72:  MOVLB  8
0EB74:  INCF   xA0,F
0EB76:  BRA    EB0A
....................    fprintf(COM_A, "\r\n"); 
0EB78:  MOVLW  0D
0EB7A:  BTFSS  F9E.4
0EB7C:  BRA    EB7A
0EB7E:  MOVWF  FAD
0EB80:  MOVLW  0A
0EB82:  BTFSS  F9E.4
0EB84:  BRA    EB82
0EB86:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EB88:  MOVLW  50
0EB8A:  MOVWF  FF6
0EB8C:  MOVLW  1D
0EB8E:  MOVWF  FF7
0EB90:  MOVLW  00
0EB92:  MOVWF  FF8
0EB94:  CLRF   1B
0EB96:  BTFSC  FF2.7
0EB98:  BSF    1B.7
0EB9A:  BCF    FF2.7
0EB9C:  MOVLB  0
0EB9E:  CALL   0DCC
0EBA2:  BTFSC  1B.7
0EBA4:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EBA6:  MOVLW  09
0EBA8:  MOVLB  8
0EBAA:  MOVWF  xA0
0EBAC:  MOVF   xA0,W
0EBAE:  SUBLW  10
0EBB0:  BNC   EC1A
0EBB2:  CLRF   03
0EBB4:  MOVF   xA0,W
0EBB6:  ADDLW  B3
0EBB8:  MOVWF  FE9
0EBBA:  MOVLW  04
0EBBC:  ADDWFC 03,W
0EBBE:  MOVWF  FEA
0EBC0:  MOVFF  FEF,8A1
0EBC4:  CLRF   1B
0EBC6:  BTFSC  FF2.7
0EBC8:  BSF    1B.7
0EBCA:  BCF    FF2.7
0EBCC:  MOVFF  8A0,A25
0EBD0:  MOVLW  01
0EBD2:  MOVLB  A
0EBD4:  MOVWF  x26
0EBD6:  MOVLB  0
0EBD8:  CALL   0FA0
0EBDC:  BTFSC  1B.7
0EBDE:  BSF    FF2.7
0EBE0:  MOVLW  5B
0EBE2:  BTFSS  F9E.4
0EBE4:  BRA    EBE2
0EBE6:  MOVWF  FAD
0EBE8:  CLRF   1B
0EBEA:  BTFSC  FF2.7
0EBEC:  BSF    1B.7
0EBEE:  BCF    FF2.7
0EBF0:  MOVFF  8A1,A25
0EBF4:  MOVLW  1B
0EBF6:  MOVLB  A
0EBF8:  MOVWF  x26
0EBFA:  MOVLB  0
0EBFC:  CALL   0FA0
0EC00:  BTFSC  1B.7
0EC02:  BSF    FF2.7
0EC04:  MOVLW  5D
0EC06:  BTFSS  F9E.4
0EC08:  BRA    EC06
0EC0A:  MOVWF  FAD
0EC0C:  MOVLW  20
0EC0E:  BTFSS  F9E.4
0EC10:  BRA    EC0E
0EC12:  MOVWF  FAD
0EC14:  MOVLB  8
0EC16:  INCF   xA0,F
0EC18:  BRA    EBAC
....................    fprintf(COM_A, "\r\n"); 
0EC1A:  MOVLW  0D
0EC1C:  BTFSS  F9E.4
0EC1E:  BRA    EC1C
0EC20:  MOVWF  FAD
0EC22:  MOVLW  0A
0EC24:  BTFSS  F9E.4
0EC26:  BRA    EC24
0EC28:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EC2A:  MOVLW  56
0EC2C:  MOVWF  FF6
0EC2E:  MOVLW  1D
0EC30:  MOVWF  FF7
0EC32:  MOVLW  00
0EC34:  MOVWF  FF8
0EC36:  CLRF   1B
0EC38:  BTFSC  FF2.7
0EC3A:  BSF    1B.7
0EC3C:  BCF    FF2.7
0EC3E:  MOVLB  0
0EC40:  CALL   0DCC
0EC44:  BTFSC  1B.7
0EC46:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EC48:  MOVLW  11
0EC4A:  MOVLB  8
0EC4C:  MOVWF  xA0
0EC4E:  MOVF   xA0,W
0EC50:  SUBLW  18
0EC52:  BNC   ECBC
0EC54:  CLRF   03
0EC56:  MOVF   xA0,W
0EC58:  ADDLW  B3
0EC5A:  MOVWF  FE9
0EC5C:  MOVLW  04
0EC5E:  ADDWFC 03,W
0EC60:  MOVWF  FEA
0EC62:  MOVFF  FEF,8A1
0EC66:  CLRF   1B
0EC68:  BTFSC  FF2.7
0EC6A:  BSF    1B.7
0EC6C:  BCF    FF2.7
0EC6E:  MOVFF  8A0,A25
0EC72:  MOVLW  01
0EC74:  MOVLB  A
0EC76:  MOVWF  x26
0EC78:  MOVLB  0
0EC7A:  CALL   0FA0
0EC7E:  BTFSC  1B.7
0EC80:  BSF    FF2.7
0EC82:  MOVLW  5B
0EC84:  BTFSS  F9E.4
0EC86:  BRA    EC84
0EC88:  MOVWF  FAD
0EC8A:  CLRF   1B
0EC8C:  BTFSC  FF2.7
0EC8E:  BSF    1B.7
0EC90:  BCF    FF2.7
0EC92:  MOVFF  8A1,A25
0EC96:  MOVLW  1B
0EC98:  MOVLB  A
0EC9A:  MOVWF  x26
0EC9C:  MOVLB  0
0EC9E:  CALL   0FA0
0ECA2:  BTFSC  1B.7
0ECA4:  BSF    FF2.7
0ECA6:  MOVLW  5D
0ECA8:  BTFSS  F9E.4
0ECAA:  BRA    ECA8
0ECAC:  MOVWF  FAD
0ECAE:  MOVLW  20
0ECB0:  BTFSS  F9E.4
0ECB2:  BRA    ECB0
0ECB4:  MOVWF  FAD
0ECB6:  MOVLB  8
0ECB8:  INCF   xA0,F
0ECBA:  BRA    EC4E
....................    fprintf(COM_A, "\r\n"); 
0ECBC:  MOVLW  0D
0ECBE:  BTFSS  F9E.4
0ECC0:  BRA    ECBE
0ECC2:  MOVWF  FAD
0ECC4:  MOVLW  0A
0ECC6:  BTFSS  F9E.4
0ECC8:  BRA    ECC6
0ECCA:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0ECCC:  MOVLW  5C
0ECCE:  MOVWF  FF6
0ECD0:  MOVLW  1D
0ECD2:  MOVWF  FF7
0ECD4:  MOVLW  00
0ECD6:  MOVWF  FF8
0ECD8:  CLRF   1B
0ECDA:  BTFSC  FF2.7
0ECDC:  BSF    1B.7
0ECDE:  BCF    FF2.7
0ECE0:  MOVLB  0
0ECE2:  CALL   0DCC
0ECE6:  BTFSC  1B.7
0ECE8:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0ECEA:  MOVLW  19
0ECEC:  MOVLB  8
0ECEE:  MOVWF  xA0
0ECF0:  MOVF   xA0,W
0ECF2:  SUBLW  20
0ECF4:  BNC   ED5E
0ECF6:  CLRF   03
0ECF8:  MOVF   xA0,W
0ECFA:  ADDLW  B3
0ECFC:  MOVWF  FE9
0ECFE:  MOVLW  04
0ED00:  ADDWFC 03,W
0ED02:  MOVWF  FEA
0ED04:  MOVFF  FEF,8A1
0ED08:  CLRF   1B
0ED0A:  BTFSC  FF2.7
0ED0C:  BSF    1B.7
0ED0E:  BCF    FF2.7
0ED10:  MOVFF  8A0,A25
0ED14:  MOVLW  01
0ED16:  MOVLB  A
0ED18:  MOVWF  x26
0ED1A:  MOVLB  0
0ED1C:  CALL   0FA0
0ED20:  BTFSC  1B.7
0ED22:  BSF    FF2.7
0ED24:  MOVLW  5B
0ED26:  BTFSS  F9E.4
0ED28:  BRA    ED26
0ED2A:  MOVWF  FAD
0ED2C:  CLRF   1B
0ED2E:  BTFSC  FF2.7
0ED30:  BSF    1B.7
0ED32:  BCF    FF2.7
0ED34:  MOVFF  8A1,A25
0ED38:  MOVLW  1B
0ED3A:  MOVLB  A
0ED3C:  MOVWF  x26
0ED3E:  MOVLB  0
0ED40:  CALL   0FA0
0ED44:  BTFSC  1B.7
0ED46:  BSF    FF2.7
0ED48:  MOVLW  5D
0ED4A:  BTFSS  F9E.4
0ED4C:  BRA    ED4A
0ED4E:  MOVWF  FAD
0ED50:  MOVLW  20
0ED52:  BTFSS  F9E.4
0ED54:  BRA    ED52
0ED56:  MOVWF  FAD
0ED58:  MOVLB  8
0ED5A:  INCF   xA0,F
0ED5C:  BRA    ECF0
....................    fprintf(COM_A, "\r\n");    
0ED5E:  MOVLW  0D
0ED60:  BTFSS  F9E.4
0ED62:  BRA    ED60
0ED64:  MOVWF  FAD
0ED66:  MOVLW  0A
0ED68:  BTFSS  F9E.4
0ED6A:  BRA    ED68
0ED6C:  MOVWF  FAD
0ED6E:  MOVLB  0
0ED70:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
140E8:  MOVF   1F,W
140EA:  SUBLW  04
140EC:  BNZ   14156
140EE:  MOVF   20,F
140F0:  BNZ   14156
140F2:  MOVLW  62
140F4:  MOVWF  FF6
140F6:  MOVLW  1D
140F8:  MOVWF  FF7
140FA:  MOVLW  00
140FC:  MOVWF  FF8
140FE:  CLRF   1B
14100:  BTFSC  FF2.7
14102:  BSF    1B.7
14104:  BCF    FF2.7
14106:  MOVLW  0C
14108:  MOVLB  A
1410A:  MOVWF  x25
1410C:  MOVLB  0
1410E:  CALL   101E
14112:  BTFSC  1B.7
14114:  BSF    FF2.7
14116:  MOVLW  10
14118:  MOVWF  FE9
1411A:  CLRF   1B
1411C:  BTFSC  FF2.7
1411E:  BSF    1B.7
14120:  BCF    FF2.7
14122:  MOVFF  8A1,A26
14126:  MOVFF  8A0,A25
1412A:  CALL   11A0
1412E:  BTFSC  1B.7
14130:  BSF    FF2.7
14132:  MOVLW  71
14134:  MOVWF  FF6
14136:  MOVLW  1D
14138:  MOVWF  FF7
1413A:  MOVLW  00
1413C:  MOVWF  FF8
1413E:  CLRF   1B
14140:  BTFSC  FF2.7
14142:  BSF    1B.7
14144:  BCF    FF2.7
14146:  MOVLW  03
14148:  MOVLB  A
1414A:  MOVWF  x25
1414C:  MOVLB  0
1414E:  CALL   101E
14152:  BTFSC  1B.7
14154:  BSF    FF2.7
....................  
....................    multidrop_on(); 
14156:  CALL   D7FE
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
1415A:  MOVLW  76
1415C:  MOVWF  FF6
1415E:  MOVLW  1D
14160:  MOVWF  FF7
14162:  MOVLW  00
14164:  MOVWF  FF8
14166:  MOVLW  03
14168:  MOVLB  8
1416A:  MOVWF  xA2
1416C:  MOVLB  0
1416E:  CALL   D812
14172:  MOVLW  10
14174:  MOVWF  FE9
14176:  MOVFF  8A1,8A3
1417A:  MOVFF  8A0,8A2
1417E:  BRA    1402E
14180:  MOVLW  0D
14182:  BTFSS  FA4.4
14184:  BRA    14182
14186:  MOVLB  F
14188:  MOVWF  x1C
....................    multidrop_off(); 
1418A:  MOVLB  0
1418C:  CALL   D8EA
....................  
....................    delay_ms(100); 
14190:  MOVLW  64
14192:  MOVLB  9
14194:  MOVWF  xD6
14196:  MOVLB  0
14198:  CALL   2972
1419C:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0D93C:  MOVF   1F,W
0D93E:  SUBLW  04
0D940:  BNZ   D9AA
0D942:  MOVF   20,F
0D944:  BNZ   D9AA
0D946:  MOVLW  7E
0D948:  MOVWF  FF6
0D94A:  MOVLW  1D
0D94C:  MOVWF  FF7
0D94E:  MOVLW  00
0D950:  MOVWF  FF8
0D952:  CLRF   1B
0D954:  BTFSC  FF2.7
0D956:  BSF    1B.7
0D958:  BCF    FF2.7
0D95A:  MOVLW  0C
0D95C:  MOVLB  A
0D95E:  MOVWF  x25
0D960:  MOVLB  0
0D962:  CALL   101E
0D966:  BTFSC  1B.7
0D968:  BSF    FF2.7
0D96A:  CLRF   1B
0D96C:  BTFSC  FF2.7
0D96E:  BSF    1B.7
0D970:  BCF    FF2.7
0D972:  MOVFF  8A0,A25
0D976:  MOVLW  1B
0D978:  MOVLB  A
0D97A:  MOVWF  x26
0D97C:  MOVLB  0
0D97E:  CALL   0FA0
0D982:  BTFSC  1B.7
0D984:  BSF    FF2.7
0D986:  MOVLW  8C
0D988:  MOVWF  FF6
0D98A:  MOVLW  1D
0D98C:  MOVWF  FF7
0D98E:  MOVLW  00
0D990:  MOVWF  FF8
0D992:  CLRF   1B
0D994:  BTFSC  FF2.7
0D996:  BSF    1B.7
0D998:  BCF    FF2.7
0D99A:  MOVLW  03
0D99C:  MOVLB  A
0D99E:  MOVWF  x25
0D9A0:  MOVLB  0
0D9A2:  CALL   101E
0D9A6:  BTFSC  1B.7
0D9A8:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0D9AA:  RCALL  D7FE
....................       fprintf(COM_B, "/1c%u\r",chip); 
0D9AC:  MOVLW  90
0D9AE:  MOVWF  FF6
0D9B0:  MOVLW  1D
0D9B2:  MOVWF  FF7
0D9B4:  MOVLW  00
0D9B6:  MOVWF  FF8
0D9B8:  MOVLW  03
0D9BA:  MOVLB  8
0D9BC:  MOVWF  xA2
0D9BE:  MOVLB  0
0D9C0:  RCALL  D812
0D9C2:  MOVFF  8A0,8DD
0D9C6:  MOVLW  1B
0D9C8:  MOVLB  8
0D9CA:  MOVWF  xDE
0D9CC:  MOVLB  0
0D9CE:  RCALL  D846
0D9D0:  MOVLW  0D
0D9D2:  BTFSS  FA4.4
0D9D4:  BRA    D9D2
0D9D6:  MOVLB  F
0D9D8:  MOVWF  x1C
....................    multidrop_off(); 
0D9DA:  MOVLB  0
0D9DC:  RCALL  D8EA
....................    delay_ms(100); 
0D9DE:  MOVLW  64
0D9E0:  MOVLB  9
0D9E2:  MOVWF  xD6
0D9E4:  MOVLB  0
0D9E6:  CALL   2972
....................  
....................    multidrop_on(); 
0D9EA:  RCALL  D7FE
....................      fprintf(COM_B, "/1s256\r"); 
0D9EC:  MOVLW  98
0D9EE:  MOVWF  FF6
0D9F0:  MOVLW  1D
0D9F2:  MOVWF  FF7
0D9F4:  MOVLW  00
0D9F6:  MOVWF  FF8
0D9F8:  BRA    D90C
....................    multidrop_off();  
0D9FA:  RCALL  D8EA
....................    delay_ms(100); 
0D9FC:  MOVLW  64
0D9FE:  MOVLB  9
0DA00:  MOVWF  xD6
0DA02:  MOVLB  0
0DA04:  CALL   2972
0DA08:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
1419E:  MOVLB  8
141A0:  MOVF   x9F,W
141A2:  ADDLW  DF
141A4:  BTFSC  FD8.0
141A6:  BRA    14592
141A8:  ADDLW  21
141AA:  MOVLB  0
141AC:  GOTO   145C4
....................       case 0 : sol_chip_cmd(1); 
141B0:  MOVLW  01
141B2:  MOVLB  8
141B4:  MOVWF  xA0
141B6:  MOVLB  0
141B8:  CALL   D93C
....................                sol_switch_cmd(0); 
141BC:  MOVLB  8
141BE:  CLRF   xA1
141C0:  CLRF   xA0
141C2:  MOVLB  0
141C4:  RCALL  140E8
....................                sol_chip_cmd(2); 
141C6:  MOVLW  02
141C8:  MOVLB  8
141CA:  MOVWF  xA0
141CC:  MOVLB  0
141CE:  CALL   D93C
....................                sol_switch_cmd(0); 
141D2:  MOVLB  8
141D4:  CLRF   xA1
141D6:  CLRF   xA0
141D8:  MOVLB  0
141DA:  RCALL  140E8
....................                sol_chip_cmd(3); 
141DC:  MOVLW  03
141DE:  MOVLB  8
141E0:  MOVWF  xA0
141E2:  MOVLB  0
141E4:  CALL   D93C
....................                sol_switch_cmd(0); 
141E8:  MOVLB  8
141EA:  CLRF   xA1
141EC:  CLRF   xA0
141EE:  MOVLB  0
141F0:  RCALL  140E8
....................                sol_chip_cmd(4); 
141F2:  MOVLW  04
141F4:  MOVLB  8
141F6:  MOVWF  xA0
141F8:  MOVLB  0
141FA:  CALL   D93C
....................                sol_switch_cmd(0); 
141FE:  MOVLB  8
14200:  CLRF   xA1
14202:  CLRF   xA0
14204:  MOVLB  0
14206:  RCALL  140E8
....................                init_valve_status(); 
14208:  CALL   311C
....................          break; 
1420C:  MOVLB  8
1420E:  BRA    14592
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
14210:  MOVLW  01
14212:  MOVLB  8
14214:  MOVWF  xA0
14216:  MOVLB  0
14218:  CALL   D93C
....................                sol_switch_cmd(1); 
1421C:  MOVLB  8
1421E:  CLRF   xA1
14220:  MOVLW  01
14222:  MOVWF  xA0
14224:  MOVLB  0
14226:  RCALL  140E8
....................          break;     
14228:  MOVLB  8
1422A:  BRA    14592
....................       case 2 : sol_chip_cmd(1); 
1422C:  MOVLW  01
1422E:  MOVLB  8
14230:  MOVWF  xA0
14232:  MOVLB  0
14234:  CALL   D93C
....................                sol_switch_cmd(2); 
14238:  MOVLB  8
1423A:  CLRF   xA1
1423C:  MOVLW  02
1423E:  MOVWF  xA0
14240:  MOVLB  0
14242:  RCALL  140E8
....................          break;           
14244:  MOVLB  8
14246:  BRA    14592
....................       case 3 : sol_chip_cmd(1); 
14248:  MOVLW  01
1424A:  MOVLB  8
1424C:  MOVWF  xA0
1424E:  MOVLB  0
14250:  CALL   D93C
....................                sol_switch_cmd(4); 
14254:  MOVLB  8
14256:  CLRF   xA1
14258:  MOVLW  04
1425A:  MOVWF  xA0
1425C:  MOVLB  0
1425E:  RCALL  140E8
....................          break;  
14260:  MOVLB  8
14262:  BRA    14592
....................       case 4 : sol_chip_cmd(1); 
14264:  MOVLW  01
14266:  MOVLB  8
14268:  MOVWF  xA0
1426A:  MOVLB  0
1426C:  CALL   D93C
....................                sol_switch_cmd(8); 
14270:  MOVLB  8
14272:  CLRF   xA1
14274:  MOVLW  08
14276:  MOVWF  xA0
14278:  MOVLB  0
1427A:  RCALL  140E8
....................          break;  
1427C:  MOVLB  8
1427E:  BRA    14592
....................       case 5 : sol_chip_cmd(1); 
14280:  MOVLW  01
14282:  MOVLB  8
14284:  MOVWF  xA0
14286:  MOVLB  0
14288:  CALL   D93C
....................                sol_switch_cmd(16); 
1428C:  MOVLB  8
1428E:  CLRF   xA1
14290:  MOVLW  10
14292:  MOVWF  xA0
14294:  MOVLB  0
14296:  RCALL  140E8
....................          break;  
14298:  MOVLB  8
1429A:  BRA    14592
....................       case 6 : sol_chip_cmd(1); 
1429C:  MOVLW  01
1429E:  MOVLB  8
142A0:  MOVWF  xA0
142A2:  MOVLB  0
142A4:  CALL   D93C
....................                sol_switch_cmd(32); 
142A8:  MOVLB  8
142AA:  CLRF   xA1
142AC:  MOVLW  20
142AE:  MOVWF  xA0
142B0:  MOVLB  0
142B2:  RCALL  140E8
....................          break;  
142B4:  MOVLB  8
142B6:  BRA    14592
....................       case 7 : sol_chip_cmd(1); 
142B8:  MOVLW  01
142BA:  MOVLB  8
142BC:  MOVWF  xA0
142BE:  MOVLB  0
142C0:  CALL   D93C
....................                sol_switch_cmd(64); 
142C4:  MOVLB  8
142C6:  CLRF   xA1
142C8:  MOVLW  40
142CA:  MOVWF  xA0
142CC:  MOVLB  0
142CE:  RCALL  140E8
....................          break;  
142D0:  MOVLB  8
142D2:  BRA    14592
....................       case 8 : sol_chip_cmd(1); 
142D4:  MOVLW  01
142D6:  MOVLB  8
142D8:  MOVWF  xA0
142DA:  MOVLB  0
142DC:  CALL   D93C
....................                sol_switch_cmd(128); 
142E0:  MOVLB  8
142E2:  CLRF   xA1
142E4:  MOVLW  80
142E6:  MOVWF  xA0
142E8:  MOVLB  0
142EA:  RCALL  140E8
....................          break;   
142EC:  MOVLB  8
142EE:  BRA    14592
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
142F0:  MOVLW  02
142F2:  MOVLB  8
142F4:  MOVWF  xA0
142F6:  MOVLB  0
142F8:  CALL   D93C
....................                sol_switch_cmd(1); 
142FC:  MOVLB  8
142FE:  CLRF   xA1
14300:  MOVLW  01
14302:  MOVWF  xA0
14304:  MOVLB  0
14306:  RCALL  140E8
....................          break;     
14308:  MOVLB  8
1430A:  BRA    14592
....................       case 10 : sol_chip_cmd(2); 
1430C:  MOVLW  02
1430E:  MOVLB  8
14310:  MOVWF  xA0
14312:  MOVLB  0
14314:  CALL   D93C
....................                sol_switch_cmd(2); 
14318:  MOVLB  8
1431A:  CLRF   xA1
1431C:  MOVLW  02
1431E:  MOVWF  xA0
14320:  MOVLB  0
14322:  RCALL  140E8
....................          break;           
14324:  MOVLB  8
14326:  BRA    14592
....................       case 11 : sol_chip_cmd(2); 
14328:  MOVLW  02
1432A:  MOVLB  8
1432C:  MOVWF  xA0
1432E:  MOVLB  0
14330:  CALL   D93C
....................                sol_switch_cmd(4); 
14334:  MOVLB  8
14336:  CLRF   xA1
14338:  MOVLW  04
1433A:  MOVWF  xA0
1433C:  MOVLB  0
1433E:  RCALL  140E8
....................          break;  
14340:  MOVLB  8
14342:  BRA    14592
....................       case 12 : sol_chip_cmd(2); 
14344:  MOVLW  02
14346:  MOVLB  8
14348:  MOVWF  xA0
1434A:  MOVLB  0
1434C:  CALL   D93C
....................                sol_switch_cmd(8); 
14350:  MOVLB  8
14352:  CLRF   xA1
14354:  MOVLW  08
14356:  MOVWF  xA0
14358:  MOVLB  0
1435A:  RCALL  140E8
....................          break;  
1435C:  MOVLB  8
1435E:  BRA    14592
....................       case 13 : sol_chip_cmd(2); 
14360:  MOVLW  02
14362:  MOVLB  8
14364:  MOVWF  xA0
14366:  MOVLB  0
14368:  CALL   D93C
....................                sol_switch_cmd(16); 
1436C:  MOVLB  8
1436E:  CLRF   xA1
14370:  MOVLW  10
14372:  MOVWF  xA0
14374:  MOVLB  0
14376:  RCALL  140E8
....................          break;  
14378:  MOVLB  8
1437A:  BRA    14592
....................       case 14 : sol_chip_cmd(2); 
1437C:  MOVLW  02
1437E:  MOVLB  8
14380:  MOVWF  xA0
14382:  MOVLB  0
14384:  CALL   D93C
....................                sol_switch_cmd(32); 
14388:  MOVLB  8
1438A:  CLRF   xA1
1438C:  MOVLW  20
1438E:  MOVWF  xA0
14390:  MOVLB  0
14392:  RCALL  140E8
....................          break;  
14394:  MOVLB  8
14396:  BRA    14592
....................       case 15 : sol_chip_cmd(2); 
14398:  MOVLW  02
1439A:  MOVLB  8
1439C:  MOVWF  xA0
1439E:  MOVLB  0
143A0:  CALL   D93C
....................                sol_switch_cmd(64); 
143A4:  MOVLB  8
143A6:  CLRF   xA1
143A8:  MOVLW  40
143AA:  MOVWF  xA0
143AC:  MOVLB  0
143AE:  RCALL  140E8
....................          break;  
143B0:  MOVLB  8
143B2:  BRA    14592
....................       case 16 : sol_chip_cmd(2); 
143B4:  MOVLW  02
143B6:  MOVLB  8
143B8:  MOVWF  xA0
143BA:  MOVLB  0
143BC:  CALL   D93C
....................                sol_switch_cmd(128); 
143C0:  MOVLB  8
143C2:  CLRF   xA1
143C4:  MOVLW  80
143C6:  MOVWF  xA0
143C8:  MOVLB  0
143CA:  RCALL  140E8
....................          break;   
143CC:  MOVLB  8
143CE:  BRA    14592
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
143D0:  MOVLW  03
143D2:  MOVLB  8
143D4:  MOVWF  xA0
143D6:  MOVLB  0
143D8:  CALL   D93C
....................                sol_switch_cmd(1); 
143DC:  MOVLB  8
143DE:  CLRF   xA1
143E0:  MOVLW  01
143E2:  MOVWF  xA0
143E4:  MOVLB  0
143E6:  RCALL  140E8
....................          break;     
143E8:  MOVLB  8
143EA:  BRA    14592
....................       case 18 : sol_chip_cmd(3); 
143EC:  MOVLW  03
143EE:  MOVLB  8
143F0:  MOVWF  xA0
143F2:  MOVLB  0
143F4:  CALL   D93C
....................                sol_switch_cmd(2); 
143F8:  MOVLB  8
143FA:  CLRF   xA1
143FC:  MOVLW  02
143FE:  MOVWF  xA0
14400:  MOVLB  0
14402:  RCALL  140E8
....................          break;           
14404:  MOVLB  8
14406:  BRA    14592
....................       case 19 : sol_chip_cmd(3); 
14408:  MOVLW  03
1440A:  MOVLB  8
1440C:  MOVWF  xA0
1440E:  MOVLB  0
14410:  CALL   D93C
....................                sol_switch_cmd(4); 
14414:  MOVLB  8
14416:  CLRF   xA1
14418:  MOVLW  04
1441A:  MOVWF  xA0
1441C:  MOVLB  0
1441E:  RCALL  140E8
....................          break;  
14420:  MOVLB  8
14422:  BRA    14592
....................       case 20 : sol_chip_cmd(3); 
14424:  MOVLW  03
14426:  MOVLB  8
14428:  MOVWF  xA0
1442A:  MOVLB  0
1442C:  CALL   D93C
....................                sol_switch_cmd(8); 
14430:  MOVLB  8
14432:  CLRF   xA1
14434:  MOVLW  08
14436:  MOVWF  xA0
14438:  MOVLB  0
1443A:  RCALL  140E8
....................          break;  
1443C:  MOVLB  8
1443E:  BRA    14592
....................       case 21 : sol_chip_cmd(3); 
14440:  MOVLW  03
14442:  MOVLB  8
14444:  MOVWF  xA0
14446:  MOVLB  0
14448:  CALL   D93C
....................                sol_switch_cmd(16); 
1444C:  MOVLB  8
1444E:  CLRF   xA1
14450:  MOVLW  10
14452:  MOVWF  xA0
14454:  MOVLB  0
14456:  RCALL  140E8
....................          break;  
14458:  MOVLB  8
1445A:  BRA    14592
....................       case 22 : sol_chip_cmd(3); 
1445C:  MOVLW  03
1445E:  MOVLB  8
14460:  MOVWF  xA0
14462:  MOVLB  0
14464:  CALL   D93C
....................                sol_switch_cmd(32); 
14468:  MOVLB  8
1446A:  CLRF   xA1
1446C:  MOVLW  20
1446E:  MOVWF  xA0
14470:  MOVLB  0
14472:  RCALL  140E8
....................          break;  
14474:  MOVLB  8
14476:  BRA    14592
....................       case 23 : sol_chip_cmd(3); 
14478:  MOVLW  03
1447A:  MOVLB  8
1447C:  MOVWF  xA0
1447E:  MOVLB  0
14480:  CALL   D93C
....................                sol_switch_cmd(64); 
14484:  MOVLB  8
14486:  CLRF   xA1
14488:  MOVLW  40
1448A:  MOVWF  xA0
1448C:  MOVLB  0
1448E:  RCALL  140E8
....................          break;  
14490:  MOVLB  8
14492:  BRA    14592
....................       case 24 : sol_chip_cmd(3); 
14494:  MOVLW  03
14496:  MOVLB  8
14498:  MOVWF  xA0
1449A:  MOVLB  0
1449C:  CALL   D93C
....................                sol_switch_cmd(128); 
144A0:  MOVLB  8
144A2:  CLRF   xA1
144A4:  MOVLW  80
144A6:  MOVWF  xA0
144A8:  MOVLB  0
144AA:  RCALL  140E8
....................          break;      
144AC:  MOVLB  8
144AE:  BRA    14592
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
144B0:  MOVLW  04
144B2:  MOVLB  8
144B4:  MOVWF  xA0
144B6:  MOVLB  0
144B8:  CALL   D93C
....................                sol_switch_cmd(1); 
144BC:  MOVLB  8
144BE:  CLRF   xA1
144C0:  MOVLW  01
144C2:  MOVWF  xA0
144C4:  MOVLB  0
144C6:  RCALL  140E8
....................          break;     
144C8:  MOVLB  8
144CA:  BRA    14592
....................       case 26 : sol_chip_cmd(4); 
144CC:  MOVLW  04
144CE:  MOVLB  8
144D0:  MOVWF  xA0
144D2:  MOVLB  0
144D4:  CALL   D93C
....................                sol_switch_cmd(2); 
144D8:  MOVLB  8
144DA:  CLRF   xA1
144DC:  MOVLW  02
144DE:  MOVWF  xA0
144E0:  MOVLB  0
144E2:  RCALL  140E8
....................          break;           
144E4:  MOVLB  8
144E6:  BRA    14592
....................       case 27 : sol_chip_cmd(4); 
144E8:  MOVLW  04
144EA:  MOVLB  8
144EC:  MOVWF  xA0
144EE:  MOVLB  0
144F0:  CALL   D93C
....................                sol_switch_cmd(4); 
144F4:  MOVLB  8
144F6:  CLRF   xA1
144F8:  MOVLW  04
144FA:  MOVWF  xA0
144FC:  MOVLB  0
144FE:  RCALL  140E8
....................          break;  
14500:  MOVLB  8
14502:  BRA    14592
....................       case 28 : sol_chip_cmd(4); 
14504:  MOVLW  04
14506:  MOVLB  8
14508:  MOVWF  xA0
1450A:  MOVLB  0
1450C:  CALL   D93C
....................                sol_switch_cmd(8); 
14510:  MOVLB  8
14512:  CLRF   xA1
14514:  MOVLW  08
14516:  MOVWF  xA0
14518:  MOVLB  0
1451A:  RCALL  140E8
....................          break;  
1451C:  MOVLB  8
1451E:  BRA    14592
....................       case 29 : sol_chip_cmd(4); 
14520:  MOVLW  04
14522:  MOVLB  8
14524:  MOVWF  xA0
14526:  MOVLB  0
14528:  CALL   D93C
....................                sol_switch_cmd(16); 
1452C:  MOVLB  8
1452E:  CLRF   xA1
14530:  MOVLW  10
14532:  MOVWF  xA0
14534:  MOVLB  0
14536:  RCALL  140E8
....................          break;  
14538:  MOVLB  8
1453A:  BRA    14592
....................       case 30 : sol_chip_cmd(4); 
1453C:  MOVLW  04
1453E:  MOVLB  8
14540:  MOVWF  xA0
14542:  MOVLB  0
14544:  CALL   D93C
....................                sol_switch_cmd(32); 
14548:  MOVLB  8
1454A:  CLRF   xA1
1454C:  MOVLW  20
1454E:  MOVWF  xA0
14550:  MOVLB  0
14552:  RCALL  140E8
....................          break;  
14554:  MOVLB  8
14556:  BRA    14592
....................       case 31 : sol_chip_cmd(4); 
14558:  MOVLW  04
1455A:  MOVLB  8
1455C:  MOVWF  xA0
1455E:  MOVLB  0
14560:  CALL   D93C
....................                sol_switch_cmd(64); 
14564:  MOVLB  8
14566:  CLRF   xA1
14568:  MOVLW  40
1456A:  MOVWF  xA0
1456C:  MOVLB  0
1456E:  RCALL  140E8
....................          break;  
14570:  MOVLB  8
14572:  BRA    14592
....................       case 32 : sol_chip_cmd(4); 
14574:  MOVLW  04
14576:  MOVLB  8
14578:  MOVWF  xA0
1457A:  MOVLB  0
1457C:  CALL   D93C
....................                sol_switch_cmd(128); 
14580:  MOVLB  8
14582:  CLRF   xA1
14584:  MOVLW  80
14586:  MOVWF  xA0
14588:  MOVLB  0
1458A:  RCALL  140E8
....................          break; 
1458C:  MOVLB  8
1458E:  BRA    14592
14590:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
14592:  MOVF   x9F,F
14594:  BZ    145AE
14596:  MOVF   x9F,W
14598:  SUBLW  20
1459A:  BNC   145AE
1459C:  CLRF   03
1459E:  MOVF   x9F,W
145A0:  ADDLW  B3
145A2:  MOVWF  FE9
145A4:  MOVLW  04
145A6:  ADDWFC 03,W
145A8:  MOVWF  FEA
145AA:  MOVLW  01
145AC:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
145AE:  MOVF   1F,W
145B0:  SUBLW  04
145B2:  BNZ   145C0
145B4:  MOVF   20,F
145B6:  BNZ   145C0
145B8:  MOVLB  0
145BA:  CALL   EAE8
145BE:  MOVLB  8
145C0:  MOVLB  0
145C2:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
1028E:  MOVLB  8
10290:  CLRF   x87
10292:  MOVF   x87,W
10294:  SUBLW  07
10296:  BNC   102B2
10298:  BCF    FD8.0
1029A:  RLCF   x87,W
1029C:  CLRF   03
1029E:  ADDLW  47
102A0:  MOVWF  FE9
102A2:  MOVLW  03
102A4:  ADDWFC 03,W
102A6:  MOVWF  FEA
102A8:  CLRF   FEC
102AA:  MOVF   FED,F
102AC:  CLRF   FEF
102AE:  INCF   x87,F
102B0:  BRA    10292
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
102B2:  CLRF   x87
102B4:  MOVF   x87,W
102B6:  SUBLW  07
102B8:  BNC   102D4
102BA:  BCF    FD8.0
102BC:  RLCF   x87,W
102BE:  CLRF   03
102C0:  ADDLW  59
102C2:  MOVWF  FE9
102C4:  MOVLW  03
102C6:  ADDWFC 03,W
102C8:  MOVWF  FEA
102CA:  CLRF   FEC
102CC:  MOVF   FED,F
102CE:  CLRF   FEF
102D0:  INCF   x87,F
102D2:  BRA    102B4
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
102D4:  CLRF   x87
102D6:  MOVF   x87,W
102D8:  SUBLW  07
102DA:  BNC   102F6
102DC:  BCF    FD8.0
102DE:  RLCF   x87,W
102E0:  CLRF   03
102E2:  ADDLW  6B
102E4:  MOVWF  FE9
102E6:  MOVLW  03
102E8:  ADDWFC 03,W
102EA:  MOVWF  FEA
102EC:  CLRF   FEC
102EE:  MOVF   FED,F
102F0:  CLRF   FEF
102F2:  INCF   x87,F
102F4:  BRA    102D6
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
102F6:  CLRF   x87
102F8:  MOVF   x87,W
102FA:  SUBLW  07
102FC:  BNC   10318
102FE:  BCF    FD8.0
10300:  RLCF   x87,W
10302:  CLRF   03
10304:  ADDLW  7D
10306:  MOVWF  FE9
10308:  MOVLW  03
1030A:  ADDWFC 03,W
1030C:  MOVWF  FEA
1030E:  CLRF   FEC
10310:  MOVF   FED,F
10312:  CLRF   FEF
10314:  INCF   x87,F
10316:  BRA    102F8
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
10318:  CLRF   x87
1031A:  MOVF   x87,W
1031C:  SUBLW  07
1031E:  BNC   1033A
10320:  BCF    FD8.0
10322:  RLCF   x87,W
10324:  CLRF   03
10326:  ADDLW  8F
10328:  MOVWF  FE9
1032A:  MOVLW  03
1032C:  ADDWFC 03,W
1032E:  MOVWF  FEA
10330:  CLRF   FEC
10332:  MOVF   FED,F
10334:  CLRF   FEF
10336:  INCF   x87,F
10338:  BRA    1031A
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
1033A:  MOVLW  04
1033C:  MOVWF  FEA
1033E:  MOVLW  21
10340:  MOVWF  FE9
10342:  CLRF   00
10344:  CLRF   02
10346:  MOVLW  44
10348:  MOVWF  01
1034A:  MOVLB  0
1034C:  CALL   3588
10350:  GOTO   14FE4 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10BFC:  MOVLB  8
10BFE:  CLRF   xAC
10C00:  MOVF   xAC,W
10C02:  SUBLW  03
10C04:  BNC   10C24
10C06:  MOVF   xAC,W
10C08:  MULLW  04
10C0A:  MOVF   FF3,W
10C0C:  CLRF   03
10C0E:  ADDLW  A1
10C10:  MOVWF  FE9
10C12:  MOVLW  03
10C14:  ADDWFC 03,W
10C16:  MOVWF  FEA
10C18:  CLRF   FEF
10C1A:  CLRF   FEC
10C1C:  CLRF   FEC
10C1E:  CLRF   FEC
10C20:  INCF   xAC,F
10C22:  BRA    10C00
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10C24:  MOVLB  3
10C26:  MOVF   x47,F
10C28:  BTFSS  FD8.2
10C2A:  BRA    10C30
10C2C:  MOVF   x48,F
10C2E:  BZ    10CCA
10C30:  MOVF   x49,F
10C32:  BNZ   10C38
10C34:  MOVF   x4A,F
10C36:  BZ    10CCA
....................       blank = NO3_array[0]; 
10C38:  MOVFF  348,902
10C3C:  MOVFF  347,901
10C40:  MOVLB  0
10C42:  CALL   C69C
10C46:  MOVFF  03,8B0
10C4A:  MOVFF  02,8AF
10C4E:  MOVFF  01,8AE
10C52:  MOVFF  00,8AD
....................       react = NO3_array[1]; 
10C56:  MOVFF  34A,902
10C5A:  MOVFF  349,901
10C5E:  CALL   C69C
10C62:  MOVFF  03,8B4
10C66:  MOVFF  02,8B3
10C6A:  MOVFF  01,8B2
10C6E:  MOVFF  00,8B1
....................       ratio = blank / react; 
10C72:  MOVFF  8B0,8E8
10C76:  MOVFF  8AF,8E7
10C7A:  MOVFF  8AE,8E6
10C7E:  MOVFF  8AD,8E5
10C82:  MOVFF  8B4,8EC
10C86:  MOVFF  8B3,8EB
10C8A:  MOVFF  8B2,8EA
10C8E:  MOVFF  8B1,8E9
10C92:  CALL   C6D2
10C96:  MOVFF  03,8B8
10C9A:  MOVFF  02,8B7
10C9E:  MOVFF  01,8B6
10CA2:  MOVFF  00,8B5
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10CA6:  MOVFF  8B8,8BC
10CAA:  MOVFF  8B7,8BB
10CAE:  MOVFF  8B6,8BA
10CB2:  MOVFF  8B5,8B9
10CB6:  RCALL  1097A
10CB8:  MOVFF  03,3A4
10CBC:  MOVFF  02,3A3
10CC0:  MOVFF  01,3A2
10CC4:  MOVFF  00,3A1
10CC8:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10CCA:  MOVF   x4B,F
10CCC:  BNZ   10CD2
10CCE:  MOVF   x4C,F
10CD0:  BZ    10D6C
10CD2:  MOVF   x4D,F
10CD4:  BNZ   10CDA
10CD6:  MOVF   x4E,F
10CD8:  BZ    10D6C
....................       blank = NO3_array[2]; 
10CDA:  MOVFF  34C,902
10CDE:  MOVFF  34B,901
10CE2:  MOVLB  0
10CE4:  CALL   C69C
10CE8:  MOVFF  03,8B0
10CEC:  MOVFF  02,8AF
10CF0:  MOVFF  01,8AE
10CF4:  MOVFF  00,8AD
....................       react = NO3_array[3]; 
10CF8:  MOVFF  34E,902
10CFC:  MOVFF  34D,901
10D00:  CALL   C69C
10D04:  MOVFF  03,8B4
10D08:  MOVFF  02,8B3
10D0C:  MOVFF  01,8B2
10D10:  MOVFF  00,8B1
....................       ratio = blank / react;    
10D14:  MOVFF  8B0,8E8
10D18:  MOVFF  8AF,8E7
10D1C:  MOVFF  8AE,8E6
10D20:  MOVFF  8AD,8E5
10D24:  MOVFF  8B4,8EC
10D28:  MOVFF  8B3,8EB
10D2C:  MOVFF  8B2,8EA
10D30:  MOVFF  8B1,8E9
10D34:  CALL   C6D2
10D38:  MOVFF  03,8B8
10D3C:  MOVFF  02,8B7
10D40:  MOVFF  01,8B6
10D44:  MOVFF  00,8B5
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10D48:  MOVFF  8B8,8BC
10D4C:  MOVFF  8B7,8BB
10D50:  MOVFF  8B6,8BA
10D54:  MOVFF  8B5,8B9
10D58:  RCALL  1097A
10D5A:  MOVFF  03,3A8
10D5E:  MOVFF  02,3A7
10D62:  MOVFF  01,3A6
10D66:  MOVFF  00,3A5
10D6A:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10D6C:  MOVF   x4F,F
10D6E:  BNZ   10D74
10D70:  MOVF   x50,F
10D72:  BZ    10E0E
10D74:  MOVF   x51,F
10D76:  BNZ   10D7C
10D78:  MOVF   x52,F
10D7A:  BZ    10E0E
....................       blank = NO3_array[4]; 
10D7C:  MOVFF  350,902
10D80:  MOVFF  34F,901
10D84:  MOVLB  0
10D86:  CALL   C69C
10D8A:  MOVFF  03,8B0
10D8E:  MOVFF  02,8AF
10D92:  MOVFF  01,8AE
10D96:  MOVFF  00,8AD
....................       react = NO3_array[5]; 
10D9A:  MOVFF  352,902
10D9E:  MOVFF  351,901
10DA2:  CALL   C69C
10DA6:  MOVFF  03,8B4
10DAA:  MOVFF  02,8B3
10DAE:  MOVFF  01,8B2
10DB2:  MOVFF  00,8B1
....................       ratio = blank / react; 
10DB6:  MOVFF  8B0,8E8
10DBA:  MOVFF  8AF,8E7
10DBE:  MOVFF  8AE,8E6
10DC2:  MOVFF  8AD,8E5
10DC6:  MOVFF  8B4,8EC
10DCA:  MOVFF  8B3,8EB
10DCE:  MOVFF  8B2,8EA
10DD2:  MOVFF  8B1,8E9
10DD6:  CALL   C6D2
10DDA:  MOVFF  03,8B8
10DDE:  MOVFF  02,8B7
10DE2:  MOVFF  01,8B6
10DE6:  MOVFF  00,8B5
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
10DEA:  MOVFF  8B8,8BC
10DEE:  MOVFF  8B7,8BB
10DF2:  MOVFF  8B6,8BA
10DF6:  MOVFF  8B5,8B9
10DFA:  RCALL  1097A
10DFC:  MOVFF  03,3AC
10E00:  MOVFF  02,3AB
10E04:  MOVFF  01,3AA
10E08:  MOVFF  00,3A9
10E0C:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
10E0E:  MOVF   x53,F
10E10:  BNZ   10E16
10E12:  MOVF   x54,F
10E14:  BZ    10EB0
10E16:  MOVF   x55,F
10E18:  BNZ   10E1E
10E1A:  MOVF   x56,F
10E1C:  BZ    10EB0
....................       blank = NO3_array[6]; 
10E1E:  MOVFF  354,902
10E22:  MOVFF  353,901
10E26:  MOVLB  0
10E28:  CALL   C69C
10E2C:  MOVFF  03,8B0
10E30:  MOVFF  02,8AF
10E34:  MOVFF  01,8AE
10E38:  MOVFF  00,8AD
....................       react = NO3_array[7]; 
10E3C:  MOVFF  356,902
10E40:  MOVFF  355,901
10E44:  CALL   C69C
10E48:  MOVFF  03,8B4
10E4C:  MOVFF  02,8B3
10E50:  MOVFF  01,8B2
10E54:  MOVFF  00,8B1
....................       ratio = blank / react; 
10E58:  MOVFF  8B0,8E8
10E5C:  MOVFF  8AF,8E7
10E60:  MOVFF  8AE,8E6
10E64:  MOVFF  8AD,8E5
10E68:  MOVFF  8B4,8EC
10E6C:  MOVFF  8B3,8EB
10E70:  MOVFF  8B2,8EA
10E74:  MOVFF  8B1,8E9
10E78:  CALL   C6D2
10E7C:  MOVFF  03,8B8
10E80:  MOVFF  02,8B7
10E84:  MOVFF  01,8B6
10E88:  MOVFF  00,8B5
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
10E8C:  MOVFF  8B8,8BC
10E90:  MOVFF  8B7,8BB
10E94:  MOVFF  8B6,8BA
10E98:  MOVFF  8B5,8B9
10E9C:  RCALL  1097A
10E9E:  MOVFF  03,3B0
10EA2:  MOVFF  02,3AF
10EA6:  MOVFF  01,3AE
10EAA:  MOVFF  00,3AD
10EAE:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
10EB0:  MOVLW  04
10EB2:  MOVWF  1E
10EB4:  MOVLW  21
10EB6:  MOVWF  1D
10EB8:  MOVLW  A0
10EBA:  MOVWF  FF6
10EBC:  MOVLW  1D
10EBE:  MOVWF  FF7
10EC0:  MOVLW  00
10EC2:  MOVWF  FF8
10EC4:  MOVLW  06
10EC6:  MOVLB  8
10EC8:  MOVWF  xD5
10ECA:  MOVLB  0
10ECC:  CALL   AB04
10ED0:  MOVLW  10
10ED2:  MOVWF  FE9
10ED4:  MOVFF  348,8E1
10ED8:  MOVFF  347,8E0
10EDC:  CALL   AB36
10EE0:  MOVLW  A9
10EE2:  MOVWF  FF6
10EE4:  MOVLW  1D
10EE6:  MOVWF  FF7
10EE8:  MOVLW  00
10EEA:  MOVWF  FF8
10EEC:  MOVLW  07
10EEE:  MOVLB  8
10EF0:  MOVWF  xD5
10EF2:  MOVLB  0
10EF4:  CALL   AB04
10EF8:  MOVLW  10
10EFA:  MOVWF  FE9
10EFC:  MOVFF  34A,8E1
10F00:  MOVFF  349,8E0
10F04:  CALL   AB36
10F08:  MOVLW  B3
10F0A:  MOVWF  FF6
10F0C:  MOVLW  1D
10F0E:  MOVWF  FF7
10F10:  MOVLW  00
10F12:  MOVWF  FF8
10F14:  MOVLW  09
10F16:  MOVLB  8
10F18:  MOVWF  xD5
10F1A:  MOVLB  0
10F1C:  CALL   AB04
10F20:  MOVLW  89
10F22:  MOVWF  FE9
10F24:  MOVFF  3A4,8BC
10F28:  MOVFF  3A3,8BB
10F2C:  MOVFF  3A2,8BA
10F30:  MOVFF  3A1,8B9
10F34:  MOVLW  04
10F36:  MOVLB  8
10F38:  MOVWF  xBD
10F3A:  MOVLB  0
10F3C:  RCALL  109E6
10F3E:  MOVLW  C1
10F40:  MOVWF  FF6
10F42:  MOVLW  1D
10F44:  MOVWF  FF7
10F46:  MOVLW  00
10F48:  MOVWF  FF8
10F4A:  MOVLW  07
10F4C:  MOVLB  8
10F4E:  MOVWF  xD5
10F50:  MOVLB  0
10F52:  CALL   AB04
10F56:  MOVLW  10
10F58:  MOVWF  FE9
10F5A:  MOVFF  34C,8E1
10F5E:  MOVFF  34B,8E0
10F62:  CALL   AB36
10F66:  MOVLW  CB
10F68:  MOVWF  FF6
10F6A:  MOVLW  1D
10F6C:  MOVWF  FF7
10F6E:  MOVLW  00
10F70:  MOVWF  FF8
10F72:  MOVLW  07
10F74:  MOVLB  8
10F76:  MOVWF  xD5
10F78:  MOVLB  0
10F7A:  CALL   AB04
10F7E:  MOVLW  10
10F80:  MOVWF  FE9
10F82:  MOVFF  34E,8E1
10F86:  MOVFF  34D,8E0
10F8A:  CALL   AB36
10F8E:  MOVLW  D5
10F90:  MOVWF  FF6
10F92:  MOVLW  1D
10F94:  MOVWF  FF7
10F96:  MOVLW  00
10F98:  MOVWF  FF8
10F9A:  MOVLW  09
10F9C:  MOVLB  8
10F9E:  MOVWF  xD5
10FA0:  MOVLB  0
10FA2:  CALL   AB04
10FA6:  MOVLW  89
10FA8:  MOVWF  FE9
10FAA:  MOVFF  3A8,8BC
10FAE:  MOVFF  3A7,8BB
10FB2:  MOVFF  3A6,8BA
10FB6:  MOVFF  3A5,8B9
10FBA:  MOVLW  04
10FBC:  MOVLB  8
10FBE:  MOVWF  xBD
10FC0:  MOVLB  0
10FC2:  RCALL  109E6
10FC4:  MOVLW  E3
10FC6:  MOVWF  FF6
10FC8:  MOVLW  1D
10FCA:  MOVWF  FF7
10FCC:  MOVLW  00
10FCE:  MOVWF  FF8
10FD0:  MOVLW  07
10FD2:  MOVLB  8
10FD4:  MOVWF  xD5
10FD6:  MOVLB  0
10FD8:  CALL   AB04
10FDC:  MOVLW  10
10FDE:  MOVWF  FE9
10FE0:  MOVFF  350,8E1
10FE4:  MOVFF  34F,8E0
10FE8:  CALL   AB36
10FEC:  MOVLW  ED
10FEE:  MOVWF  FF6
10FF0:  MOVLW  1D
10FF2:  MOVWF  FF7
10FF4:  MOVLW  00
10FF6:  MOVWF  FF8
10FF8:  MOVLW  07
10FFA:  MOVLB  8
10FFC:  MOVWF  xD5
10FFE:  MOVLB  0
11000:  CALL   AB04
11004:  MOVLW  10
11006:  MOVWF  FE9
11008:  MOVFF  352,8E1
1100C:  MOVFF  351,8E0
11010:  CALL   AB36
11014:  MOVLW  F7
11016:  MOVWF  FF6
11018:  MOVLW  1D
1101A:  MOVWF  FF7
1101C:  MOVLW  00
1101E:  MOVWF  FF8
11020:  MOVLW  09
11022:  MOVLB  8
11024:  MOVWF  xD5
11026:  MOVLB  0
11028:  CALL   AB04
1102C:  MOVLW  89
1102E:  MOVWF  FE9
11030:  MOVFF  3AC,8BC
11034:  MOVFF  3AB,8BB
11038:  MOVFF  3AA,8BA
1103C:  MOVFF  3A9,8B9
11040:  MOVLW  04
11042:  MOVLB  8
11044:  MOVWF  xBD
11046:  MOVLB  0
11048:  RCALL  109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
1104A:  MOVF   1F,W
1104C:  SUBLW  02
1104E:  BNZ   11054
11050:  MOVF   20,F
11052:  BZ    11094
11054:  MOVLW  06
11056:  MOVWF  FF6
11058:  MOVLW  1E
1105A:  MOVWF  FF7
1105C:  MOVLW  00
1105E:  MOVWF  FF8
11060:  CLRF   1B
11062:  BTFSC  FF2.7
11064:  BSF    1B.7
11066:  BCF    FF2.7
11068:  MOVLW  09
1106A:  MOVLB  A
1106C:  MOVWF  x25
1106E:  MOVLB  0
11070:  CALL   101E
11074:  BTFSC  1B.7
11076:  BSF    FF2.7
11078:  MOVLW  04
1107A:  MOVWF  FEA
1107C:  MOVLW  21
1107E:  MOVWF  FE9
11080:  CALL   79DC
11084:  MOVLW  0D
11086:  BTFSS  F9E.4
11088:  BRA    11086
1108A:  MOVWF  FAD
1108C:  MOVLW  0A
1108E:  BTFSS  F9E.4
11090:  BRA    1108E
11092:  MOVWF  FAD
11094:  GOTO   123A0 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
11098:  MOVLB  8
1109A:  CLRF   xAC
1109C:  MOVF   xAC,W
1109E:  SUBLW  03
110A0:  BNC   110C0
110A2:  MOVF   xAC,W
110A4:  MULLW  04
110A6:  MOVF   FF3,W
110A8:  CLRF   03
110AA:  ADDLW  B1
110AC:  MOVWF  FE9
110AE:  MOVLW  03
110B0:  ADDWFC 03,W
110B2:  MOVWF  FEA
110B4:  CLRF   FEF
110B6:  CLRF   FEC
110B8:  CLRF   FEC
110BA:  CLRF   FEC
110BC:  INCF   xAC,F
110BE:  BRA    1109C
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
110C0:  MOVLB  3
110C2:  MOVF   x59,F
110C4:  BTFSS  FD8.2
110C6:  BRA    110CC
110C8:  MOVF   x5A,F
110CA:  BZ    11166
110CC:  MOVF   x5B,F
110CE:  BNZ   110D4
110D0:  MOVF   x5C,F
110D2:  BZ    11166
....................       blank = NO2_array[0]; 
110D4:  MOVFF  35A,902
110D8:  MOVFF  359,901
110DC:  MOVLB  0
110DE:  CALL   C69C
110E2:  MOVFF  03,8B0
110E6:  MOVFF  02,8AF
110EA:  MOVFF  01,8AE
110EE:  MOVFF  00,8AD
....................       react = NO2_array[1]; 
110F2:  MOVFF  35C,902
110F6:  MOVFF  35B,901
110FA:  CALL   C69C
110FE:  MOVFF  03,8B4
11102:  MOVFF  02,8B3
11106:  MOVFF  01,8B2
1110A:  MOVFF  00,8B1
....................       ratio = blank / react; 
1110E:  MOVFF  8B0,8E8
11112:  MOVFF  8AF,8E7
11116:  MOVFF  8AE,8E6
1111A:  MOVFF  8AD,8E5
1111E:  MOVFF  8B4,8EC
11122:  MOVFF  8B3,8EB
11126:  MOVFF  8B2,8EA
1112A:  MOVFF  8B1,8E9
1112E:  CALL   C6D2
11132:  MOVFF  03,8B8
11136:  MOVFF  02,8B7
1113A:  MOVFF  01,8B6
1113E:  MOVFF  00,8B5
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
11142:  MOVFF  8B8,8BC
11146:  MOVFF  8B7,8BB
1114A:  MOVFF  8B6,8BA
1114E:  MOVFF  8B5,8B9
11152:  RCALL  1097A
11154:  MOVFF  03,3B4
11158:  MOVFF  02,3B3
1115C:  MOVFF  01,3B2
11160:  MOVFF  00,3B1
11164:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
11166:  MOVF   x5D,F
11168:  BNZ   1116E
1116A:  MOVF   x5E,F
1116C:  BZ    1120A
1116E:  MOVF   x5F,F
11170:  BNZ   11176
11172:  MOVF   x60,F
11174:  BZ    1120A
....................       blank = NO2_array[2]; 
11176:  MOVFF  35E,902
1117A:  MOVFF  35D,901
1117E:  MOVLB  0
11180:  CALL   C69C
11184:  MOVFF  03,8B0
11188:  MOVFF  02,8AF
1118C:  MOVFF  01,8AE
11190:  MOVFF  00,8AD
....................       react = NO2_array[3]; 
11194:  MOVFF  360,902
11198:  MOVFF  35F,901
1119C:  CALL   C69C
111A0:  MOVFF  03,8B4
111A4:  MOVFF  02,8B3
111A8:  MOVFF  01,8B2
111AC:  MOVFF  00,8B1
....................       ratio = blank / react;    
111B0:  MOVFF  8B0,8E8
111B4:  MOVFF  8AF,8E7
111B8:  MOVFF  8AE,8E6
111BC:  MOVFF  8AD,8E5
111C0:  MOVFF  8B4,8EC
111C4:  MOVFF  8B3,8EB
111C8:  MOVFF  8B2,8EA
111CC:  MOVFF  8B1,8E9
111D0:  CALL   C6D2
111D4:  MOVFF  03,8B8
111D8:  MOVFF  02,8B7
111DC:  MOVFF  01,8B6
111E0:  MOVFF  00,8B5
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
111E4:  MOVFF  8B8,8BC
111E8:  MOVFF  8B7,8BB
111EC:  MOVFF  8B6,8BA
111F0:  MOVFF  8B5,8B9
111F4:  CALL   1097A
111F8:  MOVFF  03,3B8
111FC:  MOVFF  02,3B7
11200:  MOVFF  01,3B6
11204:  MOVFF  00,3B5
11208:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
1120A:  MOVF   x61,F
1120C:  BNZ   11212
1120E:  MOVF   x62,F
11210:  BZ    112AE
11212:  MOVF   x63,F
11214:  BNZ   1121A
11216:  MOVF   x64,F
11218:  BZ    112AE
....................       blank = NO2_array[4]; 
1121A:  MOVFF  362,902
1121E:  MOVFF  361,901
11222:  MOVLB  0
11224:  CALL   C69C
11228:  MOVFF  03,8B0
1122C:  MOVFF  02,8AF
11230:  MOVFF  01,8AE
11234:  MOVFF  00,8AD
....................       react = NO2_array[5]; 
11238:  MOVFF  364,902
1123C:  MOVFF  363,901
11240:  CALL   C69C
11244:  MOVFF  03,8B4
11248:  MOVFF  02,8B3
1124C:  MOVFF  01,8B2
11250:  MOVFF  00,8B1
....................       ratio = blank / react; 
11254:  MOVFF  8B0,8E8
11258:  MOVFF  8AF,8E7
1125C:  MOVFF  8AE,8E6
11260:  MOVFF  8AD,8E5
11264:  MOVFF  8B4,8EC
11268:  MOVFF  8B3,8EB
1126C:  MOVFF  8B2,8EA
11270:  MOVFF  8B1,8E9
11274:  CALL   C6D2
11278:  MOVFF  03,8B8
1127C:  MOVFF  02,8B7
11280:  MOVFF  01,8B6
11284:  MOVFF  00,8B5
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
11288:  MOVFF  8B8,8BC
1128C:  MOVFF  8B7,8BB
11290:  MOVFF  8B6,8BA
11294:  MOVFF  8B5,8B9
11298:  CALL   1097A
1129C:  MOVFF  03,3BC
112A0:  MOVFF  02,3BB
112A4:  MOVFF  01,3BA
112A8:  MOVFF  00,3B9
112AC:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
112AE:  MOVF   x65,F
112B0:  BNZ   112B6
112B2:  MOVF   x66,F
112B4:  BZ    11352
112B6:  MOVF   x67,F
112B8:  BNZ   112BE
112BA:  MOVF   x68,F
112BC:  BZ    11352
....................       blank = NO2_array[6]; 
112BE:  MOVFF  366,902
112C2:  MOVFF  365,901
112C6:  MOVLB  0
112C8:  CALL   C69C
112CC:  MOVFF  03,8B0
112D0:  MOVFF  02,8AF
112D4:  MOVFF  01,8AE
112D8:  MOVFF  00,8AD
....................       react = NO2_array[7]; 
112DC:  MOVFF  368,902
112E0:  MOVFF  367,901
112E4:  CALL   C69C
112E8:  MOVFF  03,8B4
112EC:  MOVFF  02,8B3
112F0:  MOVFF  01,8B2
112F4:  MOVFF  00,8B1
....................       ratio = blank / react; 
112F8:  MOVFF  8B0,8E8
112FC:  MOVFF  8AF,8E7
11300:  MOVFF  8AE,8E6
11304:  MOVFF  8AD,8E5
11308:  MOVFF  8B4,8EC
1130C:  MOVFF  8B3,8EB
11310:  MOVFF  8B2,8EA
11314:  MOVFF  8B1,8E9
11318:  CALL   C6D2
1131C:  MOVFF  03,8B8
11320:  MOVFF  02,8B7
11324:  MOVFF  01,8B6
11328:  MOVFF  00,8B5
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
1132C:  MOVFF  8B8,8BC
11330:  MOVFF  8B7,8BB
11334:  MOVFF  8B6,8BA
11338:  MOVFF  8B5,8B9
1133C:  CALL   1097A
11340:  MOVFF  03,3C0
11344:  MOVFF  02,3BF
11348:  MOVFF  01,3BE
1134C:  MOVFF  00,3BD
11350:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
11352:  MOVLW  04
11354:  MOVWF  1E
11356:  MOVLW  21
11358:  MOVWF  1D
1135A:  MOVLW  14
1135C:  MOVWF  FF6
1135E:  MOVLW  1E
11360:  MOVWF  FF7
11362:  MOVLW  00
11364:  MOVWF  FF8
11366:  MOVLW  06
11368:  MOVLB  8
1136A:  MOVWF  xD5
1136C:  MOVLB  0
1136E:  CALL   AB04
11372:  MOVLW  10
11374:  MOVWF  FE9
11376:  MOVFF  35A,8E1
1137A:  MOVFF  359,8E0
1137E:  CALL   AB36
11382:  MOVLW  1D
11384:  MOVWF  FF6
11386:  MOVLW  1E
11388:  MOVWF  FF7
1138A:  MOVLW  00
1138C:  MOVWF  FF8
1138E:  MOVLW  07
11390:  MOVLB  8
11392:  MOVWF  xD5
11394:  MOVLB  0
11396:  CALL   AB04
1139A:  MOVLW  10
1139C:  MOVWF  FE9
1139E:  MOVFF  35C,8E1
113A2:  MOVFF  35B,8E0
113A6:  CALL   AB36
113AA:  MOVLW  27
113AC:  MOVWF  FF6
113AE:  MOVLW  1E
113B0:  MOVWF  FF7
113B2:  MOVLW  00
113B4:  MOVWF  FF8
113B6:  MOVLW  09
113B8:  MOVLB  8
113BA:  MOVWF  xD5
113BC:  MOVLB  0
113BE:  CALL   AB04
113C2:  MOVLW  89
113C4:  MOVWF  FE9
113C6:  MOVFF  3B4,8BC
113CA:  MOVFF  3B3,8BB
113CE:  MOVFF  3B2,8BA
113D2:  MOVFF  3B1,8B9
113D6:  MOVLW  04
113D8:  MOVLB  8
113DA:  MOVWF  xBD
113DC:  MOVLB  0
113DE:  CALL   109E6
113E2:  MOVLW  35
113E4:  MOVWF  FF6
113E6:  MOVLW  1E
113E8:  MOVWF  FF7
113EA:  MOVLW  00
113EC:  MOVWF  FF8
113EE:  MOVLW  07
113F0:  MOVLB  8
113F2:  MOVWF  xD5
113F4:  MOVLB  0
113F6:  CALL   AB04
113FA:  MOVLW  10
113FC:  MOVWF  FE9
113FE:  MOVFF  35E,8E1
11402:  MOVFF  35D,8E0
11406:  CALL   AB36
1140A:  MOVLW  3F
1140C:  MOVWF  FF6
1140E:  MOVLW  1E
11410:  MOVWF  FF7
11412:  MOVLW  00
11414:  MOVWF  FF8
11416:  MOVLW  07
11418:  MOVLB  8
1141A:  MOVWF  xD5
1141C:  MOVLB  0
1141E:  CALL   AB04
11422:  MOVLW  10
11424:  MOVWF  FE9
11426:  MOVFF  360,8E1
1142A:  MOVFF  35F,8E0
1142E:  CALL   AB36
11432:  MOVLW  49
11434:  MOVWF  FF6
11436:  MOVLW  1E
11438:  MOVWF  FF7
1143A:  MOVLW  00
1143C:  MOVWF  FF8
1143E:  MOVLW  09
11440:  MOVLB  8
11442:  MOVWF  xD5
11444:  MOVLB  0
11446:  CALL   AB04
1144A:  MOVLW  89
1144C:  MOVWF  FE9
1144E:  MOVFF  3B8,8BC
11452:  MOVFF  3B7,8BB
11456:  MOVFF  3B6,8BA
1145A:  MOVFF  3B5,8B9
1145E:  MOVLW  04
11460:  MOVLB  8
11462:  MOVWF  xBD
11464:  MOVLB  0
11466:  CALL   109E6
1146A:  MOVLW  57
1146C:  MOVWF  FF6
1146E:  MOVLW  1E
11470:  MOVWF  FF7
11472:  MOVLW  00
11474:  MOVWF  FF8
11476:  MOVLW  07
11478:  MOVLB  8
1147A:  MOVWF  xD5
1147C:  MOVLB  0
1147E:  CALL   AB04
11482:  MOVLW  10
11484:  MOVWF  FE9
11486:  MOVFF  362,8E1
1148A:  MOVFF  361,8E0
1148E:  CALL   AB36
11492:  MOVLW  61
11494:  MOVWF  FF6
11496:  MOVLW  1E
11498:  MOVWF  FF7
1149A:  MOVLW  00
1149C:  MOVWF  FF8
1149E:  MOVLW  07
114A0:  MOVLB  8
114A2:  MOVWF  xD5
114A4:  MOVLB  0
114A6:  CALL   AB04
114AA:  MOVLW  10
114AC:  MOVWF  FE9
114AE:  MOVFF  364,8E1
114B2:  MOVFF  363,8E0
114B6:  CALL   AB36
114BA:  MOVLW  6B
114BC:  MOVWF  FF6
114BE:  MOVLW  1E
114C0:  MOVWF  FF7
114C2:  MOVLW  00
114C4:  MOVWF  FF8
114C6:  MOVLW  09
114C8:  MOVLB  8
114CA:  MOVWF  xD5
114CC:  MOVLB  0
114CE:  CALL   AB04
114D2:  MOVLW  89
114D4:  MOVWF  FE9
114D6:  MOVFF  3BC,8BC
114DA:  MOVFF  3BB,8BB
114DE:  MOVFF  3BA,8BA
114E2:  MOVFF  3B9,8B9
114E6:  MOVLW  04
114E8:  MOVLB  8
114EA:  MOVWF  xBD
114EC:  MOVLB  0
114EE:  CALL   109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
114F2:  MOVF   1F,W
114F4:  SUBLW  02
114F6:  BNZ   114FC
114F8:  MOVF   20,F
114FA:  BZ    1153C
114FC:  MOVLW  7A
114FE:  MOVWF  FF6
11500:  MOVLW  1E
11502:  MOVWF  FF7
11504:  MOVLW  00
11506:  MOVWF  FF8
11508:  CLRF   1B
1150A:  BTFSC  FF2.7
1150C:  BSF    1B.7
1150E:  BCF    FF2.7
11510:  MOVLW  09
11512:  MOVLB  A
11514:  MOVWF  x25
11516:  MOVLB  0
11518:  CALL   101E
1151C:  BTFSC  1B.7
1151E:  BSF    FF2.7
11520:  MOVLW  04
11522:  MOVWF  FEA
11524:  MOVLW  21
11526:  MOVWF  FE9
11528:  CALL   79DC
1152C:  MOVLW  0D
1152E:  BTFSS  F9E.4
11530:  BRA    1152E
11532:  MOVWF  FAD
11534:  MOVLW  0A
11536:  BTFSS  F9E.4
11538:  BRA    11536
1153A:  MOVWF  FAD
1153C:  GOTO   123A0 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
11540:  MOVLB  8
11542:  CLRF   xAC
11544:  MOVF   xAC,W
11546:  SUBLW  03
11548:  BNC   11568
1154A:  MOVF   xAC,W
1154C:  MULLW  04
1154E:  MOVF   FF3,W
11550:  CLRF   03
11552:  ADDLW  C1
11554:  MOVWF  FE9
11556:  MOVLW  03
11558:  ADDWFC 03,W
1155A:  MOVWF  FEA
1155C:  CLRF   FEF
1155E:  CLRF   FEC
11560:  CLRF   FEC
11562:  CLRF   FEC
11564:  INCF   xAC,F
11566:  BRA    11544
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
11568:  MOVLB  3
1156A:  MOVF   x6B,F
1156C:  BTFSS  FD8.2
1156E:  BRA    11574
11570:  MOVF   x6C,F
11572:  BZ    11610
11574:  MOVF   x6D,F
11576:  BNZ   1157C
11578:  MOVF   x6E,F
1157A:  BZ    11610
....................       blank = PO4_array[0]; 
1157C:  MOVFF  36C,902
11580:  MOVFF  36B,901
11584:  MOVLB  0
11586:  CALL   C69C
1158A:  MOVFF  03,8B0
1158E:  MOVFF  02,8AF
11592:  MOVFF  01,8AE
11596:  MOVFF  00,8AD
....................       react = PO4_array[1]; 
1159A:  MOVFF  36E,902
1159E:  MOVFF  36D,901
115A2:  CALL   C69C
115A6:  MOVFF  03,8B4
115AA:  MOVFF  02,8B3
115AE:  MOVFF  01,8B2
115B2:  MOVFF  00,8B1
....................       ratio = blank / react; 
115B6:  MOVFF  8B0,8E8
115BA:  MOVFF  8AF,8E7
115BE:  MOVFF  8AE,8E6
115C2:  MOVFF  8AD,8E5
115C6:  MOVFF  8B4,8EC
115CA:  MOVFF  8B3,8EB
115CE:  MOVFF  8B2,8EA
115D2:  MOVFF  8B1,8E9
115D6:  CALL   C6D2
115DA:  MOVFF  03,8B8
115DE:  MOVFF  02,8B7
115E2:  MOVFF  01,8B6
115E6:  MOVFF  00,8B5
....................       PO4_abs_array[0] = log10(ratio); 
115EA:  MOVFF  8B8,8BC
115EE:  MOVFF  8B7,8BB
115F2:  MOVFF  8B6,8BA
115F6:  MOVFF  8B5,8B9
115FA:  CALL   1097A
115FE:  MOVFF  03,3C4
11602:  MOVFF  02,3C3
11606:  MOVFF  01,3C2
1160A:  MOVFF  00,3C1
1160E:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
11610:  MOVF   x6F,F
11612:  BNZ   11618
11614:  MOVF   x70,F
11616:  BZ    116B4
11618:  MOVF   x71,F
1161A:  BNZ   11620
1161C:  MOVF   x72,F
1161E:  BZ    116B4
....................       blank = PO4_array[2]; 
11620:  MOVFF  370,902
11624:  MOVFF  36F,901
11628:  MOVLB  0
1162A:  CALL   C69C
1162E:  MOVFF  03,8B0
11632:  MOVFF  02,8AF
11636:  MOVFF  01,8AE
1163A:  MOVFF  00,8AD
....................       react = PO4_array[3]; 
1163E:  MOVFF  372,902
11642:  MOVFF  371,901
11646:  CALL   C69C
1164A:  MOVFF  03,8B4
1164E:  MOVFF  02,8B3
11652:  MOVFF  01,8B2
11656:  MOVFF  00,8B1
....................       ratio = blank / react;    
1165A:  MOVFF  8B0,8E8
1165E:  MOVFF  8AF,8E7
11662:  MOVFF  8AE,8E6
11666:  MOVFF  8AD,8E5
1166A:  MOVFF  8B4,8EC
1166E:  MOVFF  8B3,8EB
11672:  MOVFF  8B2,8EA
11676:  MOVFF  8B1,8E9
1167A:  CALL   C6D2
1167E:  MOVFF  03,8B8
11682:  MOVFF  02,8B7
11686:  MOVFF  01,8B6
1168A:  MOVFF  00,8B5
....................       PO4_abs_array[1] = log10(ratio); 
1168E:  MOVFF  8B8,8BC
11692:  MOVFF  8B7,8BB
11696:  MOVFF  8B6,8BA
1169A:  MOVFF  8B5,8B9
1169E:  CALL   1097A
116A2:  MOVFF  03,3C8
116A6:  MOVFF  02,3C7
116AA:  MOVFF  01,3C6
116AE:  MOVFF  00,3C5
116B2:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
116B4:  MOVF   x73,F
116B6:  BNZ   116BC
116B8:  MOVF   x74,F
116BA:  BZ    11758
116BC:  MOVF   x75,F
116BE:  BNZ   116C4
116C0:  MOVF   x76,F
116C2:  BZ    11758
....................       blank = PO4_array[4]; 
116C4:  MOVFF  374,902
116C8:  MOVFF  373,901
116CC:  MOVLB  0
116CE:  CALL   C69C
116D2:  MOVFF  03,8B0
116D6:  MOVFF  02,8AF
116DA:  MOVFF  01,8AE
116DE:  MOVFF  00,8AD
....................       react = PO4_array[5]; 
116E2:  MOVFF  376,902
116E6:  MOVFF  375,901
116EA:  CALL   C69C
116EE:  MOVFF  03,8B4
116F2:  MOVFF  02,8B3
116F6:  MOVFF  01,8B2
116FA:  MOVFF  00,8B1
....................       ratio = blank / react; 
116FE:  MOVFF  8B0,8E8
11702:  MOVFF  8AF,8E7
11706:  MOVFF  8AE,8E6
1170A:  MOVFF  8AD,8E5
1170E:  MOVFF  8B4,8EC
11712:  MOVFF  8B3,8EB
11716:  MOVFF  8B2,8EA
1171A:  MOVFF  8B1,8E9
1171E:  CALL   C6D2
11722:  MOVFF  03,8B8
11726:  MOVFF  02,8B7
1172A:  MOVFF  01,8B6
1172E:  MOVFF  00,8B5
....................       PO4_abs_array[2] = log10(ratio); 
11732:  MOVFF  8B8,8BC
11736:  MOVFF  8B7,8BB
1173A:  MOVFF  8B6,8BA
1173E:  MOVFF  8B5,8B9
11742:  CALL   1097A
11746:  MOVFF  03,3CC
1174A:  MOVFF  02,3CB
1174E:  MOVFF  01,3CA
11752:  MOVFF  00,3C9
11756:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
11758:  MOVF   x77,F
1175A:  BNZ   11760
1175C:  MOVF   x78,F
1175E:  BZ    117FC
11760:  MOVF   x79,F
11762:  BNZ   11768
11764:  MOVF   x7A,F
11766:  BZ    117FC
....................       blank = PO4_array[6]; 
11768:  MOVFF  378,902
1176C:  MOVFF  377,901
11770:  MOVLB  0
11772:  CALL   C69C
11776:  MOVFF  03,8B0
1177A:  MOVFF  02,8AF
1177E:  MOVFF  01,8AE
11782:  MOVFF  00,8AD
....................       react = PO4_array[7]; 
11786:  MOVFF  37A,902
1178A:  MOVFF  379,901
1178E:  CALL   C69C
11792:  MOVFF  03,8B4
11796:  MOVFF  02,8B3
1179A:  MOVFF  01,8B2
1179E:  MOVFF  00,8B1
....................       ratio = blank / react; 
117A2:  MOVFF  8B0,8E8
117A6:  MOVFF  8AF,8E7
117AA:  MOVFF  8AE,8E6
117AE:  MOVFF  8AD,8E5
117B2:  MOVFF  8B4,8EC
117B6:  MOVFF  8B3,8EB
117BA:  MOVFF  8B2,8EA
117BE:  MOVFF  8B1,8E9
117C2:  CALL   C6D2
117C6:  MOVFF  03,8B8
117CA:  MOVFF  02,8B7
117CE:  MOVFF  01,8B6
117D2:  MOVFF  00,8B5
....................       PO4_abs_array[3] = log10(ratio); 
117D6:  MOVFF  8B8,8BC
117DA:  MOVFF  8B7,8BB
117DE:  MOVFF  8B6,8BA
117E2:  MOVFF  8B5,8B9
117E6:  CALL   1097A
117EA:  MOVFF  03,3D0
117EE:  MOVFF  02,3CF
117F2:  MOVFF  01,3CE
117F6:  MOVFF  00,3CD
117FA:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
117FC:  MOVLW  04
117FE:  MOVWF  1E
11800:  MOVLW  21
11802:  MOVWF  1D
11804:  MOVLW  88
11806:  MOVWF  FF6
11808:  MOVLW  1E
1180A:  MOVWF  FF7
1180C:  MOVLW  00
1180E:  MOVWF  FF8
11810:  MOVLW  06
11812:  MOVLB  8
11814:  MOVWF  xD5
11816:  MOVLB  0
11818:  CALL   AB04
1181C:  MOVLW  10
1181E:  MOVWF  FE9
11820:  MOVFF  36C,8E1
11824:  MOVFF  36B,8E0
11828:  CALL   AB36
1182C:  MOVLW  91
1182E:  MOVWF  FF6
11830:  MOVLW  1E
11832:  MOVWF  FF7
11834:  MOVLW  00
11836:  MOVWF  FF8
11838:  MOVLW  07
1183A:  MOVLB  8
1183C:  MOVWF  xD5
1183E:  MOVLB  0
11840:  CALL   AB04
11844:  MOVLW  10
11846:  MOVWF  FE9
11848:  MOVFF  36E,8E1
1184C:  MOVFF  36D,8E0
11850:  CALL   AB36
11854:  MOVLW  9B
11856:  MOVWF  FF6
11858:  MOVLW  1E
1185A:  MOVWF  FF7
1185C:  MOVLW  00
1185E:  MOVWF  FF8
11860:  MOVLW  09
11862:  MOVLB  8
11864:  MOVWF  xD5
11866:  MOVLB  0
11868:  CALL   AB04
1186C:  MOVLW  89
1186E:  MOVWF  FE9
11870:  MOVFF  3C4,8BC
11874:  MOVFF  3C3,8BB
11878:  MOVFF  3C2,8BA
1187C:  MOVFF  3C1,8B9
11880:  MOVLW  04
11882:  MOVLB  8
11884:  MOVWF  xBD
11886:  MOVLB  0
11888:  CALL   109E6
1188C:  MOVLW  A9
1188E:  MOVWF  FF6
11890:  MOVLW  1E
11892:  MOVWF  FF7
11894:  MOVLW  00
11896:  MOVWF  FF8
11898:  MOVLW  07
1189A:  MOVLB  8
1189C:  MOVWF  xD5
1189E:  MOVLB  0
118A0:  CALL   AB04
118A4:  MOVLW  10
118A6:  MOVWF  FE9
118A8:  MOVFF  370,8E1
118AC:  MOVFF  36F,8E0
118B0:  CALL   AB36
118B4:  MOVLW  B3
118B6:  MOVWF  FF6
118B8:  MOVLW  1E
118BA:  MOVWF  FF7
118BC:  MOVLW  00
118BE:  MOVWF  FF8
118C0:  MOVLW  07
118C2:  MOVLB  8
118C4:  MOVWF  xD5
118C6:  MOVLB  0
118C8:  CALL   AB04
118CC:  MOVLW  10
118CE:  MOVWF  FE9
118D0:  MOVFF  372,8E1
118D4:  MOVFF  371,8E0
118D8:  CALL   AB36
118DC:  MOVLW  BD
118DE:  MOVWF  FF6
118E0:  MOVLW  1E
118E2:  MOVWF  FF7
118E4:  MOVLW  00
118E6:  MOVWF  FF8
118E8:  MOVLW  09
118EA:  MOVLB  8
118EC:  MOVWF  xD5
118EE:  MOVLB  0
118F0:  CALL   AB04
118F4:  MOVLW  89
118F6:  MOVWF  FE9
118F8:  MOVFF  3C8,8BC
118FC:  MOVFF  3C7,8BB
11900:  MOVFF  3C6,8BA
11904:  MOVFF  3C5,8B9
11908:  MOVLW  04
1190A:  MOVLB  8
1190C:  MOVWF  xBD
1190E:  MOVLB  0
11910:  CALL   109E6
11914:  MOVLW  CB
11916:  MOVWF  FF6
11918:  MOVLW  1E
1191A:  MOVWF  FF7
1191C:  MOVLW  00
1191E:  MOVWF  FF8
11920:  MOVLW  07
11922:  MOVLB  8
11924:  MOVWF  xD5
11926:  MOVLB  0
11928:  CALL   AB04
1192C:  MOVLW  10
1192E:  MOVWF  FE9
11930:  MOVFF  374,8E1
11934:  MOVFF  373,8E0
11938:  CALL   AB36
1193C:  MOVLW  D5
1193E:  MOVWF  FF6
11940:  MOVLW  1E
11942:  MOVWF  FF7
11944:  MOVLW  00
11946:  MOVWF  FF8
11948:  MOVLW  07
1194A:  MOVLB  8
1194C:  MOVWF  xD5
1194E:  MOVLB  0
11950:  CALL   AB04
11954:  MOVLW  10
11956:  MOVWF  FE9
11958:  MOVFF  376,8E1
1195C:  MOVFF  375,8E0
11960:  CALL   AB36
11964:  MOVLW  DF
11966:  MOVWF  FF6
11968:  MOVLW  1E
1196A:  MOVWF  FF7
1196C:  MOVLW  00
1196E:  MOVWF  FF8
11970:  MOVLW  09
11972:  MOVLB  8
11974:  MOVWF  xD5
11976:  MOVLB  0
11978:  CALL   AB04
1197C:  MOVLW  89
1197E:  MOVWF  FE9
11980:  MOVFF  3CC,8BC
11984:  MOVFF  3CB,8BB
11988:  MOVFF  3CA,8BA
1198C:  MOVFF  3C9,8B9
11990:  MOVLW  04
11992:  MOVLB  8
11994:  MOVWF  xBD
11996:  MOVLB  0
11998:  CALL   109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
1199C:  MOVF   1F,W
1199E:  SUBLW  02
119A0:  BNZ   119A6
119A2:  MOVF   20,F
119A4:  BZ    119E6
119A6:  MOVLW  EE
119A8:  MOVWF  FF6
119AA:  MOVLW  1E
119AC:  MOVWF  FF7
119AE:  MOVLW  00
119B0:  MOVWF  FF8
119B2:  CLRF   1B
119B4:  BTFSC  FF2.7
119B6:  BSF    1B.7
119B8:  BCF    FF2.7
119BA:  MOVLW  09
119BC:  MOVLB  A
119BE:  MOVWF  x25
119C0:  MOVLB  0
119C2:  CALL   101E
119C6:  BTFSC  1B.7
119C8:  BSF    FF2.7
119CA:  MOVLW  04
119CC:  MOVWF  FEA
119CE:  MOVLW  21
119D0:  MOVWF  FE9
119D2:  CALL   79DC
119D6:  MOVLW  0D
119D8:  BTFSS  F9E.4
119DA:  BRA    119D8
119DC:  MOVWF  FAD
119DE:  MOVLW  0A
119E0:  BTFSS  F9E.4
119E2:  BRA    119E0
119E4:  MOVWF  FAD
119E6:  GOTO   123A0 (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
119EA:  MOVLB  8
119EC:  CLRF   xAC
119EE:  MOVF   xAC,W
119F0:  SUBLW  03
119F2:  BNC   11A12
119F4:  MOVF   xAC,W
119F6:  MULLW  04
119F8:  MOVF   FF3,W
119FA:  CLRF   03
119FC:  ADDLW  D1
119FE:  MOVWF  FE9
11A00:  MOVLW  03
11A02:  ADDWFC 03,W
11A04:  MOVWF  FEA
11A06:  CLRF   FEF
11A08:  CLRF   FEC
11A0A:  CLRF   FEC
11A0C:  CLRF   FEC
11A0E:  INCF   xAC,F
11A10:  BRA    119EE
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
11A12:  MOVLB  3
11A14:  MOVF   x7D,F
11A16:  BTFSS  FD8.2
11A18:  BRA    11A1E
11A1A:  MOVF   x7E,F
11A1C:  BZ    11ABA
11A1E:  MOVF   x7F,F
11A20:  BNZ   11A26
11A22:  MOVF   x80,F
11A24:  BZ    11ABA
....................       blank = NH4_array[0]; 
11A26:  MOVFF  37E,902
11A2A:  MOVFF  37D,901
11A2E:  MOVLB  0
11A30:  CALL   C69C
11A34:  MOVFF  03,8B0
11A38:  MOVFF  02,8AF
11A3C:  MOVFF  01,8AE
11A40:  MOVFF  00,8AD
....................       react = NH4_array[1]; 
11A44:  MOVFF  380,902
11A48:  MOVFF  37F,901
11A4C:  CALL   C69C
11A50:  MOVFF  03,8B4
11A54:  MOVFF  02,8B3
11A58:  MOVFF  01,8B2
11A5C:  MOVFF  00,8B1
....................       ratio = blank / react; 
11A60:  MOVFF  8B0,8E8
11A64:  MOVFF  8AF,8E7
11A68:  MOVFF  8AE,8E6
11A6C:  MOVFF  8AD,8E5
11A70:  MOVFF  8B4,8EC
11A74:  MOVFF  8B3,8EB
11A78:  MOVFF  8B2,8EA
11A7C:  MOVFF  8B1,8E9
11A80:  CALL   C6D2
11A84:  MOVFF  03,8B8
11A88:  MOVFF  02,8B7
11A8C:  MOVFF  01,8B6
11A90:  MOVFF  00,8B5
....................       NH4_abs_array[0] = log10(ratio); 
11A94:  MOVFF  8B8,8BC
11A98:  MOVFF  8B7,8BB
11A9C:  MOVFF  8B6,8BA
11AA0:  MOVFF  8B5,8B9
11AA4:  CALL   1097A
11AA8:  MOVFF  03,3D4
11AAC:  MOVFF  02,3D3
11AB0:  MOVFF  01,3D2
11AB4:  MOVFF  00,3D1
11AB8:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
11ABA:  MOVF   x81,F
11ABC:  BNZ   11AC2
11ABE:  MOVF   x82,F
11AC0:  BZ    11B5E
11AC2:  MOVF   x83,F
11AC4:  BNZ   11ACA
11AC6:  MOVF   x84,F
11AC8:  BZ    11B5E
....................       blank = NH4_array[2]; 
11ACA:  MOVFF  382,902
11ACE:  MOVFF  381,901
11AD2:  MOVLB  0
11AD4:  CALL   C69C
11AD8:  MOVFF  03,8B0
11ADC:  MOVFF  02,8AF
11AE0:  MOVFF  01,8AE
11AE4:  MOVFF  00,8AD
....................       react = NH4_array[3]; 
11AE8:  MOVFF  384,902
11AEC:  MOVFF  383,901
11AF0:  CALL   C69C
11AF4:  MOVFF  03,8B4
11AF8:  MOVFF  02,8B3
11AFC:  MOVFF  01,8B2
11B00:  MOVFF  00,8B1
....................       ratio = blank / react;    
11B04:  MOVFF  8B0,8E8
11B08:  MOVFF  8AF,8E7
11B0C:  MOVFF  8AE,8E6
11B10:  MOVFF  8AD,8E5
11B14:  MOVFF  8B4,8EC
11B18:  MOVFF  8B3,8EB
11B1C:  MOVFF  8B2,8EA
11B20:  MOVFF  8B1,8E9
11B24:  CALL   C6D2
11B28:  MOVFF  03,8B8
11B2C:  MOVFF  02,8B7
11B30:  MOVFF  01,8B6
11B34:  MOVFF  00,8B5
....................       NH4_abs_array[1] = log10(ratio); 
11B38:  MOVFF  8B8,8BC
11B3C:  MOVFF  8B7,8BB
11B40:  MOVFF  8B6,8BA
11B44:  MOVFF  8B5,8B9
11B48:  CALL   1097A
11B4C:  MOVFF  03,3D8
11B50:  MOVFF  02,3D7
11B54:  MOVFF  01,3D6
11B58:  MOVFF  00,3D5
11B5C:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11B5E:  MOVF   x85,F
11B60:  BNZ   11B66
11B62:  MOVF   x86,F
11B64:  BZ    11C02
11B66:  MOVF   x87,F
11B68:  BNZ   11B6E
11B6A:  MOVF   x88,F
11B6C:  BZ    11C02
....................       blank = NH4_array[4]; 
11B6E:  MOVFF  386,902
11B72:  MOVFF  385,901
11B76:  MOVLB  0
11B78:  CALL   C69C
11B7C:  MOVFF  03,8B0
11B80:  MOVFF  02,8AF
11B84:  MOVFF  01,8AE
11B88:  MOVFF  00,8AD
....................       react = NH4_array[5]; 
11B8C:  MOVFF  388,902
11B90:  MOVFF  387,901
11B94:  CALL   C69C
11B98:  MOVFF  03,8B4
11B9C:  MOVFF  02,8B3
11BA0:  MOVFF  01,8B2
11BA4:  MOVFF  00,8B1
....................       ratio = blank / react; 
11BA8:  MOVFF  8B0,8E8
11BAC:  MOVFF  8AF,8E7
11BB0:  MOVFF  8AE,8E6
11BB4:  MOVFF  8AD,8E5
11BB8:  MOVFF  8B4,8EC
11BBC:  MOVFF  8B3,8EB
11BC0:  MOVFF  8B2,8EA
11BC4:  MOVFF  8B1,8E9
11BC8:  CALL   C6D2
11BCC:  MOVFF  03,8B8
11BD0:  MOVFF  02,8B7
11BD4:  MOVFF  01,8B6
11BD8:  MOVFF  00,8B5
....................       NH4_abs_array[2] = log10(ratio); 
11BDC:  MOVFF  8B8,8BC
11BE0:  MOVFF  8B7,8BB
11BE4:  MOVFF  8B6,8BA
11BE8:  MOVFF  8B5,8B9
11BEC:  CALL   1097A
11BF0:  MOVFF  03,3DC
11BF4:  MOVFF  02,3DB
11BF8:  MOVFF  01,3DA
11BFC:  MOVFF  00,3D9
11C00:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11C02:  MOVF   x89,F
11C04:  BNZ   11C0A
11C06:  MOVF   x8A,F
11C08:  BZ    11CA6
11C0A:  MOVF   x8B,F
11C0C:  BNZ   11C12
11C0E:  MOVF   x8C,F
11C10:  BZ    11CA6
....................       blank = NH4_array[6]; 
11C12:  MOVFF  38A,902
11C16:  MOVFF  389,901
11C1A:  MOVLB  0
11C1C:  CALL   C69C
11C20:  MOVFF  03,8B0
11C24:  MOVFF  02,8AF
11C28:  MOVFF  01,8AE
11C2C:  MOVFF  00,8AD
....................       react = NH4_array[7]; 
11C30:  MOVFF  38C,902
11C34:  MOVFF  38B,901
11C38:  CALL   C69C
11C3C:  MOVFF  03,8B4
11C40:  MOVFF  02,8B3
11C44:  MOVFF  01,8B2
11C48:  MOVFF  00,8B1
....................       ratio = blank / react; 
11C4C:  MOVFF  8B0,8E8
11C50:  MOVFF  8AF,8E7
11C54:  MOVFF  8AE,8E6
11C58:  MOVFF  8AD,8E5
11C5C:  MOVFF  8B4,8EC
11C60:  MOVFF  8B3,8EB
11C64:  MOVFF  8B2,8EA
11C68:  MOVFF  8B1,8E9
11C6C:  CALL   C6D2
11C70:  MOVFF  03,8B8
11C74:  MOVFF  02,8B7
11C78:  MOVFF  01,8B6
11C7C:  MOVFF  00,8B5
....................       NH4_abs_array[3] = log10(ratio); 
11C80:  MOVFF  8B8,8BC
11C84:  MOVFF  8B7,8BB
11C88:  MOVFF  8B6,8BA
11C8C:  MOVFF  8B5,8B9
11C90:  CALL   1097A
11C94:  MOVFF  03,3E0
11C98:  MOVFF  02,3DF
11C9C:  MOVFF  01,3DE
11CA0:  MOVFF  00,3DD
11CA4:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11CA6:  MOVLW  04
11CA8:  MOVWF  1E
11CAA:  MOVLW  21
11CAC:  MOVWF  1D
11CAE:  MOVLW  FC
11CB0:  MOVWF  FF6
11CB2:  MOVLW  1E
11CB4:  MOVWF  FF7
11CB6:  MOVLW  00
11CB8:  MOVWF  FF8
11CBA:  MOVLW  06
11CBC:  MOVLB  8
11CBE:  MOVWF  xD5
11CC0:  MOVLB  0
11CC2:  CALL   AB04
11CC6:  MOVLW  10
11CC8:  MOVWF  FE9
11CCA:  MOVFF  37E,8E1
11CCE:  MOVFF  37D,8E0
11CD2:  CALL   AB36
11CD6:  MOVLW  05
11CD8:  MOVWF  FF6
11CDA:  MOVLW  1F
11CDC:  MOVWF  FF7
11CDE:  MOVLW  00
11CE0:  MOVWF  FF8
11CE2:  MOVLW  07
11CE4:  MOVLB  8
11CE6:  MOVWF  xD5
11CE8:  MOVLB  0
11CEA:  CALL   AB04
11CEE:  MOVLW  10
11CF0:  MOVWF  FE9
11CF2:  MOVFF  380,8E1
11CF6:  MOVFF  37F,8E0
11CFA:  CALL   AB36
11CFE:  MOVLW  0F
11D00:  MOVWF  FF6
11D02:  MOVLW  1F
11D04:  MOVWF  FF7
11D06:  MOVLW  00
11D08:  MOVWF  FF8
11D0A:  MOVLW  09
11D0C:  MOVLB  8
11D0E:  MOVWF  xD5
11D10:  MOVLB  0
11D12:  CALL   AB04
11D16:  MOVLW  89
11D18:  MOVWF  FE9
11D1A:  MOVFF  3D4,8BC
11D1E:  MOVFF  3D3,8BB
11D22:  MOVFF  3D2,8BA
11D26:  MOVFF  3D1,8B9
11D2A:  MOVLW  04
11D2C:  MOVLB  8
11D2E:  MOVWF  xBD
11D30:  MOVLB  0
11D32:  CALL   109E6
11D36:  MOVLW  1D
11D38:  MOVWF  FF6
11D3A:  MOVLW  1F
11D3C:  MOVWF  FF7
11D3E:  MOVLW  00
11D40:  MOVWF  FF8
11D42:  MOVLW  07
11D44:  MOVLB  8
11D46:  MOVWF  xD5
11D48:  MOVLB  0
11D4A:  CALL   AB04
11D4E:  MOVLW  10
11D50:  MOVWF  FE9
11D52:  MOVFF  382,8E1
11D56:  MOVFF  381,8E0
11D5A:  CALL   AB36
11D5E:  MOVLW  27
11D60:  MOVWF  FF6
11D62:  MOVLW  1F
11D64:  MOVWF  FF7
11D66:  MOVLW  00
11D68:  MOVWF  FF8
11D6A:  MOVLW  07
11D6C:  MOVLB  8
11D6E:  MOVWF  xD5
11D70:  MOVLB  0
11D72:  CALL   AB04
11D76:  MOVLW  10
11D78:  MOVWF  FE9
11D7A:  MOVFF  384,8E1
11D7E:  MOVFF  383,8E0
11D82:  CALL   AB36
11D86:  MOVLW  31
11D88:  MOVWF  FF6
11D8A:  MOVLW  1F
11D8C:  MOVWF  FF7
11D8E:  MOVLW  00
11D90:  MOVWF  FF8
11D92:  MOVLW  09
11D94:  MOVLB  8
11D96:  MOVWF  xD5
11D98:  MOVLB  0
11D9A:  CALL   AB04
11D9E:  MOVLW  89
11DA0:  MOVWF  FE9
11DA2:  MOVFF  3D8,8BC
11DA6:  MOVFF  3D7,8BB
11DAA:  MOVFF  3D6,8BA
11DAE:  MOVFF  3D5,8B9
11DB2:  MOVLW  04
11DB4:  MOVLB  8
11DB6:  MOVWF  xBD
11DB8:  MOVLB  0
11DBA:  CALL   109E6
11DBE:  MOVLW  3F
11DC0:  MOVWF  FF6
11DC2:  MOVLW  1F
11DC4:  MOVWF  FF7
11DC6:  MOVLW  00
11DC8:  MOVWF  FF8
11DCA:  MOVLW  07
11DCC:  MOVLB  8
11DCE:  MOVWF  xD5
11DD0:  MOVLB  0
11DD2:  CALL   AB04
11DD6:  MOVLW  10
11DD8:  MOVWF  FE9
11DDA:  MOVFF  386,8E1
11DDE:  MOVFF  385,8E0
11DE2:  CALL   AB36
11DE6:  MOVLW  49
11DE8:  MOVWF  FF6
11DEA:  MOVLW  1F
11DEC:  MOVWF  FF7
11DEE:  MOVLW  00
11DF0:  MOVWF  FF8
11DF2:  MOVLW  07
11DF4:  MOVLB  8
11DF6:  MOVWF  xD5
11DF8:  MOVLB  0
11DFA:  CALL   AB04
11DFE:  MOVLW  10
11E00:  MOVWF  FE9
11E02:  MOVFF  388,8E1
11E06:  MOVFF  387,8E0
11E0A:  CALL   AB36
11E0E:  MOVLW  53
11E10:  MOVWF  FF6
11E12:  MOVLW  1F
11E14:  MOVWF  FF7
11E16:  MOVLW  00
11E18:  MOVWF  FF8
11E1A:  MOVLW  09
11E1C:  MOVLB  8
11E1E:  MOVWF  xD5
11E20:  MOVLB  0
11E22:  CALL   AB04
11E26:  MOVLW  89
11E28:  MOVWF  FE9
11E2A:  MOVFF  3DC,8BC
11E2E:  MOVFF  3DB,8BB
11E32:  MOVFF  3DA,8BA
11E36:  MOVFF  3D9,8B9
11E3A:  MOVLW  04
11E3C:  MOVLB  8
11E3E:  MOVWF  xBD
11E40:  MOVLB  0
11E42:  CALL   109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
11E46:  MOVF   1F,W
11E48:  SUBLW  02
11E4A:  BNZ   11E50
11E4C:  MOVF   20,F
11E4E:  BZ    11E90
11E50:  MOVLW  62
11E52:  MOVWF  FF6
11E54:  MOVLW  1F
11E56:  MOVWF  FF7
11E58:  MOVLW  00
11E5A:  MOVWF  FF8
11E5C:  CLRF   1B
11E5E:  BTFSC  FF2.7
11E60:  BSF    1B.7
11E62:  BCF    FF2.7
11E64:  MOVLW  09
11E66:  MOVLB  A
11E68:  MOVWF  x25
11E6A:  MOVLB  0
11E6C:  CALL   101E
11E70:  BTFSC  1B.7
11E72:  BSF    FF2.7
11E74:  MOVLW  04
11E76:  MOVWF  FEA
11E78:  MOVLW  21
11E7A:  MOVWF  FE9
11E7C:  CALL   79DC
11E80:  MOVLW  0D
11E82:  BTFSS  F9E.4
11E84:  BRA    11E82
11E86:  MOVWF  FAD
11E88:  MOVLW  0A
11E8A:  BTFSS  F9E.4
11E8C:  BRA    11E8A
11E8E:  MOVWF  FAD
11E90:  GOTO   123A0 (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
11E94:  MOVLB  8
11E96:  CLRF   xAC
11E98:  MOVF   xAC,W
11E9A:  SUBLW  03
11E9C:  BNC   11EBC
11E9E:  MOVF   xAC,W
11EA0:  MULLW  04
11EA2:  MOVF   FF3,W
11EA4:  CLRF   03
11EA6:  ADDLW  E1
11EA8:  MOVWF  FE9
11EAA:  MOVLW  03
11EAC:  ADDWFC 03,W
11EAE:  MOVWF  FEA
11EB0:  CLRF   FEF
11EB2:  CLRF   FEC
11EB4:  CLRF   FEC
11EB6:  CLRF   FEC
11EB8:  INCF   xAC,F
11EBA:  BRA    11E98
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
11EBC:  MOVLB  3
11EBE:  MOVF   x8F,F
11EC0:  BTFSS  FD8.2
11EC2:  BRA    11EC8
11EC4:  MOVF   x90,F
11EC6:  BZ    11F64
11EC8:  MOVF   x91,F
11ECA:  BNZ   11ED0
11ECC:  MOVF   x92,F
11ECE:  BZ    11F64
....................       blank = SiO_array[0]; 
11ED0:  MOVFF  390,902
11ED4:  MOVFF  38F,901
11ED8:  MOVLB  0
11EDA:  CALL   C69C
11EDE:  MOVFF  03,8B0
11EE2:  MOVFF  02,8AF
11EE6:  MOVFF  01,8AE
11EEA:  MOVFF  00,8AD
....................       react = SiO_array[1]; 
11EEE:  MOVFF  392,902
11EF2:  MOVFF  391,901
11EF6:  CALL   C69C
11EFA:  MOVFF  03,8B4
11EFE:  MOVFF  02,8B3
11F02:  MOVFF  01,8B2
11F06:  MOVFF  00,8B1
....................       ratio = blank / react; 
11F0A:  MOVFF  8B0,8E8
11F0E:  MOVFF  8AF,8E7
11F12:  MOVFF  8AE,8E6
11F16:  MOVFF  8AD,8E5
11F1A:  MOVFF  8B4,8EC
11F1E:  MOVFF  8B3,8EB
11F22:  MOVFF  8B2,8EA
11F26:  MOVFF  8B1,8E9
11F2A:  CALL   C6D2
11F2E:  MOVFF  03,8B8
11F32:  MOVFF  02,8B7
11F36:  MOVFF  01,8B6
11F3A:  MOVFF  00,8B5
....................       SiO_abs_array[0] = log10(ratio); 
11F3E:  MOVFF  8B8,8BC
11F42:  MOVFF  8B7,8BB
11F46:  MOVFF  8B6,8BA
11F4A:  MOVFF  8B5,8B9
11F4E:  CALL   1097A
11F52:  MOVFF  03,3E4
11F56:  MOVFF  02,3E3
11F5A:  MOVFF  01,3E2
11F5E:  MOVFF  00,3E1
11F62:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
11F64:  MOVF   x93,F
11F66:  BNZ   11F6C
11F68:  MOVF   x94,F
11F6A:  BZ    12008
11F6C:  MOVF   x95,F
11F6E:  BNZ   11F74
11F70:  MOVF   x96,F
11F72:  BZ    12008
....................       blank = SiO_array[2]; 
11F74:  MOVFF  394,902
11F78:  MOVFF  393,901
11F7C:  MOVLB  0
11F7E:  CALL   C69C
11F82:  MOVFF  03,8B0
11F86:  MOVFF  02,8AF
11F8A:  MOVFF  01,8AE
11F8E:  MOVFF  00,8AD
....................       react = SiO_array[3]; 
11F92:  MOVFF  396,902
11F96:  MOVFF  395,901
11F9A:  CALL   C69C
11F9E:  MOVFF  03,8B4
11FA2:  MOVFF  02,8B3
11FA6:  MOVFF  01,8B2
11FAA:  MOVFF  00,8B1
....................       ratio = blank / react;    
11FAE:  MOVFF  8B0,8E8
11FB2:  MOVFF  8AF,8E7
11FB6:  MOVFF  8AE,8E6
11FBA:  MOVFF  8AD,8E5
11FBE:  MOVFF  8B4,8EC
11FC2:  MOVFF  8B3,8EB
11FC6:  MOVFF  8B2,8EA
11FCA:  MOVFF  8B1,8E9
11FCE:  CALL   C6D2
11FD2:  MOVFF  03,8B8
11FD6:  MOVFF  02,8B7
11FDA:  MOVFF  01,8B6
11FDE:  MOVFF  00,8B5
....................       SiO_abs_array[1] = log10(ratio); 
11FE2:  MOVFF  8B8,8BC
11FE6:  MOVFF  8B7,8BB
11FEA:  MOVFF  8B6,8BA
11FEE:  MOVFF  8B5,8B9
11FF2:  CALL   1097A
11FF6:  MOVFF  03,3E8
11FFA:  MOVFF  02,3E7
11FFE:  MOVFF  01,3E6
12002:  MOVFF  00,3E5
12006:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
12008:  MOVF   x97,F
1200A:  BNZ   12010
1200C:  MOVF   x98,F
1200E:  BZ    120AC
12010:  MOVF   x99,F
12012:  BNZ   12018
12014:  MOVF   x9A,F
12016:  BZ    120AC
....................       blank = SiO_array[4]; 
12018:  MOVFF  398,902
1201C:  MOVFF  397,901
12020:  MOVLB  0
12022:  CALL   C69C
12026:  MOVFF  03,8B0
1202A:  MOVFF  02,8AF
1202E:  MOVFF  01,8AE
12032:  MOVFF  00,8AD
....................       react = SiO_array[5]; 
12036:  MOVFF  39A,902
1203A:  MOVFF  399,901
1203E:  CALL   C69C
12042:  MOVFF  03,8B4
12046:  MOVFF  02,8B3
1204A:  MOVFF  01,8B2
1204E:  MOVFF  00,8B1
....................       ratio = blank / react; 
12052:  MOVFF  8B0,8E8
12056:  MOVFF  8AF,8E7
1205A:  MOVFF  8AE,8E6
1205E:  MOVFF  8AD,8E5
12062:  MOVFF  8B4,8EC
12066:  MOVFF  8B3,8EB
1206A:  MOVFF  8B2,8EA
1206E:  MOVFF  8B1,8E9
12072:  CALL   C6D2
12076:  MOVFF  03,8B8
1207A:  MOVFF  02,8B7
1207E:  MOVFF  01,8B6
12082:  MOVFF  00,8B5
....................       SiO_abs_array[2] = log10(ratio); 
12086:  MOVFF  8B8,8BC
1208A:  MOVFF  8B7,8BB
1208E:  MOVFF  8B6,8BA
12092:  MOVFF  8B5,8B9
12096:  CALL   1097A
1209A:  MOVFF  03,3EC
1209E:  MOVFF  02,3EB
120A2:  MOVFF  01,3EA
120A6:  MOVFF  00,3E9
120AA:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
120AC:  MOVF   x9B,F
120AE:  BNZ   120B4
120B0:  MOVF   x9C,F
120B2:  BZ    12150
120B4:  MOVF   x9D,F
120B6:  BNZ   120BC
120B8:  MOVF   x9E,F
120BA:  BZ    12150
....................       blank = SiO_array[6]; 
120BC:  MOVFF  39C,902
120C0:  MOVFF  39B,901
120C4:  MOVLB  0
120C6:  CALL   C69C
120CA:  MOVFF  03,8B0
120CE:  MOVFF  02,8AF
120D2:  MOVFF  01,8AE
120D6:  MOVFF  00,8AD
....................       react = SiO_array[7]; 
120DA:  MOVFF  39E,902
120DE:  MOVFF  39D,901
120E2:  CALL   C69C
120E6:  MOVFF  03,8B4
120EA:  MOVFF  02,8B3
120EE:  MOVFF  01,8B2
120F2:  MOVFF  00,8B1
....................       ratio = blank / react; 
120F6:  MOVFF  8B0,8E8
120FA:  MOVFF  8AF,8E7
120FE:  MOVFF  8AE,8E6
12102:  MOVFF  8AD,8E5
12106:  MOVFF  8B4,8EC
1210A:  MOVFF  8B3,8EB
1210E:  MOVFF  8B2,8EA
12112:  MOVFF  8B1,8E9
12116:  CALL   C6D2
1211A:  MOVFF  03,8B8
1211E:  MOVFF  02,8B7
12122:  MOVFF  01,8B6
12126:  MOVFF  00,8B5
....................       SiO_abs_array[3] = log10(ratio); 
1212A:  MOVFF  8B8,8BC
1212E:  MOVFF  8B7,8BB
12132:  MOVFF  8B6,8BA
12136:  MOVFF  8B5,8B9
1213A:  CALL   1097A
1213E:  MOVFF  03,3F0
12142:  MOVFF  02,3EF
12146:  MOVFF  01,3EE
1214A:  MOVFF  00,3ED
1214E:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
12150:  MOVLW  04
12152:  MOVWF  1E
12154:  MOVLW  21
12156:  MOVWF  1D
12158:  MOVLW  70
1215A:  MOVWF  FF6
1215C:  MOVLW  1F
1215E:  MOVWF  FF7
12160:  MOVLW  00
12162:  MOVWF  FF8
12164:  MOVLW  06
12166:  MOVLB  8
12168:  MOVWF  xD5
1216A:  MOVLB  0
1216C:  CALL   AB04
12170:  MOVLW  10
12172:  MOVWF  FE9
12174:  MOVFF  390,8E1
12178:  MOVFF  38F,8E0
1217C:  CALL   AB36
12180:  MOVLW  79
12182:  MOVWF  FF6
12184:  MOVLW  1F
12186:  MOVWF  FF7
12188:  MOVLW  00
1218A:  MOVWF  FF8
1218C:  MOVLW  07
1218E:  MOVLB  8
12190:  MOVWF  xD5
12192:  MOVLB  0
12194:  CALL   AB04
12198:  MOVLW  10
1219A:  MOVWF  FE9
1219C:  MOVFF  392,8E1
121A0:  MOVFF  391,8E0
121A4:  CALL   AB36
121A8:  MOVLW  83
121AA:  MOVWF  FF6
121AC:  MOVLW  1F
121AE:  MOVWF  FF7
121B0:  MOVLW  00
121B2:  MOVWF  FF8
121B4:  MOVLW  09
121B6:  MOVLB  8
121B8:  MOVWF  xD5
121BA:  MOVLB  0
121BC:  CALL   AB04
121C0:  MOVLW  89
121C2:  MOVWF  FE9
121C4:  MOVFF  3E4,8BC
121C8:  MOVFF  3E3,8BB
121CC:  MOVFF  3E2,8BA
121D0:  MOVFF  3E1,8B9
121D4:  MOVLW  04
121D6:  MOVLB  8
121D8:  MOVWF  xBD
121DA:  MOVLB  0
121DC:  CALL   109E6
121E0:  MOVLW  91
121E2:  MOVWF  FF6
121E4:  MOVLW  1F
121E6:  MOVWF  FF7
121E8:  MOVLW  00
121EA:  MOVWF  FF8
121EC:  MOVLW  07
121EE:  MOVLB  8
121F0:  MOVWF  xD5
121F2:  MOVLB  0
121F4:  CALL   AB04
121F8:  MOVLW  10
121FA:  MOVWF  FE9
121FC:  MOVFF  394,8E1
12200:  MOVFF  393,8E0
12204:  CALL   AB36
12208:  MOVLW  9B
1220A:  MOVWF  FF6
1220C:  MOVLW  1F
1220E:  MOVWF  FF7
12210:  MOVLW  00
12212:  MOVWF  FF8
12214:  MOVLW  07
12216:  MOVLB  8
12218:  MOVWF  xD5
1221A:  MOVLB  0
1221C:  CALL   AB04
12220:  MOVLW  10
12222:  MOVWF  FE9
12224:  MOVFF  396,8E1
12228:  MOVFF  395,8E0
1222C:  CALL   AB36
12230:  MOVLW  A5
12232:  MOVWF  FF6
12234:  MOVLW  1F
12236:  MOVWF  FF7
12238:  MOVLW  00
1223A:  MOVWF  FF8
1223C:  MOVLW  09
1223E:  MOVLB  8
12240:  MOVWF  xD5
12242:  MOVLB  0
12244:  CALL   AB04
12248:  MOVLW  89
1224A:  MOVWF  FE9
1224C:  MOVFF  3E8,8BC
12250:  MOVFF  3E7,8BB
12254:  MOVFF  3E6,8BA
12258:  MOVFF  3E5,8B9
1225C:  MOVLW  04
1225E:  MOVLB  8
12260:  MOVWF  xBD
12262:  MOVLB  0
12264:  CALL   109E6
12268:  MOVLW  B3
1226A:  MOVWF  FF6
1226C:  MOVLW  1F
1226E:  MOVWF  FF7
12270:  MOVLW  00
12272:  MOVWF  FF8
12274:  MOVLW  07
12276:  MOVLB  8
12278:  MOVWF  xD5
1227A:  MOVLB  0
1227C:  CALL   AB04
12280:  MOVLW  10
12282:  MOVWF  FE9
12284:  MOVFF  398,8E1
12288:  MOVFF  397,8E0
1228C:  CALL   AB36
12290:  MOVLW  BD
12292:  MOVWF  FF6
12294:  MOVLW  1F
12296:  MOVWF  FF7
12298:  MOVLW  00
1229A:  MOVWF  FF8
1229C:  MOVLW  07
1229E:  MOVLB  8
122A0:  MOVWF  xD5
122A2:  MOVLB  0
122A4:  CALL   AB04
122A8:  MOVLW  10
122AA:  MOVWF  FE9
122AC:  MOVFF  39A,8E1
122B0:  MOVFF  399,8E0
122B4:  CALL   AB36
122B8:  MOVLW  C7
122BA:  MOVWF  FF6
122BC:  MOVLW  1F
122BE:  MOVWF  FF7
122C0:  MOVLW  00
122C2:  MOVWF  FF8
122C4:  MOVLW  09
122C6:  MOVLB  8
122C8:  MOVWF  xD5
122CA:  MOVLB  0
122CC:  CALL   AB04
122D0:  MOVLW  89
122D2:  MOVWF  FE9
122D4:  MOVFF  3EC,8BC
122D8:  MOVFF  3EB,8BB
122DC:  MOVFF  3EA,8BA
122E0:  MOVFF  3E9,8B9
122E4:  MOVLW  04
122E6:  MOVLB  8
122E8:  MOVWF  xBD
122EA:  MOVLB  0
122EC:  CALL   109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
122F0:  MOVF   1F,W
122F2:  SUBLW  02
122F4:  BNZ   122FA
122F6:  MOVF   20,F
122F8:  BZ    1233A
122FA:  MOVLW  D6
122FC:  MOVWF  FF6
122FE:  MOVLW  1F
12300:  MOVWF  FF7
12302:  MOVLW  00
12304:  MOVWF  FF8
12306:  CLRF   1B
12308:  BTFSC  FF2.7
1230A:  BSF    1B.7
1230C:  BCF    FF2.7
1230E:  MOVLW  09
12310:  MOVLB  A
12312:  MOVWF  x25
12314:  MOVLB  0
12316:  CALL   101E
1231A:  BTFSC  1B.7
1231C:  BSF    FF2.7
1231E:  MOVLW  04
12320:  MOVWF  FEA
12322:  MOVLW  21
12324:  MOVWF  FE9
12326:  CALL   79DC
1232A:  MOVLW  0D
1232C:  BTFSS  F9E.4
1232E:  BRA    1232C
12330:  MOVWF  FAD
12332:  MOVLW  0A
12334:  BTFSS  F9E.4
12336:  BRA    12334
12338:  MOVWF  FAD
1233A:  GOTO   123A0 (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
1233E:  MOVLW  04
12340:  MOVWF  FEA
12342:  MOVLW  21
12344:  MOVWF  FE9
12346:  MOVLW  00
12348:  CALL   056C
1234C:  TBLRD*-
1234E:  TBLRD*+
12350:  MOVF   FF5,W
12352:  MOVWF  FEE
12354:  IORLW  00
12356:  BNZ   1234E
....................     
....................    switch (chem){ 
12358:  MOVLW  E4
1235A:  MOVWF  FF6
1235C:  MOVLW  1F
1235E:  MOVWF  FF7
12360:  MOVLW  00
12362:  MOVWF  FF8
12364:  MOVLW  03
12366:  MOVWF  FEA
12368:  MOVLW  39
1236A:  MOVWF  FE9
1236C:  CALL   FBE4
12370:  MOVF   01,W
12372:  BZ    12386
12374:  XORLW  01
12376:  BZ    1238C
12378:  XORLW  03
1237A:  BZ    12392
1237C:  XORLW  01
1237E:  BZ    12398
12380:  XORLW  07
12382:  BZ    1239E
12384:  BRA    123A0
....................       case "NO3" : calc_abs_NO3(); 
12386:  GOTO   10BFC
....................          break; 
1238A:  BRA    123A0
....................       case "NO2" : calc_abs_NO2 (); 
1238C:  GOTO   11098
....................          break;    
12390:  BRA    123A0
....................       case "PO4" : calc_abs_PO4(); 
12392:  GOTO   11540
....................          break; 
12396:  BRA    123A0
....................       case "NH4" : calc_abs_NH4(); 
12398:  GOTO   119EA
....................          break; 
1239C:  BRA    123A0
....................       case "SiO" : calc_abs_SiO(); 
1239E:  BRA    11E94
....................          break; 
....................    } 
123A0:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
123A2:  CALL   D2AE
....................     
....................    if (data_available == TRUE) { 
123A6:  MOVLB  3
123A8:  DECFSZ x37,W
123AA:  BRA    124AC
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
123AC:  MOVLB  8
123AE:  CLRF   xE3
123B0:  MOVLW  63
123B2:  MOVWF  xE2
123B4:  MOVLW  02
123B6:  MOVWF  xE5
123B8:  MOVLW  B3
123BA:  MOVWF  xE4
123BC:  MOVLB  0
123BE:  CALL   5536
....................       strcat(data_buffer, comma); 
123C2:  MOVLB  8
123C4:  CLRF   xE3
123C6:  MOVLW  63
123C8:  MOVWF  xE2
123CA:  MOVLW  03
123CC:  MOVWF  xE5
123CE:  MOVLW  35
123D0:  MOVWF  xE4
123D2:  MOVLB  0
123D4:  CALL   5536
....................       strcat(data_buffer, chem); 
123D8:  MOVLB  8
123DA:  CLRF   xE3
123DC:  MOVLW  63
123DE:  MOVWF  xE2
123E0:  MOVLW  03
123E2:  MOVWF  xE5
123E4:  MOVLW  39
123E6:  MOVWF  xE4
123E8:  MOVLB  0
123EA:  CALL   5536
....................       strcat(data_buffer, comma); 
123EE:  MOVLB  8
123F0:  CLRF   xE3
123F2:  MOVLW  63
123F4:  MOVWF  xE2
123F6:  MOVLW  03
123F8:  MOVWF  xE5
123FA:  MOVLW  35
123FC:  MOVWF  xE4
123FE:  MOVLB  0
12400:  CALL   5536
....................       strcat(data_buffer, abs_str); 
12404:  MOVLB  8
12406:  CLRF   xE3
12408:  MOVLW  63
1240A:  MOVWF  xE2
1240C:  MOVLW  04
1240E:  MOVWF  xE5
12410:  MOVLW  21
12412:  MOVWF  xE4
12414:  MOVLB  0
12416:  CALL   5536
....................       strcat(data_buffer, endofline); 
1241A:  MOVLB  8
1241C:  CLRF   xE3
1241E:  MOVLW  63
12420:  MOVWF  xE2
12422:  MOVLW  07
12424:  MOVWF  xE5
12426:  MOVLW  CA
12428:  MOVWF  xE4
1242A:  MOVLB  0
1242C:  CALL   5536
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
12430:  MOVF   1F,W
12432:  SUBLW  04
12434:  BNZ   12454
12436:  MOVF   20,F
12438:  BNZ   12454
1243A:  CLRF   FEA
1243C:  MOVLW  63
1243E:  MOVWF  FE9
12440:  CALL   79DC
12444:  MOVLW  0D
12446:  BTFSS  F9E.4
12448:  BRA    12446
1244A:  MOVWF  FAD
1244C:  MOVLW  0A
1244E:  BTFSS  F9E.4
12450:  BRA    1244E
12452:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
12454:  MOVLB  2
12456:  MOVF   xD8,F
12458:  BNZ   124AA
....................        
....................          buffer_select = 0; 
1245A:  MOVLB  0
1245C:  CLRF   x62
....................           
....................          heartbeat(FALSE); 
1245E:  MOVLB  8
12460:  CLRF   xD7
12462:  MOVLB  0
12464:  CALL   55DA
....................             append_data(file_ptr_rel_all); 
12468:  MOVLW  02
1246A:  MOVLB  8
1246C:  MOVWF  xD8
1246E:  MOVLW  F5
12470:  MOVWF  xD7
12472:  MOVLB  0
12474:  CALL   8338
....................          heartbeat(TRUE);          
12478:  MOVLW  01
1247A:  MOVLB  8
1247C:  MOVWF  xD7
1247E:  MOVLB  0
12480:  CALL   55DA
....................           
....................          heartbeat(FALSE); 
12484:  MOVLB  8
12486:  CLRF   xD7
12488:  MOVLB  0
1248A:  CALL   55DA
....................             append_data(file_ptr_rel_new);    
1248E:  MOVLW  03
12490:  MOVLB  8
12492:  MOVWF  xD8
12494:  MOVWF  xD7
12496:  MOVLB  0
12498:  CALL   8338
....................          heartbeat(TRUE); 
1249C:  MOVLW  01
1249E:  MOVLB  8
124A0:  MOVWF  xD7
124A2:  MOVLB  0
124A4:  CALL   55DA
124A8:  MOVLB  2
124AA:  MOVLB  3
....................       } 
....................    } 
124AC:  MOVLB  0
124AE:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D3C4:  MOVLW  2C
0D3C6:  MOVLB  8
0D3C8:  MOVWF  x88
0D3CA:  CLRF   x89
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D3CC:  MOVLW  0D
0D3CE:  MOVWF  x8A
0D3D0:  MOVLW  0A
0D3D2:  MOVWF  x8B
0D3D4:  CLRF   x8C
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D3D6:  MOVLB  0
0D3D8:  RCALL  D2AE
....................    time_stamp(); 
0D3DA:  CALL   5472
....................    strcat(data_buffer, time_stmp_str); 
0D3DE:  MOVLB  8
0D3E0:  CLRF   xE3
0D3E2:  MOVLW  63
0D3E4:  MOVWF  xE2
0D3E6:  MOVLW  02
0D3E8:  MOVWF  xE5
0D3EA:  MOVLW  95
0D3EC:  MOVWF  xE4
0D3EE:  MOVLB  0
0D3F0:  CALL   5536
....................    strcat(data_buffer, comma); 
0D3F4:  MOVLB  8
0D3F6:  CLRF   xE3
0D3F8:  MOVLW  63
0D3FA:  MOVWF  xE2
0D3FC:  MOVLW  08
0D3FE:  MOVWF  xE5
0D400:  MOVLW  88
0D402:  MOVWF  xE4
0D404:  MOVLB  0
0D406:  CALL   5536
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D40A:  MOVLW  08
0D40C:  MOVWF  1E
0D40E:  MOVLW  8D
0D410:  MOVWF  1D
0D412:  MOVFF  887,8D7
0D416:  MOVLW  1B
0D418:  MOVLB  8
0D41A:  MOVWF  xD8
0D41C:  MOVLB  0
0D41E:  CALL   52D8
0D422:  MOVLW  2C
0D424:  MOVLB  8
0D426:  MOVWF  xE9
0D428:  MOVLB  0
0D42A:  CALL   50F6
0D42E:  MOVLW  10
0D430:  MOVWF  FE9
0D432:  MOVFF  2A,8E1
0D436:  MOVFF  29,8E0
0D43A:  CALL   AB36
0D43E:  MOVLW  2C
0D440:  MOVLB  8
0D442:  MOVWF  xE9
0D444:  MOVLB  0
0D446:  CALL   50F6
0D44A:  MOVLW  10
0D44C:  MOVWF  FE9
0D44E:  MOVFF  24,8E1
0D452:  MOVFF  23,8E0
0D456:  CALL   AB36
0D45A:  MOVLW  2C
0D45C:  MOVLB  8
0D45E:  MOVWF  xE9
0D460:  MOVLB  0
0D462:  CALL   50F6
0D466:  MOVLW  10
0D468:  MOVWF  FE9
0D46A:  MOVFF  2C,8E1
0D46E:  MOVFF  2B,8E0
0D472:  CALL   AB36
0D476:  MOVLW  2C
0D478:  MOVLB  8
0D47A:  MOVWF  xE9
0D47C:  MOVLB  0
0D47E:  CALL   50F6
0D482:  MOVLW  10
0D484:  MOVWF  FE9
0D486:  MOVFF  2E,8E1
0D48A:  MOVFF  2D,8E0
0D48E:  CALL   AB36
0D492:  MOVLW  2C
0D494:  MOVLB  8
0D496:  MOVWF  xE9
0D498:  MOVLB  0
0D49A:  CALL   50F6
0D49E:  MOVLW  10
0D4A0:  MOVWF  FE9
0D4A2:  MOVFF  22,8E1
0D4A6:  MOVFF  21,8E0
0D4AA:  CALL   AB36
0D4AE:  MOVLW  2C
0D4B0:  MOVLB  8
0D4B2:  MOVWF  xE9
0D4B4:  MOVLB  0
0D4B6:  CALL   50F6
0D4BA:  MOVLW  10
0D4BC:  MOVWF  FE9
0D4BE:  MOVFF  7C4,8E1
0D4C2:  MOVFF  7C3,8E0
0D4C6:  CALL   AB36
0D4CA:  MOVLW  2C
0D4CC:  MOVLB  8
0D4CE:  MOVWF  xE9
0D4D0:  MOVLB  0
0D4D2:  CALL   50F6
0D4D6:  MOVLW  10
0D4D8:  MOVWF  FE9
0D4DA:  MOVFF  7B2,8AC
0D4DE:  MOVFF  7B1,8AB
0D4E2:  BRA    D2C2
....................    strcat(data_buffer, config_str); 
0D4E4:  MOVLB  8
0D4E6:  CLRF   xE3
0D4E8:  MOVLW  63
0D4EA:  MOVWF  xE2
0D4EC:  MOVLW  08
0D4EE:  MOVWF  xE5
0D4F0:  MOVLW  8D
0D4F2:  MOVWF  xE4
0D4F4:  MOVLB  0
0D4F6:  CALL   5536
....................    strcat(data_buffer, endofline); 
0D4FA:  MOVLB  8
0D4FC:  CLRF   xE3
0D4FE:  MOVLW  63
0D500:  MOVWF  xE2
0D502:  MOVLW  08
0D504:  MOVWF  xE5
0D506:  MOVLW  8A
0D508:  MOVWF  xE4
0D50A:  MOVLB  0
0D50C:  CALL   5536
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D510:  CLRF   FEA
0D512:  MOVLW  63
0D514:  MOVWF  FE9
0D516:  CALL   79DC
0D51A:  MOVLW  0D
0D51C:  BTFSS  F9E.4
0D51E:  BRA    D51C
0D520:  MOVWF  FAD
0D522:  MOVLW  0A
0D524:  BTFSS  F9E.4
0D526:  BRA    D524
0D528:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D52A:  MOVLB  2
0D52C:  MOVF   xD8,F
0D52E:  BNZ   D582
....................     
....................       buffer_select = 0; 
0D530:  MOVLB  0
0D532:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
0D534:  MOVLB  8
0D536:  CLRF   xD7
0D538:  MOVLB  0
0D53A:  CALL   55DA
....................          append_data(file_ptr_raw_all); 
0D53E:  MOVLW  02
0D540:  MOVLB  8
0D542:  MOVWF  xD8
0D544:  MOVLW  D9
0D546:  MOVWF  xD7
0D548:  MOVLB  0
0D54A:  CALL   8338
....................       heartbeat(TRUE);          
0D54E:  MOVLW  01
0D550:  MOVLB  8
0D552:  MOVWF  xD7
0D554:  MOVLB  0
0D556:  CALL   55DA
....................        
....................       heartbeat(FALSE); 
0D55A:  MOVLB  8
0D55C:  CLRF   xD7
0D55E:  MOVLB  0
0D560:  CALL   55DA
....................          append_data(file_ptr_raw_new);    
0D564:  MOVLW  02
0D566:  MOVLB  8
0D568:  MOVWF  xD8
0D56A:  MOVLW  E7
0D56C:  MOVWF  xD7
0D56E:  MOVLB  0
0D570:  CALL   8338
....................       heartbeat(TRUE); 
0D574:  MOVLW  01
0D576:  MOVLB  8
0D578:  MOVWF  xD7
0D57A:  MOVLB  0
0D57C:  CALL   55DA
0D580:  MOVLB  2
....................    } 
0D582:  MOVLB  0
0D584:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
14EAA:  MOVLW  2C
14EAC:  MOVLB  8
14EAE:  MOVWF  x8A
14EB0:  CLRF   x8B
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
14EB2:  MOVLW  0D
14EB4:  MOVWF  x8C
14EB6:  MOVLW  0A
14EB8:  MOVWF  x8D
14EBA:  CLRF   x8E
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
14EBC:  MOVLB  0
14EBE:  CALL   D2AE
....................    time_stamp(); 
14EC2:  CALL   5472
....................    strcat(data_buffer, time_stmp_str); 
14EC6:  MOVLB  8
14EC8:  CLRF   xE3
14ECA:  MOVLW  63
14ECC:  MOVWF  xE2
14ECE:  MOVLW  02
14ED0:  MOVWF  xE5
14ED2:  MOVLW  95
14ED4:  MOVWF  xE4
14ED6:  MOVLB  0
14ED8:  CALL   5536
....................    strcat(data_buffer, comma); 
14EDC:  MOVLB  8
14EDE:  CLRF   xE3
14EE0:  MOVLW  63
14EE2:  MOVWF  xE2
14EE4:  MOVLW  08
14EE6:  MOVWF  xE5
14EE8:  MOVLW  8A
14EEA:  MOVWF  xE4
14EEC:  MOVLB  0
14EEE:  CALL   5536
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
14EF2:  MOVLW  08
14EF4:  MOVWF  1E
14EF6:  MOVLW  8F
14EF8:  MOVWF  1D
14EFA:  MOVFF  887,8D7
14EFE:  MOVLW  1B
14F00:  MOVLB  8
14F02:  MOVWF  xD8
14F04:  MOVLB  0
14F06:  CALL   52D8
14F0A:  MOVLW  2C
14F0C:  MOVLB  8
14F0E:  MOVWF  xE9
14F10:  MOVLB  0
14F12:  CALL   50F6
14F16:  MOVLW  10
14F18:  MOVWF  FE9
14F1A:  MOVFF  889,8E1
14F1E:  MOVFF  888,8E0
14F22:  CALL   AB36
....................    strcat(data_buffer, config_str); 
14F26:  MOVLB  8
14F28:  CLRF   xE3
14F2A:  MOVLW  63
14F2C:  MOVWF  xE2
14F2E:  MOVLW  08
14F30:  MOVWF  xE5
14F32:  MOVLW  8F
14F34:  MOVWF  xE4
14F36:  MOVLB  0
14F38:  CALL   5536
....................    strcat(data_buffer, endofline); 
14F3C:  MOVLB  8
14F3E:  CLRF   xE3
14F40:  MOVLW  63
14F42:  MOVWF  xE2
14F44:  MOVLW  08
14F46:  MOVWF  xE5
14F48:  MOVLW  8C
14F4A:  MOVWF  xE4
14F4C:  MOVLB  0
14F4E:  CALL   5536
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
14F52:  MOVF   1F,W
14F54:  SUBLW  04
14F56:  BNZ   14F76
14F58:  MOVF   20,F
14F5A:  BNZ   14F76
14F5C:  CLRF   FEA
14F5E:  MOVLW  63
14F60:  MOVWF  FE9
14F62:  CALL   79DC
14F66:  MOVLW  0D
14F68:  BTFSS  F9E.4
14F6A:  BRA    14F68
14F6C:  MOVWF  FAD
14F6E:  MOVLW  0A
14F70:  BTFSS  F9E.4
14F72:  BRA    14F70
14F74:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
14F76:  MOVLB  2
14F78:  MOVF   xD8,F
14F7A:  BNZ   14FCE
....................     
....................       buffer_select = 0; 
14F7C:  MOVLB  0
14F7E:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
14F80:  MOVLB  8
14F82:  CLRF   xD7
14F84:  MOVLB  0
14F86:  CALL   55DA
....................          append_data(file_ptr_raw_all); 
14F8A:  MOVLW  02
14F8C:  MOVLB  8
14F8E:  MOVWF  xD8
14F90:  MOVLW  D9
14F92:  MOVWF  xD7
14F94:  MOVLB  0
14F96:  CALL   8338
....................       heartbeat(TRUE);          
14F9A:  MOVLW  01
14F9C:  MOVLB  8
14F9E:  MOVWF  xD7
14FA0:  MOVLB  0
14FA2:  CALL   55DA
....................        
....................       heartbeat(FALSE); 
14FA6:  MOVLB  8
14FA8:  CLRF   xD7
14FAA:  MOVLB  0
14FAC:  CALL   55DA
....................          append_data(file_ptr_raw_new);    
14FB0:  MOVLW  02
14FB2:  MOVLB  8
14FB4:  MOVWF  xD8
14FB6:  MOVLW  E7
14FB8:  MOVWF  xD7
14FBA:  MOVLB  0
14FBC:  CALL   8338
....................       heartbeat(TRUE); 
14FC0:  MOVLW  01
14FC2:  MOVLB  8
14FC4:  MOVWF  xD7
14FC6:  MOVLB  0
14FC8:  CALL   55DA
14FCC:  MOVLB  2
....................    } 
14FCE:  MOVLB  0
14FD0:  GOTO   1516C (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D0F6:  BSF    F90.7
....................    delay_ms(500); 
0D0F8:  MOVLW  02
0D0FA:  MOVLB  8
0D0FC:  MOVWF  xAC
0D0FE:  MOVLW  FA
0D100:  MOVLB  9
0D102:  MOVWF  xD6
0D104:  MOVLB  0
0D106:  CALL   2972
0D10A:  MOVLB  8
0D10C:  DECFSZ xAC,F
0D10E:  BRA    D0FE
....................    bus_pwr_status=1; 
0D110:  MOVLW  01
0D112:  MOVLB  4
0D114:  MOVWF  xB2
0D116:  MOVLB  0
0D118:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D11A:  BCF    F90.7
....................    delay_ms(100); 
0D11C:  MOVLW  64
0D11E:  MOVLB  9
0D120:  MOVWF  xD6
0D122:  MOVLB  0
0D124:  CALL   2972
....................    bus_pwr_status=0; 
0D128:  MOVLB  4
0D12A:  CLRF   xB2
0D12C:  MOVLB  0
0D12E:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
17B82:  MOVLB  8
17B84:  CLRF   x81
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
17B86:  CLRF   x81
17B88:  MOVF   x81,W
17B8A:  SUBLW  31
17B8C:  BNC   17BA2
....................       string_arg[i] = 0; 
17B8E:  CLRF   03
17B90:  MOVF   x81,W
17B92:  ADDLW  21
17B94:  MOVWF  FE9
17B96:  MOVLW  08
17B98:  ADDWFC 03,W
17B9A:  MOVWF  FEA
17B9C:  CLRF   FEF
17B9E:  INCF   x81,F
17BA0:  BRA    17B88
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
17BA2:  CLRF   x81
17BA4:  MOVF   x81,W
17BA6:  SUBLW  31
17BA8:  BNC   17C22
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
17BAA:  CLRF   03
17BAC:  MOVF   x81,W
17BAE:  ADDLW  21
17BB0:  MOVWF  FE9
17BB2:  MOVLW  08
17BB4:  ADDWFC 03,W
17BB6:  MOVWF  FEA
17BB8:  MOVFF  FEA,885
17BBC:  MOVFF  FE9,884
17BC0:  MOVLB  0
17BC2:  CALL   0E5C
17BC6:  MOVFF  885,FEA
17BCA:  MOVFF  884,FE9
17BCE:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
17BD2:  DECFSZ 48,W
17BD4:  BRA    17BF2
....................       { 
....................          fputc(string_arg[i],COM_A); 
17BD6:  CLRF   03
17BD8:  MOVLB  8
17BDA:  MOVF   x81,W
17BDC:  ADDLW  21
17BDE:  MOVWF  FE9
17BE0:  MOVLW  08
17BE2:  ADDWFC 03,W
17BE4:  MOVWF  FEA
17BE6:  MOVFF  FEF,882
17BEA:  MOVF   x82,W
17BEC:  MOVLB  0
17BEE:  CALL   AEB4
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
17BF2:  CLRF   03
17BF4:  MOVLB  8
17BF6:  MOVF   x81,W
17BF8:  ADDLW  21
17BFA:  MOVWF  FE9
17BFC:  MOVLW  08
17BFE:  ADDWFC 03,W
17C00:  MOVWF  FEA
17C02:  MOVF   FEF,W
17C04:  SUBLW  0D
17C06:  BZ    17C1C
17C08:  CLRF   03
17C0A:  MOVF   x81,W
17C0C:  ADDLW  21
17C0E:  MOVWF  FE9
17C10:  MOVLW  08
17C12:  ADDWFC 03,W
17C14:  MOVWF  FEA
17C16:  MOVF   FEF,W
17C18:  SUBLW  0A
17C1A:  BNZ   17C1E
....................       { 
....................          break; 
17C1C:  BRA    17C22
....................       } 
17C1E:  INCF   x81,F
17C20:  BRA    17BA4
....................    } 
17C22:  MOVLB  0
17C24:  GOTO   17F4C (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
17DCA:  MOVLB  8
17DCC:  CLRF   x81
....................    macro_arg = 0; 
17DCE:  CLRF   x83
17DD0:  CLRF   x82
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
17DD2:  MOVF   x81,W
17DD4:  SUBLW  0D
17DD6:  BZ    17E62
....................       number = fgetc(COM_A); 
17DD8:  MOVLB  0
17DDA:  CALL   0E5C
17DDE:  MOVFF  01,881
....................       if (com_echo == TRUE) 
17DE2:  DECFSZ 48,W
17DE4:  BRA    17DF6
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
17DE6:  MOVLB  8
17DE8:  MOVF   x81,W
17DEA:  SUBLW  0D
17DEC:  BZ    17DF8
17DEE:  MOVF   x81,W
17DF0:  MOVLB  0
17DF2:  CALL   AEB4
17DF6:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
17DF8:  MOVF   x81,W
17DFA:  SUBLW  2F
17DFC:  BC    17E32
17DFE:  MOVF   x81,W
17E00:  SUBLW  39
17E02:  BNC   17E32
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
17E04:  MOVLW  30
17E06:  SUBWF  x81,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
17E08:  MOVFF  883,9F7
17E0C:  MOVFF  882,9F6
17E10:  MOVLB  9
17E12:  CLRF   xF9
17E14:  MOVLW  0A
17E16:  MOVWF  xF8
17E18:  MOVLB  0
17E1A:  CALL   5D14
17E1E:  MOVFF  02,883
17E22:  MOVFF  01,882
....................          macro_arg = macro_arg + number;                // for each number 
17E26:  MOVLB  8
17E28:  MOVF   x81,W
17E2A:  ADDWF  x82,F
17E2C:  MOVLW  00
17E2E:  ADDWFC x83,F
....................       } 
17E30:  BRA    17E60
....................       else if (number == CARRIAGE_RET) 
17E32:  MOVF   x81,W
17E34:  SUBLW  0D
17E36:  BNZ   17E58
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
17E38:  INCFSZ x82,W
17E3A:  BRA    17E42
17E3C:  INCFSZ x83,W
17E3E:  BRA    17E42
17E40:  BRA    17E4E
17E42:  MOVFF  882,01
17E46:  MOVFF  883,02
17E4A:  BRA    17E62
17E4C:  BRA    17E56
....................          else return(65535); 
17E4E:  MOVLW  FF
17E50:  MOVWF  01
17E52:  MOVWF  02
17E54:  BRA    17E62
....................       } 
17E56:  BRA    17E60
....................       else 
....................       { 
....................          return(65535); 
17E58:  MOVLW  FF
17E5A:  MOVWF  01
17E5C:  MOVWF  02
17E5E:  BRA    17E62
....................       } 
17E60:  BRA    17DD2
....................    } 
17E62:  MOVLB  0
17E64:  GOTO   17F76 (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
17912:  MOVF   2F,W
17914:  MOVWF  00
17916:  MOVF   30,W
17918:  MOVWF  03
1791A:  BNZ   17920
1791C:  MOVF   00,F
1791E:  BZ    17946
17920:  MOVF   03,W
17922:  BNZ   1792C
17924:  MOVLW  03
17926:  SUBWF  00,W
17928:  BTFSC  FD8.2
1792A:  BRA    17A04
1792C:  MOVF   03,W
1792E:  BNZ   17938
17930:  MOVLW  01
17932:  SUBWF  00,W
17934:  BTFSC  FD8.2
17936:  BRA    17A04
17938:  MOVF   03,W
1793A:  BNZ   17944
1793C:  MOVLW  02
1793E:  SUBWF  00,W
17940:  BTFSC  FD8.2
17942:  BRA    17A7A
17944:  BRA    17AE8
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
17946:  MOVLB  8
17948:  MOVF   x85,F
1794A:  BNZ   1797A
1794C:  MOVF   x84,W
1794E:  SUBLW  23
17950:  BZ    17974
17952:  MOVF   x84,W
17954:  SUBLW  25
17956:  BZ    17974
17958:  MOVF   x84,W
1795A:  SUBLW  3B
1795C:  BZ    17974
1795E:  MOVF   x84,W
17960:  SUBLW  4D
17962:  BZ    17974
17964:  MOVF   x84,W
17966:  SUBLW  5A
17968:  BZ    17974
1796A:  MOVF   x84,W
1796C:  SUBLW  72
1796E:  BZ    17974
17970:  MOVLW  00
17972:  BRA    17976
17974:  MOVLW  01
17976:  MOVWF  x86
17978:  BRA    17A00
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
1797A:  MOVF   x84,W
1797C:  SUBLW  23
1797E:  BZ    179FC
17980:  MOVF   x84,W
17982:  SUBLW  25
17984:  BZ    179FC
17986:  MOVF   x84,W
17988:  SUBLW  2B
1798A:  BZ    179FC
1798C:  MOVF   x84,W
1798E:  SUBLW  2D
17990:  BZ    179FC
17992:  MOVF   x84,W
17994:  SUBLW  2F
17996:  BZ    179FC
17998:  MOVF   x84,W
1799A:  SUBLW  3B
1799C:  BZ    179FC
1799E:  MOVF   x84,W
179A0:  SUBLW  41
179A2:  BZ    179FC
179A4:  MOVF   x84,W
179A6:  SUBLW  42
179A8:  BC    179B0
179AA:  MOVF   x84,W
179AC:  SUBLW  44
179AE:  BC    179FC
179B0:  MOVF   x84,W
179B2:  SUBLW  45
179B4:  BC    179BC
179B6:  MOVF   x84,W
179B8:  SUBLW  48
179BA:  BC    179FC
179BC:  MOVF   x84,W
179BE:  SUBLW  4A
179C0:  BC    179C8
179C2:  MOVF   x84,W
179C4:  SUBLW  4C
179C6:  BC    179FC
179C8:  MOVF   x84,W
179CA:  SUBLW  4F
179CC:  BC    179D4
179CE:  MOVF   x84,W
179D0:  SUBLW  55
179D2:  BC    179FC
179D4:  MOVF   x84,W
179D6:  SUBLW  59
179D8:  BZ    179FC
179DA:  MOVF   x84,W
179DC:  SUBLW  64
179DE:  BZ    179FC
179E0:  MOVF   x84,W
179E2:  SUBLW  69
179E4:  BZ    179FC
179E6:  MOVF   x84,W
179E8:  SUBLW  6C
179EA:  BZ    179FC
179EC:  MOVF   x84,W
179EE:  SUBLW  70
179F0:  BZ    179FC
179F2:  MOVF   x84,W
179F4:  SUBLW  72
179F6:  BZ    179FC
179F8:  MOVLW  00
179FA:  BRA    179FE
179FC:  MOVLW  01
179FE:  MOVWF  x86
....................          break; 
17A00:  MOVLB  0
17A02:  BRA    17AE8
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
17A04:  MOVLB  8
17A06:  MOVF   x85,F
17A08:  BNZ   17A32
17A0A:  MOVF   x84,W
17A0C:  SUBLW  23
17A0E:  BZ    17A2C
17A10:  MOVF   x84,W
17A12:  SUBLW  3B
17A14:  BZ    17A2C
17A16:  MOVF   x84,W
17A18:  SUBLW  4A
17A1A:  BZ    17A2C
17A1C:  MOVF   x84,W
17A1E:  SUBLW  4D
17A20:  BZ    17A2C
17A22:  MOVF   x84,W
17A24:  SUBLW  50
17A26:  BZ    17A2C
17A28:  MOVLW  00
17A2A:  BRA    17A2E
17A2C:  MOVLW  01
17A2E:  MOVWF  x86
17A30:  BRA    17A76
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
17A32:  MOVF   x84,W
17A34:  SUBLW  23
17A36:  BZ    17A72
17A38:  MOVF   x84,W
17A3A:  SUBLW  2B
17A3C:  BZ    17A72
17A3E:  MOVF   x84,W
17A40:  SUBLW  2D
17A42:  BZ    17A72
17A44:  MOVF   x84,W
17A46:  SUBLW  3B
17A48:  BZ    17A72
17A4A:  MOVF   x84,W
17A4C:  SUBLW  42
17A4E:  BZ    17A72
17A50:  MOVF   x84,W
17A52:  SUBLW  47
17A54:  BZ    17A72
17A56:  MOVF   x84,W
17A58:  SUBLW  4F
17A5A:  BC    17A62
17A5C:  MOVF   x84,W
17A5E:  SUBLW  52
17A60:  BC    17A72
17A62:  MOVF   x84,W
17A64:  SUBLW  54
17A66:  BZ    17A72
17A68:  MOVF   x84,W
17A6A:  SUBLW  59
17A6C:  BZ    17A72
17A6E:  MOVLW  00
17A70:  BRA    17A74
17A72:  MOVLW  01
17A74:  MOVWF  x86
....................          break;   
17A76:  MOVLB  0
17A78:  BRA    17AE8
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17A7A:  MOVLB  8
17A7C:  MOVF   x85,F
17A7E:  BNZ   17AA2
17A80:  MOVF   x84,W
17A82:  SUBLW  23
17A84:  BZ    17A9C
17A86:  MOVF   x84,W
17A88:  SUBLW  3B
17A8A:  BZ    17A9C
17A8C:  MOVF   x84,W
17A8E:  SUBLW  4D
17A90:  BZ    17A9C
17A92:  MOVF   x84,W
17A94:  SUBLW  50
17A96:  BZ    17A9C
17A98:  MOVLW  00
17A9A:  BRA    17A9E
17A9C:  MOVLW  01
17A9E:  MOVWF  x86
17AA0:  BRA    17AE6
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
17AA2:  MOVF   x84,W
17AA4:  SUBLW  23
17AA6:  BZ    17AE2
17AA8:  MOVF   x84,W
17AAA:  SUBLW  2B
17AAC:  BZ    17AE2
17AAE:  MOVF   x84,W
17AB0:  SUBLW  2D
17AB2:  BZ    17AE2
17AB4:  MOVF   x84,W
17AB6:  SUBLW  3B
17AB8:  BZ    17AE2
17ABA:  MOVF   x84,W
17ABC:  SUBLW  42
17ABE:  BC    17AC6
17AC0:  MOVF   x84,W
17AC2:  SUBLW  44
17AC4:  BC    17AE2
17AC6:  MOVF   x84,W
17AC8:  SUBLW  4F
17ACA:  BC    17AD2
17ACC:  MOVF   x84,W
17ACE:  SUBLW  51
17AD0:  BC    17AE2
17AD2:  MOVF   x84,W
17AD4:  SUBLW  53
17AD6:  BZ    17AE2
17AD8:  MOVF   x84,W
17ADA:  SUBLW  59
17ADC:  BZ    17AE2
17ADE:  MOVLW  00
17AE0:  BRA    17AE4
17AE2:  MOVLW  01
17AE4:  MOVWF  x86
....................          break;   
17AE6:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17AE8:  MOVLB  8
17AEA:  MOVFF  886,01
17AEE:  MOVLB  0
17AF0:  GOTO   17B1C (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17AF4:  MOVLW  01
17AF6:  MOVLB  8
17AF8:  MOVWF  x83
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17AFA:  MOVLB  0
17AFC:  CALL   0E5C
17B00:  MOVFF  01,882
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17B04:  DECFSZ 48,W
17B06:  BRA    17B12
17B08:  MOVLB  8
17B0A:  MOVF   x82,W
17B0C:  MOVLB  0
17B0E:  CALL   AEB4
....................          valid_macro = check_macro(e, macro); 
17B12:  MOVFF  882,884
17B16:  MOVFF  881,885
17B1A:  BRA    17912
17B1C:  MOVFF  01,883
....................       if (valid_macro == TRUE) { 
17B20:  MOVLB  8
17B22:  DECFSZ x83,W
17B24:  BRA    17B2E
....................          return(e); 
17B26:  MOVFF  882,01
17B2A:  BRA    17B3A
....................       } 
17B2C:  BRA    17B34
....................       else return(0); 
17B2E:  MOVLW  00
17B30:  MOVWF  01
17B32:  BRA    17B3A
....................    } while (valid_macro == TRUE); 
17B34:  DECFSZ x83,W
17B36:  BRA    17B3A
17B38:  BRA    17AFA
17B3A:  MOVLB  0
17B3C:  GOTO   17F2E (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
17EB4:  BCF    FD8.0
17EB6:  MOVLB  8
17EB8:  RLCF   x84,W
17EBA:  CLRF   03
17EBC:  ADDLW  CD
17EBE:  MOVWF  FE9
17EC0:  MOVLW  07
17EC2:  ADDWFC 03,W
17EC4:  MOVWF  FEA
17EC6:  MOVFF  FEC,88A
17ECA:  MOVF   FED,F
17ECC:  MOVFF  FEF,889
17ED0:  MOVFF  886,9F7
17ED4:  MOVFF  885,9F6
17ED8:  MOVLB  9
17EDA:  CLRF   xF9
17EDC:  MOVLW  03
17EDE:  MOVWF  xF8
17EE0:  MOVLB  0
17EE2:  CALL   5D14
17EE6:  MOVF   01,W
17EE8:  MOVLB  8
17EEA:  ADDWF  x89,W
17EEC:  MOVWF  x87
17EEE:  MOVF   02,W
17EF0:  ADDWFC x8A,W
17EF2:  MOVWF  x88
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
17EF4:  MOVFF  888,892
17EF8:  MOVFF  887,891
17EFC:  MOVFF  881,893
17F00:  MOVLB  0
17F02:  RCALL  17C28
....................     
....................    ++addr; 
17F04:  MOVLB  8
17F06:  INCF   x87,F
17F08:  BTFSC  FD8.2
17F0A:  INCF   x88,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
17F0C:  MOVFF  888,88A
17F10:  MOVFF  887,889
17F14:  MOVFF  883,88C
17F18:  MOVFF  882,88B
17F1C:  MOVLB  0
17F1E:  BRA    17E68
17F20:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
17C88:  BCF    FD8.0
17C8A:  MOVLB  8
17C8C:  RLCF   x82,W
17C8E:  CLRF   03
17C90:  ADDLW  CD
17C92:  MOVWF  FE9
17C94:  MOVLW  07
17C96:  ADDWFC 03,W
17C98:  MOVWF  FEA
17C9A:  MOVFF  FEC,88B
17C9E:  MOVF   FED,F
17CA0:  MOVFF  FEF,88A
17CA4:  MOVFF  884,9F7
17CA8:  MOVFF  883,9F6
17CAC:  MOVLB  9
17CAE:  CLRF   xF9
17CB0:  MOVLW  03
17CB2:  MOVWF  xF8
17CB4:  MOVLB  0
17CB6:  CALL   5D14
17CBA:  MOVF   01,W
17CBC:  MOVLB  8
17CBE:  ADDWF  x8A,W
17CC0:  MOVWF  x87
17CC2:  MOVF   02,W
17CC4:  ADDWFC x8B,W
17CC6:  MOVWF  x88
....................    write_ext_eeprom(addr, macro_cmd); 
17CC8:  MOVFF  888,892
17CCC:  MOVFF  887,891
17CD0:  MOVFF  881,893
17CD4:  MOVLB  0
17CD6:  RCALL  17C28
....................     
....................    int i = 0; 
17CD8:  MOVLB  8
17CDA:  CLRF   x89
....................    addr = string_address[macro] + (count*50); 
17CDC:  BCF    FD8.0
17CDE:  RLCF   x82,W
17CE0:  CLRF   03
17CE2:  ADDLW  F7
17CE4:  MOVWF  FE9
17CE6:  MOVLW  07
17CE8:  ADDWFC 03,W
17CEA:  MOVWF  FEA
17CEC:  MOVFF  FEC,88B
17CF0:  MOVF   FED,F
17CF2:  MOVFF  FEF,88A
17CF6:  MOVFF  886,9F7
17CFA:  MOVFF  885,9F6
17CFE:  MOVLB  9
17D00:  CLRF   xF9
17D02:  MOVLW  32
17D04:  MOVWF  xF8
17D06:  MOVLB  0
17D08:  CALL   5D14
17D0C:  MOVF   01,W
17D0E:  MOVLB  8
17D10:  ADDWF  x8A,W
17D12:  MOVWF  x87
17D14:  MOVF   02,W
17D16:  ADDWFC x8B,W
17D18:  MOVWF  x88
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
17D1A:  MOVF   x86,F
17D1C:  BNZ   17D72
17D1E:  MOVF   x85,W
17D20:  SUBLW  14
17D22:  BNC   17D72
....................       for(i = 0; i<50; i++) { 
17D24:  CLRF   x89
17D26:  MOVF   x89,W
17D28:  SUBLW  31
17D2A:  BNC   17D70
....................          write_ext_eeprom(addr + i, string_arg[i]); 
17D2C:  MOVF   x89,W
17D2E:  ADDWF  x87,W
17D30:  MOVWF  x8A
17D32:  MOVLW  00
17D34:  ADDWFC x88,W
17D36:  MOVWF  x8B
17D38:  CLRF   03
17D3A:  MOVF   x89,W
17D3C:  ADDLW  21
17D3E:  MOVWF  FE9
17D40:  MOVLW  08
17D42:  ADDWFC 03,W
17D44:  MOVWF  FEA
17D46:  MOVFF  FEF,893
17D4A:  MOVFF  88B,892
17D4E:  MOVFF  88A,891
17D52:  MOVLB  0
17D54:  RCALL  17C28
....................          if(string_arg[i] == 0){ 
17D56:  CLRF   03
17D58:  MOVLB  8
17D5A:  MOVF   x89,W
17D5C:  ADDLW  21
17D5E:  MOVWF  FE9
17D60:  MOVLW  08
17D62:  ADDWFC 03,W
17D64:  MOVWF  FEA
17D66:  MOVF   FEF,F
17D68:  BNZ   17D6C
....................             break; 
17D6A:  BRA    17D70
....................          } 
17D6C:  INCF   x89,F
17D6E:  BRA    17D26
....................       
....................       } 
....................    }else{ 
17D70:  BRA    17DC4
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
17D72:  MOVLW  CC
17D74:  MOVWF  FF6
17D76:  MOVLW  20
17D78:  MOVWF  FF7
17D7A:  MOVLW  00
17D7C:  MOVWF  FF8
17D7E:  CLRF   1B
17D80:  BTFSC  FF2.7
17D82:  BSF    1B.7
17D84:  BCF    FF2.7
17D86:  MOVLW  1E
17D88:  MOVLB  A
17D8A:  MOVWF  x25
17D8C:  MOVLB  0
17D8E:  CALL   101E
17D92:  BTFSC  1B.7
17D94:  BSF    FF2.7
17D96:  MOVLW  10
17D98:  MOVWF  FE9
17D9A:  CLRF   1B
17D9C:  BTFSC  FF2.7
17D9E:  BSF    1B.7
17DA0:  BCF    FF2.7
17DA2:  MOVFF  884,A26
17DA6:  MOVFF  883,A25
17DAA:  CALL   11A0
17DAE:  BTFSC  1B.7
17DB0:  BSF    FF2.7
17DB2:  MOVLW  0A
17DB4:  BTFSS  F9E.4
17DB6:  BRA    17DB4
17DB8:  MOVWF  FAD
17DBA:  MOVLW  0D
17DBC:  BTFSS  F9E.4
17DBE:  BRA    17DBC
17DC0:  MOVWF  FAD
17DC2:  MOVLB  8
....................    } 
17DC4:  MOVLB  0
17DC6:  GOTO   17F66 (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
18106:  CALL   FFE8
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
1810A:  MOVLW  3B
1810C:  MOVLB  8
1810E:  MOVWF  x81
18110:  CLRF   x83
18112:  CLRF   x82
18114:  CLRF   x84
18116:  CLRF   x86
18118:  CLRF   x85
1811A:  MOVLB  0
1811C:  RCALL  17EB4
....................     
....................    write_macro_line(59, 0, 1, 0); 
1811E:  MOVLW  3B
18120:  MOVLB  8
18122:  MOVWF  x81
18124:  CLRF   x83
18126:  CLRF   x82
18128:  MOVLW  01
1812A:  MOVWF  x84
1812C:  CLRF   x86
1812E:  CLRF   x85
18130:  MOVLB  0
18132:  RCALL  17EB4
....................    write_macro_line(59, 0, 2, 0); 
18134:  MOVLW  3B
18136:  MOVLB  8
18138:  MOVWF  x81
1813A:  CLRF   x83
1813C:  CLRF   x82
1813E:  MOVLW  02
18140:  MOVWF  x84
18142:  CLRF   x86
18144:  CLRF   x85
18146:  MOVLB  0
18148:  RCALL  17EB4
....................    write_macro_line(59, 0, 3, 0); 
1814A:  MOVLW  3B
1814C:  MOVLB  8
1814E:  MOVWF  x81
18150:  CLRF   x83
18152:  CLRF   x82
18154:  MOVLW  03
18156:  MOVWF  x84
18158:  CLRF   x86
1815A:  CLRF   x85
1815C:  MOVLB  0
1815E:  RCALL  17EB4
....................    write_macro_line(59, 0, 4, 0); 
18160:  MOVLW  3B
18162:  MOVLB  8
18164:  MOVWF  x81
18166:  CLRF   x83
18168:  CLRF   x82
1816A:  MOVLW  04
1816C:  MOVWF  x84
1816E:  CLRF   x86
18170:  CLRF   x85
18172:  MOVLB  0
18174:  RCALL  17EB4
....................    write_macro_line(59, 0, 5, 0); 
18176:  MOVLW  3B
18178:  MOVLB  8
1817A:  MOVWF  x81
1817C:  CLRF   x83
1817E:  CLRF   x82
18180:  MOVLW  05
18182:  MOVWF  x84
18184:  CLRF   x86
18186:  CLRF   x85
18188:  MOVLB  0
1818A:  RCALL  17EB4
....................    write_macro_line(59, 0, 6, 0); 
1818C:  MOVLW  3B
1818E:  MOVLB  8
18190:  MOVWF  x81
18192:  CLRF   x83
18194:  CLRF   x82
18196:  MOVLW  06
18198:  MOVWF  x84
1819A:  CLRF   x86
1819C:  CLRF   x85
1819E:  MOVLB  0
181A0:  RCALL  17EB4
....................    write_macro_line(59, 0, 7, 0); 
181A2:  MOVLW  3B
181A4:  MOVLB  8
181A6:  MOVWF  x81
181A8:  CLRF   x83
181AA:  CLRF   x82
181AC:  MOVLW  07
181AE:  MOVWF  x84
181B0:  CLRF   x86
181B2:  CLRF   x85
181B4:  MOVLB  0
181B6:  RCALL  17EB4
....................    write_macro_line(59, 0, 8, 0); 
181B8:  MOVLW  3B
181BA:  MOVLB  8
181BC:  MOVWF  x81
181BE:  CLRF   x83
181C0:  CLRF   x82
181C2:  MOVLW  08
181C4:  MOVWF  x84
181C6:  CLRF   x86
181C8:  CLRF   x85
181CA:  MOVLB  0
181CC:  RCALL  17EB4
....................     
....................    write_macro_line(59, 0, 9, 0); 
181CE:  MOVLW  3B
181D0:  MOVLB  8
181D2:  MOVWF  x81
181D4:  CLRF   x83
181D6:  CLRF   x82
181D8:  MOVLW  09
181DA:  MOVWF  x84
181DC:  CLRF   x86
181DE:  CLRF   x85
181E0:  MOVLB  0
181E2:  RCALL  17EB4
....................    write_macro_line(59, 0, 10, 0); 
181E4:  MOVLW  3B
181E6:  MOVLB  8
181E8:  MOVWF  x81
181EA:  CLRF   x83
181EC:  CLRF   x82
181EE:  MOVLW  0A
181F0:  MOVWF  x84
181F2:  CLRF   x86
181F4:  CLRF   x85
181F6:  MOVLB  0
181F8:  RCALL  17EB4
....................    write_macro_line(59, 0, 11, 0); 
181FA:  MOVLW  3B
181FC:  MOVLB  8
181FE:  MOVWF  x81
18200:  CLRF   x83
18202:  CLRF   x82
18204:  MOVLW  0B
18206:  MOVWF  x84
18208:  CLRF   x86
1820A:  CLRF   x85
1820C:  MOVLB  0
1820E:  RCALL  17EB4
....................    write_macro_line(59, 0, 12, 0); 
18210:  MOVLW  3B
18212:  MOVLB  8
18214:  MOVWF  x81
18216:  CLRF   x83
18218:  CLRF   x82
1821A:  MOVLW  0C
1821C:  MOVWF  x84
1821E:  CLRF   x86
18220:  CLRF   x85
18222:  MOVLB  0
18224:  RCALL  17EB4
....................    write_macro_line(59, 0, 13, 0); 
18226:  MOVLW  3B
18228:  MOVLB  8
1822A:  MOVWF  x81
1822C:  CLRF   x83
1822E:  CLRF   x82
18230:  MOVLW  0D
18232:  MOVWF  x84
18234:  CLRF   x86
18236:  CLRF   x85
18238:  MOVLB  0
1823A:  RCALL  17EB4
....................    write_macro_line(59, 0, 14, 0); 
1823C:  MOVLW  3B
1823E:  MOVLB  8
18240:  MOVWF  x81
18242:  CLRF   x83
18244:  CLRF   x82
18246:  MOVLW  0E
18248:  MOVWF  x84
1824A:  CLRF   x86
1824C:  CLRF   x85
1824E:  MOVLB  0
18250:  RCALL  17EB4
....................    write_macro_line(59, 0, 15, 0); 
18252:  MOVLW  3B
18254:  MOVLB  8
18256:  MOVWF  x81
18258:  CLRF   x83
1825A:  CLRF   x82
1825C:  MOVLW  0F
1825E:  MOVWF  x84
18260:  CLRF   x86
18262:  CLRF   x85
18264:  MOVLB  0
18266:  RCALL  17EB4
....................    write_macro_line(59, 0, 16, 0); 
18268:  MOVLW  3B
1826A:  MOVLB  8
1826C:  MOVWF  x81
1826E:  CLRF   x83
18270:  CLRF   x82
18272:  MOVLW  10
18274:  MOVWF  x84
18276:  CLRF   x86
18278:  CLRF   x85
1827A:  MOVLB  0
1827C:  RCALL  17EB4
1827E:  GOTO   182B6 (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
17B40:  MOVLB  8
17B42:  CLRF   x81
....................     
....................    heartbeat(FALSE); 
17B44:  CLRF   xD7
17B46:  MOVLB  0
17B48:  CALL   55DA
....................     
....................    while(mcc != CARRIAGE_RET){ 
17B4C:  MOVLB  8
17B4E:  MOVF   x81,W
17B50:  SUBLW  0D
17B52:  BZ    17B74
....................       if (kbhit(COM_A)) { 
17B54:  BTFSS  F9E.5
17B56:  BRA    17B72
....................          mcc=fgetc(COM_A); 
17B58:  MOVLB  0
17B5A:  CALL   0E5C
17B5E:  MOVFF  01,881
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
17B62:  DECFSZ 48,W
17B64:  BRA    17B70
17B66:  MOVLB  8
17B68:  MOVF   x81,W
17B6A:  MOVLB  0
17B6C:  CALL   AEB4
17B70:  MOVLB  8
....................       } 
17B72:  BRA    17B4E
....................    } 
....................     
....................    heartbeat(TRUE); 
17B74:  MOVLW  01
17B76:  MOVWF  xD7
17B78:  MOVLB  0
17B7A:  CALL   55DA
17B7E:  GOTO   17F3E (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
17F22:  MOVLB  8
17F24:  CLRF   x80
....................     
....................    macro_cmd = get_cmd(macro); 
17F26:  MOVFF  878,881
17F2A:  MOVLB  0
17F2C:  BRA    17AF4
17F2E:  MOVFF  01,87D
....................    if (macro_cmd == 35){  
17F32:  MOVLB  8
17F34:  MOVF   x7D,W
17F36:  SUBLW  23
17F38:  BNZ   17F42
....................       macro_comment();        // # = 35 
17F3A:  MOVLB  0
17F3C:  BRA    17B40
....................    }else if(macro_cmd == 112){// 112 is p 
17F3E:  BRA    17FC4
17F40:  MOVLB  8
17F42:  MOVF   x7D,W
17F44:  SUBLW  70
17F46:  BNZ   17F6E
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
17F48:  MOVLB  0
17F4A:  BRA    17B82
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
17F4C:  MOVFF  87D,881
17F50:  MOVFF  878,882
17F54:  MOVFF  87A,884
17F58:  MOVFF  879,883
17F5C:  MOVFF  87C,886
17F60:  MOVFF  87B,885
17F64:  BRA    17C88
....................       valid_macro = TRUE; 
17F66:  MOVLW  01
17F68:  MOVLB  8
17F6A:  MOVWF  x80
....................    }else{ 
17F6C:  BRA    17FC2
....................       if (macro_cmd != 0) { 
17F6E:  MOVF   x7D,F
17F70:  BZ    17F98
....................          macro_arg = get_arg(); 
17F72:  MOVLB  0
17F74:  BRA    17DCA
17F76:  MOVFF  02,87F
17F7A:  MOVFF  01,87E
....................          if (macro_arg != 65535) valid_macro = TRUE; 
17F7E:  MOVLB  8
17F80:  INCFSZ x7E,W
17F82:  BRA    17F8A
17F84:  INCFSZ x7F,W
17F86:  BRA    17F8A
17F88:  BRA    17F90
17F8A:  MOVLW  01
17F8C:  MOVWF  x80
17F8E:  BRA    17F96
....................          else return(macro_cmd); 
17F90:  MOVFF  87D,01
17F94:  BRA    17FCA
....................       }else return(macro_cmd); 
17F96:  BRA    17F9E
17F98:  MOVFF  87D,01
17F9C:  BRA    17FCA
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
17F9E:  MOVFF  87D,881
17FA2:  MOVFF  87F,883
17FA6:  MOVFF  87E,882
17FAA:  MOVFF  878,884
17FAE:  MOVFF  87A,886
17FB2:  MOVFF  879,885
17FB6:  MOVLB  0
17FB8:  RCALL  17EB4
....................       return(macro_cmd); 
17FBA:  MOVLB  8
17FBC:  MOVFF  87D,01
17FC0:  BRA    17FCA
17FC2:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
17FC4:  MOVLB  8
17FC6:  MOVFF  87D,01
17FCA:  MOVLB  0
17FCC:  GOTO   18012 (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
17FD0:  MOVLB  8
17FD2:  CLRF   x77
17FD4:  CLRF   x76
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
17FD6:  CLRF   x72
17FD8:  CLRF   x71
....................    valid_macro = TRUE; 
17FDA:  MOVLW  01
17FDC:  MOVWF  x73
....................    macro_cmd = 1; 
17FDE:  MOVWF  x74
....................     
....................    init_ext_eeprom(); 
17FE0:  MOVLB  0
17FE2:  CALL   FFE8
....................     
....................    fprintf(COM_A, ":"); 
17FE6:  MOVLW  3A
17FE8:  BTFSS  F9E.4
17FEA:  BRA    17FE8
17FEC:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
17FEE:  MOVLB  8
17FF0:  MOVF   x74,W
17FF2:  SUBLW  3B
17FF4:  BZ    18058
17FF6:  MOVF   x74,F
17FF8:  BZ    18058
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
17FFA:  MOVFF  870,878
17FFE:  MOVFF  872,87A
18002:  MOVFF  871,879
18006:  MOVFF  877,87C
1800A:  MOVFF  876,87B
1800E:  MOVLB  0
18010:  BRA    17F22
18012:  MOVFF  01,874
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
18016:  MOVLB  8
18018:  MOVF   x74,W
1801A:  SUBLW  70
1801C:  BNZ   18024
....................          count++; 
1801E:  INCF   x76,F
18020:  BTFSC  FD8.2
18022:  INCF   x77,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
18024:  MOVF   x74,W
18026:  SUBLW  23
18028:  BZ    18030
1802A:  INCF   x71,F
1802C:  BTFSC  FD8.2
1802E:  INCF   x72,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
18030:  MOVF   x74,W
18032:  SUBLW  3B
18034:  BZ    18056
18036:  MOVLW  F0
18038:  MOVWF  FF6
1803A:  MOVLW  20
1803C:  MOVWF  FF7
1803E:  MOVLW  00
18040:  MOVWF  FF8
18042:  CLRF   1B
18044:  BTFSC  FF2.7
18046:  BSF    1B.7
18048:  BCF    FF2.7
1804A:  MOVLB  0
1804C:  CALL   0DCC
18050:  BTFSC  1B.7
18052:  BSF    FF2.7
18054:  MOVLB  8
18056:  BRA    17FF0
....................    }       
....................    if (macro_cmd == 0){ 
18058:  MOVF   x74,F
1805A:  BNZ   180F0
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
1805C:  MOVLW  F4
1805E:  MOVWF  FF6
18060:  MOVLW  20
18062:  MOVWF  FF7
18064:  MOVLW  00
18066:  MOVWF  FF8
18068:  CLRF   1B
1806A:  BTFSC  FF2.7
1806C:  BSF    1B.7
1806E:  BCF    FF2.7
18070:  MOVLB  0
18072:  CALL   0DCC
18076:  BTFSC  1B.7
18078:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
1807A:  MOVLW  1C
1807C:  MOVWF  FF6
1807E:  MOVLW  21
18080:  MOVWF  FF7
18082:  MOVLW  00
18084:  MOVWF  FF8
18086:  CLRF   1B
18088:  BTFSC  FF2.7
1808A:  BSF    1B.7
1808C:  BCF    FF2.7
1808E:  MOVLW  15
18090:  MOVLB  A
18092:  MOVWF  x25
18094:  MOVLB  0
18096:  CALL   101E
1809A:  BTFSC  1B.7
1809C:  BSF    FF2.7
1809E:  MOVLW  10
180A0:  MOVWF  FE9
180A2:  MOVFF  872,8DB
180A6:  MOVFF  871,8DA
180AA:  CALL   9024
180AE:  MOVLW  34
180B0:  MOVWF  FF6
180B2:  MOVLW  21
180B4:  MOVWF  FF7
180B6:  MOVLW  00
180B8:  MOVWF  FF8
180BA:  CLRF   1B
180BC:  BTFSC  FF2.7
180BE:  BSF    1B.7
180C0:  BCF    FF2.7
180C2:  MOVLW  03
180C4:  MOVLB  A
180C6:  MOVWF  x25
180C8:  MOVLB  0
180CA:  CALL   101E
180CE:  BTFSC  1B.7
180D0:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
180D2:  MOVLW  38
180D4:  MOVWF  FF6
180D6:  MOVLW  21
180D8:  MOVWF  FF7
180DA:  MOVLW  00
180DC:  MOVWF  FF8
180DE:  CLRF   1B
180E0:  BTFSC  FF2.7
180E2:  BSF    1B.7
180E4:  BCF    FF2.7
180E6:  CALL   0DCC
180EA:  BTFSC  1B.7
180EC:  BSF    FF2.7
180EE:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
180F0:  MOVLW  0D
180F2:  BTFSS  F9E.4
180F4:  BRA    180F2
180F6:  MOVWF  FAD
180F8:  MOVLW  0A
180FA:  BTFSS  F9E.4
180FC:  BRA    180FA
180FE:  MOVWF  FAD
18100:  MOVLB  0
18102:  GOTO   1829E (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
182C0:  BCF    FD8.0
182C2:  MOVLB  8
182C4:  RLCF   x75,W
182C6:  CLRF   03
182C8:  ADDLW  CD
182CA:  MOVWF  FE9
182CC:  MOVLW  07
182CE:  ADDWFC 03,W
182D0:  MOVWF  FEA
182D2:  MOVFF  FEC,87E
182D6:  MOVF   FED,F
182D8:  MOVFF  FEF,87D
182DC:  MOVFF  877,9F7
182E0:  MOVFF  876,9F6
182E4:  MOVLB  9
182E6:  CLRF   xF9
182E8:  MOVLW  03
182EA:  MOVWF  xF8
182EC:  MOVLB  0
182EE:  CALL   5D14
182F2:  MOVF   01,W
182F4:  MOVLB  8
182F6:  ADDWF  x7D,W
182F8:  MOVWF  x78
182FA:  MOVF   02,W
182FC:  ADDWFC x7E,W
182FE:  MOVWF  x79
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
18300:  MOVFF  879,8B6
18304:  MOVFF  878,8B5
18308:  MOVLB  0
1830A:  CALL   1037C
1830E:  MOVFF  01,87A
....................    ++addr; 
18312:  MOVLB  8
18314:  INCF   x78,F
18316:  BTFSC  FD8.2
18318:  INCF   x79,F
....................    macro_arg = read16_ext_eeprom(addr); 
1831A:  MOVFF  879,8AD
1831E:  MOVFF  878,8AC
18322:  MOVLB  0
18324:  CALL   10490
18328:  MOVFF  02,87C
1832C:  MOVFF  01,87B
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
18330:  MOVLB  8
18332:  MOVF   x7A,W
18334:  BTFSS  F9E.4
18336:  BRA    18334
18338:  MOVWF  FAD
1833A:  MOVLW  10
1833C:  MOVWF  FE9
1833E:  CLRF   1B
18340:  BTFSC  FF2.7
18342:  BSF    1B.7
18344:  BCF    FF2.7
18346:  MOVFF  87C,A26
1834A:  MOVFF  87B,A25
1834E:  MOVLB  0
18350:  CALL   11A0
18354:  BTFSC  1B.7
18356:  BSF    FF2.7
18358:  MOVLW  0D
1835A:  BTFSS  F9E.4
1835C:  BRA    1835A
1835E:  MOVWF  FAD
18360:  MOVLW  0A
18362:  BTFSS  F9E.4
18364:  BRA    18362
18366:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
18368:  MOVLB  8
1836A:  MOVFF  87A,01
1836E:  MOVLB  0
18370:  GOTO   183A4 (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
13F7A:  BCF    FD8.0
13F7C:  MOVLB  8
13F7E:  RLCF   xA1,W
13F80:  CLRF   03
13F82:  ADDLW  CD
13F84:  MOVWF  FE9
13F86:  MOVLW  07
13F88:  ADDWFC 03,W
13F8A:  MOVWF  FEA
13F8C:  MOVFF  FEC,8AA
13F90:  MOVF   FED,F
13F92:  MOVFF  FEF,8A9
13F96:  MOVFF  8A3,9F7
13F9A:  MOVFF  8A2,9F6
13F9E:  MOVLB  9
13FA0:  CLRF   xF9
13FA2:  MOVLW  03
13FA4:  MOVWF  xF8
13FA6:  MOVLB  0
13FA8:  CALL   5D14
13FAC:  MOVF   01,W
13FAE:  MOVLB  8
13FB0:  ADDWF  xA9,W
13FB2:  MOVWF  xA4
13FB4:  MOVF   02,W
13FB6:  ADDWFC xAA,W
13FB8:  MOVWF  xA5
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
13FBA:  MOVFF  8A5,8B6
13FBE:  MOVFF  8A4,8B5
13FC2:  MOVLB  0
13FC4:  CALL   1037C
13FC8:  MOVFF  01,8A6
....................    ++addr; 
13FCC:  MOVLB  8
13FCE:  INCF   xA4,F
13FD0:  BTFSC  FD8.2
13FD2:  INCF   xA5,F
....................    macro_arg = read16_ext_eeprom(addr); 
13FD4:  MOVFF  8A5,8AD
13FD8:  MOVFF  8A4,8AC
13FDC:  MOVLB  0
13FDE:  CALL   10490
13FE2:  MOVFF  02,8A8
13FE6:  MOVFF  01,8A7
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
13FEA:  MOVLB  8
13FEC:  MOVF   xA6,W
13FEE:  BTFSS  F9E.4
13FF0:  BRA    13FEE
13FF2:  MOVWF  FAD
13FF4:  MOVLW  10
13FF6:  MOVWF  FE9
13FF8:  CLRF   1B
13FFA:  BTFSC  FF2.7
13FFC:  BSF    1B.7
13FFE:  BCF    FF2.7
14000:  MOVFF  8A8,A26
14004:  MOVFF  8A7,A25
14008:  MOVLB  0
1400A:  CALL   11A0
1400E:  BTFSC  1B.7
14010:  BSF    FF2.7
14012:  MOVLW  0D
14014:  BTFSS  F9E.4
14016:  BRA    14014
14018:  MOVWF  FAD
1401A:  MOVLW  0A
1401C:  BTFSS  F9E.4
1401E:  BRA    1401C
14020:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
14022:  MOVLB  8
14024:  MOVFF  8A6,01
14028:  MOVLB  0
1402A:  GOTO   14802 (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
103D6:  BCF    FD8.0
103D8:  MOVLB  8
103DA:  RLCF   x9F,W
103DC:  CLRF   03
103DE:  ADDLW  F7
103E0:  MOVWF  FE9
103E2:  MOVLW  07
103E4:  ADDWFC 03,W
103E6:  MOVWF  FEA
103E8:  MOVFF  FEC,8A8
103EC:  MOVF   FED,F
103EE:  MOVFF  FEF,8A7
103F2:  MOVFF  8A3,9F7
103F6:  MOVFF  8A2,9F6
103FA:  MOVLB  9
103FC:  CLRF   xF9
103FE:  MOVLW  32
10400:  MOVWF  xF8
10402:  MOVLB  0
10404:  CALL   5D14
10408:  MOVF   01,W
1040A:  MOVLB  8
1040C:  ADDWF  xA7,W
1040E:  MOVWF  xA4
10410:  MOVF   02,W
10412:  ADDWFC xA8,W
10414:  MOVWF  xA5
....................     
....................    int i = 0; 
10416:  CLRF   xA6
....................    for(i = 0; i < 50; i++){ 
10418:  CLRF   xA6
1041A:  MOVF   xA6,W
1041C:  SUBLW  31
1041E:  BNC   10434
....................       string_arg[i] = 0; 
10420:  CLRF   03
10422:  MOVF   xA6,W
10424:  ADDLW  21
10426:  MOVWF  FE9
10428:  MOVLW  08
1042A:  ADDWFC 03,W
1042C:  MOVWF  FEA
1042E:  CLRF   FEF
10430:  INCF   xA6,F
10432:  BRA    1041A
....................    }  
....................    for(i = 0; i < 50; i++){ 
10434:  CLRF   xA6
10436:  MOVF   xA6,W
10438:  SUBLW  31
1043A:  BNC   1048C
....................       string_arg[i] = read_ext_eeprom(addr + i); 
1043C:  CLRF   03
1043E:  MOVF   xA6,W
10440:  ADDLW  21
10442:  MOVWF  01
10444:  MOVLW  08
10446:  ADDWFC 03,F
10448:  MOVFF  01,8A7
1044C:  MOVFF  03,8A8
10450:  MOVF   xA6,W
10452:  ADDWF  xA4,W
10454:  MOVWF  xA9
10456:  MOVLW  00
10458:  ADDWFC xA5,W
1045A:  MOVWF  xAA
1045C:  MOVWF  xB6
1045E:  MOVFF  8A9,8B5
10462:  MOVLB  0
10464:  RCALL  1037C
10466:  MOVFF  8A8,FEA
1046A:  MOVFF  8A7,FE9
1046E:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
10472:  CLRF   03
10474:  MOVLB  8
10476:  MOVF   xA6,W
10478:  ADDLW  21
1047A:  MOVWF  FE9
1047C:  MOVLW  08
1047E:  ADDWFC 03,W
10480:  MOVWF  FEA
10482:  MOVF   FEF,F
10484:  BNZ   10488
....................          break; 
10486:  BRA    1048C
....................       } 
10488:  INCF   xA6,F
1048A:  BRA    10436
....................    }   
1048C:  MOVLB  0
1048E:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
18374:  MOVLB  8
18376:  CLRF   x74
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
18378:  CLRF   x72
1837A:  CLRF   x71
....................    macro_cmd = 1; 
1837C:  MOVLW  01
1837E:  MOVWF  x73
....................     
....................    init_ext_eeprom(); 
18380:  MOVLB  0
18382:  CALL   FFE8
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
18386:  MOVLB  8
18388:  MOVF   x72,W
1838A:  SUBLW  03
1838C:  BNC   183D4
1838E:  MOVF   x73,W
18390:  SUBLW  3B
18392:  BZ    183D4
....................       macro_cmd = read_macro_line(macro, line); 
18394:  MOVFF  870,875
18398:  MOVFF  872,877
1839C:  MOVFF  871,876
183A0:  MOVLB  0
183A2:  BRA    182C0
183A4:  MOVFF  01,873
....................       if(macro_cmd == 'p'){ 
183A8:  MOVLB  8
183AA:  MOVF   x73,W
183AC:  SUBLW  70
183AE:  BNZ   183CC
....................          read_macro_line_string(macro,line,count); 
183B0:  MOVFF  870,89F
183B4:  MOVFF  872,8A1
183B8:  MOVFF  871,8A0
183BC:  CLRF   xA3
183BE:  MOVFF  874,8A2
183C2:  MOVLB  0
183C4:  CALL   103D6
....................          count++; 
183C8:  MOVLB  8
183CA:  INCF   x74,F
....................       } 
....................       ++line; 
183CC:  INCF   x71,F
183CE:  BTFSC  FD8.2
183D0:  INCF   x72,F
183D2:  BRA    18388
....................    } 
183D4:  MOVLB  0
183D6:  GOTO   183F6 (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D0C0:  MOVLB  8
0D0C2:  CLRF   xAF
0D0C4:  CLRF   xAE
0D0C6:  MOVF   xAF,W
0D0C8:  SUBWF  xAD,W
0D0CA:  BNC   D0F2
0D0CC:  BNZ   D0D4
0D0CE:  MOVF   xAC,W
0D0D0:  SUBWF  xAE,W
0D0D2:  BC    D0F2
....................       delay_ms(1000); 
0D0D4:  MOVLW  04
0D0D6:  MOVWF  xB0
0D0D8:  MOVLW  FA
0D0DA:  MOVLB  9
0D0DC:  MOVWF  xD6
0D0DE:  MOVLB  0
0D0E0:  CALL   2972
0D0E4:  MOVLB  8
0D0E6:  DECFSZ xB0,F
0D0E8:  BRA    D0D8
0D0EA:  INCF   xAE,F
0D0EC:  BTFSC  FD8.2
0D0EE:  INCF   xAF,F
0D0F0:  BRA    D0C6
....................    }  
0D0F2:  MOVLB  0
0D0F4:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0D088:  BCF    FD8.0
0D08A:  MOVLB  7
0D08C:  RLCF   x3C,W
0D08E:  CLRF   03
0D090:  ADDLW  92
0D092:  MOVWF  FE9
0D094:  MOVLW  07
0D096:  ADDWFC 03,W
0D098:  MOVWF  FEA
0D09A:  MOVFF  FEC,8AE
0D09E:  MOVF   FED,F
0D0A0:  MOVFF  FEF,8AD
0D0A4:  MOVLB  8
0D0A6:  DECFSZ xAD,W
0D0A8:  BRA    D0B4
0D0AA:  MOVF   xAE,F
0D0AC:  BNZ   D0B4
....................    { 
....................       macro_status = 'e'; 
0D0AE:  MOVLW  65
0D0B0:  MOVWF  xAC
....................    } 
0D0B2:  BRA    D0B8
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D0B4:  MOVLW  61
0D0B6:  MOVWF  xAC
....................    } 
....................    return(macro_status); 
0D0B8:  MOVFF  8AC,01
0D0BC:  MOVLB  0
0D0BE:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
13616:  DECFSZ 41,W
13618:  BRA    1362C
1361A:  MOVF   42,F
1361C:  BNZ   1362C
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
1361E:  MOVLW  01
13620:  MOVLB  8
13622:  MOVWF  xAC
13624:  MOVWF  xAD
13626:  MOVLB  0
13628:  RCALL  134E0
....................    } 
1362A:  BRA    13656
....................    else if(nv_det_type==2 || nv_det_type==3) 
1362C:  MOVF   41,W
1362E:  SUBLW  02
13630:  BNZ   13636
13632:  MOVF   42,F
13634:  BZ    13640
13636:  MOVF   41,W
13638:  SUBLW  03
1363A:  BNZ   13656
1363C:  MOVF   42,F
1363E:  BNZ   13656
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
13640:  MOVLB  8
13642:  CLRF   xAD
13644:  MOVLW  C8
13646:  MOVWF  xAC
13648:  MOVLW  01
1364A:  MOVWF  xAE
1364C:  MOVWF  xAF
1364E:  CLRF   xB0
13650:  MOVLB  0
13652:  CALL   FD8A
....................    } 
13656:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
12524:  DECFSZ 41,W
12526:  BRA    12542
12528:  MOVF   42,F
1252A:  BNZ   12542
....................       cmd = macro_cmd; 
1252C:  MOVFF  8AC,43
....................       arg = macro_arg; 
12530:  CLRF   47
12532:  CLRF   46
12534:  MOVFF  8AE,45
12538:  MOVFF  8AD,44
....................       det_cmd(); 
1253C:  CALL   F184
....................    } 
12540:  BRA    1255C
....................    else if(nv_det_type==2 || nv_det_type==3) { 
12542:  MOVF   41,W
12544:  SUBLW  02
12546:  BNZ   1254C
12548:  MOVF   42,F
1254A:  BZ    12556
1254C:  MOVF   41,W
1254E:  SUBLW  03
12550:  BNZ   1255C
12552:  MOVF   42,F
12554:  BNZ   1255C
....................       set_heaters(macro_arg); 
12556:  MOVFF  8AD,8AF
1255A:  RCALL  124B0
....................    } 
1255C:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
1255E:  DECFSZ 41,W
12560:  BRA    1257C
12562:  MOVF   42,F
12564:  BNZ   1257C
....................       cmd = macro_cmd; 
12566:  MOVFF  8AC,43
....................       arg = macro_arg; 
1256A:  CLRF   47
1256C:  CLRF   46
1256E:  MOVFF  8AE,45
12572:  MOVFF  8AD,44
....................       det_cmd(); 
12576:  CALL   F184
....................    } 
1257A:  BRA    1259C
....................    else if(nv_det_type==2 || nv_det_type==3) { 
1257C:  MOVF   41,W
1257E:  SUBLW  02
12580:  BNZ   12586
12582:  MOVF   42,F
12584:  BZ    12590
12586:  MOVF   41,W
12588:  SUBLW  03
1258A:  BNZ   1259C
1258C:  MOVF   42,F
1258E:  BNZ   1259C
....................       set_LED(macro_arg); 
12590:  MOVFF  8AE,8B0
12594:  MOVFF  8AD,8AF
12598:  CALL   F648
....................    } 
1259C:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13B8E:  MOVLW  65
13B90:  MOVLB  8
13B92:  MOVWF  xAB
....................     
....................    addr = macro_address[macro] + (line*3); 
13B94:  BCF    FD8.0
13B96:  RLCF   xA1,W
13B98:  CLRF   03
13B9A:  ADDLW  CD
13B9C:  MOVWF  FE9
13B9E:  MOVLW  07
13BA0:  ADDWFC 03,W
13BA2:  MOVWF  FEA
13BA4:  MOVFF  FEC,8AD
13BA8:  MOVF   FED,F
13BAA:  MOVFF  FEF,8AC
13BAE:  MOVFF  8A3,9F7
13BB2:  MOVFF  8A2,9F6
13BB6:  MOVLB  9
13BB8:  CLRF   xF9
13BBA:  MOVLW  03
13BBC:  MOVWF  xF8
13BBE:  MOVLB  0
13BC0:  CALL   5D14
13BC4:  MOVF   01,W
13BC6:  MOVLB  8
13BC8:  ADDWF  xAC,W
13BCA:  MOVWF  xA6
13BCC:  MOVF   02,W
13BCE:  ADDWFC xAD,W
13BD0:  MOVWF  xA7
....................  
....................    init_ext_eeprom(); 
13BD2:  MOVLB  0
13BD4:  CALL   FFE8
....................    macro_cmd = read_ext_eeprom(addr); 
13BD8:  MOVFF  8A7,8B6
13BDC:  MOVFF  8A6,8B5
13BE0:  CALL   1037C
13BE4:  MOVFF  01,8A8
....................    ++addr; 
13BE8:  MOVLB  8
13BEA:  INCF   xA6,F
13BEC:  BTFSC  FD8.2
13BEE:  INCF   xA7,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13BF0:  MOVFF  8A7,8AD
13BF4:  MOVFF  8A6,8AC
13BF8:  MOVLB  0
13BFA:  CALL   10490
13BFE:  MOVFF  02,8AA
13C02:  MOVFF  01,8A9
....................    //} 
....................    heartbeat(TRUE); 
13C06:  MOVLW  01
13C08:  MOVLB  8
13C0A:  MOVWF  xD7
13C0C:  MOVLB  0
13C0E:  CALL   55DA
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13C12:  MOVF   2F,F
13C14:  BTFSS  FD8.2
13C16:  BRA    13EC2
13C18:  MOVF   30,F
13C1A:  BTFSS  FD8.2
13C1C:  BRA    13EC2
....................       switch(macro_cmd) 
13C1E:  MOVLW  2B
13C20:  MOVLB  8
13C22:  SUBWF  xA8,W
13C24:  ADDLW  BA
13C26:  BTFSC  FD8.0
13C28:  BRA    13EC4
13C2A:  ADDLW  46
13C2C:  MOVLB  0
13C2E:  GOTO   13ECE
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13C32:  CALL   1233E
....................             store_rel_data(); 
13C36:  CALL   123A2
....................             macro_status = 'a'; 
13C3A:  MOVLW  61
13C3C:  MOVLB  8
13C3E:  MOVWF  xAB
....................             break; 
13C40:  BRA    13EC4
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
13C42:  MOVLW  08
13C44:  MOVWF  FEA
13C46:  MOVLW  21
13C48:  MOVWF  FE9
13C4A:  CALL   79DC
13C4E:  MOVLW  0D
13C50:  BTFSS  F9E.4
13C52:  BRA    13C50
13C54:  MOVWF  FAD
13C56:  MOVLW  0A
13C58:  BTFSS  F9E.4
13C5A:  BRA    13C58
13C5C:  MOVWF  FAD
....................             macro_status = 'a'; 
13C5E:  MOVLW  61
13C60:  MOVLB  8
13C62:  MOVWF  xAB
....................             break; 
13C64:  BRA    13EC4
....................          case 'C' : 
....................             calc_abs_data(); 
13C66:  CALL   1233E
....................             break; 
13C6A:  MOVLB  8
13C6C:  BRA    13EC4
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
13C6E:  MOVFF  8AA,8AD
13C72:  MOVFF  8A9,8AC
13C76:  CALL   D0C0
....................             macro_status = 'a'; 
13C7A:  MOVLW  61
13C7C:  MOVLB  8
13C7E:  MOVWF  xAB
....................             break; 
13C80:  BRA    13EC4
....................          case 'F' : macro_flag = macro_arg; 
13C82:  MOVFF  8AA,320
13C86:  MOVFF  8A9,31F
....................                     macro_status = 'a'; 
13C8A:  MOVLW  61
13C8C:  MOVLB  8
13C8E:  MOVWF  xAB
....................             break ; 
13C90:  BRA    13EC4
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
13C92:  MOVFF  8A9,2D1
....................                     macro_status = 'a'; 
13C96:  MOVLW  61
13C98:  MOVLB  8
13C9A:  MOVWF  xAB
....................             break ; 
13C9C:  BRA    13EC4
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
13C9E:  MOVFF  8A8,8AC
13CA2:  MOVFF  8AA,8AE
13CA6:  MOVFF  8A9,8AD
13CAA:  CALL   12524
....................                     macro_status = 'a'; 
13CAE:  MOVLW  61
13CB0:  MOVLB  8
13CB2:  MOVWF  xAB
....................             break; 
13CB4:  BRA    13EC4
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
13CB6:  MOVFF  8A8,8AC
13CBA:  MOVFF  8AA,8AE
13CBE:  MOVFF  8A9,8AD
13CC2:  CALL   12524
....................                     macro_status = 'a'; 
13CC6:  MOVLW  61
13CC8:  MOVLB  8
13CCA:  MOVWF  xAB
....................             break; 
13CCC:  BRA    13EC4
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
13CCE:  MOVFF  8AA,8C6
13CD2:  MOVFF  8A9,8C5
13CD6:  MOVLB  8
13CD8:  CLRF   xC8
13CDA:  MOVLW  64
13CDC:  MOVWF  xC7
13CDE:  MOVLB  0
13CE0:  CALL   2D36
13CE4:  MOVFF  02,749
13CE8:  MOVFF  01,748
....................                     macro_status = 'a'; 
13CEC:  MOVLW  61
13CEE:  MOVLB  8
13CF0:  MOVWF  xAB
....................             break;    
13CF2:  BRA    13EC4
....................          case 'l' : LightTargetFlag = 1; 
13CF4:  MOVLW  01
13CF6:  MOVLB  2
13CF8:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
13CFA:  MOVFF  8A8,8AC
13CFE:  MOVFF  8AA,8AE
13D02:  MOVFF  8A9,8AD
13D06:  MOVLB  0
13D08:  CALL   1255E
....................                     delay_ms(10000); 
13D0C:  MOVLW  28
13D0E:  MOVLB  8
13D10:  MOVWF  xAC
13D12:  MOVLW  FA
13D14:  MOVLB  9
13D16:  MOVWF  xD6
13D18:  MOVLB  0
13D1A:  CALL   2972
13D1E:  MOVLB  8
13D20:  DECFSZ xAC,F
13D22:  BRA    13D12
....................                     macro_status = 'a'; 
13D24:  MOVLW  61
13D26:  MOVWF  xAB
....................             break;        
13D28:  BRA    13EC4
....................          case 'L' : LightTargetFlag = 0; 
13D2A:  MOVLB  2
13D2C:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
13D2E:  MOVFF  8A8,8AC
13D32:  MOVFF  8AA,8AE
13D36:  MOVFF  8A9,8AD
13D3A:  MOVLB  0
13D3C:  CALL   1255E
....................                     macro_status = 'a'; 
13D40:  MOVLW  61
13D42:  MOVLB  8
13D44:  MOVWF  xAB
....................             break; 
13D46:  BRA    13EC4
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
13D48:  MOVFF  8A8,43
....................                     arg = macro_arg; 
13D4C:  CLRF   47
13D4E:  CLRF   46
13D50:  MOVFF  8AA,45
13D54:  MOVFF  8A9,44
....................                     det_cmd(); 
13D58:  CALL   F184
....................                     macro_status = 'a'; 
13D5C:  MOVLW  61
13D5E:  MOVLB  8
13D60:  MOVWF  xAB
....................             break ; 
13D62:  BRA    13EC4
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
13D64:  MOVLB  8
13D66:  DECFSZ xA9,W
13D68:  BRA    13D74
13D6A:  MOVF   xAA,F
13D6C:  BNZ   13D74
13D6E:  MOVLB  0
13D70:  RCALL  13616
13D72:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
13D74:  MOVF   xA9,W
13D76:  SUBLW  02
13D78:  BNZ   13D8A
13D7A:  MOVF   xAA,F
13D7C:  BNZ   13D8A
13D7E:  MOVLW  01
13D80:  MOVWF  xAC
13D82:  MOVWF  xAD
13D84:  MOVLB  0
13D86:  RCALL  137E2
13D88:  MOVLB  8
....................                     macro_status = 'a'; 
13D8A:  MOVLW  61
13D8C:  MOVWF  xAB
....................             break ;  
13D8E:  BRA    13EC4
....................          case 'T' : det_temp(); 
13D90:  RCALL  139A2
....................                     macro_status = 'a'; 
13D92:  MOVLW  61
13D94:  MOVLB  8
13D96:  MOVWF  xAB
....................             break; 
13D98:  BRA    13EC4
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
13D9A:  MOVLW  01
13D9C:  MOVLB  7
13D9E:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
13DA0:  MOVLB  8
13DA2:  CLRF   xB1
13DA4:  CLRF   xB2
13DA6:  CLRF   xB6
13DA8:  CLRF   xB5
13DAA:  MOVFF  8AA,8B4
13DAE:  MOVFF  8A9,8B3
13DB2:  MOVWF  xB7
13DB4:  MOVLB  0
13DB6:  CALL   9DB8
....................                     macro_status=step_err_status(); 
13DBA:  CALL   D088
13DBE:  MOVFF  01,8AB
....................             break; 
13DC2:  MOVLB  8
13DC4:  BRA    13EC4
....................          case '-' : motor=1; 
13DC6:  MOVLW  01
13DC8:  MOVLB  7
13DCA:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
13DCC:  MOVLB  8
13DCE:  CLRF   xB1
13DD0:  MOVWF  xB2
13DD2:  CLRF   xB6
13DD4:  CLRF   xB5
13DD6:  MOVFF  8AA,8B4
13DDA:  MOVFF  8A9,8B3
13DDE:  MOVWF  xB7
13DE0:  MOVLB  0
13DE2:  CALL   9DB8
....................                     macro_status=step_err_status(); 
13DE6:  CALL   D088
13DEA:  MOVFF  01,8AB
....................             break; 
13DEE:  MOVLB  8
13DF0:  BRA    13EC4
....................          case 'G' : motor=0; 
13DF2:  MOVLB  7
13DF4:  CLRF   x3C
....................                     align(0); 
13DF6:  MOVLB  8
13DF8:  CLRF   xAC
13DFA:  MOVLB  0
13DFC:  CALL   A8F4
....................                     macro_status=step_err_status(); 
13E00:  CALL   D088
13E04:  MOVFF  01,8AB
....................             break ;           
13E08:  MOVLB  8
13E0A:  BRA    13EC4
....................          case 'P' : motor=0; 
13E0C:  MOVLB  7
13E0E:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
13E10:  MOVLW  01
13E12:  MOVLB  8
13E14:  MOVWF  xB1
13E16:  CLRF   xB2
13E18:  CLRF   xB6
13E1A:  CLRF   xB5
13E1C:  MOVFF  8AA,8B4
13E20:  MOVFF  8A9,8B3
13E24:  MOVWF  xB7
13E26:  MOVLB  0
13E28:  CALL   9DB8
....................                     macro_status=step_err_status(); 
13E2C:  CALL   D088
13E30:  MOVFF  01,8AB
....................             break; 
13E34:  MOVLB  8
13E36:  BRA    13EC4
....................          case 'Q' : motor=0; 
13E38:  MOVLB  7
13E3A:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
13E3C:  MOVLB  8
13E3E:  CLRF   xB1
13E40:  CLRF   xB2
13E42:  CLRF   xB6
13E44:  CLRF   xB5
13E46:  MOVFF  8AA,8B4
13E4A:  MOVFF  8A9,8B3
13E4E:  MOVLW  01
13E50:  MOVWF  xB7
13E52:  MOVLB  0
13E54:  CALL   9DB8
....................                     macro_status=step_err_status(); 
13E58:  CALL   D088
13E5C:  MOVFF  01,8AB
....................             break; 
13E60:  MOVLB  8
13E62:  BRA    13EC4
....................          case 'R' : motor=0; 
13E64:  MOVLB  7
13E66:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
13E68:  MOVLB  8
13E6A:  CLRF   xB1
13E6C:  MOVLW  01
13E6E:  MOVWF  xB2
13E70:  CLRF   xB6
13E72:  CLRF   xB5
13E74:  MOVFF  8AA,8B4
13E78:  MOVFF  8A9,8B3
13E7C:  MOVWF  xB7
13E7E:  MOVLB  0
13E80:  CALL   9DB8
....................                     macro_status=step_err_status(); 
13E84:  CALL   D088
13E88:  MOVFF  01,8AB
....................             break; 
13E8C:  MOVLB  8
13E8E:  BRA    13EC4
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
13E90:  MOVLB  8
13E92:  DECFSZ xA9,W
13E94:  BRA    13EA4
13E96:  MOVF   xAA,F
13E98:  BNZ   13EA4
13E9A:  MOVLB  0
13E9C:  CALL   D0F6
13EA0:  BRA    13EB2
13EA2:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
13EA4:  MOVF   xA9,F
13EA6:  BNZ   13EB4
13EA8:  MOVF   xAA,F
13EAA:  BNZ   13EB4
13EAC:  MOVLB  0
13EAE:  CALL   D11A
13EB2:  MOVLB  8
....................                     macro_status = 'a'; 
13EB4:  MOVLW  61
13EB6:  MOVWF  xAB
....................             break; 
13EB8:  BRA    13EC4
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
13EBA:  MOVLW  66
13EBC:  MOVLB  8
13EBE:  MOVWF  xAB
....................             break ; 
13EC0:  BRA    13EC4
13EC2:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
13EC4:  MOVFF  8AB,01
13EC8:  MOVLB  0
13ECA:  GOTO   147CA (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
14626:  MOVLW  65
14628:  MOVLB  8
1462A:  MOVWF  x91
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
1462C:  BCF    FD8.0
1462E:  RLCF   x87,W
14630:  CLRF   03
14632:  ADDLW  CD
14634:  MOVWF  FE9
14636:  MOVLW  07
14638:  ADDWFC 03,W
1463A:  MOVWF  FEA
1463C:  MOVFF  FEC,8A0
14640:  MOVF   FED,F
14642:  MOVFF  FEF,89F
14646:  MOVFF  889,03
1464A:  MOVFF  888,FE9
1464E:  MOVFF  889,FEA
14652:  MOVFF  FEC,9F7
14656:  MOVF   FED,F
14658:  MOVFF  FEF,9F6
1465C:  MOVLB  9
1465E:  CLRF   xF9
14660:  MOVLW  03
14662:  MOVWF  xF8
14664:  MOVLB  0
14666:  CALL   5D14
1466A:  MOVF   01,W
1466C:  MOVLB  8
1466E:  ADDWF  x9F,W
14670:  MOVWF  x8C
14672:  MOVF   02,W
14674:  ADDWFC xA0,W
14676:  MOVWF  x8D
....................  
....................    init_ext_eeprom(); 
14678:  MOVLB  0
1467A:  CALL   FFE8
....................    macro_cmd = read_ext_eeprom(addr); 
1467E:  MOVFF  88D,8B6
14682:  MOVFF  88C,8B5
14686:  CALL   1037C
1468A:  MOVFF  01,88E
....................    ++addr; 
1468E:  MOVLB  8
14690:  INCF   x8C,F
14692:  BTFSC  FD8.2
14694:  INCF   x8D,F
....................    if(macro_cmd == 'p'){ 
14696:  MOVF   x8E,W
14698:  SUBLW  70
1469A:  BNZ   146C0
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
1469C:  MOVFF  887,89F
146A0:  MOVFF  889,8A1
146A4:  MOVFF  888,8A0
146A8:  MOVFF  854,8A3
146AC:  MOVFF  853,8A2
146B0:  MOVLB  0
146B2:  CALL   103D6
....................       count1++; 
146B6:  MOVLB  8
146B8:  INCF   x53,F
146BA:  BTFSC  FD8.2
146BC:  INCF   x54,F
....................    }else{ 
146BE:  BRA    146D8
....................    macro_arg = read16_ext_eeprom(addr); 
146C0:  MOVFF  88D,8AD
146C4:  MOVFF  88C,8AC
146C8:  MOVLB  0
146CA:  CALL   10490
146CE:  MOVFF  02,890
146D2:  MOVFF  01,88F
146D6:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
146D8:  MOVLW  01
146DA:  MOVWF  xD7
146DC:  MOVLB  0
146DE:  CALL   55DA
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
146E2:  MOVF   2F,F
146E4:  BTFSS  FD8.2
146E6:  BRA    14B34
146E8:  MOVF   30,F
146EA:  BTFSS  FD8.2
146EC:  BRA    14B34
....................       switch(macro_cmd){ 
146EE:  MOVLW  2B
146F0:  MOVLB  8
146F2:  SUBWF  x8E,W
146F4:  ADDLW  B8
146F6:  BTFSC  FD8.0
146F8:  BRA    14B30
146FA:  ADDLW  48
146FC:  MOVLB  0
146FE:  GOTO   14DFA
....................          case 'A' : 
....................             calc_abs_data(); 
14702:  CALL   1233E
....................             store_rel_data(); 
14706:  CALL   123A2
....................             macro_status = 'a'; 
1470A:  MOVLW  61
1470C:  MOVLB  8
1470E:  MOVWF  x91
....................             break; 
14710:  BRA    14B30
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
14712:  MOVLW  08
14714:  MOVWF  FEA
14716:  MOVLW  21
14718:  MOVWF  FE9
1471A:  CALL   79DC
1471E:  MOVLW  0D
14720:  BTFSS  F9E.4
14722:  BRA    14720
14724:  MOVWF  FAD
14726:  MOVLW  0A
14728:  BTFSS  F9E.4
1472A:  BRA    14728
1472C:  MOVWF  FAD
....................             macro_status = 'a'; 
1472E:  MOVLW  61
14730:  MOVLB  8
14732:  MOVWF  x91
....................             break; 
14734:  BRA    14B30
....................          case 'C' : 
....................             calc_abs_data(); 
14736:  CALL   1233E
....................             break; 
1473A:  MOVLB  8
1473C:  BRA    14B30
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
1473E:  MOVLB  8
14740:  CLRF   x95
14742:  CLRF   x94
14744:  CLRF   x93
14746:  CLRF   x92
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14748:  MOVFF  889,03
1474C:  MOVFF  888,FE9
14750:  MOVFF  889,FEA
14754:  MOVLW  01
14756:  ADDWF  FEE,F
14758:  BNC   1475C
1475A:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
1475C:  MOVFF  888,FE9
14760:  MOVFF  889,FEA
14764:  CLRF   x99
14766:  CLRF   x98
14768:  MOVFF  FEC,897
1476C:  MOVF   FED,F
1476E:  MOVFF  FEF,896
14772:  CLRF   x9D
14774:  CLRF   x9C
14776:  CLRF   x9B
14778:  CLRF   x9A
....................                    
....................                   while(count < macro_arg){ 
1477A:  MOVF   x95,F
1477C:  BTFSS  FD8.2
1477E:  BRA    148BA
14780:  MOVF   x94,F
14782:  BTFSS  FD8.2
14784:  BRA    148BA
14786:  MOVF   x93,W
14788:  SUBWF  x90,W
1478A:  BTFSS  FD8.0
1478C:  BRA    148BA
1478E:  BNZ   14798
14790:  MOVF   x8F,W
14792:  SUBWF  x92,W
14794:  BTFSC  FD8.0
14796:  BRA    148BA
....................                      char curr = 'A'; 
14798:  MOVLW  41
1479A:  MOVWF  x9E
....................                      while(curr != '%'){ 
1479C:  MOVF   x9E,W
1479E:  SUBLW  25
147A0:  BZ    1480C
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
147A2:  MOVFF  889,03
147A6:  MOVFF  888,FE9
147AA:  MOVFF  889,FEA
147AE:  MOVFF  FEC,8A3
147B2:  MOVF   FED,F
147B4:  MOVFF  FEF,8A2
147B8:  MOVFF  887,8A1
147BC:  MOVFF  88B,8A5
147C0:  MOVFF  88A,8A4
147C4:  MOVLB  0
147C6:  GOTO   13B8E
....................                         (*line)++; 
147CA:  MOVFF  889,03
147CE:  MOVLB  8
147D0:  MOVF   x88,W
147D2:  MOVWF  FE9
147D4:  MOVFF  03,FEA
147D8:  MOVLW  01
147DA:  ADDWF  FEE,F
147DC:  BNC   147E0
147DE:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
147E0:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
147E2:  MOVFF  889,03
147E6:  MOVFF  888,FE9
147EA:  MOVFF  889,FEA
147EE:  MOVFF  FEC,8A3
147F2:  MOVF   FED,F
147F4:  MOVFF  FEF,8A2
147F8:  MOVFF  887,8A1
147FC:  MOVLB  0
147FE:  GOTO   13F7A
14802:  MOVFF  01,89E
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14806:  BSF    F91.5
14808:  MOVLB  8
1480A:  BRA    1479C
....................                      } 
....................                      end_line = (*line); 
1480C:  MOVFF  888,FE9
14810:  MOVFF  889,FEA
14814:  CLRF   x9D
14816:  CLRF   x9C
14818:  MOVFF  FEC,89B
1481C:  MOVF   FED,F
1481E:  MOVFF  FEF,89A
....................                      count++; 
14822:  MOVLW  01
14824:  ADDWF  x92,F
14826:  BTFSC  FD8.0
14828:  INCF   x93,F
1482A:  BTFSC  FD8.2
1482C:  INCF   x94,F
1482E:  BTFSC  FD8.2
14830:  INCF   x95,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
14832:  MOVF   x92,W
14834:  SUBWF  x8F,W
14836:  MOVWF  x9F
14838:  MOVF   x93,W
1483A:  SUBWFB x90,W
1483C:  MOVWF  xA0
1483E:  MOVLW  00
14840:  SUBFWB x94,W
14842:  MOVWF  xA1
14844:  MOVLW  00
14846:  SUBFWB x95,W
14848:  MOVWF  xA2
1484A:  MOVLW  50
1484C:  MOVWF  FF6
1484E:  MOVLW  21
14850:  MOVWF  FF7
14852:  MOVLW  00
14854:  MOVWF  FF8
14856:  CLRF   1B
14858:  BTFSC  FF2.7
1485A:  BSF    1B.7
1485C:  BCF    FF2.7
1485E:  MOVLW  11
14860:  MOVLB  A
14862:  MOVWF  x25
14864:  MOVLB  0
14866:  CALL   101E
1486A:  BTFSC  1B.7
1486C:  BSF    FF2.7
1486E:  MOVLW  41
14870:  MOVWF  FE9
14872:  CLRF   1B
14874:  BTFSC  FF2.7
14876:  BSF    1B.7
14878:  BCF    FF2.7
1487A:  MOVFF  8A2,A28
1487E:  MOVFF  8A1,A27
14882:  MOVFF  8A0,A26
14886:  MOVFF  89F,A25
1488A:  CALL   10E4
1488E:  BTFSC  1B.7
14890:  BSF    FF2.7
14892:  MOVLW  0D
14894:  BTFSS  F9E.4
14896:  BRA    14894
14898:  MOVWF  FAD
1489A:  MOVLW  0A
1489C:  BTFSS  F9E.4
1489E:  BRA    1489C
148A0:  MOVWF  FAD
....................                      (*line) = start_line; 
148A2:  MOVFF  889,03
148A6:  MOVLB  8
148A8:  MOVFF  888,FE9
148AC:  MOVFF  889,FEA
148B0:  MOVFF  896,FEF
148B4:  MOVFF  897,FEC
148B8:  BRA    1477A
....................                   } 
....................                   (*line) = end_line + 1; 
148BA:  MOVFF  888,FE9
148BE:  MOVFF  889,FEA
148C2:  MOVLW  01
148C4:  ADDWF  x9A,W
148C6:  MOVWF  FEF
148C8:  MOVLW  00
148CA:  ADDWFC x9B,W
148CC:  MOVWF  FEC
....................                   macro_status = 'a'; 
148CE:  MOVLW  61
148D0:  MOVWF  x91
....................             break; 
148D2:  BRA    14B30
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
148D4:  MOVFF  890,8AD
148D8:  MOVFF  88F,8AC
148DC:  CALL   D0C0
....................                     macro_status = 'a'; 
148E0:  MOVLW  61
148E2:  MOVLB  8
148E4:  MOVWF  x91
....................             break; 
148E6:  BRA    14B30
....................          case 'F' : macro_flag = macro_arg; 
148E8:  MOVFF  890,320
148EC:  MOVFF  88F,31F
....................                     macro_status = 'a'; 
148F0:  MOVLW  61
148F2:  MOVLB  8
148F4:  MOVWF  x91
....................             break ; 
148F6:  BRA    14B30
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
148F8:  MOVFF  88F,2D1
....................                     macro_status = 'a'; 
148FC:  MOVLW  61
148FE:  MOVLB  8
14900:  MOVWF  x91
....................             break ; 
14902:  BRA    14B30
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14904:  MOVFF  88E,8AC
14908:  MOVFF  890,8AE
1490C:  MOVFF  88F,8AD
14910:  CALL   12524
....................                     macro_status = 'a'; 
14914:  MOVLW  61
14916:  MOVLB  8
14918:  MOVWF  x91
....................             break; 
1491A:  BRA    14B30
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
1491C:  MOVFF  88E,8AC
14920:  MOVFF  890,8AE
14924:  MOVFF  88F,8AD
14928:  CALL   12524
....................                     macro_status = 'a'; 
1492C:  MOVLW  61
1492E:  MOVLB  8
14930:  MOVWF  x91
....................             break; 
14932:  BRA    14B30
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14934:  MOVFF  890,8C6
14938:  MOVFF  88F,8C5
1493C:  MOVLB  8
1493E:  CLRF   xC8
14940:  MOVLW  64
14942:  MOVWF  xC7
14944:  MOVLB  0
14946:  CALL   2D36
1494A:  MOVFF  02,749
1494E:  MOVFF  01,748
....................                     macro_status = 'a'; 
14952:  MOVLW  61
14954:  MOVLB  8
14956:  MOVWF  x91
....................             break;    
14958:  BRA    14B30
....................          case 'l' : LightTargetFlag = 1; 
1495A:  MOVLW  01
1495C:  MOVLB  2
1495E:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
14960:  MOVFF  88E,8AC
14964:  MOVFF  890,8AE
14968:  MOVFF  88F,8AD
1496C:  MOVLB  0
1496E:  CALL   1255E
....................                     delay_ms(10000); 
14972:  MOVLW  28
14974:  MOVLB  8
14976:  MOVWF  x9F
14978:  MOVLW  FA
1497A:  MOVLB  9
1497C:  MOVWF  xD6
1497E:  MOVLB  0
14980:  CALL   2972
14984:  MOVLB  8
14986:  DECFSZ x9F,F
14988:  BRA    14978
....................                     macro_status = 'a'; 
1498A:  MOVLW  61
1498C:  MOVWF  x91
....................             break;        
1498E:  BRA    14B30
....................          case 'L' : LightTargetFlag = 0; 
14990:  MOVLB  2
14992:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
14994:  MOVFF  88E,8AC
14998:  MOVFF  890,8AE
1499C:  MOVFF  88F,8AD
149A0:  MOVLB  0
149A2:  CALL   1255E
....................                     macro_status = 'a'; 
149A6:  MOVLW  61
149A8:  MOVLB  8
149AA:  MOVWF  x91
....................             break; 
149AC:  BRA    14B30
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
149AE:  MOVFF  88E,43
....................                     arg = macro_arg; 
149B2:  CLRF   47
149B4:  CLRF   46
149B6:  MOVFF  890,45
149BA:  MOVFF  88F,44
....................                     det_cmd(); 
149BE:  CALL   F184
....................                     macro_status = 'a'; 
149C2:  MOVLW  61
149C4:  MOVLB  8
149C6:  MOVWF  x91
....................             break ; 
149C8:  BRA    14B30
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
149CA:  MOVLB  8
149CC:  DECFSZ x8F,W
149CE:  BRA    149DC
149D0:  MOVF   x90,F
149D2:  BNZ   149DC
149D4:  MOVLB  0
149D6:  CALL   13616
149DA:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
149DC:  MOVF   x8F,W
149DE:  SUBLW  02
149E0:  BNZ   149F4
149E2:  MOVF   x90,F
149E4:  BNZ   149F4
149E6:  MOVLW  01
149E8:  MOVWF  xAC
149EA:  MOVWF  xAD
149EC:  MOVLB  0
149EE:  CALL   137E2
149F2:  MOVLB  8
....................                     macro_status = 'a'; 
149F4:  MOVLW  61
149F6:  MOVWF  x91
....................             break ;  
149F8:  BRA    14B30
....................          case 'T' : det_temp(); 
149FA:  CALL   139A2
....................                     macro_status = 'a'; 
149FE:  MOVLW  61
14A00:  MOVLB  8
14A02:  MOVWF  x91
....................             break; 
14A04:  BRA    14B30
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14A06:  MOVLW  01
14A08:  MOVLB  7
14A0A:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14A0C:  MOVLB  8
14A0E:  CLRF   xB1
14A10:  CLRF   xB2
14A12:  CLRF   xB6
14A14:  CLRF   xB5
14A16:  MOVFF  890,8B4
14A1A:  MOVFF  88F,8B3
14A1E:  MOVWF  xB7
14A20:  MOVLB  0
14A22:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14A26:  CALL   D088
14A2A:  MOVFF  01,891
....................             break; 
14A2E:  MOVLB  8
14A30:  BRA    14B30
....................          case '-' : motor=1; 
14A32:  MOVLW  01
14A34:  MOVLB  7
14A36:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14A38:  MOVLB  8
14A3A:  CLRF   xB1
14A3C:  MOVWF  xB2
14A3E:  CLRF   xB6
14A40:  CLRF   xB5
14A42:  MOVFF  890,8B4
14A46:  MOVFF  88F,8B3
14A4A:  MOVWF  xB7
14A4C:  MOVLB  0
14A4E:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14A52:  CALL   D088
14A56:  MOVFF  01,891
....................             break; 
14A5A:  MOVLB  8
14A5C:  BRA    14B30
....................          case 'G' : motor=0; 
14A5E:  MOVLB  7
14A60:  CLRF   x3C
....................                     align(0); 
14A62:  MOVLB  8
14A64:  CLRF   xAC
14A66:  MOVLB  0
14A68:  CALL   A8F4
....................                     macro_status=step_err_status(); 
14A6C:  CALL   D088
14A70:  MOVFF  01,891
....................             break ;           
14A74:  MOVLB  8
14A76:  BRA    14B30
....................          case 'P' : motor=0; 
14A78:  MOVLB  7
14A7A:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
14A7C:  MOVLW  01
14A7E:  MOVLB  8
14A80:  MOVWF  xB1
14A82:  CLRF   xB2
14A84:  CLRF   xB6
14A86:  CLRF   xB5
14A88:  MOVFF  890,8B4
14A8C:  MOVFF  88F,8B3
14A90:  MOVWF  xB7
14A92:  MOVLB  0
14A94:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14A98:  CALL   D088
14A9C:  MOVFF  01,891
....................             break; 
14AA0:  MOVLB  8
14AA2:  BRA    14B30
....................          case 'Q' : motor=0; 
14AA4:  MOVLB  7
14AA6:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
14AA8:  MOVLB  8
14AAA:  CLRF   xB1
14AAC:  CLRF   xB2
14AAE:  CLRF   xB6
14AB0:  CLRF   xB5
14AB2:  MOVFF  890,8B4
14AB6:  MOVFF  88F,8B3
14ABA:  MOVLW  01
14ABC:  MOVWF  xB7
14ABE:  MOVLB  0
14AC0:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14AC4:  CALL   D088
14AC8:  MOVFF  01,891
....................             break; 
14ACC:  MOVLB  8
14ACE:  BRA    14B30
....................          case 'R' : motor=0; 
14AD0:  MOVLB  7
14AD2:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
14AD4:  MOVLB  8
14AD6:  CLRF   xB1
14AD8:  MOVLW  01
14ADA:  MOVWF  xB2
14ADC:  CLRF   xB6
14ADE:  CLRF   xB5
14AE0:  MOVFF  890,8B4
14AE4:  MOVFF  88F,8B3
14AE8:  MOVWF  xB7
14AEA:  MOVLB  0
14AEC:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14AF0:  CALL   D088
14AF4:  MOVFF  01,891
....................             break; 
14AF8:  MOVLB  8
14AFA:  BRA    14B30
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14AFC:  MOVLB  8
14AFE:  DECFSZ x8F,W
14B00:  BRA    14B10
14B02:  MOVF   x90,F
14B04:  BNZ   14B10
14B06:  MOVLB  0
14B08:  CALL   D0F6
14B0C:  BRA    14B1E
14B0E:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14B10:  MOVF   x8F,F
14B12:  BNZ   14B20
14B14:  MOVF   x90,F
14B16:  BNZ   14B20
14B18:  MOVLB  0
14B1A:  CALL   D11A
14B1E:  MOVLB  8
....................                     macro_status = 'a'; 
14B20:  MOVLW  61
14B22:  MOVWF  x91
....................             break; 
14B24:  BRA    14B30
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14B26:  MOVLW  66
14B28:  MOVLB  8
14B2A:  MOVWF  x91
....................             break ; 
14B2C:  BRA    14B30
14B2E:  MOVLB  8
....................       } 
....................    } 
14B30:  BRA    14DF0
14B32:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14B34:  DECFSZ 2F,W
14B36:  BRA    14B3C
14B38:  MOVF   30,F
14B3A:  BZ    14B4A
14B3C:  MOVF   2F,W
14B3E:  SUBLW  03
14B40:  BTFSS  FD8.2
14B42:  BRA    14CC8
14B44:  MOVF   30,F
14B46:  BTFSS  FD8.2
14B48:  BRA    14CC8
....................       switch(macro_cmd){ 
14B4A:  MOVLB  8
14B4C:  MOVF   x8E,W
14B4E:  XORLW  2B
14B50:  MOVLB  0
14B52:  BZ    14B80
14B54:  XORLW  06
14B56:  BZ    14BAA
14B58:  XORLW  6F
14B5A:  BZ    14BD4
14B5C:  XORLW  05
14B5E:  BZ    14BE6
14B60:  XORLW  17
14B62:  BZ    14BFE
14B64:  XORLW  01
14B66:  BZ    14C28
14B68:  XORLW  03
14B6A:  BZ    14C52
14B6C:  XORLW  06
14B6E:  BTFSC  FD8.2
14B70:  BRA    14C7C
14B72:  XORLW  0D
14B74:  BTFSC  FD8.2
14B76:  BRA    14C92
14B78:  XORLW  62
14B7A:  BTFSC  FD8.2
14B7C:  BRA    14CBE
14B7E:  BRA    14CC6
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14B80:  MOVLW  01
14B82:  MOVLB  7
14B84:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14B86:  MOVLB  8
14B88:  CLRF   xB1
14B8A:  CLRF   xB2
14B8C:  CLRF   xB6
14B8E:  CLRF   xB5
14B90:  MOVFF  890,8B4
14B94:  MOVFF  88F,8B3
14B98:  MOVWF  xB7
14B9A:  MOVLB  0
14B9C:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14BA0:  CALL   D088
14BA4:  MOVFF  01,891
....................             break; 
14BA8:  BRA    14CC6
....................          case '-' : motor=1; 
14BAA:  MOVLW  01
14BAC:  MOVLB  7
14BAE:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14BB0:  MOVLB  8
14BB2:  CLRF   xB1
14BB4:  MOVWF  xB2
14BB6:  CLRF   xB6
14BB8:  CLRF   xB5
14BBA:  MOVFF  890,8B4
14BBE:  MOVFF  88F,8B3
14BC2:  MOVWF  xB7
14BC4:  MOVLB  0
14BC6:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14BCA:  CALL   D088
14BCE:  MOVFF  01,891
....................             break; 
14BD2:  BRA    14CC6
....................          case 'B' : h_bridge(macro_arg); 
14BD4:  MOVFF  88F,89F
14BD8:  CALL   BFC2
....................                     macro_status = 'a'; 
14BDC:  MOVLW  61
14BDE:  MOVLB  8
14BE0:  MOVWF  x91
....................             break;             
14BE2:  MOVLB  0
14BE4:  BRA    14CC6
....................          case 'G' : motor=0; 
14BE6:  MOVLB  7
14BE8:  CLRF   x3C
....................                     align(0); 
14BEA:  MOVLB  8
14BEC:  CLRF   xAC
14BEE:  MOVLB  0
14BF0:  CALL   A8F4
....................                     macro_status=step_err_status(); 
14BF4:  CALL   D088
14BF8:  MOVFF  01,891
....................             break ;           
14BFC:  BRA    14CC6
....................          case 'P' : motor=0; 
14BFE:  MOVLB  7
14C00:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1);   
14C02:  MOVLB  8
14C04:  CLRF   xB1
14C06:  CLRF   xB2
14C08:  CLRF   xB6
14C0A:  CLRF   xB5
14C0C:  MOVFF  88B,8B4
14C10:  MOVFF  88A,8B3
14C14:  MOVLW  01
14C16:  MOVWF  xB7
14C18:  MOVLB  0
14C1A:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14C1E:  CALL   D088
14C22:  MOVFF  01,891
....................             break; 
14C26:  BRA    14CC6
....................          case 'Q' : motor=0; 
14C28:  MOVLB  7
14C2A:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1); 
14C2C:  MOVLB  8
14C2E:  CLRF   xB1
14C30:  CLRF   xB2
14C32:  CLRF   xB6
14C34:  CLRF   xB5
14C36:  MOVFF  88B,8B4
14C3A:  MOVFF  88A,8B3
14C3E:  MOVLW  01
14C40:  MOVWF  xB7
14C42:  MOVLB  0
14C44:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14C48:  CALL   D088
14C4C:  MOVFF  01,891
....................             break; 
14C50:  BRA    14CC6
....................          case 'R' : motor=0; 
14C52:  MOVLB  7
14C54:  CLRF   x3C
....................                     move_motor(0,1,mmacro_var,1); 
14C56:  MOVLB  8
14C58:  CLRF   xB1
14C5A:  MOVLW  01
14C5C:  MOVWF  xB2
14C5E:  CLRF   xB6
14C60:  CLRF   xB5
14C62:  MOVFF  88B,8B4
14C66:  MOVFF  88A,8B3
14C6A:  MOVWF  xB7
14C6C:  MOVLB  0
14C6E:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14C72:  CALL   D088
14C76:  MOVFF  01,891
....................             break; 
14C7A:  BRA    14CC6
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
14C7C:  MOVFF  890,8AD
14C80:  MOVFF  88F,8AC
14C84:  CALL   D0C0
....................                     macro_status = 'a'; 
14C88:  MOVLW  61
14C8A:  MOVLB  8
14C8C:  MOVWF  x91
....................             break; 
14C8E:  MOVLB  0
14C90:  BRA    14CC6
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
14C92:  MOVLB  8
14C94:  DECFSZ x8F,W
14C96:  BRA    14CA6
14C98:  MOVF   x90,F
14C9A:  BNZ   14CA6
14C9C:  MOVLB  0
14C9E:  CALL   D0F6
14CA2:  BRA    14CB4
14CA4:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14CA6:  MOVF   x8F,F
14CA8:  BNZ   14CB6
14CAA:  MOVF   x90,F
14CAC:  BNZ   14CB6
14CAE:  MOVLB  0
14CB0:  CALL   D11A
14CB4:  MOVLB  8
....................                     macro_status = 'a'; 
14CB6:  MOVLW  61
14CB8:  MOVWF  x91
....................             break; 
14CBA:  MOVLB  0
14CBC:  BRA    14CC6
....................          case ';' : macro_status = 'f'; 
14CBE:  MOVLW  66
14CC0:  MOVLB  8
14CC2:  MOVWF  x91
....................             break;            
14CC4:  MOVLB  0
....................       } 
....................    } 
14CC6:  BRA    14DEE
....................    else if (nv_product==AWS){ 
14CC8:  MOVF   2F,W
14CCA:  SUBLW  02
14CCC:  BTFSS  FD8.2
14CCE:  BRA    14DEE
14CD0:  MOVF   30,F
14CD2:  BTFSS  FD8.2
14CD4:  BRA    14DEE
....................       switch(macro_cmd){ 
14CD6:  MOVLB  8
14CD8:  MOVF   x8E,W
14CDA:  XORLW  2B
14CDC:  MOVLB  0
14CDE:  BZ    14D04
14CE0:  XORLW  06
14CE2:  BZ    14D2E
14CE4:  XORLW  6E
14CE6:  BZ    14D58
14CE8:  XORLW  07
14CEA:  BZ    14D6A
14CEC:  XORLW  14
14CEE:  BZ    14D80
14CF0:  XORLW  01
14CF2:  BZ    14D92
14CF4:  XORLW  02
14CF6:  BZ    14DA4
14CF8:  XORLW  0A
14CFA:  BZ    14DBA
14CFC:  XORLW  62
14CFE:  BTFSC  FD8.2
14D00:  BRA    14DE6
14D02:  BRA    14DEE
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14D04:  MOVLW  01
14D06:  MOVLB  7
14D08:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14D0A:  MOVLB  8
14D0C:  CLRF   xB1
14D0E:  CLRF   xB2
14D10:  CLRF   xB6
14D12:  CLRF   xB5
14D14:  MOVFF  890,8B4
14D18:  MOVFF  88F,8B3
14D1C:  MOVWF  xB7
14D1E:  MOVLB  0
14D20:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14D24:  CALL   D088
14D28:  MOVFF  01,891
....................             break; 
14D2C:  BRA    14DEE
....................          case '-' : motor=1; 
14D2E:  MOVLW  01
14D30:  MOVLB  7
14D32:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14D34:  MOVLB  8
14D36:  CLRF   xB1
14D38:  MOVWF  xB2
14D3A:  CLRF   xB6
14D3C:  CLRF   xB5
14D3E:  MOVFF  890,8B4
14D42:  MOVFF  88F,8B3
14D46:  MOVWF  xB7
14D48:  MOVLB  0
14D4A:  CALL   9DB8
....................                     macro_status=step_err_status(); 
14D4E:  CALL   D088
14D52:  MOVFF  01,891
....................             break; 
14D56:  BRA    14DEE
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
14D58:  MOVFF  88F,8A0
14D5C:  CALL   D93C
....................                     macro_status = 'a';  
14D60:  MOVLW  61
14D62:  MOVLB  8
14D64:  MOVWF  x91
....................             break;          
14D66:  MOVLB  0
14D68:  BRA    14DEE
....................          case 'D' : delay_sec(macro_arg); 
14D6A:  MOVFF  890,8AD
14D6E:  MOVFF  88F,8AC
14D72:  CALL   D0C0
....................                     macro_status = 'a'; 
14D76:  MOVLW  61
14D78:  MOVLB  8
14D7A:  MOVWF  x91
....................             break; 
14D7C:  MOVLB  0
14D7E:  BRA    14DEE
....................          case 'P' : sol_switch(mmacro_var); 
14D80:  MOVFF  88A,89F
14D84:  CALL   1419E
....................                     macro_status = 'a'; 
14D88:  MOVLW  61
14D8A:  MOVLB  8
14D8C:  MOVWF  x91
....................             break;              
14D8E:  MOVLB  0
14D90:  BRA    14DEE
....................          case 'Q' : sol_switch(macro_arg); 
14D92:  MOVFF  88F,89F
14D96:  CALL   1419E
....................                     macro_status = 'a'; 
14D9A:  MOVLW  61
14D9C:  MOVLB  8
14D9E:  MOVWF  x91
....................             break;             
14DA0:  MOVLB  0
14DA2:  BRA    14DEE
....................          case 'S' : sol_switch_cmd(macro_arg); 
14DA4:  MOVFF  890,8A1
14DA8:  MOVFF  88F,8A0
14DAC:  CALL   140E8
....................                     macro_status = 'a'; 
14DB0:  MOVLW  61
14DB2:  MOVLB  8
14DB4:  MOVWF  x91
....................             break; 
14DB6:  MOVLB  0
14DB8:  BRA    14DEE
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14DBA:  MOVLB  8
14DBC:  DECFSZ x8F,W
14DBE:  BRA    14DCE
14DC0:  MOVF   x90,F
14DC2:  BNZ   14DCE
14DC4:  MOVLB  0
14DC6:  CALL   D0F6
14DCA:  BRA    14DDC
14DCC:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14DCE:  MOVF   x8F,F
14DD0:  BNZ   14DDE
14DD2:  MOVF   x90,F
14DD4:  BNZ   14DDE
14DD6:  MOVLB  0
14DD8:  CALL   D11A
14DDC:  MOVLB  8
....................                     macro_status = 'a'; 
14DDE:  MOVLW  61
14DE0:  MOVWF  x91
....................             break;               
14DE2:  MOVLB  0
14DE4:  BRA    14DEE
....................          case ';' : macro_status = 'f'; 
14DE6:  MOVLW  66
14DE8:  MOVLB  8
14DEA:  MOVWF  x91
....................             break;            
14DEC:  MOVLB  0
14DEE:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
14DF0:  MOVFF  891,01
14DF4:  MOVLB  0
14DF6:  GOTO   15106 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
14FD4:  MOVLB  8
14FD6:  CLRF   x54
14FD8:  CLRF   x53
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
14FDA:  MOVLB  0
14FDC:  CALL   513E
....................    clear_data_arrays(); 
14FE0:  GOTO   1028E
....................     
....................    line = 0;  
14FE4:  MOVLB  8
14FE6:  CLRF   x85
14FE8:  CLRF   x84
....................    macro_status = 'a'; 
14FEA:  MOVLW  61
14FEC:  MOVWF  x86
....................    data_available = FALSE; 
14FEE:  MOVLB  3
14FF0:  CLRF   x37
....................    macro_flag = 900; 
14FF2:  MOVLW  03
14FF4:  MOVWF  x20
14FF6:  MOVLW  84
14FF8:  MOVWF  x1F
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
14FFA:  MOVLW  01
14FFC:  MOVWF  1E
14FFE:  MOVLW  A3
15000:  MOVWF  1D
15002:  MOVLW  68
15004:  MOVWF  FF6
15006:  MOVLW  21
15008:  MOVWF  FF7
1500A:  MOVLW  00
1500C:  MOVWF  FF8
1500E:  MOVLW  07
15010:  MOVLB  8
15012:  MOVWF  xD5
15014:  MOVLB  0
15016:  CALL   AB04
1501A:  MOVFF  881,8D7
1501E:  MOVLW  1B
15020:  MOVLB  8
15022:  MOVWF  xD8
15024:  MOVLB  0
15026:  CALL   52D8
1502A:  MOVLW  71
1502C:  MOVWF  FF6
1502E:  MOVLW  21
15030:  MOVWF  FF7
15032:  MOVLW  00
15034:  MOVWF  FF8
15036:  MOVLW  09
15038:  MOVLB  8
1503A:  MOVWF  xD5
1503C:  MOVLB  0
1503E:  CALL   AB04
....................    record_event();    
15042:  CALL   851A
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
15046:  MOVLB  8
15048:  MOVF   x85,W
1504A:  SUBLW  03
1504C:  BNC   1511E
1504E:  MOVF   x86,W
15050:  SUBLW  61
15052:  BNZ   1511E
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
15054:  MOVF   1F,W
15056:  SUBLW  04
15058:  BNZ   150EC
1505A:  MOVF   20,F
1505C:  BNZ   150EC
....................                                                macro_status, (line + 1)); 
1505E:  MOVLW  01
15060:  ADDWF  x84,W
15062:  MOVWF  x87
15064:  MOVLW  00
15066:  ADDWFC x85,W
15068:  MOVWF  x88
1506A:  MOVLW  7C
1506C:  MOVWF  FF6
1506E:  MOVLW  21
15070:  MOVWF  FF7
15072:  MOVLW  00
15074:  MOVWF  FF8
15076:  CLRF   1B
15078:  BTFSC  FF2.7
1507A:  BSF    1B.7
1507C:  BCF    FF2.7
1507E:  MOVLW  05
15080:  MOVLB  A
15082:  MOVWF  x25
15084:  MOVLB  0
15086:  CALL   101E
1508A:  BTFSC  1B.7
1508C:  BSF    FF2.7
1508E:  MOVLB  8
15090:  MOVF   x86,W
15092:  BTFSS  F9E.4
15094:  BRA    15092
15096:  MOVWF  FAD
15098:  MOVLW  5D
1509A:  BTFSS  F9E.4
1509C:  BRA    1509A
1509E:  MOVWF  FAD
150A0:  MOVLW  5B
150A2:  BTFSS  F9E.4
150A4:  BRA    150A2
150A6:  MOVWF  FAD
150A8:  MOVLW  10
150AA:  MOVWF  FE9
150AC:  CLRF   1B
150AE:  BTFSC  FF2.7
150B0:  BSF    1B.7
150B2:  BCF    FF2.7
150B4:  MOVFF  888,A26
150B8:  MOVFF  887,A25
150BC:  MOVLB  0
150BE:  CALL   11A0
150C2:  BTFSC  1B.7
150C4:  BSF    FF2.7
150C6:  MOVLW  88
150C8:  MOVWF  FF6
150CA:  MOVLW  21
150CC:  MOVWF  FF7
150CE:  MOVLW  00
150D0:  MOVWF  FF8
150D2:  CLRF   1B
150D4:  BTFSC  FF2.7
150D6:  BSF    1B.7
150D8:  BCF    FF2.7
150DA:  MOVLW  03
150DC:  MOVLB  A
150DE:  MOVWF  x25
150E0:  MOVLB  0
150E2:  CALL   101E
150E6:  BTFSC  1B.7
150E8:  BSF    FF2.7
150EA:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
150EC:  MOVFF  881,887
150F0:  MOVLW  08
150F2:  MOVWF  x89
150F4:  MOVLW  84
150F6:  MOVWF  x88
150F8:  MOVFF  883,88B
150FC:  MOVFF  882,88A
15100:  MOVLB  0
15102:  GOTO   14626
15106:  MOVFF  01,886
....................       ++line; 
1510A:  MOVLB  8
1510C:  INCF   x84,F
1510E:  BTFSC  FD8.2
15110:  INCF   x85,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
15112:  DECFSZ 4C,W
15114:  BRA    1511C
....................          macro_status = 'g'; 
15116:  MOVLW  67
15118:  MOVWF  x86
....................          break;    
1511A:  BRA    1511E
....................       } 
1511C:  BRA    15048
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
1511E:  MOVF   2F,W
15120:  MOVWF  00
15122:  MOVF   30,W
15124:  MOVWF  03
15126:  MOVF   03,W
15128:  BNZ   15134
1512A:  MOVLW  01
1512C:  SUBWF  00,W
1512E:  MOVLB  0
15130:  BZ    15152
15132:  MOVLB  8
15134:  MOVF   03,W
15136:  BNZ   15142
15138:  MOVLW  03
1513A:  SUBWF  00,W
1513C:  MOVLB  0
1513E:  BZ    15152
15140:  MOVLB  8
15142:  MOVF   03,W
15144:  BNZ   15150
15146:  MOVLW  02
15148:  SUBWF  00,W
1514A:  MOVLB  0
1514C:  BZ    1515E
1514E:  MOVLB  8
15150:  BRA    1516E
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
15152:  MOVFF  881,887
15156:  CALL   D3C4
....................          break; 
1515A:  MOVLB  8
1515C:  BRA    1516E
....................       case AWS : store_aws_data(macro,mmacro_var); 
1515E:  MOVFF  881,887
15162:  MOVFF  883,889
15166:  MOVFF  882,888
1516A:  BRA    14EAA
....................          break; 
1516C:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
1516E:  MOVLW  61
15170:  SUBWF  x86,W
15172:  ADDLW  F9
15174:  BC    15260
15176:  ADDLW  07
15178:  MOVLB  0
1517A:  GOTO   1530C
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
1517E:  MOVLW  8C
15180:  MOVWF  FF6
15182:  MOVLW  21
15184:  MOVWF  FF7
15186:  MOVLW  00
15188:  MOVWF  FF8
1518A:  CLRF   1B
1518C:  BTFSC  FF2.7
1518E:  BSF    1B.7
15190:  BCF    FF2.7
15192:  CALL   0DCC
15196:  BTFSC  1B.7
15198:  BSF    FF2.7
....................          break; 
1519A:  MOVLB  8
1519C:  BRA    15260
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
1519E:  MOVLW  94
151A0:  MOVWF  FF6
151A2:  MOVLW  21
151A4:  MOVWF  FF7
151A6:  MOVLW  00
151A8:  MOVWF  FF8
151AA:  CLRF   1B
151AC:  BTFSC  FF2.7
151AE:  BSF    1B.7
151B0:  BCF    FF2.7
151B2:  CALL   0DCC
151B6:  BTFSC  1B.7
151B8:  BSF    FF2.7
....................          break; 
151BA:  MOVLB  8
151BC:  BRA    15260
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
151BE:  MOVLW  9C
151C0:  MOVWF  FF6
151C2:  MOVLW  21
151C4:  MOVWF  FF7
151C6:  MOVLW  00
151C8:  MOVWF  FF8
151CA:  CLRF   1B
151CC:  BTFSC  FF2.7
151CE:  BSF    1B.7
151D0:  BCF    FF2.7
151D2:  CALL   0DCC
151D6:  BTFSC  1B.7
151D8:  BSF    FF2.7
....................          break; 
151DA:  MOVLB  8
151DC:  BRA    15260
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
151DE:  MOVLW  A4
151E0:  MOVWF  FF6
151E2:  MOVLW  21
151E4:  MOVWF  FF7
151E6:  MOVLW  00
151E8:  MOVWF  FF8
151EA:  CLRF   1B
151EC:  BTFSC  FF2.7
151EE:  BSF    1B.7
151F0:  BCF    FF2.7
151F2:  CALL   0DCC
151F6:  BTFSC  1B.7
151F8:  BSF    FF2.7
....................          break; 
151FA:  MOVLB  8
151FC:  BRA    15260
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
151FE:  MOVLW  AC
15200:  MOVWF  FF6
15202:  MOVLW  21
15204:  MOVWF  FF7
15206:  MOVLW  00
15208:  MOVWF  FF8
1520A:  CLRF   1B
1520C:  BTFSC  FF2.7
1520E:  BSF    1B.7
15210:  BCF    FF2.7
15212:  CALL   0DCC
15216:  BTFSC  1B.7
15218:  BSF    FF2.7
....................          break;    
1521A:  MOVLB  8
1521C:  BRA    15260
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
1521E:  MOVLW  B4
15220:  MOVWF  FF6
15222:  MOVLW  21
15224:  MOVWF  FF7
15226:  MOVLW  00
15228:  MOVWF  FF8
1522A:  CLRF   1B
1522C:  BTFSC  FF2.7
1522E:  BSF    1B.7
15230:  BCF    FF2.7
15232:  CALL   0DCC
15236:  BTFSC  1B.7
15238:  BSF    FF2.7
....................          break;    
1523A:  MOVLB  8
1523C:  BRA    15260
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
1523E:  MOVLW  BC
15240:  MOVWF  FF6
15242:  MOVLW  21
15244:  MOVWF  FF7
15246:  MOVLW  00
15248:  MOVWF  FF8
1524A:  CLRF   1B
1524C:  BTFSC  FF2.7
1524E:  BSF    1B.7
15250:  BCF    FF2.7
15252:  CALL   0DCC
15256:  BTFSC  1B.7
15258:  BSF    FF2.7
....................          break;           
1525A:  MOVLB  8
1525C:  BRA    15260
1525E:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
15260:  MOVLW  01
15262:  MOVWF  1E
15264:  MOVLW  A3
15266:  MOVWF  1D
15268:  MOVLW  C4
1526A:  MOVWF  FF6
1526C:  MOVLW  21
1526E:  MOVWF  FF7
15270:  MOVLW  00
15272:  MOVWF  FF8
15274:  MOVLW  07
15276:  MOVWF  xD5
15278:  MOVLB  0
1527A:  CALL   AB04
1527E:  MOVFF  881,8D7
15282:  MOVLW  1B
15284:  MOVLB  8
15286:  MOVWF  xD8
15288:  MOVLB  0
1528A:  CALL   52D8
1528E:  MOVLW  CD
15290:  MOVWF  FF6
15292:  MOVLW  21
15294:  MOVWF  FF7
15296:  MOVLW  00
15298:  MOVWF  FF8
1529A:  MOVLW  09
1529C:  MOVLB  8
1529E:  MOVWF  xD5
152A0:  MOVLB  0
152A2:  CALL   AB04
152A6:  MOVFF  886,8E9
152AA:  CALL   50F6
152AE:  MOVLW  D8
152B0:  MOVWF  FF6
152B2:  MOVLW  21
152B4:  MOVWF  FF7
152B6:  MOVLW  00
152B8:  MOVWF  FF8
152BA:  MOVLW  07
152BC:  MOVLB  8
152BE:  MOVWF  xD5
152C0:  MOVLB  0
152C2:  CALL   AB04
152C6:  MOVLW  10
152C8:  MOVWF  FE9
152CA:  MOVFF  885,8E1
152CE:  MOVFF  884,8E0
152D2:  CALL   AB36
152D6:  MOVLW  E2
152D8:  MOVWF  FF6
152DA:  MOVLW  21
152DC:  MOVWF  FF7
152DE:  MOVLW  00
152E0:  MOVWF  FF8
152E2:  MOVLW  03
152E4:  MOVLB  8
152E6:  MOVWF  xD5
152E8:  MOVLB  0
152EA:  CALL   AB04
....................    record_event(); 
152EE:  CALL   851A
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
152F2:  MOVLB  8
152F4:  MOVF   x86,W
152F6:  SUBLW  66
152F8:  BZ    15308
152FA:  MOVF   x86,W
152FC:  SUBLW  67
152FE:  BZ    15308
15300:  MOVLB  0
15302:  CALL   AA98
15306:  MOVLB  8
15308:  MOVLB  0
1530A:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15B9C:  MOVLW  01
15B9E:  MOVLB  8
15BA0:  MOVWF  x79
....................    while (macro_batch == TRUE){ 
15BA2:  DECFSZ x79,W
15BA4:  BRA    15E2A
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15BA6:  MOVFF  38,9F7
15BAA:  MOVFF  37,9F6
15BAE:  MOVLB  9
15BB0:  CLRF   xF9
15BB2:  MOVLW  03
15BB4:  MOVWF  xF8
15BB6:  MOVLB  0
15BB8:  CALL   5D14
15BBC:  MOVF   01,W
15BBE:  MOVLB  7
15BC0:  ADDWF  xCD,W
15BC2:  MOVLB  8
15BC4:  MOVWF  x74
15BC6:  MOVF   02,W
15BC8:  MOVLB  7
15BCA:  ADDWFC xCE,W
15BCC:  MOVLB  8
15BCE:  MOVWF  x75
....................       init_ext_eeprom(); 
15BD0:  MOVLB  0
15BD2:  CALL   FFE8
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
15BD6:  MOVFF  875,8B6
15BDA:  MOVFF  874,8B5
15BDE:  CALL   1037C
15BE2:  MOVFF  01,876
....................       ++addr; 
15BE6:  MOVLB  8
15BE8:  INCF   x74,F
15BEA:  BTFSC  FD8.2
15BEC:  INCF   x75,F
....................       macro_arg = read16_ext_eeprom(addr); 
15BEE:  MOVFF  875,8AD
15BF2:  MOVFF  874,8AC
15BF6:  MOVLB  0
15BF8:  CALL   10490
15BFC:  MOVFF  02,878
15C00:  MOVFF  01,877
....................       ++addr; 
15C04:  MOVLB  8
15C06:  INCF   x74,F
15C08:  BTFSC  FD8.2
15C0A:  INCF   x75,F
....................       ++addr;      
15C0C:  INCF   x74,F
15C0E:  BTFSC  FD8.2
15C10:  INCF   x75,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
15C12:  MOVF   x76,W
15C14:  SUBLW  4D
15C16:  BTFSS  FD8.2
15C18:  BRA    15D42
15C1A:  MOVF   x77,F
15C1C:  BNZ   15C24
15C1E:  MOVF   x78,F
15C20:  BTFSC  FD8.2
15C22:  BRA    15D42
....................          { 
....................          RTC_reset_HT(); 
15C24:  MOVLB  0
15C26:  CALL   3514
....................          RTC_read(); 
15C2A:  CALL   33A6
....................          RTC_display(); 
15C2E:  CALL   E00C
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
15C32:  MOVLW  E6
15C34:  MOVWF  FF6
15C36:  MOVLW  21
15C38:  MOVWF  FF7
15C3A:  MOVLW  00
15C3C:  MOVWF  FF8
15C3E:  CLRF   1B
15C40:  BTFSC  FF2.7
15C42:  BSF    1B.7
15C44:  BCF    FF2.7
15C46:  MOVLW  09
15C48:  MOVLB  A
15C4A:  MOVWF  x25
15C4C:  MOVLB  0
15C4E:  CALL   101E
15C52:  BTFSC  1B.7
15C54:  BSF    FF2.7
15C56:  MOVLB  8
15C58:  MOVF   x76,W
15C5A:  BTFSS  F9E.4
15C5C:  BRA    15C5A
15C5E:  MOVWF  FAD
15C60:  MOVLW  10
15C62:  MOVWF  FE9
15C64:  CLRF   1B
15C66:  BTFSC  FF2.7
15C68:  BSF    1B.7
15C6A:  BCF    FF2.7
15C6C:  MOVFF  878,A26
15C70:  MOVFF  877,A25
15C74:  MOVLB  0
15C76:  CALL   11A0
15C7A:  BTFSC  1B.7
15C7C:  BSF    FF2.7
15C7E:  MOVLW  F4
15C80:  MOVWF  FF6
15C82:  MOVLW  21
15C84:  MOVWF  FF7
15C86:  MOVLW  00
15C88:  MOVWF  FF8
15C8A:  CLRF   1B
15C8C:  BTFSC  FF2.7
15C8E:  BSF    1B.7
15C90:  BCF    FF2.7
15C92:  MOVLW  03
15C94:  MOVLB  A
15C96:  MOVWF  x25
15C98:  MOVLB  0
15C9A:  CALL   101E
15C9E:  BTFSC  1B.7
15CA0:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
15CA2:  MOVLW  01
15CA4:  ADDWF  21,W
15CA6:  MOVLB  8
15CA8:  MOVWF  x7A
15CAA:  MOVLW  00
15CAC:  ADDWFC 22,W
15CAE:  MOVWF  x7B
15CB0:  MOVLW  F8
15CB2:  MOVWF  FF6
15CB4:  MOVLW  21
15CB6:  MOVWF  FF7
15CB8:  MOVLW  00
15CBA:  MOVWF  FF8
15CBC:  CLRF   1B
15CBE:  BTFSC  FF2.7
15CC0:  BSF    1B.7
15CC2:  BCF    FF2.7
15CC4:  MOVLW  07
15CC6:  MOVLB  A
15CC8:  MOVWF  x25
15CCA:  MOVLB  0
15CCC:  CALL   101E
15CD0:  BTFSC  1B.7
15CD2:  BSF    FF2.7
15CD4:  MOVLW  09
15CD6:  MOVWF  FE9
15CD8:  CLRF   1B
15CDA:  BTFSC  FF2.7
15CDC:  BSF    1B.7
15CDE:  BCF    FF2.7
15CE0:  MOVFF  87B,A26
15CE4:  MOVFF  87A,A25
15CE8:  CALL   11A0
15CEC:  BTFSC  1B.7
15CEE:  BSF    FF2.7
15CF0:  MOVLW  04
15CF2:  MOVWF  FF6
15CF4:  MOVLW  22
15CF6:  MOVWF  FF7
15CF8:  MOVLW  00
15CFA:  MOVWF  FF8
15CFC:  CLRF   1B
15CFE:  BTFSC  FF2.7
15D00:  BSF    1B.7
15D02:  BCF    FF2.7
15D04:  MOVLW  04
15D06:  MOVLB  A
15D08:  MOVWF  x25
15D0A:  MOVLB  0
15D0C:  CALL   101E
15D10:  BTFSC  1B.7
15D12:  BSF    FF2.7
15D14:  MOVLW  09
15D16:  MOVWF  FE9
15D18:  CLRF   1B
15D1A:  BTFSC  FF2.7
15D1C:  BSF    1B.7
15D1E:  BCF    FF2.7
15D20:  MOVFF  28,A26
15D24:  MOVFF  27,A25
15D28:  CALL   11A0
15D2C:  BTFSC  1B.7
15D2E:  BSF    FF2.7
15D30:  MOVLW  0D
15D32:  BTFSS  F9E.4
15D34:  BRA    15D32
15D36:  MOVWF  FAD
15D38:  MOVLW  0A
15D3A:  BTFSS  F9E.4
15D3C:  BRA    15D3A
15D3E:  MOVWF  FAD
15D40:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
15D42:  MOVF   28,W
15D44:  SUBWF  22,W
15D46:  BNC   15D54
15D48:  BNZ   15D50
15D4A:  MOVF   27,W
15D4C:  SUBWF  21,W
15D4E:  BNC   15D54
....................          {macro_cmd = 'Z';} 
15D50:  MOVLW  5A
15D52:  MOVWF  x76
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
15D54:  MOVF   x76,W
15D56:  XORLW  72
15D58:  MOVLB  0
15D5A:  BZ    15D6E
15D5C:  XORLW  57
15D5E:  BZ    15D90
15D60:  XORLW  68
15D62:  BZ    15DC6
15D64:  XORLW  17
15D66:  BZ    15DFC
15D68:  XORLW  61
15D6A:  BZ    15E08
15D6C:  BRA    15E12
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
15D6E:  INCF   37,F
15D70:  BTFSC  FD8.2
15D72:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
15D74:  MOVLB  8
15D76:  CLRF   x5C
15D78:  CLRF   x5B
15D7A:  MOVFF  38,85A
15D7E:  MOVFF  37,859
....................                master_macro_loop_count = macro_arg; 
15D82:  CLRF   x58
15D84:  CLRF   x57
15D86:  MOVFF  878,856
15D8A:  MOVFF  877,855
....................             break; 
15D8E:  BRA    15E1E
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
15D90:  MOVLB  8
15D92:  MOVF   x58,F
15D94:  BNZ   15DA4
15D96:  MOVF   x57,F
15D98:  BNZ   15DA4
15D9A:  MOVF   x56,F
15D9C:  BNZ   15DA4
15D9E:  MOVF   x55,W
15DA0:  SUBLW  01
15DA2:  BC    15DBE
....................                   nv_macro_step = master_macro_loop_start; 
15DA4:  MOVFF  85A,38
15DA8:  MOVFF  859,37
....................                   master_macro_loop_count--; 
15DAC:  MOVLW  FF
15DAE:  ADDWF  x55,F
15DB0:  BTFSS  FD8.0
15DB2:  ADDWF  x56,F
15DB4:  BTFSS  FD8.0
15DB6:  ADDWF  x57,F
15DB8:  BTFSS  FD8.0
15DBA:  ADDWF  x58,F
....................                }else{ 
15DBC:  BRA    15DC4
....................                   nv_macro_step++; 
15DBE:  INCF   37,F
15DC0:  BTFSC  FD8.2
15DC2:  INCF   38,F
....................                } 
....................             break; 
15DC4:  BRA    15E1E
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
15DC6:  MOVLB  8
15DC8:  MOVF   x78,F
15DCA:  BNZ   15DFA
15DCC:  MOVF   x77,W
15DCE:  SUBLW  14
15DD0:  BNC   15DFA
....................                   play_macro(macro_arg,0);     // casts to int8 
15DD2:  MOVFF  877,881
15DD6:  CLRF   x83
15DD8:  CLRF   x82
15DDA:  MOVLB  0
15DDC:  CALL   14FD4
....................                   delay_ms(100); 
15DE0:  MOVLW  64
15DE2:  MOVLB  9
15DE4:  MOVWF  xD6
15DE6:  MOVLB  0
15DE8:  CALL   2972
....................                   ++nv_sample; 
15DEC:  INCF   21,F
15DEE:  BTFSC  FD8.2
15DF0:  INCF   22,F
....................                   ++nv_macro_step; 
15DF2:  INCF   37,F
15DF4:  BTFSC  FD8.2
15DF6:  INCF   38,F
15DF8:  MOVLB  8
....................                } 
....................                break; 
15DFA:  BRA    15E1E
....................             case 'Z' : ++nv_macro_step; 
15DFC:  INCF   37,F
15DFE:  BTFSC  FD8.2
15E00:  INCF   38,F
....................                        macro_batch = FALSE; 
15E02:  MOVLB  8
15E04:  CLRF   x79
....................                break; 
15E06:  BRA    15E1E
....................             case ';' : nv_macro_step = 0; 
15E08:  CLRF   38
15E0A:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
15E0C:  MOVLB  8
15E0E:  BRA    15E1E
15E10:  MOVLB  0
....................             default  : cmd_err(); 
15E12:  CALL   BD32
....................                        macro_cmd = 'e'; 
15E16:  MOVLW  65
15E18:  MOVLB  8
15E1A:  MOVWF  x76
....................                        macro_batch = FALSE; 
15E1C:  CLRF   x79
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
15E1E:  DECFSZ 4C,W
15E20:  BRA    15E28
....................             macro_cmd = ';'; 
15E22:  MOVLW  3B
15E24:  MOVWF  x76
....................             break;         // 17 = CTRL-Q (quit) 
15E26:  BRA    15E2A
....................          } 
15E28:  BRA    15BA2
....................    } 
....................    return (macro_cmd); 
15E2A:  MOVFF  876,01
15E2E:  MOVLB  0
15E30:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D130:  MOVLB  8
0D132:  MOVF   x76,W
0D134:  XORLW  2B
0D136:  MOVLB  0
0D138:  BZ    D168
0D13A:  XORLW  06
0D13C:  BZ    D190
0D13E:  XORLW  6F
0D140:  BZ    D1B8
0D142:  XORLW  05
0D144:  BZ    D1CA
0D146:  XORLW  17
0D148:  BZ    D1E0
0D14A:  XORLW  01
0D14C:  BZ    D210
0D14E:  XORLW  03
0D150:  BTFSC  FD8.2
0D152:  BRA    D238
0D154:  XORLW  06
0D156:  BTFSC  FD8.2
0D158:  BRA    D260
0D15A:  XORLW  0D
0D15C:  BTFSC  FD8.2
0D15E:  BRA    D274
0D160:  XORLW  62
0D162:  BTFSC  FD8.2
0D164:  BRA    D29C
0D166:  BRA    D2A4
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D168:  MOVLW  01
0D16A:  MOVLB  7
0D16C:  MOVWF  x3C
....................                  move_motor(0,0,macro_arg,1); 
0D16E:  MOVLB  8
0D170:  CLRF   xB1
0D172:  CLRF   xB2
0D174:  CLRF   xB6
0D176:  CLRF   xB5
0D178:  MOVFF  878,8B4
0D17C:  MOVFF  877,8B3
0D180:  MOVWF  xB7
0D182:  MOVLB  0
0D184:  CALL   9DB8
....................                  macro_status=step_err_status(); 
0D188:  RCALL  D088
0D18A:  MOVFF  01,879
....................          break; 
0D18E:  BRA    D2A4
....................       case '-' : motor=1; 
0D190:  MOVLW  01
0D192:  MOVLB  7
0D194:  MOVWF  x3C
....................                  move_motor(0,1,macro_arg,1); 
0D196:  MOVLB  8
0D198:  CLRF   xB1
0D19A:  MOVWF  xB2
0D19C:  CLRF   xB6
0D19E:  CLRF   xB5
0D1A0:  MOVFF  878,8B4
0D1A4:  MOVFF  877,8B3
0D1A8:  MOVWF  xB7
0D1AA:  MOVLB  0
0D1AC:  CALL   9DB8
....................                  macro_status=step_err_status(); 
0D1B0:  RCALL  D088
0D1B2:  MOVFF  01,879
....................          break; 
0D1B6:  BRA    D2A4
....................       case 'B' : h_bridge(macro_arg); 
0D1B8:  MOVFF  877,89F
0D1BC:  CALL   BFC2
....................                  macro_status = 'a'; 
0D1C0:  MOVLW  61
0D1C2:  MOVLB  8
0D1C4:  MOVWF  x79
....................          break; 
0D1C6:  MOVLB  0
0D1C8:  BRA    D2A4
....................       case 'G' : motor=0; 
0D1CA:  MOVLB  7
0D1CC:  CLRF   x3C
....................                  align(0); 
0D1CE:  MOVLB  8
0D1D0:  CLRF   xAC
0D1D2:  MOVLB  0
0D1D4:  CALL   A8F4
....................                  macro_status=step_err_status(); 
0D1D8:  RCALL  D088
0D1DA:  MOVFF  01,879
....................          break ;           
0D1DE:  BRA    D2A4
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D1E0:  MOVFF  878,2E
0D1E4:  MOVFF  877,2D
....................                  motor=0; 
0D1E8:  MOVLB  7
0D1EA:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1);   
0D1EC:  MOVLB  8
0D1EE:  CLRF   xB1
0D1F0:  CLRF   xB2
0D1F2:  CLRF   xB6
0D1F4:  CLRF   xB5
0D1F6:  MOVFF  878,8B4
0D1FA:  MOVFF  877,8B3
0D1FE:  MOVLW  01
0D200:  MOVWF  xB7
0D202:  MOVLB  0
0D204:  CALL   9DB8
....................                  macro_status=step_err_status(); 
0D208:  RCALL  D088
0D20A:  MOVFF  01,879
....................          break; 
0D20E:  BRA    D2A4
....................       case 'Q' : motor=0; 
0D210:  MOVLB  7
0D212:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1); 
0D214:  MOVLB  8
0D216:  CLRF   xB1
0D218:  CLRF   xB2
0D21A:  CLRF   xB6
0D21C:  CLRF   xB5
0D21E:  MOVFF  878,8B4
0D222:  MOVFF  877,8B3
0D226:  MOVLW  01
0D228:  MOVWF  xB7
0D22A:  MOVLB  0
0D22C:  CALL   9DB8
....................                  macro_status=step_err_status(); 
0D230:  RCALL  D088
0D232:  MOVFF  01,879
....................          break; 
0D236:  BRA    D2A4
....................       case 'R' : motor=0; 
0D238:  MOVLB  7
0D23A:  CLRF   x3C
....................                  move_motor(0,1,macro_arg,1); 
0D23C:  MOVLB  8
0D23E:  CLRF   xB1
0D240:  MOVLW  01
0D242:  MOVWF  xB2
0D244:  CLRF   xB6
0D246:  CLRF   xB5
0D248:  MOVFF  878,8B4
0D24C:  MOVFF  877,8B3
0D250:  MOVWF  xB7
0D252:  MOVLB  0
0D254:  CALL   9DB8
....................                  macro_status=step_err_status(); 
0D258:  RCALL  D088
0D25A:  MOVFF  01,879
....................          break; 
0D25E:  BRA    D2A4
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D260:  MOVFF  878,8AD
0D264:  MOVFF  877,8AC
0D268:  RCALL  D0C0
....................                  macro_status = 'a'; 
0D26A:  MOVLW  61
0D26C:  MOVLB  8
0D26E:  MOVWF  x79
....................          break; 
0D270:  MOVLB  0
0D272:  BRA    D2A4
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D274:  MOVLB  8
0D276:  DECFSZ x77,W
0D278:  BRA    D286
0D27A:  MOVF   x78,F
0D27C:  BNZ   D286
0D27E:  MOVLB  0
0D280:  RCALL  D0F6
0D282:  BRA    D292
0D284:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D286:  MOVF   x77,F
0D288:  BNZ   D294
0D28A:  MOVF   x78,F
0D28C:  BNZ   D294
0D28E:  MOVLB  0
0D290:  RCALL  D11A
0D292:  MOVLB  8
....................                  macro_status = 'a'; 
0D294:  MOVLW  61
0D296:  MOVWF  x79
....................          break;           
0D298:  MOVLB  0
0D29A:  BRA    D2A4
....................       case ';' : macro_status = 'f'; 
0D29C:  MOVLW  66
0D29E:  MOVLB  8
0D2A0:  MOVWF  x79
....................          break;            
0D2A2:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D2A4:  MOVLB  8
0D2A6:  MOVFF  879,01
0D2AA:  MOVLB  0
0D2AC:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D586:  MOVF   2E,F
0D588:  BNZ   D590
0D58A:  MOVF   2D,W
0D58C:  SUBLW  01
0D58E:  BC    D5A2
0D590:  MOVF   2E,F
0D592:  BNZ   D5A2
0D594:  MOVF   2D,W
0D596:  SUBLW  30
0D598:  BNC   D5A2
0D59A:  DECFSZ 2F,W
0D59C:  BRA    D5A2
0D59E:  MOVF   30,F
0D5A0:  BZ    D5C0
0D5A2:  MOVF   2E,F
0D5A4:  BNZ   D5AC
0D5A6:  MOVF   2D,W
0D5A8:  SUBLW  01
0D5AA:  BC    D5CA
0D5AC:  MOVF   2E,F
0D5AE:  BNZ   D5CA
0D5B0:  MOVF   2D,W
0D5B2:  SUBLW  32
0D5B4:  BNC   D5CA
0D5B6:  MOVF   2F,W
0D5B8:  SUBLW  03
0D5BA:  BNZ   D5CA
0D5BC:  MOVF   30,F
0D5BE:  BNZ   D5CA
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D5C0:  MOVLW  61
0D5C2:  MOVLB  8
0D5C4:  MOVWF  x75
....................    } 
0D5C6:  BRA    D5D2
0D5C8:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D5CA:  MOVLW  65
0D5CC:  MOVLB  8
0D5CE:  MOVWF  x75
....................       goto end_macro;       
0D5D0:  BRA    D682
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D5D2:  MOVLW  59
0D5D4:  MOVWF  x76
0D5D6:  CLRF   x78
0D5D8:  MOVLW  01
0D5DA:  MOVWF  x77
0D5DC:  MOVLB  0
0D5DE:  RCALL  D130
0D5E0:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D5E4:  MOVLB  8
0D5E6:  MOVF   x75,W
0D5E8:  SUBLW  61
0D5EA:  BTFSS  FD8.2
0D5EC:  BRA    D682
....................    macro_status = play_wms_macro_cmd('G',1); 
0D5EE:  MOVLW  47
0D5F0:  MOVWF  x76
0D5F2:  CLRF   x78
0D5F4:  MOVLW  01
0D5F6:  MOVWF  x77
0D5F8:  MOVLB  0
0D5FA:  RCALL  D130
0D5FC:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D600:  MOVLB  8
0D602:  MOVF   x75,W
0D604:  SUBLW  61
0D606:  BTFSS  FD8.2
0D608:  BRA    D682
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D60A:  MOVLW  2D
0D60C:  MOVWF  x76
0D60E:  MOVFF  2C,878
0D612:  MOVFF  2B,877
0D616:  MOVLB  0
0D618:  RCALL  D130
0D61A:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D61E:  MOVLB  8
0D620:  MOVF   x75,W
0D622:  SUBLW  61
0D624:  BTFSS  FD8.2
0D626:  BRA    D682
....................    macro_status = play_wms_macro_cmd('P',port); 
0D628:  MOVLW  50
0D62A:  MOVWF  x76
0D62C:  MOVFF  874,878
0D630:  MOVFF  873,877
0D634:  MOVLB  0
0D636:  RCALL  D130
0D638:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro;    
0D63C:  MOVLB  8
0D63E:  MOVF   x75,W
0D640:  SUBLW  61
0D642:  BTFSS  FD8.2
0D644:  BRA    D682
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D646:  MOVLW  2B
0D648:  MOVWF  x76
0D64A:  MOVFF  2C,878
0D64E:  MOVFF  2B,877
0D652:  MOVLB  0
0D654:  RCALL  D130
0D656:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D65A:  MOVLB  8
0D65C:  MOVF   x75,W
0D65E:  SUBLW  61
0D660:  BTFSS  FD8.2
0D662:  BRA    D682
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D664:  MOVLW  59
0D666:  MOVWF  x76
0D668:  CLRF   x78
0D66A:  CLRF   x77
0D66C:  MOVLB  0
0D66E:  RCALL  D130
0D670:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D674:  MOVLB  8
0D676:  MOVF   x75,W
0D678:  SUBLW  61
0D67A:  BTFSS  FD8.2
0D67C:  BRA    D682
....................    macro_status='f';  
0D67E:  MOVLW  66
0D680:  MOVWF  x75
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D682:  CLRF   x87
0D684:  MOVLB  0
0D686:  RCALL  D3C4
....................    
....................    switch(macro_status){ 
0D688:  MOVLW  61
0D68A:  MOVLB  8
0D68C:  SUBWF  x75,W
0D68E:  ADDLW  FA
0D690:  BC    D764
0D692:  ADDLW  06
0D694:  MOVLB  0
0D696:  GOTO   D768
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D69A:  MOVF   1F,F
0D69C:  BNZ   D6A2
0D69E:  MOVF   20,F
0D6A0:  BZ    D6BE
0D6A2:  MOVLW  10
0D6A4:  MOVWF  FF6
0D6A6:  MOVLW  22
0D6A8:  MOVWF  FF7
0D6AA:  MOVLW  00
0D6AC:  MOVWF  FF8
0D6AE:  CLRF   1B
0D6B0:  BTFSC  FF2.7
0D6B2:  BSF    1B.7
0D6B4:  BCF    FF2.7
0D6B6:  CALL   0DCC
0D6BA:  BTFSC  1B.7
0D6BC:  BSF    FF2.7
....................          break; 
0D6BE:  MOVLB  8
0D6C0:  BRA    D764
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D6C2:  MOVLW  18
0D6C4:  MOVWF  FF6
0D6C6:  MOVLW  22
0D6C8:  MOVWF  FF7
0D6CA:  MOVLW  00
0D6CC:  MOVWF  FF8
0D6CE:  CLRF   1B
0D6D0:  BTFSC  FF2.7
0D6D2:  BSF    1B.7
0D6D4:  BCF    FF2.7
0D6D6:  CALL   0DCC
0D6DA:  BTFSC  1B.7
0D6DC:  BSF    FF2.7
....................          break; 
0D6DE:  MOVLB  8
0D6E0:  BRA    D764
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D6E2:  MOVLW  20
0D6E4:  MOVWF  FF6
0D6E6:  MOVLW  22
0D6E8:  MOVWF  FF7
0D6EA:  MOVLW  00
0D6EC:  MOVWF  FF8
0D6EE:  CLRF   1B
0D6F0:  BTFSC  FF2.7
0D6F2:  BSF    1B.7
0D6F4:  BCF    FF2.7
0D6F6:  CALL   0DCC
0D6FA:  BTFSC  1B.7
0D6FC:  BSF    FF2.7
....................          break; 
0D6FE:  MOVLB  8
0D700:  BRA    D764
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D702:  MOVLW  28
0D704:  MOVWF  FF6
0D706:  MOVLW  22
0D708:  MOVWF  FF7
0D70A:  MOVLW  00
0D70C:  MOVWF  FF8
0D70E:  CLRF   1B
0D710:  BTFSC  FF2.7
0D712:  BSF    1B.7
0D714:  BCF    FF2.7
0D716:  CALL   0DCC
0D71A:  BTFSC  1B.7
0D71C:  BSF    FF2.7
....................          break; 
0D71E:  MOVLB  8
0D720:  BRA    D764
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D722:  MOVLW  30
0D724:  MOVWF  FF6
0D726:  MOVLW  22
0D728:  MOVWF  FF7
0D72A:  MOVLW  00
0D72C:  MOVWF  FF8
0D72E:  CLRF   1B
0D730:  BTFSC  FF2.7
0D732:  BSF    1B.7
0D734:  BCF    FF2.7
0D736:  CALL   0DCC
0D73A:  BTFSC  1B.7
0D73C:  BSF    FF2.7
....................          break;    
0D73E:  MOVLB  8
0D740:  BRA    D764
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D742:  MOVLW  38
0D744:  MOVWF  FF6
0D746:  MOVLW  22
0D748:  MOVWF  FF7
0D74A:  MOVLW  00
0D74C:  MOVWF  FF8
0D74E:  CLRF   1B
0D750:  BTFSC  FF2.7
0D752:  BSF    1B.7
0D754:  BCF    FF2.7
0D756:  CALL   0DCC
0D75A:  BTFSC  1B.7
0D75C:  BSF    FF2.7
....................          break;           
0D75E:  MOVLB  8
0D760:  BRA    D764
0D762:  MOVLB  8
....................    } 
0D764:  MOVLB  0
0D766:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
16072:  MOVLB  8
16074:  MOVF   x72,W
16076:  BTFSC  FD8.2
16078:  DECF   x73,F
1607A:  DECF   x72,F
....................    addr = macro_address[0] + (step*9); 
1607C:  MOVFF  873,9F7
16080:  MOVFF  872,9F6
16084:  MOVLB  9
16086:  CLRF   xF9
16088:  MOVLW  09
1608A:  MOVWF  xF8
1608C:  MOVLB  0
1608E:  CALL   5D14
16092:  MOVF   01,W
16094:  MOVLB  7
16096:  ADDWF  xCD,W
16098:  MOVLB  8
1609A:  MOVWF  x74
1609C:  MOVF   02,W
1609E:  MOVLB  7
160A0:  ADDWFC xCE,W
160A2:  MOVLB  8
160A4:  MOVWF  x75
....................     
....................    init_ext_eeprom(); 
160A6:  MOVLB  0
160A8:  CALL   FFE8
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
160AC:  MOVFF  875,8B6
160B0:  MOVFF  874,8B5
160B4:  CALL   1037C
160B8:  MOVFF  01,876
....................    ++addr; 
160BC:  MOVLB  8
160BE:  INCF   x74,F
160C0:  BTFSC  FD8.2
160C2:  INCF   x75,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
160C4:  MOVFF  875,8AD
160C8:  MOVFF  874,8AC
160CC:  MOVLB  0
160CE:  CALL   10490
160D2:  MOVFF  02,87A
160D6:  MOVFF  01,879
....................    ++addr; 
160DA:  MOVLB  8
160DC:  INCF   x74,F
160DE:  BTFSC  FD8.2
160E0:  INCF   x75,F
....................    ++addr; 
160E2:  INCF   x74,F
160E4:  BTFSC  FD8.2
160E6:  INCF   x75,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
160E8:  MOVFF  875,8B6
160EC:  MOVFF  874,8B5
160F0:  MOVLB  0
160F2:  CALL   1037C
160F6:  MOVFF  01,877
....................    ++addr; 
160FA:  MOVLB  8
160FC:  INCF   x74,F
160FE:  BTFSC  FD8.2
16100:  INCF   x75,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
16102:  MOVFF  875,8AD
16106:  MOVFF  874,8AC
1610A:  MOVLB  0
1610C:  CALL   10490
16110:  MOVFF  02,87C
16114:  MOVFF  01,87B
....................    ++addr; 
16118:  MOVLB  8
1611A:  INCF   x74,F
1611C:  BTFSC  FD8.2
1611E:  INCF   x75,F
....................    ++addr; 
16120:  INCF   x74,F
16122:  BTFSC  FD8.2
16124:  INCF   x75,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
16126:  MOVFF  875,8B6
1612A:  MOVFF  874,8B5
1612E:  MOVLB  0
16130:  CALL   1037C
16134:  MOVFF  01,878
....................    ++addr; 
16138:  MOVLB  8
1613A:  INCF   x74,F
1613C:  BTFSC  FD8.2
1613E:  INCF   x75,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
16140:  MOVFF  875,8AD
16144:  MOVFF  874,8AC
16148:  MOVLB  0
1614A:  CALL   10490
1614E:  MOVFF  02,87E
16152:  MOVFF  01,87D
....................    ++addr; 
16156:  MOVLB  8
16158:  INCF   x74,F
1615A:  BTFSC  FD8.2
1615C:  INCF   x75,F
....................    ++addr; 
1615E:  INCF   x74,F
16160:  BTFSC  FD8.2
16162:  INCF   x75,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16164:  MOVFF  875,8B6
16168:  MOVFF  874,8B5
1616C:  MOVLB  0
1616E:  CALL   1037C
16172:  MOVFF  01,87F
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
16176:  MOVLB  8
16178:  MOVF   x76,W
1617A:  SUBLW  4A
1617C:  BTFSS  FD8.2
1617E:  BRA    16254
16180:  MOVF   x77,W
16182:  SUBLW  50
16184:  BNZ   16254
16186:  MOVF   x78,W
16188:  SUBLW  4D
1618A:  BNZ   16254
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
1618C:  MOVF   x76,W
1618E:  BTFSS  F9E.4
16190:  BRA    1618E
16192:  MOVWF  FAD
16194:  MOVLW  10
16196:  MOVWF  FE9
16198:  CLRF   1B
1619A:  BTFSC  FF2.7
1619C:  BSF    1B.7
1619E:  BCF    FF2.7
161A0:  MOVFF  87A,A26
161A4:  MOVFF  879,A25
161A8:  MOVLB  0
161AA:  CALL   11A0
161AE:  BTFSC  1B.7
161B0:  BSF    FF2.7
161B2:  MOVLW  2C
161B4:  BTFSS  F9E.4
161B6:  BRA    161B4
161B8:  MOVWF  FAD
161BA:  MOVLB  8
161BC:  MOVF   x77,W
161BE:  BTFSS  F9E.4
161C0:  BRA    161BE
161C2:  MOVWF  FAD
161C4:  MOVLW  10
161C6:  MOVWF  FE9
161C8:  CLRF   1B
161CA:  BTFSC  FF2.7
161CC:  BSF    1B.7
161CE:  BCF    FF2.7
161D0:  MOVFF  87C,A26
161D4:  MOVFF  87B,A25
161D8:  MOVLB  0
161DA:  CALL   11A0
161DE:  BTFSC  1B.7
161E0:  BSF    FF2.7
161E2:  MOVLW  2C
161E4:  BTFSS  F9E.4
161E6:  BRA    161E4
161E8:  MOVWF  FAD
161EA:  MOVLB  8
161EC:  MOVF   x78,W
161EE:  BTFSS  F9E.4
161F0:  BRA    161EE
161F2:  MOVWF  FAD
161F4:  MOVLW  10
161F6:  MOVWF  FE9
161F8:  CLRF   1B
161FA:  BTFSC  FF2.7
161FC:  BSF    1B.7
161FE:  BCF    FF2.7
16200:  MOVFF  87E,A26
16204:  MOVFF  87D,A25
16208:  MOVLB  0
1620A:  CALL   11A0
1620E:  BTFSC  1B.7
16210:  BSF    FF2.7
16212:  MOVLW  0D
16214:  BTFSS  F9E.4
16216:  BRA    16214
16218:  MOVWF  FAD
1621A:  MOVLW  0A
1621C:  BTFSS  F9E.4
1621E:  BRA    1621C
16220:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
16222:  MOVFF  87A,24
16226:  MOVFF  879,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
1622A:  MOVLB  8
1622C:  MOVF   x7D,F
1622E:  BNZ   16234
16230:  MOVF   x7E,F
16232:  BZ    16252
16234:  MOVF   x7E,F
16236:  BNZ   16252
16238:  MOVF   x7D,W
1623A:  SUBLW  10
1623C:  BNC   16252
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
1623E:  MOVFF  87D,881
16242:  MOVFF  87C,883
16246:  MOVFF  87B,882
1624A:  MOVLB  0
1624C:  CALL   14FD4
16250:  MOVLB  8
....................       } 
....................    } 
16252:  BRA    16260
....................    else { 
....................       cmd_err(); 
16254:  MOVLB  0
16256:  CALL   BD32
....................       macro_end = 59; 
1625A:  MOVLW  3B
1625C:  MOVLB  8
1625E:  MOVWF  x7F
....................    } 
....................     
....................    return (macro_end); 
16260:  MOVFF  87F,01
16264:  MOVLB  0
16266:  GOTO   16350 (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
16452:  MOVLB  8
16454:  MOVF   x76,W
16456:  BTFSC  FD8.2
16458:  DECF   x77,F
1645A:  DECF   x76,F
....................    addr = macro_address[0] + (step*6); 
1645C:  MOVFF  877,9F7
16460:  MOVFF  876,9F6
16464:  MOVLB  9
16466:  CLRF   xF9
16468:  MOVLW  06
1646A:  MOVWF  xF8
1646C:  MOVLB  0
1646E:  CALL   5D14
16472:  MOVF   01,W
16474:  MOVLB  7
16476:  ADDWF  xCD,W
16478:  MOVLB  8
1647A:  MOVWF  x78
1647C:  MOVF   02,W
1647E:  MOVLB  7
16480:  ADDWFC xCE,W
16482:  MOVLB  8
16484:  MOVWF  x79
....................     
....................    init_ext_eeprom(); 
16486:  MOVLB  0
16488:  CALL   FFE8
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
1648C:  MOVFF  879,8B6
16490:  MOVFF  878,8B5
16494:  CALL   1037C
16498:  MOVFF  01,87A
....................    ++addr; 
1649C:  MOVLB  8
1649E:  INCF   x78,F
164A0:  BTFSC  FD8.2
164A2:  INCF   x79,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
164A4:  MOVFF  879,8AD
164A8:  MOVFF  878,8AC
164AC:  MOVLB  0
164AE:  CALL   10490
164B2:  MOVFF  02,87D
164B6:  MOVFF  01,87C
....................    ++addr; 
164BA:  MOVLB  8
164BC:  INCF   x78,F
164BE:  BTFSC  FD8.2
164C0:  INCF   x79,F
....................    ++addr; 
164C2:  INCF   x78,F
164C4:  BTFSC  FD8.2
164C6:  INCF   x79,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
164C8:  MOVFF  879,8B6
164CC:  MOVFF  878,8B5
164D0:  MOVLB  0
164D2:  CALL   1037C
164D6:  MOVFF  01,87B
....................    ++addr; 
164DA:  MOVLB  8
164DC:  INCF   x78,F
164DE:  BTFSC  FD8.2
164E0:  INCF   x79,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
164E2:  MOVFF  879,8AD
164E6:  MOVFF  878,8AC
164EA:  MOVLB  0
164EC:  CALL   10490
164F0:  MOVFF  02,87F
164F4:  MOVFF  01,87E
....................    ++addr; 
164F8:  MOVLB  8
164FA:  INCF   x78,F
164FC:  BTFSC  FD8.2
164FE:  INCF   x79,F
....................    ++addr; 
16500:  INCF   x78,F
16502:  BTFSC  FD8.2
16504:  INCF   x79,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16506:  MOVFF  879,8B6
1650A:  MOVFF  878,8B5
1650E:  MOVLB  0
16510:  CALL   1037C
16514:  MOVFF  01,880
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
16518:  MOVLB  8
1651A:  MOVF   x7A,W
1651C:  SUBLW  50
1651E:  BNZ   165C2
16520:  MOVF   x7B,W
16522:  SUBLW  4D
16524:  BNZ   165C2
....................        
....................       RTC_read(); 
16526:  MOVLB  0
16528:  CALL   33A6
....................       RTC_display(); 
1652C:  CALL   E00C
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
16530:  MOVLB  8
16532:  MOVF   x7A,W
16534:  BTFSS  F9E.4
16536:  BRA    16534
16538:  MOVWF  FAD
1653A:  MOVLW  10
1653C:  MOVWF  FE9
1653E:  CLRF   1B
16540:  BTFSC  FF2.7
16542:  BSF    1B.7
16544:  BCF    FF2.7
16546:  MOVFF  87D,A26
1654A:  MOVFF  87C,A25
1654E:  MOVLB  0
16550:  CALL   11A0
16554:  BTFSC  1B.7
16556:  BSF    FF2.7
16558:  MOVLW  2C
1655A:  BTFSS  F9E.4
1655C:  BRA    1655A
1655E:  MOVWF  FAD
16560:  MOVLB  8
16562:  MOVF   x7B,W
16564:  BTFSS  F9E.4
16566:  BRA    16564
16568:  MOVWF  FAD
1656A:  MOVLW  10
1656C:  MOVWF  FE9
1656E:  CLRF   1B
16570:  BTFSC  FF2.7
16572:  BSF    1B.7
16574:  BCF    FF2.7
16576:  MOVFF  87F,A26
1657A:  MOVFF  87E,A25
1657E:  MOVLB  0
16580:  CALL   11A0
16584:  BTFSC  1B.7
16586:  BSF    FF2.7
16588:  MOVLW  0D
1658A:  BTFSS  F9E.4
1658C:  BRA    1658A
1658E:  MOVWF  FAD
16590:  MOVLW  0A
16592:  BTFSS  F9E.4
16594:  BRA    16592
16596:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
16598:  MOVLB  8
1659A:  MOVF   x7E,F
1659C:  BNZ   165A2
1659E:  MOVF   x7F,F
165A0:  BZ    165C0
165A2:  MOVF   x7F,F
165A4:  BNZ   165C0
165A6:  MOVF   x7E,W
165A8:  SUBLW  10
165AA:  BNC   165C0
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
165AC:  MOVFF  87E,881
165B0:  MOVFF  87D,883
165B4:  MOVFF  87C,882
165B8:  MOVLB  0
165BA:  CALL   14FD4
165BE:  MOVLB  8
....................       } 
....................    } 
165C0:  BRA    165CE
....................    else { 
....................       cmd_err(); 
165C2:  MOVLB  0
165C4:  CALL   BD32
....................       macro_end = 59; 
165C8:  MOVLW  3B
165CA:  MOVLB  8
165CC:  MOVWF  x80
....................    } 
....................     
....................    return (macro_end); 
165CE:  MOVFF  880,01
165D2:  MOVLB  0
165D4:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
15E50:  MOVF   24,W
15E52:  SUBWF  36,W
15E54:  BTFSS  FD8.0
15E56:  BRA    1605E
15E58:  BNZ   15E62
15E5A:  MOVF   23,W
15E5C:  SUBWF  35,W
15E5E:  BTFSS  FD8.0
15E60:  BRA    1605E
15E62:  MOVF   33,F
15E64:  BTFSS  FD8.2
15E66:  BRA    1605E
15E68:  MOVF   34,F
15E6A:  BTFSS  FD8.2
15E6C:  BRA    1605E
....................       { 
....................          nv_elapsed = 0; 
15E6E:  CLRF   36
15E70:  CLRF   35
....................  
....................          init_hardware(); 
15E72:  CALL   299C
....................          sd_status = init_sdcard(); 
15E76:  CALL   5092
15E7A:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
15E7E:  MOVLB  2
15E80:  MOVF   xD8,F
15E82:  BZ    15E8C
15E84:  MOVLB  0
15E86:  CALL   50D8
15E8A:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
15E8C:  MOVLW  01
15E8E:  MOVWF  1E
15E90:  MOVLW  A3
15E92:  MOVWF  1D
15E94:  MOVLW  40
15E96:  MOVWF  FF6
15E98:  MOVLW  22
15E9A:  MOVWF  FF7
15E9C:  MOVLW  00
15E9E:  MOVWF  FF8
15EA0:  MOVLW  14
15EA2:  MOVLB  8
15EA4:  MOVWF  xD5
15EA6:  MOVLB  0
15EA8:  CALL   AB04
15EAC:  MOVLW  10
15EAE:  MOVWF  FE9
15EB0:  MOVFF  22,8E1
15EB4:  MOVFF  21,8E0
15EB8:  CALL   AB36
15EBC:  MOVLW  57
15EBE:  MOVWF  FF6
15EC0:  MOVLW  22
15EC2:  MOVWF  FF7
15EC4:  MOVLW  00
15EC6:  MOVWF  FF8
15EC8:  MOVLW  09
15ECA:  MOVLB  8
15ECC:  MOVWF  xD5
15ECE:  MOVLB  0
15ED0:  CALL   AB04
....................          record_event();          
15ED4:  CALL   851A
....................              
....................          macro_cmd = master_macro_eco(); 
15ED8:  RCALL  15B9C
15EDA:  MOVFF  01,871
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
15EDE:  MOVLW  16
15EE0:  MOVLB  8
15EE2:  MOVWF  xD8
15EE4:  MOVFF  22,8DA
15EE8:  MOVFF  21,8D9
15EEC:  MOVLB  0
15EEE:  CALL   502C
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
15EF2:  MOVLW  3A
15EF4:  MOVLB  8
15EF6:  MOVWF  xD8
15EF8:  MOVFF  38,8DA
15EFC:  MOVFF  37,8D9
15F00:  MOVLB  0
15F02:  CALL   502C
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
15F06:  DECFSZ 4C,W
15F08:  BRA    15F2C
....................          { 
....................             disable_interrupts (INT_EXT); 
15F0A:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
15F0C:  CLRF   32
15F0E:  MOVLW  01
15F10:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15F12:  MOVLW  02
15F14:  MOVLB  8
15F16:  MOVWF  x73
15F18:  MOVFF  31,874
15F1C:  MOVLB  0
15F1E:  CALL   3474
....................             busy_clear(); 
15F22:  CALL   AEAC
....................             return (user_quit); 
15F26:  MOVFF  4C,01
15F2A:  BRA    1606E
....................          } 
....................  
....................          motor_sleep_rdy(); 
15F2C:  CALL   29FA
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
15F30:  MOVLW  01
15F32:  MOVWF  1E
15F34:  MOVLW  A3
15F36:  MOVWF  1D
15F38:  MOVLW  62
15F3A:  MOVWF  FF6
15F3C:  MOVLW  22
15F3E:  MOVWF  FF7
15F40:  MOVLW  00
15F42:  MOVWF  FF8
15F44:  MOVLW  14
15F46:  MOVLB  8
15F48:  MOVWF  xD5
15F4A:  MOVLB  0
15F4C:  CALL   AB04
15F50:  MOVLW  10
15F52:  MOVWF  FE9
15F54:  MOVFF  22,8E1
15F58:  MOVFF  21,8E0
15F5C:  CALL   AB36
15F60:  MOVLW  79
15F62:  MOVWF  FF6
15F64:  MOVLW  22
15F66:  MOVWF  FF7
15F68:  MOVLW  00
15F6A:  MOVWF  FF8
15F6C:  MOVLW  0C
15F6E:  MOVLB  8
15F70:  MOVWF  xD5
15F72:  MOVLB  0
15F74:  CALL   AB04
....................          record_event();  
15F78:  CALL   851A
....................           
....................          if (macro_cmd == 'e') 
15F7C:  MOVLB  8
15F7E:  MOVF   x71,W
15F80:  SUBLW  65
15F82:  BNZ   15FD6
....................          { 
....................             disable_interrupts (INT_EXT); 
15F84:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
15F86:  MOVLW  01
15F88:  MOVWF  1E
15F8A:  MOVLW  A3
15F8C:  MOVWF  1D
15F8E:  MOVLW  86
15F90:  MOVWF  FF6
15F92:  MOVLW  22
15F94:  MOVWF  FF7
15F96:  MOVLW  00
15F98:  MOVWF  FF8
15F9A:  MOVLW  14
15F9C:  MOVWF  xD5
15F9E:  MOVLB  0
15FA0:  CALL   AB04
15FA4:  MOVLW  10
15FA6:  MOVWF  FE9
15FA8:  MOVFF  22,8E1
15FAC:  MOVFF  21,8E0
15FB0:  CALL   AB36
15FB4:  MOVLW  9D
15FB6:  MOVWF  FF6
15FB8:  MOVLW  22
15FBA:  MOVWF  FF7
15FBC:  MOVLW  00
15FBE:  MOVWF  FF8
15FC0:  MOVLW  09
15FC2:  MOVLB  8
15FC4:  MOVWF  xD5
15FC6:  MOVLB  0
15FC8:  CALL   AB04
....................             record_event();  
15FCC:  CALL   851A
....................             cmd_err(); 
15FD0:  CALL   BD32
15FD4:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
15FD6:  MOVF   28,W
15FD8:  SUBWF  22,W
15FDA:  BNC   16060
15FDC:  BNZ   15FE4
15FDE:  MOVF   27,W
15FE0:  SUBWF  21,W
15FE2:  BNC   16060
....................          { 
....................             disable_interrupts (INT_EXT); 
15FE4:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
15FE6:  MOVLW  01
15FE8:  MOVWF  1E
15FEA:  MOVLW  A3
15FEC:  MOVWF  1D
15FEE:  MOVLW  A8
15FF0:  MOVWF  FF6
15FF2:  MOVLW  22
15FF4:  MOVWF  FF7
15FF6:  MOVLW  00
15FF8:  MOVWF  FF8
15FFA:  MOVLW  14
15FFC:  MOVWF  xD5
15FFE:  MOVLB  0
16000:  CALL   AB04
16004:  MOVLW  10
16006:  MOVWF  FE9
16008:  MOVFF  22,8E1
1600C:  MOVFF  21,8E0
16010:  CALL   AB36
16014:  MOVLW  BF
16016:  MOVWF  FF6
16018:  MOVLW  22
1601A:  MOVWF  FF7
1601C:  MOVLW  00
1601E:  MOVWF  FF8
16020:  MOVLW  0F
16022:  MOVLB  8
16024:  MOVWF  xD5
16026:  MOVLB  0
16028:  CALL   AB04
....................             record_event();   
1602C:  CALL   851A
....................             msg_max(); 
16030:  RCALL  15E32
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
16032:  CLRF   34
16034:  MOVLW  01
16036:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
16038:  MOVLW  28
1603A:  MOVLB  8
1603C:  MOVWF  x73
1603E:  MOVFF  33,874
16042:  MOVLB  0
16044:  CALL   3474
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
16048:  CLRF   32
1604A:  MOVLW  01
1604C:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
1604E:  MOVLW  02
16050:  MOVLB  8
16052:  MOVWF  x73
16054:  MOVFF  31,874
16058:  MOVLB  0
1605A:  CALL   3474
1605E:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
16060:  MOVLB  0
16062:  RCALL  15AD6
16064:  BRA    15E50
....................    } 
....................     
....................    busy_clear(); 
16066:  CALL   AEAC
....................    return (user_quit); 
1606A:  MOVFF  4C,01
1606E:  GOTO   16992 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
1626A:  MOVF   24,W
1626C:  SUBWF  36,W
1626E:  BTFSS  FD8.0
16270:  BRA    16440
16272:  BNZ   1627C
16274:  MOVF   23,W
16276:  SUBWF  35,W
16278:  BTFSS  FD8.0
1627A:  BRA    16440
....................       { 
....................          nv_elapsed = 0; 
1627C:  CLRF   36
1627E:  CLRF   35
....................  
....................          init_hardware(); 
16280:  CALL   299C
....................          sd_status = init_sdcard(); 
16284:  CALL   5092
16288:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
1628C:  MOVLB  2
1628E:  MOVF   xD8,F
16290:  BZ    1629A
16292:  MOVLB  0
16294:  CALL   50D8
16298:  MOVLB  2
....................  
....................          ++nv_sample; 
1629A:  INCF   21,F
1629C:  BTFSC  FD8.2
1629E:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
162A0:  MOVLW  40
162A2:  BTFSS  F9E.4
162A4:  BRA    162A2
162A6:  MOVWF  FAD
162A8:  MOVLW  53
162AA:  BTFSS  F9E.4
162AC:  BRA    162AA
162AE:  MOVWF  FAD
162B0:  MOVLW  09
162B2:  MOVWF  FE9
162B4:  CLRF   1B
162B6:  BTFSC  FF2.7
162B8:  BSF    1B.7
162BA:  BCF    FF2.7
162BC:  MOVFF  22,A26
162C0:  MOVFF  21,A25
162C4:  MOVLB  0
162C6:  CALL   11A0
162CA:  BTFSC  1B.7
162CC:  BSF    FF2.7
162CE:  MOVLW  0D
162D0:  BTFSS  F9E.4
162D2:  BRA    162D0
162D4:  MOVWF  FAD
162D6:  MOVLW  0A
162D8:  BTFSS  F9E.4
162DA:  BRA    162D8
162DC:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
162DE:  MOVLW  01
162E0:  MOVWF  1E
162E2:  MOVLW  A3
162E4:  MOVWF  1D
162E6:  MOVLW  D0
162E8:  MOVWF  FF6
162EA:  MOVLW  22
162EC:  MOVWF  FF7
162EE:  MOVLW  00
162F0:  MOVWF  FF8
162F2:  MOVLW  14
162F4:  MOVLB  8
162F6:  MOVWF  xD5
162F8:  MOVLB  0
162FA:  CALL   AB04
162FE:  MOVLW  10
16300:  MOVWF  FE9
16302:  MOVFF  22,8E1
16306:  MOVFF  21,8E0
1630A:  CALL   AB36
1630E:  MOVLW  E7
16310:  MOVWF  FF6
16312:  MOVLW  22
16314:  MOVWF  FF7
16316:  MOVLW  00
16318:  MOVWF  FF8
1631A:  MOVLW  09
1631C:  MOVLB  8
1631E:  MOVWF  xD5
16320:  MOVLB  0
16322:  CALL   AB04
....................          record_event();   
16326:  CALL   851A
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
1632A:  MOVLW  16
1632C:  MOVLB  8
1632E:  MOVWF  xD8
16330:  MOVFF  22,8DA
16334:  MOVFF  21,8D9
16338:  MOVLB  0
1633A:  CALL   502C
....................  
....................          if (nv_macro_mode==TRUE) 
1633E:  DECFSZ 29,W
16340:  BRA    16356
16342:  MOVF   2A,F
16344:  BNZ   16356
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
16346:  MOVFF  22,873
1634A:  MOVFF  21,872
1634E:  BRA    16072
16350:  MOVFF  01,871
....................          } 
16354:  BRA    163BE
....................          else 
....................          { 
....................             time_stamp(); 
16356:  CALL   5472
....................             play_wms_hard_macro(nv_port); 
1635A:  MOVFF  2E,874
1635E:  MOVFF  2D,873
16362:  CALL   D586
....................             ++nv_port; 
16366:  INCF   2D,F
16368:  BTFSC  FD8.2
1636A:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
1636C:  MOVF   2E,F
1636E:  BNZ   16376
16370:  MOVF   2D,W
16372:  SUBLW  01
16374:  BC    16388
16376:  MOVF   2E,F
16378:  BNZ   16388
1637A:  MOVF   2D,W
1637C:  SUBLW  30
1637E:  BNC   16388
16380:  DECFSZ 2F,W
16382:  BRA    16388
16384:  MOVF   30,F
16386:  BZ    163A6
16388:  MOVF   2E,F
1638A:  BNZ   16392
1638C:  MOVF   2D,W
1638E:  SUBLW  01
16390:  BC    163BC
16392:  MOVF   2E,F
16394:  BNZ   163BC
16396:  MOVF   2D,W
16398:  SUBLW  32
1639A:  BNC   163BC
1639C:  MOVF   2F,W
1639E:  SUBLW  03
163A0:  BNZ   163BC
163A2:  MOVF   30,F
163A4:  BNZ   163BC
....................             { 
....................                write16(ADDR_PORT, nv_port);             
163A6:  MOVLW  24
163A8:  MOVLB  8
163AA:  MOVWF  xD8
163AC:  MOVFF  2E,8DA
163B0:  MOVFF  2D,8D9
163B4:  MOVLB  0
163B6:  CALL   502C
....................             } 
163BA:  BRA    163BE
....................             else disable_interrupts (INT_EXT); 
163BC:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
163BE:  DECFSZ 4C,W
163C0:  BRA    163E4
....................          { 
....................             disable_interrupts (INT_EXT); 
163C2:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
163C4:  CLRF   32
163C6:  MOVLW  01
163C8:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
163CA:  MOVLW  02
163CC:  MOVLB  8
163CE:  MOVWF  x73
163D0:  MOVFF  31,874
163D4:  MOVLB  0
163D6:  CALL   3474
....................             busy_clear(); 
163DA:  CALL   AEAC
....................             return (user_quit); 
163DE:  MOVFF  4C,01
163E2:  BRA    1644E
....................          } 
....................           
....................          motor_sleep_rdy(); 
163E4:  CALL   29FA
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
163E8:  MOVLW  01
163EA:  MOVWF  1E
163EC:  MOVLW  A3
163EE:  MOVWF  1D
163F0:  MOVLW  F2
163F2:  MOVWF  FF6
163F4:  MOVLW  22
163F6:  MOVWF  FF7
163F8:  MOVLW  00
163FA:  MOVWF  FF8
163FC:  MOVLW  14
163FE:  MOVLB  8
16400:  MOVWF  xD5
16402:  MOVLB  0
16404:  CALL   AB04
16408:  MOVLW  10
1640A:  MOVWF  FE9
1640C:  MOVFF  22,8E1
16410:  MOVFF  21,8E0
16414:  CALL   AB36
16418:  MOVLW  09
1641A:  MOVWF  FF6
1641C:  MOVLW  23
1641E:  MOVWF  FF7
16420:  MOVLW  00
16422:  MOVWF  FF8
16424:  MOVLW  0C
16426:  MOVLB  8
16428:  MOVWF  xD5
1642A:  MOVLB  0
1642C:  CALL   AB04
....................          record_event();  
16430:  CALL   851A
....................           
....................          if (macro_end == ';') 
16434:  MOVLB  8
16436:  MOVF   x71,W
16438:  SUBLW  3B
1643A:  BNZ   1643E
....................          { 
....................             disable_interrupts (INT_EXT); 
1643C:  BCF    FF2.4
1643E:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
16440:  CALL   15AD6
16444:  BRA    1626A
....................    } 
....................    busy_clear(); 
16446:  CALL   AEAC
....................    return (user_quit); 
1644A:  MOVFF  4C,01
1644E:  GOTO   1699A (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
165D6:  MOVF   24,W
165D8:  SUBWF  36,W
165DA:  BTFSS  FD8.0
165DC:  BRA    16796
165DE:  BNZ   165E8
165E0:  MOVF   23,W
165E2:  SUBWF  35,W
165E4:  BTFSS  FD8.0
165E6:  BRA    16796
....................       { 
....................          nv_elapsed = 0; 
165E8:  CLRF   36
165EA:  CLRF   35
....................  
....................          init_hardware(); 
165EC:  CALL   299C
....................          sd_status = init_sdcard(); 
165F0:  CALL   5092
165F4:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
165F8:  MOVLB  2
165FA:  MOVF   xD8,F
165FC:  BZ    16606
165FE:  MOVLB  0
16600:  CALL   50D8
16604:  MOVLB  2
....................  
....................          ++nv_sample; 
16606:  INCF   21,F
16608:  BTFSC  FD8.2
1660A:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
1660C:  MOVLW  40
1660E:  BTFSS  F9E.4
16610:  BRA    1660E
16612:  MOVWF  FAD
16614:  MOVLW  53
16616:  BTFSS  F9E.4
16618:  BRA    16616
1661A:  MOVWF  FAD
1661C:  MOVLW  09
1661E:  MOVWF  FE9
16620:  CLRF   1B
16622:  BTFSC  FF2.7
16624:  BSF    1B.7
16626:  BCF    FF2.7
16628:  MOVFF  22,A26
1662C:  MOVFF  21,A25
16630:  MOVLB  0
16632:  CALL   11A0
16636:  BTFSC  1B.7
16638:  BSF    FF2.7
1663A:  MOVLW  0D
1663C:  BTFSS  F9E.4
1663E:  BRA    1663C
16640:  MOVWF  FAD
16642:  MOVLW  0A
16644:  BTFSS  F9E.4
16646:  BRA    16644
16648:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
1664A:  MOVLW  01
1664C:  MOVWF  1E
1664E:  MOVLW  A3
16650:  MOVWF  1D
16652:  MOVLW  16
16654:  MOVWF  FF6
16656:  MOVLW  23
16658:  MOVWF  FF7
1665A:  MOVLW  00
1665C:  MOVWF  FF8
1665E:  MOVLW  14
16660:  MOVLB  8
16662:  MOVWF  xD5
16664:  MOVLB  0
16666:  CALL   AB04
1666A:  MOVLW  10
1666C:  MOVWF  FE9
1666E:  MOVFF  22,8E1
16672:  MOVFF  21,8E0
16676:  CALL   AB36
1667A:  MOVLW  2D
1667C:  MOVWF  FF6
1667E:  MOVLW  23
16680:  MOVWF  FF7
16682:  MOVLW  00
16684:  MOVWF  FF8
16686:  MOVLW  09
16688:  MOVLB  8
1668A:  MOVWF  xD5
1668C:  MOVLB  0
1668E:  CALL   AB04
....................          record_event();   
16692:  CALL   851A
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16696:  MOVLW  16
16698:  MOVLB  8
1669A:  MOVWF  xD8
1669C:  MOVFF  22,8DA
166A0:  MOVFF  21,8D9
166A4:  MOVLB  0
166A6:  CALL   502C
....................  
....................          macro_end = master_macro_aws(nv_sample); 
166AA:  MOVFF  22,877
166AE:  MOVFF  21,876
166B2:  RCALL  16452
166B4:  MOVFF  01,871
....................           
....................          if (user_quit == TRUE) 
166B8:  DECFSZ 4C,W
166BA:  BRA    166DE
....................          { 
....................             disable_interrupts (INT_EXT); 
166BC:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
166BE:  CLRF   32
166C0:  MOVLW  01
166C2:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
166C4:  MOVLW  02
166C6:  MOVLB  8
166C8:  MOVWF  x73
166CA:  MOVFF  31,874
166CE:  MOVLB  0
166D0:  CALL   3474
....................             busy_clear(); 
166D4:  CALL   AEAC
....................             return (user_quit); 
166D8:  MOVFF  4C,01
166DC:  BRA    167A8
....................          } 
....................           
....................          motor_sleep_rdy(); 
166DE:  CALL   29FA
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
166E2:  MOVLW  01
166E4:  MOVWF  1E
166E6:  MOVLW  A3
166E8:  MOVWF  1D
166EA:  MOVLW  38
166EC:  MOVWF  FF6
166EE:  MOVLW  23
166F0:  MOVWF  FF7
166F2:  MOVLW  00
166F4:  MOVWF  FF8
166F6:  MOVLW  14
166F8:  MOVLB  8
166FA:  MOVWF  xD5
166FC:  MOVLB  0
166FE:  CALL   AB04
16702:  MOVLW  10
16704:  MOVWF  FE9
16706:  MOVFF  22,8E1
1670A:  MOVFF  21,8E0
1670E:  CALL   AB36
16712:  MOVLW  4F
16714:  MOVWF  FF6
16716:  MOVLW  23
16718:  MOVWF  FF7
1671A:  MOVLW  00
1671C:  MOVWF  FF8
1671E:  MOVLW  0C
16720:  MOVLB  8
16722:  MOVWF  xD5
16724:  MOVLB  0
16726:  CALL   AB04
....................          record_event();  
1672A:  CALL   851A
....................           
....................          if (macro_end == ';') 
1672E:  MOVLB  8
16730:  MOVF   x71,W
16732:  SUBLW  3B
16734:  BNZ   16738
....................          { 
....................             disable_interrupts (INT_EXT); 
16736:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16738:  MOVF   28,W
1673A:  SUBWF  22,W
1673C:  BNC   16798
1673E:  BNZ   16746
16740:  MOVF   27,W
16742:  SUBWF  21,W
16744:  BNC   16798
....................          { 
....................             disable_interrupts (INT_EXT); 
16746:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16748:  MOVLW  01
1674A:  MOVWF  1E
1674C:  MOVLW  A3
1674E:  MOVWF  1D
16750:  MOVLW  5C
16752:  MOVWF  FF6
16754:  MOVLW  23
16756:  MOVWF  FF7
16758:  MOVLW  00
1675A:  MOVWF  FF8
1675C:  MOVLW  14
1675E:  MOVWF  xD5
16760:  MOVLB  0
16762:  CALL   AB04
16766:  MOVLW  10
16768:  MOVWF  FE9
1676A:  MOVFF  22,8E1
1676E:  MOVFF  21,8E0
16772:  CALL   AB36
16776:  MOVLW  73
16778:  MOVWF  FF6
1677A:  MOVLW  23
1677C:  MOVWF  FF7
1677E:  MOVLW  00
16780:  MOVWF  FF8
16782:  MOVLW  0F
16784:  MOVLB  8
16786:  MOVWF  xD5
16788:  MOVLB  0
1678A:  CALL   AB04
....................             record_event();   
1678E:  CALL   851A
....................             msg_max(); 
16792:  CALL   15E32
16796:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
16798:  MOVLB  0
1679A:  CALL   15AD6
1679E:  BRA    165D6
....................    } 
....................    busy_clear(); 
167A0:  CALL   AEAC
....................    return (user_quit); 
167A4:  MOVFF  4C,01
167A8:  GOTO   169A2 (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
167AC:  CALL   2A22
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
167B0:  MOVLW  01
167B2:  MOVWF  1E
167B4:  MOVLW  A3
167B6:  MOVWF  1D
167B8:  MOVLW  84
167BA:  MOVWF  FF6
167BC:  MOVLW  23
167BE:  MOVWF  FF7
167C0:  MOVLW  00
167C2:  MOVWF  FF8
167C4:  CALL   5116
....................    record_event(); 
167C8:  CALL   851A
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
167CC:  MOVLW  01
167CE:  MOVWF  1E
167D0:  MOVLW  A3
167D2:  MOVWF  1D
167D4:  MOVLW  9E
167D6:  MOVWF  FF6
167D8:  MOVLW  23
167DA:  MOVWF  FF7
167DC:  MOVLW  00
167DE:  MOVWF  FF8
167E0:  MOVLW  0C
167E2:  MOVLB  8
167E4:  MOVWF  xD5
167E6:  MOVLB  0
167E8:  CALL   AB04
167EC:  MOVLW  10
167EE:  MOVWF  FE9
167F0:  MOVFF  26,8E1
167F4:  MOVFF  25,8E0
167F8:  CALL   AB36
167FC:  MOVLW  AD
167FE:  MOVWF  FF6
16800:  MOVLW  23
16802:  MOVWF  FF7
16804:  MOVLW  00
16806:  MOVWF  FF8
16808:  MOVLW  06
1680A:  MOVLB  8
1680C:  MOVWF  xD5
1680E:  MOVLB  0
16810:  CALL   AB04
16814:  MOVLW  10
16816:  MOVWF  FE9
16818:  MOVFF  24,8E1
1681C:  MOVFF  23,8E0
16820:  CALL   AB36
16824:  MOVLW  B6
16826:  MOVWF  FF6
16828:  MOVLW  23
1682A:  MOVWF  FF7
1682C:  MOVLW  00
1682E:  MOVWF  FF8
16830:  MOVLW  06
16832:  MOVLB  8
16834:  MOVWF  xD5
16836:  MOVLB  0
16838:  CALL   AB04
1683C:  MOVLW  10
1683E:  MOVWF  FE9
16840:  MOVFF  28,8E1
16844:  MOVFF  27,8E0
16848:  CALL   AB36
1684C:  MOVLW  BF
1684E:  MOVWF  FF6
16850:  MOVLW  23
16852:  MOVWF  FF7
16854:  MOVLW  00
16856:  MOVWF  FF8
16858:  MOVLW  03
1685A:  MOVLB  8
1685C:  MOVWF  xD5
1685E:  MOVLB  0
16860:  CALL   AB04
....................    record_event(); 
16864:  CALL   851A
....................     
....................    user_quit = FALSE; 
16868:  CLRF   4C
....................     
....................    nv_cmd_mode = FALSE; 
1686A:  CLRF   32
1686C:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1686E:  MOVLW  02
16870:  MOVLB  8
16872:  MOVWF  x73
16874:  MOVFF  31,874
16878:  MOVLB  0
1687A:  CALL   3474
....................  
....................    RTC_set_AFE(); 
1687E:  GOTO   1533A
....................    // check if start is earlier than now 
....................    RTC_late(); 
16882:  CALL   15392
....................    // show clock 
....................    RTC_display(); 
16886:  CALL   E00C
....................    // show alarm 
....................    RTC_display_alarm(); 
1688A:  CALL   E26C
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
1688E:  CALL   1584C
....................  
....................    if (alarm_passed == FALSE){ 
16892:  BTFSC  49.3
16894:  BRA    16896
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
16896:  MOVLW  00
16898:  BTFSC  49.3
1689A:  MOVLW  01
1689C:  MOVLB  8
1689E:  MOVWF  x71
168A0:  MOVLW  01
168A2:  MOVWF  1E
168A4:  MOVLW  A3
168A6:  MOVWF  1D
168A8:  MOVLW  C4
168AA:  MOVWF  FF6
168AC:  MOVLW  23
168AE:  MOVWF  FF7
168B0:  MOVLW  00
168B2:  MOVWF  FF8
168B4:  MOVLW  14
168B6:  MOVWF  xD5
168B8:  MOVLB  0
168BA:  CALL   AB04
168BE:  MOVLW  10
168C0:  MOVWF  FE9
168C2:  MOVFF  22,8E1
168C6:  MOVFF  21,8E0
168CA:  CALL   AB36
168CE:  MOVLW  DB
168D0:  MOVWF  FF6
168D2:  MOVLW  23
168D4:  MOVWF  FF7
168D6:  MOVLW  00
168D8:  MOVWF  FF8
168DA:  MOVLW  08
168DC:  MOVLB  8
168DE:  MOVWF  xD5
168E0:  MOVLB  0
168E2:  CALL   AB04
168E6:  MOVFF  871,8D7
168EA:  MOVLW  1B
168EC:  MOVLB  8
168EE:  MOVWF  xD8
168F0:  MOVLB  0
168F2:  CALL   52D8
168F6:  MOVLW  E5
168F8:  MOVWF  FF6
168FA:  MOVLW  23
168FC:  MOVWF  FF7
168FE:  MOVLW  00
16900:  MOVWF  FF8
16902:  MOVLW  03
16904:  MOVLB  8
16906:  MOVWF  xD5
16908:  MOVLB  0
1690A:  CALL   AB04
....................    record_event();  
1690E:  CALL   851A
....................  
....................    while (TRUE == RTC_read_flags_running) 
16912:  BTFSS  49.2
16914:  BRA    16918
....................    { 
....................       ; 
16916:  BRA    16912
....................    } 
....................    RTC_read_flags_running = TRUE; 
16918:  BSF    49.2
1691A:  CLRF   1B
1691C:  BTFSC  FF2.7
1691E:  BSF    1B.7
16920:  BCF    FF2.7
....................    RTC_read_flags(); 
16922:  CALL   0DF6
16926:  BTFSC  1B.7
16928:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
1692A:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
1692C:  CALL   29FA
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
16930:  BTFSC  49.3
16932:  BRA    16954
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16934:  MOVLW  01
16936:  MOVWF  1E
16938:  MOVLW  A3
1693A:  MOVWF  1D
1693C:  MOVLW  EA
1693E:  MOVWF  FF6
16940:  MOVLW  23
16942:  MOVWF  FF7
16944:  MOVLW  00
16946:  MOVWF  FF8
16948:  CALL   5116
....................       record_event(); 
1694C:  CALL   851A
....................       go_to_sleep(); 
16950:  CALL   15AD6
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16954:  GOTO   15AEC
....................    nv_elapsed = nv_interval; 
16958:  MOVFF  24,36
1695C:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
16960:  MOVFF  2F,00
16964:  MOVF   30,W
16966:  MOVWF  03
16968:  BNZ   1696E
1696A:  MOVF   00,F
1696C:  BZ    1698E
1696E:  MOVF   03,W
16970:  BNZ   16978
16972:  MOVLW  01
16974:  SUBWF  00,W
16976:  BZ    16998
16978:  MOVF   03,W
1697A:  BNZ   16982
1697C:  MOVLW  03
1697E:  SUBWF  00,W
16980:  BZ    16998
16982:  MOVF   03,W
16984:  BNZ   1698C
16986:  MOVLW  02
16988:  SUBWF  00,W
1698A:  BZ    169A0
1698C:  BRA    169A6
....................       case ECO: user_quit = auto_sample_eco(); 
1698E:  GOTO   15E50
16992:  MOVFF  01,4C
....................          break; 
16996:  BRA    169A6
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
16998:  BRA    1626A
1699A:  MOVFF  01,4C
....................          break; 
1699E:  BRA    169A6
....................       case AWS: user_quit = auto_sample_aws(); 
169A0:  BRA    165D6
169A2:  MOVFF  01,4C
....................          break;          
....................    } 
....................    return(user_quit); 
169A6:  MOVFF  4C,01
169AA:  GOTO   16A9E (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BD02:  MOVF   44,F
0BD04:  BNZ   BD12
0BD06:  MOVF   45,F
0BD08:  BNZ   BD12
0BD0A:  MOVF   46,F
0BD0C:  BNZ   BD12
0BD0E:  MOVF   47,F
0BD10:  BZ    BD2A
0BD12:  MOVF   47,F
0BD14:  BNZ   BD2A
0BD16:  MOVF   46,F
0BD18:  BNZ   BD2A
0BD1A:  MOVF   45,F
0BD1C:  BNZ   BD2A
0BD1E:  MOVF   44,W
0BD20:  SUBLW  02
0BD22:  BNC   BD2A
....................       detector = arg; 
0BD24:  MOVFF  44,2D1
....................    } 
0BD28:  BRA    BD2E
....................    else cmd_arg(); 
0BD2A:  CALL   B070
0BD2E:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0BD50:  MOVF   44,F
0BD52:  BNZ   BD60
0BD54:  MOVF   45,F
0BD56:  BNZ   BD60
0BD58:  MOVF   46,F
0BD5A:  BNZ   BD60
0BD5C:  MOVF   47,F
0BD5E:  BZ    BDBA
0BD60:  MOVF   47,F
0BD62:  BNZ   BDBA
0BD64:  MOVF   46,W
0BD66:  SUBLW  00
0BD68:  BNC   BDBA
....................       switch (detector){ 
0BD6A:  MOVLB  2
0BD6C:  MOVF   xD1,W
0BD6E:  XORLW  01
0BD70:  MOVLB  0
0BD72:  BZ    BD7A
0BD74:  XORLW  03
0BD76:  BZ    BD98
0BD78:  BRA    BDB6
....................          case 1 : nv_d1_temp = arg; 
0BD7A:  MOVFF  45,3E
0BD7E:  MOVFF  44,3D
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0BD82:  MOVLW  40
0BD84:  MOVLB  8
0BD86:  MOVWF  xD8
0BD88:  MOVFF  3E,8DA
0BD8C:  MOVFF  3D,8D9
0BD90:  MOVLB  0
0BD92:  CALL   502C
....................             break; 
0BD96:  BRA    BDB8
....................          case 2 : nv_d2_temp = arg; 
0BD98:  MOVFF  45,40
0BD9C:  MOVFF  44,3F
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0BDA0:  MOVLW  42
0BDA2:  MOVLB  8
0BDA4:  MOVWF  xD8
0BDA6:  MOVFF  40,8DA
0BDAA:  MOVFF  3F,8D9
0BDAE:  MOVLB  0
0BDB0:  CALL   502C
....................             break; 
0BDB4:  BRA    BDB8
....................          default : cmd_err(); 
0BDB6:  RCALL  BD32
....................             break; 
....................       } 
....................    } 
0BDB8:  BRA    BE60
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0BDBA:  MOVF   44,F
0BDBC:  BNZ   BE5C
0BDBE:  MOVF   45,F
0BDC0:  BNZ   BE5C
0BDC2:  MOVF   46,F
0BDC4:  BNZ   BE5C
0BDC6:  MOVF   47,F
0BDC8:  BNZ   BE5C
0BDCA:  MOVLW  00
0BDCC:  MOVWF  FF6
0BDCE:  MOVLW  24
0BDD0:  MOVWF  FF7
0BDD2:  MOVLW  00
0BDD4:  MOVWF  FF8
0BDD6:  CLRF   1B
0BDD8:  BTFSC  FF2.7
0BDDA:  BSF    1B.7
0BDDC:  BCF    FF2.7
0BDDE:  MOVLW  03
0BDE0:  MOVLB  A
0BDE2:  MOVWF  x25
0BDE4:  MOVLB  0
0BDE6:  CALL   101E
0BDEA:  BTFSC  1B.7
0BDEC:  BSF    FF2.7
0BDEE:  MOVLW  10
0BDF0:  MOVWF  FE9
0BDF2:  CLRF   1B
0BDF4:  BTFSC  FF2.7
0BDF6:  BSF    1B.7
0BDF8:  BCF    FF2.7
0BDFA:  MOVFF  3E,A26
0BDFE:  MOVFF  3D,A25
0BE02:  CALL   11A0
0BE06:  BTFSC  1B.7
0BE08:  BSF    FF2.7
0BE0A:  MOVLW  06
0BE0C:  MOVWF  FF6
0BE0E:  MOVLW  24
0BE10:  MOVWF  FF7
0BE12:  MOVLW  00
0BE14:  MOVWF  FF8
0BE16:  CLRF   1B
0BE18:  BTFSC  FF2.7
0BE1A:  BSF    1B.7
0BE1C:  BCF    FF2.7
0BE1E:  MOVLW  04
0BE20:  MOVLB  A
0BE22:  MOVWF  x25
0BE24:  MOVLB  0
0BE26:  CALL   101E
0BE2A:  BTFSC  1B.7
0BE2C:  BSF    FF2.7
0BE2E:  MOVLW  10
0BE30:  MOVWF  FE9
0BE32:  CLRF   1B
0BE34:  BTFSC  FF2.7
0BE36:  BSF    1B.7
0BE38:  BCF    FF2.7
0BE3A:  MOVFF  40,A26
0BE3E:  MOVFF  3F,A25
0BE42:  CALL   11A0
0BE46:  BTFSC  1B.7
0BE48:  BSF    FF2.7
0BE4A:  MOVLW  0D
0BE4C:  BTFSS  F9E.4
0BE4E:  BRA    BE4C
0BE50:  MOVWF  FAD
0BE52:  MOVLW  0A
0BE54:  BTFSS  F9E.4
0BE56:  BRA    BE54
0BE58:  MOVWF  FAD
0BE5A:  BRA    BE60
....................    else cmd_arg(); 
0BE5C:  CALL   B070
0BE60:  GOTO   BEC6 (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0BE64:  MOVF   47,F
0BE66:  BNZ   BE94
0BE68:  MOVF   46,F
0BE6A:  BNZ   BE94
0BE6C:  MOVF   45,F
0BE6E:  BNZ   BE94
0BE70:  MOVF   44,W
0BE72:  SUBLW  01
0BE74:  BNC   BE94
....................       nv_macro_mode = arg; 
0BE76:  MOVFF  45,2A
0BE7A:  MOVFF  44,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0BE7E:  MOVLW  20
0BE80:  MOVLB  8
0BE82:  MOVWF  xD8
0BE84:  MOVFF  2A,8DA
0BE88:  MOVFF  29,8D9
0BE8C:  MOVLB  0
0BE8E:  CALL   502C
....................    } 
0BE92:  BRA    BE98
....................    else cmd_arg(); 
0BE94:  CALL   B070
0BE98:  GOTO   BEC6 (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0BE9C:  MOVF   2F,W
0BE9E:  MOVWF  00
0BEA0:  MOVF   30,W
0BEA2:  MOVWF  03
0BEA4:  BNZ   BEAA
0BEA6:  MOVF   00,F
0BEA8:  BZ    BEC0
0BEAA:  MOVF   03,W
0BEAC:  BNZ   BEB4
0BEAE:  MOVLW  01
0BEB0:  SUBWF  00,W
0BEB2:  BZ    BEC4
0BEB4:  MOVF   03,W
0BEB6:  BNZ   BEBE
0BEB8:  MOVLW  03
0BEBA:  SUBWF  00,W
0BEBC:  BZ    BEC4
0BEBE:  BRA    BEC6
....................       case ECO : commandAe(); 
0BEC0:  BRA    BD50
....................          break; 
0BEC2:  BRA    BEC6
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0BEC4:  BRA    BE64
....................          break; 
....................    } 
0BEC6:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0BECA:  MOVF   44,F
0BECC:  BNZ   BEDA
0BECE:  MOVF   45,F
0BED0:  BNZ   BEDA
0BED2:  MOVF   46,F
0BED4:  BNZ   BEDA
0BED6:  MOVF   47,F
0BED8:  BZ    BF0A
0BEDA:  MOVF   47,F
0BEDC:  BNZ   BF0A
0BEDE:  MOVF   46,F
0BEE0:  BNZ   BF0A
0BEE2:  MOVF   45,F
0BEE4:  BNZ   BF0A
0BEE6:  MOVF   44,W
0BEE8:  SUBLW  03
0BEEA:  BNC   BF0A
....................       nv_det_type = arg; 
0BEEC:  MOVFF  45,42
0BEF0:  MOVFF  44,41
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0BEF4:  MOVLW  26
0BEF6:  MOVLB  8
0BEF8:  MOVWF  xD8
0BEFA:  MOVFF  42,8DA
0BEFE:  MOVFF  41,8D9
0BF02:  MOVLB  0
0BF04:  CALL   502C
....................    } 
0BF08:  BRA    BF70
....................    else if(arg==0) { 
0BF0A:  MOVF   44,F
0BF0C:  BNZ   BF6C
0BF0E:  MOVF   45,F
0BF10:  BNZ   BF6C
0BF12:  MOVF   46,F
0BF14:  BNZ   BF6C
0BF16:  MOVF   47,F
0BF18:  BNZ   BF6C
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0BF1A:  MOVLW  10
0BF1C:  MOVWF  FF6
0BF1E:  MOVLW  24
0BF20:  MOVWF  FF7
0BF22:  MOVLW  00
0BF24:  MOVWF  FF8
0BF26:  CLRF   1B
0BF28:  BTFSC  FF2.7
0BF2A:  BSF    1B.7
0BF2C:  BCF    FF2.7
0BF2E:  MOVLW  05
0BF30:  MOVLB  A
0BF32:  MOVWF  x25
0BF34:  MOVLB  0
0BF36:  CALL   101E
0BF3A:  BTFSC  1B.7
0BF3C:  BSF    FF2.7
0BF3E:  MOVLW  10
0BF40:  MOVWF  FE9
0BF42:  CLRF   1B
0BF44:  BTFSC  FF2.7
0BF46:  BSF    1B.7
0BF48:  BCF    FF2.7
0BF4A:  MOVFF  42,A26
0BF4E:  MOVFF  41,A25
0BF52:  CALL   11A0
0BF56:  BTFSC  1B.7
0BF58:  BSF    FF2.7
0BF5A:  MOVLW  0D
0BF5C:  BTFSS  F9E.4
0BF5E:  BRA    BF5C
0BF60:  MOVWF  FAD
0BF62:  MOVLW  0A
0BF64:  BTFSS  F9E.4
0BF66:  BRA    BF64
0BF68:  MOVWF  FAD
....................    } 
0BF6A:  BRA    BF70
....................    else cmd_arg(); 
0BF6C:  CALL   B070
0BF70:  GOTO   C032 (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0BFE2:  MOVF   47,F
0BFE4:  BNZ   C000
0BFE6:  MOVF   46,F
0BFE8:  BNZ   C000
0BFEA:  MOVF   45,F
0BFEC:  BNZ   C000
0BFEE:  MOVF   44,W
0BFF0:  SUBLW  03
0BFF2:  BNC   C000
....................       hb_cmd=arg; 
0BFF4:  MOVFF  44,86F
....................       h_bridge(hb_cmd); 
0BFF8:  MOVFF  86F,89F
0BFFC:  RCALL  BFC2
....................    } 
0BFFE:  BRA    C004
....................    else cmd_arg(); 
0C000:  CALL   B070
0C004:  GOTO   C032 (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0C008:  MOVF   2F,W
0C00A:  MOVWF  00
0C00C:  MOVF   30,W
0C00E:  MOVWF  03
0C010:  BNZ   C016
0C012:  MOVF   00,F
0C014:  BZ    C02C
0C016:  MOVF   03,W
0C018:  BNZ   C020
0C01A:  MOVLW  01
0C01C:  SUBWF  00,W
0C01E:  BZ    C030
0C020:  MOVF   03,W
0C022:  BNZ   C02A
0C024:  MOVLW  03
0C026:  SUBWF  00,W
0C028:  BZ    C030
0C02A:  BRA    C032
....................       case ECO : commandBe(); 
0C02C:  BRA    BECA
....................          break; 
0C02E:  BRA    C032
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0C030:  BRA    BFE2
....................          break; 
....................    } 
0C032:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CB42:  MOVF   44,W
0CB44:  MOVWF  00
0CB46:  MOVF   45,W
0CB48:  MOVWF  03
0CB4A:  BNZ   CB50
0CB4C:  MOVF   00,F
0CB4E:  BZ    CBB2
0CB50:  MOVF   03,W
0CB52:  BNZ   CB5C
0CB54:  MOVLW  01
0CB56:  SUBWF  00,W
0CB58:  BTFSC  FD8.2
0CB5A:  BRA    CDA0
0CB5C:  MOVF   03,W
0CB5E:  BNZ   CB68
0CB60:  MOVLW  02
0CB62:  SUBWF  00,W
0CB64:  BTFSC  FD8.2
0CB66:  BRA    CDFC
0CB68:  MOVF   03,W
0CB6A:  BNZ   CB74
0CB6C:  MOVLW  03
0CB6E:  SUBWF  00,W
0CB70:  BTFSC  FD8.2
0CB72:  BRA    CE58
0CB74:  MOVF   03,W
0CB76:  BNZ   CB80
0CB78:  MOVLW  04
0CB7A:  SUBWF  00,W
0CB7C:  BTFSC  FD8.2
0CB7E:  BRA    CEB4
0CB80:  MOVF   03,W
0CB82:  BNZ   CB8C
0CB84:  MOVLW  05
0CB86:  SUBWF  00,W
0CB88:  BTFSC  FD8.2
0CB8A:  BRA    CF10
0CB8C:  MOVF   03,W
0CB8E:  BNZ   CB98
0CB90:  MOVLW  06
0CB92:  SUBWF  00,W
0CB94:  BTFSC  FD8.2
0CB96:  BRA    CF6C
0CB98:  MOVF   03,W
0CB9A:  BNZ   CBA4
0CB9C:  MOVLW  07
0CB9E:  SUBWF  00,W
0CBA0:  BTFSC  FD8.2
0CBA2:  BRA    CFC8
0CBA4:  MOVF   03,W
0CBA6:  BNZ   CBB0
0CBA8:  MOVLW  08
0CBAA:  SUBWF  00,W
0CBAC:  BTFSC  FD8.2
0CBAE:  BRA    D024
0CBB0:  BRA    D080
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CBB2:  MOVLW  1C
0CBB4:  MOVWF  FF6
0CBB6:  MOVLW  24
0CBB8:  MOVWF  FF7
0CBBA:  MOVLW  00
0CBBC:  MOVWF  FF8
0CBBE:  CLRF   1B
0CBC0:  BTFSC  FF2.7
0CBC2:  BSF    1B.7
0CBC4:  BCF    FF2.7
0CBC6:  MOVLW  04
0CBC8:  MOVLB  A
0CBCA:  MOVWF  x25
0CBCC:  MOVLB  0
0CBCE:  CALL   101E
0CBD2:  BTFSC  1B.7
0CBD4:  BSF    FF2.7
0CBD6:  MOVLW  89
0CBD8:  MOVWF  FE9
0CBDA:  MOVFF  3F4,872
0CBDE:  MOVFF  3F3,871
0CBE2:  MOVFF  3F2,870
0CBE6:  MOVFF  3F1,86F
0CBEA:  MOVLW  05
0CBEC:  MOVLB  8
0CBEE:  MOVWF  x73
0CBF0:  MOVLB  0
0CBF2:  RCALL  C41A
0CBF4:  MOVLW  2C
0CBF6:  BTFSS  F9E.4
0CBF8:  BRA    CBF6
0CBFA:  MOVWF  FAD
0CBFC:  MOVLW  89
0CBFE:  MOVWF  FE9
0CC00:  MOVFF  3F8,872
0CC04:  MOVFF  3F7,871
0CC08:  MOVFF  3F6,870
0CC0C:  MOVFF  3F5,86F
0CC10:  MOVLW  05
0CC12:  MOVLB  8
0CC14:  MOVWF  x73
0CC16:  MOVLB  0
0CC18:  RCALL  C41A
0CC1A:  MOVLW  0D
0CC1C:  BTFSS  F9E.4
0CC1E:  BRA    CC1C
0CC20:  MOVWF  FAD
0CC22:  MOVLW  0A
0CC24:  BTFSS  F9E.4
0CC26:  BRA    CC24
0CC28:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CC2A:  MOVLW  2E
0CC2C:  MOVWF  FF6
0CC2E:  MOVLW  24
0CC30:  MOVWF  FF7
0CC32:  MOVLW  00
0CC34:  MOVWF  FF8
0CC36:  CLRF   1B
0CC38:  BTFSC  FF2.7
0CC3A:  BSF    1B.7
0CC3C:  BCF    FF2.7
0CC3E:  MOVLW  04
0CC40:  MOVLB  A
0CC42:  MOVWF  x25
0CC44:  MOVLB  0
0CC46:  CALL   101E
0CC4A:  BTFSC  1B.7
0CC4C:  BSF    FF2.7
0CC4E:  MOVLW  89
0CC50:  MOVWF  FE9
0CC52:  MOVFF  3FC,872
0CC56:  MOVFF  3FB,871
0CC5A:  MOVFF  3FA,870
0CC5E:  MOVFF  3F9,86F
0CC62:  MOVLW  05
0CC64:  MOVLB  8
0CC66:  MOVWF  x73
0CC68:  MOVLB  0
0CC6A:  CALL   C41A
0CC6E:  MOVLW  2C
0CC70:  BTFSS  F9E.4
0CC72:  BRA    CC70
0CC74:  MOVWF  FAD
0CC76:  MOVLW  89
0CC78:  MOVWF  FE9
0CC7A:  MOVFF  400,872
0CC7E:  MOVFF  3FF,871
0CC82:  MOVFF  3FE,870
0CC86:  MOVFF  3FD,86F
0CC8A:  MOVLW  05
0CC8C:  MOVLB  8
0CC8E:  MOVWF  x73
0CC90:  MOVLB  0
0CC92:  CALL   C41A
0CC96:  MOVLW  0D
0CC98:  BTFSS  F9E.4
0CC9A:  BRA    CC98
0CC9C:  MOVWF  FAD
0CC9E:  MOVLW  0A
0CCA0:  BTFSS  F9E.4
0CCA2:  BRA    CCA0
0CCA4:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CCA6:  MOVLW  40
0CCA8:  MOVWF  FF6
0CCAA:  MOVLW  24
0CCAC:  MOVWF  FF7
0CCAE:  MOVLW  00
0CCB0:  MOVWF  FF8
0CCB2:  CLRF   1B
0CCB4:  BTFSC  FF2.7
0CCB6:  BSF    1B.7
0CCB8:  BCF    FF2.7
0CCBA:  MOVLW  04
0CCBC:  MOVLB  A
0CCBE:  MOVWF  x25
0CCC0:  MOVLB  0
0CCC2:  CALL   101E
0CCC6:  BTFSC  1B.7
0CCC8:  BSF    FF2.7
0CCCA:  MOVLW  89
0CCCC:  MOVWF  FE9
0CCCE:  MOVFF  404,872
0CCD2:  MOVFF  403,871
0CCD6:  MOVFF  402,870
0CCDA:  MOVFF  401,86F
0CCDE:  MOVLW  05
0CCE0:  MOVLB  8
0CCE2:  MOVWF  x73
0CCE4:  MOVLB  0
0CCE6:  CALL   C41A
0CCEA:  MOVLW  2C
0CCEC:  BTFSS  F9E.4
0CCEE:  BRA    CCEC
0CCF0:  MOVWF  FAD
0CCF2:  MOVLW  89
0CCF4:  MOVWF  FE9
0CCF6:  MOVFF  408,872
0CCFA:  MOVFF  407,871
0CCFE:  MOVFF  406,870
0CD02:  MOVFF  405,86F
0CD06:  MOVLW  05
0CD08:  MOVLB  8
0CD0A:  MOVWF  x73
0CD0C:  MOVLB  0
0CD0E:  CALL   C41A
0CD12:  MOVLW  0D
0CD14:  BTFSS  F9E.4
0CD16:  BRA    CD14
0CD18:  MOVWF  FAD
0CD1A:  MOVLW  0A
0CD1C:  BTFSS  F9E.4
0CD1E:  BRA    CD1C
0CD20:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CD22:  MOVLW  52
0CD24:  MOVWF  FF6
0CD26:  MOVLW  24
0CD28:  MOVWF  FF7
0CD2A:  MOVLW  00
0CD2C:  MOVWF  FF8
0CD2E:  CLRF   1B
0CD30:  BTFSC  FF2.7
0CD32:  BSF    1B.7
0CD34:  BCF    FF2.7
0CD36:  MOVLW  05
0CD38:  MOVLB  A
0CD3A:  MOVWF  x25
0CD3C:  MOVLB  0
0CD3E:  CALL   101E
0CD42:  BTFSC  1B.7
0CD44:  BSF    FF2.7
0CD46:  MOVLW  89
0CD48:  MOVWF  FE9
0CD4A:  MOVFF  40C,872
0CD4E:  MOVFF  40B,871
0CD52:  MOVFF  40A,870
0CD56:  MOVFF  409,86F
0CD5A:  MOVLW  05
0CD5C:  MOVLB  8
0CD5E:  MOVWF  x73
0CD60:  MOVLB  0
0CD62:  CALL   C41A
0CD66:  MOVLW  2C
0CD68:  BTFSS  F9E.4
0CD6A:  BRA    CD68
0CD6C:  MOVWF  FAD
0CD6E:  MOVLW  89
0CD70:  MOVWF  FE9
0CD72:  MOVFF  410,872
0CD76:  MOVFF  40F,871
0CD7A:  MOVFF  40E,870
0CD7E:  MOVFF  40D,86F
0CD82:  MOVLW  05
0CD84:  MOVLB  8
0CD86:  MOVWF  x73
0CD88:  MOVLB  0
0CD8A:  CALL   C41A
0CD8E:  MOVLW  0D
0CD90:  BTFSS  F9E.4
0CD92:  BRA    CD90
0CD94:  MOVWF  FAD
0CD96:  MOVLW  0A
0CD98:  BTFSS  F9E.4
0CD9A:  BRA    CD98
0CD9C:  MOVWF  FAD
....................                   break; 
0CD9E:  BRA    D084
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0CDA0:  MOVLW  66
0CDA2:  MOVWF  FF6
0CDA4:  MOVLW  24
0CDA6:  MOVWF  FF7
0CDA8:  MOVLW  00
0CDAA:  MOVWF  FF8
0CDAC:  CLRF   1B
0CDAE:  BTFSC  FF2.7
0CDB0:  BSF    1B.7
0CDB2:  BCF    FF2.7
0CDB4:  CALL   0DCC
0CDB8:  BTFSC  1B.7
0CDBA:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0CDBC:  RCALL  CA8E
0CDBE:  MOVFF  03,3F4
0CDC2:  MOVFF  02,3F3
0CDC6:  MOVFF  01,3F2
0CDCA:  MOVFF  00,3F1
....................                fprintf(COM_A,"\r\n");   
0CDCE:  MOVLW  0D
0CDD0:  BTFSS  F9E.4
0CDD2:  BRA    CDD0
0CDD4:  MOVWF  FAD
0CDD6:  MOVLW  0A
0CDD8:  BTFSS  F9E.4
0CDDA:  BRA    CDD8
0CDDC:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0CDDE:  MOVLB  8
0CDE0:  CLRF   x70
0CDE2:  MOVLW  44
0CDE4:  MOVWF  x6F
0CDE6:  MOVFF  3F4,874
0CDEA:  MOVFF  3F3,873
0CDEE:  MOVFF  3F2,872
0CDF2:  MOVFF  3F1,871
0CDF6:  MOVLB  0
0CDF8:  RCALL  CAD4
....................          break; 
0CDFA:  BRA    D084
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0CDFC:  MOVLW  6E
0CDFE:  MOVWF  FF6
0CE00:  MOVLW  24
0CE02:  MOVWF  FF7
0CE04:  MOVLW  00
0CE06:  MOVWF  FF8
0CE08:  CLRF   1B
0CE0A:  BTFSC  FF2.7
0CE0C:  BSF    1B.7
0CE0E:  BCF    FF2.7
0CE10:  CALL   0DCC
0CE14:  BTFSC  1B.7
0CE16:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0CE18:  RCALL  CA8E
0CE1A:  MOVFF  03,3F8
0CE1E:  MOVFF  02,3F7
0CE22:  MOVFF  01,3F6
0CE26:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");  
0CE2A:  MOVLW  0D
0CE2C:  BTFSS  F9E.4
0CE2E:  BRA    CE2C
0CE30:  MOVWF  FAD
0CE32:  MOVLW  0A
0CE34:  BTFSS  F9E.4
0CE36:  BRA    CE34
0CE38:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0CE3A:  MOVLB  8
0CE3C:  CLRF   x70
0CE3E:  MOVLW  48
0CE40:  MOVWF  x6F
0CE42:  MOVFF  3F8,874
0CE46:  MOVFF  3F7,873
0CE4A:  MOVFF  3F6,872
0CE4E:  MOVFF  3F5,871
0CE52:  MOVLB  0
0CE54:  RCALL  CAD4
....................          break; 
0CE56:  BRA    D084
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0CE58:  MOVLW  76
0CE5A:  MOVWF  FF6
0CE5C:  MOVLW  24
0CE5E:  MOVWF  FF7
0CE60:  MOVLW  00
0CE62:  MOVWF  FF8
0CE64:  CLRF   1B
0CE66:  BTFSC  FF2.7
0CE68:  BSF    1B.7
0CE6A:  BCF    FF2.7
0CE6C:  CALL   0DCC
0CE70:  BTFSC  1B.7
0CE72:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0CE74:  RCALL  CA8E
0CE76:  MOVFF  03,3FC
0CE7A:  MOVFF  02,3FB
0CE7E:  MOVFF  01,3FA
0CE82:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n"); 
0CE86:  MOVLW  0D
0CE88:  BTFSS  F9E.4
0CE8A:  BRA    CE88
0CE8C:  MOVWF  FAD
0CE8E:  MOVLW  0A
0CE90:  BTFSS  F9E.4
0CE92:  BRA    CE90
0CE94:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0CE96:  MOVLB  8
0CE98:  CLRF   x70
0CE9A:  MOVLW  4C
0CE9C:  MOVWF  x6F
0CE9E:  MOVFF  3FC,874
0CEA2:  MOVFF  3FB,873
0CEA6:  MOVFF  3FA,872
0CEAA:  MOVFF  3F9,871
0CEAE:  MOVLB  0
0CEB0:  RCALL  CAD4
....................          break; 
0CEB2:  BRA    D084
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0CEB4:  MOVLW  7E
0CEB6:  MOVWF  FF6
0CEB8:  MOVLW  24
0CEBA:  MOVWF  FF7
0CEBC:  MOVLW  00
0CEBE:  MOVWF  FF8
0CEC0:  CLRF   1B
0CEC2:  BTFSC  FF2.7
0CEC4:  BSF    1B.7
0CEC6:  BCF    FF2.7
0CEC8:  CALL   0DCC
0CECC:  BTFSC  1B.7
0CECE:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0CED0:  RCALL  CA8E
0CED2:  MOVFF  03,400
0CED6:  MOVFF  02,3FF
0CEDA:  MOVFF  01,3FE
0CEDE:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n");  
0CEE2:  MOVLW  0D
0CEE4:  BTFSS  F9E.4
0CEE6:  BRA    CEE4
0CEE8:  MOVWF  FAD
0CEEA:  MOVLW  0A
0CEEC:  BTFSS  F9E.4
0CEEE:  BRA    CEEC
0CEF0:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0CEF2:  MOVLB  8
0CEF4:  CLRF   x70
0CEF6:  MOVLW  52
0CEF8:  MOVWF  x6F
0CEFA:  MOVFF  3F8,874
0CEFE:  MOVFF  3F7,873
0CF02:  MOVFF  3F6,872
0CF06:  MOVFF  3F5,871
0CF0A:  MOVLB  0
0CF0C:  RCALL  CAD4
....................          break; 
0CF0E:  BRA    D084
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0CF10:  MOVLW  86
0CF12:  MOVWF  FF6
0CF14:  MOVLW  24
0CF16:  MOVWF  FF7
0CF18:  MOVLW  00
0CF1A:  MOVWF  FF8
0CF1C:  CLRF   1B
0CF1E:  BTFSC  FF2.7
0CF20:  BSF    1B.7
0CF22:  BCF    FF2.7
0CF24:  CALL   0DCC
0CF28:  BTFSC  1B.7
0CF2A:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0CF2C:  RCALL  CA8E
0CF2E:  MOVFF  03,404
0CF32:  MOVFF  02,403
0CF36:  MOVFF  01,402
0CF3A:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");   
0CF3E:  MOVLW  0D
0CF40:  BTFSS  F9E.4
0CF42:  BRA    CF40
0CF44:  MOVWF  FAD
0CF46:  MOVLW  0A
0CF48:  BTFSS  F9E.4
0CF4A:  BRA    CF48
0CF4C:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0CF4E:  MOVLB  8
0CF50:  CLRF   x70
0CF52:  MOVLW  56
0CF54:  MOVWF  x6F
0CF56:  MOVFF  404,874
0CF5A:  MOVFF  403,873
0CF5E:  MOVFF  402,872
0CF62:  MOVFF  401,871
0CF66:  MOVLB  0
0CF68:  RCALL  CAD4
....................          break; 
0CF6A:  BRA    D084
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0CF6C:  MOVLW  8E
0CF6E:  MOVWF  FF6
0CF70:  MOVLW  24
0CF72:  MOVWF  FF7
0CF74:  MOVLW  00
0CF76:  MOVWF  FF8
0CF78:  CLRF   1B
0CF7A:  BTFSC  FF2.7
0CF7C:  BSF    1B.7
0CF7E:  BCF    FF2.7
0CF80:  CALL   0DCC
0CF84:  BTFSC  1B.7
0CF86:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0CF88:  RCALL  CA8E
0CF8A:  MOVFF  03,408
0CF8E:  MOVFF  02,407
0CF92:  MOVFF  01,406
0CF96:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");  
0CF9A:  MOVLW  0D
0CF9C:  BTFSS  F9E.4
0CF9E:  BRA    CF9C
0CFA0:  MOVWF  FAD
0CFA2:  MOVLW  0A
0CFA4:  BTFSS  F9E.4
0CFA6:  BRA    CFA4
0CFA8:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0CFAA:  MOVLB  8
0CFAC:  CLRF   x70
0CFAE:  MOVLW  5A
0CFB0:  MOVWF  x6F
0CFB2:  MOVFF  408,874
0CFB6:  MOVFF  407,873
0CFBA:  MOVFF  406,872
0CFBE:  MOVFF  405,871
0CFC2:  MOVLB  0
0CFC4:  RCALL  CAD4
....................          break; 
0CFC6:  BRA    D084
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0CFC8:  MOVLW  96
0CFCA:  MOVWF  FF6
0CFCC:  MOVLW  24
0CFCE:  MOVWF  FF7
0CFD0:  MOVLW  00
0CFD2:  MOVWF  FF8
0CFD4:  CLRF   1B
0CFD6:  BTFSC  FF2.7
0CFD8:  BSF    1B.7
0CFDA:  BCF    FF2.7
0CFDC:  CALL   0DCC
0CFE0:  BTFSC  1B.7
0CFE2:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0CFE4:  RCALL  CA8E
0CFE6:  MOVFF  03,40C
0CFEA:  MOVFF  02,40B
0CFEE:  MOVFF  01,40A
0CFF2:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");   
0CFF6:  MOVLW  0D
0CFF8:  BTFSS  F9E.4
0CFFA:  BRA    CFF8
0CFFC:  MOVWF  FAD
0CFFE:  MOVLW  0A
0D000:  BTFSS  F9E.4
0D002:  BRA    D000
0D004:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0D006:  MOVLB  8
0D008:  CLRF   x70
0D00A:  MOVLW  5E
0D00C:  MOVWF  x6F
0D00E:  MOVFF  40C,874
0D012:  MOVFF  40B,873
0D016:  MOVFF  40A,872
0D01A:  MOVFF  409,871
0D01E:  MOVLB  0
0D020:  RCALL  CAD4
....................          break; 
0D022:  BRA    D084
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0D024:  MOVLW  A0
0D026:  MOVWF  FF6
0D028:  MOVLW  24
0D02A:  MOVWF  FF7
0D02C:  MOVLW  00
0D02E:  MOVWF  FF8
0D030:  CLRF   1B
0D032:  BTFSC  FF2.7
0D034:  BSF    1B.7
0D036:  BCF    FF2.7
0D038:  CALL   0DCC
0D03C:  BTFSC  1B.7
0D03E:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0D040:  RCALL  CA8E
0D042:  MOVFF  03,410
0D046:  MOVFF  02,40F
0D04A:  MOVFF  01,40E
0D04E:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");  
0D052:  MOVLW  0D
0D054:  BTFSS  F9E.4
0D056:  BRA    D054
0D058:  MOVWF  FAD
0D05A:  MOVLW  0A
0D05C:  BTFSS  F9E.4
0D05E:  BRA    D05C
0D060:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0D062:  MOVLB  8
0D064:  CLRF   x70
0D066:  MOVLW  62
0D068:  MOVWF  x6F
0D06A:  MOVFF  410,874
0D06E:  MOVFF  40F,873
0D072:  MOVFF  40E,872
0D076:  MOVFF  40D,871
0D07A:  MOVLB  0
0D07C:  RCALL  CAD4
....................          break;         
0D07E:  BRA    D084
....................       default: cmd_arg(); 
0D080:  CALL   B070
....................          break; 
....................    } 
0D084:  GOTO   DA7A (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0D794:  MOVF   47,F
0D796:  BNZ   D7A6
0D798:  MOVF   46,F
0D79A:  BNZ   D7A6
0D79C:  MOVF   45,F
0D79E:  BNZ   D7A6
0D7A0:  MOVF   44,W
0D7A2:  SUBLW  01
0D7A4:  BC    D7F6
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0D7A6:  MOVF   47,F
0D7A8:  BNZ   D7C0
0D7AA:  MOVF   46,F
0D7AC:  BNZ   D7C0
0D7AE:  MOVF   45,F
0D7B0:  BNZ   D7C0
0D7B2:  MOVF   44,W
0D7B4:  SUBLW  30
0D7B6:  BNC   D7C0
0D7B8:  DECFSZ 2F,W
0D7BA:  BRA    D7C0
0D7BC:  MOVF   30,F
0D7BE:  BZ    D7DC
0D7C0:  MOVF   47,F
0D7C2:  BNZ   D7F0
0D7C4:  MOVF   46,F
0D7C6:  BNZ   D7F0
0D7C8:  MOVF   45,F
0D7CA:  BNZ   D7F0
0D7CC:  MOVF   44,W
0D7CE:  SUBLW  32
0D7D0:  BNC   D7F0
0D7D2:  MOVF   2F,W
0D7D4:  SUBLW  03
0D7D6:  BNZ   D7F0
0D7D8:  MOVF   30,F
0D7DA:  BNZ   D7F0
....................          port=arg; 
0D7DC:  MOVFF  45,870
0D7E0:  MOVFF  44,86F
....................          play_wms_hard_macro(port);    
0D7E4:  MOVFF  870,874
0D7E8:  MOVFF  86F,873
0D7EC:  RCALL  D586
....................       } 
0D7EE:  BRA    D7F4
....................       else cmd_arg(); 
0D7F0:  CALL   B070
....................    } 
0D7F4:  BRA    D7FA
....................    else cmd_arg(); 
0D7F6:  CALL   B070
0D7FA:  GOTO   DA7A (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0DA0A:  MOVF   44,F
0DA0C:  BNZ   DA1A
0DA0E:  MOVF   45,F
0DA10:  BNZ   DA1A
0DA12:  MOVF   46,F
0DA14:  BNZ   DA1A
0DA16:  MOVF   47,F
0DA18:  BZ    DA38
0DA1A:  MOVF   47,F
0DA1C:  BNZ   DA38
0DA1E:  MOVF   46,F
0DA20:  BNZ   DA38
0DA22:  MOVF   45,F
0DA24:  BNZ   DA38
0DA26:  MOVF   44,W
0DA28:  SUBLW  04
0DA2A:  BNC   DA38
....................       chip=arg; 
0DA2C:  MOVFF  44,86F
....................       sol_chip_cmd(chip); 
0DA30:  MOVFF  86F,8A0
0DA34:  RCALL  D93C
....................    } 
0DA36:  BRA    DA3C
....................    else cmd_arg();    
0DA38:  CALL   B070
0DA3C:  GOTO   DA7A (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0DA40:  MOVF   2F,W
0DA42:  MOVWF  00
0DA44:  MOVF   30,W
0DA46:  MOVWF  03
0DA48:  BNZ   DA4E
0DA4A:  MOVF   00,F
0DA4C:  BZ    DA6E
0DA4E:  MOVF   03,W
0DA50:  BNZ   DA58
0DA52:  MOVLW  01
0DA54:  SUBWF  00,W
0DA56:  BZ    DA74
0DA58:  MOVF   03,W
0DA5A:  BNZ   DA62
0DA5C:  MOVLW  03
0DA5E:  SUBWF  00,W
0DA60:  BZ    DA74
0DA62:  MOVF   03,W
0DA64:  BNZ   DA6C
0DA66:  MOVLW  02
0DA68:  SUBWF  00,W
0DA6A:  BZ    DA78
0DA6C:  BRA    DA7A
....................       case ECO : commandCe(); 
0DA6E:  GOTO   CB42
....................          break; 
0DA72:  BRA    DA7A
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0DA74:  BRA    D794
....................          break; 
0DA76:  BRA    DA7A
....................       case AWS : commandCa(); 
0DA78:  BRA    DA0A
....................          break;          
....................    } 
0DA7A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0DA7E:  MOVF   44,W
0DA80:  MOVWF  00
0DA82:  MOVF   45,W
0DA84:  MOVWF  03
0DA86:  BNZ   DA8C
0DA88:  MOVF   00,F
0DA8A:  BZ    DAAC
0DA8C:  MOVF   03,W
0DA8E:  BNZ   DA96
0DA90:  MOVLW  01
0DA92:  SUBWF  00,W
0DA94:  BZ    DABE
0DA96:  MOVF   03,W
0DA98:  BNZ   DAA0
0DA9A:  MOVLW  02
0DA9C:  SUBWF  00,W
0DA9E:  BZ    DAE0
0DAA0:  MOVF   03,W
0DAA2:  BNZ   DAAA
0DAA4:  MOVLW  03
0DAA6:  SUBWF  00,W
0DAA8:  BZ    DAF2
0DAAA:  BRA    DB10
....................       case 0 : file_list(file_ptr_raw_all); 
0DAAC:  MOVLW  02
0DAAE:  MOVLB  8
0DAB0:  MOVWF  x74
0DAB2:  MOVLW  D9
0DAB4:  MOVWF  x73
0DAB6:  MOVLB  0
0DAB8:  CALL   B896
....................          break; 
0DABC:  BRA    DB14
....................       case 1 : file_list(file_ptr_raw_new); 
0DABE:  MOVLW  02
0DAC0:  MOVLB  8
0DAC2:  MOVWF  x74
0DAC4:  MOVLW  E7
0DAC6:  MOVWF  x73
0DAC8:  MOVLB  0
0DACA:  CALL   B896
....................                f_unlink(file_ptr_raw_new); 
0DACE:  MOVLW  02
0DAD0:  MOVLB  8
0DAD2:  MOVWF  x74
0DAD4:  MOVLW  E7
0DAD6:  MOVWF  x73
0DAD8:  MOVLB  0
0DADA:  CALL   BA10
....................          break; 
0DADE:  BRA    DB14
....................       case 2 : file_list(file_ptr_rel_all); 
0DAE0:  MOVLW  02
0DAE2:  MOVLB  8
0DAE4:  MOVWF  x74
0DAE6:  MOVLW  F5
0DAE8:  MOVWF  x73
0DAEA:  MOVLB  0
0DAEC:  CALL   B896
....................          break; 
0DAF0:  BRA    DB14
....................       case 3 : file_list(file_ptr_rel_new); 
0DAF2:  MOVLW  03
0DAF4:  MOVLB  8
0DAF6:  MOVWF  x74
0DAF8:  MOVWF  x73
0DAFA:  MOVLB  0
0DAFC:  CALL   B896
....................                f_unlink(file_ptr_rel_new); 
0DB00:  MOVLW  03
0DB02:  MOVLB  8
0DB04:  MOVWF  x74
0DB06:  MOVWF  x73
0DB08:  MOVLB  0
0DB0A:  CALL   BA10
....................          break;  
0DB0E:  BRA    DB14
....................       default : cmd_arg(); 
0DB10:  CALL   B070
....................          break; 
....................    } 
0DB14:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DB18:  MOVF   44,W
0DB1A:  MOVWF  00
0DB1C:  MOVF   45,W
0DB1E:  MOVWF  03
0DB20:  BNZ   DB26
0DB22:  MOVF   00,F
0DB24:  BZ    DB32
0DB26:  MOVF   03,W
0DB28:  BNZ   DB30
0DB2A:  MOVLW  02
0DB2C:  SUBWF  00,W
0DB2E:  BZ    DBAC
0DB30:  BRA    DC26
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DB32:  MOVLW  AA
0DB34:  MOVWF  FF6
0DB36:  MOVLW  24
0DB38:  MOVWF  FF7
0DB3A:  MOVLW  00
0DB3C:  MOVWF  FF8
0DB3E:  CLRF   1B
0DB40:  BTFSC  FF2.7
0DB42:  BSF    1B.7
0DB44:  BCF    FF2.7
0DB46:  CALL   0DCC
0DB4A:  BTFSC  1B.7
0DB4C:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DB4E:  CALL   0E5C
0DB52:  MOVFF  01,86F
....................       if(result == 'Y'){ 
0DB56:  MOVLB  8
0DB58:  MOVF   x6F,W
0DB5A:  SUBLW  59
0DB5C:  BNZ   DB8C
....................       f_unlink(file_ptr_raw_all); 
0DB5E:  MOVLW  02
0DB60:  MOVWF  x74
0DB62:  MOVLW  D9
0DB64:  MOVWF  x73
0DB66:  MOVLB  0
0DB68:  CALL   BA10
....................       printf("File deleted!\n\r"); 
0DB6C:  MOVLW  E6
0DB6E:  MOVWF  FF6
0DB70:  MOVLW  24
0DB72:  MOVWF  FF7
0DB74:  MOVLW  00
0DB76:  MOVWF  FF8
0DB78:  CLRF   1B
0DB7A:  BTFSC  FF2.7
0DB7C:  BSF    1B.7
0DB7E:  BCF    FF2.7
0DB80:  CALL   0DCC
0DB84:  BTFSC  1B.7
0DB86:  BSF    FF2.7
....................       }else{ 
0DB88:  BRA    DBAA
0DB8A:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DB8C:  MOVLW  F6
0DB8E:  MOVWF  FF6
0DB90:  MOVLW  24
0DB92:  MOVWF  FF7
0DB94:  MOVLW  00
0DB96:  MOVWF  FF8
0DB98:  CLRF   1B
0DB9A:  BTFSC  FF2.7
0DB9C:  BSF    1B.7
0DB9E:  BCF    FF2.7
0DBA0:  MOVLB  0
0DBA2:  CALL   0DCC
0DBA6:  BTFSC  1B.7
0DBA8:  BSF    FF2.7
....................       } 
....................          break; 
0DBAA:  BRA    DC2A
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DBAC:  MOVLW  0C
0DBAE:  MOVWF  FF6
0DBB0:  MOVLW  25
0DBB2:  MOVWF  FF7
0DBB4:  MOVLW  00
0DBB6:  MOVWF  FF8
0DBB8:  CLRF   1B
0DBBA:  BTFSC  FF2.7
0DBBC:  BSF    1B.7
0DBBE:  BCF    FF2.7
0DBC0:  CALL   0DCC
0DBC4:  BTFSC  1B.7
0DBC6:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DBC8:  CALL   0E5C
0DBCC:  MOVFF  01,86F
....................          if(result == 'Y'){ 
0DBD0:  MOVLB  8
0DBD2:  MOVF   x6F,W
0DBD4:  SUBLW  59
0DBD6:  BNZ   DC06
....................             f_unlink(file_ptr_rel_all); 
0DBD8:  MOVLW  02
0DBDA:  MOVWF  x74
0DBDC:  MOVLW  F5
0DBDE:  MOVWF  x73
0DBE0:  MOVLB  0
0DBE2:  CALL   BA10
....................             printf("File deleted!\n\r"); 
0DBE6:  MOVLW  50
0DBE8:  MOVWF  FF6
0DBEA:  MOVLW  25
0DBEC:  MOVWF  FF7
0DBEE:  MOVLW  00
0DBF0:  MOVWF  FF8
0DBF2:  CLRF   1B
0DBF4:  BTFSC  FF2.7
0DBF6:  BSF    1B.7
0DBF8:  BCF    FF2.7
0DBFA:  CALL   0DCC
0DBFE:  BTFSC  1B.7
0DC00:  BSF    FF2.7
....................          }else{ 
0DC02:  BRA    DC24
0DC04:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DC06:  MOVLW  60
0DC08:  MOVWF  FF6
0DC0A:  MOVLW  25
0DC0C:  MOVWF  FF7
0DC0E:  MOVLW  00
0DC10:  MOVWF  FF8
0DC12:  CLRF   1B
0DC14:  BTFSC  FF2.7
0DC16:  BSF    1B.7
0DC18:  BCF    FF2.7
0DC1A:  MOVLB  0
0DC1C:  CALL   0DCC
0DC20:  BTFSC  1B.7
0DC22:  BSF    FF2.7
....................          } 
....................          break; 
0DC24:  BRA    DC2A
....................       default : cmd_arg(); 
0DC26:  CALL   B070
....................          break;          
....................    } 
0DC2A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0DE16:  MOVF   44,W
0DE18:  SUBLW  95
0DE1A:  BNZ   DE2E
0DE1C:  MOVF   45,W
0DE1E:  SUBLW  15
0DE20:  BNZ   DE2E
0DE22:  MOVF   46,F
0DE24:  BNZ   DE2E
0DE26:  MOVF   47,F
0DE28:  BNZ   DE2E
....................       reset_nv_vars(); 
0DE2A:  BRA    DC2E
....................    } 
0DE2C:  BRA    DE32
....................    else cmd_arg(); 
0DE2E:  CALL   B070
0DE32:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0DE80:  MOVF   2F,F
0DE82:  BNZ   DE88
0DE84:  MOVF   30,F
0DE86:  BZ    DE9A
0DE88:  DECFSZ 2F,W
0DE8A:  BRA    DE90
0DE8C:  MOVF   30,F
0DE8E:  BZ    DE9A
0DE90:  MOVF   2F,W
0DE92:  SUBLW  03
0DE94:  BNZ   DF0C
0DE96:  MOVF   30,F
0DE98:  BNZ   DF0C
....................    { 
....................       busy_set(); 
0DE9A:  CALL   2A22
....................  
....................       switch(arg) 
0DE9E:  MOVFF  44,00
0DEA2:  MOVF   45,W
0DEA4:  MOVWF  03
0DEA6:  BNZ   DEAE
0DEA8:  MOVLW  01
0DEAA:  SUBWF  00,W
0DEAC:  BZ    DEC4
0DEAE:  MOVF   03,W
0DEB0:  BNZ   DEB8
0DEB2:  MOVLW  02
0DEB4:  SUBWF  00,W
0DEB6:  BZ    DED4
0DEB8:  MOVF   03,W
0DEBA:  BNZ   DEC2
0DEBC:  MOVLW  03
0DEBE:  SUBWF  00,W
0DEC0:  BZ    DEFE
0DEC2:  BRA    DF04
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0DEC4:  MOVLB  7
0DEC6:  CLRF   x3C
....................             align(0); 
0DEC8:  MOVLB  8
0DECA:  CLRF   xAC
0DECC:  MOVLB  0
0DECE:  CALL   A8F4
....................             break; 
0DED2:  BRA    DF08
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0DED4:  MOVF   44,W
0DED6:  SUBLW  02
0DED8:  BNZ   DEFC
0DEDA:  MOVF   45,F
0DEDC:  BNZ   DEFC
0DEDE:  MOVF   46,F
0DEE0:  BNZ   DEFC
0DEE2:  MOVF   47,F
0DEE4:  BNZ   DEFC
0DEE6:  MOVF   1F,W
0DEE8:  SUBLW  04
0DEEA:  BNZ   DEFC
0DEEC:  MOVF   20,F
0DEEE:  BNZ   DEFC
....................             { 
....................                motor=0; 
0DEF0:  MOVLB  7
0DEF2:  CLRF   x3C
....................                cal_disk(0); 
0DEF4:  MOVLB  8
0DEF6:  CLRF   x6F
0DEF8:  MOVLB  0
0DEFA:  BRA    DE36
....................             } 
....................             break; 
0DEFC:  BRA    DF08
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0DEFE:  CALL   AA98
....................             break; 
0DF02:  BRA    DF08
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0DF04:  CALL   B070
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0DF08:  CALL   AEAC
....................    } 
0DF0C:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E3E6:  DECFSZ 44,W
0E3E8:  BRA    E806
0E3EA:  MOVF   45,F
0E3EC:  BTFSS  FD8.2
0E3EE:  BRA    E806
0E3F0:  MOVF   46,F
0E3F2:  BTFSS  FD8.2
0E3F4:  BRA    E806
0E3F6:  MOVF   47,F
0E3F8:  BTFSS  FD8.2
0E3FA:  BRA    E806
....................       v_supply = read_supply(); 
0E3FC:  CALL   5154
0E400:  MOVFF  02,870
0E404:  MOVFF  01,86F
....................        
....................       RTC_reset_HT(); 
0E408:  CALL   3514
....................       RTC_read(); 
0E40C:  CALL   33A6
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E410:  MOVLW  76
0E412:  MOVWF  FF6
0E414:  MOVLW  25
0E416:  MOVWF  FF7
0E418:  MOVLW  00
0E41A:  MOVWF  FF8
0E41C:  CLRF   1B
0E41E:  BTFSC  FF2.7
0E420:  BSF    1B.7
0E422:  BCF    FF2.7
0E424:  MOVLW  04
0E426:  MOVLB  A
0E428:  MOVWF  x25
0E42A:  MOVLB  0
0E42C:  CALL   101E
0E430:  BTFSC  1B.7
0E432:  BSF    FF2.7
0E434:  MOVLW  10
0E436:  MOVWF  FE9
0E438:  CLRF   1B
0E43A:  BTFSC  FF2.7
0E43C:  BSF    1B.7
0E43E:  BCF    FF2.7
0E440:  MOVFF  26,A26
0E444:  MOVFF  25,A25
0E448:  CALL   11A0
0E44C:  BTFSC  1B.7
0E44E:  BSF    FF2.7
0E450:  MOVLW  20
0E452:  BTFSS  F9E.4
0E454:  BRA    E452
0E456:  MOVWF  FAD
0E458:  MOVLW  49
0E45A:  BTFSS  F9E.4
0E45C:  BRA    E45A
0E45E:  MOVWF  FAD
0E460:  MOVLW  10
0E462:  MOVWF  FE9
0E464:  CLRF   1B
0E466:  BTFSC  FF2.7
0E468:  BSF    1B.7
0E46A:  BCF    FF2.7
0E46C:  MOVFF  24,A26
0E470:  MOVFF  23,A25
0E474:  CALL   11A0
0E478:  BTFSC  1B.7
0E47A:  BSF    FF2.7
0E47C:  MOVLW  20
0E47E:  BTFSS  F9E.4
0E480:  BRA    E47E
0E482:  MOVWF  FAD
0E484:  MOVLW  4E
0E486:  BTFSS  F9E.4
0E488:  BRA    E486
0E48A:  MOVWF  FAD
0E48C:  MOVLW  10
0E48E:  MOVWF  FE9
0E490:  CLRF   1B
0E492:  BTFSC  FF2.7
0E494:  BSF    1B.7
0E496:  BCF    FF2.7
0E498:  MOVFF  22,A26
0E49C:  MOVFF  21,A25
0E4A0:  CALL   11A0
0E4A4:  BTFSC  1B.7
0E4A6:  BSF    FF2.7
0E4A8:  MOVLW  2F
0E4AA:  BTFSS  F9E.4
0E4AC:  BRA    E4AA
0E4AE:  MOVWF  FAD
0E4B0:  MOVLW  10
0E4B2:  MOVWF  FE9
0E4B4:  CLRF   1B
0E4B6:  BTFSC  FF2.7
0E4B8:  BSF    1B.7
0E4BA:  BCF    FF2.7
0E4BC:  MOVFF  28,A26
0E4C0:  MOVFF  27,A25
0E4C4:  CALL   11A0
0E4C8:  BTFSC  1B.7
0E4CA:  BSF    FF2.7
0E4CC:  MOVLW  20
0E4CE:  BTFSS  F9E.4
0E4D0:  BRA    E4CE
0E4D2:  MOVWF  FAD
0E4D4:  MOVLW  58
0E4D6:  BTFSS  F9E.4
0E4D8:  BRA    E4D6
0E4DA:  MOVWF  FAD
0E4DC:  MOVLW  10
0E4DE:  MOVWF  FE9
0E4E0:  CLRF   1B
0E4E2:  BTFSC  FF2.7
0E4E4:  BSF    1B.7
0E4E6:  BCF    FF2.7
0E4E8:  MOVFF  20,A26
0E4EC:  MOVFF  1F,A25
0E4F0:  CALL   11A0
0E4F4:  BTFSC  1B.7
0E4F6:  BSF    FF2.7
0E4F8:  MOVLW  20
0E4FA:  BTFSS  F9E.4
0E4FC:  BRA    E4FA
0E4FE:  MOVWF  FAD
0E500:  MOVLW  55
0E502:  BTFSS  F9E.4
0E504:  BRA    E502
0E506:  MOVWF  FAD
0E508:  CLRF   1B
0E50A:  BTFSC  FF2.7
0E50C:  BSF    1B.7
0E50E:  BCF    FF2.7
0E510:  MOVFF  73C,A25
0E514:  MOVLW  1B
0E516:  MOVLB  A
0E518:  MOVWF  x26
0E51A:  MOVLB  0
0E51C:  CALL   0FA0
0E520:  BTFSC  1B.7
0E522:  BSF    FF2.7
0E524:  MOVLW  20
0E526:  BTFSS  F9E.4
0E528:  BRA    E526
0E52A:  MOVWF  FAD
0E52C:  MOVLW  04
0E52E:  MOVWF  FE9
0E530:  MOVLB  8
0E532:  CLRF   x74
0E534:  CLRF   x73
0E536:  MOVFF  870,872
0E53A:  MOVFF  86F,871
0E53E:  MOVLW  02
0E540:  MOVWF  x75
0E542:  MOVLB  0
0E544:  RCALL  DF10
0E546:  MOVLW  9A
0E548:  MOVWF  FF6
0E54A:  MOVLW  25
0E54C:  MOVWF  FF7
0E54E:  MOVLW  00
0E550:  MOVWF  FF8
0E552:  CLRF   1B
0E554:  BTFSC  FF2.7
0E556:  BSF    1B.7
0E558:  BCF    FF2.7
0E55A:  MOVLW  03
0E55C:  MOVLB  A
0E55E:  MOVWF  x25
0E560:  MOVLB  0
0E562:  CALL   101E
0E566:  BTFSC  1B.7
0E568:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E56A:  MOVLW  9E
0E56C:  MOVWF  FF6
0E56E:  MOVLW  25
0E570:  MOVWF  FF7
0E572:  MOVLW  00
0E574:  MOVWF  FF8
0E576:  CLRF   1B
0E578:  BTFSC  FF2.7
0E57A:  BSF    1B.7
0E57C:  BCF    FF2.7
0E57E:  MOVLW  09
0E580:  MOVLB  A
0E582:  MOVWF  x25
0E584:  MOVLB  0
0E586:  CALL   101E
0E58A:  BTFSC  1B.7
0E58C:  BSF    FF2.7
0E58E:  MOVLW  10
0E590:  MOVWF  FE9
0E592:  CLRF   1B
0E594:  BTFSC  FF2.7
0E596:  BSF    1B.7
0E598:  BCF    FF2.7
0E59A:  MOVFF  7C0,A26
0E59E:  MOVFF  7BF,A25
0E5A2:  CALL   11A0
0E5A6:  BTFSC  1B.7
0E5A8:  BSF    FF2.7
0E5AA:  MOVLW  AA
0E5AC:  MOVWF  FF6
0E5AE:  MOVLW  25
0E5B0:  MOVWF  FF7
0E5B2:  MOVLW  00
0E5B4:  MOVWF  FF8
0E5B6:  CLRF   1B
0E5B8:  BTFSC  FF2.7
0E5BA:  BSF    1B.7
0E5BC:  BCF    FF2.7
0E5BE:  MOVLW  05
0E5C0:  MOVLB  A
0E5C2:  MOVWF  x25
0E5C4:  MOVLB  0
0E5C6:  CALL   101E
0E5CA:  BTFSC  1B.7
0E5CC:  BSF    FF2.7
0E5CE:  MOVLW  10
0E5D0:  MOVWF  FE9
0E5D2:  MOVFF  7B2,8DB
0E5D6:  MOVFF  7B1,8DA
0E5DA:  CALL   9024
0E5DE:  MOVLW  0D
0E5E0:  BTFSS  F9E.4
0E5E2:  BRA    E5E0
0E5E4:  MOVWF  FAD
0E5E6:  MOVLW  0A
0E5E8:  BTFSS  F9E.4
0E5EA:  BRA    E5E8
0E5EC:  MOVWF  FAD
....................       RTC_display(); 
0E5EE:  RCALL  E00C
....................       if (RTCfmt == 0) 
0E5F0:  MOVF   4B,F
0E5F2:  BTFSS  FD8.2
0E5F4:  BRA    E6FA
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E5F6:  MOVLW  B6
0E5F8:  MOVWF  FF6
0E5FA:  MOVLW  25
0E5FC:  MOVWF  FF7
0E5FE:  MOVLW  00
0E600:  MOVWF  FF8
0E602:  CLRF   1B
0E604:  BTFSC  FF2.7
0E606:  BSF    1B.7
0E608:  BCF    FF2.7
0E60A:  MOVLW  05
0E60C:  MOVLB  A
0E60E:  MOVWF  x25
0E610:  MOVLB  0
0E612:  CALL   101E
0E616:  BTFSC  1B.7
0E618:  BSF    FF2.7
0E61A:  CLRF   1B
0E61C:  BTFSC  FF2.7
0E61E:  BSF    1B.7
0E620:  BCF    FF2.7
0E622:  MOVFF  736,A25
0E626:  MOVLW  01
0E628:  MOVLB  A
0E62A:  MOVWF  x26
0E62C:  MOVLB  0
0E62E:  CALL   0FA0
0E632:  BTFSC  1B.7
0E634:  BSF    FF2.7
0E636:  MOVLW  2F
0E638:  BTFSS  F9E.4
0E63A:  BRA    E638
0E63C:  MOVWF  FAD
0E63E:  CLRF   1B
0E640:  BTFSC  FF2.7
0E642:  BSF    1B.7
0E644:  BCF    FF2.7
0E646:  MOVFF  737,A25
0E64A:  MOVLW  01
0E64C:  MOVLB  A
0E64E:  MOVWF  x26
0E650:  MOVLB  0
0E652:  CALL   0FA0
0E656:  BTFSC  1B.7
0E658:  BSF    FF2.7
0E65A:  MOVLW  2F
0E65C:  BTFSS  F9E.4
0E65E:  BRA    E65C
0E660:  MOVWF  FAD
0E662:  CLRF   1B
0E664:  BTFSC  FF2.7
0E666:  BSF    1B.7
0E668:  BCF    FF2.7
0E66A:  MOVFF  738,A25
0E66E:  MOVLW  01
0E670:  MOVLB  A
0E672:  MOVWF  x26
0E674:  MOVLB  0
0E676:  CALL   0FA0
0E67A:  BTFSC  1B.7
0E67C:  BSF    FF2.7
0E67E:  MOVLW  20
0E680:  BTFSS  F9E.4
0E682:  BRA    E680
0E684:  MOVWF  FAD
0E686:  CLRF   1B
0E688:  BTFSC  FF2.7
0E68A:  BSF    1B.7
0E68C:  BCF    FF2.7
0E68E:  MOVFF  739,A25
0E692:  MOVLW  01
0E694:  MOVLB  A
0E696:  MOVWF  x26
0E698:  MOVLB  0
0E69A:  CALL   0FA0
0E69E:  BTFSC  1B.7
0E6A0:  BSF    FF2.7
0E6A2:  MOVLW  3A
0E6A4:  BTFSS  F9E.4
0E6A6:  BRA    E6A4
0E6A8:  MOVWF  FAD
0E6AA:  CLRF   1B
0E6AC:  BTFSC  FF2.7
0E6AE:  BSF    1B.7
0E6B0:  BCF    FF2.7
0E6B2:  MOVFF  73A,A25
0E6B6:  MOVLW  01
0E6B8:  MOVLB  A
0E6BA:  MOVWF  x26
0E6BC:  MOVLB  0
0E6BE:  CALL   0FA0
0E6C2:  BTFSC  1B.7
0E6C4:  BSF    FF2.7
0E6C6:  MOVLW  3A
0E6C8:  BTFSS  F9E.4
0E6CA:  BRA    E6C8
0E6CC:  MOVWF  FAD
0E6CE:  CLRF   1B
0E6D0:  BTFSC  FF2.7
0E6D2:  BSF    1B.7
0E6D4:  BCF    FF2.7
0E6D6:  MOVFF  73B,A25
0E6DA:  MOVLW  01
0E6DC:  MOVLB  A
0E6DE:  MOVWF  x26
0E6E0:  MOVLB  0
0E6E2:  CALL   0FA0
0E6E6:  BTFSC  1B.7
0E6E8:  BSF    FF2.7
0E6EA:  MOVLW  0D
0E6EC:  BTFSS  F9E.4
0E6EE:  BRA    E6EC
0E6F0:  MOVWF  FAD
0E6F2:  MOVLW  0A
0E6F4:  BTFSS  F9E.4
0E6F6:  BRA    E6F4
0E6F8:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E6FA:  DECFSZ 4B,W
0E6FC:  BRA    E802
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E6FE:  MOVLW  DC
0E700:  MOVWF  FF6
0E702:  MOVLW  25
0E704:  MOVWF  FF7
0E706:  MOVLW  00
0E708:  MOVWF  FF8
0E70A:  CLRF   1B
0E70C:  BTFSC  FF2.7
0E70E:  BSF    1B.7
0E710:  BCF    FF2.7
0E712:  MOVLW  05
0E714:  MOVLB  A
0E716:  MOVWF  x25
0E718:  MOVLB  0
0E71A:  CALL   101E
0E71E:  BTFSC  1B.7
0E720:  BSF    FF2.7
0E722:  CLRF   1B
0E724:  BTFSC  FF2.7
0E726:  BSF    1B.7
0E728:  BCF    FF2.7
0E72A:  MOVFF  737,A25
0E72E:  MOVLW  01
0E730:  MOVLB  A
0E732:  MOVWF  x26
0E734:  MOVLB  0
0E736:  CALL   0FA0
0E73A:  BTFSC  1B.7
0E73C:  BSF    FF2.7
0E73E:  MOVLW  2F
0E740:  BTFSS  F9E.4
0E742:  BRA    E740
0E744:  MOVWF  FAD
0E746:  CLRF   1B
0E748:  BTFSC  FF2.7
0E74A:  BSF    1B.7
0E74C:  BCF    FF2.7
0E74E:  MOVFF  736,A25
0E752:  MOVLW  01
0E754:  MOVLB  A
0E756:  MOVWF  x26
0E758:  MOVLB  0
0E75A:  CALL   0FA0
0E75E:  BTFSC  1B.7
0E760:  BSF    FF2.7
0E762:  MOVLW  2F
0E764:  BTFSS  F9E.4
0E766:  BRA    E764
0E768:  MOVWF  FAD
0E76A:  CLRF   1B
0E76C:  BTFSC  FF2.7
0E76E:  BSF    1B.7
0E770:  BCF    FF2.7
0E772:  MOVFF  738,A25
0E776:  MOVLW  01
0E778:  MOVLB  A
0E77A:  MOVWF  x26
0E77C:  MOVLB  0
0E77E:  CALL   0FA0
0E782:  BTFSC  1B.7
0E784:  BSF    FF2.7
0E786:  MOVLW  20
0E788:  BTFSS  F9E.4
0E78A:  BRA    E788
0E78C:  MOVWF  FAD
0E78E:  CLRF   1B
0E790:  BTFSC  FF2.7
0E792:  BSF    1B.7
0E794:  BCF    FF2.7
0E796:  MOVFF  739,A25
0E79A:  MOVLW  01
0E79C:  MOVLB  A
0E79E:  MOVWF  x26
0E7A0:  MOVLB  0
0E7A2:  CALL   0FA0
0E7A6:  BTFSC  1B.7
0E7A8:  BSF    FF2.7
0E7AA:  MOVLW  3A
0E7AC:  BTFSS  F9E.4
0E7AE:  BRA    E7AC
0E7B0:  MOVWF  FAD
0E7B2:  CLRF   1B
0E7B4:  BTFSC  FF2.7
0E7B6:  BSF    1B.7
0E7B8:  BCF    FF2.7
0E7BA:  MOVFF  73A,A25
0E7BE:  MOVLW  01
0E7C0:  MOVLB  A
0E7C2:  MOVWF  x26
0E7C4:  MOVLB  0
0E7C6:  CALL   0FA0
0E7CA:  BTFSC  1B.7
0E7CC:  BSF    FF2.7
0E7CE:  MOVLW  3A
0E7D0:  BTFSS  F9E.4
0E7D2:  BRA    E7D0
0E7D4:  MOVWF  FAD
0E7D6:  CLRF   1B
0E7D8:  BTFSC  FF2.7
0E7DA:  BSF    1B.7
0E7DC:  BCF    FF2.7
0E7DE:  MOVFF  73B,A25
0E7E2:  MOVLW  01
0E7E4:  MOVLB  A
0E7E6:  MOVWF  x26
0E7E8:  MOVLB  0
0E7EA:  CALL   0FA0
0E7EE:  BTFSC  1B.7
0E7F0:  BSF    FF2.7
0E7F2:  MOVLW  0D
0E7F4:  BTFSS  F9E.4
0E7F6:  BRA    E7F4
0E7F8:  MOVWF  FAD
0E7FA:  MOVLW  0A
0E7FC:  BTFSS  F9E.4
0E7FE:  BRA    E7FC
0E800:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0E802:  RCALL  E196
....................       RTC_display_alarm(); 
0E804:  RCALL  E26C
....................    } 
0E806:  GOTO   F01A (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0E80A:  DECFSZ 44,W
0E80C:  BRA    EAE4
0E80E:  MOVF   45,F
0E810:  BTFSS  FD8.2
0E812:  BRA    EAE4
0E814:  MOVF   46,F
0E816:  BTFSS  FD8.2
0E818:  BRA    EAE4
0E81A:  MOVF   47,F
0E81C:  BTFSS  FD8.2
0E81E:  BRA    EAE4
....................       v_supply = read_supply(); 
0E820:  CALL   5154
0E824:  MOVFF  02,870
0E828:  MOVFF  01,86F
....................        
....................       RTC_reset_HT(); 
0E82C:  CALL   3514
....................       RTC_read(); 
0E830:  CALL   33A6
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0E834:  MOVLW  41
0E836:  BTFSS  F9E.4
0E838:  BRA    E836
0E83A:  MOVWF  FAD
0E83C:  MOVLW  10
0E83E:  MOVWF  FE9
0E840:  CLRF   1B
0E842:  BTFSC  FF2.7
0E844:  BSF    1B.7
0E846:  BCF    FF2.7
0E848:  MOVFF  2A,A26
0E84C:  MOVFF  29,A25
0E850:  CALL   11A0
0E854:  BTFSC  1B.7
0E856:  BSF    FF2.7
0E858:  MOVLW  20
0E85A:  BTFSS  F9E.4
0E85C:  BRA    E85A
0E85E:  MOVWF  FAD
0E860:  MOVLW  49
0E862:  BTFSS  F9E.4
0E864:  BRA    E862
0E866:  MOVWF  FAD
0E868:  MOVLW  10
0E86A:  MOVWF  FE9
0E86C:  CLRF   1B
0E86E:  BTFSC  FF2.7
0E870:  BSF    1B.7
0E872:  BCF    FF2.7
0E874:  MOVFF  24,A26
0E878:  MOVFF  23,A25
0E87C:  CALL   11A0
0E880:  BTFSC  1B.7
0E882:  BSF    FF2.7
0E884:  MOVLW  20
0E886:  BTFSS  F9E.4
0E888:  BRA    E886
0E88A:  MOVWF  FAD
0E88C:  MOVLW  4C
0E88E:  BTFSS  F9E.4
0E890:  BRA    E88E
0E892:  MOVWF  FAD
0E894:  MOVLW  10
0E896:  MOVWF  FE9
0E898:  CLRF   1B
0E89A:  BTFSC  FF2.7
0E89C:  BSF    1B.7
0E89E:  BCF    FF2.7
0E8A0:  MOVFF  2C,A26
0E8A4:  MOVFF  2B,A25
0E8A8:  CALL   11A0
0E8AC:  BTFSC  1B.7
0E8AE:  BSF    FF2.7
0E8B0:  MOVLW  20
0E8B2:  BTFSS  F9E.4
0E8B4:  BRA    E8B2
0E8B6:  MOVWF  FAD
0E8B8:  MOVLW  51
0E8BA:  BTFSS  F9E.4
0E8BC:  BRA    E8BA
0E8BE:  MOVWF  FAD
0E8C0:  MOVLW  10
0E8C2:  MOVWF  FE9
0E8C4:  CLRF   1B
0E8C6:  BTFSC  FF2.7
0E8C8:  BSF    1B.7
0E8CA:  BCF    FF2.7
0E8CC:  MOVFF  2E,A26
0E8D0:  MOVFF  2D,A25
0E8D4:  CALL   11A0
0E8D8:  BTFSC  1B.7
0E8DA:  BSF    FF2.7
0E8DC:  MOVLW  20
0E8DE:  BTFSS  F9E.4
0E8E0:  BRA    E8DE
0E8E2:  MOVWF  FAD
0E8E4:  MOVLW  53
0E8E6:  BTFSS  F9E.4
0E8E8:  BRA    E8E6
0E8EA:  MOVWF  FAD
0E8EC:  MOVLW  10
0E8EE:  MOVWF  FE9
0E8F0:  CLRF   1B
0E8F2:  BTFSC  FF2.7
0E8F4:  BSF    1B.7
0E8F6:  BCF    FF2.7
0E8F8:  MOVFF  22,A26
0E8FC:  MOVFF  21,A25
0E900:  CALL   11A0
0E904:  BTFSC  1B.7
0E906:  BSF    FF2.7
0E908:  MOVLW  20
0E90A:  BTFSS  F9E.4
0E90C:  BRA    E90A
0E90E:  MOVWF  FAD
0E910:  MOVLW  04
0E912:  MOVWF  FE9
0E914:  MOVLB  8
0E916:  CLRF   x74
0E918:  CLRF   x73
0E91A:  MOVFF  870,872
0E91E:  MOVFF  86F,871
0E922:  MOVLW  02
0E924:  MOVWF  x75
0E926:  MOVLB  0
0E928:  CALL   DF10
0E92C:  MOVLW  20
0E92E:  MOVWF  FF6
0E930:  MOVLW  26
0E932:  MOVWF  FF7
0E934:  MOVLW  00
0E936:  MOVWF  FF8
0E938:  CLRF   1B
0E93A:  BTFSC  FF2.7
0E93C:  BSF    1B.7
0E93E:  BCF    FF2.7
0E940:  MOVLW  03
0E942:  MOVLB  A
0E944:  MOVWF  x25
0E946:  MOVLB  0
0E948:  CALL   101E
0E94C:  BTFSC  1B.7
0E94E:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E950:  MOVLW  24
0E952:  MOVWF  FF6
0E954:  MOVLW  26
0E956:  MOVWF  FF7
0E958:  MOVLW  00
0E95A:  MOVWF  FF8
0E95C:  CLRF   1B
0E95E:  BTFSC  FF2.7
0E960:  BSF    1B.7
0E962:  BCF    FF2.7
0E964:  MOVLW  09
0E966:  MOVLB  A
0E968:  MOVWF  x25
0E96A:  MOVLB  0
0E96C:  CALL   101E
0E970:  BTFSC  1B.7
0E972:  BSF    FF2.7
0E974:  MOVLW  10
0E976:  MOVWF  FE9
0E978:  CLRF   1B
0E97A:  BTFSC  FF2.7
0E97C:  BSF    1B.7
0E97E:  BCF    FF2.7
0E980:  MOVFF  7C0,A26
0E984:  MOVFF  7BF,A25
0E988:  CALL   11A0
0E98C:  BTFSC  1B.7
0E98E:  BSF    FF2.7
0E990:  MOVLW  30
0E992:  MOVWF  FF6
0E994:  MOVLW  26
0E996:  MOVWF  FF7
0E998:  MOVLW  00
0E99A:  MOVWF  FF8
0E99C:  CLRF   1B
0E99E:  BTFSC  FF2.7
0E9A0:  BSF    1B.7
0E9A2:  BCF    FF2.7
0E9A4:  MOVLW  05
0E9A6:  MOVLB  A
0E9A8:  MOVWF  x25
0E9AA:  MOVLB  0
0E9AC:  CALL   101E
0E9B0:  BTFSC  1B.7
0E9B2:  BSF    FF2.7
0E9B4:  MOVLW  10
0E9B6:  MOVWF  FE9
0E9B8:  MOVFF  7B2,8DB
0E9BC:  MOVFF  7B1,8DA
0E9C0:  CALL   9024
0E9C4:  MOVLW  0D
0E9C6:  BTFSS  F9E.4
0E9C8:  BRA    E9C6
0E9CA:  MOVWF  FAD
0E9CC:  MOVLW  0A
0E9CE:  BTFSS  F9E.4
0E9D0:  BRA    E9CE
0E9D2:  MOVWF  FAD
....................       RTC_display(); 
0E9D4:  CALL   E00C
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E9D8:  MOVLW  3C
0E9DA:  MOVWF  FF6
0E9DC:  MOVLW  26
0E9DE:  MOVWF  FF7
0E9E0:  MOVLW  00
0E9E2:  MOVWF  FF8
0E9E4:  CLRF   1B
0E9E6:  BTFSC  FF2.7
0E9E8:  BSF    1B.7
0E9EA:  BCF    FF2.7
0E9EC:  MOVLW  05
0E9EE:  MOVLB  A
0E9F0:  MOVWF  x25
0E9F2:  MOVLB  0
0E9F4:  CALL   101E
0E9F8:  BTFSC  1B.7
0E9FA:  BSF    FF2.7
0E9FC:  CLRF   1B
0E9FE:  BTFSC  FF2.7
0EA00:  BSF    1B.7
0EA02:  BCF    FF2.7
0EA04:  MOVFF  736,A25
0EA08:  MOVLW  01
0EA0A:  MOVLB  A
0EA0C:  MOVWF  x26
0EA0E:  MOVLB  0
0EA10:  CALL   0FA0
0EA14:  BTFSC  1B.7
0EA16:  BSF    FF2.7
0EA18:  MOVLW  2F
0EA1A:  BTFSS  F9E.4
0EA1C:  BRA    EA1A
0EA1E:  MOVWF  FAD
0EA20:  CLRF   1B
0EA22:  BTFSC  FF2.7
0EA24:  BSF    1B.7
0EA26:  BCF    FF2.7
0EA28:  MOVFF  737,A25
0EA2C:  MOVLW  01
0EA2E:  MOVLB  A
0EA30:  MOVWF  x26
0EA32:  MOVLB  0
0EA34:  CALL   0FA0
0EA38:  BTFSC  1B.7
0EA3A:  BSF    FF2.7
0EA3C:  MOVLW  2F
0EA3E:  BTFSS  F9E.4
0EA40:  BRA    EA3E
0EA42:  MOVWF  FAD
0EA44:  CLRF   1B
0EA46:  BTFSC  FF2.7
0EA48:  BSF    1B.7
0EA4A:  BCF    FF2.7
0EA4C:  MOVFF  738,A25
0EA50:  MOVLW  01
0EA52:  MOVLB  A
0EA54:  MOVWF  x26
0EA56:  MOVLB  0
0EA58:  CALL   0FA0
0EA5C:  BTFSC  1B.7
0EA5E:  BSF    FF2.7
0EA60:  MOVLW  20
0EA62:  BTFSS  F9E.4
0EA64:  BRA    EA62
0EA66:  MOVWF  FAD
0EA68:  CLRF   1B
0EA6A:  BTFSC  FF2.7
0EA6C:  BSF    1B.7
0EA6E:  BCF    FF2.7
0EA70:  MOVFF  739,A25
0EA74:  MOVLW  01
0EA76:  MOVLB  A
0EA78:  MOVWF  x26
0EA7A:  MOVLB  0
0EA7C:  CALL   0FA0
0EA80:  BTFSC  1B.7
0EA82:  BSF    FF2.7
0EA84:  MOVLW  3A
0EA86:  BTFSS  F9E.4
0EA88:  BRA    EA86
0EA8A:  MOVWF  FAD
0EA8C:  CLRF   1B
0EA8E:  BTFSC  FF2.7
0EA90:  BSF    1B.7
0EA92:  BCF    FF2.7
0EA94:  MOVFF  73A,A25
0EA98:  MOVLW  01
0EA9A:  MOVLB  A
0EA9C:  MOVWF  x26
0EA9E:  MOVLB  0
0EAA0:  CALL   0FA0
0EAA4:  BTFSC  1B.7
0EAA6:  BSF    FF2.7
0EAA8:  MOVLW  3A
0EAAA:  BTFSS  F9E.4
0EAAC:  BRA    EAAA
0EAAE:  MOVWF  FAD
0EAB0:  CLRF   1B
0EAB2:  BTFSC  FF2.7
0EAB4:  BSF    1B.7
0EAB6:  BCF    FF2.7
0EAB8:  MOVFF  73B,A25
0EABC:  MOVLW  01
0EABE:  MOVLB  A
0EAC0:  MOVWF  x26
0EAC2:  MOVLB  0
0EAC4:  CALL   0FA0
0EAC8:  BTFSC  1B.7
0EACA:  BSF    FF2.7
0EACC:  MOVLW  0D
0EACE:  BTFSS  F9E.4
0EAD0:  BRA    EACE
0EAD2:  MOVWF  FAD
0EAD4:  MOVLW  0A
0EAD6:  BTFSS  F9E.4
0EAD8:  BRA    EAD6
0EADA:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EADC:  CALL   E196
....................       RTC_display_alarm(); 
0EAE0:  CALL   E26C
....................    } 
0EAE4:  GOTO   F01A (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0ED72:  DECFSZ 44,W
0ED74:  BRA    EFDA
0ED76:  MOVF   45,F
0ED78:  BTFSS  FD8.2
0ED7A:  BRA    EFDA
0ED7C:  MOVF   46,F
0ED7E:  BTFSS  FD8.2
0ED80:  BRA    EFDA
0ED82:  MOVF   47,F
0ED84:  BTFSS  FD8.2
0ED86:  BRA    EFDA
....................       v_supply = read_supply(); 
0ED88:  CALL   5154
0ED8C:  MOVFF  02,870
0ED90:  MOVFF  01,86F
....................        
....................       RTC_reset_HT(); 
0ED94:  CALL   3514
....................       RTC_read(); 
0ED98:  CALL   33A6
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0ED9C:  MOVLW  49
0ED9E:  BTFSS  F9E.4
0EDA0:  BRA    ED9E
0EDA2:  MOVWF  FAD
0EDA4:  MOVLW  10
0EDA6:  MOVWF  FE9
0EDA8:  CLRF   1B
0EDAA:  BTFSC  FF2.7
0EDAC:  BSF    1B.7
0EDAE:  BCF    FF2.7
0EDB0:  MOVFF  24,A26
0EDB4:  MOVFF  23,A25
0EDB8:  CALL   11A0
0EDBC:  BTFSC  1B.7
0EDBE:  BSF    FF2.7
0EDC0:  MOVLW  20
0EDC2:  BTFSS  F9E.4
0EDC4:  BRA    EDC2
0EDC6:  MOVWF  FAD
0EDC8:  MOVLW  4E
0EDCA:  BTFSS  F9E.4
0EDCC:  BRA    EDCA
0EDCE:  MOVWF  FAD
0EDD0:  MOVLW  10
0EDD2:  MOVWF  FE9
0EDD4:  CLRF   1B
0EDD6:  BTFSC  FF2.7
0EDD8:  BSF    1B.7
0EDDA:  BCF    FF2.7
0EDDC:  MOVFF  22,A26
0EDE0:  MOVFF  21,A25
0EDE4:  CALL   11A0
0EDE8:  BTFSC  1B.7
0EDEA:  BSF    FF2.7
0EDEC:  MOVLW  2F
0EDEE:  BTFSS  F9E.4
0EDF0:  BRA    EDEE
0EDF2:  MOVWF  FAD
0EDF4:  MOVLW  10
0EDF6:  MOVWF  FE9
0EDF8:  CLRF   1B
0EDFA:  BTFSC  FF2.7
0EDFC:  BSF    1B.7
0EDFE:  BCF    FF2.7
0EE00:  MOVFF  28,A26
0EE04:  MOVFF  27,A25
0EE08:  CALL   11A0
0EE0C:  BTFSC  1B.7
0EE0E:  BSF    FF2.7
0EE10:  MOVLW  20
0EE12:  BTFSS  F9E.4
0EE14:  BRA    EE12
0EE16:  MOVWF  FAD
0EE18:  MOVLW  50
0EE1A:  BTFSS  F9E.4
0EE1C:  BRA    EE1A
0EE1E:  MOVWF  FAD
0EE20:  MOVLW  10
0EE22:  MOVWF  FE9
0EE24:  CLRF   1B
0EE26:  BTFSC  FF2.7
0EE28:  BSF    1B.7
0EE2A:  BCF    FF2.7
0EE2C:  MOVFF  2E,A26
0EE30:  MOVFF  2D,A25
0EE34:  CALL   11A0
0EE38:  BTFSC  1B.7
0EE3A:  BSF    FF2.7
0EE3C:  MOVLW  20
0EE3E:  BTFSS  F9E.4
0EE40:  BRA    EE3E
0EE42:  MOVWF  FAD
0EE44:  MOVLW  04
0EE46:  MOVWF  FE9
0EE48:  MOVLB  8
0EE4A:  CLRF   x74
0EE4C:  CLRF   x73
0EE4E:  MOVFF  870,872
0EE52:  MOVFF  86F,871
0EE56:  MOVLW  02
0EE58:  MOVWF  x75
0EE5A:  MOVLB  0
0EE5C:  CALL   DF10
0EE60:  MOVLW  7A
0EE62:  MOVWF  FF6
0EE64:  MOVLW  26
0EE66:  MOVWF  FF7
0EE68:  MOVLW  00
0EE6A:  MOVWF  FF8
0EE6C:  CLRF   1B
0EE6E:  BTFSC  FF2.7
0EE70:  BSF    1B.7
0EE72:  BCF    FF2.7
0EE74:  MOVLW  03
0EE76:  MOVLB  A
0EE78:  MOVWF  x25
0EE7A:  MOVLB  0
0EE7C:  CALL   101E
0EE80:  BTFSC  1B.7
0EE82:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0EE84:  MOVLW  7E
0EE86:  MOVWF  FF6
0EE88:  MOVLW  26
0EE8A:  MOVWF  FF7
0EE8C:  MOVLW  00
0EE8E:  MOVWF  FF8
0EE90:  CLRF   1B
0EE92:  BTFSC  FF2.7
0EE94:  BSF    1B.7
0EE96:  BCF    FF2.7
0EE98:  MOVLW  09
0EE9A:  MOVLB  A
0EE9C:  MOVWF  x25
0EE9E:  MOVLB  0
0EEA0:  CALL   101E
0EEA4:  BTFSC  1B.7
0EEA6:  BSF    FF2.7
0EEA8:  MOVLW  10
0EEAA:  MOVWF  FE9
0EEAC:  MOVFF  7B2,8DB
0EEB0:  MOVFF  7B1,8DA
0EEB4:  CALL   9024
0EEB8:  MOVLW  0D
0EEBA:  BTFSS  F9E.4
0EEBC:  BRA    EEBA
0EEBE:  MOVWF  FAD
0EEC0:  MOVLW  0A
0EEC2:  BTFSS  F9E.4
0EEC4:  BRA    EEC2
0EEC6:  MOVWF  FAD
....................       display_valve_status(); 
0EEC8:  RCALL  EAE8
....................       RTC_display(); 
0EECA:  CALL   E00C
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EECE:  MOVLW  8E
0EED0:  MOVWF  FF6
0EED2:  MOVLW  26
0EED4:  MOVWF  FF7
0EED6:  MOVLW  00
0EED8:  MOVWF  FF8
0EEDA:  CLRF   1B
0EEDC:  BTFSC  FF2.7
0EEDE:  BSF    1B.7
0EEE0:  BCF    FF2.7
0EEE2:  MOVLW  05
0EEE4:  MOVLB  A
0EEE6:  MOVWF  x25
0EEE8:  MOVLB  0
0EEEA:  CALL   101E
0EEEE:  BTFSC  1B.7
0EEF0:  BSF    FF2.7
0EEF2:  CLRF   1B
0EEF4:  BTFSC  FF2.7
0EEF6:  BSF    1B.7
0EEF8:  BCF    FF2.7
0EEFA:  MOVFF  736,A25
0EEFE:  MOVLW  01
0EF00:  MOVLB  A
0EF02:  MOVWF  x26
0EF04:  MOVLB  0
0EF06:  CALL   0FA0
0EF0A:  BTFSC  1B.7
0EF0C:  BSF    FF2.7
0EF0E:  MOVLW  2F
0EF10:  BTFSS  F9E.4
0EF12:  BRA    EF10
0EF14:  MOVWF  FAD
0EF16:  CLRF   1B
0EF18:  BTFSC  FF2.7
0EF1A:  BSF    1B.7
0EF1C:  BCF    FF2.7
0EF1E:  MOVFF  737,A25
0EF22:  MOVLW  01
0EF24:  MOVLB  A
0EF26:  MOVWF  x26
0EF28:  MOVLB  0
0EF2A:  CALL   0FA0
0EF2E:  BTFSC  1B.7
0EF30:  BSF    FF2.7
0EF32:  MOVLW  2F
0EF34:  BTFSS  F9E.4
0EF36:  BRA    EF34
0EF38:  MOVWF  FAD
0EF3A:  CLRF   1B
0EF3C:  BTFSC  FF2.7
0EF3E:  BSF    1B.7
0EF40:  BCF    FF2.7
0EF42:  MOVFF  738,A25
0EF46:  MOVLW  01
0EF48:  MOVLB  A
0EF4A:  MOVWF  x26
0EF4C:  MOVLB  0
0EF4E:  CALL   0FA0
0EF52:  BTFSC  1B.7
0EF54:  BSF    FF2.7
0EF56:  MOVLW  20
0EF58:  BTFSS  F9E.4
0EF5A:  BRA    EF58
0EF5C:  MOVWF  FAD
0EF5E:  CLRF   1B
0EF60:  BTFSC  FF2.7
0EF62:  BSF    1B.7
0EF64:  BCF    FF2.7
0EF66:  MOVFF  739,A25
0EF6A:  MOVLW  01
0EF6C:  MOVLB  A
0EF6E:  MOVWF  x26
0EF70:  MOVLB  0
0EF72:  CALL   0FA0
0EF76:  BTFSC  1B.7
0EF78:  BSF    FF2.7
0EF7A:  MOVLW  3A
0EF7C:  BTFSS  F9E.4
0EF7E:  BRA    EF7C
0EF80:  MOVWF  FAD
0EF82:  CLRF   1B
0EF84:  BTFSC  FF2.7
0EF86:  BSF    1B.7
0EF88:  BCF    FF2.7
0EF8A:  MOVFF  73A,A25
0EF8E:  MOVLW  01
0EF90:  MOVLB  A
0EF92:  MOVWF  x26
0EF94:  MOVLB  0
0EF96:  CALL   0FA0
0EF9A:  BTFSC  1B.7
0EF9C:  BSF    FF2.7
0EF9E:  MOVLW  3A
0EFA0:  BTFSS  F9E.4
0EFA2:  BRA    EFA0
0EFA4:  MOVWF  FAD
0EFA6:  CLRF   1B
0EFA8:  BTFSC  FF2.7
0EFAA:  BSF    1B.7
0EFAC:  BCF    FF2.7
0EFAE:  MOVFF  73B,A25
0EFB2:  MOVLW  01
0EFB4:  MOVLB  A
0EFB6:  MOVWF  x26
0EFB8:  MOVLB  0
0EFBA:  CALL   0FA0
0EFBE:  BTFSC  1B.7
0EFC0:  BSF    FF2.7
0EFC2:  MOVLW  0D
0EFC4:  BTFSS  F9E.4
0EFC6:  BRA    EFC4
0EFC8:  MOVWF  FAD
0EFCA:  MOVLW  0A
0EFCC:  BTFSS  F9E.4
0EFCE:  BRA    EFCC
0EFD0:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EFD2:  CALL   E196
....................       RTC_display_alarm(); 
0EFD6:  CALL   E26C
....................    } 
0EFDA:  GOTO   F01A (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0EFDE:  MOVF   2F,W
0EFE0:  MOVWF  00
0EFE2:  MOVF   30,W
0EFE4:  MOVWF  03
0EFE6:  BNZ   EFEC
0EFE8:  MOVF   00,F
0EFEA:  BZ    F00C
0EFEC:  MOVF   03,W
0EFEE:  BNZ   EFF6
0EFF0:  MOVLW  01
0EFF2:  SUBWF  00,W
0EFF4:  BZ    F012
0EFF6:  MOVF   03,W
0EFF8:  BNZ   F000
0EFFA:  MOVLW  03
0EFFC:  SUBWF  00,W
0EFFE:  BZ    F012
0F000:  MOVF   03,W
0F002:  BNZ   F00A
0F004:  MOVLW  02
0F006:  SUBWF  00,W
0F008:  BZ    F018
0F00A:  BRA    F01A
....................       case ECO : commandHe(); 
0F00C:  GOTO   E3E6
....................          break; 
0F010:  BRA    F01A
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0F012:  GOTO   E80A
....................          break; 
0F016:  BRA    F01A
....................       case AWS : commandHa(); 
0F018:  BRA    ED72
....................          break;          
....................    } 
0F01A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0F01E:  MOVF   44,F
0F020:  BNZ   F02E
0F022:  MOVF   45,F
0F024:  BNZ   F02E
0F026:  MOVF   46,F
0F028:  BNZ   F02E
0F02A:  MOVF   47,F
0F02C:  BZ    F062
0F02E:  MOVF   47,F
0F030:  BNZ   F062
0F032:  MOVF   46,F
0F034:  BNZ   F062
0F036:  MOVF   45,W
0F038:  SUBLW  FD
0F03A:  BNC   F062
0F03C:  BNZ   F044
0F03E:  MOVF   44,W
0F040:  SUBLW  20
0F042:  BNC   F062
....................       nv_interval = arg; 
0F044:  MOVFF  45,24
0F048:  MOVFF  44,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0F04C:  MOVLW  14
0F04E:  MOVLB  8
0F050:  MOVWF  xD8
0F052:  MOVFF  24,8DA
0F056:  MOVFF  23,8D9
0F05A:  MOVLB  0
0F05C:  CALL   502C
....................    } 
0F060:  BRA    F066
....................    else cmd_arg(); 
0F062:  CALL   B070
0F066:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0F06A:  MOVF   47,F
0F06C:  BNZ   F09C
0F06E:  MOVF   46,F
0F070:  BNZ   F09C
0F072:  MOVF   45,W
0F074:  SUBLW  27
0F076:  BNC   F09C
0F078:  BNZ   F080
0F07A:  MOVF   44,W
0F07C:  SUBLW  0F
0F07E:  BNC   F09C
....................       nv_serial = arg; 
0F080:  MOVFF  45,26
0F084:  MOVFF  44,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0F088:  MOVLB  8
0F08A:  CLRF   xD8
0F08C:  MOVFF  26,8DA
0F090:  MOVFF  25,8D9
0F094:  MOVLB  0
0F096:  CALL   502C
....................    } 
0F09A:  BRA    F0A0
....................    else cmd_arg(); 
0F09C:  CALL   B070
0F0A0:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F2C4:  MOVF   2F,F
0F2C6:  BNZ   F2F6
0F2C8:  MOVF   30,F
0F2CA:  BNZ   F2F6
....................        
....................       if (arg > 0 && arg < 3){ 
0F2CC:  MOVF   44,F
0F2CE:  BNZ   F2DC
0F2D0:  MOVF   45,F
0F2D2:  BNZ   F2DC
0F2D4:  MOVF   46,F
0F2D6:  BNZ   F2DC
0F2D8:  MOVF   47,F
0F2DA:  BZ    F2F2
0F2DC:  MOVF   47,F
0F2DE:  BNZ   F2F2
0F2E0:  MOVF   46,F
0F2E2:  BNZ   F2F2
0F2E4:  MOVF   45,F
0F2E6:  BNZ   F2F2
0F2E8:  MOVF   44,W
0F2EA:  SUBLW  02
0F2EC:  BNC   F2F2
....................          det_cmd(); 
0F2EE:  RCALL  F184
....................       } 
0F2F0:  BRA    F2F6
....................       else cmd_arg(); 
0F2F2:  CALL   B070
....................        
....................    } 
0F2F6:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
10154:  MOVF   47,F
10156:  BNZ   101C2
10158:  MOVF   46,F
1015A:  BNZ   101C2
1015C:  MOVF   45,W
1015E:  SUBLW  0F
10160:  BNC   101C2
....................       switch (nv_det_type){ 
10162:  MOVFF  41,00
10166:  MOVF   42,W
10168:  MOVWF  03
1016A:  BNZ   10172
1016C:  MOVLW  01
1016E:  SUBWF  00,W
10170:  BZ    10188
10172:  MOVF   03,W
10174:  BNZ   1017C
10176:  MOVLW  02
10178:  SUBWF  00,W
1017A:  BZ    1018E
1017C:  MOVF   03,W
1017E:  BNZ   10186
10180:  MOVLW  03
10182:  SUBWF  00,W
10184:  BZ    101AC
10186:  BRA    101C0
....................          case 1 : det_cmd(); 
10188:  CALL   F184
....................             break; 
1018C:  BRA    101C0
....................          case 2 : DAC_set(1,arg); 
1018E:  MOVFF  45,870
10192:  MOVFF  44,86F
10196:  MOVLW  01
10198:  MOVLB  8
1019A:  MOVWF  xBD
1019C:  MOVFF  45,8BF
101A0:  MOVFF  44,8BE
101A4:  MOVLB  0
101A6:  CALL   F2FA
....................             break; 
101AA:  BRA    101C0
....................          case 3 : set_LED(arg); 
101AC:  MOVFF  45,870
101B0:  MOVFF  44,86F
101B4:  MOVFF  45,8B0
101B8:  MOVFF  44,8AF
101BC:  CALL   F648
....................             break; 
....................       } 
....................    } 
101C0:  BRA    10220
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
101C2:  MOVF   47,F
101C4:  BNZ   101DA
101C6:  MOVF   46,F
101C8:  BNZ   101DA
101CA:  MOVF   45,W
101CC:  SUBLW  4D
101CE:  BC    10204
101D0:  XORLW  FF
101D2:  BNZ   101DA
101D4:  MOVF   44,W
101D6:  SUBLW  20
101D8:  BC    10204
101DA:  MOVF   47,F
101DC:  BNZ   10204
101DE:  MOVF   46,F
101E0:  BNZ   10204
101E2:  MOVF   45,W
101E4:  SUBLW  4E
101E6:  BNC   10204
101E8:  BNZ   101F0
101EA:  MOVF   44,W
101EC:  SUBLW  22
101EE:  BNC   10204
101F0:  MOVFF  45,870
101F4:  MOVFF  44,86F
101F8:  MOVFF  45,872
101FC:  MOVFF  44,871
10200:  BRA    10000
10202:  BRA    10220
....................    else if(arg==30001)set_LED_test(); 
10204:  MOVF   44,W
10206:  SUBLW  31
10208:  BNZ   1021C
1020A:  MOVF   45,W
1020C:  SUBLW  75
1020E:  BNZ   1021C
10210:  MOVF   46,F
10212:  BNZ   1021C
10214:  MOVF   47,F
10216:  BNZ   1021C
10218:  BRA    100C8
1021A:  BRA    10220
....................    else cmd_arg(); 
1021C:  CALL   B070
10220:  GOTO   1028A (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
10224:  MOVF   47,F
10226:  BNZ   10258
10228:  MOVF   46,F
1022A:  BNZ   10258
1022C:  MOVF   45,W
1022E:  SUBLW  57
10230:  BNC   10258
10232:  BNZ   1023A
10234:  MOVF   44,W
10236:  SUBLW  E4
10238:  BNC   10258
....................       nv_volume = arg; 
1023A:  MOVFF  45,2C
1023E:  MOVFF  44,2B
....................       write16(ADDR_VOLUME, nv_volume); 
10242:  MOVLW  22
10244:  MOVLB  8
10246:  MOVWF  xD8
10248:  MOVFF  2C,8DA
1024C:  MOVFF  2B,8D9
10250:  MOVLB  0
10252:  CALL   502C
....................    } 
10256:  BRA    1025C
....................    else cmd_arg(); 
10258:  CALL   B070
1025C:  GOTO   1028A (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
10260:  MOVF   2F,W
10262:  MOVWF  00
10264:  MOVF   30,W
10266:  MOVWF  03
10268:  BNZ   1026E
1026A:  MOVF   00,F
1026C:  BZ    10284
1026E:  MOVF   03,W
10270:  BNZ   10278
10272:  MOVLW  01
10274:  SUBWF  00,W
10276:  BZ    10288
10278:  MOVF   03,W
1027A:  BNZ   10282
1027C:  MOVLW  03
1027E:  SUBWF  00,W
10280:  BZ    10288
10282:  BRA    1028A
....................       case ECO : commandLe(); 
10284:  BRA    10154
....................          break; 
10286:  BRA    1028A
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
10288:  BRA    10224
....................          break; 
....................    } 
1028A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
169AE:  CALL   2A22
....................     
....................    user_quit = FALSE; 
169B2:  CLRF   4C
....................     
....................    if(arg > 0 && arg < 21) 
169B4:  MOVF   44,F
169B6:  BNZ   169C4
169B8:  MOVF   45,F
169BA:  BNZ   169C4
169BC:  MOVF   46,F
169BE:  BNZ   169C4
169C0:  MOVF   47,F
169C2:  BZ    16A40
169C4:  MOVF   47,F
169C6:  BNZ   16A40
169C8:  MOVF   46,F
169CA:  BNZ   16A40
169CC:  MOVF   45,F
169CE:  BNZ   16A40
169D0:  MOVF   44,W
169D2:  SUBLW  14
169D4:  BNC   16A40
....................    { 
....................       macro = arg; 
169D6:  MOVFF  44,870
....................       switch(nv_product){ 
169DA:  MOVFF  2F,00
169DE:  MOVF   30,W
169E0:  MOVWF  03
169E2:  BNZ   169E8
169E4:  MOVF   00,F
169E6:  BZ    16A08
169E8:  MOVF   03,W
169EA:  BNZ   169F2
169EC:  MOVLW  01
169EE:  SUBWF  00,W
169F0:  BZ    16A08
169F2:  MOVF   03,W
169F4:  BNZ   169FC
169F6:  MOVLW  03
169F8:  SUBWF  00,W
169FA:  BZ    16A08
169FC:  MOVF   03,W
169FE:  BNZ   16A06
16A00:  MOVLW  02
16A02:  SUBWF  00,W
16A04:  BZ    16A2E
16A06:  BRA    16A3E
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
16A08:  MOVLW  01
16A0A:  MOVLB  7
16A0C:  ADDWF  xBF,W
16A0E:  MOVLB  8
16A10:  MOVWF  x71
16A12:  MOVLW  00
16A14:  MOVLB  7
16A16:  ADDWFC xC0,W
16A18:  MOVLB  8
16A1A:  MOVWF  x72
16A1C:  MOVFF  870,881
16A20:  MOVWF  x83
16A22:  MOVFF  871,882
16A26:  MOVLB  0
16A28:  CALL   14FD4
....................             break; 
16A2C:  BRA    16A3E
....................          case AWS : play_macro(macro,nv_port); 
16A2E:  MOVFF  870,881
16A32:  MOVFF  2E,883
16A36:  MOVFF  2D,882
16A3A:  CALL   14FD4
....................             break; 
....................       } 
....................    }    
16A3E:  BRA    16AA8
....................    else if (arg == 0) 
16A40:  MOVF   44,F
16A42:  BNZ   16AA4
16A44:  MOVF   45,F
16A46:  BNZ   16AA4
16A48:  MOVF   46,F
16A4A:  BNZ   16AA4
16A4C:  MOVF   47,F
16A4E:  BNZ   16AA4
....................    { 
....................       MaxSamples=FALSE; 
16A50:  CLRF   34
16A52:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
16A54:  MOVLW  28
16A56:  MOVLB  8
16A58:  MOVWF  x73
16A5A:  MOVFF  33,874
16A5E:  MOVLB  0
16A60:  CALL   3474
....................       if (LoggingReentry != TRUE) 
16A64:  MOVLB  8
16A66:  DECFSZ x6F,W
16A68:  BRA    16A6C
16A6A:  BRA    16A84
....................       { 
....................          nv_sample = 0; 
16A6C:  CLRF   22
16A6E:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
16A70:  MOVLW  16
16A72:  MOVWF  xD8
16A74:  MOVFF  22,8DA
16A78:  MOVFF  21,8D9
16A7C:  MOVLB  0
16A7E:  CALL   502C
16A82:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
16A84:  CLRF   x6F
....................       nv_macro_step = 0; 
16A86:  CLRF   38
16A88:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
16A8A:  MOVLW  3A
16A8C:  MOVWF  xD8
16A8E:  MOVFF  38,8DA
16A92:  MOVFF  37,8D9
16A96:  MOVLB  0
16A98:  CALL   502C
....................       user_quit = auto_sample_ready(); 
16A9C:  BRA    167AC
16A9E:  MOVFF  01,4C
....................    } 
16AA2:  BRA    16AA8
....................    else cmd_arg(); 
16AA4:  CALL   B070
....................     
....................    busy_clear(); 
16AA8:  CALL   AEAC
16AAC:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
16AAE:  MOVF   44,F
16AB0:  BNZ   16ABE
16AB2:  MOVF   45,F
16AB4:  BNZ   16ABE
16AB6:  MOVF   46,F
16AB8:  BNZ   16ABE
16ABA:  MOVF   47,F
16ABC:  BZ    16AF2
16ABE:  MOVF   47,F
16AC0:  BNZ   16AF2
16AC2:  MOVF   46,F
16AC4:  BNZ   16AF2
16AC6:  MOVF   45,W
16AC8:  SUBLW  0D
16ACA:  BNC   16AF2
16ACC:  BNZ   16AD4
16ACE:  MOVF   44,W
16AD0:  SUBLW  AC
16AD2:  BNC   16AF2
....................       nv_max_samples = arg; 
16AD4:  MOVFF  45,28
16AD8:  MOVFF  44,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
16ADC:  MOVLW  18
16ADE:  MOVLB  8
16AE0:  MOVWF  xD8
16AE2:  MOVFF  28,8DA
16AE6:  MOVFF  27,8D9
16AEA:  MOVLB  0
16AEC:  CALL   502C
....................    } 
16AF0:  BRA    16B38
....................    else if(arg == 0) { 
16AF2:  MOVF   44,F
16AF4:  BNZ   16B34
16AF6:  MOVF   45,F
16AF8:  BNZ   16B34
16AFA:  MOVF   46,F
16AFC:  BNZ   16B34
16AFE:  MOVF   47,F
16B00:  BNZ   16B34
....................       nv_sample = 0; 
16B02:  CLRF   22
16B04:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16B06:  MOVLW  16
16B08:  MOVLB  8
16B0A:  MOVWF  xD8
16B0C:  MOVFF  22,8DA
16B10:  MOVFF  21,8D9
16B14:  MOVLB  0
16B16:  CALL   502C
....................       nv_macro_step = 0; 
16B1A:  CLRF   38
16B1C:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16B1E:  MOVLW  3A
16B20:  MOVLB  8
16B22:  MOVWF  xD8
16B24:  MOVFF  38,8DA
16B28:  MOVFF  37,8D9
16B2C:  MOVLB  0
16B2E:  CALL   502C
....................    } 
16B32:  BRA    16B38
....................    else cmd_arg(); 
16B34:  CALL   B070
16B38:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
16C5E:  DECFSZ 44,W
16C60:  BRA    16C7A
16C62:  MOVF   45,F
16C64:  BNZ   16C7A
16C66:  MOVF   46,F
16C68:  BNZ   16C7A
16C6A:  MOVF   47,F
16C6C:  BNZ   16C7A
....................    { 
....................       bus_on(); 
16C6E:  CALL   D0F6
....................       open_pipe(); 
16C72:  BRA    16B54
....................       bus_off(); 
16C74:  CALL   D11A
....................    } 
16C78:  BRA    16C7E
....................    else cmd_arg(); 
16C7A:  CALL   B070
16C7E:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
16D3C:  MOVLB  7
16D3E:  DECFSZ x3D,W
16D40:  BRA    16D44
16D42:  CLRF   x3C
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
16D44:  MOVF   44,F
16D46:  BNZ   16D56
16D48:  MOVF   45,F
16D4A:  BNZ   16D56
16D4C:  MOVF   46,F
16D4E:  BNZ   16D56
16D50:  MOVF   47,F
16D52:  BTFSC  FD8.2
16D54:  BRA    16E1E
16D56:  BCF    FD8.0
16D58:  RLCF   x3C,W
16D5A:  CLRF   03
16D5C:  ADDLW  5E
16D5E:  MOVWF  FE9
16D60:  MOVLW  07
16D62:  ADDWFC 03,W
16D64:  MOVWF  FEA
16D66:  MOVFF  FEC,03
16D6A:  MOVF   FED,F
16D6C:  MOVFF  FEF,01
16D70:  MOVF   47,F
16D72:  BNZ   16E1E
16D74:  MOVF   46,F
16D76:  BNZ   16E1E
16D78:  MOVF   45,W
16D7A:  SUBWF  03,W
16D7C:  BNC   16E1E
16D7E:  BNZ   16D86
16D80:  MOVF   44,W
16D82:  SUBWF  01,W
16D84:  BNC   16E1E
....................       if(e_mode[motor]==2){     // if port mode then move 
16D86:  BCF    FD8.0
16D88:  RLCF   x3C,W
16D8A:  CLRF   03
16D8C:  ADDLW  62
16D8E:  MOVWF  FE9
16D90:  MOVLW  07
16D92:  ADDWFC 03,W
16D94:  MOVWF  FEA
16D96:  MOVFF  FEC,870
16D9A:  MOVF   FED,F
16D9C:  MOVFF  FEF,86F
16DA0:  MOVLB  8
16DA2:  MOVF   x6F,W
16DA4:  SUBLW  02
16DA6:  BNZ   16E14
16DA8:  MOVF   x70,F
16DAA:  BNZ   16E14
....................          switch (nv_product){ 
16DAC:  MOVF   2F,W
16DAE:  MOVWF  00
16DB0:  MOVF   30,W
16DB2:  MOVWF  03
16DB4:  MOVF   03,W
16DB6:  BNZ   16DC0
16DB8:  MOVF   00,F
16DBA:  MOVLB  0
16DBC:  BZ    16DDE
16DBE:  MOVLB  8
16DC0:  MOVF   03,W
16DC2:  BNZ   16DCE
16DC4:  MOVLW  01
16DC6:  SUBWF  00,W
16DC8:  MOVLB  0
16DCA:  BZ    16DF0
16DCC:  MOVLB  8
16DCE:  MOVF   03,W
16DD0:  BNZ   16DDC
16DD2:  MOVLW  03
16DD4:  SUBWF  00,W
16DD6:  MOVLB  0
16DD8:  BZ    16E02
16DDA:  MOVLB  8
16DDC:  BRA    16E12
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
16DDE:  MOVLW  01
16DE0:  MOVLB  8
16DE2:  MOVWF  x6F
16DE4:  CLRF   x70
16DE6:  MOVWF  x71
16DE8:  MOVLB  0
16DEA:  RCALL  16C82
....................                break;             
16DEC:  MOVLB  8
16DEE:  BRA    16E12
....................             case WMS4: command_move(0,0,1); 
16DF0:  MOVLB  8
16DF2:  CLRF   x6F
16DF4:  CLRF   x70
16DF6:  MOVLW  01
16DF8:  MOVWF  x71
16DFA:  MOVLB  0
16DFC:  RCALL  16C82
....................                break; 
16DFE:  MOVLB  8
16E00:  BRA    16E12
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
16E02:  MOVLB  8
16E04:  CLRF   x6F
16E06:  CLRF   x70
16E08:  MOVLW  01
16E0A:  MOVWF  x71
16E0C:  MOVLB  0
16E0E:  RCALL  16C82
....................                break; 
16E10:  MOVLB  8
....................          } 
....................       } 
16E12:  BRA    16E1C
....................       else cmd_err();                           // else error 
16E14:  MOVLB  0
16E16:  CALL   BD32
16E1A:  MOVLB  8
....................    } 
16E1C:  BRA    16E26
....................    else cmd_arg(); 
16E1E:  MOVLB  0
16E20:  CALL   B070
16E24:  MOVLB  8
16E26:  MOVLB  0
16E28:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
16E2A:  MOVF   47,F
16E2C:  BNZ   16E5A
16E2E:  MOVF   46,F
16E30:  BNZ   16E5A
16E32:  MOVF   45,F
16E34:  BNZ   16E5A
16E36:  MOVF   44,W
16E38:  SUBLW  30
16E3A:  BNC   16E5A
....................       nv_port = arg; 
16E3C:  MOVFF  45,2E
16E40:  MOVFF  44,2D
....................       write16(ADDR_PORT, nv_port); 
16E44:  MOVLW  24
16E46:  MOVLB  8
16E48:  MOVWF  xD8
16E4A:  MOVFF  2E,8DA
16E4E:  MOVFF  2D,8D9
16E52:  MOVLB  0
16E54:  CALL   502C
....................    } 
16E58:  BRA    16E5E
....................    else cmd_arg(); 
16E5A:  CALL   B070
16E5E:  GOTO   16E9A (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
16E62:  MOVF   2F,W
16E64:  MOVWF  00
16E66:  MOVF   30,W
16E68:  MOVWF  03
16E6A:  BNZ   16E70
16E6C:  MOVF   00,F
16E6E:  BZ    16E90
16E70:  MOVF   03,W
16E72:  BNZ   16E7A
16E74:  MOVLW  01
16E76:  SUBWF  00,W
16E78:  BZ    16E94
16E7A:  MOVF   03,W
16E7C:  BNZ   16E84
16E7E:  MOVLW  03
16E80:  SUBWF  00,W
16E82:  BZ    16E94
16E84:  MOVF   03,W
16E86:  BNZ   16E8E
16E88:  MOVLW  02
16E8A:  SUBWF  00,W
16E8C:  BZ    16E98
16E8E:  BRA    16E9A
....................       case ECO : commandPe(); 
16E90:  RCALL  16D3C
....................          break; 
16E92:  BRA    16E9A
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
16E94:  RCALL  16D3C
....................          break; 
16E96:  BRA    16E9A
....................       case AWS : commandPa(); 
16E98:  BRA    16E2A
....................          break;          
....................    } 
16E9A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
16EE6:  MOVLB  4
16EE8:  DECFSZ xB2,W
16EEA:  BRA    16F16
....................     
....................       if(arg<33){ 
16EEC:  MOVF   47,F
16EEE:  BNZ   16F0E
16EF0:  MOVF   46,F
16EF2:  BNZ   16F0E
16EF4:  MOVF   45,F
16EF6:  BNZ   16F0E
16EF8:  MOVF   44,W
16EFA:  SUBLW  20
16EFC:  BNC   16F0E
....................          valve=arg;    
16EFE:  MOVFF  44,86F
....................          sol_switch(valve); 
16F02:  MOVFF  86F,89F
16F06:  MOVLB  0
16F08:  CALL   1419E
....................       }  
16F0C:  BRA    16F14
....................       else cmd_arg(); 
16F0E:  MOVLB  0
16F10:  CALL   B070
....................    } 
16F14:  BRA    16F1C
....................    else cmd_err(); 
16F16:  MOVLB  0
16F18:  CALL   BD32
16F1C:  GOTO   16F4C (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
16E9E:  MOVF   44,F
16EA0:  BNZ   16EAE
16EA2:  MOVF   45,F
16EA4:  BNZ   16EAE
16EA6:  MOVF   46,F
16EA8:  BNZ   16EAE
16EAA:  MOVF   47,F
16EAC:  BZ    16EDE
16EAE:  MOVF   47,F
16EB0:  BNZ   16EDE
16EB2:  MOVF   46,F
16EB4:  BNZ   16EDE
16EB6:  MOVF   45,F
16EB8:  BNZ   16EDE
16EBA:  MOVF   44,W
16EBC:  SUBLW  32
16EBE:  BNC   16EDE
....................       nv_port = arg; 
16EC0:  MOVFF  45,2E
16EC4:  MOVFF  44,2D
....................       write16(ADDR_SAMPLE, nv_port); 
16EC8:  MOVLW  16
16ECA:  MOVLB  8
16ECC:  MOVWF  xD8
16ECE:  MOVFF  2E,8DA
16ED2:  MOVFF  2D,8D9
16ED6:  MOVLB  0
16ED8:  CALL   502C
....................    } 
16EDC:  BRA    16EE2
....................    else cmd_arg(); 
16EDE:  CALL   B070
16EE2:  GOTO   16F4C (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
16F20:  MOVF   2F,W
16F22:  MOVWF  00
16F24:  MOVF   30,W
16F26:  MOVWF  03
16F28:  BNZ   16F30
16F2A:  MOVLW  01
16F2C:  SUBWF  00,W
16F2E:  BZ    16F46
16F30:  MOVF   03,W
16F32:  BNZ   16F3A
16F34:  MOVLW  03
16F36:  SUBWF  00,W
16F38:  BZ    16F46
16F3A:  MOVF   03,W
16F3C:  BNZ   16F44
16F3E:  MOVLW  02
16F40:  SUBWF  00,W
16F42:  BZ    16F4A
16F44:  BRA    16F4C
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
16F46:  BRA    16E9E
....................          break; 
16F48:  BRA    16F4C
....................       case AWS : commandQa(); 
16F4A:  BRA    16EE6
....................          break;          
....................    } 
16F4C:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
16F50:  CALL   2A22
....................     
....................    nv_macro_step = 0; 
16F54:  CLRF   38
16F56:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
16F58:  MOVLW  3A
16F5A:  MOVLB  8
16F5C:  MOVWF  xD8
16F5E:  MOVFF  38,8DA
16F62:  MOVFF  37,8D9
16F66:  MOVLB  0
16F68:  CALL   502C
....................     
....................    user_quit = FALSE; 
16F6C:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 3501){ 
16F6E:  MOVF   44,F
16F70:  BNZ   16F7E
16F72:  MOVF   45,F
16F74:  BNZ   16F7E
16F76:  MOVF   46,F
16F78:  BNZ   16F7E
16F7A:  MOVF   47,F
16F7C:  BZ    1702A
16F7E:  MOVF   47,F
16F80:  BNZ   1702A
16F82:  MOVF   46,F
16F84:  BNZ   1702A
16F86:  MOVF   45,W
16F88:  SUBLW  0D
16F8A:  BNC   1702A
16F8C:  BNZ   16F94
16F8E:  MOVF   44,W
16F90:  SUBLW  AC
16F92:  BNC   1702A
....................       samples = arg; 
16F94:  MOVFF  45,871
16F98:  MOVFF  44,870
....................       user_quit = FALSE; 
16F9C:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
16F9E:  MOVLB  8
16FA0:  CLRF   x73
16FA2:  CLRF   x72
16FA4:  MOVF   x73,W
16FA6:  SUBWF  x71,W
16FA8:  BNC   17028
16FAA:  BNZ   16FB2
16FAC:  MOVF   x70,W
16FAE:  SUBWF  x72,W
16FB0:  BC    17028
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
16FB2:  MOVLW  01
16FB4:  ADDWF  x72,W
16FB6:  MOVWF  x74
16FB8:  MOVLW  00
16FBA:  ADDWFC x73,W
16FBC:  MOVWF  x75
16FBE:  MOVLW  B4
16FC0:  MOVWF  FF6
16FC2:  MOVLW  26
16FC4:  MOVWF  FF7
16FC6:  MOVLW  00
16FC8:  MOVWF  FF8
16FCA:  CLRF   1B
16FCC:  BTFSC  FF2.7
16FCE:  BSF    1B.7
16FD0:  BCF    FF2.7
16FD2:  MOVLW  05
16FD4:  MOVLB  A
16FD6:  MOVWF  x25
16FD8:  MOVLB  0
16FDA:  CALL   101E
16FDE:  BTFSC  1B.7
16FE0:  BSF    FF2.7
16FE2:  MOVLW  09
16FE4:  MOVWF  FE9
16FE6:  CLRF   1B
16FE8:  BTFSC  FF2.7
16FEA:  BSF    1B.7
16FEC:  BCF    FF2.7
16FEE:  MOVFF  875,A26
16FF2:  MOVFF  874,A25
16FF6:  CALL   11A0
16FFA:  BTFSC  1B.7
16FFC:  BSF    FF2.7
16FFE:  MOVLW  0D
17000:  BTFSS  F9E.4
17002:  BRA    17000
17004:  MOVWF  FAD
17006:  MOVLW  0A
17008:  BTFSS  F9E.4
1700A:  BRA    17008
1700C:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
1700E:  CALL   15B9C
17012:  MOVFF  01,86F
....................          if (macro_cmd == ';') break; 
17016:  MOVLB  8
17018:  MOVF   x6F,W
1701A:  SUBLW  3B
1701C:  BTFSC  FD8.2
1701E:  BRA    17028
17020:  INCF   x72,F
17022:  BTFSC  FD8.2
17024:  INCF   x73,F
17026:  BRA    16FA4
17028:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
1702A:  CALL   AEAC
1702E:  GOTO   171EE (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
17032:  MOVF   44,F
17034:  BNZ   17042
17036:  MOVF   45,F
17038:  BNZ   17042
1703A:  MOVF   46,F
1703C:  BNZ   17042
1703E:  MOVF   47,F
17040:  BZ    17086
17042:  MOVF   47,F
17044:  BNZ   17086
17046:  MOVF   46,F
17048:  BNZ   17086
1704A:  MOVF   45,F
1704C:  BNZ   17086
1704E:  MOVF   44,W
17050:  SUBLW  2F
17052:  BNC   17086
....................       n=arg; 
17054:  MOVFF  44,872
....................       port=2; 
17058:  MOVLB  8
1705A:  CLRF   x70
1705C:  MOVLW  02
1705E:  MOVWF  x6F
....................       for(i=0;i<n;++i){ 
17060:  CLRF   x71
17062:  MOVF   x72,W
17064:  SUBWF  x71,W
17066:  BC    17082
....................          play_wms_hard_macro(port); 
17068:  MOVFF  870,874
1706C:  MOVFF  86F,873
17070:  MOVLB  0
17072:  CALL   D586
....................          ++port; 
17076:  MOVLB  8
17078:  INCF   x6F,F
1707A:  BTFSC  FD8.2
1707C:  INCF   x70,F
1707E:  INCF   x71,F
17080:  BRA    17062
....................       } 
....................    } 
17082:  BRA    1708C
17084:  MOVLB  0
....................    else cmd_arg(); 
17086:  CALL   B070
1708A:  MOVLB  8
1708C:  MOVLB  0
1708E:  GOTO   171EE (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
17092:  CALL   2A22
....................     
....................    nv_macro_step = 0; 
17096:  CLRF   38
17098:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
1709A:  MOVLW  3A
1709C:  MOVLB  8
1709E:  MOVWF  xD8
170A0:  MOVFF  38,8DA
170A4:  MOVFF  37,8D9
170A8:  MOVLB  0
170AA:  CALL   502C
....................     
....................    user_quit = FALSE; 
170AE:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 241){ 
170B0:  MOVF   44,F
170B2:  BNZ   170C2
170B4:  MOVF   45,F
170B6:  BNZ   170C2
170B8:  MOVF   46,F
170BA:  BNZ   170C2
170BC:  MOVF   47,F
170BE:  BTFSC  FD8.2
170C0:  BRA    171AE
170C2:  MOVF   47,F
170C4:  BTFSS  FD8.2
170C6:  BRA    171AE
170C8:  MOVF   46,F
170CA:  BTFSS  FD8.2
170CC:  BRA    171AE
170CE:  MOVF   45,F
170D0:  BTFSS  FD8.2
170D2:  BRA    171AE
170D4:  MOVF   44,W
170D6:  SUBLW  F0
170D8:  BNC   171AE
....................       samples = arg; 
170DA:  MOVFF  45,871
170DE:  MOVFF  44,870
....................       user_quit = FALSE; 
170E2:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
170E4:  MOVLB  8
170E6:  CLRF   x73
170E8:  CLRF   x72
170EA:  MOVF   x73,W
170EC:  SUBWF  x71,W
170EE:  BNC   171AC
170F0:  BNZ   170F8
170F2:  MOVF   x70,W
170F4:  SUBWF  x72,W
170F6:  BC    171AC
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
170F8:  MOVLW  01
170FA:  ADDWF  x72,W
170FC:  MOVWF  x74
170FE:  MOVLW  00
17100:  ADDWFC x73,W
17102:  MOVWF  x75
17104:  MOVLW  C2
17106:  MOVWF  FF6
17108:  MOVLW  26
1710A:  MOVWF  FF7
1710C:  MOVLW  00
1710E:  MOVWF  FF8
17110:  CLRF   1B
17112:  BTFSC  FF2.7
17114:  BSF    1B.7
17116:  BCF    FF2.7
17118:  MOVLW  05
1711A:  MOVLB  A
1711C:  MOVWF  x25
1711E:  MOVLB  0
17120:  CALL   101E
17124:  BTFSC  1B.7
17126:  BSF    FF2.7
17128:  MOVLW  09
1712A:  MOVWF  FE9
1712C:  CLRF   1B
1712E:  BTFSC  FF2.7
17130:  BSF    1B.7
17132:  BCF    FF2.7
17134:  MOVFF  875,A26
17138:  MOVFF  874,A25
1713C:  CALL   11A0
17140:  BTFSC  1B.7
17142:  BSF    FF2.7
17144:  MOVLW  0D
17146:  BTFSS  F9E.4
17148:  BRA    17146
1714A:  MOVWF  FAD
1714C:  MOVLW  0A
1714E:  BTFSS  F9E.4
17150:  BRA    1714E
17152:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
17154:  MOVLW  01
17156:  MOVLB  8
17158:  ADDWF  x72,W
1715A:  MOVWF  x74
1715C:  MOVLW  00
1715E:  ADDWFC x73,W
17160:  MOVWF  x75
17162:  MOVWF  x77
17164:  MOVFF  874,876
17168:  MOVLB  0
1716A:  CALL   16452
1716E:  MOVFF  01,86F
....................          ++nv_sample;                     // increment sample number 
17172:  INCF   21,F
17174:  BTFSC  FD8.2
17176:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
17178:  MOVLW  16
1717A:  MOVLB  8
1717C:  MOVWF  xD8
1717E:  MOVFF  22,8DA
17182:  MOVFF  21,8D9
17186:  MOVLB  0
17188:  CALL   502C
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
1718C:  MOVF   27,W
1718E:  SUBWF  21,W
17190:  BNZ   17198
17192:  MOVF   28,W
17194:  SUBWF  22,W
17196:  BZ    171A0
17198:  MOVLB  8
1719A:  MOVF   x6F,W
1719C:  SUBLW  3B
1719E:  BNZ   171A4
171A0:  MOVLB  8
171A2:  BRA    171AC
171A4:  INCF   x72,F
171A6:  BTFSC  FD8.2
171A8:  INCF   x73,F
171AA:  BRA    170EA
171AC:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
171AE:  CALL   AEAC
171B2:  GOTO   171EE (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
171B6:  MOVF   2F,W
171B8:  MOVWF  00
171BA:  MOVF   30,W
171BC:  MOVWF  03
171BE:  BNZ   171C4
171C0:  MOVF   00,F
171C2:  BZ    171E4
171C4:  MOVF   03,W
171C6:  BNZ   171CE
171C8:  MOVLW  01
171CA:  SUBWF  00,W
171CC:  BZ    171E8
171CE:  MOVF   03,W
171D0:  BNZ   171D8
171D2:  MOVLW  03
171D4:  SUBWF  00,W
171D6:  BZ    171E8
171D8:  MOVF   03,W
171DA:  BNZ   171E2
171DC:  MOVLW  02
171DE:  SUBWF  00,W
171E0:  BZ    171EC
171E2:  BRA    171EE
....................       case ECO : commandRe(); 
171E4:  BRA    16F50
....................          break; 
171E6:  BRA    171EE
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
171E8:  BRA    17032
....................          break; 
171EA:  BRA    171EE
....................       case AWS : commandRa(); 
171EC:  BRA    17092
....................          break;          
....................    } 
171EE:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
171F2:  CALL   2A22
....................     
....................    switch(arg){ 
171F6:  MOVFF  44,00
171FA:  MOVF   45,W
171FC:  MOVWF  03
171FE:  BNZ   17206
17200:  MOVLW  01
17202:  SUBWF  00,W
17204:  BZ    17212
17206:  MOVF   03,W
17208:  BNZ   17210
1720A:  MOVLW  02
1720C:  SUBWF  00,W
1720E:  BZ    17256
17210:  BRA    17266
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
17212:  DECFSZ 41,W
17214:  BRA    1722A
17216:  MOVF   42,F
17218:  BNZ   1722A
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
1721A:  MOVLB  8
1721C:  CLRF   xAC
1721E:  MOVLW  01
17220:  MOVWF  xAD
17222:  MOVLB  0
17224:  CALL   134E0
....................       } 
17228:  BRA    17254
....................       else if(nv_det_type==2 || nv_det_type==3) 
1722A:  MOVF   41,W
1722C:  SUBLW  02
1722E:  BNZ   17234
17230:  MOVF   42,F
17232:  BZ    1723E
17234:  MOVF   41,W
17236:  SUBLW  03
17238:  BNZ   17254
1723A:  MOVF   42,F
1723C:  BNZ   17254
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
1723E:  MOVLB  8
17240:  CLRF   xAD
17242:  MOVLW  C8
17244:  MOVWF  xAC
17246:  CLRF   xAE
17248:  MOVLW  01
1724A:  MOVWF  xAF
1724C:  CLRF   xB0
1724E:  MOVLB  0
17250:  CALL   FD8A
....................       } 
....................       break;                                                        //200 scans,don't store,display 
17254:  BRA    1726A
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
17256:  MOVLB  8
17258:  CLRF   xAC
1725A:  MOVLW  01
1725C:  MOVWF  xAD
1725E:  MOVLB  0
17260:  CALL   137E2
....................       break; 
17264:  BRA    1726A
....................    default: cmd_arg(); 
17266:  CALL   B070
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
1726A:  CALL   AEAC
1726E:  GOTO   1731A (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
17272:  MOVF   47,F
17274:  BNZ   172A6
17276:  MOVF   46,F
17278:  BNZ   172A6
1727A:  MOVF   45,W
1727C:  SUBLW  04
1727E:  BNC   172A6
17280:  BNZ   17288
17282:  MOVF   44,W
17284:  SUBLW  00
17286:  BNC   172A6
....................       nv_sample = arg; 
17288:  MOVFF  45,22
1728C:  MOVFF  44,21
....................       write16(ADDR_SAMPLE, nv_sample); 
17290:  MOVLW  16
17292:  MOVLB  8
17294:  MOVWF  xD8
17296:  MOVFF  22,8DA
1729A:  MOVFF  21,8D9
1729E:  MOVLB  0
172A0:  CALL   502C
....................    } 
172A4:  BRA    172AA
....................    else cmd_arg(); 
172A6:  CALL   B070
172AA:  GOTO   1731A (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
172AE:  MOVF   47,F
172B0:  BNZ   172DA
172B2:  MOVF   46,F
172B4:  BNZ   172DA
172B6:  MOVF   45,W
172B8:  SUBLW  01
172BA:  BNC   172DA
172BC:  BNZ   172C4
172BE:  MOVF   44,W
172C0:  SUBLW  02
172C2:  BNC   172DA
....................       setting = arg; 
172C4:  MOVFF  45,870
172C8:  MOVFF  44,86F
....................       sol_switch_cmd(setting); 
172CC:  MOVFF  870,8A1
172D0:  MOVFF  86F,8A0
172D4:  CALL   140E8
....................    } 
172D8:  BRA    172DE
....................    else cmd_arg(); 
172DA:  CALL   B070
172DE:  GOTO   1731A (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
172E2:  MOVF   2F,W
172E4:  MOVWF  00
172E6:  MOVF   30,W
172E8:  MOVWF  03
172EA:  BNZ   172F0
172EC:  MOVF   00,F
172EE:  BZ    17310
172F0:  MOVF   03,W
172F2:  BNZ   172FA
172F4:  MOVLW  01
172F6:  SUBWF  00,W
172F8:  BZ    17314
172FA:  MOVF   03,W
172FC:  BNZ   17304
172FE:  MOVLW  03
17300:  SUBWF  00,W
17302:  BZ    17314
17304:  MOVF   03,W
17306:  BNZ   1730E
17308:  MOVLW  02
1730A:  SUBWF  00,W
1730C:  BZ    17318
1730E:  BRA    1731A
....................       case ECO : commandSe(); 
17310:  BRA    171F2
....................          break; 
17312:  BRA    1731A
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
17314:  BRA    17272
....................          break; 
17316:  BRA    1731A
....................       case AWS : commandSa(); 
17318:  BRA    172AE
....................          break;          
....................    } 
1731A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
17880:  MOVLW  D0
17882:  MOVWF  FF6
17884:  MOVLW  26
17886:  MOVWF  FF7
17888:  MOVLW  00
1788A:  MOVWF  FF8
1788C:  CLRF   1B
1788E:  BTFSC  FF2.7
17890:  BSF    1B.7
17892:  BCF    FF2.7
17894:  CALL   0DCC
17898:  BTFSC  1B.7
1789A:  BSF    FF2.7
....................    fputc('>',COM_A); 
1789C:  MOVLW  3E
1789E:  CALL   AEB4
....................    RTCfmt=fgetc(COM_A); 
178A2:  CALL   0E5C
178A6:  MOVFF  01,4B
....................    if (com_echo == TRUE) 
178AA:  DECFSZ 48,W
178AC:  BRA    178B4
....................       { 
....................       fputc(RTCfmt,COM_A); 
178AE:  MOVF   4B,W
178B0:  CALL   AEB4
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
178B4:  MOVLW  30
178B6:  SUBWF  4B,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
178B8:  MOVF   4B,W
178BA:  SUBLW  01
178BC:  BNC   178F2
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
178BE:  MOVLW  FC
178C0:  MOVWF  FF6
178C2:  MOVLW  26
178C4:  MOVWF  FF7
178C6:  MOVLW  00
178C8:  MOVWF  FF8
178CA:  CALL   AE82
178CE:  MOVLW  0D
178D0:  BTFSS  F9E.4
178D2:  BRA    178D0
178D4:  MOVWF  FAD
178D6:  MOVLW  0A
178D8:  BTFSS  F9E.4
178DA:  BRA    178D8
178DC:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
178DE:  MOVLW  1A
178E0:  MOVLB  8
178E2:  MOVWF  xD8
178E4:  CLRF   xDA
178E6:  MOVFF  4B,8D9
178EA:  MOVLB  0
178EC:  CALL   502C
....................       }  
178F0:  BRA    178F6
....................    else cmd_arg(); 
178F2:  CALL   B070
....................     
....................    if(arg == 1) 
178F6:  DECFSZ 44,W
178F8:  BRA    1790A
178FA:  MOVF   45,F
178FC:  BNZ   1790A
178FE:  MOVF   46,F
17900:  BNZ   1790A
17902:  MOVF   47,F
17904:  BNZ   1790A
....................    { 
....................       RTC_Set(); 
17906:  BRA    17736
....................    } 
17908:  BRA    1790E
....................    else cmd_arg(); 
1790A:  CALL   B070
1790E:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
18282:  MOVF   47,F
18284:  BNZ   182A0
18286:  MOVF   46,F
18288:  BNZ   182A0
1828A:  MOVF   45,F
1828C:  BNZ   182A0
1828E:  MOVF   44,W
18290:  SUBLW  14
18292:  BNC   182A0
....................       macro = arg; 
18294:  MOVFF  44,86F
....................       upload_macro(macro);    
18298:  MOVFF  86F,870
1829C:  BRA    17FD0
....................    }    
1829E:  BRA    182BC
....................    else if (arg == 5525){ 
182A0:  MOVF   44,W
182A2:  SUBLW  95
182A4:  BNZ   182B8
182A6:  MOVF   45,W
182A8:  SUBLW  15
182AA:  BNZ   182B8
182AC:  MOVF   46,F
182AE:  BNZ   182B8
182B0:  MOVF   47,F
182B2:  BNZ   182B8
....................       write_blank_macros(); 
182B4:  BRA    18106
....................    } 
182B6:  BRA    182BC
....................    else cmd_arg(); 
182B8:  CALL   B070
182BC:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
183DA:  MOVF   47,F
183DC:  BNZ   183F8
183DE:  MOVF   46,F
183E0:  BNZ   183F8
183E2:  MOVF   45,F
183E4:  BNZ   183F8
183E6:  MOVF   44,W
183E8:  SUBLW  14
183EA:  BNC   183F8
....................       macro = arg;  
183EC:  MOVFF  44,86F
....................       read_macro(macro); 
183F0:  MOVFF  86F,870
183F4:  BRA    18374
....................    }    
183F6:  BRA    183FC
....................    else cmd_arg(); 
183F8:  CALL   B070
183FC:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
1854E:  DECFSZ 44,W
18550:  BRA    1856A
18552:  MOVF   45,F
18554:  BNZ   1856A
18556:  MOVF   46,F
18558:  BNZ   1856A
1855A:  MOVF   47,F
1855C:  BNZ   1856A
....................       RTC_alarm(); 
1855E:  BRA    18400
....................       RTC_late(); 
18560:  CALL   15392
....................       RTC_alarm_status(); 
18564:  CALL   1584C
....................    } 
18568:  BRA    1856E
....................    else cmd_arg(); 
1856A:  CALL   B070
1856E:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
18572:  MOVF   44,W
18574:  MOVWF  00
18576:  MOVF   45,W
18578:  MOVWF  03
1857A:  BNZ   18580
1857C:  MOVF   00,F
1857E:  BZ    185B4
18580:  MOVF   03,W
18582:  BNZ   1858A
18584:  MOVLW  02
18586:  SUBWF  00,W
18588:  BZ    185B4
1858A:  MOVF   03,W
1858C:  BNZ   18594
1858E:  MOVLW  03
18590:  SUBWF  00,W
18592:  BZ    185B4
18594:  MOVF   03,W
18596:  BNZ   1859E
18598:  MOVLW  04
1859A:  SUBWF  00,W
1859C:  BZ    185B4
1859E:  MOVF   03,W
185A0:  BNZ   185A8
185A2:  MOVLW  05
185A4:  SUBWF  00,W
185A6:  BZ    185B4
185A8:  MOVF   03,W
185AA:  BNZ   185B2
185AC:  MOVLW  06
185AE:  SUBWF  00,W
185B0:  BZ    185B4
185B2:  BRA    185D2
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
185B4:  MOVFF  45,20
185B8:  MOVFF  44,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
185BC:  MOVLW  1C
185BE:  MOVLB  8
185C0:  MOVWF  xD8
185C2:  MOVFF  20,8DA
185C6:  MOVFF  1F,8D9
185CA:  MOVLB  0
185CC:  CALL   502C
....................          break; 
185D0:  BRA    185D6
....................       default: cmd_arg(); 
185D2:  CALL   B070
....................          break; 
....................    } 
185D6:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
185DA:  CALL   2A22
....................     
....................    switch(arg){ 
185DE:  MOVFF  44,00
185E2:  MOVF   45,W
185E4:  MOVWF  03
185E6:  BNZ   185EC
185E8:  MOVF   00,F
185EA:  BZ    18670
185EC:  MOVF   03,W
185EE:  BNZ   185F6
185F0:  MOVLW  0A
185F2:  SUBWF  00,W
185F4:  BZ    18670
185F6:  MOVF   03,W
185F8:  BNZ   18600
185FA:  MOVLW  01
185FC:  SUBWF  00,W
185FE:  BZ    18678
18600:  MOVF   03,W
18602:  BNZ   1860A
18604:  MOVLW  0B
18606:  SUBWF  00,W
18608:  BZ    18678
1860A:  MOVF   03,W
1860C:  BNZ   18614
1860E:  MOVLW  14
18610:  SUBWF  00,W
18612:  BZ    18682
18614:  MOVF   03,W
18616:  BNZ   1861E
18618:  MOVLW  15
1861A:  SUBWF  00,W
1861C:  BZ    18688
1861E:  MOVF   03,W
18620:  BNZ   18628
18622:  MOVLW  1E
18624:  SUBWF  00,W
18626:  BZ    1868E
18628:  MOVF   03,W
1862A:  BNZ   18632
1862C:  MOVLW  1F
1862E:  SUBWF  00,W
18630:  BZ    18694
18632:  MOVF   03,W
18634:  BNZ   1863C
18636:  MOVLW  28
18638:  SUBWF  00,W
1863A:  BZ    1869A
1863C:  MOVF   03,W
1863E:  BNZ   18646
18640:  MOVLW  29
18642:  SUBWF  00,W
18644:  BZ    186A0
18646:  MOVF   03,W
18648:  BNZ   18650
1864A:  MOVLW  32
1864C:  SUBWF  00,W
1864E:  BZ    186A6
18650:  MOVF   03,W
18652:  BNZ   1865A
18654:  MOVLW  33
18656:  SUBWF  00,W
18658:  BZ    186AC
1865A:  MOVF   03,W
1865C:  BNZ   18664
1865E:  MOVLW  3C
18660:  SUBWF  00,W
18662:  BZ    186B2
18664:  MOVF   03,W
18666:  BNZ   1866E
18668:  MOVLW  3D
1866A:  SUBWF  00,W
1866C:  BZ    186C0
1866E:  BRA    186D2
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
18670:  BCF    F90.7
....................                bus_pwr_status=0; 
18672:  MOVLB  4
18674:  CLRF   xB2
....................          break; 
18676:  BRA    186D8
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18678:  BSF    F90.7
....................                bus_pwr_status=1; 
1867A:  MOVLW  01
1867C:  MOVLB  4
1867E:  MOVWF  xB2
....................          break; 
18680:  BRA    186D8
....................       case 20: output_bit(VMOT,OFF); 
18682:  BCF    F8E.1
....................          break; 
18684:  MOVLB  4
18686:  BRA    186D8
....................       case 21: output_bit(VMOT,ON); 
18688:  BSF    F8E.1
....................          break; 
1868A:  MOVLB  4
1868C:  BRA    186D8
....................       case 30: output_bit(VENC1,OFF); 
1868E:  BCF    F8E.6
....................          break; 
18690:  MOVLB  4
18692:  BRA    186D8
....................       case 31: output_bit(VENC1,ON); 
18694:  BSF    F8E.6
....................          break; 
18696:  MOVLB  4
18698:  BRA    186D8
....................       case 40: output_bit(VENC2,OFF); 
1869A:  BCF    F8E.7
....................          break; 
1869C:  MOVLB  4
1869E:  BRA    186D8
....................       case 41: output_bit(VENC2,ON); 
186A0:  BSF    F8E.7
....................          break; 
186A2:  MOVLB  4
186A4:  BRA    186D8
....................       case 50: output_bit(VHBRDG,OFF); 
186A6:  BCF    F8E.2
....................          break; 
186A8:  MOVLB  4
186AA:  BRA    186D8
....................       case 51: output_bit(VHBRDG,ON); 
186AC:  BSF    F8E.2
....................          break;          
186AE:  MOVLB  4
186B0:  BRA    186D8
....................       case 60: set_heaters(0); 
186B2:  MOVLB  8
186B4:  CLRF   xAF
186B6:  MOVLB  0
186B8:  CALL   124B0
....................          break; 
186BC:  MOVLB  4
186BE:  BRA    186D8
....................       case 61: set_heaters(3); 
186C0:  MOVLW  03
186C2:  MOVLB  8
186C4:  MOVWF  xAF
186C6:  MOVLB  0
186C8:  CALL   124B0
....................          break; 
186CC:  MOVLB  4
186CE:  BRA    186D8
186D0:  MOVLB  0
....................       default : cmd_arg(); 
186D2:  CALL   B070
....................          break;          
186D6:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
186D8:  MOVLB  0
186DA:  CALL   AEAC
186DE:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
186E2:  MOVF   44,F
186E4:  BNZ   18700
186E6:  MOVF   45,F
186E8:  BNZ   18700
186EA:  MOVF   46,F
186EC:  BNZ   18700
186EE:  MOVF   47,F
186F0:  BNZ   18700
....................       motor_sleep_rdy(); 
186F2:  CALL   29FA
....................       shutdown(); 
186F6:  CALL   1586E
....................       go_to_sleep(); 
186FA:  CALL   15AD6
....................    } 
186FE:  BRA    18704
....................    else cmd_arg(); 
18700:  CALL   B070
18704:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
18832:  DECFSZ 44,W
18834:  BRA    18846
18836:  MOVF   45,F
18838:  BNZ   18846
1883A:  MOVF   46,F
1883C:  BNZ   18846
1883E:  MOVF   47,F
18840:  BNZ   18846
18842:  BRA    1872C
18844:  BRA    1884A
....................    else cmd_arg(); 
18846:  CALL   B070
1884A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
1884E:  MOVF   47,F
18850:  BNZ   188E0
18852:  MOVF   46,F
18854:  BNZ   188E0
18856:  MOVF   45,W
18858:  SUBLW  27
1885A:  BNC   188E0
1885C:  BNZ   18864
1885E:  MOVF   44,W
18860:  SUBLW  10
18862:  BNC   188E0
....................       m_bklsh[motor] = arg; 
18864:  BCF    FD8.0
18866:  MOVLB  7
18868:  RLCF   x3C,W
1886A:  CLRF   03
1886C:  ADDLW  6E
1886E:  MOVWF  FE9
18870:  MOVLW  07
18872:  ADDWFC 03,W
18874:  MOVWF  FEA
18876:  MOVFF  44,FEF
1887A:  MOVFF  45,FEC
....................       switch(motor){ 
1887E:  MOVF   x3C,W
18880:  XORLW  00
18882:  MOVLB  0
18884:  BZ    1888C
18886:  XORLW  01
18888:  BZ    188B6
1888A:  BRA    188DE
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
1888C:  BCF    FD8.0
1888E:  MOVLB  7
18890:  RLCF   x3C,W
18892:  CLRF   03
18894:  ADDLW  6E
18896:  MOVWF  FE9
18898:  MOVLW  07
1889A:  ADDWFC 03,W
1889C:  MOVWF  FEA
1889E:  MOVFF  FEC,8DA
188A2:  MOVF   FED,F
188A4:  MOVFF  FEF,8D9
188A8:  MOVLW  72
188AA:  MOVLB  8
188AC:  MOVWF  xD8
188AE:  MOVLB  0
188B0:  CALL   502C
....................             break; 
188B4:  BRA    188DE
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
188B6:  BCF    FD8.0
188B8:  MOVLB  7
188BA:  RLCF   x3C,W
188BC:  CLRF   03
188BE:  ADDLW  6E
188C0:  MOVWF  FE9
188C2:  MOVLW  07
188C4:  ADDWFC 03,W
188C6:  MOVWF  FEA
188C8:  MOVFF  FEC,8DA
188CC:  MOVF   FED,F
188CE:  MOVFF  FEF,8D9
188D2:  MOVLW  74
188D4:  MOVLB  8
188D6:  MOVWF  xD8
188D8:  MOVLB  0
188DA:  CALL   502C
....................             break;             
....................       } 
....................    } 
188DE:  BRA    188E4
....................    else cmd_arg();    
188E0:  CALL   B070
188E4:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
188E8:  MOVF   47,F
188EA:  BNZ   18976
188EC:  MOVF   46,F
188EE:  BNZ   18976
188F0:  MOVF   45,F
188F2:  BNZ   18976
188F4:  MOVF   44,W
188F6:  SUBLW  01
188F8:  BNC   18976
....................       m_pos_dir[motor] = arg; 
188FA:  BCF    FD8.0
188FC:  MOVLB  7
188FE:  RLCF   x3C,W
18900:  CLRF   03
18902:  ADDLW  4A
18904:  MOVWF  FE9
18906:  MOVLW  07
18908:  ADDWFC 03,W
1890A:  MOVWF  FEA
1890C:  MOVFF  44,FEF
18910:  MOVFF  45,FEC
....................       switch(motor){ 
18914:  MOVF   x3C,W
18916:  XORLW  00
18918:  MOVLB  0
1891A:  BZ    18922
1891C:  XORLW  01
1891E:  BZ    1894C
18920:  BRA    18974
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
18922:  BCF    FD8.0
18924:  MOVLB  7
18926:  RLCF   x3C,W
18928:  CLRF   03
1892A:  ADDLW  4A
1892C:  MOVWF  FE9
1892E:  MOVLW  07
18930:  ADDWFC 03,W
18932:  MOVWF  FEA
18934:  MOVFF  FEC,8DA
18938:  MOVF   FED,F
1893A:  MOVFF  FEF,8D9
1893E:  MOVLW  92
18940:  MOVLB  8
18942:  MOVWF  xD8
18944:  MOVLB  0
18946:  CALL   502C
....................             break; 
1894A:  BRA    18974
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
1894C:  BCF    FD8.0
1894E:  MOVLB  7
18950:  RLCF   x3C,W
18952:  CLRF   03
18954:  ADDLW  4A
18956:  MOVWF  FE9
18958:  MOVLW  07
1895A:  ADDWFC 03,W
1895C:  MOVWF  FEA
1895E:  MOVFF  FEC,8DA
18962:  MOVF   FED,F
18964:  MOVFF  FEF,8D9
18968:  MOVLW  94
1896A:  MOVLB  8
1896C:  MOVWF  xD8
1896E:  MOVLB  0
18970:  CALL   502C
....................             break;             
....................       } 
....................    } 
18974:  BRA    1897A
....................    else cmd_arg();    
18976:  CALL   B070
1897A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
1897E:  MOVF   47,F
18980:  BNZ   18A10
18982:  MOVF   46,F
18984:  BNZ   18A10
18986:  MOVF   45,W
18988:  SUBLW  27
1898A:  BNC   18A10
1898C:  BNZ   18994
1898E:  MOVF   44,W
18990:  SUBLW  10
18992:  BNC   18A10
....................       e_cpr[motor] = arg; 
18994:  BCF    FD8.0
18996:  MOVLB  7
18998:  RLCF   x3C,W
1899A:  CLRF   03
1899C:  ADDLW  5A
1899E:  MOVWF  FE9
189A0:  MOVLW  07
189A2:  ADDWFC 03,W
189A4:  MOVWF  FEA
189A6:  MOVFF  44,FEF
189AA:  MOVFF  45,FEC
....................       switch(motor){ 
189AE:  MOVF   x3C,W
189B0:  XORLW  00
189B2:  MOVLB  0
189B4:  BZ    189BC
189B6:  XORLW  01
189B8:  BZ    189E6
189BA:  BRA    18A0E
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
189BC:  BCF    FD8.0
189BE:  MOVLB  7
189C0:  RLCF   x3C,W
189C2:  CLRF   03
189C4:  ADDLW  5A
189C6:  MOVWF  FE9
189C8:  MOVLW  07
189CA:  ADDWFC 03,W
189CC:  MOVWF  FEA
189CE:  MOVFF  FEC,8DA
189D2:  MOVF   FED,F
189D4:  MOVFF  FEF,8D9
189D8:  MOVLW  A2
189DA:  MOVLB  8
189DC:  MOVWF  xD8
189DE:  MOVLB  0
189E0:  CALL   502C
....................             break; 
189E4:  BRA    18A0E
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
189E6:  BCF    FD8.0
189E8:  MOVLB  7
189EA:  RLCF   x3C,W
189EC:  CLRF   03
189EE:  ADDLW  5A
189F0:  MOVWF  FE9
189F2:  MOVLW  07
189F4:  ADDWFC 03,W
189F6:  MOVWF  FEA
189F8:  MOVFF  FEC,8DA
189FC:  MOVF   FED,F
189FE:  MOVFF  FEF,8D9
18A02:  MOVLW  A4
18A04:  MOVLB  8
18A06:  MOVWF  xD8
18A08:  MOVLB  0
18A0A:  CALL   502C
....................             break;             
....................       } 
....................    } 
18A0E:  BRA    18A14
....................    else cmd_arg();    
18A10:  CALL   B070
18A14:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18A18:  MOVF   47,F
18A1A:  BNZ   18A30
18A1C:  MOVF   46,F
18A1E:  BNZ   18A30
18A20:  MOVF   45,F
18A22:  BNZ   18A30
18A24:  MOVF   44,W
18A26:  SUBLW  01
18A28:  BNC   18A30
18A2A:  MOVFF  44,73D
18A2E:  BRA    18A34
....................    else cmd_arg();    
18A30:  CALL   B070
18A34:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18A38:  MOVF   47,F
18A3A:  BNZ   18ACA
18A3C:  MOVF   46,F
18A3E:  BNZ   18ACA
18A40:  MOVF   45,W
18A42:  SUBLW  EA
18A44:  BNC   18ACA
18A46:  BNZ   18A4E
18A48:  MOVF   44,W
18A4A:  SUBLW  60
18A4C:  BNC   18ACA
....................       m_gb_err[motor] = arg; 
18A4E:  BCF    FD8.0
18A50:  MOVLB  7
18A52:  RLCF   x3C,W
18A54:  CLRF   03
18A56:  ADDLW  56
18A58:  MOVWF  FE9
18A5A:  MOVLW  07
18A5C:  ADDWFC 03,W
18A5E:  MOVWF  FEA
18A60:  MOVFF  44,FEF
18A64:  MOVFF  45,FEC
....................       switch(motor){ 
18A68:  MOVF   x3C,W
18A6A:  XORLW  00
18A6C:  MOVLB  0
18A6E:  BZ    18A76
18A70:  XORLW  01
18A72:  BZ    18AA0
18A74:  BRA    18AC8
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18A76:  BCF    FD8.0
18A78:  MOVLB  7
18A7A:  RLCF   x3C,W
18A7C:  CLRF   03
18A7E:  ADDLW  56
18A80:  MOVWF  FE9
18A82:  MOVLW  07
18A84:  ADDWFC 03,W
18A86:  MOVWF  FEA
18A88:  MOVFF  FEC,8DA
18A8C:  MOVF   FED,F
18A8E:  MOVFF  FEF,8D9
18A92:  MOVLW  9E
18A94:  MOVLB  8
18A96:  MOVWF  xD8
18A98:  MOVLB  0
18A9A:  CALL   502C
....................             break; 
18A9E:  BRA    18AC8
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
18AA0:  BCF    FD8.0
18AA2:  MOVLB  7
18AA4:  RLCF   x3C,W
18AA6:  CLRF   03
18AA8:  ADDLW  56
18AAA:  MOVWF  FE9
18AAC:  MOVLW  07
18AAE:  ADDWFC 03,W
18AB0:  MOVWF  FEA
18AB2:  MOVFF  FEC,8DA
18AB6:  MOVF   FED,F
18AB8:  MOVFF  FEF,8D9
18ABC:  MOVLW  A0
18ABE:  MOVLB  8
18AC0:  MOVWF  xD8
18AC2:  MOVLB  0
18AC4:  CALL   502C
....................             break;             
....................       } 
....................    } 
18AC8:  BRA    18ACE
....................    else cmd_arg();    
18ACA:  CALL   B070
18ACE:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
18AD2:  MOVF   47,F
18AD4:  BNZ   18B9E
18AD6:  MOVF   46,F
18AD8:  BNZ   18B9E
18ADA:  MOVF   45,F
18ADC:  BNZ   18B9E
18ADE:  MOVF   44,W
18AE0:  SUBLW  64
18AE2:  BNC   18B9E
....................       hold_pc=arg; 
18AE4:  MOVFF  45,870
18AE8:  MOVFF  44,86F
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
18AEC:  BCF    FD8.0
18AEE:  MOVLB  7
18AF0:  RLCF   x3C,W
18AF2:  CLRF   03
18AF4:  ADDLW  4E
18AF6:  MOVWF  FE9
18AF8:  MOVLW  07
18AFA:  ADDWFC 03,W
18AFC:  MOVWF  FEA
18AFE:  MOVFF  870,9F7
18B02:  MOVFF  86F,9F6
18B06:  MOVLW  01
18B08:  MOVLB  9
18B0A:  MOVWF  xF9
18B0C:  SETF   xF8
18B0E:  MOVLB  0
18B10:  CALL   5D14
18B14:  MOVFF  02,874
18B18:  MOVFF  01,873
18B1C:  MOVFF  02,8C6
18B20:  MOVFF  01,8C5
18B24:  MOVLB  8
18B26:  CLRF   xC8
18B28:  MOVLW  64
18B2A:  MOVWF  xC7
18B2C:  MOVLB  0
18B2E:  CALL   2D36
18B32:  MOVFF  01,FEF
18B36:  MOVFF  02,FEC
....................       switch(motor){ 
18B3A:  MOVLB  7
18B3C:  MOVF   x3C,W
18B3E:  XORLW  00
18B40:  MOVLB  0
18B42:  BZ    18B4A
18B44:  XORLW  01
18B46:  BZ    18B74
18B48:  BRA    18B9C
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
18B4A:  BCF    FD8.0
18B4C:  MOVLB  7
18B4E:  RLCF   x3C,W
18B50:  CLRF   03
18B52:  ADDLW  4E
18B54:  MOVWF  FE9
18B56:  MOVLW  07
18B58:  ADDWFC 03,W
18B5A:  MOVWF  FEA
18B5C:  MOVFF  FEC,8DA
18B60:  MOVF   FED,F
18B62:  MOVFF  FEF,8D9
18B66:  MOVLW  96
18B68:  MOVLB  8
18B6A:  MOVWF  xD8
18B6C:  MOVLB  0
18B6E:  CALL   502C
....................             break; 
18B72:  BRA    18B9C
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
18B74:  BCF    FD8.0
18B76:  MOVLB  7
18B78:  RLCF   x3C,W
18B7A:  CLRF   03
18B7C:  ADDLW  4E
18B7E:  MOVWF  FE9
18B80:  MOVLW  07
18B82:  ADDWFC 03,W
18B84:  MOVWF  FEA
18B86:  MOVFF  FEC,8DA
18B8A:  MOVF   FED,F
18B8C:  MOVFF  FEF,8D9
18B90:  MOVLW  98
18B92:  MOVLB  8
18B94:  MOVWF  xD8
18B96:  MOVLB  0
18B98:  CALL   502C
....................             break;             
....................       } 
....................    } 
18B9C:  BRA    18BA2
....................    else cmd_arg();    
18B9E:  CALL   B070
18BA2:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
18BA6:  MOVF   47,F
18BA8:  BNZ   18C7A
18BAA:  MOVF   46,F
18BAC:  BNZ   18C7A
18BAE:  MOVF   45,W
18BB0:  SUBLW  EA
18BB2:  BNC   18C7A
18BB4:  BNZ   18BBC
18BB6:  MOVF   44,W
18BB8:  SUBLW  60
18BBA:  BNC   18C7A
....................       m_stp_int[motor] = (arg/100); 
18BBC:  BCF    FD8.0
18BBE:  MOVLB  7
18BC0:  RLCF   x3C,W
18BC2:  CLRF   03
18BC4:  ADDLW  46
18BC6:  MOVWF  FE9
18BC8:  MOVLW  07
18BCA:  ADDWFC 03,W
18BCC:  MOVWF  FEA
18BCE:  MOVFF  FEA,872
18BD2:  MOVFF  FE9,871
18BD6:  BCF    FD8.1
18BD8:  CLRF   1B
18BDA:  BTFSC  FF2.7
18BDC:  BSF    1B.7
18BDE:  BCF    FF2.7
18BE0:  MOVFF  47,A34
18BE4:  MOVFF  46,A33
18BE8:  MOVFF  45,A32
18BEC:  MOVFF  44,A31
18BF0:  MOVLB  A
18BF2:  CLRF   x38
18BF4:  CLRF   x37
18BF6:  CLRF   x36
18BF8:  MOVLW  64
18BFA:  MOVWF  x35
18BFC:  MOVLB  0
18BFE:  CALL   1050
18C02:  BTFSC  1B.7
18C04:  BSF    FF2.7
18C06:  MOVFF  872,FEA
18C0A:  MOVFF  871,FE9
18C0E:  MOVFF  00,FEF
18C12:  MOVFF  01,FEC
....................       switch(motor){ 
18C16:  MOVLB  7
18C18:  MOVF   x3C,W
18C1A:  XORLW  00
18C1C:  MOVLB  0
18C1E:  BZ    18C26
18C20:  XORLW  01
18C22:  BZ    18C50
18C24:  BRA    18C78
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
18C26:  BCF    FD8.0
18C28:  MOVLB  7
18C2A:  RLCF   x3C,W
18C2C:  CLRF   03
18C2E:  ADDLW  46
18C30:  MOVWF  FE9
18C32:  MOVLW  07
18C34:  ADDWFC 03,W
18C36:  MOVWF  FEA
18C38:  MOVFF  FEC,8DA
18C3C:  MOVF   FED,F
18C3E:  MOVFF  FEF,8D9
18C42:  MOVLW  8E
18C44:  MOVLB  8
18C46:  MOVWF  xD8
18C48:  MOVLB  0
18C4A:  CALL   502C
....................             break; 
18C4E:  BRA    18C78
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
18C50:  BCF    FD8.0
18C52:  MOVLB  7
18C54:  RLCF   x3C,W
18C56:  CLRF   03
18C58:  ADDLW  46
18C5A:  MOVWF  FE9
18C5C:  MOVLW  07
18C5E:  ADDWFC 03,W
18C60:  MOVWF  FEA
18C62:  MOVFF  FEC,8DA
18C66:  MOVF   FED,F
18C68:  MOVFF  FEF,8D9
18C6C:  MOVLW  90
18C6E:  MOVLB  8
18C70:  MOVWF  xD8
18C72:  MOVLB  0
18C74:  CALL   502C
....................             break;             
....................       } 
....................    } 
18C78:  BRA    18C7E
....................    else cmd_arg();    
18C7A:  CALL   B070
18C7E:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
18C82:  MOVF   47,F
18C84:  BNZ   18D14
18C86:  MOVF   46,F
18C88:  BNZ   18D14
18C8A:  MOVF   45,W
18C8C:  SUBLW  27
18C8E:  BNC   18D14
18C90:  BNZ   18C98
18C92:  MOVF   44,W
18C94:  SUBLW  10
18C96:  BNC   18D14
....................       m_run[motor] = arg; 
18C98:  BCF    FD8.0
18C9A:  MOVLB  7
18C9C:  RLCF   x3C,W
18C9E:  CLRF   03
18CA0:  ADDLW  6A
18CA2:  MOVWF  FE9
18CA4:  MOVLW  07
18CA6:  ADDWFC 03,W
18CA8:  MOVWF  FEA
18CAA:  MOVFF  44,FEF
18CAE:  MOVFF  45,FEC
....................       switch(motor){ 
18CB2:  MOVF   x3C,W
18CB4:  XORLW  00
18CB6:  MOVLB  0
18CB8:  BZ    18CC0
18CBA:  XORLW  01
18CBC:  BZ    18CEA
18CBE:  BRA    18D12
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
18CC0:  BCF    FD8.0
18CC2:  MOVLB  7
18CC4:  RLCF   x3C,W
18CC6:  CLRF   03
18CC8:  ADDLW  6A
18CCA:  MOVWF  FE9
18CCC:  MOVLW  07
18CCE:  ADDWFC 03,W
18CD0:  MOVWF  FEA
18CD2:  MOVFF  FEC,8DA
18CD6:  MOVF   FED,F
18CD8:  MOVFF  FEF,8D9
18CDC:  MOVLW  76
18CDE:  MOVLB  8
18CE0:  MOVWF  xD8
18CE2:  MOVLB  0
18CE4:  CALL   502C
....................             break; 
18CE8:  BRA    18D12
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
18CEA:  BCF    FD8.0
18CEC:  MOVLB  7
18CEE:  RLCF   x3C,W
18CF0:  CLRF   03
18CF2:  ADDLW  6A
18CF4:  MOVWF  FE9
18CF6:  MOVLW  07
18CF8:  ADDWFC 03,W
18CFA:  MOVWF  FEA
18CFC:  MOVFF  FEC,8DA
18D00:  MOVF   FED,F
18D02:  MOVFF  FEF,8D9
18D06:  MOVLW  78
18D08:  MOVLB  8
18D0A:  MOVWF  xD8
18D0C:  MOVLB  0
18D0E:  CALL   502C
....................             break;             
....................       } 
....................    } 
18D12:  BRA    18D18
....................    else cmd_arg();    
18D14:  CALL   B070
18D18:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
18D1C:  MOVF   47,F
18D1E:  BNZ   18DAA
18D20:  MOVF   46,F
18D22:  BNZ   18DAA
18D24:  MOVF   45,F
18D26:  BNZ   18DAA
18D28:  MOVF   44,W
18D2A:  SUBLW  03
18D2C:  BNC   18DAA
....................       e_mode[motor] = arg; 
18D2E:  BCF    FD8.0
18D30:  MOVLB  7
18D32:  RLCF   x3C,W
18D34:  CLRF   03
18D36:  ADDLW  62
18D38:  MOVWF  FE9
18D3A:  MOVLW  07
18D3C:  ADDWFC 03,W
18D3E:  MOVWF  FEA
18D40:  MOVFF  44,FEF
18D44:  MOVFF  45,FEC
....................       switch(motor){ 
18D48:  MOVF   x3C,W
18D4A:  XORLW  00
18D4C:  MOVLB  0
18D4E:  BZ    18D56
18D50:  XORLW  01
18D52:  BZ    18D80
18D54:  BRA    18DA8
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
18D56:  BCF    FD8.0
18D58:  MOVLB  7
18D5A:  RLCF   x3C,W
18D5C:  CLRF   03
18D5E:  ADDLW  62
18D60:  MOVWF  FE9
18D62:  MOVLW  07
18D64:  ADDWFC 03,W
18D66:  MOVWF  FEA
18D68:  MOVFF  FEC,8DA
18D6C:  MOVF   FED,F
18D6E:  MOVFF  FEF,8D9
18D72:  MOVLW  82
18D74:  MOVLB  8
18D76:  MOVWF  xD8
18D78:  MOVLB  0
18D7A:  CALL   502C
....................             break; 
18D7E:  BRA    18DA8
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
18D80:  BCF    FD8.0
18D82:  MOVLB  7
18D84:  RLCF   x3C,W
18D86:  CLRF   03
18D88:  ADDLW  62
18D8A:  MOVWF  FE9
18D8C:  MOVLW  07
18D8E:  ADDWFC 03,W
18D90:  MOVWF  FEA
18D92:  MOVFF  FEC,8DA
18D96:  MOVF   FED,F
18D98:  MOVFF  FEF,8D9
18D9C:  MOVLW  84
18D9E:  MOVLB  8
18DA0:  MOVWF  xD8
18DA2:  MOVLB  0
18DA4:  CALL   502C
....................             break;             
....................       } 
....................    } 
18DA8:  BRA    18DAE
....................    else cmd_arg();    
18DAA:  CALL   B070
18DAE:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
19A12:  MOVF   47,F
19A14:  BNZ   19AA0
19A16:  MOVF   46,F
19A18:  BNZ   19AA0
19A1A:  MOVF   45,F
19A1C:  BNZ   19AA0
19A1E:  MOVF   44,W
19A20:  SUBLW  01
19A22:  BNC   19AA0
....................       m_mode[motor] = arg; 
19A24:  BCF    FD8.0
19A26:  MOVLB  7
19A28:  RLCF   x3C,W
19A2A:  CLRF   03
19A2C:  ADDLW  42
19A2E:  MOVWF  FE9
19A30:  MOVLW  07
19A32:  ADDWFC 03,W
19A34:  MOVWF  FEA
19A36:  MOVFF  44,FEF
19A3A:  MOVFF  45,FEC
....................       switch(motor){ 
19A3E:  MOVF   x3C,W
19A40:  XORLW  00
19A42:  MOVLB  0
19A44:  BZ    19A4C
19A46:  XORLW  01
19A48:  BZ    19A76
19A4A:  BRA    19A9E
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19A4C:  BCF    FD8.0
19A4E:  MOVLB  7
19A50:  RLCF   x3C,W
19A52:  CLRF   03
19A54:  ADDLW  42
19A56:  MOVWF  FE9
19A58:  MOVLW  07
19A5A:  ADDWFC 03,W
19A5C:  MOVWF  FEA
19A5E:  MOVFF  FEC,8DA
19A62:  MOVF   FED,F
19A64:  MOVFF  FEF,8D9
19A68:  MOVLW  8A
19A6A:  MOVLB  8
19A6C:  MOVWF  xD8
19A6E:  MOVLB  0
19A70:  CALL   502C
....................             break; 
19A74:  BRA    19A9E
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19A76:  BCF    FD8.0
19A78:  MOVLB  7
19A7A:  RLCF   x3C,W
19A7C:  CLRF   03
19A7E:  ADDLW  42
19A80:  MOVWF  FE9
19A82:  MOVLW  07
19A84:  ADDWFC 03,W
19A86:  MOVWF  FEA
19A88:  MOVFF  FEC,8DA
19A8C:  MOVF   FED,F
19A8E:  MOVFF  FEF,8D9
19A92:  MOVLW  8C
19A94:  MOVLB  8
19A96:  MOVWF  xD8
19A98:  MOVLB  0
19A9A:  CALL   502C
....................             break;             
....................       } 
....................    } 
19A9E:  BRA    19AA4
....................    else cmd_arg();    
19AA0:  CALL   B070
19AA4:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19AA8:  MOVF   47,F
19AAA:  BNZ   19B36
19AAC:  MOVF   46,F
19AAE:  BNZ   19B36
19AB0:  MOVF   45,F
19AB2:  BNZ   19B36
19AB4:  MOVF   44,W
19AB6:  SUBLW  01
19AB8:  BNC   19B36
....................       e_index[motor] = arg; 
19ABA:  BCF    FD8.0
19ABC:  MOVLB  7
19ABE:  RLCF   x3C,W
19AC0:  CLRF   03
19AC2:  ADDLW  76
19AC4:  MOVWF  FE9
19AC6:  MOVLW  07
19AC8:  ADDWFC 03,W
19ACA:  MOVWF  FEA
19ACC:  MOVFF  44,FEF
19AD0:  MOVFF  45,FEC
....................       switch(motor){ 
19AD4:  MOVF   x3C,W
19AD6:  XORLW  00
19AD8:  MOVLB  0
19ADA:  BZ    19AE2
19ADC:  XORLW  01
19ADE:  BZ    19B0C
19AE0:  BRA    19B34
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
19AE2:  BCF    FD8.0
19AE4:  MOVLB  7
19AE6:  RLCF   x3C,W
19AE8:  CLRF   03
19AEA:  ADDLW  76
19AEC:  MOVWF  FE9
19AEE:  MOVLW  07
19AF0:  ADDWFC 03,W
19AF2:  MOVWF  FEA
19AF4:  MOVFF  FEC,8DA
19AF8:  MOVF   FED,F
19AFA:  MOVFF  FEF,8D9
19AFE:  MOVLW  BA
19B00:  MOVLB  8
19B02:  MOVWF  xD8
19B04:  MOVLB  0
19B06:  CALL   502C
....................             break; 
19B0A:  BRA    19B34
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
19B0C:  BCF    FD8.0
19B0E:  MOVLB  7
19B10:  RLCF   x3C,W
19B12:  CLRF   03
19B14:  ADDLW  76
19B16:  MOVWF  FE9
19B18:  MOVLW  07
19B1A:  ADDWFC 03,W
19B1C:  MOVWF  FEA
19B1E:  MOVFF  FEC,8DA
19B22:  MOVF   FED,F
19B24:  MOVFF  FEF,8D9
19B28:  MOVLW  BC
19B2A:  MOVLB  8
19B2C:  MOVWF  xD8
19B2E:  MOVLB  0
19B30:  CALL   502C
....................             break;             
....................       } 
....................    } 
19B34:  BRA    19B3A
....................    else cmd_arg();    
19B36:  CALL   B070
19B3A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
19B3E:  MOVF   47,F
19B40:  BNZ   19BD0
19B42:  MOVF   46,F
19B44:  BNZ   19BD0
19B46:  MOVF   45,W
19B48:  SUBLW  01
19B4A:  BNC   19BD0
19B4C:  BNZ   19B54
19B4E:  MOVF   44,W
19B50:  SUBLW  0A
19B52:  BNC   19BD0
....................        evn_so[motor] = arg; 
19B54:  BCF    FD8.0
19B56:  MOVLB  7
19B58:  RLCF   x3C,W
19B5A:  CLRF   03
19B5C:  ADDLW  7A
19B5E:  MOVWF  FE9
19B60:  MOVLW  07
19B62:  ADDWFC 03,W
19B64:  MOVWF  FEA
19B66:  MOVFF  44,FEF
19B6A:  MOVFF  45,FEC
....................        switch(motor){ 
19B6E:  MOVF   x3C,W
19B70:  XORLW  00
19B72:  MOVLB  0
19B74:  BZ    19B7C
19B76:  XORLW  01
19B78:  BZ    19BA6
19B7A:  BRA    19BCE
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
19B7C:  BCF    FD8.0
19B7E:  MOVLB  7
19B80:  RLCF   x3C,W
19B82:  CLRF   03
19B84:  ADDLW  7A
19B86:  MOVWF  FE9
19B88:  MOVLW  07
19B8A:  ADDWFC 03,W
19B8C:  MOVWF  FEA
19B8E:  MOVFF  FEC,8DA
19B92:  MOVF   FED,F
19B94:  MOVFF  FEF,8D9
19B98:  MOVLW  BE
19B9A:  MOVLB  8
19B9C:  MOVWF  xD8
19B9E:  MOVLB  0
19BA0:  CALL   502C
....................             break; 
19BA4:  BRA    19BCE
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
19BA6:  BCF    FD8.0
19BA8:  MOVLB  7
19BAA:  RLCF   x3C,W
19BAC:  CLRF   03
19BAE:  ADDLW  7A
19BB0:  MOVWF  FE9
19BB2:  MOVLW  07
19BB4:  ADDWFC 03,W
19BB6:  MOVWF  FEA
19BB8:  MOVFF  FEC,8DA
19BBC:  MOVF   FED,F
19BBE:  MOVFF  FEF,8D9
19BC2:  MOVLW  C0
19BC4:  MOVLB  8
19BC6:  MOVWF  xD8
19BC8:  MOVLB  0
19BCA:  CALL   502C
....................             break;             
....................       } 
....................    } 
19BCE:  BRA    19BD4
....................    else cmd_arg();    
19BD0:  CALL   B070
19BD4:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
19BD8:  MOVF   47,F
19BDA:  BNZ   19C6A
19BDC:  MOVF   46,F
19BDE:  BNZ   19C6A
19BE0:  MOVF   45,W
19BE2:  SUBLW  03
19BE4:  BNC   19C6A
19BE6:  BNZ   19BEE
19BE8:  MOVF   44,W
19BEA:  SUBLW  E8
19BEC:  BNC   19C6A
....................       e_ppr[motor] = arg; 
19BEE:  BCF    FD8.0
19BF0:  MOVLB  7
19BF2:  RLCF   x3C,W
19BF4:  CLRF   03
19BF6:  ADDLW  5E
19BF8:  MOVWF  FE9
19BFA:  MOVLW  07
19BFC:  ADDWFC 03,W
19BFE:  MOVWF  FEA
19C00:  MOVFF  44,FEF
19C04:  MOVFF  45,FEC
....................       switch(motor){ 
19C08:  MOVF   x3C,W
19C0A:  XORLW  00
19C0C:  MOVLB  0
19C0E:  BZ    19C16
19C10:  XORLW  01
19C12:  BZ    19C40
19C14:  BRA    19C68
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
19C16:  BCF    FD8.0
19C18:  MOVLB  7
19C1A:  RLCF   x3C,W
19C1C:  CLRF   03
19C1E:  ADDLW  5E
19C20:  MOVWF  FE9
19C22:  MOVLW  07
19C24:  ADDWFC 03,W
19C26:  MOVWF  FEA
19C28:  MOVFF  FEC,8DA
19C2C:  MOVF   FED,F
19C2E:  MOVFF  FEF,8D9
19C32:  MOVLW  A6
19C34:  MOVLB  8
19C36:  MOVWF  xD8
19C38:  MOVLB  0
19C3A:  CALL   502C
....................             break; 
19C3E:  BRA    19C68
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
19C40:  BCF    FD8.0
19C42:  MOVLB  7
19C44:  RLCF   x3C,W
19C46:  CLRF   03
19C48:  ADDLW  5E
19C4A:  MOVWF  FE9
19C4C:  MOVLW  07
19C4E:  ADDWFC 03,W
19C50:  MOVWF  FEA
19C52:  MOVFF  FEC,8DA
19C56:  MOVF   FED,F
19C58:  MOVFF  FEF,8D9
19C5C:  MOVLW  A8
19C5E:  MOVLB  8
19C60:  MOVWF  xD8
19C62:  MOVLB  0
19C64:  CALL   502C
....................             break;             
....................       } 
....................    } 
19C68:  BRA    19C6E
....................    else cmd_arg();    
19C6A:  CALL   B070
19C6E:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
19C72:  MOVF   44,F
19C74:  BNZ   19C86
19C76:  MOVF   45,F
19C78:  BNZ   19C86
19C7A:  MOVF   46,F
19C7C:  BNZ   19C86
19C7E:  MOVF   47,F
19C80:  BNZ   19C86
19C82:  BCF    F8E.1
19C84:  BRA    19C8A
....................    else cmd_arg();    
19C86:  CALL   B070
19C8A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1A76E:  MOVF   44,F
1A770:  BNZ   1A7C0
1A772:  MOVF   45,F
1A774:  BNZ   1A7C0
1A776:  MOVF   46,F
1A778:  BNZ   1A7C0
1A77A:  MOVF   47,F
1A77C:  BNZ   1A7C0
....................       switch (nv_product) { 
1A77E:  MOVFF  2F,00
1A782:  MOVF   30,W
1A784:  MOVWF  03
1A786:  BNZ   1A78C
1A788:  MOVF   00,F
1A78A:  BZ    1A7AC
1A78C:  MOVF   03,W
1A78E:  BNZ   1A796
1A790:  MOVLW  01
1A792:  SUBWF  00,W
1A794:  BZ    1A7B2
1A796:  MOVF   03,W
1A798:  BNZ   1A7A0
1A79A:  MOVLW  02
1A79C:  SUBWF  00,W
1A79E:  BZ    1A7B8
1A7A0:  MOVF   03,W
1A7A2:  BNZ   1A7AA
1A7A4:  MOVLW  03
1A7A6:  SUBWF  00,W
1A7A8:  BZ    1A7BC
1A7AA:  BRA    1A7BE
....................          case ECO : rst_step_vars_eco(); 
1A7AC:  GOTO   19C8E
....................             break; 
1A7B0:  BRA    1A7BE
....................          case WMS4 : rst_step_vars_wms4(); 
1A7B2:  GOTO   19F78
....................             break; 
1A7B6:  BRA    1A7BE
....................          case AWS : rst_step_vars_aws(); 
1A7B8:  BRA    1A224
....................             break;             
1A7BA:  BRA    1A7BE
....................          case WMS2 : rst_step_vars_wms2(); 
1A7BC:  BRA    1A4BE
....................             break; 
....................       } 
....................    }  
1A7BE:  BRA    1A7C4
....................    else cmd_arg(); 
1A7C0:  CALL   B070
1A7C4:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1A7C8:  MOVF   47,F
1A7CA:  BTFSS  FD8.2
1A7CC:  BRA    1A8CE
1A7CE:  MOVF   46,W
1A7D0:  SUBLW  00
1A7D2:  BTFSS  FD8.0
1A7D4:  BRA    1A8CE
....................       m_spr[motor] = arg; 
1A7D6:  BCF    FD8.0
1A7D8:  MOVLB  7
1A7DA:  RLCF   x3C,W
1A7DC:  CLRF   03
1A7DE:  ADDLW  72
1A7E0:  MOVWF  FE9
1A7E2:  MOVLW  07
1A7E4:  ADDWFC 03,W
1A7E6:  MOVWF  FEA
1A7E8:  MOVFF  44,FEF
1A7EC:  MOVFF  45,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1A7F0:  BCF    FD8.0
1A7F2:  RLCF   x3C,W
1A7F4:  CLRF   03
1A7F6:  ADDLW  A7
1A7F8:  MOVWF  01
1A7FA:  MOVLW  07
1A7FC:  ADDWFC 03,F
1A7FE:  MOVFF  01,86F
1A802:  MOVLB  8
1A804:  MOVFF  03,870
1A808:  BCF    FD8.0
1A80A:  MOVLB  7
1A80C:  RLCF   x3C,W
1A80E:  CLRF   03
1A810:  ADDLW  72
1A812:  MOVWF  FE9
1A814:  MOVLW  07
1A816:  ADDWFC 03,W
1A818:  MOVWF  FEA
1A81A:  MOVFF  FEC,8C6
1A81E:  MOVF   FED,F
1A820:  MOVFF  FEF,8C5
1A824:  BCF    FD8.0
1A826:  RLCF   x3C,W
1A828:  CLRF   03
1A82A:  ADDLW  5E
1A82C:  MOVWF  FE9
1A82E:  MOVLW  07
1A830:  ADDWFC 03,W
1A832:  MOVWF  FEA
1A834:  MOVFF  FEC,03
1A838:  MOVF   FED,F
1A83A:  MOVFF  FEF,8C7
1A83E:  MOVFF  03,874
1A842:  MOVFF  03,8C8
1A846:  MOVLB  0
1A848:  CALL   2D36
1A84C:  MOVFF  02,872
1A850:  BCF    FD8.0
1A852:  MOVLB  8
1A854:  RLCF   01,W
1A856:  MOVWF  02
1A858:  RLCF   x72,W
1A85A:  MOVFF  870,FEA
1A85E:  MOVFF  86F,FE9
1A862:  MOVWF  FEC
1A864:  MOVF   FED,F
1A866:  MOVFF  02,FEF
....................       switch(motor){ 
1A86A:  MOVLB  7
1A86C:  MOVF   x3C,W
1A86E:  XORLW  00
1A870:  MOVLB  0
1A872:  BZ    1A87A
1A874:  XORLW  01
1A876:  BZ    1A8A4
1A878:  BRA    1A8CC
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1A87A:  BCF    FD8.0
1A87C:  MOVLB  7
1A87E:  RLCF   x3C,W
1A880:  CLRF   03
1A882:  ADDLW  72
1A884:  MOVWF  FE9
1A886:  MOVLW  07
1A888:  ADDWFC 03,W
1A88A:  MOVWF  FEA
1A88C:  MOVFF  FEC,8DA
1A890:  MOVF   FED,F
1A892:  MOVFF  FEF,8D9
1A896:  MOVLW  AE
1A898:  MOVLB  8
1A89A:  MOVWF  xD8
1A89C:  MOVLB  0
1A89E:  CALL   502C
....................             break; 
1A8A2:  BRA    1A8CC
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1A8A4:  BCF    FD8.0
1A8A6:  MOVLB  7
1A8A8:  RLCF   x3C,W
1A8AA:  CLRF   03
1A8AC:  ADDLW  72
1A8AE:  MOVWF  FE9
1A8B0:  MOVLW  07
1A8B2:  ADDWFC 03,W
1A8B4:  MOVWF  FEA
1A8B6:  MOVFF  FEC,8DA
1A8BA:  MOVF   FED,F
1A8BC:  MOVFF  FEF,8D9
1A8C0:  MOVLW  B0
1A8C2:  MOVLB  8
1A8C4:  MOVWF  xD8
1A8C6:  MOVLB  0
1A8C8:  CALL   502C
....................             break;             
....................       } 
....................    } 
1A8CC:  BRA    1A8D2
....................    else cmd_arg();    
1A8CE:  CALL   B070
1A8D2:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1A8D6:  MOVF   47,F
1A8D8:  BNZ   1A964
1A8DA:  MOVF   46,F
1A8DC:  BNZ   1A964
1A8DE:  MOVF   45,F
1A8E0:  BNZ   1A964
1A8E2:  MOVF   44,W
1A8E4:  SUBLW  02
1A8E6:  BNC   1A964
....................       e_type[motor] = arg; 
1A8E8:  BCF    FD8.0
1A8EA:  MOVLB  7
1A8EC:  RLCF   x3C,W
1A8EE:  CLRF   03
1A8F0:  ADDLW  66
1A8F2:  MOVWF  FE9
1A8F4:  MOVLW  07
1A8F6:  ADDWFC 03,W
1A8F8:  MOVWF  FEA
1A8FA:  MOVFF  44,FEF
1A8FE:  MOVFF  45,FEC
....................       switch(motor){ 
1A902:  MOVF   x3C,W
1A904:  XORLW  00
1A906:  MOVLB  0
1A908:  BZ    1A910
1A90A:  XORLW  01
1A90C:  BZ    1A93A
1A90E:  BRA    1A962
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1A910:  BCF    FD8.0
1A912:  MOVLB  7
1A914:  RLCF   x3C,W
1A916:  CLRF   03
1A918:  ADDLW  66
1A91A:  MOVWF  FE9
1A91C:  MOVLW  07
1A91E:  ADDWFC 03,W
1A920:  MOVWF  FEA
1A922:  MOVFF  FEC,8DA
1A926:  MOVF   FED,F
1A928:  MOVFF  FEF,8D9
1A92C:  MOVLW  7A
1A92E:  MOVLB  8
1A930:  MOVWF  xD8
1A932:  MOVLB  0
1A934:  CALL   502C
....................             break; 
1A938:  BRA    1A962
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1A93A:  BCF    FD8.0
1A93C:  MOVLB  7
1A93E:  RLCF   x3C,W
1A940:  CLRF   03
1A942:  ADDLW  66
1A944:  MOVWF  FE9
1A946:  MOVLW  07
1A948:  ADDWFC 03,W
1A94A:  MOVWF  FEA
1A94C:  MOVFF  FEC,8DA
1A950:  MOVF   FED,F
1A952:  MOVFF  FEF,8D9
1A956:  MOVLW  7C
1A958:  MOVLB  8
1A95A:  MOVWF  xD8
1A95C:  MOVLB  0
1A95E:  CALL   502C
....................             break;             
....................       } 
....................    } 
1A962:  BRA    1A968
....................    else cmd_arg();    
1A964:  CALL   B070
1A968:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1A9A4:  MOVF   47,F
1A9A6:  BNZ   1AA70
1A9A8:  MOVF   46,F
1A9AA:  BNZ   1AA70
1A9AC:  MOVF   45,F
1A9AE:  BNZ   1AA70
1A9B0:  MOVF   44,W
1A9B2:  SUBLW  64
1A9B4:  BNC   1AA70
....................       drive_pc=arg; 
1A9B6:  MOVFF  45,870
1A9BA:  MOVFF  44,86F
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1A9BE:  BCF    FD8.0
1A9C0:  MOVLB  7
1A9C2:  RLCF   x3C,W
1A9C4:  CLRF   03
1A9C6:  ADDLW  52
1A9C8:  MOVWF  FE9
1A9CA:  MOVLW  07
1A9CC:  ADDWFC 03,W
1A9CE:  MOVWF  FEA
1A9D0:  MOVFF  870,9F7
1A9D4:  MOVFF  86F,9F6
1A9D8:  MOVLW  01
1A9DA:  MOVLB  9
1A9DC:  MOVWF  xF9
1A9DE:  SETF   xF8
1A9E0:  MOVLB  0
1A9E2:  CALL   5D14
1A9E6:  MOVFF  02,874
1A9EA:  MOVFF  01,873
1A9EE:  MOVFF  02,8C6
1A9F2:  MOVFF  01,8C5
1A9F6:  MOVLB  8
1A9F8:  CLRF   xC8
1A9FA:  MOVLW  64
1A9FC:  MOVWF  xC7
1A9FE:  MOVLB  0
1AA00:  CALL   2D36
1AA04:  MOVFF  01,FEF
1AA08:  MOVFF  02,FEC
....................       switch(motor){ 
1AA0C:  MOVLB  7
1AA0E:  MOVF   x3C,W
1AA10:  XORLW  00
1AA12:  MOVLB  0
1AA14:  BZ    1AA1C
1AA16:  XORLW  01
1AA18:  BZ    1AA46
1AA1A:  BRA    1AA6E
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1AA1C:  BCF    FD8.0
1AA1E:  MOVLB  7
1AA20:  RLCF   x3C,W
1AA22:  CLRF   03
1AA24:  ADDLW  52
1AA26:  MOVWF  FE9
1AA28:  MOVLW  07
1AA2A:  ADDWFC 03,W
1AA2C:  MOVWF  FEA
1AA2E:  MOVFF  FEC,8DA
1AA32:  MOVF   FED,F
1AA34:  MOVFF  FEF,8D9
1AA38:  MOVLW  9A
1AA3A:  MOVLB  8
1AA3C:  MOVWF  xD8
1AA3E:  MOVLB  0
1AA40:  CALL   502C
....................             break; 
1AA44:  BRA    1AA6E
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1AA46:  BCF    FD8.0
1AA48:  MOVLB  7
1AA4A:  RLCF   x3C,W
1AA4C:  CLRF   03
1AA4E:  ADDLW  52
1AA50:  MOVWF  FE9
1AA52:  MOVLW  07
1AA54:  ADDWFC 03,W
1AA56:  MOVWF  FEA
1AA58:  MOVFF  FEC,8DA
1AA5C:  MOVF   FED,F
1AA5E:  MOVFF  FEF,8D9
1AA62:  MOVLW  9C
1AA64:  MOVLB  8
1AA66:  MOVWF  xD8
1AA68:  MOVLB  0
1AA6A:  CALL   502C
....................             break;             
....................       } 
....................    } 
1AA6E:  BRA    1AA74
....................    else cmd_arg();    
1AA70:  CALL   B070
1AA74:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1AA78:  MOVF   47,F
1AA7A:  BNZ   1AB0A
1AA7C:  MOVF   46,F
1AA7E:  BNZ   1AB0A
1AA80:  MOVF   45,W
1AA82:  SUBLW  27
1AA84:  BNC   1AB0A
1AA86:  BNZ   1AA8E
1AA88:  MOVF   44,W
1AA8A:  SUBLW  0F
1AA8C:  BNC   1AB0A
....................        align_os[motor] = arg; 
1AA8E:  BCF    FD8.0
1AA90:  MOVLB  7
1AA92:  RLCF   x3C,W
1AA94:  CLRF   03
1AA96:  ADDLW  7E
1AA98:  MOVWF  FE9
1AA9A:  MOVLW  07
1AA9C:  ADDWFC 03,W
1AA9E:  MOVWF  FEA
1AAA0:  MOVFF  44,FEF
1AAA4:  MOVFF  45,FEC
....................        switch(motor){ 
1AAA8:  MOVF   x3C,W
1AAAA:  XORLW  00
1AAAC:  MOVLB  0
1AAAE:  BZ    1AAB6
1AAB0:  XORLW  01
1AAB2:  BZ    1AAE0
1AAB4:  BRA    1AB08
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1AAB6:  BCF    FD8.0
1AAB8:  MOVLB  7
1AABA:  RLCF   x3C,W
1AABC:  CLRF   03
1AABE:  ADDLW  7E
1AAC0:  MOVWF  FE9
1AAC2:  MOVLW  07
1AAC4:  ADDWFC 03,W
1AAC6:  MOVWF  FEA
1AAC8:  MOVFF  FEC,8DA
1AACC:  MOVF   FED,F
1AACE:  MOVFF  FEF,8D9
1AAD2:  MOVLW  C2
1AAD4:  MOVLB  8
1AAD6:  MOVWF  xD8
1AAD8:  MOVLB  0
1AADA:  CALL   502C
....................             break; 
1AADE:  BRA    1AB08
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1AAE0:  BCF    FD8.0
1AAE2:  MOVLB  7
1AAE4:  RLCF   x3C,W
1AAE6:  CLRF   03
1AAE8:  ADDLW  7E
1AAEA:  MOVWF  FE9
1AAEC:  MOVLW  07
1AAEE:  ADDWFC 03,W
1AAF0:  MOVWF  FEA
1AAF2:  MOVFF  FEC,8DA
1AAF6:  MOVF   FED,F
1AAF8:  MOVFF  FEF,8D9
1AAFC:  MOVLW  C4
1AAFE:  MOVLB  8
1AB00:  MOVWF  xD8
1AB02:  MOVLB  0
1AB04:  CALL   502C
....................             break;             
....................       } 
....................    } 
1AB08:  BRA    1AB0E
....................    else cmd_arg();    
1AB0A:  CALL   B070
1AB0E:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1AB12:  MOVF   47,F
1AB14:  BNZ   1ABA0
1AB16:  MOVF   46,F
1AB18:  BNZ   1ABA0
1AB1A:  MOVF   45,F
1AB1C:  BNZ   1ABA0
1AB1E:  MOVF   44,W
1AB20:  SUBLW  01
1AB22:  BNC   1ABA0
....................       m_ctrl[motor] = arg; 
1AB24:  BCF    FD8.0
1AB26:  MOVLB  7
1AB28:  RLCF   x3C,W
1AB2A:  CLRF   03
1AB2C:  ADDLW  3E
1AB2E:  MOVWF  FE9
1AB30:  MOVLW  07
1AB32:  ADDWFC 03,W
1AB34:  MOVWF  FEA
1AB36:  MOVFF  44,FEF
1AB3A:  MOVFF  45,FEC
....................       switch(motor){ 
1AB3E:  MOVF   x3C,W
1AB40:  XORLW  00
1AB42:  MOVLB  0
1AB44:  BZ    1AB4C
1AB46:  XORLW  01
1AB48:  BZ    1AB76
1AB4A:  BRA    1AB9E
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1AB4C:  BCF    FD8.0
1AB4E:  MOVLB  7
1AB50:  RLCF   x3C,W
1AB52:  CLRF   03
1AB54:  ADDLW  3E
1AB56:  MOVWF  FE9
1AB58:  MOVLW  07
1AB5A:  ADDWFC 03,W
1AB5C:  MOVWF  FEA
1AB5E:  MOVFF  FEC,8DA
1AB62:  MOVF   FED,F
1AB64:  MOVFF  FEF,8D9
1AB68:  MOVLW  86
1AB6A:  MOVLB  8
1AB6C:  MOVWF  xD8
1AB6E:  MOVLB  0
1AB70:  CALL   502C
....................             break; 
1AB74:  BRA    1AB9E
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1AB76:  BCF    FD8.0
1AB78:  MOVLB  7
1AB7A:  RLCF   x3C,W
1AB7C:  CLRF   03
1AB7E:  ADDLW  3E
1AB80:  MOVWF  FE9
1AB82:  MOVLW  07
1AB84:  ADDWFC 03,W
1AB86:  MOVWF  FEA
1AB88:  MOVFF  FEC,8DA
1AB8C:  MOVF   FED,F
1AB8E:  MOVFF  FEF,8D9
1AB92:  MOVLW  88
1AB94:  MOVLB  8
1AB96:  MOVWF  xD8
1AB98:  MOVLB  0
1AB9A:  CALL   502C
....................             break;             
....................       } 
....................    } 
1AB9E:  BRA    1ABA4
....................    else cmd_arg();    
1ABA0:  CALL   B070
1ABA4:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1A96C:  MOVF   44,W
1A96E:  MOVWF  00
1A970:  MOVF   45,W
1A972:  MOVWF  03
1A974:  BNZ   1A97C
1A976:  MOVLW  01
1A978:  SUBWF  00,W
1A97A:  BZ    1A988
1A97C:  MOVF   03,W
1A97E:  BNZ   1A986
1A980:  MOVLW  02
1A982:  SUBWF  00,W
1A984:  BZ    1A98E
1A986:  BRA    1A998
....................       case 1: motor = 0; 
1A988:  MOVLB  7
1A98A:  CLRF   x3C
....................          break; 
1A98C:  BRA    1A99E
....................       case 2: motor = 1; 
1A98E:  MOVLW  01
1A990:  MOVLB  7
1A992:  MOVWF  x3C
....................          break; 
1A994:  BRA    1A99E
1A996:  MOVLB  0
....................       default : cmd_arg(); 
1A998:  CALL   B070
....................          break; 
1A99C:  MOVLB  7
....................    } 
1A99E:  MOVLB  0
1A9A0:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1ABA8:  MOVF   44,F
1ABAA:  BNZ   1ABB8
1ABAC:  MOVF   45,F
1ABAE:  BNZ   1ABB8
1ABB0:  MOVF   46,F
1ABB2:  BNZ   1ABB8
1ABB4:  MOVF   47,F
1ABB6:  BZ    1AC16
1ABB8:  MOVF   47,F
1ABBA:  BNZ   1AC16
1ABBC:  MOVF   46,F
1ABBE:  BNZ   1AC16
1ABC0:  MOVF   45,F
1ABC2:  BNZ   1AC16
1ABC4:  MOVF   44,W
1ABC6:  SUBLW  02
1ABC8:  BNC   1AC16
....................       switch(arg){ 
1ABCA:  MOVFF  44,00
1ABCE:  MOVF   45,W
1ABD0:  MOVWF  03
1ABD2:  BNZ   1ABDA
1ABD4:  MOVLW  01
1ABD6:  SUBWF  00,W
1ABD8:  BZ    1ABE6
1ABDA:  MOVF   03,W
1ABDC:  BNZ   1ABE4
1ABDE:  MOVLW  02
1ABE0:  SUBWF  00,W
1ABE2:  BZ    1ABFE
1ABE4:  BRA    1AC14
....................          case 1 : e_pos[0] = 0; 
1ABE6:  MOVLB  7
1ABE8:  CLRF   xBC
1ABEA:  CLRF   xBB
....................                   write16(ADDR_E1_POS, 0); 
1ABEC:  MOVLW  7E
1ABEE:  MOVLB  8
1ABF0:  MOVWF  xD8
1ABF2:  CLRF   xDA
1ABF4:  CLRF   xD9
1ABF6:  MOVLB  0
1ABF8:  CALL   502C
....................             break; 
1ABFC:  BRA    1AC14
....................          case 2 : e_pos[1] = 0; 
1ABFE:  MOVLB  7
1AC00:  CLRF   xBE
1AC02:  CLRF   xBD
....................                   write16(ADDR_E2_POS, 0); 
1AC04:  MOVLW  80
1AC06:  MOVLB  8
1AC08:  MOVWF  xD8
1AC0A:  CLRF   xDA
1AC0C:  CLRF   xD9
1AC0E:  MOVLB  0
1AC10:  CALL   502C
....................             break;             
....................       } 
....................    } 
1AC14:  BRA    1AC1A
....................    else cmd_arg();  
1AC16:  CALL   B070
1AC1A:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
18DB2:  DECFSZ 44,W
18DB4:  GOTO   19A0A
18DB8:  MOVF   45,F
18DBA:  BTFSS  FD8.2
18DBC:  GOTO   19A0A
18DC0:  MOVF   46,F
18DC2:  BTFSS  FD8.2
18DC4:  GOTO   19A0A
18DC8:  MOVF   47,F
18DCA:  BTFSS  FD8.2
18DCC:  GOTO   19A0A
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18DD0:  MOVFF  74F,9F7
18DD4:  MOVFF  74E,9F6
18DD8:  MOVLB  9
18DDA:  CLRF   xF9
18DDC:  MOVLW  64
18DDE:  MOVWF  xF8
18DE0:  MOVLB  0
18DE2:  CALL   5D14
18DE6:  MOVFF  02,876
18DEA:  MOVFF  01,875
18DEE:  MOVFF  02,8C6
18DF2:  MOVFF  01,8C5
18DF6:  MOVLW  01
18DF8:  MOVLB  8
18DFA:  MOVWF  xC8
18DFC:  SETF   xC7
18DFE:  MOVLB  0
18E00:  CALL   2D36
18E04:  MOVFF  02,870
18E08:  MOVFF  01,86F
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18E0C:  MOVFF  753,9F7
18E10:  MOVFF  752,9F6
18E14:  MOVLB  9
18E16:  CLRF   xF9
18E18:  MOVLW  64
18E1A:  MOVWF  xF8
18E1C:  MOVLB  0
18E1E:  CALL   5D14
18E22:  MOVFF  02,876
18E26:  MOVFF  01,875
18E2A:  MOVFF  02,8C6
18E2E:  MOVFF  01,8C5
18E32:  MOVLW  01
18E34:  MOVLB  8
18E36:  MOVWF  xC8
18E38:  SETF   xC7
18E3A:  MOVLB  0
18E3C:  CALL   2D36
18E40:  MOVFF  02,872
18E44:  MOVFF  01,871
....................       step_us  =   m_stp_int[0]*100; 
18E48:  MOVFF  747,9F7
18E4C:  MOVFF  746,9F6
18E50:  MOVLB  9
18E52:  CLRF   xF9
18E54:  MOVLW  64
18E56:  MOVWF  xF8
18E58:  MOVLB  0
18E5A:  CALL   5D14
18E5E:  MOVFF  02,874
18E62:  MOVFF  01,873
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
18E66:  MOVLW  14
18E68:  MOVWF  FF6
18E6A:  MOVLW  27
18E6C:  MOVWF  FF7
18E6E:  MOVLW  00
18E70:  MOVWF  FF8
18E72:  CLRF   1B
18E74:  BTFSC  FF2.7
18E76:  BSF    1B.7
18E78:  BCF    FF2.7
18E7A:  CALL   0DCC
18E7E:  BTFSC  1B.7
18E80:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
18E82:  MOVLW  62
18E84:  BTFSS  F9E.4
18E86:  BRA    18E84
18E88:  MOVWF  FAD
18E8A:  MOVLW  3A
18E8C:  BTFSS  F9E.4
18E8E:  BRA    18E8C
18E90:  MOVWF  FAD
18E92:  MOVLW  10
18E94:  MOVWF  FE9
18E96:  CLRF   1B
18E98:  BTFSC  FF2.7
18E9A:  BSF    1B.7
18E9C:  BCF    FF2.7
18E9E:  MOVFF  76F,A26
18EA2:  MOVFF  76E,A25
18EA6:  CALL   11A0
18EAA:  BTFSC  1B.7
18EAC:  BSF    FF2.7
18EAE:  MOVLW  0D
18EB0:  BTFSS  F9E.4
18EB2:  BRA    18EB0
18EB4:  MOVWF  FAD
18EB6:  MOVLW  0A
18EB8:  BTFSS  F9E.4
18EBA:  BRA    18EB8
18EBC:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
18EBE:  MOVLW  63
18EC0:  BTFSS  F9E.4
18EC2:  BRA    18EC0
18EC4:  MOVWF  FAD
18EC6:  MOVLW  3A
18EC8:  BTFSS  F9E.4
18ECA:  BRA    18EC8
18ECC:  MOVWF  FAD
18ECE:  MOVLW  41
18ED0:  MOVWF  FE9
18ED2:  CLRF   1B
18ED4:  BTFSC  FF2.7
18ED6:  BSF    1B.7
18ED8:  BCF    FF2.7
18EDA:  MOVFF  7A1,A28
18EDE:  MOVFF  7A0,A27
18EE2:  MOVFF  79F,A26
18EE6:  MOVFF  79E,A25
18EEA:  CALL   10E4
18EEE:  BTFSC  1B.7
18EF0:  BSF    FF2.7
18EF2:  MOVLW  2F
18EF4:  BTFSS  F9E.4
18EF6:  BRA    18EF4
18EF8:  MOVWF  FAD
18EFA:  MOVLW  10
18EFC:  MOVWF  FE9
18EFE:  CLRF   1B
18F00:  BTFSC  FF2.7
18F02:  BSF    1B.7
18F04:  BCF    FF2.7
18F06:  MOVFF  7B8,A26
18F0A:  MOVFF  7B7,A25
18F0E:  CALL   11A0
18F12:  BTFSC  1B.7
18F14:  BSF    FF2.7
18F16:  MOVLW  2F
18F18:  BTFSS  F9E.4
18F1A:  BRA    18F18
18F1C:  MOVWF  FAD
18F1E:  MOVLW  10
18F20:  MOVWF  FE9
18F22:  CLRF   1B
18F24:  BTFSC  FF2.7
18F26:  BSF    1B.7
18F28:  BCF    FF2.7
18F2A:  MOVFF  7BC,A26
18F2E:  MOVFF  7BB,A25
18F32:  CALL   11A0
18F36:  BTFSC  1B.7
18F38:  BSF    FF2.7
18F3A:  MOVLW  0D
18F3C:  BTFSS  F9E.4
18F3E:  BRA    18F3C
18F40:  MOVWF  FAD
18F42:  MOVLW  0A
18F44:  BTFSS  F9E.4
18F46:  BRA    18F44
18F48:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
18F4A:  MOVLW  64
18F4C:  BTFSS  F9E.4
18F4E:  BRA    18F4C
18F50:  MOVWF  FAD
18F52:  MOVLW  3A
18F54:  BTFSS  F9E.4
18F56:  BRA    18F54
18F58:  MOVWF  FAD
18F5A:  MOVLW  10
18F5C:  MOVWF  FE9
18F5E:  CLRF   1B
18F60:  BTFSC  FF2.7
18F62:  BSF    1B.7
18F64:  BCF    FF2.7
18F66:  MOVFF  74B,A26
18F6A:  MOVFF  74A,A25
18F6E:  CALL   11A0
18F72:  BTFSC  1B.7
18F74:  BSF    FF2.7
18F76:  MOVLW  0D
18F78:  BTFSS  F9E.4
18F7A:  BRA    18F78
18F7C:  MOVWF  FAD
18F7E:  MOVLW  0A
18F80:  BTFSS  F9E.4
18F82:  BRA    18F80
18F84:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
18F86:  MOVLW  65
18F88:  BTFSS  F9E.4
18F8A:  BRA    18F88
18F8C:  MOVWF  FAD
18F8E:  MOVLW  3A
18F90:  BTFSS  F9E.4
18F92:  BRA    18F90
18F94:  MOVWF  FAD
18F96:  MOVLW  10
18F98:  MOVWF  FE9
18F9A:  CLRF   1B
18F9C:  BTFSC  FF2.7
18F9E:  BSF    1B.7
18FA0:  BCF    FF2.7
18FA2:  MOVFF  75B,A26
18FA6:  MOVFF  75A,A25
18FAA:  CALL   11A0
18FAE:  BTFSC  1B.7
18FB0:  BSF    FF2.7
18FB2:  MOVLW  0D
18FB4:  BTFSS  F9E.4
18FB6:  BRA    18FB4
18FB8:  MOVWF  FAD
18FBA:  MOVLW  0A
18FBC:  BTFSS  F9E.4
18FBE:  BRA    18FBC
18FC0:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
18FC2:  MOVLW  66
18FC4:  BTFSS  F9E.4
18FC6:  BRA    18FC4
18FC8:  MOVWF  FAD
18FCA:  MOVLW  3A
18FCC:  BTFSS  F9E.4
18FCE:  BRA    18FCC
18FD0:  MOVWF  FAD
18FD2:  CLRF   1B
18FD4:  BTFSC  FF2.7
18FD6:  BSF    1B.7
18FD8:  BCF    FF2.7
18FDA:  MOVFF  73D,A25
18FDE:  MOVLW  1B
18FE0:  MOVLB  A
18FE2:  MOVWF  x26
18FE4:  MOVLB  0
18FE6:  CALL   0FA0
18FEA:  BTFSC  1B.7
18FEC:  BSF    FF2.7
18FEE:  MOVLW  0D
18FF0:  BTFSS  F9E.4
18FF2:  BRA    18FF0
18FF4:  MOVWF  FAD
18FF6:  MOVLW  0A
18FF8:  BTFSS  F9E.4
18FFA:  BRA    18FF8
18FFC:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
18FFE:  MOVLW  67
19000:  BTFSS  F9E.4
19002:  BRA    19000
19004:  MOVWF  FAD
19006:  MOVLW  3A
19008:  BTFSS  F9E.4
1900A:  BRA    19008
1900C:  MOVWF  FAD
1900E:  MOVLW  10
19010:  MOVWF  FE9
19012:  CLRF   1B
19014:  BTFSC  FF2.7
19016:  BSF    1B.7
19018:  BCF    FF2.7
1901A:  MOVFF  757,A26
1901E:  MOVFF  756,A25
19022:  CALL   11A0
19026:  BTFSC  1B.7
19028:  BSF    FF2.7
1902A:  MOVLW  0D
1902C:  BTFSS  F9E.4
1902E:  BRA    1902C
19030:  MOVWF  FAD
19032:  MOVLW  0A
19034:  BTFSS  F9E.4
19036:  BRA    19034
19038:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
1903A:  MOVLW  68
1903C:  BTFSS  F9E.4
1903E:  BRA    1903C
19040:  MOVWF  FAD
19042:  MOVLW  3A
19044:  BTFSS  F9E.4
19046:  BRA    19044
19048:  MOVWF  FAD
1904A:  MOVLW  10
1904C:  MOVWF  FE9
1904E:  CLRF   1B
19050:  BTFSC  FF2.7
19052:  BSF    1B.7
19054:  BCF    FF2.7
19056:  MOVFF  870,A26
1905A:  MOVFF  86F,A25
1905E:  CALL   11A0
19062:  BTFSC  1B.7
19064:  BSF    FF2.7
19066:  MOVLW  0D
19068:  BTFSS  F9E.4
1906A:  BRA    19068
1906C:  MOVWF  FAD
1906E:  MOVLW  0A
19070:  BTFSS  F9E.4
19072:  BRA    19070
19074:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
19076:  MOVLW  69
19078:  BTFSS  F9E.4
1907A:  BRA    19078
1907C:  MOVWF  FAD
1907E:  MOVLW  3A
19080:  BTFSS  F9E.4
19082:  BRA    19080
19084:  MOVWF  FAD
19086:  MOVLW  10
19088:  MOVWF  FE9
1908A:  CLRF   1B
1908C:  BTFSC  FF2.7
1908E:  BSF    1B.7
19090:  BCF    FF2.7
19092:  MOVFF  874,A26
19096:  MOVFF  873,A25
1909A:  CALL   11A0
1909E:  BTFSC  1B.7
190A0:  BSF    FF2.7
190A2:  MOVLW  0D
190A4:  BTFSS  F9E.4
190A6:  BRA    190A4
190A8:  MOVWF  FAD
190AA:  MOVLW  0A
190AC:  BTFSS  F9E.4
190AE:  BRA    190AC
190B0:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
190B2:  MOVLW  6A
190B4:  BTFSS  F9E.4
190B6:  BRA    190B4
190B8:  MOVWF  FAD
190BA:  MOVLW  3A
190BC:  BTFSS  F9E.4
190BE:  BRA    190BC
190C0:  MOVWF  FAD
190C2:  MOVLW  10
190C4:  MOVWF  FE9
190C6:  CLRF   1B
190C8:  BTFSC  FF2.7
190CA:  BSF    1B.7
190CC:  BCF    FF2.7
190CE:  MOVFF  76B,A26
190D2:  MOVFF  76A,A25
190D6:  CALL   11A0
190DA:  BTFSC  1B.7
190DC:  BSF    FF2.7
190DE:  MOVLW  0D
190E0:  BTFSS  F9E.4
190E2:  BRA    190E0
190E4:  MOVWF  FAD
190E6:  MOVLW  0A
190E8:  BTFSS  F9E.4
190EA:  BRA    190E8
190EC:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
190EE:  MOVLW  6B
190F0:  BTFSS  F9E.4
190F2:  BRA    190F0
190F4:  MOVWF  FAD
190F6:  MOVLW  3A
190F8:  BTFSS  F9E.4
190FA:  BRA    190F8
190FC:  MOVWF  FAD
190FE:  MOVLW  10
19100:  MOVWF  FE9
19102:  CLRF   1B
19104:  BTFSC  FF2.7
19106:  BSF    1B.7
19108:  BCF    FF2.7
1910A:  MOVFF  763,A26
1910E:  MOVFF  762,A25
19112:  CALL   11A0
19116:  BTFSC  1B.7
19118:  BSF    FF2.7
1911A:  MOVLW  0D
1911C:  BTFSS  F9E.4
1911E:  BRA    1911C
19120:  MOVWF  FAD
19122:  MOVLW  0A
19124:  BTFSS  F9E.4
19126:  BRA    19124
19128:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
1912A:  MOVLW  6D
1912C:  BTFSS  F9E.4
1912E:  BRA    1912C
19130:  MOVWF  FAD
19132:  MOVLW  3A
19134:  BTFSS  F9E.4
19136:  BRA    19134
19138:  MOVWF  FAD
1913A:  MOVLW  10
1913C:  MOVWF  FE9
1913E:  CLRF   1B
19140:  BTFSC  FF2.7
19142:  BSF    1B.7
19144:  BCF    FF2.7
19146:  MOVFF  743,A26
1914A:  MOVFF  742,A25
1914E:  CALL   11A0
19152:  BTFSC  1B.7
19154:  BSF    FF2.7
19156:  MOVLW  0D
19158:  BTFSS  F9E.4
1915A:  BRA    19158
1915C:  MOVWF  FAD
1915E:  MOVLW  0A
19160:  BTFSS  F9E.4
19162:  BRA    19160
19164:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
19166:  MOVLW  6E
19168:  BTFSS  F9E.4
1916A:  BRA    19168
1916C:  MOVWF  FAD
1916E:  MOVLW  3A
19170:  BTFSS  F9E.4
19172:  BRA    19170
19174:  MOVWF  FAD
19176:  MOVLW  10
19178:  MOVWF  FE9
1917A:  CLRF   1B
1917C:  BTFSC  FF2.7
1917E:  BSF    1B.7
19180:  BCF    FF2.7
19182:  MOVFF  777,A26
19186:  MOVFF  776,A25
1918A:  CALL   11A0
1918E:  BTFSC  1B.7
19190:  BSF    FF2.7
19192:  MOVLW  0D
19194:  BTFSS  F9E.4
19196:  BRA    19194
19198:  MOVWF  FAD
1919A:  MOVLW  0A
1919C:  BTFSS  F9E.4
1919E:  BRA    1919C
191A0:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
191A2:  MOVLW  6F
191A4:  BTFSS  F9E.4
191A6:  BRA    191A4
191A8:  MOVWF  FAD
191AA:  MOVLW  3A
191AC:  BTFSS  F9E.4
191AE:  BRA    191AC
191B0:  MOVWF  FAD
191B2:  MOVLW  10
191B4:  MOVWF  FE9
191B6:  CLRF   1B
191B8:  BTFSC  FF2.7
191BA:  BSF    1B.7
191BC:  BCF    FF2.7
191BE:  MOVFF  77B,A26
191C2:  MOVFF  77A,A25
191C6:  CALL   11A0
191CA:  BTFSC  1B.7
191CC:  BSF    FF2.7
191CE:  MOVLW  0D
191D0:  BTFSS  F9E.4
191D2:  BRA    191D0
191D4:  MOVWF  FAD
191D6:  MOVLW  0A
191D8:  BTFSS  F9E.4
191DA:  BRA    191D8
191DC:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
191DE:  MOVLW  70
191E0:  BTFSS  F9E.4
191E2:  BRA    191E0
191E4:  MOVWF  FAD
191E6:  MOVLW  3A
191E8:  BTFSS  F9E.4
191EA:  BRA    191E8
191EC:  MOVWF  FAD
191EE:  MOVLW  10
191F0:  MOVWF  FE9
191F2:  CLRF   1B
191F4:  BTFSC  FF2.7
191F6:  BSF    1B.7
191F8:  BCF    FF2.7
191FA:  MOVFF  7C0,A26
191FE:  MOVFF  7BF,A25
19202:  CALL   11A0
19206:  BTFSC  1B.7
19208:  BSF    FF2.7
1920A:  MOVLW  2F
1920C:  BTFSS  F9E.4
1920E:  BRA    1920C
19210:  MOVWF  FAD
19212:  MOVLW  10
19214:  MOVWF  FE9
19216:  CLRF   1B
19218:  BTFSC  FF2.7
1921A:  BSF    1B.7
1921C:  BCF    FF2.7
1921E:  MOVFF  75F,A26
19222:  MOVFF  75E,A25
19226:  CALL   11A0
1922A:  BTFSC  1B.7
1922C:  BSF    FF2.7
1922E:  MOVLW  0D
19230:  BTFSS  F9E.4
19232:  BRA    19230
19234:  MOVWF  FAD
19236:  MOVLW  0A
19238:  BTFSS  F9E.4
1923A:  BRA    19238
1923C:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
1923E:  MOVLW  71
19240:  BTFSS  F9E.4
19242:  BRA    19240
19244:  MOVWF  FAD
19246:  MOVLW  3A
19248:  BTFSS  F9E.4
1924A:  BRA    19248
1924C:  MOVWF  FAD
1924E:  MOVLW  10
19250:  MOVWF  FE9
19252:  CLRF   1B
19254:  BTFSC  FF2.7
19256:  BSF    1B.7
19258:  BCF    FF2.7
1925A:  MOVFF  793,A26
1925E:  MOVFF  792,A25
19262:  CALL   11A0
19266:  BTFSC  1B.7
19268:  BSF    FF2.7
1926A:  MOVLW  0D
1926C:  BTFSS  F9E.4
1926E:  BRA    1926C
19270:  MOVWF  FAD
19272:  MOVLW  0A
19274:  BTFSS  F9E.4
19276:  BRA    19274
19278:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
1927A:  MOVLW  73
1927C:  BTFSS  F9E.4
1927E:  BRA    1927C
19280:  MOVWF  FAD
19282:  MOVLW  3A
19284:  BTFSS  F9E.4
19286:  BRA    19284
19288:  MOVWF  FAD
1928A:  MOVLW  10
1928C:  MOVWF  FE9
1928E:  CLRF   1B
19290:  BTFSC  FF2.7
19292:  BSF    1B.7
19294:  BCF    FF2.7
19296:  MOVFF  773,A26
1929A:  MOVFF  772,A25
1929E:  CALL   11A0
192A2:  BTFSC  1B.7
192A4:  BSF    FF2.7
192A6:  MOVLW  0D
192A8:  BTFSS  F9E.4
192AA:  BRA    192A8
192AC:  MOVWF  FAD
192AE:  MOVLW  0A
192B0:  BTFSS  F9E.4
192B2:  BRA    192B0
192B4:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
192B6:  MOVLW  74
192B8:  BTFSS  F9E.4
192BA:  BRA    192B8
192BC:  MOVWF  FAD
192BE:  MOVLW  3A
192C0:  BTFSS  F9E.4
192C2:  BRA    192C0
192C4:  MOVWF  FAD
192C6:  MOVLW  10
192C8:  MOVWF  FE9
192CA:  CLRF   1B
192CC:  BTFSC  FF2.7
192CE:  BSF    1B.7
192D0:  BCF    FF2.7
192D2:  MOVFF  767,A26
192D6:  MOVFF  766,A25
192DA:  CALL   11A0
192DE:  BTFSC  1B.7
192E0:  BSF    FF2.7
192E2:  MOVLW  0D
192E4:  BTFSS  F9E.4
192E6:  BRA    192E4
192E8:  MOVWF  FAD
192EA:  MOVLW  0A
192EC:  BTFSS  F9E.4
192EE:  BRA    192EC
192F0:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
192F2:  MOVLW  01
192F4:  MOVLB  7
192F6:  ADDWF  x3C,W
192F8:  MOVLB  8
192FA:  MOVWF  x75
192FC:  MOVLW  75
192FE:  BTFSS  F9E.4
19300:  BRA    192FE
19302:  MOVWF  FAD
19304:  MOVLW  3A
19306:  BTFSS  F9E.4
19308:  BRA    19306
1930A:  MOVWF  FAD
1930C:  CLRF   1B
1930E:  BTFSC  FF2.7
19310:  BSF    1B.7
19312:  BCF    FF2.7
19314:  MOVFF  875,A25
19318:  MOVLW  1B
1931A:  MOVLB  A
1931C:  MOVWF  x26
1931E:  MOVLB  0
19320:  CALL   0FA0
19324:  BTFSC  1B.7
19326:  BSF    FF2.7
19328:  MOVLW  0D
1932A:  BTFSS  F9E.4
1932C:  BRA    1932A
1932E:  MOVWF  FAD
19330:  MOVLW  0A
19332:  BTFSS  F9E.4
19334:  BRA    19332
19336:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19338:  MOVLW  77
1933A:  BTFSS  F9E.4
1933C:  BRA    1933A
1933E:  MOVWF  FAD
19340:  MOVLW  3A
19342:  BTFSS  F9E.4
19344:  BRA    19342
19346:  MOVWF  FAD
19348:  MOVLW  10
1934A:  MOVWF  FE9
1934C:  CLRF   1B
1934E:  BTFSC  FF2.7
19350:  BSF    1B.7
19352:  BCF    FF2.7
19354:  MOVFF  872,A26
19358:  MOVFF  871,A25
1935C:  CALL   11A0
19360:  BTFSC  1B.7
19362:  BSF    FF2.7
19364:  MOVLW  0D
19366:  BTFSS  F9E.4
19368:  BRA    19366
1936A:  MOVWF  FAD
1936C:  MOVLW  0A
1936E:  BTFSS  F9E.4
19370:  BRA    1936E
19372:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
19374:  MOVLW  78
19376:  BTFSS  F9E.4
19378:  BRA    19376
1937A:  MOVWF  FAD
1937C:  MOVLW  3A
1937E:  BTFSS  F9E.4
19380:  BRA    1937E
19382:  MOVWF  FAD
19384:  MOVLW  10
19386:  MOVWF  FE9
19388:  CLRF   1B
1938A:  BTFSC  FF2.7
1938C:  BSF    1B.7
1938E:  BCF    FF2.7
19390:  MOVFF  77F,A26
19394:  MOVFF  77E,A25
19398:  CALL   11A0
1939C:  BTFSC  1B.7
1939E:  BSF    FF2.7
193A0:  MOVLW  0D
193A2:  BTFSS  F9E.4
193A4:  BRA    193A2
193A6:  MOVWF  FAD
193A8:  MOVLW  0A
193AA:  BTFSS  F9E.4
193AC:  BRA    193AA
193AE:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
193B0:  MOVLW  79
193B2:  BTFSS  F9E.4
193B4:  BRA    193B2
193B6:  MOVWF  FAD
193B8:  MOVLW  3A
193BA:  BTFSS  F9E.4
193BC:  BRA    193BA
193BE:  MOVWF  FAD
193C0:  MOVLW  10
193C2:  MOVWF  FE9
193C4:  CLRF   1B
193C6:  BTFSC  FF2.7
193C8:  BSF    1B.7
193CA:  BCF    FF2.7
193CC:  MOVFF  73F,A26
193D0:  MOVFF  73E,A25
193D4:  CALL   11A0
193D8:  BTFSC  1B.7
193DA:  BSF    FF2.7
193DC:  MOVLW  0D
193DE:  BTFSS  F9E.4
193E0:  BRA    193DE
193E2:  MOVWF  FAD
193E4:  MOVLW  0A
193E6:  BTFSS  F9E.4
193E8:  BRA    193E6
193EA:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
193EC:  MOVFF  751,9F7
193F0:  MOVFF  750,9F6
193F4:  MOVLB  9
193F6:  CLRF   xF9
193F8:  MOVLW  64
193FA:  MOVWF  xF8
193FC:  MOVLB  0
193FE:  CALL   5D14
19402:  MOVFF  02,876
19406:  MOVFF  01,875
1940A:  MOVFF  02,8C6
1940E:  MOVFF  01,8C5
19412:  MOVLW  01
19414:  MOVLB  8
19416:  MOVWF  xC8
19418:  SETF   xC7
1941A:  MOVLB  0
1941C:  CALL   2D36
19420:  MOVFF  02,870
19424:  MOVFF  01,86F
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19428:  MOVFF  755,9F7
1942C:  MOVFF  754,9F6
19430:  MOVLB  9
19432:  CLRF   xF9
19434:  MOVLW  64
19436:  MOVWF  xF8
19438:  MOVLB  0
1943A:  CALL   5D14
1943E:  MOVFF  02,876
19442:  MOVFF  01,875
19446:  MOVFF  02,8C6
1944A:  MOVFF  01,8C5
1944E:  MOVLW  01
19450:  MOVLB  8
19452:  MOVWF  xC8
19454:  SETF   xC7
19456:  MOVLB  0
19458:  CALL   2D36
1945C:  MOVFF  02,872
19460:  MOVFF  01,871
....................       step_us  =   m_stp_int[1]*100; 
19464:  MOVFF  749,9F7
19468:  MOVFF  748,9F6
1946C:  MOVLB  9
1946E:  CLRF   xF9
19470:  MOVLW  64
19472:  MOVWF  xF8
19474:  MOVLB  0
19476:  CALL   5D14
1947A:  MOVFF  02,874
1947E:  MOVFF  01,873
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
19482:  MOVLW  20
19484:  MOVWF  FF6
19486:  MOVLW  27
19488:  MOVWF  FF7
1948A:  MOVLW  00
1948C:  MOVWF  FF8
1948E:  CLRF   1B
19490:  BTFSC  FF2.7
19492:  BSF    1B.7
19494:  BCF    FF2.7
19496:  CALL   0DCC
1949A:  BTFSC  1B.7
1949C:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
1949E:  MOVLW  62
194A0:  BTFSS  F9E.4
194A2:  BRA    194A0
194A4:  MOVWF  FAD
194A6:  MOVLW  3A
194A8:  BTFSS  F9E.4
194AA:  BRA    194A8
194AC:  MOVWF  FAD
194AE:  MOVLW  10
194B0:  MOVWF  FE9
194B2:  CLRF   1B
194B4:  BTFSC  FF2.7
194B6:  BSF    1B.7
194B8:  BCF    FF2.7
194BA:  MOVFF  771,A26
194BE:  MOVFF  770,A25
194C2:  CALL   11A0
194C6:  BTFSC  1B.7
194C8:  BSF    FF2.7
194CA:  MOVLW  0D
194CC:  BTFSS  F9E.4
194CE:  BRA    194CC
194D0:  MOVWF  FAD
194D2:  MOVLW  0A
194D4:  BTFSS  F9E.4
194D6:  BRA    194D4
194D8:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
194DA:  MOVLW  63
194DC:  BTFSS  F9E.4
194DE:  BRA    194DC
194E0:  MOVWF  FAD
194E2:  MOVLW  3A
194E4:  BTFSS  F9E.4
194E6:  BRA    194E4
194E8:  MOVWF  FAD
194EA:  MOVLW  41
194EC:  MOVWF  FE9
194EE:  CLRF   1B
194F0:  BTFSC  FF2.7
194F2:  BSF    1B.7
194F4:  BCF    FF2.7
194F6:  MOVFF  7A5,A28
194FA:  MOVFF  7A4,A27
194FE:  MOVFF  7A3,A26
19502:  MOVFF  7A2,A25
19506:  CALL   10E4
1950A:  BTFSC  1B.7
1950C:  BSF    FF2.7
1950E:  MOVLW  2F
19510:  BTFSS  F9E.4
19512:  BRA    19510
19514:  MOVWF  FAD
19516:  MOVLW  10
19518:  MOVWF  FE9
1951A:  CLRF   1B
1951C:  BTFSC  FF2.7
1951E:  BSF    1B.7
19520:  BCF    FF2.7
19522:  MOVFF  7BA,A26
19526:  MOVFF  7B9,A25
1952A:  CALL   11A0
1952E:  BTFSC  1B.7
19530:  BSF    FF2.7
19532:  MOVLW  2F
19534:  BTFSS  F9E.4
19536:  BRA    19534
19538:  MOVWF  FAD
1953A:  MOVLW  10
1953C:  MOVWF  FE9
1953E:  CLRF   1B
19540:  BTFSC  FF2.7
19542:  BSF    1B.7
19544:  BCF    FF2.7
19546:  MOVFF  7BE,A26
1954A:  MOVFF  7BD,A25
1954E:  CALL   11A0
19552:  BTFSC  1B.7
19554:  BSF    FF2.7
19556:  MOVLW  0D
19558:  BTFSS  F9E.4
1955A:  BRA    19558
1955C:  MOVWF  FAD
1955E:  MOVLW  0A
19560:  BTFSS  F9E.4
19562:  BRA    19560
19564:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
19566:  MOVLW  64
19568:  BTFSS  F9E.4
1956A:  BRA    19568
1956C:  MOVWF  FAD
1956E:  MOVLW  3A
19570:  BTFSS  F9E.4
19572:  BRA    19570
19574:  MOVWF  FAD
19576:  MOVLW  10
19578:  MOVWF  FE9
1957A:  CLRF   1B
1957C:  BTFSC  FF2.7
1957E:  BSF    1B.7
19580:  BCF    FF2.7
19582:  MOVFF  74D,A26
19586:  MOVFF  74C,A25
1958A:  CALL   11A0
1958E:  BTFSC  1B.7
19590:  BSF    FF2.7
19592:  MOVLW  0D
19594:  BTFSS  F9E.4
19596:  BRA    19594
19598:  MOVWF  FAD
1959A:  MOVLW  0A
1959C:  BTFSS  F9E.4
1959E:  BRA    1959C
195A0:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
195A2:  MOVLW  65
195A4:  BTFSS  F9E.4
195A6:  BRA    195A4
195A8:  MOVWF  FAD
195AA:  MOVLW  3A
195AC:  BTFSS  F9E.4
195AE:  BRA    195AC
195B0:  MOVWF  FAD
195B2:  MOVLW  10
195B4:  MOVWF  FE9
195B6:  CLRF   1B
195B8:  BTFSC  FF2.7
195BA:  BSF    1B.7
195BC:  BCF    FF2.7
195BE:  MOVFF  75D,A26
195C2:  MOVFF  75C,A25
195C6:  CALL   11A0
195CA:  BTFSC  1B.7
195CC:  BSF    FF2.7
195CE:  MOVLW  0D
195D0:  BTFSS  F9E.4
195D2:  BRA    195D0
195D4:  MOVWF  FAD
195D6:  MOVLW  0A
195D8:  BTFSS  F9E.4
195DA:  BRA    195D8
195DC:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
195DE:  MOVLW  66
195E0:  BTFSS  F9E.4
195E2:  BRA    195E0
195E4:  MOVWF  FAD
195E6:  MOVLW  3A
195E8:  BTFSS  F9E.4
195EA:  BRA    195E8
195EC:  MOVWF  FAD
195EE:  CLRF   1B
195F0:  BTFSC  FF2.7
195F2:  BSF    1B.7
195F4:  BCF    FF2.7
195F6:  MOVFF  73D,A25
195FA:  MOVLW  1B
195FC:  MOVLB  A
195FE:  MOVWF  x26
19600:  MOVLB  0
19602:  CALL   0FA0
19606:  BTFSC  1B.7
19608:  BSF    FF2.7
1960A:  MOVLW  0D
1960C:  BTFSS  F9E.4
1960E:  BRA    1960C
19610:  MOVWF  FAD
19612:  MOVLW  0A
19614:  BTFSS  F9E.4
19616:  BRA    19614
19618:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
1961A:  MOVLW  67
1961C:  BTFSS  F9E.4
1961E:  BRA    1961C
19620:  MOVWF  FAD
19622:  MOVLW  3A
19624:  BTFSS  F9E.4
19626:  BRA    19624
19628:  MOVWF  FAD
1962A:  MOVLW  10
1962C:  MOVWF  FE9
1962E:  CLRF   1B
19630:  BTFSC  FF2.7
19632:  BSF    1B.7
19634:  BCF    FF2.7
19636:  MOVFF  759,A26
1963A:  MOVFF  758,A25
1963E:  CALL   11A0
19642:  BTFSC  1B.7
19644:  BSF    FF2.7
19646:  MOVLW  0D
19648:  BTFSS  F9E.4
1964A:  BRA    19648
1964C:  MOVWF  FAD
1964E:  MOVLW  0A
19650:  BTFSS  F9E.4
19652:  BRA    19650
19654:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19656:  MOVLW  68
19658:  BTFSS  F9E.4
1965A:  BRA    19658
1965C:  MOVWF  FAD
1965E:  MOVLW  3A
19660:  BTFSS  F9E.4
19662:  BRA    19660
19664:  MOVWF  FAD
19666:  MOVLW  10
19668:  MOVWF  FE9
1966A:  CLRF   1B
1966C:  BTFSC  FF2.7
1966E:  BSF    1B.7
19670:  BCF    FF2.7
19672:  MOVFF  870,A26
19676:  MOVFF  86F,A25
1967A:  CALL   11A0
1967E:  BTFSC  1B.7
19680:  BSF    FF2.7
19682:  MOVLW  0D
19684:  BTFSS  F9E.4
19686:  BRA    19684
19688:  MOVWF  FAD
1968A:  MOVLW  0A
1968C:  BTFSS  F9E.4
1968E:  BRA    1968C
19690:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
19692:  MOVLW  69
19694:  BTFSS  F9E.4
19696:  BRA    19694
19698:  MOVWF  FAD
1969A:  MOVLW  3A
1969C:  BTFSS  F9E.4
1969E:  BRA    1969C
196A0:  MOVWF  FAD
196A2:  MOVLW  10
196A4:  MOVWF  FE9
196A6:  CLRF   1B
196A8:  BTFSC  FF2.7
196AA:  BSF    1B.7
196AC:  BCF    FF2.7
196AE:  MOVFF  874,A26
196B2:  MOVFF  873,A25
196B6:  CALL   11A0
196BA:  BTFSC  1B.7
196BC:  BSF    FF2.7
196BE:  MOVLW  0D
196C0:  BTFSS  F9E.4
196C2:  BRA    196C0
196C4:  MOVWF  FAD
196C6:  MOVLW  0A
196C8:  BTFSS  F9E.4
196CA:  BRA    196C8
196CC:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
196CE:  MOVLW  6A
196D0:  BTFSS  F9E.4
196D2:  BRA    196D0
196D4:  MOVWF  FAD
196D6:  MOVLW  3A
196D8:  BTFSS  F9E.4
196DA:  BRA    196D8
196DC:  MOVWF  FAD
196DE:  MOVLW  10
196E0:  MOVWF  FE9
196E2:  CLRF   1B
196E4:  BTFSC  FF2.7
196E6:  BSF    1B.7
196E8:  BCF    FF2.7
196EA:  MOVFF  76D,A26
196EE:  MOVFF  76C,A25
196F2:  CALL   11A0
196F6:  BTFSC  1B.7
196F8:  BSF    FF2.7
196FA:  MOVLW  0D
196FC:  BTFSS  F9E.4
196FE:  BRA    196FC
19700:  MOVWF  FAD
19702:  MOVLW  0A
19704:  BTFSS  F9E.4
19706:  BRA    19704
19708:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
1970A:  MOVLW  6B
1970C:  BTFSS  F9E.4
1970E:  BRA    1970C
19710:  MOVWF  FAD
19712:  MOVLW  3A
19714:  BTFSS  F9E.4
19716:  BRA    19714
19718:  MOVWF  FAD
1971A:  MOVLW  10
1971C:  MOVWF  FE9
1971E:  CLRF   1B
19720:  BTFSC  FF2.7
19722:  BSF    1B.7
19724:  BCF    FF2.7
19726:  MOVFF  765,A26
1972A:  MOVFF  764,A25
1972E:  CALL   11A0
19732:  BTFSC  1B.7
19734:  BSF    FF2.7
19736:  MOVLW  0D
19738:  BTFSS  F9E.4
1973A:  BRA    19738
1973C:  MOVWF  FAD
1973E:  MOVLW  0A
19740:  BTFSS  F9E.4
19742:  BRA    19740
19744:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
19746:  MOVLW  6D
19748:  BTFSS  F9E.4
1974A:  BRA    19748
1974C:  MOVWF  FAD
1974E:  MOVLW  3A
19750:  BTFSS  F9E.4
19752:  BRA    19750
19754:  MOVWF  FAD
19756:  MOVLW  10
19758:  MOVWF  FE9
1975A:  CLRF   1B
1975C:  BTFSC  FF2.7
1975E:  BSF    1B.7
19760:  BCF    FF2.7
19762:  MOVFF  745,A26
19766:  MOVFF  744,A25
1976A:  CALL   11A0
1976E:  BTFSC  1B.7
19770:  BSF    FF2.7
19772:  MOVLW  0D
19774:  BTFSS  F9E.4
19776:  BRA    19774
19778:  MOVWF  FAD
1977A:  MOVLW  0A
1977C:  BTFSS  F9E.4
1977E:  BRA    1977C
19780:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
19782:  MOVLW  6E
19784:  BTFSS  F9E.4
19786:  BRA    19784
19788:  MOVWF  FAD
1978A:  MOVLW  3A
1978C:  BTFSS  F9E.4
1978E:  BRA    1978C
19790:  MOVWF  FAD
19792:  MOVLW  10
19794:  MOVWF  FE9
19796:  CLRF   1B
19798:  BTFSC  FF2.7
1979A:  BSF    1B.7
1979C:  BCF    FF2.7
1979E:  MOVFF  779,A26
197A2:  MOVFF  778,A25
197A6:  CALL   11A0
197AA:  BTFSC  1B.7
197AC:  BSF    FF2.7
197AE:  MOVLW  0D
197B0:  BTFSS  F9E.4
197B2:  BRA    197B0
197B4:  MOVWF  FAD
197B6:  MOVLW  0A
197B8:  BTFSS  F9E.4
197BA:  BRA    197B8
197BC:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
197BE:  MOVLW  6F
197C0:  BTFSS  F9E.4
197C2:  BRA    197C0
197C4:  MOVWF  FAD
197C6:  MOVLW  3A
197C8:  BTFSS  F9E.4
197CA:  BRA    197C8
197CC:  MOVWF  FAD
197CE:  MOVLW  10
197D0:  MOVWF  FE9
197D2:  CLRF   1B
197D4:  BTFSC  FF2.7
197D6:  BSF    1B.7
197D8:  BCF    FF2.7
197DA:  MOVFF  77D,A26
197DE:  MOVFF  77C,A25
197E2:  CALL   11A0
197E6:  BTFSC  1B.7
197E8:  BSF    FF2.7
197EA:  MOVLW  0D
197EC:  BTFSS  F9E.4
197EE:  BRA    197EC
197F0:  MOVWF  FAD
197F2:  MOVLW  0A
197F4:  BTFSS  F9E.4
197F6:  BRA    197F4
197F8:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
197FA:  MOVLW  70
197FC:  BTFSS  F9E.4
197FE:  BRA    197FC
19800:  MOVWF  FAD
19802:  MOVLW  3A
19804:  BTFSS  F9E.4
19806:  BRA    19804
19808:  MOVWF  FAD
1980A:  MOVLW  10
1980C:  MOVWF  FE9
1980E:  CLRF   1B
19810:  BTFSC  FF2.7
19812:  BSF    1B.7
19814:  BCF    FF2.7
19816:  MOVFF  7C2,A26
1981A:  MOVFF  7C1,A25
1981E:  CALL   11A0
19822:  BTFSC  1B.7
19824:  BSF    FF2.7
19826:  MOVLW  2F
19828:  BTFSS  F9E.4
1982A:  BRA    19828
1982C:  MOVWF  FAD
1982E:  MOVLW  10
19830:  MOVWF  FE9
19832:  CLRF   1B
19834:  BTFSC  FF2.7
19836:  BSF    1B.7
19838:  BCF    FF2.7
1983A:  MOVFF  761,A26
1983E:  MOVFF  760,A25
19842:  CALL   11A0
19846:  BTFSC  1B.7
19848:  BSF    FF2.7
1984A:  MOVLW  0D
1984C:  BTFSS  F9E.4
1984E:  BRA    1984C
19850:  MOVWF  FAD
19852:  MOVLW  0A
19854:  BTFSS  F9E.4
19856:  BRA    19854
19858:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
1985A:  MOVLW  71
1985C:  BTFSS  F9E.4
1985E:  BRA    1985C
19860:  MOVWF  FAD
19862:  MOVLW  3A
19864:  BTFSS  F9E.4
19866:  BRA    19864
19868:  MOVWF  FAD
1986A:  MOVLW  10
1986C:  MOVWF  FE9
1986E:  CLRF   1B
19870:  BTFSC  FF2.7
19872:  BSF    1B.7
19874:  BCF    FF2.7
19876:  MOVFF  795,A26
1987A:  MOVFF  794,A25
1987E:  CALL   11A0
19882:  BTFSC  1B.7
19884:  BSF    FF2.7
19886:  MOVLW  0D
19888:  BTFSS  F9E.4
1988A:  BRA    19888
1988C:  MOVWF  FAD
1988E:  MOVLW  0A
19890:  BTFSS  F9E.4
19892:  BRA    19890
19894:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
19896:  MOVLW  73
19898:  BTFSS  F9E.4
1989A:  BRA    19898
1989C:  MOVWF  FAD
1989E:  MOVLW  3A
198A0:  BTFSS  F9E.4
198A2:  BRA    198A0
198A4:  MOVWF  FAD
198A6:  MOVLW  10
198A8:  MOVWF  FE9
198AA:  CLRF   1B
198AC:  BTFSC  FF2.7
198AE:  BSF    1B.7
198B0:  BCF    FF2.7
198B2:  MOVFF  775,A26
198B6:  MOVFF  774,A25
198BA:  CALL   11A0
198BE:  BTFSC  1B.7
198C0:  BSF    FF2.7
198C2:  MOVLW  0D
198C4:  BTFSS  F9E.4
198C6:  BRA    198C4
198C8:  MOVWF  FAD
198CA:  MOVLW  0A
198CC:  BTFSS  F9E.4
198CE:  BRA    198CC
198D0:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
198D2:  MOVLW  74
198D4:  BTFSS  F9E.4
198D6:  BRA    198D4
198D8:  MOVWF  FAD
198DA:  MOVLW  3A
198DC:  BTFSS  F9E.4
198DE:  BRA    198DC
198E0:  MOVWF  FAD
198E2:  MOVLW  10
198E4:  MOVWF  FE9
198E6:  CLRF   1B
198E8:  BTFSC  FF2.7
198EA:  BSF    1B.7
198EC:  BCF    FF2.7
198EE:  MOVFF  769,A26
198F2:  MOVFF  768,A25
198F6:  CALL   11A0
198FA:  BTFSC  1B.7
198FC:  BSF    FF2.7
198FE:  MOVLW  0D
19900:  BTFSS  F9E.4
19902:  BRA    19900
19904:  MOVWF  FAD
19906:  MOVLW  0A
19908:  BTFSS  F9E.4
1990A:  BRA    19908
1990C:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
1990E:  MOVLW  01
19910:  MOVLB  7
19912:  ADDWF  x3C,W
19914:  MOVLB  8
19916:  MOVWF  x75
19918:  MOVLW  75
1991A:  BTFSS  F9E.4
1991C:  BRA    1991A
1991E:  MOVWF  FAD
19920:  MOVLW  3A
19922:  BTFSS  F9E.4
19924:  BRA    19922
19926:  MOVWF  FAD
19928:  CLRF   1B
1992A:  BTFSC  FF2.7
1992C:  BSF    1B.7
1992E:  BCF    FF2.7
19930:  MOVFF  875,A25
19934:  MOVLW  1B
19936:  MOVLB  A
19938:  MOVWF  x26
1993A:  MOVLB  0
1993C:  CALL   0FA0
19940:  BTFSC  1B.7
19942:  BSF    FF2.7
19944:  MOVLW  0D
19946:  BTFSS  F9E.4
19948:  BRA    19946
1994A:  MOVWF  FAD
1994C:  MOVLW  0A
1994E:  BTFSS  F9E.4
19950:  BRA    1994E
19952:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19954:  MOVLW  77
19956:  BTFSS  F9E.4
19958:  BRA    19956
1995A:  MOVWF  FAD
1995C:  MOVLW  3A
1995E:  BTFSS  F9E.4
19960:  BRA    1995E
19962:  MOVWF  FAD
19964:  MOVLW  10
19966:  MOVWF  FE9
19968:  CLRF   1B
1996A:  BTFSC  FF2.7
1996C:  BSF    1B.7
1996E:  BCF    FF2.7
19970:  MOVFF  872,A26
19974:  MOVFF  871,A25
19978:  CALL   11A0
1997C:  BTFSC  1B.7
1997E:  BSF    FF2.7
19980:  MOVLW  0D
19982:  BTFSS  F9E.4
19984:  BRA    19982
19986:  MOVWF  FAD
19988:  MOVLW  0A
1998A:  BTFSS  F9E.4
1998C:  BRA    1998A
1998E:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
19990:  MOVLW  78
19992:  BTFSS  F9E.4
19994:  BRA    19992
19996:  MOVWF  FAD
19998:  MOVLW  3A
1999A:  BTFSS  F9E.4
1999C:  BRA    1999A
1999E:  MOVWF  FAD
199A0:  MOVLW  10
199A2:  MOVWF  FE9
199A4:  CLRF   1B
199A6:  BTFSC  FF2.7
199A8:  BSF    1B.7
199AA:  BCF    FF2.7
199AC:  MOVFF  781,A26
199B0:  MOVFF  780,A25
199B4:  CALL   11A0
199B8:  BTFSC  1B.7
199BA:  BSF    FF2.7
199BC:  MOVLW  0D
199BE:  BTFSS  F9E.4
199C0:  BRA    199BE
199C2:  MOVWF  FAD
199C4:  MOVLW  0A
199C6:  BTFSS  F9E.4
199C8:  BRA    199C6
199CA:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
199CC:  MOVLW  79
199CE:  BTFSS  F9E.4
199D0:  BRA    199CE
199D2:  MOVWF  FAD
199D4:  MOVLW  3A
199D6:  BTFSS  F9E.4
199D8:  BRA    199D6
199DA:  MOVWF  FAD
199DC:  MOVLW  10
199DE:  MOVWF  FE9
199E0:  CLRF   1B
199E2:  BTFSC  FF2.7
199E4:  BSF    1B.7
199E6:  BCF    FF2.7
199E8:  MOVFF  741,A26
199EC:  MOVFF  740,A25
199F0:  CALL   11A0
199F4:  BTFSC  1B.7
199F6:  BSF    FF2.7
199F8:  MOVLW  0D
199FA:  BTFSS  F9E.4
199FC:  BRA    199FA
199FE:  MOVWF  FAD
19A00:  MOVLW  0A
19A02:  BTFSS  F9E.4
19A04:  BRA    19A02
19A06:  MOVWF  FAD
....................    } 
19A08:  BRA    19A0E
....................    else cmd_arg(); 
19A0A:  CALL   B070
19A0E:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BCB8:  MOVF   44,W
0BCBA:  SUBLW  0D
0BCBC:  BNZ   BCDC
0BCBE:  MOVF   45,W
0BCC0:  SUBLW  07
0BCC2:  BNZ   BCDC
0BCC4:  MOVF   46,F
0BCC6:  BNZ   BCDC
0BCC8:  MOVF   47,F
0BCCA:  BNZ   BCDC
0BCCC:  MOVLW  03
0BCCE:  MOVLB  8
0BCD0:  MOVWF  x74
0BCD2:  MOVLW  11
0BCD4:  MOVWF  x73
0BCD6:  MOVLB  0
0BCD8:  RCALL  B896
0BCDA:  BRA    BCFE
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BCDC:  MOVF   44,W
0BCDE:  SUBLW  98
0BCE0:  BNZ   BCFE
0BCE2:  MOVF   45,W
0BCE4:  SUBLW  07
0BCE6:  BNZ   BCFE
0BCE8:  MOVF   46,F
0BCEA:  BNZ   BCFE
0BCEC:  MOVF   47,F
0BCEE:  BNZ   BCFE
0BCF0:  MOVLW  03
0BCF2:  MOVLB  8
0BCF4:  MOVWF  x74
0BCF6:  MOVLW  11
0BCF8:  MOVWF  x73
0BCFA:  MOVLB  0
0BCFC:  RCALL  BA10
0BCFE:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0B0CA:  MOVF   44,W
0B0CC:  MOVWF  00
0B0CE:  MOVFF  45,03
0B0D2:  MOVLW  15
0B0D4:  SUBWF  45,W
0B0D6:  BNZ   B0DE
0B0D8:  MOVLW  95
0B0DA:  SUBWF  00,W
0B0DC:  BZ    B104
0B0DE:  MOVLW  15
0B0E0:  SUBWF  03,W
0B0E2:  BNZ   B0EA
0B0E4:  MOVLW  96
0B0E6:  SUBWF  00,W
0B0E8:  BZ    B136
0B0EA:  MOVLW  15
0B0EC:  SUBWF  03,W
0B0EE:  BNZ   B0F6
0B0F0:  MOVLW  97
0B0F2:  SUBWF  00,W
0B0F4:  BZ    B16C
0B0F6:  MOVLW  15
0B0F8:  SUBWF  03,W
0B0FA:  BNZ   B102
0B0FC:  MOVLW  98
0B0FE:  SUBWF  00,W
0B100:  BZ    B1A2
0B102:  BRA    B1D6
....................       case 5525 : nv_product = ECO; 
0B104:  CLRF   30
0B106:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B108:  MOVLW  1E
0B10A:  MOVLB  8
0B10C:  MOVWF  xD8
0B10E:  CLRF   xDA
0B110:  CLRF   xD9
0B112:  MOVLB  0
0B114:  CALL   502C
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B118:  MOVLW  01
0B11A:  MOVWF  1E
0B11C:  MOVLW  A3
0B11E:  MOVWF  1D
0B120:  MOVLW  2C
0B122:  MOVWF  FF6
0B124:  MOVLW  27
0B126:  MOVWF  FF7
0B128:  MOVLW  00
0B12A:  MOVWF  FF8
0B12C:  CALL   5116
....................                   record_event(); 
0B130:  CALL   851A
....................          break; 
0B134:  BRA    B1D6
....................       case 5526 : nv_product = WMS4; 
0B136:  CLRF   30
0B138:  MOVLW  01
0B13A:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B13C:  MOVLW  1E
0B13E:  MOVLB  8
0B140:  MOVWF  xD8
0B142:  CLRF   xDA
0B144:  MOVLW  01
0B146:  MOVWF  xD9
0B148:  MOVLB  0
0B14A:  CALL   502C
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B14E:  MOVLW  01
0B150:  MOVWF  1E
0B152:  MOVLW  A3
0B154:  MOVWF  1D
0B156:  MOVLW  3C
0B158:  MOVWF  FF6
0B15A:  MOVLW  27
0B15C:  MOVWF  FF7
0B15E:  MOVLW  00
0B160:  MOVWF  FF8
0B162:  CALL   5116
....................                   record_event();                   
0B166:  CALL   851A
....................          break;    
0B16A:  BRA    B1D6
....................       case 5527 : nv_product = AWS; 
0B16C:  CLRF   30
0B16E:  MOVLW  02
0B170:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B172:  MOVLW  1E
0B174:  MOVLB  8
0B176:  MOVWF  xD8
0B178:  CLRF   xDA
0B17A:  MOVLW  02
0B17C:  MOVWF  xD9
0B17E:  MOVLB  0
0B180:  CALL   502C
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B184:  MOVLW  01
0B186:  MOVWF  1E
0B188:  MOVLW  A3
0B18A:  MOVWF  1D
0B18C:  MOVLW  52
0B18E:  MOVWF  FF6
0B190:  MOVLW  27
0B192:  MOVWF  FF7
0B194:  MOVLW  00
0B196:  MOVWF  FF8
0B198:  CALL   5116
....................                   record_event();                   
0B19C:  CALL   851A
....................          break;   
0B1A0:  BRA    B1D6
....................       case 5528 : nv_product = WMS2; 
0B1A2:  CLRF   30
0B1A4:  MOVLW  03
0B1A6:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B1A8:  MOVLW  1E
0B1AA:  MOVLB  8
0B1AC:  MOVWF  xD8
0B1AE:  CLRF   xDA
0B1B0:  MOVLW  03
0B1B2:  MOVWF  xD9
0B1B4:  MOVLB  0
0B1B6:  CALL   502C
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B1BA:  MOVLW  01
0B1BC:  MOVWF  1E
0B1BE:  MOVLW  A3
0B1C0:  MOVWF  1D
0B1C2:  MOVLW  62
0B1C4:  MOVWF  FF6
0B1C6:  MOVLW  27
0B1C8:  MOVWF  FF7
0B1CA:  MOVLW  00
0B1CC:  MOVWF  FF8
0B1CE:  CALL   5116
....................                   record_event();                   
0B1D2:  CALL   851A
....................          break;            
....................    } 
0B1D6:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0B08E:  MOVF   44,W
0B090:  MOVWF  00
0B092:  MOVF   45,W
0B094:  MOVWF  03
0B096:  BNZ   B09C
0B098:  MOVF   00,F
0B09A:  BZ    B0B2
0B09C:  MOVF   03,W
0B09E:  BNZ   B0A6
0B0A0:  MOVLW  01
0B0A2:  SUBWF  00,W
0B0A4:  BZ    B0B8
0B0A6:  MOVF   03,W
0B0A8:  BNZ   B0B0
0B0AA:  MOVLW  02
0B0AC:  SUBWF  00,W
0B0AE:  BZ    B0BE
0B0B0:  BRA    B0C4
....................       case 0 : kill_wd(); 
0B0B2:  CALL   3158
....................          break; 
0B0B6:  BRA    B0C6
....................       case 1 : start_heartbeat(); 
0B0B8:  CALL   2962
....................          break; 
0B0BC:  BRA    B0C6
....................       case 2 : suspend_heartbeat(); 
0B0BE:  CALL   55A8
....................          break; 
0B0C2:  BRA    B0C6
....................       default : cmd_arg(); 
0B0C4:  RCALL  B070
....................          break; 
....................    } 
0B0C6:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0AFCE:  MOVF   44,W
0AFD0:  MOVWF  00
0AFD2:  MOVF   45,W
0AFD4:  MOVWF  03
0AFD6:  BNZ   AFDC
0AFD8:  MOVF   00,F
0AFDA:  BZ    AFEA
0AFDC:  MOVLW  15
0AFDE:  SUBWF  03,W
0AFE0:  BNZ   AFE8
0AFE2:  MOVLW  95
0AFE4:  SUBWF  00,W
0AFE6:  BZ    B048
0AFE8:  BRA    B06C
....................       case 0:     signon(); 
0AFEA:  CALL   31AA
....................                   fprintf(COM_A, __DATE__); 
0AFEE:  MOVLW  78
0AFF0:  MOVWF  FF6
0AFF2:  MOVLW  27
0AFF4:  MOVWF  FF7
0AFF6:  MOVLW  00
0AFF8:  MOVWF  FF8
0AFFA:  CLRF   1B
0AFFC:  BTFSC  FF2.7
0AFFE:  BSF    1B.7
0B000:  BCF    FF2.7
0B002:  CALL   0DCC
0B006:  BTFSC  1B.7
0B008:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B00A:  MOVLW  0D
0B00C:  BTFSS  F9E.4
0B00E:  BRA    B00C
0B010:  MOVWF  FAD
0B012:  MOVLW  0A
0B014:  BTFSS  F9E.4
0B016:  BRA    B014
0B018:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0B01A:  MOVLW  82
0B01C:  MOVWF  FF6
0B01E:  MOVLW  27
0B020:  MOVWF  FF7
0B022:  MOVLW  00
0B024:  MOVWF  FF8
0B026:  CLRF   1B
0B028:  BTFSC  FF2.7
0B02A:  BSF    1B.7
0B02C:  BCF    FF2.7
0B02E:  CALL   0DCC
0B032:  BTFSC  1B.7
0B034:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B036:  MOVLW  0D
0B038:  BTFSS  F9E.4
0B03A:  BRA    B038
0B03C:  MOVWF  FAD
0B03E:  MOVLW  0A
0B040:  BTFSS  F9E.4
0B042:  BRA    B040
0B044:  MOVWF  FAD
....................          break; 
0B046:  BRA    B06C
....................       case 5525 : kill_wd(); 
0B048:  CALL   3158
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0B04C:  MOVLW  8C
0B04E:  MOVWF  FF6
0B050:  MOVLW  27
0B052:  MOVWF  FF7
0B054:  MOVLW  00
0B056:  MOVWF  FF8
0B058:  CLRF   1B
0B05A:  BTFSC  FF2.7
0B05C:  BSF    1B.7
0B05E:  BCF    FF2.7
0B060:  CALL   0DCC
0B064:  BTFSC  1B.7
0B066:  BSF    FF2.7
....................                   load_program(); 
0B068:  CALL   1F800
....................          break; 
....................    } 
0B06C:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
18706:  MOVF   44,W
18708:  MOVWF  00
1870A:  MOVF   45,W
1870C:  MOVWF  03
1870E:  BNZ   18714
18710:  MOVF   00,F
18712:  BZ    18720
18714:  MOVF   03,W
18716:  BNZ   1871E
18718:  MOVLW  01
1871A:  SUBWF  00,W
1871C:  BZ    18724
1871E:  BRA    18728
....................       case 0 : cmd_set=0;  // user 
18720:  CLRF   4D
....................          break; 
18722:  BRA    18728
....................       case 1 : cmd_set=1;  // full 
18724:  MOVLW  01
18726:  MOVWF  4D
....................          break; 
....................    } 
18728:  GOTO   1ADAE (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1AC1E:  CALL   AEAC
....................     
....................    switch (cmd) 
1AC22:  MOVLW  23
1AC24:  SUBWF  43,W
1AC26:  ADDLW  A8
1AC28:  BTFSC  FD8.0
1AC2A:  BRA    1ADAE
1AC2C:  ADDLW  58
1AC2E:  GOTO   1ADB2
....................    { 
....................       case '&': commandFW(); 
1AC32:  GOTO   AFCE
....................          break; 
1AC36:  BRA    1ADAE
....................       case '#': command_hash(); 
1AC38:  GOTO   B08E
....................          break;          
1AC3C:  BRA    1ADAE
....................       case '%': command_prod(); 
1AC3E:  GOTO   B0CA
....................          break; 
1AC42:  BRA    1ADAE
....................       case '*': command_star(); 
1AC44:  GOTO   BCB8
....................          break;       
1AC48:  BRA    1ADAE
....................       // standard commands 
....................       case '/': command_addr(); 
1AC4A:  GOTO   BD02
....................          break; 
1AC4E:  BRA    1ADAE
....................       case 'A': commandA(); 
1AC50:  GOTO   BE9C
....................          break; 
1AC54:  BRA    1ADAE
....................       case 'B': commandB(); 
1AC56:  GOTO   C008
....................          break; 
1AC5A:  BRA    1ADAE
....................       case 'C': commandC(); 
1AC5C:  GOTO   DA40
....................          break; 
1AC60:  BRA    1ADAE
....................       case 'D': commandD(); 
1AC62:  GOTO   DA7E
....................          break; 
1AC66:  BRA    1ADAE
....................       case 'E': commandE(); 
1AC68:  GOTO   DB18
....................          break;          
1AC6C:  BRA    1ADAE
....................       case 'F': commandF(); 
1AC6E:  GOTO   DE16
....................          break;          
1AC72:  BRA    1ADAE
....................       case 'G': commandG(); 
1AC74:  GOTO   DE80
....................          break; 
1AC78:  BRA    1ADAE
....................       case 'H': commandH(); 
1AC7A:  GOTO   EFDE
....................          break; 
1AC7E:  BRA    1ADAE
....................       case 'I': commandI(); 
1AC80:  GOTO   F01E
....................          break;    
1AC84:  BRA    1ADAE
....................       case 'J': commandJ(); 
1AC86:  GOTO   F06A
....................          break;      
1AC8A:  BRA    1ADAE
....................       case 'K': commandK(); 
1AC8C:  GOTO   F2C4
....................          break;    
1AC90:  BRA    1ADAE
....................       case 'L': commandL(); 
1AC92:  GOTO   10260
....................          break;             
1AC96:  BRA    1ADAE
....................       case 'M': commandM(FALSE); 
1AC98:  MOVLB  8
1AC9A:  CLRF   x6F
1AC9C:  MOVLB  0
1AC9E:  CALL   169AE
....................          break;   
1ACA2:  BRA    1ADAE
....................       case 'N': commandN(); 
1ACA4:  GOTO   16AAE
....................          break;          
1ACA8:  BRA    1ADAE
....................       case 'O': commandO(); 
1ACAA:  GOTO   16C5E
....................          break;    
1ACAE:  BRA    1ADAE
....................       case 'P': commandP(); 
1ACB0:  GOTO   16E62
....................          break;  
1ACB4:  BRA    1ADAE
....................       case 'Q': commandQ(); 
1ACB6:  GOTO   16F20
....................          break;              
1ACBA:  BRA    1ADAE
....................       case 'R': commandR(); 
1ACBC:  GOTO   171B6
....................          break;    
1ACC0:  BRA    1ADAE
....................       case 'S': commandS(); 
1ACC2:  GOTO   172E2
....................          break;  
1ACC6:  BRA    1ADAE
....................       case 'T': commandT(); 
1ACC8:  GOTO   17880
....................          break;            
1ACCC:  BRA    1ADAE
....................       case 'U': commandU(); 
1ACCE:  GOTO   18282
....................          break;           
1ACD2:  BRA    1ADAE
....................       case 'V': commandV(); 
1ACD4:  GOTO   183DA
....................          break; 
1ACD8:  BRA    1ADAE
....................       case 'W': commandW(); 
1ACDA:  GOTO   1854E
....................          break; 
1ACDE:  BRA    1ADAE
....................       case 'X': commandX(); 
1ACE0:  GOTO   18572
....................          break; 
1ACE4:  BRA    1ADAE
....................       case 'Y': commandY(); 
1ACE6:  GOTO   185DA
....................          break;  
1ACEA:  BRA    1ADAE
....................       case 'Z': commandZ(); 
1ACEC:  CALL   186E2
....................          break;    
1ACF0:  BRA    1ADAE
....................       // stepper 
....................       case '^': command_set(); 
1ACF2:  GOTO   18706
....................          break;       
1ACF6:  BRA    1ADAE
....................       case '+': if(m_fixed==1) motor=1; 
1ACF8:  MOVLB  7
1ACFA:  DECFSZ x3D,W
1ACFC:  BRA    1AD02
1ACFE:  MOVLW  01
1AD00:  MOVWF  x3C
....................                 command_move(0,0,1); 
1AD02:  MOVLB  8
1AD04:  CLRF   x6F
1AD06:  CLRF   x70
1AD08:  MOVLW  01
1AD0A:  MOVWF  x71
1AD0C:  MOVLB  0
1AD0E:  CALL   16C82
....................          break; 
1AD12:  BRA    1ADAE
....................       case '-': if(m_fixed==1) motor=1; 
1AD14:  MOVLB  7
1AD16:  DECFSZ x3D,W
1AD18:  BRA    1AD1E
1AD1A:  MOVLW  01
1AD1C:  MOVWF  x3C
....................                 command_move(0,1,1); 
1AD1E:  MOVLB  8
1AD20:  CLRF   x6F
1AD22:  MOVLW  01
1AD24:  MOVWF  x70
1AD26:  MOVWF  x71
1AD28:  MOVLB  0
1AD2A:  CALL   16C82
....................          break; 
1AD2E:  BRA    1ADAE
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1AD30:  GOTO   18832
....................          break;     
1AD34:  BRA    1ADAE
....................       case 'b': command_b(); 
1AD36:  GOTO   1884E
....................          break;           
1AD3A:  BRA    1ADAE
....................       case 'd': command_d(); 
1AD3C:  GOTO   188E8
....................          break;          
1AD40:  BRA    1ADAE
....................       case 'e': command_e(); 
1AD42:  GOTO   1897E
....................          break;       
1AD46:  BRA    1ADAE
....................       case 'f': command_f(); 
1AD48:  GOTO   18A18
....................          break; 
1AD4C:  BRA    1ADAE
....................       case 'g': command_g(); 
1AD4E:  GOTO   18A38
....................          break;          
1AD52:  BRA    1ADAE
....................       case 'h': command_h(); 
1AD54:  GOTO   18AD2
....................          break; 
1AD58:  BRA    1ADAE
....................       case 'i': command_i(); 
1AD5A:  GOTO   18BA6
....................          break;   
1AD5E:  BRA    1ADAE
....................       case 'j': command_j(); 
1AD60:  GOTO   18C82
....................          break;           
1AD64:  BRA    1ADAE
....................       case 'k': command_k(); 
1AD66:  GOTO   18D1C
....................          break;          
1AD6A:  BRA    1ADAE
....................       case 'l': step_var_list(); 
1AD6C:  GOTO   18DB2
....................          break;          
1AD70:  BRA    1ADAE
....................       case 'm': command_m(); 
1AD72:  GOTO   19A12
....................          break;    
1AD76:  BRA    1ADAE
....................       case 'n': command_n(); 
1AD78:  GOTO   19AA8
....................          break; 
1AD7C:  BRA    1ADAE
....................       case 'o': command_o(); 
1AD7E:  GOTO   19B3E
....................          break;    
1AD82:  BRA    1ADAE
....................       case 'p': command_p(); 
1AD84:  GOTO   19BD8
....................          break;   
1AD88:  BRA    1ADAE
....................       case 'q': command_q(); 
1AD8A:  GOTO   19C72
....................          break; 
1AD8E:  BRA    1ADAE
....................       case 'r': command_r(); 
1AD90:  BRA    1A76E
....................          break;    
1AD92:  BRA    1ADAE
....................       case 's': command_s(); 
1AD94:  BRA    1A7C8
....................          break;           
1AD96:  BRA    1ADAE
....................       case 't': command_t(); 
1AD98:  BRA    1A8D6
....................          break;          
1AD9A:  BRA    1ADAE
....................       case 'u': command_u(); 
1AD9C:  BRA    1A96C
....................          break;           
1AD9E:  BRA    1ADAE
....................       case 'w': command_w(); 
1ADA0:  BRA    1A9A4
....................          break; 
1ADA2:  BRA    1ADAE
....................       case 'x': command_x(); 
1ADA4:  BRA    1AA78
....................          break;    
1ADA6:  BRA    1ADAE
....................       case 'y': command_y(); 
1ADA8:  BRA    1AB12
....................          break;  
1ADAA:  BRA    1ADAE
....................       case 'z': command_z(); 
1ADAC:  BRA    1ABA8
....................          break;           
....................    } 
1ADAE:  GOTO   1AF36 (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................  
....................   number = 0; 
*
1AE82:  MOVLB  8
1AE84:  CLRF   x6D
....................   arg = 0; 
1AE86:  CLRF   47
1AE88:  CLRF   46
1AE8A:  CLRF   45
1AE8C:  CLRF   44
....................   good_arg = FALSE; 
1AE8E:  CLRF   x6E
....................    
....................   while (number != CARRIAGE_RET) 
1AE90:  MOVF   x6D,W
1AE92:  SUBLW  0D
1AE94:  BZ    1AF68
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
1AE96:  MOVLB  0
1AE98:  CALL   0E5C
1AE9C:  MOVFF  01,86D
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
1AEA0:  MOVLB  8
1AEA2:  MOVF   x6D,W
1AEA4:  SUBLW  0D
1AEA6:  BZ    1AEB2
1AEA8:  MOVF   x6D,W
1AEAA:  MOVLB  0
1AEAC:  CALL   AEB4
1AEB0:  MOVLB  8
....................      if (number > 47 && number < 58) 
1AEB2:  MOVF   x6D,W
1AEB4:  SUBLW  2F
1AEB6:  BC    1AF08
1AEB8:  MOVF   x6D,W
1AEBA:  SUBLW  39
1AEBC:  BNC   1AF08
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
1AEBE:  MOVLW  30
1AEC0:  SUBWF  x6D,F
....................         arg = arg * 10;                    // increase significance 
1AEC2:  MOVFF  47,9E3
1AEC6:  MOVFF  46,9E2
1AECA:  MOVFF  45,9E1
1AECE:  MOVFF  44,9E0
1AED2:  MOVLB  9
1AED4:  CLRF   xE7
1AED6:  CLRF   xE6
1AED8:  CLRF   xE5
1AEDA:  MOVLW  0A
1AEDC:  MOVWF  xE4
1AEDE:  MOVLB  0
1AEE0:  CALL   4852
1AEE4:  MOVFF  03,47
1AEE8:  MOVFF  02,46
1AEEC:  MOVFF  01,45
1AEF0:  MOVFF  00,44
....................         arg = arg + number;                // for each number 
1AEF4:  MOVLB  8
1AEF6:  MOVF   x6D,W
1AEF8:  ADDWF  44,F
1AEFA:  MOVLW  00
1AEFC:  ADDWFC 45,F
1AEFE:  ADDWFC 46,F
1AF00:  ADDWFC 47,F
....................         good_arg = TRUE; 
1AF02:  MOVLW  01
1AF04:  MOVWF  x6E
....................      } 
1AF06:  BRA    1AF60
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
1AF08:  MOVF   x6D,W
1AF0A:  SUBLW  0D
1AF0C:  BNZ   1AF3A
1AF0E:  DECFSZ x6E,W
1AF10:  BRA    1AF3A
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
1AF12:  MOVLW  B2
1AF14:  MOVWF  FF6
1AF16:  MOVLW  27
1AF18:  MOVWF  FF7
1AF1A:  MOVLW  00
1AF1C:  MOVWF  FF8
1AF1E:  MOVLB  0
1AF20:  CALL   AE82
1AF24:  MOVLW  0D
1AF26:  BTFSS  F9E.4
1AF28:  BRA    1AF26
1AF2A:  MOVWF  FAD
1AF2C:  MOVLW  0A
1AF2E:  BTFSS  F9E.4
1AF30:  BRA    1AF2E
1AF32:  MOVWF  FAD
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
1AF34:  BRA    1AC1E
....................      } 
1AF36:  BRA    1AF5E
1AF38:  MOVLB  8
....................      else 
....................      { 
....................         good_arg = FALSE; 
1AF3A:  CLRF   x6E
....................         fputs("@ARG ", COM_A);             // bad input 
1AF3C:  MOVLW  B8
1AF3E:  MOVWF  FF6
1AF40:  MOVLW  27
1AF42:  MOVWF  FF7
1AF44:  MOVLW  00
1AF46:  MOVWF  FF8
1AF48:  MOVLB  0
1AF4A:  CALL   AE82
1AF4E:  MOVLW  0D
1AF50:  BTFSS  F9E.4
1AF52:  BRA    1AF50
1AF54:  MOVWF  FAD
1AF56:  MOVLW  0A
1AF58:  BTFSS  F9E.4
1AF5A:  BRA    1AF58
1AF5C:  MOVWF  FAD
1AF5E:  MOVLB  8
....................      } 
....................      if (good_arg == FALSE) break; 
1AF60:  MOVF   x6E,F
1AF62:  BTFSC  FD8.2
1AF64:  BRA    1AF68
1AF66:  BRA    1AE90
....................   } 
1AF68:  MOVLB  0
1AF6A:  GOTO   1AF9E (RETURN)
.................... } 
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0AEFE:  MOVF   4D,F
0AF00:  BNZ   AF52
0AF02:  MOVLB  8
0AF04:  MOVF   x6D,W
0AF06:  SUBLW  24
0AF08:  BC    AF10
0AF0A:  MOVF   x6D,W
0AF0C:  SUBLW  26
0AF0E:  BC    AF4A
0AF10:  MOVF   x6D,W
0AF12:  SUBLW  29
0AF14:  BC    AF1C
0AF16:  MOVF   x6D,W
0AF18:  SUBLW  2B
0AF1A:  BC    AF4A
0AF1C:  MOVF   x6D,W
0AF1E:  SUBLW  2D
0AF20:  BZ    AF4A
0AF22:  MOVF   x6D,W
0AF24:  SUBLW  2F
0AF26:  BZ    AF4A
0AF28:  MOVF   x6D,W
0AF2A:  SUBLW  40
0AF2C:  BC    AF34
0AF2E:  MOVF   x6D,W
0AF30:  SUBLW  42
0AF32:  BC    AF4A
0AF34:  MOVF   x6D,W
0AF36:  SUBLW  43
0AF38:  BC    AF40
0AF3A:  MOVF   x6D,W
0AF3C:  SUBLW  5A
0AF3E:  BC    AF4A
0AF40:  MOVF   x6D,W
0AF42:  SUBLW  5E
0AF44:  BZ    AF4A
0AF46:  MOVLW  00
0AF48:  BRA    AF4C
0AF4A:  MOVLW  01
0AF4C:  MOVWF  x6E
0AF4E:  BRA    AFC0
0AF50:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0AF52:  DECFSZ 4D,W
0AF54:  BRA    AFC2
0AF56:  MOVLB  8
0AF58:  MOVF   x6D,W
0AF5A:  SUBLW  23
0AF5C:  BZ    AFBC
0AF5E:  MOVF   x6D,W
0AF60:  SUBLW  24
0AF62:  BC    AF6A
0AF64:  MOVF   x6D,W
0AF66:  SUBLW  26
0AF68:  BC    AFBC
0AF6A:  MOVF   x6D,W
0AF6C:  SUBLW  29
0AF6E:  BC    AF76
0AF70:  MOVF   x6D,W
0AF72:  SUBLW  2B
0AF74:  BC    AFBC
0AF76:  MOVF   x6D,W
0AF78:  SUBLW  2D
0AF7A:  BZ    AFBC
0AF7C:  MOVF   x6D,W
0AF7E:  SUBLW  2F
0AF80:  BZ    AFBC
0AF82:  MOVF   x6D,W
0AF84:  SUBLW  40
0AF86:  BC    AF8E
0AF88:  MOVF   x6D,W
0AF8A:  SUBLW  42
0AF8C:  BC    AFBC
0AF8E:  MOVF   x6D,W
0AF90:  SUBLW  43
0AF92:  BC    AF9A
0AF94:  MOVF   x6D,W
0AF96:  SUBLW  5A
0AF98:  BC    AFBC
0AF9A:  MOVF   x6D,W
0AF9C:  SUBLW  5E
0AF9E:  BZ    AFBC
0AFA0:  MOVF   x6D,W
0AFA2:  SUBLW  60
0AFA4:  BC    AFAC
0AFA6:  MOVF   x6D,W
0AFA8:  SUBLW  75
0AFAA:  BC    AFBC
0AFAC:  MOVF   x6D,W
0AFAE:  SUBLW  76
0AFB0:  BC    AFB8
0AFB2:  MOVF   x6D,W
0AFB4:  SUBLW  7A
0AFB6:  BC    AFBC
0AFB8:  MOVLW  00
0AFBA:  BRA    AFBE
0AFBC:  MOVLW  01
0AFBE:  MOVWF  x6E
0AFC0:  MOVLB  0
....................    return(valid); 
0AFC2:  MOVLB  8
0AFC4:  MOVFF  86E,01
0AFC8:  MOVLB  0
0AFCA:  GOTO   1AF76 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
*
1AF6E:  MOVFF  43,86D
1AF72:  GOTO   AEFE
1AF76:  MOVF   01,F
1AF78:  BZ    1AF7E
1AF7A:  BRA    1AE82
1AF7C:  BRA    1AF9E
....................    else fputs("@INV", COM_A); 
1AF7E:  MOVLW  BE
1AF80:  MOVWF  FF6
1AF82:  MOVLW  27
1AF84:  MOVWF  FF7
1AF86:  MOVLW  00
1AF88:  MOVWF  FF8
1AF8A:  CALL   AE82
1AF8E:  MOVLW  0D
1AF90:  BTFSS  F9E.4
1AF92:  BRA    1AF90
1AF94:  MOVWF  FAD
1AF96:  MOVLW  0A
1AF98:  BTFSS  F9E.4
1AF9A:  BRA    1AF98
1AF9C:  MOVWF  FAD
1AF9E:  GOTO   1B020 (RETURN)
.................... } 
....................  
.................... void command_prompt() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................     
....................    nv_cmd_mode = TRUE; 
1AFA2:  CLRF   32
1AFA4:  MOVLW  01
1AFA6:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1AFA8:  MOVLW  02
1AFAA:  MOVLB  8
1AFAC:  MOVWF  x73
1AFAE:  MOVFF  31,874
1AFB2:  MOVLB  0
1AFB4:  CALL   3474
....................     
....................    fputs("@CMD", COM_A); 
1AFB8:  MOVLW  C4
1AFBA:  MOVWF  FF6
1AFBC:  MOVLW  27
1AFBE:  MOVWF  FF7
1AFC0:  MOVLW  00
1AFC2:  MOVWF  FF8
1AFC4:  CALL   AE82
1AFC8:  MOVLW  0D
1AFCA:  BTFSS  F9E.4
1AFCC:  BRA    1AFCA
1AFCE:  MOVWF  FAD
1AFD0:  MOVLW  0A
1AFD2:  BTFSS  F9E.4
1AFD4:  BRA    1AFD2
1AFD6:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1AFD8:  MOVLW  01
1AFDA:  MOVWF  1E
1AFDC:  MOVLW  A3
1AFDE:  MOVWF  1D
1AFE0:  MOVLW  CA
1AFE2:  MOVWF  FF6
1AFE4:  MOVLW  27
1AFE6:  MOVWF  FF7
1AFE8:  MOVLW  00
1AFEA:  MOVWF  FF8
1AFEC:  CALL   5116
....................    record_event(); 
1AFF0:  CALL   851A
....................     
....................    busy_clear(); 
1AFF4:  CALL   AEAC
....................     
....................    cmd_set=0; // user 
1AFF8:  CLRF   4D
....................     
....................    do { 
....................       fputc('>',COM_A); 
1AFFA:  MOVLW  3E
1AFFC:  CALL   AEB4
....................       cmd=fgetc(COM_A); 
1B000:  CALL   0E5C
1B004:  MOVFF  01,43
....................       if (com_echo == TRUE) 
1B008:  DECFSZ 48,W
1B00A:  BRA    1B012
....................       { 
....................          fputc(cmd,COM_A); 
1B00C:  MOVF   43,W
1B00E:  CALL   AEB4
....................       } 
....................       if (cmd == '?') msg_busy(); 
1B012:  MOVF   43,W
1B014:  SUBLW  3F
1B016:  BNZ   1B01E
1B018:  GOTO   AEBC
1B01C:  BRA    1B020
....................       else proc_cmd(); 
1B01E:  BRA    1AF6E
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
1B020:  DECFSZ 31,W
1B022:  BRA    1B028
1B024:  MOVF   32,F
1B026:  BZ    1AFFA
1B028:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
1B02A:  CLRF   FF8
1B02C:  BCF    FD0.7
1B02E:  BSF    07.7
1B030:  MOVLW  70
1B032:  MOVWF  FD3
1B034:  MOVLW  40
1B036:  MOVWF  F9B
1B038:  CLRF   F64
1B03A:  CLRF   1C
1B03C:  BSF    F65.3
1B03E:  MOVWF  FAF
1B040:  MOVLW  03
1B042:  MOVWF  FD4
1B044:  MOVLW  A6
1B046:  MOVWF  FAC
1B048:  MOVLW  90
1B04A:  MOVWF  FAB
1B04C:  MOVLB  F
1B04E:  BSF    x20.3
1B050:  MOVLW  82
1B052:  MOVWF  x1E
1B054:  MOVLW  06
1B056:  MOVWF  x1F
1B058:  MOVLW  A6
1B05A:  MOVWF  x21
1B05C:  MOVLW  90
1B05E:  MOVWF  x22
1B060:  BSF    F65.3
1B062:  MOVLW  40
1B064:  MOVWF  FAF
1B066:  MOVLW  03
1B068:  MOVWF  FD4
1B06A:  MOVLW  A6
1B06C:  MOVWF  FAC
1B06E:  MOVLW  90
1B070:  MOVWF  FAB
1B072:  CLRF   1E
1B074:  CLRF   1D
1B076:  CLRF   42
1B078:  MOVLW  01
1B07A:  MOVWF  41
1B07C:  MOVWF  48
1B07E:  BCF    49.0
1B080:  BCF    49.1
1B082:  BCF    49.2
1B084:  MOVLB  0
1B086:  CLRF   x62
1B088:  MOVLB  2
1B08A:  MOVWF  xD5
1B08C:  MOVLB  3
1B08E:  CLRF   x37
1B090:  MOVLB  4
1B092:  CLRF   xE3
1B094:  MOVWF  xE9
1B096:  MOVLW  04
1B098:  MOVLB  7
1B09A:  MOVWF  x0F
1B09C:  MOVLW  EA
1B09E:  MOVWF  x0E
1B0A0:  CLRF   xC9
1B0A2:  MOVLB  8
1B0A4:  CLRF   x54
1B0A6:  CLRF   x53
1B0A8:  CLRF   x58
1B0AA:  CLRF   x57
1B0AC:  CLRF   x56
1B0AE:  CLRF   x55
1B0B0:  CLRF   x5C
1B0B2:  CLRF   x5B
1B0B4:  CLRF   x5A
1B0B6:  CLRF   x59
1B0B8:  MOVLW  00
1B0BA:  MOVLB  F
1B0BC:  MOVWF  x23
1B0BE:  MOVWF  x24
1B0C0:  MOVWF  x25
1B0C2:  BCF    FC1.3
1B0C4:  BCF    FC1.4
1B0C6:  BCF    FC1.5
1B0C8:  CLRF   x2E
1B0CA:  CLRF   x2F
1B0CC:  CLRF   x54
1B0CE:  BRA    1B190
1B0D0:  DATA 44,02
1B0D2:  DATA D9,20
1B0D4:  DATA 64,72
1B0D6:  DATA 61,77
1B0D8:  DATA 5F,61
1B0DA:  DATA 6C,6C
1B0DC:  DATA 2E,63
1B0DE:  DATA 73,76
1B0E0:  DATA 00,20
1B0E2:  DATA 64,72
1B0E4:  DATA 61,77
1B0E6:  DATA 5F,6E
1B0E8:  DATA 65,77
1B0EA:  DATA 2E,63
1B0EC:  DATA 73,76
1B0EE:  DATA 00,20
1B0F0:  DATA 64,72
1B0F2:  DATA 65,6C
1B0F4:  DATA 5F,61
1B0F6:  DATA 6C,6C
1B0F8:  DATA 2E,63
1B0FA:  DATA 73,76
1B0FC:  DATA 00,20
1B0FE:  DATA 64,72
1B100:  DATA 65,6C
1B102:  DATA 5F,6E
1B104:  DATA 65,77
1B106:  DATA 2E,63
1B108:  DATA 73,76
1B10A:  DATA 00,20
1B10C:  DATA 65,76
1B10E:  DATA 65,6E
1B110:  DATA 74,73
1B112:  DATA 2E,74
1B114:  DATA 78,74
1B116:  DATA 00,02
1B118:  DATA 03,35
1B11A:  DATA 2C,00
1B11C:  DATA 02,04
1B11E:  DATA D4,00
1B120:  DATA 00,10
1B122:  DATA 07,10
1B124:  DATA 46,41
1B126:  DATA 54,31
1B128:  DATA 32,46
1B12A:  DATA 41,54
1B12C:  DATA 31,36
1B12E:  DATA 46,41
1B130:  DATA 54,33
1B132:  DATA 32,00
1B134:  DATA 57,07
1B136:  DATA CA,0D
1B138:  DATA 0A,00
1B13A:  DATA 00,03
1B13C:  DATA 00,0F
1B13E:  DATA 00,1B
1B140:  DATA 00,27
1B142:  DATA 00,33
1B144:  DATA 00,3F
1B146:  DATA 00,4B
1B148:  DATA 00,57
1B14A:  DATA 00,63
1B14C:  DATA 00,6F
1B14E:  DATA 00,7B
1B150:  DATA 00,87
1B152:  DATA 00,93
1B154:  DATA 00,9F
1B156:  DATA 00,AB
1B158:  DATA 00,B7
1B15A:  DATA 00,C3
1B15C:  DATA 48,B1
1B15E:  DATA 70,D4
1B160:  DATA 98,F7
1B162:  DATA C0,1A
1B164:  DATA 00,CF
1B166:  DATA 28,F2
1B168:  DATA 50,15
1B16A:  DATA 78,38
1B16C:  DATA A0,5B
1B16E:  DATA C8,7E
1B170:  DATA F0,A1
1B172:  DATA 18,C5
1B174:  DATA 40,E8
1B176:  DATA 68,0B
1B178:  DATA 90,2E
1B17A:  DATA B8,51
1B17C:  DATA E0,74
1B17E:  DATA 08,98
1B180:  DATA 30,BB
1B182:  DATA 58,DE
1B184:  DATA 80,01
1B186:  DATA A8,24
1B188:  DATA D0,47
1B18A:  DATA F8,6A
1B18C:  DATA 20,8E
1B18E:  DATA 00,00
1B190:  MOVLW  01
1B192:  MOVWF  FF8
1B194:  MOVLW  B0
1B196:  MOVWF  FF7
1B198:  MOVLW  D0
1B19A:  MOVWF  FF6
1B19C:  TBLRD*+
1B19E:  MOVF   FF5,W
1B1A0:  MOVWF  00
1B1A2:  XORLW  00
1B1A4:  BZ    1B1CC
1B1A6:  TBLRD*+
1B1A8:  MOVF   FF5,W
1B1AA:  MOVWF  01
1B1AC:  BTFSC  FE8.7
1B1AE:  BRA    1B1BA
1B1B0:  ANDLW  0F
1B1B2:  MOVWF  FEA
1B1B4:  TBLRD*+
1B1B6:  MOVFF  FF5,FE9
1B1BA:  BTFSC  01.6
1B1BC:  TBLRD*+
1B1BE:  BTFSS  01.6
1B1C0:  TBLRD*+
1B1C2:  MOVFF  FF5,FEE
1B1C6:  DCFSNZ 00,F
1B1C8:  BRA    1B19C
1B1CA:  BRA    1B1BE
1B1CC:  CLRF   FF8
1B1CE:  MOVLB  8
1B1D0:  CLRF   x5D
1B1D2:  CLRF   x5F
1B1D4:  CLRF   x5E
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B1D6:  BCF    FF2.6
1B1D8:  BCF    FF2.7
1B1DA:  BTFSC  FF2.7
1B1DC:  BRA    1B1D8
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B1DE:  BCF    FC6.5
1B1E0:  MOVLW  21
1B1E2:  MOVWF  FC6
1B1E4:  MOVLW  40
1B1E6:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B1E8:  BCF    F67.5
1B1EA:  MOVLW  21
1B1EC:  MOVWF  F67
1B1EE:  MOVLW  40
1B1F0:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B1F2:  MOVLW  00
1B1F4:  MOVLB  F
1B1F6:  MOVWF  x23
1B1F8:  MOVWF  x24
1B1FA:  MOVLW  1F
1B1FC:  MOVWF  x25
1B1FE:  BCF    FC1.3
1B200:  BSF    FC1.4
1B202:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B204:  MOVF   FC0,W
1B206:  ANDLW  C0
1B208:  IORLW  07
1B20A:  MOVWF  FC0
1B20C:  BSF    FC0.7
1B20E:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B210:  MOVLW  87
1B212:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B214:  MOVLW  37
1B216:  MOVWF  FCD
1B218:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B21A:  MOVLB  0
1B21C:  GOTO   2926
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B220:  CLRF   FB0
1B222:  MOVLW  07
1B224:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B226:  MOVLW  04
1B228:  MOVLB  F
1B22A:  MOVWF  x2E
1B22C:  MOVWF  x2F
1B22E:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B230:  MOVLW  70
1B232:  MOVWF  FD3
1B234:  MOVLW  40
1B236:  MOVWF  F9B
1B238:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B23A:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B23C:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B23E:  MOVLB  0
1B240:  CALL   2962
....................  
....................    enable_interrupts(GLOBAL); 
1B244:  MOVLW  C0
1B246:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
1B248:  CALL   299C
....................    motor_sleep_rdy(); 
1B24C:  CALL   29FA
....................  
....................    sleep_mode = FALSE;    
1B250:  BCF    49.1
....................    busy_set(); 
1B252:  CALL   2A22
....................     
....................    init_nv_vars(); 
1B256:  CALL   2B1A
....................    get_step_vars(); 
1B25A:  CALL   2D7C
....................    init_aws(); 
1B25E:  GOTO   313E
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B262:  CALL   3158
....................    blink(); 
1B266:  GOTO   315E
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B26A:  CALL   31AA
....................     
....................    RTC_read(); 
1B26E:  CALL   33A6
....................    RTC_last_power(); 
1B272:  GOTO   34A4
....................    RTC_reset_HT();   
1B276:  CALL   3514
....................    RTC_read(); 
1B27A:  CALL   33A6
1B27E:  CLRF   1B
1B280:  BTFSC  FF2.7
1B282:  BSF    1B.7
1B284:  BCF    FF2.7
....................    RTC_read_flags(); 
1B286:  CALL   0DF6
1B28A:  BTFSC  1B.7
1B28C:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B28E:  MOVF   3B,F
1B290:  BNZ   1B296
1B292:  MOVF   3C,F
1B294:  BZ    1B2E6
1B296:  MOVLW  DC
1B298:  MOVWF  FF6
1B29A:  MOVLW  27
1B29C:  MOVWF  FF7
1B29E:  MOVLW  00
1B2A0:  MOVWF  FF8
1B2A2:  CLRF   1B
1B2A4:  BTFSC  FF2.7
1B2A6:  BSF    1B.7
1B2A8:  BCF    FF2.7
1B2AA:  MOVLW  04
1B2AC:  MOVLB  A
1B2AE:  MOVWF  x25
1B2B0:  MOVLB  0
1B2B2:  CALL   101E
1B2B6:  BTFSC  1B.7
1B2B8:  BSF    FF2.7
1B2BA:  MOVLW  10
1B2BC:  MOVWF  FE9
1B2BE:  CLRF   1B
1B2C0:  BTFSC  FF2.7
1B2C2:  BSF    1B.7
1B2C4:  BCF    FF2.7
1B2C6:  MOVFF  3C,A26
1B2CA:  MOVFF  3B,A25
1B2CE:  CALL   11A0
1B2D2:  BTFSC  1B.7
1B2D4:  BSF    FF2.7
1B2D6:  MOVLW  0D
1B2D8:  BTFSS  F9E.4
1B2DA:  BRA    1B2D8
1B2DC:  MOVWF  FAD
1B2DE:  MOVLW  0A
1B2E0:  BTFSS  F9E.4
1B2E2:  BRA    1B2E0
1B2E4:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B2E6:  CALL   356A
....................    sd_status = init_sdcard(); 
1B2EA:  CALL   5092
1B2EE:  MOVFF  01,2D8
....................    if(sd_status>0) msg_card_fail(); 
1B2F2:  MOVLB  2
1B2F4:  MOVF   xD8,F
1B2F6:  BZ    1B300
1B2F8:  MOVLB  0
1B2FA:  CALL   50D8
1B2FE:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
1B300:  MOVLB  0
1B302:  GOTO   ABFE
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B306:  MOVLB  7
1B308:  MOVF   x92,F
1B30A:  BNZ   1B318
1B30C:  MOVF   x93,F
1B30E:  BNZ   1B318
1B310:  MOVF   x94,F
1B312:  BNZ   1B318
1B314:  MOVF   x95,F
1B316:  BZ    1B320
1B318:  MOVLB  0
1B31A:  CALL   9D42
1B31E:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B320:  MOVF   xAB,F
1B322:  BNZ   1B3A6
1B324:  MOVF   xAC,F
1B326:  BNZ   1B3A6
....................       e_port[0]=0; 
1B328:  CLRF   xC0
1B32A:  CLRF   xBF
....................       write16(ADDR_E1_PORT,0); 
1B32C:  MOVLW  AA
1B32E:  MOVLB  8
1B330:  MOVWF  xD8
1B332:  CLRF   xDA
1B334:  CLRF   xD9
1B336:  MOVLB  0
1B338:  CALL   502C
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B33C:  MOVLW  E6
1B33E:  MOVWF  FF6
1B340:  MOVLW  27
1B342:  MOVWF  FF7
1B344:  MOVLW  00
1B346:  MOVWF  FF8
1B348:  CLRF   1B
1B34A:  BTFSC  FF2.7
1B34C:  BSF    1B.7
1B34E:  BCF    FF2.7
1B350:  MOVLW  05
1B352:  MOVLB  A
1B354:  MOVWF  x25
1B356:  MOVLB  0
1B358:  CALL   101E
1B35C:  BTFSC  1B.7
1B35E:  BSF    FF2.7
1B360:  MOVLW  10
1B362:  MOVWF  FE9
1B364:  CLRF   1B
1B366:  BTFSC  FF2.7
1B368:  BSF    1B.7
1B36A:  BCF    FF2.7
1B36C:  MOVFF  7AC,A26
1B370:  MOVFF  7AB,A25
1B374:  CALL   11A0
1B378:  BTFSC  1B.7
1B37A:  BSF    FF2.7
1B37C:  MOVLW  2C
1B37E:  BTFSS  F9E.4
1B380:  BRA    1B37E
1B382:  MOVWF  FAD
1B384:  MOVLW  10
1B386:  MOVWF  FE9
1B388:  MOVFF  7C0,8DB
1B38C:  MOVFF  7BF,8DA
1B390:  CALL   9024
1B394:  MOVLW  0D
1B396:  BTFSS  F9E.4
1B398:  BRA    1B396
1B39A:  MOVWF  FAD
1B39C:  MOVLW  0A
1B39E:  BTFSS  F9E.4
1B3A0:  BRA    1B39E
1B3A2:  MOVWF  FAD
1B3A4:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B3A6:  MOVF   xAD,F
1B3A8:  BNZ   1B42C
1B3AA:  MOVF   xAE,F
1B3AC:  BNZ   1B42C
....................       m_lin_pos[1]=-1; 
1B3AE:  SETF   xB2
1B3B0:  SETF   xB1
....................       write16(ADDR_M2_LIN_POS, -1); 
1B3B2:  MOVLW  B8
1B3B4:  MOVLB  8
1B3B6:  MOVWF  xD8
1B3B8:  SETF   xDA
1B3BA:  SETF   xD9
1B3BC:  MOVLB  0
1B3BE:  CALL   502C
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B3C2:  MOVLW  F6
1B3C4:  MOVWF  FF6
1B3C6:  MOVLW  27
1B3C8:  MOVWF  FF7
1B3CA:  MOVLW  00
1B3CC:  MOVWF  FF8
1B3CE:  CLRF   1B
1B3D0:  BTFSC  FF2.7
1B3D2:  BSF    1B.7
1B3D4:  BCF    FF2.7
1B3D6:  MOVLW  05
1B3D8:  MOVLB  A
1B3DA:  MOVWF  x25
1B3DC:  MOVLB  0
1B3DE:  CALL   101E
1B3E2:  BTFSC  1B.7
1B3E4:  BSF    FF2.7
1B3E6:  MOVLW  10
1B3E8:  MOVWF  FE9
1B3EA:  CLRF   1B
1B3EC:  BTFSC  FF2.7
1B3EE:  BSF    1B.7
1B3F0:  BCF    FF2.7
1B3F2:  MOVFF  7AE,A26
1B3F6:  MOVFF  7AD,A25
1B3FA:  CALL   11A0
1B3FE:  BTFSC  1B.7
1B400:  BSF    FF2.7
1B402:  MOVLW  2C
1B404:  BTFSS  F9E.4
1B406:  BRA    1B404
1B408:  MOVWF  FAD
1B40A:  MOVLW  10
1B40C:  MOVWF  FE9
1B40E:  MOVFF  7B2,8DB
1B412:  MOVFF  7B1,8DA
1B416:  CALL   9024
1B41A:  MOVLW  0D
1B41C:  BTFSS  F9E.4
1B41E:  BRA    1B41C
1B420:  MOVWF  FAD
1B422:  MOVLW  0A
1B424:  BTFSS  F9E.4
1B426:  BRA    1B424
1B428:  MOVWF  FAD
1B42A:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1B42C:  MOVF   31,F
1B42E:  BNZ   1B4D2
1B430:  MOVF   32,F
1B432:  BNZ   1B4D2
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1B434:  MOVLW  06
1B436:  MOVWF  FF6
1B438:  MOVLW  28
1B43A:  MOVWF  FF7
1B43C:  MOVLW  00
1B43E:  MOVWF  FF8
1B440:  CLRF   1B
1B442:  BTFSC  FF2.7
1B444:  BSF    1B.7
1B446:  BCF    FF2.7
1B448:  MOVLB  0
1B44A:  CALL   0DCC
1B44E:  BTFSC  1B.7
1B450:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1B452:  MOVLB  8
1B454:  MOVF   x5F,F
1B456:  BNZ   1B484
1B458:  MOVF   x5E,W
1B45A:  SUBLW  63
1B45C:  BNC   1B484
1B45E:  MOVF   x5D,W
1B460:  SUBLW  1B
1B462:  BZ    1B484
....................       { 
....................          EscNum=TestForEsc(); 
1B464:  MOVLB  0
1B466:  GOTO   AE28
1B46A:  MOVFF  01,85D
....................          if(EscNum == ESCAPE) command_prompt(); 
1B46E:  MOVLB  8
1B470:  MOVF   x5D,W
1B472:  SUBLW  1B
1B474:  BNZ   1B47C
1B476:  MOVLB  0
1B478:  RCALL  1AFA2
1B47A:  MOVLB  8
....................          EscCount++; 
1B47C:  INCF   x5E,F
1B47E:  BTFSC  FD8.2
1B480:  INCF   x5F,F
1B482:  BRA    1B454
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1B484:  DECFSZ 33,W
1B486:  BRA    1B49C
1B488:  MOVF   34,F
1B48A:  BNZ   1B49C
....................       { 
....................          arg=0; 
1B48C:  CLRF   47
1B48E:  CLRF   46
1B490:  CLRF   45
1B492:  CLRF   44
....................          commandZ(); 
1B494:  MOVLB  0
1B496:  CALL   186E2
1B49A:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1B49C:  MOVLW  3E
1B49E:  MOVWF  FF6
1B4A0:  MOVLW  28
1B4A2:  MOVWF  FF7
1B4A4:  MOVLW  00
1B4A6:  MOVWF  FF8
1B4A8:  CLRF   1B
1B4AA:  BTFSC  FF2.7
1B4AC:  BSF    1B.7
1B4AE:  BCF    FF2.7
1B4B0:  MOVLB  0
1B4B2:  CALL   0DCC
1B4B6:  BTFSC  1B.7
1B4B8:  BSF    FF2.7
....................       arg = 0; 
1B4BA:  CLRF   47
1B4BC:  CLRF   46
1B4BE:  CLRF   45
1B4C0:  CLRF   44
....................       commandM(TRUE); 
1B4C2:  MOVLW  01
1B4C4:  MOVLB  8
1B4C6:  MOVWF  x6F
1B4C8:  MOVLB  0
1B4CA:  CALL   169AE
....................    } 
1B4CE:  BRA    1BB52
1B4D0:  MOVLB  7
....................    else 
....................    { 
....................       int8 RTC_buffer = 0; 
....................       unsigned int8 a0 = 0; 
....................       unsigned int8 a1 = 0; 
....................       unsigned int8 a2 = 0; 
....................       unsigned int8 a3 = 0; 
....................       unsigned int8 a4 = 0; 
....................       unsigned int8 a5 = 0; 
....................       unsigned int8 a6 = 0; 
....................       unsigned int8 a7 = 0; 
....................       unsigned int8 a8 = 0; 
....................       unsigned int8 a9 = 0; 
....................       unsigned int8 a10 = 0; 
....................       unsigned int8 a11 = 0; 
1B4D2:  MOVLB  8
1B4D4:  CLRF   x60
1B4D6:  CLRF   x61
1B4D8:  CLRF   x62
1B4DA:  CLRF   x63
1B4DC:  CLRF   x64
1B4DE:  CLRF   x65
1B4E0:  CLRF   x66
1B4E2:  CLRF   x67
1B4E4:  CLRF   x68
1B4E6:  CLRF   x69
1B4E8:  CLRF   x6A
1B4EA:  CLRF   x6B
1B4EC:  CLRF   x6C
....................        
....................       RTC_reset_HT(); 
1B4EE:  MOVLB  0
1B4F0:  CALL   3514
....................       output_bit(RTC_CS, ENABLE); 
1B4F4:  BCF    F91.0
....................       spi_write(0x89); 
1B4F6:  MOVF   FC9,W
1B4F8:  MOVLW  89
1B4FA:  MOVWF  FC9
1B4FC:  RRCF   FC7,W
1B4FE:  BNC   1B4FC
....................       spi_write(0b11111111); 
1B500:  MOVF   FC9,W
1B502:  SETF   FC9
1B504:  RRCF   FC7,W
1B506:  BNC   1B504
....................       output_bit(RTC_CS, DISABLE); 
1B508:  BSF    F91.0
....................        
....................       output_bit(RTC_CS, ENABLE); 
1B50A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x00); 
1B50C:  MOVF   FC9,W
1B50E:  CLRF   FC9
1B510:  RRCF   FC7,W
1B512:  BNC   1B510
1B514:  MOVFF  FC9,860
....................       a0 = RTC_buffer; 
1B518:  MOVFF  860,861
....................       fprintf(COM_A,"crap: %u\r\n",RTC_buffer); 
1B51C:  MOVLW  5A
1B51E:  MOVWF  FF6
1B520:  MOVLW  28
1B522:  MOVWF  FF7
1B524:  MOVLW  00
1B526:  MOVWF  FF8
1B528:  CLRF   1B
1B52A:  BTFSC  FF2.7
1B52C:  BSF    1B.7
1B52E:  BCF    FF2.7
1B530:  MOVLW  06
1B532:  MOVLB  A
1B534:  MOVWF  x25
1B536:  MOVLB  0
1B538:  CALL   101E
1B53C:  BTFSC  1B.7
1B53E:  BSF    FF2.7
1B540:  CLRF   1B
1B542:  BTFSC  FF2.7
1B544:  BSF    1B.7
1B546:  BCF    FF2.7
1B548:  MOVFF  860,A25
1B54C:  MOVLW  1B
1B54E:  MOVLB  A
1B550:  MOVWF  x26
1B552:  MOVLB  0
1B554:  CALL   0FA0
1B558:  BTFSC  1B.7
1B55A:  BSF    FF2.7
1B55C:  MOVLW  0D
1B55E:  BTFSS  F9E.4
1B560:  BRA    1B55E
1B562:  MOVWF  FAD
1B564:  MOVLW  0A
1B566:  BTFSS  F9E.4
1B568:  BRA    1B566
1B56A:  MOVWF  FAD
....................       a1 = spi_read(RTC_buffer); 
1B56C:  MOVF   FC9,W
1B56E:  MOVFF  860,FC9
1B572:  RRCF   FC7,W
1B574:  BNC   1B572
1B576:  MOVFF  FC9,862
....................       fprintf(COM_A,"reg0: %u\r\n",a1); 
1B57A:  MOVLW  66
1B57C:  MOVWF  FF6
1B57E:  MOVLW  28
1B580:  MOVWF  FF7
1B582:  MOVLW  00
1B584:  MOVWF  FF8
1B586:  CLRF   1B
1B588:  BTFSC  FF2.7
1B58A:  BSF    1B.7
1B58C:  BCF    FF2.7
1B58E:  MOVLW  06
1B590:  MOVLB  A
1B592:  MOVWF  x25
1B594:  MOVLB  0
1B596:  CALL   101E
1B59A:  BTFSC  1B.7
1B59C:  BSF    FF2.7
1B59E:  CLRF   1B
1B5A0:  BTFSC  FF2.7
1B5A2:  BSF    1B.7
1B5A4:  BCF    FF2.7
1B5A6:  MOVFF  862,A25
1B5AA:  MOVLW  1B
1B5AC:  MOVLB  A
1B5AE:  MOVWF  x26
1B5B0:  MOVLB  0
1B5B2:  CALL   0FA0
1B5B6:  BTFSC  1B.7
1B5B8:  BSF    FF2.7
1B5BA:  MOVLW  0D
1B5BC:  BTFSS  F9E.4
1B5BE:  BRA    1B5BC
1B5C0:  MOVWF  FAD
1B5C2:  MOVLW  0A
1B5C4:  BTFSS  F9E.4
1B5C6:  BRA    1B5C4
1B5C8:  MOVWF  FAD
....................       a2 = spi_read(RTC_buffer); 
1B5CA:  MOVF   FC9,W
1B5CC:  MOVFF  860,FC9
1B5D0:  RRCF   FC7,W
1B5D2:  BNC   1B5D0
1B5D4:  MOVFF  FC9,863
....................       fprintf(COM_A,"reg1: %u\r\n",a2); 
1B5D8:  MOVLW  72
1B5DA:  MOVWF  FF6
1B5DC:  MOVLW  28
1B5DE:  MOVWF  FF7
1B5E0:  MOVLW  00
1B5E2:  MOVWF  FF8
1B5E4:  CLRF   1B
1B5E6:  BTFSC  FF2.7
1B5E8:  BSF    1B.7
1B5EA:  BCF    FF2.7
1B5EC:  MOVLW  06
1B5EE:  MOVLB  A
1B5F0:  MOVWF  x25
1B5F2:  MOVLB  0
1B5F4:  CALL   101E
1B5F8:  BTFSC  1B.7
1B5FA:  BSF    FF2.7
1B5FC:  CLRF   1B
1B5FE:  BTFSC  FF2.7
1B600:  BSF    1B.7
1B602:  BCF    FF2.7
1B604:  MOVFF  863,A25
1B608:  MOVLW  1B
1B60A:  MOVLB  A
1B60C:  MOVWF  x26
1B60E:  MOVLB  0
1B610:  CALL   0FA0
1B614:  BTFSC  1B.7
1B616:  BSF    FF2.7
1B618:  MOVLW  0D
1B61A:  BTFSS  F9E.4
1B61C:  BRA    1B61A
1B61E:  MOVWF  FAD
1B620:  MOVLW  0A
1B622:  BTFSS  F9E.4
1B624:  BRA    1B622
1B626:  MOVWF  FAD
....................       a3 = spi_read(RTC_buffer); 
1B628:  MOVF   FC9,W
1B62A:  MOVFF  860,FC9
1B62E:  RRCF   FC7,W
1B630:  BNC   1B62E
1B632:  MOVFF  FC9,864
....................       fprintf(COM_A,"reg2: %u\r\n",a3); 
1B636:  MOVLW  7E
1B638:  MOVWF  FF6
1B63A:  MOVLW  28
1B63C:  MOVWF  FF7
1B63E:  MOVLW  00
1B640:  MOVWF  FF8
1B642:  CLRF   1B
1B644:  BTFSC  FF2.7
1B646:  BSF    1B.7
1B648:  BCF    FF2.7
1B64A:  MOVLW  06
1B64C:  MOVLB  A
1B64E:  MOVWF  x25
1B650:  MOVLB  0
1B652:  CALL   101E
1B656:  BTFSC  1B.7
1B658:  BSF    FF2.7
1B65A:  CLRF   1B
1B65C:  BTFSC  FF2.7
1B65E:  BSF    1B.7
1B660:  BCF    FF2.7
1B662:  MOVFF  864,A25
1B666:  MOVLW  1B
1B668:  MOVLB  A
1B66A:  MOVWF  x26
1B66C:  MOVLB  0
1B66E:  CALL   0FA0
1B672:  BTFSC  1B.7
1B674:  BSF    FF2.7
1B676:  MOVLW  0D
1B678:  BTFSS  F9E.4
1B67A:  BRA    1B678
1B67C:  MOVWF  FAD
1B67E:  MOVLW  0A
1B680:  BTFSS  F9E.4
1B682:  BRA    1B680
1B684:  MOVWF  FAD
....................       a4 = spi_read(RTC_buffer); 
1B686:  MOVF   FC9,W
1B688:  MOVFF  860,FC9
1B68C:  RRCF   FC7,W
1B68E:  BNC   1B68C
1B690:  MOVFF  FC9,865
....................       fprintf(COM_A,"reg3: %u\r\n",a4); 
1B694:  MOVLW  8A
1B696:  MOVWF  FF6
1B698:  MOVLW  28
1B69A:  MOVWF  FF7
1B69C:  MOVLW  00
1B69E:  MOVWF  FF8
1B6A0:  CLRF   1B
1B6A2:  BTFSC  FF2.7
1B6A4:  BSF    1B.7
1B6A6:  BCF    FF2.7
1B6A8:  MOVLW  06
1B6AA:  MOVLB  A
1B6AC:  MOVWF  x25
1B6AE:  MOVLB  0
1B6B0:  CALL   101E
1B6B4:  BTFSC  1B.7
1B6B6:  BSF    FF2.7
1B6B8:  CLRF   1B
1B6BA:  BTFSC  FF2.7
1B6BC:  BSF    1B.7
1B6BE:  BCF    FF2.7
1B6C0:  MOVFF  865,A25
1B6C4:  MOVLW  1B
1B6C6:  MOVLB  A
1B6C8:  MOVWF  x26
1B6CA:  MOVLB  0
1B6CC:  CALL   0FA0
1B6D0:  BTFSC  1B.7
1B6D2:  BSF    FF2.7
1B6D4:  MOVLW  0D
1B6D6:  BTFSS  F9E.4
1B6D8:  BRA    1B6D6
1B6DA:  MOVWF  FAD
1B6DC:  MOVLW  0A
1B6DE:  BTFSS  F9E.4
1B6E0:  BRA    1B6DE
1B6E2:  MOVWF  FAD
....................       a5 = spi_read(RTC_buffer); 
1B6E4:  MOVF   FC9,W
1B6E6:  MOVFF  860,FC9
1B6EA:  RRCF   FC7,W
1B6EC:  BNC   1B6EA
1B6EE:  MOVFF  FC9,866
....................       fprintf(COM_A,"reg4: %u\r\n",a5); 
1B6F2:  MOVLW  96
1B6F4:  MOVWF  FF6
1B6F6:  MOVLW  28
1B6F8:  MOVWF  FF7
1B6FA:  MOVLW  00
1B6FC:  MOVWF  FF8
1B6FE:  CLRF   1B
1B700:  BTFSC  FF2.7
1B702:  BSF    1B.7
1B704:  BCF    FF2.7
1B706:  MOVLW  06
1B708:  MOVLB  A
1B70A:  MOVWF  x25
1B70C:  MOVLB  0
1B70E:  CALL   101E
1B712:  BTFSC  1B.7
1B714:  BSF    FF2.7
1B716:  CLRF   1B
1B718:  BTFSC  FF2.7
1B71A:  BSF    1B.7
1B71C:  BCF    FF2.7
1B71E:  MOVFF  866,A25
1B722:  MOVLW  1B
1B724:  MOVLB  A
1B726:  MOVWF  x26
1B728:  MOVLB  0
1B72A:  CALL   0FA0
1B72E:  BTFSC  1B.7
1B730:  BSF    FF2.7
1B732:  MOVLW  0D
1B734:  BTFSS  F9E.4
1B736:  BRA    1B734
1B738:  MOVWF  FAD
1B73A:  MOVLW  0A
1B73C:  BTFSS  F9E.4
1B73E:  BRA    1B73C
1B740:  MOVWF  FAD
....................       a6 = spi_read(RTC_buffer); 
1B742:  MOVF   FC9,W
1B744:  MOVFF  860,FC9
1B748:  RRCF   FC7,W
1B74A:  BNC   1B748
1B74C:  MOVFF  FC9,867
....................       fprintf(COM_A,"reg5: %u\r\n",a6); 
1B750:  MOVLW  A2
1B752:  MOVWF  FF6
1B754:  MOVLW  28
1B756:  MOVWF  FF7
1B758:  MOVLW  00
1B75A:  MOVWF  FF8
1B75C:  CLRF   1B
1B75E:  BTFSC  FF2.7
1B760:  BSF    1B.7
1B762:  BCF    FF2.7
1B764:  MOVLW  06
1B766:  MOVLB  A
1B768:  MOVWF  x25
1B76A:  MOVLB  0
1B76C:  CALL   101E
1B770:  BTFSC  1B.7
1B772:  BSF    FF2.7
1B774:  CLRF   1B
1B776:  BTFSC  FF2.7
1B778:  BSF    1B.7
1B77A:  BCF    FF2.7
1B77C:  MOVFF  867,A25
1B780:  MOVLW  1B
1B782:  MOVLB  A
1B784:  MOVWF  x26
1B786:  MOVLB  0
1B788:  CALL   0FA0
1B78C:  BTFSC  1B.7
1B78E:  BSF    FF2.7
1B790:  MOVLW  0D
1B792:  BTFSS  F9E.4
1B794:  BRA    1B792
1B796:  MOVWF  FAD
1B798:  MOVLW  0A
1B79A:  BTFSS  F9E.4
1B79C:  BRA    1B79A
1B79E:  MOVWF  FAD
....................       a7 = spi_read(RTC_buffer); 
1B7A0:  MOVF   FC9,W
1B7A2:  MOVFF  860,FC9
1B7A6:  RRCF   FC7,W
1B7A8:  BNC   1B7A6
1B7AA:  MOVFF  FC9,868
....................       fprintf(COM_A,"reg6: %u\r\n",a7); 
1B7AE:  MOVLW  AE
1B7B0:  MOVWF  FF6
1B7B2:  MOVLW  28
1B7B4:  MOVWF  FF7
1B7B6:  MOVLW  00
1B7B8:  MOVWF  FF8
1B7BA:  CLRF   1B
1B7BC:  BTFSC  FF2.7
1B7BE:  BSF    1B.7
1B7C0:  BCF    FF2.7
1B7C2:  MOVLW  06
1B7C4:  MOVLB  A
1B7C6:  MOVWF  x25
1B7C8:  MOVLB  0
1B7CA:  CALL   101E
1B7CE:  BTFSC  1B.7
1B7D0:  BSF    FF2.7
1B7D2:  CLRF   1B
1B7D4:  BTFSC  FF2.7
1B7D6:  BSF    1B.7
1B7D8:  BCF    FF2.7
1B7DA:  MOVFF  868,A25
1B7DE:  MOVLW  1B
1B7E0:  MOVLB  A
1B7E2:  MOVWF  x26
1B7E4:  MOVLB  0
1B7E6:  CALL   0FA0
1B7EA:  BTFSC  1B.7
1B7EC:  BSF    FF2.7
1B7EE:  MOVLW  0D
1B7F0:  BTFSS  F9E.4
1B7F2:  BRA    1B7F0
1B7F4:  MOVWF  FAD
1B7F6:  MOVLW  0A
1B7F8:  BTFSS  F9E.4
1B7FA:  BRA    1B7F8
1B7FC:  MOVWF  FAD
....................       a8 = spi_read(RTC_buffer); 
1B7FE:  MOVF   FC9,W
1B800:  MOVFF  860,FC9
1B804:  RRCF   FC7,W
1B806:  BNC   1B804
1B808:  MOVFF  FC9,869
....................       fprintf(COM_A,"reg7: %u\r\n",a8); 
1B80C:  MOVLW  BA
1B80E:  MOVWF  FF6
1B810:  MOVLW  28
1B812:  MOVWF  FF7
1B814:  MOVLW  00
1B816:  MOVWF  FF8
1B818:  CLRF   1B
1B81A:  BTFSC  FF2.7
1B81C:  BSF    1B.7
1B81E:  BCF    FF2.7
1B820:  MOVLW  06
1B822:  MOVLB  A
1B824:  MOVWF  x25
1B826:  MOVLB  0
1B828:  CALL   101E
1B82C:  BTFSC  1B.7
1B82E:  BSF    FF2.7
1B830:  CLRF   1B
1B832:  BTFSC  FF2.7
1B834:  BSF    1B.7
1B836:  BCF    FF2.7
1B838:  MOVFF  869,A25
1B83C:  MOVLW  1B
1B83E:  MOVLB  A
1B840:  MOVWF  x26
1B842:  MOVLB  0
1B844:  CALL   0FA0
1B848:  BTFSC  1B.7
1B84A:  BSF    FF2.7
1B84C:  MOVLW  0D
1B84E:  BTFSS  F9E.4
1B850:  BRA    1B84E
1B852:  MOVWF  FAD
1B854:  MOVLW  0A
1B856:  BTFSS  F9E.4
1B858:  BRA    1B856
1B85A:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1B85C:  MOVF   FC9,W
1B85E:  MOVFF  860,FC9
1B862:  RRCF   FC7,W
1B864:  BNC   1B862
1B866:  MOVFF  FC9,86A
....................       fprintf(COM_A,"reg8: %u\r\n",a9); 
1B86A:  MOVLW  C6
1B86C:  MOVWF  FF6
1B86E:  MOVLW  28
1B870:  MOVWF  FF7
1B872:  MOVLW  00
1B874:  MOVWF  FF8
1B876:  CLRF   1B
1B878:  BTFSC  FF2.7
1B87A:  BSF    1B.7
1B87C:  BCF    FF2.7
1B87E:  MOVLW  06
1B880:  MOVLB  A
1B882:  MOVWF  x25
1B884:  MOVLB  0
1B886:  CALL   101E
1B88A:  BTFSC  1B.7
1B88C:  BSF    FF2.7
1B88E:  CLRF   1B
1B890:  BTFSC  FF2.7
1B892:  BSF    1B.7
1B894:  BCF    FF2.7
1B896:  MOVFF  86A,A25
1B89A:  MOVLW  1B
1B89C:  MOVLB  A
1B89E:  MOVWF  x26
1B8A0:  MOVLB  0
1B8A2:  CALL   0FA0
1B8A6:  BTFSC  1B.7
1B8A8:  BSF    FF2.7
1B8AA:  MOVLW  0D
1B8AC:  BTFSS  F9E.4
1B8AE:  BRA    1B8AC
1B8B0:  MOVWF  FAD
1B8B2:  MOVLW  0A
1B8B4:  BTFSS  F9E.4
1B8B6:  BRA    1B8B4
1B8B8:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1B8BA:  MOVF   FC9,W
1B8BC:  MOVFF  860,FC9
1B8C0:  RRCF   FC7,W
1B8C2:  BNC   1B8C0
1B8C4:  MOVFF  FC9,86A
....................       fprintf(COM_A,"reg9: %u\r\n",a9); 
1B8C8:  MOVLW  D2
1B8CA:  MOVWF  FF6
1B8CC:  MOVLW  28
1B8CE:  MOVWF  FF7
1B8D0:  MOVLW  00
1B8D2:  MOVWF  FF8
1B8D4:  CLRF   1B
1B8D6:  BTFSC  FF2.7
1B8D8:  BSF    1B.7
1B8DA:  BCF    FF2.7
1B8DC:  MOVLW  06
1B8DE:  MOVLB  A
1B8E0:  MOVWF  x25
1B8E2:  MOVLB  0
1B8E4:  CALL   101E
1B8E8:  BTFSC  1B.7
1B8EA:  BSF    FF2.7
1B8EC:  CLRF   1B
1B8EE:  BTFSC  FF2.7
1B8F0:  BSF    1B.7
1B8F2:  BCF    FF2.7
1B8F4:  MOVFF  86A,A25
1B8F8:  MOVLW  1B
1B8FA:  MOVLB  A
1B8FC:  MOVWF  x26
1B8FE:  MOVLB  0
1B900:  CALL   0FA0
1B904:  BTFSC  1B.7
1B906:  BSF    FF2.7
1B908:  MOVLW  0D
1B90A:  BTFSS  F9E.4
1B90C:  BRA    1B90A
1B90E:  MOVWF  FAD
1B910:  MOVLW  0A
1B912:  BTFSS  F9E.4
1B914:  BRA    1B912
1B916:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1B918:  MOVF   FC9,W
1B91A:  MOVFF  860,FC9
1B91E:  RRCF   FC7,W
1B920:  BNC   1B91E
1B922:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regA: %u\r\n",a9); 
1B926:  MOVLW  DE
1B928:  MOVWF  FF6
1B92A:  MOVLW  28
1B92C:  MOVWF  FF7
1B92E:  MOVLW  00
1B930:  MOVWF  FF8
1B932:  CLRF   1B
1B934:  BTFSC  FF2.7
1B936:  BSF    1B.7
1B938:  BCF    FF2.7
1B93A:  MOVLW  06
1B93C:  MOVLB  A
1B93E:  MOVWF  x25
1B940:  MOVLB  0
1B942:  CALL   101E
1B946:  BTFSC  1B.7
1B948:  BSF    FF2.7
1B94A:  CLRF   1B
1B94C:  BTFSC  FF2.7
1B94E:  BSF    1B.7
1B950:  BCF    FF2.7
1B952:  MOVFF  86A,A25
1B956:  MOVLW  1B
1B958:  MOVLB  A
1B95A:  MOVWF  x26
1B95C:  MOVLB  0
1B95E:  CALL   0FA0
1B962:  BTFSC  1B.7
1B964:  BSF    FF2.7
1B966:  MOVLW  0D
1B968:  BTFSS  F9E.4
1B96A:  BRA    1B968
1B96C:  MOVWF  FAD
1B96E:  MOVLW  0A
1B970:  BTFSS  F9E.4
1B972:  BRA    1B970
1B974:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1B976:  MOVF   FC9,W
1B978:  MOVFF  860,FC9
1B97C:  RRCF   FC7,W
1B97E:  BNC   1B97C
1B980:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regB: %u\r\n",a9); 
1B984:  MOVLW  EA
1B986:  MOVWF  FF6
1B988:  MOVLW  28
1B98A:  MOVWF  FF7
1B98C:  MOVLW  00
1B98E:  MOVWF  FF8
1B990:  CLRF   1B
1B992:  BTFSC  FF2.7
1B994:  BSF    1B.7
1B996:  BCF    FF2.7
1B998:  MOVLW  06
1B99A:  MOVLB  A
1B99C:  MOVWF  x25
1B99E:  MOVLB  0
1B9A0:  CALL   101E
1B9A4:  BTFSC  1B.7
1B9A6:  BSF    FF2.7
1B9A8:  CLRF   1B
1B9AA:  BTFSC  FF2.7
1B9AC:  BSF    1B.7
1B9AE:  BCF    FF2.7
1B9B0:  MOVFF  86A,A25
1B9B4:  MOVLW  1B
1B9B6:  MOVLB  A
1B9B8:  MOVWF  x26
1B9BA:  MOVLB  0
1B9BC:  CALL   0FA0
1B9C0:  BTFSC  1B.7
1B9C2:  BSF    FF2.7
1B9C4:  MOVLW  0D
1B9C6:  BTFSS  F9E.4
1B9C8:  BRA    1B9C6
1B9CA:  MOVWF  FAD
1B9CC:  MOVLW  0A
1B9CE:  BTFSS  F9E.4
1B9D0:  BRA    1B9CE
1B9D2:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1B9D4:  MOVF   FC9,W
1B9D6:  MOVFF  860,FC9
1B9DA:  RRCF   FC7,W
1B9DC:  BNC   1B9DA
1B9DE:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regC: %u\r\n",a9); 
1B9E2:  MOVLW  F6
1B9E4:  MOVWF  FF6
1B9E6:  MOVLW  28
1B9E8:  MOVWF  FF7
1B9EA:  MOVLW  00
1B9EC:  MOVWF  FF8
1B9EE:  CLRF   1B
1B9F0:  BTFSC  FF2.7
1B9F2:  BSF    1B.7
1B9F4:  BCF    FF2.7
1B9F6:  MOVLW  06
1B9F8:  MOVLB  A
1B9FA:  MOVWF  x25
1B9FC:  MOVLB  0
1B9FE:  CALL   101E
1BA02:  BTFSC  1B.7
1BA04:  BSF    FF2.7
1BA06:  CLRF   1B
1BA08:  BTFSC  FF2.7
1BA0A:  BSF    1B.7
1BA0C:  BCF    FF2.7
1BA0E:  MOVFF  86A,A25
1BA12:  MOVLW  1B
1BA14:  MOVLB  A
1BA16:  MOVWF  x26
1BA18:  MOVLB  0
1BA1A:  CALL   0FA0
1BA1E:  BTFSC  1B.7
1BA20:  BSF    FF2.7
1BA22:  MOVLW  0D
1BA24:  BTFSS  F9E.4
1BA26:  BRA    1BA24
1BA28:  MOVWF  FAD
1BA2A:  MOVLW  0A
1BA2C:  BTFSS  F9E.4
1BA2E:  BRA    1BA2C
1BA30:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1BA32:  MOVF   FC9,W
1BA34:  MOVFF  860,FC9
1BA38:  RRCF   FC7,W
1BA3A:  BNC   1BA38
1BA3C:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regD: %u\r\n",a9); 
1BA40:  MOVLW  02
1BA42:  MOVWF  FF6
1BA44:  MOVLW  29
1BA46:  MOVWF  FF7
1BA48:  MOVLW  00
1BA4A:  MOVWF  FF8
1BA4C:  CLRF   1B
1BA4E:  BTFSC  FF2.7
1BA50:  BSF    1B.7
1BA52:  BCF    FF2.7
1BA54:  MOVLW  06
1BA56:  MOVLB  A
1BA58:  MOVWF  x25
1BA5A:  MOVLB  0
1BA5C:  CALL   101E
1BA60:  BTFSC  1B.7
1BA62:  BSF    FF2.7
1BA64:  CLRF   1B
1BA66:  BTFSC  FF2.7
1BA68:  BSF    1B.7
1BA6A:  BCF    FF2.7
1BA6C:  MOVFF  86A,A25
1BA70:  MOVLW  1B
1BA72:  MOVLB  A
1BA74:  MOVWF  x26
1BA76:  MOVLB  0
1BA78:  CALL   0FA0
1BA7C:  BTFSC  1B.7
1BA7E:  BSF    FF2.7
1BA80:  MOVLW  0D
1BA82:  BTFSS  F9E.4
1BA84:  BRA    1BA82
1BA86:  MOVWF  FAD
1BA88:  MOVLW  0A
1BA8A:  BTFSS  F9E.4
1BA8C:  BRA    1BA8A
1BA8E:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1BA90:  MOVF   FC9,W
1BA92:  MOVFF  860,FC9
1BA96:  RRCF   FC7,W
1BA98:  BNC   1BA96
1BA9A:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regE: %u\r\n",a9); 
1BA9E:  MOVLW  0E
1BAA0:  MOVWF  FF6
1BAA2:  MOVLW  29
1BAA4:  MOVWF  FF7
1BAA6:  MOVLW  00
1BAA8:  MOVWF  FF8
1BAAA:  CLRF   1B
1BAAC:  BTFSC  FF2.7
1BAAE:  BSF    1B.7
1BAB0:  BCF    FF2.7
1BAB2:  MOVLW  06
1BAB4:  MOVLB  A
1BAB6:  MOVWF  x25
1BAB8:  MOVLB  0
1BABA:  CALL   101E
1BABE:  BTFSC  1B.7
1BAC0:  BSF    FF2.7
1BAC2:  CLRF   1B
1BAC4:  BTFSC  FF2.7
1BAC6:  BSF    1B.7
1BAC8:  BCF    FF2.7
1BACA:  MOVFF  86A,A25
1BACE:  MOVLW  1B
1BAD0:  MOVLB  A
1BAD2:  MOVWF  x26
1BAD4:  MOVLB  0
1BAD6:  CALL   0FA0
1BADA:  BTFSC  1B.7
1BADC:  BSF    FF2.7
1BADE:  MOVLW  0D
1BAE0:  BTFSS  F9E.4
1BAE2:  BRA    1BAE0
1BAE4:  MOVWF  FAD
1BAE6:  MOVLW  0A
1BAE8:  BTFSS  F9E.4
1BAEA:  BRA    1BAE8
1BAEC:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1BAEE:  MOVF   FC9,W
1BAF0:  MOVFF  860,FC9
1BAF4:  RRCF   FC7,W
1BAF6:  BNC   1BAF4
1BAF8:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regF: %u\r\n",a9); 
1BAFC:  MOVLW  1A
1BAFE:  MOVWF  FF6
1BB00:  MOVLW  29
1BB02:  MOVWF  FF7
1BB04:  MOVLW  00
1BB06:  MOVWF  FF8
1BB08:  CLRF   1B
1BB0A:  BTFSC  FF2.7
1BB0C:  BSF    1B.7
1BB0E:  BCF    FF2.7
1BB10:  MOVLW  06
1BB12:  MOVLB  A
1BB14:  MOVWF  x25
1BB16:  MOVLB  0
1BB18:  CALL   101E
1BB1C:  BTFSC  1B.7
1BB1E:  BSF    FF2.7
1BB20:  CLRF   1B
1BB22:  BTFSC  FF2.7
1BB24:  BSF    1B.7
1BB26:  BCF    FF2.7
1BB28:  MOVFF  86A,A25
1BB2C:  MOVLW  1B
1BB2E:  MOVLB  A
1BB30:  MOVWF  x26
1BB32:  MOVLB  0
1BB34:  CALL   0FA0
1BB38:  BTFSC  1B.7
1BB3A:  BSF    FF2.7
1BB3C:  MOVLW  0D
1BB3E:  BTFSS  F9E.4
1BB40:  BRA    1BB3E
1BB42:  MOVWF  FAD
1BB44:  MOVLW  0A
1BB46:  BTFSS  F9E.4
1BB48:  BRA    1BB46
1BB4A:  MOVWF  FAD
....................        
....................       output_bit(RTC_CS, DISABLE); 
1BB4C:  BSF    F91.0
....................     
....................       command_prompt(); 
1BB4E:  CALL   1AFA2
....................    } 
....................  
....................    reset_cpu(); 
1BB52:  RESET
.................... } 
....................  
1BB54:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 7F78   PUT NOBROWNOUT BORV18 ZPBORM WDT WDT1048576
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
