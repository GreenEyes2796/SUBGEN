CCS PCH C Compiler, Version 5.071d, 1               07-Jul-17 13:15
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   115064 bytes (88%)
                           Largest free fragment is 15642
               RAM used:   2148 (56%) at main() level
                           2649 (69%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1B62E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0F08
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0F32
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   1928
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E34
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   170A
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   1780
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E98
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 0D,0A
00668:  DATA 3F,40
0066A:  DATA 42,53
0066C:  DATA 59,0D
0066E:  DATA 0A,00
00670:  DATA 0D,0A
00672:  DATA 40,52
00674:  DATA 44,59
00676:  DATA 0D,0A
00678:  DATA 00,00
0067A:  DATA 40,46
0067C:  DATA 53,3A
0067E:  DATA 44,69
00680:  DATA 73,63
00682:  DATA 6F,76
00684:  DATA 65,72
00686:  DATA 79,0D
00688:  DATA 0A,00
0068A:  DATA 40,46
0068C:  DATA 53,3A
0068E:  DATA 55,6E
00690:  DATA 61,62
00692:  DATA 6C,65
00694:  DATA 20,74
00696:  DATA 6F,20
00698:  DATA 70,75
0069A:  DATA 74,20
0069C:  DATA 63,61
0069E:  DATA 72,64
006A0:  DATA 20,69
006A2:  DATA 6E,20
006A4:  DATA 69,64
006A6:  DATA 6C,65
006A8:  DATA 20,73
006AA:  DATA 74,61
006AC:  DATA 74,65
006AE:  DATA 2C,20
006B0:  DATA 72,65
006B2:  DATA 73,70
006B4:  DATA 6F,6E
006B6:  DATA 73,65
006B8:  DATA 20,3D
006BA:  DATA 20,25
006BC:  DATA 30,32
006BE:  DATA 78,0D
006C0:  DATA 0A,00
006C2:  DATA 40,46
006C4:  DATA 53,3A
006C6:  DATA 43,61
006C8:  DATA 72,64
006CA:  DATA 20,69
006CC:  DATA 64,6C
006CE:  DATA 65,2C
006D0:  DATA 20,72
006D2:  DATA 65,73
006D4:  DATA 70,6F
006D6:  DATA 6E,73
006D8:  DATA 65,20
006DA:  DATA 3D,20
006DC:  DATA 25,30
006DE:  DATA 32,78
006E0:  DATA 0D,0A
006E2:  DATA 00,00
006E4:  DATA 40,46
006E6:  DATA 53,3A
006E8:  DATA 52,65
006EA:  DATA 73,70
006EC:  DATA 6F,6E
006EE:  DATA 73,65
006F0:  DATA 20,74
006F2:  DATA 6F,20
006F4:  DATA 53,44
006F6:  DATA 20,76
006F8:  DATA 65,72
006FA:  DATA 20,32
006FC:  DATA 20,74
006FE:  DATA 65,73
00700:  DATA 74,20
00702:  DATA 43,4D
00704:  DATA 44,38
00706:  DATA 20,3D
00708:  DATA 20,25
0070A:  DATA 78,0D
0070C:  DATA 0A,00
0070E:  DATA 40,46
00710:  DATA 53,3A
00712:  DATA 50,6F
00714:  DATA 73,73
00716:  DATA 69,62
00718:  DATA 6C,65
0071A:  DATA 20,53
0071C:  DATA 44,76
0071E:  DATA 32,20
00720:  DATA 63,61
00722:  DATA 72,64
00724:  DATA 20,64
00726:  DATA 65,74
00728:  DATA 65,63
0072A:  DATA 74,65
0072C:  DATA 64,0D
0072E:  DATA 0A,00
00730:  DATA 40,46
00732:  DATA 53,3A
00734:  DATA 56,6F
00736:  DATA 6C,74
00738:  DATA 61,67
0073A:  DATA 65,20
0073C:  DATA 72,61
0073E:  DATA 6E,67
00740:  DATA 65,20
00742:  DATA 63,68
00744:  DATA 65,63
00746:  DATA 6B,2C
00748:  DATA 20,6F
0074A:  DATA 63,72
0074C:  DATA 20,3D
0074E:  DATA 20,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,25
0075C:  DATA 30,32
0075E:  DATA 78,0D
00760:  DATA 0A,00
00762:  DATA 40,46
00764:  DATA 53,3A
00766:  DATA 43,61
00768:  DATA 72,64
0076A:  DATA 20,56
0076C:  DATA 64,64
0076E:  DATA 20,72
00770:  DATA 61,6E
00772:  DATA 67,65
00774:  DATA 20,3D
00776:  DATA 20,32
00778:  DATA 2E,37
0077A:  DATA 2D,33
0077C:  DATA 2E,36
0077E:  DATA 20,76
00780:  DATA 6F,6C
00782:  DATA 74,73
00784:  DATA 0D,0A
00786:  DATA 00,00
00788:  DATA 40,46
0078A:  DATA 53,3A
0078C:  DATA 53,65
0078E:  DATA 6E,64
00790:  DATA 69,6E
00792:  DATA 67,20
00794:  DATA 41,43
00796:  DATA 4D,44
00798:  DATA 34,31
0079A:  DATA 20,63
0079C:  DATA 6F,6D
0079E:  DATA 6D,61
007A0:  DATA 6E,64
007A2:  DATA 20,74
007A4:  DATA 6F,20
007A6:  DATA 53,44
007A8:  DATA 20,76
007AA:  DATA 65,72
007AC:  DATA 20,32
007AE:  DATA 20,63
007B0:  DATA 61,72
007B2:  DATA 64,0D
007B4:  DATA 0A,00
007B6:  DATA 40,46
007B8:  DATA 53,3A
007BA:  DATA 52,65
007BC:  DATA 73,70
007BE:  DATA 6F,6E
007C0:  DATA 73,65
007C2:  DATA 20,66
007C4:  DATA 72,6F
007C6:  DATA 6D,20
007C8:  DATA 73,65
007CA:  DATA 6E,64
007CC:  DATA 69,6E
007CE:  DATA 67,20
007D0:  DATA 41,43
007D2:  DATA 4D,44
007D4:  DATA 34,31
007D6:  DATA 20,3D
007D8:  DATA 20,25
007DA:  DATA 30,32
007DC:  DATA 78,2C
007DE:  DATA 20,54
007E0:  DATA 69,6D
007E2:  DATA 65,72
007E4:  DATA 20,3D
007E6:  DATA 20,25
007E8:  DATA 6C,75
007EA:  DATA 0D,0A
007EC:  DATA 00,00
007EE:  DATA 40,46
007F0:  DATA 53,3A
007F2:  DATA 52,65
007F4:  DATA 73,70
007F6:  DATA 6F,6E
007F8:  DATA 73,65
007FA:  DATA 20,74
007FC:  DATA 6F,20
007FE:  DATA 43,4D
00800:  DATA 44,35
00802:  DATA 38,20
00804:  DATA 3D,20
00806:  DATA 25,78
00808:  DATA 0D,0A
0080A:  DATA 00,00
0080C:  DATA 40,46
0080E:  DATA 53,3A
00810:  DATA 53,65
00812:  DATA 6E,74
00814:  DATA 20,43
00816:  DATA 4D,44
00818:  DATA 20,35
0081A:  DATA 38,2C
0081C:  DATA 20,54
0081E:  DATA 69,6D
00820:  DATA 65,72
00822:  DATA 20,76
00824:  DATA 61,6C
00826:  DATA 75,65
00828:  DATA 20,3D
0082A:  DATA 20,25
0082C:  DATA 6C,75
0082E:  DATA 2C,20
00830:  DATA 6F,63
00832:  DATA 72,20
00834:  DATA 3D,20
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 25,30
00844:  DATA 32,78
00846:  DATA 0D,0A
00848:  DATA 00,00
0084A:  DATA 40,46
0084C:  DATA 53,3A
0084E:  DATA 43,61
00850:  DATA 72,64
00852:  DATA 20,43
00854:  DATA 41,4E
00856:  DATA 4E,4F
00858:  DATA 54,20
0085A:  DATA 77,6F
0085C:  DATA 72,6B
0085E:  DATA 20,56
00860:  DATA 64,64
00862:  DATA 20,72
00864:  DATA 61,6E
00866:  DATA 67,65
00868:  DATA 20,6F
0086A:  DATA 66,20
0086C:  DATA 32,2E
0086E:  DATA 37,2D
00870:  DATA 33,2E
00872:  DATA 36,20
00874:  DATA 76,6F
00876:  DATA 6C,74
00878:  DATA 73,0D
0087A:  DATA 0A,00
0087C:  DATA 40,46
0087E:  DATA 53,3A
00880:  DATA 4E,6F
00882:  DATA 74,20
00884:  DATA 61,6E
00886:  DATA 20,53
00888:  DATA 44,53
0088A:  DATA 43,20
0088C:  DATA 6F,72
0088E:  DATA 20,53
00890:  DATA 44,48
00892:  DATA 43,20
00894:  DATA 63,61
00896:  DATA 72,64
00898:  DATA 2C,20
0089A:  DATA 54,65
0089C:  DATA 73,74
0089E:  DATA 69,6E
008A0:  DATA 67,20
008A2:  DATA 66,6F
008A4:  DATA 72,20
008A6:  DATA 53,44
008A8:  DATA 20,56
008AA:  DATA 65,72
008AC:  DATA 31,20
008AE:  DATA 6F,72
008B0:  DATA 20,4D
008B2:  DATA 4D,43
008B4:  DATA 20,43
008B6:  DATA 61,72
008B8:  DATA 64,0D
008BA:  DATA 0A,00
008BC:  DATA 40,46
008BE:  DATA 53,3A
008C0:  DATA 52,65
008C2:  DATA 73,70
008C4:  DATA 6F,6E
008C6:  DATA 73,65
008C8:  DATA 20,66
008CA:  DATA 72,6F
008CC:  DATA 6D,20
008CE:  DATA 47,4F
008D0:  DATA 5F,49
008D2:  DATA 44,4C
008D4:  DATA 45,20
008D6:  DATA 3D,20
008D8:  DATA 25,30
008DA:  DATA 32,78
008DC:  DATA 0D,0A
008DE:  DATA 00,00
008E0:  DATA 40,46
008E2:  DATA 53,3A
008E4:  DATA 52,65
008E6:  DATA 73,70
008E8:  DATA 6F,6E
008EA:  DATA 73,65
008EC:  DATA 20,66
008EE:  DATA 72,6F
008F0:  DATA 6D,20
008F2:  DATA 53,44
008F4:  DATA 5F,43
008F6:  DATA 4D,44
008F8:  DATA 5F,53
008FA:  DATA 45,4E
008FC:  DATA 44,5F
008FE:  DATA 4F,50
00900:  DATA 5F,43
00902:  DATA 4F,4E
00904:  DATA 44,20
00906:  DATA 3D,20
00908:  DATA 25,30
0090A:  DATA 32,78
0090C:  DATA 2C,20
0090E:  DATA 54,69
00910:  DATA 6D,65
00912:  DATA 72,20
00914:  DATA 3D,20
00916:  DATA 25,6C
00918:  DATA 75,0D
0091A:  DATA 0A,00
0091C:  DATA 40,46
0091E:  DATA 53,3A
00920:  DATA 41,74
00922:  DATA 74,65
00924:  DATA 6D,70
00926:  DATA 74,69
00928:  DATA 6E,67
0092A:  DATA 20,53
0092C:  DATA 44,76
0092E:  DATA 31,20
00930:  DATA 76,65
00932:  DATA 72,73
00934:  DATA 75,73
00936:  DATA 20,4D
00938:  DATA 4D,43
0093A:  DATA 20,49
0093C:  DATA 44,2C
0093E:  DATA 20,52
00940:  DATA 65,73
00942:  DATA 70,6F
00944:  DATA 6E,73
00946:  DATA 65,20
00948:  DATA 66,72
0094A:  DATA 6F,6D
0094C:  DATA 20,53
0094E:  DATA 44,5F
00950:  DATA 43,4D
00952:  DATA 44,5F
00954:  DATA 41,50
00956:  DATA 50,4C
00958:  DATA 5F,43
0095A:  DATA 4D,44
0095C:  DATA 20,3D
0095E:  DATA 20,25
00960:  DATA 30,32
00962:  DATA 78,0D
00964:  DATA 0A,00
00966:  DATA 40,46
00968:  DATA 53,3A
0096A:  DATA 49,6E
0096C:  DATA 76,61
0096E:  DATA 6C,69
00970:  DATA 64,20
00972:  DATA 72,65
00974:  DATA 73,70
00976:  DATA 6F,6E
00978:  DATA 73,65
0097A:  DATA 20,74
0097C:  DATA 6F,20
0097E:  DATA 53,44
00980:  DATA 5F,41
00982:  DATA 43,4D
00984:  DATA 44,34
00986:  DATA 31,2C
00988:  DATA 20,72
0098A:  DATA 65,73
0098C:  DATA 70,6F
0098E:  DATA 6E,73
00990:  DATA 65,20
00992:  DATA 3D,20
00994:  DATA 25,30
00996:  DATA 32,58
00998:  DATA 2C,20
0099A:  DATA 72,65
0099C:  DATA 69,6E
0099E:  DATA 69,74
009A0:  DATA 69,61
009A2:  DATA 6C,69
009A4:  DATA 7A,69
009A6:  DATA 6E,67
009A8:  DATA 20,61
009AA:  DATA 73,20
009AC:  DATA 4D,4D
009AE:  DATA 43,0D
009B0:  DATA 0A,00
009B2:  DATA 40,46
009B4:  DATA 53,3A
009B6:  DATA 46,61
009B8:  DATA 69,6C
009BA:  DATA 65,64
009BC:  DATA 20,74
009BE:  DATA 6F,20
009C0:  DATA 69,6E
009C2:  DATA 69,74
009C4:  DATA 69,61
009C6:  DATA 6C,69
009C8:  DATA 7A,65
009CA:  DATA 20,61
009CC:  DATA 73,20
009CE:  DATA 4D,4D
009D0:  DATA 43,2C
009D2:  DATA 20,72
009D4:  DATA 65,73
009D6:  DATA 70,6F
009D8:  DATA 6E,73
009DA:  DATA 65,20
009DC:  DATA 3D,20
009DE:  DATA 25,30
009E0:  DATA 32,58
009E2:  DATA 2C,20
009E4:  DATA 65,78
009E6:  DATA 69,74
009E8:  DATA 69,6E
009EA:  DATA 67,0D
009EC:  DATA 0A,00
009EE:  DATA 40,46
009F0:  DATA 53,3A
009F2:  DATA 43,61
009F4:  DATA 72,64
009F6:  DATA 20,66
009F8:  DATA 61,69
009FA:  DATA 6C,65
009FC:  DATA 64,20
009FE:  DATA 74,6F
00A00:  DATA 20,72
00A02:  DATA 65,73
00A04:  DATA 70,6F
00A06:  DATA 6E,64
00A08:  DATA 20,63
00A0A:  DATA 6F,72
00A0C:  DATA 72,65
00A0E:  DATA 63,6C
00A10:  DATA 79,20
00A12:  DATA 61,66
00A14:  DATA 74,65
00A16:  DATA 72,20
00A18:  DATA 53,44
00A1A:  DATA 5F,43
00A1C:  DATA 4D,44
00A1E:  DATA 5F,53
00A20:  DATA 45,4E
00A22:  DATA 44,5F
00A24:  DATA 4F,50
00A26:  DATA 5F,43
00A28:  DATA 4F,4E
00A2A:  DATA 44,2C
00A2C:  DATA 20,72
00A2E:  DATA 65,73
00A30:  DATA 70,6F
00A32:  DATA 6E,73
00A34:  DATA 65,20
00A36:  DATA 3D,20
00A38:  DATA 25,30
00A3A:  DATA 32,58
00A3C:  DATA 2C,20
00A3E:  DATA 54,69
00A40:  DATA 6D,65
00A42:  DATA 72,20
00A44:  DATA 3D,20
00A46:  DATA 25,6C
00A48:  DATA 75,0D
00A4A:  DATA 0A,00
00A4C:  DATA 40,46
00A4E:  DATA 53,3A
00A50:  DATA 53,65
00A52:  DATA 74,74
00A54:  DATA 69,6E
00A56:  DATA 67,20
00A58:  DATA 62,6C
00A5A:  DATA 6F,63
00A5C:  DATA 6B,20
00A5E:  DATA 6C,65
00A60:  DATA 6E,67
00A62:  DATA 74,68
00A64:  DATA 0D,0A
00A66:  DATA 00,00
00A68:  DATA 40,46
00A6A:  DATA 53,3A
00A6C:  DATA 45,72
00A6E:  DATA 72,6F
00A70:  DATA 72,20
00A72:  DATA 73,65
00A74:  DATA 74,74
00A76:  DATA 69,6E
00A78:  DATA 67,20
00A7A:  DATA 62,6C
00A7C:  DATA 6F,63
00A7E:  DATA 6B,20
00A80:  DATA 6C,65
00A82:  DATA 6E,67
00A84:  DATA 74,68
00A86:  DATA 2C,20
00A88:  DATA 72,65
00A8A:  DATA 73,70
00A8C:  DATA 6F,6E
00A8E:  DATA 73,65
00A90:  DATA 20,3D
00A92:  DATA 20,25
00A94:  DATA 30,32
00A96:  DATA 78,2C
00A98:  DATA 20,74
00A9A:  DATA 69,6D
00A9C:  DATA 65,72
00A9E:  DATA 20,3D
00AA0:  DATA 20,25
00AA2:  DATA 6C,75
00AA4:  DATA 0D,0A
00AA6:  DATA 00,00
00AA8:  DATA 40,46
00AAA:  DATA 53,3A
00AAC:  DATA 43,61
00AAE:  DATA 72,64
00AB0:  DATA 20,54
00AB2:  DATA 79,70
00AB4:  DATA 65,20
00AB6:  DATA 44,69
00AB8:  DATA 73,63
00ABA:  DATA 6F,76
00ABC:  DATA 65,72
00ABE:  DATA 79,20
00AC0:  DATA 45,72
00AC2:  DATA 72,6F
00AC4:  DATA 72,0D
00AC6:  DATA 0A,00
00AC8:  DATA 40,46
00ACA:  DATA 53,3A
00ACC:  DATA 4D,4D
00ACE:  DATA 43,20
00AD0:  DATA 43,61
00AD2:  DATA 72,64
00AD4:  DATA 20,66
00AD6:  DATA 6F,75
00AD8:  DATA 6E,64
00ADA:  DATA 0D,0A
00ADC:  DATA 00,00
00ADE:  DATA 40,46
00AE0:  DATA 53,3A
00AE2:  DATA 53,44
00AE4:  DATA 76,31
00AE6:  DATA 20,43
00AE8:  DATA 61,72
00AEA:  DATA 64,20
00AEC:  DATA 66,6F
00AEE:  DATA 75,6E
00AF0:  DATA 64,0D
00AF2:  DATA 0A,00
00AF4:  DATA 40,46
00AF6:  DATA 53,3A
00AF8:  DATA 53,44
00AFA:  DATA 53,43
00AFC:  DATA 20,43
00AFE:  DATA 61,72
00B00:  DATA 64,20
00B02:  DATA 66,6F
00B04:  DATA 75,6E
00B06:  DATA 64,0D
00B08:  DATA 0A,00
00B0A:  DATA 40,46
00B0C:  DATA 53,3A
00B0E:  DATA 53,44
00B10:  DATA 48,43
00B12:  DATA 20,43
00B14:  DATA 61,72
00B16:  DATA 64,20
00B18:  DATA 66,6F
00B1A:  DATA 75,6E
00B1C:  DATA 64,0D
00B1E:  DATA 0A,00
00B20:  DATA 40,46
00B22:  DATA 53,3A
00B24:  DATA 43,61
00B26:  DATA 72,64
00B28:  DATA 20,54
00B2A:  DATA 79,70
00B2C:  DATA 65,20
00B2E:  DATA 44,69
00B30:  DATA 73,63
00B32:  DATA 6F,76
00B34:  DATA 65,72
00B36:  DATA 79,20
00B38:  DATA 45,72
00B3A:  DATA 72,6F
00B3C:  DATA 72,2C
00B3E:  DATA 20,43
00B40:  DATA 61,72
00B42:  DATA 64,20
00B44:  DATA 3D,20
00B46:  DATA 25,30
00B48:  DATA 32,58
00B4A:  DATA 0D,0A
00B4C:  DATA 00,00
00B4E:  DATA 40,46
00B50:  DATA 53,3A
00B52:  DATA 43,61
00B54:  DATA 72,64
00B56:  DATA 20,72
00B58:  DATA 65,73
00B5A:  DATA 65,74
00B5C:  DATA 20,73
00B5E:  DATA 75,63
00B60:  DATA 63,65
00B62:  DATA 73,73
00B64:  DATA 20,2D
00B66:  DATA 20,43
00B68:  DATA 6D,64
00B6A:  DATA 20,74
00B6C:  DATA 6F,20
00B6E:  DATA 52,65
00B70:  DATA 61,64
00B72:  DATA 79,20
00B74:  DATA 63,6F
00B76:  DATA 75,6E
00B78:  DATA 74,20
00B7A:  DATA 3D,20
00B7C:  DATA 25,6C
00B7E:  DATA 75,0D
00B80:  DATA 0A,00
00B82:  DATA 40,46
00B84:  DATA 53,3A
00B86:  DATA 53,50
00B88:  DATA 49,20
00B8A:  DATA 62,75
00B8C:  DATA 73,20
00B8E:  DATA 73,70
00B90:  DATA 65,65
00B92:  DATA 64,20
00B94:  DATA 73,65
00B96:  DATA 74,20
00B98:  DATA 74,6F
00B9A:  DATA 20,68
00B9C:  DATA 69,67
00B9E:  DATA 68,0D
00BA0:  DATA 0A,00
00BA2:  DATA 40,46
00BA4:  DATA 53,3A
00BA6:  DATA 43,61
00BA8:  DATA 72,64
00BAA:  DATA 20,61
00BAC:  DATA 63,74
00BAE:  DATA 69,76
00BB0:  DATA 61,74
00BB2:  DATA 65,20
00BB4:  DATA 66,61
00BB6:  DATA 69,6C
00BB8:  DATA 75,72
00BBA:  DATA 65,2C
00BBC:  DATA 20,72
00BBE:  DATA 65,73
00BC0:  DATA 70,6F
00BC2:  DATA 6E,73
00BC4:  DATA 65,20
00BC6:  DATA 3D,20
00BC8:  DATA 25,30
00BCA:  DATA 32,58
00BCC:  DATA 2C,20
00BCE:  DATA 54,69
00BD0:  DATA 6D,65
00BD2:  DATA 72,20
00BD4:  DATA 3D,20
00BD6:  DATA 25,6C
00BD8:  DATA 75,0D
00BDA:  DATA 0A,00
00BDC:  DATA 40,46
00BDE:  DATA 53,3A
00BE0:  DATA 43,61
00BE2:  DATA 72,64
00BE4:  DATA 20,61
00BE6:  DATA 63,74
00BE8:  DATA 69,76
00BEA:  DATA 61,74
00BEC:  DATA 65,20
00BEE:  DATA 73,75
00BF0:  DATA 63,63
00BF2:  DATA 65,73
00BF4:  DATA 73,20
00BF6:  DATA 6F,6E
00BF8:  DATA 20,61
00BFA:  DATA 74,74
00BFC:  DATA 65,6D
00BFE:  DATA 70,74
00C00:  DATA 20,25
00C02:  DATA 6C,75
00C04:  DATA 0D,0A
00C06:  DATA 00,00
00C08:  DATA 46,41
00C0A:  DATA 54,20
00C0C:  DATA 61,74
00C0E:  DATA 20,73
00C10:  DATA 65,63
00C12:  DATA 74,6F
00C14:  DATA 72,20
00C16:  DATA 30,0D
00C18:  DATA 0A,00
00C1A:  DATA 54,59
00C1C:  DATA 50,45
00C1E:  DATA 20,63
00C20:  DATA 6F,6D
00C22:  DATA 6D,61
00C24:  DATA 6E,64
00C26:  DATA 20,45
00C28:  DATA 52,52
00C2A:  DATA 4F,52
00C2C:  DATA 0D,0A
00C2E:  DATA 00,00
00C30:  DATA 40,46
00C32:  DATA 53,3A
00C34:  DATA 20,25
00C36:  DATA 73,0D
00C38:  DATA 0A,00
00C3A:  DATA 40,46
00C3C:  DATA 53,3A
00C3E:  DATA 20,25
00C40:  DATA 73,0D
00C42:  DATA 0A,00
00C44:  DATA 2A,2A
00C46:  DATA 20,40
00C48:  DATA 46,53
00C4A:  DATA 3A,20
00C4C:  DATA 45,52
00C4E:  DATA 52,4F
00C50:  DATA 52,0D
00C52:  DATA 0A,00
00C54:  DATA 20,20
00C56:  DATA 20,4E
00C58:  DATA 6F,45
00C5A:  DATA 72,72
00C5C:  DATA 6F,72
00C5E:  DATA 0D,0A
00C60:  DATA 00,00
00C62:  DATA 20,20
00C64:  DATA 20,4D
00C66:  DATA 65,64
00C68:  DATA 69,61
00C6A:  DATA 20,4E
00C6C:  DATA 6F,74
00C6E:  DATA 20,52
00C70:  DATA 65,61
00C72:  DATA 64,79
00C74:  DATA 0D,0A
00C76:  DATA 00,00
00C78:  DATA 20,20
00C7A:  DATA 20,46
00C7C:  DATA 69,6C
00C7E:  DATA 65,20
00C80:  DATA 4E,6F
00C82:  DATA 74,20
00C84:  DATA 46,6F
00C86:  DATA 75,6E
00C88:  DATA 64,0D
00C8A:  DATA 0A,00
00C8C:  DATA 20,20
00C8E:  DATA 20,49
00C90:  DATA 6E,76
00C92:  DATA 61,6C
00C94:  DATA 69,64
00C96:  DATA 20,50
00C98:  DATA 61,74
00C9A:  DATA 68,0D
00C9C:  DATA 0A,00
00C9E:  DATA 20,20
00CA0:  DATA 20,49
00CA2:  DATA 6E,76
00CA4:  DATA 61,6C
00CA6:  DATA 69,64
00CA8:  DATA 20,4E
00CAA:  DATA 61,6D
00CAC:  DATA 65,0D
00CAE:  DATA 0A,00
00CB0:  DATA 20,20
00CB2:  DATA 20,41
00CB4:  DATA 63,63
00CB6:  DATA 65,73
00CB8:  DATA 73,20
00CBA:  DATA 44,65
00CBC:  DATA 6E,69
00CBE:  DATA 65,64
00CC0:  DATA 0D,0A
00CC2:  DATA 00,00
00CC4:  DATA 20,20
00CC6:  DATA 20,44
00CC8:  DATA 69,73
00CCA:  DATA 6B,20
00CCC:  DATA 46,75
00CCE:  DATA 6C,6C
00CD0:  DATA 0D,0A
00CD2:  DATA 00,00
00CD4:  DATA 20,20
00CD6:  DATA 20,52
00CD8:  DATA 65,61
00CDA:  DATA 64,2F
00CDC:  DATA 57,72
00CDE:  DATA 69,74
00CE0:  DATA 65,20
00CE2:  DATA 45,72
00CE4:  DATA 72,6F
00CE6:  DATA 72,0D
00CE8:  DATA 0A,00
00CEA:  DATA 20,20
00CEC:  DATA 20,49
00CEE:  DATA 6E,63
00CF0:  DATA 6F,72
00CF2:  DATA 72,65
00CF4:  DATA 63,74
00CF6:  DATA 20,4D
00CF8:  DATA 65,64
00CFA:  DATA 69,61
00CFC:  DATA 20,43
00CFE:  DATA 68,61
00D00:  DATA 6E,67
00D02:  DATA 65,0D
00D04:  DATA 0A,00
00D06:  DATA 20,20
00D08:  DATA 20,57
00D0A:  DATA 72,69
00D0C:  DATA 74,65
00D0E:  DATA 20,50
00D10:  DATA 72,6F
00D12:  DATA 74,65
00D14:  DATA 63,74
00D16:  DATA 65,64
00D18:  DATA 0D,0A
00D1A:  DATA 00,00
00D1C:  DATA 20,20
00D1E:  DATA 20,4E
00D20:  DATA 6F,74
00D22:  DATA 20,45
00D24:  DATA 6E,61
00D26:  DATA 62,6C
00D28:  DATA 65,64
00D2A:  DATA 0D,0A
00D2C:  DATA 00,00
00D2E:  DATA 20,20
00D30:  DATA 20,4E
00D32:  DATA 6F,20
00D34:  DATA 46,69
00D36:  DATA 6C,65
00D38:  DATA 20,53
00D3A:  DATA 79,73
00D3C:  DATA 74,65
00D3E:  DATA 6D,0D
00D40:  DATA 0A,00
00D42:  DATA 61,70
00D44:  DATA 70,65
00D46:  DATA 6E,64
00D48:  DATA 3A,20
00D4A:  DATA 46,53
00D4C:  DATA 20,45
00D4E:  DATA 52,52
00D50:  DATA 4F,52
00D52:  DATA 20,6F
00D54:  DATA 6E,20
00D56:  DATA 66,69
00D58:  DATA 6C,65
00D5A:  DATA 5F,6F
00D5C:  DATA 70,65
00D5E:  DATA 6E,0D
00D60:  DATA 0A,00
00D62:  DATA 40,46
00D64:  DATA 53,3A
00D66:  DATA 57,72
00D68:  DATA 69,74
00D6A:  DATA 69,6E
00D6C:  DATA 67,0D
00D6E:  DATA 0A,5B
00D70:  DATA 25,73
00D72:  DATA 5D,0D
00D74:  DATA 0A,00
00D76:  DATA 40,46
00D78:  DATA 53,3A
00D7A:  DATA 45,52
00D7C:  DATA 52,4F
00D7E:  DATA 52,5B
00D80:  DATA 61,70
00D82:  DATA 70,65
00D84:  DATA 6E,64
00D86:  DATA 5D,0D
00D88:  DATA 0A,00
00D8A:  DATA 40,46
00D8C:  DATA 53,3A
00D8E:  DATA 43,6C
00D90:  DATA 6F,73
00D92:  DATA 69,6E
00D94:  DATA 67,0D
00D96:  DATA 0A,00
00D98:  DATA 40,52
00D9A:  DATA 54,43
00D9C:  DATA 3A,25
00D9E:  DATA 30,32
00DA0:  DATA 75,2F
00DA2:  DATA 00,00
00DA4:  DATA 40,52
00DA6:  DATA 54,43
00DA8:  DATA 3A,25
00DAA:  DATA 30,32
00DAC:  DATA 75,2F
00DAE:  DATA 00,00
00DB0:  DATA 40,41
00DB2:  DATA 4C,4D
00DB4:  DATA 3A,25
00DB6:  DATA 30,32
00DB8:  DATA 75,2F
00DBA:  DATA 00,00
00DBC:  DATA 40,41
00DBE:  DATA 4C,4D
00DC0:  DATA 3A,25
00DC2:  DATA 30,32
00DC4:  DATA 75,2F
00DC6:  DATA 00,00
00DC8:  DATA 20,20
00DCA:  DATA 20,20
00DCC:  DATA 20,20
00DCE:  DATA 20,20
00DD0:  DATA 20,20
00DD2:  DATA 20,20
00DD4:  DATA 20,20
00DD6:  DATA 20,20
00DD8:  DATA 20,20
00DDA:  DATA 20,20
00DDC:  DATA 20,20
00DDE:  DATA 20,20
00DE0:  DATA 20,20
00DE2:  DATA 20,20
00DE4:  DATA 20,20
00DE6:  DATA 20,20
00DE8:  DATA 20,20
00DEA:  DATA 20,20
00DEC:  DATA 20,20
00DEE:  DATA 20,00
00DF0:  DATA 40,41
00DF2:  DATA 4C,4D
00DF4:  DATA 0D,0A
00DF6:  DATA 00,00
*
00E6E:  TBLRD*+
00E70:  MOVF   FF5,F
00E72:  BZ    0E96
00E74:  MOVFF  FF6,A38
00E78:  MOVFF  FF7,A39
00E7C:  MOVFF  FF8,A3A
00E80:  MOVF   FF5,W
00E82:  BTFSS  F9E.4
00E84:  BRA    0E82
00E86:  MOVWF  FAD
00E88:  MOVFF  A38,FF6
00E8C:  MOVFF  A39,FF7
00E90:  MOVFF  A3A,FF8
00E94:  BRA    0E6E
00E96:  RETURN 0
*
00EF8:  DATA 3F,40
00EFA:  DATA 42,53
00EFC:  DATA 59,0D
00EFE:  DATA 0A,00
00F00:  DATA 40,52
00F02:  DATA 44,59
00F04:  DATA 0D,0A
00F06:  DATA 00,00
*
00F48:  DATA 40,5B
00F4A:  DATA 4F,5D
00F4C:  DATA 0D,0A
00F4E:  DATA 00,00
00F50:  DATA 40,43
00F52:  DATA 4D,44
00F54:  DATA 20,74
00F56:  DATA 6F,6F
00F58:  DATA 20,6C
00F5A:  DATA 6F,6E
00F5C:  DATA 67,0D
00F5E:  DATA 0A,00
00F60:  DATA 40,5B
00F62:  DATA 43,5D
00F64:  DATA 0D,0A
00F66:  DATA 00,00
00F68:  DATA 40,53
00F6A:  DATA 4C,45
00F6C:  DATA 45,50
00F6E:  DATA 0D,0A
00F70:  DATA 00,00
00F72:  DATA 40,4D
00F74:  DATA 45,52
00F76:  DATA 2C,25
00F78:  DATA 4C,75
00F7A:  DATA 2C,25
00F7C:  DATA 4C,75
00F7E:  DATA 0D,0A
00F80:  DATA 00,00
00F82:  DATA 6D,3A
00F84:  DATA 25,75
00F86:  DATA 2C,25
00F88:  DATA 75,20
00F8A:  DATA 63,3A
00F8C:  DATA 25,4C
00F8E:  DATA 75,2C
00F90:  DATA 25,4C
00F92:  DATA 75,2C
00F94:  DATA 25,4C
00F96:  DATA 75,0D
00F98:  DATA 0A,00
00F9A:  MOVLB  A
00F9C:  MOVF   x43,W
00F9E:  CLRF   01
00FA0:  SUBWF  x42,W
00FA2:  BC    0FAA
00FA4:  MOVFF  A42,00
00FA8:  BRA    0FC2
00FAA:  CLRF   00
00FAC:  MOVLW  08
00FAE:  MOVWF  x44
00FB0:  RLCF   x42,F
00FB2:  RLCF   00,F
00FB4:  MOVF   x43,W
00FB6:  SUBWF  00,W
00FB8:  BTFSC  FD8.0
00FBA:  MOVWF  00
00FBC:  RLCF   01,F
00FBE:  DECFSZ x44,F
00FC0:  BRA    0FB0
00FC2:  MOVLB  0
00FC4:  RETURN 0
00FC6:  MOVF   01,W
00FC8:  MOVFF  A40,A42
00FCC:  MOVLW  64
00FCE:  MOVLB  A
00FD0:  MOVWF  x43
00FD2:  MOVLB  0
00FD4:  RCALL  0F9A
00FD6:  MOVFF  00,A40
00FDA:  MOVF   01,W
00FDC:  MOVLW  30
00FDE:  BNZ   0FF0
00FE0:  MOVLB  A
00FE2:  BTFSS  x41.1
00FE4:  BRA    1002
00FE6:  BTFSC  x41.3
00FE8:  BRA    1002
00FEA:  BTFSC  x41.4
00FEC:  MOVLW  20
00FEE:  BRA    0FF8
00FF0:  MOVLB  A
00FF2:  BCF    x41.3
00FF4:  BCF    x41.4
00FF6:  BSF    x41.0
00FF8:  ADDWF  01,F
00FFA:  MOVF   01,W
00FFC:  BTFSS  F9E.4
00FFE:  BRA    0FFC
01000:  MOVWF  FAD
01002:  MOVFF  A40,A42
01006:  MOVLW  0A
01008:  MOVWF  x43
0100A:  MOVLB  0
0100C:  RCALL  0F9A
0100E:  MOVFF  00,A40
01012:  MOVF   01,W
01014:  MOVLW  30
01016:  BNZ   1028
01018:  MOVLB  A
0101A:  BTFSC  x41.3
0101C:  BRA    1034
0101E:  BTFSS  x41.0
01020:  BRA    1034
01022:  BTFSC  x41.4
01024:  MOVLW  20
01026:  MOVLB  0
01028:  ADDWF  01,F
0102A:  MOVF   01,W
0102C:  BTFSS  F9E.4
0102E:  BRA    102C
01030:  MOVWF  FAD
01032:  MOVLB  A
01034:  MOVLW  30
01036:  ADDWF  x40,F
01038:  MOVF   x40,W
0103A:  BTFSS  F9E.4
0103C:  BRA    103A
0103E:  MOVWF  FAD
01040:  MOVLB  0
01042:  RETURN 0
01044:  TBLRD*+
01046:  MOVFF  FF6,A41
0104A:  MOVFF  FF7,A42
0104E:  MOVFF  FF8,A43
01052:  MOVF   FF5,W
01054:  BTFSS  F9E.4
01056:  BRA    1054
01058:  MOVWF  FAD
0105A:  MOVFF  A41,FF6
0105E:  MOVFF  A42,FF7
01062:  MOVFF  A43,FF8
01066:  MOVLB  A
01068:  DECFSZ x40,F
0106A:  BRA    106E
0106C:  BRA    1072
0106E:  MOVLB  0
01070:  BRA    1044
01072:  MOVLB  0
01074:  RETURN 0
01076:  BTFSC  FD8.1
01078:  BRA    1082
0107A:  MOVLW  0A
0107C:  MOVWF  FEA
0107E:  MOVLW  54
01080:  MOVWF  FE9
01082:  CLRF   00
01084:  CLRF   01
01086:  CLRF   02
01088:  CLRF   03
0108A:  MOVLB  A
0108C:  CLRF   x54
0108E:  CLRF   x55
01090:  CLRF   x56
01092:  CLRF   x57
01094:  MOVF   x53,W
01096:  IORWF  x52,W
01098:  IORWF  x51,W
0109A:  IORWF  x50,W
0109C:  BZ    10F6
0109E:  MOVLW  20
010A0:  MOVWF  x58
010A2:  BCF    FD8.0
010A4:  RLCF   x4C,F
010A6:  RLCF   x4D,F
010A8:  RLCF   x4E,F
010AA:  RLCF   x4F,F
010AC:  RLCF   x54,F
010AE:  RLCF   x55,F
010B0:  RLCF   x56,F
010B2:  RLCF   x57,F
010B4:  MOVF   x53,W
010B6:  SUBWF  x57,W
010B8:  BNZ   10CA
010BA:  MOVF   x52,W
010BC:  SUBWF  x56,W
010BE:  BNZ   10CA
010C0:  MOVF   x51,W
010C2:  SUBWF  x55,W
010C4:  BNZ   10CA
010C6:  MOVF   x50,W
010C8:  SUBWF  x54,W
010CA:  BNC   10EA
010CC:  MOVF   x50,W
010CE:  SUBWF  x54,F
010D0:  MOVF   x51,W
010D2:  BTFSS  FD8.0
010D4:  INCFSZ x51,W
010D6:  SUBWF  x55,F
010D8:  MOVF   x52,W
010DA:  BTFSS  FD8.0
010DC:  INCFSZ x52,W
010DE:  SUBWF  x56,F
010E0:  MOVF   x53,W
010E2:  BTFSS  FD8.0
010E4:  INCFSZ x53,W
010E6:  SUBWF  x57,F
010E8:  BSF    FD8.0
010EA:  RLCF   00,F
010EC:  RLCF   01,F
010EE:  RLCF   02,F
010F0:  RLCF   03,F
010F2:  DECFSZ x58,F
010F4:  BRA    10A2
010F6:  MOVFF  A54,FEF
010FA:  MOVFF  A55,FEC
010FE:  MOVFF  A56,FEC
01102:  MOVFF  A57,FEC
01106:  MOVLB  0
01108:  RETURN 0
0110A:  MOVF   FE9,W
0110C:  MOVLB  A
0110E:  MOVWF  x44
01110:  MOVLW  3B
01112:  MOVWF  x4B
01114:  MOVLW  9A
01116:  MOVWF  x4A
01118:  MOVLW  CA
0111A:  MOVWF  x49
0111C:  CLRF   x48
0111E:  MOVLW  0A
01120:  MOVWF  x46
01122:  BSF    FD8.1
01124:  MOVLW  0A
01126:  MOVWF  FEA
01128:  MOVLW  40
0112A:  MOVWF  FE9
0112C:  MOVFF  A43,A4F
01130:  MOVFF  A42,A4E
01134:  MOVFF  A41,A4D
01138:  MOVFF  A40,A4C
0113C:  MOVFF  A4B,A53
01140:  MOVFF  A4A,A52
01144:  MOVFF  A49,A51
01148:  MOVFF  A48,A50
0114C:  MOVLB  0
0114E:  RCALL  1076
01150:  MOVF   01,W
01152:  MOVF   00,F
01154:  BNZ   117C
01156:  MOVLB  A
01158:  MOVF   x46,W
0115A:  XORLW  01
0115C:  BTFSS  FD8.2
0115E:  BRA    1164
01160:  MOVLB  0
01162:  BRA    117C
01164:  MOVF   x44,W
01166:  BZ    1180
01168:  ANDLW  0F
0116A:  SUBWF  x46,W
0116C:  BZ    1170
0116E:  BC    118C
01170:  BTFSC  x44.7
01172:  BRA    118C
01174:  BTFSC  x44.6
01176:  BRA    1180
01178:  MOVLW  20
0117A:  BRA    1182
0117C:  MOVLB  A
0117E:  CLRF   x44
01180:  MOVLW  30
01182:  ADDWF  00,F
01184:  MOVF   00,W
01186:  BTFSS  F9E.4
01188:  BRA    1186
0118A:  MOVWF  FAD
0118C:  BCF    FD8.1
0118E:  MOVFF  A4B,A4F
01192:  MOVFF  A4A,A4E
01196:  MOVFF  A49,A4D
0119A:  MOVFF  A48,A4C
0119E:  CLRF   x53
011A0:  CLRF   x52
011A2:  CLRF   x51
011A4:  MOVLW  0A
011A6:  MOVWF  x50
011A8:  MOVLB  0
011AA:  RCALL  1076
011AC:  MOVFF  03,A4B
011B0:  MOVFF  02,A4A
011B4:  MOVFF  01,A49
011B8:  MOVFF  00,A48
011BC:  MOVLB  A
011BE:  DECFSZ x46,F
011C0:  BRA    1122
011C2:  MOVLB  0
011C4:  RETURN 0
011C6:  MOVFF  FEA,A48
011CA:  MOVFF  FE9,A47
011CE:  MOVLB  A
011D0:  SWAPF  x41,W
011D2:  IORLW  F0
011D4:  MOVWF  x43
011D6:  ADDWF  x43,F
011D8:  ADDLW  E2
011DA:  MOVWF  x44
011DC:  ADDLW  32
011DE:  MOVWF  x46
011E0:  MOVF   x41,W
011E2:  ANDLW  0F
011E4:  ADDWF  x44,F
011E6:  ADDWF  x44,F
011E8:  ADDWF  x46,F
011EA:  ADDLW  E9
011EC:  MOVWF  x45
011EE:  ADDWF  x45,F
011F0:  ADDWF  x45,F
011F2:  SWAPF  x40,W
011F4:  ANDLW  0F
011F6:  ADDWF  x45,F
011F8:  ADDWF  x46,F
011FA:  RLCF   x45,F
011FC:  RLCF   x46,F
011FE:  COMF   x46,F
01200:  RLCF   x46,F
01202:  MOVF   x40,W
01204:  ANDLW  0F
01206:  ADDWF  x46,F
01208:  RLCF   x43,F
0120A:  MOVLW  07
0120C:  MOVWF  x42
0120E:  MOVLW  0A
01210:  DECF   x45,F
01212:  ADDWF  x46,F
01214:  BNC   1210
01216:  DECF   x44,F
01218:  ADDWF  x45,F
0121A:  BNC   1216
0121C:  DECF   x43,F
0121E:  ADDWF  x44,F
01220:  BNC   121C
01222:  DECF   x42,F
01224:  ADDWF  x43,F
01226:  BNC   1222
01228:  MOVLW  0A
0122A:  MOVWF  FEA
0122C:  MOVLW  42
0122E:  MOVWF  FE9
01230:  MOVLW  07
01232:  ANDWF  x47,W
01234:  BCF    x47.6
01236:  ADDWF  FE9,F
01238:  MOVLW  00
0123A:  ADDWFC FEA,F
0123C:  MOVF   FE9,W
0123E:  SUBLW  46
01240:  BNZ   124A
01242:  MOVF   FEA,W
01244:  SUBLW  0A
01246:  BNZ   124A
01248:  BSF    x47.6
0124A:  MOVF   FEF,W
0124C:  MOVWF  00
0124E:  BNZ   1260
01250:  BTFSC  x47.6
01252:  BRA    1260
01254:  BTFSC  x47.4
01256:  BRA    1270
01258:  BTFSC  x47.3
0125A:  BRA    1260
0125C:  MOVLW  20
0125E:  BRA    1266
01260:  BSF    x47.3
01262:  BCF    x47.4
01264:  MOVLW  30
01266:  ADDWF  00,F
01268:  MOVF   00,W
0126A:  BTFSS  F9E.4
0126C:  BRA    126A
0126E:  MOVWF  FAD
01270:  MOVF   FEE,W
01272:  BTFSS  x47.6
01274:  BRA    123C
01276:  MOVLB  0
01278:  RETURN 0
*
01A7E:  DATA 40,4C
01A80:  DATA 50,43
01A82:  DATA 2C,25
01A84:  DATA 4C,75
01A86:  DATA 2C,25
01A88:  DATA 4C,64
01A8A:  DATA 0D,0A
01A8C:  DATA 00,00
01A8E:  DATA 40,4D
01A90:  DATA 4D,45
01A92:  DATA 2C,25
01A94:  DATA 75,2C
01A96:  DATA 25,4C
01A98:  DATA 64,2C
01A9A:  DATA 25,4C
01A9C:  DATA 75,2C
01A9E:  DATA 25,4C
01AA0:  DATA 75,2C
01AA2:  DATA 25,4C
01AA4:  DATA 64,2C
01AA6:  DATA 25,4C
01AA8:  DATA 64,0D
01AAA:  DATA 0A,00
01AAC:  DATA 56,41
01AAE:  DATA 4C,56
01AB0:  DATA 45,20
01AB2:  DATA 53,54
01AB4:  DATA 4F,50
01AB6:  DATA 20,25
01AB8:  DATA 4C,75
01ABA:  DATA 2C,25
01ABC:  DATA 4C,75
01ABE:  DATA 0D,0A
01AC0:  DATA 00,00
01AC2:  DATA 69,6E
01AC4:  DATA 64,3A
01AC6:  DATA 25,75
01AC8:  DATA 20,2F
01ACA:  DATA 20,70
01ACC:  DATA 68,61
01ACE:  DATA 3A,25
01AD0:  DATA 75,0D
01AD2:  DATA 0A,00
01AD4:  DATA 40,52
01AD6:  DATA 45,43
01AD8:  DATA 20,2D
01ADA:  DATA 20,68
01ADC:  DATA 6F,6D
01ADE:  DATA 69,6E
01AE0:  DATA 67,20
01AE2:  DATA 73,79
01AE4:  DATA 72,69
01AE6:  DATA 6E,67
01AE8:  DATA 65,20
01AEA:  DATA 61,6E
01AEC:  DATA 64,20
01AEE:  DATA 61,6C
01AF0:  DATA 69,67
01AF2:  DATA 6E,69
01AF4:  DATA 6E,67
01AF6:  DATA 20,76
01AF8:  DATA 61,6C
01AFA:  DATA 76,65
01AFC:  DATA 20,74
01AFE:  DATA 6F,20
01B00:  DATA 70,6F
01B02:  DATA 72,74
01B04:  DATA 20,31
01B06:  DATA 0D,0A
01B08:  DATA 00,00
01B0A:  DATA 2C,73
01B0C:  DATA 65,72
01B0E:  DATA 69,61
01B10:  DATA 6C,20
01B12:  DATA 77,61
01B14:  DATA 6B,65
01B16:  DATA 2D,75
01B18:  DATA 70,2C
01B1A:  DATA 53,44
01B1C:  DATA 20,69
01B1E:  DATA 6E,69
01B20:  DATA 74,69
01B22:  DATA 61,6C
01B24:  DATA 69,7A
01B26:  DATA 65,64
01B28:  DATA 0D,0A
01B2A:  DATA 00,00
01B2C:  DATA 40,52
01B2E:  DATA 53,54
01B30:  DATA 0D,0A
01B32:  DATA 00,00
01B34:  DATA 40,57
01B36:  DATA 44,54
01B38:  DATA 0D,0A
01B3A:  DATA 00,00
01B3C:  DATA 2C,72
01B3E:  DATA 65,73
01B40:  DATA 74,61
01B42:  DATA 72,74
01B44:  DATA 20,63
01B46:  DATA 61,75
01B48:  DATA 73,65
01B4A:  DATA 2C,57
01B4C:  DATA 44,20
01B4E:  DATA 74,69
01B50:  DATA 6D,65
01B52:  DATA 2D,6F
01B54:  DATA 75,74
01B56:  DATA 0D,0A
01B58:  DATA 00,00
01B5A:  DATA 40,57
01B5C:  DATA 44,53
01B5E:  DATA 0D,0A
01B60:  DATA 00,00
01B62:  DATA 2C,72
01B64:  DATA 65,73
01B66:  DATA 74,61
01B68:  DATA 72,74
01B6A:  DATA 20,63
01B6C:  DATA 61,75
01B6E:  DATA 73,65
01B70:  DATA 2C,57
01B72:  DATA 44,20
01B74:  DATA 66,72
01B76:  DATA 6F,6D
01B78:  DATA 20,73
01B7A:  DATA 6C,65
01B7C:  DATA 65,70
01B7E:  DATA 0D,0A
01B80:  DATA 00,00
01B82:  DATA 40,4E
01B84:  DATA 50,55
01B86:  DATA 0D,0A
01B88:  DATA 00,00
01B8A:  DATA 2C,69
01B8C:  DATA 64,23
01B8E:  DATA 5B,25
01B90:  DATA 4C,75
01B92:  DATA 5D,2C
01B94:  DATA 70,6F
01B96:  DATA 77,65
01B98:  DATA 72,20
01B9A:  DATA 61,70
01B9C:  DATA 70,6C
01B9E:  DATA 69,65
01BA0:  DATA 64,2C
01BA2:  DATA 53,44
01BA4:  DATA 20,69
01BA6:  DATA 6E,69
01BA8:  DATA 74,69
01BAA:  DATA 61,6C
01BAC:  DATA 69,7A
01BAE:  DATA 65,64
01BB0:  DATA 0D,0A
01BB2:  DATA 00,00
01BB4:  DATA 40,52
01BB6:  DATA 53,54
01BB8:  DATA 0D,0A
01BBA:  DATA 00,00
01BBC:  DATA 2C,72
01BBE:  DATA 65,73
01BC0:  DATA 74,61
01BC2:  DATA 72,74
01BC4:  DATA 20,63
01BC6:  DATA 61,75
01BC8:  DATA 73,65
01BCA:  DATA 2C,72
01BCC:  DATA 65,73
01BCE:  DATA 65,74
01BD0:  DATA 20,69
01BD2:  DATA 6E,73
01BD4:  DATA 74,72
01BD6:  DATA 75,63
01BD8:  DATA 74,69
01BDA:  DATA 6F,6E
01BDC:  DATA 0D,0A
01BDE:  DATA 00,00
01BE0:  DATA 40,42
01BE2:  DATA 4F,52
01BE4:  DATA 0D,0A
01BE6:  DATA 00,00
01BE8:  DATA 2C,72
01BEA:  DATA 65,73
01BEC:  DATA 74,61
01BEE:  DATA 72,74
01BF0:  DATA 20,63
01BF2:  DATA 61,75
01BF4:  DATA 73,65
01BF6:  DATA 2C,62
01BF8:  DATA 72,6F
01BFA:  DATA 77,6E
01BFC:  DATA 2D,6F
01BFE:  DATA 75,74
01C00:  DATA 0D,0A
01C02:  DATA 00,00
01C04:  DATA 40,4D
01C06:  DATA 52,53
01C08:  DATA 0D,0A
01C0A:  DATA 00,00
01C0C:  DATA 2C,72
01C0E:  DATA 65,73
01C10:  DATA 74,61
01C12:  DATA 72,74
01C14:  DATA 20,63
01C16:  DATA 61,75
01C18:  DATA 73,65
01C1A:  DATA 2C,4D
01C1C:  DATA 43,4C
01C1E:  DATA 52,20
01C20:  DATA 66,72
01C22:  DATA 6F,6D
01C24:  DATA 20,73
01C26:  DATA 6C,65
01C28:  DATA 65,70
01C2A:  DATA 0D,0A
01C2C:  DATA 00,00
01C2E:  DATA 40,4D
01C30:  DATA 52,52
01C32:  DATA 0D,0A
01C34:  DATA 00,00
01C36:  DATA 2C,72
01C38:  DATA 65,73
01C3A:  DATA 74,61
01C3C:  DATA 72,74
01C3E:  DATA 20,63
01C40:  DATA 61,75
01C42:  DATA 73,65
01C44:  DATA 2C,4D
01C46:  DATA 43,4C
01C48:  DATA 52,20
01C4A:  DATA 77,68
01C4C:  DATA 65,6E
01C4E:  DATA 20,72
01C50:  DATA 75,6E
01C52:  DATA 6E,69
01C54:  DATA 6E,67
01C56:  DATA 0D,0A
01C58:  DATA 00,00
01C5A:  DATA 4E,4F
01C5C:  DATA 33,00
01C5E:  DATA 4E,4F
01C60:  DATA 32,00
01C62:  DATA 50,4F
01C64:  DATA 34,00
01C66:  DATA 4E,48
01C68:  DATA 34,00
01C6A:  DATA 53,69
01C6C:  DATA 4F,00
01C6E:  DATA 00,00
01C70:  DATA 40,44
01C72:  DATA 45,54
01C74:  DATA 5B,2F
01C76:  DATA 25,75
01C78:  DATA 5D,5B
01C7A:  DATA 25,63
01C7C:  DATA 5D,41
01C7E:  DATA 52,47
01C80:  DATA 5B,25
01C82:  DATA 4C,75
01C84:  DATA 5D,0D
01C86:  DATA 0A,00
01C88:  DATA 20,74
01C8A:  DATA 69,6D
01C8C:  DATA 65,2D
01C8E:  DATA 6F,75
01C90:  DATA 74,00
01C92:  DATA 20,64
01C94:  DATA 61,74
01C96:  DATA 61,20
01C98:  DATA 74,6F
01C9A:  DATA 6F,20
01C9C:  DATA 73,68
01C9E:  DATA 6F,72
01CA0:  DATA 74,00
01CA2:  DATA 20,64
01CA4:  DATA 61,74
01CA6:  DATA 61,20
01CA8:  DATA 74,6F
01CAA:  DATA 6F,20
01CAC:  DATA 6C,6F
01CAE:  DATA 6E,67
01CB0:  DATA 00,00
01CB2:  DATA 2C,64
01CB4:  DATA 65,74
01CB6:  DATA 65,63
01CB8:  DATA 74,6F
01CBA:  DATA 72,5B
01CBC:  DATA 25,73
01CBE:  DATA 5D,2C
01CC0:  DATA 6C,65
01CC2:  DATA 6E,5B
01CC4:  DATA 25,75
01CC6:  DATA 5D,00
01CC8:  DATA 40,52
01CCA:  DATA 54,59
01CCC:  DATA 2C,25
01CCE:  DATA 75,0D
01CD0:  DATA 0A,00
01CD2:  DATA 2C,73
01CD4:  DATA 74,61
01CD6:  DATA 72,74
01CD8:  DATA 20,68
01CDA:  DATA 65,61
01CDC:  DATA 74,69
01CDE:  DATA 6E,67
01CE0:  DATA 2C,74
01CE2:  DATA 61,72
01CE4:  DATA 67,65
01CE6:  DATA 74,5B
01CE8:  DATA 25,4C
01CEA:  DATA 75,5D
01CEC:  DATA 2C,61
01CEE:  DATA 63,74
01CF0:  DATA 75,61
01CF2:  DATA 6C,5B
01CF4:  DATA 25,4C
01CF6:  DATA 75,5D
01CF8:  DATA 2C,72
01CFA:  DATA 65,61
01CFC:  DATA 64,69
01CFE:  DATA 6E,67
01D00:  DATA 73,5B
01D02:  DATA 25,4C
01D04:  DATA 75,5D
01D06:  DATA 0D,0A
01D08:  DATA 00,00
01D0A:  DATA 2C,65
01D0C:  DATA 6E,64
01D0E:  DATA 20,68
01D10:  DATA 65,61
01D12:  DATA 74,69
01D14:  DATA 6E,67
01D16:  DATA 2C,74
01D18:  DATA 61,72
01D1A:  DATA 67,65
01D1C:  DATA 74,5B
01D1E:  DATA 25,4C
01D20:  DATA 75,5D
01D22:  DATA 2C,61
01D24:  DATA 63,74
01D26:  DATA 75,61
01D28:  DATA 6C,5B
01D2A:  DATA 25,4C
01D2C:  DATA 75,5D
01D2E:  DATA 2C,72
01D30:  DATA 65,61
01D32:  DATA 64,69
01D34:  DATA 6E,67
01D36:  DATA 73,5B
01D38:  DATA 25,4C
01D3A:  DATA 75,5D
01D3C:  DATA 0D,0A
01D3E:  DATA 00,00
01D40:  DATA 4E,4F
01D42:  DATA 33,00
01D44:  DATA 4E,4F
01D46:  DATA 32,00
01D48:  DATA 50,4F
01D4A:  DATA 34,00
01D4C:  DATA 4E,48
01D4E:  DATA 34,00
01D50:  DATA 53,69
01D52:  DATA 4F,00
01D54:  DATA 00,00
01D56:  DATA 40,44
01D58:  DATA 41,43
01D5A:  DATA 2C,25
01D5C:  DATA 4C,75
01D5E:  DATA 2C,25
01D60:  DATA 4C,75
01D62:  DATA 2C,00
01D64:  DATA 40,53
01D66:  DATA 41,52
01D68:  DATA 2C,31
01D6A:  DATA 2C,25
01D6C:  DATA 4C,75
01D6E:  DATA 2C,00
01D70:  DATA 40,56
01D72:  DATA 41,4C
01D74:  DATA 20,00
01D76:  DATA 40,56
01D78:  DATA 41,4C
01D7A:  DATA 20,00
01D7C:  DATA 40,56
01D7E:  DATA 41,4C
01D80:  DATA 20,00
01D82:  DATA 40,56
01D84:  DATA 41,4C
01D86:  DATA 20,00
01D88:  DATA 40,53
01D8A:  DATA 4F,4C
01D8C:  DATA 5B,2F
01D8E:  DATA 31,5D
01D90:  DATA 5B,73
01D92:  DATA 5D,5B
01D94:  DATA 25,4C
01D96:  DATA 75,5D
01D98:  DATA 0D,0A
01D9A:  DATA 00,00
01D9C:  DATA 2F,31
01D9E:  DATA 73,25
01DA0:  DATA 4C,75
01DA2:  DATA 0D,00
01DA4:  DATA 40,53
01DA6:  DATA 4F,4C
01DA8:  DATA 5B,2F
01DAA:  DATA 31,5D
01DAC:  DATA 5B,63
01DAE:  DATA 5D,5B
01DB0:  DATA 25,75
01DB2:  DATA 5D,0D
01DB4:  DATA 0A,00
01DB6:  DATA 2F,31
01DB8:  DATA 63,25
01DBA:  DATA 75,0D
01DBC:  DATA 00,00
01DBE:  DATA 2F,31
01DC0:  DATA 73,32
01DC2:  DATA 35,36
01DC4:  DATA 0D,00
01DC6:  DATA 28,49
01DC8:  DATA 30,73
01DCA:  DATA 29,2C
01DCC:  DATA 25,4C
01DCE:  DATA 75,2C
01DD0:  DATA 28,49
01DD2:  DATA 31,73
01DD4:  DATA 29,2C
01DD6:  DATA 25,4C
01DD8:  DATA 75,2C
01DDA:  DATA 28,41
01DDC:  DATA 62,73
01DDE:  DATA 2D,73
01DE0:  DATA 29,2C
01DE2:  DATA 25,31
01DE4:  DATA 2E,34
01DE6:  DATA 67,2C
01DE8:  DATA 28,49
01DEA:  DATA 30,74
01DEC:  DATA 29,2C
01DEE:  DATA 25,4C
01DF0:  DATA 75,2C
01DF2:  DATA 28,49
01DF4:  DATA 31,74
01DF6:  DATA 29,2C
01DF8:  DATA 25,4C
01DFA:  DATA 75,2C
01DFC:  DATA 28,41
01DFE:  DATA 62,73
01E00:  DATA 2D,74
01E02:  DATA 29,2C
01E04:  DATA 25,31
01E06:  DATA 2E,34
01E08:  DATA 67,2C
01E0A:  DATA 28,49
01E0C:  DATA 30,72
01E0E:  DATA 29,2C
01E10:  DATA 25,4C
01E12:  DATA 75,2C
01E14:  DATA 28,49
01E16:  DATA 31,72
01E18:  DATA 29,2C
01E1A:  DATA 25,4C
01E1C:  DATA 75,2C
01E1E:  DATA 28,41
01E20:  DATA 62,73
01E22:  DATA 2D,72
01E24:  DATA 29,2C
01E26:  DATA 25,31
01E28:  DATA 2E,34
01E2A:  DATA 67,00
01E2C:  DATA 40,41
01E2E:  DATA 62,73
01E30:  DATA 2C,4E
01E32:  DATA 4F,33
01E34:  DATA 2C,25
01E36:  DATA 73,0D
01E38:  DATA 0A,00
01E3A:  DATA 28,49
01E3C:  DATA 30,73
01E3E:  DATA 29,2C
01E40:  DATA 25,4C
01E42:  DATA 75,2C
01E44:  DATA 28,49
01E46:  DATA 31,73
01E48:  DATA 29,2C
01E4A:  DATA 25,4C
01E4C:  DATA 75,2C
01E4E:  DATA 28,41
01E50:  DATA 62,73
01E52:  DATA 2D,73
01E54:  DATA 29,2C
01E56:  DATA 25,31
01E58:  DATA 2E,34
01E5A:  DATA 67,2C
01E5C:  DATA 28,49
01E5E:  DATA 30,74
01E60:  DATA 29,2C
01E62:  DATA 25,4C
01E64:  DATA 75,2C
01E66:  DATA 28,49
01E68:  DATA 31,74
01E6A:  DATA 29,2C
01E6C:  DATA 25,4C
01E6E:  DATA 75,2C
01E70:  DATA 28,41
01E72:  DATA 62,73
01E74:  DATA 2D,74
01E76:  DATA 29,2C
01E78:  DATA 25,31
01E7A:  DATA 2E,34
01E7C:  DATA 67,2C
01E7E:  DATA 28,49
01E80:  DATA 30,72
01E82:  DATA 29,2C
01E84:  DATA 25,4C
01E86:  DATA 75,2C
01E88:  DATA 28,49
01E8A:  DATA 31,72
01E8C:  DATA 29,2C
01E8E:  DATA 25,4C
01E90:  DATA 75,2C
01E92:  DATA 28,41
01E94:  DATA 62,73
01E96:  DATA 2D,72
01E98:  DATA 29,2C
01E9A:  DATA 25,31
01E9C:  DATA 2E,34
01E9E:  DATA 67,00
01EA0:  DATA 40,41
01EA2:  DATA 62,73
01EA4:  DATA 2C,4E
01EA6:  DATA 4F,32
01EA8:  DATA 2C,25
01EAA:  DATA 73,0D
01EAC:  DATA 0A,00
01EAE:  DATA 28,49
01EB0:  DATA 30,73
01EB2:  DATA 29,2C
01EB4:  DATA 25,4C
01EB6:  DATA 75,2C
01EB8:  DATA 28,49
01EBA:  DATA 31,73
01EBC:  DATA 29,2C
01EBE:  DATA 25,4C
01EC0:  DATA 75,2C
01EC2:  DATA 28,41
01EC4:  DATA 62,73
01EC6:  DATA 2D,73
01EC8:  DATA 29,2C
01ECA:  DATA 25,31
01ECC:  DATA 2E,34
01ECE:  DATA 67,2C
01ED0:  DATA 28,49
01ED2:  DATA 30,74
01ED4:  DATA 29,2C
01ED6:  DATA 25,4C
01ED8:  DATA 75,2C
01EDA:  DATA 28,49
01EDC:  DATA 31,74
01EDE:  DATA 29,2C
01EE0:  DATA 25,4C
01EE2:  DATA 75,2C
01EE4:  DATA 28,41
01EE6:  DATA 62,73
01EE8:  DATA 2D,74
01EEA:  DATA 29,2C
01EEC:  DATA 25,31
01EEE:  DATA 2E,34
01EF0:  DATA 67,2C
01EF2:  DATA 28,49
01EF4:  DATA 30,72
01EF6:  DATA 29,2C
01EF8:  DATA 25,4C
01EFA:  DATA 75,2C
01EFC:  DATA 28,49
01EFE:  DATA 31,72
01F00:  DATA 29,2C
01F02:  DATA 25,4C
01F04:  DATA 75,2C
01F06:  DATA 28,41
01F08:  DATA 62,73
01F0A:  DATA 2D,72
01F0C:  DATA 29,2C
01F0E:  DATA 25,31
01F10:  DATA 2E,34
01F12:  DATA 67,00
01F14:  DATA 40,41
01F16:  DATA 62,73
01F18:  DATA 2C,50
01F1A:  DATA 4F,34
01F1C:  DATA 2C,25
01F1E:  DATA 73,0D
01F20:  DATA 0A,00
01F22:  DATA 28,49
01F24:  DATA 30,73
01F26:  DATA 29,2C
01F28:  DATA 25,4C
01F2A:  DATA 75,2C
01F2C:  DATA 28,49
01F2E:  DATA 31,73
01F30:  DATA 29,2C
01F32:  DATA 25,4C
01F34:  DATA 75,2C
01F36:  DATA 28,41
01F38:  DATA 62,73
01F3A:  DATA 2D,73
01F3C:  DATA 29,2C
01F3E:  DATA 25,31
01F40:  DATA 2E,34
01F42:  DATA 67,2C
01F44:  DATA 28,49
01F46:  DATA 30,74
01F48:  DATA 29,2C
01F4A:  DATA 25,4C
01F4C:  DATA 75,2C
01F4E:  DATA 28,49
01F50:  DATA 31,74
01F52:  DATA 29,2C
01F54:  DATA 25,4C
01F56:  DATA 75,2C
01F58:  DATA 28,41
01F5A:  DATA 62,73
01F5C:  DATA 2D,74
01F5E:  DATA 29,2C
01F60:  DATA 25,31
01F62:  DATA 2E,34
01F64:  DATA 67,2C
01F66:  DATA 28,49
01F68:  DATA 30,72
01F6A:  DATA 29,2C
01F6C:  DATA 25,4C
01F6E:  DATA 75,2C
01F70:  DATA 28,49
01F72:  DATA 31,72
01F74:  DATA 29,2C
01F76:  DATA 25,4C
01F78:  DATA 75,2C
01F7A:  DATA 28,41
01F7C:  DATA 62,73
01F7E:  DATA 2D,72
01F80:  DATA 29,2C
01F82:  DATA 25,31
01F84:  DATA 2E,34
01F86:  DATA 67,00
01F88:  DATA 40,41
01F8A:  DATA 62,73
01F8C:  DATA 2C,4E
01F8E:  DATA 48,34
01F90:  DATA 2C,25
01F92:  DATA 73,0D
01F94:  DATA 0A,00
01F96:  DATA 28,49
01F98:  DATA 30,73
01F9A:  DATA 29,2C
01F9C:  DATA 25,4C
01F9E:  DATA 75,2C
01FA0:  DATA 28,49
01FA2:  DATA 31,73
01FA4:  DATA 29,2C
01FA6:  DATA 25,4C
01FA8:  DATA 75,2C
01FAA:  DATA 28,41
01FAC:  DATA 62,73
01FAE:  DATA 2D,73
01FB0:  DATA 29,2C
01FB2:  DATA 25,31
01FB4:  DATA 2E,34
01FB6:  DATA 67,2C
01FB8:  DATA 28,49
01FBA:  DATA 30,74
01FBC:  DATA 29,2C
01FBE:  DATA 25,4C
01FC0:  DATA 75,2C
01FC2:  DATA 28,49
01FC4:  DATA 31,74
01FC6:  DATA 29,2C
01FC8:  DATA 25,4C
01FCA:  DATA 75,2C
01FCC:  DATA 28,41
01FCE:  DATA 62,73
01FD0:  DATA 2D,74
01FD2:  DATA 29,2C
01FD4:  DATA 25,31
01FD6:  DATA 2E,34
01FD8:  DATA 67,2C
01FDA:  DATA 28,49
01FDC:  DATA 30,72
01FDE:  DATA 29,2C
01FE0:  DATA 25,4C
01FE2:  DATA 75,2C
01FE4:  DATA 28,49
01FE6:  DATA 31,72
01FE8:  DATA 29,2C
01FEA:  DATA 25,4C
01FEC:  DATA 75,2C
01FEE:  DATA 28,41
01FF0:  DATA 62,73
01FF2:  DATA 2D,72
01FF4:  DATA 29,2C
01FF6:  DATA 25,31
01FF8:  DATA 2E,34
01FFA:  DATA 67,00
01FFC:  DATA 40,41
01FFE:  DATA 42,53
02000:  DATA 2C,53
02002:  DATA 69,4F
02004:  DATA 2C,25
02006:  DATA 73,0D
02008:  DATA 0A,00
0200A:  DATA 4E,4F
0200C:  DATA 33,00
0200E:  DATA 4E,4F
02010:  DATA 32,00
02012:  DATA 50,4F
02014:  DATA 34,00
02016:  DATA 4E,48
02018:  DATA 34,00
0201A:  DATA 53,69
0201C:  DATA 4F,00
0201E:  DATA 00,00
02020:  DATA 28,6D
02022:  DATA 29,2C
02024:  DATA 25,33
02026:  DATA 2E,33
02028:  DATA 67,2C
0202A:  DATA 28,63
0202C:  DATA 29,2C
0202E:  DATA 25,33
02030:  DATA 2E,33
02032:  DATA 67,00
02034:  DATA 28,43
02036:  DATA 73,29
02038:  DATA 2C,25
0203A:  DATA 33,2E
0203C:  DATA 33,67
0203E:  DATA 0D,0A
02040:  DATA 00,00
02042:  DATA 40,43
02044:  DATA 4F,4E
02046:  DATA 2C,4E
02048:  DATA 4F,33
0204A:  DATA 2C,25
0204C:  DATA 73,0D
0204E:  DATA 0A,00
02050:  DATA 28,6D
02052:  DATA 29,2C
02054:  DATA 25,33
02056:  DATA 2E,33
02058:  DATA 67,2C
0205A:  DATA 28,63
0205C:  DATA 29,2C
0205E:  DATA 25,33
02060:  DATA 2E,33
02062:  DATA 67,00
02064:  DATA 28,43
02066:  DATA 73,29
02068:  DATA 2C,25
0206A:  DATA 33,2E
0206C:  DATA 33,67
0206E:  DATA 0D,0A
02070:  DATA 00,00
02072:  DATA 40,43
02074:  DATA 4F,4E
02076:  DATA 2C,50
02078:  DATA 4F,34
0207A:  DATA 2C,25
0207C:  DATA 73,0D
0207E:  DATA 0A,00
02080:  DATA 28,6D
02082:  DATA 29,2C
02084:  DATA 25,33
02086:  DATA 2E,33
02088:  DATA 67,2C
0208A:  DATA 28,63
0208C:  DATA 29,2C
0208E:  DATA 25,33
02090:  DATA 2E,33
02092:  DATA 67,00
02094:  DATA 28,43
02096:  DATA 73,29
02098:  DATA 2C,25
0209A:  DATA 33,2E
0209C:  DATA 33,67
0209E:  DATA 0D,0A
020A0:  DATA 00,00
020A2:  DATA 40,43
020A4:  DATA 4F,4E
020A6:  DATA 2C,4E
020A8:  DATA 48,34
020AA:  DATA 2C,25
020AC:  DATA 73,0D
020AE:  DATA 0A,00
020B0:  DATA 28,6D
020B2:  DATA 29,2C
020B4:  DATA 25,33
020B6:  DATA 2E,33
020B8:  DATA 67,2C
020BA:  DATA 28,63
020BC:  DATA 29,2C
020BE:  DATA 25,33
020C0:  DATA 2E,33
020C2:  DATA 67,00
020C4:  DATA 28,43
020C6:  DATA 73,29
020C8:  DATA 2C,25
020CA:  DATA 33,2E
020CC:  DATA 33,67
020CE:  DATA 0D,0A
020D0:  DATA 00,00
020D2:  DATA 40,43
020D4:  DATA 4F,4E
020D6:  DATA 2C,53
020D8:  DATA 69,4F
020DA:  DATA 2C,25
020DC:  DATA 73,0D
020DE:  DATA 0A,00
020E0:  DATA 4E,4F
020E2:  DATA 33,00
020E4:  DATA 50,4F
020E6:  DATA 34,00
020E8:  DATA 4E,48
020EA:  DATA 34,00
020EC:  DATA 53,69
020EE:  DATA 4F,00
020F0:  DATA 00,00
020F2:  DATA 4D,45
020F4:  DATA 4D,4F
020F6:  DATA 52,59
020F8:  DATA 20,4F
020FA:  DATA 56,45
020FC:  DATA 52,46
020FE:  DATA 4C,4F
02100:  DATA 57,20
02102:  DATA 45,52
02104:  DATA 52,4F
02106:  DATA 52,20
02108:  DATA 40,20
0210A:  DATA 4C,69
0210C:  DATA 6E,65
0210E:  DATA 20,3A
02110:  DATA 25,4C
02112:  DATA 75,0A
02114:  DATA 0D,00
02116:  DATA 0D,0A
02118:  DATA 3A,00
0211A:  DATA 0D,0A
0211C:  DATA 57,41
0211E:  DATA 52,4E
02120:  DATA 49,4E
02122:  DATA 47,3A
02124:  DATA 20,49
02126:  DATA 4E,56
02128:  DATA 41,4C
0212A:  DATA 49,44
0212C:  DATA 20,43
0212E:  DATA 4F,4D
02130:  DATA 4D,41
02132:  DATA 4E,44
02134:  DATA 20,49
02136:  DATA 4E,20
02138:  DATA 4D,41
0213A:  DATA 43,52
0213C:  DATA 4F,21
0213E:  DATA 0D,0A
02140:  DATA 00,00
02142:  DATA 42,61
02144:  DATA 64,20
02146:  DATA 63,6F
02148:  DATA 6D,6D
0214A:  DATA 61,6E
0214C:  DATA 64,20
0214E:  DATA 61,74
02150:  DATA 20,6C
02152:  DATA 69,6E
02154:  DATA 65,3A
02156:  DATA 20,25
02158:  DATA 4C,64
0215A:  DATA 20,0D
0215C:  DATA 0A,00
0215E:  DATA 50,6C
02160:  DATA 65,61
02162:  DATA 73,65
02164:  DATA 20,72
02166:  DATA 65,2D
02168:  DATA 75,70
0216A:  DATA 6C,6F
0216C:  DATA 61,64
0216E:  DATA 20,6D
02170:  DATA 61,63
02172:  DATA 72,6F
02174:  DATA 00,00
02176:  DATA 49,74
02178:  DATA 65,72
0217A:  DATA 61,74
0217C:  DATA 69,6F
0217E:  DATA 6E,73
02180:  DATA 20,6C
02182:  DATA 65,66
02184:  DATA 74,3A
02186:  DATA 20,25
02188:  DATA 4C,75
0218A:  DATA 0D,0A
0218C:  DATA 00,00
0218E:  DATA 2C,6D
02190:  DATA 61,63
02192:  DATA 72,6F
02194:  DATA 5B,25
02196:  DATA 75,5D
02198:  DATA 2C,73
0219A:  DATA 74,61
0219C:  DATA 72,74
0219E:  DATA 0D,0A
021A0:  DATA 00,00
021A2:  DATA 40,4D
021A4:  DATA 43,4C
021A6:  DATA 5B,25
021A8:  DATA 63,5D
021AA:  DATA 5B,25
021AC:  DATA 4C,75
021AE:  DATA 5D,0D
021B0:  DATA 0A,00
021B2:  DATA 40,4C
021B4:  DATA 4E,45
021B6:  DATA 0D,0A
021B8:  DATA 00,00
021BA:  DATA 40,52
021BC:  DATA 55,4E
021BE:  DATA 0D,0A
021C0:  DATA 00,00
021C2:  DATA 40,42
021C4:  DATA 41,44
021C6:  DATA 0D,0A
021C8:  DATA 00,00
021CA:  DATA 40,54
021CC:  DATA 2F,4F
021CE:  DATA 0D,0A
021D0:  DATA 00,00
021D2:  DATA 40,45
021D4:  DATA 52,52
021D6:  DATA 0D,0A
021D8:  DATA 00,00
021DA:  DATA 40,45
021DC:  DATA 4E,44
021DE:  DATA 0D,0A
021E0:  DATA 00,00
021E2:  DATA 40,48
021E4:  DATA 4C,54
021E6:  DATA 0D,0A
021E8:  DATA 00,00
021EA:  DATA 2C,6D
021EC:  DATA 61,63
021EE:  DATA 72,6F
021F0:  DATA 5B,25
021F2:  DATA 75,5D
021F4:  DATA 2C,73
021F6:  DATA 74,61
021F8:  DATA 74,75
021FA:  DATA 73,5B
021FC:  DATA 25,63
021FE:  DATA 5D,2C
02200:  DATA 6C,69
02202:  DATA 6E,65
02204:  DATA 5B,25
02206:  DATA 4C,75
02208:  DATA 5D,0D
0220A:  DATA 0A,00
0220C:  DATA 40,52
0220E:  DATA 75,6E
02210:  DATA 6E,69
02212:  DATA 6E,67
02214:  DATA 20,25
02216:  DATA 63,25
02218:  DATA 4C,75
0221A:  DATA 20,0D
0221C:  DATA 0A,00
0221E:  DATA 40,4D
02220:  DATA 61,63
02222:  DATA 72,6F
02224:  DATA 20,25
02226:  DATA 30,34
02228:  DATA 4C,75
0222A:  DATA 20,6F
0222C:  DATA 66,20
0222E:  DATA 25,30
02230:  DATA 34,4C
02232:  DATA 75,0D
02234:  DATA 0A,00
02236:  DATA 40,4C
02238:  DATA 4E,45
0223A:  DATA 0D,0A
0223C:  DATA 00,00
0223E:  DATA 40,52
02240:  DATA 55,4E
02242:  DATA 0D,0A
02244:  DATA 00,00
02246:  DATA 40,42
02248:  DATA 41,44
0224A:  DATA 0D,0A
0224C:  DATA 00,00
0224E:  DATA 40,54
02250:  DATA 2F,4F
02252:  DATA 0D,0A
02254:  DATA 00,00
02256:  DATA 40,45
02258:  DATA 52,52
0225A:  DATA 0D,0A
0225C:  DATA 00,00
0225E:  DATA 40,45
02260:  DATA 4E,44
02262:  DATA 0D,0A
02264:  DATA 00,00
02266:  DATA 2C,61
02268:  DATA 75,74
0226A:  DATA 6F,2D
0226C:  DATA 73,61
0226E:  DATA 6D,70
02270:  DATA 6C,65
02272:  DATA 2C,73
02274:  DATA 61,6D
02276:  DATA 70,6C
02278:  DATA 65,5B
0227A:  DATA 25,4C
0227C:  DATA 75,5D
0227E:  DATA 2C,73
02280:  DATA 74,61
02282:  DATA 72,74
02284:  DATA 0D,0A
02286:  DATA 00,00
02288:  DATA 2C,61
0228A:  DATA 75,74
0228C:  DATA 6F,2D
0228E:  DATA 73,61
02290:  DATA 6D,70
02292:  DATA 6C,65
02294:  DATA 2C,73
02296:  DATA 61,6D
02298:  DATA 70,6C
0229A:  DATA 65,5B
0229C:  DATA 25,4C
0229E:  DATA 75,5D
022A0:  DATA 2C,63
022A2:  DATA 6F,6D
022A4:  DATA 70,6C
022A6:  DATA 65,74
022A8:  DATA 65,0D
022AA:  DATA 0A,00
022AC:  DATA 2C,61
022AE:  DATA 75,74
022B0:  DATA 6F,2D
022B2:  DATA 73,61
022B4:  DATA 6D,70
022B6:  DATA 6C,65
022B8:  DATA 2C,73
022BA:  DATA 61,6D
022BC:  DATA 70,6C
022BE:  DATA 65,5B
022C0:  DATA 25,4C
022C2:  DATA 75,5D
022C4:  DATA 2C,65
022C6:  DATA 72,72
022C8:  DATA 6F,72
022CA:  DATA 0D,0A
022CC:  DATA 00,00
022CE:  DATA 2C,61
022D0:  DATA 75,74
022D2:  DATA 6F,2D
022D4:  DATA 73,61
022D6:  DATA 6D,70
022D8:  DATA 6C,65
022DA:  DATA 2C,73
022DC:  DATA 61,6D
022DE:  DATA 70,6C
022E0:  DATA 65,5B
022E2:  DATA 25,4C
022E4:  DATA 75,5D
022E6:  DATA 2C,6D
022E8:  DATA 61,78
022EA:  DATA 20,73
022EC:  DATA 61,6D
022EE:  DATA 70,6C
022F0:  DATA 65,73
022F2:  DATA 0D,0A
022F4:  DATA 00,00
022F6:  DATA 2C,61
022F8:  DATA 75,74
022FA:  DATA 6F,2D
022FC:  DATA 73,61
022FE:  DATA 6D,70
02300:  DATA 6C,65
02302:  DATA 2C,73
02304:  DATA 61,6D
02306:  DATA 70,6C
02308:  DATA 65,5B
0230A:  DATA 25,4C
0230C:  DATA 75,5D
0230E:  DATA 2C,73
02310:  DATA 74,61
02312:  DATA 72,74
02314:  DATA 0D,0A
02316:  DATA 00,00
02318:  DATA 2C,61
0231A:  DATA 75,74
0231C:  DATA 6F,2D
0231E:  DATA 73,61
02320:  DATA 6D,70
02322:  DATA 6C,65
02324:  DATA 2C,73
02326:  DATA 61,6D
02328:  DATA 70,6C
0232A:  DATA 65,5B
0232C:  DATA 25,4C
0232E:  DATA 75,5D
02330:  DATA 2C,63
02332:  DATA 6F,6D
02334:  DATA 70,6C
02336:  DATA 65,74
02338:  DATA 65,0D
0233A:  DATA 0A,00
0233C:  DATA 2C,61
0233E:  DATA 75,74
02340:  DATA 6F,2D
02342:  DATA 73,61
02344:  DATA 6D,70
02346:  DATA 6C,65
02348:  DATA 2C,73
0234A:  DATA 61,6D
0234C:  DATA 70,6C
0234E:  DATA 65,5B
02350:  DATA 25,4C
02352:  DATA 75,5D
02354:  DATA 2C,73
02356:  DATA 74,61
02358:  DATA 72,74
0235A:  DATA 0D,0A
0235C:  DATA 00,00
0235E:  DATA 2C,61
02360:  DATA 75,74
02362:  DATA 6F,2D
02364:  DATA 73,61
02366:  DATA 6D,70
02368:  DATA 6C,65
0236A:  DATA 2C,73
0236C:  DATA 61,6D
0236E:  DATA 70,6C
02370:  DATA 65,5B
02372:  DATA 25,4C
02374:  DATA 75,5D
02376:  DATA 2C,63
02378:  DATA 6F,6D
0237A:  DATA 70,6C
0237C:  DATA 65,74
0237E:  DATA 65,0D
02380:  DATA 0A,00
02382:  DATA 2C,61
02384:  DATA 75,74
02386:  DATA 6F,2D
02388:  DATA 73,61
0238A:  DATA 6D,70
0238C:  DATA 6C,65
0238E:  DATA 2C,73
02390:  DATA 61,6D
02392:  DATA 70,6C
02394:  DATA 65,5B
02396:  DATA 25,4C
02398:  DATA 75,5D
0239A:  DATA 2C,6D
0239C:  DATA 61,78
0239E:  DATA 20,73
023A0:  DATA 61,6D
023A2:  DATA 70,6C
023A4:  DATA 65,73
023A6:  DATA 0D,0A
023A8:  DATA 00,00
023AA:  DATA 2C,61
023AC:  DATA 75,74
023AE:  DATA 6F,2D
023B0:  DATA 73,61
023B2:  DATA 6D,70
023B4:  DATA 6C,65
023B6:  DATA 2C,69
023B8:  DATA 6E,69
023BA:  DATA 74,69
023BC:  DATA 61,6C
023BE:  DATA 69,7A
023C0:  DATA 65,0D
023C2:  DATA 0A,00
023C4:  DATA 2C,68
023C6:  DATA 65,61
023C8:  DATA 64,65
023CA:  DATA 72,2C
023CC:  DATA 69,64
023CE:  DATA 23,5B
023D0:  DATA 25,4C
023D2:  DATA 75,5D
023D4:  DATA 2C,69
023D6:  DATA 6E,74
023D8:  DATA 5B,25
023DA:  DATA 4C,75
023DC:  DATA 5D,2C
023DE:  DATA 6D,61
023E0:  DATA 78,5B
023E2:  DATA 25,4C
023E4:  DATA 75,5D
023E6:  DATA 0D,0A
023E8:  DATA 00,00
023EA:  DATA 2C,61
023EC:  DATA 75,74
023EE:  DATA 6F,2D
023F0:  DATA 73,61
023F2:  DATA 6D,70
023F4:  DATA 6C,65
023F6:  DATA 2C,73
023F8:  DATA 61,6D
023FA:  DATA 70,6C
023FC:  DATA 65,5B
023FE:  DATA 25,4C
02400:  DATA 75,5D
02402:  DATA 2C,61
02404:  DATA 6C,61
02406:  DATA 72,6D
02408:  DATA 5B,25
0240A:  DATA 75,5D
0240C:  DATA 0D,0A
0240E:  DATA 00,00
02410:  DATA 2C,61
02412:  DATA 75,74
02414:  DATA 6F,2D
02416:  DATA 73,61
02418:  DATA 6D,70
0241A:  DATA 6C,65
0241C:  DATA 2C,73
0241E:  DATA 6C,65
02420:  DATA 65,70
02422:  DATA 0D,0A
02424:  DATA 00,00
02426:  DATA 74,31
02428:  DATA 3A,25
0242A:  DATA 4C,75
0242C:  DATA 20,74
0242E:  DATA 32,3A
02430:  DATA 25,4C
02432:  DATA 75,0D
02434:  DATA 0A,00
02436:  DATA 40,44
02438:  DATA 45,54
0243A:  DATA 2C,25
0243C:  DATA 4C,75
0243E:  DATA 0D,0A
02440:  DATA 00,00
02442:  DATA 4E,4F
02444:  DATA 33,2C
02446:  DATA 25,31
02448:  DATA 2E,35
0244A:  DATA 67,2C
0244C:  DATA 25,31
0244E:  DATA 2E,35
02450:  DATA 67,0D
02452:  DATA 0A,00
02454:  DATA 50,4F
02456:  DATA 34,2C
02458:  DATA 25,31
0245A:  DATA 2E,35
0245C:  DATA 67,2C
0245E:  DATA 25,31
02460:  DATA 2E,35
02462:  DATA 67,0D
02464:  DATA 0A,00
02466:  DATA 4E,48
02468:  DATA 34,2C
0246A:  DATA 25,31
0246C:  DATA 2E,35
0246E:  DATA 67,2C
02470:  DATA 25,31
02472:  DATA 2E,35
02474:  DATA 67,0D
02476:  DATA 0A,00
02478:  DATA 53,69
0247A:  DATA 4F,34
0247C:  DATA 2C,25
0247E:  DATA 31,2E
02480:  DATA 35,67
02482:  DATA 2C,25
02484:  DATA 31,2E
02486:  DATA 35,67
02488:  DATA 0D,0A
0248A:  DATA 00,00
0248C:  DATA 4E,4F
0248E:  DATA 33,28
02490:  DATA 6D,29
02492:  DATA 3A,00
02494:  DATA 4E,4F
02496:  DATA 33,28
02498:  DATA 63,29
0249A:  DATA 3A,00
0249C:  DATA 50,4F
0249E:  DATA 34,28
024A0:  DATA 6D,29
024A2:  DATA 3A,00
024A4:  DATA 50,4F
024A6:  DATA 34,28
024A8:  DATA 63,29
024AA:  DATA 3A,00
024AC:  DATA 4E,48
024AE:  DATA 34,28
024B0:  DATA 6D,29
024B2:  DATA 3A,00
024B4:  DATA 4E,48
024B6:  DATA 34,28
024B8:  DATA 63,29
024BA:  DATA 3A,00
024BC:  DATA 53,69
024BE:  DATA 4F,34
024C0:  DATA 28,6D
024C2:  DATA 29,3A
024C4:  DATA 00,00
024C6:  DATA 53,69
024C8:  DATA 4F,34
024CA:  DATA 28,63
024CC:  DATA 29,3A
024CE:  DATA 00,00
024D0:  DATA 41,72
024D2:  DATA 65,20
024D4:  DATA 79,6F
024D6:  DATA 75,20
024D8:  DATA 73,75
024DA:  DATA 72,65
024DC:  DATA 20,79
024DE:  DATA 6F,75
024E0:  DATA 20,77
024E2:  DATA 61,6E
024E4:  DATA 74,20
024E6:  DATA 74,6F
024E8:  DATA 20,65
024EA:  DATA 72,61
024EC:  DATA 73,65
024EE:  DATA 20,74
024F0:  DATA 68,65
024F2:  DATA 20,72
024F4:  DATA 61,77
024F6:  DATA 20,64
024F8:  DATA 61,74
024FA:  DATA 61,20
024FC:  DATA 66,69
024FE:  DATA 6C,65
02500:  DATA 3F,20
02502:  DATA 59,20
02504:  DATA 6F,72
02506:  DATA 20,4E
02508:  DATA 21,0D
0250A:  DATA 0A,00
0250C:  DATA 46,69
0250E:  DATA 6C,65
02510:  DATA 20,64
02512:  DATA 65,6C
02514:  DATA 65,74
02516:  DATA 65,64
02518:  DATA 21,0A
0251A:  DATA 0D,00
0251C:  DATA 4F,70
0251E:  DATA 65,72
02520:  DATA 61,74
02522:  DATA 69,6F
02524:  DATA 6E,20
02526:  DATA 63,61
02528:  DATA 6E,63
0252A:  DATA 65,6C
0252C:  DATA 65,64
0252E:  DATA 21,0D
02530:  DATA 0A,00
02532:  DATA 41,72
02534:  DATA 65,20
02536:  DATA 79,6F
02538:  DATA 75,20
0253A:  DATA 73,75
0253C:  DATA 72,65
0253E:  DATA 20,79
02540:  DATA 6F,75
02542:  DATA 20,77
02544:  DATA 61,6E
02546:  DATA 74,20
02548:  DATA 74,6F
0254A:  DATA 20,65
0254C:  DATA 72,61
0254E:  DATA 73,65
02550:  DATA 20,74
02552:  DATA 68,65
02554:  DATA 20,63
02556:  DATA 61,6C
02558:  DATA 63,75
0255A:  DATA 6C,61
0255C:  DATA 74,65
0255E:  DATA 64,20
02560:  DATA 64,61
02562:  DATA 74,61
02564:  DATA 20,66
02566:  DATA 69,6C
02568:  DATA 65,3F
0256A:  DATA 20,59
0256C:  DATA 20,6F
0256E:  DATA 72,20
02570:  DATA 4E,21
02572:  DATA 0D,0A
02574:  DATA 00,00
02576:  DATA 46,69
02578:  DATA 6C,65
0257A:  DATA 20,64
0257C:  DATA 65,6C
0257E:  DATA 65,74
02580:  DATA 65,64
02582:  DATA 21,0A
02584:  DATA 0D,00
02586:  DATA 4F,70
02588:  DATA 65,72
0258A:  DATA 61,74
0258C:  DATA 69,6F
0258E:  DATA 6E,20
02590:  DATA 63,61
02592:  DATA 6E,63
02594:  DATA 65,6C
02596:  DATA 65,64
02598:  DATA 21,0D
0259A:  DATA 0A,00
0259C:  DATA 40,49
0259E:  DATA 44,23
025A0:  DATA 25,4C
025A2:  DATA 75,20
025A4:  DATA 49,25
025A6:  DATA 4C,75
025A8:  DATA 20,4E
025AA:  DATA 25,4C
025AC:  DATA 75,2F
025AE:  DATA 25,4C
025B0:  DATA 75,20
025B2:  DATA 58,25
025B4:  DATA 4C,75
025B6:  DATA 20,55
025B8:  DATA 25,75
025BA:  DATA 20,25
025BC:  DATA 34,2E
025BE:  DATA 32,77
025C0:  DATA 56,0D
025C2:  DATA 0A,00
025C4:  DATA 40,4D
025C6:  DATA 4F,54
025C8:  DATA 3A,56
025CA:  DATA 41,4C
025CC:  DATA 3D,25
025CE:  DATA 4C,75
025D0:  DATA 20,53
025D2:  DATA 59,52
025D4:  DATA 3D,25
025D6:  DATA 4C,64
025D8:  DATA 0D,0A
025DA:  DATA 00,00
025DC:  DATA 40,50
025DE:  DATA 57,52
025E0:  DATA 3A,25
025E2:  DATA 30,32
025E4:  DATA 75,2F
025E6:  DATA 25,30
025E8:  DATA 32,75
025EA:  DATA 2F,25
025EC:  DATA 30,32
025EE:  DATA 75,20
025F0:  DATA 25,30
025F2:  DATA 32,75
025F4:  DATA 3A,25
025F6:  DATA 30,32
025F8:  DATA 75,3A
025FA:  DATA 25,30
025FC:  DATA 32,75
025FE:  DATA 0D,0A
02600:  DATA 00,00
02602:  DATA 40,50
02604:  DATA 57,52
02606:  DATA 3A,25
02608:  DATA 30,32
0260A:  DATA 75,2F
0260C:  DATA 25,30
0260E:  DATA 32,75
02610:  DATA 2F,25
02612:  DATA 30,32
02614:  DATA 75,20
02616:  DATA 25,30
02618:  DATA 32,75
0261A:  DATA 3A,25
0261C:  DATA 30,32
0261E:  DATA 75,3A
02620:  DATA 25,30
02622:  DATA 32,75
02624:  DATA 0D,0A
02626:  DATA 00,00
02628:  DATA 41,25
0262A:  DATA 4C,75
0262C:  DATA 20,49
0262E:  DATA 25,4C
02630:  DATA 75,20
02632:  DATA 4C,25
02634:  DATA 4C,75
02636:  DATA 20,51
02638:  DATA 25,4C
0263A:  DATA 75,20
0263C:  DATA 53,25
0263E:  DATA 4C,75
02640:  DATA 20,25
02642:  DATA 34,2E
02644:  DATA 32,77
02646:  DATA 56,0D
02648:  DATA 0A,00
0264A:  DATA 40,4D
0264C:  DATA 4F,54
0264E:  DATA 3A,56
02650:  DATA 41,4C
02652:  DATA 3D,25
02654:  DATA 4C,75
02656:  DATA 20,53
02658:  DATA 59,52
0265A:  DATA 3D,25
0265C:  DATA 4C,64
0265E:  DATA 0D,0A
02660:  DATA 00,00
02662:  DATA 40,50
02664:  DATA 57,52
02666:  DATA 3A,25
02668:  DATA 30,32
0266A:  DATA 75,2F
0266C:  DATA 25,30
0266E:  DATA 32,75
02670:  DATA 2F,25
02672:  DATA 30,32
02674:  DATA 75,20
02676:  DATA 25,30
02678:  DATA 32,75
0267A:  DATA 3A,25
0267C:  DATA 30,32
0267E:  DATA 75,3A
02680:  DATA 25,30
02682:  DATA 32,75
02684:  DATA 0D,0A
02686:  DATA 00,00
02688:  DATA 49,25
0268A:  DATA 4C,75
0268C:  DATA 20,4E
0268E:  DATA 25,4C
02690:  DATA 75,2F
02692:  DATA 25,4C
02694:  DATA 75,20
02696:  DATA 50,25
02698:  DATA 4C,75
0269A:  DATA 20,25
0269C:  DATA 34,2E
0269E:  DATA 32,77
026A0:  DATA 56,0D
026A2:  DATA 0A,00
026A4:  DATA 40,4D
026A6:  DATA 4F,54
026A8:  DATA 3A,53
026AA:  DATA 59,52
026AC:  DATA 3D,25
026AE:  DATA 4C,64
026B0:  DATA 0D,0A
026B2:  DATA 00,00
026B4:  DATA 40,50
026B6:  DATA 57,52
026B8:  DATA 3A,25
026BA:  DATA 30,32
026BC:  DATA 75,2F
026BE:  DATA 25,30
026C0:  DATA 32,75
026C2:  DATA 2F,25
026C4:  DATA 30,32
026C6:  DATA 75,20
026C8:  DATA 25,30
026CA:  DATA 32,75
026CC:  DATA 3A,25
026CE:  DATA 30,32
026D0:  DATA 75,3A
026D2:  DATA 25,30
026D4:  DATA 32,75
026D6:  DATA 0D,0A
026D8:  DATA 00,00
026DA:  DATA 40,53
026DC:  DATA 4D,50
026DE:  DATA 20,25
026E0:  DATA 30,34
026E2:  DATA 4C,75
026E4:  DATA 0D,0A
026E6:  DATA 00,00
026E8:  DATA 40,53
026EA:  DATA 4D,50
026EC:  DATA 20,25
026EE:  DATA 30,34
026F0:  DATA 4C,75
026F2:  DATA 0D,0A
026F4:  DATA 00,00
026F6:  DATA 45,6E
026F8:  DATA 74,65
026FA:  DATA 72,20
026FC:  DATA 64,61
026FE:  DATA 74,65
02700:  DATA 20,66
02702:  DATA 6F,72
02704:  DATA 6D,61
02706:  DATA 74,20
02708:  DATA 30,3D
0270A:  DATA 4D,4D
0270C:  DATA 2F,44
0270E:  DATA 44,2F
02710:  DATA 59,59
02712:  DATA 20,20
02714:  DATA 31,3D
02716:  DATA 44,44
02718:  DATA 2F,4D
0271A:  DATA 4D,2F
0271C:  DATA 59,59
0271E:  DATA 0D,0A
02720:  DATA 00,00
02722:  DATA 40,4F
02724:  DATA 4B,21
02726:  DATA 0D,0A
02728:  DATA 20,00
0272A:  DATA 40,45
0272C:  DATA 52,52
0272E:  DATA 0D,0A
02730:  DATA 00,00
02732:  DATA 40,52
02734:  DATA 55,4E
02736:  DATA 0D,0A
02738:  DATA 00,00
0273A:  DATA 5B,6D
0273C:  DATA 6F,74
0273E:  DATA 6F,72
02740:  DATA 3A,31
02742:  DATA 5D,0D
02744:  DATA 0A,00
02746:  DATA 5B,6D
02748:  DATA 6F,74
0274A:  DATA 6F,72
0274C:  DATA 3A,32
0274E:  DATA 5D,0D
02750:  DATA 0A,00
02752:  DATA 2C,45
02754:  DATA 43,4F
02756:  DATA 20,6D
02758:  DATA 6F,64
0275A:  DATA 65,20
0275C:  DATA 73,65
0275E:  DATA 74,0D
02760:  DATA 0A,00
02762:  DATA 2C,57
02764:  DATA 4D,53
02766:  DATA 2D,34
02768:  DATA 2D,53
0276A:  DATA 44,20
0276C:  DATA 6D,6F
0276E:  DATA 64,65
02770:  DATA 20,73
02772:  DATA 65,74
02774:  DATA 0D,0A
02776:  DATA 00,00
02778:  DATA 2C,41
0277A:  DATA 57,53
0277C:  DATA 20,6D
0277E:  DATA 6F,64
02780:  DATA 65,20
02782:  DATA 73,65
02784:  DATA 74,0D
02786:  DATA 0A,00
02788:  DATA 2C,57
0278A:  DATA 4D,53
0278C:  DATA 2D,34
0278E:  DATA 2D,51
02790:  DATA 45,20
02792:  DATA 6D,6F
02794:  DATA 64,65
02796:  DATA 20,73
02798:  DATA 65,74
0279A:  DATA 0D,0A
0279C:  DATA 00,00
0279E:  DATA 30,37
027A0:  DATA 2D,4A
027A2:  DATA 75,6C
027A4:  DATA 2D,31
027A6:  DATA 37,00
027A8:  DATA 31,33
027AA:  DATA 3A,31
027AC:  DATA 35,3A
027AE:  DATA 34,38
027B0:  DATA 00,00
027B2:  DATA 53,45
027B4:  DATA 4E,44
027B6:  DATA 20,48
027B8:  DATA 45,58
027BA:  DATA 20,46
027BC:  DATA 49,4C
027BE:  DATA 45,20
027C0:  DATA 28,31
027C2:  DATA 39,32
027C4:  DATA 30,30
027C6:  DATA 2C,4E
027C8:  DATA 38,31
027CA:  DATA 2C,58
027CC:  DATA 4F,4E
027CE:  DATA 2D,58
027D0:  DATA 4F,46
027D2:  DATA 46,29
027D4:  DATA 0D,0A
027D6:  DATA 00,00
027D8:  DATA 40,4F
027DA:  DATA 4B,21
027DC:  DATA 20,00
027DE:  DATA 40,41
027E0:  DATA 52,47
027E2:  DATA 20,00
027E4:  DATA 40,4F
027E6:  DATA 4B,21
027E8:  DATA 20,00
027EA:  DATA 40,41
027EC:  DATA 52,47
027EE:  DATA 20,00
027F0:  DATA 0D,0A
027F2:  DATA 40,49
027F4:  DATA 4E,56
027F6:  DATA 00,00
027F8:  DATA 0D,0A
027FA:  DATA 40,4F
027FC:  DATA 4B,21
027FE:  DATA 20,00
02800:  DATA 40,49
02802:  DATA 4E,56
02804:  DATA 00,00
02806:  DATA 40,43
02808:  DATA 4D,44
0280A:  DATA 00,00
0280C:  DATA 2C,63
0280E:  DATA 6F,6D
02810:  DATA 6D,61
02812:  DATA 6E,64
02814:  DATA 20,70
02816:  DATA 72,6F
02818:  DATA 6D,70
0281A:  DATA 74,0D
0281C:  DATA 0A,00
0281E:  DATA 20,20
02820:  DATA 20,20
02822:  DATA 20,20
02824:  DATA 20,20
02826:  DATA 20,20
02828:  DATA 20,20
0282A:  DATA 20,20
0282C:  DATA 20,20
0282E:  DATA 20,20
02830:  DATA 20,20
02832:  DATA 20,20
02834:  DATA 20,20
02836:  DATA 20,20
02838:  DATA 20,20
0283A:  DATA 20,20
0283C:  DATA 20,20
0283E:  DATA 20,20
02840:  DATA 20,20
02842:  DATA 20,20
02844:  DATA 20,00
02846:  DATA 0D,0A
02848:  DATA 40,41
0284A:  DATA 52,47
0284C:  DATA 20,00
0284E:  DATA 0D,0A
02850:  DATA 40,41
02852:  DATA 52,47
02854:  DATA 20,00
02856:  DATA 40,43
02858:  DATA 4D,44
0285A:  DATA 00,00
0285C:  DATA 2C,63
0285E:  DATA 6F,6D
02860:  DATA 6D,61
02862:  DATA 6E,64
02864:  DATA 20,70
02866:  DATA 72,6F
02868:  DATA 6D,70
0286A:  DATA 74,0D
0286C:  DATA 0A,00
0286E:  DATA 40,53
02870:  DATA 44,3D
02872:  DATA 25,4C
02874:  DATA 75,0D
02876:  DATA 0A,00
02878:  DATA 40,4D
0287A:  DATA 43,31
0287C:  DATA 2C,25
0287E:  DATA 4C,75
02880:  DATA 2C,25
02882:  DATA 4C,64
02884:  DATA 0D,0A
02886:  DATA 00,00
02888:  DATA 40,4D
0288A:  DATA 43,32
0288C:  DATA 2C,25
0288E:  DATA 4C,75
02890:  DATA 2C,25
02892:  DATA 4C,64
02894:  DATA 0D,0A
02896:  DATA 00,00
02898:  DATA 50,72
0289A:  DATA 65,73
0289C:  DATA 73,20
0289E:  DATA 61,6E
028A0:  DATA 64,20
028A2:  DATA 68,6F
028A4:  DATA 6C,64
028A6:  DATA 20,74
028A8:  DATA 68,65
028AA:  DATA 20,45
028AC:  DATA 73,63
028AE:  DATA 20,6B
028B0:  DATA 65,79
028B2:  DATA 20,74
028B4:  DATA 6F,20
028B6:  DATA 72,65
028B8:  DATA 74,75
028BA:  DATA 72,6E
028BC:  DATA 20,74
028BE:  DATA 6F,20
028C0:  DATA 43,6F
028C2:  DATA 6D,6D
028C4:  DATA 61,6E
028C6:  DATA 64,20
028C8:  DATA 4D,6F
028CA:  DATA 64,65
028CC:  DATA 0D,0A
028CE:  DATA 00,00
028D0:  DATA 52,65
028D2:  DATA 74,75
028D4:  DATA 72,6E
028D6:  DATA 69,6E
028D8:  DATA 67,20
028DA:  DATA 74,6F
028DC:  DATA 20,4C
028DE:  DATA 6F,67
028E0:  DATA 67,69
028E2:  DATA 6E,67
028E4:  DATA 20,4D
028E6:  DATA 6F,64
028E8:  DATA 65,0D
028EA:  DATA 0A,00
*
02CFC:  CLRF   01
02CFE:  CLRF   02
02D00:  CLRF   00
02D02:  CLRF   03
02D04:  MOVLB  8
02D06:  MOVF   xDE,W
02D08:  BNZ   2D0E
02D0A:  MOVF   xDD,W
02D0C:  BZ    2D3E
02D0E:  MOVLW  10
02D10:  MOVWF  xDF
02D12:  BCF    FD8.0
02D14:  RLCF   xDB,F
02D16:  RLCF   xDC,F
02D18:  RLCF   00,F
02D1A:  RLCF   03,F
02D1C:  MOVF   xDE,W
02D1E:  SUBWF  03,W
02D20:  BNZ   2D26
02D22:  MOVF   xDD,W
02D24:  SUBWF  00,W
02D26:  BNC   2D36
02D28:  MOVF   xDD,W
02D2A:  SUBWF  00,F
02D2C:  BTFSS  FD8.0
02D2E:  DECF   03,F
02D30:  MOVF   xDE,W
02D32:  SUBWF  03,F
02D34:  BSF    FD8.0
02D36:  RLCF   01,F
02D38:  RLCF   02,F
02D3A:  DECFSZ xDF,F
02D3C:  BRA    2D12
02D3E:  MOVLB  0
02D40:  RETURN 0
*
0354E:  TSTFSZ 01
03550:  BRA    3558
03552:  TSTFSZ 02
03554:  BRA    355A
03556:  BRA    3566
03558:  INCF   02,F
0355A:  MOVFF  00,FEE
0355E:  DECFSZ 01,F
03560:  BRA    355A
03562:  DECFSZ 02,F
03564:  BRA    355A
03566:  RETURN 0
*
03638:  MOVLB  9
0363A:  BTFSC  xED.7
0363C:  BRA    365E
0363E:  MOVLW  0F
03640:  MOVWF  00
03642:  SWAPF  xEC,W
03644:  ANDWF  00,F
03646:  MOVLW  0A
03648:  SUBWF  00,W
0364A:  BC    3652
0364C:  MOVLW  30
0364E:  ADDWF  00,F
03650:  BRA    3656
03652:  MOVF   xED,W
03654:  ADDWF  00,F
03656:  MOVF   00,W
03658:  BTFSS  F9E.4
0365A:  BRA    3658
0365C:  MOVWF  FAD
0365E:  MOVLW  0F
03660:  ANDWF  xEC,F
03662:  MOVLW  0A
03664:  SUBWF  xEC,W
03666:  BC    366C
03668:  MOVLW  30
0366A:  BRA    3670
0366C:  BCF    xED.7
0366E:  MOVF   xED,W
03670:  ADDWF  xEC,F
03672:  MOVF   xEC,W
03674:  BTFSS  F9E.4
03676:  BRA    3674
03678:  MOVWF  FAD
0367A:  MOVLB  0
0367C:  RETURN 0
*
04818:  MOVLB  9
0481A:  CLRF   xFE
0481C:  CLRF   xFF
0481E:  MOVLW  01
04820:  MOVLB  A
04822:  MOVWF  x00
04824:  CLRF   FDA
04826:  CLRF   FD9
04828:  MOVLW  09
0482A:  MOVWF  x03
0482C:  MOVLW  F6
0482E:  MOVWF  x02
04830:  MOVLW  09
04832:  MOVWF  FEA
04834:  MOVLW  FA
04836:  MOVWF  FE9
04838:  MOVFF  A03,FE2
0483C:  MOVFF  A02,FE1
04840:  MOVFF  A00,A01
04844:  BCF    FD8.0
04846:  MOVF   FE5,W
04848:  MULWF  FEE
0484A:  MOVF   FF3,W
0484C:  MOVLB  9
0484E:  ADDWFC xFE,F
04850:  MOVF   FF4,W
04852:  ADDWFC xFF,F
04854:  MOVLB  A
04856:  DECFSZ x01,F
04858:  BRA    4844
0485A:  MOVFF  9FE,FDE
0485E:  MOVFF  9FF,9FE
04862:  MOVLB  9
04864:  CLRF   xFF
04866:  BTFSC  FD8.0
04868:  INCF   xFF,F
0486A:  MOVLB  A
0486C:  INCF   x02,F
0486E:  BTFSC  FD8.2
04870:  INCF   x03,F
04872:  INCF   x00,F
04874:  MOVF   x00,W
04876:  SUBLW  05
04878:  BNZ   4830
0487A:  MOVLB  0
0487C:  RETURN 0
*
050C6:  MOVFF  1E,FEA
050CA:  MOVFF  1D,FE9
050CE:  MOVLB  8
050D0:  MOVFF  8FF,FEF
050D4:  INCF   FE9,F
050D6:  BTFSC  FD8.2
050D8:  INCF   FEA,F
050DA:  CLRF   FEF
050DC:  INCF   1D,F
050DE:  BTFSC  FD8.2
050E0:  INCF   1E,F
050E2:  MOVLB  0
050E4:  RETURN 0
050E6:  TBLRD*+
050E8:  MOVF   FF5,F
050EA:  BZ    510C
050EC:  MOVFF  FF6,8EB
050F0:  MOVFF  FF7,8EC
050F4:  MOVFF  FF8,8ED
050F8:  MOVFF  FF5,8FF
050FC:  RCALL  50C6
050FE:  MOVFF  8EB,FF6
05102:  MOVFF  8EC,FF7
05106:  MOVFF  8ED,FF8
0510A:  BRA    50E6
0510C:  RETURN 0
*
052A8:  MOVF   01,W
052AA:  CLRF   1B
052AC:  BTFSC  FF2.7
052AE:  BSF    1B.7
052B0:  BCF    FF2.7
052B2:  MOVFF  8ED,A42
052B6:  MOVLW  64
052B8:  MOVLB  A
052BA:  MOVWF  x43
052BC:  MOVLB  0
052BE:  CALL   0F9A
052C2:  BTFSC  1B.7
052C4:  BSF    FF2.7
052C6:  MOVFF  00,8ED
052CA:  MOVF   01,W
052CC:  MOVLW  30
052CE:  BNZ   52E0
052D0:  MOVLB  8
052D2:  BTFSS  xEE.1
052D4:  BRA    52F4
052D6:  BTFSC  xEE.3
052D8:  BRA    52F4
052DA:  BTFSC  xEE.4
052DC:  MOVLW  20
052DE:  BRA    52E8
052E0:  MOVLB  8
052E2:  BCF    xEE.3
052E4:  BCF    xEE.4
052E6:  BSF    xEE.0
052E8:  ADDWF  01,F
052EA:  MOVFF  01,8FF
052EE:  MOVLB  0
052F0:  RCALL  50C6
052F2:  MOVLB  8
052F4:  CLRF   1B
052F6:  BTFSC  FF2.7
052F8:  BSF    1B.7
052FA:  BCF    FF2.7
052FC:  MOVFF  8ED,A42
05300:  MOVLW  0A
05302:  MOVLB  A
05304:  MOVWF  x43
05306:  MOVLB  0
05308:  CALL   0F9A
0530C:  BTFSC  1B.7
0530E:  BSF    FF2.7
05310:  MOVFF  00,8ED
05314:  MOVF   01,W
05316:  MOVLW  30
05318:  BNZ   532A
0531A:  MOVLB  8
0531C:  BTFSC  xEE.3
0531E:  BRA    5334
05320:  BTFSS  xEE.0
05322:  BRA    5334
05324:  BTFSC  xEE.4
05326:  MOVLW  20
05328:  MOVLB  0
0532A:  ADDWF  01,F
0532C:  MOVFF  01,8FF
05330:  RCALL  50C6
05332:  MOVLB  8
05334:  MOVLW  30
05336:  ADDWF  xED,F
05338:  MOVFF  8ED,8FF
0533C:  MOVLB  0
0533E:  RCALL  50C6
05340:  RETURN 0
05342:  MOVF   FE9,W
05344:  MOVLB  8
05346:  MOVWF  xF2
05348:  MOVLW  3B
0534A:  MOVWF  xF9
0534C:  MOVLW  9A
0534E:  MOVWF  xF8
05350:  MOVLW  CA
05352:  MOVWF  xF7
05354:  CLRF   xF6
05356:  MOVLW  0A
05358:  MOVWF  xF4
0535A:  MOVF   xF1,W
0535C:  BTFSS  FD8.2
0535E:  DECF   xF2,F
05360:  BSF    FD8.1
05362:  MOVLW  08
05364:  MOVWF  FEA
05366:  MOVLW  ED
05368:  MOVWF  FE9
0536A:  CLRF   1B
0536C:  BTFSC  FF2.7
0536E:  BSF    1B.7
05370:  BCF    FF2.7
05372:  MOVFF  8F0,A4F
05376:  MOVFF  8EF,A4E
0537A:  MOVFF  8EE,A4D
0537E:  MOVFF  8ED,A4C
05382:  MOVFF  8F9,A53
05386:  MOVFF  8F8,A52
0538A:  MOVFF  8F7,A51
0538E:  MOVFF  8F6,A50
05392:  MOVLB  0
05394:  CALL   1076
05398:  BTFSC  1B.7
0539A:  BSF    FF2.7
0539C:  MOVF   01,W
0539E:  MOVF   00,F
053A0:  BNZ   53C8
053A2:  MOVLB  8
053A4:  INCF   xF1,W
053A6:  SUBWF  xF4,W
053A8:  BTFSS  FD8.2
053AA:  BRA    53B0
053AC:  MOVLB  0
053AE:  BRA    53C8
053B0:  MOVF   xF2,W
053B2:  BZ    53CC
053B4:  ANDLW  0F
053B6:  SUBWF  xF4,W
053B8:  BZ    53BC
053BA:  BC    53F8
053BC:  BTFSC  xF2.7
053BE:  BRA    53F8
053C0:  BTFSC  xF2.6
053C2:  BRA    53CC
053C4:  MOVLW  20
053C6:  BRA    53EC
053C8:  MOVLB  8
053CA:  CLRF   xF2
053CC:  MOVF   xF1,W
053CE:  SUBWF  xF4,W
053D0:  BNZ   53EA
053D2:  MOVFF  00,8F2
053D6:  MOVLW  2E
053D8:  MOVWF  xFF
053DA:  MOVLB  0
053DC:  RCALL  50C6
053DE:  MOVLB  8
053E0:  MOVFF  8F2,00
053E4:  MOVLW  20
053E6:  ANDWF  xF2,F
053E8:  MOVLW  00
053EA:  MOVLW  30
053EC:  ADDWF  00,F
053EE:  MOVFF  00,8FF
053F2:  MOVLB  0
053F4:  RCALL  50C6
053F6:  MOVLB  8
053F8:  BCF    FD8.1
053FA:  CLRF   1B
053FC:  BTFSC  FF2.7
053FE:  BSF    1B.7
05400:  BCF    FF2.7
05402:  MOVFF  8F9,A4F
05406:  MOVFF  8F8,A4E
0540A:  MOVFF  8F7,A4D
0540E:  MOVFF  8F6,A4C
05412:  MOVLB  A
05414:  CLRF   x53
05416:  CLRF   x52
05418:  CLRF   x51
0541A:  MOVLW  0A
0541C:  MOVWF  x50
0541E:  MOVLB  0
05420:  CALL   1076
05424:  BTFSC  1B.7
05426:  BSF    FF2.7
05428:  MOVFF  03,8F9
0542C:  MOVFF  02,8F8
05430:  MOVFF  01,8F7
05434:  MOVFF  00,8F6
05438:  MOVLB  8
0543A:  DECFSZ xF4,F
0543C:  BRA    5360
0543E:  MOVLB  0
05440:  RETURN 0
*
05CC0:  MOVLB  A
05CC2:  MOVF   x10,W
05CC4:  MULWF  x12
05CC6:  MOVFF  FF3,01
05CCA:  MOVFF  FF4,00
05CCE:  MULWF  x13
05CD0:  MOVF   FF3,W
05CD2:  ADDWF  00,F
05CD4:  MOVF   x11,W
05CD6:  MULWF  x12
05CD8:  MOVF   FF3,W
05CDA:  ADDWFC 00,W
05CDC:  MOVWF  02
05CDE:  MOVLB  0
05CE0:  RETURN 0
*
079BE:  MOVF   FEF,F
079C0:  BZ    79E2
079C2:  MOVFF  FEA,9B1
079C6:  MOVFF  FE9,9B0
079CA:  MOVF   FEF,W
079CC:  BTFSS  F9E.4
079CE:  BRA    79CC
079D0:  MOVWF  FAD
079D2:  MOVFF  9B1,FEA
079D6:  MOVFF  9B0,FE9
079DA:  INCF   FE9,F
079DC:  BTFSC  FD8.2
079DE:  INCF   FEA,F
079E0:  BRA    79BE
079E2:  RETURN 0
*
0900C:  MOVFF  FEA,8F8
09010:  MOVFF  FE9,8F7
09014:  MOVLB  8
09016:  BTFSS  xF1.7
09018:  BRA    902A
0901A:  BSF    xF7.7
0901C:  BTFSS  xF7.4
0901E:  INCF   xF7,F
09020:  COMF   xF0,F
09022:  COMF   xF1,F
09024:  INCF   xF0,F
09026:  BTFSC  FD8.2
09028:  INCF   xF1,F
0902A:  SWAPF  xF1,W
0902C:  IORLW  F0
0902E:  MOVWF  xF3
09030:  ADDWF  xF3,F
09032:  ADDLW  E2
09034:  MOVWF  xF4
09036:  ADDLW  32
09038:  MOVWF  xF6
0903A:  MOVF   xF1,W
0903C:  ANDLW  0F
0903E:  ADDWF  xF4,F
09040:  ADDWF  xF4,F
09042:  ADDWF  xF6,F
09044:  ADDLW  E9
09046:  MOVWF  xF5
09048:  ADDWF  xF5,F
0904A:  ADDWF  xF5,F
0904C:  SWAPF  xF0,W
0904E:  ANDLW  0F
09050:  ADDWF  xF5,F
09052:  ADDWF  xF6,F
09054:  RLCF   xF5,F
09056:  RLCF   xF6,F
09058:  COMF   xF6,F
0905A:  RLCF   xF6,F
0905C:  MOVF   xF0,W
0905E:  ANDLW  0F
09060:  ADDWF  xF6,F
09062:  RLCF   xF3,F
09064:  MOVLW  07
09066:  MOVWF  xF2
09068:  MOVLW  0A
0906A:  DECF   xF5,F
0906C:  ADDWF  xF6,F
0906E:  BNC   906A
09070:  DECF   xF4,F
09072:  ADDWF  xF5,F
09074:  BNC   9070
09076:  DECF   xF3,F
09078:  ADDWF  xF4,F
0907A:  BNC   9076
0907C:  DECF   xF2,F
0907E:  ADDWF  xF3,F
09080:  BNC   907C
09082:  MOVLW  08
09084:  MOVWF  FEA
09086:  MOVLW  F2
09088:  MOVWF  FE9
0908A:  MOVLW  07
0908C:  ANDWF  xF7,W
0908E:  BCF    xF7.6
09090:  MOVF   FED,F
09092:  ANDWF  xF7,W
09094:  BNZ   90A4
09096:  BTFSC  xF7.4
09098:  MOVF   FEE,F
0909A:  BTFSC  xF7.4
0909C:  BRA    90A4
0909E:  MOVLW  20
090A0:  MOVWF  00
090A2:  BRA    90E6
090A4:  ADDWF  FE9,F
090A6:  MOVLW  00
090A8:  ADDWFC FEA,F
090AA:  MOVF   FE9,W
090AC:  SUBLW  F6
090AE:  BNZ   90B8
090B0:  MOVF   FEA,W
090B2:  SUBLW  08
090B4:  BNZ   90B8
090B6:  BSF    xF7.6
090B8:  MOVF   FEF,W
090BA:  MOVWF  00
090BC:  BNZ   90CE
090BE:  BTFSC  xF7.6
090C0:  BRA    90CE
090C2:  BTFSC  xF7.4
090C4:  BRA    90EE
090C6:  BTFSC  xF7.3
090C8:  BRA    90CE
090CA:  MOVLW  20
090CC:  BRA    90E4
090CE:  BTFSS  xF7.7
090D0:  BRA    90DE
090D2:  MOVLW  2D
090D4:  MOVWF  00
090D6:  MOVF   FED,W
090D8:  BCF    xF7.6
090DA:  BCF    xF7.7
090DC:  BRA    90E6
090DE:  BSF    xF7.3
090E0:  BCF    xF7.4
090E2:  MOVLW  30
090E4:  ADDWF  00,F
090E6:  MOVF   00,W
090E8:  BTFSS  F9E.4
090EA:  BRA    90E8
090EC:  MOVWF  FAD
090EE:  MOVF   FEE,W
090F0:  BTFSS  xF7.6
090F2:  BRA    90AA
090F4:  MOVLB  0
090F6:  RETURN 0
*
0958C:  MOVF   FE9,W
0958E:  MOVLB  8
09590:  MOVWF  xF6
09592:  BTFSS  xF5.7
09594:  BRA    95B0
09596:  DECF   xF6,F
09598:  BSF    xF6.5
0959A:  COMF   xF2,F
0959C:  COMF   xF3,F
0959E:  COMF   xF4,F
095A0:  COMF   xF5,F
095A2:  INCF   xF2,F
095A4:  BTFSC  FD8.2
095A6:  INCF   xF3,F
095A8:  BTFSC  FD8.2
095AA:  INCF   xF4,F
095AC:  BTFSC  FD8.2
095AE:  INCF   xF5,F
095B0:  MOVLW  3B
095B2:  MOVWF  xFD
095B4:  MOVLW  9A
095B6:  MOVWF  xFC
095B8:  MOVLW  CA
095BA:  MOVWF  xFB
095BC:  CLRF   xFA
095BE:  MOVLW  0A
095C0:  MOVWF  xF8
095C2:  BSF    FD8.1
095C4:  MOVLW  08
095C6:  MOVWF  FEA
095C8:  MOVLW  F2
095CA:  MOVWF  FE9
095CC:  CLRF   1B
095CE:  BTFSC  FF2.7
095D0:  BSF    1B.7
095D2:  BCF    FF2.7
095D4:  MOVFF  8F5,A4F
095D8:  MOVFF  8F4,A4E
095DC:  MOVFF  8F3,A4D
095E0:  MOVFF  8F2,A4C
095E4:  MOVFF  8FD,A53
095E8:  MOVFF  8FC,A52
095EC:  MOVFF  8FB,A51
095F0:  MOVFF  8FA,A50
095F4:  MOVLB  0
095F6:  CALL   1076
095FA:  BTFSC  1B.7
095FC:  BSF    FF2.7
095FE:  MOVF   01,W
09600:  MOVF   00,F
09602:  BNZ   962A
09604:  MOVLB  8
09606:  MOVF   xF8,W
09608:  XORLW  01
0960A:  BTFSS  FD8.2
0960C:  BRA    9612
0960E:  MOVLB  0
09610:  BRA    962A
09612:  MOVF   xF6,W
09614:  BZ    9630
09616:  ANDLW  0F
09618:  SUBWF  xF8,W
0961A:  BZ    961E
0961C:  BC    966E
0961E:  BTFSC  xF6.7
09620:  BRA    966E
09622:  BTFSC  xF6.6
09624:  BRA    9630
09626:  MOVLW  20
09628:  BRA    9664
0962A:  MOVLW  20
0962C:  MOVLB  8
0962E:  ANDWF  xF6,F
09630:  BTFSS  xF6.5
09632:  BRA    9648
09634:  BCF    xF6.5
09636:  MOVFF  00,8F6
0963A:  MOVLW  2D
0963C:  BTFSS  F9E.4
0963E:  BRA    963C
09640:  MOVWF  FAD
09642:  MOVFF  8F6,00
09646:  CLRF   xF6
09648:  MOVLW  30
0964A:  BTFSS  xF6.5
0964C:  BRA    9664
0964E:  BCF    xF6.5
09650:  MOVFF  00,8F6
09654:  MOVLW  2D
09656:  BTFSS  F9E.4
09658:  BRA    9656
0965A:  MOVWF  FAD
0965C:  MOVFF  8F6,00
09660:  CLRF   xF6
09662:  MOVLW  30
09664:  ADDWF  00,F
09666:  MOVF   00,W
09668:  BTFSS  F9E.4
0966A:  BRA    9668
0966C:  MOVWF  FAD
0966E:  BCF    FD8.1
09670:  CLRF   1B
09672:  BTFSC  FF2.7
09674:  BSF    1B.7
09676:  BCF    FF2.7
09678:  MOVFF  8FD,A4F
0967C:  MOVFF  8FC,A4E
09680:  MOVFF  8FB,A4D
09684:  MOVFF  8FA,A4C
09688:  MOVLB  A
0968A:  CLRF   x53
0968C:  CLRF   x52
0968E:  CLRF   x51
09690:  MOVLW  0A
09692:  MOVWF  x50
09694:  MOVLB  0
09696:  CALL   1076
0969A:  BTFSC  1B.7
0969C:  BSF    FF2.7
0969E:  MOVFF  03,8FD
096A2:  MOVFF  02,8FC
096A6:  MOVFF  01,8FB
096AA:  MOVFF  00,8FA
096AE:  MOVLB  8
096B0:  DECFSZ xF8,F
096B2:  BRA    95C2
096B4:  MOVLB  0
096B6:  RETURN 0
*
0A780:  ADDWF  FE8,W
0A782:  CLRF   FF7
0A784:  RLCF   FF7,F
0A786:  ADDLW  A1
0A788:  MOVWF  FF6
0A78A:  MOVLW  A7
0A78C:  ADDWFC FF7,F
0A78E:  MOVLW  00
0A790:  MOVWF  FF8
0A792:  MOVWF  FFB
0A794:  TBLRD*-
0A796:  MOVF   FF5,W
0A798:  MOVWF  FFA
0A79A:  TBLRD*
0A79C:  MOVF   FF5,W
0A79E:  MOVWF  FF9
0A7A0:  DATA DC,A0
0A7A2:  DATA FC,A0
0A7A4:  DATA 24,A1
0A7A6:  DATA 54,A1
0A7A8:  DATA 7C,A1
*
0AAF4:  TBLRD*+
0AAF6:  MOVFF  FF6,8EC
0AAFA:  MOVFF  FF7,8ED
0AAFE:  MOVFF  FF8,8EE
0AB02:  MOVFF  FF5,8FF
0AB06:  CALL   50C6
0AB0A:  MOVFF  8EC,FF6
0AB0E:  MOVFF  8ED,FF7
0AB12:  MOVFF  8EE,FF8
0AB16:  MOVLB  8
0AB18:  DECFSZ xEB,F
0AB1A:  BRA    AB1E
0AB1C:  BRA    AB22
0AB1E:  MOVLB  0
0AB20:  BRA    AAF4
0AB22:  MOVLB  0
0AB24:  RETURN 0
0AB26:  MOVFF  FEA,8FE
0AB2A:  MOVFF  FE9,8FD
0AB2E:  MOVLB  8
0AB30:  SWAPF  xF7,W
0AB32:  IORLW  F0
0AB34:  MOVWF  xF9
0AB36:  ADDWF  xF9,F
0AB38:  ADDLW  E2
0AB3A:  MOVWF  xFA
0AB3C:  ADDLW  32
0AB3E:  MOVWF  xFC
0AB40:  MOVF   xF7,W
0AB42:  ANDLW  0F
0AB44:  ADDWF  xFA,F
0AB46:  ADDWF  xFA,F
0AB48:  ADDWF  xFC,F
0AB4A:  ADDLW  E9
0AB4C:  MOVWF  xFB
0AB4E:  ADDWF  xFB,F
0AB50:  ADDWF  xFB,F
0AB52:  SWAPF  xF6,W
0AB54:  ANDLW  0F
0AB56:  ADDWF  xFB,F
0AB58:  ADDWF  xFC,F
0AB5A:  RLCF   xFB,F
0AB5C:  RLCF   xFC,F
0AB5E:  COMF   xFC,F
0AB60:  RLCF   xFC,F
0AB62:  MOVF   xF6,W
0AB64:  ANDLW  0F
0AB66:  ADDWF  xFC,F
0AB68:  RLCF   xF9,F
0AB6A:  MOVLW  07
0AB6C:  MOVWF  xF8
0AB6E:  MOVLW  0A
0AB70:  DECF   xFB,F
0AB72:  ADDWF  xFC,F
0AB74:  BNC   AB70
0AB76:  DECF   xFA,F
0AB78:  ADDWF  xFB,F
0AB7A:  BNC   AB76
0AB7C:  DECF   xF9,F
0AB7E:  ADDWF  xFA,F
0AB80:  BNC   AB7C
0AB82:  DECF   xF8,F
0AB84:  ADDWF  xF9,F
0AB86:  BNC   AB82
0AB88:  MOVLW  08
0AB8A:  MOVWF  FEA
0AB8C:  MOVLW  F8
0AB8E:  MOVWF  FE9
0AB90:  MOVLW  07
0AB92:  ANDWF  xFD,W
0AB94:  BCF    xFD.6
0AB96:  ADDWF  FE9,F
0AB98:  MOVLW  00
0AB9A:  ADDWFC FEA,F
0AB9C:  MOVF   FE9,W
0AB9E:  SUBLW  FC
0ABA0:  BNZ   ABAA
0ABA2:  MOVF   FEA,W
0ABA4:  SUBLW  08
0ABA6:  BNZ   ABAA
0ABA8:  BSF    xFD.6
0ABAA:  MOVF   FEF,W
0ABAC:  MOVWF  00
0ABAE:  BNZ   ABC0
0ABB0:  BTFSC  xFD.6
0ABB2:  BRA    ABC0
0ABB4:  BTFSC  xFD.4
0ABB6:  BRA    ABE4
0ABB8:  BTFSC  xFD.3
0ABBA:  BRA    ABC0
0ABBC:  MOVLW  20
0ABBE:  BRA    ABC6
0ABC0:  BSF    xFD.3
0ABC2:  BCF    xFD.4
0ABC4:  MOVLW  30
0ABC6:  ADDWF  00,F
0ABC8:  MOVFF  FEA,8F7
0ABCC:  MOVFF  FE9,8F6
0ABD0:  MOVFF  00,8FF
0ABD4:  MOVLB  0
0ABD6:  CALL   50C6
0ABDA:  MOVFF  8F7,FEA
0ABDE:  MOVFF  8F6,FE9
0ABE2:  MOVLB  8
0ABE4:  MOVF   FEE,W
0ABE6:  BTFSS  xFD.6
0ABE8:  BRA    AB9C
0ABEA:  MOVLB  0
0ABEC:  RETURN 0
*
0AE14:  ADDWF  FE8,W
0AE16:  CLRF   FF7
0AE18:  RLCF   FF7,F
0AE1A:  ADDLW  35
0AE1C:  MOVWF  FF6
0AE1E:  MOVLW  AE
0AE20:  ADDWFC FF7,F
0AE22:  MOVLW  00
0AE24:  MOVWF  FF8
0AE26:  MOVWF  FFB
0AE28:  TBLRD*-
0AE2A:  MOVF   FF5,W
0AE2C:  MOVWF  FFA
0AE2E:  TBLRD*
0AE30:  MOVF   FF5,W
0AE32:  MOVWF  FF9
0AE34:  DATA E8,AC
0AE36:  DATA 10,AE
0AE38:  DATA 10,AE
0AE3A:  DATA 48,AC
0AE3C:  DATA 10,AE
0AE3E:  DATA 10,AE
0AE40:  DATA 10,AE
0AE42:  DATA 0C,AC
0AE44:  DATA 10,AE
0AE46:  DATA 10,AE
0AE48:  DATA 10,AE
0AE4A:  DATA 5E,AD
0AE4C:  DATA 84,AC
0AE4E:  DATA 10,AE
0AE50:  DATA 22,AD
0AE52:  DATA B8,AD
*
0AEAE:  TBLRD*+
0AEB0:  MOVF   FF5,F
0AEB2:  BZ    AED6
0AEB4:  MOVFF  FF6,885
0AEB8:  MOVFF  FF7,886
0AEBC:  MOVFF  FF8,887
0AEC0:  MOVF   FF5,W
0AEC2:  BTFSS  F9E.4
0AEC4:  BRA    AEC2
0AEC6:  MOVWF  FAD
0AEC8:  MOVFF  885,FF6
0AECC:  MOVFF  886,FF7
0AED0:  MOVFF  887,FF8
0AED4:  BRA    AEAE
0AED6:  RETURN 0
*
0C2EC:  MOVLB  9
0C2EE:  MOVF   x13,W
0C2F0:  BTFSC  FD8.2
0C2F2:  BRA    C3D6
0C2F4:  MOVWF  00
0C2F6:  MOVF   x17,W
0C2F8:  BTFSC  FD8.2
0C2FA:  BRA    C3D6
0C2FC:  ADDWF  00,F
0C2FE:  BNC   C308
0C300:  MOVLW  81
0C302:  ADDWF  00,F
0C304:  BC    C3D6
0C306:  BRA    C310
0C308:  MOVLW  7F
0C30A:  SUBWF  00,F
0C30C:  BNC   C3D6
0C30E:  BZ    C3D6
0C310:  MOVFF  914,91B
0C314:  MOVF   x18,W
0C316:  XORWF  x1B,F
0C318:  BSF    x14.7
0C31A:  BSF    x18.7
0C31C:  MOVF   x16,W
0C31E:  MULWF  x1A
0C320:  MOVFF  FF4,91D
0C324:  MOVF   x15,W
0C326:  MULWF  x19
0C328:  MOVFF  FF4,03
0C32C:  MOVFF  FF3,91C
0C330:  MULWF  x1A
0C332:  MOVF   FF3,W
0C334:  ADDWF  x1D,F
0C336:  MOVF   FF4,W
0C338:  ADDWFC x1C,F
0C33A:  MOVLW  00
0C33C:  ADDWFC 03,F
0C33E:  MOVF   x16,W
0C340:  MULWF  x19
0C342:  MOVF   FF3,W
0C344:  ADDWF  x1D,F
0C346:  MOVF   FF4,W
0C348:  ADDWFC x1C,F
0C34A:  MOVLW  00
0C34C:  CLRF   02
0C34E:  ADDWFC 03,F
0C350:  ADDWFC 02,F
0C352:  MOVF   x14,W
0C354:  MULWF  x1A
0C356:  MOVF   FF3,W
0C358:  ADDWF  x1C,F
0C35A:  MOVF   FF4,W
0C35C:  ADDWFC 03,F
0C35E:  MOVLW  00
0C360:  ADDWFC 02,F
0C362:  MOVF   x14,W
0C364:  MULWF  x19
0C366:  MOVF   FF3,W
0C368:  ADDWF  03,F
0C36A:  MOVF   FF4,W
0C36C:  ADDWFC 02,F
0C36E:  MOVLW  00
0C370:  CLRF   01
0C372:  ADDWFC 01,F
0C374:  MOVF   x16,W
0C376:  MULWF  x18
0C378:  MOVF   FF3,W
0C37A:  ADDWF  x1C,F
0C37C:  MOVF   FF4,W
0C37E:  ADDWFC 03,F
0C380:  MOVLW  00
0C382:  ADDWFC 02,F
0C384:  ADDWFC 01,F
0C386:  MOVF   x15,W
0C388:  MULWF  x18
0C38A:  MOVF   FF3,W
0C38C:  ADDWF  03,F
0C38E:  MOVF   FF4,W
0C390:  ADDWFC 02,F
0C392:  MOVLW  00
0C394:  ADDWFC 01,F
0C396:  MOVF   x14,W
0C398:  MULWF  x18
0C39A:  MOVF   FF3,W
0C39C:  ADDWF  02,F
0C39E:  MOVF   FF4,W
0C3A0:  ADDWFC 01,F
0C3A2:  INCF   00,F
0C3A4:  BTFSC  01.7
0C3A6:  BRA    C3B2
0C3A8:  RLCF   x1C,F
0C3AA:  RLCF   03,F
0C3AC:  RLCF   02,F
0C3AE:  RLCF   01,F
0C3B0:  DECF   00,F
0C3B2:  MOVLW  00
0C3B4:  BTFSS  x1C.7
0C3B6:  BRA    C3CC
0C3B8:  INCF   03,F
0C3BA:  ADDWFC 02,F
0C3BC:  ADDWFC 01,F
0C3BE:  MOVF   01,W
0C3C0:  BNZ   C3CC
0C3C2:  MOVF   02,W
0C3C4:  BNZ   C3CC
0C3C6:  MOVF   03,W
0C3C8:  BNZ   C3CC
0C3CA:  INCF   00,F
0C3CC:  BTFSC  x1B.7
0C3CE:  BSF    01.7
0C3D0:  BTFSS  x1B.7
0C3D2:  BCF    01.7
0C3D4:  BRA    C3DE
0C3D6:  CLRF   00
0C3D8:  CLRF   01
0C3DA:  CLRF   02
0C3DC:  CLRF   03
0C3DE:  MOVLB  0
0C3E0:  RETURN 0
0C3E2:  MOVLW  80
0C3E4:  BTFSS  FD8.1
0C3E6:  BRA    C3EC
0C3E8:  MOVLB  9
0C3EA:  XORWF  x1C,F
0C3EC:  MOVLB  9
0C3EE:  CLRF   x21
0C3F0:  CLRF   x22
0C3F2:  MOVFF  918,920
0C3F6:  MOVF   x1C,W
0C3F8:  XORWF  x20,F
0C3FA:  MOVF   x17,W
0C3FC:  BTFSC  FD8.2
0C3FE:  BRA    C5BE
0C400:  MOVWF  x1F
0C402:  MOVWF  00
0C404:  MOVF   x1B,W
0C406:  BTFSC  FD8.2
0C408:  BRA    C5D0
0C40A:  SUBWF  x1F,F
0C40C:  BTFSC  FD8.2
0C40E:  BRA    C516
0C410:  BNC   C48E
0C412:  MOVFF  91C,925
0C416:  BSF    x25.7
0C418:  MOVFF  91D,924
0C41C:  MOVFF  91E,923
0C420:  CLRF   x22
0C422:  BCF    FD8.0
0C424:  RRCF   x25,F
0C426:  RRCF   x24,F
0C428:  RRCF   x23,F
0C42A:  RRCF   x22,F
0C42C:  DECFSZ x1F,F
0C42E:  BRA    C420
0C430:  BTFSS  x20.7
0C432:  BRA    C43A
0C434:  BSF    x21.0
0C436:  BRA    C5F8
0C438:  BCF    x21.0
0C43A:  BCF    x1F.0
0C43C:  BSF    x21.4
0C43E:  MOVLW  09
0C440:  MOVWF  FEA
0C442:  MOVLW  1A
0C444:  MOVWF  FE9
0C446:  BRA    C61E
0C448:  BCF    x21.4
0C44A:  BTFSC  x20.7
0C44C:  BRA    C462
0C44E:  BTFSS  x1F.0
0C450:  BRA    C478
0C452:  RRCF   x25,F
0C454:  RRCF   x24,F
0C456:  RRCF   x23,F
0C458:  RRCF   x22,F
0C45A:  INCF   00,F
0C45C:  BTFSC  FD8.2
0C45E:  BRA    C5EE
0C460:  BRA    C478
0C462:  BTFSC  x25.7
0C464:  BRA    C47E
0C466:  BCF    FD8.0
0C468:  RLCF   x22,F
0C46A:  RLCF   x23,F
0C46C:  RLCF   x24,F
0C46E:  RLCF   x25,F
0C470:  DECF   00,F
0C472:  BTFSC  FD8.2
0C474:  BRA    C5EE
0C476:  BRA    C462
0C478:  BSF    x21.6
0C47A:  BRA    C556
0C47C:  BCF    x21.6
0C47E:  MOVFF  918,920
0C482:  BTFSS  x18.7
0C484:  BRA    C48A
0C486:  BSF    x25.7
0C488:  BRA    C5E0
0C48A:  BCF    x25.7
0C48C:  BRA    C5E0
0C48E:  MOVFF  91B,91F
0C492:  MOVFF  91B,00
0C496:  MOVF   x17,W
0C498:  SUBWF  x1F,F
0C49A:  MOVFF  918,925
0C49E:  BSF    x25.7
0C4A0:  MOVFF  919,924
0C4A4:  MOVFF  91A,923
0C4A8:  CLRF   x22
0C4AA:  BCF    FD8.0
0C4AC:  RRCF   x25,F
0C4AE:  RRCF   x24,F
0C4B0:  RRCF   x23,F
0C4B2:  RRCF   x22,F
0C4B4:  DECFSZ x1F,F
0C4B6:  BRA    C4A8
0C4B8:  BTFSS  x20.7
0C4BA:  BRA    C4C2
0C4BC:  BSF    x21.1
0C4BE:  BRA    C5F8
0C4C0:  BCF    x21.1
0C4C2:  BCF    x1F.0
0C4C4:  BSF    x21.5
0C4C6:  MOVLW  09
0C4C8:  MOVWF  FEA
0C4CA:  MOVLW  1E
0C4CC:  MOVWF  FE9
0C4CE:  BRA    C61E
0C4D0:  BCF    x21.5
0C4D2:  BTFSC  x20.7
0C4D4:  BRA    C4EA
0C4D6:  BTFSS  x1F.0
0C4D8:  BRA    C500
0C4DA:  RRCF   x25,F
0C4DC:  RRCF   x24,F
0C4DE:  RRCF   x23,F
0C4E0:  RRCF   x22,F
0C4E2:  INCF   00,F
0C4E4:  BTFSC  FD8.2
0C4E6:  BRA    C5EE
0C4E8:  BRA    C500
0C4EA:  BTFSC  x25.7
0C4EC:  BRA    C506
0C4EE:  BCF    FD8.0
0C4F0:  RLCF   x22,F
0C4F2:  RLCF   x23,F
0C4F4:  RLCF   x24,F
0C4F6:  RLCF   x25,F
0C4F8:  DECF   00,F
0C4FA:  BTFSC  FD8.2
0C4FC:  BRA    C5EE
0C4FE:  BRA    C4EA
0C500:  BSF    x21.7
0C502:  BRA    C556
0C504:  BCF    x21.7
0C506:  MOVFF  91C,920
0C50A:  BTFSS  x1C.7
0C50C:  BRA    C512
0C50E:  BSF    x25.7
0C510:  BRA    C5E0
0C512:  BCF    x25.7
0C514:  BRA    C5E0
0C516:  MOVFF  91C,925
0C51A:  BSF    x25.7
0C51C:  MOVFF  91D,924
0C520:  MOVFF  91E,923
0C524:  BTFSS  x20.7
0C526:  BRA    C530
0C528:  BCF    x25.7
0C52A:  BSF    x21.2
0C52C:  BRA    C5F8
0C52E:  BCF    x21.2
0C530:  CLRF   x22
0C532:  BCF    x1F.0
0C534:  MOVLW  09
0C536:  MOVWF  FEA
0C538:  MOVLW  1A
0C53A:  MOVWF  FE9
0C53C:  BRA    C61E
0C53E:  BTFSC  x20.7
0C540:  BRA    C57A
0C542:  MOVFF  918,920
0C546:  BTFSS  x1F.0
0C548:  BRA    C556
0C54A:  RRCF   x25,F
0C54C:  RRCF   x24,F
0C54E:  RRCF   x23,F
0C550:  RRCF   x22,F
0C552:  INCF   00,F
0C554:  BZ    C5EE
0C556:  BTFSS  x22.7
0C558:  BRA    C570
0C55A:  INCF   x23,F
0C55C:  BNZ   C570
0C55E:  INCF   x24,F
0C560:  BNZ   C570
0C562:  INCF   x25,F
0C564:  BNZ   C570
0C566:  RRCF   x25,F
0C568:  RRCF   x24,F
0C56A:  RRCF   x23,F
0C56C:  INCF   00,F
0C56E:  BZ    C5EE
0C570:  BTFSC  x21.6
0C572:  BRA    C47C
0C574:  BTFSC  x21.7
0C576:  BRA    C504
0C578:  BRA    C5B2
0C57A:  MOVLW  80
0C57C:  XORWF  x25,F
0C57E:  BTFSS  x25.7
0C580:  BRA    C58A
0C582:  BRA    C5F8
0C584:  MOVFF  91C,920
0C588:  BRA    C59E
0C58A:  MOVFF  918,920
0C58E:  MOVF   x25,F
0C590:  BNZ   C59E
0C592:  MOVF   x24,F
0C594:  BNZ   C59E
0C596:  MOVF   x23,F
0C598:  BNZ   C59E
0C59A:  CLRF   00
0C59C:  BRA    C5E0
0C59E:  BTFSC  x25.7
0C5A0:  BRA    C5B2
0C5A2:  BCF    FD8.0
0C5A4:  RLCF   x22,F
0C5A6:  RLCF   x23,F
0C5A8:  RLCF   x24,F
0C5AA:  RLCF   x25,F
0C5AC:  DECFSZ 00,F
0C5AE:  BRA    C59E
0C5B0:  BRA    C5EE
0C5B2:  BTFSS  x20.7
0C5B4:  BRA    C5BA
0C5B6:  BSF    x25.7
0C5B8:  BRA    C5E0
0C5BA:  BCF    x25.7
0C5BC:  BRA    C5E0
0C5BE:  MOVFF  91B,00
0C5C2:  MOVFF  91C,925
0C5C6:  MOVFF  91D,924
0C5CA:  MOVFF  91E,923
0C5CE:  BRA    C5E0
0C5D0:  MOVFF  917,00
0C5D4:  MOVFF  918,925
0C5D8:  MOVFF  919,924
0C5DC:  MOVFF  91A,923
0C5E0:  MOVFF  925,01
0C5E4:  MOVFF  924,02
0C5E8:  MOVFF  923,03
0C5EC:  BRA    C656
0C5EE:  CLRF   00
0C5F0:  CLRF   01
0C5F2:  CLRF   02
0C5F4:  CLRF   03
0C5F6:  BRA    C656
0C5F8:  CLRF   x22
0C5FA:  COMF   x23,F
0C5FC:  COMF   x24,F
0C5FE:  COMF   x25,F
0C600:  COMF   x22,F
0C602:  INCF   x22,F
0C604:  BNZ   C610
0C606:  INCF   x23,F
0C608:  BNZ   C610
0C60A:  INCF   x24,F
0C60C:  BNZ   C610
0C60E:  INCF   x25,F
0C610:  BTFSC  x21.0
0C612:  BRA    C438
0C614:  BTFSC  x21.1
0C616:  BRA    C4C0
0C618:  BTFSC  x21.2
0C61A:  BRA    C52E
0C61C:  BRA    C584
0C61E:  MOVF   FEF,W
0C620:  ADDWF  x23,F
0C622:  BNC   C62E
0C624:  INCF   x24,F
0C626:  BNZ   C62E
0C628:  INCF   x25,F
0C62A:  BTFSC  FD8.2
0C62C:  BSF    x1F.0
0C62E:  MOVF   FED,F
0C630:  MOVF   FEF,W
0C632:  ADDWF  x24,F
0C634:  BNC   C63C
0C636:  INCF   x25,F
0C638:  BTFSC  FD8.2
0C63A:  BSF    x1F.0
0C63C:  MOVF   FED,F
0C63E:  MOVF   FEF,W
0C640:  BTFSC  FEF.7
0C642:  BRA    C646
0C644:  XORLW  80
0C646:  ADDWF  x25,F
0C648:  BTFSC  FD8.0
0C64A:  BSF    x1F.0
0C64C:  BTFSC  x21.4
0C64E:  BRA    C448
0C650:  BTFSC  x21.5
0C652:  BRA    C4D0
0C654:  BRA    C53E
0C656:  MOVLB  0
0C658:  RETURN 0
0C65A:  MOVLB  8
0C65C:  MOVF   xDC,W
0C65E:  SUBLW  B6
0C660:  MOVWF  xDC
0C662:  CLRF   03
0C664:  MOVFF  8DD,8E0
0C668:  BSF    xDD.7
0C66A:  BCF    FD8.0
0C66C:  RRCF   xDD,F
0C66E:  RRCF   xDE,F
0C670:  RRCF   xDF,F
0C672:  RRCF   03,F
0C674:  RRCF   02,F
0C676:  RRCF   01,F
0C678:  RRCF   00,F
0C67A:  DECFSZ xDC,F
0C67C:  BRA    C66A
0C67E:  BTFSS  xE0.7
0C680:  BRA    C698
0C682:  COMF   00,F
0C684:  COMF   01,F
0C686:  COMF   02,F
0C688:  COMF   03,F
0C68A:  INCF   00,F
0C68C:  BTFSC  FD8.2
0C68E:  INCF   01,F
0C690:  BTFSC  FD8.2
0C692:  INCF   02,F
0C694:  BTFSC  FD8.2
0C696:  INCF   03,F
0C698:  MOVLB  0
0C69A:  RETURN 0
0C69C:  MOVF   FE9,W
0C69E:  MOVLB  8
0C6A0:  MOVWF  x8A
0C6A2:  MOVF   x89,W
0C6A4:  MOVWF  x8C
0C6A6:  BZ    C6E0
0C6A8:  MOVFF  888,916
0C6AC:  MOVFF  887,915
0C6B0:  MOVFF  886,914
0C6B4:  MOVFF  885,913
0C6B8:  MOVLB  9
0C6BA:  CLRF   x1A
0C6BC:  CLRF   x19
0C6BE:  MOVLW  20
0C6C0:  MOVWF  x18
0C6C2:  MOVLW  82
0C6C4:  MOVWF  x17
0C6C6:  MOVLB  0
0C6C8:  RCALL  C2EC
0C6CA:  MOVFF  03,888
0C6CE:  MOVFF  02,887
0C6D2:  MOVFF  01,886
0C6D6:  MOVFF  00,885
0C6DA:  MOVLB  8
0C6DC:  DECFSZ x8C,F
0C6DE:  BRA    C6A8
0C6E0:  MOVLW  7E
0C6E2:  MOVWF  00
0C6E4:  CLRF   01
0C6E6:  BTFSC  x86.7
0C6E8:  BSF    01.7
0C6EA:  CLRF   02
0C6EC:  CLRF   03
0C6EE:  BCF    FD8.1
0C6F0:  MOVFF  888,91A
0C6F4:  MOVFF  887,919
0C6F8:  MOVFF  886,918
0C6FC:  MOVFF  885,917
0C700:  MOVFF  03,91E
0C704:  MOVFF  02,91D
0C708:  MOVFF  01,91C
0C70C:  MOVFF  FE8,91B
0C710:  MOVLB  0
0C712:  RCALL  C3E2
0C714:  MOVFF  03,888
0C718:  MOVFF  02,887
0C71C:  MOVFF  01,886
0C720:  MOVFF  00,885
0C724:  MOVFF  888,8DF
0C728:  MOVFF  887,8DE
0C72C:  MOVFF  886,8DD
0C730:  MOVFF  885,8DC
0C734:  RCALL  C65A
0C736:  MOVFF  03,888
0C73A:  MOVFF  02,887
0C73E:  MOVFF  01,886
0C742:  MOVFF  00,885
0C746:  MOVLB  8
0C748:  BTFSS  x88.7
0C74A:  BRA    C766
0C74C:  DECF   x8A,F
0C74E:  BSF    x8A.5
0C750:  COMF   x85,F
0C752:  COMF   x86,F
0C754:  COMF   x87,F
0C756:  COMF   x88,F
0C758:  INCF   x85,F
0C75A:  BTFSC  FD8.2
0C75C:  INCF   x86,F
0C75E:  BTFSC  FD8.2
0C760:  INCF   x87,F
0C762:  BTFSC  FD8.2
0C764:  INCF   x88,F
0C766:  MOVLW  3B
0C768:  MOVWF  x91
0C76A:  MOVLW  9A
0C76C:  MOVWF  x90
0C76E:  MOVLW  CA
0C770:  MOVWF  x8F
0C772:  CLRF   x8E
0C774:  MOVLW  0A
0C776:  MOVWF  x8C
0C778:  MOVF   x89,W
0C77A:  BTFSC  FD8.2
0C77C:  INCF   x8A,F
0C77E:  BSF    FD8.1
0C780:  MOVLW  08
0C782:  MOVWF  FEA
0C784:  MOVLW  85
0C786:  MOVWF  FE9
0C788:  CLRF   1B
0C78A:  BTFSC  FF2.7
0C78C:  BSF    1B.7
0C78E:  BCF    FF2.7
0C790:  MOVFF  888,A4F
0C794:  MOVFF  887,A4E
0C798:  MOVFF  886,A4D
0C79C:  MOVFF  885,A4C
0C7A0:  MOVFF  891,A53
0C7A4:  MOVFF  890,A52
0C7A8:  MOVFF  88F,A51
0C7AC:  MOVFF  88E,A50
0C7B0:  MOVLB  0
0C7B2:  CALL   1076
0C7B6:  BTFSC  1B.7
0C7B8:  BSF    FF2.7
0C7BA:  MOVF   01,W
0C7BC:  MOVF   00,F
0C7BE:  BNZ   C7E6
0C7C0:  MOVLB  8
0C7C2:  INCF   x89,W
0C7C4:  SUBWF  x8C,W
0C7C6:  BTFSS  FD8.2
0C7C8:  BRA    C7CE
0C7CA:  MOVLB  0
0C7CC:  BRA    C7E6
0C7CE:  MOVF   x8A,W
0C7D0:  BZ    C7EC
0C7D2:  ANDLW  0F
0C7D4:  SUBWF  x8C,W
0C7D6:  BZ    C7DA
0C7D8:  BC    C852
0C7DA:  BTFSC  x8A.7
0C7DC:  BRA    C852
0C7DE:  BTFSC  x8A.6
0C7E0:  BRA    C7EC
0C7E2:  MOVLW  20
0C7E4:  BRA    C848
0C7E6:  MOVLW  20
0C7E8:  MOVLB  8
0C7EA:  ANDWF  x8A,F
0C7EC:  BTFSS  x8A.5
0C7EE:  BRA    C80A
0C7F0:  BCF    x8A.5
0C7F2:  MOVF   x89,W
0C7F4:  BTFSS  FD8.2
0C7F6:  DECF   x8A,F
0C7F8:  MOVF   00,W
0C7FA:  MOVWF  x8A
0C7FC:  MOVLW  2D
0C7FE:  BTFSS  F9E.4
0C800:  BRA    C7FE
0C802:  MOVWF  FAD
0C804:  MOVF   x8A,W
0C806:  MOVWF  00
0C808:  CLRF   x8A
0C80A:  MOVF   x89,W
0C80C:  SUBWF  x8C,W
0C80E:  BNZ   C826
0C810:  MOVF   00,W
0C812:  MOVWF  x8A
0C814:  MOVLW  2E
0C816:  BTFSS  F9E.4
0C818:  BRA    C816
0C81A:  MOVWF  FAD
0C81C:  MOVF   x8A,W
0C81E:  MOVWF  00
0C820:  MOVLW  20
0C822:  ANDWF  x8A,F
0C824:  MOVLW  00
0C826:  MOVLW  30
0C828:  BTFSS  x8A.5
0C82A:  BRA    C848
0C82C:  BCF    x8A.5
0C82E:  MOVF   x89,W
0C830:  BTFSS  FD8.2
0C832:  DECF   x8A,F
0C834:  MOVF   00,W
0C836:  MOVWF  x8A
0C838:  MOVLW  2D
0C83A:  BTFSS  F9E.4
0C83C:  BRA    C83A
0C83E:  MOVWF  FAD
0C840:  MOVF   x8A,W
0C842:  MOVWF  00
0C844:  CLRF   x8A
0C846:  MOVLW  30
0C848:  ADDWF  00,F
0C84A:  MOVF   00,W
0C84C:  BTFSS  F9E.4
0C84E:  BRA    C84C
0C850:  MOVWF  FAD
0C852:  BCF    FD8.1
0C854:  CLRF   1B
0C856:  BTFSC  FF2.7
0C858:  BSF    1B.7
0C85A:  BCF    FF2.7
0C85C:  MOVFF  891,A4F
0C860:  MOVFF  890,A4E
0C864:  MOVFF  88F,A4D
0C868:  MOVFF  88E,A4C
0C86C:  MOVLB  A
0C86E:  CLRF   x53
0C870:  CLRF   x52
0C872:  CLRF   x51
0C874:  MOVLW  0A
0C876:  MOVWF  x50
0C878:  MOVLB  0
0C87A:  CALL   1076
0C87E:  BTFSC  1B.7
0C880:  BSF    FF2.7
0C882:  MOVFF  03,891
0C886:  MOVFF  02,890
0C88A:  MOVFF  01,88F
0C88E:  MOVFF  00,88E
0C892:  MOVLB  8
0C894:  DECFSZ x8C,F
0C896:  BRA    C77E
0C898:  MOVLB  0
0C89A:  RETURN 0
*
0C91E:  MOVLW  8E
0C920:  MOVWF  00
0C922:  MOVFF  918,01
0C926:  MOVFF  917,02
0C92A:  CLRF   03
0C92C:  MOVF   01,F
0C92E:  BNZ   C942
0C930:  MOVFF  02,01
0C934:  CLRF   02
0C936:  MOVLW  08
0C938:  SUBWF  00,F
0C93A:  MOVF   01,F
0C93C:  BNZ   C942
0C93E:  CLRF   00
0C940:  BRA    C952
0C942:  BCF    FD8.0
0C944:  BTFSC  01.7
0C946:  BRA    C950
0C948:  RLCF   02,F
0C94A:  RLCF   01,F
0C94C:  DECF   00,F
0C94E:  BRA    C942
0C950:  BCF    01.7
0C952:  RETURN 0
0C954:  MOVLB  8
0C956:  MOVF   xFB,W
0C958:  BTFSC  FD8.2
0C95A:  BRA    CAC4
0C95C:  MOVLB  9
0C95E:  MOVWF  x07
0C960:  MOVLB  8
0C962:  MOVF   xFF,W
0C964:  BTFSC  FD8.2
0C966:  BRA    CAC4
0C968:  MOVLB  9
0C96A:  SUBWF  x07,F
0C96C:  BNC   C97C
0C96E:  MOVLW  7F
0C970:  ADDWF  x07,F
0C972:  BTFSS  FD8.0
0C974:  BRA    C97A
0C976:  MOVLB  8
0C978:  BRA    CAC4
0C97A:  BRA    C990
0C97C:  MOVLW  81
0C97E:  SUBWF  x07,F
0C980:  BTFSC  FD8.0
0C982:  BRA    C988
0C984:  MOVLB  8
0C986:  BRA    CAC4
0C988:  BTFSS  FD8.2
0C98A:  BRA    C990
0C98C:  MOVLB  8
0C98E:  BRA    CAC4
0C990:  MOVFF  907,00
0C994:  CLRF   01
0C996:  CLRF   02
0C998:  CLRF   03
0C99A:  CLRF   x06
0C99C:  MOVFF  8FC,905
0C9A0:  BSF    x05.7
0C9A2:  MOVFF  8FD,904
0C9A6:  MOVFF  8FE,903
0C9AA:  MOVLW  19
0C9AC:  MOVWF  x07
0C9AE:  MOVF   x02,W
0C9B0:  SUBWF  x03,F
0C9B2:  BC    C9CE
0C9B4:  MOVLW  01
0C9B6:  SUBWF  x04,F
0C9B8:  BC    C9CE
0C9BA:  SUBWF  x05,F
0C9BC:  BC    C9CE
0C9BE:  SUBWF  x06,F
0C9C0:  BC    C9CE
0C9C2:  INCF   x06,F
0C9C4:  INCF   x05,F
0C9C6:  INCF   x04,F
0C9C8:  MOVF   x02,W
0C9CA:  ADDWF  x03,F
0C9CC:  BRA    CA1E
0C9CE:  MOVF   x01,W
0C9D0:  SUBWF  x04,F
0C9D2:  BC    C9F8
0C9D4:  MOVLW  01
0C9D6:  SUBWF  x05,F
0C9D8:  BC    C9F8
0C9DA:  SUBWF  x06,F
0C9DC:  BC    C9F8
0C9DE:  INCF   x06,F
0C9E0:  INCF   x05,F
0C9E2:  MOVF   x01,W
0C9E4:  ADDWF  x04,F
0C9E6:  MOVF   x02,W
0C9E8:  ADDWF  x03,F
0C9EA:  BNC   CA1E
0C9EC:  INCF   x04,F
0C9EE:  BNZ   CA1E
0C9F0:  INCF   x05,F
0C9F2:  BNZ   CA1E
0C9F4:  INCF   x06,F
0C9F6:  BRA    CA1E
0C9F8:  MOVF   x00,W
0C9FA:  IORLW  80
0C9FC:  SUBWF  x05,F
0C9FE:  BC    CA1C
0CA00:  MOVLW  01
0CA02:  SUBWF  x06,F
0CA04:  BC    CA1C
0CA06:  INCF   x06,F
0CA08:  MOVF   x00,W
0CA0A:  IORLW  80
0CA0C:  ADDWF  x05,F
0CA0E:  MOVF   x01,W
0CA10:  ADDWF  x04,F
0CA12:  BNC   C9E6
0CA14:  INCF   x05,F
0CA16:  BNZ   C9E6
0CA18:  INCF   x06,F
0CA1A:  BRA    C9E6
0CA1C:  BSF    03.0
0CA1E:  DECFSZ x07,F
0CA20:  BRA    CA24
0CA22:  BRA    CA3A
0CA24:  BCF    FD8.0
0CA26:  RLCF   x03,F
0CA28:  RLCF   x04,F
0CA2A:  RLCF   x05,F
0CA2C:  RLCF   x06,F
0CA2E:  BCF    FD8.0
0CA30:  RLCF   03,F
0CA32:  RLCF   02,F
0CA34:  RLCF   01,F
0CA36:  RLCF   x08,F
0CA38:  BRA    C9AE
0CA3A:  BTFSS  x08.0
0CA3C:  BRA    CA4A
0CA3E:  BCF    FD8.0
0CA40:  RRCF   01,F
0CA42:  RRCF   02,F
0CA44:  RRCF   03,F
0CA46:  RRCF   x08,F
0CA48:  BRA    CA52
0CA4A:  DECFSZ 00,F
0CA4C:  BRA    CA52
0CA4E:  MOVLB  8
0CA50:  BRA    CAC4
0CA52:  BTFSC  x08.7
0CA54:  BRA    CA92
0CA56:  BCF    FD8.0
0CA58:  RLCF   x03,F
0CA5A:  RLCF   x04,F
0CA5C:  RLCF   x05,F
0CA5E:  RLCF   x06,F
0CA60:  MOVF   x02,W
0CA62:  SUBWF  x03,F
0CA64:  BC    CA74
0CA66:  MOVLW  01
0CA68:  SUBWF  x04,F
0CA6A:  BC    CA74
0CA6C:  SUBWF  x05,F
0CA6E:  BC    CA74
0CA70:  SUBWF  x06,F
0CA72:  BNC   CAAE
0CA74:  MOVF   x01,W
0CA76:  SUBWF  x04,F
0CA78:  BC    CA84
0CA7A:  MOVLW  01
0CA7C:  SUBWF  x05,F
0CA7E:  BC    CA84
0CA80:  SUBWF  x06,F
0CA82:  BNC   CAAE
0CA84:  MOVF   x00,W
0CA86:  IORLW  80
0CA88:  SUBWF  x05,F
0CA8A:  BC    CA92
0CA8C:  MOVLW  01
0CA8E:  SUBWF  x06,F
0CA90:  BNC   CAAE
0CA92:  INCF   03,F
0CA94:  BNZ   CAAE
0CA96:  INCF   02,F
0CA98:  BNZ   CAAE
0CA9A:  INCF   01,F
0CA9C:  BNZ   CAAE
0CA9E:  INCF   00,F
0CAA0:  BTFSS  FD8.2
0CAA2:  BRA    CAA8
0CAA4:  MOVLB  8
0CAA6:  BRA    CAC4
0CAA8:  RRCF   01,F
0CAAA:  RRCF   02,F
0CAAC:  RRCF   03,F
0CAAE:  MOVFF  8FC,907
0CAB2:  MOVF   x00,W
0CAB4:  XORWF  x07,F
0CAB6:  BTFSS  x07.7
0CAB8:  BRA    CABE
0CABA:  BSF    01.7
0CABC:  BRA    CACE
0CABE:  BCF    01.7
0CAC0:  BRA    CACE
0CAC2:  MOVLB  8
0CAC4:  CLRF   00
0CAC6:  CLRF   01
0CAC8:  CLRF   02
0CACA:  CLRF   03
0CACC:  MOVLB  9
0CACE:  MOVLB  0
0CAD0:  RETURN 0
*
0D564:  MOVFF  FEA,8C9
0D568:  MOVFF  FE9,8C8
0D56C:  MOVLB  8
0D56E:  BTFSS  xC2.7
0D570:  BRA    D582
0D572:  BSF    xC8.7
0D574:  BTFSS  xC8.4
0D576:  INCF   xC8,F
0D578:  COMF   xC1,F
0D57A:  COMF   xC2,F
0D57C:  INCF   xC1,F
0D57E:  BTFSC  FD8.2
0D580:  INCF   xC2,F
0D582:  SWAPF  xC2,W
0D584:  IORLW  F0
0D586:  MOVWF  xC4
0D588:  ADDWF  xC4,F
0D58A:  ADDLW  E2
0D58C:  MOVWF  xC5
0D58E:  ADDLW  32
0D590:  MOVWF  xC7
0D592:  MOVF   xC2,W
0D594:  ANDLW  0F
0D596:  ADDWF  xC5,F
0D598:  ADDWF  xC5,F
0D59A:  ADDWF  xC7,F
0D59C:  ADDLW  E9
0D59E:  MOVWF  xC6
0D5A0:  ADDWF  xC6,F
0D5A2:  ADDWF  xC6,F
0D5A4:  SWAPF  xC1,W
0D5A6:  ANDLW  0F
0D5A8:  ADDWF  xC6,F
0D5AA:  ADDWF  xC7,F
0D5AC:  RLCF   xC6,F
0D5AE:  RLCF   xC7,F
0D5B0:  COMF   xC7,F
0D5B2:  RLCF   xC7,F
0D5B4:  MOVF   xC1,W
0D5B6:  ANDLW  0F
0D5B8:  ADDWF  xC7,F
0D5BA:  RLCF   xC4,F
0D5BC:  MOVLW  07
0D5BE:  MOVWF  xC3
0D5C0:  MOVLW  0A
0D5C2:  DECF   xC6,F
0D5C4:  ADDWF  xC7,F
0D5C6:  BNC   D5C2
0D5C8:  DECF   xC5,F
0D5CA:  ADDWF  xC6,F
0D5CC:  BNC   D5C8
0D5CE:  DECF   xC4,F
0D5D0:  ADDWF  xC5,F
0D5D2:  BNC   D5CE
0D5D4:  DECF   xC3,F
0D5D6:  ADDWF  xC4,F
0D5D8:  BNC   D5D4
0D5DA:  MOVLW  08
0D5DC:  MOVWF  FEA
0D5DE:  MOVLW  C3
0D5E0:  MOVWF  FE9
0D5E2:  MOVLW  07
0D5E4:  ANDWF  xC8,W
0D5E6:  BCF    xC8.6
0D5E8:  MOVF   FED,F
0D5EA:  ANDWF  xC8,W
0D5EC:  BNZ   D5FC
0D5EE:  BTFSC  xC8.4
0D5F0:  MOVF   FEE,F
0D5F2:  BTFSC  xC8.4
0D5F4:  BRA    D5FC
0D5F6:  MOVLW  20
0D5F8:  MOVWF  00
0D5FA:  BRA    D63E
0D5FC:  ADDWF  FE9,F
0D5FE:  MOVLW  00
0D600:  ADDWFC FEA,F
0D602:  MOVF   FE9,W
0D604:  SUBLW  C7
0D606:  BNZ   D610
0D608:  MOVF   FEA,W
0D60A:  SUBLW  08
0D60C:  BNZ   D610
0D60E:  BSF    xC8.6
0D610:  MOVF   FEF,W
0D612:  MOVWF  00
0D614:  BNZ   D626
0D616:  BTFSC  xC8.6
0D618:  BRA    D626
0D61A:  BTFSC  xC8.4
0D61C:  BRA    D65A
0D61E:  BTFSC  xC8.3
0D620:  BRA    D626
0D622:  MOVLW  20
0D624:  BRA    D63C
0D626:  BTFSS  xC8.7
0D628:  BRA    D636
0D62A:  MOVLW  2D
0D62C:  MOVWF  00
0D62E:  MOVF   FED,W
0D630:  BCF    xC8.6
0D632:  BCF    xC8.7
0D634:  BRA    D63E
0D636:  BSF    xC8.3
0D638:  BCF    xC8.4
0D63A:  MOVLW  30
0D63C:  ADDWF  00,F
0D63E:  MOVFF  FEA,8C2
0D642:  MOVFF  FE9,8C1
0D646:  MOVFF  00,8FF
0D64A:  MOVLB  0
0D64C:  CALL   50C6
0D650:  MOVFF  8C2,FEA
0D654:  MOVFF  8C1,FE9
0D658:  MOVLB  8
0D65A:  MOVF   FEE,W
0D65C:  BTFSS  xC8.6
0D65E:  BRA    D602
0D660:  MOVLB  0
0D662:  GOTO   D786 (RETURN)
*
0DA0A:  ADDWF  FE8,W
0DA0C:  CLRF   FF7
0DA0E:  RLCF   FF7,F
0DA10:  ADDLW  2B
0DA12:  MOVWF  FF6
0DA14:  MOVLW  DA
0DA16:  ADDWFC FF7,F
0DA18:  MOVLW  00
0DA1A:  MOVWF  FF8
0DA1C:  MOVWF  FFB
0DA1E:  TBLRD*-
0DA20:  MOVF   FF5,W
0DA22:  MOVWF  FFA
0DA24:  TBLRD*
0DA26:  MOVF   FF5,W
0DA28:  MOVWF  FF9
0DA2A:  DATA 3C,D9
0DA2C:  DATA 64,D9
0DA2E:  DATA 84,D9
0DA30:  DATA A4,D9
0DA32:  DATA C4,D9
0DA34:  DATA E4,D9
*
0DAB4:  TBLRD*+
0DAB6:  MOVFF  FF6,8B9
0DABA:  MOVFF  FF7,8BA
0DABE:  MOVFF  FF8,8BB
0DAC2:  MOVF   FF5,W
0DAC4:  BTFSS  FA4.4
0DAC6:  BRA    DAC4
0DAC8:  MOVLB  F
0DACA:  MOVWF  x1C
0DACC:  MOVFF  8B9,FF6
0DAD0:  MOVFF  8BA,FF7
0DAD4:  MOVFF  8BB,FF8
0DAD8:  MOVLB  8
0DADA:  DECFSZ xB8,F
0DADC:  BRA    DAE0
0DADE:  BRA    DAE4
0DAE0:  MOVLB  0
0DAE2:  BRA    DAB4
0DAE4:  MOVLB  0
0DAE6:  RETURN 0
0DAE8:  MOVF   01,W
0DAEA:  CLRF   1B
0DAEC:  BTFSC  FF2.7
0DAEE:  BSF    1B.7
0DAF0:  BCF    FF2.7
0DAF2:  MOVFF  8F3,A42
0DAF6:  MOVLW  64
0DAF8:  MOVLB  A
0DAFA:  MOVWF  x43
0DAFC:  MOVLB  0
0DAFE:  CALL   0F9A
0DB02:  BTFSC  1B.7
0DB04:  BSF    FF2.7
0DB06:  MOVFF  00,8F3
0DB0A:  MOVF   01,W
0DB0C:  MOVLW  30
0DB0E:  BNZ   DB20
0DB10:  MOVLB  8
0DB12:  BTFSS  xF4.1
0DB14:  BRA    DB36
0DB16:  BTFSC  xF4.3
0DB18:  BRA    DB36
0DB1A:  BTFSC  xF4.4
0DB1C:  MOVLW  20
0DB1E:  BRA    DB28
0DB20:  MOVLB  8
0DB22:  BCF    xF4.3
0DB24:  BCF    xF4.4
0DB26:  BSF    xF4.0
0DB28:  ADDWF  01,F
0DB2A:  MOVF   01,W
0DB2C:  BTFSS  FA4.4
0DB2E:  BRA    DB2C
0DB30:  MOVLB  F
0DB32:  MOVWF  x1C
0DB34:  MOVLB  8
0DB36:  CLRF   1B
0DB38:  BTFSC  FF2.7
0DB3A:  BSF    1B.7
0DB3C:  BCF    FF2.7
0DB3E:  MOVFF  8F3,A42
0DB42:  MOVLW  0A
0DB44:  MOVLB  A
0DB46:  MOVWF  x43
0DB48:  MOVLB  0
0DB4A:  CALL   0F9A
0DB4E:  BTFSC  1B.7
0DB50:  BSF    FF2.7
0DB52:  MOVFF  00,8F3
0DB56:  MOVF   01,W
0DB58:  MOVLW  30
0DB5A:  BNZ   DB6C
0DB5C:  MOVLB  8
0DB5E:  BTFSC  xF4.3
0DB60:  BRA    DB7A
0DB62:  BTFSS  xF4.0
0DB64:  BRA    DB7A
0DB66:  BTFSC  xF4.4
0DB68:  MOVLW  20
0DB6A:  MOVLB  0
0DB6C:  ADDWF  01,F
0DB6E:  MOVF   01,W
0DB70:  BTFSS  FA4.4
0DB72:  BRA    DB70
0DB74:  MOVLB  F
0DB76:  MOVWF  x1C
0DB78:  MOVLB  8
0DB7A:  MOVLW  30
0DB7C:  ADDWF  xF3,F
0DB7E:  MOVF   xF3,W
0DB80:  BTFSS  FA4.4
0DB82:  BRA    DB80
0DB84:  MOVLB  F
0DB86:  MOVWF  x1C
0DB88:  MOVLB  0
0DB8A:  RETURN 0
*
0DBAE:  TBLRD*+
0DBB0:  MOVF   FF5,F
0DBB2:  BZ    DBDA
0DBB4:  MOVFF  FF6,8B7
0DBB8:  MOVFF  FF7,8B8
0DBBC:  MOVFF  FF8,8B9
0DBC0:  MOVF   FF5,W
0DBC2:  BTFSS  FA4.4
0DBC4:  BRA    DBC2
0DBC6:  MOVLB  F
0DBC8:  MOVWF  x1C
0DBCA:  MOVFF  8B7,FF6
0DBCE:  MOVFF  8B8,FF7
0DBD2:  MOVFF  8B9,FF8
0DBD6:  MOVLB  0
0DBD8:  BRA    DBAE
0DBDA:  GOTO   DC9C (RETURN)
*
0E1B6:  MOVF   FE9,W
0E1B8:  MOVLB  8
0E1BA:  MOVWF  x8C
0E1BC:  MOVLW  3B
0E1BE:  MOVWF  x93
0E1C0:  MOVLW  9A
0E1C2:  MOVWF  x92
0E1C4:  MOVLW  CA
0E1C6:  MOVWF  x91
0E1C8:  CLRF   x90
0E1CA:  MOVLW  0A
0E1CC:  MOVWF  x8E
0E1CE:  MOVF   x8B,W
0E1D0:  BTFSS  FD8.2
0E1D2:  DECF   x8C,F
0E1D4:  BSF    FD8.1
0E1D6:  MOVLW  08
0E1D8:  MOVWF  FEA
0E1DA:  MOVLW  87
0E1DC:  MOVWF  FE9
0E1DE:  CLRF   1B
0E1E0:  BTFSC  FF2.7
0E1E2:  BSF    1B.7
0E1E4:  BCF    FF2.7
0E1E6:  MOVFF  88A,A4F
0E1EA:  MOVFF  889,A4E
0E1EE:  MOVFF  888,A4D
0E1F2:  MOVFF  887,A4C
0E1F6:  MOVFF  893,A53
0E1FA:  MOVFF  892,A52
0E1FE:  MOVFF  891,A51
0E202:  MOVFF  890,A50
0E206:  MOVLB  0
0E208:  CALL   1076
0E20C:  BTFSC  1B.7
0E20E:  BSF    FF2.7
0E210:  MOVF   01,W
0E212:  MOVF   00,F
0E214:  BNZ   E23C
0E216:  MOVLB  8
0E218:  INCF   x8B,W
0E21A:  SUBWF  x8E,W
0E21C:  BTFSS  FD8.2
0E21E:  BRA    E224
0E220:  MOVLB  0
0E222:  BRA    E23C
0E224:  MOVF   x8C,W
0E226:  BZ    E240
0E228:  ANDLW  0F
0E22A:  SUBWF  x8E,W
0E22C:  BZ    E230
0E22E:  BC    E268
0E230:  BTFSC  x8C.7
0E232:  BRA    E268
0E234:  BTFSC  x8C.6
0E236:  BRA    E240
0E238:  MOVLW  20
0E23A:  BRA    E25E
0E23C:  MOVLB  8
0E23E:  CLRF   x8C
0E240:  MOVF   x8B,W
0E242:  SUBWF  x8E,W
0E244:  BNZ   E25C
0E246:  MOVFF  00,88C
0E24A:  MOVLW  2E
0E24C:  BTFSS  F9E.4
0E24E:  BRA    E24C
0E250:  MOVWF  FAD
0E252:  MOVFF  88C,00
0E256:  MOVLW  20
0E258:  ANDWF  x8C,F
0E25A:  MOVLW  00
0E25C:  MOVLW  30
0E25E:  ADDWF  00,F
0E260:  MOVF   00,W
0E262:  BTFSS  F9E.4
0E264:  BRA    E262
0E266:  MOVWF  FAD
0E268:  BCF    FD8.1
0E26A:  CLRF   1B
0E26C:  BTFSC  FF2.7
0E26E:  BSF    1B.7
0E270:  BCF    FF2.7
0E272:  MOVFF  893,A4F
0E276:  MOVFF  892,A4E
0E27A:  MOVFF  891,A4D
0E27E:  MOVFF  890,A4C
0E282:  MOVLB  A
0E284:  CLRF   x53
0E286:  CLRF   x52
0E288:  CLRF   x51
0E28A:  MOVLW  0A
0E28C:  MOVWF  x50
0E28E:  MOVLB  0
0E290:  CALL   1076
0E294:  BTFSC  1B.7
0E296:  BSF    FF2.7
0E298:  MOVFF  03,893
0E29C:  MOVFF  02,892
0E2A0:  MOVFF  01,891
0E2A4:  MOVFF  00,890
0E2A8:  MOVLB  8
0E2AA:  DECFSZ x8E,F
0E2AC:  BRA    E1D4
0E2AE:  MOVLB  0
0E2B0:  RETURN 0
*
0F34A:  MOVF   FE9,W
0F34C:  MOVLB  8
0F34E:  MOVWF  xF7
0F350:  MOVLW  3B
0F352:  MOVWF  xFE
0F354:  MOVLW  9A
0F356:  MOVWF  xFD
0F358:  MOVLW  CA
0F35A:  MOVWF  xFC
0F35C:  CLRF   xFB
0F35E:  MOVLW  0A
0F360:  MOVWF  xF9
0F362:  BSF    FD8.1
0F364:  MOVLW  08
0F366:  MOVWF  FEA
0F368:  MOVLW  F3
0F36A:  MOVWF  FE9
0F36C:  CLRF   1B
0F36E:  BTFSC  FF2.7
0F370:  BSF    1B.7
0F372:  BCF    FF2.7
0F374:  MOVFF  8F6,A4F
0F378:  MOVFF  8F5,A4E
0F37C:  MOVFF  8F4,A4D
0F380:  MOVFF  8F3,A4C
0F384:  MOVFF  8FE,A53
0F388:  MOVFF  8FD,A52
0F38C:  MOVFF  8FC,A51
0F390:  MOVFF  8FB,A50
0F394:  MOVLB  0
0F396:  CALL   1076
0F39A:  BTFSC  1B.7
0F39C:  BSF    FF2.7
0F39E:  MOVF   01,W
0F3A0:  MOVF   00,F
0F3A2:  BNZ   F3CA
0F3A4:  MOVLB  8
0F3A6:  MOVF   xF9,W
0F3A8:  XORLW  01
0F3AA:  BTFSS  FD8.2
0F3AC:  BRA    F3B2
0F3AE:  MOVLB  0
0F3B0:  BRA    F3CA
0F3B2:  MOVF   xF7,W
0F3B4:  BZ    F3CE
0F3B6:  ANDLW  0F
0F3B8:  SUBWF  xF9,W
0F3BA:  BZ    F3BE
0F3BC:  BC    F3DE
0F3BE:  BTFSC  xF7.7
0F3C0:  BRA    F3DE
0F3C2:  BTFSC  xF7.6
0F3C4:  BRA    F3CE
0F3C6:  MOVLW  20
0F3C8:  BRA    F3D0
0F3CA:  MOVLB  8
0F3CC:  CLRF   xF7
0F3CE:  MOVLW  30
0F3D0:  ADDWF  00,F
0F3D2:  MOVF   00,W
0F3D4:  BTFSS  FA4.4
0F3D6:  BRA    F3D4
0F3D8:  MOVLB  F
0F3DA:  MOVWF  x1C
0F3DC:  MOVLB  8
0F3DE:  BCF    FD8.1
0F3E0:  CLRF   1B
0F3E2:  BTFSC  FF2.7
0F3E4:  BSF    1B.7
0F3E6:  BCF    FF2.7
0F3E8:  MOVFF  8FE,A4F
0F3EC:  MOVFF  8FD,A4E
0F3F0:  MOVFF  8FC,A4D
0F3F4:  MOVFF  8FB,A4C
0F3F8:  MOVLB  A
0F3FA:  CLRF   x53
0F3FC:  CLRF   x52
0F3FE:  CLRF   x51
0F400:  MOVLW  0A
0F402:  MOVWF  x50
0F404:  MOVLB  0
0F406:  CALL   1076
0F40A:  BTFSC  1B.7
0F40C:  BSF    FF2.7
0F40E:  MOVFF  03,8FE
0F412:  MOVFF  02,8FD
0F416:  MOVFF  01,8FC
0F41A:  MOVFF  00,8FB
0F41E:  MOVLB  8
0F420:  DECFSZ xF9,F
0F422:  BRA    F362
0F424:  MOVLB  0
0F426:  GOTO   F550 (RETURN)
*
0F620:  ADDWF  FE8,W
0F622:  CLRF   FF7
0F624:  RLCF   FF7,F
0F626:  ADDLW  41
0F628:  MOVWF  FF6
0F62A:  MOVLW  F6
0F62C:  ADDWFC FF7,F
0F62E:  MOVLW  00
0F630:  MOVWF  FF8
0F632:  MOVWF  FFB
0F634:  TBLRD*-
0F636:  MOVF   FF5,W
0F638:  MOVWF  FFA
0F63A:  TBLRD*
0F63C:  MOVF   FF5,W
0F63E:  MOVWF  FF9
0F640:  DATA E0,F5
0F642:  DATA E8,F5
0F644:  DATA F0,F5
0F646:  DATA F8,F5
*
0FE64:  MOVF   FEF,F
0FE66:  BZ    FE88
0FE68:  MOVFF  FEA,8EC
0FE6C:  MOVFF  FE9,8EB
0FE70:  MOVFF  FEF,8FF
0FE74:  CALL   50C6
0FE78:  MOVFF  8EC,FEA
0FE7C:  MOVFF  8EB,FE9
0FE80:  INCF   FE9,F
0FE82:  BTFSC  FD8.2
0FE84:  INCF   FEA,F
0FE86:  BRA    FE64
0FE88:  RETURN 0
0FE8A:  MOVFF  FEA,FE2
0FE8E:  MOVFF  FE9,FE1
0FE92:  CLRF   01
0FE94:  BSF    00.0
0FE96:  TBLRD*+
0FE98:  MOVF   FF5,W
0FE9A:  BTFSS  00.0
0FE9C:  BRA    FEA8
0FE9E:  SUBWF  FEE,W
0FEA0:  BNZ   FEA8
0FEA2:  MOVF   FF5,F
0FEA4:  BNZ   FE96
0FEA6:  BRA    FEC2
0FEA8:  BCF    00.0
0FEAA:  MOVF   FF5,F
0FEAC:  BNZ   FE96
0FEAE:  INCF   01,F
0FEB0:  BSF    00.0
0FEB2:  MOVFF  FE2,FEA
0FEB6:  MOVFF  FE1,FE9
0FEBA:  TBLRD*
0FEBC:  MOVF   FF5,F
0FEBE:  BNZ   FE96
0FEC0:  SETF   01
0FEC2:  RETURN 0
*
1079A:  MOVFF  914,91B
1079E:  MOVLB  9
107A0:  MOVF   x18,W
107A2:  XORWF  x1B,F
107A4:  BTFSS  x1B.7
107A6:  BRA    107B2
107A8:  BCF    FD8.2
107AA:  BCF    FD8.0
107AC:  BTFSC  x14.7
107AE:  BSF    FD8.0
107B0:  BRA    10810
107B2:  MOVFF  914,91B
107B6:  MOVFF  917,91C
107BA:  MOVF   x13,W
107BC:  SUBWF  x1C,F
107BE:  BZ    107CC
107C0:  BTFSS  x1B.7
107C2:  BRA    10810
107C4:  MOVF   FD8,W
107C6:  XORLW  01
107C8:  MOVWF  FD8
107CA:  BRA    10810
107CC:  MOVFF  918,91C
107D0:  MOVF   x14,W
107D2:  SUBWF  x1C,F
107D4:  BZ    107E2
107D6:  BTFSS  x1B.7
107D8:  BRA    10810
107DA:  MOVF   FD8,W
107DC:  XORLW  01
107DE:  MOVWF  FD8
107E0:  BRA    10810
107E2:  MOVFF  919,91C
107E6:  MOVF   x15,W
107E8:  SUBWF  x1C,F
107EA:  BZ    107F8
107EC:  BTFSS  x1B.7
107EE:  BRA    10810
107F0:  MOVF   FD8,W
107F2:  XORLW  01
107F4:  MOVWF  FD8
107F6:  BRA    10810
107F8:  MOVFF  91A,91C
107FC:  MOVF   x16,W
107FE:  SUBWF  x1C,F
10800:  BZ    1080E
10802:  BTFSS  x1B.7
10804:  BRA    10810
10806:  MOVF   FD8,W
10808:  XORLW  01
1080A:  MOVWF  FD8
1080C:  BRA    10810
1080E:  BCF    FD8.0
10810:  MOVLB  0
10812:  RETURN 0
10814:  MOVLW  8E
10816:  MOVWF  00
10818:  MOVFF  8ED,01
1081C:  MOVFF  8EC,02
10820:  CLRF   03
10822:  BTFSS  01.7
10824:  BRA    10830
10826:  COMF   01,F
10828:  COMF   02,F
1082A:  INCF   02,F
1082C:  BNZ   10830
1082E:  INCF   01,F
10830:  MOVF   01,F
10832:  BNZ   10846
10834:  MOVFF  02,01
10838:  CLRF   02
1083A:  MOVLW  08
1083C:  SUBWF  00,F
1083E:  MOVF   01,F
10840:  BNZ   10846
10842:  CLRF   00
10844:  BRA    10862
10846:  BCF    FD8.0
10848:  BTFSC  01.7
1084A:  BRA    10854
1084C:  RLCF   02,F
1084E:  RLCF   01,F
10850:  DECF   00,F
10852:  BRA    10846
10854:  MOVLB  8
10856:  BTFSS  xED.7
10858:  BRA    1085E
1085A:  MOVLB  0
1085C:  BRA    10862
1085E:  BCF    01.7
10860:  MOVLB  0
10862:  RETURN 0
*
10C64:  MOVF   FE9,W
10C66:  MOVLB  8
10C68:  MOVWF  xD4
10C6A:  MOVF   xD3,W
10C6C:  MOVWF  xD6
10C6E:  BZ    10CAA
10C70:  MOVFF  8D2,916
10C74:  MOVFF  8D1,915
10C78:  MOVFF  8D0,914
10C7C:  MOVFF  8CF,913
10C80:  MOVLB  9
10C82:  CLRF   x1A
10C84:  CLRF   x19
10C86:  MOVLW  20
10C88:  MOVWF  x18
10C8A:  MOVLW  82
10C8C:  MOVWF  x17
10C8E:  MOVLB  0
10C90:  CALL   C2EC
10C94:  MOVFF  03,8D2
10C98:  MOVFF  02,8D1
10C9C:  MOVFF  01,8D0
10CA0:  MOVFF  00,8CF
10CA4:  MOVLB  8
10CA6:  DECFSZ xD6,F
10CA8:  BRA    10C70
10CAA:  MOVLW  7E
10CAC:  MOVWF  00
10CAE:  CLRF   01
10CB0:  BTFSC  xD0.7
10CB2:  BSF    01.7
10CB4:  CLRF   02
10CB6:  CLRF   03
10CB8:  BCF    FD8.1
10CBA:  MOVFF  8D2,91A
10CBE:  MOVFF  8D1,919
10CC2:  MOVFF  8D0,918
10CC6:  MOVFF  8CF,917
10CCA:  MOVFF  03,91E
10CCE:  MOVFF  02,91D
10CD2:  MOVFF  01,91C
10CD6:  MOVFF  FE8,91B
10CDA:  MOVLB  0
10CDC:  CALL   C3E2
10CE0:  MOVFF  03,8D2
10CE4:  MOVFF  02,8D1
10CE8:  MOVFF  01,8D0
10CEC:  MOVFF  00,8CF
10CF0:  MOVFF  8D2,8DF
10CF4:  MOVFF  8D1,8DE
10CF8:  MOVFF  8D0,8DD
10CFC:  MOVFF  8CF,8DC
10D00:  CALL   C65A
10D04:  MOVFF  03,8D2
10D08:  MOVFF  02,8D1
10D0C:  MOVFF  01,8D0
10D10:  MOVFF  00,8CF
10D14:  MOVLB  8
10D16:  BTFSS  xD2.7
10D18:  BRA    10D34
10D1A:  DECF   xD4,F
10D1C:  BSF    xD4.5
10D1E:  COMF   xCF,F
10D20:  COMF   xD0,F
10D22:  COMF   xD1,F
10D24:  COMF   xD2,F
10D26:  INCF   xCF,F
10D28:  BTFSC  FD8.2
10D2A:  INCF   xD0,F
10D2C:  BTFSC  FD8.2
10D2E:  INCF   xD1,F
10D30:  BTFSC  FD8.2
10D32:  INCF   xD2,F
10D34:  MOVLW  3B
10D36:  MOVWF  xDB
10D38:  MOVLW  9A
10D3A:  MOVWF  xDA
10D3C:  MOVLW  CA
10D3E:  MOVWF  xD9
10D40:  CLRF   xD8
10D42:  MOVLW  0A
10D44:  MOVWF  xD6
10D46:  MOVF   xD3,W
10D48:  BTFSC  FD8.2
10D4A:  INCF   xD4,F
10D4C:  BSF    FD8.1
10D4E:  MOVLW  08
10D50:  MOVWF  FEA
10D52:  MOVLW  CF
10D54:  MOVWF  FE9
10D56:  CLRF   1B
10D58:  BTFSC  FF2.7
10D5A:  BSF    1B.7
10D5C:  BCF    FF2.7
10D5E:  MOVFF  8D2,A4F
10D62:  MOVFF  8D1,A4E
10D66:  MOVFF  8D0,A4D
10D6A:  MOVFF  8CF,A4C
10D6E:  MOVFF  8DB,A53
10D72:  MOVFF  8DA,A52
10D76:  MOVFF  8D9,A51
10D7A:  MOVFF  8D8,A50
10D7E:  MOVLB  0
10D80:  CALL   1076
10D84:  BTFSC  1B.7
10D86:  BSF    FF2.7
10D88:  MOVF   01,W
10D8A:  MOVF   00,F
10D8C:  BNZ   10DB4
10D8E:  MOVLB  8
10D90:  INCF   xD3,W
10D92:  SUBWF  xD6,W
10D94:  BTFSS  FD8.2
10D96:  BRA    10D9C
10D98:  MOVLB  0
10D9A:  BRA    10DB4
10D9C:  MOVF   xD4,W
10D9E:  BZ    10DBA
10DA0:  ANDLW  0F
10DA2:  SUBWF  xD6,W
10DA4:  BZ    10DA8
10DA6:  BC    10E30
10DA8:  BTFSC  xD4.7
10DAA:  BRA    10E30
10DAC:  BTFSC  xD4.6
10DAE:  BRA    10DBA
10DB0:  MOVLW  20
10DB2:  BRA    10E22
10DB4:  MOVLW  20
10DB6:  MOVLB  8
10DB8:  ANDWF  xD4,F
10DBA:  BTFSS  xD4.5
10DBC:  BRA    10DDC
10DBE:  BCF    xD4.5
10DC0:  MOVF   xD3,W
10DC2:  BTFSS  FD8.2
10DC4:  DECF   xD4,F
10DC6:  MOVF   00,W
10DC8:  MOVWF  xD4
10DCA:  MOVLW  2D
10DCC:  MOVWF  xFF
10DCE:  MOVLB  0
10DD0:  CALL   50C6
10DD4:  MOVLB  8
10DD6:  MOVF   xD4,W
10DD8:  MOVWF  00
10DDA:  CLRF   xD4
10DDC:  MOVF   xD3,W
10DDE:  SUBWF  xD6,W
10DE0:  BNZ   10DFC
10DE2:  MOVF   00,W
10DE4:  MOVWF  xD4
10DE6:  MOVLW  2E
10DE8:  MOVWF  xFF
10DEA:  MOVLB  0
10DEC:  CALL   50C6
10DF0:  MOVLB  8
10DF2:  MOVF   xD4,W
10DF4:  MOVWF  00
10DF6:  MOVLW  20
10DF8:  ANDWF  xD4,F
10DFA:  MOVLW  00
10DFC:  MOVLW  30
10DFE:  BTFSS  xD4.5
10E00:  BRA    10E22
10E02:  BCF    xD4.5
10E04:  MOVF   xD3,W
10E06:  BTFSS  FD8.2
10E08:  DECF   xD4,F
10E0A:  MOVF   00,W
10E0C:  MOVWF  xD4
10E0E:  MOVLW  2D
10E10:  MOVWF  xFF
10E12:  MOVLB  0
10E14:  CALL   50C6
10E18:  MOVLB  8
10E1A:  MOVF   xD4,W
10E1C:  MOVWF  00
10E1E:  CLRF   xD4
10E20:  MOVLW  30
10E22:  ADDWF  00,F
10E24:  MOVFF  00,8FF
10E28:  MOVLB  0
10E2A:  CALL   50C6
10E2E:  MOVLB  8
10E30:  BCF    FD8.1
10E32:  CLRF   1B
10E34:  BTFSC  FF2.7
10E36:  BSF    1B.7
10E38:  BCF    FF2.7
10E3A:  MOVFF  8DB,A4F
10E3E:  MOVFF  8DA,A4E
10E42:  MOVFF  8D9,A4D
10E46:  MOVFF  8D8,A4C
10E4A:  MOVLB  A
10E4C:  CLRF   x53
10E4E:  CLRF   x52
10E50:  CLRF   x51
10E52:  MOVLW  0A
10E54:  MOVWF  x50
10E56:  MOVLB  0
10E58:  CALL   1076
10E5C:  BTFSC  1B.7
10E5E:  BSF    FF2.7
10E60:  MOVFF  03,8DB
10E64:  MOVFF  02,8DA
10E68:  MOVFF  01,8D9
10E6C:  MOVFF  00,8D8
10E70:  MOVLB  8
10E72:  DECFSZ xD6,F
10E74:  BRA    10D4C
10E76:  MOVLB  0
10E78:  RETURN 0
*
1277C:  ADDWF  FE8,W
1277E:  CLRF   FF7
12780:  RLCF   FF7,F
12782:  ADDLW  9D
12784:  MOVWF  FF6
12786:  MOVLW  27
12788:  ADDWFC FF7,F
1278A:  MOVLW  01
1278C:  MOVWF  FF8
1278E:  MOVWF  FFB
12790:  TBLRD*-
12792:  MOVF   FF5,W
12794:  MOVWF  FFA
12796:  TBLRD*
12798:  MOVF   FF5,W
1279A:  MOVWF  FF9
1279C:  DATA 40,27
1279E:  DATA 48,27
127A0:  DATA 4E,27
127A2:  DATA 54,27
*
12834:  MOVLW  8E
12836:  MOVWF  00
12838:  MOVLB  9
1283A:  MOVF   x13,W
1283C:  SUBWF  00,F
1283E:  MOVFF  914,02
12842:  MOVFF  915,01
12846:  BSF    02.7
12848:  MOVF   00,F
1284A:  BZ    1285E
1284C:  BCF    FD8.0
1284E:  MOVF   02,F
12850:  BNZ   12856
12852:  MOVF   01,F
12854:  BZ    1285E
12856:  RRCF   02,F
12858:  RRCF   01,F
1285A:  DECFSZ 00,F
1285C:  BRA    1284C
1285E:  BTFSS  x14.7
12860:  BRA    1286C
12862:  COMF   01,F
12864:  COMF   02,F
12866:  INCF   01,F
12868:  BTFSC  FD8.2
1286A:  INCF   02,F
1286C:  MOVLB  0
1286E:  RETURN 0
*
1332C:  ADDWF  FE8,W
1332E:  CLRF   FF7
13330:  RLCF   FF7,F
13332:  ADDLW  4D
13334:  MOVWF  FF6
13336:  MOVLW  33
13338:  ADDWFC FF7,F
1333A:  MOVLW  01
1333C:  MOVWF  FF8
1333E:  MOVWF  FFB
13340:  TBLRD*-
13342:  MOVF   FF5,W
13344:  MOVWF  FFA
13346:  TBLRD*
13348:  MOVF   FF5,W
1334A:  MOVWF  FF9
1334C:  DATA 68,31
1334E:  DATA 6E,31
13350:  DATA 8C,31
13352:  DATA AA,31
*
133C4:  MOVLB  8
133C6:  MOVF   xDD,W
133C8:  XORWF  xDF,W
133CA:  ANDLW  80
133CC:  MOVWF  xE1
133CE:  BTFSS  xDD.7
133D0:  BRA    133DC
133D2:  COMF   xDC,F
133D4:  COMF   xDD,F
133D6:  INCF   xDC,F
133D8:  BTFSC  FD8.2
133DA:  INCF   xDD,F
133DC:  BTFSS  xDF.7
133DE:  BRA    133EA
133E0:  COMF   xDE,F
133E2:  COMF   xDF,F
133E4:  INCF   xDE,F
133E6:  BTFSC  FD8.2
133E8:  INCF   xDF,F
133EA:  MOVF   xDC,W
133EC:  MULWF  xDE
133EE:  MOVFF  FF3,01
133F2:  MOVFF  FF4,00
133F6:  MULWF  xDF
133F8:  MOVF   FF3,W
133FA:  ADDWF  00,F
133FC:  MOVF   xDD,W
133FE:  MULWF  xDE
13400:  MOVF   FF3,W
13402:  ADDWFC 00,W
13404:  MOVWF  02
13406:  BTFSS  xE1.7
13408:  BRA    13414
1340A:  COMF   01,F
1340C:  COMF   02,F
1340E:  INCF   01,F
13410:  BTFSC  FD8.2
13412:  INCF   02,F
13414:  MOVLB  0
13416:  GOTO   134F4 (RETURN)
*
142B2:  ADDWF  FE8,W
142B4:  CLRF   FF7
142B6:  RLCF   FF7,F
142B8:  ADDLW  D3
142BA:  MOVWF  FF6
142BC:  MOVLW  42
142BE:  ADDWFC FF7,F
142C0:  MOVLW  01
142C2:  MOVWF  FF8
142C4:  MOVWF  FFB
142C6:  TBLRD*-
142C8:  MOVF   FF5,W
142CA:  MOVWF  FFA
142CC:  TBLRD*
142CE:  MOVF   FF5,W
142D0:  MOVWF  FF9
142D2:  DATA 68,41
142D4:  DATA A6,42
142D6:  DATA 94,41
142D8:  DATA A6,42
142DA:  DATA 5E,40
142DC:  DATA A6,42
142DE:  DATA A6,42
142E0:  DATA A6,42
142E2:  DATA A6,42
142E4:  DATA A6,42
142E6:  DATA A6,42
142E8:  DATA A6,42
142EA:  DATA A6,42
142EC:  DATA A6,42
142EE:  DATA A6,42
142F0:  DATA A6,42
142F2:  DATA 9E,42
142F4:  DATA A6,42
142F6:  DATA A6,42
142F8:  DATA A6,42
142FA:  DATA A6,42
142FC:  DATA A6,42
142FE:  DATA FE,3F
14300:  DATA A6,42
14302:  DATA 32,40
14304:  DATA 3A,40
14306:  DATA A6,42
14308:  DATA 4E,40
1430A:  DATA C0,41
1430C:  DATA 82,40
1430E:  DATA A6,42
14310:  DATA A6,42
14312:  DATA 14,41
14314:  DATA F6,40
14316:  DATA A6,42
14318:  DATA A6,42
1431A:  DATA A6,42
1431C:  DATA DA,41
1431E:  DATA 06,42
14320:  DATA 32,42
14322:  DATA 30,41
14324:  DATA 5E,41
14326:  DATA A6,42
14328:  DATA A6,42
1432A:  DATA A6,42
1432C:  DATA A6,42
1432E:  DATA 5E,42
14330:  DATA A6,42
14332:  DATA A6,42
14334:  DATA A6,42
14336:  DATA A6,42
14338:  DATA A6,42
1433A:  DATA A6,42
1433C:  DATA A6,42
1433E:  DATA A6,42
14340:  DATA A6,42
14342:  DATA A6,42
14344:  DATA 6A,40
14346:  DATA A6,42
14348:  DATA A6,42
1434A:  DATA A6,42
1434C:  DATA A6,42
1434E:  DATA 9A,40
14350:  DATA A6,42
14352:  DATA A6,42
14354:  DATA C0,40
14356:  DATA A6,42
14358:  DATA A6,42
1435A:  DATA A6,42
1435C:  DATA 0E,40
1435E:  DATA A6,42
14360:  DATA A6,42
14362:  DATA A6,42
14364:  DATA A6,42
14366:  DATA A6,42
14368:  DATA 88,42
*
1441E:  MOVFF  FEA,8C0
14422:  MOVFF  FE9,8BF
14426:  MOVLB  8
14428:  SWAPF  xB9,W
1442A:  IORLW  F0
1442C:  MOVWF  xBB
1442E:  ADDWF  xBB,F
14430:  ADDLW  E2
14432:  MOVWF  xBC
14434:  ADDLW  32
14436:  MOVWF  xBE
14438:  MOVF   xB9,W
1443A:  ANDLW  0F
1443C:  ADDWF  xBC,F
1443E:  ADDWF  xBC,F
14440:  ADDWF  xBE,F
14442:  ADDLW  E9
14444:  MOVWF  xBD
14446:  ADDWF  xBD,F
14448:  ADDWF  xBD,F
1444A:  SWAPF  xB8,W
1444C:  ANDLW  0F
1444E:  ADDWF  xBD,F
14450:  ADDWF  xBE,F
14452:  RLCF   xBD,F
14454:  RLCF   xBE,F
14456:  COMF   xBE,F
14458:  RLCF   xBE,F
1445A:  MOVF   xB8,W
1445C:  ANDLW  0F
1445E:  ADDWF  xBE,F
14460:  RLCF   xBB,F
14462:  MOVLW  07
14464:  MOVWF  xBA
14466:  MOVLW  0A
14468:  DECF   xBD,F
1446A:  ADDWF  xBE,F
1446C:  BNC   14468
1446E:  DECF   xBC,F
14470:  ADDWF  xBD,F
14472:  BNC   1446E
14474:  DECF   xBB,F
14476:  ADDWF  xBC,F
14478:  BNC   14474
1447A:  DECF   xBA,F
1447C:  ADDWF  xBB,F
1447E:  BNC   1447A
14480:  MOVLW  08
14482:  MOVWF  FEA
14484:  MOVLW  BA
14486:  MOVWF  FE9
14488:  MOVLW  07
1448A:  ANDWF  xBF,W
1448C:  BCF    xBF.6
1448E:  ADDWF  FE9,F
14490:  MOVLW  00
14492:  ADDWFC FEA,F
14494:  MOVF   FE9,W
14496:  SUBLW  BE
14498:  BNZ   144A2
1449A:  MOVF   FEA,W
1449C:  SUBLW  08
1449E:  BNZ   144A2
144A0:  BSF    xBF.6
144A2:  MOVF   FEF,W
144A4:  MOVWF  00
144A6:  BNZ   144B8
144A8:  BTFSC  xBF.6
144AA:  BRA    144B8
144AC:  BTFSC  xBF.4
144AE:  BRA    144CC
144B0:  BTFSC  xBF.3
144B2:  BRA    144B8
144B4:  MOVLW  20
144B6:  BRA    144BE
144B8:  BSF    xBF.3
144BA:  BCF    xBF.4
144BC:  MOVLW  30
144BE:  ADDWF  00,F
144C0:  MOVF   00,W
144C2:  BTFSS  FA4.4
144C4:  BRA    144C2
144C6:  MOVLB  F
144C8:  MOVWF  x1C
144CA:  MOVLB  8
144CC:  MOVF   FEE,W
144CE:  BTFSS  xBF.6
144D0:  BRA    14494
144D2:  MOVLB  0
144D4:  GOTO   14570 (RETURN)
*
149B4:  ADDWF  FE8,W
149B6:  CLRF   FF7
149B8:  RLCF   FF7,F
149BA:  ADDLW  D5
149BC:  MOVWF  FF6
149BE:  MOVLW  49
149C0:  ADDWFC FF7,F
149C2:  MOVLW  01
149C4:  MOVWF  FF8
149C6:  MOVWF  FFB
149C8:  TBLRD*-
149CA:  MOVF   FF5,W
149CC:  MOVWF  FFA
149CE:  TBLRD*
149D0:  MOVF   FF5,W
149D2:  MOVWF  FF9
149D4:  DATA A0,45
149D6:  DATA 00,46
149D8:  DATA 1C,46
149DA:  DATA 38,46
149DC:  DATA 54,46
149DE:  DATA 70,46
149E0:  DATA 8C,46
149E2:  DATA A8,46
149E4:  DATA C4,46
149E6:  DATA E0,46
149E8:  DATA FC,46
149EA:  DATA 18,47
149EC:  DATA 34,47
149EE:  DATA 50,47
149F0:  DATA 6C,47
149F2:  DATA 88,47
149F4:  DATA A4,47
149F6:  DATA C0,47
149F8:  DATA DC,47
149FA:  DATA F8,47
149FC:  DATA 14,48
149FE:  DATA 30,48
14A00:  DATA 4C,48
14A02:  DATA 68,48
14A04:  DATA 84,48
14A06:  DATA A0,48
14A08:  DATA BC,48
14A0A:  DATA D8,48
14A0C:  DATA F4,48
14A0E:  DATA 10,49
14A10:  DATA 2C,49
14A12:  DATA 48,49
14A14:  DATA 64,49
*
15202:  ADDWF  FE8,W
15204:  CLRF   FF7
15206:  RLCF   FF7,F
15208:  ADDLW  23
1520A:  MOVWF  FF6
1520C:  MOVLW  52
1520E:  ADDWFC FF7,F
15210:  MOVLW  01
15212:  MOVWF  FF8
15214:  MOVWF  FFB
15216:  TBLRD*-
15218:  MOVF   FF5,W
1521A:  MOVWF  FFA
1521C:  TBLRD*
1521E:  MOVF   FF5,W
15220:  MOVWF  FF9
15222:  DATA F6,4D
15224:  DATA 36,4F
15226:  DATA 22,4E
15228:  DATA 36,4F
1522A:  DATA E8,4C
1522C:  DATA 36,4F
1522E:  DATA 36,4F
15230:  DATA 36,4F
15232:  DATA 36,4F
15234:  DATA 36,4F
15236:  DATA 36,4F
15238:  DATA 36,4F
1523A:  DATA 36,4F
1523C:  DATA 36,4F
1523E:  DATA 36,4F
15240:  DATA 36,4F
15242:  DATA 2E,4F
15244:  DATA 36,4F
15246:  DATA 36,4F
15248:  DATA 36,4F
1524A:  DATA 36,4F
1524C:  DATA 36,4F
1524E:  DATA F2,4A
15250:  DATA 36,4F
15252:  DATA 26,4B
15254:  DATA C4,4C
15256:  DATA 36,4F
15258:  DATA D8,4C
1525A:  DATA 4E,4E
1525C:  DATA 0C,4D
1525E:  DATA 36,4F
15260:  DATA 36,4F
15262:  DATA 9E,4D
15264:  DATA 80,4D
15266:  DATA 36,4F
15268:  DATA 36,4F
1526A:  DATA 36,4F
1526C:  DATA 68,4E
1526E:  DATA 94,4E
15270:  DATA C0,4E
15272:  DATA BA,4D
15274:  DATA EA,4D
15276:  DATA 36,4F
15278:  DATA 36,4F
1527A:  DATA 36,4F
1527C:  DATA 36,4F
1527E:  DATA EC,4E
15280:  DATA 36,4F
15282:  DATA 36,4F
15284:  DATA 36,4F
15286:  DATA 36,4F
15288:  DATA 36,4F
1528A:  DATA 36,4F
1528C:  DATA 36,4F
1528E:  DATA 36,4F
15290:  DATA 36,4F
15292:  DATA 36,4F
15294:  DATA F4,4C
15296:  DATA 36,4F
15298:  DATA 36,4F
1529A:  DATA 36,4F
1529C:  DATA 36,4F
1529E:  DATA 24,4D
152A0:  DATA 36,4F
152A2:  DATA 36,4F
152A4:  DATA 4A,4D
152A6:  DATA 36,4F
152A8:  DATA 36,4F
152AA:  DATA 36,4F
152AC:  DATA 02,4B
152AE:  DATA 36,4F
152B0:  DATA 2E,4B
152B2:  DATA 36,4F
152B4:  DATA 36,4F
152B6:  DATA 36,4F
152B8:  DATA 16,4F
*
1571C:  ADDWF  FE8,W
1571E:  CLRF   FF7
15720:  RLCF   FF7,F
15722:  ADDLW  3D
15724:  MOVWF  FF6
15726:  MOVLW  57
15728:  ADDWFC FF7,F
1572A:  MOVLW  01
1572C:  MOVWF  FF8
1572E:  MOVWF  FFB
15730:  TBLRD*-
15732:  MOVF   FF5,W
15734:  MOVWF  FFA
15736:  TBLRD*
15738:  MOVF   FF5,W
1573A:  MOVWF  FF9
1573C:  DATA 8E,55
1573E:  DATA AE,55
15740:  DATA CE,55
15742:  DATA EE,55
15744:  DATA 0E,56
15746:  DATA 2E,56
15748:  DATA 4E,56
*
1B2EA:  ADDWF  FE8,W
1B2EC:  CLRF   FF7
1B2EE:  RLCF   FF7,F
1B2F0:  ADDLW  0B
1B2F2:  MOVWF  FF6
1B2F4:  MOVLW  B3
1B2F6:  ADDWFC FF7,F
1B2F8:  MOVLW  01
1B2FA:  MOVWF  FF8
1B2FC:  MOVWF  FFB
1B2FE:  TBLRD*-
1B300:  MOVF   FF5,W
1B302:  MOVWF  FFA
1B304:  TBLRD*
1B306:  MOVF   FF5,W
1B308:  MOVWF  FF9
1B30A:  DATA 64,B1
1B30C:  DATA E6,B2
1B30E:  DATA 6A,B1
1B310:  DATA 5E,B1
1B312:  DATA E6,B2
1B314:  DATA E6,B2
1B316:  DATA E6,B2
1B318:  DATA 70,B1
1B31A:  DATA 24,B2
1B31C:  DATA E6,B2
1B31E:  DATA 40,B2
1B320:  DATA E6,B2
1B322:  DATA 76,B1
1B324:  DATA E6,B2
1B326:  DATA E6,B2
1B328:  DATA E6,B2
1B32A:  DATA E6,B2
1B32C:  DATA E6,B2
1B32E:  DATA E6,B2
1B330:  DATA E6,B2
1B332:  DATA E6,B2
1B334:  DATA E6,B2
1B336:  DATA E6,B2
1B338:  DATA E6,B2
1B33A:  DATA E6,B2
1B33C:  DATA E6,B2
1B33E:  DATA E6,B2
1B340:  DATA E6,B2
1B342:  DATA E6,B2
1B344:  DATA E6,B2
1B346:  DATA 7C,B1
1B348:  DATA 82,B1
1B34A:  DATA 88,B1
1B34C:  DATA 8E,B1
1B34E:  DATA 94,B1
1B350:  DATA 9A,B1
1B352:  DATA A0,B1
1B354:  DATA A6,B1
1B356:  DATA AC,B1
1B358:  DATA B2,B1
1B35A:  DATA B8,B1
1B35C:  DATA BE,B1
1B35E:  DATA C4,B1
1B360:  DATA D0,B1
1B362:  DATA D6,B1
1B364:  DATA DC,B1
1B366:  DATA E2,B1
1B368:  DATA E8,B1
1B36A:  DATA EE,B1
1B36C:  DATA F4,B1
1B36E:  DATA FA,B1
1B370:  DATA 00,B2
1B372:  DATA 06,B2
1B374:  DATA 0C,B2
1B376:  DATA 12,B2
1B378:  DATA 18,B2
1B37A:  DATA E6,B2
1B37C:  DATA E6,B2
1B37E:  DATA E6,B2
1B380:  DATA 1E,B2
1B382:  DATA E6,B2
1B384:  DATA E6,B2
1B386:  DATA 5C,B2
1B388:  DATA 62,B2
1B38A:  DATA 68,B2
1B38C:  DATA 6E,B2
1B38E:  DATA 74,B2
1B390:  DATA 7A,B2
1B392:  DATA 80,B2
1B394:  DATA 86,B2
1B396:  DATA 8C,B2
1B398:  DATA 92,B2
1B39A:  DATA 98,B2
1B39C:  DATA 9E,B2
1B39E:  DATA A4,B2
1B3A0:  DATA AA,B2
1B3A2:  DATA B0,B2
1B3A4:  DATA B6,B2
1B3A6:  DATA BC,B2
1B3A8:  DATA C2,B2
1B3AA:  DATA C6,B2
1B3AC:  DATA CA,B2
1B3AE:  DATA CE,B2
1B3B0:  DATA D2,B2
1B3B2:  DATA D8,B2
1B3B4:  DATA DC,B2
1B3B6:  DATA E0,B2
1B3B8:  DATA E4,B2
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8F4
1F8BA:  MOVFF  FF7,8F5
1F8BE:  MOVFF  FF8,8F6
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8F4,FF6
1F8CE:  MOVFF  8F5,FF7
1F8D2:  MOVFF  8F6,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8F5
1F8E0:  MOVFF  FF7,8F6
1F8E4:  MOVFF  FF8,8F7
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8F5,FF6
1F8F4:  MOVFF  8F6,FF7
1F8F8:  MOVFF  8F7,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xF4,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xF5.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xF4,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xF5,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xF4,F
1F936:  MOVLW  0A
1F938:  SUBWF  xF4,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xF5.7
1F942:  MOVF   xF5,W
1F944:  ADDWF  xF4,F
1F946:  MOVF   xF4,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xF7,W
1F956:  CLRF   01
1F958:  SUBWF  xF6,W
1F95A:  BC    1F962
1F95C:  MOVFF  8F6,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xF8
1F968:  RLCF   xF6,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xF7,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xF8,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8F4,8F6
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xF7
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8F4
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xF5.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xF5.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xF5.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xF5.3
1F9AC:  BCF    xF5.4
1F9AE:  BSF    xF5.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8F4,8F6
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xF7
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8F4
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xF5.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xF5.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xF5.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xF4,F
1F9F0:  MOVF   xF4,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8F4,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8F5,01
1FA60:  MOVFF  8F4,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... #FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... #FUSES WDT_SW   
.................... //#use delay(clock=2000000) 
....................  
.................... #FUSES NOWDT 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
02938:  MOVLW  09
0293A:  MOVWF  FEA
0293C:  MOVLW  EC
0293E:  MOVWF  FE9
02940:  MOVF   FEF,W
02942:  BZ    2960
02944:  MOVLW  14
02946:  MOVWF  01
02948:  CLRF   00
0294A:  DECFSZ 00,F
0294C:  BRA    294A
0294E:  DECFSZ 01,F
02950:  BRA    2948
02952:  MOVLW  BF
02954:  MOVWF  00
02956:  DECFSZ 00,F
02958:  BRA    2956
0295A:  BRA    295C
0295C:  DECFSZ FEF,F
0295E:  BRA    2944
02960:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E58:  BTFSS  F9E.5
00E5A:  BRA    0E58
00E5C:  MOVFF  FAB,1C
00E60:  MOVFF  FAE,01
00E64:  BTFSS  1C.1
00E66:  BRA    0E6C
00E68:  BCF    FAB.4
00E6A:  BSF    FAB.4
00E6C:  RETURN 0
*
0AEE0:  BTFSS  F9E.4
0AEE2:  BRA    AEE0
0AEE4:  MOVWF  FAD
0AEE6:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12E5A:  BTFSS  FA4.5
12E5C:  BRA    12E5A
12E5E:  MOVLB  F
12E60:  MOVFF  F22,1C
12E64:  MOVFF  F1D,01
12E68:  BTFSS  1C.1
12E6A:  BRA    12E70
12E6C:  BCF    x22.4
12E6E:  BSF    x22.4
12E70:  MOVLB  0
12E72:  RETURN 0
*
16F88:  BTFSS  FA4.4
16F8A:  BRA    16F88
16F8C:  MOVLB  F
16F8E:  MOVWF  x1C
16F90:  MOVLB  0
16F92:  GOTO   17036 (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xFA
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xFB
1F850:  MOVF   xFB,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8F9,03
1F85A:  MOVFF  8F8,FE9
1F85E:  MOVFF  8F9,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xFA,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8FC
1F870:  MOVFF  8F8,FE9
1F874:  MOVFF  8F9,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xFC,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xFA
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xFA,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8FC
1F88C:  MOVFF  8F8,FE9
1F890:  MOVFF  8F9,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xFC,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xFA
....................       }  
1F89C:  MOVF   xFB,W
1F89E:  INCF   xFB,F
1F8A0:  INCF   xF8,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xF9,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8FA,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xF8,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8F5,03
1FA84:  MOVFF  8F4,FE9
1FA88:  MOVFF  8F5,FEA
1FA8C:  MOVFF  FEF,8F9
1FA90:  MOVFF  8F7,03
1FA94:  MOVFF  8F6,FE9
1FA98:  MOVFF  8F7,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xF9,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8F5,03
1FAA6:  MOVFF  8F4,FE9
1FAAA:  MOVFF  8F5,FEA
1FAAE:  MOVFF  FEF,8F9
1FAB2:  MOVFF  8F7,03
1FAB6:  MOVFF  8F6,FE9
1FABA:  MOVFF  8F7,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xF9,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8F5,03
1FAD4:  MOVFF  8F4,FE9
1FAD8:  MOVFF  8F5,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8F5,03
1FAEA:  MOVF   xF4,W
1FAEC:  INCF   xF4,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xF5,F
1FAF2:  MOVFF  8F7,03
1FAF6:  MOVF   xF6,W
1FAF8:  INCF   xF6,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xF7,F
1FAFE:  DECF   xF8,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x85.1
1FB0E:  CLRF   x8F
1FB10:  CLRF   x8E
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xEC
1FB2A:  MOVLB  0
1FB2C:  CALL   2938
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x85.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x8B
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x8B,W
1FB3C:  ADDLW  B4
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x8B,W
1FB50:  INCF   x8B,F
1FB52:  CLRF   03
1FB54:  ADDLW  B4
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x8B,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x85.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   xB4,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xF9
1FB80:  MOVLW  B5
1FB82:  MOVWF  xF8
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,88A
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xF9
1FB92:  MOVLW  B7
1FB94:  MOVWF  xF8
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8F4
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xF9
1FBA4:  MOVLW  B9
1FBA6:  MOVWF  xF8
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8F4,88D
1FBB0:  MOVFF  01,88C
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xF9
1FBBA:  MOVLW  BB
1FBBC:  MOVWF  xF8
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,887
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  88E,892
1FBCA:  MOVFF  88F,893
1FBCE:  MOVFF  88C,890
1FBD2:  MOVFF  88D,891
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x87,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x85.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x85.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x93,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x92,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x91,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x93,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x92,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x93,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x92,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x86
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x89
1FC26:  MOVLW  03
1FC28:  SUBWF  x8B,W
1FC2A:  SUBWF  x89,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x89,W
1FC32:  ADDLW  B4
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8F4
1FC3E:  MOVFF  03,8F5
1FC42:  MOVFF  03,8F9
1FC46:  MOVFF  01,8F8
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x86,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x89,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x86,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x86
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x8B,W
1FC68:  CLRF   03
1FC6A:  ADDLW  B4
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8F4
1FC76:  MOVFF  03,8F5
1FC7A:  MOVFF  03,8F9
1FC7E:  MOVFF  01,8F8
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x86,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x85.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x87,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x89
1FCAE:  CLRF   x88
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x8B,W
1FCB4:  SUBWF  x89,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x88,W
1FCBA:  INCF   x88,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  94
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8F4
1FCCA:  MOVFF  03,8F5
1FCCE:  CLRF   03
1FCD0:  MOVF   x89,W
1FCD2:  ADDLW  B4
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8F6
1FCDE:  MOVFF  03,8F7
1FCE2:  MOVFF  03,8F9
1FCE6:  MOVFF  01,8F8
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8F5,FEA
1FCF2:  MOVFF  8F4,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x89,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xF4
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  893,8F4
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xF5
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  892,8F4
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xF5
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  891,8F4
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xF5
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  890,8F4
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xF5
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  88A,8F4
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xF5
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  892,FF8
1FD80:  MOVFF  891,FF7
1FD84:  MOVFF  890,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  94
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  88A,8F4
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  892,FF8
1FD9A:  MOVFF  891,FF7
1FD9E:  MOVFF  890,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  B4
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xF5
1FDAE:  MOVFF  88A,8F4
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xF5
1FDBC:  MOVLW  94
1FDBE:  MOVWF  xF4
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xF7
1FDC4:  MOVLW  B4
1FDC6:  MOVWF  xF6
1FDC8:  MOVFF  88A,8F8
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x85.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x87,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xF9
1FE02:  MOVLW  BD
1FE04:  MOVWF  xF8
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8F4
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xF9
1FE14:  MOVLW  BF
1FE16:  MOVWF  xF8
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8F4,88F
1FE20:  MOVFF  01,88E
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xF4
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  88E,8F4
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xF5
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x85.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x85.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xF4
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xEC
1FE8E:  MOVLB  0
1FE90:  CALL   2938
1FE94:  MOVLB  8
1FE96:  DECFSZ xF4,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... int16 valve_align_timeout = -1; 
.................... int16 valve_align_counter = -1; 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
0557C:  BCF    FF2.5
....................    restart_wdt(); 
0557E:  CLRWDT
05580:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
05582:  CLRF   FCF
05584:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
05586:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
05588:  MOVF   2F,W
0558A:  SUBLW  02
0558C:  BNZ   5594
0558E:  MOVF   30,F
05590:  BNZ   5594
05592:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
05594:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
05596:  BSF    F9D.0
05598:  GOTO   55AC (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
0559C:  MOVLW  0B
0559E:  MOVWF  FD7
055A0:  MOVLW  DC
055A2:  MOVWF  FD6
....................    restart_wdt(); 
055A4:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
055A6:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
055A8:  BSF    FF2.5
....................    setup_led_pulse(); 
055AA:  BRA    5582
055AC:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
055AE:  MOVLB  8
055B0:  MOVF   xED,W
055B2:  XORLW  00
055B4:  MOVLB  0
055B6:  BZ    55BE
055B8:  XORLW  01
055BA:  BZ    55C2
055BC:  BRA    55C4
....................       case 0 : suspend_heartbeat(); 
055BE:  RCALL  557C
....................          break; 
055C0:  BRA    55C4
....................       case 1 : restart_heartbeat(); 
055C2:  RCALL  559C
....................          break; 
....................    } 
055C4:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
0311E:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
03120:  BCF    FD1.0
03122:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
02928:  MOVLW  0B
0292A:  MOVWF  FD7
0292C:  MOVLW  DC
0292E:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
02930:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
02932:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
02934:  BSF    FD1.0
02936:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
07930:  MOVFF  9B1,9B7
07934:  MOVFF  9B0,9B6
07938:  MOVLB  9
0793A:  MOVF   xB4,F
0793C:  BNZ   7942
0793E:  MOVF   xB5,F
07940:  BZ    798C
07942:  MOVFF  9B3,03
07946:  MOVFF  9B2,FE9
0794A:  MOVFF  9B3,FEA
0794E:  MOVF   FEF,F
07950:  BZ    798C
....................      *s++ = *s2++; 
07952:  MOVFF  9B7,9B9
07956:  MOVF   xB6,W
07958:  INCF   xB6,F
0795A:  BTFSC  FD8.2
0795C:  INCF   xB7,F
0795E:  MOVWF  xB8
07960:  MOVFF  9B3,03
07964:  MOVF   xB2,W
07966:  INCF   xB2,F
07968:  BTFSC  FD8.2
0796A:  INCF   xB3,F
0796C:  MOVWF  FE9
0796E:  MOVFF  03,FEA
07972:  MOVFF  FEF,9BA
07976:  MOVFF  9B9,FEA
0797A:  MOVFF  9B8,FE9
0797E:  MOVFF  9BA,FEF
07982:  MOVF   xB4,W
07984:  BTFSC  FD8.2
07986:  DECF   xB5,F
07988:  DECF   xB4,F
0798A:  BRA    793A
....................   for (; n > 0; n--) 
0798C:  MOVF   xB4,F
0798E:  BNZ   7994
07990:  MOVF   xB5,F
07992:  BZ    79B2
....................      *s++ = '\0'; 
07994:  MOVFF  9B7,03
07998:  MOVF   xB6,W
0799A:  INCF   xB6,F
0799C:  BTFSC  FD8.2
0799E:  INCF   xB7,F
079A0:  MOVWF  FE9
079A2:  MOVFF  03,FEA
079A6:  CLRF   FEF
079A8:  MOVF   xB4,W
079AA:  BTFSC  FD8.2
079AC:  DECF   xB5,F
079AE:  DECF   xB4,F
079B0:  BRA    798C
....................  
....................   return(s1); 
079B2:  MOVFF  9B0,01
079B6:  MOVFF  9B1,02
079BA:  MOVLB  0
079BC:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05506:  MOVFF  8F9,8FD
0550A:  MOVFF  8F8,8FC
0550E:  MOVFF  8FD,03
05512:  MOVLB  8
05514:  MOVFF  8FC,FE9
05518:  MOVFF  8FD,FEA
0551C:  MOVF   FEF,F
0551E:  BZ    552C
05520:  INCF   xFC,F
05522:  BTFSC  FD8.2
05524:  INCF   xFD,F
05526:  MOVLB  0
05528:  BRA    550E
0552A:  MOVLB  8
....................    while(*s2 != '\0') 
0552C:  MOVFF  8FB,03
05530:  MOVFF  8FA,FE9
05534:  MOVFF  8FB,FEA
05538:  MOVF   FEF,F
0553A:  BZ    5566
....................    { 
....................       *s = *s2; 
0553C:  MOVFF  8FA,FE9
05540:  MOVFF  8FB,FEA
05544:  MOVFF  FEF,900
05548:  MOVLB  9
0554A:  MOVFF  8FD,FEA
0554E:  MOVFF  8FC,FE9
05552:  MOVFF  900,FEF
....................       ++s; 
05556:  MOVLB  8
05558:  INCF   xFC,F
0555A:  BTFSC  FD8.2
0555C:  INCF   xFD,F
....................       ++s2; 
0555E:  INCF   xFA,F
05560:  BTFSC  FD8.2
05562:  INCF   xFB,F
05564:  BRA    552C
....................    } 
....................  
....................    *s = '\0'; 
05566:  MOVFF  8FC,FE9
0556A:  MOVFF  8FD,FEA
0556E:  CLRF   FEF
....................    return(s1); 
05570:  MOVFF  8F8,01
05574:  MOVFF  8F9,02
05578:  MOVLB  0
0557A:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12DD6:  MOVFF  8EE,8F4
12DDA:  MOVFF  8ED,8F3
12DDE:  MOVFF  8F4,03
12DE2:  MOVLB  8
12DE4:  MOVFF  8F3,FE9
12DE8:  MOVFF  8F4,FEA
12DEC:  MOVF   FEF,F
12DEE:  BZ    12DFC
12DF0:  INCF   xF3,F
12DF2:  BTFSC  FD8.2
12DF4:  INCF   xF4,F
12DF6:  MOVLB  0
12DF8:  BRA    12DDE
12DFA:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12DFC:  MOVFF  8F0,03
12E00:  MOVFF  8EF,FE9
12E04:  MOVFF  8F0,FEA
12E08:  MOVF   FEF,F
12E0A:  BZ    12E44
12E0C:  MOVF   xF2,F
12E0E:  BNZ   12E16
12E10:  MOVF   xF1,W
12E12:  SUBLW  00
12E14:  BC    12E44
....................    { 
....................       *s = *s2; 
12E16:  MOVFF  8EF,FE9
12E1A:  MOVFF  8F0,FEA
12E1E:  MOVFF  FEF,8F7
12E22:  MOVFF  8F4,FEA
12E26:  MOVFF  8F3,FE9
12E2A:  MOVFF  8F7,FEF
....................       ++s; 
12E2E:  INCF   xF3,F
12E30:  BTFSC  FD8.2
12E32:  INCF   xF4,F
....................       ++s2; 
12E34:  INCF   xEF,F
12E36:  BTFSC  FD8.2
12E38:  INCF   xF0,F
....................       --n; 
12E3A:  MOVF   xF1,W
12E3C:  BTFSC  FD8.2
12E3E:  DECF   xF2,F
12E40:  DECF   xF1,F
12E42:  BRA    12DFC
....................    } 
....................  
....................    *s = '\0'; 
12E44:  MOVFF  8F3,FE9
12E48:  MOVFF  8F4,FEA
12E4C:  CLRF   FEF
....................    return(s1); 
12E4E:  MOVFF  8ED,01
12E52:  MOVFF  8EE,02
12E56:  MOVLB  0
12E58:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
04634:  MOVFF  9EA,9F0
04638:  MOVFF  9E9,9EF
0463C:  MOVFF  9EC,9F2
04640:  MOVFF  9EB,9F1
04644:  MOVLB  9
04646:  MOVF   xEE,F
04648:  BNZ   4650
0464A:  MOVF   xED,W
0464C:  SUBLW  00
0464E:  BC    46B0
.................... { 
....................    if(*su1!=*su2) 
04650:  MOVFF  9EF,FE9
04654:  MOVFF  9F0,FEA
04658:  MOVFF  FEF,9F3
0465C:  MOVFF  9F2,03
04660:  MOVFF  9F1,FE9
04664:  MOVFF  9F2,FEA
04668:  MOVF   FEF,W
0466A:  SUBWF  xF3,W
0466C:  BZ    469A
....................       return ((*su1<*su2)?-1:1); 
0466E:  MOVFF  9F0,03
04672:  MOVFF  9EF,FE9
04676:  MOVFF  03,FEA
0467A:  MOVFF  FEF,9F3
0467E:  MOVFF  9F2,03
04682:  MOVFF  9F1,FE9
04686:  MOVFF  9F2,FEA
0468A:  MOVF   FEF,W
0468C:  SUBWF  xF3,W
0468E:  BC    4694
04690:  MOVLW  FF
04692:  BRA    4696
04694:  MOVLW  01
04696:  MOVWF  01
04698:  BRA    46B4
0469A:  INCF   xEF,F
0469C:  BTFSC  FD8.2
0469E:  INCF   xF0,F
046A0:  INCF   xF1,F
046A2:  BTFSC  FD8.2
046A4:  INCF   xF2,F
046A6:  MOVF   xED,W
046A8:  BTFSC  FD8.2
046AA:  DECF   xEE,F
046AC:  DECF   xED,F
046AE:  BRA    4646
.................... } 
.................... return 0; 
046B0:  MOVLW  00
046B2:  MOVWF  01
046B4:  MOVLB  0
046B6:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12D9A:  MOVFF  8EC,8EE
12D9E:  MOVFF  8EB,8ED
12DA2:  MOVFF  8EE,03
12DA6:  MOVLB  8
12DA8:  MOVFF  8ED,FE9
12DAC:  MOVFF  8EE,FEA
12DB0:  MOVF   FEF,F
12DB2:  BZ    12DC0
12DB4:  INCF   xED,F
12DB6:  BTFSC  FD8.2
12DB8:  INCF   xEE,F
12DBA:  MOVLB  0
12DBC:  BRA    12DA2
12DBE:  MOVLB  8
....................    return(sc - s); 
12DC0:  MOVF   xEB,W
12DC2:  SUBWF  xED,W
12DC4:  MOVWF  00
12DC6:  MOVF   xEC,W
12DC8:  SUBWFB xEE,W
12DCA:  MOVWF  03
12DCC:  MOVFF  00,01
12DD0:  MOVWF  02
12DD2:  MOVLB  0
12DD4:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
1341A:  MOVLB  8
1341C:  CLRF   xDA
....................    sign = 0; 
1341E:  CLRF   xD8
....................    base = 10; 
13420:  MOVLW  0A
13422:  MOVWF  xD9
....................    result = 0; 
13424:  CLRF   xD7
13426:  CLRF   xD6
....................  
....................    if (!s) 
13428:  MOVF   xD4,W
1342A:  IORWF  xD5,W
1342C:  BNZ   13436
....................       return 0; 
1342E:  MOVLW  00
13430:  MOVWF  01
13432:  MOVWF  02
13434:  BRA    135FA
....................    c = s[index++]; 
13436:  MOVF   xDA,W
13438:  INCF   xDA,F
1343A:  ADDWF  xD4,W
1343C:  MOVWF  FE9
1343E:  MOVLW  00
13440:  ADDWFC xD5,W
13442:  MOVWF  FEA
13444:  MOVFF  FEF,8DB
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
13448:  MOVF   xDB,W
1344A:  SUBLW  2D
1344C:  BNZ   13466
....................    { 
....................       sign = 1;         // Set the sign to negative 
1344E:  MOVLW  01
13450:  MOVWF  xD8
....................       c = s[index++]; 
13452:  MOVF   xDA,W
13454:  INCF   xDA,F
13456:  ADDWF  xD4,W
13458:  MOVWF  FE9
1345A:  MOVLW  00
1345C:  ADDWFC xD5,W
1345E:  MOVWF  FEA
13460:  MOVFF  FEF,8DB
....................    } 
13464:  BRA    1347E
....................    else if (c == '+') 
13466:  MOVF   xDB,W
13468:  SUBLW  2B
1346A:  BNZ   1347E
....................    { 
....................       c = s[index++]; 
1346C:  MOVF   xDA,W
1346E:  INCF   xDA,F
13470:  ADDWF  xD4,W
13472:  MOVWF  FE9
13474:  MOVLW  00
13476:  ADDWFC xD5,W
13478:  MOVWF  FEA
1347A:  MOVFF  FEF,8DB
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1347E:  MOVF   xDB,W
13480:  SUBLW  2F
13482:  BTFSC  FD8.0
13484:  BRA    135DE
13486:  MOVF   xDB,W
13488:  SUBLW  39
1348A:  BTFSS  FD8.0
1348C:  BRA    135DE
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1348E:  MOVF   xDB,W
13490:  SUBLW  30
13492:  BNZ   134D0
13494:  MOVF   xDA,W
13496:  ADDWF  xD4,W
13498:  MOVWF  FE9
1349A:  MOVLW  00
1349C:  ADDWFC xD5,W
1349E:  MOVWF  FEA
134A0:  MOVF   FEF,W
134A2:  SUBLW  78
134A4:  BZ    134B8
134A6:  MOVF   xDA,W
134A8:  ADDWF  xD4,W
134AA:  MOVWF  FE9
134AC:  MOVLW  00
134AE:  ADDWFC xD5,W
134B0:  MOVWF  FEA
134B2:  MOVF   FEF,W
134B4:  SUBLW  58
134B6:  BNZ   134D0
....................       { 
....................          base = 16; 
134B8:  MOVLW  10
134BA:  MOVWF  xD9
....................          index++; 
134BC:  INCF   xDA,F
....................          c = s[index++]; 
134BE:  MOVF   xDA,W
134C0:  INCF   xDA,F
134C2:  ADDWF  xD4,W
134C4:  MOVWF  FE9
134C6:  MOVLW  00
134C8:  ADDWFC xD5,W
134CA:  MOVWF  FEA
134CC:  MOVFF  FEF,8DB
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
134D0:  MOVF   xD9,W
134D2:  SUBLW  0A
134D4:  BNZ   1351A
....................       { 
....................          while (c >= '0' && c <= '9') 
134D6:  MOVF   xDB,W
134D8:  SUBLW  2F
134DA:  BC    13518
134DC:  MOVF   xDB,W
134DE:  SUBLW  39
134E0:  BNC   13518
....................          { 
....................             result = 10*result + (c - '0'); 
134E2:  CLRF   xDD
134E4:  MOVLW  0A
134E6:  MOVWF  xDC
134E8:  MOVFF  8D7,8DF
134EC:  MOVFF  8D6,8DE
134F0:  MOVLB  0
134F2:  BRA    133C4
134F4:  MOVLW  30
134F6:  MOVLB  8
134F8:  SUBWF  xDB,W
134FA:  ADDWF  01,W
134FC:  MOVWF  xD6
134FE:  MOVLW  00
13500:  ADDWFC 02,W
13502:  MOVWF  xD7
....................             c = s[index++]; 
13504:  MOVF   xDA,W
13506:  INCF   xDA,F
13508:  ADDWF  xD4,W
1350A:  MOVWF  FE9
1350C:  MOVLW  00
1350E:  ADDWFC xD5,W
13510:  MOVWF  FEA
13512:  MOVFF  FEF,8DB
13516:  BRA    134D6
....................          } 
....................       } 
13518:  BRA    135DE
....................       else if (base == 16)    // The number is a hexa number 
1351A:  MOVF   xD9,W
1351C:  SUBLW  10
1351E:  BNZ   135DE
....................       { 
....................          c = toupper(c); 
13520:  MOVF   xDB,W
13522:  SUBLW  60
13524:  BC    13532
13526:  MOVF   xDB,W
13528:  SUBLW  7A
1352A:  BNC   13532
1352C:  MOVF   xDB,W
1352E:  ANDLW  DF
13530:  BRA    13534
13532:  MOVF   xDB,W
13534:  MOVWF  xDB
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
13536:  MOVF   xDB,W
13538:  SUBLW  2F
1353A:  BC    13542
1353C:  MOVF   xDB,W
1353E:  SUBLW  39
13540:  BC    1354E
13542:  MOVF   xDB,W
13544:  SUBLW  40
13546:  BC    135DE
13548:  MOVF   xDB,W
1354A:  SUBLW  46
1354C:  BNC   135DE
....................          { 
....................             if (c >= '0' && c <= '9') 
1354E:  MOVF   xDB,W
13550:  SUBLW  2F
13552:  BC    13588
13554:  MOVF   xDB,W
13556:  SUBLW  39
13558:  BNC   13588
....................                result = (result << 4) + (c - '0'); 
1355A:  RLCF   xD6,W
1355C:  MOVWF  xDC
1355E:  RLCF   xD7,W
13560:  MOVWF  xDD
13562:  RLCF   xDC,F
13564:  RLCF   xDD,F
13566:  RLCF   xDC,F
13568:  RLCF   xDD,F
1356A:  RLCF   xDC,F
1356C:  RLCF   xDD,F
1356E:  MOVLW  F0
13570:  ANDWF  xDC,F
13572:  MOVLW  30
13574:  SUBWF  xDB,W
13576:  ADDWF  xDC,W
13578:  MOVWF  01
1357A:  MOVLW  00
1357C:  ADDWFC xDD,W
1357E:  MOVWF  03
13580:  MOVFF  01,8D6
13584:  MOVWF  xD7
13586:  BRA    135B4
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
13588:  RLCF   xD6,W
1358A:  MOVWF  xDC
1358C:  RLCF   xD7,W
1358E:  MOVWF  xDD
13590:  RLCF   xDC,F
13592:  RLCF   xDD,F
13594:  RLCF   xDC,F
13596:  RLCF   xDD,F
13598:  RLCF   xDC,F
1359A:  RLCF   xDD,F
1359C:  MOVLW  F0
1359E:  ANDWF  xDC,F
135A0:  MOVLW  41
135A2:  SUBWF  xDB,W
135A4:  ADDLW  0A
135A6:  ADDWF  xDC,W
135A8:  MOVWF  01
135AA:  MOVLW  00
135AC:  ADDWFC xDD,W
135AE:  MOVFF  01,8D6
135B2:  MOVWF  xD7
....................  
....................             c = s[index++];c = toupper(c); 
135B4:  MOVF   xDA,W
135B6:  INCF   xDA,F
135B8:  ADDWF  xD4,W
135BA:  MOVWF  FE9
135BC:  MOVLW  00
135BE:  ADDWFC xD5,W
135C0:  MOVWF  FEA
135C2:  MOVFF  FEF,8DB
135C6:  MOVF   xDB,W
135C8:  SUBLW  60
135CA:  BC    135D8
135CC:  MOVF   xDB,W
135CE:  SUBLW  7A
135D0:  BNC   135D8
135D2:  MOVF   xDB,W
135D4:  ANDLW  DF
135D6:  BRA    135DA
135D8:  MOVF   xDB,W
135DA:  MOVWF  xDB
135DC:  BRA    13536
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
135DE:  MOVF   xD9,W
135E0:  SUBLW  0A
135E2:  BNZ   135F2
135E4:  DECFSZ xD8,W
135E6:  BRA    135F2
....................       result = -result; 
135E8:  COMF   xD6,F
135EA:  COMF   xD7,F
135EC:  INCF   xD6,F
135EE:  BTFSC  FD8.2
135F0:  INCF   xD7,F
....................  
....................    return(result); 
135F2:  MOVFF  8D6,01
135F6:  MOVFF  8D7,02
135FA:  MOVLB  0
135FC:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0AF2A:  MOVLB  8
0AF2C:  CLRF   x8D
....................    sign = 0; 
0AF2E:  CLRF   x8B
....................    base = 10; 
0AF30:  MOVLW  0A
0AF32:  MOVWF  x8C
....................    result = 0; 
0AF34:  CLRF   x8A
0AF36:  CLRF   x89
0AF38:  CLRF   x88
0AF3A:  CLRF   x87
....................  
....................    if (!s) 
0AF3C:  MOVF   x85,W
0AF3E:  IORWF  x86,W
0AF40:  BNZ   AF4C
....................       return 0; 
0AF42:  CLRF   00
0AF44:  CLRF   01
0AF46:  CLRF   02
0AF48:  CLRF   03
0AF4A:  BRA    B1BA
....................    c = s[index++]; 
0AF4C:  MOVF   x8D,W
0AF4E:  INCF   x8D,F
0AF50:  ADDWF  x85,W
0AF52:  MOVWF  FE9
0AF54:  MOVLW  00
0AF56:  ADDWFC x86,W
0AF58:  MOVWF  FEA
0AF5A:  MOVFF  FEF,88E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0AF5E:  MOVF   x8E,W
0AF60:  SUBLW  2D
0AF62:  BNZ   AF7C
....................    { 
....................       sign = 1;         // Set the sign to negative 
0AF64:  MOVLW  01
0AF66:  MOVWF  x8B
....................       c = s[index++]; 
0AF68:  MOVF   x8D,W
0AF6A:  INCF   x8D,F
0AF6C:  ADDWF  x85,W
0AF6E:  MOVWF  FE9
0AF70:  MOVLW  00
0AF72:  ADDWFC x86,W
0AF74:  MOVWF  FEA
0AF76:  MOVFF  FEF,88E
....................    } 
0AF7A:  BRA    AF94
....................    else if (c == '+') 
0AF7C:  MOVF   x8E,W
0AF7E:  SUBLW  2B
0AF80:  BNZ   AF94
....................    { 
....................       c = s[index++]; 
0AF82:  MOVF   x8D,W
0AF84:  INCF   x8D,F
0AF86:  ADDWF  x85,W
0AF88:  MOVWF  FE9
0AF8A:  MOVLW  00
0AF8C:  ADDWFC x86,W
0AF8E:  MOVWF  FEA
0AF90:  MOVFF  FEF,88E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0AF94:  MOVF   x8E,W
0AF96:  SUBLW  2F
0AF98:  BTFSC  FD8.0
0AF9A:  BRA    B18A
0AF9C:  MOVF   x8E,W
0AF9E:  SUBLW  39
0AFA0:  BTFSS  FD8.0
0AFA2:  BRA    B18A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0AFA4:  MOVF   x8E,W
0AFA6:  SUBLW  30
0AFA8:  BNZ   AFE6
0AFAA:  MOVF   x8D,W
0AFAC:  ADDWF  x85,W
0AFAE:  MOVWF  FE9
0AFB0:  MOVLW  00
0AFB2:  ADDWFC x86,W
0AFB4:  MOVWF  FEA
0AFB6:  MOVF   FEF,W
0AFB8:  SUBLW  78
0AFBA:  BZ    AFCE
0AFBC:  MOVF   x8D,W
0AFBE:  ADDWF  x85,W
0AFC0:  MOVWF  FE9
0AFC2:  MOVLW  00
0AFC4:  ADDWFC x86,W
0AFC6:  MOVWF  FEA
0AFC8:  MOVF   FEF,W
0AFCA:  SUBLW  58
0AFCC:  BNZ   AFE6
....................       { 
....................          base = 16; 
0AFCE:  MOVLW  10
0AFD0:  MOVWF  x8C
....................          index++; 
0AFD2:  INCF   x8D,F
....................          c = s[index++]; 
0AFD4:  MOVF   x8D,W
0AFD6:  INCF   x8D,F
0AFD8:  ADDWF  x85,W
0AFDA:  MOVWF  FE9
0AFDC:  MOVLW  00
0AFDE:  ADDWFC x86,W
0AFE0:  MOVWF  FEA
0AFE2:  MOVFF  FEF,88E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0AFE6:  MOVF   x8C,W
0AFE8:  SUBLW  0A
0AFEA:  BNZ   B072
....................       { 
....................          while (c >= '0' && c <= '9') { 
0AFEC:  MOVF   x8E,W
0AFEE:  SUBLW  2F
0AFF0:  BC    B070
0AFF2:  MOVF   x8E,W
0AFF4:  SUBLW  39
0AFF6:  BNC   B070
....................             result = (result << 1) + (result << 3);  // result *= 10; 
0AFF8:  BCF    FD8.0
0AFFA:  RLCF   x87,W
0AFFC:  MOVWF  x90
0AFFE:  RLCF   x88,W
0B000:  MOVWF  x91
0B002:  RLCF   x89,W
0B004:  MOVWF  x92
0B006:  RLCF   x8A,W
0B008:  MOVWF  x93
0B00A:  RLCF   x87,W
0B00C:  MOVWF  00
0B00E:  RLCF   x88,W
0B010:  MOVWF  01
0B012:  RLCF   x89,W
0B014:  MOVWF  02
0B016:  RLCF   x8A,W
0B018:  MOVWF  03
0B01A:  RLCF   00,F
0B01C:  RLCF   01,F
0B01E:  RLCF   02,F
0B020:  RLCF   03,F
0B022:  RLCF   00,F
0B024:  RLCF   01,F
0B026:  RLCF   02,F
0B028:  RLCF   03,F
0B02A:  MOVLW  F8
0B02C:  ANDWF  00,F
0B02E:  MOVF   x90,W
0B030:  ADDWF  00,F
0B032:  MOVF   x91,W
0B034:  ADDWFC 01,F
0B036:  MOVF   x92,W
0B038:  ADDWFC 02,F
0B03A:  MOVF   x93,W
0B03C:  ADDWFC 03,F
0B03E:  MOVFF  03,88A
0B042:  MOVFF  02,889
0B046:  MOVFF  01,888
0B04A:  MOVFF  00,887
....................             result += (c - '0'); 
0B04E:  MOVLW  30
0B050:  SUBWF  x8E,W
0B052:  ADDWF  x87,F
0B054:  MOVLW  00
0B056:  ADDWFC x88,F
0B058:  ADDWFC x89,F
0B05A:  ADDWFC x8A,F
....................             c = s[index++]; 
0B05C:  MOVF   x8D,W
0B05E:  INCF   x8D,F
0B060:  ADDWF  x85,W
0B062:  MOVWF  FE9
0B064:  MOVLW  00
0B066:  ADDWFC x86,W
0B068:  MOVWF  FEA
0B06A:  MOVFF  FEF,88E
0B06E:  BRA    AFEC
....................          } 
....................       } 
0B070:  BRA    B18A
....................       else if (base == 16)    // The number is a hexa number 
0B072:  MOVF   x8C,W
0B074:  SUBLW  10
0B076:  BTFSS  FD8.2
0B078:  BRA    B18A
....................       { 
....................          c = toupper(c); 
0B07A:  MOVF   x8E,W
0B07C:  SUBLW  60
0B07E:  BC    B08C
0B080:  MOVF   x8E,W
0B082:  SUBLW  7A
0B084:  BNC   B08C
0B086:  MOVF   x8E,W
0B088:  ANDLW  DF
0B08A:  BRA    B08E
0B08C:  MOVF   x8E,W
0B08E:  MOVWF  x8E
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0B090:  MOVF   x8E,W
0B092:  SUBLW  2F
0B094:  BC    B09C
0B096:  MOVF   x8E,W
0B098:  SUBLW  39
0B09A:  BC    B0AA
0B09C:  MOVF   x8E,W
0B09E:  SUBLW  40
0B0A0:  BTFSC  FD8.0
0B0A2:  BRA    B18A
0B0A4:  MOVF   x8E,W
0B0A6:  SUBLW  46
0B0A8:  BNC   B18A
....................          { 
....................             if (c >= '0' && c <= '9') 
0B0AA:  MOVF   x8E,W
0B0AC:  SUBLW  2F
0B0AE:  BC    B10C
0B0B0:  MOVF   x8E,W
0B0B2:  SUBLW  39
0B0B4:  BNC   B10C
....................                result = (result << 4) + (c - '0'); 
0B0B6:  RLCF   x87,W
0B0B8:  MOVWF  x90
0B0BA:  RLCF   x88,W
0B0BC:  MOVWF  x91
0B0BE:  RLCF   x89,W
0B0C0:  MOVWF  x92
0B0C2:  RLCF   x8A,W
0B0C4:  MOVWF  x93
0B0C6:  RLCF   x90,F
0B0C8:  RLCF   x91,F
0B0CA:  RLCF   x92,F
0B0CC:  RLCF   x93,F
0B0CE:  RLCF   x90,F
0B0D0:  RLCF   x91,F
0B0D2:  RLCF   x92,F
0B0D4:  RLCF   x93,F
0B0D6:  RLCF   x90,F
0B0D8:  RLCF   x91,F
0B0DA:  RLCF   x92,F
0B0DC:  RLCF   x93,F
0B0DE:  MOVLW  F0
0B0E0:  ANDWF  x90,F
0B0E2:  MOVLW  30
0B0E4:  SUBWF  x8E,W
0B0E6:  ADDWF  x90,W
0B0E8:  MOVWF  00
0B0EA:  MOVLW  00
0B0EC:  ADDWFC x91,W
0B0EE:  MOVWF  01
0B0F0:  MOVLW  00
0B0F2:  ADDWFC x92,W
0B0F4:  MOVWF  02
0B0F6:  MOVLW  00
0B0F8:  ADDWFC x93,W
0B0FA:  MOVWF  03
0B0FC:  MOVWF  x8A
0B0FE:  MOVFF  02,889
0B102:  MOVFF  01,888
0B106:  MOVFF  00,887
0B10A:  BRA    B160
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B10C:  RLCF   x87,W
0B10E:  MOVWF  x90
0B110:  RLCF   x88,W
0B112:  MOVWF  x91
0B114:  RLCF   x89,W
0B116:  MOVWF  x92
0B118:  RLCF   x8A,W
0B11A:  MOVWF  x93
0B11C:  RLCF   x90,F
0B11E:  RLCF   x91,F
0B120:  RLCF   x92,F
0B122:  RLCF   x93,F
0B124:  RLCF   x90,F
0B126:  RLCF   x91,F
0B128:  RLCF   x92,F
0B12A:  RLCF   x93,F
0B12C:  RLCF   x90,F
0B12E:  RLCF   x91,F
0B130:  RLCF   x92,F
0B132:  RLCF   x93,F
0B134:  MOVLW  F0
0B136:  ANDWF  x90,F
0B138:  MOVLW  41
0B13A:  SUBWF  x8E,W
0B13C:  ADDLW  0A
0B13E:  ADDWF  x90,W
0B140:  MOVWF  00
0B142:  MOVLW  00
0B144:  ADDWFC x91,W
0B146:  MOVWF  01
0B148:  MOVLW  00
0B14A:  ADDWFC x92,W
0B14C:  MOVWF  02
0B14E:  MOVLW  00
0B150:  ADDWFC x93,W
0B152:  MOVWF  x8A
0B154:  MOVFF  02,889
0B158:  MOVFF  01,888
0B15C:  MOVFF  00,887
....................  
....................             c = s[index++];c = toupper(c); 
0B160:  MOVF   x8D,W
0B162:  INCF   x8D,F
0B164:  ADDWF  x85,W
0B166:  MOVWF  FE9
0B168:  MOVLW  00
0B16A:  ADDWFC x86,W
0B16C:  MOVWF  FEA
0B16E:  MOVFF  FEF,88E
0B172:  MOVF   x8E,W
0B174:  SUBLW  60
0B176:  BC    B184
0B178:  MOVF   x8E,W
0B17A:  SUBLW  7A
0B17C:  BNC   B184
0B17E:  MOVF   x8E,W
0B180:  ANDLW  DF
0B182:  BRA    B186
0B184:  MOVF   x8E,W
0B186:  MOVWF  x8E
0B188:  BRA    B090
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0B18A:  MOVF   x8C,W
0B18C:  SUBLW  0A
0B18E:  BNZ   B1AA
0B190:  DECFSZ x8B,W
0B192:  BRA    B1AA
....................       result = -result; 
0B194:  COMF   x87,F
0B196:  COMF   x88,F
0B198:  COMF   x89,F
0B19A:  COMF   x8A,F
0B19C:  INCF   x87,F
0B19E:  BTFSC  FD8.2
0B1A0:  INCF   x88,F
0B1A2:  BTFSC  FD8.2
0B1A4:  INCF   x89,F
0B1A6:  BTFSC  FD8.2
0B1A8:  INCF   x8A,F
....................  
....................    return(result); 
0B1AA:  MOVFF  887,00
0B1AE:  MOVFF  888,01
0B1B2:  MOVFF  889,02
0B1B6:  MOVFF  88A,03
0B1BA:  MOVLB  0
0B1BC:  GOTO   1B60C (RETURN)
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0CAD2:  MOVLB  8
0CAD4:  CLRF   xA4
0CAD6:  CLRF   xA3
0CAD8:  CLRF   xA2
0CADA:  MOVLW  7F
0CADC:  MOVWF  xA1
0CADE:  CLRF   xA8
0CAE0:  CLRF   xA7
0CAE2:  CLRF   xA6
0CAE4:  CLRF   xA5
0CAE6:  BSF    xA9.0
0CAE8:  BCF    xA9.1
0CAEA:  BCF    xA9.2
0CAEC:  CLRF   xAB
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0CAEE:  MOVF   x9D,W
0CAF0:  IORWF  x9E,W
0CAF2:  BNZ   CAFE
....................       return 0; 
0CAF4:  CLRF   00
0CAF6:  CLRF   01
0CAF8:  CLRF   02
0CAFA:  CLRF   03
0CAFC:  BRA    CD28
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0CAFE:  MOVF   xAB,W
0CB00:  INCF   xAB,F
0CB02:  ADDWF  x9D,W
0CB04:  MOVWF  FE9
0CB06:  MOVLW  00
0CB08:  ADDWFC x9E,W
0CB0A:  MOVWF  FEA
0CB0C:  MOVFF  FEF,8AA
0CB10:  MOVF   xAA,F
0CB12:  BTFSC  FD8.2
0CB14:  BRA    CCAA
....................    { 
....................       if (skip && !isspace(c)) 
0CB16:  BTFSS  xA9.0
0CB18:  BRA    CB38
0CB1A:  MOVF   xAA,W
0CB1C:  SUBLW  20
0CB1E:  BZ    CB38
....................       { 
....................          skip = 0; 
0CB20:  BCF    xA9.0
....................          if (c == '+') 
0CB22:  MOVF   xAA,W
0CB24:  SUBLW  2B
0CB26:  BNZ   CB2E
....................          { 
....................             sign = 0; 
0CB28:  BCF    xA9.1
....................             continue; 
0CB2A:  BRA    CC92
....................          }             
0CB2C:  BRA    CB38
....................          else if (c == '-') 
0CB2E:  MOVF   xAA,W
0CB30:  SUBLW  2D
0CB32:  BNZ   CB38
....................          { 
....................             sign = 1; 
0CB34:  BSF    xA9.1
....................             continue; 
0CB36:  BRA    CC92
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0CB38:  BTFSC  xA9.0
0CB3A:  BRA    CB4A
0CB3C:  MOVF   xAA,W
0CB3E:  SUBLW  2E
0CB40:  BNZ   CB4A
0CB42:  BTFSC  xA9.2
0CB44:  BRA    CB4A
....................          point = 1; 
0CB46:  BSF    xA9.2
0CB48:  BRA    CC92
....................       else if (!skip && isdigit(c)) 
0CB4A:  BTFSC  xA9.0
0CB4C:  BRA    CC8C
0CB4E:  MOVF   xAA,W
0CB50:  SUBLW  2F
0CB52:  BTFSC  FD8.0
0CB54:  BRA    CC8C
0CB56:  MOVF   xAA,W
0CB58:  SUBLW  39
0CB5A:  BTFSS  FD8.0
0CB5C:  BRA    CC8C
....................       { 
....................          c -= '0'; 
0CB5E:  MOVLW  30
0CB60:  SUBWF  xAA,F
....................          if (point) 
0CB62:  BTFSS  xA9.2
0CB64:  BRA    CC12
....................          { 
....................             pow10 = pow10 * 10.0; 
0CB66:  MOVFF  8A4,916
0CB6A:  MOVFF  8A3,915
0CB6E:  MOVFF  8A2,914
0CB72:  MOVFF  8A1,913
0CB76:  MOVLB  9
0CB78:  CLRF   x1A
0CB7A:  CLRF   x19
0CB7C:  MOVLW  20
0CB7E:  MOVWF  x18
0CB80:  MOVLW  82
0CB82:  MOVWF  x17
0CB84:  MOVLB  0
0CB86:  CALL   C2EC
0CB8A:  MOVFF  03,8A4
0CB8E:  MOVFF  02,8A3
0CB92:  MOVFF  01,8A2
0CB96:  MOVFF  00,8A1
....................             result += (float)c / pow10;    
0CB9A:  MOVLB  9
0CB9C:  CLRF   x18
0CB9E:  MOVFF  8AA,917
0CBA2:  MOVLB  0
0CBA4:  RCALL  C91E
0CBA6:  MOVFF  03,8AF
0CBAA:  MOVFF  02,8AE
0CBAE:  MOVFF  01,8AD
0CBB2:  MOVFF  00,8AC
0CBB6:  MOVFF  03,8FE
0CBBA:  MOVFF  02,8FD
0CBBE:  MOVFF  01,8FC
0CBC2:  MOVFF  00,8FB
0CBC6:  MOVFF  8A4,902
0CBCA:  MOVFF  8A3,901
0CBCE:  MOVFF  8A2,900
0CBD2:  MOVFF  8A1,8FF
0CBD6:  RCALL  C954
0CBD8:  BCF    FD8.1
0CBDA:  MOVFF  8A8,91A
0CBDE:  MOVFF  8A7,919
0CBE2:  MOVFF  8A6,918
0CBE6:  MOVFF  8A5,917
0CBEA:  MOVFF  03,91E
0CBEE:  MOVFF  02,91D
0CBF2:  MOVFF  01,91C
0CBF6:  MOVFF  00,91B
0CBFA:  CALL   C3E2
0CBFE:  MOVFF  03,8A8
0CC02:  MOVFF  02,8A7
0CC06:  MOVFF  01,8A6
0CC0A:  MOVFF  00,8A5
....................          } 
0CC0E:  BRA    CC88
0CC10:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0CC12:  MOVLB  9
0CC14:  CLRF   x16
0CC16:  CLRF   x15
0CC18:  MOVLW  20
0CC1A:  MOVWF  x14
0CC1C:  MOVLW  82
0CC1E:  MOVWF  x13
0CC20:  MOVFF  8A8,91A
0CC24:  MOVFF  8A7,919
0CC28:  MOVFF  8A6,918
0CC2C:  MOVFF  8A5,917
0CC30:  MOVLB  0
0CC32:  CALL   C2EC
0CC36:  MOVFF  03,8AF
0CC3A:  MOVFF  02,8AE
0CC3E:  MOVFF  01,8AD
0CC42:  MOVFF  00,8AC
0CC46:  MOVLB  9
0CC48:  CLRF   x18
0CC4A:  MOVFF  8AA,917
0CC4E:  MOVLB  0
0CC50:  RCALL  C91E
0CC52:  BCF    FD8.1
0CC54:  MOVFF  8AF,91A
0CC58:  MOVFF  8AE,919
0CC5C:  MOVFF  8AD,918
0CC60:  MOVFF  8AC,917
0CC64:  MOVFF  03,91E
0CC68:  MOVFF  02,91D
0CC6C:  MOVFF  01,91C
0CC70:  MOVFF  00,91B
0CC74:  CALL   C3E2
0CC78:  MOVFF  03,8A8
0CC7C:  MOVFF  02,8A7
0CC80:  MOVFF  01,8A6
0CC84:  MOVFF  00,8A5
....................          } 
....................       } 
0CC88:  BRA    CC94
0CC8A:  MOVLB  8
....................       else if (!skip) 
0CC8C:  BTFSC  xA9.0
0CC8E:  BRA    CC92
....................          break; 
0CC90:  BRA    CCAA
0CC92:  MOVLB  0
0CC94:  MOVLB  8
0CC96:  MOVF   xAB,W
0CC98:  INCF   xAB,F
0CC9A:  ADDWF  x9D,W
0CC9C:  MOVWF  FE9
0CC9E:  MOVLW  00
0CCA0:  ADDWFC x9E,W
0CCA2:  MOVWF  FEA
0CCA4:  MOVFF  FEF,8AA
0CCA8:  BRA    CB10
....................    } 
....................  
....................    if (sign) 
0CCAA:  BTFSS  xA9.1
0CCAC:  BRA    CCE4
....................       result = -1*result; 
0CCAE:  MOVLB  9
0CCB0:  CLRF   x16
0CCB2:  CLRF   x15
0CCB4:  MOVLW  80
0CCB6:  MOVWF  x14
0CCB8:  MOVLW  7F
0CCBA:  MOVWF  x13
0CCBC:  MOVFF  8A8,91A
0CCC0:  MOVFF  8A7,919
0CCC4:  MOVFF  8A6,918
0CCC8:  MOVFF  8A5,917
0CCCC:  MOVLB  0
0CCCE:  CALL   C2EC
0CCD2:  MOVFF  03,8A8
0CCD6:  MOVFF  02,8A7
0CCDA:  MOVFF  01,8A6
0CCDE:  MOVFF  00,8A5
0CCE2:  MOVLB  8
....................        
....................    if(endptr) 
0CCE4:  MOVF   x9F,W
0CCE6:  IORWF  xA0,W
0CCE8:  BZ    CD18
....................    { 
....................       if (ptr) { 
0CCEA:  MOVF   xAB,F
0CCEC:  BZ    CD06
....................          ptr--; 
0CCEE:  DECF   xAB,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0CCF0:  MOVFF  89F,FE9
0CCF4:  MOVFF  8A0,FEA
0CCF8:  MOVF   xAB,W
0CCFA:  ADDWF  x9D,W
0CCFC:  MOVWF  FEF
0CCFE:  MOVLW  00
0CD00:  ADDWFC x9E,W
0CD02:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0CD04:  BRA    CD18
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0CD06:  MOVFF  89F,FE9
0CD0A:  MOVFF  8A0,FEA
0CD0E:  MOVFF  89E,FEC
0CD12:  MOVF   FED,F
0CD14:  MOVFF  89D,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0CD18:  MOVFF  8A5,00
0CD1C:  MOVFF  8A6,01
0CD20:  MOVFF  8A7,02
0CD24:  MOVFF  8A8,03
0CD28:  MOVLB  0
0CD2A:  GOTO   CD52 (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
12870:  MOVLB  9
12872:  BCF    x12.0
....................    y = x; 
12874:  MOVFF  906,90B
12878:  MOVFF  905,90A
1287C:  MOVFF  904,909
12880:  MOVFF  903,908
....................  
....................    if (x < 0) 
12884:  MOVFF  906,916
12888:  MOVFF  905,915
1288C:  MOVFF  904,914
12890:  MOVFF  903,913
12894:  CLRF   x1A
12896:  CLRF   x19
12898:  CLRF   x18
1289A:  CLRF   x17
1289C:  MOVLB  0
1289E:  CALL   1079A
128A2:  BNC   128B0
....................    { 
....................       s = 1; 
128A4:  MOVLB  9
128A6:  BSF    x12.0
....................       y = -y; 
128A8:  MOVF   x09,W
128AA:  XORLW  80
128AC:  MOVWF  x09
128AE:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
128B0:  MOVFF  90B,916
128B4:  MOVFF  90A,915
128B8:  MOVFF  909,914
128BC:  MOVFF  908,913
128C0:  MOVLB  9
128C2:  CLRF   x1A
128C4:  CLRF   x19
128C6:  CLRF   x18
128C8:  MOVLW  8E
128CA:  MOVWF  x17
128CC:  MOVLB  0
128CE:  CALL   1079A
128D2:  BC    128D6
128D4:  BNZ   12906
....................       res = (float32)(unsigned int16)y; 
128D6:  MOVFF  90B,916
128DA:  MOVFF  90A,915
128DE:  MOVFF  909,914
128E2:  MOVFF  908,913
128E6:  RCALL  12834
128E8:  MOVFF  02,918
128EC:  MOVFF  01,917
128F0:  CALL   C91E
128F4:  MOVFF  03,90F
128F8:  MOVFF  02,90E
128FC:  MOVFF  01,90D
12900:  MOVFF  00,90C
12904:  BRA    12AA8
....................  
....................  else if (y < 10000000.0) 
12906:  MOVFF  90B,916
1290A:  MOVFF  90A,915
1290E:  MOVFF  909,914
12912:  MOVFF  908,913
12916:  MOVLW  80
12918:  MOVLB  9
1291A:  MOVWF  x1A
1291C:  MOVLW  96
1291E:  MOVWF  x19
12920:  MOVLW  18
12922:  MOVWF  x18
12924:  MOVLW  96
12926:  MOVWF  x17
12928:  MOVLB  0
1292A:  CALL   1079A
1292E:  BTFSS  FD8.0
12930:  BRA    12A98
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
12932:  MOVFF  90B,916
12936:  MOVFF  90A,915
1293A:  MOVFF  909,914
1293E:  MOVFF  908,913
12942:  MOVLB  9
12944:  CLRF   x1A
12946:  CLRF   x19
12948:  CLRF   x18
1294A:  MOVLW  70
1294C:  MOVWF  x17
1294E:  MOVLB  0
12950:  CALL   C2EC
12954:  MOVFF  03,916
12958:  MOVFF  02,915
1295C:  MOVFF  01,914
12960:  MOVFF  00,913
12964:  RCALL  12834
12966:  MOVFF  02,911
1296A:  MOVFF  01,910
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
1296E:  MOVFF  90B,916
12972:  MOVFF  90A,915
12976:  MOVFF  909,914
1297A:  MOVFF  908,913
1297E:  MOVLB  9
12980:  CLRF   x1A
12982:  CLRF   x19
12984:  CLRF   x18
12986:  MOVLW  70
12988:  MOVWF  x17
1298A:  MOVLB  0
1298C:  CALL   C2EC
12990:  MOVFF  03,916
12994:  MOVFF  02,915
12998:  MOVFF  01,914
1299C:  MOVFF  00,913
129A0:  MOVFF  911,918
129A4:  MOVFF  910,917
129A8:  CALL   C91E
129AC:  BSF    FD8.1
129AE:  MOVFF  916,91A
129B2:  MOVFF  915,919
129B6:  MOVFF  914,918
129BA:  MOVFF  913,917
129BE:  MOVFF  03,91E
129C2:  MOVFF  02,91D
129C6:  MOVFF  01,91C
129CA:  MOVFF  00,91B
129CE:  CALL   C3E2
129D2:  MOVLB  9
129D4:  CLRF   x16
129D6:  CLRF   x15
129D8:  CLRF   x14
129DA:  MOVLW  8E
129DC:  MOVWF  x13
129DE:  MOVFF  03,91A
129E2:  MOVFF  02,919
129E6:  MOVFF  01,918
129EA:  MOVFF  00,917
129EE:  MOVLB  0
129F0:  CALL   C2EC
129F4:  MOVFF  03,90B
129F8:  MOVFF  02,90A
129FC:  MOVFF  01,909
12A00:  MOVFF  00,908
....................       res = 32768.0*(float32)l; 
12A04:  MOVFF  911,918
12A08:  MOVFF  910,917
12A0C:  CALL   C91E
12A10:  MOVLB  9
12A12:  CLRF   x16
12A14:  CLRF   x15
12A16:  CLRF   x14
12A18:  MOVLW  8E
12A1A:  MOVWF  x13
12A1C:  MOVFF  03,91A
12A20:  MOVFF  02,919
12A24:  MOVFF  01,918
12A28:  MOVFF  00,917
12A2C:  MOVLB  0
12A2E:  CALL   C2EC
12A32:  MOVFF  03,90F
12A36:  MOVFF  02,90E
12A3A:  MOVFF  01,90D
12A3E:  MOVFF  00,90C
....................       res += (float32)(unsigned int16)y; 
12A42:  MOVFF  90B,916
12A46:  MOVFF  90A,915
12A4A:  MOVFF  909,914
12A4E:  MOVFF  908,913
12A52:  RCALL  12834
12A54:  MOVFF  02,918
12A58:  MOVFF  01,917
12A5C:  CALL   C91E
12A60:  BCF    FD8.1
12A62:  MOVFF  90F,91A
12A66:  MOVFF  90E,919
12A6A:  MOVFF  90D,918
12A6E:  MOVFF  90C,917
12A72:  MOVFF  03,91E
12A76:  MOVFF  02,91D
12A7A:  MOVFF  01,91C
12A7E:  MOVFF  00,91B
12A82:  CALL   C3E2
12A86:  MOVFF  03,90F
12A8A:  MOVFF  02,90E
12A8E:  MOVFF  01,90D
12A92:  MOVFF  00,90C
....................    } 
12A96:  BRA    12AA8
....................  
....................  else 
....................   res = y; 
12A98:  MOVFF  90B,90F
12A9C:  MOVFF  90A,90E
12AA0:  MOVFF  909,90D
12AA4:  MOVFF  908,90C
....................  
....................  y = y - (float32)(unsigned int16)y; 
12AA8:  MOVFF  90B,916
12AAC:  MOVFF  90A,915
12AB0:  MOVFF  909,914
12AB4:  MOVFF  908,913
12AB8:  RCALL  12834
12ABA:  MOVFF  02,918
12ABE:  MOVFF  01,917
12AC2:  CALL   C91E
12AC6:  BSF    FD8.1
12AC8:  MOVFF  90B,91A
12ACC:  MOVFF  90A,919
12AD0:  MOVFF  909,918
12AD4:  MOVFF  908,917
12AD8:  MOVFF  03,91E
12ADC:  MOVFF  02,91D
12AE0:  MOVFF  01,91C
12AE4:  MOVFF  00,91B
12AE8:  CALL   C3E2
12AEC:  MOVFF  03,90B
12AF0:  MOVFF  02,90A
12AF4:  MOVFF  01,909
12AF8:  MOVFF  00,908
....................  
....................  if (s) 
12AFC:  MOVLB  9
12AFE:  BTFSS  x12.0
12B00:  BRA    12B08
....................   res = -res; 
12B02:  MOVF   x0D,W
12B04:  XORLW  80
12B06:  MOVWF  x0D
....................  
....................  if (y != 0) 
12B08:  MOVFF  90B,916
12B0C:  MOVFF  90A,915
12B10:  MOVFF  909,914
12B14:  MOVFF  908,913
12B18:  CLRF   x1A
12B1A:  CLRF   x19
12B1C:  CLRF   x18
12B1E:  CLRF   x17
12B20:  MOVLB  0
12B22:  CALL   1079A
12B26:  BZ    12BA0
....................  { 
....................   if (s == 1 && n == 0) 
12B28:  MOVLB  9
12B2A:  BTFSS  x12.0
12B2C:  BRA    12B66
12B2E:  MOVF   x07,F
12B30:  BNZ   12B66
....................    res -= 1.0; 
12B32:  BSF    FD8.1
12B34:  MOVFF  90F,91A
12B38:  MOVFF  90E,919
12B3C:  MOVFF  90D,918
12B40:  MOVFF  90C,917
12B44:  CLRF   x1E
12B46:  CLRF   x1D
12B48:  CLRF   x1C
12B4A:  MOVLW  7F
12B4C:  MOVWF  x1B
12B4E:  MOVLB  0
12B50:  CALL   C3E2
12B54:  MOVFF  03,90F
12B58:  MOVFF  02,90E
12B5C:  MOVFF  01,90D
12B60:  MOVFF  00,90C
12B64:  MOVLB  9
....................  
....................   if (s == 0 && n == 1) 
12B66:  BTFSC  x12.0
12B68:  BRA    12BA2
12B6A:  DECFSZ x07,W
12B6C:  BRA    12BA2
....................    res += 1.0; 
12B6E:  BCF    FD8.1
12B70:  MOVFF  90F,91A
12B74:  MOVFF  90E,919
12B78:  MOVFF  90D,918
12B7C:  MOVFF  90C,917
12B80:  CLRF   x1E
12B82:  CLRF   x1D
12B84:  CLRF   x1C
12B86:  MOVLW  7F
12B88:  MOVWF  x1B
12B8A:  MOVLB  0
12B8C:  CALL   C3E2
12B90:  MOVFF  03,90F
12B94:  MOVFF  02,90E
12B98:  MOVFF  01,90D
12B9C:  MOVFF  00,90C
12BA0:  MOVLB  9
....................  } 
....................  if (x == 0) 
12BA2:  MOVFF  906,916
12BA6:  MOVFF  905,915
12BAA:  MOVFF  904,914
12BAE:  MOVFF  903,913
12BB2:  CLRF   x1A
12BB4:  CLRF   x19
12BB6:  CLRF   x18
12BB8:  CLRF   x17
12BBA:  MOVLB  0
12BBC:  CALL   1079A
12BC0:  BNZ   12BCE
....................     res = 0; 
12BC2:  MOVLB  9
12BC4:  CLRF   x0F
12BC6:  CLRF   x0E
12BC8:  CLRF   x0D
12BCA:  CLRF   x0C
12BCC:  MOVLB  0
....................  
....................  return (res); 
12BCE:  MOVFF  90C,00
12BD2:  MOVFF  90D,01
12BD6:  MOVFF  90E,02
12BDA:  MOVFF  90F,03
12BDE:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
12BFE:  MOVFF  902,906
12C02:  MOVFF  901,905
12C06:  MOVFF  900,904
12C0A:  MOVFF  8FF,903
12C0E:  MOVLB  9
12C10:  CLRF   x07
12C12:  MOVLB  0
12C14:  RCALL  12870
12C16:  GOTO   12D22 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
12BE0:  MOVFF  902,906
12BE4:  MOVFF  901,905
12BE8:  MOVFF  900,904
12BEC:  MOVFF  8FF,903
12BF0:  MOVLW  01
12BF2:  MOVLB  9
12BF4:  MOVWF  x07
12BF6:  MOVLB  0
12BF8:  RCALL  12870
12BFA:  GOTO   12CDA (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
12C1A:  MOVFF  8F6,916
12C1E:  MOVFF  8F5,915
12C22:  MOVFF  8F4,914
12C26:  MOVFF  8F3,913
12C2A:  MOVLB  9
12C2C:  CLRF   x1A
12C2E:  CLRF   x19
12C30:  CLRF   x18
12C32:  CLRF   x17
12C34:  MOVLB  0
12C36:  CALL   1079A
12C3A:  BTFSC  FD8.2
12C3C:  BRA    12D7E
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
12C3E:  MOVFF  8F2,8FE
12C42:  MOVFF  8F1,8FD
12C46:  MOVFF  8F0,8FC
12C4A:  MOVFF  8EF,8FB
12C4E:  MOVFF  8F6,902
12C52:  MOVFF  8F5,901
12C56:  MOVFF  8F4,900
12C5A:  MOVFF  8F3,8FF
12C5E:  CALL   C954
12C62:  MOVFF  03,8FE
12C66:  MOVFF  02,8FD
12C6A:  MOVFF  01,8FC
12C6E:  MOVFF  00,8FB
12C72:  MOVFF  03,916
12C76:  MOVFF  02,915
12C7A:  MOVFF  01,914
12C7E:  MOVFF  00,913
12C82:  MOVLB  9
12C84:  CLRF   x1A
12C86:  CLRF   x19
12C88:  CLRF   x18
12C8A:  CLRF   x17
12C8C:  MOVLB  0
12C8E:  CALL   1079A
12C92:  BNC   12CDC
12C94:  MOVFF  8F2,8FE
12C98:  MOVFF  8F1,8FD
12C9C:  MOVFF  8F0,8FC
12CA0:  MOVFF  8EF,8FB
12CA4:  MOVFF  8F6,902
12CA8:  MOVFF  8F5,901
12CAC:  MOVFF  8F4,900
12CB0:  MOVFF  8F3,8FF
12CB4:  CALL   C954
12CB8:  MOVFF  03,8FE
12CBC:  MOVFF  02,8FD
12CC0:  MOVFF  01,8FC
12CC4:  MOVFF  00,8FB
12CC8:  MOVFF  03,902
12CCC:  MOVFF  02,901
12CD0:  MOVFF  01,900
12CD4:  MOVFF  00,8FF
12CD8:  BRA    12BE0
12CDA:  BRA    12D22
12CDC:  MOVFF  8F2,8FE
12CE0:  MOVFF  8F1,8FD
12CE4:  MOVFF  8F0,8FC
12CE8:  MOVFF  8EF,8FB
12CEC:  MOVFF  8F6,902
12CF0:  MOVFF  8F5,901
12CF4:  MOVFF  8F4,900
12CF8:  MOVFF  8F3,8FF
12CFC:  CALL   C954
12D00:  MOVFF  03,8FE
12D04:  MOVFF  02,8FD
12D08:  MOVFF  01,8FC
12D0C:  MOVFF  00,8FB
12D10:  MOVFF  03,902
12D14:  MOVFF  02,901
12D18:  MOVFF  01,900
12D1C:  MOVFF  00,8FF
12D20:  BRA    12BFE
12D22:  MOVFF  03,8FA
12D26:  MOVFF  02,8F9
12D2A:  MOVFF  01,8F8
12D2E:  MOVFF  00,8F7
....................       return(x-(i*y)); 
12D32:  MOVFF  8FA,916
12D36:  MOVFF  8F9,915
12D3A:  MOVFF  8F8,914
12D3E:  MOVFF  8F7,913
12D42:  MOVFF  8F6,91A
12D46:  MOVFF  8F5,919
12D4A:  MOVFF  8F4,918
12D4E:  MOVFF  8F3,917
12D52:  CALL   C2EC
12D56:  BSF    FD8.1
12D58:  MOVFF  8F2,91A
12D5C:  MOVFF  8F1,919
12D60:  MOVFF  8F0,918
12D64:  MOVFF  8EF,917
12D68:  MOVFF  03,91E
12D6C:  MOVFF  02,91D
12D70:  MOVFF  01,91C
12D74:  MOVFF  00,91B
12D78:  CALL   C3E2
12D7C:  BRA    12D7E
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12D7E:  GOTO   13016 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
10864:  MOVFF  8DA,8DE
10868:  MOVFF  8D9,8DD
1086C:  MOVFF  8D8,8DC
10870:  MOVFF  8D7,8DB
....................  
....................    if (y != 1.0) 
10874:  MOVFF  8DE,916
10878:  MOVFF  8DD,915
1087C:  MOVFF  8DC,914
10880:  MOVFF  8DB,913
10884:  MOVLB  9
10886:  CLRF   x1A
10888:  CLRF   x19
1088A:  CLRF   x18
1088C:  MOVLW  7F
1088E:  MOVWF  x17
10890:  MOVLB  0
10892:  RCALL  1079A
10894:  BTFSC  FD8.2
10896:  BRA    10BD8
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
10898:  MOVLW  08
1089A:  MOVLB  8
1089C:  MOVWF  xED
1089E:  MOVLW  DB
108A0:  MOVWF  FE9
108A2:  MOVFF  8ED,FEA
108A6:  MOVLW  7E
108A8:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
108AA:  BSF    FD8.1
108AC:  MOVFF  8DE,91A
108B0:  MOVFF  8DD,919
108B4:  MOVFF  8DC,918
108B8:  MOVFF  8DB,917
108BC:  MOVLB  9
108BE:  CLRF   x1E
108C0:  CLRF   x1D
108C2:  CLRF   x1C
108C4:  MOVLW  7F
108C6:  MOVWF  x1B
108C8:  MOVLB  0
108CA:  CALL   C3E2
108CE:  MOVFF  03,8EF
108D2:  MOVFF  02,8EE
108D6:  MOVFF  01,8ED
108DA:  MOVFF  00,8EC
108DE:  BCF    FD8.1
108E0:  MOVFF  8DE,91A
108E4:  MOVFF  8DD,919
108E8:  MOVFF  8DC,918
108EC:  MOVFF  8DB,917
108F0:  MOVLB  9
108F2:  CLRF   x1E
108F4:  CLRF   x1D
108F6:  CLRF   x1C
108F8:  MOVLW  7F
108FA:  MOVWF  x1B
108FC:  MOVLB  0
108FE:  CALL   C3E2
10902:  MOVFF  8EF,8FE
10906:  MOVFF  8EE,8FD
1090A:  MOVFF  8ED,8FC
1090E:  MOVFF  8EC,8FB
10912:  MOVFF  03,902
10916:  MOVFF  02,901
1091A:  MOVFF  01,900
1091E:  MOVFF  00,8FF
10922:  CALL   C954
10926:  MOVFF  03,8DE
1092A:  MOVFF  02,8DD
1092E:  MOVFF  01,8DC
10932:  MOVFF  00,8DB
....................  
....................       y2=y*y; 
10936:  MOVFF  8DE,916
1093A:  MOVFF  8DD,915
1093E:  MOVFF  8DC,914
10942:  MOVFF  8DB,913
10946:  MOVFF  8DE,91A
1094A:  MOVFF  8DD,919
1094E:  MOVFF  8DC,918
10952:  MOVFF  8DB,917
10956:  CALL   C2EC
1095A:  MOVFF  03,8EA
1095E:  MOVFF  02,8E9
10962:  MOVFF  01,8E8
10966:  MOVFF  00,8E7
....................  
....................       res = pl[0]*y2 + pl[1]; 
1096A:  MOVLW  99
1096C:  MOVLB  9
1096E:  MOVWF  x16
10970:  MOVLW  47
10972:  MOVWF  x15
10974:  MOVLW  8A
10976:  MOVWF  x14
10978:  MOVLW  7F
1097A:  MOVWF  x13
1097C:  MOVFF  8EA,91A
10980:  MOVFF  8E9,919
10984:  MOVFF  8E8,918
10988:  MOVFF  8E7,917
1098C:  MOVLB  0
1098E:  CALL   C2EC
10992:  MOVFF  03,8EF
10996:  MOVFF  02,8EE
1099A:  MOVFF  01,8ED
1099E:  MOVFF  00,8EC
109A2:  BCF    FD8.1
109A4:  MOVFF  03,91A
109A8:  MOVFF  02,919
109AC:  MOVFF  01,918
109B0:  MOVFF  00,917
109B4:  MOVLB  9
109B6:  CLRF   x1E
109B8:  CLRF   x1D
109BA:  CLRF   x1C
109BC:  MOVLW  80
109BE:  MOVWF  x1B
109C0:  MOVLB  0
109C2:  CALL   C3E2
109C6:  MOVFF  03,8E2
109CA:  MOVFF  02,8E1
109CE:  MOVFF  01,8E0
109D2:  MOVFF  00,8DF
....................  
....................       r = ql[0]*y2 + ql[1]; 
109D6:  MOVLW  4C
109D8:  MOVLB  9
109DA:  MOVWF  x16
109DC:  MOVLW  F3
109DE:  MOVWF  x15
109E0:  MOVLW  3A
109E2:  MOVWF  x14
109E4:  MOVLW  7B
109E6:  MOVWF  x13
109E8:  MOVFF  8EA,91A
109EC:  MOVFF  8E9,919
109F0:  MOVFF  8E8,918
109F4:  MOVFF  8E7,917
109F8:  MOVLB  0
109FA:  CALL   C2EC
109FE:  MOVFF  03,8EF
10A02:  MOVFF  02,8EE
10A06:  MOVFF  01,8ED
10A0A:  MOVFF  00,8EC
10A0E:  BCF    FD8.1
10A10:  MOVFF  03,91A
10A14:  MOVFF  02,919
10A18:  MOVFF  01,918
10A1C:  MOVFF  00,917
10A20:  MOVLW  2B
10A22:  MOVLB  9
10A24:  MOVWF  x1E
10A26:  MOVLW  9D
10A28:  MOVWF  x1D
10A2A:  MOVLW  DF
10A2C:  MOVWF  x1C
10A2E:  MOVLW  7E
10A30:  MOVWF  x1B
10A32:  MOVLB  0
10A34:  CALL   C3E2
10A38:  MOVFF  03,8E6
10A3C:  MOVFF  02,8E5
10A40:  MOVFF  01,8E4
10A44:  MOVFF  00,8E3
....................       r = r*y2 + 1.0; 
10A48:  MOVFF  8E6,916
10A4C:  MOVFF  8E5,915
10A50:  MOVFF  8E4,914
10A54:  MOVFF  8E3,913
10A58:  MOVFF  8EA,91A
10A5C:  MOVFF  8E9,919
10A60:  MOVFF  8E8,918
10A64:  MOVFF  8E7,917
10A68:  CALL   C2EC
10A6C:  MOVFF  03,8EF
10A70:  MOVFF  02,8EE
10A74:  MOVFF  01,8ED
10A78:  MOVFF  00,8EC
10A7C:  BCF    FD8.1
10A7E:  MOVFF  03,91A
10A82:  MOVFF  02,919
10A86:  MOVFF  01,918
10A8A:  MOVFF  00,917
10A8E:  MOVLB  9
10A90:  CLRF   x1E
10A92:  CLRF   x1D
10A94:  CLRF   x1C
10A96:  MOVLW  7F
10A98:  MOVWF  x1B
10A9A:  MOVLB  0
10A9C:  CALL   C3E2
10AA0:  MOVFF  03,8E6
10AA4:  MOVFF  02,8E5
10AA8:  MOVFF  01,8E4
10AAC:  MOVFF  00,8E3
....................  
....................       res = y*res/r; 
10AB0:  MOVFF  8DE,916
10AB4:  MOVFF  8DD,915
10AB8:  MOVFF  8DC,914
10ABC:  MOVFF  8DB,913
10AC0:  MOVFF  8E2,91A
10AC4:  MOVFF  8E1,919
10AC8:  MOVFF  8E0,918
10ACC:  MOVFF  8DF,917
10AD0:  CALL   C2EC
10AD4:  MOVFF  03,8EF
10AD8:  MOVFF  02,8EE
10ADC:  MOVFF  01,8ED
10AE0:  MOVFF  00,8EC
10AE4:  MOVFF  03,8FE
10AE8:  MOVFF  02,8FD
10AEC:  MOVFF  01,8FC
10AF0:  MOVFF  00,8FB
10AF4:  MOVFF  8E6,902
10AF8:  MOVFF  8E5,901
10AFC:  MOVFF  8E4,900
10B00:  MOVFF  8E3,8FF
10B04:  CALL   C954
10B08:  MOVFF  03,8E2
10B0C:  MOVFF  02,8E1
10B10:  MOVFF  01,8E0
10B14:  MOVFF  00,8DF
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
10B18:  MOVLW  08
10B1A:  MOVLB  8
10B1C:  MOVWF  xED
10B1E:  MOVLW  D7
10B20:  MOVWF  FE9
10B22:  MOVFF  8ED,FEA
10B26:  MOVLW  7E
10B28:  SUBWF  FEF,W
10B2A:  MOVWF  xEB
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
10B2C:  BTFSS  xEB.7
10B2E:  BRA    10B58
....................          r = -(float32)-n; 
10B30:  MOVLW  00
10B32:  BSF    FD8.0
10B34:  SUBFWB xEB,W
10B36:  CLRF   xED
10B38:  MOVWF  xEC
10B3A:  BTFSC  xEC.7
10B3C:  DECF   xED,F
10B3E:  MOVLB  0
10B40:  RCALL  10814
10B42:  MOVFF  00,8E3
10B46:  MOVF   01,W
10B48:  XORLW  80
10B4A:  MOVLB  8
10B4C:  MOVWF  xE4
10B4E:  MOVFF  02,8E5
10B52:  MOVFF  03,8E6
10B56:  BRA    10B78
....................       else 
....................          r = (float32)n; 
10B58:  CLRF   xED
10B5A:  MOVFF  8EB,8EC
10B5E:  BTFSC  xEC.7
10B60:  DECF   xED,F
10B62:  MOVLB  0
10B64:  RCALL  10814
10B66:  MOVFF  03,8E6
10B6A:  MOVFF  02,8E5
10B6E:  MOVFF  01,8E4
10B72:  MOVFF  00,8E3
10B76:  MOVLB  8
....................  
....................       res += r*LN2; 
10B78:  MOVFF  8E6,916
10B7C:  MOVFF  8E5,915
10B80:  MOVFF  8E4,914
10B84:  MOVFF  8E3,913
10B88:  MOVLW  18
10B8A:  MOVLB  9
10B8C:  MOVWF  x1A
10B8E:  MOVLW  72
10B90:  MOVWF  x19
10B92:  MOVLW  31
10B94:  MOVWF  x18
10B96:  MOVLW  7E
10B98:  MOVWF  x17
10B9A:  MOVLB  0
10B9C:  CALL   C2EC
10BA0:  BCF    FD8.1
10BA2:  MOVFF  8E2,91A
10BA6:  MOVFF  8E1,919
10BAA:  MOVFF  8E0,918
10BAE:  MOVFF  8DF,917
10BB2:  MOVFF  03,91E
10BB6:  MOVFF  02,91D
10BBA:  MOVFF  01,91C
10BBE:  MOVFF  00,91B
10BC2:  CALL   C3E2
10BC6:  MOVFF  03,8E2
10BCA:  MOVFF  02,8E1
10BCE:  MOVFF  01,8E0
10BD2:  MOVFF  00,8DF
....................    } 
10BD6:  BRA    10BE4
....................  
....................    else 
....................       res = 0.0; 
10BD8:  MOVLB  8
10BDA:  CLRF   xE2
10BDC:  CLRF   xE1
10BDE:  CLRF   xE0
10BE0:  CLRF   xDF
10BE2:  MOVLB  0
....................  
....................    return(res); 
10BE4:  MOVFF  8DF,00
10BE8:  MOVFF  8E0,01
10BEC:  MOVFF  8E1,02
10BF0:  MOVFF  8E2,03
10BF4:  GOTO   10C0A (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
10BF8:  MOVFF  8D2,8DA
10BFC:  MOVFF  8D1,8D9
10C00:  MOVFF  8D0,8D8
10C04:  MOVFF  8CF,8D7
10C08:  BRA    10864
10C0A:  MOVFF  03,8D6
10C0E:  MOVFF  02,8D5
10C12:  MOVFF  01,8D4
10C16:  MOVFF  00,8D3
....................    r = r*LN10_INV; 
10C1A:  MOVFF  8D6,916
10C1E:  MOVFF  8D5,915
10C22:  MOVFF  8D4,914
10C26:  MOVFF  8D3,913
10C2A:  MOVLW  D9
10C2C:  MOVLB  9
10C2E:  MOVWF  x1A
10C30:  MOVLW  5B
10C32:  MOVWF  x19
10C34:  MOVLW  5E
10C36:  MOVWF  x18
10C38:  MOVLW  7D
10C3A:  MOVWF  x17
10C3C:  MOVLB  0
10C3E:  CALL   C2EC
10C42:  MOVFF  03,8D6
10C46:  MOVFF  02,8D5
10C4A:  MOVFF  01,8D4
10C4E:  MOVFF  00,8D3
....................    return(r); 
10C52:  MOVFF  8D3,00
10C56:  MOVFF  8D4,01
10C5A:  MOVFF  8D5,02
10C5E:  MOVFF  8D6,03
10C62:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
105F2:  BCF    FC6.5
105F4:  MOVLW  21
105F6:  MOVWF  FC6
105F8:  MOVLW  40
105FA:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
105FC:  BSF    F91.2
....................    output_high(EEP_WP); 
105FE:  BSF    F91.3
10600:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
10602:  BCF    F91.2
....................    spi_write(0x05);  
10604:  MOVF   FC9,W
10606:  MOVLW  05
10608:  MOVWF  FC9
1060A:  RRCF   FC7,W
1060C:  BNC   1060A
....................    data = spi_read(0);  
1060E:  MOVF   FC9,W
10610:  CLRF   FC9
10612:  RRCF   FC7,W
10614:  BNC   10612
10616:  MOVFF  FC9,8CE
....................    output_high(EEP_CS);  
1061A:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
1061C:  MOVLW  00
1061E:  MOVLB  8
10620:  BTFSS  xCE.0
10622:  MOVLW  01
10624:  MOVWF  01
10626:  MOVLB  0
10628:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
18104:  MOVLB  8
18106:  CLRF   xED
18108:  MOVLB  0
1810A:  CALL   55AE
....................       while(!ext_eeprom_ready()); 
1810E:  CALL   10602
18112:  MOVF   01,F
18114:  BZ    1810E
....................     
....................       output_low(EEP_CS);  
18116:  BCF    F91.2
....................       spi_write(0x06);  
18118:  MOVF   FC9,W
1811A:  MOVLW  06
1811C:  MOVWF  FC9
1811E:  RRCF   FC7,W
18120:  BNC   1811E
....................       output_high(EEP_CS);  
18122:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
18124:  BCF    F91.2
....................       spi_write(0x02);  
18126:  MOVF   FC9,W
18128:  MOVLW  02
1812A:  MOVWF  FC9
1812C:  RRCF   FC7,W
1812E:  BNC   1812C
....................       spi_write(address >> 8);  
18130:  MOVFF  8A8,8AA
18134:  MOVLB  8
18136:  CLRF   xAB
18138:  MOVF   FC9,W
1813A:  MOVFF  8A8,FC9
1813E:  RRCF   FC7,W
18140:  BNC   1813E
....................       spi_write(address);  
18142:  MOVF   FC9,W
18144:  MOVFF  8A7,FC9
18148:  RRCF   FC7,W
1814A:  BNC   18148
....................       spi_write(data);  
1814C:  MOVF   FC9,W
1814E:  MOVFF  8A9,FC9
18152:  RRCF   FC7,W
18154:  BNC   18152
....................       output_high(EEP_CS);  
18156:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
18158:  MOVLW  01
1815A:  MOVWF  xED
1815C:  MOVLB  0
1815E:  CALL   55AE
18162:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
1062A:  MOVLB  8
1062C:  CLRF   xED
1062E:  MOVLB  0
10630:  CALL   55AE
....................     
....................       while(!ext_eeprom_ready()); 
10634:  RCALL  10602
10636:  MOVF   01,F
10638:  BZ    10634
....................        
....................       output_low(EEP_CS);  
1063A:  BCF    F91.2
....................       spi_write(0x03);  
1063C:  MOVF   FC9,W
1063E:  MOVLW  03
10640:  MOVWF  FC9
10642:  RRCF   FC7,W
10644:  BNC   10642
....................       spi_write(address >> 8);  
10646:  MOVFF  8CC,8CE
1064A:  MOVLB  8
1064C:  CLRF   xCF
1064E:  MOVF   FC9,W
10650:  MOVFF  8CC,FC9
10654:  RRCF   FC7,W
10656:  BNC   10654
....................       spi_write(address);  
10658:  MOVF   FC9,W
1065A:  MOVFF  8CB,FC9
1065E:  RRCF   FC7,W
10660:  BNC   1065E
....................        
....................       data = spi_read(0);  
10662:  MOVF   FC9,W
10664:  CLRF   FC9
10666:  RRCF   FC7,W
10668:  BNC   10666
1066A:  MOVFF  FC9,8CD
....................       output_high(EEP_CS);  
1066E:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
10670:  MOVLW  01
10672:  MOVWF  xED
10674:  MOVLB  0
10676:  CALL   55AE
....................     
....................    return(data);  
1067A:  MOVLB  8
1067C:  MOVFF  8CD,01
10680:  MOVLB  0
10682:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
0343A:  MOVF   FF2,W
0343C:  MOVWF  00
0343E:  BCF    FF2.7
03440:  CLRF   F63
03442:  MOVFF  889,F62
03446:  MOVFF  88A,F61
0344A:  BCF    F7F.6
0344C:  BCF    F7F.7
0344E:  BSF    F7F.2
03450:  MOVLB  F
03452:  MOVLW  55
03454:  MOVWF  F7E
03456:  MOVLW  AA
03458:  MOVWF  F7E
0345A:  BSF    F7F.1
0345C:  BTFSC  F7F.1
0345E:  BRA    345C
03460:  BCF    F7F.2
03462:  MOVF   00,W
03464:  IORWF  FF2,F
03466:  MOVLB  0
03468:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
02A4C:  MOVLB  8
02A4E:  CLRF   xB8
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
02A50:  MOVFF  FF2,8B9
02A54:  BCF    FF2.7
02A56:  CLRF   F63
02A58:  MOVFF  8B7,F62
02A5C:  BCF    F7F.6
02A5E:  BCF    F7F.7
02A60:  BSF    F7F.0
02A62:  MOVF   F61,W
02A64:  BTFSC  xB9.7
02A66:  BSF    FF2.7
02A68:  MOVWF  xB8
....................    return(data); 
02A6A:  MOVFF  8B8,01
02A6E:  MOVLB  0
02A70:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04FFC:  MOVLB  8
04FFE:  CLRF   xF1
05000:  MOVF   xF1,W
05002:  SUBLW  01
05004:  BNC   505E
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
05006:  MOVF   xEE,W
05008:  ADDWF  xF1,W
0500A:  MOVWF  xF2
0500C:  MOVLW  08
0500E:  MOVWF  xF4
05010:  MOVLW  EF
05012:  MOVWF  xF3
05014:  MOVF   xF1,W
05016:  ADDWF  xF3,W
05018:  MOVWF  01
0501A:  MOVLW  00
0501C:  ADDWFC xF4,W
0501E:  MOVWF  03
05020:  MOVF   01,W
05022:  MOVWF  FE9
05024:  MOVFF  03,FEA
05028:  MOVFF  FEF,8F3
0502C:  MOVF   FF2,W
0502E:  MOVWF  00
05030:  BCF    FF2.7
05032:  CLRF   F63
05034:  MOVFF  8F2,F62
05038:  MOVFF  8F3,F61
0503C:  BCF    F7F.6
0503E:  BCF    F7F.7
05040:  BSF    F7F.2
05042:  MOVLB  F
05044:  MOVLW  55
05046:  MOVWF  F7E
05048:  MOVLW  AA
0504A:  MOVWF  F7E
0504C:  BSF    F7F.1
0504E:  BTFSC  F7F.1
05050:  BRA    504E
05052:  BCF    F7F.2
05054:  MOVF   00,W
05056:  IORWF  FF2,F
05058:  MOVLB  8
0505A:  INCF   xF1,F
0505C:  BRA    5000
....................     }  
0505E:  MOVLB  0
05060:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
029F2:  MOVLB  8
029F4:  CLRF   x9A
029F6:  CLRF   x99
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
029F8:  CLRF   x98
029FA:  MOVF   x98,W
029FC:  SUBLW  01
029FE:  BNC   2A40
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A00:  MOVLW  08
02A02:  MOVWF  x9C
02A04:  MOVLW  99
02A06:  MOVWF  x9B
02A08:  MOVF   x98,W
02A0A:  ADDWF  x9B,W
02A0C:  MOVWF  01
02A0E:  MOVLW  00
02A10:  ADDWFC x9C,W
02A12:  MOVWF  03
02A14:  MOVF   01,W
02A16:  MOVWF  FE9
02A18:  MOVFF  03,FEA
02A1C:  MOVF   x97,W
02A1E:  ADDWF  x98,W
02A20:  MOVWF  x9D
02A22:  MOVFF  FF2,89E
02A26:  BCF    FF2.7
02A28:  CLRF   F63
02A2A:  MOVFF  89D,F62
02A2E:  BCF    F7F.6
02A30:  BCF    F7F.7
02A32:  BSF    F7F.0
02A34:  MOVF   F61,W
02A36:  BTFSC  x9E.7
02A38:  BSF    FF2.7
02A3A:  MOVWF  FEF
02A3C:  INCF   x98,F
02A3E:  BRA    29FA
....................    } 
....................  
....................    return(data);  
02A40:  MOVFF  899,01
02A44:  MOVFF  89A,02
02A48:  MOVLB  0
02A4A:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CD74:  MOVLB  8
0CD76:  CLRF   x8B
0CD78:  MOVF   x8B,W
0CD7A:  SUBLW  03
0CD7C:  BNC   CDDE
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CD7E:  MOVF   x8B,W
0CD80:  ADDWF  x85,W
0CD82:  MOVWF  x8C
0CD84:  MOVLW  00
0CD86:  ADDWFC x86,W
0CD88:  MOVWF  x8D
0CD8A:  MOVLW  08
0CD8C:  MOVWF  x8F
0CD8E:  MOVLW  87
0CD90:  MOVWF  x8E
0CD92:  MOVF   x8B,W
0CD94:  ADDWF  x8E,W
0CD96:  MOVWF  01
0CD98:  MOVLW  00
0CD9A:  ADDWFC x8F,W
0CD9C:  MOVWF  03
0CD9E:  MOVF   01,W
0CDA0:  MOVWF  FE9
0CDA2:  MOVFF  03,FEA
0CDA6:  MOVFF  FEF,88E
0CDAA:  MOVF   FF2,W
0CDAC:  MOVWF  00
0CDAE:  BCF    FF2.7
0CDB0:  MOVFF  88D,F63
0CDB4:  MOVFF  88C,F62
0CDB8:  MOVFF  88E,F61
0CDBC:  BCF    F7F.6
0CDBE:  BCF    F7F.7
0CDC0:  BSF    F7F.2
0CDC2:  MOVLB  F
0CDC4:  MOVLW  55
0CDC6:  MOVWF  F7E
0CDC8:  MOVLW  AA
0CDCA:  MOVWF  F7E
0CDCC:  BSF    F7F.1
0CDCE:  BTFSC  F7F.1
0CDD0:  BRA    CDCE
0CDD2:  BCF    F7F.2
0CDD4:  MOVF   00,W
0CDD6:  IORWF  FF2,F
0CDD8:  MOVLB  8
0CDDA:  INCF   x8B,F
0CDDC:  BRA    CD78
....................    } 
0CDDE:  MOVLB  0
0CDE0:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
02A72:  MOVLB  8
02A74:  CLRF   x8B
02A76:  CLRF   x8A
02A78:  CLRF   x89
02A7A:  CLRF   x88
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
02A7C:  CLRF   x87
02A7E:  MOVF   x87,W
02A80:  SUBLW  03
02A82:  BNC   2ACC
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A84:  MOVLW  08
02A86:  MOVWF  x8D
02A88:  MOVLW  88
02A8A:  MOVWF  x8C
02A8C:  MOVF   x87,W
02A8E:  ADDWF  x8C,W
02A90:  MOVWF  01
02A92:  MOVLW  00
02A94:  ADDWFC x8D,W
02A96:  MOVWF  03
02A98:  MOVF   01,W
02A9A:  MOVWF  FE9
02A9C:  MOVFF  03,FEA
02AA0:  MOVF   x87,W
02AA2:  ADDWF  x85,W
02AA4:  MOVWF  x8E
02AA6:  MOVLW  00
02AA8:  ADDWFC x86,W
02AAA:  MOVWF  x8F
02AAC:  MOVFF  FF2,890
02AB0:  BCF    FF2.7
02AB2:  MOVFF  88F,F63
02AB6:  MOVFF  88E,F62
02ABA:  BCF    F7F.6
02ABC:  BCF    F7F.7
02ABE:  BSF    F7F.0
02AC0:  MOVF   F61,W
02AC2:  BTFSC  x90.7
02AC4:  BSF    FF2.7
02AC6:  MOVWF  FEF
02AC8:  INCF   x87,F
02ACA:  BRA    2A7E
....................    } 
....................  
....................    return(data);  
02ACC:  MOVFF  888,00
02AD0:  MOVFF  889,01
02AD4:  MOVFF  88A,02
02AD8:  MOVFF  88B,03
02ADC:  MOVLB  0
02ADE:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
18344:  MOVLB  8
18346:  CLRF   xA3
18348:  MOVF   xA3,W
1834A:  SUBLW  01
1834C:  BNC   1838A
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
1834E:  MOVF   xA3,W
18350:  ADDWF  x9F,W
18352:  MOVWF  xA4
18354:  MOVLW  00
18356:  ADDWFC xA0,W
18358:  MOVWF  xA5
1835A:  MOVLW  08
1835C:  MOVWF  xA7
1835E:  MOVLW  A1
18360:  MOVWF  xA6
18362:  MOVF   xA3,W
18364:  ADDWF  xA6,W
18366:  MOVWF  01
18368:  MOVLW  00
1836A:  ADDWFC xA7,W
1836C:  MOVWF  03
1836E:  MOVFF  01,FE9
18372:  MOVWF  FEA
18374:  MOVFF  FEF,8A9
18378:  MOVFF  8A5,8A8
1837C:  MOVFF  8A4,8A7
18380:  MOVLB  0
18382:  RCALL  18104
18384:  MOVLB  8
18386:  INCF   xA3,F
18388:  BRA    18348
....................     }  
1838A:  MOVLB  0
1838C:  GOTO   183FC (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
1073E:  MOVLB  8
10740:  CLRF   xC6
10742:  CLRF   xC5
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
10744:  CLRF   xC4
10746:  MOVF   xC4,W
10748:  SUBLW  01
1074A:  BNC   1078E
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
1074C:  MOVLW  08
1074E:  MOVWF  xC8
10750:  MOVLW  C5
10752:  MOVWF  xC7
10754:  MOVF   xC4,W
10756:  ADDWF  xC7,W
10758:  MOVWF  01
1075A:  MOVLW  00
1075C:  ADDWFC xC8,W
1075E:  MOVWF  03
10760:  MOVFF  01,8C7
10764:  MOVWF  xC8
10766:  MOVF   xC4,W
10768:  ADDWF  xC2,W
1076A:  MOVWF  xC9
1076C:  MOVLW  00
1076E:  ADDWFC xC3,W
10770:  MOVWF  xCA
10772:  MOVWF  xCC
10774:  MOVFF  8C9,8CB
10778:  MOVLB  0
1077A:  RCALL  1062A
1077C:  MOVFF  8C8,FEA
10780:  MOVFF  8C7,FE9
10784:  MOVFF  01,FEF
10788:  MOVLB  8
1078A:  INCF   xC4,F
1078C:  BRA    10746
....................    } 
....................    return(data);  
1078E:  MOVFF  8C5,01
10792:  MOVFF  8C6,02
10796:  MOVLB  0
10798:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
15D26:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
15D28:  MOVF   2F,W
15D2A:  SUBLW  02
15D2C:  BNZ   15D34
15D2E:  MOVF   30,F
15D30:  BNZ   15D34
15D32:  BSF    F90.6
....................    delay_ms(32); 
15D34:  MOVLW  20
15D36:  MOVLB  9
15D38:  MOVWF  xEC
15D3A:  MOVLB  0
15D3C:  CALL   2938
....................    output_bit(BOARD_LED, OFF); 
15D40:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15D42:  MOVF   2F,W
15D44:  SUBLW  02
15D46:  BNZ   15D4E
15D48:  MOVF   30,F
15D4A:  BNZ   15D4E
15D4C:  BCF    F90.6
....................    delay_ms(32); 
15D4E:  MOVLW  20
15D50:  MOVLB  9
15D52:  MOVWF  xEC
15D54:  MOVLB  0
15D56:  CALL   2938
15D5A:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
03170:  MOVF   2F,W
03172:  MOVWF  00
03174:  MOVF   30,W
03176:  MOVWF  03
03178:  BNZ   317E
0317A:  MOVF   00,F
0317C:  BZ    31A0
0317E:  MOVF   03,W
03180:  BNZ   3188
03182:  MOVLW  01
03184:  SUBWF  00,W
03186:  BZ    31F2
03188:  MOVF   03,W
0318A:  BNZ   3192
0318C:  MOVLW  02
0318E:  SUBWF  00,W
03190:  BZ    3244
03192:  MOVF   03,W
03194:  BNZ   319E
03196:  MOVLW  03
03198:  SUBWF  00,W
0319A:  BTFSC  FD8.2
0319C:  BRA    3296
0319E:  BRA    32E8
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
031A0:  MOVLW  BE
031A2:  MOVWF  FF6
031A4:  MOVLW  05
031A6:  MOVWF  FF7
031A8:  MOVLW  00
031AA:  MOVWF  FF8
031AC:  CLRF   1B
031AE:  BTFSC  FF2.7
031B0:  BSF    1B.7
031B2:  BCF    FF2.7
031B4:  MOVLW  06
031B6:  MOVLB  A
031B8:  MOVWF  x40
031BA:  MOVLB  0
031BC:  CALL   1044
031C0:  BTFSC  1B.7
031C2:  BSF    FF2.7
031C4:  MOVLW  CA
031C6:  MOVWF  FF6
031C8:  MOVLW  05
031CA:  MOVWF  FF7
031CC:  MOVLW  00
031CE:  MOVWF  FF8
031D0:  CLRF   1B
031D2:  BTFSC  FF2.7
031D4:  BSF    1B.7
031D6:  BCF    FF2.7
031D8:  CALL   0E6E
031DC:  BTFSC  1B.7
031DE:  BSF    FF2.7
031E0:  MOVLW  0D
031E2:  BTFSS  F9E.4
031E4:  BRA    31E2
031E6:  MOVWF  FAD
031E8:  MOVLW  0A
031EA:  BTFSS  F9E.4
031EC:  BRA    31EA
031EE:  MOVWF  FAD
....................          break; 
031F0:  BRA    3338
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
031F2:  MOVLW  D2
031F4:  MOVWF  FF6
031F6:  MOVLW  05
031F8:  MOVWF  FF7
031FA:  MOVLW  00
031FC:  MOVWF  FF8
031FE:  CLRF   1B
03200:  BTFSC  FF2.7
03202:  BSF    1B.7
03204:  BCF    FF2.7
03206:  MOVLW  09
03208:  MOVLB  A
0320A:  MOVWF  x40
0320C:  MOVLB  0
0320E:  CALL   1044
03212:  BTFSC  1B.7
03214:  BSF    FF2.7
03216:  MOVLW  E0
03218:  MOVWF  FF6
0321A:  MOVLW  05
0321C:  MOVWF  FF7
0321E:  MOVLW  00
03220:  MOVWF  FF8
03222:  CLRF   1B
03224:  BTFSC  FF2.7
03226:  BSF    1B.7
03228:  BCF    FF2.7
0322A:  CALL   0E6E
0322E:  BTFSC  1B.7
03230:  BSF    FF2.7
03232:  MOVLW  0D
03234:  BTFSS  F9E.4
03236:  BRA    3234
03238:  MOVWF  FAD
0323A:  MOVLW  0A
0323C:  BTFSS  F9E.4
0323E:  BRA    323C
03240:  MOVWF  FAD
....................          break;  
03242:  BRA    3338
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
03244:  MOVLW  E8
03246:  MOVWF  FF6
03248:  MOVLW  05
0324A:  MOVWF  FF7
0324C:  MOVLW  00
0324E:  MOVWF  FF8
03250:  CLRF   1B
03252:  BTFSC  FF2.7
03254:  BSF    1B.7
03256:  BCF    FF2.7
03258:  MOVLW  06
0325A:  MOVLB  A
0325C:  MOVWF  x40
0325E:  MOVLB  0
03260:  CALL   1044
03264:  BTFSC  1B.7
03266:  BSF    FF2.7
03268:  MOVLW  F4
0326A:  MOVWF  FF6
0326C:  MOVLW  05
0326E:  MOVWF  FF7
03270:  MOVLW  00
03272:  MOVWF  FF8
03274:  CLRF   1B
03276:  BTFSC  FF2.7
03278:  BSF    1B.7
0327A:  BCF    FF2.7
0327C:  CALL   0E6E
03280:  BTFSC  1B.7
03282:  BSF    FF2.7
03284:  MOVLW  0D
03286:  BTFSS  F9E.4
03288:  BRA    3286
0328A:  MOVWF  FAD
0328C:  MOVLW  0A
0328E:  BTFSS  F9E.4
03290:  BRA    328E
03292:  MOVWF  FAD
....................          break; 
03294:  BRA    3338
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
03296:  MOVLW  FC
03298:  MOVWF  FF6
0329A:  MOVLW  05
0329C:  MOVWF  FF7
0329E:  MOVLW  00
032A0:  MOVWF  FF8
032A2:  CLRF   1B
032A4:  BTFSC  FF2.7
032A6:  BSF    1B.7
032A8:  BCF    FF2.7
032AA:  MOVLW  09
032AC:  MOVLB  A
032AE:  MOVWF  x40
032B0:  MOVLB  0
032B2:  CALL   1044
032B6:  BTFSC  1B.7
032B8:  BSF    FF2.7
032BA:  MOVLW  0A
032BC:  MOVWF  FF6
032BE:  MOVLW  06
032C0:  MOVWF  FF7
032C2:  MOVLW  00
032C4:  MOVWF  FF8
032C6:  CLRF   1B
032C8:  BTFSC  FF2.7
032CA:  BSF    1B.7
032CC:  BCF    FF2.7
032CE:  CALL   0E6E
032D2:  BTFSC  1B.7
032D4:  BSF    FF2.7
032D6:  MOVLW  0D
032D8:  BTFSS  F9E.4
032DA:  BRA    32D8
032DC:  MOVWF  FAD
032DE:  MOVLW  0A
032E0:  BTFSS  F9E.4
032E2:  BRA    32E0
032E4:  MOVWF  FAD
....................          break;           
032E6:  BRA    3338
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
032E8:  MOVLW  12
032EA:  MOVWF  FF6
032EC:  MOVLW  06
032EE:  MOVWF  FF7
032F0:  MOVLW  00
032F2:  MOVWF  FF8
032F4:  CLRF   1B
032F6:  BTFSC  FF2.7
032F8:  BSF    1B.7
032FA:  BCF    FF2.7
032FC:  MOVLW  06
032FE:  MOVLB  A
03300:  MOVWF  x40
03302:  MOVLB  0
03304:  CALL   1044
03308:  BTFSC  1B.7
0330A:  BSF    FF2.7
0330C:  MOVLW  1E
0330E:  MOVWF  FF6
03310:  MOVLW  06
03312:  MOVWF  FF7
03314:  MOVLW  00
03316:  MOVWF  FF8
03318:  CLRF   1B
0331A:  BTFSC  FF2.7
0331C:  BSF    1B.7
0331E:  BCF    FF2.7
03320:  CALL   0E6E
03324:  BTFSC  1B.7
03326:  BSF    FF2.7
03328:  MOVLW  0D
0332A:  BTFSS  F9E.4
0332C:  BRA    332A
0332E:  MOVWF  FAD
03330:  MOVLW  0A
03332:  BTFSS  F9E.4
03334:  BRA    3332
03336:  MOVWF  FAD
....................          break; 
....................    } 
03338:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
1776A:  MOVLW  26
1776C:  MOVWF  FF6
1776E:  MOVLW  06
17770:  MOVWF  FF7
17772:  MOVLW  00
17774:  MOVWF  FF8
17776:  CLRF   1B
17778:  BTFSC  FF2.7
1777A:  BSF    1B.7
1777C:  BCF    FF2.7
1777E:  CALL   0E6E
17782:  BTFSC  1B.7
17784:  BSF    FF2.7
17786:  GOTO   17BBA (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0B326:  MOVLW  2E
0B328:  MOVWF  FF6
0B32A:  MOVLW  06
0B32C:  MOVWF  FF7
0B32E:  MOVLW  00
0B330:  MOVWF  FF8
0B332:  CLRF   1B
0B334:  BTFSC  FF2.7
0B336:  BSF    1B.7
0B338:  BCF    FF2.7
0B33A:  CALL   0E6E
0B33E:  BTFSC  1B.7
0B340:  BSF    FF2.7
0B342:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BFE8:  MOVLW  36
0BFEA:  MOVWF  FF6
0BFEC:  MOVLW  06
0BFEE:  MOVWF  FF7
0BFF0:  MOVLW  00
0BFF2:  MOVWF  FF8
0BFF4:  CLRF   1B
0BFF6:  BTFSC  FF2.7
0BFF8:  BSF    1B.7
0BFFA:  BCF    FF2.7
0BFFC:  CALL   0E6E
0C000:  BTFSC  1B.7
0C002:  BSF    FF2.7
0C004:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
0367E:  MOVLW  4E
03680:  MOVWF  FF6
03682:  MOVLW  06
03684:  MOVWF  FF7
03686:  MOVLW  00
03688:  MOVWF  FF8
0368A:  CLRF   1B
0368C:  BTFSC  FF2.7
0368E:  BSF    1B.7
03690:  BCF    FF2.7
03692:  CALL   0E6E
03696:  BTFSC  1B.7
03698:  BSF    FF2.7
0369A:  GOTO   43F0 (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
050A8:  MOVLW  56
050AA:  MOVWF  FF6
050AC:  MOVLW  06
050AE:  MOVWF  FF7
050B0:  MOVLW  00
050B2:  MOVWF  FF8
050B4:  CLRF   1B
050B6:  BTFSC  FF2.7
050B8:  BSF    1B.7
050BA:  BCF    FF2.7
050BC:  CALL   0E6E
050C0:  BTFSC  1B.7
050C2:  BSF    FF2.7
050C4:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
16260:  MOVLW  5E
16262:  MOVWF  FF6
16264:  MOVLW  06
16266:  MOVWF  FF7
16268:  MOVLW  00
1626A:  MOVWF  FF8
1626C:  CLRF   1B
1626E:  BTFSC  FF2.7
16270:  BSF    1B.7
16272:  BCF    FF2.7
16274:  CALL   0E6E
16278:  BTFSC  1B.7
1627A:  BSF    FF2.7
1627C:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "\r\n?@BSY\r\n"); 
*
0AEE8:  DECFSZ 4E,W
0AEEA:  BRA    AF0A
0AEEC:  MOVLW  66
0AEEE:  MOVWF  FF6
0AEF0:  MOVLW  06
0AEF2:  MOVWF  FF7
0AEF4:  MOVLW  00
0AEF6:  MOVWF  FF8
0AEF8:  CLRF   1B
0AEFA:  BTFSC  FF2.7
0AEFC:  BSF    1B.7
0AEFE:  BCF    FF2.7
0AF00:  CALL   0E6E
0AF04:  BTFSC  1B.7
0AF06:  BSF    FF2.7
0AF08:  BRA    AF26
....................    else fprintf(COM_A, "\r\n@RDY\r\n"); 
0AF0A:  MOVLW  70
0AF0C:  MOVWF  FF6
0AF0E:  MOVLW  06
0AF10:  MOVWF  FF7
0AF12:  MOVLW  00
0AF14:  MOVWF  FF8
0AF16:  CLRF   1B
0AF18:  BTFSC  FF2.7
0AF1A:  BSF    1B.7
0AF1C:  BCF    FF2.7
0AF1E:  CALL   0E6E
0AF22:  BTFSC  1B.7
0AF24:  BSF    FF2.7
0AF26:  GOTO   1B562 (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
03568:  MOVLW  0A
0356A:  MOVLB  A
0356C:  MOVWF  x35
0356E:  MOVLW  2C
03570:  MOVFF  A35,A33
03574:  MOVWF  x32
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
03576:  MOVF   FC9,W
03578:  SETF   FC9
0357A:  RRCF   FC7,W
0357C:  BNC   357A
....................    SD_spi_read(sdcmd); 
0357E:  MOVF   FC9,W
03580:  MOVFF  A2B,FC9
03584:  RRCF   FC7,W
03586:  BNC   3584
....................    SD_spi_read(value[3]); 
03588:  MOVLW  03
0358A:  ADDWF  x32,W
0358C:  MOVWF  FE9
0358E:  MOVLW  00
03590:  ADDWFC x33,W
03592:  MOVWF  FEA
03594:  MOVFF  FEF,A34
03598:  MOVF   FC9,W
0359A:  MOVFF  A34,FC9
0359E:  RRCF   FC7,W
035A0:  BNC   359E
....................    SD_spi_read(value[2]); 
035A2:  MOVLW  02
035A4:  ADDWF  x32,W
035A6:  MOVWF  FE9
035A8:  MOVLW  00
035AA:  ADDWFC x33,W
035AC:  MOVWF  FEA
035AE:  MOVFF  FEF,A34
035B2:  MOVF   FC9,W
035B4:  MOVFF  A34,FC9
035B8:  RRCF   FC7,W
035BA:  BNC   35B8
....................    SD_spi_read(value[1]); 
035BC:  MOVLW  01
035BE:  ADDWF  x32,W
035C0:  MOVWF  FE9
035C2:  MOVLW  00
035C4:  ADDWFC x33,W
035C6:  MOVWF  FEA
035C8:  MOVFF  FEF,A34
035CC:  MOVF   FC9,W
035CE:  MOVFF  A34,FC9
035D2:  RRCF   FC7,W
035D4:  BNC   35D2
....................    SD_spi_read(value[0]); 
035D6:  MOVFF  A32,FE9
035DA:  MOVFF  A33,FEA
035DE:  MOVFF  FEF,A34
035E2:  MOVF   FC9,W
035E4:  MOVFF  A34,FC9
035E8:  RRCF   FC7,W
035EA:  BNC   35E8
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
035EC:  MOVF   x2B,W
035EE:  SUBLW  48
035F0:  BNZ   35FE
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
035F2:  MOVF   FC9,W
035F4:  MOVLW  87
035F6:  MOVWF  FC9
035F8:  RRCF   FC7,W
035FA:  BNC   35F8
035FC:  BRA    3608
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
035FE:  MOVF   FC9,W
03600:  MOVLW  95
03602:  MOVWF  FC9
03604:  RRCF   FC7,W
03606:  BNC   3604
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
03608:  CLRF   x30
....................    response = SD_spi_read(0xFF); 
0360A:  MOVF   FC9,W
0360C:  SETF   FC9
0360E:  RRCF   FC7,W
03610:  BNC   360E
03612:  MOVFF  FC9,A31
....................    while ((response == 0xFF) && (i < 100)) 
03616:  INCFSZ x31,W
03618:  BRA    3630
0361A:  MOVF   x30,W
0361C:  SUBLW  63
0361E:  BNC   3630
....................       { 
....................       i++; 
03620:  INCF   x30,F
....................       response = SD_spi_read(0xFF); 
03622:  MOVF   FC9,W
03624:  SETF   FC9
03626:  RRCF   FC7,W
03628:  BNC   3626
0362A:  MOVFF  FC9,A31
0362E:  BRA    3616
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
03630:  MOVFF  A31,01
03634:  MOVLB  0
03636:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
043FC:  MOVLW  50
043FE:  MOVLB  A
04400:  MOVWF  x2B
04402:  MOVFF  A2A,A2F
04406:  MOVFF  A29,A2E
0440A:  MOVFF  A28,A2D
0440E:  MOVFF  A27,A2C
04412:  MOVLB  0
04414:  CALL   3568
04418:  MOVF   01,W
0441A:  BZ    4422
0441C:  XORLW  40
0441E:  BZ    4438
04420:  BRA    443E
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
04422:  MOVFF  A2A,4EC
04426:  MOVFF  A29,4EB
0442A:  MOVFF  A28,4EA
0442E:  MOVFF  A27,4E9
....................          return(TRUE); 
04432:  MOVLW  01
04434:  MOVWF  01
04436:  BRA    4442
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
04438:  MOVLW  00
0443A:  MOVWF  01
0443C:  BRA    4442
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
0443E:  MOVLW  00
04440:  MOVWF  01
....................       } 
04442:  GOTO   4526 (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
04446:  MOVF   FC9,W
04448:  SETF   FC9
0444A:  RRCF   FC7,W
0444C:  BNC   444A
0444E:  MOVFF  FC9,A2F
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
04452:  MOVLB  A
04454:  CLRF   x2E
04456:  CLRF   x2D
04458:  MOVF   x2E,W
0445A:  SUBLW  27
0445C:  BNC   4486
0445E:  BNZ   4466
04460:  MOVF   x2D,W
04462:  SUBLW  0F
04464:  BNC   4486
04466:  INCFSZ x2F,W
04468:  BRA    4486
....................       { 
....................       delay_us(10); 
0446A:  MOVLW  35
0446C:  MOVWF  00
0446E:  DECFSZ 00,F
04470:  BRA    446E
....................       response = SD_spi_read(0xFF);  
04472:  MOVF   FC9,W
04474:  SETF   FC9
04476:  RRCF   FC7,W
04478:  BNC   4476
0447A:  MOVFF  FC9,A2F
0447E:  INCF   x2D,F
04480:  BTFSC  FD8.2
04482:  INCF   x2E,F
04484:  BRA    4458
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
04486:  MOVF   x2F,W
04488:  SUBLW  FE
0448A:  BZ    449A
....................       { 
....................       if (!response) 
0448C:  MOVF   x2F,F
0448E:  BNZ   4494
....................          response = 0xFE; 
04490:  MOVLW  FE
04492:  MOVWF  x2F
....................       return(response); 
04494:  MOVFF  A2F,01
04498:  BRA    44F0
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
0449A:  CLRF   x2E
0449C:  CLRF   x2D
0449E:  MOVF   x2C,F
044A0:  BNZ   44B4
044A2:  MOVF   x2B,F
044A4:  BNZ   44B4
044A6:  MOVF   x2E,W
044A8:  SUBWF  x2A,W
044AA:  BNC   44D4
044AC:  BNZ   44B4
044AE:  MOVF   x29,W
044B0:  SUBWF  x2D,W
044B2:  BC    44D4
....................       ptr[i]=SD_spi_read(0xFF); 
044B4:  MOVF   x27,W
044B6:  ADDWF  x2D,W
044B8:  MOVWF  FE9
044BA:  MOVF   x28,W
044BC:  ADDWFC x2E,W
044BE:  MOVWF  FEA
044C0:  MOVF   FC9,W
044C2:  SETF   FC9
044C4:  RRCF   FC7,W
044C6:  BNC   44C4
044C8:  MOVFF  FC9,FEF
044CC:  INCF   x2D,F
044CE:  BTFSC  FD8.2
044D0:  INCF   x2E,F
044D2:  BRA    449E
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
044D4:  MOVF   FC9,W
044D6:  SETF   FC9
044D8:  RRCF   FC7,W
044DA:  BNC   44D8
....................    SD_spi_read(0xFF); 
044DC:  MOVF   FC9,W
044DE:  SETF   FC9
044E0:  RRCF   FC7,W
044E2:  BNC   44E0
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
044E4:  MOVF   FC9,W
044E6:  SETF   FC9
044E8:  RRCF   FC7,W
044EA:  BNC   44E8
....................    return(0); 
044EC:  MOVLW  00
044EE:  MOVWF  01
044F0:  MOVLB  0
044F2:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
0586E:  MOVLW  C3
05870:  MOVLB  A
05872:  MOVWF  x2F
05874:  MOVLW  50
05876:  MOVWF  x2E
....................    SD_spi_read(0xFF); 
05878:  MOVF   FC9,W
0587A:  SETF   FC9
0587C:  RRCF   FC7,W
0587E:  BNC   587C
....................    do 
....................       { 
....................       delay_us(10); 
05880:  MOVLW  35
05882:  MOVWF  00
05884:  DECFSZ 00,F
05886:  BRA    5884
....................       response = SD_spi_read(0xFF); 
05888:  MOVF   FC9,W
0588A:  SETF   FC9
0588C:  RRCF   FC7,W
0588E:  BNC   588C
05890:  MOVFF  FC9,A2D
....................       Timer--; 
05894:  MOVF   x2E,W
05896:  BTFSC  FD8.2
05898:  DECF   x2F,F
0589A:  DECF   x2E,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
0589C:  INCFSZ x2D,W
0589E:  BRA    58A2
058A0:  BRA    58A8
058A2:  MOVF   x2E,W
058A4:  IORWF  x2F,W
058A6:  BNZ   5880
....................       ; 
....................  
....................    return (response); 
058A8:  MOVFF  A2D,01
058AC:  MOVLB  0
058AE:  GOTO   58BE (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
058B2:  MOVLW  02
058B4:  MOVLB  A
058B6:  MOVWF  x2C
058B8:  CLRF   x2B
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
058BA:  MOVLB  0
058BC:  BRA    586E
058BE:  INCFSZ 01,W
058C0:  BRA    58C4
058C2:  BRA    58CA
....................       return (FALSE); 
058C4:  MOVLW  00
058C6:  MOVWF  01
058C8:  BRA    5964
....................  
....................    SD_spi_write(token);               // transmit data token 
058CA:  MOVF   FC9,W
058CC:  MOVFF  A29,FC9
058D0:  RRCF   FC7,W
058D2:  BNC   58D0
....................    if (token != 0xFD) 
058D4:  MOVLB  A
058D6:  MOVF   x29,W
058D8:  SUBLW  FD
058DA:  BZ    595E
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
058DC:  MOVFF  A2C,03
058E0:  MOVF   x2B,W
058E2:  BTFSC  FD8.2
058E4:  DECF   x2C,F
058E6:  DECF   x2B,F
058E8:  IORWF  03,W
058EA:  BZ    590E
....................          SD_spi_write(*ptr++); 
058EC:  MOVFF  A28,03
058F0:  MOVF   x27,W
058F2:  INCF   x27,F
058F4:  BTFSC  FD8.2
058F6:  INCF   x28,F
058F8:  MOVWF  FE9
058FA:  MOVFF  03,FEA
058FE:  MOVFF  FEF,A2D
05902:  MOVF   FC9,W
05904:  MOVFF  A2D,FC9
05908:  RRCF   FC7,W
0590A:  BNC   5908
0590C:  BRA    58DC
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
0590E:  MOVF   FC9,W
05910:  SETF   FC9
05912:  RRCF   FC7,W
05914:  BNC   5912
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
05916:  MOVF   FC9,W
05918:  SETF   FC9
0591A:  RRCF   FC7,W
0591C:  BNC   591A
....................       response = SD_spi_read(0xFF);      // Receive data response 
0591E:  MOVF   FC9,W
05920:  SETF   FC9
05922:  RRCF   FC7,W
05924:  BNC   5922
05926:  MOVFF  FC9,A2A
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
0592A:  CLRF   x2C
0592C:  CLRF   x2B
0592E:  MOVF   x2C,W
05930:  SUBLW  C3
05932:  BNC   595E
05934:  BNZ   593C
05936:  MOVF   x2B,W
05938:  SUBLW  4F
0593A:  BNC   595E
....................          { 
....................          delay_us(10); 
0593C:  MOVLW  35
0593E:  MOVWF  00
05940:  DECFSZ 00,F
05942:  BRA    5940
....................          response = SD_spi_read(0xFF);   // digest prior operation 
05944:  MOVF   FC9,W
05946:  SETF   FC9
05948:  RRCF   FC7,W
0594A:  BNC   5948
0594C:  MOVFF  FC9,A2A
....................          if (response != 0x00) 
05950:  MOVF   x2A,F
05952:  BZ    5956
....................             break; 
05954:  BRA    595E
05956:  INCF   x2B,F
05958:  BTFSC  FD8.2
0595A:  INCF   x2C,F
0595C:  BRA    592E
....................          } 
....................  
....................       } 
....................    return(TRUE); 
0595E:  MOVLW  01
05960:  MOVWF  01
05962:  MOVLB  0
05964:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
05966:  MOVLB  4
05968:  BTFSS  xED.0
0596A:  BRA    5972
....................       return (RES_NOTRDY); 
0596C:  MOVLW  03
0596E:  MOVWF  01
05970:  BRA    5AA6
....................  
....................    if (Media_Status & STA_PROTECT) 
05972:  BTFSS  xED.2
05974:  BRA    597C
....................       return (RES_WRPRT); 
05976:  MOVLW  02
05978:  MOVWF  01
0597A:  BRA    5AA6
....................  
....................    if (!SectorCount) 
0597C:  MOVLB  A
0597E:  MOVF   x26,F
05980:  BNZ   598C
....................       return (RES_PARERR); 
05982:  MOVLW  04
05984:  MOVWF  01
05986:  MOVLB  4
05988:  BRA    5AA6
0598A:  MOVLB  A
....................  
....................    SelectSD; 
0598C:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
0598E:  MOVLB  4
05990:  MOVF   xE7,W
05992:  SUBLW  05
05994:  BZ    59B0
....................       SectorNumber *= 512; 
05996:  BCF    FD8.0
05998:  MOVFF  A24,A25
0599C:  MOVFF  A23,A24
059A0:  MOVFF  A22,A23
059A4:  MOVLB  A
059A6:  CLRF   x22
059A8:  RLCF   x23,F
059AA:  RLCF   x24,F
059AC:  RLCF   x25,F
059AE:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
059B0:  MOVLB  A
059B2:  DECFSZ x26,W
059B4:  BRA    59F4
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
059B6:  MOVLW  58
059B8:  MOVWF  x2B
059BA:  MOVFF  A25,A2F
059BE:  MOVFF  A24,A2E
059C2:  MOVFF  A23,A2D
059C6:  MOVFF  A22,A2C
059CA:  MOVLB  0
059CC:  CALL   3568
059D0:  MOVF   01,F
059D2:  BNZ   59F0
....................          if (SD_write_data(Buffer, 0xFE)) 
059D4:  MOVFF  A21,A28
059D8:  MOVFF  A20,A27
059DC:  MOVLW  FE
059DE:  MOVLB  A
059E0:  MOVWF  x29
059E2:  MOVLB  0
059E4:  RCALL  58B2
059E6:  MOVF   01,F
059E8:  BZ    59F0
....................             SectorCount = 0; 
059EA:  MOVLB  A
059EC:  CLRF   x26
059EE:  MOVLB  0
....................       } 
059F0:  BRA    5A8C
059F2:  MOVLB  A
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
059F4:  MOVLB  4
059F6:  MOVF   xE7,W
059F8:  ANDLW  03
059FA:  BZ    5A28
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
059FC:  MOVLW  77
059FE:  MOVLB  A
05A00:  MOVWF  x2B
05A02:  CLRF   x2F
05A04:  CLRF   x2E
05A06:  CLRF   x2D
05A08:  CLRF   x2C
05A0A:  MOVLB  0
05A0C:  CALL   3568
....................          SD_cmd(SD_ACMD23, SectorCount); 
05A10:  MOVLW  57
05A12:  MOVLB  A
05A14:  MOVWF  x2B
05A16:  CLRF   x2F
05A18:  CLRF   x2E
05A1A:  CLRF   x2D
05A1C:  MOVFF  A26,A2C
05A20:  MOVLB  0
05A22:  CALL   3568
05A26:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05A28:  MOVLW  59
05A2A:  MOVLB  A
05A2C:  MOVWF  x2B
05A2E:  MOVFF  A25,A2F
05A32:  MOVFF  A24,A2E
05A36:  MOVFF  A23,A2D
05A3A:  MOVFF  A22,A2C
05A3E:  MOVLB  0
05A40:  CALL   3568
05A44:  MOVF   01,F
05A46:  BNZ   5A8C
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
05A48:  MOVFF  A21,A28
05A4C:  MOVFF  A20,A27
05A50:  MOVLW  FC
05A52:  MOVLB  A
05A54:  MOVWF  x29
05A56:  MOVLB  0
05A58:  RCALL  58B2
05A5A:  MOVF   01,F
05A5C:  BNZ   5A60
....................                break; 
05A5E:  BRA    5A72
....................             Buffer += 512; 
05A60:  MOVLW  02
05A62:  MOVLB  A
05A64:  ADDWF  x21,F
....................             } while (--SectorCount); 
05A66:  DECF   x26,F
05A68:  BTFSC  FD8.2
05A6A:  BRA    5A70
05A6C:  MOVLB  0
05A6E:  BRA    5A48
05A70:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
05A72:  MOVLB  A
05A74:  CLRF   x28
05A76:  CLRF   x27
05A78:  MOVLW  FD
05A7A:  MOVWF  x29
05A7C:  MOVLB  0
05A7E:  RCALL  58B2
05A80:  MOVF   01,F
05A82:  BNZ   5A8C
....................             SectorCount = 1; 
05A84:  MOVLW  01
05A86:  MOVLB  A
05A88:  MOVWF  x26
05A8A:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
05A8C:  BSF    F91.1
....................    SD_spi_read(0xFF); 
05A8E:  MOVF   FC9,W
05A90:  SETF   FC9
05A92:  RRCF   FC7,W
05A94:  BNC   5A92
....................    return SectorCount ? RES_ERROR : RES_OK; 
05A96:  MOVLB  A
05A98:  MOVF   x26,F
05A9A:  BZ    5AA0
05A9C:  MOVLW  01
05A9E:  BRA    5AA2
05AA0:  MOVLW  00
05AA2:  MOVWF  01
05AA4:  MOVLB  4
05AA6:  MOVLB  0
05AA8:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
044F4:  MOVLB  4
044F6:  BTFSS  xED.0
044F8:  BRA    4500
....................       return (RES_NOTRDY); 
044FA:  MOVLW  03
044FC:  MOVWF  01
044FE:  BRA    4630
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
04500:  MOVLB  A
04502:  MOVF   x26,W
04504:  SUBLW  01
04506:  BNC   450C
04508:  MOVF   x26,F
0450A:  BNZ   4516
....................       return(RES_PARERR); 
0450C:  MOVLW  04
0450E:  MOVWF  01
04510:  MOVLB  4
04512:  BRA    4630
04514:  MOVLB  A
....................  
....................    SelectSD; 
04516:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
04518:  CLRF   x2A
0451A:  CLRF   x29
0451C:  MOVLW  02
0451E:  MOVWF  x28
04520:  CLRF   x27
04522:  MOVLB  0
04524:  BRA    43FC
04526:  MOVF   01,F
04528:  BNZ   4536
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
0452A:  BSF    F91.1
....................       return(RES_ERROR); 
0452C:  MOVLW  01
0452E:  MOVWF  01
04530:  MOVLB  4
04532:  BRA    4630
04534:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
04536:  MOVLB  4
04538:  MOVF   xE7,W
0453A:  SUBLW  05
0453C:  BZ    4558
....................       SectorNumber *= 512; 
0453E:  BCF    FD8.0
04540:  MOVFF  A24,A25
04544:  MOVFF  A23,A24
04548:  MOVFF  A22,A23
0454C:  MOVLB  A
0454E:  CLRF   x22
04550:  RLCF   x23,F
04552:  RLCF   x24,F
04554:  RLCF   x25,F
04556:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
04558:  MOVLB  A
0455A:  DECFSZ x26,W
0455C:  BRA    45B4
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
0455E:  MOVLW  51
04560:  MOVWF  x2B
04562:  MOVFF  A25,A2F
04566:  MOVFF  A24,A2E
0456A:  MOVFF  A23,A2D
0456E:  MOVFF  A22,A2C
04572:  MOVLB  0
04574:  CALL   3568
04578:  MOVF   01,F
0457A:  BZ    4588
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
0457C:  BSF    F91.1
....................          return(RES_PARERR); 
0457E:  MOVLW  04
04580:  MOVWF  01
04582:  MOVLB  4
04584:  BRA    4630
04586:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
04588:  MOVFF  A21,A28
0458C:  MOVFF  A20,A27
04590:  MOVLB  A
04592:  CLRF   x2C
04594:  CLRF   x2B
04596:  MOVLW  02
04598:  MOVWF  x2A
0459A:  CLRF   x29
0459C:  MOVLB  0
0459E:  RCALL  4446
045A0:  MOVF   01,F
045A2:  BZ    45B0
....................          { 
....................          DeselectSD; 
045A4:  BSF    F91.1
....................          return(RES_ERROR); 
045A6:  MOVLW  01
045A8:  MOVWF  01
045AA:  MOVLB  4
045AC:  BRA    4630
045AE:  MOVLB  0
....................          } 
....................       } 
045B0:  BRA    4628
045B2:  MOVLB  A
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
045B4:  MOVLW  52
045B6:  MOVWF  x2B
045B8:  MOVFF  A25,A2F
045BC:  MOVFF  A24,A2E
045C0:  MOVFF  A23,A2D
045C4:  MOVFF  A22,A2C
045C8:  MOVLB  0
045CA:  CALL   3568
045CE:  MOVF   01,F
045D0:  BZ    45DE
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
045D2:  BSF    F91.1
....................          return(RES_PARERR); 
045D4:  MOVLW  04
045D6:  MOVWF  01
045D8:  MOVLB  4
045DA:  BRA    4630
045DC:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
045DE:  MOVFF  A21,A28
045E2:  MOVFF  A20,A27
045E6:  MOVLB  A
045E8:  CLRF   x2C
045EA:  CLRF   x2B
045EC:  MOVLW  02
045EE:  MOVWF  x2A
045F0:  CLRF   x29
045F2:  MOVLB  0
045F4:  RCALL  4446
045F6:  MOVF   01,F
045F8:  BZ    4606
....................             { 
....................             DeselectSD; 
045FA:  BSF    F91.1
....................             return(RES_ERROR); 
045FC:  MOVLW  01
045FE:  MOVWF  01
04600:  MOVLB  4
04602:  BRA    4630
04604:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
04606:  MOVLW  02
04608:  MOVLB  A
0460A:  ADDWF  x21,F
....................          } while (--SectorCount); 
0460C:  DECF   x26,F
0460E:  BTFSC  FD8.2
04610:  BRA    4616
04612:  MOVLB  0
04614:  BRA    45DE
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
04616:  MOVLW  4C
04618:  MOVWF  x2B
0461A:  CLRF   x2F
0461C:  CLRF   x2E
0461E:  CLRF   x2D
04620:  CLRF   x2C
04622:  MOVLB  0
04624:  CALL   3568
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
04628:  BSF    F91.1
....................    return(RES_OK); 
0462A:  MOVLW  00
0462C:  MOVWF  01
0462E:  MOVLB  4
04630:  MOVLB  0
04632:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
055C6:  MOVLB  4
055C8:  BCF    xED.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
055CA:  BCF    xED.2
....................  
....................    return(Media_Status); 
055CC:  MOVFF  4ED,01
055D0:  MOVLB  0
055D2:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
0369E:  MOVLB  9
036A0:  CLRF   xEB
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
036A2:  MOVLB  4
036A4:  CLRF   xE7
....................  
....................    DeselectSD; 
036A6:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
036A8:  MOVLW  0A
036AA:  MOVLB  9
036AC:  MOVWF  xEC
036AE:  MOVLB  0
036B0:  CALL   2938
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
036B4:  BCF    FC6.5
036B6:  MOVLW  22
036B8:  MOVWF  FC6
036BA:  MOVLW  40
036BC:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
036BE:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
036C0:  MOVLB  9
036C2:  CLRF   xE3
036C4:  MOVF   xE3,W
036C6:  SUBLW  09
036C8:  BNC   36D6
....................       SD_spi_read(0xFF); 
036CA:  MOVF   FC9,W
036CC:  SETF   FC9
036CE:  RRCF   FC7,W
036D0:  BNC   36CE
036D2:  INCF   xE3,F
036D4:  BRA    36C4
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
036D6:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
036D8:  MOVF   1F,W
036DA:  SUBLW  04
036DC:  BNZ   3702
036DE:  MOVF   20,F
036E0:  BNZ   3702
036E2:  MOVLW  7A
036E4:  MOVWF  FF6
036E6:  MOVLW  06
036E8:  MOVWF  FF7
036EA:  MOVLW  00
036EC:  MOVWF  FF8
036EE:  CLRF   1B
036F0:  BTFSC  FF2.7
036F2:  BSF    1B.7
036F4:  BCF    FF2.7
036F6:  MOVLB  0
036F8:  CALL   0E6E
036FC:  BTFSC  1B.7
036FE:  BSF    FF2.7
03700:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
03702:  MOVLW  40
03704:  MOVLB  A
03706:  MOVWF  x2B
03708:  CLRF   x2F
0370A:  CLRF   x2E
0370C:  CLRF   x2D
0370E:  CLRF   x2C
03710:  MOVLB  0
03712:  RCALL  3568
03714:  MOVFF  01,9E4
....................    if (response > 1 ) 
03718:  MOVLB  9
0371A:  MOVF   xE4,W
0371C:  SUBLW  01
0371E:  BC    3774
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
03720:  MOVF   1F,W
03722:  SUBLW  04
03724:  BNZ   376E
03726:  MOVF   20,F
03728:  BNZ   376E
0372A:  MOVLW  8A
0372C:  MOVWF  FF6
0372E:  MOVLW  06
03730:  MOVWF  FF7
03732:  MOVLW  00
03734:  MOVWF  FF8
03736:  CLRF   1B
03738:  BTFSC  FF2.7
0373A:  BSF    1B.7
0373C:  BCF    FF2.7
0373E:  MOVLW  31
03740:  MOVLB  A
03742:  MOVWF  x40
03744:  MOVLB  0
03746:  CALL   1044
0374A:  BTFSC  1B.7
0374C:  BSF    FF2.7
0374E:  MOVFF  9E4,9EC
03752:  MOVLW  57
03754:  MOVLB  9
03756:  MOVWF  xED
03758:  MOVLB  0
0375A:  RCALL  3638
0375C:  MOVLW  0D
0375E:  BTFSS  F9E.4
03760:  BRA    375E
03762:  MOVWF  FAD
03764:  MOVLW  0A
03766:  BTFSS  F9E.4
03768:  BRA    3766
0376A:  MOVWF  FAD
0376C:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
0376E:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
03770:  GOTO   43F2
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
03774:  MOVF   1F,W
03776:  SUBLW  04
03778:  BNZ   37C2
0377A:  MOVF   20,F
0377C:  BNZ   37C2
0377E:  MOVLW  C2
03780:  MOVWF  FF6
03782:  MOVLW  06
03784:  MOVWF  FF7
03786:  MOVLW  00
03788:  MOVWF  FF8
0378A:  CLRF   1B
0378C:  BTFSC  FF2.7
0378E:  BSF    1B.7
03790:  BCF    FF2.7
03792:  MOVLW  1A
03794:  MOVLB  A
03796:  MOVWF  x40
03798:  MOVLB  0
0379A:  CALL   1044
0379E:  BTFSC  1B.7
037A0:  BSF    FF2.7
037A2:  MOVFF  9E4,9EC
037A6:  MOVLW  57
037A8:  MOVLB  9
037AA:  MOVWF  xED
037AC:  MOVLB  0
037AE:  RCALL  3638
037B0:  MOVLW  0D
037B2:  BTFSS  F9E.4
037B4:  BRA    37B2
037B6:  MOVWF  FAD
037B8:  MOVLW  0A
037BA:  BTFSS  F9E.4
037BC:  BRA    37BA
037BE:  MOVWF  FAD
037C0:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
037C2:  MOVLW  48
037C4:  MOVLB  A
037C6:  MOVWF  x2B
037C8:  CLRF   x2F
037CA:  CLRF   x2E
037CC:  MOVLW  01
037CE:  MOVWF  x2D
037D0:  MOVLW  AA
037D2:  MOVWF  x2C
037D4:  MOVLB  0
037D6:  RCALL  3568
037D8:  MOVFF  01,9E4
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
037DC:  MOVF   1F,W
037DE:  SUBLW  04
037E0:  BNZ   3828
037E2:  MOVF   20,F
037E4:  BNZ   3828
037E6:  MOVLW  E4
037E8:  MOVWF  FF6
037EA:  MOVLW  06
037EC:  MOVWF  FF7
037EE:  MOVLW  00
037F0:  MOVWF  FF8
037F2:  CLRF   1B
037F4:  BTFSC  FF2.7
037F6:  BSF    1B.7
037F8:  BCF    FF2.7
037FA:  MOVLW  25
037FC:  MOVLB  A
037FE:  MOVWF  x40
03800:  MOVLB  0
03802:  CALL   1044
03806:  BTFSC  1B.7
03808:  BSF    FF2.7
0380A:  MOVFF  9E4,9EC
0380E:  MOVLW  57
03810:  MOVLB  9
03812:  MOVWF  xED
03814:  MOVLB  0
03816:  RCALL  3638
03818:  MOVLW  0D
0381A:  BTFSS  F9E.4
0381C:  BRA    381A
0381E:  MOVWF  FAD
03820:  MOVLW  0A
03822:  BTFSS  F9E.4
03824:  BRA    3822
03826:  MOVWF  FAD
....................    if (response == 1)  
03828:  MOVLB  9
0382A:  DECFSZ xE4,W
0382C:  BRA    3BFE
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
0382E:  MOVF   1F,W
03830:  SUBLW  04
03832:  BNZ   3858
03834:  MOVF   20,F
03836:  BNZ   3858
03838:  MOVLW  0E
0383A:  MOVWF  FF6
0383C:  MOVLW  07
0383E:  MOVWF  FF7
03840:  MOVLW  00
03842:  MOVWF  FF8
03844:  CLRF   1B
03846:  BTFSC  FF2.7
03848:  BSF    1B.7
0384A:  BCF    FF2.7
0384C:  MOVLB  0
0384E:  CALL   0E6E
03852:  BTFSC  1B.7
03854:  BSF    FF2.7
03856:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
03858:  CLRF   xE3
0385A:  MOVF   xE3,W
0385C:  SUBLW  03
0385E:  BNC   387E
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
03860:  CLRF   03
03862:  MOVF   xE3,W
03864:  ADDLW  E5
03866:  MOVWF  FE9
03868:  MOVLW  09
0386A:  ADDWFC 03,W
0386C:  MOVWF  FEA
0386E:  MOVF   FC9,W
03870:  SETF   FC9
03872:  RRCF   FC7,W
03874:  BNC   3872
03876:  MOVFF  FC9,FEF
0387A:  INCF   xE3,F
0387C:  BRA    385A
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
0387E:  MOVF   1F,W
03880:  SUBLW  04
03882:  BNZ   38F6
03884:  MOVF   20,F
03886:  BNZ   38F6
03888:  MOVLW  30
0388A:  MOVWF  FF6
0388C:  MOVLW  07
0388E:  MOVWF  FF7
03890:  MOVLW  00
03892:  MOVWF  FF8
03894:  CLRF   1B
03896:  BTFSC  FF2.7
03898:  BSF    1B.7
0389A:  BCF    FF2.7
0389C:  MOVLW  1F
0389E:  MOVLB  A
038A0:  MOVWF  x40
038A2:  MOVLB  0
038A4:  CALL   1044
038A8:  BTFSC  1B.7
038AA:  BSF    FF2.7
038AC:  MOVFF  9E5,9EC
038B0:  MOVLW  57
038B2:  MOVLB  9
038B4:  MOVWF  xED
038B6:  MOVLB  0
038B8:  RCALL  3638
038BA:  MOVFF  9E6,9EC
038BE:  MOVLW  57
038C0:  MOVLB  9
038C2:  MOVWF  xED
038C4:  MOVLB  0
038C6:  RCALL  3638
038C8:  MOVFF  9E7,9EC
038CC:  MOVLW  57
038CE:  MOVLB  9
038D0:  MOVWF  xED
038D2:  MOVLB  0
038D4:  RCALL  3638
038D6:  MOVFF  9E8,9EC
038DA:  MOVLW  57
038DC:  MOVLB  9
038DE:  MOVWF  xED
038E0:  MOVLB  0
038E2:  RCALL  3638
038E4:  MOVLW  0D
038E6:  BTFSS  F9E.4
038E8:  BRA    38E6
038EA:  MOVWF  FAD
038EC:  MOVLW  0A
038EE:  BTFSS  F9E.4
038F0:  BRA    38EE
038F2:  MOVWF  FAD
038F4:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
038F6:  DECFSZ xE7,W
038F8:  BRA    3BD4
038FA:  MOVF   xE8,W
038FC:  SUBLW  AA
038FE:  BTFSS  FD8.2
03900:  BRA    3BD4
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
03902:  MOVF   1F,W
03904:  SUBLW  04
03906:  BNZ   392C
03908:  MOVF   20,F
0390A:  BNZ   392C
0390C:  MOVLW  62
0390E:  MOVWF  FF6
03910:  MOVLW  07
03912:  MOVWF  FF7
03914:  MOVLW  00
03916:  MOVWF  FF8
03918:  CLRF   1B
0391A:  BTFSC  FF2.7
0391C:  BSF    1B.7
0391E:  BCF    FF2.7
03920:  MOVLB  0
03922:  CALL   0E6E
03926:  BTFSC  1B.7
03928:  BSF    FF2.7
0392A:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
0392C:  MOVF   1F,W
0392E:  SUBLW  04
03930:  BNZ   3956
03932:  MOVF   20,F
03934:  BNZ   3956
03936:  MOVLW  88
03938:  MOVWF  FF6
0393A:  MOVLW  07
0393C:  MOVWF  FF7
0393E:  MOVLW  00
03940:  MOVWF  FF8
03942:  CLRF   1B
03944:  BTFSC  FF2.7
03946:  BSF    1B.7
03948:  BCF    FF2.7
0394A:  MOVLB  0
0394C:  CALL   0E6E
03950:  BTFSC  1B.7
03952:  BSF    FF2.7
03954:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
03956:  CLRF   xEA
03958:  CLRF   xE9
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
0395A:  MOVLW  77
0395C:  MOVLB  A
0395E:  MOVWF  x2B
03960:  CLRF   x2F
03962:  CLRF   x2E
03964:  CLRF   x2D
03966:  CLRF   x2C
03968:  MOVLB  0
0396A:  RCALL  3568
0396C:  MOVFF  01,9E4
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
03970:  MOVLW  69
03972:  MOVLB  A
03974:  MOVWF  x2B
03976:  MOVLW  40
03978:  MOVWF  x2F
0397A:  CLRF   x2E
0397C:  CLRF   x2D
0397E:  CLRF   x2C
03980:  MOVLB  0
03982:  RCALL  3568
03984:  MOVFF  01,9E4
....................          while (response && (Timer < 50000)) 
03988:  MOVLB  9
0398A:  MOVF   xE4,F
0398C:  BZ    39DE
0398E:  MOVF   xEA,W
03990:  SUBLW  C3
03992:  BNC   39DE
03994:  BNZ   399C
03996:  MOVF   xE9,W
03998:  SUBLW  4F
0399A:  BNC   39DE
....................          { 
....................             delay_us(20); 
0399C:  MOVLW  6A
0399E:  MOVWF  00
039A0:  DECFSZ 00,F
039A2:  BRA    39A0
039A4:  NOP   
....................             Timer++; 
039A6:  INCF   xE9,F
039A8:  BTFSC  FD8.2
039AA:  INCF   xEA,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
039AC:  MOVLW  77
039AE:  MOVLB  A
039B0:  MOVWF  x2B
039B2:  CLRF   x2F
039B4:  CLRF   x2E
039B6:  CLRF   x2D
039B8:  CLRF   x2C
039BA:  MOVLB  0
039BC:  RCALL  3568
039BE:  MOVFF  01,9E4
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
039C2:  MOVLW  69
039C4:  MOVLB  A
039C6:  MOVWF  x2B
039C8:  MOVLW  40
039CA:  MOVWF  x2F
039CC:  CLRF   x2E
039CE:  CLRF   x2D
039D0:  CLRF   x2C
039D2:  MOVLB  0
039D4:  RCALL  3568
039D6:  MOVFF  01,9E4
039DA:  BRA    3988
039DC:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
039DE:  MOVF   1F,W
039E0:  SUBLW  04
039E2:  BNZ   3A6C
039E4:  MOVF   20,F
039E6:  BNZ   3A6C
039E8:  MOVLW  B6
039EA:  MOVWF  FF6
039EC:  MOVLW  07
039EE:  MOVWF  FF7
039F0:  MOVLW  00
039F2:  MOVWF  FF8
039F4:  CLRF   1B
039F6:  BTFSC  FF2.7
039F8:  BSF    1B.7
039FA:  BCF    FF2.7
039FC:  MOVLW  23
039FE:  MOVLB  A
03A00:  MOVWF  x40
03A02:  MOVLB  0
03A04:  CALL   1044
03A08:  BTFSC  1B.7
03A0A:  BSF    FF2.7
03A0C:  MOVFF  9E4,9EC
03A10:  MOVLW  57
03A12:  MOVLB  9
03A14:  MOVWF  xED
03A16:  MOVLB  0
03A18:  RCALL  3638
03A1A:  MOVLW  DD
03A1C:  MOVWF  FF6
03A1E:  MOVLW  07
03A20:  MOVWF  FF7
03A22:  MOVLW  00
03A24:  MOVWF  FF8
03A26:  CLRF   1B
03A28:  BTFSC  FF2.7
03A2A:  BSF    1B.7
03A2C:  BCF    FF2.7
03A2E:  MOVLW  0A
03A30:  MOVLB  A
03A32:  MOVWF  x40
03A34:  MOVLB  0
03A36:  CALL   1044
03A3A:  BTFSC  1B.7
03A3C:  BSF    FF2.7
03A3E:  MOVLW  10
03A40:  MOVWF  FE9
03A42:  CLRF   1B
03A44:  BTFSC  FF2.7
03A46:  BSF    1B.7
03A48:  BCF    FF2.7
03A4A:  MOVFF  9EA,A41
03A4E:  MOVFF  9E9,A40
03A52:  CALL   11C6
03A56:  BTFSC  1B.7
03A58:  BSF    FF2.7
03A5A:  MOVLW  0D
03A5C:  BTFSS  F9E.4
03A5E:  BRA    3A5C
03A60:  MOVWF  FAD
03A62:  MOVLW  0A
03A64:  BTFSS  F9E.4
03A66:  BRA    3A64
03A68:  MOVWF  FAD
03A6A:  MOVLB  9
....................          if (!response) 
03A6C:  MOVF   xE4,F
03A6E:  BTFSS  FD8.2
03A70:  BRA    3BD2
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
03A72:  MOVLW  7A
03A74:  MOVLB  A
03A76:  MOVWF  x2B
03A78:  MOVLW  40
03A7A:  MOVWF  x2F
03A7C:  CLRF   x2E
03A7E:  CLRF   x2D
03A80:  CLRF   x2C
03A82:  MOVLB  0
03A84:  RCALL  3568
03A86:  MOVFF  01,9E4
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
03A8A:  MOVF   1F,W
03A8C:  SUBLW  04
03A8E:  BNZ   3AD6
03A90:  MOVF   20,F
03A92:  BNZ   3AD6
03A94:  MOVLW  EE
03A96:  MOVWF  FF6
03A98:  MOVLW  07
03A9A:  MOVWF  FF7
03A9C:  MOVLW  00
03A9E:  MOVWF  FF8
03AA0:  CLRF   1B
03AA2:  BTFSC  FF2.7
03AA4:  BSF    1B.7
03AA6:  BCF    FF2.7
03AA8:  MOVLW  18
03AAA:  MOVLB  A
03AAC:  MOVWF  x40
03AAE:  MOVLB  0
03AB0:  CALL   1044
03AB4:  BTFSC  1B.7
03AB6:  BSF    FF2.7
03AB8:  MOVFF  9E4,9EC
03ABC:  MOVLW  57
03ABE:  MOVLB  9
03AC0:  MOVWF  xED
03AC2:  MOVLB  0
03AC4:  RCALL  3638
03AC6:  MOVLW  0D
03AC8:  BTFSS  F9E.4
03ACA:  BRA    3AC8
03ACC:  MOVWF  FAD
03ACE:  MOVLW  0A
03AD0:  BTFSS  F9E.4
03AD2:  BRA    3AD0
03AD4:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03AD6:  MOVLB  9
03AD8:  MOVF   xE4,F
03ADA:  BTFSS  FD8.2
03ADC:  BRA    3BD2
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03ADE:  CLRF   xE3
03AE0:  MOVF   xE3,W
03AE2:  SUBLW  03
03AE4:  BNC   3B04
....................                   ocr[i] = SD_spi_read(0xFF); 
03AE6:  CLRF   03
03AE8:  MOVF   xE3,W
03AEA:  ADDLW  E5
03AEC:  MOVWF  FE9
03AEE:  MOVLW  09
03AF0:  ADDWFC 03,W
03AF2:  MOVWF  FEA
03AF4:  MOVF   FC9,W
03AF6:  SETF   FC9
03AF8:  RRCF   FC7,W
03AFA:  BNC   3AF8
03AFC:  MOVFF  FC9,FEF
03B00:  INCF   xE3,F
03B02:  BRA    3AE0
....................                if (ocr[0] & 0x40) 
03B04:  BTFSS  xE5.6
03B06:  BRA    3B12
....................                   Card = SDHC; 
03B08:  MOVLW  05
03B0A:  MOVLB  4
03B0C:  MOVWF  xE7
03B0E:  BRA    3B18
03B10:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03B12:  MOVLW  04
03B14:  MOVLB  4
03B16:  MOVWF  xE7
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03B18:  MOVF   1F,W
03B1A:  SUBLW  04
03B1C:  BNZ   3BD0
03B1E:  MOVF   20,F
03B20:  BNZ   3BD0
03B22:  MOVLW  0C
03B24:  MOVWF  FF6
03B26:  MOVLW  08
03B28:  MOVWF  FF7
03B2A:  MOVLW  00
03B2C:  MOVWF  FF8
03B2E:  CLRF   1B
03B30:  BTFSC  FF2.7
03B32:  BSF    1B.7
03B34:  BCF    FF2.7
03B36:  MOVLW  1F
03B38:  MOVLB  A
03B3A:  MOVWF  x40
03B3C:  MOVLB  0
03B3E:  CALL   1044
03B42:  BTFSC  1B.7
03B44:  BSF    FF2.7
03B46:  MOVLW  10
03B48:  MOVWF  FE9
03B4A:  CLRF   1B
03B4C:  BTFSC  FF2.7
03B4E:  BSF    1B.7
03B50:  BCF    FF2.7
03B52:  MOVFF  9EA,A41
03B56:  MOVFF  9E9,A40
03B5A:  CALL   11C6
03B5E:  BTFSC  1B.7
03B60:  BSF    FF2.7
03B62:  MOVLW  2E
03B64:  MOVWF  FF6
03B66:  MOVLW  08
03B68:  MOVWF  FF7
03B6A:  MOVLW  00
03B6C:  MOVWF  FF8
03B6E:  CLRF   1B
03B70:  BTFSC  FF2.7
03B72:  BSF    1B.7
03B74:  BCF    FF2.7
03B76:  MOVLW  08
03B78:  MOVLB  A
03B7A:  MOVWF  x40
03B7C:  MOVLB  0
03B7E:  CALL   1044
03B82:  BTFSC  1B.7
03B84:  BSF    FF2.7
03B86:  MOVFF  9E5,9EC
03B8A:  MOVLW  57
03B8C:  MOVLB  9
03B8E:  MOVWF  xED
03B90:  MOVLB  0
03B92:  RCALL  3638
03B94:  MOVFF  9E6,9EC
03B98:  MOVLW  57
03B9A:  MOVLB  9
03B9C:  MOVWF  xED
03B9E:  MOVLB  0
03BA0:  RCALL  3638
03BA2:  MOVFF  9E7,9EC
03BA6:  MOVLW  57
03BA8:  MOVLB  9
03BAA:  MOVWF  xED
03BAC:  MOVLB  0
03BAE:  RCALL  3638
03BB0:  MOVFF  9E8,9EC
03BB4:  MOVLW  57
03BB6:  MOVLB  9
03BB8:  MOVWF  xED
03BBA:  MOVLB  0
03BBC:  RCALL  3638
03BBE:  MOVLW  0D
03BC0:  BTFSS  F9E.4
03BC2:  BRA    3BC0
03BC4:  MOVWF  FAD
03BC6:  MOVLW  0A
03BC8:  BTFSS  F9E.4
03BCA:  BRA    3BC8
03BCC:  MOVWF  FAD
03BCE:  MOVLB  4
03BD0:  MOVLB  9
....................             } 
....................          } 
....................       } 
03BD2:  BRA    3BFE
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03BD4:  MOVF   1F,W
03BD6:  SUBLW  04
03BD8:  BNZ   3BFE
03BDA:  MOVF   20,F
03BDC:  BNZ   3BFE
03BDE:  MOVLW  4A
03BE0:  MOVWF  FF6
03BE2:  MOVLW  08
03BE4:  MOVWF  FF7
03BE6:  MOVLW  00
03BE8:  MOVWF  FF8
03BEA:  CLRF   1B
03BEC:  BTFSC  FF2.7
03BEE:  BSF    1B.7
03BF0:  BCF    FF2.7
03BF2:  MOVLB  0
03BF4:  CALL   0E6E
03BF8:  BTFSC  1B.7
03BFA:  BSF    FF2.7
03BFC:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03BFE:  MOVLB  4
03C00:  MOVF   xE7,F
03C02:  BTFSS  FD8.2
03C04:  BRA    40D4
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03C06:  MOVF   1F,W
03C08:  SUBLW  04
03C0A:  BNZ   3C30
03C0C:  MOVF   20,F
03C0E:  BNZ   3C30
03C10:  MOVLW  7C
03C12:  MOVWF  FF6
03C14:  MOVLW  08
03C16:  MOVWF  FF7
03C18:  MOVLW  00
03C1A:  MOVWF  FF8
03C1C:  CLRF   1B
03C1E:  BTFSC  FF2.7
03C20:  BSF    1B.7
03C22:  BCF    FF2.7
03C24:  MOVLB  0
03C26:  CALL   0E6E
03C2A:  BTFSC  1B.7
03C2C:  BSF    FF2.7
03C2E:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03C30:  MOVLW  40
03C32:  MOVLB  A
03C34:  MOVWF  x2B
03C36:  CLRF   x2F
03C38:  CLRF   x2E
03C3A:  CLRF   x2D
03C3C:  CLRF   x2C
03C3E:  MOVLB  0
03C40:  RCALL  3568
03C42:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03C46:  MOVF   1F,W
03C48:  SUBLW  04
03C4A:  BNZ   3C92
03C4C:  MOVF   20,F
03C4E:  BNZ   3C92
03C50:  MOVLW  BC
03C52:  MOVWF  FF6
03C54:  MOVLW  08
03C56:  MOVWF  FF7
03C58:  MOVLW  00
03C5A:  MOVWF  FF8
03C5C:  CLRF   1B
03C5E:  BTFSC  FF2.7
03C60:  BSF    1B.7
03C62:  BCF    FF2.7
03C64:  MOVLW  1C
03C66:  MOVLB  A
03C68:  MOVWF  x40
03C6A:  MOVLB  0
03C6C:  CALL   1044
03C70:  BTFSC  1B.7
03C72:  BSF    FF2.7
03C74:  MOVFF  9E4,9EC
03C78:  MOVLW  57
03C7A:  MOVLB  9
03C7C:  MOVWF  xED
03C7E:  MOVLB  0
03C80:  RCALL  3638
03C82:  MOVLW  0D
03C84:  BTFSS  F9E.4
03C86:  BRA    3C84
03C88:  MOVWF  FAD
03C8A:  MOVLW  0A
03C8C:  BTFSS  F9E.4
03C8E:  BRA    3C8C
03C90:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03C92:  MOVLB  9
03C94:  DECFSZ xE4,W
03C96:  BRA    3C9A
03C98:  BRA    3CA4
03C9A:  MOVF   xE4,F
03C9C:  BZ    3CA4
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03C9E:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03CA0:  GOTO   43F2
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03CA4:  CLRF   xEA
03CA6:  CLRF   xE9
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03CA8:  MOVLW  41
03CAA:  MOVLB  A
03CAC:  MOVWF  x2B
03CAE:  CLRF   x2F
03CB0:  CLRF   x2E
03CB2:  CLRF   x2D
03CB4:  CLRF   x2C
03CB6:  MOVLB  0
03CB8:  RCALL  3568
03CBA:  MOVFF  01,9E4
....................          if (response != 0x00 ) 
03CBE:  MOVLB  9
03CC0:  MOVF   xE4,F
03CC2:  BZ    3CCC
....................             delay_us(10); 
03CC4:  MOVLW  35
03CC6:  MOVWF  00
03CC8:  DECFSZ 00,F
03CCA:  BRA    3CC8
....................          Timer++; 
03CCC:  INCF   xE9,F
03CCE:  BTFSC  FD8.2
03CD0:  INCF   xEA,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03CD2:  MOVF   xE4,F
03CD4:  BZ    3CE4
03CD6:  MOVF   xEA,W
03CD8:  SUBLW  C3
03CDA:  BNC   3CE4
03CDC:  BNZ   3CA8
03CDE:  MOVF   xE9,W
03CE0:  SUBLW  4F
03CE2:  BC    3CA8
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03CE4:  MOVF   1F,W
03CE6:  SUBLW  04
03CE8:  BNZ   3D72
03CEA:  MOVF   20,F
03CEC:  BNZ   3D72
03CEE:  MOVLW  E0
03CF0:  MOVWF  FF6
03CF2:  MOVLW  08
03CF4:  MOVWF  FF7
03CF6:  MOVLW  00
03CF8:  MOVWF  FF8
03CFA:  CLRF   1B
03CFC:  BTFSC  FF2.7
03CFE:  BSF    1B.7
03D00:  BCF    FF2.7
03D02:  MOVLW  28
03D04:  MOVLB  A
03D06:  MOVWF  x40
03D08:  MOVLB  0
03D0A:  CALL   1044
03D0E:  BTFSC  1B.7
03D10:  BSF    FF2.7
03D12:  MOVFF  9E4,9EC
03D16:  MOVLW  57
03D18:  MOVLB  9
03D1A:  MOVWF  xED
03D1C:  MOVLB  0
03D1E:  RCALL  3638
03D20:  MOVLW  0C
03D22:  MOVWF  FF6
03D24:  MOVLW  09
03D26:  MOVWF  FF7
03D28:  MOVLW  00
03D2A:  MOVWF  FF8
03D2C:  CLRF   1B
03D2E:  BTFSC  FF2.7
03D30:  BSF    1B.7
03D32:  BCF    FF2.7
03D34:  MOVLW  0A
03D36:  MOVLB  A
03D38:  MOVWF  x40
03D3A:  MOVLB  0
03D3C:  CALL   1044
03D40:  BTFSC  1B.7
03D42:  BSF    FF2.7
03D44:  MOVLW  10
03D46:  MOVWF  FE9
03D48:  CLRF   1B
03D4A:  BTFSC  FF2.7
03D4C:  BSF    1B.7
03D4E:  BCF    FF2.7
03D50:  MOVFF  9EA,A41
03D54:  MOVFF  9E9,A40
03D58:  CALL   11C6
03D5C:  BTFSC  1B.7
03D5E:  BSF    FF2.7
03D60:  MOVLW  0D
03D62:  BTFSS  F9E.4
03D64:  BRA    3D62
03D66:  MOVWF  FAD
03D68:  MOVLW  0A
03D6A:  BTFSS  F9E.4
03D6C:  BRA    3D6A
03D6E:  MOVWF  FAD
03D70:  MOVLB  9
....................       if(response) 
03D72:  MOVF   xE4,F
03D74:  BZ    3D7A
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03D76:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03D78:  BRA    43F2
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03D7A:  MOVLW  77
03D7C:  MOVLB  A
03D7E:  MOVWF  x2B
03D80:  CLRF   x2F
03D82:  CLRF   x2E
03D84:  CLRF   x2D
03D86:  CLRF   x2C
03D88:  MOVLB  0
03D8A:  CALL   3568
03D8E:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03D92:  MOVF   1F,W
03D94:  SUBLW  04
03D96:  BNZ   3DDE
03D98:  MOVF   20,F
03D9A:  BNZ   3DDE
03D9C:  MOVLW  1C
03D9E:  MOVWF  FF6
03DA0:  MOVLW  09
03DA2:  MOVWF  FF7
03DA4:  MOVLW  00
03DA6:  MOVWF  FF8
03DA8:  CLRF   1B
03DAA:  BTFSC  FF2.7
03DAC:  BSF    1B.7
03DAE:  BCF    FF2.7
03DB0:  MOVLW  43
03DB2:  MOVLB  A
03DB4:  MOVWF  x40
03DB6:  MOVLB  0
03DB8:  CALL   1044
03DBC:  BTFSC  1B.7
03DBE:  BSF    FF2.7
03DC0:  MOVFF  9E4,9EC
03DC4:  MOVLW  57
03DC6:  MOVLB  9
03DC8:  MOVWF  xED
03DCA:  MOVLB  0
03DCC:  RCALL  3638
03DCE:  MOVLW  0D
03DD0:  BTFSS  F9E.4
03DD2:  BRA    3DD0
03DD4:  MOVWF  FAD
03DD6:  MOVLW  0A
03DD8:  BTFSS  F9E.4
03DDA:  BRA    3DD8
03DDC:  MOVWF  FAD
....................       if (response) 
03DDE:  MOVLB  9
03DE0:  MOVF   xE4,F
03DE2:  BZ    3DEE
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03DE4:  MOVLW  02
03DE6:  MOVLB  4
03DE8:  MOVWF  xE7
....................          } 
03DEA:  BRA    3FE8
03DEC:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03DEE:  MOVLW  69
03DF0:  MOVLB  A
03DF2:  MOVWF  x2B
03DF4:  CLRF   x2F
03DF6:  CLRF   x2E
03DF8:  CLRF   x2D
03DFA:  CLRF   x2C
03DFC:  MOVLB  0
03DFE:  CALL   3568
03E02:  MOVFF  01,9E4
....................          if (response <= 1 ) 
03E06:  MOVLB  9
03E08:  MOVF   xE4,W
03E0A:  SUBLW  01
03E0C:  BNC   3E18
....................             Card = SDv1; 
03E0E:  MOVLW  03
03E10:  MOVLB  4
03E12:  MOVWF  xE7
03E14:  BRA    3FE8
03E16:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03E18:  MOVF   1F,W
03E1A:  SUBLW  04
03E1C:  BNZ   3E7C
03E1E:  MOVF   20,F
03E20:  BNZ   3E7C
03E22:  MOVLW  66
03E24:  MOVWF  FF6
03E26:  MOVLW  09
03E28:  MOVWF  FF7
03E2A:  MOVLW  00
03E2C:  MOVWF  FF8
03E2E:  CLRF   1B
03E30:  BTFSC  FF2.7
03E32:  BSF    1B.7
03E34:  BCF    FF2.7
03E36:  MOVLW  2E
03E38:  MOVLB  A
03E3A:  MOVWF  x40
03E3C:  MOVLB  0
03E3E:  CALL   1044
03E42:  BTFSC  1B.7
03E44:  BSF    FF2.7
03E46:  MOVFF  9E4,9EC
03E4A:  MOVLW  37
03E4C:  MOVLB  9
03E4E:  MOVWF  xED
03E50:  MOVLB  0
03E52:  CALL   3638
03E56:  MOVLW  98
03E58:  MOVWF  FF6
03E5A:  MOVLW  09
03E5C:  MOVWF  FF7
03E5E:  MOVLW  00
03E60:  MOVWF  FF8
03E62:  CLRF   1B
03E64:  BTFSC  FF2.7
03E66:  BSF    1B.7
03E68:  BCF    FF2.7
03E6A:  MOVLW  19
03E6C:  MOVLB  A
03E6E:  MOVWF  x40
03E70:  MOVLB  0
03E72:  CALL   1044
03E76:  BTFSC  1B.7
03E78:  BSF    FF2.7
03E7A:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03E7C:  MOVLW  40
03E7E:  MOVLB  A
03E80:  MOVWF  x2B
03E82:  CLRF   x2F
03E84:  CLRF   x2E
03E86:  CLRF   x2D
03E88:  CLRF   x2C
03E8A:  MOVLB  0
03E8C:  CALL   3568
03E90:  MOVFF  01,9E4
....................             if ((response !=0x01) && (response != 0)) 
03E94:  MOVLB  9
03E96:  DECFSZ xE4,W
03E98:  BRA    3E9C
03E9A:  BRA    3F08
03E9C:  MOVF   xE4,F
03E9E:  BZ    3F08
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03EA0:  MOVF   1F,W
03EA2:  SUBLW  04
03EA4:  BNZ   3F04
03EA6:  MOVF   20,F
03EA8:  BNZ   3F04
03EAA:  MOVLW  B2
03EAC:  MOVWF  FF6
03EAE:  MOVLW  09
03EB0:  MOVWF  FF7
03EB2:  MOVLW  00
03EB4:  MOVWF  FF8
03EB6:  CLRF   1B
03EB8:  BTFSC  FF2.7
03EBA:  BSF    1B.7
03EBC:  BCF    FF2.7
03EBE:  MOVLW  2C
03EC0:  MOVLB  A
03EC2:  MOVWF  x40
03EC4:  MOVLB  0
03EC6:  CALL   1044
03ECA:  BTFSC  1B.7
03ECC:  BSF    FF2.7
03ECE:  MOVFF  9E4,9EC
03ED2:  MOVLW  37
03ED4:  MOVLB  9
03ED6:  MOVWF  xED
03ED8:  MOVLB  0
03EDA:  CALL   3638
03EDE:  MOVLW  E2
03EE0:  MOVWF  FF6
03EE2:  MOVLW  09
03EE4:  MOVWF  FF7
03EE6:  MOVLW  00
03EE8:  MOVWF  FF8
03EEA:  CLRF   1B
03EEC:  BTFSC  FF2.7
03EEE:  BSF    1B.7
03EF0:  BCF    FF2.7
03EF2:  MOVLW  0B
03EF4:  MOVLB  A
03EF6:  MOVWF  x40
03EF8:  MOVLB  0
03EFA:  CALL   1044
03EFE:  BTFSC  1B.7
03F00:  BSF    FF2.7
03F02:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03F04:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03F06:  BRA    43F2
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03F08:  CLRF   xEA
03F0A:  CLRF   xE9
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03F0C:  MOVLW  41
03F0E:  MOVLB  A
03F10:  MOVWF  x2B
03F12:  CLRF   x2F
03F14:  CLRF   x2E
03F16:  CLRF   x2D
03F18:  CLRF   x2C
03F1A:  MOVLB  0
03F1C:  CALL   3568
03F20:  MOVFF  01,9E4
....................                if (response != 0x00 ) 
03F24:  MOVLB  9
03F26:  MOVF   xE4,F
03F28:  BZ    3F32
....................                   delay_us(10); 
03F2A:  MOVLW  35
03F2C:  MOVWF  00
03F2E:  DECFSZ 00,F
03F30:  BRA    3F2E
....................                Timer++; 
03F32:  INCF   xE9,F
03F34:  BTFSC  FD8.2
03F36:  INCF   xEA,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03F38:  MOVF   xE4,F
03F3A:  BZ    3F4A
03F3C:  MOVF   xEA,W
03F3E:  SUBLW  C3
03F40:  BNC   3F4A
03F42:  BNZ   3F0C
03F44:  MOVF   xE9,W
03F46:  SUBLW  4F
03F48:  BC    3F0C
....................     
....................             if(response) 
03F4A:  MOVF   xE4,F
03F4C:  BZ    3FE2
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03F4E:  MOVF   1F,W
03F50:  SUBLW  04
03F52:  BNZ   3FDE
03F54:  MOVF   20,F
03F56:  BNZ   3FDE
03F58:  MOVLW  EE
03F5A:  MOVWF  FF6
03F5C:  MOVLW  09
03F5E:  MOVWF  FF7
03F60:  MOVLW  00
03F62:  MOVWF  FF8
03F64:  CLRF   1B
03F66:  BTFSC  FF2.7
03F68:  BSF    1B.7
03F6A:  BCF    FF2.7
03F6C:  MOVLW  4A
03F6E:  MOVLB  A
03F70:  MOVWF  x40
03F72:  MOVLB  0
03F74:  CALL   1044
03F78:  BTFSC  1B.7
03F7A:  BSF    FF2.7
03F7C:  MOVFF  9E4,9EC
03F80:  MOVLW  37
03F82:  MOVLB  9
03F84:  MOVWF  xED
03F86:  MOVLB  0
03F88:  CALL   3638
03F8C:  MOVLW  3C
03F8E:  MOVWF  FF6
03F90:  MOVLW  0A
03F92:  MOVWF  FF7
03F94:  MOVLW  00
03F96:  MOVWF  FF8
03F98:  CLRF   1B
03F9A:  BTFSC  FF2.7
03F9C:  BSF    1B.7
03F9E:  BCF    FF2.7
03FA0:  MOVLW  0A
03FA2:  MOVLB  A
03FA4:  MOVWF  x40
03FA6:  MOVLB  0
03FA8:  CALL   1044
03FAC:  BTFSC  1B.7
03FAE:  BSF    FF2.7
03FB0:  MOVLW  10
03FB2:  MOVWF  FE9
03FB4:  CLRF   1B
03FB6:  BTFSC  FF2.7
03FB8:  BSF    1B.7
03FBA:  BCF    FF2.7
03FBC:  MOVFF  9EA,A41
03FC0:  MOVFF  9E9,A40
03FC4:  CALL   11C6
03FC8:  BTFSC  1B.7
03FCA:  BSF    FF2.7
03FCC:  MOVLW  0D
03FCE:  BTFSS  F9E.4
03FD0:  BRA    3FCE
03FD2:  MOVWF  FAD
03FD4:  MOVLW  0A
03FD6:  BTFSS  F9E.4
03FD8:  BRA    3FD6
03FDA:  MOVWF  FAD
03FDC:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03FDE:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03FE0:  BRA    43F2
....................                } 
....................  
....................             Card = MMC; 
03FE2:  MOVLW  02
03FE4:  MOVLB  4
03FE6:  MOVWF  xE7
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03FE8:  MOVF   1F,W
03FEA:  SUBLW  04
03FEC:  BNZ   4012
03FEE:  MOVF   20,F
03FF0:  BNZ   4012
03FF2:  MOVLW  4C
03FF4:  MOVWF  FF6
03FF6:  MOVLW  0A
03FF8:  MOVWF  FF7
03FFA:  MOVLW  00
03FFC:  MOVWF  FF8
03FFE:  CLRF   1B
04000:  BTFSC  FF2.7
04002:  BSF    1B.7
04004:  BCF    FF2.7
04006:  MOVLB  0
04008:  CALL   0E6E
0400C:  BTFSC  1B.7
0400E:  BSF    FF2.7
04010:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
04012:  MOVLW  50
04014:  MOVLB  A
04016:  MOVWF  x2B
04018:  CLRF   x2F
0401A:  CLRF   x2E
0401C:  MOVLW  02
0401E:  MOVWF  x2D
04020:  CLRF   x2C
04022:  MOVLB  0
04024:  CALL   3568
04028:  MOVFF  01,9E4
....................       if ((Timer == 50000) || (response > 1))    
0402C:  MOVLB  9
0402E:  MOVF   xE9,W
04030:  SUBLW  50
04032:  BNZ   403A
04034:  MOVF   xEA,W
04036:  SUBLW  C3
04038:  BZ    4040
0403A:  MOVF   xE4,W
0403C:  SUBLW  01
0403E:  BC    40D6
....................       { 
....................          Card = None; 
04040:  MOVLB  4
04042:  CLRF   xE7
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
04044:  MOVF   1F,W
04046:  SUBLW  04
04048:  BNZ   40D4
0404A:  MOVF   20,F
0404C:  BNZ   40D4
0404E:  MOVLW  68
04050:  MOVWF  FF6
04052:  MOVLW  0A
04054:  MOVWF  FF7
04056:  MOVLW  00
04058:  MOVWF  FF8
0405A:  CLRF   1B
0405C:  BTFSC  FF2.7
0405E:  BSF    1B.7
04060:  BCF    FF2.7
04062:  MOVLW  2B
04064:  MOVLB  A
04066:  MOVWF  x40
04068:  MOVLB  0
0406A:  CALL   1044
0406E:  BTFSC  1B.7
04070:  BSF    FF2.7
04072:  MOVFF  9E4,9EC
04076:  MOVLW  57
04078:  MOVLB  9
0407A:  MOVWF  xED
0407C:  MOVLB  0
0407E:  CALL   3638
04082:  MOVLW  97
04084:  MOVWF  FF6
04086:  MOVLW  0A
04088:  MOVWF  FF7
0408A:  MOVLW  00
0408C:  MOVWF  FF8
0408E:  CLRF   1B
04090:  BTFSC  FF2.7
04092:  BSF    1B.7
04094:  BCF    FF2.7
04096:  MOVLW  0A
04098:  MOVLB  A
0409A:  MOVWF  x40
0409C:  MOVLB  0
0409E:  CALL   1044
040A2:  BTFSC  1B.7
040A4:  BSF    FF2.7
040A6:  MOVLW  10
040A8:  MOVWF  FE9
040AA:  CLRF   1B
040AC:  BTFSC  FF2.7
040AE:  BSF    1B.7
040B0:  BCF    FF2.7
040B2:  MOVFF  9EA,A41
040B6:  MOVFF  9E9,A40
040BA:  CALL   11C6
040BE:  BTFSC  1B.7
040C0:  BSF    FF2.7
040C2:  MOVLW  0D
040C4:  BTFSS  F9E.4
040C6:  BRA    40C4
040C8:  MOVWF  FAD
040CA:  MOVLW  0A
040CC:  BTFSS  F9E.4
040CE:  BRA    40CC
040D0:  MOVWF  FAD
040D2:  MOVLB  4
040D4:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
040D6:  MOVLB  4
040D8:  MOVF   xE7,F
040DA:  BNZ   410E
....................    { 
....................       if (nv_report_mode == 4) 
040DC:  MOVF   1F,W
040DE:  SUBLW  04
040E0:  BNZ   4106
040E2:  MOVF   20,F
040E4:  BNZ   4106
....................          printf("@FS:Card Type Discovery Error\r\n"); 
040E6:  MOVLW  A8
040E8:  MOVWF  FF6
040EA:  MOVLW  0A
040EC:  MOVWF  FF7
040EE:  MOVLW  00
040F0:  MOVWF  FF8
040F2:  CLRF   1B
040F4:  BTFSC  FF2.7
040F6:  BSF    1B.7
040F8:  BCF    FF2.7
040FA:  MOVLB  0
040FC:  CALL   0E6E
04100:  BTFSC  1B.7
04102:  BSF    FF2.7
04104:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
04106:  MOVLB  9
04108:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
0410A:  BRA    43F2
0410C:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
0410E:  MOVF   xE7,W
04110:  XORLW  02
04112:  MOVLB  0
04114:  BZ    4124
04116:  XORLW  01
04118:  BZ    414C
0411A:  XORLW  07
0411C:  BZ    4174
0411E:  XORLW  01
04120:  BZ    419C
04122:  BRA    41C4
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
04124:  MOVF   1F,W
04126:  SUBLW  04
04128:  BNZ   414A
0412A:  MOVF   20,F
0412C:  BNZ   414A
0412E:  MOVLW  C8
04130:  MOVWF  FF6
04132:  MOVLW  0A
04134:  MOVWF  FF7
04136:  MOVLW  00
04138:  MOVWF  FF8
0413A:  CLRF   1B
0413C:  BTFSC  FF2.7
0413E:  BSF    1B.7
04140:  BCF    FF2.7
04142:  CALL   0E6E
04146:  BTFSC  1B.7
04148:  BSF    FF2.7
....................          break; 
0414A:  BRA    421A
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
0414C:  MOVF   1F,W
0414E:  SUBLW  04
04150:  BNZ   4172
04152:  MOVF   20,F
04154:  BNZ   4172
04156:  MOVLW  DE
04158:  MOVWF  FF6
0415A:  MOVLW  0A
0415C:  MOVWF  FF7
0415E:  MOVLW  00
04160:  MOVWF  FF8
04162:  CLRF   1B
04164:  BTFSC  FF2.7
04166:  BSF    1B.7
04168:  BCF    FF2.7
0416A:  CALL   0E6E
0416E:  BTFSC  1B.7
04170:  BSF    FF2.7
....................          break; 
04172:  BRA    421A
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
04174:  MOVF   1F,W
04176:  SUBLW  04
04178:  BNZ   419A
0417A:  MOVF   20,F
0417C:  BNZ   419A
0417E:  MOVLW  F4
04180:  MOVWF  FF6
04182:  MOVLW  0A
04184:  MOVWF  FF7
04186:  MOVLW  00
04188:  MOVWF  FF8
0418A:  CLRF   1B
0418C:  BTFSC  FF2.7
0418E:  BSF    1B.7
04190:  BCF    FF2.7
04192:  CALL   0E6E
04196:  BTFSC  1B.7
04198:  BSF    FF2.7
....................          break; 
0419A:  BRA    421A
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
0419C:  MOVF   1F,W
0419E:  SUBLW  04
041A0:  BNZ   41C2
041A2:  MOVF   20,F
041A4:  BNZ   41C2
041A6:  MOVLW  0A
041A8:  MOVWF  FF6
041AA:  MOVLW  0B
041AC:  MOVWF  FF7
041AE:  MOVLW  00
041B0:  MOVWF  FF8
041B2:  CLRF   1B
041B4:  BTFSC  FF2.7
041B6:  BSF    1B.7
041B8:  BCF    FF2.7
041BA:  CALL   0E6E
041BE:  BTFSC  1B.7
041C0:  BSF    FF2.7
....................          break; 
041C2:  BRA    421A
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
041C4:  MOVF   1F,W
041C6:  SUBLW  04
041C8:  BNZ   4212
041CA:  MOVF   20,F
041CC:  BNZ   4212
041CE:  MOVLW  20
041D0:  MOVWF  FF6
041D2:  MOVLW  0B
041D4:  MOVWF  FF7
041D6:  MOVLW  00
041D8:  MOVWF  FF8
041DA:  CLRF   1B
041DC:  BTFSC  FF2.7
041DE:  BSF    1B.7
041E0:  BCF    FF2.7
041E2:  MOVLW  26
041E4:  MOVLB  A
041E6:  MOVWF  x40
041E8:  MOVLB  0
041EA:  CALL   1044
041EE:  BTFSC  1B.7
041F0:  BSF    FF2.7
041F2:  MOVFF  4E7,9EC
041F6:  MOVLW  37
041F8:  MOVLB  9
041FA:  MOVWF  xED
041FC:  MOVLB  0
041FE:  CALL   3638
04202:  MOVLW  0D
04204:  BTFSS  F9E.4
04206:  BRA    4204
04208:  MOVWF  FAD
0420A:  MOVLW  0A
0420C:  BTFSS  F9E.4
0420E:  BRA    420C
04210:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
04212:  MOVLB  9
04214:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
04216:  BRA    43F2
04218:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
0421A:  MOVLB  9
0421C:  BCF    xEB.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
0421E:  MOVF   1F,W
04220:  SUBLW  04
04222:  BNZ   427A
04224:  MOVF   20,F
04226:  BNZ   427A
04228:  MOVLW  4E
0422A:  MOVWF  FF6
0422C:  MOVLW  0B
0422E:  MOVWF  FF7
04230:  MOVLW  00
04232:  MOVWF  FF8
04234:  CLRF   1B
04236:  BTFSC  FF2.7
04238:  BSF    1B.7
0423A:  BCF    FF2.7
0423C:  MOVLW  2E
0423E:  MOVLB  A
04240:  MOVWF  x40
04242:  MOVLB  0
04244:  CALL   1044
04248:  BTFSC  1B.7
0424A:  BSF    FF2.7
0424C:  MOVLW  10
0424E:  MOVWF  FE9
04250:  CLRF   1B
04252:  BTFSC  FF2.7
04254:  BSF    1B.7
04256:  BCF    FF2.7
04258:  MOVFF  9EA,A41
0425C:  MOVFF  9E9,A40
04260:  CALL   11C6
04264:  BTFSC  1B.7
04266:  BSF    FF2.7
04268:  MOVLW  0D
0426A:  BTFSS  F9E.4
0426C:  BRA    426A
0426E:  MOVWF  FAD
04270:  MOVLW  0A
04272:  BTFSS  F9E.4
04274:  BRA    4272
04276:  MOVWF  FAD
04278:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
0427A:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
0427C:  BCF    FC6.5
0427E:  MOVLW  20
04280:  MOVWF  FC6
04282:  MOVLW  40
04284:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
04286:  BCF    F9E.3
....................    SelectSD; 
04288:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
0428A:  MOVF   1F,W
0428C:  SUBLW  04
0428E:  BNZ   42B4
04290:  MOVF   20,F
04292:  BNZ   42B4
04294:  MOVLW  82
04296:  MOVWF  FF6
04298:  MOVLW  0B
0429A:  MOVWF  FF7
0429C:  MOVLW  00
0429E:  MOVWF  FF8
042A0:  CLRF   1B
042A2:  BTFSC  FF2.7
042A4:  BSF    1B.7
042A6:  BCF    FF2.7
042A8:  MOVLB  0
042AA:  CALL   0E6E
042AE:  BTFSC  1B.7
042B0:  BSF    FF2.7
042B2:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
042B4:  CLRF   xEA
042B6:  CLRF   xE9
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
042B8:  MOVLW  41
042BA:  MOVLB  A
042BC:  MOVWF  x2B
042BE:  CLRF   x2F
042C0:  CLRF   x2E
042C2:  CLRF   x2D
042C4:  CLRF   x2C
042C6:  MOVLB  0
042C8:  CALL   3568
042CC:  MOVFF  01,9E4
....................       if (response != 0x00 ) 
042D0:  MOVLB  9
042D2:  MOVF   xE4,F
042D4:  BZ    42DE
....................          delay_us(10); 
042D6:  MOVLW  35
042D8:  MOVWF  00
042DA:  DECFSZ 00,F
042DC:  BRA    42DA
....................  
....................       Timer++; 
042DE:  INCF   xE9,F
042E0:  BTFSC  FD8.2
042E2:  INCF   xEA,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
042E4:  MOVF   xE4,F
042E6:  BZ    42F6
042E8:  MOVF   xEA,W
042EA:  SUBLW  C3
042EC:  BNC   42F6
042EE:  BNZ   42B8
042F0:  MOVF   xE9,W
042F2:  SUBLW  4F
042F4:  BC    42B8
....................  
....................    if (response != 0x00) 
042F6:  MOVF   xE4,F
042F8:  BZ    438E
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
042FA:  MOVF   1F,W
042FC:  SUBLW  04
042FE:  BNZ   438A
04300:  MOVF   20,F
04302:  BNZ   438A
04304:  MOVLW  A2
04306:  MOVWF  FF6
04308:  MOVLW  0B
0430A:  MOVWF  FF7
0430C:  MOVLW  00
0430E:  MOVWF  FF8
04310:  CLRF   1B
04312:  BTFSC  FF2.7
04314:  BSF    1B.7
04316:  BCF    FF2.7
04318:  MOVLW  26
0431A:  MOVLB  A
0431C:  MOVWF  x40
0431E:  MOVLB  0
04320:  CALL   1044
04324:  BTFSC  1B.7
04326:  BSF    FF2.7
04328:  MOVFF  9E4,9EC
0432C:  MOVLW  37
0432E:  MOVLB  9
04330:  MOVWF  xED
04332:  MOVLB  0
04334:  CALL   3638
04338:  MOVLW  CC
0433A:  MOVWF  FF6
0433C:  MOVLW  0B
0433E:  MOVWF  FF7
04340:  MOVLW  00
04342:  MOVWF  FF8
04344:  CLRF   1B
04346:  BTFSC  FF2.7
04348:  BSF    1B.7
0434A:  BCF    FF2.7
0434C:  MOVLW  0A
0434E:  MOVLB  A
04350:  MOVWF  x40
04352:  MOVLB  0
04354:  CALL   1044
04358:  BTFSC  1B.7
0435A:  BSF    FF2.7
0435C:  MOVLW  10
0435E:  MOVWF  FE9
04360:  CLRF   1B
04362:  BTFSC  FF2.7
04364:  BSF    1B.7
04366:  BCF    FF2.7
04368:  MOVFF  9EA,A41
0436C:  MOVFF  9E9,A40
04370:  CALL   11C6
04374:  BTFSC  1B.7
04376:  BSF    FF2.7
04378:  MOVLW  0D
0437A:  BTFSS  F9E.4
0437C:  BRA    437A
0437E:  MOVWF  FAD
04380:  MOVLW  0A
04382:  BTFSS  F9E.4
04384:  BRA    4382
04386:  MOVWF  FAD
04388:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
0438A:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
0438C:  BRA    43F2
....................    } 
....................  
....................    if (nv_report_mode == 4) 
0438E:  MOVF   1F,W
04390:  SUBLW  04
04392:  BNZ   43EA
04394:  MOVF   20,F
04396:  BNZ   43EA
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
04398:  MOVLW  DC
0439A:  MOVWF  FF6
0439C:  MOVLW  0B
0439E:  MOVWF  FF7
043A0:  MOVLW  00
043A2:  MOVWF  FF8
043A4:  CLRF   1B
043A6:  BTFSC  FF2.7
043A8:  BSF    1B.7
043AA:  BCF    FF2.7
043AC:  MOVLW  25
043AE:  MOVLB  A
043B0:  MOVWF  x40
043B2:  MOVLB  0
043B4:  CALL   1044
043B8:  BTFSC  1B.7
043BA:  BSF    FF2.7
043BC:  MOVLW  10
043BE:  MOVWF  FE9
043C0:  CLRF   1B
043C2:  BTFSC  FF2.7
043C4:  BSF    1B.7
043C6:  BCF    FF2.7
043C8:  MOVFF  9EA,A41
043CC:  MOVFF  9E9,A40
043D0:  CALL   11C6
043D4:  BTFSC  1B.7
043D6:  BSF    FF2.7
043D8:  MOVLW  0D
043DA:  BTFSS  F9E.4
043DC:  BRA    43DA
043DE:  MOVWF  FAD
043E0:  MOVLW  0A
043E2:  BTFSS  F9E.4
043E4:  BRA    43E2
043E6:  MOVWF  FAD
043E8:  MOVLB  9
....................  
....................    msg_card_ok(); 
043EA:  MOVLB  0
043EC:  GOTO   367E
043F0:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
043F2:  BSF    F91.1
....................    return(SDCardStatus); 
043F4:  MOVFF  9EB,01
043F8:  MOVLB  0
043FA:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05AAA:  MOVLW  20
05AAC:  MOVLB  7
05AAE:  ADDWF  x12,W
05AB0:  MOVWF  FE9
05AB2:  MOVLW  00
05AB4:  ADDWFC x13,W
05AB6:  MOVWF  FEA
05AB8:  MOVFF  FEF,A18
05ABC:  MOVFF  FEC,A19
05AC0:  MOVFF  FEC,A1A
05AC4:  MOVFF  FEC,A1B
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05AC8:  MOVLB  A
05ACA:  MOVF   x14,W
05ACC:  SUBWF  x18,W
05ACE:  BNZ   5AE4
05AD0:  MOVF   x15,W
05AD2:  SUBWF  x19,W
05AD4:  BNZ   5AE4
05AD6:  MOVF   x16,W
05AD8:  SUBWF  x1A,W
05ADA:  BNZ   5AE4
05ADC:  MOVF   x17,W
05ADE:  SUBWF  x1B,W
05AE0:  BTFSC  FD8.2
05AE2:  BRA    5CB8
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05AE4:  MOVLW  06
05AE6:  MOVLB  7
05AE8:  ADDWF  x12,W
05AEA:  MOVWF  FE9
05AEC:  MOVLW  00
05AEE:  ADDWFC x13,W
05AF0:  MOVWF  FEA
05AF2:  MOVF   FEF,F
05AF4:  BTFSC  FD8.2
05AF6:  BRA    5C42
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05AF8:  MOVLW  24
05AFA:  ADDWF  x12,W
05AFC:  MOVWF  01
05AFE:  MOVLW  00
05B00:  ADDWFC x13,W
05B02:  MOVWF  03
05B04:  MOVFF  01,A1E
05B08:  MOVLB  A
05B0A:  MOVWF  x1F
05B0C:  MOVWF  x21
05B0E:  MOVFF  01,A20
05B12:  MOVFF  A1B,A25
05B16:  MOVFF  A1A,A24
05B1A:  MOVFF  A19,A23
05B1E:  MOVFF  A18,A22
05B22:  MOVLW  01
05B24:  MOVWF  x26
05B26:  MOVLB  0
05B28:  RCALL  5966
05B2A:  MOVFF  01,A1C
....................             if (response != RES_OK) 
05B2E:  MOVLB  A
05B30:  MOVF   x1C,F
05B32:  BZ    5B3A
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05B34:  MOVLW  00
05B36:  MOVWF  01
05B38:  BRA    5CBC
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05B3A:  MOVLW  06
05B3C:  MOVLB  7
05B3E:  ADDWF  x12,W
05B40:  MOVWF  FE9
05B42:  MOVLW  00
05B44:  ADDWFC x13,W
05B46:  MOVWF  FEA
05B48:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05B4A:  MOVLW  10
05B4C:  ADDWF  x12,W
05B4E:  MOVWF  FE9
05B50:  MOVLW  00
05B52:  ADDWFC x13,W
05B54:  MOVWF  FEA
05B56:  MOVFF  FEF,A1E
05B5A:  MOVFF  FEC,A1F
05B5E:  MOVFF  FEC,A20
05B62:  MOVFF  FEC,A21
05B66:  MOVLW  08
05B68:  ADDWF  x12,W
05B6A:  MOVWF  FE9
05B6C:  MOVLW  00
05B6E:  ADDWFC x13,W
05B70:  MOVWF  FEA
05B72:  MOVFF  FEF,00
05B76:  MOVFF  FEC,01
05B7A:  MOVFF  FEC,02
05B7E:  MOVFF  FEC,03
05B82:  MOVLB  A
05B84:  MOVF   x1E,W
05B86:  ADDWF  00,F
05B88:  MOVF   x1F,W
05B8A:  ADDWFC 01,F
05B8C:  MOVF   x20,W
05B8E:  ADDWFC 02,F
05B90:  MOVF   x21,W
05B92:  ADDWFC 03,F
05B94:  MOVF   x1B,W
05B96:  SUBWF  03,W
05B98:  BNC   5C40
05B9A:  BNZ   5BB2
05B9C:  MOVF   x1A,W
05B9E:  SUBWF  02,W
05BA0:  BNC   5C40
05BA2:  BNZ   5BB2
05BA4:  MOVF   x19,W
05BA6:  SUBWF  01,W
05BA8:  BNC   5C40
05BAA:  BNZ   5BB2
05BAC:  MOVF   00,W
05BAE:  SUBWF  x18,W
05BB0:  BC    5C40
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05BB2:  MOVLW  03
05BB4:  MOVLB  7
05BB6:  ADDWF  x12,W
05BB8:  MOVWF  FE9
05BBA:  MOVLW  00
05BBC:  ADDWFC x13,W
05BBE:  MOVWF  FEA
05BC0:  MOVFF  FEF,A1D
05BC4:  MOVLB  A
05BC6:  MOVF   x1D,W
05BC8:  SUBLW  01
05BCA:  BC    5C40
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05BCC:  MOVLW  08
05BCE:  MOVLB  7
05BD0:  ADDWF  x12,W
05BD2:  MOVWF  FE9
05BD4:  MOVLW  00
05BD6:  ADDWFC x13,W
05BD8:  MOVWF  FEA
05BDA:  MOVFF  FEF,00
05BDE:  MOVFF  FEC,01
05BE2:  MOVFF  FEC,02
05BE6:  MOVFF  FEC,03
05BEA:  MOVF   00,W
05BEC:  MOVLB  A
05BEE:  ADDWF  x18,F
05BF0:  MOVF   01,W
05BF2:  ADDWFC x19,F
05BF4:  MOVF   02,W
05BF6:  ADDWFC x1A,F
05BF8:  MOVF   03,W
05BFA:  ADDWFC x1B,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05BFC:  MOVLW  24
05BFE:  MOVLB  7
05C00:  ADDWF  x12,W
05C02:  MOVWF  01
05C04:  MOVLW  00
05C06:  ADDWFC x13,W
05C08:  MOVWF  03
05C0A:  MOVFF  01,A1E
05C0E:  MOVLB  A
05C10:  MOVWF  x1F
05C12:  MOVWF  x21
05C14:  MOVFF  01,A20
05C18:  MOVFF  A1B,A25
05C1C:  MOVFF  A1A,A24
05C20:  MOVFF  A19,A23
05C24:  MOVFF  A18,A22
05C28:  MOVLW  01
05C2A:  MOVWF  x26
05C2C:  MOVLB  0
05C2E:  RCALL  5966
05C30:  MOVF   01,F
05C32:  BZ    5C3A
....................                      break; 
05C34:  MOVLB  A
05C36:  BRA    5C40
05C38:  MOVLB  0
05C3A:  MOVLB  A
05C3C:  DECF   x1D,F
05C3E:  BRA    5BC6
05C40:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05C42:  MOVLB  A
05C44:  MOVF   x14,F
05C46:  BNZ   5C54
05C48:  MOVF   x15,F
05C4A:  BNZ   5C54
05C4C:  MOVF   x16,F
05C4E:  BNZ   5C54
05C50:  MOVF   x17,F
05C52:  BZ    5CB8
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05C54:  MOVLW  24
05C56:  MOVLB  7
05C58:  ADDWF  x12,W
05C5A:  MOVWF  01
05C5C:  MOVLW  00
05C5E:  ADDWFC x13,W
05C60:  MOVWF  03
05C62:  MOVFF  01,A1E
05C66:  MOVLB  A
05C68:  MOVWF  x1F
05C6A:  MOVWF  x21
05C6C:  MOVFF  01,A20
05C70:  MOVFF  A17,A25
05C74:  MOVFF  A16,A24
05C78:  MOVFF  A15,A23
05C7C:  MOVFF  A14,A22
05C80:  MOVLW  01
05C82:  MOVWF  x26
05C84:  MOVLB  0
05C86:  CALL   44F4
05C8A:  MOVF   01,F
05C8C:  BZ    5C98
....................             return FALSE; 
05C8E:  MOVLW  00
05C90:  MOVWF  01
05C92:  MOVLB  A
05C94:  BRA    5CBC
05C96:  MOVLB  0
....................          fs->winsect = sector; 
05C98:  MOVLW  20
05C9A:  MOVLB  7
05C9C:  ADDWF  x12,W
05C9E:  MOVWF  FE9
05CA0:  MOVLW  00
05CA2:  ADDWFC x13,W
05CA4:  MOVWF  FEA
05CA6:  MOVFF  A14,FEF
05CAA:  MOVFF  A15,FEC
05CAE:  MOVFF  A16,FEC
05CB2:  MOVFF  A17,FEC
05CB6:  MOVLB  A
....................          } 
....................       } 
....................    return (TRUE); 
05CB8:  MOVLW  01
05CBA:  MOVWF  01
05CBC:  MOVLB  0
05CBE:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05CE2:  MOVLB  9
05CE4:  MOVF   xFF,F
05CE6:  BNZ   5CF8
05CE8:  MOVF   xFE,F
05CEA:  BNZ   5CF8
05CEC:  MOVF   xFD,F
05CEE:  BNZ   5CF8
05CF0:  MOVF   xFC,W
05CF2:  SUBLW  01
05CF4:  BTFSC  FD8.0
05CF6:  BRA    6020
05CF8:  MOVLW  0C
05CFA:  MOVLB  7
05CFC:  ADDWF  x12,W
05CFE:  MOVWF  FE9
05D00:  MOVLW  00
05D02:  ADDWFC x13,W
05D04:  MOVWF  FEA
05D06:  MOVFF  FEF,00
05D0A:  MOVFF  FEC,01
05D0E:  MOVFF  FEC,02
05D12:  MOVFF  FEC,03
05D16:  MOVLB  9
05D18:  MOVF   xFF,W
05D1A:  SUBWF  03,W
05D1C:  BTFSS  FD8.0
05D1E:  BRA    6020
05D20:  BNZ   5D3E
05D22:  MOVF   xFE,W
05D24:  SUBWF  02,W
05D26:  BTFSS  FD8.0
05D28:  BRA    6020
05D2A:  BNZ   5D3E
05D2C:  MOVF   xFD,W
05D2E:  SUBWF  01,W
05D30:  BTFSS  FD8.0
05D32:  BRA    6020
05D34:  BNZ   5D3E
05D36:  MOVF   00,W
05D38:  SUBWF  xFC,W
05D3A:  BTFSC  FD8.0
05D3C:  BRA    6020
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05D3E:  MOVLW  10
05D40:  MOVLB  7
05D42:  ADDWF  x12,W
05D44:  MOVWF  FE9
05D46:  MOVLW  00
05D48:  ADDWFC x13,W
05D4A:  MOVWF  FEA
05D4C:  MOVFF  FEF,A04
05D50:  MOVFF  FEC,A05
05D54:  MOVFF  FEC,A06
05D58:  MOVFF  FEC,A07
....................       switch (fs->fs_type)  
05D5C:  MOVF   x12,W
05D5E:  MOVWF  FE9
05D60:  MOVF   x13,W
05D62:  MOVWF  FEA
05D64:  MOVF   FEF,W
05D66:  XORLW  01
05D68:  MOVLB  0
05D6A:  BZ    5D7A
05D6C:  XORLW  03
05D6E:  BTFSC  FD8.2
05D70:  BRA    5EC6
05D72:  XORLW  01
05D74:  BTFSC  FD8.2
05D76:  BRA    5F4E
05D78:  BRA    601E
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05D7A:  MOVFF  9FD,A11
05D7E:  MOVFF  9FC,A10
05D82:  MOVLB  A
05D84:  CLRF   x13
05D86:  MOVLW  03
05D88:  MOVWF  x12
05D8A:  MOVLB  0
05D8C:  RCALL  5CC0
05D8E:  BCF    FD8.0
05D90:  MOVLB  A
05D92:  RRCF   02,W
05D94:  MOVWF  x03
05D96:  RRCF   01,W
05D98:  MOVWF  x02
....................             if (!move_window(fatsect + bc / 512))  
05D9A:  BCF    FD8.0
05D9C:  CLRF   03
05D9E:  RRCF   x03,W
05DA0:  MOVWF  02
05DA2:  ADDWF  x04,W
05DA4:  MOVWF  x08
05DA6:  MOVF   03,W
05DA8:  ADDWFC x05,W
05DAA:  MOVWF  x09
05DAC:  MOVLW  00
05DAE:  ADDWFC x06,W
05DB0:  MOVWF  x0A
05DB2:  MOVLW  00
05DB4:  ADDWFC x07,W
05DB6:  MOVWF  x0B
05DB8:  MOVWF  x17
05DBA:  MOVFF  A0A,A16
05DBE:  MOVFF  A09,A15
05DC2:  MOVFF  A08,A14
05DC6:  MOVLB  0
05DC8:  RCALL  5AAA
05DCA:  MOVF   01,F
05DCC:  BNZ   5DD0
....................                break; 
05DCE:  BRA    601E
....................             wc = fs->win[bc % 512]; 
05DD0:  MOVLB  A
05DD2:  MOVF   x03,W
05DD4:  ANDLW  01
05DD6:  MOVWF  x09
05DD8:  MOVLW  24
05DDA:  ADDWF  x02,W
05DDC:  MOVWF  01
05DDE:  MOVLW  00
05DE0:  ADDWFC x09,W
05DE2:  MOVWF  03
05DE4:  MOVF   01,W
05DE6:  MOVLB  7
05DE8:  ADDWF  x12,W
05DEA:  MOVWF  FE9
05DEC:  MOVF   x13,W
05DEE:  ADDWFC 03,W
05DF0:  MOVWF  FEA
05DF2:  MOVLB  A
05DF4:  CLRF   x01
05DF6:  MOVFF  FEF,A00
....................             bc++; 
05DFA:  INCF   x02,F
05DFC:  BTFSC  FD8.2
05DFE:  INCF   x03,F
....................             if (!move_window(fatsect + bc / 512))  
05E00:  BCF    FD8.0
05E02:  CLRF   03
05E04:  RRCF   x03,W
05E06:  MOVWF  02
05E08:  ADDWF  x04,W
05E0A:  MOVWF  x08
05E0C:  MOVF   03,W
05E0E:  ADDWFC x05,W
05E10:  MOVWF  x09
05E12:  MOVLW  00
05E14:  ADDWFC x06,W
05E16:  MOVWF  x0A
05E18:  MOVLW  00
05E1A:  ADDWFC x07,W
05E1C:  MOVWF  x0B
05E1E:  MOVWF  x17
05E20:  MOVFF  A0A,A16
05E24:  MOVFF  A09,A15
05E28:  MOVFF  A08,A14
05E2C:  MOVLB  0
05E2E:  RCALL  5AAA
05E30:  MOVF   01,F
05E32:  BNZ   5E36
....................                break; 
05E34:  BRA    601E
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05E36:  MOVLB  A
05E38:  MOVF   x03,W
05E3A:  ANDLW  01
05E3C:  MOVWF  x09
05E3E:  MOVLW  24
05E40:  ADDWF  x02,W
05E42:  MOVWF  01
05E44:  MOVLW  00
05E46:  ADDWFC x09,W
05E48:  MOVWF  03
05E4A:  MOVF   01,W
05E4C:  MOVLB  7
05E4E:  ADDWF  x12,W
05E50:  MOVWF  FE9
05E52:  MOVF   x13,W
05E54:  ADDWFC 03,W
05E56:  MOVWF  FEA
05E58:  MOVF   FEF,W
05E5A:  MOVLB  A
05E5C:  MOVWF  x0A
05E5E:  MOVLW  00
05E60:  IORWF  x00,F
05E62:  MOVF   x0A,W
05E64:  IORWF  x01,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05E66:  MOVLB  9
05E68:  MOVF   xFC,W
05E6A:  ANDLW  01
05E6C:  MOVWF  00
05E6E:  CLRF   01
05E70:  CLRF   02
05E72:  CLRF   03
05E74:  MOVF   00,F
05E76:  BNZ   5E84
05E78:  MOVF   01,F
05E7A:  BNZ   5E84
05E7C:  MOVF   02,F
05E7E:  BNZ   5E84
05E80:  MOVF   03,F
05E82:  BZ    5EAC
05E84:  MOVLB  A
05E86:  RRCF   x01,W
05E88:  MOVWF  03
05E8A:  RRCF   x00,W
05E8C:  MOVWF  02
05E8E:  RRCF   03,F
05E90:  RRCF   02,F
05E92:  RRCF   03,F
05E94:  RRCF   02,F
05E96:  RRCF   03,F
05E98:  RRCF   02,F
05E9A:  MOVLW  0F
05E9C:  ANDWF  03,F
05E9E:  MOVFF  02,00
05EA2:  MOVFF  03,01
05EA6:  CLRF   02
05EA8:  CLRF   03
05EAA:  BRA    5EC2
05EAC:  MOVLB  A
05EAE:  MOVFF  A00,00
05EB2:  MOVF   x01,W
05EB4:  ANDLW  0F
05EB6:  MOVWF  03
05EB8:  MOVF   x00,W
05EBA:  MOVFF  03,01
05EBE:  CLRF   02
05EC0:  CLRF   03
05EC2:  BRA    602C
05EC4:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05EC6:  MOVFF  9FD,00
05ECA:  MOVFF  9FE,01
05ECE:  MOVFF  9FF,02
05ED2:  CLRF   03
05ED4:  MOVF   00,W
05ED6:  MOVLB  A
05ED8:  ADDWF  x04,W
05EDA:  MOVWF  x08
05EDC:  MOVF   01,W
05EDE:  ADDWFC x05,W
05EE0:  MOVWF  x09
05EE2:  MOVF   02,W
05EE4:  ADDWFC x06,W
05EE6:  MOVWF  x0A
05EE8:  MOVF   03,W
05EEA:  ADDWFC x07,W
05EEC:  MOVWF  x0B
05EEE:  MOVWF  x17
05EF0:  MOVFF  A0A,A16
05EF4:  MOVFF  A09,A15
05EF8:  MOVFF  A08,A14
05EFC:  MOVLB  0
05EFE:  RCALL  5AAA
05F00:  MOVF   01,F
05F02:  BNZ   5F06
....................                break; 
05F04:  BRA    601E
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05F06:  BCF    FD8.0
05F08:  MOVLB  9
05F0A:  RLCF   xFC,W
05F0C:  MOVLB  A
05F0E:  MOVWF  x08
05F10:  MOVLB  9
05F12:  RLCF   xFD,W
05F14:  MOVLB  A
05F16:  MOVWF  x09
05F18:  MOVLW  01
05F1A:  ANDWF  x09,F
05F1C:  MOVLW  24
05F1E:  ADDWF  x08,W
05F20:  MOVWF  01
05F22:  MOVLW  00
05F24:  ADDWFC x09,W
05F26:  MOVWF  03
05F28:  MOVF   01,W
05F2A:  MOVLB  7
05F2C:  ADDWF  x12,W
05F2E:  MOVWF  01
05F30:  MOVF   x13,W
05F32:  ADDWFC 03,F
05F34:  MOVFF  01,FE9
05F38:  MOVFF  03,FEA
05F3C:  MOVFF  FEF,00
05F40:  MOVFF  FEC,01
05F44:  CLRF   02
05F46:  CLRF   03
05F48:  MOVLB  A
05F4A:  BRA    602C
05F4C:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05F4E:  MOVLB  9
05F50:  RRCF   xFF,W
05F52:  MOVWF  03
05F54:  RRCF   xFE,W
05F56:  MOVWF  02
05F58:  RRCF   xFD,W
05F5A:  MOVWF  01
05F5C:  RRCF   xFC,W
05F5E:  MOVWF  00
05F60:  RRCF   03,F
05F62:  RRCF   02,F
05F64:  RRCF   01,F
05F66:  RRCF   00,F
05F68:  RRCF   03,F
05F6A:  RRCF   02,F
05F6C:  RRCF   01,F
05F6E:  RRCF   00,F
05F70:  RRCF   03,F
05F72:  RRCF   02,F
05F74:  RRCF   01,F
05F76:  RRCF   00,F
05F78:  RRCF   03,F
05F7A:  RRCF   02,F
05F7C:  RRCF   01,F
05F7E:  RRCF   00,F
05F80:  RRCF   03,F
05F82:  RRCF   02,F
05F84:  RRCF   01,F
05F86:  RRCF   00,F
05F88:  RRCF   03,F
05F8A:  RRCF   02,F
05F8C:  RRCF   01,F
05F8E:  RRCF   00,F
05F90:  MOVLW  01
05F92:  ANDWF  03,F
05F94:  MOVF   00,W
05F96:  MOVLB  A
05F98:  ADDWF  x04,W
05F9A:  MOVWF  x08
05F9C:  MOVF   01,W
05F9E:  ADDWFC x05,W
05FA0:  MOVWF  x09
05FA2:  MOVF   02,W
05FA4:  ADDWFC x06,W
05FA6:  MOVWF  x0A
05FA8:  MOVF   03,W
05FAA:  ADDWFC x07,W
05FAC:  MOVWF  x0B
05FAE:  MOVWF  x17
05FB0:  MOVFF  A0A,A16
05FB4:  MOVFF  A09,A15
05FB8:  MOVFF  A08,A14
05FBC:  MOVLB  0
05FBE:  RCALL  5AAA
05FC0:  MOVF   01,F
05FC2:  BNZ   5FC6
....................                break; 
05FC4:  BRA    601E
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05FC6:  MOVLB  9
05FC8:  RLCF   xFC,W
05FCA:  MOVLB  A
05FCC:  MOVWF  x08
05FCE:  MOVLB  9
05FD0:  RLCF   xFD,W
05FD2:  MOVLB  A
05FD4:  MOVWF  x09
05FD6:  RLCF   x08,F
05FD8:  RLCF   x09,F
05FDA:  MOVLW  FC
05FDC:  ANDWF  x08,F
05FDE:  MOVLW  01
05FE0:  ANDWF  x09,F
05FE2:  MOVLW  24
05FE4:  ADDWF  x08,W
05FE6:  MOVWF  01
05FE8:  MOVLW  00
05FEA:  ADDWFC x09,W
05FEC:  MOVWF  03
05FEE:  MOVF   01,W
05FF0:  MOVLB  7
05FF2:  ADDWF  x12,W
05FF4:  MOVWF  01
05FF6:  MOVF   x13,W
05FF8:  ADDWFC 03,F
05FFA:  MOVFF  01,FE9
05FFE:  MOVFF  03,FEA
06002:  MOVFF  FEF,00
06006:  MOVFF  FEC,01
0600A:  MOVFF  FEC,02
0600E:  MOVFF  FEC,A0D
06012:  MOVLB  A
06014:  MOVF   x0D,W
06016:  ANDLW  0F
06018:  MOVWF  03
0601A:  BRA    602C
0601C:  MOVLB  0
0601E:  MOVLB  9
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
06020:  MOVLW  01
06022:  MOVWF  00
06024:  CLRF   01
06026:  CLRF   02
06028:  CLRF   03
0602A:  MOVLB  A
0602C:  MOVLB  0
0602E:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
065F2:  MOVLW  10
065F4:  MOVLB  7
065F6:  ADDWF  x12,W
065F8:  MOVWF  FE9
065FA:  MOVLW  00
065FC:  ADDWFC x13,W
065FE:  MOVWF  FEA
06600:  MOVFF  FEF,A08
06604:  MOVFF  FEC,A09
06608:  MOVFF  FEC,A0A
0660C:  MOVFF  FEC,A0B
....................    switch (fs->fs_type)  
06610:  MOVF   x12,W
06612:  MOVWF  FE9
06614:  MOVF   x13,W
06616:  MOVWF  FEA
06618:  MOVF   FEF,W
0661A:  XORLW  01
0661C:  MOVLB  0
0661E:  BZ    662E
06620:  XORLW  03
06622:  BTFSC  FD8.2
06624:  BRA    6812
06626:  XORLW  01
06628:  BTFSC  FD8.2
0662A:  BRA    689C
0662C:  BRA    696C
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
0662E:  MOVFF  9FD,A11
06632:  MOVFF  9FC,A10
06636:  MOVLB  A
06638:  CLRF   x13
0663A:  MOVLW  03
0663C:  MOVWF  x12
0663E:  MOVLB  0
06640:  CALL   5CC0
06644:  BCF    FD8.0
06646:  MOVLB  A
06648:  RRCF   02,W
0664A:  MOVWF  x05
0664C:  RRCF   01,W
0664E:  MOVWF  x04
....................          if (!move_window(fatsect + bc / 512)) 
06650:  BCF    FD8.0
06652:  CLRF   03
06654:  RRCF   x05,W
06656:  MOVWF  02
06658:  ADDWF  x08,W
0665A:  MOVWF  x0C
0665C:  MOVF   03,W
0665E:  ADDWFC x09,W
06660:  MOVWF  x0D
06662:  MOVLW  00
06664:  ADDWFC x0A,W
06666:  MOVWF  x0E
06668:  MOVLW  00
0666A:  ADDWFC x0B,W
0666C:  MOVWF  x0F
0666E:  MOVWF  x17
06670:  MOVFF  A0E,A16
06674:  MOVFF  A0D,A15
06678:  MOVFF  A0C,A14
0667C:  MOVLB  0
0667E:  CALL   5AAA
06682:  MOVF   01,F
06684:  BNZ   668C
....................             return (FALSE); 
06686:  MOVLW  00
06688:  MOVWF  01
0668A:  BRA    698A
....................          p = &fs->win[bc % 512]; 
0668C:  MOVLB  A
0668E:  MOVF   x05,W
06690:  ANDLW  01
06692:  MOVWF  x0D
06694:  MOVLW  24
06696:  ADDWF  x04,W
06698:  MOVWF  01
0669A:  MOVLW  00
0669C:  ADDWFC x0D,W
0669E:  MOVWF  03
066A0:  MOVF   01,W
066A2:  MOVLB  7
066A4:  ADDWF  x12,W
066A6:  MOVWF  01
066A8:  MOVF   x13,W
066AA:  ADDWFC 03,F
066AC:  MOVFF  01,A06
066B0:  MOVLB  A
066B2:  MOVFF  03,A07
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
066B6:  MOVFF  A06,A0C
066BA:  MOVFF  A07,A0D
066BE:  MOVLB  9
066C0:  MOVF   xFC,W
066C2:  ANDLW  01
066C4:  MOVWF  00
066C6:  CLRF   01
066C8:  CLRF   02
066CA:  CLRF   03
066CC:  MOVF   00,F
066CE:  BNZ   66DC
066D0:  MOVF   01,F
066D2:  BNZ   66DC
066D4:  MOVF   02,F
066D6:  BNZ   66DC
066D8:  MOVF   03,F
066DA:  BZ    66FE
066DC:  MOVFF  A07,03
066E0:  MOVLB  A
066E2:  MOVFF  A06,FE9
066E6:  MOVFF  A07,FEA
066EA:  MOVF   FEF,W
066EC:  ANDLW  0F
066EE:  MOVWF  x0E
066F0:  SWAPF  x00,W
066F2:  MOVWF  00
066F4:  MOVLW  F0
066F6:  ANDWF  00,F
066F8:  MOVF   00,W
066FA:  IORWF  x0E,W
066FC:  BRA    6702
066FE:  MOVLB  A
06700:  MOVF   x00,W
06702:  MOVFF  A0D,FEA
06706:  MOVFF  A0C,FE9
0670A:  MOVWF  FEF
....................          fs->winflag = 1; 
0670C:  MOVLW  06
0670E:  MOVLB  7
06710:  ADDWF  x12,W
06712:  MOVWF  FE9
06714:  MOVLW  00
06716:  ADDWFC x13,W
06718:  MOVWF  FEA
0671A:  MOVLW  01
0671C:  MOVWF  FEF
....................          bc++; 
0671E:  MOVLB  A
06720:  INCF   x04,F
06722:  BTFSC  FD8.2
06724:  INCF   x05,F
....................          if (!move_window(fatsect + bc / 512)) 
06726:  BCF    FD8.0
06728:  CLRF   03
0672A:  RRCF   x05,W
0672C:  MOVWF  02
0672E:  ADDWF  x08,W
06730:  MOVWF  x0C
06732:  MOVF   03,W
06734:  ADDWFC x09,W
06736:  MOVWF  x0D
06738:  MOVLW  00
0673A:  ADDWFC x0A,W
0673C:  MOVWF  x0E
0673E:  MOVLW  00
06740:  ADDWFC x0B,W
06742:  MOVWF  x0F
06744:  MOVWF  x17
06746:  MOVFF  A0E,A16
0674A:  MOVFF  A0D,A15
0674E:  MOVFF  A0C,A14
06752:  MOVLB  0
06754:  CALL   5AAA
06758:  MOVF   01,F
0675A:  BNZ   6762
....................             return (FALSE); 
0675C:  MOVLW  00
0675E:  MOVWF  01
06760:  BRA    698A
....................          p = &fs->win[bc % 512]; 
06762:  MOVLB  A
06764:  MOVF   x05,W
06766:  ANDLW  01
06768:  MOVWF  x0D
0676A:  MOVLW  24
0676C:  ADDWF  x04,W
0676E:  MOVWF  01
06770:  MOVLW  00
06772:  ADDWFC x0D,W
06774:  MOVWF  03
06776:  MOVF   01,W
06778:  MOVLB  7
0677A:  ADDWF  x12,W
0677C:  MOVWF  01
0677E:  MOVF   x13,W
06780:  ADDWFC 03,F
06782:  MOVFF  01,A06
06786:  MOVLB  A
06788:  MOVFF  03,A07
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
0678C:  MOVFF  A06,A0C
06790:  MOVFF  A07,A0D
06794:  MOVLB  9
06796:  MOVF   xFC,W
06798:  ANDLW  01
0679A:  MOVWF  00
0679C:  CLRF   01
0679E:  CLRF   02
067A0:  CLRF   03
067A2:  MOVF   00,F
067A4:  BNZ   67B2
067A6:  MOVF   01,F
067A8:  BNZ   67B2
067AA:  MOVF   02,F
067AC:  BNZ   67B2
067AE:  MOVF   03,F
067B0:  BZ    67E4
067B2:  MOVLB  A
067B4:  RRCF   x03,W
067B6:  MOVWF  03
067B8:  RRCF   x02,W
067BA:  MOVWF  02
067BC:  RRCF   x01,W
067BE:  MOVWF  01
067C0:  RRCF   x00,W
067C2:  MOVWF  00
067C4:  RRCF   03,F
067C6:  RRCF   02,F
067C8:  RRCF   01,F
067CA:  RRCF   00,F
067CC:  RRCF   03,F
067CE:  RRCF   02,F
067D0:  RRCF   01,F
067D2:  RRCF   00,F
067D4:  RRCF   03,F
067D6:  RRCF   02,F
067D8:  RRCF   01,F
067DA:  RRCF   00,F
067DC:  MOVLW  0F
067DE:  ANDWF  03,F
067E0:  MOVF   00,W
067E2:  BRA    6806
067E4:  MOVLB  A
067E6:  MOVFF  A06,FE9
067EA:  MOVFF  A07,FEA
067EE:  MOVF   FEF,W
067F0:  ANDLW  F0
067F2:  MOVWF  x0F
067F4:  MOVFF  A01,00
067F8:  MOVFF  A02,01
067FC:  MOVFF  A03,02
06800:  MOVF   x01,W
06802:  ANDLW  0F
06804:  IORWF  x0F,W
06806:  MOVFF  A0D,FEA
0680A:  MOVFF  A0C,FE9
0680E:  MOVWF  FEF
....................          break; 
06810:  BRA    6974
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
06812:  MOVFF  9FD,00
06816:  MOVFF  9FE,01
0681A:  MOVFF  9FF,02
0681E:  CLRF   03
06820:  MOVF   00,W
06822:  MOVLB  A
06824:  ADDWF  x08,W
06826:  MOVWF  x0C
06828:  MOVF   01,W
0682A:  ADDWFC x09,W
0682C:  MOVWF  x0D
0682E:  MOVF   02,W
06830:  ADDWFC x0A,W
06832:  MOVWF  x0E
06834:  MOVF   03,W
06836:  ADDWFC x0B,W
06838:  MOVWF  x0F
0683A:  MOVWF  x17
0683C:  MOVFF  A0E,A16
06840:  MOVFF  A0D,A15
06844:  MOVFF  A0C,A14
06848:  MOVLB  0
0684A:  CALL   5AAA
0684E:  MOVF   01,F
06850:  BNZ   6858
....................             return (FALSE); 
06852:  MOVLW  00
06854:  MOVWF  01
06856:  BRA    698A
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
06858:  BCF    FD8.0
0685A:  MOVLB  9
0685C:  RLCF   xFC,W
0685E:  MOVLB  A
06860:  MOVWF  x0C
06862:  MOVLB  9
06864:  RLCF   xFD,W
06866:  MOVLB  A
06868:  MOVWF  x0D
0686A:  MOVLW  01
0686C:  ANDWF  x0D,F
0686E:  MOVLW  24
06870:  ADDWF  x0C,W
06872:  MOVWF  01
06874:  MOVLW  00
06876:  ADDWFC x0D,W
06878:  MOVWF  03
0687A:  MOVF   01,W
0687C:  MOVLB  7
0687E:  ADDWF  x12,W
06880:  MOVWF  01
06882:  MOVF   x13,W
06884:  ADDWFC 03,F
06886:  MOVFF  01,FE9
0688A:  MOVFF  03,FEA
0688E:  MOVFF  A01,FEC
06892:  MOVF   FED,F
06894:  MOVFF  A00,FEF
....................          break; 
06898:  MOVLB  A
0689A:  BRA    6974
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
0689C:  MOVLB  9
0689E:  RRCF   xFF,W
068A0:  MOVWF  03
068A2:  RRCF   xFE,W
068A4:  MOVWF  02
068A6:  RRCF   xFD,W
068A8:  MOVWF  01
068AA:  RRCF   xFC,W
068AC:  MOVWF  00
068AE:  RRCF   03,F
068B0:  RRCF   02,F
068B2:  RRCF   01,F
068B4:  RRCF   00,F
068B6:  RRCF   03,F
068B8:  RRCF   02,F
068BA:  RRCF   01,F
068BC:  RRCF   00,F
068BE:  RRCF   03,F
068C0:  RRCF   02,F
068C2:  RRCF   01,F
068C4:  RRCF   00,F
068C6:  RRCF   03,F
068C8:  RRCF   02,F
068CA:  RRCF   01,F
068CC:  RRCF   00,F
068CE:  RRCF   03,F
068D0:  RRCF   02,F
068D2:  RRCF   01,F
068D4:  RRCF   00,F
068D6:  RRCF   03,F
068D8:  RRCF   02,F
068DA:  RRCF   01,F
068DC:  RRCF   00,F
068DE:  MOVLW  01
068E0:  ANDWF  03,F
068E2:  MOVF   00,W
068E4:  MOVLB  A
068E6:  ADDWF  x08,W
068E8:  MOVWF  x0C
068EA:  MOVF   01,W
068EC:  ADDWFC x09,W
068EE:  MOVWF  x0D
068F0:  MOVF   02,W
068F2:  ADDWFC x0A,W
068F4:  MOVWF  x0E
068F6:  MOVF   03,W
068F8:  ADDWFC x0B,W
068FA:  MOVWF  x0F
068FC:  MOVWF  x17
068FE:  MOVFF  A0E,A16
06902:  MOVFF  A0D,A15
06906:  MOVFF  A0C,A14
0690A:  MOVLB  0
0690C:  CALL   5AAA
06910:  MOVF   01,F
06912:  BNZ   691A
....................             return (FALSE); 
06914:  MOVLW  00
06916:  MOVWF  01
06918:  BRA    698A
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
0691A:  MOVLB  9
0691C:  RLCF   xFC,W
0691E:  MOVLB  A
06920:  MOVWF  x0C
06922:  MOVLB  9
06924:  RLCF   xFD,W
06926:  MOVLB  A
06928:  MOVWF  x0D
0692A:  RLCF   x0C,F
0692C:  RLCF   x0D,F
0692E:  MOVLW  FC
06930:  ANDWF  x0C,F
06932:  MOVLW  01
06934:  ANDWF  x0D,F
06936:  MOVLW  24
06938:  ADDWF  x0C,W
0693A:  MOVWF  01
0693C:  MOVLW  00
0693E:  ADDWFC x0D,W
06940:  MOVWF  03
06942:  MOVF   01,W
06944:  MOVLB  7
06946:  ADDWF  x12,W
06948:  MOVWF  01
0694A:  MOVF   x13,W
0694C:  ADDWFC 03,F
0694E:  MOVFF  01,FE9
06952:  MOVFF  03,FEA
06956:  MOVFF  A00,FEF
0695A:  MOVFF  A01,FEC
0695E:  MOVFF  A02,FEC
06962:  MOVFF  A03,FEC
....................          break; 
06966:  MOVLB  A
06968:  BRA    6974
0696A:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
0696C:  MOVLW  00
0696E:  MOVWF  01
06970:  BRA    698A
06972:  MOVLB  A
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
06974:  MOVLW  06
06976:  MOVLB  7
06978:  ADDWF  x12,W
0697A:  MOVWF  FE9
0697C:  MOVLW  00
0697E:  ADDWFC x13,W
06980:  MOVWF  FEA
06982:  MOVLW  01
06984:  MOVWF  FEF
....................    return (TRUE); 
06986:  MOVWF  01
06988:  MOVLB  0
0698A:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06F6E:  MOVFF  9DE,9FF
06F72:  MOVFF  9DD,9FE
06F76:  MOVFF  9DC,9FD
06F7A:  MOVFF  9DB,9FC
06F7E:  CALL   5CE2
06F82:  MOVFF  03,9E2
06F86:  MOVFF  02,9E1
06F8A:  MOVFF  01,9E0
06F8E:  MOVFF  00,9DF
06F92:  MOVLB  9
06F94:  MOVF   xE2,F
06F96:  BNZ   6FA6
06F98:  MOVF   xE1,F
06F9A:  BNZ   6FA6
06F9C:  MOVF   xE0,F
06F9E:  BNZ   6FA6
06FA0:  MOVF   xDF,W
06FA2:  SUBLW  01
06FA4:  BC    7008
....................       { 
....................       if (!put_cluster(clust, 0)) 
06FA6:  MOVFF  9DE,9FF
06FAA:  MOVFF  9DD,9FE
06FAE:  MOVFF  9DC,9FD
06FB2:  MOVFF  9DB,9FC
06FB6:  MOVLB  A
06FB8:  CLRF   x03
06FBA:  CLRF   x02
06FBC:  CLRF   x01
06FBE:  CLRF   x00
06FC0:  MOVLB  0
06FC2:  CALL   65F2
06FC6:  MOVF   01,F
06FC8:  BNZ   6FD0
....................          return FALSE; 
06FCA:  MOVLW  00
06FCC:  MOVWF  01
06FCE:  BRA    700E
....................       clust = nxt; 
06FD0:  MOVFF  9E2,9DE
06FD4:  MOVFF  9E1,9DD
06FD8:  MOVFF  9E0,9DC
06FDC:  MOVFF  9DF,9DB
06FE0:  MOVFF  9DE,9FF
06FE4:  MOVFF  9DD,9FE
06FE8:  MOVFF  9DC,9FD
06FEC:  MOVFF  9DB,9FC
06FF0:  CALL   5CE2
06FF4:  MOVFF  03,9E2
06FF8:  MOVFF  02,9E1
06FFC:  MOVFF  01,9E0
07000:  MOVFF  00,9DF
07004:  BRA    6F92
07006:  MOVLB  9
....................       } 
....................    return TRUE; 
07008:  MOVLW  01
0700A:  MOVWF  01
0700C:  MOVLB  0
0700E:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
0698C:  MOVLW  0C
0698E:  MOVLB  7
06990:  ADDWF  x12,W
06992:  MOVWF  FE9
06994:  MOVLW  00
06996:  ADDWFC x13,W
06998:  MOVWF  FEA
0699A:  MOVFF  FEF,9F8
0699E:  MOVFF  FEC,9F9
069A2:  MOVFF  FEC,9FA
069A6:  MOVFF  FEC,9FB
....................    if (clust == 0)  
069AA:  MOVLB  9
069AC:  MOVF   xE8,F
069AE:  BNZ   6A18
069B0:  MOVF   xE9,F
069B2:  BNZ   6A18
069B4:  MOVF   xEA,F
069B6:  BNZ   6A18
069B8:  MOVF   xEB,F
069BA:  BNZ   6A18
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
069BC:  MOVLW  1C
069BE:  MOVLB  7
069C0:  ADDWF  x12,W
069C2:  MOVWF  FE9
069C4:  MOVLW  00
069C6:  ADDWFC x13,W
069C8:  MOVWF  FEA
069CA:  MOVFF  FEF,9F4
069CE:  MOVFF  FEC,9F5
069D2:  MOVFF  FEC,9F6
069D6:  MOVFF  FEC,9F7
....................       if (scl < 2 || scl >= mcl) scl = 1; 
069DA:  MOVLB  9
069DC:  MOVF   xF7,F
069DE:  BNZ   69EE
069E0:  MOVF   xF6,F
069E2:  BNZ   69EE
069E4:  MOVF   xF5,F
069E6:  BNZ   69EE
069E8:  MOVF   xF4,W
069EA:  SUBLW  01
069EC:  BC    6A0C
069EE:  MOVF   xFB,W
069F0:  SUBWF  xF7,W
069F2:  BNC   6A16
069F4:  BNZ   6A0C
069F6:  MOVF   xFA,W
069F8:  SUBWF  xF6,W
069FA:  BNC   6A16
069FC:  BNZ   6A0C
069FE:  MOVF   xF9,W
06A00:  SUBWF  xF5,W
06A02:  BNC   6A16
06A04:  BNZ   6A0C
06A06:  MOVF   xF8,W
06A08:  SUBWF  xF4,W
06A0A:  BNC   6A16
06A0C:  CLRF   xF7
06A0E:  CLRF   xF6
06A10:  CLRF   xF5
06A12:  MOVLW  01
06A14:  MOVWF  xF4
....................       } 
06A16:  BRA    6A9C
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
06A18:  MOVFF  9EB,9FF
06A1C:  MOVFF  9EA,9FE
06A20:  MOVFF  9E9,9FD
06A24:  MOVFF  9E8,9FC
06A28:  MOVLB  0
06A2A:  CALL   5CE2
06A2E:  MOVFF  03,9EF
06A32:  MOVFF  02,9EE
06A36:  MOVFF  01,9ED
06A3A:  MOVFF  00,9EC
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06A3E:  MOVLB  9
06A40:  MOVF   xEF,F
06A42:  BNZ   6A5C
06A44:  MOVF   xEE,F
06A46:  BNZ   6A5C
06A48:  MOVF   xED,F
06A4A:  BNZ   6A5C
06A4C:  MOVF   xEC,W
06A4E:  SUBLW  01
06A50:  BNC   6A5C
06A52:  CLRF   00
06A54:  CLRF   01
06A56:  CLRF   02
06A58:  CLRF   03
06A5A:  BRA    6C20
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
06A5C:  MOVF   xEF,W
06A5E:  SUBWF  xFB,W
06A60:  BNC   6A8C
06A62:  BNZ   6A7A
06A64:  MOVF   xEE,W
06A66:  SUBWF  xFA,W
06A68:  BNC   6A8C
06A6A:  BNZ   6A7A
06A6C:  MOVF   xED,W
06A6E:  SUBWF  xF9,W
06A70:  BNC   6A8C
06A72:  BNZ   6A7A
06A74:  MOVF   xF8,W
06A76:  SUBWF  xEC,W
06A78:  BC    6A8C
06A7A:  MOVFF  9EC,00
06A7E:  MOVFF  9ED,01
06A82:  MOVFF  9EE,02
06A86:  MOVFF  9EF,03
06A8A:  BRA    6C20
....................       scl = clust; 
06A8C:  MOVFF  9EB,9F7
06A90:  MOVFF  9EA,9F6
06A94:  MOVFF  9E9,9F5
06A98:  MOVFF  9E8,9F4
....................       } 
....................       ncl = scl;                  // Scan start cluster 
06A9C:  MOVFF  9F7,9F3
06AA0:  MOVFF  9F6,9F2
06AA4:  MOVFF  9F5,9F1
06AA8:  MOVFF  9F4,9F0
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
06AAC:  MOVLW  01
06AAE:  ADDWF  xF0,F
06AB0:  BTFSC  FD8.0
06AB2:  INCF   xF1,F
06AB4:  BTFSC  FD8.2
06AB6:  INCF   xF2,F
06AB8:  BTFSC  FD8.2
06ABA:  INCF   xF3,F
....................       if (ncl >= mcl)  
06ABC:  MOVF   xFB,W
06ABE:  SUBWF  xF3,W
06AC0:  BNC   6AFE
06AC2:  BNZ   6ADA
06AC4:  MOVF   xFA,W
06AC6:  SUBWF  xF2,W
06AC8:  BNC   6AFE
06ACA:  BNZ   6ADA
06ACC:  MOVF   xF9,W
06ACE:  SUBWF  xF1,W
06AD0:  BNC   6AFE
06AD2:  BNZ   6ADA
06AD4:  MOVF   xF8,W
06AD6:  SUBWF  xF0,W
06AD8:  BNC   6AFE
....................          {         // Wrap around 
....................          ncl = 2; 
06ADA:  CLRF   xF3
06ADC:  CLRF   xF2
06ADE:  CLRF   xF1
06AE0:  MOVLW  02
06AE2:  MOVWF  xF0
....................          if (scl == 1) return 0;      // No free custer was found 
06AE4:  DECFSZ xF4,W
06AE6:  BRA    6AFE
06AE8:  MOVF   xF5,F
06AEA:  BNZ   6AFE
06AEC:  MOVF   xF6,F
06AEE:  BNZ   6AFE
06AF0:  MOVF   xF7,F
06AF2:  BNZ   6AFE
06AF4:  CLRF   00
06AF6:  CLRF   01
06AF8:  CLRF   02
06AFA:  CLRF   03
06AFC:  BRA    6C20
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06AFE:  MOVF   xF4,W
06B00:  SUBWF  xF0,W
06B02:  BNZ   6B20
06B04:  MOVF   xF5,W
06B06:  SUBWF  xF1,W
06B08:  BNZ   6B20
06B0A:  MOVF   xF6,W
06B0C:  SUBWF  xF2,W
06B0E:  BNZ   6B20
06B10:  MOVF   xF7,W
06B12:  SUBWF  xF3,W
06B14:  BNZ   6B20
06B16:  CLRF   00
06B18:  CLRF   01
06B1A:  CLRF   02
06B1C:  CLRF   03
06B1E:  BRA    6C20
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06B20:  MOVFF  9F3,9FF
06B24:  MOVFF  9F2,9FE
06B28:  MOVFF  9F1,9FD
06B2C:  MOVFF  9F0,9FC
06B30:  MOVLB  0
06B32:  CALL   5CE2
06B36:  MOVFF  03,9EF
06B3A:  MOVFF  02,9EE
06B3E:  MOVFF  01,9ED
06B42:  MOVFF  00,9EC
....................       if (cstat == 1) return 0;      // Any error occured 
06B46:  MOVLB  9
06B48:  DECFSZ xEC,W
06B4A:  BRA    6B62
06B4C:  MOVF   xED,F
06B4E:  BNZ   6B62
06B50:  MOVF   xEE,F
06B52:  BNZ   6B62
06B54:  MOVF   xEF,F
06B56:  BNZ   6B62
06B58:  CLRF   00
06B5A:  CLRF   01
06B5C:  CLRF   02
06B5E:  CLRF   03
06B60:  BRA    6C20
....................       } while (cstat);            // Repeat until find a free cluster 
06B62:  MOVF   xEC,F
06B64:  BNZ   6AAC
06B66:  MOVF   xED,F
06B68:  BNZ   6AAC
06B6A:  MOVF   xEE,F
06B6C:  BNZ   6AAC
06B6E:  MOVF   xEF,F
06B70:  BNZ   6AAC
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06B72:  MOVFF  9F3,9FF
06B76:  MOVFF  9F2,9FE
06B7A:  MOVFF  9F1,9FD
06B7E:  MOVFF  9F0,9FC
06B82:  MOVLW  0F
06B84:  MOVLB  A
06B86:  MOVWF  x03
06B88:  SETF   x02
06B8A:  SETF   x01
06B8C:  SETF   x00
06B8E:  MOVLB  0
06B90:  RCALL  65F2
06B92:  MOVF   01,F
06B94:  BNZ   6BA4
06B96:  CLRF   00
06B98:  CLRF   01
06B9A:  CLRF   02
06B9C:  CLRF   03
06B9E:  MOVLB  9
06BA0:  BRA    6C20
06BA2:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06BA4:  MOVLB  9
06BA6:  MOVF   xE8,F
06BA8:  BNZ   6BB6
06BAA:  MOVF   xE9,F
06BAC:  BNZ   6BB6
06BAE:  MOVF   xEA,F
06BB0:  BNZ   6BB6
06BB2:  MOVF   xEB,F
06BB4:  BZ    6BF0
06BB6:  MOVFF  9EB,9FF
06BBA:  MOVFF  9EA,9FE
06BBE:  MOVFF  9E9,9FD
06BC2:  MOVFF  9E8,9FC
06BC6:  MOVFF  9F3,A03
06BCA:  MOVFF  9F2,A02
06BCE:  MOVFF  9F1,A01
06BD2:  MOVFF  9F0,A00
06BD6:  MOVLB  0
06BD8:  RCALL  65F2
06BDA:  MOVF   01,F
06BDC:  BTFSC  FD8.2
06BDE:  BRA    6BE4
06BE0:  MOVLB  9
06BE2:  BRA    6BF0
06BE4:  CLRF   00
06BE6:  CLRF   01
06BE8:  CLRF   02
06BEA:  CLRF   03
06BEC:  MOVLB  9
06BEE:  BRA    6C20
....................    fs->last_clust = ncl; 
06BF0:  MOVLW  1C
06BF2:  MOVLB  7
06BF4:  ADDWF  x12,W
06BF6:  MOVWF  FE9
06BF8:  MOVLW  00
06BFA:  ADDWFC x13,W
06BFC:  MOVWF  FEA
06BFE:  MOVFF  9F0,FEF
06C02:  MOVFF  9F1,FEC
06C06:  MOVFF  9F2,FEC
06C0A:  MOVFF  9F3,FEC
....................  
....................    return ncl;      // Return new cluster number 
06C0E:  MOVFF  9F0,00
06C12:  MOVFF  9F1,01
06C16:  MOVFF  9F2,02
06C1A:  MOVFF  9F3,03
06C1E:  MOVLB  9
06C20:  MOVLB  0
06C22:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
05636:  MOVLW  02
05638:  MOVLB  9
0563A:  SUBWF  xEF,F
0563C:  MOVLW  00
0563E:  SUBWFB xF0,F
05640:  SUBWFB xF1,F
05642:  SUBWFB xF2,F
....................    if (clust >= fs->max_clust)  
05644:  MOVLW  0C
05646:  MOVLB  7
05648:  ADDWF  x12,W
0564A:  MOVWF  FE9
0564C:  MOVLW  00
0564E:  ADDWFC x13,W
05650:  MOVWF  FEA
05652:  MOVFF  FEF,00
05656:  MOVFF  FEC,01
0565A:  MOVFF  FEC,02
0565E:  MOVFF  FEC,03
05662:  MOVF   03,W
05664:  MOVLB  9
05666:  SUBWF  xF2,W
05668:  BNC   568C
0566A:  BNZ   5682
0566C:  MOVF   02,W
0566E:  SUBWF  xF1,W
05670:  BNC   568C
05672:  BNZ   5682
05674:  MOVF   01,W
05676:  SUBWF  xF0,W
05678:  BNC   568C
0567A:  BNZ   5682
0567C:  MOVF   00,W
0567E:  SUBWF  xEF,W
05680:  BNC   568C
....................       return 0;      // Invalid cluster#  
05682:  CLRF   00
05684:  CLRF   01
05686:  CLRF   02
05688:  CLRF   03
0568A:  BRA    570C
....................    return (clust * fs->sects_clust + fs->database); 
0568C:  MOVLW  02
0568E:  MOVLB  7
05690:  ADDWF  x12,W
05692:  MOVWF  FE9
05694:  MOVLW  00
05696:  ADDWFC x13,W
05698:  MOVWF  FEA
0569A:  MOVFF  FEF,9FA
0569E:  MOVLB  9
056A0:  MOVFF  FEA,9F5
056A4:  MOVFF  FE9,9F4
056A8:  MOVFF  9F2,9F9
056AC:  MOVFF  9F1,9F8
056B0:  MOVFF  9F0,9F7
056B4:  MOVFF  9EF,9F6
056B8:  CLRF   xFD
056BA:  CLRF   xFC
056BC:  CLRF   xFB
056BE:  MOVLB  0
056C0:  CALL   4818
056C4:  MOVFF  9F5,FEA
056C8:  MOVFF  9F4,FE9
056CC:  MOVFF  03,9F6
056D0:  MOVFF  02,9F5
056D4:  MOVFF  01,9F4
056D8:  MOVFF  00,9F3
056DC:  MOVLW  18
056DE:  MOVLB  7
056E0:  ADDWF  x12,W
056E2:  MOVWF  FE9
056E4:  MOVLW  00
056E6:  ADDWFC x13,W
056E8:  MOVWF  FEA
056EA:  MOVFF  FEF,00
056EE:  MOVFF  FEC,01
056F2:  MOVFF  FEC,02
056F6:  MOVFF  FEC,03
056FA:  MOVLB  9
056FC:  MOVF   xF3,W
056FE:  ADDWF  00,F
05700:  MOVF   xF4,W
05702:  ADDWFC 01,F
05704:  MOVF   xF5,W
05706:  ADDWFC 02,F
05708:  MOVF   xF6,W
0570A:  ADDWFC 03,F
0570C:  MOVLB  0
0570E:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
046B8:  MOVLW  24
046BA:  MOVLB  7
046BC:  ADDWF  x12,W
046BE:  MOVWF  01
046C0:  MOVLW  00
046C2:  ADDWFC x13,W
046C4:  MOVWF  03
046C6:  MOVFF  01,9E7
046CA:  MOVLB  9
046CC:  MOVWF  xE8
046CE:  MOVWF  FEA
046D0:  MOVFF  01,FE9
046D4:  CLRF   00
046D6:  MOVLW  02
046D8:  MOVWF  02
046DA:  CLRF   01
046DC:  MOVLB  0
046DE:  CALL   354E
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
046E2:  MOVLW  24
046E4:  MOVLB  7
046E6:  ADDWF  x12,W
046E8:  MOVWF  01
046EA:  MOVLW  00
046EC:  ADDWFC x13,W
046EE:  MOVWF  03
046F0:  MOVFF  01,9E7
046F4:  MOVLB  9
046F6:  MOVWF  xE8
046F8:  MOVFF  FE8,A21
046FC:  MOVFF  01,A20
04700:  MOVFF  9E6,A25
04704:  MOVFF  9E5,A24
04708:  MOVFF  9E4,A23
0470C:  MOVFF  9E3,A22
04710:  MOVLW  01
04712:  MOVLB  A
04714:  MOVWF  x26
04716:  MOVLB  0
04718:  RCALL  44F4
0471A:  MOVF   01,F
0471C:  BTFSS  FD8.2
0471E:  BRA    480E
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
04720:  MOVLW  22
04722:  MOVLB  7
04724:  ADDWF  x12,W
04726:  MOVWF  01
04728:  MOVLW  02
0472A:  ADDWFC x13,W
0472C:  MOVWF  03
0472E:  MOVFF  01,FE9
04732:  MOVWF  FEA
04734:  MOVFF  FEC,9E8
04738:  MOVF   FED,F
0473A:  MOVFF  FEF,9E7
0473E:  MOVLB  9
04740:  MOVF   xE7,W
04742:  SUBLW  55
04744:  BNZ   4810
04746:  MOVF   xE8,W
04748:  SUBLW  AA
0474A:  BNZ   4810
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
0474C:  MOVLW  5A
0474E:  MOVLB  7
04750:  ADDWF  x12,W
04752:  MOVWF  01
04754:  MOVLW  00
04756:  ADDWFC x13,W
04758:  MOVWF  03
0475A:  MOVFF  01,9E7
0475E:  MOVLB  9
04760:  MOVWF  xE8
04762:  MOVWF  xEA
04764:  MOVFF  01,9E9
04768:  MOVLW  07
0476A:  MOVWF  xEC
0476C:  MOVLW  14
0476E:  MOVWF  xEB
04770:  CLRF   xEE
04772:  MOVLW  05
04774:  MOVWF  xED
04776:  MOVLB  0
04778:  RCALL  4634
0477A:  MOVF   01,F
0477C:  BNZ   4784
....................             return (FS_FAT12); 
0477E:  MOVLW  01
04780:  MOVWF  01
04782:  BRA    4816
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
04784:  MOVLW  5A
04786:  MOVLB  7
04788:  ADDWF  x12,W
0478A:  MOVWF  01
0478C:  MOVLW  00
0478E:  ADDWFC x13,W
04790:  MOVWF  03
04792:  MOVFF  01,9E7
04796:  MOVLB  9
04798:  MOVWF  xE8
0479A:  MOVWF  xEA
0479C:  MOVFF  01,9E9
047A0:  MOVLW  07
047A2:  MOVWF  xEC
047A4:  MOVLW  19
047A6:  MOVWF  xEB
047A8:  CLRF   xEE
047AA:  MOVLW  05
047AC:  MOVWF  xED
047AE:  MOVLB  0
047B0:  RCALL  4634
047B2:  MOVF   01,F
047B4:  BNZ   47BC
....................             return (FS_FAT16); 
047B6:  MOVLW  02
047B8:  MOVWF  01
047BA:  BRA    4816
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
047BC:  MOVLW  76
047BE:  MOVLB  7
047C0:  ADDWF  x12,W
047C2:  MOVWF  01
047C4:  MOVLW  00
047C6:  ADDWFC x13,W
047C8:  MOVWF  03
047CA:  MOVFF  01,9E7
047CE:  MOVLB  9
047D0:  MOVWF  xE8
047D2:  MOVWF  xEA
047D4:  MOVFF  01,9E9
047D8:  MOVLW  07
047DA:  MOVWF  xEC
047DC:  MOVLW  1E
047DE:  MOVWF  xEB
047E0:  CLRF   xEE
047E2:  MOVLW  05
047E4:  MOVWF  xED
047E6:  MOVLB  0
047E8:  RCALL  4634
047EA:  MOVF   01,F
047EC:  BNZ   480E
047EE:  MOVLW  4C
047F0:  MOVLB  7
047F2:  ADDWF  x12,W
047F4:  MOVWF  FE9
047F6:  MOVLW  00
047F8:  ADDWFC x13,W
047FA:  MOVWF  FEA
047FC:  MOVF   FEF,F
047FE:  BTFSC  FD8.2
04800:  BRA    4806
04802:  MOVLB  0
04804:  BRA    480E
....................             return (FS_FAT32); 
04806:  MOVLW  03
04808:  MOVWF  01
0480A:  MOVLB  0
0480C:  BRA    4816
0480E:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
04810:  MOVLW  00
04812:  MOVWF  01
04814:  MOVLB  0
04816:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
06030:  MOVLW  0C
06032:  MOVLB  9
06034:  ADDWF  xE5,W
06036:  MOVWF  FE9
06038:  MOVLW  00
0603A:  ADDWFC xE6,W
0603C:  MOVWF  FEA
0603E:  MOVFF  FEC,9EE
06042:  MOVF   FED,F
06044:  MOVFF  FEF,9ED
06048:  MOVLW  01
0604A:  ADDWF  xED,W
0604C:  MOVWF  xEB
0604E:  MOVLW  00
06050:  ADDWFC xEE,W
06052:  MOVWF  xEC
....................    if ((idx & 15) == 0)  
06054:  MOVF   xEB,W
06056:  ANDLW  0F
06058:  MOVWF  xED
0605A:  CLRF   xEE
0605C:  MOVF   xED,F
0605E:  BTFSS  FD8.2
06060:  BRA    61EC
06062:  MOVF   xEE,F
06064:  BTFSS  FD8.2
06066:  BRA    61EC
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
06068:  MOVLW  08
0606A:  ADDWF  xE5,W
0606C:  MOVWF  FE9
0606E:  MOVLW  00
06070:  ADDWFC xE6,W
06072:  MOVWF  FEA
06074:  MOVLW  01
06076:  ADDWF  FEE,F
06078:  MOVLW  00
0607A:  ADDWFC FEE,F
0607C:  ADDWFC FEE,F
0607E:  ADDWFC FED,F
....................       if (!scan->clust)  
06080:  MOVLW  04
06082:  ADDWF  xE5,W
06084:  MOVWF  FE9
06086:  MOVLW  00
06088:  ADDWFC xE6,W
0608A:  MOVWF  FEA
0608C:  MOVF   FEF,F
0608E:  BNZ   60CC
06090:  MOVF   FEC,F
06092:  BNZ   60CC
06094:  MOVF   FEC,F
06096:  BNZ   60CC
06098:  MOVF   FEC,F
0609A:  BNZ   60CC
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
0609C:  MOVLW  04
0609E:  MOVLB  7
060A0:  ADDWF  x12,W
060A2:  MOVWF  FE9
060A4:  MOVLW  00
060A6:  ADDWFC x13,W
060A8:  MOVWF  FEA
060AA:  MOVFF  FEC,03
060AE:  MOVF   FED,F
060B0:  MOVFF  FEF,01
060B4:  MOVF   03,W
060B6:  MOVLB  9
060B8:  SUBWF  xEC,W
060BA:  BNC   60CA
060BC:  BNZ   60C4
060BE:  MOVF   01,W
060C0:  SUBWF  xEB,W
060C2:  BNC   60CA
....................             return (FALSE);   // Reached to end of table  
060C4:  MOVLW  00
060C6:  MOVWF  01
060C8:  BRA    6206
....................          }  
060CA:  BRA    61EC
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
060CC:  RRCF   xEC,W
060CE:  MOVWF  xEE
060D0:  RRCF   xEB,W
060D2:  MOVWF  xED
060D4:  RRCF   xEE,F
060D6:  RRCF   xED,F
060D8:  RRCF   xEE,F
060DA:  RRCF   xED,F
060DC:  RRCF   xEE,F
060DE:  RRCF   xED,F
060E0:  MOVLW  0F
060E2:  ANDWF  xEE,F
060E4:  MOVLW  02
060E6:  MOVLB  7
060E8:  ADDWF  x12,W
060EA:  MOVWF  FE9
060EC:  MOVLW  00
060EE:  ADDWFC x13,W
060F0:  MOVWF  FEA
060F2:  MOVLW  01
060F4:  SUBWF  FEF,W
060F6:  MOVLB  9
060F8:  ANDWF  xED,F
060FA:  CLRF   xEE
060FC:  MOVF   xED,F
060FE:  BTFSS  FD8.2
06100:  BRA    61EC
06102:  MOVF   xEE,F
06104:  BTFSS  FD8.2
06106:  BRA    61EC
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
06108:  MOVLW  04
0610A:  ADDWF  xE5,W
0610C:  MOVWF  FE9
0610E:  MOVLW  00
06110:  ADDWFC xE6,W
06112:  MOVWF  FEA
06114:  MOVFF  FEF,9FC
06118:  MOVFF  FEC,9FD
0611C:  MOVFF  FEC,9FE
06120:  MOVFF  FEC,9FF
06124:  MOVLB  0
06126:  RCALL  5CE2
06128:  MOVFF  03,9EA
0612C:  MOVFF  02,9E9
06130:  MOVFF  01,9E8
06134:  MOVFF  00,9E7
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06138:  MOVLW  0C
0613A:  MOVLB  7
0613C:  ADDWF  x12,W
0613E:  MOVWF  FE9
06140:  MOVLW  00
06142:  ADDWFC x13,W
06144:  MOVWF  FEA
06146:  MOVFF  FEF,00
0614A:  MOVFF  FEC,01
0614E:  MOVFF  FEC,02
06152:  MOVFF  FEC,03
06156:  MOVF   03,W
06158:  MOVLB  9
0615A:  SUBWF  xEA,W
0615C:  BNC   6176
0615E:  BNZ   6188
06160:  MOVF   02,W
06162:  SUBWF  xE9,W
06164:  BNC   6176
06166:  BNZ   6188
06168:  MOVF   01,W
0616A:  SUBWF  xE8,W
0616C:  BNC   6176
0616E:  BNZ   6188
06170:  MOVF   00,W
06172:  SUBWF  xE7,W
06174:  BC    6188
06176:  MOVF   xEA,F
06178:  BNZ   618E
0617A:  MOVF   xE9,F
0617C:  BNZ   618E
0617E:  MOVF   xE8,F
06180:  BNZ   618E
06182:  MOVF   xE7,W
06184:  SUBLW  01
06186:  BNC   618E
....................                return (FALSE); 
06188:  MOVLW  00
0618A:  MOVWF  01
0618C:  BRA    6206
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
0618E:  MOVLW  04
06190:  ADDWF  xE5,W
06192:  MOVWF  FE9
06194:  MOVLW  00
06196:  ADDWFC xE6,W
06198:  MOVWF  FEA
0619A:  MOVFF  9E7,FEF
0619E:  MOVFF  9E8,FEC
061A2:  MOVFF  9E9,FEC
061A6:  MOVFF  9EA,FEC
....................             scan->sect = clust2sect(clust); 
061AA:  MOVLW  08
061AC:  ADDWF  xE5,W
061AE:  MOVWF  01
061B0:  MOVLW  00
061B2:  ADDWFC xE6,W
061B4:  MOVWF  03
061B6:  MOVFF  01,9ED
061BA:  MOVWF  xEE
061BC:  MOVFF  9EA,9F2
061C0:  MOVFF  9E9,9F1
061C4:  MOVFF  9E8,9F0
061C8:  MOVFF  9E7,9EF
061CC:  MOVLB  0
061CE:  CALL   5636
061D2:  MOVFF  9EE,FEA
061D6:  MOVFF  9ED,FE9
061DA:  MOVFF  00,FEF
061DE:  MOVFF  01,FEC
061E2:  MOVFF  02,FEC
061E6:  MOVFF  03,FEC
061EA:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
061EC:  MOVLW  0C
061EE:  ADDWF  xE5,W
061F0:  MOVWF  FE9
061F2:  MOVLW  00
061F4:  ADDWFC xE6,W
061F6:  MOVWF  FEA
061F8:  MOVFF  9EC,FEC
061FC:  MOVF   FED,F
061FE:  MOVFF  9EB,FEF
....................    return (TRUE); 
06202:  MOVLW  01
06204:  MOVWF  01
06206:  MOVLB  0
06208:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
05710:  MOVFF  9E8,FEA
05714:  MOVFF  9E7,FE9
05718:  MOVLW  20
0571A:  MOVWF  00
0571C:  CLRF   02
0571E:  MOVLW  0B
05720:  MOVWF  01
05722:  CALL   354E
....................    a = 0; b = 0x18;            // NT flag 
05726:  MOVLB  9
05728:  CLRF   xEC
0572A:  MOVLW  18
0572C:  MOVWF  xED
....................    n = 0; t = 8; 
0572E:  CLRF   xE9
05730:  MOVLW  08
05732:  MOVWF  xEA
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
05734:  MOVFF  9E5,FE9
05738:  MOVFF  9E6,FEA
0573C:  MOVFF  FEC,9EF
05740:  MOVF   FED,F
05742:  MOVFF  FEF,9EE
....................       c = *ptr; 
05746:  MOVFF  9EE,FE9
0574A:  MOVFF  9EF,FEA
0574E:  MOVFF  FEF,9EB
....................       (*path)++; 
05752:  MOVFF  9E6,03
05756:  MOVFF  9E5,FE9
0575A:  MOVFF  9E6,FEA
0575E:  MOVLW  01
05760:  ADDWF  FEE,F
05762:  BNC   5766
05764:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
05766:  MOVF   xEB,W
05768:  SUBLW  20
0576A:  BNC   576E
....................          c = 0; 
0576C:  CLRF   xEB
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
0576E:  MOVF   xEB,F
05770:  BZ    577E
05772:  MOVF   xEB,W
05774:  SUBLW  2F
05776:  BZ    577E
05778:  MOVF   xEB,W
0577A:  SUBLW  5C
0577C:  BNZ   579C
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
0577E:  MOVF   xE9,F
05780:  BNZ   5784
....................             break; 
05782:  BRA    5864
....................          dirname[11] = a & b;  
05784:  MOVLW  0B
05786:  ADDWF  xE7,W
05788:  MOVWF  FE9
0578A:  MOVLW  00
0578C:  ADDWFC xE8,W
0578E:  MOVWF  FEA
05790:  MOVF   xEC,W
05792:  ANDWF  xED,W
05794:  MOVWF  FEF
....................             return (c); 
05796:  MOVFF  9EB,01
0579A:  BRA    5868
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
0579C:  MOVF   xEB,W
0579E:  SUBLW  20
057A0:  BC    57A8
057A2:  MOVF   xEB,W
057A4:  SUBLW  7F
057A6:  BNZ   57AA
....................          break;   // reject invisible characters 
057A8:  BRA    5864
....................       if (c == '.')  
057AA:  MOVF   xEB,W
057AC:  SUBLW  2E
057AE:  BNZ   57CC
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
057B0:  BTFSC  xEC.0
057B2:  BRA    57CA
057B4:  MOVF   xE9,W
057B6:  SUBLW  00
057B8:  BC    57CA
057BA:  MOVF   xE9,W
057BC:  SUBLW  08
057BE:  BNC   57CA
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
057C0:  MOVLW  08
057C2:  MOVWF  xE9
057C4:  MOVLW  0B
057C6:  MOVWF  xEA
....................             continue; 
057C8:  BRA    5862
....................             } 
....................          break; 
057CA:  BRA    5864
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
057CC:  MOVF   xEB,W
057CE:  SUBLW  22
057D0:  BNZ   57D4
....................          break;               // Reject "  
057D2:  BRA    5864
....................  
....................       if (c <= ')')  
057D4:  MOVF   xEB,W
057D6:  SUBLW  29
057D8:  BNC   57DC
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
057DA:  BRA    5846
....................  
....................       if (c <= ',') 
057DC:  MOVF   xEB,W
057DE:  SUBLW  2C
057E0:  BNC   57E4
....................          break;               // Reject * + ,  
057E2:  BRA    5864
....................  
....................       if (c <= '9')  
057E4:  MOVF   xEB,W
057E6:  SUBLW  39
057E8:  BNC   57EC
....................          goto md_l1;            // Accept - 0-9  
057EA:  BRA    5846
....................  
....................       if (c <= '?')  
057EC:  MOVF   xEB,W
057EE:  SUBLW  3F
057F0:  BNC   57F4
....................          break;               // Reject : ; < = > ?  
057F2:  BRA    5864
....................  
....................       if (!(a & 1))  
057F4:  BTFSC  xEC.0
057F6:  BRA    5846
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
057F8:  MOVF   xEB,W
057FA:  SUBLW  7C
057FC:  BNZ   5800
....................             break;            // Reject |  
057FE:  BRA    5864
....................  
....................          if ((c >= '[') && (c <= ']')) 
05800:  MOVF   xEB,W
05802:  SUBLW  5A
05804:  BC    580E
05806:  MOVF   xEB,W
05808:  SUBLW  5D
0580A:  BNC   580E
....................             break;// Reject [ \ ]  
0580C:  BRA    5864
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
0580E:  MOVF   xEB,W
05810:  SUBLW  40
05812:  BC    5828
05814:  MOVF   xEB,W
05816:  SUBLW  5A
05818:  BNC   5828
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
0581A:  MOVF   xEA,W
0581C:  SUBLW  08
0581E:  BNZ   5826
05820:  BCF    xED.3
05822:  MOVF   xED,W
05824:  BRA    5828
05826:  BCF    xED.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
05828:  MOVF   xEB,W
0582A:  SUBLW  60
0582C:  BC    5846
0582E:  MOVF   xEB,W
05830:  SUBLW  7A
05832:  BNC   5846
....................             {      // Convert to upper case  
....................             c -= 0x20; 
05834:  MOVLW  20
05836:  SUBWF  xEB,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
05838:  MOVF   xEA,W
0583A:  SUBLW  08
0583C:  BNZ   5844
0583E:  BSF    xEC.3
05840:  MOVF   xEC,W
05842:  BRA    5846
05844:  BSF    xEC.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
05846:  BCF    xEC.0
....................    md_l2: 
....................       if (n >= t)  
05848:  MOVF   xEA,W
0584A:  SUBWF  xE9,W
0584C:  BNC   5850
....................          break; 
0584E:  BRA    5864
....................       dirname[n++] = c; 
05850:  MOVF   xE9,W
05852:  INCF   xE9,F
05854:  ADDWF  xE7,W
05856:  MOVWF  FE9
05858:  MOVLW  00
0585A:  ADDWFC xE8,W
0585C:  MOVWF  FEA
0585E:  MOVFF  9EB,FEF
05862:  BRA    5734
....................       } 
....................    return 1; 
05864:  MOVLW  01
05866:  MOVWF  01
05868:  MOVLB  0
0586A:  GOTO   63AC (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
0620A:  MOVLB  9
0620C:  CLRF   xE4
0620E:  CLRF   xE3
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
06210:  MOVLW  14
06212:  MOVLB  7
06214:  ADDWF  x12,W
06216:  MOVWF  FE9
06218:  MOVLW  00
0621A:  ADDWFC x13,W
0621C:  MOVWF  FEA
0621E:  MOVFF  FEF,9DE
06222:  MOVFF  FEC,9DF
06226:  MOVFF  FEC,9E0
0622A:  MOVFF  FEC,9E1
....................    if (fs->fs_type == FS_FAT32)  
0622E:  MOVFF  712,FE9
06232:  MOVFF  713,FEA
06236:  MOVF   FEF,W
06238:  SUBLW  03
0623A:  BNZ   62BE
....................       { 
....................       scan->clust = scan->sclust = clust; 
0623C:  MOVLW  04
0623E:  MOVLB  9
06240:  ADDWF  xD6,W
06242:  MOVWF  01
06244:  MOVLW  00
06246:  ADDWFC xD7,W
06248:  MOVFF  01,9E5
0624C:  MOVFF  9D6,FE9
06250:  MOVFF  9D7,FEA
06254:  MOVFF  9DE,FEF
06258:  MOVFF  9DF,FEC
0625C:  MOVFF  9E0,FEC
06260:  MOVFF  9E1,FEC
06264:  MOVWF  FEA
06266:  MOVFF  9E5,FE9
0626A:  MOVFF  9DE,FEF
0626E:  MOVFF  9DF,FEC
06272:  MOVFF  9E0,FEC
06276:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
0627A:  MOVLW  08
0627C:  ADDWF  xD6,W
0627E:  MOVWF  01
06280:  MOVLW  00
06282:  ADDWFC xD7,W
06284:  MOVWF  03
06286:  MOVFF  01,9E5
0628A:  MOVWF  xE6
0628C:  MOVFF  9E1,9F2
06290:  MOVFF  9E0,9F1
06294:  MOVFF  9DF,9F0
06298:  MOVFF  9DE,9EF
0629C:  MOVLB  0
0629E:  CALL   5636
062A2:  MOVFF  9E6,FEA
062A6:  MOVFF  9E5,FE9
062AA:  MOVFF  00,FEF
062AE:  MOVFF  01,FEC
062B2:  MOVFF  02,FEC
062B6:  MOVFF  03,FEC
....................       } 
062BA:  BRA    631E
062BC:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
062BE:  MOVLW  04
062C0:  MOVLB  9
062C2:  ADDWF  xD6,W
062C4:  MOVWF  01
062C6:  MOVLW  00
062C8:  ADDWFC xD7,W
062CA:  MOVWF  03
062CC:  MOVFF  9D6,FE9
062D0:  MOVFF  9D7,FEA
062D4:  MOVF   FEE,F
062D6:  MOVF   FEE,F
062D8:  CLRF   FEC
062DA:  MOVF   FED,F
062DC:  CLRF   FEF
062DE:  MOVF   FED,F
062E0:  CLRF   FEF
062E2:  MOVF   FED,F
062E4:  CLRF   FEF
062E6:  MOVLW  00
062E8:  MOVFF  03,FEA
062EC:  MOVFF  01,FE9
062F0:  MOVFF  00,FEF
062F4:  MOVFF  01,FEC
062F8:  MOVFF  02,FEC
062FC:  MOVFF  03,FEC
....................       scan->sect = clust; 
06300:  MOVLW  08
06302:  ADDWF  xD6,W
06304:  MOVWF  FE9
06306:  MOVLW  00
06308:  ADDWFC xD7,W
0630A:  MOVWF  FEA
0630C:  MOVFF  9DE,FEF
06310:  MOVFF  9DF,FEC
06314:  MOVFF  9E0,FEC
06318:  MOVFF  9E1,FEC
0631C:  MOVLB  0
....................       } 
....................    scan->index = 0; 
0631E:  MOVLW  0C
06320:  MOVLB  9
06322:  ADDWF  xD6,W
06324:  MOVWF  FE9
06326:  MOVLW  00
06328:  ADDWFC xD7,W
0632A:  MOVWF  FEA
0632C:  CLRF   FEC
0632E:  MOVF   FED,F
06330:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
06332:  MOVFF  9DB,03
06336:  MOVFF  9DA,FE9
0633A:  MOVFF  9DB,FEA
0633E:  MOVF   FEF,W
06340:  SUBLW  20
06342:  BZ    6368
06344:  MOVFF  9DB,03
06348:  MOVFF  9DA,FE9
0634C:  MOVFF  9DB,FEA
06350:  MOVF   FEF,W
06352:  SUBLW  2F
06354:  BZ    6368
06356:  MOVFF  9DB,03
0635A:  MOVFF  9DA,FE9
0635E:  MOVFF  9DB,FEA
06362:  MOVF   FEF,W
06364:  SUBLW  5C
06366:  BNZ   6370
....................        path++; 
06368:  INCF   xDA,F
0636A:  BTFSC  FD8.2
0636C:  INCF   xDB,F
0636E:  BRA    6332
....................  
....................    if ((BYTE)*path < ' ')  
06370:  MOVFF  9DB,03
06374:  MOVFF  9DA,FE9
06378:  MOVFF  9DB,FEA
0637C:  MOVF   FEF,W
0637E:  SUBLW  1F
06380:  BNC   6396
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
06382:  MOVFF  9DC,FE9
06386:  MOVFF  9DD,FEA
0638A:  CLRF   FEC
0638C:  MOVF   FED,F
0638E:  CLRF   FEF
....................       return (FR_OK); 
06390:  MOVLW  00
06392:  MOVWF  01
06394:  BRA    65EE
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
06396:  MOVLW  09
06398:  MOVWF  xE6
0639A:  MOVLW  DA
0639C:  MOVWF  xE5
0639E:  MOVFF  9D9,9E8
063A2:  MOVFF  9D8,9E7
063A6:  MOVLB  0
063A8:  GOTO   5710
063AC:  MOVFF  01,9E2
....................       if (ds == 1)  
063B0:  MOVLB  9
063B2:  DECFSZ xE2,W
063B4:  BRA    63BC
....................          return (FR_INVALID_NAME); 
063B6:  MOVLW  04
063B8:  MOVWF  01
063BA:  BRA    65EE
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
063BC:  MOVLW  08
063BE:  ADDWF  xD6,W
063C0:  MOVWF  FE9
063C2:  MOVLW  00
063C4:  ADDWFC xD7,W
063C6:  MOVWF  FEA
063C8:  MOVFF  FEF,A14
063CC:  MOVFF  FEC,A15
063D0:  MOVFF  FEC,A16
063D4:  MOVFF  FEC,A17
063D8:  MOVLB  0
063DA:  CALL   5AAA
063DE:  MOVF   01,F
063E0:  BNZ   63EC
....................             return (FR_RW_ERROR); 
063E2:  MOVLW  07
063E4:  MOVWF  01
063E6:  MOVLB  9
063E8:  BRA    65EE
063EA:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
063EC:  MOVLW  0C
063EE:  MOVLB  9
063F0:  ADDWF  xD6,W
063F2:  MOVWF  FE9
063F4:  MOVLW  00
063F6:  ADDWFC xD7,W
063F8:  MOVWF  FEA
063FA:  MOVFF  FEC,9E6
063FE:  MOVF   FED,F
06400:  MOVFF  FEF,9E5
06404:  MOVLW  0F
06406:  ANDWF  xE5,F
06408:  CLRF   xE6
0640A:  RLCF   xE5,F
0640C:  RLCF   xE6,F
0640E:  RLCF   xE5,F
06410:  RLCF   xE6,F
06412:  RLCF   xE5,F
06414:  RLCF   xE6,F
06416:  RLCF   xE5,F
06418:  RLCF   xE6,F
0641A:  RLCF   xE5,F
0641C:  RLCF   xE6,F
0641E:  MOVLW  E0
06420:  ANDWF  xE5,F
06422:  MOVLW  24
06424:  ADDWF  xE5,W
06426:  MOVWF  01
06428:  MOVLW  00
0642A:  ADDWFC xE6,W
0642C:  MOVWF  03
0642E:  MOVF   01,W
06430:  MOVLB  7
06432:  ADDWF  x12,W
06434:  MOVWF  01
06436:  MOVF   x13,W
06438:  ADDWFC 03,F
0643A:  MOVFF  01,9E3
0643E:  MOVLB  9
06440:  MOVFF  03,9E4
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
06444:  MOVFF  9E4,03
06448:  MOVFF  9E3,FE9
0644C:  MOVFF  9E4,FEA
06450:  MOVF   FEF,F
06452:  BNZ   6462
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06454:  MOVF   xE2,F
06456:  BNZ   645C
06458:  MOVLW  02
0645A:  BRA    645E
0645C:  MOVLW  03
0645E:  MOVWF  01
06460:  BRA    65EE
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
06462:  MOVFF  9E4,03
06466:  MOVFF  9E3,FE9
0646A:  MOVFF  9E4,FEA
0646E:  MOVF   FEF,W
06470:  SUBLW  E5
06472:  BZ    64B4
06474:  MOVLW  0B
06476:  ADDWF  xE3,W
06478:  MOVWF  01
0647A:  MOVLW  00
0647C:  ADDWFC xE4,W
0647E:  MOVWF  03
06480:  MOVFF  01,FE9
06484:  MOVWF  FEA
06486:  BTFSC  FEF.3
06488:  BRA    64B4
0648A:  MOVFF  9E4,9EA
0648E:  MOVFF  9E3,9E9
06492:  MOVFF  9D9,9EC
06496:  MOVFF  9D8,9EB
0649A:  CLRF   xEE
0649C:  MOVLW  0B
0649E:  MOVWF  xED
064A0:  MOVLB  0
064A2:  CALL   4634
064A6:  MOVF   01,F
064A8:  BTFSC  FD8.2
064AA:  BRA    64B0
064AC:  MOVLB  9
064AE:  BRA    64B4
....................              break; 
064B0:  BRA    64DC
064B2:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
064B4:  MOVFF  9D7,9E6
064B8:  MOVFF  9D6,9E5
064BC:  MOVLB  0
064BE:  RCALL  6030
064C0:  MOVF   01,F
064C2:  BNZ   64D6
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
064C4:  MOVLB  9
064C6:  MOVF   xE2,F
064C8:  BNZ   64CE
064CA:  MOVLW  02
064CC:  BRA    64D0
064CE:  MOVLW  03
064D0:  MOVWF  01
064D2:  BRA    65EE
064D4:  MOVLB  0
064D6:  MOVLB  9
064D8:  BRA    63BC
064DA:  MOVLB  0
....................          } 
....................       if (!ds)  
064DC:  MOVLB  9
064DE:  MOVF   xE2,F
064E0:  BNZ   64FA
....................          {  
....................          *win_dir = dptr;  
064E2:  MOVFF  9DC,FE9
064E6:  MOVFF  9DD,FEA
064EA:  MOVFF  9E4,FEC
064EE:  MOVF   FED,F
064F0:  MOVFF  9E3,FEF
....................          return (FR_OK); 
064F4:  MOVLW  00
064F6:  MOVWF  01
064F8:  BRA    65EE
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
064FA:  MOVLW  0B
064FC:  ADDWF  xE3,W
064FE:  MOVWF  01
06500:  MOVLW  00
06502:  ADDWFC xE4,W
06504:  MOVWF  03
06506:  MOVFF  01,FE9
0650A:  MOVWF  FEA
0650C:  BTFSC  FEF.4
0650E:  BRA    6516
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
06510:  MOVLW  03
06512:  MOVWF  01
06514:  BRA    65EE
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
06516:  MOVLW  14
06518:  ADDWF  xE3,W
0651A:  MOVWF  01
0651C:  MOVLW  00
0651E:  ADDWFC xE4,W
06520:  MOVWF  03
06522:  MOVFF  01,FE9
06526:  MOVWF  FEA
06528:  MOVFF  FEC,9E1
0652C:  MOVF   FED,F
0652E:  MOVFF  FEF,9E5
06532:  MOVFF  9E5,9E0
06536:  CLRF   xE5
06538:  CLRF   xE6
0653A:  MOVLW  1A
0653C:  ADDWF  xE3,W
0653E:  MOVWF  01
06540:  MOVLW  00
06542:  ADDWFC xE4,W
06544:  MOVFF  01,FE9
06548:  MOVWF  FEA
0654A:  MOVFF  FEC,03
0654E:  MOVF   FED,F
06550:  MOVF   FEF,W
06552:  IORWF  xE5,W
06554:  MOVWF  xDE
06556:  MOVF   03,W
06558:  IORWF  xE6,W
0655A:  MOVWF  xDF
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
0655C:  MOVLW  04
0655E:  ADDWF  xD6,W
06560:  MOVWF  01
06562:  MOVLW  00
06564:  ADDWFC xD7,W
06566:  MOVFF  01,9E5
0656A:  MOVFF  9D6,FE9
0656E:  MOVFF  9D7,FEA
06572:  MOVFF  9DE,FEF
06576:  MOVFF  9DF,FEC
0657A:  MOVFF  9E0,FEC
0657E:  MOVFF  9E1,FEC
06582:  MOVWF  FEA
06584:  MOVFF  9E5,FE9
06588:  MOVFF  9DE,FEF
0658C:  MOVFF  9DF,FEC
06590:  MOVFF  9E0,FEC
06594:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
06598:  MOVLW  08
0659A:  ADDWF  xD6,W
0659C:  MOVWF  01
0659E:  MOVLW  00
065A0:  ADDWFC xD7,W
065A2:  MOVWF  03
065A4:  MOVFF  01,9E5
065A8:  MOVWF  xE6
065AA:  MOVFF  9E1,9F2
065AE:  MOVFF  9E0,9F1
065B2:  MOVFF  9DF,9F0
065B6:  MOVFF  9DE,9EF
065BA:  MOVLB  0
065BC:  CALL   5636
065C0:  MOVFF  9E6,FEA
065C4:  MOVFF  9E5,FE9
065C8:  MOVFF  00,FEF
065CC:  MOVFF  01,FEC
065D0:  MOVFF  02,FEC
065D4:  MOVFF  03,FEC
....................       scan->index = 0; 
065D8:  MOVLW  0C
065DA:  MOVLB  9
065DC:  ADDWF  xD6,W
065DE:  MOVWF  FE9
065E0:  MOVLW  00
065E2:  ADDWFC xD7,W
065E4:  MOVWF  FEA
065E6:  CLRF   FEC
065E8:  MOVF   FED,F
065EA:  CLRF   FEF
065EC:  BRA    6396
....................       } 
065EE:  MOVLB  0
065F0:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06C24:  MOVLB  9
06C26:  MOVFF  9D6,FE9
06C2A:  MOVFF  9D7,FEA
06C2E:  MOVFF  FEF,9D8
06C32:  MOVFF  FEC,9D9
06C36:  MOVFF  FEC,9DA
06C3A:  MOVFF  FEC,9DB
....................    if (clust) {   // Dyanmic directory table  
06C3E:  MOVF   xD8,F
06C40:  BNZ   6C4E
06C42:  MOVF   xD9,F
06C44:  BNZ   6C4E
06C46:  MOVF   xDA,F
06C48:  BNZ   6C4E
06C4A:  MOVF   xDB,F
06C4C:  BZ    6CAE
....................       scan->clust = clust; 
06C4E:  MOVLW  04
06C50:  ADDWF  xD6,W
06C52:  MOVWF  FE9
06C54:  MOVLW  00
06C56:  ADDWFC xD7,W
06C58:  MOVWF  FEA
06C5A:  MOVFF  9D8,FEF
06C5E:  MOVFF  9D9,FEC
06C62:  MOVFF  9DA,FEC
06C66:  MOVFF  9DB,FEC
....................       scan->sect = clust2sect(clust); 
06C6A:  MOVLW  08
06C6C:  ADDWF  xD6,W
06C6E:  MOVWF  01
06C70:  MOVLW  00
06C72:  ADDWFC xD7,W
06C74:  MOVWF  03
06C76:  MOVFF  01,9E4
06C7A:  MOVWF  xE5
06C7C:  MOVFF  9DB,9F2
06C80:  MOVFF  9DA,9F1
06C84:  MOVFF  9D9,9F0
06C88:  MOVFF  9D8,9EF
06C8C:  MOVLB  0
06C8E:  CALL   5636
06C92:  MOVFF  9E5,FEA
06C96:  MOVFF  9E4,FE9
06C9A:  MOVFF  00,FEF
06C9E:  MOVFF  01,FEC
06CA2:  MOVFF  02,FEC
06CA6:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06CAA:  BRA    6CF8
06CAC:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06CAE:  MOVLW  08
06CB0:  ADDWF  xD6,W
06CB2:  MOVWF  01
06CB4:  MOVLW  00
06CB6:  ADDWFC xD7,W
06CB8:  MOVWF  03
06CBA:  MOVFF  01,9E4
06CBE:  MOVWF  xE5
06CC0:  MOVLW  14
06CC2:  MOVLB  7
06CC4:  ADDWF  x12,W
06CC6:  MOVWF  FE9
06CC8:  MOVLW  00
06CCA:  ADDWFC x13,W
06CCC:  MOVWF  FEA
06CCE:  MOVFF  FEF,00
06CD2:  MOVFF  FEC,01
06CD6:  MOVFF  FEC,02
06CDA:  MOVFF  FEC,03
06CDE:  MOVFF  9E5,FEA
06CE2:  MOVFF  9E4,FE9
06CE6:  MOVFF  00,FEF
06CEA:  MOVFF  01,FEC
06CEE:  MOVFF  02,FEC
06CF2:  MOVFF  03,FEC
06CF6:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06CF8:  MOVLW  0C
06CFA:  MOVLB  9
06CFC:  ADDWF  xD6,W
06CFE:  MOVWF  FE9
06D00:  MOVLW  00
06D02:  ADDWFC xD7,W
06D04:  MOVWF  FEA
06D06:  CLRF   FEC
06D08:  MOVF   FED,F
06D0A:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06D0C:  MOVLW  08
06D0E:  ADDWF  xD6,W
06D10:  MOVWF  FE9
06D12:  MOVLW  00
06D14:  ADDWFC xD7,W
06D16:  MOVWF  FEA
06D18:  MOVFF  FEF,A14
06D1C:  MOVFF  FEC,A15
06D20:  MOVFF  FEC,A16
06D24:  MOVFF  FEC,A17
06D28:  MOVLB  0
06D2A:  CALL   5AAA
06D2E:  MOVF   01,F
06D30:  BNZ   6D3A
....................          return (NULL); 
06D32:  MOVLW  00
06D34:  MOVWF  01
06D36:  MOVWF  02
06D38:  BRA    6F68
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06D3A:  MOVLW  0C
06D3C:  MOVLB  9
06D3E:  ADDWF  xD6,W
06D40:  MOVWF  FE9
06D42:  MOVLW  00
06D44:  ADDWFC xD7,W
06D46:  MOVWF  FEA
06D48:  MOVFF  FEC,9E5
06D4C:  MOVF   FED,F
06D4E:  MOVFF  FEF,9E4
06D52:  MOVLW  0F
06D54:  ANDWF  xE4,F
06D56:  CLRF   xE5
06D58:  RLCF   xE4,F
06D5A:  RLCF   xE5,F
06D5C:  RLCF   xE4,F
06D5E:  RLCF   xE5,F
06D60:  RLCF   xE4,F
06D62:  RLCF   xE5,F
06D64:  RLCF   xE4,F
06D66:  RLCF   xE5,F
06D68:  RLCF   xE4,F
06D6A:  RLCF   xE5,F
06D6C:  MOVLW  E0
06D6E:  ANDWF  xE4,F
06D70:  MOVLW  24
06D72:  ADDWF  xE4,W
06D74:  MOVWF  01
06D76:  MOVLW  00
06D78:  ADDWFC xE5,W
06D7A:  MOVWF  03
06D7C:  MOVF   01,W
06D7E:  MOVLB  7
06D80:  ADDWF  x12,W
06D82:  MOVWF  01
06D84:  MOVF   x13,W
06D86:  ADDWFC 03,F
06D88:  MOVFF  01,9E2
06D8C:  MOVLB  9
06D8E:  MOVFF  03,9E3
....................       c = *dptr; 
06D92:  MOVFF  9E2,FE9
06D96:  MOVFF  9E3,FEA
06D9A:  MOVFF  FEF,9E0
....................       if ((c == 0) || (c == 0xE5))  
06D9E:  MOVF   xE0,F
06DA0:  BZ    6DA8
06DA2:  MOVF   xE0,W
06DA4:  SUBLW  E5
06DA6:  BNZ   6DB6
....................          return (dptr);      // Found an empty entry!  
06DA8:  MOVFF  9E2,01
06DAC:  MOVFF  9E3,02
06DB0:  MOVLB  0
06DB2:  BRA    6F68
06DB4:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06DB6:  MOVFF  9D7,9E6
06DBA:  MOVFF  9D6,9E5
06DBE:  MOVLB  0
06DC0:  CALL   6030
06DC4:  MOVF   01,F
06DC6:  BTFSC  FD8.2
06DC8:  BRA    6DCE
06DCA:  MOVLB  9
06DCC:  BRA    6D0C
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06DCE:  MOVLB  9
06DD0:  MOVF   xD8,F
06DD2:  BNZ   6DEC
06DD4:  MOVF   xD9,F
06DD6:  BNZ   6DEC
06DD8:  MOVF   xDA,F
06DDA:  BNZ   6DEC
06DDC:  MOVF   xDB,F
06DDE:  BNZ   6DEC
....................        return (NULL); 
06DE0:  MOVLW  00
06DE2:  MOVWF  01
06DE4:  MOVWF  02
06DE6:  MOVLB  0
06DE8:  BRA    6F68
06DEA:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06DEC:  MOVLW  04
06DEE:  ADDWF  xD6,W
06DF0:  MOVWF  FE9
06DF2:  MOVLW  00
06DF4:  ADDWFC xD7,W
06DF6:  MOVWF  FEA
06DF8:  MOVFF  FEF,9E8
06DFC:  MOVFF  FEC,9E9
06E00:  MOVFF  FEC,9EA
06E04:  MOVFF  FEC,9EB
06E08:  MOVLB  0
06E0A:  RCALL  698C
06E0C:  MOVFF  03,9DB
06E10:  MOVFF  02,9DA
06E14:  MOVFF  01,9D9
06E18:  MOVFF  00,9D8
....................    if (!(clust))  
06E1C:  MOVLB  9
06E1E:  MOVF   xD8,F
06E20:  BNZ   6E3A
06E22:  MOVF   xD9,F
06E24:  BNZ   6E3A
06E26:  MOVF   xDA,F
06E28:  BNZ   6E3A
06E2A:  MOVF   xDB,F
06E2C:  BNZ   6E3A
....................       return (NULL); 
06E2E:  MOVLW  00
06E30:  MOVWF  01
06E32:  MOVWF  02
06E34:  MOVLB  0
06E36:  BRA    6F68
06E38:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06E3A:  MOVLB  A
06E3C:  CLRF   x17
06E3E:  CLRF   x16
06E40:  CLRF   x15
06E42:  CLRF   x14
06E44:  MOVLB  0
06E46:  CALL   5AAA
06E4A:  MOVF   01,F
06E4C:  BNZ   6E56
....................       return (0); 
06E4E:  MOVLW  00
06E50:  MOVWF  01
06E52:  MOVWF  02
06E54:  BRA    6F68
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06E56:  MOVLW  20
06E58:  MOVLB  7
06E5A:  ADDWF  x12,W
06E5C:  MOVWF  01
06E5E:  MOVLW  00
06E60:  ADDWFC x13,W
06E62:  MOVWF  03
06E64:  MOVFF  01,9E4
06E68:  MOVLB  9
06E6A:  MOVWF  xE5
06E6C:  MOVFF  9DB,9F2
06E70:  MOVFF  9DA,9F1
06E74:  MOVFF  9D9,9F0
06E78:  MOVFF  9D8,9EF
06E7C:  MOVLB  0
06E7E:  CALL   5636
06E82:  MOVFF  03,9DF
06E86:  MOVFF  02,9DE
06E8A:  MOVFF  01,9DD
06E8E:  MOVFF  00,9DC
06E92:  MOVFF  9E5,FEA
06E96:  MOVFF  9E4,FE9
06E9A:  MOVFF  9DC,FEF
06E9E:  MOVFF  9DD,FEC
06EA2:  MOVFF  9DE,FEC
06EA6:  MOVFF  9DF,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06EAA:  MOVLW  24
06EAC:  MOVLB  7
06EAE:  ADDWF  x12,W
06EB0:  MOVWF  01
06EB2:  MOVLW  00
06EB4:  ADDWFC x13,W
06EB6:  MOVWF  03
06EB8:  MOVFF  01,9E4
06EBC:  MOVLB  9
06EBE:  MOVWF  xE5
06EC0:  MOVWF  FEA
06EC2:  MOVFF  01,FE9
06EC6:  CLRF   00
06EC8:  MOVLW  02
06ECA:  MOVWF  02
06ECC:  CLRF   01
06ECE:  MOVLB  0
06ED0:  CALL   354E
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06ED4:  MOVLW  02
06ED6:  MOVLB  7
06ED8:  ADDWF  x12,W
06EDA:  MOVWF  FE9
06EDC:  MOVLW  00
06EDE:  ADDWFC x13,W
06EE0:  MOVWF  FEA
06EE2:  MOVFF  FEF,9E1
06EE6:  MOVLB  9
06EE8:  MOVF   xE1,F
06EEA:  BZ    6F48
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06EEC:  MOVLW  24
06EEE:  MOVLB  7
06EF0:  ADDWF  x12,W
06EF2:  MOVWF  01
06EF4:  MOVLW  00
06EF6:  ADDWFC x13,W
06EF8:  MOVWF  03
06EFA:  MOVFF  01,9E4
06EFE:  MOVLB  9
06F00:  MOVWF  xE5
06F02:  MOVFF  FE8,A21
06F06:  MOVFF  01,A20
06F0A:  MOVFF  9DF,A25
06F0E:  MOVFF  9DE,A24
06F12:  MOVFF  9DD,A23
06F16:  MOVFF  9DC,A22
06F1A:  MOVLW  01
06F1C:  MOVLB  A
06F1E:  MOVWF  x26
06F20:  MOVLB  0
06F22:  CALL   5966
06F26:  MOVF   01,F
06F28:  BZ    6F32
....................          return (NULL); 
06F2A:  MOVLW  00
06F2C:  MOVWF  01
06F2E:  MOVWF  02
06F30:  BRA    6F68
....................       sector++; 
06F32:  MOVLW  01
06F34:  MOVLB  9
06F36:  ADDWF  xDC,F
06F38:  BTFSC  FD8.0
06F3A:  INCF   xDD,F
06F3C:  BTFSC  FD8.2
06F3E:  INCF   xDE,F
06F40:  BTFSC  FD8.2
06F42:  INCF   xDF,F
06F44:  DECF   xE1,F
06F46:  BRA    6EE8
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06F48:  MOVLW  06
06F4A:  MOVLB  7
06F4C:  ADDWF  x12,W
06F4E:  MOVWF  FE9
06F50:  MOVLW  00
06F52:  ADDWFC x13,W
06F54:  MOVWF  FEA
06F56:  MOVLW  01
06F58:  MOVWF  FEF
....................    return (fs->win); 
06F5A:  MOVLW  24
06F5C:  ADDWF  x12,W
06F5E:  MOVWF  01
06F60:  MOVLW  00
06F62:  ADDWFC x13,W
06F64:  MOVWF  03
06F66:  MOVWF  02
06F68:  MOVLB  0
06F6A:  GOTO   7202 (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
055D4:  MOVLB  7
055D6:  MOVF   x12,W
055D8:  IORWF  x13,W
055DA:  BNZ   55E2
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
055DC:  MOVLW  0B
055DE:  MOVWF  01
055E0:  BRA    5632
....................  
....................    if (disk_status() & STA_NOINIT)  
055E2:  MOVLB  0
055E4:  RCALL  55C6
055E6:  BTFSS  01.0
055E8:  BRA    5614
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
055EA:  MOVLW  01
055EC:  MOVLB  7
055EE:  ADDWF  x12,W
055F0:  MOVWF  FE9
055F2:  MOVLW  00
055F4:  ADDWFC x13,W
055F6:  MOVWF  FEA
055F8:  MOVF   FEF,F
055FA:  BZ    5604
....................          return (FR_INCORRECT_DISK_CHANGE); 
055FC:  MOVLW  09
055FE:  MOVWF  01
05600:  BRA    5632
05602:  BRA    5610
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
05604:  MOVLB  0
05606:  CALL   487E
0560A:  MOVF   01,W
0560C:  MOVLB  7
0560E:  BRA    5632
....................       }  
05610:  BRA    562E
05612:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
05614:  MOVLB  7
05616:  MOVFF  712,FE9
0561A:  MOVFF  713,FEA
0561E:  MOVF   FEF,F
05620:  BNZ   562E
....................          return (f_mountdrv());      // Initialize file system and return resulut  
05622:  MOVLB  0
05624:  CALL   487E
05628:  MOVF   01,W
0562A:  MOVLB  7
0562C:  BRA    5632
....................       } 
....................    return FR_OK;                  // File system is valid  
0562E:  MOVLW  00
05630:  MOVWF  01
05632:  MOVLB  0
05634:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B99E:  MOVLB  8
0B9A0:  MOVF   xCC,W
0B9A2:  XORLW  00
0B9A4:  MOVLB  0
0B9A6:  BZ    B9E0
0B9A8:  XORLW  04
0B9AA:  BZ    B9FC
0B9AC:  XORLW  05
0B9AE:  BZ    BA18
0B9B0:  XORLW  03
0B9B2:  BZ    BA34
0B9B4:  XORLW  01
0B9B6:  BZ    BA50
0B9B8:  XORLW  06
0B9BA:  BZ    BA6C
0B9BC:  XORLW  03
0B9BE:  BZ    BA88
0B9C0:  XORLW  01
0B9C2:  BTFSC  FD8.2
0B9C4:  BRA    BAA4
0B9C6:  XORLW  0E
0B9C8:  BTFSC  FD8.2
0B9CA:  BRA    BAC0
0B9CC:  XORLW  03
0B9CE:  BTFSC  FD8.2
0B9D0:  BRA    BADC
0B9D2:  XORLW  01
0B9D4:  BTFSC  FD8.2
0B9D6:  BRA    BAF8
0B9D8:  XORLW  07
0B9DA:  BTFSC  FD8.2
0B9DC:  BRA    BB14
0B9DE:  BRA    BB30
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B9E0:  MOVFF  8CE,FEA
0B9E4:  MOVFF  8CD,FE9
0B9E8:  MOVLW  00
0B9EA:  CALL   0106
0B9EE:  TBLRD*-
0B9F0:  TBLRD*+
0B9F2:  MOVF   FF5,W
0B9F4:  MOVWF  FEE
0B9F6:  IORLW  00
0B9F8:  BNZ   B9F0
....................          break; 
0B9FA:  BRA    BB4A
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B9FC:  MOVFF  8CE,FEA
0BA00:  MOVFF  8CD,FE9
0BA04:  MOVLW  00
0BA06:  CALL   0124
0BA0A:  TBLRD*-
0BA0C:  TBLRD*+
0BA0E:  MOVF   FF5,W
0BA10:  MOVWF  FEE
0BA12:  IORLW  00
0BA14:  BNZ   BA0C
....................          break; 
0BA16:  BRA    BB4A
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0BA18:  MOVFF  8CE,FEA
0BA1C:  MOVFF  8CD,FE9
0BA20:  MOVLW  00
0BA22:  CALL   014A
0BA26:  TBLRD*-
0BA28:  TBLRD*+
0BA2A:  MOVF   FF5,W
0BA2C:  MOVWF  FEE
0BA2E:  IORLW  00
0BA30:  BNZ   BA28
....................          break; 
0BA32:  BRA    BB4A
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0BA34:  MOVFF  8CE,FEA
0BA38:  MOVFF  8CD,FE9
0BA3C:  MOVLW  00
0BA3E:  CALL   016E
0BA42:  TBLRD*-
0BA44:  TBLRD*+
0BA46:  MOVF   FF5,W
0BA48:  MOVWF  FEE
0BA4A:  IORLW  00
0BA4C:  BNZ   BA44
....................          break; 
0BA4E:  BRA    BB4A
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0BA50:  MOVFF  8CE,FEA
0BA54:  MOVFF  8CD,FE9
0BA58:  MOVLW  00
0BA5A:  CALL   0192
0BA5E:  TBLRD*-
0BA60:  TBLRD*+
0BA62:  MOVF   FF5,W
0BA64:  MOVWF  FEE
0BA66:  IORLW  00
0BA68:  BNZ   BA60
....................          break; 
0BA6A:  BRA    BB4A
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0BA6C:  MOVFF  8CE,FEA
0BA70:  MOVFF  8CD,FE9
0BA74:  MOVLW  00
0BA76:  CALL   01B6
0BA7A:  TBLRD*-
0BA7C:  TBLRD*+
0BA7E:  MOVF   FF5,W
0BA80:  MOVWF  FEE
0BA82:  IORLW  00
0BA84:  BNZ   BA7C
....................          break; 
0BA86:  BRA    BB4A
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0BA88:  MOVFF  8CE,FEA
0BA8C:  MOVFF  8CD,FE9
0BA90:  MOVLW  00
0BA92:  CALL   01D8
0BA96:  TBLRD*-
0BA98:  TBLRD*+
0BA9A:  MOVF   FF5,W
0BA9C:  MOVWF  FEE
0BA9E:  IORLW  00
0BAA0:  BNZ   BA98
....................          break; 
0BAA2:  BRA    BB4A
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0BAA4:  MOVFF  8CE,FEA
0BAA8:  MOVFF  8CD,FE9
0BAAC:  MOVLW  00
0BAAE:  CALL   01F8
0BAB2:  TBLRD*-
0BAB4:  TBLRD*+
0BAB6:  MOVF   FF5,W
0BAB8:  MOVWF  FEE
0BABA:  IORLW  00
0BABC:  BNZ   BAB4
....................          break; 
0BABE:  BRA    BB4A
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0BAC0:  MOVFF  8CE,FEA
0BAC4:  MOVFF  8CD,FE9
0BAC8:  MOVLW  00
0BACA:  CALL   0216
0BACE:  TBLRD*-
0BAD0:  TBLRD*+
0BAD2:  MOVF   FF5,W
0BAD4:  MOVWF  FEE
0BAD6:  IORLW  00
0BAD8:  BNZ   BAD0
....................          break; 
0BADA:  BRA    BB4A
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0BADC:  MOVFF  8CE,FEA
0BAE0:  MOVFF  8CD,FE9
0BAE4:  MOVLW  00
0BAE6:  CALL   0242
0BAEA:  TBLRD*-
0BAEC:  TBLRD*+
0BAEE:  MOVF   FF5,W
0BAF0:  MOVWF  FEE
0BAF2:  IORLW  00
0BAF4:  BNZ   BAEC
....................          break; 
0BAF6:  BRA    BB4A
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0BAF8:  MOVFF  8CE,FEA
0BAFC:  MOVFF  8CD,FE9
0BB00:  MOVLW  00
0BB02:  CALL   0266
0BB06:  TBLRD*-
0BB08:  TBLRD*+
0BB0A:  MOVF   FF5,W
0BB0C:  MOVWF  FEE
0BB0E:  IORLW  00
0BB10:  BNZ   BB08
....................          break; 
0BB12:  BRA    BB4A
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0BB14:  MOVFF  8CE,FEA
0BB18:  MOVFF  8CD,FE9
0BB1C:  MOVLW  00
0BB1E:  CALL   028A
0BB22:  TBLRD*-
0BB24:  TBLRD*+
0BB26:  MOVF   FF5,W
0BB28:  MOVWF  FEE
0BB2A:  IORLW  00
0BB2C:  BNZ   BB24
....................          break; 
0BB2E:  BRA    BB4A
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0BB30:  MOVFF  8CE,FEA
0BB34:  MOVFF  8CD,FE9
0BB38:  MOVLW  00
0BB3A:  CALL   02AC
0BB3E:  TBLRD*-
0BB40:  TBLRD*+
0BB42:  MOVF   FF5,W
0BB44:  MOVWF  FEE
0BB46:  IORLW  00
0BB48:  BNZ   BB40
....................       } 
0BB4A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
0487E:  MOVLB  7
04880:  MOVF   x12,W
04882:  IORWF  x13,W
04884:  BNZ   488C
....................       return (FR_NOT_ENABLED); 
04886:  MOVLW  0B
04888:  MOVWF  01
0488A:  BRA    4E18
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
0488C:  MOVFF  713,FEA
04890:  MOVFF  712,FE9
04894:  CLRF   00
04896:  MOVLW  02
04898:  MOVWF  02
0489A:  MOVLW  24
0489C:  MOVWF  01
0489E:  MOVLB  0
048A0:  CALL   354E
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
048A4:  CALL   369E
048A8:  MOVFF  01,4ED
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
048AC:  MOVLB  4
048AE:  BTFSS  xED.0
048B0:  BRA    48BE
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
048B2:  MOVLB  0
048B4:  CALL   369E
048B8:  MOVFF  01,4ED
048BC:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
048BE:  BTFSS  xED.0
048C0:  BRA    48CC
048C2:  MOVLW  01
048C4:  MOVWF  01
048C6:  MOVLB  7
048C8:  BRA    4E18
048CA:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
048CC:  MOVLB  9
048CE:  CLRF   xDA
048D0:  CLRF   xD9
048D2:  CLRF   xD8
048D4:  CLRF   xD7
048D6:  MOVFF  9DA,9E6
048DA:  MOVFF  9D9,9E5
048DE:  MOVFF  9D8,9E4
048E2:  MOVFF  9D7,9E3
048E6:  MOVLB  0
048E8:  RCALL  46B8
048EA:  MOVFF  01,9D6
....................    if (!fat)  
048EE:  MOVLB  9
048F0:  MOVF   xD6,F
048F2:  BNZ   4962
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
048F4:  MOVLW  E6
048F6:  MOVLB  7
048F8:  ADDWF  x12,W
048FA:  MOVWF  FE9
048FC:  MOVLW  01
048FE:  ADDWFC x13,W
04900:  MOVWF  FEA
04902:  MOVF   FEF,F
04904:  BZ    4942
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
04906:  MOVLW  EA
04908:  ADDWF  x12,W
0490A:  MOVWF  01
0490C:  MOVLW  01
0490E:  ADDWFC x13,W
04910:  MOVFF  01,FE9
04914:  MOVWF  FEA
04916:  MOVFF  FEF,9D7
0491A:  MOVFF  FEC,9D8
0491E:  MOVFF  FEC,9D9
04922:  MOVFF  FEC,9DA
....................          fat = check_fs(sect);            // Check the partition  
04926:  MOVFF  9DA,9E6
0492A:  MOVFF  9D9,9E5
0492E:  MOVFF  9D8,9E4
04932:  MOVFF  9D7,9E3
04936:  MOVLB  0
04938:  RCALL  46B8
0493A:  MOVFF  01,9D6
....................          } 
0493E:  BRA    4960
04940:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
04942:  MOVLW  08
04944:  MOVWF  FF6
04946:  MOVLW  0C
04948:  MOVWF  FF7
0494A:  MOVLW  00
0494C:  MOVWF  FF8
0494E:  CLRF   1B
04950:  BTFSC  FF2.7
04952:  BSF    1B.7
04954:  BCF    FF2.7
04956:  MOVLB  0
04958:  CALL   0E6E
0495C:  BTFSC  1B.7
0495E:  BSF    FF2.7
04960:  MOVLB  9
....................       } 
....................    if (!fat)  
04962:  MOVF   xD6,F
04964:  BNZ   4970
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
04966:  MOVLW  0C
04968:  MOVWF  01
0496A:  MOVLB  7
0496C:  BRA    4E18
0496E:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
04970:  MOVLB  7
04972:  MOVFF  712,FE9
04976:  MOVFF  713,FEA
0497A:  MOVFF  9D6,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
0497E:  MOVLB  9
04980:  MOVF   xD6,W
04982:  SUBLW  03
04984:  BNZ   49EA
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
04986:  MOVLW  08
04988:  MOVLB  7
0498A:  ADDWF  x12,W
0498C:  MOVWF  01
0498E:  MOVLW  00
04990:  ADDWFC x13,W
04992:  MOVWF  03
04994:  MOVFF  01,9E3
04998:  MOVLB  9
0499A:  MOVWF  xE4
0499C:  MOVLW  48
0499E:  MOVLB  7
049A0:  ADDWF  x12,W
049A2:  MOVWF  01
049A4:  MOVLW  00
049A6:  ADDWFC x13,W
049A8:  MOVFF  01,FE9
049AC:  MOVWF  FEA
049AE:  MOVFF  FEF,00
049B2:  MOVFF  FEC,01
049B6:  MOVFF  FEC,02
049BA:  MOVFF  FEC,03
049BE:  MOVFF  03,9E8
049C2:  MOVFF  02,9E7
049C6:  MOVFF  01,9E6
049CA:  MOVFF  00,9E5
049CE:  MOVFF  9E4,FEA
049D2:  MOVFF  9E3,FE9
049D6:  MOVFF  00,FEF
049DA:  MOVFF  01,FEC
049DE:  MOVFF  02,FEC
049E2:  MOVFF  03,FEC
049E6:  BRA    4A42
049E8:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
049EA:  MOVLW  08
049EC:  MOVLB  7
049EE:  ADDWF  x12,W
049F0:  MOVWF  01
049F2:  MOVLW  00
049F4:  ADDWFC x13,W
049F6:  MOVWF  03
049F8:  MOVFF  01,9E3
049FC:  MOVLB  9
049FE:  MOVWF  xE4
04A00:  MOVLW  3A
04A02:  MOVLB  7
04A04:  ADDWF  x12,W
04A06:  MOVWF  01
04A08:  MOVLW  00
04A0A:  ADDWFC x13,W
04A0C:  MOVFF  01,FE9
04A10:  MOVWF  FEA
04A12:  MOVFF  FEC,03
04A16:  MOVF   FED,F
04A18:  MOVFF  FEF,9E5
04A1C:  MOVLB  9
04A1E:  MOVFF  03,9E6
04A22:  MOVFF  9E4,FEA
04A26:  MOVFF  9E3,FE9
04A2A:  MOVF   FEE,F
04A2C:  MOVF   FEE,F
04A2E:  CLRF   FEC
04A30:  MOVF   FED,F
04A32:  CLRF   FEF
04A34:  MOVF   FED,F
04A36:  MOVFF  03,FEF
04A3A:  MOVF   FED,F
04A3C:  MOVFF  9E5,FEF
04A40:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
04A42:  MOVLW  02
04A44:  ADDWF  x12,W
04A46:  MOVWF  01
04A48:  MOVLW  00
04A4A:  ADDWFC x13,W
04A4C:  MOVWF  03
04A4E:  MOVLW  31
04A50:  MOVLB  7
04A52:  ADDWF  x12,W
04A54:  MOVWF  FE9
04A56:  MOVLW  00
04A58:  ADDWFC x13,W
04A5A:  MOVWF  FEA
04A5C:  MOVFF  FEF,9E5
04A60:  MOVLB  9
04A62:  MOVFF  03,FEA
04A66:  MOVFF  01,FE9
04A6A:  MOVFF  9E5,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
04A6E:  MOVLW  03
04A70:  MOVLB  7
04A72:  ADDWF  x12,W
04A74:  MOVWF  01
04A76:  MOVLW  00
04A78:  ADDWFC x13,W
04A7A:  MOVWF  03
04A7C:  MOVLW  34
04A7E:  MOVLB  7
04A80:  ADDWF  x12,W
04A82:  MOVWF  FE9
04A84:  MOVLW  00
04A86:  ADDWFC x13,W
04A88:  MOVWF  FEA
04A8A:  MOVFF  FEF,9E5
04A8E:  MOVLB  9
04A90:  MOVFF  03,FEA
04A94:  MOVFF  01,FE9
04A98:  MOVFF  9E5,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
04A9C:  MOVLW  10
04A9E:  MOVLB  7
04AA0:  ADDWF  x12,W
04AA2:  MOVWF  01
04AA4:  MOVLW  00
04AA6:  ADDWFC x13,W
04AA8:  MOVWF  03
04AAA:  MOVFF  01,9E3
04AAE:  MOVLB  9
04AB0:  MOVWF  xE4
04AB2:  MOVLW  32
04AB4:  MOVLB  7
04AB6:  ADDWF  x12,W
04AB8:  MOVWF  01
04ABA:  MOVLW  00
04ABC:  ADDWFC x13,W
04ABE:  MOVFF  01,FE9
04AC2:  MOVWF  FEA
04AC4:  MOVFF  FEC,03
04AC8:  MOVF   FED,F
04ACA:  MOVF   FEF,W
04ACC:  MOVLB  9
04ACE:  ADDWF  xD7,W
04AD0:  MOVWF  00
04AD2:  MOVF   03,W
04AD4:  ADDWFC xD8,W
04AD6:  MOVWF  01
04AD8:  MOVLW  00
04ADA:  ADDWFC xD9,W
04ADC:  MOVWF  02
04ADE:  MOVLW  00
04AE0:  ADDWFC xDA,W
04AE2:  MOVFF  9E4,FEA
04AE6:  MOVFF  9E3,FE9
04AEA:  MOVFF  00,FEF
04AEE:  MOVFF  01,FEC
04AF2:  MOVFF  02,FEC
04AF6:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04AF8:  MOVLW  04
04AFA:  MOVLB  7
04AFC:  ADDWF  x12,W
04AFE:  MOVWF  01
04B00:  MOVLW  00
04B02:  ADDWFC x13,W
04B04:  MOVWF  03
04B06:  MOVFF  01,9E3
04B0A:  MOVLB  9
04B0C:  MOVWF  xE4
04B0E:  MOVLW  35
04B10:  MOVLB  7
04B12:  ADDWF  x12,W
04B14:  MOVWF  01
04B16:  MOVLW  00
04B18:  ADDWFC x13,W
04B1A:  MOVFF  01,FE9
04B1E:  MOVWF  FEA
04B20:  MOVFF  FEC,03
04B24:  MOVF   FED,F
04B26:  MOVFF  FEF,9E5
04B2A:  MOVLB  9
04B2C:  MOVFF  9E4,FEA
04B30:  MOVFF  9E3,FE9
04B34:  MOVFF  03,FEC
04B38:  MOVF   FED,F
04B3A:  MOVFF  9E5,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04B3E:  MOVLW  08
04B40:  MOVLB  7
04B42:  ADDWF  x12,W
04B44:  MOVWF  FE9
04B46:  MOVLW  00
04B48:  ADDWFC x13,W
04B4A:  MOVWF  FEA
04B4C:  MOVFF  FEF,9F6
04B50:  MOVFF  FEC,9F7
04B54:  MOVFF  FEC,9F8
04B58:  MOVFF  FEC,9F9
04B5C:  MOVLW  03
04B5E:  ADDWF  x12,W
04B60:  MOVWF  FE9
04B62:  MOVLW  00
04B64:  ADDWFC x13,W
04B66:  MOVWF  FEA
04B68:  MOVFF  FEF,9FA
04B6C:  MOVLB  9
04B6E:  MOVFF  FEA,9E9
04B72:  MOVFF  FE9,9E8
04B76:  CLRF   xFD
04B78:  CLRF   xFC
04B7A:  CLRF   xFB
04B7C:  MOVLB  0
04B7E:  RCALL  4818
04B80:  MOVFF  9E9,FEA
04B84:  MOVFF  9E8,FE9
04B88:  MOVFF  03,9E6
04B8C:  MOVFF  02,9E5
04B90:  MOVFF  01,9E4
04B94:  MOVFF  00,9E3
04B98:  MOVLW  10
04B9A:  MOVLB  7
04B9C:  ADDWF  x12,W
04B9E:  MOVWF  FE9
04BA0:  MOVLW  00
04BA2:  ADDWFC x13,W
04BA4:  MOVWF  FEA
04BA6:  MOVFF  FEF,00
04BAA:  MOVFF  FEC,01
04BAE:  MOVFF  FEC,02
04BB2:  MOVFF  FEC,03
04BB6:  MOVF   00,W
04BB8:  MOVLB  9
04BBA:  ADDWF  xE3,W
04BBC:  MOVWF  xDB
04BBE:  MOVF   01,W
04BC0:  ADDWFC xE4,W
04BC2:  MOVWF  xDC
04BC4:  MOVF   02,W
04BC6:  ADDWFC xE5,W
04BC8:  MOVWF  xDD
04BCA:  MOVF   03,W
04BCC:  ADDWFC xE6,W
04BCE:  MOVWF  xDE
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04BD0:  MOVF   xD6,W
04BD2:  SUBLW  03
04BD4:  BNZ   4C46
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04BD6:  MOVLW  14
04BD8:  MOVLB  7
04BDA:  ADDWF  x12,W
04BDC:  MOVWF  01
04BDE:  MOVLW  00
04BE0:  ADDWFC x13,W
04BE2:  MOVWF  03
04BE4:  MOVFF  01,9E3
04BE8:  MOVLB  9
04BEA:  MOVWF  xE4
04BEC:  MOVLW  50
04BEE:  MOVLB  7
04BF0:  ADDWF  x12,W
04BF2:  MOVWF  01
04BF4:  MOVLW  00
04BF6:  ADDWFC x13,W
04BF8:  MOVFF  01,FE9
04BFC:  MOVWF  FEA
04BFE:  MOVFF  FEF,00
04C02:  MOVFF  FEC,01
04C06:  MOVFF  FEC,02
04C0A:  MOVFF  FEC,03
04C0E:  MOVFF  9E4,FEA
04C12:  MOVFF  9E3,FE9
04C16:  MOVFF  00,FEF
04C1A:  MOVFF  01,FEC
04C1E:  MOVFF  02,FEC
04C22:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04C26:  MOVLW  18
04C28:  ADDWF  x12,W
04C2A:  MOVWF  FE9
04C2C:  MOVLW  00
04C2E:  ADDWFC x13,W
04C30:  MOVWF  FEA
04C32:  MOVFF  9DB,FEF
04C36:  MOVFF  9DC,FEC
04C3A:  MOVFF  9DD,FEC
04C3E:  MOVFF  9DE,FEC
....................       }  
04C42:  BRA    4CD2
04C44:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04C46:  MOVLW  14
04C48:  MOVLB  7
04C4A:  ADDWF  x12,W
04C4C:  MOVWF  FE9
04C4E:  MOVLW  00
04C50:  ADDWFC x13,W
04C52:  MOVWF  FEA
04C54:  MOVFF  9DB,FEF
04C58:  MOVFF  9DC,FEC
04C5C:  MOVFF  9DD,FEC
04C60:  MOVFF  9DE,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04C64:  MOVLW  18
04C66:  ADDWF  x12,W
04C68:  MOVWF  01
04C6A:  MOVLW  00
04C6C:  ADDWFC x13,W
04C6E:  MOVFF  01,9E3
04C72:  MOVLB  9
04C74:  MOVWF  xE4
04C76:  MOVLW  04
04C78:  MOVLB  7
04C7A:  ADDWF  x12,W
04C7C:  MOVWF  FE9
04C7E:  MOVLW  00
04C80:  ADDWFC x13,W
04C82:  MOVWF  FEA
04C84:  MOVFF  FEC,9E6
04C88:  MOVF   FED,F
04C8A:  MOVFF  FEF,9E5
04C8E:  MOVLB  9
04C90:  RRCF   xE6,F
04C92:  RRCF   xE5,F
04C94:  RRCF   xE6,F
04C96:  RRCF   xE5,F
04C98:  RRCF   xE6,F
04C9A:  RRCF   xE5,F
04C9C:  RRCF   xE6,F
04C9E:  RRCF   xE5,F
04CA0:  MOVLW  0F
04CA2:  ANDWF  xE6,F
04CA4:  MOVF   xE5,W
04CA6:  ADDWF  xDB,W
04CA8:  MOVWF  00
04CAA:  MOVF   xE6,W
04CAC:  ADDWFC xDC,W
04CAE:  MOVWF  01
04CB0:  MOVLW  00
04CB2:  ADDWFC xDD,W
04CB4:  MOVWF  02
04CB6:  MOVLW  00
04CB8:  ADDWFC xDE,W
04CBA:  MOVFF  9E4,FEA
04CBE:  MOVFF  9E3,FE9
04CC2:  MOVFF  00,FEF
04CC6:  MOVFF  01,FEC
04CCA:  MOVFF  02,FEC
04CCE:  MOVWF  FEC
04CD0:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04CD2:  MOVLW  44
04CD4:  ADDWF  x12,W
04CD6:  MOVWF  01
04CD8:  MOVLW  00
04CDA:  ADDWFC x13,W
04CDC:  MOVFF  01,FE9
04CE0:  MOVWF  FEA
04CE2:  MOVFF  FEF,9DF
04CE6:  MOVFF  FEC,9E0
04CEA:  MOVFF  FEC,9E1
04CEE:  MOVFF  FEC,9E2
....................    if (!maxsect)  
04CF2:  MOVLB  9
04CF4:  MOVF   xDF,F
04CF6:  BNZ   4D26
04CF8:  MOVF   xE0,F
04CFA:  BNZ   4D26
04CFC:  MOVF   xE1,F
04CFE:  BNZ   4D26
04D00:  MOVF   xE2,F
04D02:  BNZ   4D26
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04D04:  MOVLW  37
04D06:  MOVLB  7
04D08:  ADDWF  x12,W
04D0A:  MOVWF  01
04D0C:  MOVLW  00
04D0E:  ADDWFC x13,W
04D10:  MOVFF  01,FE9
04D14:  MOVWF  FEA
04D16:  MOVLB  9
04D18:  CLRF   xE2
04D1A:  CLRF   xE1
04D1C:  MOVFF  FEC,9E0
04D20:  MOVF   FED,F
04D22:  MOVFF  FEF,9DF
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04D26:  MOVLW  0C
04D28:  MOVLB  7
04D2A:  ADDWF  x12,W
04D2C:  MOVWF  01
04D2E:  MOVLW  00
04D30:  ADDWFC x13,W
04D32:  MOVWF  03
04D34:  MOVFF  01,9E3
04D38:  MOVLB  9
04D3A:  MOVWF  xE4
04D3C:  MOVLW  18
04D3E:  MOVLB  7
04D40:  ADDWF  x12,W
04D42:  MOVWF  FE9
04D44:  MOVLW  00
04D46:  ADDWFC x13,W
04D48:  MOVWF  FEA
04D4A:  MOVFF  FEF,00
04D4E:  MOVFF  FEC,01
04D52:  MOVFF  FEC,02
04D56:  MOVFF  FEC,03
04D5A:  MOVF   00,W
04D5C:  MOVLB  9
04D5E:  SUBWF  xDF,W
04D60:  MOVWF  xE5
04D62:  MOVF   01,W
04D64:  SUBWFB xE0,W
04D66:  MOVWF  xE6
04D68:  MOVF   02,W
04D6A:  SUBWFB xE1,W
04D6C:  MOVWF  xE7
04D6E:  MOVF   03,W
04D70:  SUBWFB xE2,W
04D72:  MOVWF  xE8
04D74:  MOVF   xD7,W
04D76:  ADDWF  xE5,F
04D78:  MOVF   xD8,W
04D7A:  ADDWFC xE6,F
04D7C:  MOVF   xD9,W
04D7E:  ADDWFC xE7,F
04D80:  MOVF   xDA,W
04D82:  ADDWFC xE8,F
04D84:  MOVLW  02
04D86:  MOVLB  7
04D88:  ADDWF  x12,W
04D8A:  MOVWF  FE9
04D8C:  MOVLW  00
04D8E:  ADDWFC x13,W
04D90:  MOVWF  FEA
04D92:  MOVFF  FEF,A50
04D96:  MOVLB  9
04D98:  MOVFF  FEA,9EB
04D9C:  MOVFF  FE9,9EA
04DA0:  BCF    FD8.1
04DA2:  CLRF   1B
04DA4:  BTFSC  FF2.7
04DA6:  BSF    1B.7
04DA8:  BCF    FF2.7
04DAA:  MOVFF  9E8,A4F
04DAE:  MOVFF  9E7,A4E
04DB2:  MOVFF  9E6,A4D
04DB6:  MOVFF  9E5,A4C
04DBA:  MOVLB  A
04DBC:  CLRF   x53
04DBE:  CLRF   x52
04DC0:  CLRF   x51
04DC2:  MOVLB  0
04DC4:  CALL   1076
04DC8:  BTFSC  1B.7
04DCA:  BSF    FF2.7
04DCC:  MOVFF  9EB,FEA
04DD0:  MOVFF  9EA,FE9
04DD4:  MOVFF  03,9E8
04DD8:  MOVFF  02,9E7
04DDC:  MOVFF  01,9E6
04DE0:  MOVFF  00,9E5
04DE4:  MOVLW  02
04DE6:  MOVLB  9
04DE8:  ADDWF  00,W
04DEA:  MOVWF  00
04DEC:  MOVLW  00
04DEE:  ADDWFC 01,W
04DF0:  MOVWF  01
04DF2:  MOVLW  00
04DF4:  ADDWFC 02,W
04DF6:  MOVWF  02
04DF8:  MOVLW  00
04DFA:  ADDWFC 03,W
04DFC:  MOVFF  9E4,FEA
04E00:  MOVFF  9E3,FE9
04E04:  MOVFF  00,FEF
04E08:  MOVFF  01,FEC
04E0C:  MOVFF  02,FEC
04E10:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04E12:  MOVLW  00
04E14:  MOVWF  01
04E16:  MOVLB  7
04E18:  MOVLB  0
04E1A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
07180:  CALL   55D4
07184:  MOVFF  01,9C3
....................    if (result != FR_OK)  
07188:  MOVLB  9
0718A:  MOVF   xC3,F
0718C:  BZ    7194
....................       return (result); 
0718E:  MOVFF  9C3,01
07192:  BRA    75C4
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
07194:  MOVF   xB4,W
07196:  ANDLW  0A
07198:  BZ    71B0
0719A:  MOVLB  0
0719C:  CALL   55C6
071A0:  BTFSC  01.2
071A2:  BRA    71A8
071A4:  MOVLB  9
071A6:  BRA    71B0
....................          return (FR_WRITE_PROTECTED); 
071A8:  MOVLW  0A
071AA:  MOVWF  01
071AC:  MOVLB  9
071AE:  BRA    75C4
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
071B0:  MOVLW  09
071B2:  MOVWF  xD7
071B4:  MOVLW  B5
071B6:  MOVWF  xD6
071B8:  MOVLW  09
071BA:  MOVWF  xD9
071BC:  MOVLW  C6
071BE:  MOVWF  xD8
071C0:  MOVFF  9B3,9DB
071C4:  MOVFF  9B2,9DA
071C8:  MOVLW  09
071CA:  MOVWF  xDD
071CC:  MOVLW  C4
071CE:  MOVWF  xDC
071D0:  MOVLB  0
071D2:  CALL   620A
071D6:  MOVFF  01,9C3
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
071DA:  MOVLB  9
071DC:  MOVF   xB4,W
071DE:  ANDLW  18
071E0:  BTFSC  FD8.2
071E2:  BRA    7406
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
071E4:  MOVF   xC3,F
071E6:  BZ    726E
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
071E8:  BSF    xB4.3
....................          if (result != FR_NO_FILE) 
071EA:  MOVF   xC3,W
071EC:  SUBLW  02
071EE:  BZ    71F6
....................             return (result); 
071F0:  MOVFF  9C3,01
071F4:  BRA    75C4
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
071F6:  MOVLW  09
071F8:  MOVWF  xD7
071FA:  MOVLW  B5
071FC:  MOVWF  xD6
071FE:  MOVLB  0
07200:  BRA    6C24
07202:  MOVFF  02,9C5
07206:  MOVFF  01,9C4
....................          if (dir_ptr == NULL) 
0720A:  MOVLB  9
0720C:  MOVF   xC4,F
0720E:  BNZ   721A
07210:  MOVF   xC5,F
07212:  BNZ   721A
....................             return (FR_DENIED); 
07214:  MOVLW  05
07216:  MOVWF  01
07218:  BRA    75C4
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
0721A:  MOVFF  9C5,FEA
0721E:  MOVFF  9C4,FE9
07222:  MOVLW  09
07224:  MOVWF  FE2
07226:  MOVLW  C6
07228:  MOVWF  FE1
0722A:  MOVLW  0B
0722C:  MOVWF  01
0722E:  MOVFF  FE6,FEE
07232:  DECFSZ 01,F
07234:  BRA    722E
....................          *(dir_ptr+12) = fn[11]; 
07236:  MOVLW  0C
07238:  ADDWF  xC4,W
0723A:  MOVWF  01
0723C:  MOVLW  00
0723E:  ADDWFC xC5,W
07240:  MOVFF  01,FE9
07244:  MOVWF  FEA
07246:  MOVFF  9D1,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
0724A:  MOVLW  0D
0724C:  ADDWF  xC4,W
0724E:  MOVWF  xD6
07250:  MOVLW  00
07252:  ADDWFC xC5,W
07254:  MOVWF  xD7
07256:  MOVWF  FEA
07258:  MOVFF  9D6,FE9
0725C:  CLRF   00
0725E:  CLRF   02
07260:  MOVLW  13
07262:  MOVWF  01
07264:  MOVLB  0
07266:  CALL   354E
....................       }  
0726A:  BRA    7380
0726C:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
0726E:  MOVF   xC4,F
07270:  BNZ   7276
07272:  MOVF   xC5,F
07274:  BZ    728E
07276:  MOVLW  0B
07278:  ADDWF  xC4,W
0727A:  MOVWF  01
0727C:  MOVLW  00
0727E:  ADDWFC xC5,W
07280:  MOVWF  03
07282:  MOVFF  01,FE9
07286:  MOVWF  FEA
07288:  MOVF   FEF,W
0728A:  ANDLW  11
0728C:  BZ    7294
....................             return (FR_DENIED); 
0728E:  MOVLW  05
07290:  MOVWF  01
07292:  BRA    75C4
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
07294:  BTFSS  xB4.3
07296:  BRA    737E
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
07298:  MOVLW  20
0729A:  MOVLB  7
0729C:  ADDWF  x12,W
0729E:  MOVWF  FE9
072A0:  MOVLW  00
072A2:  ADDWFC x13,W
072A4:  MOVWF  FEA
072A6:  MOVFF  FEF,9D2
072AA:  MOVFF  FEC,9D3
072AE:  MOVFF  FEC,9D4
072B2:  MOVFF  FEC,9D5
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
072B6:  MOVLW  14
072B8:  MOVLB  9
072BA:  ADDWF  xC4,W
072BC:  MOVWF  01
072BE:  MOVLW  00
072C0:  ADDWFC xC5,W
072C2:  MOVWF  03
072C4:  MOVFF  01,FE9
072C8:  MOVWF  FEA
072CA:  MOVFF  FEC,9DE
072CE:  MOVF   FED,F
072D0:  MOVFF  FEF,9D6
072D4:  CLRF   xD8
072D6:  MOVFF  9D6,9DD
072DA:  CLRF   xD6
072DC:  CLRF   xD7
072DE:  MOVLW  1A
072E0:  ADDWF  xC4,W
072E2:  MOVWF  01
072E4:  MOVLW  00
072E6:  ADDWFC xC5,W
072E8:  MOVFF  01,FE9
072EC:  MOVWF  FEA
072EE:  MOVFF  FEC,03
072F2:  MOVF   FED,F
072F4:  MOVF   FEF,W
072F6:  IORWF  xD6,F
072F8:  MOVF   03,W
072FA:  IORWF  xD7,F
072FC:  MOVFF  9D7,9DC
07300:  MOVFF  9D6,9DB
07304:  MOVLB  0
07306:  RCALL  6F6E
07308:  MOVF   01,F
0730A:  BZ    7324
0730C:  MOVFF  9D5,A17
07310:  MOVFF  9D4,A16
07314:  MOVFF  9D3,A15
07318:  MOVFF  9D2,A14
0731C:  CALL   5AAA
07320:  MOVF   01,F
07322:  BNZ   732E
....................                return (FR_RW_ERROR); 
07324:  MOVLW  07
07326:  MOVWF  01
07328:  MOVLB  9
0732A:  BRA    75C4
0732C:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
0732E:  MOVLW  14
07330:  MOVLB  9
07332:  ADDWF  xC4,W
07334:  MOVWF  01
07336:  MOVLW  00
07338:  ADDWFC xC5,W
0733A:  MOVFF  01,FE9
0733E:  MOVWF  FEA
07340:  CLRF   FEC
07342:  MOVF   FED,F
07344:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
07346:  MOVLW  1A
07348:  ADDWF  xC4,W
0734A:  MOVWF  01
0734C:  MOVLW  00
0734E:  ADDWFC xC5,W
07350:  MOVFF  01,FE9
07354:  MOVWF  FEA
07356:  CLRF   FEC
07358:  MOVF   FED,F
0735A:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
0735C:  MOVLW  1C
0735E:  ADDWF  xC4,W
07360:  MOVWF  01
07362:  MOVLW  00
07364:  ADDWFC xC5,W
07366:  MOVFF  01,FE9
0736A:  MOVWF  FEA
0736C:  MOVF   FEE,F
0736E:  MOVF   FEE,F
07370:  CLRF   FEC
07372:  MOVF   FED,F
07374:  CLRF   FEF
07376:  MOVF   FED,F
07378:  CLRF   FEF
0737A:  MOVF   FED,F
0737C:  CLRF   FEF
0737E:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
07380:  MOVLB  9
07382:  BTFSS  xB4.3
07384:  BRA    7404
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
07386:  MOVLW  0B
07388:  ADDWF  xC4,W
0738A:  MOVWF  01
0738C:  MOVLW  00
0738E:  ADDWFC xC5,W
07390:  MOVFF  01,FE9
07394:  MOVWF  FEA
07396:  MOVLW  20
07398:  MOVWF  FEF
....................          dw = get_fattime(); 
0739A:  MOVLB  0
0739C:  RCALL  7010
0739E:  MOVFF  03,9D5
073A2:  MOVFF  02,9D4
073A6:  MOVFF  01,9D3
073AA:  MOVFF  00,9D2
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
073AE:  MOVLW  0E
073B0:  MOVLB  9
073B2:  ADDWF  xC4,W
073B4:  MOVWF  01
073B6:  MOVLW  00
073B8:  ADDWFC xC5,W
073BA:  MOVFF  01,FE9
073BE:  MOVWF  FEA
073C0:  MOVFF  9D2,FEF
073C4:  MOVFF  9D3,FEC
073C8:  MOVFF  9D4,FEC
073CC:  MOVFF  9D5,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
073D0:  MOVLW  16
073D2:  ADDWF  xC4,W
073D4:  MOVWF  01
073D6:  MOVLW  00
073D8:  ADDWFC xC5,W
073DA:  MOVFF  01,FE9
073DE:  MOVWF  FEA
073E0:  MOVFF  9D2,FEF
073E4:  MOVFF  9D3,FEC
073E8:  MOVFF  9D4,FEC
073EC:  MOVFF  9D5,FEC
....................          fs->winflag = 1; 
073F0:  MOVLW  06
073F2:  MOVLB  7
073F4:  ADDWF  x12,W
073F6:  MOVWF  FE9
073F8:  MOVLW  00
073FA:  ADDWFC x13,W
073FC:  MOVWF  FEA
073FE:  MOVLW  01
07400:  MOVWF  FEF
07402:  MOVLB  9
....................       } 
....................    } 
07404:  BRA    7454
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
07406:  MOVF   xC3,F
07408:  BZ    7410
....................          return (result);      // Trace failed  
0740A:  MOVFF  9C3,01
0740E:  BRA    75C4
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
07410:  MOVF   xC4,F
07412:  BNZ   7418
07414:  MOVF   xC5,F
07416:  BZ    742E
07418:  MOVLW  0B
0741A:  ADDWF  xC4,W
0741C:  MOVWF  01
0741E:  MOVLW  00
07420:  ADDWFC xC5,W
07422:  MOVWF  03
07424:  MOVFF  01,FE9
07428:  MOVWF  FEA
0742A:  BTFSS  FEF.4
0742C:  BRA    7434
....................          return (FR_NO_FILE); 
0742E:  MOVLW  02
07430:  MOVWF  01
07432:  BRA    75C4
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
07434:  BTFSS  xB4.1
07436:  BRA    7454
07438:  MOVLW  0B
0743A:  ADDWF  xC4,W
0743C:  MOVWF  01
0743E:  MOVLW  00
07440:  ADDWFC xC5,W
07442:  MOVWF  03
07444:  MOVFF  01,FE9
07448:  MOVWF  FEA
0744A:  BTFSS  FEF.0
0744C:  BRA    7454
....................          return (FR_DENIED); 
0744E:  MOVLW  05
07450:  MOVWF  01
07452:  BRA    75C4
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
07454:  MOVLW  1A
07456:  ADDWF  xB0,W
07458:  MOVWF  FE9
0745A:  MOVLW  00
0745C:  ADDWFC xB1,W
0745E:  MOVWF  FEA
07460:  MOVF   xB4,W
07462:  ANDLW  03
07464:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
07466:  MOVLW  14
07468:  ADDWF  xB0,W
0746A:  MOVWF  01
0746C:  MOVLW  00
0746E:  ADDWFC xB1,W
07470:  MOVWF  03
07472:  MOVFF  01,9D6
07476:  MOVWF  xD7
07478:  MOVLW  20
0747A:  MOVLB  7
0747C:  ADDWF  x12,W
0747E:  MOVWF  FE9
07480:  MOVLW  00
07482:  ADDWFC x13,W
07484:  MOVWF  FEA
07486:  MOVFF  FEF,00
0748A:  MOVFF  FEC,01
0748E:  MOVFF  FEC,02
07492:  MOVFF  FEC,03
07496:  MOVFF  9D7,FEA
0749A:  MOVFF  9D6,FE9
0749E:  MOVFF  00,FEF
074A2:  MOVFF  01,FEC
074A6:  MOVFF  02,FEC
074AA:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
074AE:  MOVLW  18
074B0:  MOVLB  9
074B2:  ADDWF  xB0,W
074B4:  MOVWF  FE9
074B6:  MOVLW  00
074B8:  ADDWFC xB1,W
074BA:  MOVWF  FEA
074BC:  MOVFF  9C5,FEC
074C0:  MOVF   FED,F
074C2:  MOVFF  9C4,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
074C6:  MOVLW  08
074C8:  ADDWF  xB0,W
074CA:  MOVWF  01
074CC:  MOVLW  00
074CE:  ADDWFC xB1,W
074D0:  MOVWF  03
074D2:  MOVFF  01,9D6
074D6:  MOVWF  xD7
074D8:  MOVLW  14
074DA:  ADDWF  xC4,W
074DC:  MOVWF  01
074DE:  MOVLW  00
074E0:  ADDWFC xC5,W
074E2:  MOVWF  03
074E4:  MOVFF  01,FE9
074E8:  MOVWF  FEA
074EA:  MOVFF  FEC,9DB
074EE:  MOVF   FED,F
074F0:  MOVFF  FEF,9D8
074F4:  CLRF   xDA
074F6:  MOVFF  9D8,9DA
074FA:  CLRF   xD8
074FC:  CLRF   xD9
074FE:  MOVLW  1A
07500:  ADDWF  xC4,W
07502:  MOVWF  01
07504:  MOVLW  00
07506:  ADDWFC xC5,W
07508:  MOVFF  01,FE9
0750C:  MOVWF  FEA
0750E:  MOVFF  FEC,03
07512:  MOVF   FED,F
07514:  MOVF   FEF,W
07516:  IORWF  xD8,W
07518:  MOVWF  00
0751A:  MOVF   03,W
0751C:  IORWF  xD9,W
0751E:  MOVFF  9DA,02
07522:  MOVFF  9DB,03
07526:  MOVFF  9D7,FEA
0752A:  MOVFF  9D6,FE9
0752E:  MOVFF  00,FEF
07532:  MOVWF  FEC
07534:  MOVFF  9DA,FEC
07538:  MOVFF  9DB,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
0753C:  MOVLW  04
0753E:  ADDWF  xB0,W
07540:  MOVWF  01
07542:  MOVLW  00
07544:  ADDWFC xB1,W
07546:  MOVWF  03
07548:  MOVFF  01,9D6
0754C:  MOVWF  xD7
0754E:  MOVLW  1C
07550:  ADDWF  xC4,W
07552:  MOVWF  01
07554:  MOVLW  00
07556:  ADDWFC xC5,W
07558:  MOVFF  01,FE9
0755C:  MOVWF  FEA
0755E:  MOVFF  FEF,00
07562:  MOVFF  FEC,01
07566:  MOVFF  FEC,02
0756A:  MOVFF  FEC,03
0756E:  MOVFF  9D7,FEA
07572:  MOVFF  9D6,FE9
07576:  MOVFF  00,FEF
0757A:  MOVFF  01,FEC
0757E:  MOVFF  02,FEC
07582:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
07586:  MOVFF  9B0,FE9
0758A:  MOVFF  9B1,FEA
0758E:  MOVF   FEE,F
07590:  MOVF   FEE,F
07592:  CLRF   FEC
07594:  MOVF   FED,F
07596:  CLRF   FEF
07598:  MOVF   FED,F
0759A:  CLRF   FEF
0759C:  MOVF   FED,F
0759E:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
075A0:  MOVLW  1B
075A2:  ADDWF  xB0,W
075A4:  MOVWF  FE9
075A6:  MOVLW  00
075A8:  ADDWFC xB1,W
075AA:  MOVWF  FEA
075AC:  MOVLW  01
075AE:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
075B0:  MOVLB  7
075B2:  ADDWF  x12,W
075B4:  MOVWF  FE9
075B6:  MOVLW  00
075B8:  ADDWFC x13,W
075BA:  MOVWF  FEA
075BC:  INCF   FEF,F
....................    return (FR_OK); 
075BE:  MOVLW  00
075C0:  MOVWF  01
075C2:  MOVLB  9
075C4:  MOVLB  0
075C6:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B490:  MOVFF  8CF,8E4
0B494:  MOVFF  8CE,8E3
....................       *br = 0; 
0B498:  MOVLB  8
0B49A:  MOVFF  8D2,FE9
0B49E:  MOVFF  8D3,FEA
0B4A2:  CLRF   FEC
0B4A4:  MOVF   FED,F
0B4A6:  CLRF   FEF
....................       if (!fs)  
0B4A8:  MOVLB  7
0B4AA:  MOVF   x12,W
0B4AC:  IORWF  x13,W
0B4AE:  BNZ   B4B6
....................          return (FR_NOT_ENABLED); 
0B4B0:  MOVLW  0B
0B4B2:  MOVWF  01
0B4B4:  BRA    B998
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B4B6:  MOVLB  0
0B4B8:  CALL   55C6
0B4BC:  BTFSC  01.0
0B4BE:  BRA    B4D0
0B4C0:  MOVLB  7
0B4C2:  MOVFF  712,FE9
0B4C6:  MOVFF  713,FEA
0B4CA:  MOVF   FEF,F
0B4CC:  BNZ   B4D8
0B4CE:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B4D0:  MOVLW  01
0B4D2:  MOVWF  01
0B4D4:  MOVLB  7
0B4D6:  BRA    B998
....................     
....................       if (fp->flag & FA__ERROR) 
0B4D8:  MOVLW  1A
0B4DA:  MOVLB  8
0B4DC:  ADDWF  xCC,W
0B4DE:  MOVWF  FE9
0B4E0:  MOVLW  00
0B4E2:  ADDWFC xCD,W
0B4E4:  MOVWF  FEA
0B4E6:  BTFSS  FEF.7
0B4E8:  BRA    B4F4
....................          return (FR_RW_ERROR);   // Check error flag  
0B4EA:  MOVLW  07
0B4EC:  MOVWF  01
0B4EE:  MOVLB  7
0B4F0:  BRA    B998
0B4F2:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B4F4:  MOVLW  1A
0B4F6:  ADDWF  xCC,W
0B4F8:  MOVWF  FE9
0B4FA:  MOVLW  00
0B4FC:  ADDWFC xCD,W
0B4FE:  MOVWF  FEA
0B500:  BTFSC  FEF.0
0B502:  BRA    B50E
....................          return (FR_DENIED);      // Check access mode  
0B504:  MOVLW  05
0B506:  MOVWF  01
0B508:  MOVLB  7
0B50A:  BRA    B998
0B50C:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B50E:  MOVLW  04
0B510:  ADDWF  xCC,W
0B512:  MOVWF  FE9
0B514:  MOVLW  00
0B516:  ADDWFC xCD,W
0B518:  MOVWF  FEA
0B51A:  MOVFF  FEF,8E5
0B51E:  MOVFF  FEC,8E6
0B522:  MOVFF  FEC,8E7
0B526:  MOVFF  FEC,8E8
0B52A:  MOVFF  8CC,FE9
0B52E:  MOVFF  8CD,FEA
0B532:  MOVFF  FEF,00
0B536:  MOVFF  FEC,01
0B53A:  MOVFF  FEC,02
0B53E:  MOVFF  FEC,03
0B542:  MOVF   00,W
0B544:  SUBWF  xE5,W
0B546:  MOVWF  xDC
0B548:  MOVF   01,W
0B54A:  SUBWFB xE6,W
0B54C:  MOVWF  xDD
0B54E:  MOVF   02,W
0B550:  SUBWFB xE7,W
0B552:  MOVWF  xDE
0B554:  MOVF   03,W
0B556:  SUBWFB xE8,W
0B558:  MOVWF  xDF
....................       if (btr > ln) 
0B55A:  MOVF   xDF,F
0B55C:  BNZ   B578
0B55E:  MOVF   xDE,F
0B560:  BNZ   B578
0B562:  MOVF   xDD,W
0B564:  SUBWF  xD1,W
0B566:  BNC   B578
0B568:  BNZ   B570
0B56A:  MOVF   xD0,W
0B56C:  SUBWF  xDC,W
0B56E:  BC    B578
....................          btr = ln;            // Truncate read count by number of bytes left  
0B570:  MOVFF  8DD,8D1
0B574:  MOVFF  8DC,8D0
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B578:  MOVF   xD0,W
0B57A:  IORWF  xD1,W
0B57C:  BTFSC  FD8.2
0B57E:  BRA    B976
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B580:  MOVFF  8CC,FE9
0B584:  MOVFF  8CD,FEA
0B588:  MOVFF  FEF,8E5
0B58C:  MOVFF  FEC,8E6
0B590:  MOVFF  FEC,8E7
0B594:  MOVFF  FEC,8E8
0B598:  MOVLW  01
0B59A:  ANDWF  xE6,F
0B59C:  CLRF   xE7
0B59E:  CLRF   xE8
0B5A0:  MOVF   xE5,F
0B5A2:  BTFSS  FD8.2
0B5A4:  BRA    B81E
0B5A6:  MOVF   xE6,F
0B5A8:  BTFSS  FD8.2
0B5AA:  BRA    B81E
0B5AC:  MOVF   xE7,F
0B5AE:  BTFSS  FD8.2
0B5B0:  BRA    B81E
0B5B2:  MOVF   xE8,F
0B5B4:  BTFSS  FD8.2
0B5B6:  BRA    B81E
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B5B8:  MOVLW  1B
0B5BA:  ADDWF  xCC,W
0B5BC:  MOVWF  FE9
0B5BE:  MOVLW  00
0B5C0:  ADDWFC xCD,W
0B5C2:  MOVWF  FEA
0B5C4:  DECF   FEF,F
0B5C6:  BZ    B5FE
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B5C8:  MOVLW  10
0B5CA:  ADDWF  xCC,W
0B5CC:  MOVWF  FE9
0B5CE:  MOVLW  00
0B5D0:  ADDWFC xCD,W
0B5D2:  MOVWF  FEA
0B5D4:  MOVFF  FEF,8E5
0B5D8:  MOVFF  FEC,8E6
0B5DC:  MOVFF  FEC,8E7
0B5E0:  MOVFF  FEC,8E8
0B5E4:  MOVLW  01
0B5E6:  ADDWF  xE5,W
0B5E8:  MOVWF  xD8
0B5EA:  MOVLW  00
0B5EC:  ADDWFC xE6,W
0B5EE:  MOVWF  xD9
0B5F0:  MOVLW  00
0B5F2:  ADDWFC xE7,W
0B5F4:  MOVWF  xDA
0B5F6:  MOVLW  00
0B5F8:  ADDWFC xE8,W
0B5FA:  MOVWF  xDB
....................                }  
0B5FC:  BRA    B73A
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B5FE:  MOVFF  8CC,FE9
0B602:  MOVFF  8CD,FEA
0B606:  MOVFF  FEF,8E5
0B60A:  MOVFF  FEC,8E6
0B60E:  MOVFF  FEC,8E7
0B612:  MOVFF  FEC,8E8
0B616:  MOVF   xE5,F
0B618:  BNZ   B644
0B61A:  MOVF   xE6,F
0B61C:  BNZ   B644
0B61E:  MOVF   xE7,F
0B620:  BNZ   B644
0B622:  MOVF   xE8,F
0B624:  BNZ   B644
0B626:  MOVLW  08
0B628:  ADDWF  xCC,W
0B62A:  MOVWF  FE9
0B62C:  MOVLW  00
0B62E:  ADDWFC xCD,W
0B630:  MOVWF  FEA
0B632:  MOVFF  FEF,00
0B636:  MOVFF  FEC,01
0B63A:  MOVFF  FEC,02
0B63E:  MOVFF  FEC,03
0B642:  BRA    B668
0B644:  MOVLW  0C
0B646:  ADDWF  xCC,W
0B648:  MOVWF  FE9
0B64A:  MOVLW  00
0B64C:  ADDWFC xCD,W
0B64E:  MOVWF  FEA
0B650:  MOVFF  FEF,9FC
0B654:  MOVFF  FEC,9FD
0B658:  MOVFF  FEC,9FE
0B65C:  MOVFF  FEC,9FF
0B660:  MOVLB  0
0B662:  CALL   5CE2
0B666:  MOVLB  8
0B668:  MOVFF  03,8D7
0B66C:  MOVFF  02,8D6
0B670:  MOVFF  01,8D5
0B674:  MOVFF  00,8D4
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B678:  MOVF   xD7,F
0B67A:  BNZ   B68A
0B67C:  MOVF   xD6,F
0B67E:  BNZ   B68A
0B680:  MOVF   xD5,F
0B682:  BNZ   B68A
0B684:  MOVF   xD4,W
0B686:  SUBLW  01
0B688:  BC    B6C8
0B68A:  MOVLW  0C
0B68C:  MOVLB  7
0B68E:  ADDWF  x12,W
0B690:  MOVWF  FE9
0B692:  MOVLW  00
0B694:  ADDWFC x13,W
0B696:  MOVWF  FEA
0B698:  MOVFF  FEF,00
0B69C:  MOVFF  FEC,01
0B6A0:  MOVFF  FEC,02
0B6A4:  MOVFF  FEC,03
0B6A8:  MOVF   03,W
0B6AA:  MOVLB  8
0B6AC:  SUBWF  xD7,W
0B6AE:  BNC   B6CA
0B6B0:  BNZ   B6C8
0B6B2:  MOVF   02,W
0B6B4:  SUBWF  xD6,W
0B6B6:  BNC   B6CA
0B6B8:  BNZ   B6C8
0B6BA:  MOVF   01,W
0B6BC:  SUBWF  xD5,W
0B6BE:  BNC   B6CA
0B6C0:  BNZ   B6C8
0B6C2:  MOVF   00,W
0B6C4:  SUBWF  xD4,W
0B6C6:  BNC   B6CA
....................                   goto fr_error; 
0B6C8:  BRA    B980
....................                fp->curr_clust = clust;            // Current cluster  
0B6CA:  MOVLW  0C
0B6CC:  ADDWF  xCC,W
0B6CE:  MOVWF  FE9
0B6D0:  MOVLW  00
0B6D2:  ADDWFC xCD,W
0B6D4:  MOVWF  FEA
0B6D6:  MOVFF  8D4,FEF
0B6DA:  MOVFF  8D5,FEC
0B6DE:  MOVFF  8D6,FEC
0B6E2:  MOVFF  8D7,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B6E6:  MOVFF  8D7,9F2
0B6EA:  MOVFF  8D6,9F1
0B6EE:  MOVFF  8D5,9F0
0B6F2:  MOVFF  8D4,9EF
0B6F6:  MOVLB  0
0B6F8:  CALL   5636
0B6FC:  MOVFF  03,8DB
0B700:  MOVFF  02,8DA
0B704:  MOVFF  01,8D9
0B708:  MOVFF  00,8D8
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B70C:  MOVLW  1B
0B70E:  MOVLB  8
0B710:  ADDWF  xCC,W
0B712:  MOVWF  01
0B714:  MOVLW  00
0B716:  ADDWFC xCD,W
0B718:  MOVWF  03
0B71A:  MOVLW  02
0B71C:  MOVLB  7
0B71E:  ADDWF  x12,W
0B720:  MOVWF  FE9
0B722:  MOVLW  00
0B724:  ADDWFC x13,W
0B726:  MOVWF  FEA
0B728:  MOVFF  FEF,8E7
0B72C:  MOVLB  8
0B72E:  MOVFF  03,FEA
0B732:  MOVFF  01,FE9
0B736:  MOVFF  8E7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B73A:  MOVLW  10
0B73C:  ADDWF  xCC,W
0B73E:  MOVWF  FE9
0B740:  MOVLW  00
0B742:  ADDWFC xCD,W
0B744:  MOVWF  FEA
0B746:  MOVFF  8D8,FEF
0B74A:  MOVFF  8D9,FEC
0B74E:  MOVFF  8DA,FEC
0B752:  MOVFF  8DB,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B756:  BCF    FD8.0
0B758:  RRCF   xD1,W
0B75A:  MOVWF  xE2
....................             if (cc)  
0B75C:  MOVF   xE2,F
0B75E:  BZ    B81E
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B760:  MOVLW  1B
0B762:  ADDWF  xCC,W
0B764:  MOVWF  FE9
0B766:  MOVLW  00
0B768:  ADDWFC xCD,W
0B76A:  MOVWF  FEA
0B76C:  MOVF   FEF,W
0B76E:  SUBWF  xE2,W
0B770:  BZ    B784
0B772:  BNC   B784
....................                   cc = fp->sect_clust; 
0B774:  MOVLW  1B
0B776:  ADDWF  xCC,W
0B778:  MOVWF  FE9
0B77A:  MOVLW  00
0B77C:  ADDWFC xCD,W
0B77E:  MOVWF  FEA
0B780:  MOVFF  FEF,8E2
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B784:  MOVFF  8E4,A21
0B788:  MOVFF  8E3,A20
0B78C:  MOVFF  8DB,A25
0B790:  MOVFF  8DA,A24
0B794:  MOVFF  8D9,A23
0B798:  MOVFF  8D8,A22
0B79C:  MOVFF  8E2,A26
0B7A0:  MOVLB  0
0B7A2:  CALL   44F4
0B7A6:  MOVF   01,F
0B7A8:  BZ    B7B0
....................                   goto fr_error; 
0B7AA:  MOVLB  8
0B7AC:  BRA    B980
0B7AE:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B7B0:  MOVLW  1B
0B7B2:  MOVLB  8
0B7B4:  ADDWF  xCC,W
0B7B6:  MOVWF  FE9
0B7B8:  MOVLW  00
0B7BA:  ADDWFC xCD,W
0B7BC:  MOVWF  FEA
0B7BE:  MOVLW  01
0B7C0:  SUBWF  xE2,W
0B7C2:  SUBWF  FEF,W
0B7C4:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B7C6:  MOVLW  10
0B7C8:  ADDWF  xCC,W
0B7CA:  MOVWF  FE9
0B7CC:  MOVLW  00
0B7CE:  ADDWFC xCD,W
0B7D0:  MOVWF  FEA
0B7D2:  MOVLW  01
0B7D4:  SUBWF  xE2,W
0B7D6:  ADDWF  FEF,W
0B7D8:  MOVWF  00
0B7DA:  MOVLW  00
0B7DC:  ADDWFC FEC,W
0B7DE:  MOVWF  01
0B7E0:  MOVLW  00
0B7E2:  ADDWFC FEC,W
0B7E4:  MOVWF  02
0B7E6:  MOVLW  00
0B7E8:  ADDWFC FEC,W
0B7EA:  MOVF   FED,F
0B7EC:  MOVF   FED,F
0B7EE:  MOVF   FED,F
0B7F0:  MOVFF  00,FEF
0B7F4:  MOVFF  01,FEC
0B7F8:  MOVFF  02,FEC
0B7FC:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B7FE:  MOVLB  A
0B800:  CLRF   x11
0B802:  MOVFF  8E2,A10
0B806:  MOVLW  02
0B808:  MOVWF  x13
0B80A:  CLRF   x12
0B80C:  MOVLB  0
0B80E:  CALL   5CC0
0B812:  MOVFF  02,8E1
0B816:  MOVFF  01,8E0
....................                continue; 
0B81A:  BRA    B912
0B81C:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B81E:  MOVLW  10
0B820:  ADDWF  xCC,W
0B822:  MOVWF  FE9
0B824:  MOVLW  00
0B826:  ADDWFC xCD,W
0B828:  MOVWF  FEA
0B82A:  MOVFF  FEF,A14
0B82E:  MOVFF  FEC,A15
0B832:  MOVFF  FEC,A16
0B836:  MOVFF  FEC,A17
0B83A:  MOVLB  0
0B83C:  CALL   5AAA
0B840:  MOVF   01,F
0B842:  BNZ   B84A
....................                goto fr_error; 
0B844:  MOVLB  8
0B846:  BRA    B980
0B848:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B84A:  MOVLB  8
0B84C:  MOVFF  8CC,FE9
0B850:  MOVFF  8CD,FEA
0B854:  MOVFF  FEF,8E5
0B858:  MOVFF  FEC,8E6
0B85C:  MOVFF  FEC,8E7
0B860:  MOVFF  FEC,8E8
0B864:  MOVF   xE6,W
0B866:  ANDLW  01
0B868:  MOVWF  01
0B86A:  MOVLW  00
0B86C:  BSF    FD8.0
0B86E:  SUBFWB xE5,W
0B870:  MOVWF  xE0
0B872:  MOVLW  02
0B874:  SUBFWB 01,W
0B876:  MOVWF  xE1
....................          if (rcnt > btr) 
0B878:  MOVF   xD1,W
0B87A:  SUBWF  xE1,W
0B87C:  BNC   B88E
0B87E:  BNZ   B886
0B880:  MOVF   xE0,W
0B882:  SUBWF  xD0,W
0B884:  BC    B88E
....................             rcnt = btr; 
0B886:  MOVFF  8D1,8E1
0B88A:  MOVFF  8D0,8E0
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B88E:  MOVFF  8CC,FE9
0B892:  MOVFF  8CD,FEA
0B896:  MOVFF  FEF,8E5
0B89A:  MOVFF  FEC,8E6
0B89E:  MOVFF  FEC,8E7
0B8A2:  MOVFF  FEC,8E8
0B8A6:  MOVLW  01
0B8A8:  ANDWF  xE6,F
0B8AA:  CLRF   xE7
0B8AC:  CLRF   xE8
0B8AE:  MOVLW  24
0B8B0:  ADDWF  xE5,W
0B8B2:  MOVWF  00
0B8B4:  MOVLW  00
0B8B6:  ADDWFC xE6,W
0B8B8:  MOVWF  01
0B8BA:  MOVLW  00
0B8BC:  ADDWFC xE7,W
0B8BE:  MOVWF  02
0B8C0:  MOVLW  00
0B8C2:  ADDWFC xE8,W
0B8C4:  MOVWF  03
0B8C6:  MOVFF  01,03
0B8CA:  MOVF   00,W
0B8CC:  MOVLB  7
0B8CE:  ADDWF  x12,W
0B8D0:  MOVWF  01
0B8D2:  MOVF   x13,W
0B8D4:  ADDWFC 03,F
0B8D6:  MOVFF  01,8E9
0B8DA:  MOVLB  8
0B8DC:  MOVFF  03,8EA
0B8E0:  MOVFF  8E4,FEA
0B8E4:  MOVFF  8E3,FE9
0B8E8:  MOVFF  03,FE2
0B8EC:  MOVFF  01,FE1
0B8F0:  MOVFF  8E1,02
0B8F4:  MOVFF  8E0,01
0B8F8:  MOVF   01,F
0B8FA:  BZ    B900
0B8FC:  INCF   02,F
0B8FE:  BRA    B904
0B900:  MOVF   02,F
0B902:  BZ    B910
0B904:  MOVFF  FE6,FEE
0B908:  DECFSZ 01,F
0B90A:  BRA    B904
0B90C:  DECFSZ 02,F
0B90E:  BRA    B904
0B910:  MOVLB  0
0B912:  MOVLB  8
0B914:  MOVF   xE0,W
0B916:  ADDWF  xE3,F
0B918:  MOVF   xE1,W
0B91A:  ADDWFC xE4,F
0B91C:  MOVFF  8CC,FE9
0B920:  MOVFF  8CD,FEA
0B924:  MOVF   xE0,W
0B926:  ADDWF  FEF,W
0B928:  MOVWF  00
0B92A:  MOVF   xE1,W
0B92C:  ADDWFC FEC,W
0B92E:  MOVWF  01
0B930:  MOVLW  00
0B932:  ADDWFC FEC,W
0B934:  MOVWF  02
0B936:  MOVLW  00
0B938:  ADDWFC FEC,W
0B93A:  MOVWF  03
0B93C:  MOVF   FED,F
0B93E:  MOVF   FED,F
0B940:  MOVF   FED,F
0B942:  MOVFF  00,FEF
0B946:  MOVFF  01,FEC
0B94A:  MOVFF  02,FEC
0B94E:  MOVWF  FEC
0B950:  MOVFF  8D2,FE9
0B954:  MOVFF  8D3,FEA
0B958:  MOVF   xE0,W
0B95A:  ADDWF  FEF,W
0B95C:  MOVWF  01
0B95E:  MOVF   xE1,W
0B960:  ADDWFC FEC,W
0B962:  MOVWF  03
0B964:  MOVF   FED,F
0B966:  MOVFF  01,FEF
0B96A:  MOVWF  FEC
0B96C:  MOVF   xE0,W
0B96E:  SUBWF  xD0,F
0B970:  MOVF   xE1,W
0B972:  SUBWFB xD1,F
0B974:  BRA    B578
....................          } 
....................       return (FR_OK); 
0B976:  MOVLW  00
0B978:  MOVWF  01
0B97A:  MOVLB  7
0B97C:  BRA    B998
0B97E:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B980:  MOVLW  1A
0B982:  ADDWF  xCC,W
0B984:  MOVWF  FE9
0B986:  MOVLW  00
0B988:  ADDWFC xCD,W
0B98A:  MOVWF  FEA
0B98C:  MOVF   FEF,W
0B98E:  IORLW  80
0B990:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B992:  MOVLW  07
0B994:  MOVWF  01
0B996:  MOVLB  7
0B998:  MOVLB  0
0B99A:  GOTO   BB96 (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
07A22:  MOVFF  9B3,9C4
07A26:  MOVFF  9B2,9C3
....................       *bw = 0; 
07A2A:  MOVLB  9
07A2C:  MOVFF  9B6,FE9
07A30:  MOVFF  9B7,FEA
07A34:  CLRF   FEC
07A36:  MOVF   FED,F
07A38:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07A3A:  CLRF   xC1
07A3C:  CLRF   xC0
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07A3E:  MOVLB  7
07A40:  MOVF   x12,W
07A42:  IORWF  x13,W
07A44:  BNZ   7A4C
....................          return (FR_NOT_ENABLED); 
07A46:  MOVLW  0B
07A48:  MOVWF  01
07A4A:  BRA    80EC
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07A4C:  MOVLB  0
07A4E:  CALL   55C6
07A52:  BTFSC  01.0
07A54:  BRA    7A66
07A56:  MOVLB  7
07A58:  MOVFF  712,FE9
07A5C:  MOVFF  713,FEA
07A60:  MOVF   FEF,F
07A62:  BNZ   7A6E
07A64:  MOVLB  0
....................          return (FR_NOT_READY); 
07A66:  MOVLW  01
07A68:  MOVWF  01
07A6A:  MOVLB  7
07A6C:  BRA    80EC
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
07A6E:  MOVLW  1A
07A70:  MOVLB  9
07A72:  ADDWF  xB0,W
07A74:  MOVWF  FE9
07A76:  MOVLW  00
07A78:  ADDWFC xB1,W
07A7A:  MOVWF  FEA
07A7C:  BTFSS  FEF.7
07A7E:  BRA    7A8A
....................          return (FR_RW_ERROR);         // Check error flag  
07A80:  MOVLW  07
07A82:  MOVWF  01
07A84:  MOVLB  7
07A86:  BRA    80EC
07A88:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
07A8A:  MOVLW  1A
07A8C:  ADDWF  xB0,W
07A8E:  MOVWF  FE9
07A90:  MOVLW  00
07A92:  ADDWFC xB1,W
07A94:  MOVWF  FEA
07A96:  BTFSC  FEF.1
07A98:  BRA    7AA4
....................          return (FR_DENIED);            // Check access mode  
07A9A:  MOVLW  05
07A9C:  MOVWF  01
07A9E:  MOVLB  7
07AA0:  BRA    80EC
07AA2:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
07AA4:  MOVLW  04
07AA6:  ADDWF  xB0,W
07AA8:  MOVWF  FE9
07AAA:  MOVLW  00
07AAC:  ADDWFC xB1,W
07AAE:  MOVWF  FEA
07AB0:  MOVFF  FEF,9C5
07AB4:  MOVFF  FEC,9C6
07AB8:  MOVFF  FEC,9C7
07ABC:  MOVFF  FEC,9C8
07AC0:  MOVF   xB4,W
07AC2:  ADDWF  xC5,F
07AC4:  MOVF   xB5,W
07AC6:  ADDWFC xC6,F
07AC8:  MOVLW  00
07ACA:  ADDWFC xC7,F
07ACC:  ADDWFC xC8,F
07ACE:  MOVLW  04
07AD0:  ADDWF  xB0,W
07AD2:  MOVWF  FE9
07AD4:  MOVLW  00
07AD6:  ADDWFC xB1,W
07AD8:  MOVWF  FEA
07ADA:  MOVFF  FEF,00
07ADE:  MOVFF  FEC,01
07AE2:  MOVFF  FEC,02
07AE6:  MOVFF  FEC,03
07AEA:  MOVF   xC8,W
07AEC:  SUBWF  03,W
07AEE:  BNC   7B0C
07AF0:  BNZ   7B08
07AF2:  MOVF   xC7,W
07AF4:  SUBWF  02,W
07AF6:  BNC   7B0C
07AF8:  BNZ   7B08
07AFA:  MOVF   xC6,W
07AFC:  SUBWF  01,W
07AFE:  BNC   7B0C
07B00:  BNZ   7B08
07B02:  MOVF   00,W
07B04:  SUBWF  xC5,W
07B06:  BC    7B0C
....................          btw = 0;                  // File size cannot reach 4GB  
07B08:  CLRF   xB5
07B0A:  CLRF   xB4
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07B0C:  MOVF   xB4,W
07B0E:  IORWF  xB5,W
07B10:  BTFSC  FD8.2
07B12:  BRA    8020
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07B14:  MOVFF  9B0,FE9
07B18:  MOVFF  9B1,FEA
07B1C:  MOVFF  FEF,9C5
07B20:  MOVFF  FEC,9C6
07B24:  MOVFF  FEC,9C7
07B28:  MOVFF  FEC,9C8
07B2C:  MOVLW  01
07B2E:  ANDWF  xC6,F
07B30:  CLRF   xC7
07B32:  CLRF   xC8
07B34:  MOVF   xC5,F
07B36:  BTFSS  FD8.2
07B38:  BRA    7EBA
07B3A:  MOVF   xC6,F
07B3C:  BTFSS  FD8.2
07B3E:  BRA    7EBA
07B40:  MOVF   xC7,F
07B42:  BTFSS  FD8.2
07B44:  BRA    7EBA
07B46:  MOVF   xC8,F
07B48:  BTFSS  FD8.2
07B4A:  BRA    7EBA
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07B4C:  MOVLW  1B
07B4E:  ADDWF  xB0,W
07B50:  MOVWF  FE9
07B52:  MOVLW  00
07B54:  ADDWFC xB1,W
07B56:  MOVWF  FEA
07B58:  DECF   FEF,F
07B5A:  BZ    7B92
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07B5C:  MOVLW  10
07B5E:  ADDWF  xB0,W
07B60:  MOVWF  FE9
07B62:  MOVLW  00
07B64:  ADDWFC xB1,W
07B66:  MOVWF  FEA
07B68:  MOVFF  FEF,9C5
07B6C:  MOVFF  FEC,9C6
07B70:  MOVFF  FEC,9C7
07B74:  MOVFF  FEC,9C8
07B78:  MOVLW  01
07B7A:  ADDWF  xC5,W
07B7C:  MOVWF  xBC
07B7E:  MOVLW  00
07B80:  ADDWFC xC6,W
07B82:  MOVWF  xBD
07B84:  MOVLW  00
07B86:  ADDWFC xC7,W
07B88:  MOVWF  xBE
07B8A:  MOVLW  00
07B8C:  ADDWFC xC8,W
07B8E:  MOVWF  xBF
....................                }  
07B90:  BRA    7D28
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07B92:  MOVFF  9B0,FE9
07B96:  MOVFF  9B1,FEA
07B9A:  MOVFF  FEF,9C5
07B9E:  MOVFF  FEC,9C6
07BA2:  MOVFF  FEC,9C7
07BA6:  MOVFF  FEC,9C8
07BAA:  MOVF   xC5,F
07BAC:  BNZ   7C32
07BAE:  MOVF   xC6,F
07BB0:  BNZ   7C32
07BB2:  MOVF   xC7,F
07BB4:  BNZ   7C32
07BB6:  MOVF   xC8,F
07BB8:  BNZ   7C32
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07BBA:  MOVLW  08
07BBC:  ADDWF  xB0,W
07BBE:  MOVWF  FE9
07BC0:  MOVLW  00
07BC2:  ADDWFC xB1,W
07BC4:  MOVWF  FEA
07BC6:  MOVFF  FEF,9B8
07BCA:  MOVFF  FEC,9B9
07BCE:  MOVFF  FEC,9BA
07BD2:  MOVFF  FEC,9BB
....................                   if (clust == 0)            // No cluster is created  
07BD6:  MOVF   xB8,F
07BD8:  BNZ   7C30
07BDA:  MOVF   xB9,F
07BDC:  BNZ   7C30
07BDE:  MOVF   xBA,F
07BE0:  BNZ   7C30
07BE2:  MOVF   xBB,F
07BE4:  BNZ   7C30
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07BE6:  MOVLW  08
07BE8:  ADDWF  xB0,W
07BEA:  MOVWF  01
07BEC:  MOVLW  00
07BEE:  ADDWFC xB1,W
07BF0:  MOVWF  03
07BF2:  MOVFF  01,9C5
07BF6:  MOVWF  xC6
07BF8:  CLRF   xEB
07BFA:  CLRF   xEA
07BFC:  CLRF   xE9
07BFE:  CLRF   xE8
07C00:  MOVLB  0
07C02:  CALL   698C
07C06:  MOVFF  03,9BB
07C0A:  MOVFF  02,9BA
07C0E:  MOVFF  01,9B9
07C12:  MOVFF  00,9B8
07C16:  MOVFF  9C6,FEA
07C1A:  MOVFF  9C5,FE9
07C1E:  MOVFF  9B8,FEF
07C22:  MOVFF  9B9,FEC
07C26:  MOVFF  9BA,FEC
07C2A:  MOVFF  9BB,FEC
07C2E:  MOVLB  9
....................                   } 
07C30:  BRA    7C66
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07C32:  MOVLW  0C
07C34:  ADDWF  xB0,W
07C36:  MOVWF  FE9
07C38:  MOVLW  00
07C3A:  ADDWFC xB1,W
07C3C:  MOVWF  FEA
07C3E:  MOVFF  FEF,9E8
07C42:  MOVFF  FEC,9E9
07C46:  MOVFF  FEC,9EA
07C4A:  MOVFF  FEC,9EB
07C4E:  MOVLB  0
07C50:  CALL   698C
07C54:  MOVFF  03,9BB
07C58:  MOVFF  02,9BA
07C5C:  MOVFF  01,9B9
07C60:  MOVFF  00,9B8
07C64:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07C66:  MOVF   xBB,F
07C68:  BNZ   7C78
07C6A:  MOVF   xBA,F
07C6C:  BNZ   7C78
07C6E:  MOVF   xB9,F
07C70:  BNZ   7C78
07C72:  MOVF   xB8,W
07C74:  SUBLW  01
07C76:  BC    7CB6
07C78:  MOVLW  0C
07C7A:  MOVLB  7
07C7C:  ADDWF  x12,W
07C7E:  MOVWF  FE9
07C80:  MOVLW  00
07C82:  ADDWFC x13,W
07C84:  MOVWF  FEA
07C86:  MOVFF  FEF,00
07C8A:  MOVFF  FEC,01
07C8E:  MOVFF  FEC,02
07C92:  MOVFF  FEC,03
07C96:  MOVF   03,W
07C98:  MOVLB  9
07C9A:  SUBWF  xBB,W
07C9C:  BNC   7CB8
07C9E:  BNZ   7CB6
07CA0:  MOVF   02,W
07CA2:  SUBWF  xBA,W
07CA4:  BNC   7CB8
07CA6:  BNZ   7CB6
07CA8:  MOVF   01,W
07CAA:  SUBWF  xB9,W
07CAC:  BNC   7CB8
07CAE:  BNZ   7CB6
07CB0:  MOVF   00,W
07CB2:  SUBWF  xB8,W
07CB4:  BNC   7CB8
....................                   break; 
07CB6:  BRA    8020
....................                fp->curr_clust = clust;            // Current cluster  
07CB8:  MOVLW  0C
07CBA:  ADDWF  xB0,W
07CBC:  MOVWF  FE9
07CBE:  MOVLW  00
07CC0:  ADDWFC xB1,W
07CC2:  MOVWF  FEA
07CC4:  MOVFF  9B8,FEF
07CC8:  MOVFF  9B9,FEC
07CCC:  MOVFF  9BA,FEC
07CD0:  MOVFF  9BB,FEC
....................                sect = clust2sect(clust);         // Current sector  
07CD4:  MOVFF  9BB,9F2
07CD8:  MOVFF  9BA,9F1
07CDC:  MOVFF  9B9,9F0
07CE0:  MOVFF  9B8,9EF
07CE4:  MOVLB  0
07CE6:  CALL   5636
07CEA:  MOVFF  03,9BF
07CEE:  MOVFF  02,9BE
07CF2:  MOVFF  01,9BD
07CF6:  MOVFF  00,9BC
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07CFA:  MOVLW  1B
07CFC:  MOVLB  9
07CFE:  ADDWF  xB0,W
07D00:  MOVWF  01
07D02:  MOVLW  00
07D04:  ADDWFC xB1,W
07D06:  MOVWF  03
07D08:  MOVLW  02
07D0A:  MOVLB  7
07D0C:  ADDWF  x12,W
07D0E:  MOVWF  FE9
07D10:  MOVLW  00
07D12:  ADDWFC x13,W
07D14:  MOVWF  FEA
07D16:  MOVFF  FEF,9C7
07D1A:  MOVLB  9
07D1C:  MOVFF  03,FEA
07D20:  MOVFF  01,FE9
07D24:  MOVFF  9C7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07D28:  MOVLW  10
07D2A:  ADDWF  xB0,W
07D2C:  MOVWF  FE9
07D2E:  MOVLW  00
07D30:  ADDWFC xB1,W
07D32:  MOVWF  FEA
07D34:  MOVFF  9BC,FEF
07D38:  MOVFF  9BD,FEC
07D3C:  MOVFF  9BE,FEC
07D40:  MOVFF  9BF,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07D44:  BCF    FD8.0
07D46:  RRCF   xB5,W
07D48:  MOVWF  xC2
....................             if (cc)  
07D4A:  MOVF   xC2,F
07D4C:  BZ    7E08
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07D4E:  MOVLW  1B
07D50:  ADDWF  xB0,W
07D52:  MOVWF  FE9
07D54:  MOVLW  00
07D56:  ADDWFC xB1,W
07D58:  MOVWF  FEA
07D5A:  MOVF   FEF,W
07D5C:  SUBWF  xC2,W
07D5E:  BZ    7D72
07D60:  BNC   7D72
....................                   cc = fp->sect_clust; 
07D62:  MOVLW  1B
07D64:  ADDWF  xB0,W
07D66:  MOVWF  FE9
07D68:  MOVLW  00
07D6A:  ADDWFC xB1,W
07D6C:  MOVWF  FEA
07D6E:  MOVFF  FEF,9C2
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07D72:  MOVFF  9C4,A21
07D76:  MOVFF  9C3,A20
07D7A:  MOVFF  9BF,A25
07D7E:  MOVFF  9BE,A24
07D82:  MOVFF  9BD,A23
07D86:  MOVFF  9BC,A22
07D8A:  MOVFF  9C2,A26
07D8E:  MOVLB  0
07D90:  CALL   5966
07D94:  MOVF   01,F
07D96:  BZ    7D9A
....................                   goto fw_error; 
07D98:  BRA    80D2
....................                fp->sect_clust -= cc - 1; 
07D9A:  MOVLW  1B
07D9C:  MOVLB  9
07D9E:  ADDWF  xB0,W
07DA0:  MOVWF  FE9
07DA2:  MOVLW  00
07DA4:  ADDWFC xB1,W
07DA6:  MOVWF  FEA
07DA8:  MOVLW  01
07DAA:  SUBWF  xC2,W
07DAC:  SUBWF  FEF,W
07DAE:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07DB0:  MOVLW  10
07DB2:  ADDWF  xB0,W
07DB4:  MOVWF  FE9
07DB6:  MOVLW  00
07DB8:  ADDWFC xB1,W
07DBA:  MOVWF  FEA
07DBC:  MOVLW  01
07DBE:  SUBWF  xC2,W
07DC0:  ADDWF  FEF,W
07DC2:  MOVWF  00
07DC4:  MOVLW  00
07DC6:  ADDWFC FEC,W
07DC8:  MOVWF  01
07DCA:  MOVLW  00
07DCC:  ADDWFC FEC,W
07DCE:  MOVWF  02
07DD0:  MOVLW  00
07DD2:  ADDWFC FEC,W
07DD4:  MOVF   FED,F
07DD6:  MOVF   FED,F
07DD8:  MOVF   FED,F
07DDA:  MOVFF  00,FEF
07DDE:  MOVFF  01,FEC
07DE2:  MOVFF  02,FEC
07DE6:  MOVWF  FEC
....................                wcnt = cc * 512; 
07DE8:  MOVLB  A
07DEA:  CLRF   x11
07DEC:  MOVFF  9C2,A10
07DF0:  MOVLW  02
07DF2:  MOVWF  x13
07DF4:  CLRF   x12
07DF6:  MOVLB  0
07DF8:  CALL   5CC0
07DFC:  MOVFF  02,9C1
07E00:  MOVFF  01,9C0
....................                continue; 
07E04:  BRA    7FBC
07E06:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07E08:  MOVFF  9B0,FE9
07E0C:  MOVFF  9B1,FEA
07E10:  MOVFF  FEF,9C5
07E14:  MOVFF  FEC,9C6
07E18:  MOVFF  FEC,9C7
07E1C:  MOVFF  FEC,9C8
07E20:  MOVLW  04
07E22:  ADDWF  xB0,W
07E24:  MOVWF  FE9
07E26:  MOVLW  00
07E28:  ADDWFC xB1,W
07E2A:  MOVWF  FEA
07E2C:  MOVFF  FEF,00
07E30:  MOVFF  FEC,01
07E34:  MOVFF  FEC,02
07E38:  MOVFF  FEC,03
07E3C:  MOVF   03,W
07E3E:  SUBWF  xC8,W
07E40:  BNC   7EBA
07E42:  BNZ   7E5A
07E44:  MOVF   02,W
07E46:  SUBWF  xC7,W
07E48:  BNC   7EBA
07E4A:  BNZ   7E5A
07E4C:  MOVF   01,W
07E4E:  SUBWF  xC6,W
07E50:  BNC   7EBA
07E52:  BNZ   7E5A
07E54:  MOVF   00,W
07E56:  SUBWF  xC5,W
07E58:  BNC   7EBA
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07E5A:  MOVLB  A
07E5C:  CLRF   x17
07E5E:  CLRF   x16
07E60:  CLRF   x15
07E62:  CLRF   x14
07E64:  MOVLB  0
07E66:  CALL   5AAA
07E6A:  MOVF   01,F
07E6C:  BNZ   7E70
....................                   goto fw_error; 
07E6E:  BRA    80D2
....................                fs->winsect = fp->curr_sect; 
07E70:  MOVLW  20
07E72:  MOVLB  7
07E74:  ADDWF  x12,W
07E76:  MOVWF  01
07E78:  MOVLW  00
07E7A:  ADDWFC x13,W
07E7C:  MOVWF  03
07E7E:  MOVFF  01,9C5
07E82:  MOVLB  9
07E84:  MOVWF  xC6
07E86:  MOVLW  10
07E88:  ADDWF  xB0,W
07E8A:  MOVWF  FE9
07E8C:  MOVLW  00
07E8E:  ADDWFC xB1,W
07E90:  MOVWF  FEA
07E92:  MOVFF  FEF,00
07E96:  MOVFF  FEC,01
07E9A:  MOVFF  FEC,02
07E9E:  MOVFF  FEC,03
07EA2:  MOVFF  9C6,FEA
07EA6:  MOVFF  9C5,FE9
07EAA:  MOVFF  00,FEF
07EAE:  MOVFF  01,FEC
07EB2:  MOVFF  02,FEC
07EB6:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07EBA:  MOVLW  10
07EBC:  ADDWF  xB0,W
07EBE:  MOVWF  FE9
07EC0:  MOVLW  00
07EC2:  ADDWFC xB1,W
07EC4:  MOVWF  FEA
07EC6:  MOVFF  FEF,A14
07ECA:  MOVFF  FEC,A15
07ECE:  MOVFF  FEC,A16
07ED2:  MOVFF  FEC,A17
07ED6:  MOVLB  0
07ED8:  CALL   5AAA
07EDC:  MOVF   01,F
07EDE:  BNZ   7EE2
....................             goto fw_error;               // Move sector window 
07EE0:  BRA    80D2
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07EE2:  MOVLB  9
07EE4:  MOVFF  9B0,FE9
07EE8:  MOVFF  9B1,FEA
07EEC:  MOVFF  FEF,9C5
07EF0:  MOVFF  FEC,9C6
07EF4:  MOVFF  FEC,9C7
07EF8:  MOVFF  FEC,9C8
07EFC:  MOVF   xC6,W
07EFE:  ANDLW  01
07F00:  MOVWF  01
07F02:  MOVLW  00
07F04:  BSF    FD8.0
07F06:  SUBFWB xC5,W
07F08:  MOVWF  xC0
07F0A:  MOVLW  02
07F0C:  SUBFWB 01,W
07F0E:  MOVWF  xC1
....................          if (wcnt > btw) 
07F10:  MOVF   xB5,W
07F12:  SUBWF  xC1,W
07F14:  BNC   7F26
07F16:  BNZ   7F1E
07F18:  MOVF   xC0,W
07F1A:  SUBWF  xB4,W
07F1C:  BC    7F26
....................             wcnt = btw; 
07F1E:  MOVFF  9B5,9C1
07F22:  MOVFF  9B4,9C0
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07F26:  MOVFF  9B0,FE9
07F2A:  MOVFF  9B1,FEA
07F2E:  MOVFF  FEF,9C5
07F32:  MOVFF  FEC,9C6
07F36:  MOVFF  FEC,9C7
07F3A:  MOVFF  FEC,9C8
07F3E:  MOVLW  01
07F40:  ANDWF  xC6,F
07F42:  CLRF   xC7
07F44:  CLRF   xC8
07F46:  MOVLW  24
07F48:  ADDWF  xC5,W
07F4A:  MOVWF  00
07F4C:  MOVLW  00
07F4E:  ADDWFC xC6,W
07F50:  MOVWF  01
07F52:  MOVLW  00
07F54:  ADDWFC xC7,W
07F56:  MOVWF  02
07F58:  MOVLW  00
07F5A:  ADDWFC xC8,W
07F5C:  MOVWF  03
07F5E:  MOVFF  01,03
07F62:  MOVF   00,W
07F64:  MOVLB  7
07F66:  ADDWF  x12,W
07F68:  MOVWF  01
07F6A:  MOVF   x13,W
07F6C:  ADDWFC 03,F
07F6E:  MOVFF  01,9C9
07F72:  MOVLB  9
07F74:  MOVFF  03,9CA
07F78:  MOVFF  03,FEA
07F7C:  MOVFF  01,FE9
07F80:  MOVFF  9C4,FE2
07F84:  MOVFF  9C3,FE1
07F88:  MOVFF  9C1,02
07F8C:  MOVFF  9C0,01
07F90:  MOVF   01,F
07F92:  BZ    7F98
07F94:  INCF   02,F
07F96:  BRA    7F9C
07F98:  MOVF   02,F
07F9A:  BZ    7FA8
07F9C:  MOVFF  FE6,FEE
07FA0:  DECFSZ 01,F
07FA2:  BRA    7F9C
07FA4:  DECFSZ 02,F
07FA6:  BRA    7F9C
....................          fs->winflag = 1; 
07FA8:  MOVLW  06
07FAA:  MOVLB  7
07FAC:  ADDWF  x12,W
07FAE:  MOVWF  FE9
07FB0:  MOVLW  00
07FB2:  ADDWFC x13,W
07FB4:  MOVWF  FEA
07FB6:  MOVLW  01
07FB8:  MOVWF  FEF
07FBA:  MOVLB  0
07FBC:  MOVLB  9
07FBE:  MOVF   xC0,W
07FC0:  ADDWF  xC3,F
07FC2:  MOVF   xC1,W
07FC4:  ADDWFC xC4,F
07FC6:  MOVFF  9B0,FE9
07FCA:  MOVFF  9B1,FEA
07FCE:  MOVF   xC0,W
07FD0:  ADDWF  FEF,W
07FD2:  MOVWF  00
07FD4:  MOVF   xC1,W
07FD6:  ADDWFC FEC,W
07FD8:  MOVWF  01
07FDA:  MOVLW  00
07FDC:  ADDWFC FEC,W
07FDE:  MOVWF  02
07FE0:  MOVLW  00
07FE2:  ADDWFC FEC,W
07FE4:  MOVWF  03
07FE6:  MOVF   FED,F
07FE8:  MOVF   FED,F
07FEA:  MOVF   FED,F
07FEC:  MOVFF  00,FEF
07FF0:  MOVFF  01,FEC
07FF4:  MOVFF  02,FEC
07FF8:  MOVWF  FEC
07FFA:  MOVFF  9B6,FE9
07FFE:  MOVFF  9B7,FEA
08002:  MOVF   xC0,W
08004:  ADDWF  FEF,W
08006:  MOVWF  01
08008:  MOVF   xC1,W
0800A:  ADDWFC FEC,W
0800C:  MOVWF  03
0800E:  MOVF   FED,F
08010:  MOVFF  01,FEF
08014:  MOVWF  FEC
08016:  MOVF   xC0,W
08018:  SUBWF  xB4,F
0801A:  MOVF   xC1,W
0801C:  SUBWFB xB5,F
0801E:  BRA    7B0C
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
08020:  MOVFF  9B0,FE9
08024:  MOVFF  9B1,FEA
08028:  MOVFF  FEF,9C5
0802C:  MOVFF  FEC,9C6
08030:  MOVFF  FEC,9C7
08034:  MOVFF  FEC,9C8
08038:  MOVLW  04
0803A:  ADDWF  xB0,W
0803C:  MOVWF  FE9
0803E:  MOVLW  00
08040:  ADDWFC xB1,W
08042:  MOVWF  FEA
08044:  MOVFF  FEF,00
08048:  MOVFF  FEC,01
0804C:  MOVFF  FEC,02
08050:  MOVFF  FEC,03
08054:  MOVF   03,W
08056:  SUBWF  xC8,W
08058:  BNC   80B6
0805A:  BNZ   8072
0805C:  MOVF   02,W
0805E:  SUBWF  xC7,W
08060:  BNC   80B6
08062:  BNZ   8072
08064:  MOVF   01,W
08066:  SUBWF  xC6,W
08068:  BNC   80B6
0806A:  BNZ   8072
0806C:  MOVF   xC5,W
0806E:  SUBWF  00,W
08070:  BC    80B6
....................          fp->fsize = fp->fptr;      // Update file size if needed  
08072:  MOVLW  04
08074:  ADDWF  xB0,W
08076:  MOVWF  01
08078:  MOVLW  00
0807A:  ADDWFC xB1,W
0807C:  MOVWF  03
0807E:  MOVFF  01,9C5
08082:  MOVFF  03,9C6
08086:  MOVFF  9B0,FE9
0808A:  MOVFF  9B1,FEA
0808E:  MOVFF  FEF,00
08092:  MOVFF  FEC,01
08096:  MOVFF  FEC,02
0809A:  MOVFF  FEC,03
0809E:  MOVFF  9C6,FEA
080A2:  MOVFF  9C5,FE9
080A6:  MOVFF  00,FEF
080AA:  MOVFF  01,FEC
080AE:  MOVFF  02,FEC
080B2:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
080B6:  MOVLW  1A
080B8:  ADDWF  xB0,W
080BA:  MOVWF  FE9
080BC:  MOVLW  00
080BE:  ADDWFC xB1,W
080C0:  MOVWF  FEA
080C2:  MOVF   FEF,W
080C4:  IORLW  20
080C6:  MOVWF  FEF
....................       return (FR_OK); 
080C8:  MOVLW  00
080CA:  MOVWF  01
080CC:  MOVLB  7
080CE:  BRA    80EC
080D0:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
080D2:  MOVLW  1A
080D4:  MOVLB  9
080D6:  ADDWF  xB0,W
080D8:  MOVWF  FE9
080DA:  MOVLW  00
080DC:  ADDWFC xB1,W
080DE:  MOVWF  FEA
080E0:  MOVF   FEF,W
080E2:  IORLW  80
080E4:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
080E6:  MOVLW  07
080E8:  MOVWF  01
080EA:  MOVLB  7
080EC:  MOVLB  0
080EE:  GOTO   8496 (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
075C8:  MOVLB  7
075CA:  MOVF   x12,W
075CC:  IORWF  x13,W
075CE:  BNZ   75D6
....................          return (FR_NOT_ENABLED); 
075D0:  MOVLW  0B
075D2:  MOVWF  01
075D4:  BRA    792A
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
075D6:  MOVLB  0
075D8:  CALL   55C6
075DC:  BTFSC  01.0
075DE:  BRA    75F0
075E0:  MOVLB  7
075E2:  MOVFF  712,FE9
075E6:  MOVFF  713,FEA
075EA:  MOVF   FEF,F
075EC:  BNZ   75F8
075EE:  MOVLB  0
....................          return (FR_NOT_READY); 
075F0:  MOVLW  01
075F2:  MOVWF  01
075F4:  MOVLB  7
075F6:  BRA    792A
....................     
....................       if (fp->flag & FA__ERROR) 
075F8:  MOVLW  1A
075FA:  MOVLB  9
075FC:  ADDWF  xB0,W
075FE:  MOVWF  FE9
07600:  MOVLW  00
07602:  ADDWFC xB1,W
07604:  MOVWF  FEA
07606:  BTFSS  FEF.7
07608:  BRA    7614
....................          return (FR_RW_ERROR); 
0760A:  MOVLW  07
0760C:  MOVWF  01
0760E:  MOVLB  7
07610:  BRA    792A
07612:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
07614:  MOVLW  04
07616:  ADDWF  xB0,W
07618:  MOVWF  FE9
0761A:  MOVLW  00
0761C:  ADDWFC xB1,W
0761E:  MOVWF  FEA
07620:  MOVFF  FEF,00
07624:  MOVFF  FEC,01
07628:  MOVFF  FEC,02
0762C:  MOVFF  FEC,03
07630:  MOVF   03,W
07632:  SUBWF  xB5,W
07634:  BNC   766A
07636:  BNZ   764E
07638:  MOVF   02,W
0763A:  SUBWF  xB4,W
0763C:  BNC   766A
0763E:  BNZ   764E
07640:  MOVF   01,W
07642:  SUBWF  xB3,W
07644:  BNC   766A
07646:  BNZ   764E
07648:  MOVF   xB2,W
0764A:  SUBWF  00,W
0764C:  BC    766A
....................          ofs = fp->fsize;               // Clip offset by file size  
0764E:  MOVLW  04
07650:  ADDWF  xB0,W
07652:  MOVWF  FE9
07654:  MOVLW  00
07656:  ADDWFC xB1,W
07658:  MOVWF  FEA
0765A:  MOVFF  FEF,9B2
0765E:  MOVFF  FEC,9B3
07662:  MOVFF  FEC,9B4
07666:  MOVFF  FEC,9B5
....................       fp->fptr = ofs;  
0766A:  MOVFF  9B0,FE9
0766E:  MOVF   xB1,W
07670:  MOVWF  FEA
07672:  MOVFF  9B2,FEF
07676:  MOVFF  9B3,FEC
0767A:  MOVFF  9B4,FEC
0767E:  MOVFF  9B5,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
07682:  MOVLW  1B
07684:  ADDWF  xB0,W
07686:  MOVWF  FE9
07688:  MOVLW  00
0768A:  ADDWFC xB1,W
0768C:  MOVWF  FEA
0768E:  MOVLW  01
07690:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
07692:  MOVF   xB2,F
07694:  BNZ   76A4
07696:  MOVF   xB3,F
07698:  BNZ   76A4
0769A:  MOVF   xB4,F
0769C:  BNZ   76A4
0769E:  MOVF   xB5,F
076A0:  BTFSC  FD8.2
076A2:  BRA    7908
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
076A4:  MOVLW  01
076A6:  SUBWF  xB2,W
076A8:  MOVLW  00
076AA:  SUBWFB xB3,W
076AC:  MOVWF  xBC
076AE:  MOVLW  00
076B0:  SUBWFB xB4,W
076B2:  MOVWF  xBD
076B4:  MOVLW  00
076B6:  SUBWFB xB5,W
076B8:  MOVWF  xBE
076BA:  BCF    FD8.0
076BC:  CLRF   xB5
076BE:  RRCF   xBE,W
076C0:  MOVWF  xB4
076C2:  RRCF   xBD,W
076C4:  MOVWF  xB3
076C6:  RRCF   xBC,W
076C8:  MOVWF  xB2
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
076CA:  MOVLW  02
076CC:  MOVLB  7
076CE:  ADDWF  x12,W
076D0:  MOVWF  FE9
076D2:  MOVLW  00
076D4:  ADDWFC x13,W
076D6:  MOVWF  FEA
076D8:  MOVFF  FEF,9BA
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
076DC:  MOVLW  1B
076DE:  MOVLB  9
076E0:  ADDWF  xB0,W
076E2:  MOVWF  01
076E4:  MOVLW  00
076E6:  ADDWFC xB1,W
076E8:  MOVWF  03
076EA:  MOVFF  01,9BB
076EE:  MOVWF  xBC
076F0:  MOVFF  FEA,9BE
076F4:  MOVFF  FE9,9BD
076F8:  BSF    FD8.1
076FA:  MOVLW  09
076FC:  MOVWF  FEA
076FE:  MOVLW  BF
07700:  MOVWF  FE9
07702:  CLRF   1B
07704:  BTFSC  FF2.7
07706:  BSF    1B.7
07708:  BCF    FF2.7
0770A:  MOVFF  9B5,A4F
0770E:  MOVFF  9B4,A4E
07712:  MOVFF  9B3,A4D
07716:  MOVFF  9B2,A4C
0771A:  MOVLB  A
0771C:  CLRF   x53
0771E:  CLRF   x52
07720:  CLRF   x51
07722:  MOVFF  9BA,A50
07726:  MOVLB  0
07728:  CALL   1076
0772C:  BTFSC  1B.7
0772E:  BSF    FF2.7
07730:  MOVFF  9BF,00
07734:  MOVFF  9C0,01
07738:  MOVFF  9C1,02
0773C:  MOVFF  9C2,03
07740:  MOVFF  9BE,FEA
07744:  MOVFF  9BD,FE9
07748:  MOVF   00,W
0774A:  MOVLB  9
0774C:  SUBWF  xBA,W
0774E:  MOVWF  00
07750:  MOVLW  00
07752:  SUBFWB 01,F
07754:  SUBFWB 02,F
07756:  SUBFWB 03,F
07758:  MOVFF  9BC,FEA
0775C:  MOVFF  9BB,FE9
07760:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
07764:  BCF    FD8.1
07766:  CLRF   1B
07768:  BTFSC  FF2.7
0776A:  BSF    1B.7
0776C:  BCF    FF2.7
0776E:  MOVFF  9B5,A4F
07772:  MOVFF  9B4,A4E
07776:  MOVFF  9B3,A4D
0777A:  MOVFF  9B2,A4C
0777E:  MOVLB  A
07780:  CLRF   x53
07782:  CLRF   x52
07784:  CLRF   x51
07786:  MOVFF  9BA,A50
0778A:  MOVLB  0
0778C:  CALL   1076
07790:  BTFSC  1B.7
07792:  BSF    FF2.7
07794:  MOVFF  03,9B5
07798:  MOVFF  02,9B4
0779C:  MOVFF  01,9B3
077A0:  MOVFF  00,9B2
....................          clust = fp->org_clust;            // Seek to current cluster  
077A4:  MOVLW  08
077A6:  MOVLB  9
077A8:  ADDWF  xB0,W
077AA:  MOVWF  FE9
077AC:  MOVLW  00
077AE:  ADDWFC xB1,W
077B0:  MOVWF  FEA
077B2:  MOVFF  FEF,9B6
077B6:  MOVFF  FEC,9B7
077BA:  MOVFF  FEC,9B8
077BE:  MOVFF  FEC,9B9
....................     
....................          while (ofs--) 
077C2:  MOVFF  9B5,03
077C6:  MOVFF  9B4,02
077CA:  MOVFF  9B3,01
077CE:  MOVFF  9B2,00
077D2:  MOVLW  FF
077D4:  ADDWF  xB2,F
077D6:  BTFSS  FD8.0
077D8:  ADDWF  xB3,F
077DA:  BTFSS  FD8.0
077DC:  ADDWF  xB4,F
077DE:  BTFSS  FD8.0
077E0:  ADDWF  xB5,F
077E2:  MOVF   00,F
077E4:  BNZ   77F2
077E6:  MOVF   01,F
077E8:  BNZ   77F2
077EA:  MOVF   02,F
077EC:  BNZ   77F2
077EE:  MOVF   03,F
077F0:  BZ    781C
....................             clust = get_cluster(clust); 
077F2:  MOVFF  9B9,9FF
077F6:  MOVFF  9B8,9FE
077FA:  MOVFF  9B7,9FD
077FE:  MOVFF  9B6,9FC
07802:  MOVLB  0
07804:  CALL   5CE2
07808:  MOVFF  03,9B9
0780C:  MOVFF  02,9B8
07810:  MOVFF  01,9B7
07814:  MOVFF  00,9B6
07818:  MOVLB  9
0781A:  BRA    77C2
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
0781C:  MOVF   xB9,F
0781E:  BNZ   782E
07820:  MOVF   xB8,F
07822:  BNZ   782E
07824:  MOVF   xB7,F
07826:  BNZ   782E
07828:  MOVF   xB6,W
0782A:  SUBLW  01
0782C:  BC    786C
0782E:  MOVLW  0C
07830:  MOVLB  7
07832:  ADDWF  x12,W
07834:  MOVWF  FE9
07836:  MOVLW  00
07838:  ADDWFC x13,W
0783A:  MOVWF  FEA
0783C:  MOVFF  FEF,00
07840:  MOVFF  FEC,01
07844:  MOVFF  FEC,02
07848:  MOVFF  FEC,03
0784C:  MOVF   03,W
0784E:  MOVLB  9
07850:  SUBWF  xB9,W
07852:  BNC   786E
07854:  BNZ   786C
07856:  MOVF   02,W
07858:  SUBWF  xB8,W
0785A:  BNC   786E
0785C:  BNZ   786C
0785E:  MOVF   01,W
07860:  SUBWF  xB7,W
07862:  BNC   786E
07864:  BNZ   786C
07866:  MOVF   00,W
07868:  SUBWF  xB6,W
0786A:  BNC   786E
....................             goto fk_error; 
0786C:  BRA    7912
....................     
....................          fp->curr_clust = clust; 
0786E:  MOVLW  0C
07870:  ADDWF  xB0,W
07872:  MOVWF  FE9
07874:  MOVLW  00
07876:  ADDWFC xB1,W
07878:  MOVWF  FEA
0787A:  MOVFF  9B6,FEF
0787E:  MOVFF  9B7,FEC
07882:  MOVFF  9B8,FEC
07886:  MOVFF  9B9,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
0788A:  MOVLW  10
0788C:  ADDWF  xB0,W
0788E:  MOVWF  01
07890:  MOVLW  00
07892:  ADDWFC xB1,W
07894:  MOVWF  03
07896:  MOVFF  01,9BB
0789A:  MOVWF  xBC
0789C:  MOVFF  9B9,9F2
078A0:  MOVFF  9B8,9F1
078A4:  MOVFF  9B7,9F0
078A8:  MOVFF  9B6,9EF
078AC:  MOVLB  0
078AE:  CALL   5636
078B2:  MOVFF  03,9C0
078B6:  MOVFF  02,9BF
078BA:  MOVFF  01,9BE
078BE:  MOVFF  00,9BD
078C2:  MOVLB  9
078C4:  MOVF   xBA,W
078C6:  ADDWF  xBD,F
078C8:  MOVLW  00
078CA:  ADDWFC xBE,F
078CC:  ADDWFC xBF,F
078CE:  ADDWFC xC0,F
078D0:  MOVLW  1B
078D2:  ADDWF  xB0,W
078D4:  MOVWF  FE9
078D6:  MOVLW  00
078D8:  ADDWFC xB1,W
078DA:  MOVWF  FEA
078DC:  MOVF   FEF,W
078DE:  SUBWF  xBD,W
078E0:  MOVWF  00
078E2:  MOVLW  00
078E4:  SUBWFB xBE,W
078E6:  MOVWF  01
078E8:  MOVLW  00
078EA:  SUBWFB xBF,W
078EC:  MOVWF  02
078EE:  MOVLW  00
078F0:  SUBWFB xC0,W
078F2:  MOVFF  9BC,FEA
078F6:  MOVFF  9BB,FE9
078FA:  MOVFF  00,FEF
078FE:  MOVFF  01,FEC
07902:  MOVFF  02,FEC
07906:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
07908:  MOVLW  00
0790A:  MOVWF  01
0790C:  MOVLB  7
0790E:  BRA    792A
07910:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07912:  MOVLW  1A
07914:  ADDWF  xB0,W
07916:  MOVWF  FE9
07918:  MOVLW  00
0791A:  ADDWFC xB1,W
0791C:  MOVWF  FEA
0791E:  MOVF   FEF,W
07920:  IORLW  80
07922:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
07924:  MOVLW  07
07926:  MOVWF  01
07928:  MOVLB  7
0792A:  MOVLB  0
0792C:  GOTO   83AE (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
080F2:  MOVLB  7
080F4:  MOVF   x12,W
080F6:  IORWF  x13,W
080F8:  BNZ   8100
....................       return (FR_NOT_ENABLED); 
080FA:  MOVLW  0B
080FC:  MOVWF  01
080FE:  BRA    82CE
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
08100:  MOVLB  0
08102:  CALL   55C6
08106:  BTFSC  01.0
08108:  BRA    811A
0810A:  MOVLB  7
0810C:  MOVFF  712,FE9
08110:  MOVFF  713,FEA
08114:  MOVF   FEF,F
08116:  BNZ   8122
08118:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
0811A:  MOVLW  09
0811C:  MOVWF  01
0811E:  MOVLB  7
08120:  BRA    82CE
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
08122:  MOVLW  1A
08124:  MOVLB  9
08126:  ADDWF  xB3,W
08128:  MOVWF  FE9
0812A:  MOVLW  00
0812C:  ADDWFC xB4,W
0812E:  MOVWF  FEA
08130:  BTFSS  FEF.5
08132:  BRA    82AA
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
08134:  MOVLW  14
08136:  ADDWF  xB3,W
08138:  MOVWF  FE9
0813A:  MOVLW  00
0813C:  ADDWFC xB4,W
0813E:  MOVWF  FEA
08140:  MOVFF  FEF,A14
08144:  MOVFF  FEC,A15
08148:  MOVFF  FEC,A16
0814C:  MOVFF  FEC,A17
08150:  MOVLB  0
08152:  CALL   5AAA
08156:  MOVF   01,F
08158:  BNZ   8164
....................          return (FR_RW_ERROR); 
0815A:  MOVLW  07
0815C:  MOVWF  01
0815E:  MOVLB  7
08160:  BRA    82CE
08162:  MOVLB  0
....................       ptr = fp->dir_ptr; 
08164:  MOVLW  18
08166:  MOVLB  9
08168:  ADDWF  xB3,W
0816A:  MOVWF  FE9
0816C:  MOVLW  00
0816E:  ADDWFC xB4,W
08170:  MOVWF  FEA
08172:  MOVFF  FEC,9B6
08176:  MOVF   FED,F
08178:  MOVFF  FEF,9B5
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
0817C:  MOVLW  0B
0817E:  ADDWF  xB5,W
08180:  MOVWF  01
08182:  MOVLW  00
08184:  ADDWFC xB6,W
08186:  MOVFF  01,FE9
0818A:  MOVWF  FEA
0818C:  MOVF   FEF,W
0818E:  IORLW  20
08190:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
08192:  MOVLW  1C
08194:  ADDWF  xB5,W
08196:  MOVWF  01
08198:  MOVLW  00
0819A:  ADDWFC xB6,W
0819C:  MOVWF  03
0819E:  MOVFF  01,9B7
081A2:  MOVWF  xB8
081A4:  MOVLW  04
081A6:  ADDWF  xB3,W
081A8:  MOVWF  FE9
081AA:  MOVLW  00
081AC:  ADDWFC xB4,W
081AE:  MOVWF  FEA
081B0:  MOVFF  FEF,00
081B4:  MOVFF  FEC,01
081B8:  MOVFF  FEC,02
081BC:  MOVFF  FEC,03
081C0:  MOVFF  9B8,FEA
081C4:  MOVFF  9B7,FE9
081C8:  MOVFF  00,FEF
081CC:  MOVFF  01,FEC
081D0:  MOVFF  02,FEC
081D4:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
081D8:  MOVLW  1A
081DA:  ADDWF  xB5,W
081DC:  MOVWF  01
081DE:  MOVLW  00
081E0:  ADDWFC xB6,W
081E2:  MOVWF  03
081E4:  MOVFF  01,9B7
081E8:  MOVWF  xB8
081EA:  MOVLW  08
081EC:  ADDWF  xB3,W
081EE:  MOVWF  FE9
081F0:  MOVLW  00
081F2:  ADDWFC xB4,W
081F4:  MOVWF  FEA
081F6:  MOVFF  FEF,00
081FA:  MOVFF  FEC,01
081FE:  MOVFF  FEC,02
08202:  MOVFF  FEC,03
08206:  MOVFF  9B8,FEA
0820A:  MOVFF  9B7,FE9
0820E:  MOVFF  00,FEF
08212:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
08216:  MOVLW  14
08218:  ADDWF  xB5,W
0821A:  MOVWF  01
0821C:  MOVLW  00
0821E:  ADDWFC xB6,W
08220:  MOVWF  03
08222:  MOVFF  01,9B7
08226:  MOVWF  xB8
08228:  MOVLW  08
0822A:  ADDWF  xB3,W
0822C:  MOVWF  FE9
0822E:  MOVLW  00
08230:  ADDWFC xB4,W
08232:  MOVWF  FEA
08234:  MOVFF  FEF,9B9
08238:  MOVFF  FEC,9BA
0823C:  MOVFF  FEC,00
08240:  MOVFF  FEC,01
08244:  MOVFF  9B8,FEA
08248:  MOVFF  9B7,FE9
0824C:  MOVFF  00,FEF
08250:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
08254:  MOVLW  16
08256:  ADDWF  xB5,W
08258:  MOVWF  01
0825A:  MOVLW  00
0825C:  ADDWFC xB6,W
0825E:  MOVWF  03
08260:  MOVFF  01,9B7
08264:  MOVWF  xB8
08266:  MOVLB  0
08268:  CALL   7010
0826C:  MOVFF  9B8,FEA
08270:  MOVFF  9B7,FE9
08274:  MOVFF  00,FEF
08278:  MOVFF  01,FEC
0827C:  MOVFF  02,FEC
08280:  MOVFF  03,FEC
....................       fs->winflag = 1; 
08284:  MOVLW  06
08286:  MOVLB  7
08288:  ADDWF  x12,W
0828A:  MOVWF  FE9
0828C:  MOVLW  00
0828E:  ADDWFC x13,W
08290:  MOVWF  FEA
08292:  MOVLW  01
08294:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
08296:  MOVLW  1A
08298:  MOVLB  9
0829A:  ADDWF  xB3,W
0829C:  MOVWF  FE9
0829E:  MOVLW  00
082A0:  ADDWFC xB4,W
082A2:  MOVWF  FEA
082A4:  MOVF   FEF,W
082A6:  ANDLW  DF
082A8:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
082AA:  MOVLB  A
082AC:  CLRF   x17
082AE:  CLRF   x16
082B0:  CLRF   x15
082B2:  CLRF   x14
082B4:  MOVLB  0
082B6:  CALL   5AAA
082BA:  MOVF   01,F
082BC:  BNZ   82C8
....................       return (FR_RW_ERROR); 
082BE:  MOVLW  07
082C0:  MOVWF  01
082C2:  MOVLB  7
082C4:  BRA    82CE
082C6:  MOVLB  0
....................  
....................    return (FR_OK); 
082C8:  MOVLW  00
082CA:  MOVWF  01
082CC:  MOVLB  7
082CE:  MOVLB  0
082D0:  GOTO   82DE (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
082D4:  MOVFF  9B1,9B4
082D8:  MOVFF  9B0,9B3
082DC:  BRA    80F2
082DE:  MOVFF  01,9B2
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
082E2:  MOVLB  9
082E4:  MOVF   xB2,F
082E6:  BNZ   8318
....................       { 
....................       fp->flag = 0; 
082E8:  MOVLW  1A
082EA:  ADDWF  xB0,W
082EC:  MOVWF  FE9
082EE:  MOVLW  00
082F0:  ADDWFC xB1,W
082F2:  MOVWF  FEA
082F4:  CLRF   FEF
....................       if (fs->files) 
082F6:  MOVLW  01
082F8:  MOVLB  7
082FA:  ADDWF  x12,W
082FC:  MOVWF  FE9
082FE:  MOVLW  00
08300:  ADDWFC x13,W
08302:  MOVWF  FEA
08304:  MOVF   FEF,F
08306:  BZ    8316
....................          fs->files--; 
08308:  MOVLW  01
0830A:  ADDWF  x12,W
0830C:  MOVWF  FE9
0830E:  MOVLW  00
08310:  ADDWFC x13,W
08312:  MOVWF  FEA
08314:  DECF   FEF,F
08316:  MOVLB  9
....................       } 
....................    return (res); 
08318:  MOVFF  9B2,01
0831C:  MOVLB  0
0831E:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0BCC6:  CALL   55D4
0BCCA:  MOVFF  01,88B
....................    if (res != FR_OK)  
0BCCE:  MOVLB  8
0BCD0:  MOVF   x8B,F
0BCD2:  BZ    BCDA
....................       return (res); 
0BCD4:  MOVFF  88B,01
0BCD8:  BRA    BF6A
....................  
....................    if (disk_status() & STA_PROTECT) 
0BCDA:  MOVLB  0
0BCDC:  CALL   55C6
0BCE0:  BTFSS  01.2
0BCE2:  BRA    BCEE
....................       return (FR_WRITE_PROTECTED); 
0BCE4:  MOVLW  0A
0BCE6:  MOVWF  01
0BCE8:  MOVLB  8
0BCEA:  BRA    BF6A
0BCEC:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0BCEE:  MOVLW  08
0BCF0:  MOVLB  9
0BCF2:  MOVWF  xD7
0BCF4:  MOVLW  98
0BCF6:  MOVWF  xD6
0BCF8:  MOVLW  08
0BCFA:  MOVWF  xD9
0BCFC:  MOVLW  A6
0BCFE:  MOVWF  xD8
0BD00:  MOVFF  88A,9DB
0BD04:  MOVFF  889,9DA
0BD08:  MOVLW  08
0BD0A:  MOVWF  xDD
0BD0C:  MOVLW  8C
0BD0E:  MOVWF  xDC
0BD10:  MOVLB  0
0BD12:  CALL   620A
0BD16:  MOVFF  01,88B
....................  
....................    if (res != FR_OK)  
0BD1A:  MOVLB  8
0BD1C:  MOVF   x8B,F
0BD1E:  BZ    BD26
....................       return (res);            // Trace failed  
0BD20:  MOVFF  88B,01
0BD24:  BRA    BF6A
....................  
....................    if (dir_ptr == NULL)  
0BD26:  MOVF   x8C,F
0BD28:  BNZ   BD34
0BD2A:  MOVF   x8D,F
0BD2C:  BNZ   BD34
....................       return (FR_NO_FILE);      // It is a root directory  
0BD2E:  MOVLW  02
0BD30:  MOVWF  01
0BD32:  BRA    BF6A
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0BD34:  MOVLW  0B
0BD36:  ADDWF  x8C,W
0BD38:  MOVWF  01
0BD3A:  MOVLW  00
0BD3C:  ADDWFC x8D,W
0BD3E:  MOVWF  03
0BD40:  MOVFF  01,FE9
0BD44:  MOVWF  FEA
0BD46:  BTFSS  FEF.0
0BD48:  BRA    BD50
....................       return (FR_DENIED);         // It is a R/O item  
0BD4A:  MOVLW  05
0BD4C:  MOVWF  01
0BD4E:  BRA    BF6A
....................  
....................    dsect = fs->winsect; 
0BD50:  MOVLW  20
0BD52:  MOVLB  7
0BD54:  ADDWF  x12,W
0BD56:  MOVWF  FE9
0BD58:  MOVLW  00
0BD5A:  ADDWFC x13,W
0BD5C:  MOVWF  FEA
0BD5E:  MOVFF  FEF,894
0BD62:  MOVFF  FEC,895
0BD66:  MOVFF  FEC,896
0BD6A:  MOVFF  FEC,897
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0BD6E:  MOVLW  14
0BD70:  MOVLB  8
0BD72:  ADDWF  x8C,W
0BD74:  MOVWF  01
0BD76:  MOVLW  00
0BD78:  ADDWFC x8D,W
0BD7A:  MOVWF  03
0BD7C:  MOVFF  01,FE9
0BD80:  MOVWF  FEA
0BD82:  MOVFF  FEC,893
0BD86:  MOVF   FED,F
0BD88:  MOVFF  FEF,8B2
0BD8C:  MOVFF  8B2,892
0BD90:  CLRF   xB2
0BD92:  CLRF   xB3
0BD94:  MOVLW  1A
0BD96:  ADDWF  x8C,W
0BD98:  MOVWF  01
0BD9A:  MOVLW  00
0BD9C:  ADDWFC x8D,W
0BD9E:  MOVFF  01,FE9
0BDA2:  MOVWF  FEA
0BDA4:  MOVFF  FEC,03
0BDA8:  MOVF   FED,F
0BDAA:  MOVF   FEF,W
0BDAC:  IORWF  xB2,W
0BDAE:  MOVWF  x90
0BDB0:  MOVF   03,W
0BDB2:  IORWF  xB3,W
0BDB4:  MOVWF  x91
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BDB6:  MOVLW  0B
0BDB8:  ADDWF  x8C,W
0BDBA:  MOVWF  01
0BDBC:  MOVLW  00
0BDBE:  ADDWFC x8D,W
0BDC0:  MOVWF  03
0BDC2:  MOVFF  01,FE9
0BDC6:  MOVWF  FEA
0BDC8:  BTFSS  FEF.4
0BDCA:  BRA    BEDE
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BDCC:  MOVFF  893,89F
0BDD0:  MOVFF  892,89E
0BDD4:  MOVFF  891,89D
0BDD8:  MOVFF  890,89C
....................       dirscan.sect = clust2sect(dclust); 
0BDDC:  MOVFF  893,9F2
0BDE0:  MOVFF  892,9F1
0BDE4:  MOVFF  891,9F0
0BDE8:  MOVFF  890,9EF
0BDEC:  MOVLB  0
0BDEE:  CALL   5636
0BDF2:  MOVFF  03,8A3
0BDF6:  MOVFF  02,8A2
0BDFA:  MOVFF  01,8A1
0BDFE:  MOVFF  00,8A0
....................       dirscan.index = 0; 
0BE02:  MOVLB  8
0BE04:  CLRF   xA5
0BE06:  CLRF   xA4
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BE08:  MOVFF  8A3,A17
0BE0C:  MOVFF  8A2,A16
0BE10:  MOVFF  8A1,A15
0BE14:  MOVFF  8A0,A14
0BE18:  MOVLB  0
0BE1A:  CALL   5AAA
0BE1E:  MOVF   01,F
0BE20:  BNZ   BE2C
....................             return (FR_RW_ERROR); 
0BE22:  MOVLW  07
0BE24:  MOVWF  01
0BE26:  MOVLB  8
0BE28:  BRA    BF6A
0BE2A:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BE2C:  MOVLB  8
0BE2E:  MOVF   xA4,W
0BE30:  ANDLW  0F
0BE32:  MOVWF  xB2
0BE34:  CLRF   xB3
0BE36:  RLCF   xB2,F
0BE38:  RLCF   xB3,F
0BE3A:  RLCF   xB2,F
0BE3C:  RLCF   xB3,F
0BE3E:  RLCF   xB2,F
0BE40:  RLCF   xB3,F
0BE42:  RLCF   xB2,F
0BE44:  RLCF   xB3,F
0BE46:  RLCF   xB2,F
0BE48:  RLCF   xB3,F
0BE4A:  MOVLW  E0
0BE4C:  ANDWF  xB2,F
0BE4E:  MOVLW  24
0BE50:  ADDWF  xB2,W
0BE52:  MOVWF  01
0BE54:  MOVLW  00
0BE56:  ADDWFC xB3,W
0BE58:  MOVWF  03
0BE5A:  MOVF   01,W
0BE5C:  MOVLB  7
0BE5E:  ADDWF  x12,W
0BE60:  MOVWF  01
0BE62:  MOVF   x13,W
0BE64:  ADDWFC 03,F
0BE66:  MOVFF  01,88E
0BE6A:  MOVLB  8
0BE6C:  MOVFF  03,88F
....................          if (*sdir == 0) 
0BE70:  MOVFF  88F,03
0BE74:  MOVFF  88E,FE9
0BE78:  MOVFF  88F,FEA
0BE7C:  MOVF   FEF,F
0BE7E:  BNZ   BE82
....................             break; 
0BE80:  BRA    BEDE
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BE82:  MOVFF  88F,03
0BE86:  MOVFF  88E,FE9
0BE8A:  MOVFF  88F,FEA
0BE8E:  MOVF   FEF,W
0BE90:  SUBLW  E5
0BE92:  BZ    BEC2
0BE94:  MOVFF  88F,03
0BE98:  MOVFF  88E,FE9
0BE9C:  MOVFF  88F,FEA
0BEA0:  MOVF   FEF,W
0BEA2:  SUBLW  2E
0BEA4:  BZ    BEC2
0BEA6:  MOVLW  0B
0BEA8:  ADDWF  x8E,W
0BEAA:  MOVWF  01
0BEAC:  MOVLW  00
0BEAE:  ADDWFC x8F,W
0BEB0:  MOVWF  03
0BEB2:  MOVFF  01,FE9
0BEB6:  MOVWF  FEA
0BEB8:  BTFSC  FEF.3
0BEBA:  BRA    BEC2
....................             return (FR_DENIED);   // The directory is not empty  
0BEBC:  MOVLW  05
0BEBE:  MOVWF  01
0BEC0:  BRA    BF6A
....................          } while (next_dir_ptr(&dirscan)); 
0BEC2:  MOVLW  08
0BEC4:  MOVLB  9
0BEC6:  MOVWF  xE6
0BEC8:  MOVLW  98
0BECA:  MOVWF  xE5
0BECC:  MOVLB  0
0BECE:  CALL   6030
0BED2:  MOVF   01,F
0BED4:  BTFSC  FD8.2
0BED6:  BRA    BEDC
0BED8:  MOVLB  8
0BEDA:  BRA    BE08
0BEDC:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BEDE:  MOVFF  897,A17
0BEE2:  MOVFF  896,A16
0BEE6:  MOVFF  895,A15
0BEEA:  MOVFF  894,A14
0BEEE:  MOVLB  0
0BEF0:  CALL   5AAA
0BEF4:  MOVF   01,F
0BEF6:  BNZ   BF02
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BEF8:  MOVLW  07
0BEFA:  MOVWF  01
0BEFC:  MOVLB  8
0BEFE:  BRA    BF6A
0BF00:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BF02:  MOVLB  8
0BF04:  MOVFF  88C,FE9
0BF08:  MOVFF  88D,FEA
0BF0C:  MOVLW  E5
0BF0E:  MOVWF  FEF
....................    fs->winflag = 1; 
0BF10:  MOVLW  06
0BF12:  MOVLB  7
0BF14:  ADDWF  x12,W
0BF16:  MOVWF  FE9
0BF18:  MOVLW  00
0BF1A:  ADDWFC x13,W
0BF1C:  MOVWF  FEA
0BF1E:  MOVLW  01
0BF20:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BF22:  MOVFF  893,9DE
0BF26:  MOVFF  892,9DD
0BF2A:  MOVFF  891,9DC
0BF2E:  MOVFF  890,9DB
0BF32:  MOVLB  0
0BF34:  CALL   6F6E
0BF38:  MOVF   01,F
0BF3A:  BNZ   BF46
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BF3C:  MOVLW  07
0BF3E:  MOVWF  01
0BF40:  MOVLB  8
0BF42:  BRA    BF6A
0BF44:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BF46:  MOVLB  A
0BF48:  CLRF   x17
0BF4A:  CLRF   x16
0BF4C:  CLRF   x15
0BF4E:  CLRF   x14
0BF50:  MOVLB  0
0BF52:  CALL   5AAA
0BF56:  MOVF   01,F
0BF58:  BNZ   BF64
....................       return (FR_RW_ERROR); 
0BF5A:  MOVLW  07
0BF5C:  MOVWF  01
0BF5E:  MOVLB  8
0BF60:  BRA    BF6A
0BF62:  MOVLB  0
....................  
....................    return (FR_OK); 
0BF64:  MOVLW  00
0BF66:  MOVWF  01
0BF68:  MOVLB  8
0BF6A:  MOVLB  0
0BF6C:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
079E4:  MOVFF  9B1,9B3
079E8:  MOVFF  9B0,9B2
079EC:  MOVFF  9B3,03
079F0:  MOVLB  9
079F2:  MOVFF  9B2,FE9
079F6:  MOVFF  9B3,FEA
079FA:  MOVF   FEF,F
079FC:  BZ    7A0A
079FE:  INCF   xB2,F
07A00:  BTFSC  FD8.2
07A02:  INCF   xB3,F
07A04:  MOVLB  0
07A06:  BRA    79EC
07A08:  MOVLB  9
....................    return(sc - s); 
07A0A:  MOVF   xB0,W
07A0C:  SUBWF  xB2,W
07A0E:  MOVWF  00
07A10:  MOVF   xB1,W
07A12:  SUBWFB xB3,W
07A14:  MOVWF  03
07A16:  MOVFF  00,01
07A1A:  MOVWF  02
07A1C:  MOVLB  0
07A1E:  GOTO   8466 (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
03530:  MOVLB  4
03532:  CLRF   xE6
03534:  MOVLW  01
03536:  MOVWF  xE5
....................    rtc.year=10; 
03538:  MOVLW  0A
0353A:  MOVWF  xE4
....................    rtc.month=1; 
0353C:  MOVLW  01
0353E:  MOVWF  xE3
....................    rtc.day=1; 
03540:  MOVWF  xE2
....................    rtc.hour=0; 
03542:  CLRF   xE1
....................    rtc.min=0; 
03544:  CLRF   xE0
....................    rtc.sec=0; 
03546:  CLRF   xDF
....................    rtc.ms100=0; 
03548:  CLRF   xDE
0354A:  MOVLB  0
0354C:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
07010:  MOVLB  9
07012:  CLRF   xDD
07014:  CLRF   xDC
07016:  CLRF   xDB
07018:  MOVFF  4E4,9DA
0701C:  MOVLW  14
0701E:  ADDWF  xDA,F
07020:  MOVLW  00
07022:  ADDWFC xDB,F
07024:  ADDWFC xDC,F
07026:  ADDWFC xDD,F
07028:  BCF    FD8.0
0702A:  CLRF   xD6
0702C:  CLRF   xD7
0702E:  CLRF   xD8
07030:  RLCF   xDA,W
07032:  MOVWF  xD9
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
07034:  CLRF   xDD
07036:  CLRF   xDC
07038:  CLRF   xDB
0703A:  MOVFF  4E3,9DA
0703E:  MOVLW  0F
07040:  ANDWF  xDA,F
07042:  CLRF   xDB
07044:  CLRF   xDC
07046:  CLRF   xDD
07048:  CLRF   00
0704A:  CLRF   01
0704C:  RLCF   xDA,W
0704E:  MOVWF  02
07050:  RLCF   xDB,W
07052:  MOVWF  03
07054:  RLCF   02,F
07056:  RLCF   03,F
07058:  RLCF   02,F
0705A:  RLCF   03,F
0705C:  RLCF   02,F
0705E:  RLCF   03,F
07060:  RLCF   02,F
07062:  RLCF   03,F
07064:  MOVLW  E0
07066:  ANDWF  02,F
07068:  MOVF   00,W
0706A:  IORWF  xD6,F
0706C:  MOVF   01,W
0706E:  IORWF  xD7,F
07070:  MOVF   02,W
07072:  IORWF  xD8,F
07074:  MOVF   03,W
07076:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
07078:  CLRF   xDD
0707A:  CLRF   xDC
0707C:  CLRF   xDB
0707E:  MOVFF  4E2,9DA
07082:  MOVLW  1F
07084:  ANDWF  xDA,F
07086:  CLRF   xDB
07088:  CLRF   xDC
0708A:  CLRF   xDD
0708C:  CLRF   00
0708E:  CLRF   01
07090:  MOVF   00,W
07092:  IORWF  xD6,F
07094:  MOVF   01,W
07096:  IORWF  xD7,F
07098:  MOVF   xDA,W
0709A:  IORWF  xD8,F
0709C:  MOVF   xDB,W
0709E:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
070A0:  CLRF   xDD
070A2:  CLRF   xDC
070A4:  CLRF   xDB
070A6:  MOVFF  4E1,9DA
070AA:  MOVLW  1F
070AC:  ANDWF  xDA,F
070AE:  CLRF   xDB
070B0:  CLRF   xDC
070B2:  CLRF   xDD
070B4:  CLRF   00
070B6:  RLCF   xDA,W
070B8:  MOVWF  01
070BA:  RLCF   xDB,W
070BC:  MOVWF  02
070BE:  RLCF   xDC,W
070C0:  MOVWF  03
070C2:  RLCF   01,F
070C4:  RLCF   02,F
070C6:  RLCF   03,F
070C8:  RLCF   01,F
070CA:  RLCF   02,F
070CC:  RLCF   03,F
070CE:  MOVLW  F8
070D0:  ANDWF  01,F
070D2:  MOVF   00,W
070D4:  IORWF  xD6,F
070D6:  MOVF   01,W
070D8:  IORWF  xD7,F
070DA:  MOVF   02,W
070DC:  IORWF  xD8,F
070DE:  MOVF   03,W
070E0:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
070E2:  CLRF   xDD
070E4:  CLRF   xDC
070E6:  CLRF   xDB
070E8:  MOVFF  4E0,9DA
070EC:  MOVLW  3F
070EE:  ANDWF  xDA,F
070F0:  CLRF   xDB
070F2:  CLRF   xDC
070F4:  CLRF   xDD
070F6:  RLCF   xDA,W
070F8:  MOVWF  00
070FA:  RLCF   xDB,W
070FC:  MOVWF  01
070FE:  RLCF   xDC,W
07100:  MOVWF  02
07102:  RLCF   xDD,W
07104:  MOVWF  03
07106:  RLCF   00,F
07108:  RLCF   01,F
0710A:  RLCF   02,F
0710C:  RLCF   03,F
0710E:  RLCF   00,F
07110:  RLCF   01,F
07112:  RLCF   02,F
07114:  RLCF   03,F
07116:  RLCF   00,F
07118:  RLCF   01,F
0711A:  RLCF   02,F
0711C:  RLCF   03,F
0711E:  RLCF   00,F
07120:  RLCF   01,F
07122:  RLCF   02,F
07124:  RLCF   03,F
07126:  MOVLW  E0
07128:  ANDWF  00,F
0712A:  MOVF   00,W
0712C:  IORWF  xD6,F
0712E:  MOVF   01,W
07130:  IORWF  xD7,F
07132:  MOVF   02,W
07134:  IORWF  xD8,F
07136:  MOVF   03,W
07138:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
0713A:  CLRF   xDD
0713C:  CLRF   xDC
0713E:  CLRF   xDB
07140:  MOVFF  4DF,9DA
07144:  MOVLW  3F
07146:  ANDWF  xDA,F
07148:  CLRF   xDB
0714A:  CLRF   xDC
0714C:  CLRF   xDD
0714E:  BCF    FD8.0
07150:  RRCF   xDD,W
07152:  MOVWF  03
07154:  RRCF   xDC,W
07156:  MOVWF  02
07158:  RRCF   xDB,W
0715A:  MOVWF  01
0715C:  RRCF   xDA,W
0715E:  IORWF  xD6,F
07160:  MOVF   01,W
07162:  IORWF  xD7,F
07164:  MOVF   02,W
07166:  IORWF  xD8,F
07168:  MOVF   03,W
0716A:  IORWF  xD9,F
....................    return (work); 
0716C:  MOVFF  9D6,00
07170:  MOVFF  9D7,01
07174:  MOVFF  9D8,02
07178:  MOVFF  9D9,03
0717C:  MOVLB  0
0717E:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0BB4C:  MOVLW  08
0BB4E:  MOVLB  9
0BB50:  MOVWF  xB1
0BB52:  MOVLW  8B
0BB54:  MOVWF  xB0
0BB56:  MOVFF  88A,9B3
0BB5A:  MOVFF  889,9B2
0BB5E:  MOVLW  01
0BB60:  MOVWF  xB4
0BB62:  MOVLB  0
0BB64:  CALL   7180
0BB68:  MOVFF  01,8A7
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0BB6C:  MOVLB  8
0BB6E:  MOVF   xA7,F
0BB70:  BTFSS  FD8.2
0BB72:  BRA    BC74
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0BB74:  MOVLW  08
0BB76:  MOVWF  xCD
0BB78:  MOVLW  8B
0BB7A:  MOVWF  xCC
0BB7C:  MOVLW  08
0BB7E:  MOVWF  xCF
0BB80:  MOVLW  A8
0BB82:  MOVWF  xCE
0BB84:  CLRF   xD1
0BB86:  MOVLW  20
0BB88:  MOVWF  xD0
0BB8A:  MOVLW  08
0BB8C:  MOVWF  xD3
0BB8E:  MOVLW  CA
0BB90:  MOVWF  xD2
0BB92:  MOVLB  0
0BB94:  BRA    B490
0BB96:  MOVFF  01,8A7
....................          for (i = 0; i < br; i++) 
0BB9A:  MOVLB  8
0BB9C:  CLRF   xC9
0BB9E:  CLRF   xC8
0BBA0:  MOVF   xC9,W
0BBA2:  SUBWF  xCB,W
0BBA4:  BNC   BBD0
0BBA6:  BNZ   BBAE
0BBA8:  MOVF   xCA,W
0BBAA:  SUBWF  xC8,W
0BBAC:  BC    BBD0
....................          { 
....................             putc(mesg[i]); 
0BBAE:  MOVLW  A8
0BBB0:  ADDWF  xC8,W
0BBB2:  MOVWF  FE9
0BBB4:  MOVLW  08
0BBB6:  ADDWFC xC9,W
0BBB8:  MOVWF  FEA
0BBBA:  MOVFF  FEF,8CC
0BBBE:  MOVF   xCC,W
0BBC0:  MOVLB  0
0BBC2:  CALL   AEE0
0BBC6:  MOVLB  8
0BBC8:  INCF   xC8,F
0BBCA:  BTFSC  FD8.2
0BBCC:  INCF   xC9,F
0BBCE:  BRA    BBA0
....................          } 
....................       } while ((result == FR_OK) && br); 
0BBD0:  MOVF   xA7,F
0BBD2:  BNZ   BBDA
0BBD4:  MOVF   xCA,W
0BBD6:  IORWF  xCB,W
0BBD8:  BNZ   BB74
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0BBDA:  MOVF   xA7,F
0BBDC:  BZ    BC50
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0BBDE:  MOVLW  1A
0BBE0:  MOVWF  FF6
0BBE2:  MOVLW  0C
0BBE4:  MOVWF  FF7
0BBE6:  MOVLW  00
0BBE8:  MOVWF  FF8
0BBEA:  CLRF   1B
0BBEC:  BTFSC  FF2.7
0BBEE:  BSF    1B.7
0BBF0:  BCF    FF2.7
0BBF2:  MOVLB  0
0BBF4:  CALL   0E6E
0BBF8:  BTFSC  1B.7
0BBFA:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0BBFC:  MOVFF  8A7,8CC
0BC00:  MOVLW  08
0BC02:  MOVLB  8
0BC04:  MOVWF  xCE
0BC06:  MOVLW  A8
0BC08:  MOVWF  xCD
0BC0A:  MOVLB  0
0BC0C:  RCALL  B99E
....................          printf("@FS: %s\r\n",mesg); 
0BC0E:  MOVLW  30
0BC10:  MOVWF  FF6
0BC12:  MOVLW  0C
0BC14:  MOVWF  FF7
0BC16:  MOVLW  00
0BC18:  MOVWF  FF8
0BC1A:  CLRF   1B
0BC1C:  BTFSC  FF2.7
0BC1E:  BSF    1B.7
0BC20:  BCF    FF2.7
0BC22:  MOVLW  05
0BC24:  MOVLB  A
0BC26:  MOVWF  x40
0BC28:  MOVLB  0
0BC2A:  CALL   1044
0BC2E:  BTFSC  1B.7
0BC30:  BSF    FF2.7
0BC32:  MOVLW  08
0BC34:  MOVWF  FEA
0BC36:  MOVLW  A8
0BC38:  MOVWF  FE9
0BC3A:  CALL   79BE
0BC3E:  MOVLW  0D
0BC40:  BTFSS  F9E.4
0BC42:  BRA    BC40
0BC44:  MOVWF  FAD
0BC46:  MOVLW  0A
0BC48:  BTFSS  F9E.4
0BC4A:  BRA    BC48
0BC4C:  MOVWF  FAD
0BC4E:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0BC50:  MOVLW  08
0BC52:  MOVLB  9
0BC54:  MOVWF  xB1
0BC56:  MOVLW  8B
0BC58:  MOVWF  xB0
0BC5A:  MOVLB  0
0BC5C:  CALL   82D4
....................       printf("\r\n");       
0BC60:  MOVLW  0D
0BC62:  BTFSS  F9E.4
0BC64:  BRA    BC62
0BC66:  MOVWF  FAD
0BC68:  MOVLW  0A
0BC6A:  BTFSS  F9E.4
0BC6C:  BRA    BC6A
0BC6E:  MOVWF  FAD
....................    } 
0BC70:  BRA    BCC4
0BC72:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0BC74:  MOVFF  8A7,8CC
0BC78:  MOVLW  08
0BC7A:  MOVWF  xCE
0BC7C:  MOVLW  A8
0BC7E:  MOVWF  xCD
0BC80:  MOVLB  0
0BC82:  RCALL  B99E
....................       printf("@FS: %s\r\n",mesg); 
0BC84:  MOVLW  3A
0BC86:  MOVWF  FF6
0BC88:  MOVLW  0C
0BC8A:  MOVWF  FF7
0BC8C:  MOVLW  00
0BC8E:  MOVWF  FF8
0BC90:  CLRF   1B
0BC92:  BTFSC  FF2.7
0BC94:  BSF    1B.7
0BC96:  BCF    FF2.7
0BC98:  MOVLW  05
0BC9A:  MOVLB  A
0BC9C:  MOVWF  x40
0BC9E:  MOVLB  0
0BCA0:  CALL   1044
0BCA4:  BTFSC  1B.7
0BCA6:  BSF    FF2.7
0BCA8:  MOVLW  08
0BCAA:  MOVWF  FEA
0BCAC:  MOVLW  A8
0BCAE:  MOVWF  FE9
0BCB0:  CALL   79BE
0BCB4:  MOVLW  0D
0BCB6:  BTFSS  F9E.4
0BCB8:  BRA    BCB6
0BCBA:  MOVWF  FAD
0BCBC:  MOVLW  0A
0BCBE:  BTFSS  F9E.4
0BCC0:  BRA    BCBE
0BCC2:  MOVWF  FAD
....................    } 
0BCC4:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04E1C:  MOVLW  44
04E1E:  MOVWF  FF6
04E20:  MOVLW  0C
04E22:  MOVWF  FF7
04E24:  MOVLW  00
04E26:  MOVWF  FF8
04E28:  CLRF   1B
04E2A:  BTFSC  FF2.7
04E2C:  BSF    1B.7
04E2E:  BCF    FF2.7
04E30:  CALL   0E6E
04E34:  BTFSC  1B.7
04E36:  BSF    FF2.7
....................    if (status & FR_OK) 
04E38:  ANDLW  00
04E3A:  BZ    4E58
....................       printf("   NoError\r\n"); 
04E3C:  MOVLW  54
04E3E:  MOVWF  FF6
04E40:  MOVLW  0C
04E42:  MOVWF  FF7
04E44:  MOVLW  00
04E46:  MOVWF  FF8
04E48:  CLRF   1B
04E4A:  BTFSC  FF2.7
04E4C:  BSF    1B.7
04E4E:  BCF    FF2.7
04E50:  CALL   0E6E
04E54:  BTFSC  1B.7
04E56:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04E58:  MOVLB  8
04E5A:  BTFSS  x8A.0
04E5C:  BRA    4E7E
....................       printf("   Media Not Ready\r\n"); 
04E5E:  MOVLW  62
04E60:  MOVWF  FF6
04E62:  MOVLW  0C
04E64:  MOVWF  FF7
04E66:  MOVLW  00
04E68:  MOVWF  FF8
04E6A:  CLRF   1B
04E6C:  BTFSC  FF2.7
04E6E:  BSF    1B.7
04E70:  BCF    FF2.7
04E72:  MOVLB  0
04E74:  CALL   0E6E
04E78:  BTFSC  1B.7
04E7A:  BSF    FF2.7
04E7C:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04E7E:  BTFSS  x8A.1
04E80:  BRA    4EA2
....................       printf("   File Not Found\r\n"); 
04E82:  MOVLW  78
04E84:  MOVWF  FF6
04E86:  MOVLW  0C
04E88:  MOVWF  FF7
04E8A:  MOVLW  00
04E8C:  MOVWF  FF8
04E8E:  CLRF   1B
04E90:  BTFSC  FF2.7
04E92:  BSF    1B.7
04E94:  BCF    FF2.7
04E96:  MOVLB  0
04E98:  CALL   0E6E
04E9C:  BTFSC  1B.7
04E9E:  BSF    FF2.7
04EA0:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04EA2:  MOVF   x8A,W
04EA4:  ANDLW  03
04EA6:  BZ    4EC8
....................       printf("   Invalid Path\r\n"); 
04EA8:  MOVLW  8C
04EAA:  MOVWF  FF6
04EAC:  MOVLW  0C
04EAE:  MOVWF  FF7
04EB0:  MOVLW  00
04EB2:  MOVWF  FF8
04EB4:  CLRF   1B
04EB6:  BTFSC  FF2.7
04EB8:  BSF    1B.7
04EBA:  BCF    FF2.7
04EBC:  MOVLB  0
04EBE:  CALL   0E6E
04EC2:  BTFSC  1B.7
04EC4:  BSF    FF2.7
04EC6:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04EC8:  BTFSS  x8A.2
04ECA:  BRA    4EEC
....................       printf("   Invalid Name\r\n"); 
04ECC:  MOVLW  9E
04ECE:  MOVWF  FF6
04ED0:  MOVLW  0C
04ED2:  MOVWF  FF7
04ED4:  MOVLW  00
04ED6:  MOVWF  FF8
04ED8:  CLRF   1B
04EDA:  BTFSC  FF2.7
04EDC:  BSF    1B.7
04EDE:  BCF    FF2.7
04EE0:  MOVLB  0
04EE2:  CALL   0E6E
04EE6:  BTFSC  1B.7
04EE8:  BSF    FF2.7
04EEA:  MOVLB  8
....................    if (status & FR_DENIED) 
04EEC:  MOVF   x8A,W
04EEE:  ANDLW  05
04EF0:  BZ    4F12
....................       printf("   Access Denied\r\n"); 
04EF2:  MOVLW  B0
04EF4:  MOVWF  FF6
04EF6:  MOVLW  0C
04EF8:  MOVWF  FF7
04EFA:  MOVLW  00
04EFC:  MOVWF  FF8
04EFE:  CLRF   1B
04F00:  BTFSC  FF2.7
04F02:  BSF    1B.7
04F04:  BCF    FF2.7
04F06:  MOVLB  0
04F08:  CALL   0E6E
04F0C:  BTFSC  1B.7
04F0E:  BSF    FF2.7
04F10:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04F12:  MOVF   x8A,W
04F14:  ANDLW  06
04F16:  BZ    4F38
....................       printf("   Disk Full\r\n"); 
04F18:  MOVLW  C4
04F1A:  MOVWF  FF6
04F1C:  MOVLW  0C
04F1E:  MOVWF  FF7
04F20:  MOVLW  00
04F22:  MOVWF  FF8
04F24:  CLRF   1B
04F26:  BTFSC  FF2.7
04F28:  BSF    1B.7
04F2A:  BCF    FF2.7
04F2C:  MOVLB  0
04F2E:  CALL   0E6E
04F32:  BTFSC  1B.7
04F34:  BSF    FF2.7
04F36:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04F38:  MOVF   x8A,W
04F3A:  ANDLW  07
04F3C:  BZ    4F5E
....................       printf("   Read/Write Error\r\n"); 
04F3E:  MOVLW  D4
04F40:  MOVWF  FF6
04F42:  MOVLW  0C
04F44:  MOVWF  FF7
04F46:  MOVLW  00
04F48:  MOVWF  FF8
04F4A:  CLRF   1B
04F4C:  BTFSC  FF2.7
04F4E:  BSF    1B.7
04F50:  BCF    FF2.7
04F52:  MOVLB  0
04F54:  CALL   0E6E
04F58:  BTFSC  1B.7
04F5A:  BSF    FF2.7
04F5C:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04F5E:  MOVF   x8A,W
04F60:  ANDLW  09
04F62:  BZ    4F84
....................       printf("   Incorrect Media Change\r\n"); 
04F64:  MOVLW  EA
04F66:  MOVWF  FF6
04F68:  MOVLW  0C
04F6A:  MOVWF  FF7
04F6C:  MOVLW  00
04F6E:  MOVWF  FF8
04F70:  CLRF   1B
04F72:  BTFSC  FF2.7
04F74:  BSF    1B.7
04F76:  BCF    FF2.7
04F78:  MOVLB  0
04F7A:  CALL   0E6E
04F7E:  BTFSC  1B.7
04F80:  BSF    FF2.7
04F82:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04F84:  MOVF   x8A,W
04F86:  ANDLW  0A
04F88:  BZ    4FAA
....................       printf("   Write Protected\r\n"); 
04F8A:  MOVLW  06
04F8C:  MOVWF  FF6
04F8E:  MOVLW  0D
04F90:  MOVWF  FF7
04F92:  MOVLW  00
04F94:  MOVWF  FF8
04F96:  CLRF   1B
04F98:  BTFSC  FF2.7
04F9A:  BSF    1B.7
04F9C:  BCF    FF2.7
04F9E:  MOVLB  0
04FA0:  CALL   0E6E
04FA4:  BTFSC  1B.7
04FA6:  BSF    FF2.7
04FA8:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04FAA:  MOVF   x8A,W
04FAC:  ANDLW  0B
04FAE:  BZ    4FD0
....................       printf("   Not Enabled\r\n"); 
04FB0:  MOVLW  1C
04FB2:  MOVWF  FF6
04FB4:  MOVLW  0D
04FB6:  MOVWF  FF7
04FB8:  MOVLW  00
04FBA:  MOVWF  FF8
04FBC:  CLRF   1B
04FBE:  BTFSC  FF2.7
04FC0:  BSF    1B.7
04FC2:  BCF    FF2.7
04FC4:  MOVLB  0
04FC6:  CALL   0E6E
04FCA:  BTFSC  1B.7
04FCC:  BSF    FF2.7
04FCE:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04FD0:  MOVF   x8A,W
04FD2:  ANDLW  0C
04FD4:  BZ    4FF6
....................       printf("   No File System\r\n"); 
04FD6:  MOVLW  2E
04FD8:  MOVWF  FF6
04FDA:  MOVLW  0D
04FDC:  MOVWF  FF7
04FDE:  MOVLW  00
04FE0:  MOVWF  FF8
04FE2:  CLRF   1B
04FE4:  BTFSC  FF2.7
04FE6:  BSF    1B.7
04FE8:  BCF    FF2.7
04FEA:  MOVLB  0
04FEC:  CALL   0E6E
04FF0:  BTFSC  1B.7
04FF2:  BSF    FF2.7
04FF4:  MOVLB  8
04FF6:  MOVLB  0
04FF8:  GOTO   5082 (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
08320:  MOVLW  09
08322:  MOVWF  FEA
08324:  MOVLW  10
08326:  MOVWF  FE9
08328:  CLRF   00
0832A:  CLRF   02
0832C:  MOVLW  A0
0832E:  MOVWF  01
08330:  CALL   354E
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
08334:  MOVLW  08
08336:  MOVLB  9
08338:  MOVWF  xB1
0833A:  MOVLW  EF
0833C:  MOVWF  xB0
0833E:  MOVFF  8EE,9B3
08342:  MOVFF  8ED,9B2
08346:  MOVLW  12
08348:  MOVWF  xB4
0834A:  MOVLB  0
0834C:  CALL   7180
08350:  MOVFF  01,90B
....................    if (result) 
08354:  MOVLB  9
08356:  MOVF   x0B,F
08358:  BZ    837C
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
0835A:  MOVLW  42
0835C:  MOVWF  FF6
0835E:  MOVLW  0D
08360:  MOVWF  FF7
08362:  MOVLW  00
08364:  MOVWF  FF8
08366:  CLRF   1B
08368:  BTFSC  FF2.7
0836A:  BSF    1B.7
0836C:  BCF    FF2.7
0836E:  MOVLB  0
08370:  CALL   0E6E
08374:  BTFSC  1B.7
08376:  BSF    FF2.7
....................    } 
08378:  BRA    84F8
0837A:  MOVLB  9
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
0837C:  MOVLB  8
0837E:  MOVF   xF3,F
08380:  BNZ   838E
08382:  MOVF   xF4,F
08384:  BNZ   838E
08386:  MOVF   xF5,F
08388:  BNZ   838E
0838A:  MOVF   xF6,F
0838C:  BZ    83B4
....................          result = f_lseek(&fdst, fdst.fsize);  
0838E:  MOVLW  08
08390:  MOVLB  9
08392:  MOVWF  xB1
08394:  MOVLW  EF
08396:  MOVWF  xB0
08398:  MOVFF  8F6,9B5
0839C:  MOVFF  8F5,9B4
083A0:  MOVFF  8F4,9B3
083A4:  MOVFF  8F3,9B2
083A8:  MOVLB  0
083AA:  GOTO   75C8
083AE:  MOVFF  01,90B
083B2:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
083B4:  MOVLB  0
083B6:  MOVF   x66,F
083B8:  BNZ   83D6
083BA:  MOVLW  09
083BC:  MOVLB  9
083BE:  MOVWF  xB1
083C0:  MOVLW  10
083C2:  MOVWF  xB0
083C4:  CLRF   xB3
083C6:  MOVLW  67
083C8:  MOVWF  xB2
083CA:  CLRF   xB5
083CC:  MOVLW  9F
083CE:  MOVWF  xB4
083D0:  MOVLB  0
083D2:  CALL   7930
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
083D6:  DECFSZ x66,W
083D8:  BRA    83F8
083DA:  MOVLW  09
083DC:  MOVLB  9
083DE:  MOVWF  xB1
083E0:  MOVLW  10
083E2:  MOVWF  xB0
083E4:  MOVLW  01
083E6:  MOVWF  xB3
083E8:  MOVLW  07
083EA:  MOVWF  xB2
083EC:  CLRF   xB5
083EE:  MOVLW  9F
083F0:  MOVWF  xB4
083F2:  MOVLB  0
083F4:  CALL   7930
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
083F8:  MOVF   20,F
083FA:  BNZ   8402
083FC:  MOVF   1F,W
083FE:  SUBLW  04
08400:  BC    8456
08402:  MOVLW  62
08404:  MOVWF  FF6
08406:  MOVLW  0D
08408:  MOVWF  FF7
0840A:  MOVLW  00
0840C:  MOVWF  FF8
0840E:  CLRF   1B
08410:  BTFSC  FF2.7
08412:  BSF    1B.7
08414:  BCF    FF2.7
08416:  MOVLW  0E
08418:  MOVLB  A
0841A:  MOVWF  x40
0841C:  MOVLB  0
0841E:  CALL   1044
08422:  BTFSC  1B.7
08424:  BSF    FF2.7
08426:  MOVLW  09
08428:  MOVWF  FEA
0842A:  MOVLW  10
0842C:  MOVWF  FE9
0842E:  CALL   79BE
08432:  MOVLW  72
08434:  MOVWF  FF6
08436:  MOVLW  0D
08438:  MOVWF  FF7
0843A:  MOVLW  00
0843C:  MOVWF  FF8
0843E:  CLRF   1B
08440:  BTFSC  FF2.7
08442:  BSF    1B.7
08444:  BCF    FF2.7
08446:  MOVLW  03
08448:  MOVLB  A
0844A:  MOVWF  x40
0844C:  MOVLB  0
0844E:  CALL   1044
08452:  BTFSC  1B.7
08454:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
08456:  MOVLW  09
08458:  MOVLB  9
0845A:  MOVWF  xB1
0845C:  MOVLW  10
0845E:  MOVWF  xB0
08460:  MOVLB  0
08462:  GOTO   79E4
08466:  MOVFF  02,90D
0846A:  MOVFF  01,90C
....................       result = f_write(&fdst, mesg, btw, &bw); 
0846E:  MOVLW  08
08470:  MOVLB  9
08472:  MOVWF  xB1
08474:  MOVLW  EF
08476:  MOVWF  xB0
08478:  MOVLW  09
0847A:  MOVWF  xB3
0847C:  MOVLW  10
0847E:  MOVWF  xB2
08480:  MOVFF  90D,9B5
08484:  MOVFF  90C,9B4
08488:  MOVLW  09
0848A:  MOVWF  xB7
0848C:  MOVLW  0E
0848E:  MOVWF  xB6
08490:  MOVLB  0
08492:  GOTO   7A22
08496:  MOVFF  01,90B
....................       if (result) 
0849A:  MOVLB  9
0849C:  MOVF   x0B,F
0849E:  BZ    84C2
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
084A0:  MOVLW  76
084A2:  MOVWF  FF6
084A4:  MOVLW  0D
084A6:  MOVWF  FF7
084A8:  MOVLW  00
084AA:  MOVWF  FF8
084AC:  CLRF   1B
084AE:  BTFSC  FF2.7
084B0:  BSF    1B.7
084B2:  BCF    FF2.7
084B4:  MOVLB  0
084B6:  CALL   0E6E
084BA:  BTFSC  1B.7
084BC:  BSF    FF2.7
....................       } 
084BE:  BRA    84EA
084C0:  MOVLB  9
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
084C2:  MOVF   20,F
084C4:  BNZ   84CC
084C6:  MOVF   1F,W
084C8:  SUBLW  04
084CA:  BC    84EC
084CC:  MOVLW  8A
084CE:  MOVWF  FF6
084D0:  MOVLW  0D
084D2:  MOVWF  FF7
084D4:  MOVLW  00
084D6:  MOVWF  FF8
084D8:  CLRF   1B
084DA:  BTFSC  FF2.7
084DC:  BSF    1B.7
084DE:  BCF    FF2.7
084E0:  MOVLB  0
084E2:  CALL   0E6E
084E6:  BTFSC  1B.7
084E8:  BSF    FF2.7
084EA:  MOVLB  9
....................       } 
....................  
....................       f_close(&fdst); 
084EC:  MOVLW  08
084EE:  MOVWF  xB1
084F0:  MOVLW  EF
084F2:  MOVWF  xB0
084F4:  MOVLB  0
084F6:  RCALL  82D4
....................    } 
....................  
....................    return (result); 
084F8:  MOVLB  9
084FA:  MOVFF  90B,01
084FE:  MOVLB  0
08500:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
17BCE:  CLRF   1B
17BD0:  BTFSC  FF2.7
17BD2:  BSF    1B.7
17BD4:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
17BD6:  MOVFF  887,A42
17BDA:  MOVLW  0A
17BDC:  MOVLB  A
17BDE:  MOVWF  x43
17BE0:  MOVLB  0
17BE2:  CALL   0F9A
17BE6:  BTFSC  1B.7
17BE8:  BSF    FF2.7
17BEA:  MOVFF  01,888
....................    nibl=data-(nibh*10); 
17BEE:  MOVLB  8
17BF0:  MOVF   x88,W
17BF2:  MULLW  0A
17BF4:  MOVF   FF3,W
17BF6:  SUBWF  x87,W
17BF8:  MOVWF  x89
....................  
....................    return((nibh<<4)|nibl); 
17BFA:  SWAPF  x88,W
17BFC:  MOVWF  00
17BFE:  MOVLW  F0
17C00:  ANDWF  00,F
17C02:  MOVF   00,W
17C04:  IORWF  x89,W
17C06:  MOVWF  01
17C08:  MOVLB  0
17C0A:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
0333A:  MOVFF  8EE,8EF
....................    data=(i>>4)*10; 
0333E:  MOVLB  8
03340:  SWAPF  xEF,W
03342:  MOVWF  00
03344:  MOVLW  0F
03346:  ANDWF  00,F
03348:  MOVF   00,W
0334A:  MULLW  0A
0334C:  MOVFF  FF3,8EE
....................    data=data+(i<<4>>4); 
03350:  SWAPF  xEF,W
03352:  MOVWF  00
03354:  MOVLW  F0
03356:  ANDWF  00,F
03358:  MOVF   00,W
0335A:  SWAPF  00,F
0335C:  MOVLW  0F
0335E:  ANDWF  00,F
03360:  MOVF   00,W
03362:  ADDWF  xEE,F
....................  
....................    return data; 
03364:  MOVFF  8EE,01
03368:  MOVLB  0
0336A:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
034DA:  MOVLB  8
034DC:  CLRF   xCB
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
034DE:  BCF    FC6.5
034E0:  MOVLW  21
034E2:  MOVWF  FC6
034E4:  MOVLW  40
034E6:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
034E8:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
034EA:  MOVF   FC9,W
034EC:  MOVLW  0C
034EE:  MOVWF  FC9
034F0:  RRCF   FC7,W
034F2:  BNC   34F0
034F4:  MOVFF  FC9,8CB
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
034F8:  MOVF   FC9,W
034FA:  MOVFF  8CB,FC9
034FE:  RRCF   FC7,W
03500:  BNC   34FE
03502:  MOVFF  FC9,730
....................    output_bit(RTC_CS, DISABLE); 
03506:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
03508:  MOVLB  7
0350A:  BCF    x30.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
0350C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
0350E:  MOVF   FC9,W
03510:  MOVLW  8C
03512:  MOVWF  FC9
03514:  RRCF   FC7,W
03516:  BNC   3514
03518:  MOVFF  FC9,8CB
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
0351C:  MOVF   FC9,W
0351E:  MOVFF  730,FC9
03522:  RRCF   FC7,W
03524:  BNC   3522
03526:  MOVFF  FC9,8CB
....................    output_bit(RTC_CS, DISABLE); 
0352A:  BSF    F91.0
0352C:  MOVLB  0
0352E:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0E2B2:  MOVLW  1A
0E2B4:  MOVLB  8
0E2B6:  MOVWF  x97
0E2B8:  MOVLB  0
0E2BA:  CALL   29F2
0E2BE:  MOVFF  01,4F
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0E2C2:  MOVF   4F,F
0E2C4:  BNZ   E332
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0E2C6:  MOVLW  98
0E2C8:  MOVWF  FF6
0E2CA:  MOVLW  0D
0E2CC:  MOVWF  FF7
0E2CE:  MOVLW  00
0E2D0:  MOVWF  FF8
0E2D2:  CLRF   1B
0E2D4:  BTFSC  FF2.7
0E2D6:  BSF    1B.7
0E2D8:  BCF    FF2.7
0E2DA:  MOVLW  05
0E2DC:  MOVLB  A
0E2DE:  MOVWF  x40
0E2E0:  MOVLB  0
0E2E2:  CALL   1044
0E2E6:  BTFSC  1B.7
0E2E8:  BSF    FF2.7
0E2EA:  CLRF   1B
0E2EC:  BTFSC  FF2.7
0E2EE:  BSF    1B.7
0E2F0:  BCF    FF2.7
0E2F2:  MOVFF  72A,A40
0E2F6:  MOVLW  01
0E2F8:  MOVLB  A
0E2FA:  MOVWF  x41
0E2FC:  MOVLB  0
0E2FE:  CALL   0FC6
0E302:  BTFSC  1B.7
0E304:  BSF    FF2.7
0E306:  MOVLW  2F
0E308:  BTFSS  F9E.4
0E30A:  BRA    E308
0E30C:  MOVWF  FAD
0E30E:  CLRF   1B
0E310:  BTFSC  FF2.7
0E312:  BSF    1B.7
0E314:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0E316:  MOVFF  729,A40
0E31A:  MOVLW  01
0E31C:  MOVLB  A
0E31E:  MOVWF  x41
0E320:  MOVLB  0
0E322:  CALL   0FC6
0E326:  BTFSC  1B.7
0E328:  BSF    FF2.7
0E32A:  MOVLW  2F
0E32C:  BTFSS  F9E.4
0E32E:  BRA    E32C
0E330:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E332:  DECFSZ 4F,W
0E334:  BRA    E3A2
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E336:  MOVLW  A4
0E338:  MOVWF  FF6
0E33A:  MOVLW  0D
0E33C:  MOVWF  FF7
0E33E:  MOVLW  00
0E340:  MOVWF  FF8
0E342:  CLRF   1B
0E344:  BTFSC  FF2.7
0E346:  BSF    1B.7
0E348:  BCF    FF2.7
0E34A:  MOVLW  05
0E34C:  MOVLB  A
0E34E:  MOVWF  x40
0E350:  MOVLB  0
0E352:  CALL   1044
0E356:  BTFSC  1B.7
0E358:  BSF    FF2.7
0E35A:  CLRF   1B
0E35C:  BTFSC  FF2.7
0E35E:  BSF    1B.7
0E360:  BCF    FF2.7
0E362:  MOVFF  729,A40
0E366:  MOVLW  01
0E368:  MOVLB  A
0E36A:  MOVWF  x41
0E36C:  MOVLB  0
0E36E:  CALL   0FC6
0E372:  BTFSC  1B.7
0E374:  BSF    FF2.7
0E376:  MOVLW  2F
0E378:  BTFSS  F9E.4
0E37A:  BRA    E378
0E37C:  MOVWF  FAD
0E37E:  CLRF   1B
0E380:  BTFSC  FF2.7
0E382:  BSF    1B.7
0E384:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E386:  MOVFF  72A,A40
0E38A:  MOVLW  01
0E38C:  MOVLB  A
0E38E:  MOVWF  x41
0E390:  MOVLB  0
0E392:  CALL   0FC6
0E396:  BTFSC  1B.7
0E398:  BSF    FF2.7
0E39A:  MOVLW  2F
0E39C:  BTFSS  F9E.4
0E39E:  BRA    E39C
0E3A0:  MOVWF  FAD
0E3A2:  CLRF   1B
0E3A4:  BTFSC  FF2.7
0E3A6:  BSF    1B.7
0E3A8:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E3AA:  MOVFF  72B,A40
0E3AE:  MOVLW  01
0E3B0:  MOVLB  A
0E3B2:  MOVWF  x41
0E3B4:  MOVLB  0
0E3B6:  CALL   0FC6
0E3BA:  BTFSC  1B.7
0E3BC:  BSF    FF2.7
0E3BE:  MOVLW  20
0E3C0:  BTFSS  F9E.4
0E3C2:  BRA    E3C0
0E3C4:  MOVWF  FAD
0E3C6:  CLRF   1B
0E3C8:  BTFSC  FF2.7
0E3CA:  BSF    1B.7
0E3CC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E3CE:  MOVFF  727,A40
0E3D2:  MOVLW  01
0E3D4:  MOVLB  A
0E3D6:  MOVWF  x41
0E3D8:  MOVLB  0
0E3DA:  CALL   0FC6
0E3DE:  BTFSC  1B.7
0E3E0:  BSF    FF2.7
0E3E2:  MOVLW  3A
0E3E4:  BTFSS  F9E.4
0E3E6:  BRA    E3E4
0E3E8:  MOVWF  FAD
0E3EA:  CLRF   1B
0E3EC:  BTFSC  FF2.7
0E3EE:  BSF    1B.7
0E3F0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E3F2:  MOVFF  726,A40
0E3F6:  MOVLW  01
0E3F8:  MOVLB  A
0E3FA:  MOVWF  x41
0E3FC:  MOVLB  0
0E3FE:  CALL   0FC6
0E402:  BTFSC  1B.7
0E404:  BSF    FF2.7
0E406:  MOVLW  3A
0E408:  BTFSS  F9E.4
0E40A:  BRA    E408
0E40C:  MOVWF  FAD
0E40E:  CLRF   1B
0E410:  BTFSC  FF2.7
0E412:  BSF    1B.7
0E414:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E416:  MOVFF  725,A40
0E41A:  MOVLW  01
0E41C:  MOVLB  A
0E41E:  MOVWF  x41
0E420:  MOVLB  0
0E422:  CALL   0FC6
0E426:  BTFSC  1B.7
0E428:  BSF    FF2.7
0E42A:  MOVLW  0A
0E42C:  BTFSS  F9E.4
0E42E:  BRA    E42C
0E430:  MOVWF  FAD
0E432:  MOVLW  0D
0E434:  BTFSS  F9E.4
0E436:  BRA    E434
0E438:  MOVWF  FAD
0E43A:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0336C:  MOVLB  8
0336E:  CLRF   xED
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
03370:  BCF    FC6.5
03372:  MOVLW  21
03374:  MOVWF  FC6
03376:  MOVLW  40
03378:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0337A:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
0337C:  MOVF   FC9,W
0337E:  CLRF   FC9
03380:  RRCF   FC7,W
03382:  BNC   3380
03384:  MOVFF  FC9,8ED
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
03388:  MOVF   FC9,W
0338A:  MOVFF  8ED,FC9
0338E:  RRCF   FC7,W
03390:  BNC   338E
03392:  MOVFF  FC9,72C
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
03396:  MOVF   FC9,W
03398:  MOVFF  8ED,FC9
0339C:  RRCF   FC7,W
0339E:  BNC   339C
033A0:  MOVFF  FC9,725
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
033A4:  MOVF   FC9,W
033A6:  MOVFF  8ED,FC9
033AA:  RRCF   FC7,W
033AC:  BNC   33AA
033AE:  MOVFF  FC9,726
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
033B2:  MOVF   FC9,W
033B4:  MOVFF  8ED,FC9
033B8:  RRCF   FC7,W
033BA:  BNC   33B8
033BC:  MOVFF  FC9,727
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
033C0:  MOVF   FC9,W
033C2:  MOVFF  8ED,FC9
033C6:  RRCF   FC7,W
033C8:  BNC   33C6
033CA:  MOVFF  FC9,728
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
033CE:  MOVF   FC9,W
033D0:  MOVFF  8ED,FC9
033D4:  RRCF   FC7,W
033D6:  BNC   33D4
033D8:  MOVFF  FC9,729
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
033DC:  MOVF   FC9,W
033DE:  MOVFF  8ED,FC9
033E2:  RRCF   FC7,W
033E4:  BNC   33E2
033E6:  MOVFF  FC9,72A
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
033EA:  MOVF   FC9,W
033EC:  MOVFF  8ED,FC9
033F0:  RRCF   FC7,W
033F2:  BNC   33F0
033F4:  MOVFF  FC9,72B
....................    output_bit(RTC_CS, DISABLE); 
033F8:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
033FA:  MOVFF  725,8EE
033FE:  MOVLB  0
03400:  RCALL  333A
03402:  MOVFF  01,725
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
03406:  MOVFF  726,8EE
0340A:  RCALL  333A
0340C:  MOVFF  01,726
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
03410:  MOVFF  727,8EE
03414:  RCALL  333A
03416:  MOVFF  01,727
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
0341A:  MOVFF  729,8EE
0341E:  RCALL  333A
03420:  MOVFF  01,729
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
03424:  MOVFF  72A,8EE
03428:  RCALL  333A
0342A:  MOVFF  01,72A
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
0342E:  MOVFF  72B,8EE
03432:  RCALL  333A
03434:  MOVFF  01,72B
03438:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DF8:  MOVLB  A
00DFA:  CLRF   x37
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DFC:  BCF    FC6.5
00DFE:  MOVLW  21
00E00:  MOVWF  FC6
00E02:  MOVLW  40
00E04:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00E06:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00E08:  MOVF   FC9,W
00E0A:  MOVLW  0F
00E0C:  MOVWF  FC9
00E0E:  RRCF   FC7,W
00E10:  BNC   0E0E
00E12:  MOVFF  FC9,A37
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00E16:  MOVF   FC9,W
00E18:  MOVFF  A37,FC9
00E1C:  RRCF   FC7,W
00E1E:  BNC   0E1C
00E20:  MOVFF  FC9,733
....................    spi_read(0x00); 
00E24:  MOVF   FC9,W
00E26:  CLRF   FC9
00E28:  RRCF   FC7,W
00E2A:  BNC   0E28
....................    output_bit(RTC_CS, DISABLE); 
00E2C:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00E2E:  BCF    4D.2
00E30:  MOVLB  0
00E32:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E512:  MOVF   4F,F
0E514:  BNZ   E582
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E516:  MOVLW  B0
0E518:  MOVWF  FF6
0E51A:  MOVLW  0D
0E51C:  MOVWF  FF7
0E51E:  MOVLW  00
0E520:  MOVWF  FF8
0E522:  CLRF   1B
0E524:  BTFSC  FF2.7
0E526:  BSF    1B.7
0E528:  BCF    FF2.7
0E52A:  MOVLW  05
0E52C:  MOVLB  A
0E52E:  MOVWF  x40
0E530:  MOVLB  0
0E532:  CALL   1044
0E536:  BTFSC  1B.7
0E538:  BSF    FF2.7
0E53A:  CLRF   1B
0E53C:  BTFSC  FF2.7
0E53E:  BSF    1B.7
0E540:  BCF    FF2.7
0E542:  MOVFF  72E,A40
0E546:  MOVLW  01
0E548:  MOVLB  A
0E54A:  MOVWF  x41
0E54C:  MOVLB  0
0E54E:  CALL   0FC6
0E552:  BTFSC  1B.7
0E554:  BSF    FF2.7
0E556:  MOVLW  2F
0E558:  BTFSS  F9E.4
0E55A:  BRA    E558
0E55C:  MOVWF  FAD
0E55E:  CLRF   1B
0E560:  BTFSC  FF2.7
0E562:  BSF    1B.7
0E564:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E566:  MOVFF  72F,A40
0E56A:  MOVLW  01
0E56C:  MOVLB  A
0E56E:  MOVWF  x41
0E570:  MOVLB  0
0E572:  CALL   0FC6
0E576:  BTFSC  1B.7
0E578:  BSF    FF2.7
0E57A:  MOVLW  2F
0E57C:  BTFSS  F9E.4
0E57E:  BRA    E57C
0E580:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E582:  DECFSZ 4F,W
0E584:  BRA    E5F2
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E586:  MOVLW  BC
0E588:  MOVWF  FF6
0E58A:  MOVLW  0D
0E58C:  MOVWF  FF7
0E58E:  MOVLW  00
0E590:  MOVWF  FF8
0E592:  CLRF   1B
0E594:  BTFSC  FF2.7
0E596:  BSF    1B.7
0E598:  BCF    FF2.7
0E59A:  MOVLW  05
0E59C:  MOVLB  A
0E59E:  MOVWF  x40
0E5A0:  MOVLB  0
0E5A2:  CALL   1044
0E5A6:  BTFSC  1B.7
0E5A8:  BSF    FF2.7
0E5AA:  CLRF   1B
0E5AC:  BTFSC  FF2.7
0E5AE:  BSF    1B.7
0E5B0:  BCF    FF2.7
0E5B2:  MOVFF  72F,A40
0E5B6:  MOVLW  01
0E5B8:  MOVLB  A
0E5BA:  MOVWF  x41
0E5BC:  MOVLB  0
0E5BE:  CALL   0FC6
0E5C2:  BTFSC  1B.7
0E5C4:  BSF    FF2.7
0E5C6:  MOVLW  2F
0E5C8:  BTFSS  F9E.4
0E5CA:  BRA    E5C8
0E5CC:  MOVWF  FAD
0E5CE:  CLRF   1B
0E5D0:  BTFSC  FF2.7
0E5D2:  BSF    1B.7
0E5D4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E5D6:  MOVFF  72E,A40
0E5DA:  MOVLW  01
0E5DC:  MOVLB  A
0E5DE:  MOVWF  x41
0E5E0:  MOVLB  0
0E5E2:  CALL   0FC6
0E5E6:  BTFSC  1B.7
0E5E8:  BSF    FF2.7
0E5EA:  MOVLW  2F
0E5EC:  BTFSS  F9E.4
0E5EE:  BRA    E5EC
0E5F0:  MOVWF  FAD
0E5F2:  CLRF   1B
0E5F4:  BTFSC  FF2.7
0E5F6:  BSF    1B.7
0E5F8:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E5FA:  MOVFF  72D,A40
0E5FE:  MOVLW  01
0E600:  MOVLB  A
0E602:  MOVWF  x41
0E604:  MOVLB  0
0E606:  CALL   0FC6
0E60A:  BTFSC  1B.7
0E60C:  BSF    FF2.7
0E60E:  MOVLW  20
0E610:  BTFSS  F9E.4
0E612:  BRA    E610
0E614:  MOVWF  FAD
0E616:  CLRF   1B
0E618:  BTFSC  FF2.7
0E61A:  BSF    1B.7
0E61C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E61E:  MOVFF  730,A40
0E622:  MOVLW  01
0E624:  MOVLB  A
0E626:  MOVWF  x41
0E628:  MOVLB  0
0E62A:  CALL   0FC6
0E62E:  BTFSC  1B.7
0E630:  BSF    FF2.7
0E632:  MOVLW  3A
0E634:  BTFSS  F9E.4
0E636:  BRA    E634
0E638:  MOVWF  FAD
0E63A:  CLRF   1B
0E63C:  BTFSC  FF2.7
0E63E:  BSF    1B.7
0E640:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E642:  MOVFF  731,A40
0E646:  MOVLW  01
0E648:  MOVLB  A
0E64A:  MOVWF  x41
0E64C:  MOVLB  0
0E64E:  CALL   0FC6
0E652:  BTFSC  1B.7
0E654:  BSF    FF2.7
0E656:  MOVLW  3A
0E658:  BTFSS  F9E.4
0E65A:  BRA    E658
0E65C:  MOVWF  FAD
0E65E:  CLRF   1B
0E660:  BTFSC  FF2.7
0E662:  BSF    1B.7
0E664:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E666:  MOVFF  732,A40
0E66A:  MOVLW  01
0E66C:  MOVLB  A
0E66E:  MOVWF  x41
0E670:  MOVLB  0
0E672:  CALL   0FC6
0E676:  BTFSC  1B.7
0E678:  BSF    FF2.7
0E67A:  MOVLW  0A
0E67C:  BTFSS  F9E.4
0E67E:  BRA    E67C
0E680:  MOVWF  FAD
0E682:  MOVLW  0D
0E684:  BTFSS  F9E.4
0E686:  BRA    E684
0E688:  MOVWF  FAD
0E68A:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E43C:  MOVLB  8
0E43E:  CLRF   xB7
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E440:  BCF    FC6.5
0E442:  MOVLW  21
0E444:  MOVWF  FC6
0E446:  MOVLW  40
0E448:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E44A:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E44C:  MOVF   FC9,W
0E44E:  MOVLW  0A
0E450:  MOVWF  FC9
0E452:  RRCF   FC7,W
0E454:  BNC   E452
0E456:  MOVFF  FC9,8B7
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E45A:  MOVF   FC9,W
0E45C:  MOVFF  8B7,FC9
0E460:  RRCF   FC7,W
0E462:  BNC   E460
0E464:  MOVFF  FC9,72E
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E468:  MOVF   FC9,W
0E46A:  MOVFF  8B7,FC9
0E46E:  RRCF   FC7,W
0E470:  BNC   E46E
0E472:  MOVFF  FC9,72F
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E476:  MOVF   FC9,W
0E478:  MOVFF  8B7,FC9
0E47C:  RRCF   FC7,W
0E47E:  BNC   E47C
0E480:  MOVFF  FC9,730
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E484:  MOVF   FC9,W
0E486:  MOVFF  8B7,FC9
0E48A:  RRCF   FC7,W
0E48C:  BNC   E48A
0E48E:  MOVFF  FC9,731
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E492:  MOVF   FC9,W
0E494:  MOVFF  8B7,FC9
0E498:  RRCF   FC7,W
0E49A:  BNC   E498
0E49C:  MOVFF  FC9,732
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E4A0:  MOVF   FC9,W
0E4A2:  MOVFF  8B7,FC9
0E4A6:  RRCF   FC7,W
0E4A8:  BNC   E4A6
0E4AA:  MOVFF  FC9,733
....................    output_bit(RTC_CS, DISABLE); 
0E4AE:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E4B0:  MOVLW  1F
0E4B2:  MOVLB  7
0E4B4:  ANDWF  x2E,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E4B6:  MOVFF  72E,8EE
0E4BA:  MOVLB  0
0E4BC:  CALL   333A
0E4C0:  MOVFF  01,72E
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E4C4:  MOVLW  3F
0E4C6:  MOVLB  7
0E4C8:  ANDWF  x2F,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E4CA:  MOVFF  72F,8EE
0E4CE:  MOVLB  0
0E4D0:  CALL   333A
0E4D4:  MOVFF  01,72F
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E4D8:  MOVLW  3F
0E4DA:  MOVLB  7
0E4DC:  ANDWF  x30,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E4DE:  MOVFF  730,8EE
0E4E2:  MOVLB  0
0E4E4:  CALL   333A
0E4E8:  MOVFF  01,730
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E4EC:  MOVLB  7
0E4EE:  BCF    x31.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E4F0:  MOVFF  731,8EE
0E4F4:  MOVLB  0
0E4F6:  CALL   333A
0E4FA:  MOVFF  01,731
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E4FE:  MOVLB  7
0E500:  BCF    x32.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E502:  MOVFF  732,8EE
0E506:  MOVLB  0
0E508:  CALL   333A
0E50C:  MOVFF  01,732
0E510:  RETURN 0
.................... } 
....................  
.................... int8 get_time2() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................    char input_string[30]; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
....................  
....................    time_error = 0; 
....................     
....................    fputc('[', COM_A); 
....................     
....................    for (n=0; n<12; ++n){ 
....................       c = fgetc(COM_A); 
....................       if (com_echo == TRUE) 
....................       { 
....................          fputc(c, COM_A); 
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
....................          break; 
....................       } 
....................    } 
....................     
....................    if (time_error == 0){ 
....................     
....................       fputc(']', COM_A); 
....................        
....................       for (n=0; n<12; ++n){ 
....................          t_entry[n] = (t_entry[n] - 48); 
....................       } 
....................        
....................       if (RTCfmt == 0) 
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
....................       } 
....................        
....................       if (RTCfmt == 1) 
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
....................       if (RTC_Yr_Data > 99) time_error = 2;  
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
....................       if (RTC_Hr_Data > 24) time_error = 2;  
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
....................       if (RTC_Min_Data > 60) time_error = 2;  
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
....................       if (RTC_Sec_Data > 60) time_error = 2; 
....................        
....................       if (RTCfmt == 0) 
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
....................       } 
....................        
....................       if (RTCfmt == 1) 
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
....................       } 
....................       if (time_error == 2) cmd_inv();             
....................  
....................    } 
....................    else cmd_arg(); 
....................     
....................    return time_error; 
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
1778A:  MOVLW  08
1778C:  MOVWF  FEA
1778E:  MOVLW  89
17790:  MOVWF  FE9
17792:  CLRF   00
17794:  CLRF   02
17796:  MOVLW  0C
17798:  MOVWF  01
1779A:  CALL   354E
....................  
....................    time_error = 0; 
1779E:  MOVLB  8
177A0:  CLRF   x95
....................     
....................    fputc('[', COM_A); 
177A2:  MOVLW  5B
177A4:  MOVLB  0
177A6:  CALL   AEE0
....................     
....................    while(n<12){ 
177AA:  MOVLB  8
177AC:  MOVF   x88,W
177AE:  SUBLW  0B
177B0:  BNC   17842
....................       c = fgetc(COM_A); 
177B2:  MOVLB  0
177B4:  CALL   0E58
177B8:  MOVFF  01,887
....................        
....................       if(c != 8){ 
177BC:  MOVLB  8
177BE:  MOVF   x87,W
177C0:  SUBLW  08
177C2:  BZ    177E8
....................             if (com_echo == TRUE) 
177C4:  DECFSZ 4C,W
177C6:  BRA    177D2
....................             { 
....................                fputc(c,COM_A); 
177C8:  MOVF   x87,W
177CA:  MOVLB  0
177CC:  CALL   AEE0
177D0:  MOVLB  8
....................             } 
....................              
....................             t_entry[n] = c; 
177D2:  CLRF   03
177D4:  MOVF   x88,W
177D6:  ADDLW  89
177D8:  MOVWF  FE9
177DA:  MOVLW  08
177DC:  ADDWFC 03,W
177DE:  MOVWF  FEA
177E0:  MOVFF  887,FEF
....................             n++; 
177E4:  INCF   x88,F
....................      }else{ 
177E6:  BRA    17840
....................             //backspace code 
....................             if(n != 0){ 
177E8:  MOVF   x88,F
177EA:  BZ    17840
....................                t_entry[n-1] = 0; 
177EC:  MOVLW  01
177EE:  SUBWF  x88,W
177F0:  CLRF   03
177F2:  ADDLW  89
177F4:  MOVWF  FE9
177F6:  MOVLW  08
177F8:  ADDWFC 03,W
177FA:  MOVWF  FEA
177FC:  CLRF   FEF
....................                n--; 
177FE:  DECF   x88,F
....................                //Clear buffer and overwrite with previous minus one character 
....................                fputc('\r',COM_A); 
17800:  MOVLW  0D
17802:  MOVLB  0
17804:  CALL   AEE0
....................                fprintf(COM_A,"                                       "); 
17808:  MOVLW  C8
1780A:  MOVWF  FF6
1780C:  MOVLW  0D
1780E:  MOVWF  FF7
17810:  MOVLW  00
17812:  MOVWF  FF8
17814:  CLRF   1B
17816:  BTFSC  FF2.7
17818:  BSF    1B.7
1781A:  BCF    FF2.7
1781C:  CALL   0E6E
17820:  BTFSC  1B.7
17822:  BSF    FF2.7
....................                fputc('\r',COM_A); 
17824:  MOVLW  0D
17826:  CALL   AEE0
....................                fprintf(COM_A,"["); 
1782A:  MOVLW  5B
1782C:  BTFSS  F9E.4
1782E:  BRA    1782C
17830:  MOVWF  FAD
....................                fprintf(COM_A,t_entry); 
17832:  MOVLW  08
17834:  MOVWF  FEA
17836:  MOVLW  89
17838:  MOVWF  FE9
1783A:  CALL   79BE
1783E:  MOVLB  8
....................                 
....................             } 
....................       } 
17840:  BRA    177AC
....................        
....................    } 
....................    n = 0; 
17842:  CLRF   x88
....................       while(t_entry[n] != 0){ 
17844:  CLRF   03
17846:  MOVF   x88,W
17848:  ADDLW  89
1784A:  MOVWF  FE9
1784C:  MOVLW  08
1784E:  ADDWFC 03,W
17850:  MOVWF  FEA
17852:  MOVF   FEF,F
17854:  BZ    17882
....................       //fputc(input_string[i],COM_A); 
....................          if(!isdigit(t_entry[n])){ 
17856:  CLRF   03
17858:  MOVF   x88,W
1785A:  ADDLW  89
1785C:  MOVWF  FE9
1785E:  MOVLW  08
17860:  ADDWFC 03,W
17862:  MOVWF  FEA
17864:  MOVFF  FEF,896
17868:  MOVF   x96,W
1786A:  SUBLW  2F
1786C:  BC    17874
1786E:  MOVF   x96,W
17870:  SUBLW  39
17872:  BC    1787C
....................             //fputs("\r\n@ARG ", COM_A); 
....................             time_error = 1; 
17874:  MOVLW  01
17876:  MOVWF  x95
....................             break; 
17878:  BRA    17882
....................          }else{ 
1787A:  BRA    1787E
....................             time_error = 0; 
1787C:  CLRF   x95
....................          } 
....................          n++; 
1787E:  INCF   x88,F
17880:  BRA    17844
....................       } 
....................     
....................    if (time_error == 0){ 
17882:  MOVF   x95,F
17884:  BTFSS  FD8.2
17886:  BRA    17BBE
....................     
....................       fputc(']', COM_A); 
17888:  MOVLW  5D
1788A:  MOVLB  0
1788C:  CALL   AEE0
....................        
....................       for (n=0; n<12; ++n){ 
17890:  MOVLB  8
17892:  CLRF   x88
17894:  MOVF   x88,W
17896:  SUBLW  0B
17898:  BNC   178CA
....................          t_entry[n] = (t_entry[n] - 48); 
1789A:  CLRF   03
1789C:  MOVF   x88,W
1789E:  ADDLW  89
178A0:  MOVWF  01
178A2:  MOVLW  08
178A4:  ADDWFC 03,F
178A6:  MOVFF  03,897
178AA:  CLRF   03
178AC:  MOVF   x88,W
178AE:  ADDLW  89
178B0:  MOVWF  FE9
178B2:  MOVLW  08
178B4:  ADDWFC 03,W
178B6:  MOVWF  FEA
178B8:  MOVLW  30
178BA:  SUBWF  FEF,W
178BC:  MOVFF  897,FEA
178C0:  MOVFF  01,FE9
178C4:  MOVWF  FEF
178C6:  INCF   x88,F
178C8:  BRA    17894
....................       } 
....................        
....................       if (RTCfmt == 0) 
178CA:  MOVF   4F,F
178CC:  BNZ   1790A
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
178CE:  MOVF   x89,W
178D0:  MULLW  0A
178D2:  MOVF   FF3,W
178D4:  ADDWF  x8A,W
178D6:  MOVLB  7
178D8:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
178DA:  MOVF   x38,F
178DC:  BZ    178E4
178DE:  MOVF   x38,W
178E0:  SUBLW  0C
178E2:  BC    178EC
178E4:  MOVLW  02
178E6:  MOVLB  8
178E8:  MOVWF  x95
178EA:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
178EC:  MOVLB  8
178EE:  MOVF   x8B,W
178F0:  MULLW  0A
178F2:  MOVF   FF3,W
178F4:  ADDWF  x8C,W
178F6:  MOVLB  7
178F8:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
178FA:  MOVF   x37,F
178FC:  BZ    17904
178FE:  MOVF   x37,W
17900:  SUBLW  1F
17902:  BC    1790C
17904:  MOVLW  02
17906:  MOVLB  8
17908:  MOVWF  x95
1790A:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
1790C:  DECFSZ 4F,W
1790E:  BRA    17950
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
17910:  MOVLB  8
17912:  MOVF   x89,W
17914:  MULLW  0A
17916:  MOVF   FF3,W
17918:  ADDWF  x8A,W
1791A:  MOVLB  7
1791C:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
1791E:  MOVF   x37,F
17920:  BZ    17928
17922:  MOVF   x37,W
17924:  SUBLW  1F
17926:  BC    17930
17928:  MOVLW  02
1792A:  MOVLB  8
1792C:  MOVWF  x95
1792E:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
17930:  MOVLB  8
17932:  MOVF   x8B,W
17934:  MULLW  0A
17936:  MOVF   FF3,W
17938:  ADDWF  x8C,W
1793A:  MOVLB  7
1793C:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
1793E:  MOVF   x38,F
17940:  BZ    17948
17942:  MOVF   x38,W
17944:  SUBLW  0C
17946:  BC    17950
17948:  MOVLW  02
1794A:  MOVLB  8
1794C:  MOVWF  x95
1794E:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
17950:  MOVLB  8
17952:  MOVF   x8D,W
17954:  MULLW  0A
17956:  MOVF   FF3,W
17958:  ADDWF  x8E,W
1795A:  MOVLB  7
1795C:  MOVWF  x39
....................       if (RTC_Yr_Data > 99) time_error = 2;  
1795E:  MOVF   x39,W
17960:  SUBLW  63
17962:  BC    1796C
17964:  MOVLW  02
17966:  MOVLB  8
17968:  MOVWF  x95
1796A:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
1796C:  MOVLB  8
1796E:  MOVF   x8F,W
17970:  MULLW  0A
17972:  MOVF   FF3,W
17974:  ADDWF  x90,W
17976:  MOVLB  7
17978:  MOVWF  x36
....................       if (RTC_Hr_Data > 24) time_error = 2;  
1797A:  MOVF   x36,W
1797C:  SUBLW  18
1797E:  BC    17988
17980:  MOVLW  02
17982:  MOVLB  8
17984:  MOVWF  x95
17986:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
17988:  MOVLB  8
1798A:  MOVF   x91,W
1798C:  MULLW  0A
1798E:  MOVF   FF3,W
17990:  ADDWF  x92,W
17992:  MOVLB  7
17994:  MOVWF  x35
....................       if (RTC_Min_Data > 60) time_error = 2;  
17996:  MOVF   x35,W
17998:  SUBLW  3C
1799A:  BC    179A4
1799C:  MOVLW  02
1799E:  MOVLB  8
179A0:  MOVWF  x95
179A2:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
179A4:  MOVLB  8
179A6:  MOVF   x93,W
179A8:  MULLW  0A
179AA:  MOVF   FF3,W
179AC:  ADDWF  x94,W
179AE:  MOVLB  7
179B0:  MOVWF  x34
....................       if (RTC_Sec_Data > 60) time_error = 2; 
179B2:  MOVF   x34,W
179B4:  SUBLW  3C
179B6:  BC    179C0
179B8:  MOVLW  02
179BA:  MOVLB  8
179BC:  MOVWF  x95
179BE:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
179C0:  MOVF   4F,F
179C2:  BTFSS  FD8.2
179C4:  BRA    17AB8
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
179C6:  MOVLW  0A
179C8:  BTFSS  F9E.4
179CA:  BRA    179C8
179CC:  MOVWF  FAD
179CE:  MOVLW  0D
179D0:  BTFSS  F9E.4
179D2:  BRA    179D0
179D4:  MOVWF  FAD
179D6:  CLRF   1B
179D8:  BTFSC  FF2.7
179DA:  BSF    1B.7
179DC:  BCF    FF2.7
179DE:  MOVFF  738,A40
179E2:  MOVLW  01
179E4:  MOVLB  A
179E6:  MOVWF  x41
179E8:  MOVLB  0
179EA:  CALL   0FC6
179EE:  BTFSC  1B.7
179F0:  BSF    FF2.7
179F2:  MOVLW  2F
179F4:  BTFSS  F9E.4
179F6:  BRA    179F4
179F8:  MOVWF  FAD
179FA:  CLRF   1B
179FC:  BTFSC  FF2.7
179FE:  BSF    1B.7
17A00:  BCF    FF2.7
17A02:  MOVFF  737,A40
17A06:  MOVLW  01
17A08:  MOVLB  A
17A0A:  MOVWF  x41
17A0C:  MOVLB  0
17A0E:  CALL   0FC6
17A12:  BTFSC  1B.7
17A14:  BSF    FF2.7
17A16:  MOVLW  2F
17A18:  BTFSS  F9E.4
17A1A:  BRA    17A18
17A1C:  MOVWF  FAD
17A1E:  CLRF   1B
17A20:  BTFSC  FF2.7
17A22:  BSF    1B.7
17A24:  BCF    FF2.7
17A26:  MOVFF  739,A40
17A2A:  MOVLW  01
17A2C:  MOVLB  A
17A2E:  MOVWF  x41
17A30:  MOVLB  0
17A32:  CALL   0FC6
17A36:  BTFSC  1B.7
17A38:  BSF    FF2.7
17A3A:  MOVLW  20
17A3C:  BTFSS  F9E.4
17A3E:  BRA    17A3C
17A40:  MOVWF  FAD
17A42:  CLRF   1B
17A44:  BTFSC  FF2.7
17A46:  BSF    1B.7
17A48:  BCF    FF2.7
17A4A:  MOVFF  736,A40
17A4E:  MOVLW  01
17A50:  MOVLB  A
17A52:  MOVWF  x41
17A54:  MOVLB  0
17A56:  CALL   0FC6
17A5A:  BTFSC  1B.7
17A5C:  BSF    FF2.7
17A5E:  MOVLW  3A
17A60:  BTFSS  F9E.4
17A62:  BRA    17A60
17A64:  MOVWF  FAD
17A66:  CLRF   1B
17A68:  BTFSC  FF2.7
17A6A:  BSF    1B.7
17A6C:  BCF    FF2.7
17A6E:  MOVFF  735,A40
17A72:  MOVLW  01
17A74:  MOVLB  A
17A76:  MOVWF  x41
17A78:  MOVLB  0
17A7A:  CALL   0FC6
17A7E:  BTFSC  1B.7
17A80:  BSF    FF2.7
17A82:  MOVLW  3A
17A84:  BTFSS  F9E.4
17A86:  BRA    17A84
17A88:  MOVWF  FAD
17A8A:  CLRF   1B
17A8C:  BTFSC  FF2.7
17A8E:  BSF    1B.7
17A90:  BCF    FF2.7
17A92:  MOVFF  734,A40
17A96:  MOVLW  01
17A98:  MOVLB  A
17A9A:  MOVWF  x41
17A9C:  MOVLB  0
17A9E:  CALL   0FC6
17AA2:  BTFSC  1B.7
17AA4:  BSF    FF2.7
17AA6:  MOVLW  0A
17AA8:  BTFSS  F9E.4
17AAA:  BRA    17AA8
17AAC:  MOVWF  FAD
17AAE:  MOVLW  0D
17AB0:  BTFSS  F9E.4
17AB2:  BRA    17AB0
17AB4:  MOVWF  FAD
17AB6:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17AB8:  DECFSZ 4F,W
17ABA:  BRA    17BAE
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
17ABC:  MOVLW  0A
17ABE:  BTFSS  F9E.4
17AC0:  BRA    17ABE
17AC2:  MOVWF  FAD
17AC4:  MOVLW  0D
17AC6:  BTFSS  F9E.4
17AC8:  BRA    17AC6
17ACA:  MOVWF  FAD
17ACC:  CLRF   1B
17ACE:  BTFSC  FF2.7
17AD0:  BSF    1B.7
17AD2:  BCF    FF2.7
17AD4:  MOVFF  737,A40
17AD8:  MOVLW  01
17ADA:  MOVLB  A
17ADC:  MOVWF  x41
17ADE:  MOVLB  0
17AE0:  CALL   0FC6
17AE4:  BTFSC  1B.7
17AE6:  BSF    FF2.7
17AE8:  MOVLW  2F
17AEA:  BTFSS  F9E.4
17AEC:  BRA    17AEA
17AEE:  MOVWF  FAD
17AF0:  CLRF   1B
17AF2:  BTFSC  FF2.7
17AF4:  BSF    1B.7
17AF6:  BCF    FF2.7
17AF8:  MOVFF  738,A40
17AFC:  MOVLW  01
17AFE:  MOVLB  A
17B00:  MOVWF  x41
17B02:  MOVLB  0
17B04:  CALL   0FC6
17B08:  BTFSC  1B.7
17B0A:  BSF    FF2.7
17B0C:  MOVLW  2F
17B0E:  BTFSS  F9E.4
17B10:  BRA    17B0E
17B12:  MOVWF  FAD
17B14:  CLRF   1B
17B16:  BTFSC  FF2.7
17B18:  BSF    1B.7
17B1A:  BCF    FF2.7
17B1C:  MOVFF  739,A40
17B20:  MOVLW  01
17B22:  MOVLB  A
17B24:  MOVWF  x41
17B26:  MOVLB  0
17B28:  CALL   0FC6
17B2C:  BTFSC  1B.7
17B2E:  BSF    FF2.7
17B30:  MOVLW  20
17B32:  BTFSS  F9E.4
17B34:  BRA    17B32
17B36:  MOVWF  FAD
17B38:  CLRF   1B
17B3A:  BTFSC  FF2.7
17B3C:  BSF    1B.7
17B3E:  BCF    FF2.7
17B40:  MOVFF  736,A40
17B44:  MOVLW  01
17B46:  MOVLB  A
17B48:  MOVWF  x41
17B4A:  MOVLB  0
17B4C:  CALL   0FC6
17B50:  BTFSC  1B.7
17B52:  BSF    FF2.7
17B54:  MOVLW  3A
17B56:  BTFSS  F9E.4
17B58:  BRA    17B56
17B5A:  MOVWF  FAD
17B5C:  CLRF   1B
17B5E:  BTFSC  FF2.7
17B60:  BSF    1B.7
17B62:  BCF    FF2.7
17B64:  MOVFF  735,A40
17B68:  MOVLW  01
17B6A:  MOVLB  A
17B6C:  MOVWF  x41
17B6E:  MOVLB  0
17B70:  CALL   0FC6
17B74:  BTFSC  1B.7
17B76:  BSF    FF2.7
17B78:  MOVLW  3A
17B7A:  BTFSS  F9E.4
17B7C:  BRA    17B7A
17B7E:  MOVWF  FAD
17B80:  CLRF   1B
17B82:  BTFSC  FF2.7
17B84:  BSF    1B.7
17B86:  BCF    FF2.7
17B88:  MOVFF  734,A40
17B8C:  MOVLW  01
17B8E:  MOVLB  A
17B90:  MOVWF  x41
17B92:  MOVLB  0
17B94:  CALL   0FC6
17B98:  BTFSC  1B.7
17B9A:  BSF    FF2.7
17B9C:  MOVLW  0A
17B9E:  BTFSS  F9E.4
17BA0:  BRA    17B9E
17BA2:  MOVWF  FAD
17BA4:  MOVLW  0D
17BA6:  BTFSS  F9E.4
17BA8:  BRA    17BA6
17BAA:  MOVWF  FAD
17BAC:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
17BAE:  MOVLB  8
17BB0:  MOVF   x95,W
17BB2:  SUBLW  02
17BB4:  BNZ   17BBC
17BB6:  MOVLB  0
17BB8:  BRA    1776A
17BBA:  MOVLB  8
....................  
....................    } 
17BBC:  BRA    17BC6
....................    else cmd_arg(); 
17BBE:  MOVLB  0
17BC0:  CALL   B326
17BC4:  MOVLB  8
....................     
....................    return time_error; 
17BC6:  MOVFF  895,01
17BCA:  MOVLB  0
17BCC:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
17C0C:  RCALL  1778A
17C0E:  MOVFF  01,885
....................     
....................    if (time_error ==0 ){ 
17C12:  MOVLB  8
17C14:  MOVF   x85,F
17C16:  BTFSS  FD8.2
17C18:  BRA    17D50
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
17C1A:  BCF    FC6.5
17C1C:  MOVLW  21
17C1E:  MOVWF  FC6
17C20:  MOVLW  40
17C22:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
17C24:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
17C26:  MOVF   FC9,W
17C28:  MOVLW  86
17C2A:  MOVWF  FC9
17C2C:  RRCF   FC7,W
17C2E:  BNC   17C2C
17C30:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
17C34:  MOVFF  738,887
17C38:  MOVLB  0
17C3A:  RCALL  17BCE
17C3C:  MOVFF  01,887
17C40:  MOVF   FC9,W
17C42:  MOVFF  01,FC9
17C46:  RRCF   FC7,W
17C48:  BNC   17C46
17C4A:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C4E:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C50:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
17C52:  MOVF   FC9,W
17C54:  MOVLW  85
17C56:  MOVWF  FC9
17C58:  RRCF   FC7,W
17C5A:  BNC   17C58
17C5C:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
17C60:  MOVFF  737,887
17C64:  RCALL  17BCE
17C66:  MOVFF  01,887
17C6A:  MOVF   FC9,W
17C6C:  MOVFF  01,FC9
17C70:  RRCF   FC7,W
17C72:  BNC   17C70
17C74:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C78:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C7A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
17C7C:  MOVF   FC9,W
17C7E:  MOVLW  87
17C80:  MOVWF  FC9
17C82:  RRCF   FC7,W
17C84:  BNC   17C82
17C86:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
17C8A:  MOVFF  739,887
17C8E:  RCALL  17BCE
17C90:  MOVFF  01,887
17C94:  MOVF   FC9,W
17C96:  MOVFF  01,FC9
17C9A:  RRCF   FC7,W
17C9C:  BNC   17C9A
17C9E:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17CA2:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17CA4:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
17CA6:  MOVF   FC9,W
17CA8:  MOVLW  83
17CAA:  MOVWF  FC9
17CAC:  RRCF   FC7,W
17CAE:  BNC   17CAC
17CB0:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
17CB4:  MOVFF  736,887
17CB8:  RCALL  17BCE
17CBA:  MOVFF  01,887
17CBE:  MOVF   FC9,W
17CC0:  MOVFF  01,FC9
17CC4:  RRCF   FC7,W
17CC6:  BNC   17CC4
17CC8:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17CCC:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17CCE:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
17CD0:  MOVF   FC9,W
17CD2:  MOVLW  82
17CD4:  MOVWF  FC9
17CD6:  RRCF   FC7,W
17CD8:  BNC   17CD6
17CDA:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
17CDE:  MOVFF  735,887
17CE2:  RCALL  17BCE
17CE4:  MOVFF  01,887
17CE8:  MOVF   FC9,W
17CEA:  MOVFF  01,FC9
17CEE:  RRCF   FC7,W
17CF0:  BNC   17CEE
17CF2:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17CF6:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17CF8:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
17CFA:  MOVF   FC9,W
17CFC:  MOVLW  81
17CFE:  MOVWF  FC9
17D00:  RRCF   FC7,W
17D02:  BNC   17D00
17D04:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
17D08:  MOVFF  734,887
17D0C:  RCALL  17BCE
17D0E:  MOVFF  01,887
17D12:  MOVF   FC9,W
17D14:  MOVFF  01,FC9
17D18:  RRCF   FC7,W
17D1A:  BNC   17D18
17D1C:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17D20:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17D22:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
17D24:  MOVF   FC9,W
17D26:  MOVLW  80
17D28:  MOVWF  FC9
17D2A:  RRCF   FC7,W
17D2C:  BNC   17D2A
17D2E:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
17D32:  MOVLB  8
17D34:  CLRF   x87
17D36:  MOVLB  0
17D38:  RCALL  17BCE
17D3A:  MOVFF  01,887
17D3E:  MOVF   FC9,W
17D40:  MOVFF  01,FC9
17D44:  RRCF   FC7,W
17D46:  BNC   17D44
17D48:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17D4C:  BSF    F91.0
17D4E:  MOVLB  8
....................    } 
17D50:  MOVLB  0
17D52:  GOTO   17DDE (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
188DC:  CALL   E43C
....................     
....................    time_error = get_time(); 
188E0:  CALL   1778A
188E4:  MOVFF  01,885
....................     
....................    if (time_error == 0 ){ 
188E8:  MOVLB  8
188EA:  MOVF   x85,F
188EC:  BTFSS  FD8.2
188EE:  BRA    18A24
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
188F0:  MOVFF  739,72D
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
188F4:  MOVLW  04
188F6:  MOVWF  x89
188F8:  MOVFF  72D,88A
188FC:  MOVLB  0
188FE:  CALL   343A
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
18902:  MOVFF  738,887
18906:  CALL   17BCE
1890A:  MOVFF  01,738
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
1890E:  MOVLB  7
18910:  BSF    x38.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
18912:  BCF    FC6.5
18914:  MOVLW  21
18916:  MOVWF  FC6
18918:  MOVLW  40
1891A:  MOVWF  FC7
....................       delay_us(10); 
1891C:  MOVLW  35
1891E:  MOVWF  00
18920:  DECFSZ 00,F
18922:  BRA    18920
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
18924:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
18926:  MOVF   FC9,W
18928:  MOVLW  8E
1892A:  MOVWF  FC9
1892C:  RRCF   FC7,W
1892E:  BNC   1892C
18930:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
18934:  MOVFF  734,887
18938:  MOVLB  0
1893A:  CALL   17BCE
1893E:  MOVFF  01,887
18942:  MOVF   FC9,W
18944:  MOVFF  01,FC9
18948:  RRCF   FC7,W
1894A:  BNC   18948
1894C:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18950:  BSF    F91.0
....................       delay_us(1); // Delays added 1.020A 
18952:  MOVLW  05
18954:  MOVWF  00
18956:  DECFSZ 00,F
18958:  BRA    18956
....................        
....................       output_bit(RTC_CS, ENABLE); 
1895A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
1895C:  MOVF   FC9,W
1895E:  MOVLW  8D
18960:  MOVWF  FC9
18962:  RRCF   FC7,W
18964:  BNC   18962
18966:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
1896A:  MOVFF  735,887
1896E:  CALL   17BCE
18972:  MOVFF  01,887
18976:  MOVF   FC9,W
18978:  MOVFF  01,FC9
1897C:  RRCF   FC7,W
1897E:  BNC   1897C
18980:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18984:  BSF    F91.0
....................       delay_us(1); 
18986:  MOVLW  05
18988:  MOVWF  00
1898A:  DECFSZ 00,F
1898C:  BRA    1898A
....................        
....................       output_bit(RTC_CS, ENABLE); 
1898E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
18990:  MOVF   FC9,W
18992:  MOVLW  8C
18994:  MOVWF  FC9
18996:  RRCF   FC7,W
18998:  BNC   18996
1899A:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
1899E:  MOVFF  736,887
189A2:  CALL   17BCE
189A6:  MOVFF  01,887
189AA:  MOVF   FC9,W
189AC:  MOVFF  01,FC9
189B0:  RRCF   FC7,W
189B2:  BNC   189B0
189B4:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
189B8:  BSF    F91.0
....................       delay_us(1);  
189BA:  MOVLW  05
189BC:  MOVWF  00
189BE:  DECFSZ 00,F
189C0:  BRA    189BE
....................        
....................       output_bit(RTC_CS, ENABLE); 
189C2:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
189C4:  MOVF   FC9,W
189C6:  MOVLW  8B
189C8:  MOVWF  FC9
189CA:  RRCF   FC7,W
189CC:  BNC   189CA
189CE:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
189D2:  MOVFF  737,887
189D6:  CALL   17BCE
189DA:  MOVFF  01,887
189DE:  MOVF   FC9,W
189E0:  MOVFF  01,FC9
189E4:  RRCF   FC7,W
189E6:  BNC   189E4
189E8:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE);  
189EC:  BSF    F91.0
....................       delay_us(1); 
189EE:  MOVLW  05
189F0:  MOVWF  00
189F2:  DECFSZ 00,F
189F4:  BRA    189F2
....................        
....................       output_bit(RTC_CS, ENABLE); 
189F6:  BCF    F91.0
....................       //fprintf(COM_A,"test61\r\n"); 
....................       RTC_buffer = spi_read(0x8A);// address - Month 
189F8:  MOVF   FC9,W
189FA:  MOVLW  8A
189FC:  MOVWF  FC9
189FE:  RRCF   FC7,W
18A00:  BNC   189FE
18A02:  MOVFF  FC9,886
....................       //fprintf(COM_A,"test62\r\n"); 
....................       //fprintf(COM_A,"test6: %d\r\n",RTC_Mon_Data); 
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
18A06:  MOVF   FC9,W
18A08:  MOVFF  738,FC9
18A0C:  RRCF   FC7,W
18A0E:  BNC   18A0C
18A10:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18A14:  BSF    F91.0
....................       delay_us(1); 
18A16:  MOVLW  05
18A18:  MOVWF  00
18A1A:  DECFSZ 00,F
18A1C:  BRA    18A1A
....................       //fprintf(COM_A,"test6\r\n"); 
....................     
....................    RTC_read_alarm(); 
18A1E:  CALL   E43C
18A22:  MOVLB  8
....................    } 
18A24:  MOVLB  0
18A26:  GOTO   18A3C (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15F1A:  BCF    FC6.5
15F1C:  MOVLW  21
15F1E:  MOVWF  FC6
15F20:  MOVLW  40
15F22:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15F24:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15F26:  MOVF   FC9,W
15F28:  MOVLW  8E
15F2A:  MOVWF  FC9
15F2C:  RRCF   FC7,W
15F2E:  BNC   15F2C
15F30:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b00000000);  // data 
15F34:  MOVF   FC9,W
15F36:  CLRF   FC9
15F38:  RRCF   FC7,W
15F3A:  BNC   15F38
15F3C:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F40:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F42:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15F44:  MOVF   FC9,W
15F46:  MOVLW  8D
15F48:  MOVWF  FC9
15F4A:  RRCF   FC7,W
15F4C:  BNC   15F4A
15F4E:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F52:  MOVF   FC9,W
15F54:  MOVLW  80
15F56:  MOVWF  FC9
15F58:  RRCF   FC7,W
15F5A:  BNC   15F58
15F5C:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F60:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F62:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15F64:  MOVF   FC9,W
15F66:  MOVLW  8C
15F68:  MOVWF  FC9
15F6A:  RRCF   FC7,W
15F6C:  BNC   15F6A
15F6E:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F72:  MOVF   FC9,W
15F74:  MOVLW  80
15F76:  MOVWF  FC9
15F78:  RRCF   FC7,W
15F7A:  BNC   15F78
15F7C:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F80:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F82:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15F84:  MOVF   FC9,W
15F86:  MOVLW  8B
15F88:  MOVWF  FC9
15F8A:  RRCF   FC7,W
15F8C:  BNC   15F8A
15F8E:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b11000000);  // data 
15F92:  MOVF   FC9,W
15F94:  MOVLW  C0
15F96:  MOVWF  FC9
15F98:  RRCF   FC7,W
15F9A:  BNC   15F98
15F9C:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE);    
15FA0:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15FA2:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15FA4:  MOVF   FC9,W
15FA6:  MOVLW  8A
15FA8:  MOVWF  FC9
15FAA:  RRCF   FC7,W
15FAC:  BNC   15FAA
15FAE:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15FB2:  MOVF   FC9,W
15FB4:  MOVLW  80
15FB6:  MOVWF  FC9
15FB8:  RRCF   FC7,W
15FBA:  BNC   15FB8
15FBC:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15FC0:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15FC2:  CALL   E43C
15FC6:  GOTO   16D86 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
1574A:  MOVLB  8
1574C:  CLRF   x87
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1574E:  BCF    FC6.5
15750:  MOVLW  21
15752:  MOVWF  FC6
15754:  MOVLW  40
15756:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15758:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
1575A:  MOVF   FC9,W
1575C:  MOVLW  0A
1575E:  MOVWF  FC9
15760:  RRCF   FC7,W
15762:  BNC   15760
15764:  MOVFF  FC9,887
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
15768:  MOVF   FC9,W
1576A:  MOVFF  887,FC9
1576E:  RRCF   FC7,W
15770:  BNC   1576E
15772:  MOVFF  FC9,72E
....................    output_bit(RTC_CS, DISABLE); 
15776:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
15778:  MOVLB  7
1577A:  BSF    x2E.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
1577C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
1577E:  MOVF   FC9,W
15780:  MOVLW  8A
15782:  MOVWF  FC9
15784:  RRCF   FC7,W
15786:  BNC   15784
15788:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
1578C:  MOVF   FC9,W
1578E:  MOVFF  72E,FC9
15792:  RRCF   FC7,W
15794:  BNC   15792
15796:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
1579A:  BSF    F91.0
1579C:  MOVLB  0
1579E:  GOTO   16CB0 (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
0346A:  MOVFF  725,73F
....................    rtc_last_min   = RTC_Min_Reg; 
0346E:  MOVFF  726,73E
....................    rtc_last_hour  = RTC_Hr_Reg; 
03472:  MOVFF  727,73D
....................    rtc_last_day   = RTC_DOM_Reg; 
03476:  MOVFF  729,73B
....................    rtc_last_month = RTC_Mon_Reg; 
0347A:  MOVFF  72A,73A
....................    rtc_last_year  = RTC_Yr_Reg; 
0347E:  MOVFF  72B,73C
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
03482:  MOVLW  06
03484:  MOVLB  8
03486:  MOVWF  x89
03488:  MOVFF  73A,88A
0348C:  MOVLB  0
0348E:  RCALL  343A
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
03490:  MOVLW  08
03492:  MOVLB  8
03494:  MOVWF  x89
03496:  MOVFF  73B,88A
0349A:  MOVLB  0
0349C:  RCALL  343A
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
0349E:  MOVLW  0A
034A0:  MOVLB  8
034A2:  MOVWF  x89
034A4:  MOVFF  73C,88A
034A8:  MOVLB  0
034AA:  RCALL  343A
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
034AC:  MOVLW  0C
034AE:  MOVLB  8
034B0:  MOVWF  x89
034B2:  MOVFF  73D,88A
034B6:  MOVLB  0
034B8:  RCALL  343A
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
034BA:  MOVLW  0E
034BC:  MOVLB  8
034BE:  MOVWF  x89
034C0:  MOVFF  73E,88A
034C4:  MOVLB  0
034C6:  RCALL  343A
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
034C8:  MOVLW  10
034CA:  MOVLB  8
034CC:  MOVWF  x89
034CE:  MOVFF  73F,88A
034D2:  MOVLB  0
034D4:  RCALL  343A
034D6:  GOTO   1B882 (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
157A2:  MOVLB  8
157A4:  CLRF   x8A
157A6:  CLRF   x89
157A8:  CLRF   x88
157AA:  CLRF   x87
157AC:  CLRF   x8E
157AE:  CLRF   x8D
157B0:  CLRF   x8C
157B2:  CLRF   x8B
157B4:  CLRF   x92
157B6:  CLRF   x91
157B8:  CLRF   x90
157BA:  CLRF   x8F
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
157BC:  CLRF   x9F
157BE:  CLRF   xA0
157C0:  MOVLW  1F
157C2:  MOVWF  xA1
157C4:  CLRF   xA2
157C6:  MOVLW  3B
157C8:  MOVWF  xA3
157CA:  CLRF   xA4
157CC:  MOVLW  5A
157CE:  MOVWF  xA5
157D0:  CLRF   xA6
157D2:  MOVLW  78
157D4:  MOVWF  xA7
157D6:  CLRF   xA8
157D8:  MOVLW  97
157DA:  MOVWF  xA9
157DC:  CLRF   xAA
157DE:  MOVLW  B5
157E0:  MOVWF  xAB
157E2:  CLRF   xAC
157E4:  MOVLW  D4
157E6:  MOVWF  xAD
157E8:  CLRF   xAE
157EA:  MOVLW  F3
157EC:  MOVWF  xAF
157EE:  CLRF   xB0
157F0:  MOVLW  11
157F2:  MOVWF  xB1
157F4:  MOVLW  01
157F6:  MOVWF  xB2
157F8:  MOVLW  30
157FA:  MOVWF  xB3
157FC:  MOVLW  01
157FE:  MOVWF  xB4
15800:  MOVLW  4E
15802:  MOVWF  xB5
15804:  MOVLW  01
15806:  MOVWF  xB6
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
15808:  BCF    4D.3
....................     
....................    RTC_read(); 
1580A:  MOVLB  0
1580C:  CALL   336C
....................    RTC_read_alarm(); 
15810:  CALL   E43C
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
15814:  MOVLW  04
15816:  MOVLB  8
15818:  MOVWF  xB7
1581A:  MOVLB  0
1581C:  CALL   2A4C
15820:  MOVFF  01,72D
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
15824:  MOVLB  7
15826:  MOVF   x2B,W
15828:  SUBWF  x2D,W
1582A:  BC    15830
1582C:  BSF    4D.3
1582E:  BRA    15C64
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
15830:  MOVF   x2D,W
15832:  SUBWF  x2B,W
15834:  BTFSS  FD8.2
15836:  BRA    15C64
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
15838:  MOVLW  01
1583A:  SUBWF  x2A,W
1583C:  MOVWF  00
1583E:  BCF    FD8.0
15840:  RLCF   00,F
15842:  MOVF   00,W
15844:  CLRF   03
15846:  ADDLW  9F
15848:  MOVWF  FE9
1584A:  MOVLW  08
1584C:  ADDWFC 03,W
1584E:  MOVWF  FEA
15850:  MOVFF  FEC,03
15854:  MOVF   FED,F
15856:  MOVFF  FEF,917
1585A:  MOVFF  03,918
1585E:  MOVLB  0
15860:  CALL   C91E
15864:  MOVFF  03,88A
15868:  MOVFF  02,889
1586C:  MOVFF  01,888
15870:  MOVFF  00,887
....................          time_now = time_now + RTC_DOM_Reg; 
15874:  MOVLB  9
15876:  CLRF   x18
15878:  MOVFF  729,917
1587C:  MOVLB  0
1587E:  CALL   C91E
15882:  BCF    FD8.1
15884:  MOVFF  88A,91A
15888:  MOVFF  889,919
1588C:  MOVFF  888,918
15890:  MOVFF  887,917
15894:  MOVFF  03,91E
15898:  MOVFF  02,91D
1589C:  MOVFF  01,91C
158A0:  MOVFF  00,91B
158A4:  CALL   C3E2
158A8:  MOVFF  03,88A
158AC:  MOVFF  02,889
158B0:  MOVFF  01,888
158B4:  MOVFF  00,887
....................           
....................          hour = RTC_Hr_Reg; 
158B8:  MOVLB  9
158BA:  CLRF   x18
158BC:  MOVFF  727,917
158C0:  MOVLB  0
158C2:  CALL   C91E
158C6:  MOVFF  03,896
158CA:  MOVFF  02,895
158CE:  MOVFF  01,894
158D2:  MOVFF  00,893
....................          minute = RTC_Min_Reg; 
158D6:  MOVLB  9
158D8:  CLRF   x18
158DA:  MOVFF  726,917
158DE:  MOVLB  0
158E0:  CALL   C91E
158E4:  MOVFF  03,89A
158E8:  MOVFF  02,899
158EC:  MOVFF  01,898
158F0:  MOVFF  00,897
....................          second = RTC_Sec_Reg; 
158F4:  MOVLB  9
158F6:  CLRF   x18
158F8:  MOVFF  725,917
158FC:  MOVLB  0
158FE:  CALL   C91E
15902:  MOVFF  03,89E
15906:  MOVFF  02,89D
1590A:  MOVFF  01,89C
1590E:  MOVFF  00,89B
....................           
....................          fraction_of_day = (hour / 24); 
15912:  MOVFF  896,8FE
15916:  MOVFF  895,8FD
1591A:  MOVFF  894,8FC
1591E:  MOVFF  893,8FB
15922:  MOVLB  9
15924:  CLRF   x02
15926:  CLRF   x01
15928:  MOVLW  40
1592A:  MOVWF  x00
1592C:  MOVLW  83
1592E:  MOVLB  8
15930:  MOVWF  xFF
15932:  MOVLB  0
15934:  CALL   C954
15938:  MOVFF  03,892
1593C:  MOVFF  02,891
15940:  MOVFF  01,890
15944:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15948:  MOVFF  89A,8FE
1594C:  MOVFF  899,8FD
15950:  MOVFF  898,8FC
15954:  MOVFF  897,8FB
15958:  MOVLB  9
1595A:  CLRF   x02
1595C:  CLRF   x01
1595E:  MOVLW  34
15960:  MOVWF  x00
15962:  MOVLW  89
15964:  MOVLB  8
15966:  MOVWF  xFF
15968:  MOVLB  0
1596A:  CALL   C954
1596E:  BCF    FD8.1
15970:  MOVFF  892,91A
15974:  MOVFF  891,919
15978:  MOVFF  890,918
1597C:  MOVFF  88F,917
15980:  MOVFF  03,91E
15984:  MOVFF  02,91D
15988:  MOVFF  01,91C
1598C:  MOVFF  00,91B
15990:  CALL   C3E2
15994:  MOVFF  03,892
15998:  MOVFF  02,891
1599C:  MOVFF  01,890
159A0:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
159A4:  MOVFF  89E,8FE
159A8:  MOVFF  89D,8FD
159AC:  MOVFF  89C,8FC
159B0:  MOVFF  89B,8FB
159B4:  MOVLB  9
159B6:  CLRF   x02
159B8:  MOVLW  C0
159BA:  MOVWF  x01
159BC:  MOVLW  28
159BE:  MOVWF  x00
159C0:  MOVLW  8F
159C2:  MOVLB  8
159C4:  MOVWF  xFF
159C6:  MOVLB  0
159C8:  CALL   C954
159CC:  BCF    FD8.1
159CE:  MOVFF  892,91A
159D2:  MOVFF  891,919
159D6:  MOVFF  890,918
159DA:  MOVFF  88F,917
159DE:  MOVFF  03,91E
159E2:  MOVFF  02,91D
159E6:  MOVFF  01,91C
159EA:  MOVFF  00,91B
159EE:  CALL   C3E2
159F2:  MOVFF  03,892
159F6:  MOVFF  02,891
159FA:  MOVFF  01,890
159FE:  MOVFF  00,88F
....................           
....................          time_now = time_now + fraction_of_day; 
15A02:  BCF    FD8.1
15A04:  MOVFF  88A,91A
15A08:  MOVFF  889,919
15A0C:  MOVFF  888,918
15A10:  MOVFF  887,917
15A14:  MOVFF  892,91E
15A18:  MOVFF  891,91D
15A1C:  MOVFF  890,91C
15A20:  MOVFF  88F,91B
15A24:  CALL   C3E2
15A28:  MOVFF  03,88A
15A2C:  MOVFF  02,889
15A30:  MOVFF  01,888
15A34:  MOVFF  00,887
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
15A38:  MOVLB  9
15A3A:  CLRF   x18
15A3C:  MOVFF  730,917
15A40:  MOVLB  0
15A42:  CALL   C91E
15A46:  MOVFF  03,896
15A4A:  MOVFF  02,895
15A4E:  MOVFF  01,894
15A52:  MOVFF  00,893
....................          minute = RTC_Al_Min_Reg; 
15A56:  MOVLB  9
15A58:  CLRF   x18
15A5A:  MOVFF  731,917
15A5E:  MOVLB  0
15A60:  CALL   C91E
15A64:  MOVFF  03,89A
15A68:  MOVFF  02,899
15A6C:  MOVFF  01,898
15A70:  MOVFF  00,897
....................          second = RTC_Al_Sec_Reg; 
15A74:  MOVLB  9
15A76:  CLRF   x18
15A78:  MOVFF  732,917
15A7C:  MOVLB  0
15A7E:  CALL   C91E
15A82:  MOVFF  03,89E
15A86:  MOVFF  02,89D
15A8A:  MOVFF  01,89C
15A8E:  MOVFF  00,89B
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
15A92:  MOVLW  01
15A94:  MOVLB  7
15A96:  SUBWF  x2E,W
15A98:  MOVWF  00
15A9A:  BCF    FD8.0
15A9C:  RLCF   00,F
15A9E:  MOVF   00,W
15AA0:  CLRF   03
15AA2:  ADDLW  9F
15AA4:  MOVWF  FE9
15AA6:  MOVLW  08
15AA8:  ADDWFC 03,W
15AAA:  MOVWF  FEA
15AAC:  MOVFF  FEC,03
15AB0:  MOVF   FED,F
15AB2:  MOVFF  FEF,917
15AB6:  MOVFF  03,918
15ABA:  MOVLB  0
15ABC:  CALL   C91E
15AC0:  MOVFF  03,88E
15AC4:  MOVFF  02,88D
15AC8:  MOVFF  01,88C
15ACC:  MOVFF  00,88B
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
15AD0:  MOVLB  9
15AD2:  CLRF   x18
15AD4:  MOVFF  72F,917
15AD8:  MOVLB  0
15ADA:  CALL   C91E
15ADE:  BCF    FD8.1
15AE0:  MOVFF  88E,91A
15AE4:  MOVFF  88D,919
15AE8:  MOVFF  88C,918
15AEC:  MOVFF  88B,917
15AF0:  MOVFF  03,91E
15AF4:  MOVFF  02,91D
15AF8:  MOVFF  01,91C
15AFC:  MOVFF  00,91B
15B00:  CALL   C3E2
15B04:  MOVFF  03,88E
15B08:  MOVFF  02,88D
15B0C:  MOVFF  01,88C
15B10:  MOVFF  00,88B
....................           
....................          fraction_of_day = (hour / 24); 
15B14:  MOVFF  896,8FE
15B18:  MOVFF  895,8FD
15B1C:  MOVFF  894,8FC
15B20:  MOVFF  893,8FB
15B24:  MOVLB  9
15B26:  CLRF   x02
15B28:  CLRF   x01
15B2A:  MOVLW  40
15B2C:  MOVWF  x00
15B2E:  MOVLW  83
15B30:  MOVLB  8
15B32:  MOVWF  xFF
15B34:  MOVLB  0
15B36:  CALL   C954
15B3A:  MOVFF  03,892
15B3E:  MOVFF  02,891
15B42:  MOVFF  01,890
15B46:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15B4A:  MOVFF  89A,8FE
15B4E:  MOVFF  899,8FD
15B52:  MOVFF  898,8FC
15B56:  MOVFF  897,8FB
15B5A:  MOVLB  9
15B5C:  CLRF   x02
15B5E:  CLRF   x01
15B60:  MOVLW  34
15B62:  MOVWF  x00
15B64:  MOVLW  89
15B66:  MOVLB  8
15B68:  MOVWF  xFF
15B6A:  MOVLB  0
15B6C:  CALL   C954
15B70:  BCF    FD8.1
15B72:  MOVFF  892,91A
15B76:  MOVFF  891,919
15B7A:  MOVFF  890,918
15B7E:  MOVFF  88F,917
15B82:  MOVFF  03,91E
15B86:  MOVFF  02,91D
15B8A:  MOVFF  01,91C
15B8E:  MOVFF  00,91B
15B92:  CALL   C3E2
15B96:  MOVFF  03,892
15B9A:  MOVFF  02,891
15B9E:  MOVFF  01,890
15BA2:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15BA6:  MOVFF  89E,8FE
15BAA:  MOVFF  89D,8FD
15BAE:  MOVFF  89C,8FC
15BB2:  MOVFF  89B,8FB
15BB6:  MOVLB  9
15BB8:  CLRF   x02
15BBA:  MOVLW  C0
15BBC:  MOVWF  x01
15BBE:  MOVLW  28
15BC0:  MOVWF  x00
15BC2:  MOVLW  8F
15BC4:  MOVLB  8
15BC6:  MOVWF  xFF
15BC8:  MOVLB  0
15BCA:  CALL   C954
15BCE:  BCF    FD8.1
15BD0:  MOVFF  892,91A
15BD4:  MOVFF  891,919
15BD8:  MOVFF  890,918
15BDC:  MOVFF  88F,917
15BE0:  MOVFF  03,91E
15BE4:  MOVFF  02,91D
15BE8:  MOVFF  01,91C
15BEC:  MOVFF  00,91B
15BF0:  CALL   C3E2
15BF4:  MOVFF  03,892
15BF8:  MOVFF  02,891
15BFC:  MOVFF  01,890
15C00:  MOVFF  00,88F
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
15C04:  BCF    FD8.1
15C06:  MOVFF  88E,91A
15C0A:  MOVFF  88D,919
15C0E:  MOVFF  88C,918
15C12:  MOVFF  88B,917
15C16:  MOVFF  892,91E
15C1A:  MOVFF  891,91D
15C1E:  MOVFF  890,91C
15C22:  MOVFF  88F,91B
15C26:  CALL   C3E2
15C2A:  MOVFF  03,88E
15C2E:  MOVFF  02,88D
15C32:  MOVFF  01,88C
15C36:  MOVFF  00,88B
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
15C3A:  MOVFF  88E,916
15C3E:  MOVFF  88D,915
15C42:  MOVFF  88C,914
15C46:  MOVFF  88B,913
15C4A:  MOVFF  88A,91A
15C4E:  MOVFF  889,919
15C52:  MOVFF  888,918
15C56:  MOVFF  887,917
15C5A:  CALL   1079A
15C5E:  BNC   15C62
15C60:  BSF    4D.3
15C62:  MOVLB  7
....................       } 
....................    } 
15C64:  MOVLB  0
15C66:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
15C68:  BTFSS  4D.3
15C6A:  BRA    15C88
15C6C:  MOVLW  F0
15C6E:  MOVWF  FF6
15C70:  MOVLW  0D
15C72:  MOVWF  FF7
15C74:  MOVLW  00
15C76:  MOVWF  FF8
15C78:  CLRF   1B
15C7A:  BTFSC  FF2.7
15C7C:  BSF    1B.7
15C7E:  BCF    FF2.7
15C80:  CALL   0E6E
15C84:  BTFSC  1B.7
15C86:  BSF    FF2.7
15C88:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F5A0:  BCF    F67.5
0F5A2:  MOVLW  32
0F5A4:  MOVWF  F67
0F5A6:  MOVLW  40
0F5A8:  MOVWF  F68
....................     
....................    data = 0; 
0F5AA:  MOVLB  8
0F5AC:  CLRF   xD7
0F5AE:  CLRF   xD6
....................     
....................    DAC_MS_byte = 0; 
0F5B0:  CLRF   xD8
....................    DAC_LS_byte = 0; 
0F5B2:  CLRF   xD9
....................     
....................    data = setting & 0b0000111100000000; 
0F5B4:  CLRF   xD6
0F5B6:  MOVF   xD5,W
0F5B8:  ANDLW  0F
0F5BA:  MOVWF  xD7
....................    data = data >> 8; 
0F5BC:  MOVFF  8D7,8D6
0F5C0:  CLRF   xD7
....................    DAC_MS_byte = data; 
0F5C2:  MOVFF  8D6,8D8
....................     
....................    data = setting & 0b0000000011111111; 
0F5C6:  MOVFF  8D4,8D6
0F5CA:  CLRF   xD7
....................    DAC_LS_byte = data; 
0F5CC:  MOVFF  8D6,8D9
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F5D0:  MOVLW  01
0F5D2:  SUBWF  xD3,W
0F5D4:  ADDLW  FC
0F5D6:  BC    F602
0F5D8:  ADDLW  04
0F5DA:  MOVLB  0
0F5DC:  GOTO   F620
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F5E0:  MOVLW  30
0F5E2:  MOVLB  8
0F5E4:  IORWF  xD8,F
....................          break; 
0F5E6:  BRA    F602
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F5E8:  MOVLW  70
0F5EA:  MOVLB  8
0F5EC:  IORWF  xD8,F
....................          break; 
0F5EE:  BRA    F602
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F5F0:  MOVLW  B0
0F5F2:  MOVLB  8
0F5F4:  IORWF  xD8,F
....................          break; 
0F5F6:  BRA    F602
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F5F8:  MOVLW  F0
0F5FA:  MOVLB  8
0F5FC:  IORWF  xD8,F
....................          break; 
0F5FE:  BRA    F602
0F600:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F602:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F604:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F606:  MOVF   F6A,W
0F608:  MOVFF  8D8,F6A
0F60C:  RRCF   F68,W
0F60E:  BNC   F60C
....................    spi_write2(DAC_LS_byte); 
0F610:  MOVF   F6A,W
0F612:  MOVFF  8D9,F6A
0F616:  RRCF   F68,W
0F618:  BNC   F616
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F61A:  BSF    F8C.3
0F61C:  MOVLB  0
0F61E:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F648:  MOVLB  8
0F64A:  CLRF   xD8
0F64C:  CLRF   xD9
0F64E:  CLRF   xDA
0F650:  CLRF   xDB
0F652:  CLRF   xDC
0F654:  CLRF   xDD
0F656:  CLRF   xDE
0F658:  CLRF   xDF
0F65A:  CLRF   xE0
0F65C:  CLRF   xE1
0F65E:  CLRF   xE2
0F660:  CLRF   xE3
0F662:  CLRF   xE4
0F664:  CLRF   xE5
0F666:  CLRF   xE6
0F668:  CLRF   xE7
0F66A:  CLRF   xE8
0F66C:  CLRF   xE9
0F66E:  CLRF   xEA
0F670:  CLRF   xEB
0F672:  CLRF   xEC
0F674:  CLRF   xED
0F676:  CLRF   xEE
0F678:  CLRF   xEF
0F67A:  CLRF   xF0
0F67C:  CLRF   xF1
0F67E:  CLRF   xF2
0F680:  CLRF   xF3
0F682:  CLRF   xF4
0F684:  CLRF   xF5
0F686:  CLRF   xF6
0F688:  CLRF   xF7
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F68A:  CLRF   xF8
0F68C:  CLRF   xF9
0F68E:  CLRF   xFA
0F690:  CLRF   xFB
0F692:  CLRF   xFC
0F694:  CLRF   xFD
0F696:  CLRF   xFE
0F698:  CLRF   xFF
0F69A:  MOVLB  9
0F69C:  CLRF   x00
0F69E:  CLRF   x01
0F6A0:  CLRF   x02
0F6A2:  CLRF   x03
0F6A4:  CLRF   x04
0F6A6:  CLRF   x05
0F6A8:  CLRF   x06
0F6AA:  CLRF   x07
0F6AC:  CLRF   x08
0F6AE:  CLRF   x09
0F6B0:  CLRF   x0A
0F6B2:  CLRF   x0B
0F6B4:  CLRF   x0C
0F6B6:  CLRF   x0D
0F6B8:  CLRF   x0E
0F6BA:  CLRF   x0F
0F6BC:  CLRF   x10
0F6BE:  CLRF   x11
0F6C0:  CLRF   x12
0F6C2:  CLRF   x13
0F6C4:  CLRF   x14
0F6C6:  CLRF   x15
0F6C8:  CLRF   x16
0F6CA:  CLRF   x17
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F6CC:  MOVLB  8
0F6CE:  CLRF   xD7
0F6D0:  MOVLW  01
0F6D2:  MOVWF  xD6
0F6D4:  MOVLW  01
0F6D6:  ADDWF  xD3,W
0F6D8:  MOVWF  01
0F6DA:  MOVLW  00
0F6DC:  ADDWFC xD4,W
0F6DE:  MOVWF  03
0F6E0:  MOVF   xD7,W
0F6E2:  SUBWF  03,W
0F6E4:  BTFSS  FD8.0
0F6E6:  BRA    F7D2
0F6E8:  BNZ   F6F0
0F6EA:  MOVF   01,W
0F6EC:  SUBWF  xD6,W
0F6EE:  BC    F7D2
....................    { 
....................       for (n=1; n<5; ++n) 
0F6F0:  MOVLW  01
0F6F2:  MOVWF  xD5
0F6F4:  MOVF   xD5,W
0F6F6:  SUBLW  04
0F6F8:  BNC   F7CA
....................       { 
....................          set_adc_channel(n,VSS); 
0F6FA:  RLCF   xD5,W
0F6FC:  MOVWF  00
0F6FE:  RLCF   00,F
0F700:  MOVLW  FC
0F702:  ANDWF  00,F
0F704:  MOVF   FC2,W
0F706:  ANDLW  83
0F708:  IORWF  00,W
0F70A:  MOVWF  FC2
0F70C:  MOVLW  00
0F70E:  MOVWF  01
0F710:  MOVF   FC1,W
0F712:  ANDLW  F8
0F714:  IORWF  01,W
0F716:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F718:  MOVF   xD5,W
0F71A:  MULLW  04
0F71C:  MOVF   FF3,W
0F71E:  CLRF   03
0F720:  ADDLW  F8
0F722:  MOVWF  FE9
0F724:  MOVLW  08
0F726:  ADDWFC 03,W
0F728:  MOVWF  FEA
0F72A:  BSF    FC2.1
0F72C:  BTFSC  FC2.1
0F72E:  BRA    F72C
0F730:  MOVFF  FC3,FEF
0F734:  MOVFF  FC4,FEC
0F738:  CLRF   FEC
0F73A:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F73C:  MOVF   xD5,W
0F73E:  MULLW  04
0F740:  MOVF   FF3,W
0F742:  CLRF   03
0F744:  ADDLW  D8
0F746:  MOVWF  01
0F748:  MOVLW  08
0F74A:  ADDWFC 03,F
0F74C:  MOVFF  01,918
0F750:  MOVFF  03,919
0F754:  MOVLB  8
0F756:  MOVF   xD5,W
0F758:  MULLW  04
0F75A:  MOVF   FF3,W
0F75C:  CLRF   03
0F75E:  ADDLW  D8
0F760:  MOVWF  FE9
0F762:  MOVLW  08
0F764:  ADDWFC 03,W
0F766:  MOVWF  FEA
0F768:  MOVFF  FEF,91A
0F76C:  MOVFF  FEC,91B
0F770:  MOVFF  FEC,91C
0F774:  MOVFF  FEC,91D
0F778:  MOVF   xD5,W
0F77A:  MULLW  04
0F77C:  MOVF   FF3,W
0F77E:  CLRF   03
0F780:  ADDLW  F8
0F782:  MOVWF  FE9
0F784:  MOVLW  08
0F786:  ADDWFC 03,W
0F788:  MOVWF  FEA
0F78A:  MOVFF  FEF,00
0F78E:  MOVFF  FEC,01
0F792:  MOVFF  FEC,02
0F796:  MOVFF  FEC,03
0F79A:  MOVLB  9
0F79C:  MOVF   x1A,W
0F79E:  ADDWF  00,F
0F7A0:  MOVF   x1B,W
0F7A2:  ADDWFC 01,F
0F7A4:  MOVF   x1C,W
0F7A6:  ADDWFC 02,F
0F7A8:  MOVF   x1D,W
0F7AA:  ADDWFC 03,F
0F7AC:  MOVFF  919,FEA
0F7B0:  MOVFF  918,FE9
0F7B4:  MOVFF  00,FEF
0F7B8:  MOVFF  01,FEC
0F7BC:  MOVFF  02,FEC
0F7C0:  MOVFF  03,FEC
0F7C4:  MOVLB  8
0F7C6:  INCF   xD5,F
0F7C8:  BRA    F6F4
....................       } 
0F7CA:  INCF   xD6,F
0F7CC:  BTFSC  FD8.2
0F7CE:  INCF   xD7,F
0F7D0:  BRA    F6D4
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F7D2:  MOVLW  01
0F7D4:  MOVWF  xD5
0F7D6:  MOVF   xD5,W
0F7D8:  SUBLW  04
0F7DA:  BNC   F84E
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F7DC:  BCF    FD8.0
0F7DE:  RLCF   xD5,W
0F7E0:  CLRF   03
0F7E2:  ADDLW  A5
0F7E4:  MOVWF  01
0F7E6:  MOVLW  04
0F7E8:  ADDWFC 03,F
0F7EA:  MOVFF  01,918
0F7EE:  MOVFF  03,919
0F7F2:  MOVLB  8
0F7F4:  MOVF   xD5,W
0F7F6:  MULLW  04
0F7F8:  MOVF   FF3,W
0F7FA:  CLRF   03
0F7FC:  ADDLW  D8
0F7FE:  MOVWF  FE9
0F800:  MOVLW  08
0F802:  ADDWFC 03,W
0F804:  MOVWF  FEA
0F806:  MOVFF  FEF,A4C
0F80A:  MOVFF  FEC,A4D
0F80E:  MOVFF  FEC,A4E
0F812:  MOVFF  FEC,A4F
0F816:  BCF    FD8.1
0F818:  CLRF   1B
0F81A:  BTFSC  FF2.7
0F81C:  BSF    1B.7
0F81E:  BCF    FF2.7
0F820:  MOVLB  A
0F822:  CLRF   x53
0F824:  CLRF   x52
0F826:  MOVFF  8D4,A51
0F82A:  MOVFF  8D3,A50
0F82E:  MOVLB  0
0F830:  CALL   1076
0F834:  BTFSC  1B.7
0F836:  BSF    FF2.7
0F838:  MOVFF  919,FEA
0F83C:  MOVFF  918,FE9
0F840:  MOVFF  00,FEF
0F844:  MOVFF  01,FEC
0F848:  MOVLB  8
0F84A:  INCF   xD5,F
0F84C:  BRA    F7D6
....................    } 
0F84E:  MOVLB  0
0F850:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    //Handle updating variables for the valve timeout 
....................    /*if(valve_align_timeout != -1){ 
....................       fprintf(COM_A,"align_var: %Ld \r\n",valve_align_timeout); 
....................       if(valve_align_timeout >= 2){ 
....................          valve_align_timeout = -1; 
....................          reset_cpu(); 
....................       } 
....................       valve_align_timeout++; 
....................    }*/ 
....................    //Service watchdog 
....................    output_bit(PIN_J7,(!input(PIN_J7))); 
*
00E34:  BTFSS  F88.7
00E36:  BRA    0E3C
00E38:  BCF    F91.7
00E3A:  BRA    0E3E
00E3C:  BSF    F91.7
....................     
....................    rtc_alarm = TRUE; 
00E3E:  BSF    4D.0
....................    sleep_mode = FALSE; 
00E40:  BCF    4D.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E42:  BTFSS  4D.2
00E44:  BRA    0E48
....................    { 
....................       ; 
00E46:  BRA    0E42
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E48:  BSF    4D.2
....................    RTC_read_flags(); 
00E4A:  RCALL  0DF8
....................    ++nv_elapsed; 
00E4C:  INCF   35,F
00E4E:  BTFSC  FD8.2
00E50:  INCF   36,F
.................... } 
....................  
00E52:  BCF    FF2.1
00E54:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E98:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E9A:  BTFSC  4D.1
00E9C:  BRA    0EEE
....................    { 
....................       if (kbhit(COM_A)) 
00E9E:  BTFSS  F9E.5
00EA0:  BRA    0EEC
....................       { 
....................          c = getc(COM_A); 
00EA2:  RCALL  0E58
00EA4:  MOVFF  01,A37
....................          switch (c) 
00EA8:  MOVLB  A
00EAA:  MOVF   x37,W
00EAC:  XORLW  3F
00EAE:  MOVLB  0
00EB0:  BZ    0EBC
00EB2:  XORLW  2E
00EB4:  BZ    0EE0
00EB6:  XORLW  0A
00EB8:  BZ    0EE6
00EBA:  BRA    0EEC
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00EBC:  DECFSZ 4E,W
00EBE:  BRA    0ED0
00EC0:  MOVLW  F8
00EC2:  MOVWF  FF6
00EC4:  MOVLW  0E
00EC6:  MOVWF  FF7
00EC8:  MOVLW  00
00ECA:  MOVWF  FF8
00ECC:  RCALL  0E6E
00ECE:  BRA    0EDE
....................                else fprintf(COM_A, "@RDY\r\n"); 
00ED0:  MOVLW  00
00ED2:  MOVWF  FF6
00ED4:  MOVLW  0F
00ED6:  MOVWF  FF7
00ED8:  MOVLW  00
00EDA:  MOVWF  FF8
00EDC:  RCALL  0E6E
....................                break; 
00EDE:  BRA    0EEC
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EE0:  MOVLW  01
00EE2:  MOVWF  50
....................                break;          
00EE4:  BRA    0EEC
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EE6:  CLRF   32
00EE8:  MOVLW  01
00EEA:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EEC:  BRA    0EF2
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EEE:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00EF0:  BCF    F9E.5
....................    } 
00EF2:  BCF    F9E.5
00EF4:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0AED8:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0AEDA:  MOVF   FAE,W
....................    busy_status = FALSE; 
0AEDC:  CLRF   4E
0AEDE:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
029E8:  MOVLW  01
029EA:  MOVWF  4E
....................    clear_interrupt(INT_RDA); 
029EC:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
029EE:  BSF    F9D.5
029F0:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00F08:  MOVLW  0B
00F0A:  MOVWF  FD7
00F0C:  MOVLW  DC
00F0E:  MOVWF  FD6
....................    restart_wdt(); 
00F10:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00F12:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00F14:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00F16:  CLRF   FCF
00F18:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00F1A:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00F1C:  MOVF   2F,W
00F1E:  SUBLW  02
00F20:  BNZ   0F28
00F22:  MOVF   30,F
00F24:  BNZ   0F28
00F26:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00F28:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00F2A:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00F2C:  BCF    FF2.2
00F2E:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00F32:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F34:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F36:  MOVF   2F,W
00F38:  SUBLW  02
00F3A:  BNZ   0F42
00F3C:  MOVF   30,F
00F3E:  BNZ   0F42
00F40:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F42:  BCF    F9E.0
00F44:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
15D5C:  MOVLB  8
15D5E:  CLRF   x8C
15D60:  CLRF   x90
15D62:  CLRF   x8F
15D64:  CLRF   x8E
15D66:  CLRF   x8D
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
15D68:  MOVLW  01
15D6A:  ADDWF  x8D,F
15D6C:  BTFSC  FD8.0
15D6E:  INCF   x8E,F
15D70:  BTFSC  FD8.2
15D72:  INCF   x8F,F
15D74:  BTFSC  FD8.2
15D76:  INCF   x90,F
15D78:  MOVF   x90,F
15D7A:  BNZ   15DBC
15D7C:  MOVF   x8F,W
15D7E:  SUBLW  04
15D80:  BNC   15DBC
15D82:  BNZ   15D92
15D84:  MOVF   x8E,W
15D86:  SUBLW  93
15D88:  BNC   15DBC
15D8A:  BNZ   15D92
15D8C:  MOVF   x8D,W
15D8E:  SUBLW  DF
15D90:  BNC   15DBC
....................    { 
....................       if(kbhit(COM_A)) 
15D92:  BTFSS  F9E.5
15D94:  BRA    15DB2
....................       { 
....................          c = fgetc(COM_A); 
15D96:  MOVLB  0
15D98:  CALL   0E58
15D9C:  MOVFF  01,88C
....................          if (com_echo == TRUE) 
15DA0:  DECFSZ 4C,W
15DA2:  BRA    15DAE
....................          { 
....................             fputc(c, COM_A); 
15DA4:  MOVLB  8
15DA6:  MOVF   x8C,W
15DA8:  MOVLB  0
15DAA:  CALL   AEE0
....................          } 
....................          break; 
15DAE:  MOVLB  8
15DB0:  BRA    15DBC
....................       } 
....................  
....................       delay_us(10); 
15DB2:  MOVLW  35
15DB4:  MOVWF  00
15DB6:  DECFSZ 00,F
15DB8:  BRA    15DB6
15DBA:  BRA    15D68
....................    } 
....................  
....................    return(c); 
15DBC:  MOVFF  88C,01
15DC0:  MOVLB  0
15DC2:  GOTO   15DD2 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AE54:  MOVLW  58
0AE56:  MOVLB  8
0AE58:  MOVWF  x64
0AE5A:  CLRF   x68
0AE5C:  CLRF   x67
0AE5E:  CLRF   x66
0AE60:  CLRF   x65
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AE62:  MOVLW  01
0AE64:  ADDWF  x65,F
0AE66:  BTFSC  FD8.0
0AE68:  INCF   x66,F
0AE6A:  BTFSC  FD8.2
0AE6C:  INCF   x67,F
0AE6E:  BTFSC  FD8.2
0AE70:  INCF   x68,F
0AE72:  MOVF   x68,F
0AE74:  BNZ   AEA4
0AE76:  MOVF   x67,F
0AE78:  BNZ   AEA4
0AE7A:  MOVF   x66,W
0AE7C:  SUBLW  C3
0AE7E:  BNC   AEA4
0AE80:  BNZ   AE88
0AE82:  MOVF   x65,W
0AE84:  SUBLW  4F
0AE86:  BNC   AEA4
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AE88:  MOVLW  05
0AE8A:  MOVWF  00
0AE8C:  DECFSZ 00,F
0AE8E:  BRA    AE8C
....................  
....................       if(kbhit()) 
0AE90:  BTFSS  F9E.5
0AE92:  BRA    AEA2
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AE94:  MOVLB  0
0AE96:  CALL   0E58
0AE9A:  MOVFF  01,864
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AE9E:  MOVLB  8
0AEA0:  BRA    AEA4
....................       } 
0AEA2:  BRA    AE62
....................    } 
....................  
....................    return(EscChar); 
0AEA4:  MOVFF  864,01
0AEA8:  MOVLB  0
0AEAA:  GOTO   1BA76 (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0DAA0:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0DAA2:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0DAA4:  BSF    F8F.3
....................    delay_ms(10); 
0DAA6:  MOVLW  0A
0DAA8:  MOVLB  9
0DAAA:  MOVWF  xEC
0DAAC:  MOVLB  0
0DAAE:  CALL   2938
0DAB2:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0DB8C:  MOVLB  8
0DB8E:  CLRF   xF4
0DB90:  CLRF   xF3
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0DB92:  MOVLB  F
0DB94:  BTFSC  x21.1
0DB96:  BRA    DBA4
....................       ++c; 
0DB98:  MOVLB  8
0DB9A:  INCF   xF3,F
0DB9C:  BTFSC  FD8.2
0DB9E:  INCF   xF4,F
0DBA0:  BRA    DB92
0DBA2:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0DBA4:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0DBA6:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0DBA8:  BCF    F8F.3
0DBAA:  MOVLB  0
0DBAC:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
16F96:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
16F98:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
16F9A:  BCF    F8F.3
16F9C:  GOTO   1708A (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
16FA0:  MOVLB  8
16FA2:  CLRF   x85
16FA4:  CLRF   x86
16FA6:  CLRF   xD7
16FA8:  CLRF   xD8
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16FAA:  MOVLW  48
16FAC:  MOVWF  FF6
16FAE:  MOVLW  0F
16FB0:  MOVWF  FF7
16FB2:  MOVLW  00
16FB4:  MOVWF  FF8
16FB6:  CLRF   1B
16FB8:  BTFSC  FF2.7
16FBA:  BSF    1B.7
16FBC:  BCF    FF2.7
16FBE:  MOVLB  0
16FC0:  CALL   0E6E
16FC4:  BTFSC  1B.7
16FC6:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16FC8:  MOVLB  8
16FCA:  MOVF   x86,W
16FCC:  SUBLW  04
16FCE:  BZ    17086
....................    { 
....................        if (kbhit(COM_A)) 
16FD0:  BTFSS  F9E.5
16FD2:  BRA    1706A
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16FD4:  MOVLB  0
16FD6:  CALL   0E58
16FDA:  MOVFF  01,885
....................           if (com_echo == TRUE) 
16FDE:  DECFSZ 4C,W
16FE0:  BRA    16FEC
....................           { 
....................              fputc(charFromA, COM_A); 
16FE2:  MOVLB  8
16FE4:  MOVF   x85,W
16FE6:  MOVLB  0
16FE8:  CALL   AEE0
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16FEC:  MOVLB  8
16FEE:  MOVF   xD8,W
16FF0:  SUBLW  4F
16FF2:  BNC   17048
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16FF4:  MOVF   xD8,W
16FF6:  INCF   xD8,F
16FF8:  CLRF   03
16FFA:  ADDLW  87
16FFC:  MOVWF  FE9
16FFE:  MOVLW  08
17000:  ADDWFC 03,W
17002:  MOVWF  FEA
17004:  MOVFF  885,FEF
....................              if (CARRIAGE_RET == charFromA) 
17008:  MOVF   x85,W
1700A:  SUBLW  0D
1700C:  BNZ   17046
....................              { 
....................                 multidrop_on(); 
1700E:  MOVLB  0
17010:  CALL   DAA0
....................                 for (index = 0 ; index < charCount; index++) 
17014:  MOVLB  8
17016:  CLRF   xD7
17018:  MOVF   xD8,W
1701A:  SUBWF  xD7,W
1701C:  BC    1703C
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
1701E:  CLRF   03
17020:  MOVF   xD7,W
17022:  ADDLW  87
17024:  MOVWF  FE9
17026:  MOVLW  08
17028:  ADDWFC 03,W
1702A:  MOVWF  FEA
1702C:  MOVFF  FEF,8D9
17030:  MOVF   xD9,W
17032:  MOVLB  0
17034:  BRA    16F88
17036:  MOVLB  8
17038:  INCF   xD7,F
1703A:  BRA    17018
....................                 } 
....................                 charCount = 0; 
1703C:  CLRF   xD8
....................                 multidrop_off(); 
1703E:  MOVLB  0
17040:  CALL   DB8C
17044:  MOVLB  8
....................              } 
....................           } 
17046:  BRA    1706A
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
17048:  MOVLW  50
1704A:  MOVWF  FF6
1704C:  MOVLW  0F
1704E:  MOVWF  FF7
17050:  MOVLW  00
17052:  MOVWF  FF8
17054:  CLRF   1B
17056:  BTFSC  FF2.7
17058:  BSF    1B.7
1705A:  BCF    FF2.7
1705C:  MOVLB  0
1705E:  CALL   0E6E
17062:  BTFSC  1B.7
17064:  BSF    FF2.7
....................              charCount = 0; 
17066:  MOVLB  8
17068:  CLRF   xD8
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
1706A:  BTFSS  FA4.5
1706C:  BRA    17084
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
1706E:  MOVLB  0
17070:  CALL   12E5A
17074:  MOVFF  01,886
....................           fputc(charFromB, COM_A);                  // send data via USART 
17078:  MOVLB  8
1707A:  MOVF   x86,W
1707C:  MOVLB  0
1707E:  CALL   AEE0
17082:  MOVLB  8
....................        } 
17084:  BRA    16FCA
....................    } 
....................  
....................    multidrop_shdn(); 
17086:  MOVLB  0
17088:  BRA    16F96
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
1708A:  MOVLW  60
1708C:  MOVWF  FF6
1708E:  MOVLW  0F
17090:  MOVWF  FF7
17092:  MOVLW  00
17094:  MOVWF  FF8
17096:  CLRF   1B
17098:  BTFSC  FF2.7
1709A:  BSF    1B.7
1709C:  BCF    FF2.7
1709E:  CALL   0E6E
170A2:  BTFSC  1B.7
170A4:  BSF    FF2.7
170A6:  GOTO   170C0 (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C89C:  MOVLB  8
0C89E:  DECF   x9F,F
....................    len=0; 
0C8A0:  CLRF   xA0
....................    do { 
....................      c=getc(); 
0C8A2:  MOVLB  0
0C8A4:  CALL   0E58
0C8A8:  MOVFF  01,8A1
....................      if(c==8) {  // Backspace 
0C8AC:  MOVLB  8
0C8AE:  MOVF   xA1,W
0C8B0:  SUBLW  08
0C8B2:  BNZ   C8D6
....................         if(len>0) { 
0C8B4:  MOVF   xA0,F
0C8B6:  BZ    C8D4
....................           len--; 
0C8B8:  DECF   xA0,F
....................           putc(c); 
0C8BA:  MOVF   xA1,W
0C8BC:  MOVLB  0
0C8BE:  CALL   AEE0
....................           putc(' '); 
0C8C2:  MOVLW  20
0C8C4:  CALL   AEE0
....................           putc(c); 
0C8C8:  MOVLB  8
0C8CA:  MOVF   xA1,W
0C8CC:  MOVLB  0
0C8CE:  CALL   AEE0
0C8D2:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C8D4:  BRA    C904
0C8D6:  MOVF   xA1,W
0C8D8:  SUBLW  1F
0C8DA:  BC    C904
0C8DC:  MOVF   xA1,W
0C8DE:  SUBLW  7E
0C8E0:  BNC   C904
....................        if(len<=max) { 
0C8E2:  MOVF   xA0,W
0C8E4:  SUBWF  x9F,W
0C8E6:  BNC   C904
....................          s[len++]=c; 
0C8E8:  MOVF   xA0,W
0C8EA:  INCF   xA0,F
0C8EC:  ADDWF  x9D,W
0C8EE:  MOVWF  FE9
0C8F0:  MOVLW  00
0C8F2:  ADDWFC x9E,W
0C8F4:  MOVWF  FEA
0C8F6:  MOVFF  8A1,FEF
....................          putc(c); 
0C8FA:  MOVF   xA1,W
0C8FC:  MOVLB  0
0C8FE:  CALL   AEE0
0C902:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C904:  MOVF   xA1,W
0C906:  SUBLW  0D
0C908:  BNZ   C8A2
....................    s[len]=0; 
0C90A:  MOVF   xA0,W
0C90C:  ADDWF  x9D,W
0C90E:  MOVWF  FE9
0C910:  MOVLW  00
0C912:  ADDWFC x9E,W
0C914:  MOVWF  FEA
0C916:  CLRF   FEF
0C918:  MOVLB  0
0C91A:  GOTO   CD40 (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CD2E:  MOVLW  08
0CD30:  MOVLB  8
0CD32:  MOVWF  x9E
0CD34:  MOVLW  85
0CD36:  MOVWF  x9D
0CD38:  MOVLW  14
0CD3A:  MOVWF  x9F
0CD3C:  MOVLB  0
0CD3E:  BRA    C89C
....................   f = atof(s); 
0CD40:  MOVLW  08
0CD42:  MOVLB  8
0CD44:  MOVWF  x9E
0CD46:  MOVLW  85
0CD48:  MOVWF  x9D
0CD4A:  CLRF   xA0
0CD4C:  CLRF   x9F
0CD4E:  MOVLB  0
0CD50:  BRA    CAD2
0CD52:  MOVFF  03,89C
0CD56:  MOVFF  02,89B
0CD5A:  MOVFF  01,89A
0CD5E:  MOVFF  00,899
....................   return(f); 
0CD62:  MOVFF  899,00
0CD66:  MOVFF  89A,01
0CD6A:  MOVFF  89B,02
0CD6E:  MOVFF  89C,03
0CD72:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
02962:  MOVLW  2F
02964:  MOVWF  F92
....................    set_tris_b(0b00110111); 
02966:  MOVLW  37
02968:  MOVWF  F93
....................    set_tris_c(0b10010000); 
0296A:  MOVLW  90
0296C:  MOVWF  F94
....................    set_tris_d(0b00100000); 
0296E:  MOVLW  20
02970:  MOVWF  F95
....................    set_tris_e(0b01000000); 
02972:  MOVLW  40
02974:  MOVWF  F96
....................    set_tris_f(0b00000000); 
02976:  MOVLW  00
02978:  MOVWF  F97
....................    set_tris_g(0b11100100); 
0297A:  MOVLW  E4
0297C:  MOVWF  F98
....................    set_tris_h(0b01000000); 
0297E:  MOVLW  40
02980:  MOVWF  F99
....................    set_tris_j(0b00000000); 
02982:  MOVLW  00
02984:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
02986:  BCF    F8E.3
....................    output_low(HB_IN1); 
02988:  BCF    F8E.4
....................    output_low(HB_IN2); 
0298A:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
0298C:  BCF    F91.3
....................    output_high(EEP_CS);        
0298E:  BSF    F91.2
....................    output_high(RTC_CS); 
02990:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
02992:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
02994:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
02996:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
02998:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
0299A:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
0299C:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
0299E:  BCF    F8F.3
....................    delay_ms(20);   
029A0:  MOVLW  14
029A2:  MOVLB  9
029A4:  MOVWF  xEC
029A6:  MOVLB  0
029A8:  RCALL  2938
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
029AA:  BCF    F8E.1
....................    output_low(VDET);     
029AC:  BCF    F90.7
....................    bus_pwr_status=0; 
029AE:  MOVLB  4
029B0:  CLRF   xB6
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
029B2:  BSF    F8C.2
....................    output_high(DAC_CS); 
029B4:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
029B6:  BCF    F8C.0
....................    output_low(HSW2); 
029B8:  BCF    F8C.1
....................    heater_stat=0; 
029BA:  CLRF   xB5
029BC:  MOVLB  0
029BE:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
15C8A:  BSF    F91.1
....................    output_low(EEP_WP);        
15C8C:  BCF    F91.3
....................    output_high(EEP_CS);        
15C8E:  BSF    F91.2
....................    output_high(RTC_CS);  
15C90:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
15C92:  BCF    F8E.3
....................    output_low(HB_IN1);        
15C94:  BCF    F8E.4
....................    output_low(HB_IN2); 
15C96:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
15C98:  BCF    F8C.2
....................    output_low(DAC_CS); 
15C9A:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
15C9C:  BCF    F8C.0
....................    output_low(HSW2); 
15C9E:  BCF    F8C.1
....................    heater_stat=0; 
15CA0:  MOVLB  4
15CA2:  CLRF   xB5
....................    // Power switches 
....................    output_low(VMOT);         
15CA4:  BCF    F8E.1
....................    output_low(VDET);  
15CA6:  BCF    F90.7
....................    bus_pwr_status=0; 
15CA8:  CLRF   xB6
....................    output_low(VENC1);         
15CAA:  BCF    F8E.6
....................    output_low(VENC2);         
15CAC:  BCF    F8E.7
....................    output_low(VHBRDG);  
15CAE:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
15CB0:  MOVLW  68
15CB2:  MOVWF  FF6
15CB4:  MOVLW  0F
15CB6:  MOVWF  FF7
15CB8:  MOVLW  00
15CBA:  MOVWF  FF8
15CBC:  CLRF   1B
15CBE:  BTFSC  FF2.7
15CC0:  BSF    1B.7
15CC2:  BCF    FF2.7
15CC4:  MOVLB  0
15CC6:  CALL   0E6E
15CCA:  BTFSC  1B.7
15CCC:  BSF    FF2.7
....................    delay_ms(50); 
15CCE:  MOVLW  32
15CD0:  MOVLB  9
15CD2:  MOVWF  xEC
15CD4:  MOVLB  0
15CD6:  CALL   2938
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
15CDA:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
15CDC:  BSF    F91.6
....................    output_low(MD1_TXEN); 
15CDE:  BCF    F91.5
....................    output_low(MD2_SHDN);    
15CE0:  BCF    F8F.0
....................    output_low(MD2_REN); 
15CE2:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
15CE4:  BCF    F8F.3
....................  
....................    delay_ms(30); 
15CE6:  MOVLW  1E
15CE8:  MOVLB  9
15CEA:  MOVWF  xEC
15CEC:  MOVLB  0
15CEE:  CALL   2938
15CF2:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
05062:  MOVLB  8
05064:  CLRF   x89
05066:  MOVF   x89,W
05068:  SUBLW  02
0506A:  BNC   5090
....................       FS_Status = f_mountdrv(); 
0506C:  MOVLB  0
0506E:  RCALL  487E
05070:  MOVFF  01,724
....................       if (FS_Status) 
05074:  MOVLB  7
05076:  MOVF   x24,F
05078:  BZ    5084
....................          { 
....................          display_file_result(FS_Status); 
0507A:  MOVFF  724,88A
0507E:  MOVLB  0
05080:  BRA    4E1C
....................          } 
05082:  BRA    508A
....................       else break; 
05084:  MOVLB  8
05086:  BRA    5090
05088:  MOVLB  0
0508A:  MOVLB  8
0508C:  INCF   x89,F
0508E:  BRA    5066
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
05090:  MOVLW  3E
05092:  MOVWF  xEE
05094:  CLRF   xF0
05096:  MOVFF  724,8EF
0509A:  MOVLB  0
0509C:  RCALL  4FFC
....................     
....................    return(FS_Status); 
0509E:  MOVLB  7
050A0:  MOVFF  724,01
050A4:  MOVLB  0
050A6:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
03124:  MOVLW  01
03126:  MOVLB  8
03128:  MOVWF  x64
0312A:  MOVF   x64,W
0312C:  SUBLW  03
0312E:  BNC   316A
....................    { 
....................       output_bit(BOARD_LED, ON); 
03130:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
03132:  MOVF   2F,W
03134:  SUBLW  02
03136:  BNZ   313E
03138:  MOVF   30,F
0313A:  BNZ   313E
0313C:  BSF    F90.6
....................       delay_ms(32); 
0313E:  MOVLW  20
03140:  MOVLB  9
03142:  MOVWF  xEC
03144:  MOVLB  0
03146:  CALL   2938
....................       output_bit(BOARD_LED, OFF); 
0314A:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
0314C:  MOVF   2F,W
0314E:  SUBLW  02
03150:  BNZ   3158
03152:  MOVF   30,F
03154:  BNZ   3158
03156:  BCF    F90.6
....................       delay_ms(32); 
03158:  MOVLW  20
0315A:  MOVLB  9
0315C:  MOVWF  xEC
0315E:  MOVLB  0
03160:  CALL   2938
03164:  MOVLB  8
03166:  INCF   x64,F
03168:  BRA    312A
....................    } 
0316A:  MOVLB  0
0316C:  GOTO   1B876 (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
05124:  MOVLB  8
05126:  CLRF   xF3
05128:  CLRF   xF2
0512A:  CLRF   xF1
0512C:  CLRF   xF0
....................    set_adc_channel(0,VSS); 
0512E:  MOVLW  00
05130:  MOVWF  01
05132:  MOVF   FC2,W
05134:  ANDLW  83
05136:  IORWF  01,W
05138:  MOVWF  FC2
0513A:  MOVLW  00
0513C:  MOVWF  01
0513E:  MOVF   FC1,W
05140:  ANDLW  F8
05142:  IORWF  01,W
05144:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
05146:  MOVLW  01
05148:  MOVWF  xED
0514A:  MOVF   xED,W
0514C:  SUBLW  32
0514E:  BNC   5174
....................       reading=read_adc(); 
05150:  BSF    FC2.1
05152:  BTFSC  FC2.1
05154:  BRA    5152
05156:  MOVFF  FC3,8F4
0515A:  MOVFF  FC4,8F5
0515E:  CLRF   xF6
05160:  CLRF   xF7
....................       delay_ms(5); 
05162:  MOVLW  05
05164:  MOVLB  9
05166:  MOVWF  xEC
05168:  MOVLB  0
0516A:  CALL   2938
0516E:  MOVLB  8
05170:  INCF   xED,F
05172:  BRA    514A
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
05174:  MOVLW  01
05176:  MOVWF  xED
05178:  MOVF   xED,W
0517A:  SUBLW  64
0517C:  BNC   522A
....................       reading=read_adc(); 
0517E:  BSF    FC2.1
05180:  BTFSC  FC2.1
05182:  BRA    5180
05184:  MOVFF  FC3,8F4
05188:  MOVFF  FC4,8F5
0518C:  CLRF   xF6
0518E:  CLRF   xF7
....................       result=(((result*(i-1))+reading)/i); 
05190:  MOVLW  01
05192:  SUBWF  xED,W
05194:  MOVWF  xF8
05196:  MOVFF  8F3,9F9
0519A:  MOVFF  8F2,9F8
0519E:  MOVFF  8F1,9F7
051A2:  MOVFF  8F0,9F6
051A6:  MOVLB  9
051A8:  CLRF   xFD
051AA:  CLRF   xFC
051AC:  CLRF   xFB
051AE:  MOVWF  xFA
051B0:  MOVLB  0
051B2:  CALL   4818
051B6:  MOVFF  03,8FB
051BA:  MOVFF  02,8FA
051BE:  MOVFF  01,8F9
051C2:  MOVFF  00,8F8
051C6:  MOVLB  8
051C8:  MOVF   xF4,W
051CA:  ADDWF  xF8,F
051CC:  MOVF   xF5,W
051CE:  ADDWFC xF9,F
051D0:  MOVF   xF6,W
051D2:  ADDWFC xFA,F
051D4:  MOVF   xF7,W
051D6:  ADDWFC xFB,F
051D8:  BCF    FD8.1
051DA:  CLRF   1B
051DC:  BTFSC  FF2.7
051DE:  BSF    1B.7
051E0:  BCF    FF2.7
051E2:  MOVFF  8FB,A4F
051E6:  MOVFF  8FA,A4E
051EA:  MOVFF  8F9,A4D
051EE:  MOVFF  8F8,A4C
051F2:  MOVLB  A
051F4:  CLRF   x53
051F6:  CLRF   x52
051F8:  CLRF   x51
051FA:  MOVFF  8ED,A50
051FE:  MOVLB  0
05200:  CALL   1076
05204:  BTFSC  1B.7
05206:  BSF    FF2.7
05208:  MOVFF  03,8F3
0520C:  MOVFF  02,8F2
05210:  MOVFF  01,8F1
05214:  MOVFF  00,8F0
....................       delay_ms(5); 
05218:  MOVLW  05
0521A:  MOVLB  9
0521C:  MOVWF  xEC
0521E:  MOVLB  0
05220:  CALL   2938
05224:  MOVLB  8
05226:  INCF   xED,F
05228:  BRA    5178
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
0522A:  MOVFF  8F3,9F9
0522E:  MOVFF  8F2,9F8
05232:  MOVFF  8F1,9F7
05236:  MOVFF  8F0,9F6
0523A:  MOVLB  9
0523C:  CLRF   xFD
0523E:  CLRF   xFC
05240:  CLRF   xFB
05242:  MOVLW  64
05244:  MOVWF  xFA
05246:  MOVLB  0
05248:  CALL   4818
0524C:  MOVFF  03,8FB
05250:  MOVFF  02,8FA
05254:  MOVFF  01,8F9
05258:  MOVFF  00,8F8
0525C:  BCF    FD8.1
0525E:  CLRF   1B
05260:  BTFSC  FF2.7
05262:  BSF    1B.7
05264:  BCF    FF2.7
05266:  MOVFF  03,A4F
0526A:  MOVFF  02,A4E
0526E:  MOVFF  01,A4D
05272:  MOVFF  00,A4C
05276:  MOVLB  A
05278:  CLRF   x53
0527A:  CLRF   x52
0527C:  MOVLW  01
0527E:  MOVWF  x51
05280:  MOVLW  10
05282:  MOVWF  x50
05284:  MOVLB  0
05286:  CALL   1076
0528A:  BTFSC  1B.7
0528C:  BSF    FF2.7
0528E:  MOVLW  56
05290:  MOVLB  8
05292:  ADDWF  00,W
05294:  MOVWF  xEE
05296:  MOVLW  00
05298:  ADDWFC 01,W
0529A:  MOVWF  xEF
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
0529C:  MOVFF  8EE,01
052A0:  MOVFF  8EF,02
052A4:  MOVLB  0
052A6:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
0510E:  MOVLW  02
05110:  MOVWF  FEA
05112:  MOVLW  99
05114:  MOVWF  FE9
05116:  CLRF   00
05118:  CLRF   02
0511A:  MOVLW  1E
0511C:  MOVWF  01
0511E:  CALL   354E
05122:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12D82:  MOVLW  02
12D84:  MOVWF  FEA
12D86:  MOVLW  B7
12D88:  MOVWF  FE9
12D8A:  CLRF   00
12D8C:  CLRF   02
12D8E:  MOVLW  1E
12D90:  MOVWF  01
12D92:  CALL   354E
12D96:  GOTO   1303E (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
05442:  RCALL  510E
....................     
....................    v_supply = read_supply(); 
05444:  RCALL  5124
05446:  MOVFF  02,8EC
0544A:  MOVFF  01,8EB
....................    RTC_read(); 
0544E:  CALL   336C
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
05452:  MOVLW  02
05454:  MOVWF  1E
05456:  MOVLW  99
05458:  MOVWF  1D
0545A:  MOVFF  72A,8ED
0545E:  MOVLW  01
05460:  MOVLB  8
05462:  MOVWF  xEE
05464:  MOVLB  0
05466:  RCALL  52A8
05468:  MOVLW  2F
0546A:  MOVLB  8
0546C:  MOVWF  xFF
0546E:  MOVLB  0
05470:  RCALL  50C6
05472:  MOVFF  729,8ED
05476:  MOVLW  01
05478:  MOVLB  8
0547A:  MOVWF  xEE
0547C:  MOVLB  0
0547E:  RCALL  52A8
05480:  MOVLW  2F
05482:  MOVLB  8
05484:  MOVWF  xFF
05486:  MOVLB  0
05488:  RCALL  50C6
0548A:  MOVFF  72B,8ED
0548E:  MOVLW  01
05490:  MOVLB  8
05492:  MOVWF  xEE
05494:  MOVLB  0
05496:  RCALL  52A8
05498:  MOVLW  20
0549A:  MOVLB  8
0549C:  MOVWF  xFF
0549E:  MOVLB  0
054A0:  RCALL  50C6
054A2:  MOVFF  727,8ED
054A6:  MOVLW  01
054A8:  MOVLB  8
054AA:  MOVWF  xEE
054AC:  MOVLB  0
054AE:  RCALL  52A8
054B0:  MOVLW  3A
054B2:  MOVLB  8
054B4:  MOVWF  xFF
054B6:  MOVLB  0
054B8:  RCALL  50C6
054BA:  MOVFF  726,8ED
054BE:  MOVLW  01
054C0:  MOVLB  8
054C2:  MOVWF  xEE
054C4:  MOVLB  0
054C6:  RCALL  52A8
054C8:  MOVLW  3A
054CA:  MOVLB  8
054CC:  MOVWF  xFF
054CE:  MOVLB  0
054D0:  RCALL  50C6
054D2:  MOVFF  725,8ED
054D6:  MOVLW  01
054D8:  MOVLB  8
054DA:  MOVWF  xEE
054DC:  MOVLB  0
054DE:  RCALL  52A8
054E0:  MOVLW  2C
054E2:  MOVLB  8
054E4:  MOVWF  xFF
054E6:  MOVLB  0
054E8:  RCALL  50C6
054EA:  MOVLW  44
054EC:  MOVWF  FE9
054EE:  MOVLB  8
054F0:  CLRF   xF0
054F2:  CLRF   xEF
054F4:  MOVFF  8EC,8EE
054F8:  MOVFF  8EB,8ED
054FC:  MOVLW  02
054FE:  MOVWF  xF1
05500:  MOVLB  0
05502:  RCALL  5342
05504:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
08502:  MOVLB  2
08504:  MOVF   xDC,F
08506:  BNZ   8582
....................    { 
....................       strcopy(event_buffer,""); 
08508:  MOVLW  01
0850A:  MOVWF  FEA
0850C:  MOVLW  07
0850E:  MOVWF  FE9
08510:  MOVLW  00
08512:  MOVLB  0
08514:  CALL   02CE
08518:  TBLRD*-
0851A:  TBLRD*+
0851C:  MOVF   FF5,W
0851E:  MOVWF  FEE
08520:  IORLW  00
08522:  BNZ   851A
....................       time_stamp(); 
08524:  CALL   5442
....................       strcat(event_buffer, time_stmp_str); 
08528:  MOVLW  01
0852A:  MOVLB  8
0852C:  MOVWF  xF9
0852E:  MOVLW  07
08530:  MOVWF  xF8
08532:  MOVLW  02
08534:  MOVWF  xFB
08536:  MOVLW  99
08538:  MOVWF  xFA
0853A:  MOVLB  0
0853C:  CALL   5506
....................       strcat(event_buffer, event_str); 
08540:  MOVLW  01
08542:  MOVLB  8
08544:  MOVWF  xF9
08546:  MOVLW  07
08548:  MOVWF  xF8
0854A:  MOVLW  01
0854C:  MOVWF  xFB
0854E:  MOVLW  A7
08550:  MOVWF  xFA
08552:  MOVLB  0
08554:  CALL   5506
....................       buffer_select = 1; 
08558:  MOVLW  01
0855A:  MOVWF  x66
....................     
....................       heartbeat(FALSE); 
0855C:  MOVLB  8
0855E:  CLRF   xED
08560:  MOVLB  0
08562:  CALL   55AE
....................          append_data(file_ptr_events); 
08566:  MOVLW  03
08568:  MOVLB  8
0856A:  MOVWF  xEE
0856C:  MOVLW  15
0856E:  MOVWF  xED
08570:  MOVLB  0
08572:  RCALL  8320
....................       heartbeat(TRUE); 
08574:  MOVLW  01
08576:  MOVLB  8
08578:  MOVWF  xED
0857A:  MOVLB  0
0857C:  CALL   55AE
08580:  MOVLB  2
....................    } 
08582:  MOVLB  0
08584:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
028EC:  BCF    F8B.2
028EE:  MOVLW  0C
028F0:  MOVWF  FBB
028F2:  CLRF   FBE
028F4:  CLRF   FBF
028F6:  MOVLW  01
028F8:  MOVWF  F9C
028FA:  MOVLW  F8
028FC:  MOVLB  F
028FE:  ANDWF  x2D,F
02900:  MOVLW  00
02902:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
02904:  BCF    F8B.1
02906:  MOVLW  0C
02908:  MOVWF  x4E
0290A:  CLRF   x51
0290C:  CLRF   x52
0290E:  MOVLW  01
02910:  MOVWF  x1B
02912:  MOVLW  C7
02914:  ANDWF  x2D,F
02916:  MOVLW  00
02918:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
0291A:  IORLW  05
0291C:  MOVWF  FCA
0291E:  MOVLW  7F
02920:  MOVWF  FCB
02922:  MOVLB  0
02924:  GOTO   1B82C (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09D2A:  MOVLW  72
09D2C:  MOVWF  FF6
09D2E:  MOVLW  0F
09D30:  MOVWF  FF7
09D32:  MOVLW  00
09D34:  MOVWF  FF8
09D36:  CLRF   1B
09D38:  BTFSC  FF2.7
09D3A:  BSF    1B.7
09D3C:  BCF    FF2.7
09D3E:  MOVLW  05
09D40:  MOVLB  A
09D42:  MOVWF  x40
09D44:  MOVLB  0
09D46:  CALL   1044
09D4A:  BTFSC  1B.7
09D4C:  BSF    FF2.7
09D4E:  MOVLW  10
09D50:  MOVWF  FE9
09D52:  CLRF   1B
09D54:  BTFSC  FF2.7
09D56:  BSF    1B.7
09D58:  BCF    FF2.7
09D5A:  MOVFF  797,A41
09D5E:  MOVFF  796,A40
09D62:  CALL   11C6
09D66:  BTFSC  1B.7
09D68:  BSF    FF2.7
09D6A:  MOVLW  2C
09D6C:  BTFSS  F9E.4
09D6E:  BRA    9D6C
09D70:  MOVWF  FAD
09D72:  MOVLW  10
09D74:  MOVWF  FE9
09D76:  CLRF   1B
09D78:  BTFSC  FF2.7
09D7A:  BSF    1B.7
09D7C:  BCF    FF2.7
09D7E:  MOVFF  799,A41
09D82:  MOVFF  798,A40
09D86:  CALL   11C6
09D8A:  BTFSC  1B.7
09D8C:  BSF    FF2.7
09D8E:  MOVLW  0D
09D90:  BTFSS  F9E.4
09D92:  BRA    9D90
09D94:  MOVWF  FAD
09D96:  MOVLW  0A
09D98:  BTFSS  F9E.4
09D9A:  BRA    9D98
09D9C:  MOVWF  FAD
09D9E:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02D42:  MOVLW  86
02D44:  MOVLB  8
02D46:  MOVWF  x97
02D48:  MOVLB  0
02D4A:  RCALL  29F2
02D4C:  MOVFF  02,743
02D50:  MOVFF  01,742
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02D54:  MOVLW  8A
02D56:  MOVLB  8
02D58:  MOVWF  x97
02D5A:  MOVLB  0
02D5C:  RCALL  29F2
02D5E:  MOVFF  02,747
02D62:  MOVFF  01,746
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02D66:  MOVLW  8E
02D68:  MOVLB  8
02D6A:  MOVWF  x97
02D6C:  MOVLB  0
02D6E:  RCALL  29F2
02D70:  MOVFF  02,74B
02D74:  MOVFF  01,74A
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02D78:  MOVLW  92
02D7A:  MOVLB  8
02D7C:  MOVWF  x97
02D7E:  MOVLB  0
02D80:  RCALL  29F2
02D82:  MOVFF  02,74F
02D86:  MOVFF  01,74E
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02D8A:  MOVLW  96
02D8C:  MOVLB  8
02D8E:  MOVWF  x97
02D90:  MOVLB  0
02D92:  RCALL  29F2
02D94:  MOVFF  02,753
02D98:  MOVFF  01,752
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02D9C:  MOVLW  9A
02D9E:  MOVLB  8
02DA0:  MOVWF  x97
02DA2:  MOVLB  0
02DA4:  RCALL  29F2
02DA6:  MOVFF  02,757
02DAA:  MOVFF  01,756
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02DAE:  MOVLW  9E
02DB0:  MOVLB  8
02DB2:  MOVWF  x97
02DB4:  MOVLB  0
02DB6:  RCALL  29F2
02DB8:  MOVFF  02,75B
02DBC:  MOVFF  01,75A
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02DC0:  MOVLW  A2
02DC2:  MOVLB  8
02DC4:  MOVWF  x97
02DC6:  MOVLB  0
02DC8:  RCALL  29F2
02DCA:  MOVFF  02,75F
02DCE:  MOVFF  01,75E
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02DD2:  MOVLW  A6
02DD4:  MOVLB  8
02DD6:  MOVWF  x97
02DD8:  MOVLB  0
02DDA:  RCALL  29F2
02DDC:  MOVFF  02,763
02DE0:  MOVFF  01,762
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02DE4:  MOVLW  82
02DE6:  MOVLB  8
02DE8:  MOVWF  x97
02DEA:  MOVLB  0
02DEC:  RCALL  29F2
02DEE:  MOVFF  02,767
02DF2:  MOVFF  01,766
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02DF6:  MOVLW  7E
02DF8:  MOVLB  8
02DFA:  MOVWF  x97
02DFC:  MOVLB  0
02DFE:  RCALL  29F2
02E00:  MOVFF  02,7C0
02E04:  MOVFF  01,7BF
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02E08:  MOVLW  AA
02E0A:  MOVLB  8
02E0C:  MOVWF  x97
02E0E:  MOVLB  0
02E10:  RCALL  29F2
02E12:  MOVFF  02,7C4
02E16:  MOVFF  01,7C3
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02E1A:  MOVLW  7A
02E1C:  MOVLB  8
02E1E:  MOVWF  x97
02E20:  MOVLB  0
02E22:  RCALL  29F2
02E24:  MOVFF  02,76B
02E28:  MOVFF  01,76A
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02E2C:  MOVLW  76
02E2E:  MOVLB  8
02E30:  MOVWF  x97
02E32:  MOVLB  0
02E34:  RCALL  29F2
02E36:  MOVFF  02,76F
02E3A:  MOVFF  01,76E
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02E3E:  MOVLW  72
02E40:  MOVLB  8
02E42:  MOVWF  x97
02E44:  MOVLB  0
02E46:  RCALL  29F2
02E48:  MOVFF  02,773
02E4C:  MOVFF  01,772
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02E50:  MOVLW  6E
02E52:  MOVLB  8
02E54:  MOVWF  x97
02E56:  MOVLB  0
02E58:  RCALL  29F2
02E5A:  MOVFF  02,797
02E5E:  MOVFF  01,796
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02E62:  MOVLW  AE
02E64:  MOVLB  8
02E66:  MOVWF  x97
02E68:  MOVLB  0
02E6A:  RCALL  29F2
02E6C:  MOVFF  02,777
02E70:  MOVFF  01,776
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02E74:  MOVLW  B2
02E76:  MOVLB  8
02E78:  MOVWF  x97
02E7A:  MOVLB  0
02E7C:  RCALL  29F2
02E7E:  MOVFF  02,7B0
02E82:  MOVFF  01,7AF
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02E86:  MOVLW  B6
02E88:  MOVLB  8
02E8A:  MOVWF  x97
02E8C:  MOVLB  0
02E8E:  RCALL  29F2
02E90:  MOVFF  02,7B4
02E94:  MOVFF  01,7B3
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02E98:  MOVLW  BA
02E9A:  MOVLB  8
02E9C:  MOVWF  x97
02E9E:  MOVLB  0
02EA0:  RCALL  29F2
02EA2:  MOVFF  02,77B
02EA6:  MOVFF  01,77A
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02EAA:  MOVLW  BE
02EAC:  MOVLB  8
02EAE:  MOVWF  x97
02EB0:  MOVLB  0
02EB2:  RCALL  29F2
02EB4:  MOVFF  02,77F
02EB8:  MOVFF  01,77E
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02EBC:  MOVLW  C2
02EBE:  MOVLB  8
02EC0:  MOVWF  x97
02EC2:  MOVLB  0
02EC4:  RCALL  29F2
02EC6:  MOVFF  02,783
02ECA:  MOVFF  01,782
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02ECE:  MOVLW  88
02ED0:  MOVLB  8
02ED2:  MOVWF  x97
02ED4:  MOVLB  0
02ED6:  RCALL  29F2
02ED8:  MOVFF  02,745
02EDC:  MOVFF  01,744
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02EE0:  MOVLW  8C
02EE2:  MOVLB  8
02EE4:  MOVWF  x97
02EE6:  MOVLB  0
02EE8:  RCALL  29F2
02EEA:  MOVFF  02,749
02EEE:  MOVFF  01,748
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02EF2:  MOVLW  90
02EF4:  MOVLB  8
02EF6:  MOVWF  x97
02EF8:  MOVLB  0
02EFA:  RCALL  29F2
02EFC:  MOVFF  02,74D
02F00:  MOVFF  01,74C
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02F04:  MOVLW  94
02F06:  MOVLB  8
02F08:  MOVWF  x97
02F0A:  MOVLB  0
02F0C:  RCALL  29F2
02F0E:  MOVFF  02,751
02F12:  MOVFF  01,750
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02F16:  MOVLW  98
02F18:  MOVLB  8
02F1A:  MOVWF  x97
02F1C:  MOVLB  0
02F1E:  RCALL  29F2
02F20:  MOVFF  02,755
02F24:  MOVFF  01,754
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02F28:  MOVLW  9C
02F2A:  MOVLB  8
02F2C:  MOVWF  x97
02F2E:  MOVLB  0
02F30:  RCALL  29F2
02F32:  MOVFF  02,759
02F36:  MOVFF  01,758
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02F3A:  MOVLW  A0
02F3C:  MOVLB  8
02F3E:  MOVWF  x97
02F40:  MOVLB  0
02F42:  RCALL  29F2
02F44:  MOVFF  02,75D
02F48:  MOVFF  01,75C
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02F4C:  MOVLW  A4
02F4E:  MOVLB  8
02F50:  MOVWF  x97
02F52:  MOVLB  0
02F54:  RCALL  29F2
02F56:  MOVFF  02,761
02F5A:  MOVFF  01,760
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02F5E:  MOVLW  A8
02F60:  MOVLB  8
02F62:  MOVWF  x97
02F64:  MOVLB  0
02F66:  RCALL  29F2
02F68:  MOVFF  02,765
02F6C:  MOVFF  01,764
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02F70:  MOVLW  84
02F72:  MOVLB  8
02F74:  MOVWF  x97
02F76:  MOVLB  0
02F78:  RCALL  29F2
02F7A:  MOVFF  02,769
02F7E:  MOVFF  01,768
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02F82:  MOVLW  80
02F84:  MOVLB  8
02F86:  MOVWF  x97
02F88:  MOVLB  0
02F8A:  RCALL  29F2
02F8C:  MOVFF  02,7C2
02F90:  MOVFF  01,7C1
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02F94:  MOVLW  AC
02F96:  MOVLB  8
02F98:  MOVWF  x97
02F9A:  MOVLB  0
02F9C:  RCALL  29F2
02F9E:  MOVFF  02,7C6
02FA2:  MOVFF  01,7C5
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02FA6:  MOVLW  7C
02FA8:  MOVLB  8
02FAA:  MOVWF  x97
02FAC:  MOVLB  0
02FAE:  RCALL  29F2
02FB0:  MOVFF  02,76D
02FB4:  MOVFF  01,76C
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02FB8:  MOVLW  78
02FBA:  MOVLB  8
02FBC:  MOVWF  x97
02FBE:  MOVLB  0
02FC0:  RCALL  29F2
02FC2:  MOVFF  02,771
02FC6:  MOVFF  01,770
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02FCA:  MOVLW  74
02FCC:  MOVLB  8
02FCE:  MOVWF  x97
02FD0:  MOVLB  0
02FD2:  RCALL  29F2
02FD4:  MOVFF  02,775
02FD8:  MOVFF  01,774
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02FDC:  MOVLW  70
02FDE:  MOVLB  8
02FE0:  MOVWF  x97
02FE2:  MOVLB  0
02FE4:  RCALL  29F2
02FE6:  MOVFF  02,799
02FEA:  MOVFF  01,798
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02FEE:  MOVLW  B0
02FF0:  MOVLB  8
02FF2:  MOVWF  x97
02FF4:  MOVLB  0
02FF6:  RCALL  29F2
02FF8:  MOVFF  02,779
02FFC:  MOVFF  01,778
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
03000:  MOVLW  B4
03002:  MOVLB  8
03004:  MOVWF  x97
03006:  MOVLB  0
03008:  RCALL  29F2
0300A:  MOVFF  02,7B2
0300E:  MOVFF  01,7B1
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
03012:  MOVLW  B8
03014:  MOVLB  8
03016:  MOVWF  x97
03018:  MOVLB  0
0301A:  RCALL  29F2
0301C:  MOVFF  02,7B6
03020:  MOVFF  01,7B5
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
03024:  MOVLW  BC
03026:  MOVLB  8
03028:  MOVWF  x97
0302A:  MOVLB  0
0302C:  RCALL  29F2
0302E:  MOVFF  02,77D
03032:  MOVFF  01,77C
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
03036:  MOVLW  C0
03038:  MOVLB  8
0303A:  MOVWF  x97
0303C:  MOVLB  0
0303E:  RCALL  29F2
03040:  MOVFF  02,781
03044:  MOVFF  01,780
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
03048:  MOVLW  C4
0304A:  MOVLB  8
0304C:  MOVWF  x97
0304E:  MOVLB  0
03050:  RCALL  29F2
03052:  MOVFF  02,785
03056:  MOVFF  01,784
....................     
....................    motor=0; 
0305A:  MOVLB  7
0305C:  CLRF   x40
....................    m_fixed=1; 
0305E:  MOVLW  01
03060:  MOVWF  x41
....................    m_step_cnt[0]=0; 
03062:  CLRF   xA5
03064:  CLRF   xA4
03066:  CLRF   xA3
03068:  CLRF   xA2
....................    m_step_cnt[1]=0; 
0306A:  CLRF   xA9
0306C:  CLRF   xA8
0306E:  CLRF   xA7
03070:  CLRF   xA6
....................    e_cha_cnt[0]=0; 
03072:  CLRF   xBC
03074:  CLRF   xBB
....................    e_cha_cnt[1]=0;  
03076:  CLRF   xBE
03078:  CLRF   xBD
....................    m_gb_cnt[0]=0; 
0307A:  CLRF   x9B
0307C:  CLRF   x9A
....................    m_gb_cnt[1]=0; 
0307E:  CLRF   x9D
03080:  CLRF   x9C
....................    e_mode_rst[0]=0; 
03082:  CLRF   x9F
03084:  CLRF   x9E
....................    e_mode_rst[1]=0;    
03086:  CLRF   xA1
03088:  CLRF   xA0
....................    e_port_dist[0]=0; 
0308A:  CLRF   xB8
0308C:  CLRF   xB7
....................    e_port_dist[1]=0; 
0308E:  CLRF   xBA
03090:  CLRF   xB9
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
03092:  MOVFF  777,8DC
03096:  MOVFF  776,8DB
0309A:  MOVFF  763,8DE
0309E:  MOVFF  762,8DD
030A2:  MOVLB  0
030A4:  RCALL  2CFC
030A6:  BCF    FD8.0
030A8:  MOVLB  8
030AA:  RLCF   01,W
030AC:  MOVLB  7
030AE:  MOVWF  xAB
030B0:  MOVLB  8
030B2:  RLCF   02,W
030B4:  MOVLB  7
030B6:  MOVWF  xAC
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
030B8:  MOVFF  779,8DC
030BC:  MOVFF  778,8DB
030C0:  MOVFF  765,8DE
030C4:  MOVFF  764,8DD
030C8:  MOVLB  0
030CA:  RCALL  2CFC
030CC:  BCF    FD8.0
030CE:  MOVLB  8
030D0:  RLCF   01,W
030D2:  MOVLB  7
030D4:  MOVWF  xAD
030D6:  MOVLB  8
030D8:  RLCF   02,W
030DA:  MOVLB  7
030DC:  MOVWF  xAE
030DE:  MOVLB  0
030E0:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
1A1BA:  MOVLW  86
1A1BC:  MOVLB  8
1A1BE:  MOVWF  xEE
1A1C0:  CLRF   xF0
1A1C2:  MOVLW  01
1A1C4:  MOVWF  xEF
1A1C6:  MOVLB  0
1A1C8:  CALL   4FFC
....................    write16(ADDR_M1_MODE,FULL); 
1A1CC:  MOVLW  8A
1A1CE:  MOVLB  8
1A1D0:  MOVWF  xEE
1A1D2:  CLRF   xF0
1A1D4:  CLRF   xEF
1A1D6:  MOVLB  0
1A1D8:  CALL   4FFC
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A1DC:  MOVLW  8E
1A1DE:  MOVLB  8
1A1E0:  MOVWF  xEE
1A1E2:  CLRF   xF0
1A1E4:  MOVLW  0A
1A1E6:  MOVWF  xEF
1A1E8:  MOVLB  0
1A1EA:  CALL   4FFC
....................    write16(ADDR_M1_POS_DIR,0); 
1A1EE:  MOVLW  92
1A1F0:  MOVLB  8
1A1F2:  MOVWF  xEE
1A1F4:  CLRF   xF0
1A1F6:  CLRF   xEF
1A1F8:  MOVLB  0
1A1FA:  CALL   4FFC
....................    write16(ADDR_M1_PWM_HLD,0); 
1A1FE:  MOVLW  96
1A200:  MOVLB  8
1A202:  MOVWF  xEE
1A204:  CLRF   xF0
1A206:  CLRF   xEF
1A208:  MOVLB  0
1A20A:  CALL   4FFC
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A20E:  MOVLW  9A
1A210:  MOVLB  8
1A212:  MOVWF  xEE
1A214:  CLRF   xF0
1A216:  MOVLW  7F
1A218:  MOVWF  xEF
1A21A:  MOVLB  0
1A21C:  CALL   4FFC
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A220:  MOVLW  9E
1A222:  MOVLB  8
1A224:  MOVWF  xEE
1A226:  MOVLW  17
1A228:  MOVWF  xF0
1A22A:  MOVLW  70
1A22C:  MOVWF  xEF
1A22E:  MOVLB  0
1A230:  CALL   4FFC
....................    write16(ADDR_E1_CPR,16); 
1A234:  MOVLW  A2
1A236:  MOVLB  8
1A238:  MOVWF  xEE
1A23A:  CLRF   xF0
1A23C:  MOVLW  10
1A23E:  MOVWF  xEF
1A240:  MOVLB  0
1A242:  CALL   4FFC
....................    write16(ADDR_E1_PPR,16); 
1A246:  MOVLW  A6
1A248:  MOVLB  8
1A24A:  MOVWF  xEE
1A24C:  CLRF   xF0
1A24E:  MOVLW  10
1A250:  MOVWF  xEF
1A252:  MOVLB  0
1A254:  CALL   4FFC
....................    write16(ADDR_E1_MODE,2); 
1A258:  MOVLW  82
1A25A:  MOVLB  8
1A25C:  MOVWF  xEE
1A25E:  CLRF   xF0
1A260:  MOVLW  02
1A262:  MOVWF  xEF
1A264:  MOVLB  0
1A266:  CALL   4FFC
....................    write16(ADDR_E1_POS,0); 
1A26A:  MOVLW  7E
1A26C:  MOVLB  8
1A26E:  MOVWF  xEE
1A270:  CLRF   xF0
1A272:  CLRF   xEF
1A274:  MOVLB  0
1A276:  CALL   4FFC
....................    write16(ADDR_E1_PORT,0); 
1A27A:  MOVLW  AA
1A27C:  MOVLB  8
1A27E:  MOVWF  xEE
1A280:  CLRF   xF0
1A282:  CLRF   xEF
1A284:  MOVLB  0
1A286:  CALL   4FFC
....................    write16(ADDR_E1_TYPE,2); 
1A28A:  MOVLW  7A
1A28C:  MOVLB  8
1A28E:  MOVWF  xEE
1A290:  CLRF   xF0
1A292:  MOVLW  02
1A294:  MOVWF  xEF
1A296:  MOVLB  0
1A298:  CALL   4FFC
....................    write16(ADDR_M1_RUN,270); 
1A29C:  MOVLW  76
1A29E:  MOVLB  8
1A2A0:  MOVWF  xEE
1A2A2:  MOVLW  01
1A2A4:  MOVWF  xF0
1A2A6:  MOVLW  0E
1A2A8:  MOVWF  xEF
1A2AA:  MOVLB  0
1A2AC:  CALL   4FFC
....................    write16(ADDR_M1_BKLSH,0); 
1A2B0:  MOVLW  72
1A2B2:  MOVLB  8
1A2B4:  MOVWF  xEE
1A2B6:  CLRF   xF0
1A2B8:  CLRF   xEF
1A2BA:  MOVLB  0
1A2BC:  CALL   4FFC
....................    write16(ADDR_M1_ERROR,0);   
1A2C0:  MOVLW  6E
1A2C2:  MOVLB  8
1A2C4:  MOVWF  xEE
1A2C6:  CLRF   xF0
1A2C8:  CLRF   xEF
1A2CA:  MOVLB  0
1A2CC:  CALL   4FFC
....................    write16(ADDR_M1_SPR,38400); 
1A2D0:  MOVLW  AE
1A2D2:  MOVLB  8
1A2D4:  MOVWF  xEE
1A2D6:  MOVLW  96
1A2D8:  MOVWF  xF0
1A2DA:  CLRF   xEF
1A2DC:  MOVLB  0
1A2DE:  CALL   4FFC
....................    write16(ADDR_M1_COMP,0); 
1A2E2:  MOVLW  B2
1A2E4:  MOVLB  8
1A2E6:  MOVWF  xEE
1A2E8:  CLRF   xF0
1A2EA:  CLRF   xEF
1A2EC:  MOVLB  0
1A2EE:  CALL   4FFC
....................    write16(ADDR_M1_LIN_POS,0); 
1A2F2:  MOVLW  B6
1A2F4:  MOVLB  8
1A2F6:  MOVWF  xEE
1A2F8:  CLRF   xF0
1A2FA:  CLRF   xEF
1A2FC:  MOVLB  0
1A2FE:  CALL   4FFC
....................    write16(ADDR_E1_INDEX,1); 
1A302:  MOVLW  BA
1A304:  MOVLB  8
1A306:  MOVWF  xEE
1A308:  CLRF   xF0
1A30A:  MOVLW  01
1A30C:  MOVWF  xEF
1A30E:  MOVLB  0
1A310:  CALL   4FFC
....................    write16(ADDR_M1_EVN_SO,0); 
1A314:  MOVLW  BE
1A316:  MOVLB  8
1A318:  MOVWF  xEE
1A31A:  CLRF   xF0
1A31C:  CLRF   xEF
1A31E:  MOVLB  0
1A320:  CALL   4FFC
....................    write16(ADDR_M1_ALIGN_OS,0); 
1A324:  MOVLW  C2
1A326:  MOVLB  8
1A328:  MOVWF  xEE
1A32A:  CLRF   xF0
1A32C:  CLRF   xEF
1A32E:  MOVLB  0
1A330:  CALL   4FFC
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A334:  MOVLW  88
1A336:  MOVLB  8
1A338:  MOVWF  xEE
1A33A:  CLRF   xF0
1A33C:  MOVLW  01
1A33E:  MOVWF  xEF
1A340:  MOVLB  0
1A342:  CALL   4FFC
....................    write16(ADDR_M2_MODE,HALF); 
1A346:  MOVLW  8C
1A348:  MOVLB  8
1A34A:  MOVWF  xEE
1A34C:  CLRF   xF0
1A34E:  MOVLW  01
1A350:  MOVWF  xEF
1A352:  MOVLB  0
1A354:  CALL   4FFC
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
1A358:  MOVLW  90
1A35A:  MOVLB  8
1A35C:  MOVWF  xEE
1A35E:  CLRF   xF0
1A360:  MOVLW  05
1A362:  MOVWF  xEF
1A364:  MOVLB  0
1A366:  CALL   4FFC
....................    write16(ADDR_M2_POS_DIR,0); 
1A36A:  MOVLW  94
1A36C:  MOVLB  8
1A36E:  MOVWF  xEE
1A370:  CLRF   xF0
1A372:  CLRF   xEF
1A374:  MOVLB  0
1A376:  CALL   4FFC
....................    write16(ADDR_M2_PWM_HLD,0); 
1A37A:  MOVLW  98
1A37C:  MOVLB  8
1A37E:  MOVWF  xEE
1A380:  CLRF   xF0
1A382:  CLRF   xEF
1A384:  MOVLB  0
1A386:  CALL   4FFC
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A38A:  MOVLW  9C
1A38C:  MOVLB  8
1A38E:  MOVWF  xEE
1A390:  CLRF   xF0
1A392:  MOVLW  7F
1A394:  MOVWF  xEF
1A396:  MOVLB  0
1A398:  CALL   4FFC
....................    write16(ADDR_M2_GB_ERR,0); 
1A39C:  MOVLW  A0
1A39E:  MOVLB  8
1A3A0:  MOVWF  xEE
1A3A2:  CLRF   xF0
1A3A4:  CLRF   xEF
1A3A6:  MOVLB  0
1A3A8:  CALL   4FFC
....................    write16(ADDR_E2_CPR,0); 
1A3AC:  MOVLW  A4
1A3AE:  MOVLB  8
1A3B0:  MOVWF  xEE
1A3B2:  CLRF   xF0
1A3B4:  CLRF   xEF
1A3B6:  MOVLB  0
1A3B8:  CALL   4FFC
....................    write16(ADDR_E2_PPR,0);   
1A3BC:  MOVLW  A8
1A3BE:  MOVLB  8
1A3C0:  MOVWF  xEE
1A3C2:  CLRF   xF0
1A3C4:  CLRF   xEF
1A3C6:  MOVLB  0
1A3C8:  CALL   4FFC
....................    write16(ADDR_E2_MODE,0); 
1A3CC:  MOVLW  84
1A3CE:  MOVLB  8
1A3D0:  MOVWF  xEE
1A3D2:  CLRF   xF0
1A3D4:  CLRF   xEF
1A3D6:  MOVLB  0
1A3D8:  CALL   4FFC
....................    write16(ADDR_E2_POS,0); 
1A3DC:  MOVLW  80
1A3DE:  MOVLB  8
1A3E0:  MOVWF  xEE
1A3E2:  CLRF   xF0
1A3E4:  CLRF   xEF
1A3E6:  MOVLB  0
1A3E8:  CALL   4FFC
....................    write16(ADDR_E2_PORT,0); 
1A3EC:  MOVLW  AC
1A3EE:  MOVLB  8
1A3F0:  MOVWF  xEE
1A3F2:  CLRF   xF0
1A3F4:  CLRF   xEF
1A3F6:  MOVLB  0
1A3F8:  CALL   4FFC
....................    write16(ADDR_E2_TYPE,0); 
1A3FC:  MOVLW  7C
1A3FE:  MOVLB  8
1A400:  MOVWF  xEE
1A402:  CLRF   xF0
1A404:  CLRF   xEF
1A406:  MOVLB  0
1A408:  CALL   4FFC
....................    write16(ADDR_M2_RUN,0); 
1A40C:  MOVLW  78
1A40E:  MOVLB  8
1A410:  MOVWF  xEE
1A412:  CLRF   xF0
1A414:  CLRF   xEF
1A416:  MOVLB  0
1A418:  CALL   4FFC
....................    write16(ADDR_M2_BKLSH,0); 
1A41C:  MOVLW  74
1A41E:  MOVLB  8
1A420:  MOVWF  xEE
1A422:  CLRF   xF0
1A424:  CLRF   xEF
1A426:  MOVLB  0
1A428:  CALL   4FFC
....................    write16(ADDR_M2_ERROR,0);   
1A42C:  MOVLW  70
1A42E:  MOVLB  8
1A430:  MOVWF  xEE
1A432:  CLRF   xF0
1A434:  CLRF   xEF
1A436:  MOVLB  0
1A438:  CALL   4FFC
....................    write16(ADDR_M2_SPR,0); 
1A43C:  MOVLW  B0
1A43E:  MOVLB  8
1A440:  MOVWF  xEE
1A442:  CLRF   xF0
1A444:  CLRF   xEF
1A446:  MOVLB  0
1A448:  CALL   4FFC
....................    write16(ADDR_M2_COMP,0); 
1A44C:  MOVLW  B4
1A44E:  MOVLB  8
1A450:  MOVWF  xEE
1A452:  CLRF   xF0
1A454:  CLRF   xEF
1A456:  MOVLB  0
1A458:  CALL   4FFC
....................    write16(ADDR_M2_LIN_POS,0);    
1A45C:  MOVLW  B8
1A45E:  MOVLB  8
1A460:  MOVWF  xEE
1A462:  CLRF   xF0
1A464:  CLRF   xEF
1A466:  MOVLB  0
1A468:  CALL   4FFC
....................    write16(ADDR_E2_INDEX,0); 
1A46C:  MOVLW  BC
1A46E:  MOVLB  8
1A470:  MOVWF  xEE
1A472:  CLRF   xF0
1A474:  CLRF   xEF
1A476:  MOVLB  0
1A478:  CALL   4FFC
....................    write16(ADDR_M2_EVN_SO,0); 
1A47C:  MOVLW  C0
1A47E:  MOVLB  8
1A480:  MOVWF  xEE
1A482:  CLRF   xF0
1A484:  CLRF   xEF
1A486:  MOVLB  0
1A488:  CALL   4FFC
....................    write16(ADDR_M2_ALIGN_OS,0); 
1A48C:  MOVLW  C4
1A48E:  MOVLB  8
1A490:  MOVWF  xEE
1A492:  CLRF   xF0
1A494:  CLRF   xEF
1A496:  MOVLB  0
1A498:  CALL   4FFC
....................     
....................    get_step_vars(); 
1A49C:  CALL   2D42
1A4A0:  GOTO   1ACEA (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A4A4:  MOVLW  86
1A4A6:  MOVLB  8
1A4A8:  MOVWF  xEE
1A4AA:  CLRF   xF0
1A4AC:  MOVLW  01
1A4AE:  MOVWF  xEF
1A4B0:  MOVLB  0
1A4B2:  CALL   4FFC
....................    write16(ADDR_M1_MODE,FULL); 
1A4B6:  MOVLW  8A
1A4B8:  MOVLB  8
1A4BA:  MOVWF  xEE
1A4BC:  CLRF   xF0
1A4BE:  CLRF   xEF
1A4C0:  MOVLB  0
1A4C2:  CALL   4FFC
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
1A4C6:  MOVLW  8E
1A4C8:  MOVLB  8
1A4CA:  MOVWF  xEE
1A4CC:  CLRF   xF0
1A4CE:  MOVLW  14
1A4D0:  MOVWF  xEF
1A4D2:  MOVLB  0
1A4D4:  CALL   4FFC
....................    write16(ADDR_M1_POS_DIR,1); 
1A4D8:  MOVLW  92
1A4DA:  MOVLB  8
1A4DC:  MOVWF  xEE
1A4DE:  CLRF   xF0
1A4E0:  MOVLW  01
1A4E2:  MOVWF  xEF
1A4E4:  MOVLB  0
1A4E6:  CALL   4FFC
....................    write16(ADDR_M1_PWM_HLD,51); 
1A4EA:  MOVLW  96
1A4EC:  MOVLB  8
1A4EE:  MOVWF  xEE
1A4F0:  CLRF   xF0
1A4F2:  MOVLW  33
1A4F4:  MOVWF  xEF
1A4F6:  MOVLB  0
1A4F8:  CALL   4FFC
....................    write16(ADDR_M1_PWM_DRV,511); 
1A4FC:  MOVLW  9A
1A4FE:  MOVLB  8
1A500:  MOVWF  xEE
1A502:  MOVLW  01
1A504:  MOVWF  xF0
1A506:  SETF   xEF
1A508:  MOVLB  0
1A50A:  CALL   4FFC
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
1A50E:  MOVLW  9E
1A510:  MOVLB  8
1A512:  MOVWF  xEE
1A514:  MOVLW  02
1A516:  MOVWF  xF0
1A518:  MOVLW  9E
1A51A:  MOVWF  xEF
1A51C:  MOVLB  0
1A51E:  CALL   4FFC
....................    write16(ADDR_E1_CPR,24); 
1A522:  MOVLW  A2
1A524:  MOVLB  8
1A526:  MOVWF  xEE
1A528:  CLRF   xF0
1A52A:  MOVLW  18
1A52C:  MOVWF  xEF
1A52E:  MOVLB  0
1A530:  CALL   4FFC
....................    write16(ADDR_E1_PPR,48); 
1A534:  MOVLW  A6
1A536:  MOVLB  8
1A538:  MOVWF  xEE
1A53A:  CLRF   xF0
1A53C:  MOVLW  30
1A53E:  MOVWF  xEF
1A540:  MOVLB  0
1A542:  CALL   4FFC
....................    write16(ADDR_E1_MODE,2); 
1A546:  MOVLW  82
1A548:  MOVLB  8
1A54A:  MOVWF  xEE
1A54C:  CLRF   xF0
1A54E:  MOVLW  02
1A550:  MOVWF  xEF
1A552:  MOVLB  0
1A554:  CALL   4FFC
....................    write16(ADDR_E1_POS,0); 
1A558:  MOVLW  7E
1A55A:  MOVLB  8
1A55C:  MOVWF  xEE
1A55E:  CLRF   xF0
1A560:  CLRF   xEF
1A562:  MOVLB  0
1A564:  CALL   4FFC
....................    write16(ADDR_E1_PORT,0); 
1A568:  MOVLW  AA
1A56A:  MOVLB  8
1A56C:  MOVWF  xEE
1A56E:  CLRF   xF0
1A570:  CLRF   xEF
1A572:  MOVLB  0
1A574:  CALL   4FFC
....................    write16(ADDR_E1_TYPE,2); 
1A578:  MOVLW  7A
1A57A:  MOVLB  8
1A57C:  MOVWF  xEE
1A57E:  CLRF   xF0
1A580:  MOVLW  02
1A582:  MOVWF  xEF
1A584:  MOVLB  0
1A586:  CALL   4FFC
....................    write16(ADDR_M1_RUN,34); 
1A58A:  MOVLW  76
1A58C:  MOVLB  8
1A58E:  MOVWF  xEE
1A590:  CLRF   xF0
1A592:  MOVLW  22
1A594:  MOVWF  xEF
1A596:  MOVLB  0
1A598:  CALL   4FFC
....................    write16(ADDR_M1_BKLSH,0); 
1A59C:  MOVLW  72
1A59E:  MOVLB  8
1A5A0:  MOVWF  xEE
1A5A2:  CLRF   xF0
1A5A4:  CLRF   xEF
1A5A6:  MOVLB  0
1A5A8:  CALL   4FFC
....................    write16(ADDR_M1_ERROR,0);   
1A5AC:  MOVLW  6E
1A5AE:  MOVLB  8
1A5B0:  MOVWF  xEE
1A5B2:  CLRF   xF0
1A5B4:  CLRF   xEF
1A5B6:  MOVLB  0
1A5B8:  CALL   4FFC
....................    write16(ADDR_M1_SPR,6400); 
1A5BC:  MOVLW  AE
1A5BE:  MOVLB  8
1A5C0:  MOVWF  xEE
1A5C2:  MOVLW  19
1A5C4:  MOVWF  xF0
1A5C6:  CLRF   xEF
1A5C8:  MOVLB  0
1A5CA:  CALL   4FFC
....................    write16(ADDR_M1_COMP,0); 
1A5CE:  MOVLW  B2
1A5D0:  MOVLB  8
1A5D2:  MOVWF  xEE
1A5D4:  CLRF   xF0
1A5D6:  CLRF   xEF
1A5D8:  MOVLB  0
1A5DA:  CALL   4FFC
....................    write16(ADDR_M1_LIN_POS,0); 
1A5DE:  MOVLW  B6
1A5E0:  MOVLB  8
1A5E2:  MOVWF  xEE
1A5E4:  CLRF   xF0
1A5E6:  CLRF   xEF
1A5E8:  MOVLB  0
1A5EA:  CALL   4FFC
....................    write16(ADDR_E1_INDEX,1);    
1A5EE:  MOVLW  BA
1A5F0:  MOVLB  8
1A5F2:  MOVWF  xEE
1A5F4:  CLRF   xF0
1A5F6:  MOVLW  01
1A5F8:  MOVWF  xEF
1A5FA:  MOVLB  0
1A5FC:  CALL   4FFC
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A600:  MOVLW  88
1A602:  MOVLB  8
1A604:  MOVWF  xEE
1A606:  CLRF   xF0
1A608:  MOVLW  01
1A60A:  MOVWF  xEF
1A60C:  MOVLB  0
1A60E:  CALL   4FFC
....................    write16(ADDR_M2_MODE,HALF); 
1A612:  MOVLW  8C
1A614:  MOVLB  8
1A616:  MOVWF  xEE
1A618:  CLRF   xF0
1A61A:  MOVLW  01
1A61C:  MOVWF  xEF
1A61E:  MOVLB  0
1A620:  CALL   4FFC
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A624:  MOVLW  90
1A626:  MOVLB  8
1A628:  MOVWF  xEE
1A62A:  CLRF   xF0
1A62C:  MOVLW  28
1A62E:  MOVWF  xEF
1A630:  MOVLB  0
1A632:  CALL   4FFC
....................    write16(ADDR_M2_POS_DIR,0); 
1A636:  MOVLW  94
1A638:  MOVLB  8
1A63A:  MOVWF  xEE
1A63C:  CLRF   xF0
1A63E:  CLRF   xEF
1A640:  MOVLB  0
1A642:  CALL   4FFC
....................    write16(ADDR_M2_PWM_HLD,0); 
1A646:  MOVLW  98
1A648:  MOVLB  8
1A64A:  MOVWF  xEE
1A64C:  CLRF   xF0
1A64E:  CLRF   xEF
1A650:  MOVLB  0
1A652:  CALL   4FFC
....................    write16(ADDR_M2_PWM_DRV,511); 
1A656:  MOVLW  9C
1A658:  MOVLB  8
1A65A:  MOVWF  xEE
1A65C:  MOVLW  01
1A65E:  MOVWF  xF0
1A660:  SETF   xEF
1A662:  MOVLB  0
1A664:  CALL   4FFC
....................    write16(ADDR_M2_GB_ERR,0); 
1A668:  MOVLW  A0
1A66A:  MOVLB  8
1A66C:  MOVWF  xEE
1A66E:  CLRF   xF0
1A670:  CLRF   xEF
1A672:  MOVLB  0
1A674:  CALL   4FFC
....................    write16(ADDR_E2_CPR,0); 
1A678:  MOVLW  A4
1A67A:  MOVLB  8
1A67C:  MOVWF  xEE
1A67E:  CLRF   xF0
1A680:  CLRF   xEF
1A682:  MOVLB  0
1A684:  CALL   4FFC
....................    write16(ADDR_E2_PPR,0);   
1A688:  MOVLW  A8
1A68A:  MOVLB  8
1A68C:  MOVWF  xEE
1A68E:  CLRF   xF0
1A690:  CLRF   xEF
1A692:  MOVLB  0
1A694:  CALL   4FFC
....................    write16(ADDR_E2_MODE,0); 
1A698:  MOVLW  84
1A69A:  MOVLB  8
1A69C:  MOVWF  xEE
1A69E:  CLRF   xF0
1A6A0:  CLRF   xEF
1A6A2:  MOVLB  0
1A6A4:  CALL   4FFC
....................    write16(ADDR_E2_POS,0); 
1A6A8:  MOVLW  80
1A6AA:  MOVLB  8
1A6AC:  MOVWF  xEE
1A6AE:  CLRF   xF0
1A6B0:  CLRF   xEF
1A6B2:  MOVLB  0
1A6B4:  CALL   4FFC
....................    write16(ADDR_E2_PORT,0); 
1A6B8:  MOVLW  AC
1A6BA:  MOVLB  8
1A6BC:  MOVWF  xEE
1A6BE:  CLRF   xF0
1A6C0:  CLRF   xEF
1A6C2:  MOVLB  0
1A6C4:  CALL   4FFC
....................    write16(ADDR_E2_TYPE,0); 
1A6C8:  MOVLW  7C
1A6CA:  MOVLB  8
1A6CC:  MOVWF  xEE
1A6CE:  CLRF   xF0
1A6D0:  CLRF   xEF
1A6D2:  MOVLB  0
1A6D4:  CALL   4FFC
....................    write16(ADDR_M2_RUN,0); 
1A6D8:  MOVLW  78
1A6DA:  MOVLB  8
1A6DC:  MOVWF  xEE
1A6DE:  CLRF   xF0
1A6E0:  CLRF   xEF
1A6E2:  MOVLB  0
1A6E4:  CALL   4FFC
....................    write16(ADDR_M2_BKLSH,0); 
1A6E8:  MOVLW  74
1A6EA:  MOVLB  8
1A6EC:  MOVWF  xEE
1A6EE:  CLRF   xF0
1A6F0:  CLRF   xEF
1A6F2:  MOVLB  0
1A6F4:  CALL   4FFC
....................    write16(ADDR_M2_ERROR,0);   
1A6F8:  MOVLW  70
1A6FA:  MOVLB  8
1A6FC:  MOVWF  xEE
1A6FE:  CLRF   xF0
1A700:  CLRF   xEF
1A702:  MOVLB  0
1A704:  CALL   4FFC
....................    write16(ADDR_M2_SPR,0); 
1A708:  MOVLW  B0
1A70A:  MOVLB  8
1A70C:  MOVWF  xEE
1A70E:  CLRF   xF0
1A710:  CLRF   xEF
1A712:  MOVLB  0
1A714:  CALL   4FFC
....................    write16(ADDR_M2_COMP,0); 
1A718:  MOVLW  B4
1A71A:  MOVLB  8
1A71C:  MOVWF  xEE
1A71E:  CLRF   xF0
1A720:  CLRF   xEF
1A722:  MOVLB  0
1A724:  CALL   4FFC
....................    write16(ADDR_M2_LIN_POS,0);   
1A728:  MOVLW  B8
1A72A:  MOVLB  8
1A72C:  MOVWF  xEE
1A72E:  CLRF   xF0
1A730:  CLRF   xEF
1A732:  MOVLB  0
1A734:  CALL   4FFC
....................    write16(ADDR_E2_INDEX,0);    
1A738:  MOVLW  BC
1A73A:  MOVLB  8
1A73C:  MOVWF  xEE
1A73E:  CLRF   xF0
1A740:  CLRF   xEF
1A742:  MOVLB  0
1A744:  CALL   4FFC
....................     
....................    get_step_vars(); 
1A748:  CALL   2D42
1A74C:  GOTO   1ACEA (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A750:  MOVLW  86
1A752:  MOVLB  8
1A754:  MOVWF  xEE
1A756:  CLRF   xF0
1A758:  MOVLW  01
1A75A:  MOVWF  xEF
1A75C:  MOVLB  0
1A75E:  CALL   4FFC
....................    write16(ADDR_M1_MODE,FULL); 
1A762:  MOVLW  8A
1A764:  MOVLB  8
1A766:  MOVWF  xEE
1A768:  CLRF   xF0
1A76A:  CLRF   xEF
1A76C:  MOVLB  0
1A76E:  CALL   4FFC
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A772:  MOVLW  8E
1A774:  MOVLB  8
1A776:  MOVWF  xEE
1A778:  CLRF   xF0
1A77A:  MOVLW  0A
1A77C:  MOVWF  xEF
1A77E:  MOVLB  0
1A780:  CALL   4FFC
....................    write16(ADDR_M1_POS_DIR,0); 
1A784:  MOVLW  92
1A786:  MOVLB  8
1A788:  MOVWF  xEE
1A78A:  CLRF   xF0
1A78C:  CLRF   xEF
1A78E:  MOVLB  0
1A790:  CALL   4FFC
....................    write16(ADDR_M1_PWM_HLD,0); 
1A794:  MOVLW  96
1A796:  MOVLB  8
1A798:  MOVWF  xEE
1A79A:  CLRF   xF0
1A79C:  CLRF   xEF
1A79E:  MOVLB  0
1A7A0:  CALL   4FFC
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A7A4:  MOVLW  9A
1A7A6:  MOVLB  8
1A7A8:  MOVWF  xEE
1A7AA:  CLRF   xF0
1A7AC:  MOVLW  7F
1A7AE:  MOVWF  xEF
1A7B0:  MOVLB  0
1A7B2:  CALL   4FFC
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A7B6:  MOVLW  9E
1A7B8:  MOVLB  8
1A7BA:  MOVWF  xEE
1A7BC:  MOVLW  17
1A7BE:  MOVWF  xF0
1A7C0:  MOVLW  70
1A7C2:  MOVWF  xEF
1A7C4:  MOVLB  0
1A7C6:  CALL   4FFC
....................    write16(ADDR_E1_CPR,16); 
1A7CA:  MOVLW  A2
1A7CC:  MOVLB  8
1A7CE:  MOVWF  xEE
1A7D0:  CLRF   xF0
1A7D2:  MOVLW  10
1A7D4:  MOVWF  xEF
1A7D6:  MOVLB  0
1A7D8:  CALL   4FFC
....................    write16(ADDR_E1_PPR,16); 
1A7DC:  MOVLW  A6
1A7DE:  MOVLB  8
1A7E0:  MOVWF  xEE
1A7E2:  CLRF   xF0
1A7E4:  MOVLW  10
1A7E6:  MOVWF  xEF
1A7E8:  MOVLB  0
1A7EA:  CALL   4FFC
....................    write16(ADDR_E1_MODE,2); 
1A7EE:  MOVLW  82
1A7F0:  MOVLB  8
1A7F2:  MOVWF  xEE
1A7F4:  CLRF   xF0
1A7F6:  MOVLW  02
1A7F8:  MOVWF  xEF
1A7FA:  MOVLB  0
1A7FC:  CALL   4FFC
....................    write16(ADDR_E1_POS,0); 
1A800:  MOVLW  7E
1A802:  MOVLB  8
1A804:  MOVWF  xEE
1A806:  CLRF   xF0
1A808:  CLRF   xEF
1A80A:  MOVLB  0
1A80C:  CALL   4FFC
....................    write16(ADDR_E1_PORT,0); 
1A810:  MOVLW  AA
1A812:  MOVLB  8
1A814:  MOVWF  xEE
1A816:  CLRF   xF0
1A818:  CLRF   xEF
1A81A:  MOVLB  0
1A81C:  CALL   4FFC
....................    write16(ADDR_E1_TYPE,2); 
1A820:  MOVLW  7A
1A822:  MOVLB  8
1A824:  MOVWF  xEE
1A826:  CLRF   xF0
1A828:  MOVLW  02
1A82A:  MOVWF  xEF
1A82C:  MOVLB  0
1A82E:  CALL   4FFC
....................    write16(ADDR_M1_RUN,270); 
1A832:  MOVLW  76
1A834:  MOVLB  8
1A836:  MOVWF  xEE
1A838:  MOVLW  01
1A83A:  MOVWF  xF0
1A83C:  MOVLW  0E
1A83E:  MOVWF  xEF
1A840:  MOVLB  0
1A842:  CALL   4FFC
....................    write16(ADDR_M1_BKLSH,0); 
1A846:  MOVLW  72
1A848:  MOVLB  8
1A84A:  MOVWF  xEE
1A84C:  CLRF   xF0
1A84E:  CLRF   xEF
1A850:  MOVLB  0
1A852:  CALL   4FFC
....................    write16(ADDR_M1_ERROR,0);   
1A856:  MOVLW  6E
1A858:  MOVLB  8
1A85A:  MOVWF  xEE
1A85C:  CLRF   xF0
1A85E:  CLRF   xEF
1A860:  MOVLB  0
1A862:  CALL   4FFC
....................    write16(ADDR_M1_SPR,38400); 
1A866:  MOVLW  AE
1A868:  MOVLB  8
1A86A:  MOVWF  xEE
1A86C:  MOVLW  96
1A86E:  MOVWF  xF0
1A870:  CLRF   xEF
1A872:  MOVLB  0
1A874:  CALL   4FFC
....................    write16(ADDR_M1_COMP,0); 
1A878:  MOVLW  B2
1A87A:  MOVLB  8
1A87C:  MOVWF  xEE
1A87E:  CLRF   xF0
1A880:  CLRF   xEF
1A882:  MOVLB  0
1A884:  CALL   4FFC
....................    write16(ADDR_M1_LIN_POS,0); 
1A888:  MOVLW  B6
1A88A:  MOVLB  8
1A88C:  MOVWF  xEE
1A88E:  CLRF   xF0
1A890:  CLRF   xEF
1A892:  MOVLB  0
1A894:  CALL   4FFC
....................    write16(ADDR_E1_INDEX,1); 
1A898:  MOVLW  BA
1A89A:  MOVLB  8
1A89C:  MOVWF  xEE
1A89E:  CLRF   xF0
1A8A0:  MOVLW  01
1A8A2:  MOVWF  xEF
1A8A4:  MOVLB  0
1A8A6:  CALL   4FFC
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A8AA:  MOVLW  88
1A8AC:  MOVLB  8
1A8AE:  MOVWF  xEE
1A8B0:  CLRF   xF0
1A8B2:  MOVLW  01
1A8B4:  MOVWF  xEF
1A8B6:  MOVLB  0
1A8B8:  CALL   4FFC
....................    write16(ADDR_M2_MODE,HALF); 
1A8BC:  MOVLW  8C
1A8BE:  MOVLB  8
1A8C0:  MOVWF  xEE
1A8C2:  CLRF   xF0
1A8C4:  MOVLW  01
1A8C6:  MOVWF  xEF
1A8C8:  MOVLB  0
1A8CA:  CALL   4FFC
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A8CE:  MOVLW  90
1A8D0:  MOVLB  8
1A8D2:  MOVWF  xEE
1A8D4:  CLRF   xF0
1A8D6:  MOVLW  64
1A8D8:  MOVWF  xEF
1A8DA:  MOVLB  0
1A8DC:  CALL   4FFC
....................    write16(ADDR_M2_POS_DIR,0); 
1A8E0:  MOVLW  94
1A8E2:  MOVLB  8
1A8E4:  MOVWF  xEE
1A8E6:  CLRF   xF0
1A8E8:  CLRF   xEF
1A8EA:  MOVLB  0
1A8EC:  CALL   4FFC
....................    write16(ADDR_M2_PWM_HLD,0); 
1A8F0:  MOVLW  98
1A8F2:  MOVLB  8
1A8F4:  MOVWF  xEE
1A8F6:  CLRF   xF0
1A8F8:  CLRF   xEF
1A8FA:  MOVLB  0
1A8FC:  CALL   4FFC
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A900:  MOVLW  9C
1A902:  MOVLB  8
1A904:  MOVWF  xEE
1A906:  CLRF   xF0
1A908:  MOVLW  7F
1A90A:  MOVWF  xEF
1A90C:  MOVLB  0
1A90E:  CALL   4FFC
....................    write16(ADDR_M2_GB_ERR,0); 
1A912:  MOVLW  A0
1A914:  MOVLB  8
1A916:  MOVWF  xEE
1A918:  CLRF   xF0
1A91A:  CLRF   xEF
1A91C:  MOVLB  0
1A91E:  CALL   4FFC
....................    write16(ADDR_E2_CPR,0); 
1A922:  MOVLW  A4
1A924:  MOVLB  8
1A926:  MOVWF  xEE
1A928:  CLRF   xF0
1A92A:  CLRF   xEF
1A92C:  MOVLB  0
1A92E:  CALL   4FFC
....................    write16(ADDR_E2_PPR,0);   
1A932:  MOVLW  A8
1A934:  MOVLB  8
1A936:  MOVWF  xEE
1A938:  CLRF   xF0
1A93A:  CLRF   xEF
1A93C:  MOVLB  0
1A93E:  CALL   4FFC
....................    write16(ADDR_E2_MODE,0); 
1A942:  MOVLW  84
1A944:  MOVLB  8
1A946:  MOVWF  xEE
1A948:  CLRF   xF0
1A94A:  CLRF   xEF
1A94C:  MOVLB  0
1A94E:  CALL   4FFC
....................    write16(ADDR_E2_POS,0); 
1A952:  MOVLW  80
1A954:  MOVLB  8
1A956:  MOVWF  xEE
1A958:  CLRF   xF0
1A95A:  CLRF   xEF
1A95C:  MOVLB  0
1A95E:  CALL   4FFC
....................    write16(ADDR_E2_PORT,0); 
1A962:  MOVLW  AC
1A964:  MOVLB  8
1A966:  MOVWF  xEE
1A968:  CLRF   xF0
1A96A:  CLRF   xEF
1A96C:  MOVLB  0
1A96E:  CALL   4FFC
....................    write16(ADDR_E2_TYPE,0); 
1A972:  MOVLW  7C
1A974:  MOVLB  8
1A976:  MOVWF  xEE
1A978:  CLRF   xF0
1A97A:  CLRF   xEF
1A97C:  MOVLB  0
1A97E:  CALL   4FFC
....................    write16(ADDR_M2_RUN,0); 
1A982:  MOVLW  78
1A984:  MOVLB  8
1A986:  MOVWF  xEE
1A988:  CLRF   xF0
1A98A:  CLRF   xEF
1A98C:  MOVLB  0
1A98E:  CALL   4FFC
....................    write16(ADDR_M2_BKLSH,0); 
1A992:  MOVLW  74
1A994:  MOVLB  8
1A996:  MOVWF  xEE
1A998:  CLRF   xF0
1A99A:  CLRF   xEF
1A99C:  MOVLB  0
1A99E:  CALL   4FFC
....................    write16(ADDR_M2_ERROR,0);   
1A9A2:  MOVLW  70
1A9A4:  MOVLB  8
1A9A6:  MOVWF  xEE
1A9A8:  CLRF   xF0
1A9AA:  CLRF   xEF
1A9AC:  MOVLB  0
1A9AE:  CALL   4FFC
....................    write16(ADDR_M2_SPR,0); 
1A9B2:  MOVLW  B0
1A9B4:  MOVLB  8
1A9B6:  MOVWF  xEE
1A9B8:  CLRF   xF0
1A9BA:  CLRF   xEF
1A9BC:  MOVLB  0
1A9BE:  CALL   4FFC
....................    write16(ADDR_M2_COMP,0); 
1A9C2:  MOVLW  B4
1A9C4:  MOVLB  8
1A9C6:  MOVWF  xEE
1A9C8:  CLRF   xF0
1A9CA:  CLRF   xEF
1A9CC:  MOVLB  0
1A9CE:  CALL   4FFC
....................    write16(ADDR_M2_LIN_POS,0);    
1A9D2:  MOVLW  B8
1A9D4:  MOVLB  8
1A9D6:  MOVWF  xEE
1A9D8:  CLRF   xF0
1A9DA:  CLRF   xEF
1A9DC:  MOVLB  0
1A9DE:  CALL   4FFC
....................     
....................    get_step_vars(); 
1A9E2:  CALL   2D42
1A9E6:  GOTO   1ACEA (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A9EA:  MOVLW  86
1A9EC:  MOVLB  8
1A9EE:  MOVWF  xEE
1A9F0:  CLRF   xF0
1A9F2:  MOVLW  01
1A9F4:  MOVWF  xEF
1A9F6:  MOVLB  0
1A9F8:  CALL   4FFC
....................    write16(ADDR_M1_MODE,FULL); 
1A9FC:  MOVLW  8A
1A9FE:  MOVLB  8
1AA00:  MOVWF  xEE
1AA02:  CLRF   xF0
1AA04:  CLRF   xEF
1AA06:  MOVLB  0
1AA08:  CALL   4FFC
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1AA0C:  MOVLW  8E
1AA0E:  MOVLB  8
1AA10:  MOVWF  xEE
1AA12:  CLRF   xF0
1AA14:  MOVLW  28
1AA16:  MOVWF  xEF
1AA18:  MOVLB  0
1AA1A:  CALL   4FFC
....................    write16(ADDR_M1_POS_DIR,1); 
1AA1E:  MOVLW  92
1AA20:  MOVLB  8
1AA22:  MOVWF  xEE
1AA24:  CLRF   xF0
1AA26:  MOVLW  01
1AA28:  MOVWF  xEF
1AA2A:  MOVLB  0
1AA2C:  CALL   4FFC
....................    write16(ADDR_M1_PWM_HLD,0); 
1AA30:  MOVLW  96
1AA32:  MOVLB  8
1AA34:  MOVWF  xEE
1AA36:  CLRF   xF0
1AA38:  CLRF   xEF
1AA3A:  MOVLB  0
1AA3C:  CALL   4FFC
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1AA40:  MOVLW  9A
1AA42:  MOVLB  8
1AA44:  MOVWF  xEE
1AA46:  CLRF   xF0
1AA48:  MOVLW  7F
1AA4A:  MOVWF  xEF
1AA4C:  MOVLB  0
1AA4E:  CALL   4FFC
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1AA52:  MOVLW  9E
1AA54:  MOVLB  8
1AA56:  MOVWF  xEE
1AA58:  MOVLW  02
1AA5A:  MOVWF  xF0
1AA5C:  MOVLW  9E
1AA5E:  MOVWF  xEF
1AA60:  MOVLB  0
1AA62:  CALL   4FFC
....................    write16(ADDR_E1_CPR,500); 
1AA66:  MOVLW  A2
1AA68:  MOVLB  8
1AA6A:  MOVWF  xEE
1AA6C:  MOVLW  01
1AA6E:  MOVWF  xF0
1AA70:  MOVLW  F4
1AA72:  MOVWF  xEF
1AA74:  MOVLB  0
1AA76:  CALL   4FFC
....................    write16(ADDR_E1_PPR,50); 
1AA7A:  MOVLW  A6
1AA7C:  MOVLB  8
1AA7E:  MOVWF  xEE
1AA80:  CLRF   xF0
1AA82:  MOVLW  32
1AA84:  MOVWF  xEF
1AA86:  MOVLB  0
1AA88:  CALL   4FFC
....................    write16(ADDR_E1_MODE,2); 
1AA8C:  MOVLW  82
1AA8E:  MOVLB  8
1AA90:  MOVWF  xEE
1AA92:  CLRF   xF0
1AA94:  MOVLW  02
1AA96:  MOVWF  xEF
1AA98:  MOVLB  0
1AA9A:  CALL   4FFC
....................    write16(ADDR_E1_POS,0); 
1AA9E:  MOVLW  7E
1AAA0:  MOVLB  8
1AAA2:  MOVWF  xEE
1AAA4:  CLRF   xF0
1AAA6:  CLRF   xEF
1AAA8:  MOVLB  0
1AAAA:  CALL   4FFC
....................    write16(ADDR_E1_PORT,0); 
1AAAE:  MOVLW  AA
1AAB0:  MOVLB  8
1AAB2:  MOVWF  xEE
1AAB4:  CLRF   xF0
1AAB6:  CLRF   xEF
1AAB8:  MOVLB  0
1AABA:  CALL   4FFC
....................    write16(ADDR_E1_TYPE,1); 
1AABE:  MOVLW  7A
1AAC0:  MOVLB  8
1AAC2:  MOVWF  xEE
1AAC4:  CLRF   xF0
1AAC6:  MOVLW  01
1AAC8:  MOVWF  xEF
1AACA:  MOVLB  0
1AACC:  CALL   4FFC
....................    write16(ADDR_M1_RUN,0); 
1AAD0:  MOVLW  76
1AAD2:  MOVLB  8
1AAD4:  MOVWF  xEE
1AAD6:  CLRF   xF0
1AAD8:  CLRF   xEF
1AADA:  MOVLB  0
1AADC:  CALL   4FFC
....................    write16(ADDR_M1_BKLSH,1300); 
1AAE0:  MOVLW  72
1AAE2:  MOVLB  8
1AAE4:  MOVWF  xEE
1AAE6:  MOVLW  05
1AAE8:  MOVWF  xF0
1AAEA:  MOVLW  14
1AAEC:  MOVWF  xEF
1AAEE:  MOVLB  0
1AAF0:  CALL   4FFC
....................    write16(ADDR_M1_ERROR,0);   
1AAF4:  MOVLW  6E
1AAF6:  MOVLB  8
1AAF8:  MOVWF  xEE
1AAFA:  CLRF   xF0
1AAFC:  CLRF   xEF
1AAFE:  MOVLB  0
1AB00:  CALL   4FFC
....................    write16(ADDR_M1_SPR,20000); 
1AB04:  MOVLW  AE
1AB06:  MOVLB  8
1AB08:  MOVWF  xEE
1AB0A:  MOVLW  4E
1AB0C:  MOVWF  xF0
1AB0E:  MOVLW  20
1AB10:  MOVWF  xEF
1AB12:  MOVLB  0
1AB14:  CALL   4FFC
....................    write16(ADDR_M1_COMP,0); 
1AB18:  MOVLW  B2
1AB1A:  MOVLB  8
1AB1C:  MOVWF  xEE
1AB1E:  CLRF   xF0
1AB20:  CLRF   xEF
1AB22:  MOVLB  0
1AB24:  CALL   4FFC
....................    write16(ADDR_M1_LIN_POS,0); 
1AB28:  MOVLW  B6
1AB2A:  MOVLB  8
1AB2C:  MOVWF  xEE
1AB2E:  CLRF   xF0
1AB30:  CLRF   xEF
1AB32:  MOVLB  0
1AB34:  CALL   4FFC
....................    write16(ADDR_E1_INDEX,0); 
1AB38:  MOVLW  BA
1AB3A:  MOVLB  8
1AB3C:  MOVWF  xEE
1AB3E:  CLRF   xF0
1AB40:  CLRF   xEF
1AB42:  MOVLB  0
1AB44:  CALL   4FFC
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1AB48:  MOVLW  88
1AB4A:  MOVLB  8
1AB4C:  MOVWF  xEE
1AB4E:  CLRF   xF0
1AB50:  MOVLW  01
1AB52:  MOVWF  xEF
1AB54:  MOVLB  0
1AB56:  CALL   4FFC
....................    write16(ADDR_M2_MODE,HALF); 
1AB5A:  MOVLW  8C
1AB5C:  MOVLB  8
1AB5E:  MOVWF  xEE
1AB60:  CLRF   xF0
1AB62:  MOVLW  01
1AB64:  MOVWF  xEF
1AB66:  MOVLB  0
1AB68:  CALL   4FFC
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1AB6C:  MOVLW  90
1AB6E:  MOVLB  8
1AB70:  MOVWF  xEE
1AB72:  CLRF   xF0
1AB74:  MOVLW  28
1AB76:  MOVWF  xEF
1AB78:  MOVLB  0
1AB7A:  CALL   4FFC
....................    write16(ADDR_M2_POS_DIR,1); 
1AB7E:  MOVLW  94
1AB80:  MOVLB  8
1AB82:  MOVWF  xEE
1AB84:  CLRF   xF0
1AB86:  MOVLW  01
1AB88:  MOVWF  xEF
1AB8A:  MOVLB  0
1AB8C:  CALL   4FFC
....................    write16(ADDR_M2_PWM_HLD,0); 
1AB90:  MOVLW  98
1AB92:  MOVLB  8
1AB94:  MOVWF  xEE
1AB96:  CLRF   xF0
1AB98:  CLRF   xEF
1AB9A:  MOVLB  0
1AB9C:  CALL   4FFC
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1ABA0:  MOVLW  9C
1ABA2:  MOVLB  8
1ABA4:  MOVWF  xEE
1ABA6:  CLRF   xF0
1ABA8:  MOVLW  7F
1ABAA:  MOVWF  xEF
1ABAC:  MOVLB  0
1ABAE:  CALL   4FFC
....................    write16(ADDR_M2_GB_ERR,0); 
1ABB2:  MOVLW  A0
1ABB4:  MOVLB  8
1ABB6:  MOVWF  xEE
1ABB8:  CLRF   xF0
1ABBA:  CLRF   xEF
1ABBC:  MOVLB  0
1ABBE:  CALL   4FFC
....................    write16(ADDR_E2_CPR,0); 
1ABC2:  MOVLW  A4
1ABC4:  MOVLB  8
1ABC6:  MOVWF  xEE
1ABC8:  CLRF   xF0
1ABCA:  CLRF   xEF
1ABCC:  MOVLB  0
1ABCE:  CALL   4FFC
....................    write16(ADDR_E2_PPR,0);   
1ABD2:  MOVLW  A8
1ABD4:  MOVLB  8
1ABD6:  MOVWF  xEE
1ABD8:  CLRF   xF0
1ABDA:  CLRF   xEF
1ABDC:  MOVLB  0
1ABDE:  CALL   4FFC
....................    write16(ADDR_E2_MODE,0); 
1ABE2:  MOVLW  84
1ABE4:  MOVLB  8
1ABE6:  MOVWF  xEE
1ABE8:  CLRF   xF0
1ABEA:  CLRF   xEF
1ABEC:  MOVLB  0
1ABEE:  CALL   4FFC
....................    write16(ADDR_E2_POS,0); 
1ABF2:  MOVLW  80
1ABF4:  MOVLB  8
1ABF6:  MOVWF  xEE
1ABF8:  CLRF   xF0
1ABFA:  CLRF   xEF
1ABFC:  MOVLB  0
1ABFE:  CALL   4FFC
....................    write16(ADDR_E2_PORT,0); 
1AC02:  MOVLW  AC
1AC04:  MOVLB  8
1AC06:  MOVWF  xEE
1AC08:  CLRF   xF0
1AC0A:  CLRF   xEF
1AC0C:  MOVLB  0
1AC0E:  CALL   4FFC
....................    write16(ADDR_E2_TYPE,0); 
1AC12:  MOVLW  7C
1AC14:  MOVLB  8
1AC16:  MOVWF  xEE
1AC18:  CLRF   xF0
1AC1A:  CLRF   xEF
1AC1C:  MOVLB  0
1AC1E:  CALL   4FFC
....................    write16(ADDR_M2_RUN,0); 
1AC22:  MOVLW  78
1AC24:  MOVLB  8
1AC26:  MOVWF  xEE
1AC28:  CLRF   xF0
1AC2A:  CLRF   xEF
1AC2C:  MOVLB  0
1AC2E:  CALL   4FFC
....................    write16(ADDR_M2_BKLSH,0); 
1AC32:  MOVLW  74
1AC34:  MOVLB  8
1AC36:  MOVWF  xEE
1AC38:  CLRF   xF0
1AC3A:  CLRF   xEF
1AC3C:  MOVLB  0
1AC3E:  CALL   4FFC
....................    write16(ADDR_M2_ERROR,0);   
1AC42:  MOVLW  70
1AC44:  MOVLB  8
1AC46:  MOVWF  xEE
1AC48:  CLRF   xF0
1AC4A:  CLRF   xEF
1AC4C:  MOVLB  0
1AC4E:  CALL   4FFC
....................    write16(ADDR_M2_SPR,0); 
1AC52:  MOVLW  B0
1AC54:  MOVLB  8
1AC56:  MOVWF  xEE
1AC58:  CLRF   xF0
1AC5A:  CLRF   xEF
1AC5C:  MOVLB  0
1AC5E:  CALL   4FFC
....................    write16(ADDR_M2_COMP,0); 
1AC62:  MOVLW  B4
1AC64:  MOVLB  8
1AC66:  MOVWF  xEE
1AC68:  CLRF   xF0
1AC6A:  CLRF   xEF
1AC6C:  MOVLB  0
1AC6E:  CALL   4FFC
....................    write16(ADDR_M2_LIN_POS,0);    
1AC72:  MOVLW  B8
1AC74:  MOVLB  8
1AC76:  MOVWF  xEE
1AC78:  CLRF   xF0
1AC7A:  CLRF   xEF
1AC7C:  MOVLB  0
1AC7E:  CALL   4FFC
....................    write16(ADDR_E2_INDEX,0); 
1AC82:  MOVLW  BC
1AC84:  MOVLB  8
1AC86:  MOVWF  xEE
1AC88:  CLRF   xF0
1AC8A:  CLRF   xEF
1AC8C:  MOVLB  0
1AC8E:  CALL   4FFC
....................     
....................    get_step_vars(); 
1AC92:  CALL   2D42
1AC96:  GOTO   1ACEA (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
029C0:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
029C2:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
029C4:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
029C6:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
029C8:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
029CA:  BCF    F90.5
....................    set_pwm1_duty(0);    
029CC:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
029CE:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
029D0:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
029D2:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
029D4:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
029D6:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
029D8:  BCF    F8D.5
....................    set_pwm2_duty(0);  
029DA:  MOVLB  F
029DC:  CLRF   x4F
....................  
....................    output_low(VENC1); 
029DE:  BCF    F8E.6
....................    output_low(VENC2);         
029E0:  BCF    F8E.7
....................    output_low(VHBRDG); 
029E2:  BCF    F8E.2
029E4:  MOVLB  0
029E6:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
0127A:  BCF    FD8.0
0127C:  MOVLB  7
0127E:  RLCF   x40,W
01280:  CLRF   03
01282:  ADDLW  4E
01284:  MOVWF  FE9
01286:  MOVLW  07
01288:  ADDWFC 03,W
0128A:  MOVWF  FEA
0128C:  MOVFF  FEC,A38
01290:  MOVF   FED,F
01292:  MOVFF  FEF,A37
01296:  MOVLB  A
01298:  MOVF   x37,F
0129A:  BTFSS  FD8.2
0129C:  BRA    1424
0129E:  MOVF   x38,F
012A0:  BTFSS  FD8.2
012A2:  BRA    1424
....................       if(m_way[motor]==POS) { 
012A4:  BCF    FD8.0
012A6:  MOVLB  7
012A8:  RLCF   x40,W
012AA:  CLRF   03
012AC:  ADDLW  86
012AE:  MOVWF  FE9
012B0:  MOVLW  07
012B2:  ADDWFC 03,W
012B4:  MOVWF  FEA
012B6:  MOVFF  FEC,A38
012BA:  MOVF   FED,F
012BC:  MOVFF  FEF,A37
012C0:  MOVLB  A
012C2:  MOVF   x37,F
012C4:  BNZ   135E
012C6:  MOVF   x38,F
012C8:  BNZ   135E
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
012CA:  BCF    FD8.0
012CC:  MOVLB  7
012CE:  RLCF   x40,W
012D0:  CLRF   03
012D2:  ADDLW  BF
012D4:  MOVWF  FE9
012D6:  MOVLW  07
012D8:  ADDWFC 03,W
012DA:  MOVWF  FEA
012DC:  MOVFF  FEC,A38
012E0:  MOVF   FED,F
012E2:  MOVFF  FEF,A37
012E6:  BCF    FD8.0
012E8:  RLCF   x40,W
012EA:  CLRF   03
012EC:  ADDLW  5E
012EE:  MOVWF  FE9
012F0:  MOVLW  07
012F2:  ADDWFC 03,W
012F4:  MOVWF  FEA
012F6:  MOVFF  FEC,03
012FA:  MOVF   FED,F
012FC:  MOVFF  FEF,01
01300:  MOVF   03,W
01302:  MOVLB  A
01304:  SUBWF  x38,W
01306:  BNC   132A
01308:  BNZ   1310
0130A:  MOVF   01,W
0130C:  SUBWF  x37,W
0130E:  BNC   132A
01310:  BCF    FD8.0
01312:  MOVLB  7
01314:  RLCF   x40,W
01316:  CLRF   03
01318:  ADDLW  BF
0131A:  MOVWF  FE9
0131C:  MOVLW  07
0131E:  ADDWFC 03,W
01320:  MOVWF  FEA
01322:  CLRF   FEC
01324:  MOVF   FED,F
01326:  CLRF   FEF
01328:  MOVLB  A
....................          e_pos[motor]++; 
0132A:  BCF    FD8.0
0132C:  MOVLB  7
0132E:  RLCF   x40,W
01330:  CLRF   03
01332:  ADDLW  BF
01334:  MOVWF  FE9
01336:  MOVLW  07
01338:  ADDWFC 03,W
0133A:  MOVWF  FEA
0133C:  MOVLW  01
0133E:  ADDWF  FEE,F
01340:  BNC   1344
01342:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
01344:  BCF    FD8.0
01346:  RLCF   x40,W
01348:  CLRF   03
0134A:  ADDLW  9A
0134C:  MOVWF  FE9
0134E:  MOVLW  07
01350:  ADDWFC 03,W
01352:  MOVWF  FEA
01354:  CLRF   FEC
01356:  MOVF   FED,F
01358:  CLRF   FEF
....................       } 
0135A:  BRA    1422
0135C:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
0135E:  BCF    FD8.0
01360:  MOVLB  7
01362:  RLCF   x40,W
01364:  CLRF   03
01366:  ADDLW  86
01368:  MOVWF  FE9
0136A:  MOVLW  07
0136C:  ADDWFC 03,W
0136E:  MOVWF  FEA
01370:  MOVFF  FEC,A38
01374:  MOVF   FED,F
01376:  MOVFF  FEF,A37
0137A:  MOVLB  A
0137C:  DECFSZ x37,W
0137E:  BRA    1424
01380:  MOVF   x38,F
01382:  BNZ   1424
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01384:  BCF    FD8.0
01386:  MOVLB  7
01388:  RLCF   x40,W
0138A:  CLRF   03
0138C:  ADDLW  BF
0138E:  MOVWF  FE9
01390:  MOVLW  07
01392:  ADDWFC 03,W
01394:  MOVWF  FEA
01396:  MOVFF  FEC,A38
0139A:  MOVF   FED,F
0139C:  MOVFF  FEF,A37
013A0:  MOVLB  A
013A2:  MOVF   x37,F
013A4:  BNZ   13F0
013A6:  MOVF   x38,F
013A8:  BNZ   13F0
013AA:  BCF    FD8.0
013AC:  MOVLB  7
013AE:  RLCF   x40,W
013B0:  CLRF   03
013B2:  ADDLW  BF
013B4:  MOVWF  01
013B6:  MOVLW  07
013B8:  ADDWFC 03,F
013BA:  MOVLB  A
013BC:  MOVFF  03,A38
013C0:  BCF    FD8.0
013C2:  MOVLB  7
013C4:  RLCF   x40,W
013C6:  CLRF   03
013C8:  ADDLW  5E
013CA:  MOVWF  FE9
013CC:  MOVLW  07
013CE:  ADDWFC 03,W
013D0:  MOVWF  FEA
013D2:  MOVFF  FEC,03
013D6:  MOVF   FED,F
013D8:  MOVFF  FEF,A39
013DC:  MOVLB  A
013DE:  MOVFF  A38,FEA
013E2:  MOVFF  01,FE9
013E6:  MOVFF  03,FEC
013EA:  MOVF   FED,F
013EC:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
013F0:  BCF    FD8.0
013F2:  MOVLB  7
013F4:  RLCF   x40,W
013F6:  CLRF   03
013F8:  ADDLW  BF
013FA:  MOVWF  FE9
013FC:  MOVLW  07
013FE:  ADDWFC 03,W
01400:  MOVWF  FEA
01402:  MOVLW  FF
01404:  ADDWF  FEF,F
01406:  BC    140C
01408:  MOVF   FEE,F
0140A:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
0140C:  BCF    FD8.0
0140E:  RLCF   x40,W
01410:  CLRF   03
01412:  ADDLW  9A
01414:  MOVWF  FE9
01416:  MOVLW  07
01418:  ADDWFC 03,W
0141A:  MOVWF  FEA
0141C:  CLRF   FEC
0141E:  MOVF   FED,F
01420:  CLRF   FEF
01422:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
01424:  BCF    FD8.0
01426:  MOVLB  7
01428:  RLCF   x40,W
0142A:  CLRF   03
0142C:  ADDLW  4E
0142E:  MOVWF  FE9
01430:  MOVLW  07
01432:  ADDWFC 03,W
01434:  MOVWF  FEA
01436:  MOVFF  FEC,A38
0143A:  MOVF   FED,F
0143C:  MOVFF  FEF,A37
01440:  MOVLB  A
01442:  DECFSZ x37,W
01444:  BRA    15CC
01446:  MOVF   x38,F
01448:  BTFSS  FD8.2
0144A:  BRA    15CC
....................       if(m_way[motor]==NEG) { 
0144C:  BCF    FD8.0
0144E:  MOVLB  7
01450:  RLCF   x40,W
01452:  CLRF   03
01454:  ADDLW  86
01456:  MOVWF  FE9
01458:  MOVLW  07
0145A:  ADDWFC 03,W
0145C:  MOVWF  FEA
0145E:  MOVFF  FEC,A38
01462:  MOVF   FED,F
01464:  MOVFF  FEF,A37
01468:  MOVLB  A
0146A:  DECFSZ x37,W
0146C:  BRA    1506
0146E:  MOVF   x38,F
01470:  BNZ   1506
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
01472:  BCF    FD8.0
01474:  MOVLB  7
01476:  RLCF   x40,W
01478:  CLRF   03
0147A:  ADDLW  BF
0147C:  MOVWF  FE9
0147E:  MOVLW  07
01480:  ADDWFC 03,W
01482:  MOVWF  FEA
01484:  MOVFF  FEC,A38
01488:  MOVF   FED,F
0148A:  MOVFF  FEF,A37
0148E:  BCF    FD8.0
01490:  RLCF   x40,W
01492:  CLRF   03
01494:  ADDLW  5E
01496:  MOVWF  FE9
01498:  MOVLW  07
0149A:  ADDWFC 03,W
0149C:  MOVWF  FEA
0149E:  MOVFF  FEC,03
014A2:  MOVF   FED,F
014A4:  MOVFF  FEF,01
014A8:  MOVF   03,W
014AA:  MOVLB  A
014AC:  SUBWF  x38,W
014AE:  BNC   14D2
014B0:  BNZ   14B8
014B2:  MOVF   01,W
014B4:  SUBWF  x37,W
014B6:  BNC   14D2
014B8:  BCF    FD8.0
014BA:  MOVLB  7
014BC:  RLCF   x40,W
014BE:  CLRF   03
014C0:  ADDLW  BF
014C2:  MOVWF  FE9
014C4:  MOVLW  07
014C6:  ADDWFC 03,W
014C8:  MOVWF  FEA
014CA:  CLRF   FEC
014CC:  MOVF   FED,F
014CE:  CLRF   FEF
014D0:  MOVLB  A
....................          e_pos[motor]++; 
014D2:  BCF    FD8.0
014D4:  MOVLB  7
014D6:  RLCF   x40,W
014D8:  CLRF   03
014DA:  ADDLW  BF
014DC:  MOVWF  FE9
014DE:  MOVLW  07
014E0:  ADDWFC 03,W
014E2:  MOVWF  FEA
014E4:  MOVLW  01
014E6:  ADDWF  FEE,F
014E8:  BNC   14EC
014EA:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014EC:  BCF    FD8.0
014EE:  RLCF   x40,W
014F0:  CLRF   03
014F2:  ADDLW  9A
014F4:  MOVWF  FE9
014F6:  MOVLW  07
014F8:  ADDWFC 03,W
014FA:  MOVWF  FEA
014FC:  CLRF   FEC
014FE:  MOVF   FED,F
01500:  CLRF   FEF
....................       } 
01502:  BRA    15CA
01504:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
01506:  BCF    FD8.0
01508:  MOVLB  7
0150A:  RLCF   x40,W
0150C:  CLRF   03
0150E:  ADDLW  86
01510:  MOVWF  FE9
01512:  MOVLW  07
01514:  ADDWFC 03,W
01516:  MOVWF  FEA
01518:  MOVFF  FEC,A38
0151C:  MOVF   FED,F
0151E:  MOVFF  FEF,A37
01522:  MOVLB  A
01524:  MOVF   x37,F
01526:  BNZ   15CC
01528:  MOVF   x38,F
0152A:  BNZ   15CC
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
0152C:  BCF    FD8.0
0152E:  MOVLB  7
01530:  RLCF   x40,W
01532:  CLRF   03
01534:  ADDLW  BF
01536:  MOVWF  FE9
01538:  MOVLW  07
0153A:  ADDWFC 03,W
0153C:  MOVWF  FEA
0153E:  MOVFF  FEC,A38
01542:  MOVF   FED,F
01544:  MOVFF  FEF,A37
01548:  MOVLB  A
0154A:  MOVF   x37,F
0154C:  BNZ   1598
0154E:  MOVF   x38,F
01550:  BNZ   1598
01552:  BCF    FD8.0
01554:  MOVLB  7
01556:  RLCF   x40,W
01558:  CLRF   03
0155A:  ADDLW  BF
0155C:  MOVWF  01
0155E:  MOVLW  07
01560:  ADDWFC 03,F
01562:  MOVLB  A
01564:  MOVFF  03,A38
01568:  BCF    FD8.0
0156A:  MOVLB  7
0156C:  RLCF   x40,W
0156E:  CLRF   03
01570:  ADDLW  5E
01572:  MOVWF  FE9
01574:  MOVLW  07
01576:  ADDWFC 03,W
01578:  MOVWF  FEA
0157A:  MOVFF  FEC,03
0157E:  MOVF   FED,F
01580:  MOVFF  FEF,A39
01584:  MOVLB  A
01586:  MOVFF  A38,FEA
0158A:  MOVFF  01,FE9
0158E:  MOVFF  03,FEC
01592:  MOVF   FED,F
01594:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
01598:  BCF    FD8.0
0159A:  MOVLB  7
0159C:  RLCF   x40,W
0159E:  CLRF   03
015A0:  ADDLW  BF
015A2:  MOVWF  FE9
015A4:  MOVLW  07
015A6:  ADDWFC 03,W
015A8:  MOVWF  FEA
015AA:  MOVLW  FF
015AC:  ADDWF  FEF,F
015AE:  BC    15B4
015B0:  MOVF   FEE,F
015B2:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
015B4:  BCF    FD8.0
015B6:  RLCF   x40,W
015B8:  CLRF   03
015BA:  ADDLW  9A
015BC:  MOVWF  FE9
015BE:  MOVLW  07
015C0:  ADDWFC 03,W
015C2:  MOVWF  FEA
015C4:  CLRF   FEC
015C6:  MOVF   FED,F
015C8:  CLRF   FEF
015CA:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
015CC:  MOVF   1F,W
015CE:  SUBLW  04
015D0:  BTFSS  FD8.2
015D2:  BRA    1706
015D4:  MOVF   20,F
015D6:  BTFSS  FD8.2
015D8:  BRA    1706
015DA:  BCF    FD8.0
015DC:  MOVLB  7
015DE:  RLCF   x40,W
015E0:  CLRF   03
015E2:  ADDLW  6A
015E4:  MOVWF  FE9
015E6:  MOVLW  07
015E8:  ADDWFC 03,W
015EA:  MOVWF  FEA
015EC:  MOVFF  FEC,A38
015F0:  MOVF   FED,F
015F2:  MOVFF  FEF,A37
015F6:  MOVLB  A
015F8:  MOVF   x37,W
015FA:  SUBLW  02
015FC:  BTFSS  FD8.2
015FE:  BRA    1706
01600:  MOVF   x38,F
01602:  BTFSS  FD8.2
01604:  BRA    1706
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
01606:  MOVLW  01
01608:  MOVLB  7
0160A:  ADDWF  x40,W
0160C:  MOVLB  A
0160E:  MOVWF  x37
01610:  MOVLB  7
01612:  MOVF   x40,W
01614:  MULLW  04
01616:  MOVF   FF3,W
01618:  CLRF   03
0161A:  ADDLW  A2
0161C:  MOVWF  FE9
0161E:  MOVLW  07
01620:  ADDWFC 03,W
01622:  MOVWF  FEA
01624:  MOVFF  FEF,A38
01628:  MOVFF  FEC,A39
0162C:  MOVFF  FEC,A3A
01630:  MOVFF  FEC,A3B
01634:  BCF    FD8.0
01636:  RLCF   x40,W
01638:  CLRF   03
0163A:  ADDLW  BB
0163C:  MOVWF  FE9
0163E:  MOVLW  07
01640:  ADDWFC 03,W
01642:  MOVWF  FEA
01644:  MOVFF  FEC,A3D
01648:  MOVF   FED,F
0164A:  MOVFF  FEF,A3C
0164E:  BCF    FD8.0
01650:  RLCF   x40,W
01652:  CLRF   03
01654:  ADDLW  BF
01656:  MOVWF  FE9
01658:  MOVLW  07
0165A:  ADDWFC 03,W
0165C:  MOVWF  FEA
0165E:  MOVFF  FEC,A3F
01662:  MOVF   FED,F
01664:  MOVFF  FEF,A3E
01668:  MOVLW  6D
0166A:  BTFSS  F9E.4
0166C:  BRA    166A
0166E:  MOVWF  FAD
01670:  MOVLW  3A
01672:  BTFSS  F9E.4
01674:  BRA    1672
01676:  MOVWF  FAD
01678:  MOVFF  A37,A40
0167C:  MOVLW  1B
0167E:  MOVLB  A
01680:  MOVWF  x41
01682:  MOVLB  0
01684:  RCALL  0FC6
01686:  MOVLW  2C
01688:  BTFSS  F9E.4
0168A:  BRA    1688
0168C:  MOVWF  FAD
0168E:  MOVFF  7AA,A40
01692:  MOVLW  1B
01694:  MOVLB  A
01696:  MOVWF  x41
01698:  MOVLB  0
0169A:  RCALL  0FC6
0169C:  MOVLW  89
0169E:  MOVWF  FF6
016A0:  MOVLW  0F
016A2:  MOVWF  FF7
016A4:  MOVLW  00
016A6:  MOVWF  FF8
016A8:  MOVLW  03
016AA:  MOVLB  A
016AC:  MOVWF  x40
016AE:  MOVLB  0
016B0:  RCALL  1044
016B2:  MOVLW  41
016B4:  MOVWF  FE9
016B6:  MOVFF  A3B,A43
016BA:  MOVFF  A3A,A42
016BE:  MOVFF  A39,A41
016C2:  MOVFF  A38,A40
016C6:  RCALL  110A
016C8:  MOVLW  2C
016CA:  BTFSS  F9E.4
016CC:  BRA    16CA
016CE:  MOVWF  FAD
016D0:  MOVLW  10
016D2:  MOVWF  FE9
016D4:  MOVFF  A3D,A41
016D8:  MOVFF  A3C,A40
016DC:  RCALL  11C6
016DE:  MOVLW  2C
016E0:  BTFSS  F9E.4
016E2:  BRA    16E0
016E4:  MOVWF  FAD
016E6:  MOVLW  10
016E8:  MOVWF  FE9
016EA:  MOVFF  A3F,A41
016EE:  MOVFF  A3E,A40
016F2:  RCALL  11C6
016F4:  MOVLW  0D
016F6:  BTFSS  F9E.4
016F8:  BRA    16F6
016FA:  MOVWF  FAD
016FC:  MOVLW  0A
016FE:  BTFSS  F9E.4
01700:  BRA    16FE
01702:  MOVWF  FAD
01704:  MOVLB  A
....................    }    
01706:  MOVLB  0
01708:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A7AA:  MOVLB  7
0A7AC:  MOVF   x40,W
0A7AE:  XORLW  00
0A7B0:  MOVLB  0
0A7B2:  BZ    A7BA
0A7B4:  XORLW  01
0A7B6:  BZ    A84A
0A7B8:  BRA    A8D8
....................       case 0 : if (e_type[motor]==1) { 
0A7BA:  BCF    FD8.0
0A7BC:  MOVLB  7
0A7BE:  RLCF   x40,W
0A7C0:  CLRF   03
0A7C2:  ADDLW  6A
0A7C4:  MOVWF  FE9
0A7C6:  MOVLW  07
0A7C8:  ADDWFC 03,W
0A7CA:  MOVWF  FEA
0A7CC:  MOVFF  FEC,8C8
0A7D0:  MOVF   FED,F
0A7D2:  MOVFF  FEF,8C7
0A7D6:  MOVLB  8
0A7D8:  DECFSZ xC7,W
0A7DA:  BRA    A7FA
0A7DC:  MOVF   xC8,F
0A7DE:  BNZ   A7FA
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A7E0:  CLRF   03
0A7E2:  MOVLB  7
0A7E4:  MOVF   x40,W
0A7E6:  ADDLW  CB
0A7E8:  MOVWF  FE9
0A7EA:  MOVLW  07
0A7EC:  ADDWFC 03,W
0A7EE:  MOVWF  FEA
0A7F0:  MOVLW  00
0A7F2:  BTFSC  F81.4
0A7F4:  MOVLW  01
0A7F6:  MOVWF  FEF
0A7F8:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A7FA:  BCF    FD8.0
0A7FC:  MOVLB  7
0A7FE:  RLCF   x40,W
0A800:  CLRF   03
0A802:  ADDLW  6A
0A804:  MOVWF  FE9
0A806:  MOVLW  07
0A808:  ADDWFC 03,W
0A80A:  MOVWF  FEA
0A80C:  MOVFF  FEC,8C8
0A810:  MOVF   FED,F
0A812:  MOVFF  FEF,8C7
0A816:  MOVLB  8
0A818:  MOVF   xC7,W
0A81A:  SUBLW  02
0A81C:  BNZ   A846
0A81E:  MOVF   xC8,F
0A820:  BNZ   A846
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A822:  CLRF   03
0A824:  MOVLB  7
0A826:  MOVF   x40,W
0A828:  ADDLW  CB
0A82A:  MOVWF  FE9
0A82C:  MOVLW  07
0A82E:  ADDWFC 03,W
0A830:  MOVWF  FEA
0A832:  MOVLW  00
0A834:  BTFSC  F81.4
0A836:  MOVLW  01
0A838:  MOVLB  8
0A83A:  MOVWF  xC9
0A83C:  MOVLW  00
0A83E:  BTFSC  F81.1
0A840:  MOVLW  01
0A842:  ANDWF  xC9,W
0A844:  MOVWF  FEF
....................                } 
....................          break; 
0A846:  MOVLB  0
0A848:  BRA    A8D8
....................       case 1 : if (e_type[motor]==1) { 
0A84A:  BCF    FD8.0
0A84C:  MOVLB  7
0A84E:  RLCF   x40,W
0A850:  CLRF   03
0A852:  ADDLW  6A
0A854:  MOVWF  FE9
0A856:  MOVLW  07
0A858:  ADDWFC 03,W
0A85A:  MOVWF  FEA
0A85C:  MOVFF  FEC,8C8
0A860:  MOVF   FED,F
0A862:  MOVFF  FEF,8C7
0A866:  MOVLB  8
0A868:  DECFSZ xC7,W
0A86A:  BRA    A88A
0A86C:  MOVF   xC8,F
0A86E:  BNZ   A88A
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A870:  CLRF   03
0A872:  MOVLB  7
0A874:  MOVF   x40,W
0A876:  ADDLW  CB
0A878:  MOVWF  FE9
0A87A:  MOVLW  07
0A87C:  ADDWFC 03,W
0A87E:  MOVWF  FEA
0A880:  MOVLW  00
0A882:  BTFSC  F81.5
0A884:  MOVLW  01
0A886:  MOVWF  FEF
0A888:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A88A:  BCF    FD8.0
0A88C:  MOVLB  7
0A88E:  RLCF   x40,W
0A890:  CLRF   03
0A892:  ADDLW  6A
0A894:  MOVWF  FE9
0A896:  MOVLW  07
0A898:  ADDWFC 03,W
0A89A:  MOVWF  FEA
0A89C:  MOVFF  FEC,8C8
0A8A0:  MOVF   FED,F
0A8A2:  MOVFF  FEF,8C7
0A8A6:  MOVLB  8
0A8A8:  MOVF   xC7,W
0A8AA:  SUBLW  02
0A8AC:  BNZ   A8D6
0A8AE:  MOVF   xC8,F
0A8B0:  BNZ   A8D6
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A8B2:  CLRF   03
0A8B4:  MOVLB  7
0A8B6:  MOVF   x40,W
0A8B8:  ADDLW  CB
0A8BA:  MOVWF  FE9
0A8BC:  MOVLW  07
0A8BE:  ADDWFC 03,W
0A8C0:  MOVWF  FEA
0A8C2:  MOVLW  00
0A8C4:  BTFSC  F81.5
0A8C6:  MOVLW  01
0A8C8:  MOVLB  8
0A8CA:  MOVWF  xC9
0A8CC:  MOVLW  00
0A8CE:  BTFSC  F81.2
0A8D0:  MOVLW  01
0A8D2:  ANDWF  xC9,W
0A8D4:  MOVWF  FEF
....................                } 
....................          break; 
0A8D6:  MOVLB  0
....................    } 
0A8D8:  GOTO   A992 (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017F6:  MOVLB  7
017F8:  MOVF   x40,W
017FA:  XORLW  00
017FC:  MOVLB  0
017FE:  BZ    1806
01800:  XORLW  01
01802:  BZ    1896
01804:  BRA    1924
....................       case 0 : if (e_type[motor]==1) { 
01806:  BCF    FD8.0
01808:  MOVLB  7
0180A:  RLCF   x40,W
0180C:  CLRF   03
0180E:  ADDLW  6A
01810:  MOVWF  FE9
01812:  MOVLW  07
01814:  ADDWFC 03,W
01816:  MOVWF  FEA
01818:  MOVFF  FEC,A38
0181C:  MOVF   FED,F
0181E:  MOVFF  FEF,A37
01822:  MOVLB  A
01824:  DECFSZ x37,W
01826:  BRA    1846
01828:  MOVF   x38,F
0182A:  BNZ   1846
....................                   e_ch_n[motor]=input(ENC1_IND); 
0182C:  CLRF   03
0182E:  MOVLB  7
01830:  MOVF   x40,W
01832:  ADDLW  CB
01834:  MOVWF  FE9
01836:  MOVLW  07
01838:  ADDWFC 03,W
0183A:  MOVWF  FEA
0183C:  MOVLW  00
0183E:  BTFSC  F81.4
01840:  MOVLW  01
01842:  MOVWF  FEF
01844:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01846:  BCF    FD8.0
01848:  MOVLB  7
0184A:  RLCF   x40,W
0184C:  CLRF   03
0184E:  ADDLW  6A
01850:  MOVWF  FE9
01852:  MOVLW  07
01854:  ADDWFC 03,W
01856:  MOVWF  FEA
01858:  MOVFF  FEC,A38
0185C:  MOVF   FED,F
0185E:  MOVFF  FEF,A37
01862:  MOVLB  A
01864:  MOVF   x37,W
01866:  SUBLW  02
01868:  BNZ   1892
0186A:  MOVF   x38,F
0186C:  BNZ   1892
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0186E:  CLRF   03
01870:  MOVLB  7
01872:  MOVF   x40,W
01874:  ADDLW  CB
01876:  MOVWF  FE9
01878:  MOVLW  07
0187A:  ADDWFC 03,W
0187C:  MOVWF  FEA
0187E:  MOVLW  00
01880:  BTFSC  F81.4
01882:  MOVLW  01
01884:  MOVLB  A
01886:  MOVWF  x39
01888:  MOVLW  00
0188A:  BTFSC  F81.1
0188C:  MOVLW  01
0188E:  ANDWF  x39,W
01890:  MOVWF  FEF
....................                } 
....................          break; 
01892:  MOVLB  0
01894:  BRA    1924
....................       case 1 : if (e_type[motor]==1) { 
01896:  BCF    FD8.0
01898:  MOVLB  7
0189A:  RLCF   x40,W
0189C:  CLRF   03
0189E:  ADDLW  6A
018A0:  MOVWF  FE9
018A2:  MOVLW  07
018A4:  ADDWFC 03,W
018A6:  MOVWF  FEA
018A8:  MOVFF  FEC,A38
018AC:  MOVF   FED,F
018AE:  MOVFF  FEF,A37
018B2:  MOVLB  A
018B4:  DECFSZ x37,W
018B6:  BRA    18D6
018B8:  MOVF   x38,F
018BA:  BNZ   18D6
....................                   e_ch_n[motor]=input(ENC2_IND); 
018BC:  CLRF   03
018BE:  MOVLB  7
018C0:  MOVF   x40,W
018C2:  ADDLW  CB
018C4:  MOVWF  FE9
018C6:  MOVLW  07
018C8:  ADDWFC 03,W
018CA:  MOVWF  FEA
018CC:  MOVLW  00
018CE:  BTFSC  F81.5
018D0:  MOVLW  01
018D2:  MOVWF  FEF
018D4:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018D6:  BCF    FD8.0
018D8:  MOVLB  7
018DA:  RLCF   x40,W
018DC:  CLRF   03
018DE:  ADDLW  6A
018E0:  MOVWF  FE9
018E2:  MOVLW  07
018E4:  ADDWFC 03,W
018E6:  MOVWF  FEA
018E8:  MOVFF  FEC,A38
018EC:  MOVF   FED,F
018EE:  MOVFF  FEF,A37
018F2:  MOVLB  A
018F4:  MOVF   x37,W
018F6:  SUBLW  02
018F8:  BNZ   1922
018FA:  MOVF   x38,F
018FC:  BNZ   1922
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018FE:  CLRF   03
01900:  MOVLB  7
01902:  MOVF   x40,W
01904:  ADDLW  CB
01906:  MOVWF  FE9
01908:  MOVLW  07
0190A:  ADDWFC 03,W
0190C:  MOVWF  FEA
0190E:  MOVLW  00
01910:  BTFSC  F81.5
01912:  MOVLW  01
01914:  MOVLB  A
01916:  MOVWF  x39
01918:  MOVLW  00
0191A:  BTFSC  F81.2
0191C:  MOVLW  01
0191E:  ANDWF  x39,W
01920:  MOVWF  FEF
....................                } 
....................          break; 
01922:  MOVLB  0
....................    } 
01924:  GOTO   1A72 (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
0170A:  BCF    FD8.0
0170C:  MOVLB  7
0170E:  RLCF   x40,W
01710:  CLRF   03
01712:  ADDLW  BB
01714:  MOVWF  FE9
01716:  MOVLW  07
01718:  ADDWFC 03,W
0171A:  MOVWF  FEA
0171C:  MOVLW  01
0171E:  ADDWF  FEE,F
01720:  BNC   1724
01722:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
01724:  MOVF   xAA,W
01726:  XORLW  00
01728:  MOVLB  0
0172A:  BZ    1736
0172C:  XORLW  01
0172E:  BZ    173C
01730:  XORLW  03
01732:  BZ    174E
01734:  BRA    1778
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
01736:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
01738:  BCF    FF0.0
....................          break; 
0173A:  BRA    1778
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
0173C:  MOVLW  02
0173E:  MOVLB  7
01740:  MOVWF  xAA
....................                disable_interrupts(INT_EXT1_L2H); 
01742:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
01744:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01746:  BSF    FF0.3
01748:  BCF    FF1.5
....................          break; 
0174A:  MOVLB  0
0174C:  BRA    1778
....................       case 2 : edge_mode=1; 
0174E:  MOVLW  01
01750:  MOVLB  7
01752:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01754:  BCF    FD8.0
01756:  RLCF   x40,W
01758:  CLRF   03
0175A:  ADDLW  BB
0175C:  MOVWF  FE9
0175E:  MOVLW  07
01760:  ADDWFC 03,W
01762:  MOVWF  FEA
01764:  MOVLW  FF
01766:  ADDWF  FEF,F
01768:  BC    176E
0176A:  MOVF   FEE,F
0176C:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
0176E:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
01770:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
01772:  BSF    FF0.3
01774:  BSF    FF1.5
....................          break; 
01776:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
01778:  RCALL  127A
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
0177A:  BCF    FF0.0
0177C:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
01780:  BCF    FD8.0
01782:  MOVLB  7
01784:  RLCF   x40,W
01786:  CLRF   03
01788:  ADDLW  BB
0178A:  MOVWF  FE9
0178C:  MOVLW  07
0178E:  ADDWFC 03,W
01790:  MOVWF  FEA
01792:  MOVLW  01
01794:  ADDWF  FEE,F
01796:  BNC   179A
01798:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
0179A:  MOVF   xAA,W
0179C:  XORLW  00
0179E:  MOVLB  0
017A0:  BZ    17AC
017A2:  XORLW  01
017A4:  BZ    17B2
017A6:  XORLW  03
017A8:  BZ    17C4
017AA:  BRA    17EE
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
017AC:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
017AE:  BCF    FF0.1
....................          break; 
017B0:  BRA    17EE
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
017B2:  MOVLW  02
017B4:  MOVLB  7
017B6:  MOVWF  xAA
....................                disable_interrupts(INT_EXT2_L2H); 
017B8:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
017BA:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
017BC:  BSF    FF0.4
017BE:  BCF    FF1.4
....................          break; 
017C0:  MOVLB  0
017C2:  BRA    17EE
....................       case 2 : edge_mode=1; 
017C4:  MOVLW  01
017C6:  MOVLB  7
017C8:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
017CA:  BCF    FD8.0
017CC:  RLCF   x40,W
017CE:  CLRF   03
017D0:  ADDLW  BB
017D2:  MOVWF  FE9
017D4:  MOVLW  07
017D6:  ADDWFC 03,W
017D8:  MOVWF  FEA
017DA:  MOVLW  FF
017DC:  ADDWF  FEF,F
017DE:  BC    17E4
017E0:  MOVF   FEE,F
017E2:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017E4:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017E6:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017E8:  BSF    FF0.4
017EA:  BSF    FF1.4
....................          break; 
017EC:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017EE:  RCALL  127A
.................... } 
....................  
.................... // motor step timer interrupt 
017F0:  BCF    FF0.1
017F2:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
01928:  MOVLW  F9
0192A:  MOVWF  FB3
0192C:  MOVLW  C0
0192E:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
01930:  BCF    FD8.0
01932:  MOVLB  7
01934:  RLCF   x40,W
01936:  CLRF   03
01938:  ADDLW  8E
0193A:  MOVWF  FE9
0193C:  MOVLW  07
0193E:  ADDWFC 03,W
01940:  MOVWF  FEA
01942:  MOVLW  01
01944:  ADDWF  FEE,F
01946:  BNC   194A
01948:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
0194A:  BCF    FD8.0
0194C:  RLCF   x40,W
0194E:  CLRF   03
01950:  ADDLW  8E
01952:  MOVWF  FE9
01954:  MOVLW  07
01956:  ADDWFC 03,W
01958:  MOVWF  FEA
0195A:  MOVFF  FEC,A38
0195E:  MOVF   FED,F
01960:  MOVFF  FEF,A37
01964:  BCF    FD8.0
01966:  RLCF   x40,W
01968:  CLRF   03
0196A:  ADDLW  4A
0196C:  MOVWF  FE9
0196E:  MOVLW  07
01970:  ADDWFC 03,W
01972:  MOVWF  FEA
01974:  MOVFF  FEC,03
01978:  MOVF   FED,F
0197A:  MOVFF  FEF,01
0197E:  MOVF   03,W
01980:  MOVLB  A
01982:  SUBWF  x38,W
01984:  BTFSS  FD8.0
01986:  BRA    1A74
01988:  BNZ   1992
0198A:  MOVF   01,W
0198C:  SUBWF  x37,W
0198E:  BTFSS  FD8.0
01990:  BRA    1A74
....................    { 
....................       m_step_cnt[motor]++; 
01992:  MOVLB  7
01994:  MOVF   x40,W
01996:  MULLW  04
01998:  MOVF   FF3,W
0199A:  CLRF   03
0199C:  ADDLW  A2
0199E:  MOVWF  FE9
019A0:  MOVLW  07
019A2:  ADDWFC 03,W
019A4:  MOVWF  FEA
019A6:  MOVLW  01
019A8:  ADDWF  FEE,F
019AA:  MOVLW  00
019AC:  ADDWFC FEE,F
019AE:  ADDWFC FEE,F
019B0:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
019B2:  BCF    FD8.0
019B4:  RLCF   x40,W
019B6:  CLRF   03
019B8:  ADDLW  9A
019BA:  MOVWF  FE9
019BC:  MOVLW  07
019BE:  ADDWFC 03,W
019C0:  MOVWF  FEA
019C2:  MOVLW  01
019C4:  ADDWF  FEE,F
019C6:  BNC   19CA
019C8:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
019CA:  BCF    FD8.0
019CC:  RLCF   x40,W
019CE:  CLRF   03
019D0:  ADDLW  8E
019D2:  MOVWF  FE9
019D4:  MOVLW  07
019D6:  ADDWFC 03,W
019D8:  MOVWF  FEA
019DA:  CLRF   FEC
019DC:  MOVF   FED,F
019DE:  CLRF   FEF
....................  
....................       if (motor==0) 
019E0:  MOVF   x40,F
019E2:  BNZ   19E8
....................       { 
....................          output_toggle(M1_CLOCK); 
019E4:  BTG    F90.4
....................       } 
019E6:  BRA    1A48
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019E8:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019EA:  BCF    FD8.0
019EC:  RLCF   x40,W
019EE:  CLRF   03
019F0:  ADDLW  86
019F2:  MOVWF  FE9
019F4:  MOVLW  07
019F6:  ADDWFC 03,W
019F8:  MOVWF  FEA
019FA:  MOVFF  FEC,A38
019FE:  MOVF   FED,F
01A00:  MOVFF  FEF,A37
01A04:  MOVLB  A
01A06:  MOVF   x37,F
01A08:  BNZ   1A2E
01A0A:  MOVF   x38,F
01A0C:  BNZ   1A2E
01A0E:  BCF    FD8.0
01A10:  MOVLB  7
01A12:  RLCF   x40,W
01A14:  CLRF   03
01A16:  ADDLW  B3
01A18:  MOVWF  FE9
01A1A:  MOVLW  07
01A1C:  ADDWFC 03,W
01A1E:  MOVWF  FEA
01A20:  MOVLW  FF
01A22:  ADDWF  FEF,F
01A24:  BC    1A2A
01A26:  MOVF   FEE,F
01A28:  DECF   FED,F
01A2A:  BRA    1A48
01A2C:  MOVLB  A
....................          else m_lin_pos[motor]++;          
01A2E:  BCF    FD8.0
01A30:  MOVLB  7
01A32:  RLCF   x40,W
01A34:  CLRF   03
01A36:  ADDLW  B3
01A38:  MOVWF  FE9
01A3A:  MOVLW  07
01A3C:  ADDWFC 03,W
01A3E:  MOVWF  FEA
01A40:  MOVLW  01
01A42:  ADDWF  FEE,F
01A44:  BNC   1A48
01A46:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A48:  BCF    FD8.0
01A4A:  RLCF   x40,W
01A4C:  CLRF   03
01A4E:  ADDLW  66
01A50:  MOVWF  FE9
01A52:  MOVLW  07
01A54:  ADDWFC 03,W
01A56:  MOVWF  FEA
01A58:  MOVFF  FEC,A38
01A5C:  MOVF   FED,F
01A5E:  MOVFF  FEF,A37
01A62:  MOVLB  A
01A64:  MOVF   x37,W
01A66:  SUBLW  03
01A68:  BNZ   1A74
01A6A:  MOVF   x38,F
01A6C:  BNZ   1A74
01A6E:  MOVLB  0
01A70:  BRA    17F6
01A72:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A74:  BCF    FA1.1
01A76:  BCF    FA1.1
01A78:  MOVLB  0
01A7A:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
08A0C:  BCF    FD8.0
08A0E:  MOVLB  7
08A10:  RLCF   x40,W
08A12:  CLRF   03
08A14:  ADDLW  4E
08A16:  MOVWF  FE9
08A18:  MOVLW  07
08A1A:  ADDWFC 03,W
08A1C:  MOVWF  FEA
08A1E:  MOVFF  FEC,8D9
08A22:  MOVF   FED,F
08A24:  MOVFF  FEF,8D8
08A28:  MOVLB  8
08A2A:  DECFSZ xD8,W
08A2C:  BRA    8A7C
08A2E:  MOVF   xD9,F
08A30:  BNZ   8A7C
08A32:  BCF    FD8.0
08A34:  MOVLB  7
08A36:  RLCF   x40,W
08A38:  CLRF   03
08A3A:  ADDLW  86
08A3C:  MOVWF  01
08A3E:  MOVLW  07
08A40:  ADDWFC 03,F
08A42:  MOVFF  01,8D8
08A46:  MOVLB  8
08A48:  MOVFF  03,8D9
08A4C:  BCF    FD8.0
08A4E:  MOVLB  7
08A50:  RLCF   x40,W
08A52:  CLRF   03
08A54:  ADDLW  86
08A56:  MOVWF  FE9
08A58:  MOVLW  07
08A5A:  ADDWFC 03,W
08A5C:  MOVWF  FEA
08A5E:  MOVF   FEF,F
08A60:  BNZ   8A66
08A62:  MOVF   FEC,F
08A64:  BZ    8A6A
08A66:  MOVLW  00
08A68:  BRA    8A6C
08A6A:  MOVLW  01
08A6C:  MOVLB  8
08A6E:  MOVFF  8D9,FEA
08A72:  MOVFF  8D8,FE9
08A76:  CLRF   FEC
08A78:  MOVF   FED,F
08A7A:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
08A7C:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
08A7E:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
08A80:  BCF    FD8.0
08A82:  MOVLB  7
08A84:  RLCF   x40,W
08A86:  CLRF   03
08A88:  ADDLW  42
08A8A:  MOVWF  FE9
08A8C:  MOVLW  07
08A8E:  ADDWFC 03,W
08A90:  MOVWF  FEA
08A92:  MOVF   FEF,F
08A94:  BNZ   8A9E
08A96:  MOVF   FEC,F
08A98:  BNZ   8A9E
08A9A:  BCF    F90.2
08A9C:  BRA    8AA0
08A9E:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
08AA0:  BCF    FD8.0
08AA2:  RLCF   x40,W
08AA4:  CLRF   03
08AA6:  ADDLW  46
08AA8:  MOVWF  FE9
08AAA:  MOVLW  07
08AAC:  ADDWFC 03,W
08AAE:  MOVWF  FEA
08AB0:  MOVF   FEF,F
08AB2:  BNZ   8ABC
08AB4:  MOVF   FEC,F
08AB6:  BNZ   8ABC
08AB8:  BCF    F90.3
08ABA:  BRA    8ABE
08ABC:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
08ABE:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
08AC0:  BCF    FD8.0
08AC2:  RLCF   x40,W
08AC4:  CLRF   03
08AC6:  ADDLW  86
08AC8:  MOVWF  FE9
08ACA:  MOVLW  07
08ACC:  ADDWFC 03,W
08ACE:  MOVWF  FEA
08AD0:  MOVF   FEF,F
08AD2:  BNZ   8ADC
08AD4:  MOVF   FEC,F
08AD6:  BNZ   8ADC
08AD8:  BCF    F90.5
08ADA:  BRA    8ADE
08ADC:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08ADE:  BCF    FD8.0
08AE0:  RLCF   x40,W
08AE2:  CLRF   03
08AE4:  ADDLW  56
08AE6:  MOVWF  FE9
08AE8:  MOVLW  07
08AEA:  ADDWFC 03,W
08AEC:  MOVWF  FEA
08AEE:  MOVFF  FEC,8D9
08AF2:  MOVF   FED,F
08AF4:  MOVFF  FEF,8D8
08AF8:  MOVLB  8
08AFA:  RRCF   xD9,F
08AFC:  RRCF   xD8,F
08AFE:  RRCF   xD9,F
08B00:  RRCF   xD8,F
08B02:  RRCF   xD9,F
08B04:  MOVFF  8D8,FBC
08B08:  RRCF   xD9,F
08B0A:  RRCF   xD9,W
08B0C:  ANDLW  30
08B0E:  MOVWF  00
08B10:  MOVF   FBB,W
08B12:  ANDLW  CF
08B14:  IORWF  00,W
08B16:  MOVWF  FBB
08B18:  MOVLB  0
08B1A:  GOTO   8CA4 (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08B1E:  BCF    FD8.0
08B20:  MOVLB  7
08B22:  RLCF   x40,W
08B24:  CLRF   03
08B26:  ADDLW  4E
08B28:  MOVWF  FE9
08B2A:  MOVLW  07
08B2C:  ADDWFC 03,W
08B2E:  MOVWF  FEA
08B30:  MOVFF  FEC,8D9
08B34:  MOVF   FED,F
08B36:  MOVFF  FEF,8D8
08B3A:  MOVLB  8
08B3C:  DECFSZ xD8,W
08B3E:  BRA    8B8E
08B40:  MOVF   xD9,F
08B42:  BNZ   8B8E
08B44:  BCF    FD8.0
08B46:  MOVLB  7
08B48:  RLCF   x40,W
08B4A:  CLRF   03
08B4C:  ADDLW  86
08B4E:  MOVWF  01
08B50:  MOVLW  07
08B52:  ADDWFC 03,F
08B54:  MOVFF  01,8D8
08B58:  MOVLB  8
08B5A:  MOVFF  03,8D9
08B5E:  BCF    FD8.0
08B60:  MOVLB  7
08B62:  RLCF   x40,W
08B64:  CLRF   03
08B66:  ADDLW  86
08B68:  MOVWF  FE9
08B6A:  MOVLW  07
08B6C:  ADDWFC 03,W
08B6E:  MOVWF  FEA
08B70:  MOVF   FEF,F
08B72:  BNZ   8B78
08B74:  MOVF   FEC,F
08B76:  BZ    8B7C
08B78:  MOVLW  00
08B7A:  BRA    8B7E
08B7C:  MOVLW  01
08B7E:  MOVLB  8
08B80:  MOVFF  8D9,FEA
08B84:  MOVFF  8D8,FE9
08B88:  CLRF   FEC
08B8A:  MOVF   FED,F
08B8C:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08B8E:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08B90:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08B92:  BCF    FD8.0
08B94:  MOVLB  7
08B96:  RLCF   x40,W
08B98:  CLRF   03
08B9A:  ADDLW  42
08B9C:  MOVWF  FE9
08B9E:  MOVLW  07
08BA0:  ADDWFC 03,W
08BA2:  MOVWF  FEA
08BA4:  MOVF   FEF,F
08BA6:  BNZ   8BB0
08BA8:  MOVF   FEC,F
08BAA:  BNZ   8BB0
08BAC:  BCF    F8D.2
08BAE:  BRA    8BB2
08BB0:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08BB2:  BCF    FD8.0
08BB4:  RLCF   x40,W
08BB6:  CLRF   03
08BB8:  ADDLW  46
08BBA:  MOVWF  FE9
08BBC:  MOVLW  07
08BBE:  ADDWFC 03,W
08BC0:  MOVWF  FEA
08BC2:  MOVF   FEF,F
08BC4:  BNZ   8BCE
08BC6:  MOVF   FEC,F
08BC8:  BNZ   8BCE
08BCA:  BCF    F8D.3
08BCC:  BRA    8BD0
08BCE:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08BD0:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08BD2:  BCF    FD8.0
08BD4:  RLCF   x40,W
08BD6:  CLRF   03
08BD8:  ADDLW  86
08BDA:  MOVWF  FE9
08BDC:  MOVLW  07
08BDE:  ADDWFC 03,W
08BE0:  MOVWF  FEA
08BE2:  MOVF   FEF,F
08BE4:  BNZ   8BEE
08BE6:  MOVF   FEC,F
08BE8:  BNZ   8BEE
08BEA:  BCF    F8D.5
08BEC:  BRA    8BF0
08BEE:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08BF0:  BCF    FD8.0
08BF2:  RLCF   x40,W
08BF4:  CLRF   03
08BF6:  ADDLW  56
08BF8:  MOVWF  FE9
08BFA:  MOVLW  07
08BFC:  ADDWFC 03,W
08BFE:  MOVWF  FEA
08C00:  MOVFF  FEC,8D9
08C04:  MOVF   FED,F
08C06:  MOVFF  FEF,8D8
08C0A:  MOVLB  8
08C0C:  RRCF   xD9,F
08C0E:  RRCF   xD8,F
08C10:  RRCF   xD9,F
08C12:  RRCF   xD8,F
08C14:  RRCF   xD9,F
08C16:  MOVFF  8D8,F4F
08C1A:  RRCF   xD9,F
08C1C:  RRCF   xD9,W
08C1E:  ANDLW  30
08C20:  MOVWF  00
08C22:  MOVLB  F
08C24:  MOVF   x4E,W
08C26:  ANDLW  CF
08C28:  IORWF  00,W
08C2A:  MOVWF  x4E
08C2C:  MOVLB  0
08C2E:  GOTO   8CA4 (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
089F8:  MOVLB  8
089FA:  MOVF   xEC,F
089FC:  BZ    8A04
....................       output_bit(VENC1,ON); 
089FE:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
08A00:  BSF    F8E.7
....................    } 
08A02:  BRA    8A08
....................    else {       
....................       output_bit(VENC1,OFF); 
08A04:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
08A06:  BCF    F8E.7
....................    } 
08A08:  MOVLB  0
08A0A:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08D92:  MOVLB  8
08D94:  MOVF   xED,F
08D96:  BNZ   8DBE
08D98:  MOVF   xEE,F
08D9A:  BNZ   8DBE
....................       edge_mode=0; 
08D9C:  MOVLB  7
08D9E:  CLRF   xAA
....................       switch (motor){ 
08DA0:  MOVF   x40,W
08DA2:  XORLW  00
08DA4:  MOVLB  0
08DA6:  BZ    8DAE
08DA8:  XORLW  01
08DAA:  BZ    8DB6
08DAC:  BRA    8DBC
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08DAE:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08DB0:  BSF    FF0.3
08DB2:  BCF    FF1.5
....................             break; 
08DB4:  BRA    8DBC
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08DB6:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08DB8:  BSF    FF0.4
08DBA:  BCF    FF1.4
....................             break; 
08DBC:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08DBE:  DECFSZ xED,W
08DC0:  BRA    8DE8
08DC2:  MOVF   xEE,F
08DC4:  BNZ   8DE8
....................       edge_mode=0; 
08DC6:  MOVLB  7
08DC8:  CLRF   xAA
....................       switch (motor){ 
08DCA:  MOVF   x40,W
08DCC:  XORLW  00
08DCE:  MOVLB  0
08DD0:  BZ    8DD8
08DD2:  XORLW  01
08DD4:  BZ    8DE0
08DD6:  BRA    8DE6
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08DD8:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08DDA:  BSF    FF0.3
08DDC:  BSF    FF1.5
....................             break; 
08DDE:  BRA    8DE6
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08DE0:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08DE2:  BSF    FF0.4
08DE4:  BSF    FF1.4
....................             break; 
08DE6:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08DE8:  MOVF   xED,W
08DEA:  SUBLW  02
08DEC:  BNZ   8E3E
08DEE:  MOVF   xEE,F
08DF0:  BNZ   8E3E
08DF2:  BCF    FD8.0
08DF4:  MOVLB  7
08DF6:  RLCF   x40,W
08DF8:  CLRF   03
08DFA:  ADDLW  6A
08DFC:  MOVWF  FE9
08DFE:  MOVLW  07
08E00:  ADDWFC 03,W
08E02:  MOVWF  FEA
08E04:  MOVFF  FEC,8F0
08E08:  MOVF   FED,F
08E0A:  MOVFF  FEF,8EF
08E0E:  MOVLB  8
08E10:  MOVF   xEF,W
08E12:  SUBLW  02
08E14:  BNZ   8E3E
08E16:  MOVF   xF0,F
08E18:  BNZ   8E3E
....................       edge_mode=1; 
08E1A:  MOVLW  01
08E1C:  MOVLB  7
08E1E:  MOVWF  xAA
....................       switch (motor){ 
08E20:  MOVF   x40,W
08E22:  XORLW  00
08E24:  MOVLB  0
08E26:  BZ    8E2E
08E28:  XORLW  01
08E2A:  BZ    8E36
08E2C:  BRA    8E3C
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08E2E:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08E30:  BSF    FF0.3
08E32:  BSF    FF1.5
....................             break; 
08E34:  BRA    8E3C
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08E36:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08E38:  BSF    FF0.4
08E3A:  BSF    FF1.4
....................             break; 
08E3C:  MOVLB  8
....................       }  
....................    }     
08E3E:  MOVLB  0
08E40:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08FA8:  MOVLB  7
08FAA:  MOVF   x40,W
08FAC:  XORLW  00
08FAE:  MOVLB  0
08FB0:  BZ    8FB8
08FB2:  XORLW  01
08FB4:  BZ    8FE2
08FB6:  BRA    900A
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08FB8:  BCF    FD8.0
08FBA:  MOVLB  7
08FBC:  RLCF   x40,W
08FBE:  CLRF   03
08FC0:  ADDLW  96
08FC2:  MOVWF  FE9
08FC4:  MOVLW  07
08FC6:  ADDWFC 03,W
08FC8:  MOVWF  FEA
08FCA:  MOVFF  FEC,8F0
08FCE:  MOVF   FED,F
08FD0:  MOVFF  FEF,8EF
08FD4:  MOVLW  6E
08FD6:  MOVLB  8
08FD8:  MOVWF  xEE
08FDA:  MOVLB  0
08FDC:  CALL   4FFC
....................          break; 
08FE0:  BRA    900A
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08FE2:  BCF    FD8.0
08FE4:  MOVLB  7
08FE6:  RLCF   x40,W
08FE8:  CLRF   03
08FEA:  ADDLW  96
08FEC:  MOVWF  FE9
08FEE:  MOVLW  07
08FF0:  ADDWFC 03,W
08FF2:  MOVWF  FEA
08FF4:  MOVFF  FEC,8F0
08FF8:  MOVF   FED,F
08FFA:  MOVFF  FEF,8EF
08FFE:  MOVLW  70
09000:  MOVLB  8
09002:  MOVWF  xEE
09004:  MOVLB  0
09006:  CALL   4FFC
....................          break;          
....................    } 
0900A:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08E42:  MOVLB  8
08E44:  MOVF   xEC,F
08E46:  BNZ   8E64
....................    { 
....................       switch (motor) 
08E48:  MOVLB  7
08E4A:  MOVF   x40,W
08E4C:  XORLW  00
08E4E:  MOVLB  0
08E50:  BZ    8E58
08E52:  XORLW  01
08E54:  BZ    8E5E
08E56:  BRA    8E62
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08E58:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08E5A:  BCF    FF0.3
....................             break; 
08E5C:  BRA    8E62
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08E5E:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08E60:  BCF    FF0.4
....................             break; 
08E62:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08E64:  DECFSZ xEC,W
08E66:  BRA    8ECC
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08E68:  BCF    FD8.0
08E6A:  MOVLB  7
08E6C:  RLCF   x40,W
08E6E:  CLRF   03
08E70:  ADDLW  6A
08E72:  MOVWF  FE9
08E74:  MOVLW  07
08E76:  ADDWFC 03,W
08E78:  MOVWF  FEA
08E7A:  MOVFF  FEC,8EE
08E7E:  MOVF   FED,F
08E80:  MOVFF  FEF,8ED
08E84:  MOVLB  8
08E86:  DECFSZ xED,W
08E88:  BRA    8E98
08E8A:  MOVF   xEE,F
08E8C:  BNZ   8E98
08E8E:  CLRF   xEE
08E90:  CLRF   xED
08E92:  MOVLB  0
08E94:  RCALL  8D92
08E96:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08E98:  BCF    FD8.0
08E9A:  MOVLB  7
08E9C:  RLCF   x40,W
08E9E:  CLRF   03
08EA0:  ADDLW  6A
08EA2:  MOVWF  FE9
08EA4:  MOVLW  07
08EA6:  ADDWFC 03,W
08EA8:  MOVWF  FEA
08EAA:  MOVFF  FEC,8EE
08EAE:  MOVF   FED,F
08EB0:  MOVFF  FEF,8ED
08EB4:  MOVLB  8
08EB6:  MOVF   xED,W
08EB8:  SUBLW  02
08EBA:  BNZ   8ECC
08EBC:  MOVF   xEE,F
08EBE:  BNZ   8ECC
08EC0:  CLRF   xEE
08EC2:  MOVLW  01
08EC4:  MOVWF  xED
08EC6:  MOVLB  0
08EC8:  RCALL  8D92
08ECA:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08ECC:  MOVF   xEC,W
08ECE:  SUBLW  02
08ED0:  BNZ   8F06
08ED2:  BCF    FD8.0
08ED4:  MOVLB  7
08ED6:  RLCF   x40,W
08ED8:  CLRF   03
08EDA:  ADDLW  6A
08EDC:  MOVWF  FE9
08EDE:  MOVLW  07
08EE0:  ADDWFC 03,W
08EE2:  MOVWF  FEA
08EE4:  MOVFF  FEC,8EE
08EE8:  MOVF   FED,F
08EEA:  MOVFF  FEF,8ED
08EEE:  MOVLB  8
08EF0:  MOVF   xED,W
08EF2:  SUBLW  02
08EF4:  BNZ   8F06
08EF6:  MOVF   xEE,F
08EF8:  BNZ   8F06
....................    { 
....................       enable_enc_isr(2);   
08EFA:  CLRF   xEE
08EFC:  MOVLW  02
08EFE:  MOVWF  xED
08F00:  MOVLB  0
08F02:  RCALL  8D92
08F04:  MOVLB  8
....................    } 
08F06:  MOVLB  0
08F08:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08C32:  BCF    FD8.0
08C34:  MOVLB  7
08C36:  RLCF   x40,W
08C38:  CLRF   03
08C3A:  ADDLW  8E
08C3C:  MOVWF  FE9
08C3E:  MOVLW  07
08C40:  ADDWFC 03,W
08C42:  MOVWF  FEA
08C44:  CLRF   FEC
08C46:  MOVF   FED,F
08C48:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08C4A:  BCF    FD8.0
08C4C:  RLCF   x40,W
08C4E:  CLRF   03
08C50:  ADDLW  BB
08C52:  MOVWF  FE9
08C54:  MOVLW  07
08C56:  ADDWFC 03,W
08C58:  MOVWF  FEA
08C5A:  CLRF   FEC
08C5C:  MOVF   FED,F
08C5E:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08C60:  BCF    FD8.0
08C62:  RLCF   x40,W
08C64:  CLRF   03
08C66:  ADDLW  9A
08C68:  MOVWF  FE9
08C6A:  MOVLW  07
08C6C:  ADDWFC 03,W
08C6E:  MOVWF  FEA
08C70:  CLRF   FEC
08C72:  MOVF   FED,F
08C74:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08C76:  BSF    F8E.1
....................    enc_pwr(ON); 
08C78:  MOVLW  01
08C7A:  MOVLB  8
08C7C:  MOVWF  xEC
08C7E:  MOVLB  0
08C80:  RCALL  89F8
....................    delay_ms(100); 
08C82:  MOVLW  64
08C84:  MOVLB  9
08C86:  MOVWF  xEC
08C88:  MOVLB  0
08C8A:  CALL   2938
....................     
....................    switch (motor){ 
08C8E:  MOVLB  7
08C90:  MOVF   x40,W
08C92:  XORLW  00
08C94:  MOVLB  0
08C96:  BZ    8C9E
08C98:  XORLW  01
08C9A:  BZ    8CA2
08C9C:  BRA    8CA4
....................       case 0 : motor_setup1(); 
08C9E:  BRA    8A0C
....................          break; 
08CA0:  BRA    8CA4
....................       case 1 : motor_setup2(); 
08CA2:  BRA    8B1E
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08CA4:  BCF    FD8.0
08CA6:  MOVLB  7
08CA8:  RLCF   x40,W
08CAA:  CLRF   03
08CAC:  ADDLW  8A
08CAE:  MOVWF  FE9
08CB0:  MOVLW  07
08CB2:  ADDWFC 03,W
08CB4:  MOVWF  FEA
08CB6:  MOVFF  FEC,8D9
08CBA:  MOVF   FED,F
08CBC:  MOVFF  FEF,8D8
08CC0:  BCF    FD8.0
08CC2:  RLCF   x40,W
08CC4:  CLRF   03
08CC6:  ADDLW  86
08CC8:  MOVWF  FE9
08CCA:  MOVLW  07
08CCC:  ADDWFC 03,W
08CCE:  MOVWF  FEA
08CD0:  MOVFF  FEC,03
08CD4:  MOVF   FED,F
08CD6:  MOVF   FEF,W
08CD8:  MOVLB  8
08CDA:  SUBWF  xD8,W
08CDC:  BNZ   8CE4
08CDE:  MOVF   03,W
08CE0:  SUBWF  xD9,W
08CE2:  BZ    8D8C
....................       m_way_rst[motor]=m_way[motor]; 
08CE4:  BCF    FD8.0
08CE6:  MOVLB  7
08CE8:  RLCF   x40,W
08CEA:  CLRF   03
08CEC:  ADDLW  8A
08CEE:  MOVWF  01
08CF0:  MOVLW  07
08CF2:  ADDWFC 03,F
08CF4:  MOVLB  8
08CF6:  MOVFF  03,8D9
08CFA:  BCF    FD8.0
08CFC:  MOVLB  7
08CFE:  RLCF   x40,W
08D00:  CLRF   03
08D02:  ADDLW  86
08D04:  MOVWF  FE9
08D06:  MOVLW  07
08D08:  ADDWFC 03,W
08D0A:  MOVWF  FEA
08D0C:  MOVFF  FEC,03
08D10:  MOVF   FED,F
08D12:  MOVFF  FEF,8DA
08D16:  MOVLB  8
08D18:  MOVFF  8D9,FEA
08D1C:  MOVFF  01,FE9
08D20:  MOVFF  03,FEC
08D24:  MOVF   FED,F
08D26:  MOVFF  8DA,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08D2A:  BCF    FD8.0
08D2C:  MOVLB  7
08D2E:  RLCF   x40,W
08D30:  CLRF   03
08D32:  ADDLW  9E
08D34:  MOVWF  01
08D36:  MOVLW  07
08D38:  ADDWFC 03,F
08D3A:  MOVLB  8
08D3C:  MOVFF  03,8D9
08D40:  BCF    FD8.0
08D42:  MOVLB  7
08D44:  RLCF   x40,W
08D46:  CLRF   03
08D48:  ADDLW  66
08D4A:  MOVWF  FE9
08D4C:  MOVLW  07
08D4E:  ADDWFC 03,W
08D50:  MOVWF  FEA
08D52:  MOVFF  FEC,03
08D56:  MOVF   FED,F
08D58:  MOVFF  FEF,8DA
08D5C:  MOVLB  8
08D5E:  MOVFF  8D9,FEA
08D62:  MOVFF  01,FE9
08D66:  MOVFF  03,FEC
08D6A:  MOVF   FED,F
08D6C:  MOVFF  8DA,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08D70:  BCF    FD8.0
08D72:  MOVLB  7
08D74:  RLCF   x40,W
08D76:  CLRF   03
08D78:  ADDLW  66
08D7A:  MOVWF  FE9
08D7C:  MOVLW  07
08D7E:  ADDWFC 03,W
08D80:  MOVWF  FEA
08D82:  CLRF   FEC
08D84:  MOVF   FED,F
08D86:  MOVLW  05
08D88:  MOVWF  FEF
08D8A:  MOVLB  8
....................    } 
08D8C:  MOVLB  0
08D8E:  GOTO   8F0C (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08F0A:  BRA    8C32
....................     
....................    m_comp[motor]=FALSE; 
08F0C:  BCF    FD8.0
08F0E:  MOVLB  7
08F10:  RLCF   x40,W
08F12:  CLRF   03
08F14:  ADDLW  AF
08F16:  MOVWF  FE9
08F18:  MOVLW  07
08F1A:  ADDWFC 03,W
08F1C:  MOVWF  FEA
08F1E:  CLRF   FEC
08F20:  MOVF   FED,F
08F22:  CLRF   FEF
....................     
....................    switch (motor){ 
08F24:  MOVF   x40,W
08F26:  XORLW  00
08F28:  MOVLB  0
08F2A:  BZ    8F32
08F2C:  XORLW  01
08F2E:  BZ    8F44
08F30:  BRA    8F54
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08F32:  MOVLW  B2
08F34:  MOVLB  8
08F36:  MOVWF  xEE
08F38:  CLRF   xF0
08F3A:  CLRF   xEF
08F3C:  MOVLB  0
08F3E:  CALL   4FFC
....................          break; 
08F42:  BRA    8F54
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08F44:  MOVLW  B4
08F46:  MOVLB  8
08F48:  MOVWF  xEE
08F4A:  CLRF   xF0
08F4C:  CLRF   xEF
08F4E:  MOVLB  0
08F50:  CALL   4FFC
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08F54:  MOVLB  7
08F56:  MOVF   x40,W
08F58:  XORLW  00
08F5A:  MOVLB  0
08F5C:  BZ    8F64
08F5E:  XORLW  01
08F60:  BZ    8F68
08F62:  BRA    8F6A
....................       case 0 : output_bit(M1_ENABLE, ON); 
08F64:  BSF    F90.1
....................          break; 
08F66:  BRA    8F6A
....................       case 1 : output_bit(M2_ENABLE, ON); 
08F68:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08F6A:  MOVLW  32
08F6C:  MOVLB  9
08F6E:  MOVWF  xEC
08F70:  MOVLB  0
08F72:  CALL   2938
....................     
....................    set_timer3(STEP_INTERVAL); 
08F76:  MOVLW  F9
08F78:  MOVWF  FB3
08F7A:  MOVLW  C0
08F7C:  MOVWF  FB2
....................    enc_isr(int_mode); 
08F7E:  MOVFF  8D7,8EC
08F82:  RCALL  8E42
....................    clear_interrupt(INT_TIMER3); 
08F84:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08F86:  BCF    FD8.0
08F88:  MOVLB  7
08F8A:  RLCF   x40,W
08F8C:  CLRF   03
08F8E:  ADDLW  92
08F90:  MOVWF  FE9
08F92:  MOVLW  07
08F94:  ADDWFC 03,W
08F96:  MOVWF  FEA
08F98:  CLRF   FEC
08F9A:  MOVF   FED,F
08F9C:  MOVLW  01
08F9E:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08FA0:  BSF    FA0.1
08FA2:  MOVLB  0
08FA4:  GOTO   A21C (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
0862E:  MOVFF  8DA,8E2
08632:  MOVFF  8D9,8E1
08636:  MOVFF  8D8,8E0
0863A:  MOVFF  8D7,8DF
....................    enc_res    = e_cpr[motor]; 
0863E:  BCF    FD8.0
08640:  MOVLB  7
08642:  RLCF   x40,W
08644:  CLRF   03
08646:  ADDLW  5E
08648:  MOVWF  FE9
0864A:  MOVLW  07
0864C:  ADDWFC 03,W
0864E:  MOVWF  FEA
08650:  MOVLB  8
08652:  CLRF   xE6
08654:  CLRF   xE5
08656:  MOVFF  FEC,8E4
0865A:  MOVF   FED,F
0865C:  MOVFF  FEF,8E3
....................    ports      = e_ppr[motor]; 
08660:  BCF    FD8.0
08662:  MOVLB  7
08664:  RLCF   x40,W
08666:  CLRF   03
08668:  ADDLW  62
0866A:  MOVWF  FE9
0866C:  MOVLW  07
0866E:  ADDWFC 03,W
08670:  MOVWF  FEA
08672:  MOVLB  8
08674:  CLRF   xEE
08676:  CLRF   xED
08678:  MOVFF  FEC,8EC
0867C:  MOVF   FED,F
0867E:  MOVFF  FEF,8EB
....................     
....................    enc_res = enc_res * 1000; 
08682:  MOVFF  8E6,9F9
08686:  MOVFF  8E5,9F8
0868A:  MOVFF  8E4,9F7
0868E:  MOVFF  8E3,9F6
08692:  MOVLB  9
08694:  CLRF   xFD
08696:  CLRF   xFC
08698:  MOVLW  03
0869A:  MOVWF  xFB
0869C:  MOVLW  E8
0869E:  MOVWF  xFA
086A0:  MOVLB  0
086A2:  CALL   4818
086A6:  MOVFF  03,8E6
086AA:  MOVFF  02,8E5
086AE:  MOVFF  01,8E4
086B2:  MOVFF  00,8E3
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
086B6:  BCF    FD8.1
086B8:  CLRF   1B
086BA:  BTFSC  FF2.7
086BC:  BSF    1B.7
086BE:  BCF    FF2.7
086C0:  MOVFF  8E6,A4F
086C4:  MOVFF  8E5,A4E
086C8:  MOVFF  8E4,A4D
086CC:  MOVFF  8E3,A4C
086D0:  MOVFF  8EE,A53
086D4:  MOVFF  8ED,A52
086D8:  MOVFF  8EC,A51
086DC:  MOVFF  8EB,A50
086E0:  CALL   1076
086E4:  BTFSC  1B.7
086E6:  BSF    FF2.7
086E8:  MOVFF  03,8DE
086EC:  MOVFF  02,8DD
086F0:  MOVFF  01,8DC
086F4:  MOVFF  00,8DB
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
086F8:  MOVFF  8DA,9F9
086FC:  MOVFF  8D9,9F8
08700:  MOVFF  8D8,9F7
08704:  MOVFF  8D7,9F6
08708:  MOVFF  8DE,9FD
0870C:  MOVFF  8DD,9FC
08710:  MOVFF  8DC,9FB
08714:  MOVFF  8DB,9FA
08718:  CALL   4818
0871C:  MOVLB  8
0871E:  MOVF   xDB,W
08720:  SUBWF  00,W
08722:  MOVWF  xDF
08724:  MOVF   xDC,W
08726:  SUBWFB 01,W
08728:  MOVWF  xE0
0872A:  MOVF   xDD,W
0872C:  SUBWFB 02,W
0872E:  MOVWF  xE1
08730:  MOVF   xDE,W
08732:  SUBWFB 03,W
08734:  MOVWF  xE2
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
08736:  BCF    FD8.1
08738:  CLRF   1B
0873A:  BTFSC  FF2.7
0873C:  BSF    1B.7
0873E:  BCF    FF2.7
08740:  MOVFF  8E2,A4F
08744:  MOVFF  8E1,A4E
08748:  MOVFF  8E0,A4D
0874C:  MOVFF  8DF,A4C
08750:  MOVLB  A
08752:  CLRF   x53
08754:  CLRF   x52
08756:  MOVLW  03
08758:  MOVWF  x51
0875A:  MOVLW  E8
0875C:  MOVWF  x50
0875E:  MOVLB  0
08760:  CALL   1076
08764:  BTFSC  1B.7
08766:  BSF    FF2.7
08768:  MOVFF  03,8EA
0876C:  MOVFF  02,8E9
08770:  MOVFF  01,8E8
08774:  MOVFF  00,8E7
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
08778:  MOVFF  8EA,9F9
0877C:  MOVFF  8E9,9F8
08780:  MOVFF  8E8,9F7
08784:  MOVFF  8E7,9F6
08788:  MOVLB  9
0878A:  CLRF   xFD
0878C:  CLRF   xFC
0878E:  MOVLW  03
08790:  MOVWF  xFB
08792:  MOVLW  E8
08794:  MOVWF  xFA
08796:  MOVLB  0
08798:  CALL   4818
0879C:  MOVFF  03,8EA
087A0:  MOVFF  02,8E9
087A4:  MOVFF  01,8E8
087A8:  MOVFF  00,8E7
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
087AC:  MOVLB  8
087AE:  MOVF   xE7,W
087B0:  SUBWF  xDF,F
087B2:  MOVF   xE8,W
087B4:  SUBWFB xE0,F
087B6:  MOVF   xE9,W
087B8:  SUBWFB xE1,F
087BA:  MOVF   xEA,W
087BC:  SUBWFB xE2,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
087BE:  BCF    FD8.1
087C0:  CLRF   1B
087C2:  BTFSC  FF2.7
087C4:  BSF    1B.7
087C6:  BCF    FF2.7
087C8:  MOVFF  8EA,A4F
087CC:  MOVFF  8E9,A4E
087D0:  MOVFF  8E8,A4D
087D4:  MOVFF  8E7,A4C
087D8:  MOVLB  A
087DA:  CLRF   x53
087DC:  CLRF   x52
087DE:  MOVLW  03
087E0:  MOVWF  x51
087E2:  MOVLW  E8
087E4:  MOVWF  x50
087E6:  MOVLB  0
087E8:  CALL   1076
087EC:  BTFSC  1B.7
087EE:  BSF    FF2.7
087F0:  MOVFF  03,8EA
087F4:  MOVFF  02,8E9
087F8:  MOVFF  01,8E8
087FC:  MOVFF  00,8E7
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
08800:  MOVLB  8
08802:  MOVF   xE2,F
08804:  BNZ   881A
08806:  MOVF   xE1,F
08808:  BNZ   881A
0880A:  MOVF   xE0,W
0880C:  SUBLW  00
0880E:  BC    882A
08810:  XORLW  FF
08812:  BNZ   881A
08814:  MOVF   xDF,W
08816:  SUBLW  F3
08818:  BC    882A
0881A:  MOVLW  01
0881C:  ADDWF  xE7,F
0881E:  BTFSC  FD8.0
08820:  INCF   xE8,F
08822:  BTFSC  FD8.2
08824:  INCF   xE9,F
08826:  BTFSC  FD8.2
08828:  INCF   xEA,F
....................    return(enc_pos); 
0882A:  MOVFF  8E7,00
0882E:  MOVFF  8E8,01
08832:  MOVFF  8E9,02
08836:  MOVFF  8EA,03
0883A:  MOVLB  0
0883C:  GOTO   A1A4 (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
08840:  BCF    FD8.0
08842:  MOVLB  7
08844:  RLCF   x40,W
08846:  CLRF   03
08848:  ADDLW  BF
0884A:  MOVWF  FE9
0884C:  MOVLW  07
0884E:  ADDWFC 03,W
08850:  MOVWF  FEA
08852:  MOVFF  FEC,03
08856:  MOVF   FED,F
08858:  MOVFF  FEF,01
0885C:  MOVF   03,W
0885E:  MOVLB  8
08860:  SUBWF  xDA,W
08862:  BNC   892A
08864:  BNZ   886C
08866:  MOVF   xD9,W
08868:  SUBWF  01,W
0886A:  BC    892A
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
0886C:  BCF    FD8.0
0886E:  MOVLB  7
08870:  RLCF   x40,W
08872:  CLRF   03
08874:  ADDLW  BF
08876:  MOVWF  FE9
08878:  MOVLW  07
0887A:  ADDWFC 03,W
0887C:  MOVWF  FEA
0887E:  MOVFF  FEC,03
08882:  MOVF   FED,F
08884:  MOVF   FEF,W
08886:  MOVLB  8
08888:  SUBWF  xD9,W
0888A:  MOVWF  xDB
0888C:  MOVF   03,W
0888E:  SUBWFB xDA,W
08890:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
08892:  BCF    FD8.0
08894:  MOVLB  7
08896:  RLCF   x40,W
08898:  CLRF   03
0889A:  ADDLW  5E
0889C:  MOVWF  FE9
0889E:  MOVLW  07
088A0:  ADDWFC 03,W
088A2:  MOVWF  FEA
088A4:  MOVFF  FEC,8DE
088A8:  MOVF   FED,F
088AA:  MOVFF  FEF,8DD
088AE:  BCF    FD8.0
088B0:  MOVLB  8
088B2:  RRCF   xDE,W
088B4:  MOVWF  03
088B6:  RRCF   xDD,W
088B8:  MOVWF  02
088BA:  MOVWF  01
088BC:  MOVF   03,W
088BE:  SUBWF  xDC,W
088C0:  BNC   890E
088C2:  BNZ   88CA
088C4:  MOVF   xDB,W
088C6:  SUBWF  01,W
088C8:  BC    890E
....................       { 
....................          m_way[motor] = NEG; 
088CA:  BCF    FD8.0
088CC:  MOVLB  7
088CE:  RLCF   x40,W
088D0:  CLRF   03
088D2:  ADDLW  86
088D4:  MOVWF  FE9
088D6:  MOVLW  07
088D8:  ADDWFC 03,W
088DA:  MOVWF  FEA
088DC:  CLRF   FEC
088DE:  MOVF   FED,F
088E0:  MOVLW  01
088E2:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088E4:  BCF    FD8.0
088E6:  RLCF   x40,W
088E8:  CLRF   03
088EA:  ADDLW  5E
088EC:  MOVWF  FE9
088EE:  MOVLW  07
088F0:  ADDWFC 03,W
088F2:  MOVWF  FEA
088F4:  MOVFF  FEC,8DE
088F8:  MOVF   FED,F
088FA:  MOVFF  FEF,8DD
088FE:  MOVLB  8
08900:  MOVF   xDB,W
08902:  SUBWF  xDD,W
08904:  MOVWF  xDB
08906:  MOVF   xDC,W
08908:  SUBWFB xDE,W
0890A:  MOVWF  xDC
....................       } 
0890C:  BRA    8928
....................       else 
....................       { 
....................          m_way[motor] = POS; 
0890E:  BCF    FD8.0
08910:  MOVLB  7
08912:  RLCF   x40,W
08914:  CLRF   03
08916:  ADDLW  86
08918:  MOVWF  FE9
0891A:  MOVLW  07
0891C:  ADDWFC 03,W
0891E:  MOVWF  FEA
08920:  CLRF   FEC
08922:  MOVF   FED,F
08924:  CLRF   FEF
08926:  MOVLB  8
....................       } 
....................    } 
08928:  BRA    89EA
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
0892A:  BCF    FD8.0
0892C:  MOVLB  7
0892E:  RLCF   x40,W
08930:  CLRF   03
08932:  ADDLW  BF
08934:  MOVWF  FE9
08936:  MOVLW  07
08938:  ADDWFC 03,W
0893A:  MOVWF  FEA
0893C:  MOVFF  FEC,8DE
08940:  MOVF   FED,F
08942:  MOVFF  FEF,8DD
08946:  MOVLB  8
08948:  MOVF   xD9,W
0894A:  SUBWF  xDD,W
0894C:  MOVWF  xDB
0894E:  MOVF   xDA,W
08950:  SUBWFB xDE,W
08952:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
08954:  BCF    FD8.0
08956:  MOVLB  7
08958:  RLCF   x40,W
0895A:  CLRF   03
0895C:  ADDLW  5E
0895E:  MOVWF  FE9
08960:  MOVLW  07
08962:  ADDWFC 03,W
08964:  MOVWF  FEA
08966:  MOVFF  FEC,8DE
0896A:  MOVF   FED,F
0896C:  MOVFF  FEF,8DD
08970:  BCF    FD8.0
08972:  MOVLB  8
08974:  RRCF   xDE,W
08976:  MOVWF  03
08978:  RRCF   xDD,W
0897A:  MOVWF  02
0897C:  MOVWF  01
0897E:  MOVF   03,W
08980:  SUBWF  xDC,W
08982:  BNC   89CE
08984:  BNZ   898C
08986:  MOVF   xDB,W
08988:  SUBWF  01,W
0898A:  BC    89CE
....................       { 
....................          m_way[motor] = POS; 
0898C:  BCF    FD8.0
0898E:  MOVLB  7
08990:  RLCF   x40,W
08992:  CLRF   03
08994:  ADDLW  86
08996:  MOVWF  FE9
08998:  MOVLW  07
0899A:  ADDWFC 03,W
0899C:  MOVWF  FEA
0899E:  CLRF   FEC
089A0:  MOVF   FED,F
089A2:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
089A4:  BCF    FD8.0
089A6:  RLCF   x40,W
089A8:  CLRF   03
089AA:  ADDLW  5E
089AC:  MOVWF  FE9
089AE:  MOVLW  07
089B0:  ADDWFC 03,W
089B2:  MOVWF  FEA
089B4:  MOVFF  FEC,8DE
089B8:  MOVF   FED,F
089BA:  MOVFF  FEF,8DD
089BE:  MOVLB  8
089C0:  MOVF   xDB,W
089C2:  SUBWF  xDD,W
089C4:  MOVWF  xDB
089C6:  MOVF   xDC,W
089C8:  SUBWFB xDE,W
089CA:  MOVWF  xDC
....................       } 
089CC:  BRA    89EA
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
089CE:  BCF    FD8.0
089D0:  MOVLB  7
089D2:  RLCF   x40,W
089D4:  CLRF   03
089D6:  ADDLW  86
089D8:  MOVWF  FE9
089DA:  MOVLW  07
089DC:  ADDWFC 03,W
089DE:  MOVWF  FEA
089E0:  CLRF   FEC
089E2:  MOVF   FED,F
089E4:  MOVLW  01
089E6:  MOVWF  FEF
089E8:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
089EA:  MOVFF  8DB,01
089EE:  MOVFF  8DC,02
089F2:  MOVLB  0
089F4:  GOTO   A1D0 (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
090F8:  BCF    FD8.0
090FA:  MOVLB  7
090FC:  RLCF   x40,W
090FE:  CLRF   03
09100:  ADDLW  92
09102:  MOVWF  FE9
09104:  MOVLW  07
09106:  ADDWFC 03,W
09108:  MOVWF  FEA
0910A:  CLRF   FEC
0910C:  MOVF   FED,F
0910E:  CLRF   FEF
....................           
....................    switch (motor){ 
09110:  MOVF   x40,W
09112:  XORLW  00
09114:  MOVLB  0
09116:  BZ    911E
09118:  XORLW  01
0911A:  BZ    9188
0911C:  BRA    91F6
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
0911E:  BCF    FD8.0
09120:  MOVLB  7
09122:  RLCF   x40,W
09124:  CLRF   03
09126:  ADDLW  52
09128:  MOVWF  FE9
0912A:  MOVLW  07
0912C:  ADDWFC 03,W
0912E:  MOVWF  FEA
09130:  MOVFF  FEC,8ED
09134:  MOVF   FED,F
09136:  MOVFF  FEF,8EC
0913A:  MOVLB  8
0913C:  MOVF   xEC,F
0913E:  BNZ   9144
09140:  MOVF   xED,F
09142:  BZ    9182
09144:  BCF    FD8.0
09146:  MOVLB  7
09148:  RLCF   x40,W
0914A:  CLRF   03
0914C:  ADDLW  52
0914E:  MOVWF  FE9
09150:  MOVLW  07
09152:  ADDWFC 03,W
09154:  MOVWF  FEA
09156:  MOVFF  FEC,8ED
0915A:  MOVF   FED,F
0915C:  MOVFF  FEF,8EC
09160:  MOVLB  8
09162:  RRCF   xED,F
09164:  RRCF   xEC,F
09166:  RRCF   xED,F
09168:  RRCF   xEC,F
0916A:  RRCF   xED,F
0916C:  MOVFF  8EC,FBC
09170:  RRCF   xED,F
09172:  RRCF   xED,W
09174:  ANDLW  30
09176:  MOVWF  00
09178:  MOVF   FBB,W
0917A:  ANDLW  CF
0917C:  IORWF  00,W
0917E:  MOVWF  FBB
09180:  BRA    9184
....................                else output_bit(M1_ENABLE, OFF); 
09182:  BCF    F90.1
....................          break;   
09184:  MOVLB  0
09186:  BRA    91F6
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
09188:  BCF    FD8.0
0918A:  MOVLB  7
0918C:  RLCF   x40,W
0918E:  CLRF   03
09190:  ADDLW  52
09192:  MOVWF  FE9
09194:  MOVLW  07
09196:  ADDWFC 03,W
09198:  MOVWF  FEA
0919A:  MOVFF  FEC,8ED
0919E:  MOVF   FED,F
091A0:  MOVFF  FEF,8EC
091A4:  MOVLB  8
091A6:  MOVF   xEC,F
091A8:  BNZ   91AE
091AA:  MOVF   xED,F
091AC:  BZ    91F0
091AE:  BCF    FD8.0
091B0:  MOVLB  7
091B2:  RLCF   x40,W
091B4:  CLRF   03
091B6:  ADDLW  52
091B8:  MOVWF  FE9
091BA:  MOVLW  07
091BC:  ADDWFC 03,W
091BE:  MOVWF  FEA
091C0:  MOVFF  FEC,8ED
091C4:  MOVF   FED,F
091C6:  MOVFF  FEF,8EC
091CA:  MOVLB  8
091CC:  RRCF   xED,F
091CE:  RRCF   xEC,F
091D0:  RRCF   xED,F
091D2:  RRCF   xEC,F
091D4:  RRCF   xED,F
091D6:  MOVFF  8EC,F4F
091DA:  RRCF   xED,F
091DC:  RRCF   xED,W
091DE:  ANDLW  30
091E0:  MOVWF  00
091E2:  MOVLB  F
091E4:  MOVF   x4E,W
091E6:  ANDLW  CF
091E8:  IORWF  00,W
091EA:  MOVWF  x4E
091EC:  BRA    91F4
091EE:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
091F0:  BCF    F8D.1
091F2:  MOVLB  F
....................          break; 
091F4:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
091F6:  BCF    FA0.1
....................    enc_isr(OFF); 
091F8:  MOVLB  8
091FA:  CLRF   xEC
091FC:  MOVLB  0
091FE:  RCALL  8E42
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
09200:  MOVLB  7
09202:  MOVF   x52,F
09204:  BNZ   9214
09206:  MOVF   x53,F
09208:  BNZ   9214
0920A:  MOVF   x54,F
0920C:  BNZ   9214
0920E:  MOVF   x55,F
09210:  BNZ   9214
....................    { 
....................       output_bit(VMOT,OFF); 
09212:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
09214:  MOVLB  8
09216:  CLRF   xEC
09218:  MOVLB  0
0921A:  CALL   89F8
....................  
....................    if(success==TRUE) 
0921E:  MOVLB  8
09220:  DECFSZ xEB,W
09222:  BRA    93BE
....................    { 
....................       m_error[motor]=FALSE; 
09224:  BCF    FD8.0
09226:  MOVLB  7
09228:  RLCF   x40,W
0922A:  CLRF   03
0922C:  ADDLW  96
0922E:  MOVWF  FE9
09230:  MOVLW  07
09232:  ADDWFC 03,W
09234:  MOVWF  FEA
09236:  CLRF   FEC
09238:  MOVF   FED,F
0923A:  CLRF   FEF
....................       wrt_m_error(); 
0923C:  MOVLB  0
0923E:  RCALL  8FA8
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
09240:  BCF    FD8.0
09242:  MOVLB  7
09244:  RLCF   x40,W
09246:  CLRF   03
09248:  ADDLW  66
0924A:  MOVWF  FE9
0924C:  MOVLW  07
0924E:  ADDWFC 03,W
09250:  MOVWF  FEA
09252:  MOVFF  FEC,8ED
09256:  MOVF   FED,F
09258:  MOVFF  FEF,8EC
0925C:  MOVLB  8
0925E:  MOVF   xEC,W
09260:  SUBLW  03
09262:  BNZ   929A
09264:  MOVF   xED,F
09266:  BNZ   929A
....................       { 
....................          e_pos[motor] = 0; 
09268:  BCF    FD8.0
0926A:  MOVLB  7
0926C:  RLCF   x40,W
0926E:  CLRF   03
09270:  ADDLW  BF
09272:  MOVWF  FE9
09274:  MOVLW  07
09276:  ADDWFC 03,W
09278:  MOVWF  FEA
0927A:  CLRF   FEC
0927C:  MOVF   FED,F
0927E:  CLRF   FEF
....................          e_port[motor] = 1; 
09280:  BCF    FD8.0
09282:  RLCF   x40,W
09284:  CLRF   03
09286:  ADDLW  C3
09288:  MOVWF  FE9
0928A:  MOVLW  07
0928C:  ADDWFC 03,W
0928E:  MOVWF  FEA
09290:  CLRF   FEC
09292:  MOVF   FED,F
09294:  MOVLW  01
09296:  MOVWF  FEF
09298:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
0929A:  BCF    FD8.0
0929C:  MOVLB  7
0929E:  RLCF   x40,W
092A0:  CLRF   03
092A2:  ADDLW  66
092A4:  MOVWF  FE9
092A6:  MOVLW  07
092A8:  ADDWFC 03,W
092AA:  MOVWF  FEA
092AC:  MOVFF  FEC,8ED
092B0:  MOVF   FED,F
092B2:  MOVFF  FEF,8EC
092B6:  MOVLB  8
092B8:  MOVF   xEC,W
092BA:  SUBLW  02
092BC:  BNZ   9308
092BE:  MOVF   xED,F
092C0:  BNZ   9308
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
092C2:  BCF    FD8.0
092C4:  MOVLB  7
092C6:  RLCF   x40,W
092C8:  CLRF   03
092CA:  ADDLW  C3
092CC:  MOVWF  01
092CE:  MOVLW  07
092D0:  ADDWFC 03,F
092D2:  MOVLB  8
092D4:  MOVFF  03,8ED
092D8:  BCF    FD8.0
092DA:  MOVLB  7
092DC:  RLCF   x40,W
092DE:  CLRF   03
092E0:  ADDLW  C7
092E2:  MOVWF  FE9
092E4:  MOVLW  07
092E6:  ADDWFC 03,W
092E8:  MOVWF  FEA
092EA:  MOVFF  FEC,03
092EE:  MOVF   FED,F
092F0:  MOVFF  FEF,8EE
092F4:  MOVLB  8
092F6:  MOVFF  8ED,FEA
092FA:  MOVFF  01,FE9
092FE:  MOVFF  03,FEC
09302:  MOVF   FED,F
09304:  MOVFF  8EE,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
09308:  BCF    FD8.0
0930A:  MOVLB  7
0930C:  RLCF   x40,W
0930E:  CLRF   03
09310:  ADDLW  66
09312:  MOVWF  FE9
09314:  MOVLW  07
09316:  ADDWFC 03,W
09318:  MOVWF  FEA
0931A:  MOVFF  FEC,8ED
0931E:  MOVF   FED,F
09320:  MOVFF  FEF,8EC
09324:  MOVLB  8
09326:  MOVF   xEC,W
09328:  SUBLW  02
0932A:  BNZ   9330
0932C:  MOVF   xED,F
0932E:  BZ    9358
09330:  BCF    FD8.0
09332:  MOVLB  7
09334:  RLCF   x40,W
09336:  CLRF   03
09338:  ADDLW  66
0933A:  MOVWF  FE9
0933C:  MOVLW  07
0933E:  ADDWFC 03,W
09340:  MOVWF  FEA
09342:  MOVFF  FEC,8ED
09346:  MOVF   FED,F
09348:  MOVFF  FEF,8EC
0934C:  MOVLB  8
0934E:  MOVF   xEC,W
09350:  SUBLW  03
09352:  BNZ   93BC
09354:  MOVF   xED,F
09356:  BNZ   93BC
....................       { 
....................          switch(motor) 
09358:  MOVLB  7
0935A:  MOVF   x40,W
0935C:  XORLW  00
0935E:  MOVLB  0
09360:  BZ    9368
09362:  XORLW  01
09364:  BZ    9392
09366:  BRA    93BA
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09368:  MOVLW  7E
0936A:  MOVLB  8
0936C:  MOVWF  xEE
0936E:  MOVFF  7C0,8F0
09372:  MOVFF  7BF,8EF
09376:  MOVLB  0
09378:  CALL   4FFC
....................                      write16(ADDR_E1_PORT,e_port[0]); 
0937C:  MOVLW  AA
0937E:  MOVLB  8
09380:  MOVWF  xEE
09382:  MOVFF  7C4,8F0
09386:  MOVFF  7C3,8EF
0938A:  MOVLB  0
0938C:  CALL   4FFC
....................                break; 
09390:  BRA    93BA
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
09392:  MOVLW  80
09394:  MOVLB  8
09396:  MOVWF  xEE
09398:  MOVFF  7C2,8F0
0939C:  MOVFF  7C1,8EF
093A0:  MOVLB  0
093A2:  CALL   4FFC
....................                      write16(ADDR_E2_PORT,e_port[1]); 
093A6:  MOVLW  AC
093A8:  MOVLB  8
093AA:  MOVWF  xEE
093AC:  MOVFF  7C6,8F0
093B0:  MOVFF  7C5,8EF
093B4:  MOVLB  0
093B6:  CALL   4FFC
....................                break;             
093BA:  MOVLB  8
....................          } 
....................       } 
....................    } 
093BC:  BRA    9466
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
093BE:  BCF    FD8.0
093C0:  MOVLB  7
093C2:  RLCF   x40,W
093C4:  CLRF   03
093C6:  ADDLW  96
093C8:  MOVWF  FE9
093CA:  MOVLW  07
093CC:  ADDWFC 03,W
093CE:  MOVWF  FEA
093D0:  CLRF   FEC
093D2:  MOVF   FED,F
093D4:  MOVLW  01
093D6:  MOVWF  FEF
....................       e_pos[motor] = 0; 
093D8:  BCF    FD8.0
093DA:  RLCF   x40,W
093DC:  CLRF   03
093DE:  ADDLW  BF
093E0:  MOVWF  FE9
093E2:  MOVLW  07
093E4:  ADDWFC 03,W
093E6:  MOVWF  FEA
093E8:  CLRF   FEC
093EA:  MOVF   FED,F
093EC:  CLRF   FEF
....................       e_port[motor] = 0; 
093EE:  BCF    FD8.0
093F0:  RLCF   x40,W
093F2:  CLRF   03
093F4:  ADDLW  C3
093F6:  MOVWF  FE9
093F8:  MOVLW  07
093FA:  ADDWFC 03,W
093FC:  MOVWF  FEA
093FE:  CLRF   FEC
09400:  MOVF   FED,F
09402:  CLRF   FEF
....................       switch(motor) 
09404:  MOVF   x40,W
09406:  XORLW  00
09408:  MOVLB  0
0940A:  BZ    9412
0940C:  XORLW  01
0940E:  BZ    943C
09410:  BRA    9464
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09412:  MOVLW  7E
09414:  MOVLB  8
09416:  MOVWF  xEE
09418:  MOVFF  7C0,8F0
0941C:  MOVFF  7BF,8EF
09420:  MOVLB  0
09422:  CALL   4FFC
....................                   write16(ADDR_E1_PORT,e_port[0]); 
09426:  MOVLW  AA
09428:  MOVLB  8
0942A:  MOVWF  xEE
0942C:  MOVFF  7C4,8F0
09430:  MOVFF  7C3,8EF
09434:  MOVLB  0
09436:  CALL   4FFC
....................             break; 
0943A:  BRA    9464
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
0943C:  MOVLW  80
0943E:  MOVLB  8
09440:  MOVWF  xEE
09442:  MOVFF  7C2,8F0
09446:  MOVFF  7C1,8EF
0944A:  MOVLB  0
0944C:  CALL   4FFC
....................                   write16(ADDR_E2_PORT,e_port[1]); 
09450:  MOVLW  AC
09452:  MOVLB  8
09454:  MOVWF  xEE
09456:  MOVFF  7C6,8F0
0945A:  MOVFF  7C5,8EF
0945E:  MOVLB  0
09460:  CALL   4FFC
....................             break;             
09464:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
09466:  BCF    FD8.0
09468:  MOVLB  7
0946A:  RLCF   x40,W
0946C:  CLRF   03
0946E:  ADDLW  AF
09470:  MOVWF  FE9
09472:  MOVLW  07
09474:  ADDWFC 03,W
09476:  MOVWF  FEA
09478:  CLRF   FEC
0947A:  MOVF   FED,F
0947C:  MOVLW  01
0947E:  MOVWF  FEF
....................     
....................    switch (motor) 
09480:  MOVF   x40,W
09482:  XORLW  00
09484:  MOVLB  0
09486:  BZ    948E
09488:  XORLW  01
0948A:  BZ    94B6
0948C:  BRA    94DC
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
0948E:  MOVLW  B2
09490:  MOVLB  8
09492:  MOVWF  xEE
09494:  CLRF   xF0
09496:  MOVLW  01
09498:  MOVWF  xEF
0949A:  MOVLB  0
0949C:  CALL   4FFC
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
094A0:  MOVLW  B6
094A2:  MOVLB  8
094A4:  MOVWF  xEE
094A6:  MOVFF  7B4,8F0
094AA:  MOVFF  7B3,8EF
094AE:  MOVLB  0
094B0:  CALL   4FFC
....................          break; 
094B4:  BRA    94DC
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
094B6:  MOVLW  B4
094B8:  MOVLB  8
094BA:  MOVWF  xEE
094BC:  CLRF   xF0
094BE:  MOVLW  01
094C0:  MOVWF  xEF
094C2:  MOVLB  0
094C4:  CALL   4FFC
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
094C8:  MOVLW  B8
094CA:  MOVLB  8
094CC:  MOVWF  xEE
094CE:  MOVFF  7B6,8F0
094D2:  MOVFF  7B5,8EF
094D6:  MOVLB  0
094D8:  CALL   4FFC
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
094DC:  MOVF   1F,W
094DE:  SUBLW  04
094E0:  BNZ   9586
094E2:  MOVF   20,F
094E4:  BNZ   9586
....................    { 
....................       if(motor==1) 
094E6:  MOVLB  7
094E8:  DECFSZ x40,W
094EA:  BRA    9588
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
094EC:  BCF    FD8.0
094EE:  RLCF   x40,W
094F0:  CLRF   03
094F2:  ADDLW  AF
094F4:  MOVWF  FE9
094F6:  MOVLW  07
094F8:  ADDWFC 03,W
094FA:  MOVWF  FEA
094FC:  MOVFF  FEC,8ED
09500:  MOVF   FED,F
09502:  MOVFF  FEF,8EC
09506:  BCF    FD8.0
09508:  RLCF   x40,W
0950A:  CLRF   03
0950C:  ADDLW  B3
0950E:  MOVWF  FE9
09510:  MOVLW  07
09512:  ADDWFC 03,W
09514:  MOVWF  FEA
09516:  MOVFF  FEC,8EF
0951A:  MOVF   FED,F
0951C:  MOVFF  FEF,8EE
09520:  MOVLW  7E
09522:  MOVWF  FF6
09524:  MOVLW  1A
09526:  MOVWF  FF7
09528:  MOVLW  00
0952A:  MOVWF  FF8
0952C:  CLRF   1B
0952E:  BTFSC  FF2.7
09530:  BSF    1B.7
09532:  BCF    FF2.7
09534:  MOVLW  05
09536:  MOVLB  A
09538:  MOVWF  x40
0953A:  MOVLB  0
0953C:  CALL   1044
09540:  BTFSC  1B.7
09542:  BSF    FF2.7
09544:  MOVLW  10
09546:  MOVWF  FE9
09548:  CLRF   1B
0954A:  BTFSC  FF2.7
0954C:  BSF    1B.7
0954E:  BCF    FF2.7
09550:  MOVFF  8ED,A41
09554:  MOVFF  8EC,A40
09558:  CALL   11C6
0955C:  BTFSC  1B.7
0955E:  BSF    FF2.7
09560:  MOVLW  2C
09562:  BTFSS  F9E.4
09564:  BRA    9562
09566:  MOVWF  FAD
09568:  MOVLW  10
0956A:  MOVWF  FE9
0956C:  MOVFF  8EF,8F1
09570:  MOVFF  8EE,8F0
09574:  RCALL  900C
09576:  MOVLW  0D
09578:  BTFSS  F9E.4
0957A:  BRA    9578
0957C:  MOVWF  FAD
0957E:  MOVLW  0A
09580:  BTFSS  F9E.4
09582:  BRA    9580
09584:  MOVWF  FAD
09586:  MOVLB  7
....................       } 
....................    } 
09588:  MOVLB  0
0958A:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
096B8:  BCF    FD8.0
096BA:  MOVLB  7
096BC:  RLCF   x40,W
096BE:  CLRF   03
096C0:  ADDLW  6A
096C2:  MOVWF  FE9
096C4:  MOVLW  07
096C6:  ADDWFC 03,W
096C8:  MOVWF  FEA
096CA:  MOVFF  FEC,8EC
096CE:  MOVF   FED,F
096D0:  MOVFF  FEF,8EB
096D4:  MOVLB  8
096D6:  DECFSZ xEB,W
096D8:  BRA    96E8
096DA:  MOVF   xEC,F
096DC:  BNZ   96E8
096DE:  MOVLW  01
096E0:  MOVWF  xEB
096E2:  MOVLB  0
096E4:  RCALL  90F8
096E6:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
096E8:  BCF    FD8.0
096EA:  MOVLB  7
096EC:  RLCF   x40,W
096EE:  CLRF   03
096F0:  ADDLW  6A
096F2:  MOVWF  FE9
096F4:  MOVLW  07
096F6:  ADDWFC 03,W
096F8:  MOVWF  FEA
096FA:  MOVFF  FEC,8EC
096FE:  MOVF   FED,F
09700:  MOVFF  FEF,8EB
09704:  MOVLB  8
09706:  MOVF   xEB,W
09708:  SUBLW  02
0970A:  BTFSS  FD8.2
0970C:  BRA    9D16
0970E:  MOVF   xEC,F
09710:  BTFSS  FD8.2
09712:  BRA    9D16
....................       if (e_mode[motor]==2){ 
09714:  BCF    FD8.0
09716:  MOVLB  7
09718:  RLCF   x40,W
0971A:  CLRF   03
0971C:  ADDLW  66
0971E:  MOVWF  FE9
09720:  MOVLW  07
09722:  ADDWFC 03,W
09724:  MOVWF  FEA
09726:  MOVFF  FEC,8EC
0972A:  MOVF   FED,F
0972C:  MOVFF  FEF,8EB
09730:  MOVLB  8
09732:  MOVF   xEB,W
09734:  SUBLW  02
09736:  BTFSS  FD8.2
09738:  BRA    9C92
0973A:  MOVF   xEC,F
0973C:  BTFSS  FD8.2
0973E:  BRA    9C92
....................          if(nv_product==ECO || nv_product==WMS2){ 
09740:  MOVF   2F,F
09742:  BNZ   9748
09744:  MOVF   30,F
09746:  BZ    9756
09748:  MOVF   2F,W
0974A:  SUBLW  03
0974C:  BTFSS  FD8.2
0974E:  BRA    989A
09750:  MOVF   30,F
09752:  BTFSS  FD8.2
09754:  BRA    989A
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
09756:  BCF    FD8.0
09758:  MOVLB  7
0975A:  RLCF   x40,W
0975C:  CLRF   03
0975E:  ADDLW  AB
09760:  MOVWF  FE9
09762:  MOVLW  07
09764:  ADDWFC 03,W
09766:  MOVWF  FEA
09768:  MOVFF  FEC,9F7
0976C:  MOVF   FED,F
0976E:  MOVFF  FEF,9F6
09772:  MOVFF  FEA,8EE
09776:  MOVFF  FE9,8ED
0977A:  MOVLB  9
0977C:  CLRF   xF9
0977E:  CLRF   xF8
09780:  MOVFF  8DC,9FD
09784:  MOVFF  8DB,9FC
09788:  MOVFF  8DA,9FB
0978C:  MOVFF  8D9,9FA
09790:  MOVLB  0
09792:  CALL   4818
09796:  MOVFF  8EE,FEA
0979A:  MOVFF  8ED,FE9
0979E:  MOVFF  03,8EE
097A2:  MOVFF  02,8ED
097A6:  MOVFF  01,8EC
097AA:  MOVFF  00,8EB
097AE:  BCF    FD8.0
097B0:  MOVLB  7
097B2:  RLCF   x40,W
097B4:  CLRF   03
097B6:  ADDLW  AB
097B8:  MOVWF  FE9
097BA:  MOVLW  07
097BC:  ADDWFC 03,W
097BE:  MOVWF  FEA
097C0:  MOVFF  FEC,8F0
097C4:  MOVF   FED,F
097C6:  MOVFF  FEF,8EF
097CA:  BCF    FD8.0
097CC:  MOVLB  8
097CE:  RRCF   xF0,W
097D0:  MOVWF  03
097D2:  RRCF   xEF,W
097D4:  MOVWF  02
097D6:  ADDWF  00,W
097D8:  MOVWF  00
097DA:  MOVF   03,W
097DC:  ADDWFC 01,W
097DE:  MOVWF  01
097E0:  MOVLW  00
097E2:  ADDWFC xED,W
097E4:  MOVWF  02
097E6:  MOVLW  00
097E8:  ADDWFC xEE,W
097EA:  MOVWF  xE6
097EC:  MOVFF  02,8E5
097F0:  MOVFF  01,8E4
097F4:  MOVFF  00,8E3
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
097F8:  BCF    FD8.0
097FA:  MOVLB  7
097FC:  RLCF   x40,W
097FE:  CLRF   03
09800:  ADDLW  AB
09802:  MOVWF  FE9
09804:  MOVLW  07
09806:  ADDWFC 03,W
09808:  MOVWF  FEA
0980A:  MOVFF  FEC,9F7
0980E:  MOVF   FED,F
09810:  MOVFF  FEF,9F6
09814:  MOVFF  FEA,8EE
09818:  MOVFF  FE9,8ED
0981C:  MOVLB  9
0981E:  CLRF   xF9
09820:  CLRF   xF8
09822:  MOVFF  8DC,9FD
09826:  MOVFF  8DB,9FC
0982A:  MOVFF  8DA,9FB
0982E:  MOVFF  8D9,9FA
09832:  MOVLB  0
09834:  CALL   4818
09838:  MOVFF  8EE,FEA
0983C:  MOVFF  8ED,FE9
09840:  MOVFF  03,8EE
09844:  MOVFF  02,8ED
09848:  MOVFF  01,8EC
0984C:  MOVFF  00,8EB
09850:  BCF    FD8.0
09852:  MOVLB  7
09854:  RLCF   x40,W
09856:  CLRF   03
09858:  ADDLW  AB
0985A:  MOVWF  FE9
0985C:  MOVLW  07
0985E:  ADDWFC 03,W
09860:  MOVWF  FEA
09862:  MOVFF  FEC,8F0
09866:  MOVF   FED,F
09868:  MOVFF  FEF,8EF
0986C:  BCF    FD8.0
0986E:  MOVLB  8
09870:  RRCF   xF0,W
09872:  MOVWF  03
09874:  RRCF   xEF,W
09876:  MOVWF  02
09878:  SUBWF  00,W
0987A:  MOVWF  00
0987C:  MOVF   03,W
0987E:  SUBWFB 01,W
09880:  MOVWF  01
09882:  MOVLW  00
09884:  SUBWFB xED,W
09886:  MOVWF  02
09888:  MOVLW  00
0988A:  SUBWFB xEE,W
0988C:  MOVWF  xEA
0988E:  MOVFF  02,8E9
09892:  MOVFF  01,8E8
09896:  MOVFF  00,8E7
....................          } 
....................          if (nv_product==WMS4){ 
0989A:  DECFSZ 2F,W
0989C:  BRA    9AB4
0989E:  MOVF   30,F
098A0:  BTFSS  FD8.2
098A2:  BRA    9AB4
....................             if (end_even_port==FALSE){ 
098A4:  MOVLB  2
098A6:  MOVF   xDB,F
098A8:  BNZ   999E
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
098AA:  BCF    FD8.0
098AC:  MOVLB  7
098AE:  RLCF   x40,W
098B0:  CLRF   03
098B2:  ADDLW  AB
098B4:  MOVWF  FE9
098B6:  MOVLW  07
098B8:  ADDWFC 03,W
098BA:  MOVWF  FEA
098BC:  MOVFF  FEC,A11
098C0:  MOVF   FED,F
098C2:  MOVFF  FEF,A10
098C6:  MOVFF  8DE,A13
098CA:  MOVFF  8DD,A12
098CE:  MOVLB  0
098D0:  CALL   5CC0
098D4:  MOVFF  02,8EC
098D8:  MOVFF  01,8EB
098DC:  BCF    FD8.0
098DE:  MOVLB  7
098E0:  RLCF   x40,W
098E2:  CLRF   03
098E4:  ADDLW  AB
098E6:  MOVWF  FE9
098E8:  MOVLW  07
098EA:  ADDWFC 03,W
098EC:  MOVWF  FEA
098EE:  MOVFF  FEC,8EE
098F2:  MOVF   FED,F
098F4:  MOVFF  FEF,8ED
098F8:  BCF    FD8.0
098FA:  MOVLB  8
098FC:  RRCF   xEE,W
098FE:  MOVWF  03
09900:  RRCF   xED,W
09902:  MOVWF  02
09904:  ADDWF  01,W
09906:  MOVWF  01
09908:  MOVF   xEC,W
0990A:  ADDWFC 03,F
0990C:  MOVFF  01,8E3
09910:  MOVFF  03,8E4
09914:  CLRF   02
09916:  CLRF   03
09918:  MOVFF  03,8E6
0991C:  MOVFF  02,8E5
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
09920:  BCF    FD8.0
09922:  MOVLB  7
09924:  RLCF   x40,W
09926:  CLRF   03
09928:  ADDLW  AB
0992A:  MOVWF  FE9
0992C:  MOVLW  07
0992E:  ADDWFC 03,W
09930:  MOVWF  FEA
09932:  MOVFF  FEC,A11
09936:  MOVF   FED,F
09938:  MOVFF  FEF,A10
0993C:  MOVFF  8DE,A13
09940:  MOVFF  8DD,A12
09944:  MOVLB  0
09946:  CALL   5CC0
0994A:  MOVFF  02,8EC
0994E:  MOVFF  01,8EB
09952:  BCF    FD8.0
09954:  MOVLB  7
09956:  RLCF   x40,W
09958:  CLRF   03
0995A:  ADDLW  AB
0995C:  MOVWF  FE9
0995E:  MOVLW  07
09960:  ADDWFC 03,W
09962:  MOVWF  FEA
09964:  MOVFF  FEC,8EE
09968:  MOVF   FED,F
0996A:  MOVFF  FEF,8ED
0996E:  BCF    FD8.0
09970:  MOVLB  8
09972:  RRCF   xEE,W
09974:  MOVWF  03
09976:  RRCF   xED,W
09978:  MOVWF  02
0997A:  SUBWF  01,W
0997C:  MOVWF  00
0997E:  MOVF   03,W
09980:  SUBWFB xEC,W
09982:  MOVWF  03
09984:  MOVF   00,W
09986:  MOVFF  03,8E8
0998A:  CLRF   02
0998C:  CLRF   03
0998E:  MOVFF  03,8EA
09992:  MOVFF  02,8E9
09996:  MOVFF  00,8E7
....................             } 
0999A:  BRA    9AB4
0999C:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
0999E:  DECFSZ xDB,W
099A0:  BRA    9AB6
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
099A2:  BCF    FD8.0
099A4:  MOVLB  7
099A6:  RLCF   x40,W
099A8:  CLRF   03
099AA:  ADDLW  AB
099AC:  MOVWF  FE9
099AE:  MOVLW  07
099B0:  ADDWFC 03,W
099B2:  MOVWF  FEA
099B4:  MOVFF  FEC,A11
099B8:  MOVF   FED,F
099BA:  MOVFF  FEF,A10
099BE:  MOVLW  01
099C0:  MOVLB  8
099C2:  SUBWF  xDD,W
099C4:  MOVWF  00
099C6:  MOVLW  00
099C8:  SUBWFB xDE,W
099CA:  MOVWF  03
099CC:  MOVFF  00,8ED
099D0:  MOVWF  xEE
099D2:  MOVFF  FE8,A13
099D6:  MOVFF  00,A12
099DA:  MOVLB  0
099DC:  CALL   5CC0
099E0:  MOVFF  02,8EC
099E4:  MOVFF  01,8EB
099E8:  BCF    FD8.0
099EA:  MOVLB  7
099EC:  RLCF   x40,W
099EE:  CLRF   03
099F0:  ADDLW  AB
099F2:  MOVWF  FE9
099F4:  MOVLW  07
099F6:  ADDWFC 03,W
099F8:  MOVWF  FEA
099FA:  MOVFF  FEC,8EE
099FE:  MOVF   FED,F
09A00:  MOVFF  FEF,8ED
09A04:  BCF    FD8.0
09A06:  MOVLB  8
09A08:  RRCF   xEE,W
09A0A:  MOVWF  03
09A0C:  RRCF   xED,W
09A0E:  MOVWF  02
09A10:  ADDWF  01,W
09A12:  MOVWF  01
09A14:  MOVF   xEC,W
09A16:  ADDWFC 03,F
09A18:  MOVFF  01,8E3
09A1C:  MOVFF  03,8E4
09A20:  CLRF   02
09A22:  CLRF   03
09A24:  MOVFF  03,8E6
09A28:  MOVFF  02,8E5
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
09A2C:  BCF    FD8.0
09A2E:  MOVLB  7
09A30:  RLCF   x40,W
09A32:  CLRF   03
09A34:  ADDLW  AB
09A36:  MOVWF  FE9
09A38:  MOVLW  07
09A3A:  ADDWFC 03,W
09A3C:  MOVWF  FEA
09A3E:  MOVFF  FEC,A11
09A42:  MOVF   FED,F
09A44:  MOVFF  FEF,A10
09A48:  MOVLW  01
09A4A:  MOVLB  8
09A4C:  SUBWF  xDD,W
09A4E:  MOVWF  00
09A50:  MOVLW  00
09A52:  SUBWFB xDE,W
09A54:  MOVWF  03
09A56:  MOVFF  00,8ED
09A5A:  MOVWF  xEE
09A5C:  MOVFF  FE8,A13
09A60:  MOVFF  00,A12
09A64:  MOVLB  0
09A66:  CALL   5CC0
09A6A:  MOVFF  02,03
09A6E:  MOVFF  01,8E7
09A72:  MOVFF  02,8E8
09A76:  CLRF   02
09A78:  CLRF   03
09A7A:  MOVFF  03,8EA
09A7E:  MOVFF  02,8E9
....................                m_pll = m_pll -(m_ppp[motor]/2); 
09A82:  BCF    FD8.0
09A84:  MOVLB  7
09A86:  RLCF   x40,W
09A88:  CLRF   03
09A8A:  ADDLW  AB
09A8C:  MOVWF  FE9
09A8E:  MOVLW  07
09A90:  ADDWFC 03,W
09A92:  MOVWF  FEA
09A94:  MOVFF  FEC,8EC
09A98:  MOVF   FED,F
09A9A:  MOVFF  FEF,8EB
09A9E:  BCF    FD8.0
09AA0:  MOVLB  8
09AA2:  RRCF   xEC,W
09AA4:  MOVWF  03
09AA6:  RRCF   xEB,W
09AA8:  SUBWF  xE7,F
09AAA:  MOVF   03,W
09AAC:  SUBWFB xE8,F
09AAE:  MOVLW  00
09AB0:  SUBWFB xE9,F
09AB2:  SUBWFB xEA,F
09AB4:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
09AB6:  MOVLB  7
09AB8:  MOVF   x40,W
09ABA:  MULLW  04
09ABC:  MOVF   FF3,W
09ABE:  CLRF   03
09AC0:  ADDLW  A2
09AC2:  MOVWF  FE9
09AC4:  MOVLW  07
09AC6:  ADDWFC 03,W
09AC8:  MOVWF  FEA
09ACA:  MOVFF  FEF,8EB
09ACE:  MOVFF  FEC,8EC
09AD2:  MOVFF  FEC,8ED
09AD6:  MOVFF  FEC,8EE
09ADA:  MOVLB  8
09ADC:  BTFSC  xE6.7
09ADE:  BRA    9B4E
09AE0:  MOVF   xE6,W
09AE2:  SUBWF  xEE,W
09AE4:  BNC   9AFE
09AE6:  BNZ   9B4E
09AE8:  MOVF   xE5,W
09AEA:  SUBWF  xED,W
09AEC:  BNC   9AFE
09AEE:  BNZ   9B4E
09AF0:  MOVF   xE4,W
09AF2:  SUBWF  xEC,W
09AF4:  BNC   9AFE
09AF6:  BNZ   9B4E
09AF8:  MOVF   xEB,W
09AFA:  SUBWF  xE3,W
09AFC:  BNC   9B4E
09AFE:  MOVLB  7
09B00:  MOVF   x40,W
09B02:  MULLW  04
09B04:  MOVF   FF3,W
09B06:  CLRF   03
09B08:  ADDLW  A2
09B0A:  MOVWF  FE9
09B0C:  MOVLW  07
09B0E:  ADDWFC 03,W
09B10:  MOVWF  FEA
09B12:  MOVFF  FEF,8EB
09B16:  MOVFF  FEC,8EC
09B1A:  MOVFF  FEC,8ED
09B1E:  MOVFF  FEC,8EE
09B22:  MOVLB  8
09B24:  BTFSC  xEA.7
09B26:  BRA    9C92
09B28:  MOVF   xEE,W
09B2A:  SUBWF  xEA,W
09B2C:  BTFSS  FD8.0
09B2E:  BRA    9C92
09B30:  BNZ   9B4E
09B32:  MOVF   xED,W
09B34:  SUBWF  xE9,W
09B36:  BTFSS  FD8.0
09B38:  BRA    9C92
09B3A:  BNZ   9B4E
09B3C:  MOVF   xEC,W
09B3E:  SUBWF  xE8,W
09B40:  BTFSS  FD8.0
09B42:  BRA    9C92
09B44:  BNZ   9B4E
09B46:  MOVF   xE7,W
09B48:  SUBWF  xEB,W
09B4A:  BTFSC  FD8.0
09B4C:  BRA    9C92
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09B4E:  MOVLW  01
09B50:  MOVLB  7
09B52:  ADDWF  x40,W
09B54:  MOVLB  8
09B56:  MOVWF  xEB
09B58:  BCF    FD8.0
09B5A:  MOVLB  7
09B5C:  RLCF   x40,W
09B5E:  CLRF   03
09B60:  ADDLW  AB
09B62:  MOVWF  FE9
09B64:  MOVLW  07
09B66:  ADDWFC 03,W
09B68:  MOVWF  FEA
09B6A:  MOVFF  FEC,8ED
09B6E:  MOVF   FED,F
09B70:  MOVFF  FEF,8EC
09B74:  MOVF   x40,W
09B76:  MULLW  04
09B78:  MOVF   FF3,W
09B7A:  CLRF   03
09B7C:  ADDLW  A2
09B7E:  MOVWF  FE9
09B80:  MOVLW  07
09B82:  ADDWFC 03,W
09B84:  MOVWF  FEA
09B86:  MOVFF  FEF,8EE
09B8A:  MOVFF  FEC,8EF
09B8E:  MOVFF  FEC,8F0
09B92:  MOVFF  FEC,8F1
09B96:  MOVLW  8E
09B98:  MOVWF  FF6
09B9A:  MOVLW  1A
09B9C:  MOVWF  FF7
09B9E:  MOVLW  00
09BA0:  MOVWF  FF8
09BA2:  CLRF   1B
09BA4:  BTFSC  FF2.7
09BA6:  BSF    1B.7
09BA8:  BCF    FF2.7
09BAA:  MOVLW  05
09BAC:  MOVLB  A
09BAE:  MOVWF  x40
09BB0:  MOVLB  0
09BB2:  CALL   1044
09BB6:  BTFSC  1B.7
09BB8:  BSF    FF2.7
09BBA:  CLRF   1B
09BBC:  BTFSC  FF2.7
09BBE:  BSF    1B.7
09BC0:  BCF    FF2.7
09BC2:  MOVFF  8EB,A40
09BC6:  MOVLW  1B
09BC8:  MOVLB  A
09BCA:  MOVWF  x41
09BCC:  MOVLB  0
09BCE:  CALL   0FC6
09BD2:  BTFSC  1B.7
09BD4:  BSF    FF2.7
09BD6:  MOVLW  2C
09BD8:  BTFSS  F9E.4
09BDA:  BRA    9BD8
09BDC:  MOVWF  FAD
09BDE:  MOVLW  41
09BE0:  MOVWF  FE9
09BE2:  MOVFF  8DC,8F5
09BE6:  MOVFF  8DB,8F4
09BEA:  MOVFF  8DA,8F3
09BEE:  MOVFF  8D9,8F2
09BF2:  RCALL  958C
09BF4:  MOVLW  2C
09BF6:  BTFSS  F9E.4
09BF8:  BRA    9BF6
09BFA:  MOVWF  FAD
09BFC:  MOVLW  10
09BFE:  MOVWF  FE9
09C00:  CLRF   1B
09C02:  BTFSC  FF2.7
09C04:  BSF    1B.7
09C06:  BCF    FF2.7
09C08:  MOVFF  8ED,A41
09C0C:  MOVFF  8EC,A40
09C10:  CALL   11C6
09C14:  BTFSC  1B.7
09C16:  BSF    FF2.7
09C18:  MOVLW  2C
09C1A:  BTFSS  F9E.4
09C1C:  BRA    9C1A
09C1E:  MOVWF  FAD
09C20:  MOVLW  41
09C22:  MOVWF  FE9
09C24:  CLRF   1B
09C26:  BTFSC  FF2.7
09C28:  BSF    1B.7
09C2A:  BCF    FF2.7
09C2C:  MOVFF  8F1,A43
09C30:  MOVFF  8F0,A42
09C34:  MOVFF  8EF,A41
09C38:  MOVFF  8EE,A40
09C3C:  CALL   110A
09C40:  BTFSC  1B.7
09C42:  BSF    FF2.7
09C44:  MOVLW  2C
09C46:  BTFSS  F9E.4
09C48:  BRA    9C46
09C4A:  MOVWF  FAD
09C4C:  MOVLW  41
09C4E:  MOVWF  FE9
09C50:  MOVFF  8E6,8F5
09C54:  MOVFF  8E5,8F4
09C58:  MOVFF  8E4,8F3
09C5C:  MOVFF  8E3,8F2
09C60:  RCALL  958C
09C62:  MOVLW  2C
09C64:  BTFSS  F9E.4
09C66:  BRA    9C64
09C68:  MOVWF  FAD
09C6A:  MOVLW  41
09C6C:  MOVWF  FE9
09C6E:  MOVFF  8EA,8F5
09C72:  MOVFF  8E9,8F4
09C76:  MOVFF  8E8,8F3
09C7A:  MOVFF  8E7,8F2
09C7E:  RCALL  958C
09C80:  MOVLW  0D
09C82:  BTFSS  F9E.4
09C84:  BRA    9C82
09C86:  MOVWF  FAD
09C88:  MOVLW  0A
09C8A:  BTFSS  F9E.4
09C8C:  BRA    9C8A
09C8E:  MOVWF  FAD
09C90:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09C92:  BCF    FD8.0
09C94:  MOVLB  7
09C96:  RLCF   x40,W
09C98:  CLRF   03
09C9A:  ADDLW  9E
09C9C:  MOVWF  01
09C9E:  MOVLW  07
09CA0:  ADDWFC 03,F
09CA2:  MOVLB  8
09CA4:  MOVFF  03,8EC
09CA8:  BCF    FD8.0
09CAA:  MOVLB  7
09CAC:  RLCF   x40,W
09CAE:  CLRF   03
09CB0:  ADDLW  66
09CB2:  MOVWF  FE9
09CB4:  MOVLW  07
09CB6:  ADDWFC 03,W
09CB8:  MOVWF  FEA
09CBA:  MOVFF  FEC,03
09CBE:  MOVF   FED,F
09CC0:  MOVFF  FEF,8ED
09CC4:  MOVLB  8
09CC6:  MOVFF  8EC,FEA
09CCA:  MOVFF  01,FE9
09CCE:  MOVFF  03,FEC
09CD2:  MOVF   FED,F
09CD4:  MOVFF  8ED,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09CD8:  BCF    FD8.0
09CDA:  MOVLB  7
09CDC:  RLCF   x40,W
09CDE:  CLRF   03
09CE0:  ADDLW  66
09CE2:  MOVWF  FE9
09CE4:  MOVLW  07
09CE6:  ADDWFC 03,W
09CE8:  MOVWF  FEA
09CEA:  CLRF   FEC
09CEC:  MOVF   FED,F
09CEE:  MOVLW  04
09CF0:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09CF2:  MOVF   x40,W
09CF4:  MULLW  04
09CF6:  MOVF   FF3,W
09CF8:  CLRF   03
09CFA:  ADDLW  A2
09CFC:  MOVWF  FE9
09CFE:  MOVLW  07
09D00:  ADDWFC 03,W
09D02:  MOVWF  FEA
09D04:  MOVFF  FEF,8DF
09D08:  MOVFF  FEC,8E0
09D0C:  MOVFF  FEC,8E1
09D10:  MOVFF  FEC,8E2
09D14:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09D16:  MOVFF  8DF,00
09D1A:  MOVFF  8E0,01
09D1E:  MOVFF  8E1,02
09D22:  MOVFF  8E2,03
09D26:  MOVLB  0
09D28:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
08586:  MOVLB  2
08588:  CLRF   xDB
....................    start_even_port = FALSE; 
0858A:  CLRF   xDA
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
0858C:  BCF    FD8.0
0858E:  MOVLB  7
08590:  RLCF   x40,W
08592:  CLRF   03
08594:  ADDLW  C7
08596:  MOVWF  FE9
08598:  MOVLW  07
0859A:  ADDWFC 03,W
0859C:  MOVWF  FEA
0859E:  MOVFF  FEC,8D9
085A2:  MOVF   FED,F
085A4:  MOVFF  FEF,8D8
085A8:  MOVLW  01
085AA:  MOVLB  8
085AC:  ANDWF  xD8,F
085AE:  CLRF   xD9
085B0:  MOVF   xD8,F
085B2:  BNZ   85C0
085B4:  MOVF   xD9,F
085B6:  BNZ   85C0
....................    { 
....................       end_even_port = TRUE; 
085B8:  MOVLW  01
085BA:  MOVLB  2
085BC:  MOVWF  xDB
085BE:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
085C0:  BCF    FD8.0
085C2:  MOVLB  7
085C4:  RLCF   x40,W
085C6:  CLRF   03
085C8:  ADDLW  C3
085CA:  MOVWF  FE9
085CC:  MOVLW  07
085CE:  ADDWFC 03,W
085D0:  MOVWF  FEA
085D2:  MOVFF  FEC,8D9
085D6:  MOVF   FED,F
085D8:  MOVFF  FEF,8D8
085DC:  MOVLW  01
085DE:  MOVLB  8
085E0:  ANDWF  xD8,F
085E2:  CLRF   xD9
085E4:  MOVF   xD8,F
085E6:  BNZ   85F4
085E8:  MOVF   xD9,F
085EA:  BNZ   85F4
....................    { 
....................       start_even_port = TRUE; 
085EC:  MOVLW  01
085EE:  MOVLB  2
085F0:  MOVWF  xDA
085F2:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
085F4:  MOVLB  2
085F6:  MOVF   xDA,F
085F8:  BNZ   860E
....................    { 
....................       evenOdd = 0; 
085FA:  MOVLB  8
085FC:  CLRF   xD7
....................       if (TRUE == end_even_port) 
085FE:  MOVLB  2
08600:  DECFSZ xDB,W
08602:  BRA    860C
....................       { 
....................          evenOdd = 1; 
08604:  MOVLW  01
08606:  MOVLB  8
08608:  MOVWF  xD7
0860A:  MOVLB  2
....................       } 
....................    } 
0860C:  BRA    8622
....................    else 
....................    { 
....................       evenOdd = 2; 
0860E:  MOVLW  02
08610:  MOVLB  8
08612:  MOVWF  xD7
....................       if (TRUE == end_even_port) 
08614:  MOVLB  2
08616:  DECFSZ xDB,W
08618:  BRA    8622
....................       { 
....................          evenOdd = 3; 
0861A:  MOVLW  03
0861C:  MOVLB  8
0861E:  MOVWF  xD7
08620:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
08622:  MOVLB  8
08624:  MOVFF  8D7,01
08628:  MOVLB  0
0862A:  GOTO   A078 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09DA0:  BCF    FD8.0
09DA2:  MOVLB  7
09DA4:  RLCF   x40,W
09DA6:  CLRF   03
09DA8:  ADDLW  86
09DAA:  MOVWF  FE9
09DAC:  MOVLW  07
09DAE:  ADDWFC 03,W
09DB0:  MOVWF  FEA
09DB2:  CLRF   FEC
09DB4:  MOVF   FED,F
09DB6:  MOVFF  8C8,FEF
....................    m_step_cnt[motor] = 0; 
09DBA:  MOVF   x40,W
09DBC:  MULLW  04
09DBE:  MOVF   FF3,W
09DC0:  CLRF   03
09DC2:  ADDLW  A2
09DC4:  MOVWF  FE9
09DC6:  MOVLW  07
09DC8:  ADDWFC 03,W
09DCA:  MOVWF  FEA
09DCC:  MOVF   FEE,F
09DCE:  MOVF   FEE,F
09DD0:  CLRF   FEC
09DD2:  MOVF   FED,F
09DD4:  CLRF   FEF
09DD6:  MOVF   FED,F
09DD8:  CLRF   FEF
09DDA:  MOVF   FED,F
09DDC:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09DDE:  BCF    FD8.0
09DE0:  RLCF   x40,W
09DE2:  CLRF   03
09DE4:  ADDLW  6E
09DE6:  MOVWF  FE9
09DE8:  MOVLW  07
09DEA:  ADDWFC 03,W
09DEC:  MOVWF  FEA
09DEE:  MOVFF  FEC,8D5
09DF2:  MOVF   FED,F
09DF4:  MOVFF  FEF,8D4
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09DF8:  BCF    FD8.0
09DFA:  RLCF   x40,W
09DFC:  CLRF   03
09DFE:  ADDLW  76
09E00:  MOVWF  FE9
09E02:  MOVLW  07
09E04:  ADDWFC 03,W
09E06:  MOVWF  FEA
09E08:  MOVFF  FEC,8DC
09E0C:  MOVF   FED,F
09E0E:  MOVFF  FEF,8DB
09E12:  BCF    FD8.0
09E14:  RLCF   x40,W
09E16:  CLRF   03
09E18:  ADDLW  5E
09E1A:  MOVWF  FE9
09E1C:  MOVLW  07
09E1E:  ADDWFC 03,W
09E20:  MOVWF  FEA
09E22:  MOVFF  FEC,03
09E26:  MOVF   FED,F
09E28:  MOVFF  FEF,8DD
09E2C:  MOVFF  03,8DA
09E30:  MOVFF  03,8DE
09E34:  MOVLB  0
09E36:  CALL   2CFC
09E3A:  MOVFF  02,8D3
09E3E:  MOVFF  01,8D2
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09E42:  BCF    FD8.0
09E44:  MOVLB  7
09E46:  RLCF   x40,W
09E48:  CLRF   03
09E4A:  ADDLW  66
09E4C:  MOVWF  FE9
09E4E:  MOVLW  07
09E50:  ADDWFC 03,W
09E52:  MOVWF  FEA
09E54:  MOVFF  FEC,8D8
09E58:  MOVF   FED,F
09E5A:  MOVFF  FEF,8D7
09E5E:  MOVLB  8
09E60:  MOVF   xD7,W
09E62:  SUBLW  02
09E64:  BNZ   9E94
09E66:  MOVF   xD8,F
09E68:  BNZ   9E94
09E6A:  BCF    FD8.0
09E6C:  MOVLB  7
09E6E:  RLCF   x40,W
09E70:  CLRF   03
09E72:  ADDLW  C3
09E74:  MOVWF  FE9
09E76:  MOVLW  07
09E78:  ADDWFC 03,W
09E7A:  MOVWF  FEA
09E7C:  MOVFF  FEC,8D8
09E80:  MOVF   FED,F
09E82:  MOVFF  FEF,8D7
09E86:  MOVLB  8
09E88:  MOVF   xD7,F
09E8A:  BNZ   9E94
09E8C:  MOVF   xD8,F
09E8E:  BTFSC  FD8.2
09E90:  GOTO   A732
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09E94:  BCF    FD8.0
09E96:  MOVLB  7
09E98:  RLCF   x40,W
09E9A:  CLRF   03
09E9C:  ADDLW  66
09E9E:  MOVWF  FE9
09EA0:  MOVLW  07
09EA2:  ADDWFC 03,W
09EA4:  MOVWF  FEA
09EA6:  MOVFF  FEC,8D8
09EAA:  MOVF   FED,F
09EAC:  MOVFF  FEF,8D7
09EB0:  MOVLB  8
09EB2:  MOVF   xD7,W
09EB4:  SUBLW  02
09EB6:  BTFSS  FD8.2
09EB8:  BRA    A212
09EBA:  MOVF   xD8,F
09EBC:  BTFSS  FD8.2
09EBE:  BRA    A212
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09EC0:  BCF    FD8.0
09EC2:  MOVLB  7
09EC4:  RLCF   x40,W
09EC6:  CLRF   03
09EC8:  ADDLW  C7
09ECA:  MOVWF  FE9
09ECC:  MOVLW  07
09ECE:  ADDWFC 03,W
09ED0:  MOVWF  FEA
09ED2:  MOVFF  8C9,FEF
09ED6:  MOVFF  8CA,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09EDA:  DECFSZ 2F,W
09EDC:  BRA    A18E
09EDE:  MOVF   30,F
09EE0:  BTFSS  FD8.2
09EE2:  BRA    A18E
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09EE4:  BCF    FD8.0
09EE6:  RLCF   x40,W
09EE8:  CLRF   03
09EEA:  ADDLW  C7
09EEC:  MOVWF  FE9
09EEE:  MOVLW  07
09EF0:  ADDWFC 03,W
09EF2:  MOVWF  FEA
09EF4:  MOVFF  FEC,8D8
09EF8:  MOVF   FED,F
09EFA:  MOVFF  FEF,8D7
09EFE:  BCF    FD8.0
09F00:  RLCF   x40,W
09F02:  CLRF   03
09F04:  ADDLW  C3
09F06:  MOVWF  FE9
09F08:  MOVLW  07
09F0A:  ADDWFC 03,W
09F0C:  MOVWF  FEA
09F0E:  MOVFF  FEC,03
09F12:  MOVF   FED,F
09F14:  MOVFF  FEF,01
09F18:  MOVF   03,W
09F1A:  MOVLB  8
09F1C:  SUBWF  xD8,W
09F1E:  BNC   9FBA
09F20:  BNZ   9F28
09F22:  MOVF   xD7,W
09F24:  SUBWF  01,W
09F26:  BC    9FBA
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09F28:  BCF    FD8.0
09F2A:  MOVLB  7
09F2C:  RLCF   x40,W
09F2E:  CLRF   03
09F30:  ADDLW  B7
09F32:  MOVWF  01
09F34:  MOVLW  07
09F36:  ADDWFC 03,F
09F38:  MOVLB  8
09F3A:  MOVFF  03,8D8
09F3E:  BCF    FD8.0
09F40:  MOVLB  7
09F42:  RLCF   x40,W
09F44:  CLRF   03
09F46:  ADDLW  C7
09F48:  MOVWF  FE9
09F4A:  MOVLW  07
09F4C:  ADDWFC 03,W
09F4E:  MOVWF  FEA
09F50:  MOVFF  FEC,8DA
09F54:  MOVF   FED,F
09F56:  MOVFF  FEF,8D9
09F5A:  BCF    FD8.0
09F5C:  RLCF   x40,W
09F5E:  CLRF   03
09F60:  ADDLW  C3
09F62:  MOVWF  FE9
09F64:  MOVLW  07
09F66:  ADDWFC 03,W
09F68:  MOVWF  FEA
09F6A:  MOVFF  FEC,03
09F6E:  MOVF   FED,F
09F70:  MOVF   FEF,W
09F72:  MOVLB  8
09F74:  SUBWF  xD9,W
09F76:  MOVWF  00
09F78:  MOVF   03,W
09F7A:  SUBWFB xDA,W
09F7C:  MOVFF  8D8,FEA
09F80:  MOVFF  01,FE9
09F84:  MOVWF  FEC
09F86:  MOVF   FED,F
09F88:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F8C:  BCF    FD8.0
09F8E:  MOVLB  7
09F90:  RLCF   x40,W
09F92:  CLRF   03
09F94:  ADDLW  B7
09F96:  MOVWF  FE9
09F98:  MOVLW  07
09F9A:  ADDWFC 03,W
09F9C:  MOVWF  FEA
09F9E:  MOVFF  FEC,8D8
09FA2:  MOVF   FED,F
09FA4:  MOVFF  FEF,8D7
09FA8:  BCF    FD8.0
09FAA:  MOVLB  8
09FAC:  CLRF   xCC
09FAE:  CLRF   xCB
09FB0:  RRCF   xD8,W
09FB2:  MOVWF  xCA
09FB4:  RRCF   xD7,W
09FB6:  MOVWF  xC9
....................             } 
09FB8:  BRA    A072
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09FBA:  BCF    FD8.0
09FBC:  MOVLB  7
09FBE:  RLCF   x40,W
09FC0:  CLRF   03
09FC2:  ADDLW  B7
09FC4:  MOVWF  01
09FC6:  MOVLW  07
09FC8:  ADDWFC 03,F
09FCA:  MOVFF  01,8D7
09FCE:  MOVLB  8
09FD0:  MOVFF  03,8D8
09FD4:  BCF    FD8.0
09FD6:  MOVLB  7
09FD8:  RLCF   x40,W
09FDA:  CLRF   03
09FDC:  ADDLW  62
09FDE:  MOVWF  FE9
09FE0:  MOVLW  07
09FE2:  ADDWFC 03,W
09FE4:  MOVWF  FEA
09FE6:  MOVFF  FEC,8DA
09FEA:  MOVF   FED,F
09FEC:  MOVFF  FEF,8D9
09FF0:  BCF    FD8.0
09FF2:  RLCF   x40,W
09FF4:  CLRF   03
09FF6:  ADDLW  C3
09FF8:  MOVWF  FE9
09FFA:  MOVLW  07
09FFC:  ADDWFC 03,W
09FFE:  MOVWF  FEA
0A000:  MOVFF  FEC,03
0A004:  MOVF   FED,F
0A006:  MOVF   FEF,W
0A008:  MOVLB  8
0A00A:  SUBWF  xD9,F
0A00C:  MOVF   03,W
0A00E:  SUBWFB xDA,F
0A010:  BCF    FD8.0
0A012:  MOVLB  7
0A014:  RLCF   x40,W
0A016:  CLRF   03
0A018:  ADDLW  C7
0A01A:  MOVWF  FE9
0A01C:  MOVLW  07
0A01E:  ADDWFC 03,W
0A020:  MOVWF  FEA
0A022:  MOVFF  FEC,03
0A026:  MOVF   FED,F
0A028:  MOVF   FEF,W
0A02A:  MOVLB  8
0A02C:  ADDWF  xD9,W
0A02E:  MOVWF  01
0A030:  MOVF   xDA,W
0A032:  ADDWFC 03,F
0A034:  MOVFF  8D8,FEA
0A038:  MOVFF  8D7,FE9
0A03C:  MOVFF  03,FEC
0A040:  MOVF   FED,F
0A042:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
0A046:  BCF    FD8.0
0A048:  MOVLB  7
0A04A:  RLCF   x40,W
0A04C:  CLRF   03
0A04E:  ADDLW  B7
0A050:  MOVWF  FE9
0A052:  MOVLW  07
0A054:  ADDWFC 03,W
0A056:  MOVWF  FEA
0A058:  MOVFF  FEC,8D8
0A05C:  MOVF   FED,F
0A05E:  MOVFF  FEF,8D7
0A062:  BCF    FD8.0
0A064:  MOVLB  8
0A066:  CLRF   xCC
0A068:  CLRF   xCB
0A06A:  RRCF   xD8,W
0A06C:  MOVWF  xCA
0A06E:  RRCF   xD7,W
0A070:  MOVWF  xC9
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
0A072:  MOVLB  0
0A074:  GOTO   8586
0A078:  MOVFF  01,8D6
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
0A07C:  BCF    FD8.0
0A07E:  MOVLB  7
0A080:  RLCF   x40,W
0A082:  CLRF   03
0A084:  ADDLW  C7
0A086:  MOVWF  FE9
0A088:  MOVLW  07
0A08A:  ADDWFC 03,W
0A08C:  MOVWF  FEA
0A08E:  MOVFF  FEC,8D8
0A092:  MOVF   FED,F
0A094:  MOVFF  FEF,8D7
0A098:  MOVLB  8
0A09A:  MOVF   xD7,W
0A09C:  SUBLW  02
0A09E:  BNZ   A0CE
0A0A0:  MOVF   xD8,F
0A0A2:  BNZ   A0CE
0A0A4:  BCF    FD8.0
0A0A6:  MOVLB  7
0A0A8:  RLCF   x40,W
0A0AA:  CLRF   03
0A0AC:  ADDLW  C3
0A0AE:  MOVWF  FE9
0A0B0:  MOVLW  07
0A0B2:  ADDWFC 03,W
0A0B4:  MOVWF  FEA
0A0B6:  MOVFF  FEC,8D8
0A0BA:  MOVF   FED,F
0A0BC:  MOVFF  FEF,8D7
0A0C0:  MOVLB  8
0A0C2:  DECFSZ xD7,W
0A0C4:  BRA    A0CE
0A0C6:  MOVF   xD8,F
0A0C8:  BNZ   A0CE
....................             { 
....................                port_port=4; 
0A0CA:  MOVLW  04
0A0CC:  MOVWF  xD6
....................             } 
....................              
....................             switch(port_port){ 
0A0CE:  MOVF   xD6,W
0A0D0:  ADDLW  FB
0A0D2:  BC    A18A
0A0D4:  ADDLW  05
0A0D6:  MOVLB  0
0A0D8:  GOTO   A780
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
0A0DC:  BCF    FD8.0
0A0DE:  MOVLB  7
0A0E0:  RLCF   x40,W
0A0E2:  CLRF   03
0A0E4:  ADDLW  6E
0A0E6:  MOVWF  FE9
0A0E8:  MOVLW  07
0A0EA:  ADDWFC 03,W
0A0EC:  MOVWF  FEA
0A0EE:  MOVFF  FEC,8D5
0A0F2:  MOVF   FED,F
0A0F4:  MOVFF  FEF,8D4
....................                   break; 
0A0F8:  MOVLB  8
0A0FA:  BRA    A18A
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A0FC:  BCF    FD8.0
0A0FE:  MOVLB  7
0A100:  RLCF   x40,W
0A102:  CLRF   03
0A104:  ADDLW  7E
0A106:  MOVWF  FE9
0A108:  MOVLW  07
0A10A:  ADDWFC 03,W
0A10C:  MOVWF  FEA
0A10E:  MOVFF  FEC,03
0A112:  MOVF   FED,F
0A114:  MOVF   FEF,W
0A116:  MOVLB  8
0A118:  ADDWF  xD2,W
0A11A:  MOVWF  xD4
0A11C:  MOVF   03,W
0A11E:  ADDWFC xD3,W
0A120:  MOVWF  xD5
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A122:  BRA    A18A
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A124:  BCF    FD8.0
0A126:  MOVLB  7
0A128:  RLCF   x40,W
0A12A:  CLRF   03
0A12C:  ADDLW  6E
0A12E:  MOVWF  FE9
0A130:  MOVLW  07
0A132:  ADDWFC 03,W
0A134:  MOVWF  FEA
0A136:  MOVFF  FEC,8D5
0A13A:  MOVF   FED,F
0A13C:  MOVFF  FEF,8D4
....................                         ++m_steps; 
0A140:  MOVLW  01
0A142:  MOVLB  8
0A144:  ADDWF  xC9,F
0A146:  BTFSC  FD8.0
0A148:  INCF   xCA,F
0A14A:  BTFSC  FD8.2
0A14C:  INCF   xCB,F
0A14E:  BTFSC  FD8.2
0A150:  INCF   xCC,F
....................                   break; 
0A152:  BRA    A18A
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A154:  BCF    FD8.0
0A156:  MOVLB  7
0A158:  RLCF   x40,W
0A15A:  CLRF   03
0A15C:  ADDLW  7E
0A15E:  MOVWF  FE9
0A160:  MOVLW  07
0A162:  ADDWFC 03,W
0A164:  MOVWF  FEA
0A166:  MOVFF  FEC,03
0A16A:  MOVF   FED,F
0A16C:  MOVF   FEF,W
0A16E:  MOVLB  8
0A170:  ADDWF  xD2,W
0A172:  MOVWF  xD4
0A174:  MOVF   03,W
0A176:  ADDWFC xD3,W
0A178:  MOVWF  xD5
....................  
....................                   break; 
0A17A:  BRA    A18A
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A17C:  MOVFF  8D3,8D5
0A180:  MOVFF  8D2,8D4
....................                   break;     
0A184:  MOVLB  8
0A186:  BRA    A18A
0A188:  MOVLB  8
....................             } 
....................          } 
0A18A:  BRA    A1B6
0A18C:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A18E:  MOVFF  8CC,8DA
0A192:  MOVFF  8CB,8D9
0A196:  MOVFF  8CA,8D8
0A19A:  MOVFF  8C9,8D7
0A19E:  MOVLB  0
0A1A0:  GOTO   862E
0A1A4:  MOVFF  03,8CC
0A1A8:  MOVFF  02,8CB
0A1AC:  MOVFF  01,8CA
0A1B0:  MOVFF  00,8C9
0A1B4:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A1B6:  DECFSZ xC7,W
0A1B8:  BRA    A1E0
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A1BA:  MOVFF  8CA,8D8
0A1BE:  MOVFF  8C9,8D7
0A1C2:  MOVFF  8CA,8DA
0A1C6:  MOVFF  8C9,8D9
0A1CA:  MOVLB  0
0A1CC:  GOTO   8840
0A1D0:  MOVLB  8
0A1D2:  CLRF   xCC
0A1D4:  CLRF   xCB
0A1D6:  MOVFF  02,8CA
0A1DA:  MOVFF  01,8C9
....................          } 
0A1DE:  BRA    A212
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A1E0:  MOVF   2F,W
0A1E2:  SUBLW  03
0A1E4:  BNZ   A212
0A1E6:  MOVF   30,F
0A1E8:  BNZ   A212
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A1EA:  BCF    FD8.0
0A1EC:  MOVLB  7
0A1EE:  RLCF   x40,W
0A1F0:  CLRF   03
0A1F2:  ADDLW  BF
0A1F4:  MOVWF  FE9
0A1F6:  MOVLW  07
0A1F8:  ADDWFC 03,W
0A1FA:  MOVWF  FEA
0A1FC:  MOVFF  FEC,03
0A200:  MOVF   FED,F
0A202:  MOVF   FEF,W
0A204:  MOVLB  8
0A206:  SUBWF  xC9,F
0A208:  MOVF   03,W
0A20A:  SUBWFB xCA,F
0A20C:  MOVLW  00
0A20E:  SUBWFB xCB,F
0A210:  SUBWFB xCC,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A212:  MOVFF  8CD,8D7
0A216:  MOVLB  0
0A218:  GOTO   8F0A
....................        
....................       //timeout could be set here!!! 
....................       while (m_running[motor]) 
0A21C:  BCF    FD8.0
0A21E:  MOVLB  7
0A220:  RLCF   x40,W
0A222:  CLRF   03
0A224:  ADDLW  92
0A226:  MOVWF  FE9
0A228:  MOVLW  07
0A22A:  ADDWFC 03,W
0A22C:  MOVWF  FEA
0A22E:  MOVF   FEF,F
0A230:  BNZ   A238
0A232:  MOVF   FEC,F
0A234:  BTFSC  FD8.2
0A236:  BRA    A72E
....................       { 
....................          switch(e_mode[motor]) 
0A238:  BCF    FD8.0
0A23A:  RLCF   x40,W
0A23C:  CLRF   03
0A23E:  ADDLW  66
0A240:  MOVWF  FE9
0A242:  MOVLW  07
0A244:  ADDWFC 03,W
0A246:  MOVWF  FEA
0A248:  MOVF   FEF,W
0A24A:  MOVWF  00
0A24C:  MOVF   FEE,F
0A24E:  MOVF   FED,W
0A250:  MOVWF  03
0A252:  MOVF   03,W
0A254:  BNZ   A25E
0A256:  MOVF   00,F
0A258:  MOVLB  0
0A25A:  BZ    A2AC
0A25C:  MOVLB  7
0A25E:  MOVF   03,W
0A260:  BNZ   A26C
0A262:  MOVLW  01
0A264:  SUBWF  00,W
0A266:  MOVLB  0
0A268:  BZ    A302
0A26A:  MOVLB  7
0A26C:  MOVF   03,W
0A26E:  BNZ   A27A
0A270:  MOVLW  02
0A272:  SUBWF  00,W
0A274:  MOVLB  0
0A276:  BZ    A302
0A278:  MOVLB  7
0A27A:  MOVF   03,W
0A27C:  BNZ   A28A
0A27E:  MOVLW  03
0A280:  SUBWF  00,W
0A282:  MOVLB  0
0A284:  BTFSC  FD8.2
0A286:  BRA    A3D0
0A288:  MOVLB  7
0A28A:  MOVF   03,W
0A28C:  BNZ   A29A
0A28E:  MOVLW  04
0A290:  SUBWF  00,W
0A292:  MOVLB  0
0A294:  BTFSC  FD8.2
0A296:  BRA    A520
0A298:  MOVLB  7
0A29A:  MOVF   03,W
0A29C:  BNZ   A2AA
0A29E:  MOVLW  05
0A2A0:  SUBWF  00,W
0A2A2:  MOVLB  0
0A2A4:  BTFSC  FD8.2
0A2A6:  BRA    A670
0A2A8:  MOVLB  7
0A2AA:  BRA    A728
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A2AC:  MOVLB  7
0A2AE:  MOVF   x40,W
0A2B0:  MULLW  04
0A2B2:  MOVF   FF3,W
0A2B4:  CLRF   03
0A2B6:  ADDLW  A2
0A2B8:  MOVWF  FE9
0A2BA:  MOVLW  07
0A2BC:  ADDWFC 03,W
0A2BE:  MOVWF  FEA
0A2C0:  MOVFF  FEF,8D7
0A2C4:  MOVFF  FEC,8D8
0A2C8:  MOVFF  FEC,8D9
0A2CC:  MOVFF  FEC,8DA
0A2D0:  MOVLB  8
0A2D2:  MOVF   xCC,W
0A2D4:  SUBWF  xDA,W
0A2D6:  BNC   A2FC
0A2D8:  BNZ   A2F0
0A2DA:  MOVF   xCB,W
0A2DC:  SUBWF  xD9,W
0A2DE:  BNC   A2FC
0A2E0:  BNZ   A2F0
0A2E2:  MOVF   xCA,W
0A2E4:  SUBWF  xD8,W
0A2E6:  BNC   A2FC
0A2E8:  BNZ   A2F0
0A2EA:  MOVF   xC9,W
0A2EC:  SUBWF  xD7,W
0A2EE:  BNC   A2FC
....................                { 
....................                   terminate(1); 
0A2F0:  MOVLW  01
0A2F2:  MOVWF  xEB
0A2F4:  MOVLB  0
0A2F6:  CALL   90F8
0A2FA:  MOVLB  8
....................                } 
....................                break; 
0A2FC:  MOVLB  7
0A2FE:  BRA    A728
0A300:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A302:  BCF    FD8.0
0A304:  MOVLB  7
0A306:  RLCF   x40,W
0A308:  CLRF   03
0A30A:  ADDLW  9A
0A30C:  MOVWF  FE9
0A30E:  MOVLW  07
0A310:  ADDWFC 03,W
0A312:  MOVWF  FEA
0A314:  MOVFF  FEC,8D8
0A318:  MOVF   FED,F
0A31A:  MOVFF  FEF,8D7
0A31E:  BCF    FD8.0
0A320:  RLCF   x40,W
0A322:  CLRF   03
0A324:  ADDLW  5A
0A326:  MOVWF  FE9
0A328:  MOVLW  07
0A32A:  ADDWFC 03,W
0A32C:  MOVWF  FEA
0A32E:  MOVFF  FEC,03
0A332:  MOVF   FED,F
0A334:  MOVFF  FEF,01
0A338:  MOVF   03,W
0A33A:  MOVLB  8
0A33C:  SUBWF  xD8,W
0A33E:  BNC   A352
0A340:  BNZ   A348
0A342:  MOVF   01,W
0A344:  SUBWF  xD7,W
0A346:  BNC   A352
....................                { 
....................                   terminate(0); 
0A348:  CLRF   xEB
0A34A:  MOVLB  0
0A34C:  CALL   90F8
0A350:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A352:  BCF    FD8.0
0A354:  MOVLB  7
0A356:  RLCF   x40,W
0A358:  CLRF   03
0A35A:  ADDLW  BB
0A35C:  MOVWF  FE9
0A35E:  MOVLW  07
0A360:  ADDWFC 03,W
0A362:  MOVWF  FEA
0A364:  MOVFF  FEC,8D8
0A368:  MOVF   FED,F
0A36A:  MOVFF  FEF,8D7
0A36E:  MOVLB  8
0A370:  MOVF   xCC,F
0A372:  BNZ   A3CA
0A374:  MOVF   xCB,F
0A376:  BNZ   A3CA
0A378:  MOVF   xCA,W
0A37A:  SUBWF  xD8,W
0A37C:  BNC   A3CA
0A37E:  BNZ   A386
0A380:  MOVF   xC9,W
0A382:  SUBWF  xD7,W
0A384:  BNC   A3CA
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A386:  BCF    FD8.0
0A388:  MOVLB  7
0A38A:  RLCF   x40,W
0A38C:  CLRF   03
0A38E:  ADDLW  B7
0A390:  MOVWF  FE9
0A392:  MOVLW  07
0A394:  ADDWFC 03,W
0A396:  MOVWF  FEA
0A398:  MOVFF  FEC,8DE
0A39C:  MOVF   FED,F
0A39E:  MOVFF  FEF,8DD
0A3A2:  MOVFF  8CC,8DC
0A3A6:  MOVFF  8CB,8DB
0A3AA:  MOVFF  8CA,8DA
0A3AE:  MOVFF  8C9,8D9
0A3B2:  MOVLB  0
0A3B4:  CALL   96B8
0A3B8:  MOVFF  03,8D1
0A3BC:  MOVFF  02,8D0
0A3C0:  MOVFF  01,8CF
0A3C4:  MOVFF  00,8CE
0A3C8:  MOVLB  8
....................                } 
....................                break; 
0A3CA:  MOVLB  7
0A3CC:  BRA    A728
0A3CE:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A3D0:  BCF    FD8.0
0A3D2:  MOVLB  7
0A3D4:  RLCF   x40,W
0A3D6:  CLRF   03
0A3D8:  ADDLW  BB
0A3DA:  MOVWF  FE9
0A3DC:  MOVLW  07
0A3DE:  ADDWFC 03,W
0A3E0:  MOVWF  FEA
0A3E2:  MOVFF  FEC,8D8
0A3E6:  MOVF   FED,F
0A3E8:  MOVFF  FEF,8D7
0A3EC:  MOVLB  8
0A3EE:  MOVF   xCC,F
0A3F0:  BNZ   A40E
0A3F2:  MOVF   xCB,F
0A3F4:  BNZ   A40E
0A3F6:  MOVF   xCA,W
0A3F8:  SUBWF  xD8,W
0A3FA:  BNC   A40E
0A3FC:  BNZ   A404
0A3FE:  MOVF   xC9,W
0A400:  SUBWF  xD7,W
0A402:  BNC   A40E
....................                { 
....................                   terminate(0); 
0A404:  CLRF   xEB
0A406:  MOVLB  0
0A408:  CALL   90F8
0A40C:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A40E:  BCF    FD8.0
0A410:  MOVLB  7
0A412:  RLCF   x40,W
0A414:  CLRF   03
0A416:  ADDLW  7A
0A418:  MOVWF  FE9
0A41A:  MOVLW  07
0A41C:  ADDWFC 03,W
0A41E:  MOVWF  FEA
0A420:  MOVFF  FEC,8D8
0A424:  MOVF   FED,F
0A426:  MOVFF  FEF,8D7
0A42A:  MOVLB  8
0A42C:  MOVF   xD7,F
0A42E:  BNZ   A494
0A430:  MOVF   xD8,F
0A432:  BNZ   A494
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A434:  CLRF   03
0A436:  MOVLB  7
0A438:  MOVF   x40,W
0A43A:  ADDLW  CB
0A43C:  MOVWF  FE9
0A43E:  MOVLW  07
0A440:  ADDWFC 03,W
0A442:  MOVWF  FEA
0A444:  MOVF   FEF,F
0A446:  BNZ   A492
....................                   { 
....................                      wrt_m_error(); 
0A448:  MOVLB  0
0A44A:  CALL   8FA8
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A44E:  BCF    FD8.0
0A450:  MOVLB  7
0A452:  RLCF   x40,W
0A454:  CLRF   03
0A456:  ADDLW  B7
0A458:  MOVWF  FE9
0A45A:  MOVLW  07
0A45C:  ADDWFC 03,W
0A45E:  MOVWF  FEA
0A460:  MOVFF  FEC,8DE
0A464:  MOVF   FED,F
0A466:  MOVFF  FEF,8DD
0A46A:  MOVFF  8CC,8DC
0A46E:  MOVFF  8CB,8DB
0A472:  MOVFF  8CA,8DA
0A476:  MOVFF  8C9,8D9
0A47A:  MOVLB  0
0A47C:  CALL   96B8
0A480:  MOVFF  03,8D1
0A484:  MOVFF  02,8D0
0A488:  MOVFF  01,8CF
0A48C:  MOVFF  00,8CE
0A490:  MOVLB  7
0A492:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A494:  BCF    FD8.0
0A496:  MOVLB  7
0A498:  RLCF   x40,W
0A49A:  CLRF   03
0A49C:  ADDLW  7A
0A49E:  MOVWF  FE9
0A4A0:  MOVLW  07
0A4A2:  ADDWFC 03,W
0A4A4:  MOVWF  FEA
0A4A6:  MOVFF  FEC,8D8
0A4AA:  MOVF   FED,F
0A4AC:  MOVFF  FEF,8D7
0A4B0:  MOVLB  8
0A4B2:  DECFSZ xD7,W
0A4B4:  BRA    A51A
0A4B6:  MOVF   xD8,F
0A4B8:  BNZ   A51A
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A4BA:  CLRF   03
0A4BC:  MOVLB  7
0A4BE:  MOVF   x40,W
0A4C0:  ADDLW  CB
0A4C2:  MOVWF  FE9
0A4C4:  MOVLW  07
0A4C6:  ADDWFC 03,W
0A4C8:  MOVWF  FEA
0A4CA:  DECFSZ FEF,W
0A4CC:  BRA    A518
....................                   { 
....................                      wrt_m_error(); 
0A4CE:  MOVLB  0
0A4D0:  CALL   8FA8
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A4D4:  BCF    FD8.0
0A4D6:  MOVLB  7
0A4D8:  RLCF   x40,W
0A4DA:  CLRF   03
0A4DC:  ADDLW  B7
0A4DE:  MOVWF  FE9
0A4E0:  MOVLW  07
0A4E2:  ADDWFC 03,W
0A4E4:  MOVWF  FEA
0A4E6:  MOVFF  FEC,8DE
0A4EA:  MOVF   FED,F
0A4EC:  MOVFF  FEF,8DD
0A4F0:  MOVFF  8CC,8DC
0A4F4:  MOVFF  8CB,8DB
0A4F8:  MOVFF  8CA,8DA
0A4FC:  MOVFF  8C9,8D9
0A500:  MOVLB  0
0A502:  CALL   96B8
0A506:  MOVFF  03,8D1
0A50A:  MOVFF  02,8D0
0A50E:  MOVFF  01,8CF
0A512:  MOVFF  00,8CE
0A516:  MOVLB  7
0A518:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A51A:  MOVLB  7
0A51C:  BRA    A728
0A51E:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A520:  MOVLB  7
0A522:  MOVF   x40,W
0A524:  MULLW  04
0A526:  MOVF   FF3,W
0A528:  CLRF   03
0A52A:  ADDLW  A2
0A52C:  MOVWF  FE9
0A52E:  MOVLW  07
0A530:  ADDWFC 03,W
0A532:  MOVWF  FEA
0A534:  MOVFF  FEF,8D7
0A538:  MOVFF  FEC,8D8
0A53C:  MOVFF  FEC,8D9
0A540:  MOVFF  FEC,8DA
0A544:  MOVLB  8
0A546:  MOVF   xCE,W
0A548:  SUBWF  xD7,F
0A54A:  MOVF   xCF,W
0A54C:  SUBWFB xD8,F
0A54E:  MOVF   xD0,W
0A550:  SUBWFB xD9,F
0A552:  MOVF   xD1,W
0A554:  SUBWFB xDA,F
0A556:  BNZ   A56E
0A558:  MOVF   xD9,F
0A55A:  BNZ   A56E
0A55C:  MOVF   xD5,W
0A55E:  SUBWF  xD8,W
0A560:  BTFSS  FD8.0
0A562:  BRA    A66A
0A564:  BNZ   A56E
0A566:  MOVF   xD4,W
0A568:  SUBWF  xD7,W
0A56A:  BTFSS  FD8.0
0A56C:  BRA    A66A
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A56E:  BCF    FD8.0
0A570:  MOVLB  7
0A572:  RLCF   x40,W
0A574:  CLRF   03
0A576:  ADDLW  66
0A578:  MOVWF  01
0A57A:  MOVLW  07
0A57C:  ADDWFC 03,F
0A57E:  MOVLB  8
0A580:  MOVFF  03,8D8
0A584:  BCF    FD8.0
0A586:  MOVLB  7
0A588:  RLCF   x40,W
0A58A:  CLRF   03
0A58C:  ADDLW  9E
0A58E:  MOVWF  FE9
0A590:  MOVLW  07
0A592:  ADDWFC 03,W
0A594:  MOVWF  FEA
0A596:  MOVFF  FEC,03
0A59A:  MOVF   FED,F
0A59C:  MOVFF  FEF,8D9
0A5A0:  MOVLB  8
0A5A2:  MOVFF  8D8,FEA
0A5A6:  MOVFF  01,FE9
0A5AA:  MOVFF  03,FEC
0A5AE:  MOVF   FED,F
0A5B0:  MOVFF  8D9,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A5B4:  MOVLB  7
0A5B6:  MOVF   x40,W
0A5B8:  MULLW  04
0A5BA:  MOVF   FF3,W
0A5BC:  CLRF   03
0A5BE:  ADDLW  A2
0A5C0:  MOVWF  FE9
0A5C2:  MOVLW  07
0A5C4:  ADDWFC 03,W
0A5C6:  MOVWF  FEA
0A5C8:  MOVFF  FEF,8D7
0A5CC:  MOVFF  FEC,8D8
0A5D0:  MOVFF  FEC,8D9
0A5D4:  MOVFF  FEC,8DA
0A5D8:  MOVLW  AC
0A5DA:  MOVWF  FF6
0A5DC:  MOVLW  1A
0A5DE:  MOVWF  FF7
0A5E0:  MOVLW  00
0A5E2:  MOVWF  FF8
0A5E4:  CLRF   1B
0A5E6:  BTFSC  FF2.7
0A5E8:  BSF    1B.7
0A5EA:  BCF    FF2.7
0A5EC:  MOVLW  0B
0A5EE:  MOVLB  A
0A5F0:  MOVWF  x40
0A5F2:  MOVLB  0
0A5F4:  CALL   1044
0A5F8:  BTFSC  1B.7
0A5FA:  BSF    FF2.7
0A5FC:  MOVLW  41
0A5FE:  MOVWF  FE9
0A600:  CLRF   1B
0A602:  BTFSC  FF2.7
0A604:  BSF    1B.7
0A606:  BCF    FF2.7
0A608:  MOVFF  8DA,A43
0A60C:  MOVFF  8D9,A42
0A610:  MOVFF  8D8,A41
0A614:  MOVFF  8D7,A40
0A618:  CALL   110A
0A61C:  BTFSC  1B.7
0A61E:  BSF    FF2.7
0A620:  MOVLW  2C
0A622:  BTFSS  F9E.4
0A624:  BRA    A622
0A626:  MOVWF  FAD
0A628:  MOVLW  41
0A62A:  MOVWF  FE9
0A62C:  CLRF   1B
0A62E:  BTFSC  FF2.7
0A630:  BSF    1B.7
0A632:  BCF    FF2.7
0A634:  MOVFF  8D1,A43
0A638:  MOVFF  8D0,A42
0A63C:  MOVFF  8CF,A41
0A640:  MOVFF  8CE,A40
0A644:  CALL   110A
0A648:  BTFSC  1B.7
0A64A:  BSF    FF2.7
0A64C:  MOVLW  0D
0A64E:  BTFSS  F9E.4
0A650:  BRA    A64E
0A652:  MOVWF  FAD
0A654:  MOVLW  0A
0A656:  BTFSS  F9E.4
0A658:  BRA    A656
0A65A:  MOVWF  FAD
....................                   terminate(1); 
0A65C:  MOVLW  01
0A65E:  MOVLB  8
0A660:  MOVWF  xEB
0A662:  MOVLB  0
0A664:  CALL   90F8
0A668:  MOVLB  8
....................                } 
....................                break; 
0A66A:  MOVLB  7
0A66C:  BRA    A728
0A66E:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A670:  MOVLB  7
0A672:  MOVF   x40,W
0A674:  MULLW  04
0A676:  MOVF   FF3,W
0A678:  CLRF   03
0A67A:  ADDLW  A2
0A67C:  MOVWF  FE9
0A67E:  MOVLW  07
0A680:  ADDWFC 03,W
0A682:  MOVWF  FEA
0A684:  MOVFF  FEF,8D7
0A688:  MOVFF  FEC,8D8
0A68C:  MOVFF  FEC,8D9
0A690:  MOVFF  FEC,8DA
0A694:  BCF    FD8.0
0A696:  RLCF   x40,W
0A698:  CLRF   03
0A69A:  ADDLW  72
0A69C:  MOVWF  FE9
0A69E:  MOVLW  07
0A6A0:  ADDWFC 03,W
0A6A2:  MOVWF  FEA
0A6A4:  MOVFF  FEC,03
0A6A8:  MOVF   FED,F
0A6AA:  MOVFF  FEF,01
0A6AE:  MOVLB  8
0A6B0:  MOVF   xDA,F
0A6B2:  BNZ   A6C6
0A6B4:  MOVF   xD9,F
0A6B6:  BNZ   A6C6
0A6B8:  MOVF   03,W
0A6BA:  SUBWF  xD8,W
0A6BC:  BNC   A726
0A6BE:  BNZ   A6C6
0A6C0:  MOVF   01,W
0A6C2:  SUBWF  xD7,W
0A6C4:  BNC   A726
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A6C6:  BCF    FD8.0
0A6C8:  MOVLB  7
0A6CA:  RLCF   x40,W
0A6CC:  CLRF   03
0A6CE:  ADDLW  66
0A6D0:  MOVWF  01
0A6D2:  MOVLW  07
0A6D4:  ADDWFC 03,F
0A6D6:  MOVLB  8
0A6D8:  MOVFF  03,8D8
0A6DC:  BCF    FD8.0
0A6DE:  MOVLB  7
0A6E0:  RLCF   x40,W
0A6E2:  CLRF   03
0A6E4:  ADDLW  9E
0A6E6:  MOVWF  FE9
0A6E8:  MOVLW  07
0A6EA:  ADDWFC 03,W
0A6EC:  MOVWF  FEA
0A6EE:  MOVFF  FEC,03
0A6F2:  MOVF   FED,F
0A6F4:  MOVFF  FEF,8D9
0A6F8:  MOVLB  8
0A6FA:  MOVFF  8D8,FEA
0A6FE:  MOVFF  01,FE9
0A702:  MOVFF  03,FEC
0A706:  MOVF   FED,F
0A708:  MOVFF  8D9,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A70C:  BCF    FD8.0
0A70E:  MOVLB  7
0A710:  RLCF   x40,W
0A712:  CLRF   03
0A714:  ADDLW  BB
0A716:  MOVWF  FE9
0A718:  MOVLW  07
0A71A:  ADDWFC 03,W
0A71C:  MOVWF  FEA
0A71E:  CLRF   FEC
0A720:  MOVF   FED,F
0A722:  CLRF   FEF
0A724:  MOVLB  8
....................                } 
....................                break; 
0A726:  MOVLB  7
....................             } 
....................          } 
0A728:  MOVLB  0
0A72A:  BRA    A21C
0A72C:  MOVLB  7
....................       } 
....................    } 
0A72E:  BRA    A74C
0A730:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A732:  BCF    FD8.0
0A734:  MOVLB  7
0A736:  RLCF   x40,W
0A738:  CLRF   03
0A73A:  ADDLW  96
0A73C:  MOVWF  FE9
0A73E:  MOVLW  07
0A740:  ADDWFC 03,W
0A742:  MOVWF  FEA
0A744:  CLRF   FEC
0A746:  MOVF   FED,F
0A748:  MOVLW  01
0A74A:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A74C:  BCF    FD8.0
0A74E:  RLCF   x40,W
0A750:  CLRF   03
0A752:  ADDLW  96
0A754:  MOVWF  FE9
0A756:  MOVLW  07
0A758:  ADDWFC 03,W
0A75A:  MOVWF  FEA
0A75C:  MOVFF  FEC,8D8
0A760:  MOVF   FED,F
0A762:  MOVFF  FEF,8D7
0A766:  MOVLB  8
0A768:  DECFSZ xD7,W
0A76A:  BRA    A77C
0A76C:  MOVF   xD8,F
0A76E:  BNZ   A77C
....................       wrt_m_error(); 
0A770:  MOVLB  0
0A772:  CALL   8FA8
....................       msg_mer(); 
0A776:  CALL   9D2A
0A77A:  MOVLB  8
....................    } 
0A77C:  MOVLB  0
0A77E:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
170CE:  MOVF   48,F
170D0:  BNZ   170DE
170D2:  MOVF   49,F
170D4:  BNZ   170DE
170D6:  MOVF   4A,F
170D8:  BNZ   170DE
170DA:  MOVF   4B,F
170DC:  BZ    1710A
170DE:  MOVF   4B,F
170E0:  BNZ   1710A
170E2:  MOVF   4A,W
170E4:  SUBLW  00
170E6:  BNC   1710A
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
170E8:  MOVFF  885,8C7
170EC:  MOVFF  886,8C8
170F0:  MOVFF  4B,8CC
170F4:  MOVFF  4A,8CB
170F8:  MOVFF  49,8CA
170FC:  MOVFF  48,8C9
17100:  MOVFF  887,8CD
17104:  CALL   9DA0
....................    } 
17108:  BRA    17186
....................    else if(arg==0) 
1710A:  MOVF   48,F
1710C:  BNZ   17182
1710E:  MOVF   49,F
17110:  BNZ   17182
17112:  MOVF   4A,F
17114:  BNZ   17182
17116:  MOVF   4B,F
17118:  BNZ   17182
....................    { 
....................       m_lin_pos[motor]=0; 
1711A:  BCF    FD8.0
1711C:  MOVLB  7
1711E:  RLCF   x40,W
17120:  CLRF   03
17122:  ADDLW  B3
17124:  MOVWF  FE9
17126:  MOVLW  07
17128:  ADDWFC 03,W
1712A:  MOVWF  FEA
1712C:  CLRF   FEC
1712E:  MOVF   FED,F
17130:  CLRF   FEF
....................       switch (motor){ 
17132:  MOVF   x40,W
17134:  XORLW  00
17136:  MOVLB  0
17138:  BZ    17140
1713A:  XORLW  01
1713C:  BZ    17152
1713E:  BRA    17162
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
17140:  MOVLW  B6
17142:  MOVLB  8
17144:  MOVWF  xEE
17146:  CLRF   xF0
17148:  CLRF   xEF
1714A:  MOVLB  0
1714C:  CALL   4FFC
....................             break; 
17150:  BRA    17162
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
17152:  MOVLW  B8
17154:  MOVLB  8
17156:  MOVWF  xEE
17158:  CLRF   xF0
1715A:  CLRF   xEF
1715C:  MOVLB  0
1715E:  CALL   4FFC
....................             break; 
....................       }  
....................       m_error[motor]=0; 
17162:  BCF    FD8.0
17164:  MOVLB  7
17166:  RLCF   x40,W
17168:  CLRF   03
1716A:  ADDLW  96
1716C:  MOVWF  FE9
1716E:  MOVLW  07
17170:  ADDWFC 03,W
17172:  MOVWF  FEA
17174:  CLRF   FEC
17176:  MOVF   FED,F
17178:  CLRF   FEF
....................       wrt_m_error(); 
1717A:  MOVLB  0
1717C:  CALL   8FA8
....................    } 
17180:  BRA    17186
....................    else cmd_arg(); 
17182:  CALL   B326
17186:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
18C08:  MOVLW  01
18C0A:  MOVLB  8
18C0C:  MOVWF  xEC
18C0E:  MOVLB  0
18C10:  CALL   89F8
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18C14:  MOVLW  FA
18C16:  MOVLB  9
18C18:  MOVWF  xEC
18C1A:  MOVLB  0
18C1C:  CALL   2938
....................       switch(motor) 
18C20:  MOVLB  7
18C22:  MOVF   x40,W
18C24:  XORLW  00
18C26:  MOVLB  0
18C28:  BZ    18C30
18C2A:  XORLW  01
18C2C:  BZ    18C42
18C2E:  BRA    18C52
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18C30:  MOVLB  8
18C32:  CLRF   x85
18C34:  BTFSC  F81.4
18C36:  INCF   x85,F
....................             chanA = input(ENC1_PHA); 
18C38:  CLRF   x86
18C3A:  BTFSC  F81.1
18C3C:  INCF   x86,F
....................             break; 
18C3E:  MOVLB  0
18C40:  BRA    18C52
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18C42:  MOVLB  8
18C44:  CLRF   x85
18C46:  BTFSC  F81.5
18C48:  INCF   x85,F
....................             chanA = input(ENC2_PHA); 
18C4A:  CLRF   x86
18C4C:  BTFSC  F81.2
18C4E:  INCF   x86,F
....................             break; 
18C50:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18C52:  MOVLW  C2
18C54:  MOVWF  FF6
18C56:  MOVLW  1A
18C58:  MOVWF  FF7
18C5A:  MOVLW  00
18C5C:  MOVWF  FF8
18C5E:  CLRF   1B
18C60:  BTFSC  FF2.7
18C62:  BSF    1B.7
18C64:  BCF    FF2.7
18C66:  MOVLW  04
18C68:  MOVLB  A
18C6A:  MOVWF  x40
18C6C:  MOVLB  0
18C6E:  CALL   1044
18C72:  BTFSC  1B.7
18C74:  BSF    FF2.7
18C76:  CLRF   1B
18C78:  BTFSC  FF2.7
18C7A:  BSF    1B.7
18C7C:  BCF    FF2.7
18C7E:  MOVFF  885,A40
18C82:  MOVLW  1B
18C84:  MOVLB  A
18C86:  MOVWF  x41
18C88:  MOVLB  0
18C8A:  CALL   0FC6
18C8E:  BTFSC  1B.7
18C90:  BSF    FF2.7
18C92:  MOVLW  C8
18C94:  MOVWF  FF6
18C96:  MOVLW  1A
18C98:  MOVWF  FF7
18C9A:  MOVLW  00
18C9C:  MOVWF  FF8
18C9E:  CLRF   1B
18CA0:  BTFSC  FF2.7
18CA2:  BSF    1B.7
18CA4:  BCF    FF2.7
18CA6:  MOVLW  07
18CA8:  MOVLB  A
18CAA:  MOVWF  x40
18CAC:  MOVLB  0
18CAE:  CALL   1044
18CB2:  BTFSC  1B.7
18CB4:  BSF    FF2.7
18CB6:  CLRF   1B
18CB8:  BTFSC  FF2.7
18CBA:  BSF    1B.7
18CBC:  BCF    FF2.7
18CBE:  MOVFF  886,A40
18CC2:  MOVLW  1B
18CC4:  MOVLB  A
18CC6:  MOVWF  x41
18CC8:  MOVLB  0
18CCA:  CALL   0FC6
18CCE:  BTFSC  1B.7
18CD0:  BSF    FF2.7
18CD2:  MOVLW  0D
18CD4:  BTFSS  F9E.4
18CD6:  BRA    18CD4
18CD8:  MOVWF  FAD
18CDA:  MOVLW  0A
18CDC:  BTFSS  F9E.4
18CDE:  BRA    18CDC
18CE0:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
18CE2:  BTFSS  F9E.5
18CE4:  BRA    18CF2
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
18CE6:  CALL   0E58
18CEA:  MOVF   01,W
18CEC:  SUBLW  1B
18CEE:  BNZ   18CF2
....................          { 
....................             break; 
18CF0:  BRA    18CF4
....................          } 
....................       } 
18CF2:  BRA    18C14
....................    } 
....................  
....................    delay_ms(100); 
18CF4:  MOVLW  64
18CF6:  MOVLB  9
18CF8:  MOVWF  xEC
18CFA:  MOVLB  0
18CFC:  CALL   2938
....................    enc_pwr(OFF); 
18D00:  MOVLB  8
18D02:  CLRF   xEC
18D04:  MOVLB  0
18D06:  CALL   89F8
18D0A:  GOTO   18D26 (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A8DC:  BCF    FD8.0
0A8DE:  MOVLB  7
0A8E0:  RLCF   x40,W
0A8E2:  CLRF   03
0A8E4:  ADDLW  66
0A8E6:  MOVWF  FE9
0A8E8:  MOVLW  07
0A8EA:  ADDWFC 03,W
0A8EC:  MOVWF  FEA
0A8EE:  MOVFF  FEC,8C6
0A8F2:  MOVF   FED,F
0A8F4:  MOVFF  FEF,8C5
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A8F8:  BCF    FD8.0
0A8FA:  RLCF   x40,W
0A8FC:  CLRF   03
0A8FE:  ADDLW  76
0A900:  MOVWF  FE9
0A902:  MOVLW  07
0A904:  ADDWFC 03,W
0A906:  MOVWF  FEA
0A908:  MOVFF  FEC,8DC
0A90C:  MOVF   FED,F
0A90E:  MOVFF  FEF,8DB
0A912:  BCF    FD8.0
0A914:  RLCF   x40,W
0A916:  CLRF   03
0A918:  ADDLW  62
0A91A:  MOVWF  FE9
0A91C:  MOVLW  07
0A91E:  ADDWFC 03,W
0A920:  MOVWF  FEA
0A922:  MOVFF  FEC,03
0A926:  MOVF   FED,F
0A928:  MOVFF  FEF,8DD
0A92C:  MOVFF  03,8CA
0A930:  MOVFF  03,8DE
0A934:  MOVLB  0
0A936:  CALL   2CFC
0A93A:  MOVFF  02,8C4
0A93E:  MOVFF  01,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A942:  BCF    FD8.0
0A944:  MOVLB  7
0A946:  RLCF   x40,W
0A948:  CLRF   03
0A94A:  ADDLW  66
0A94C:  MOVWF  FE9
0A94E:  MOVLW  07
0A950:  ADDWFC 03,W
0A952:  MOVWF  FEA
0A954:  CLRF   FEC
0A956:  MOVF   FED,F
0A958:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A95A:  MOVLB  8
0A95C:  CLRF   xC7
0A95E:  MOVFF  8C2,8C8
0A962:  CLRF   xCC
0A964:  CLRF   xCB
0A966:  MOVFF  8C4,8CA
0A96A:  MOVFF  8C3,8C9
0A96E:  MOVLW  01
0A970:  MOVWF  xCD
0A972:  MOVLB  0
0A974:  CALL   9DA0
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A978:  MOVLW  01
0A97A:  MOVLB  8
0A97C:  MOVWF  xEC
0A97E:  MOVLB  0
0A980:  CALL   89F8
....................    delay_ms(100); 
0A984:  MOVLW  64
0A986:  MOVLB  9
0A988:  MOVWF  xEC
0A98A:  MOVLB  0
0A98C:  CALL   2938
....................    poll_index(); 
0A990:  BRA    A7AA
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A992:  BCF    FD8.0
0A994:  MOVLB  7
0A996:  RLCF   x40,W
0A998:  CLRF   03
0A99A:  ADDLW  5E
0A99C:  MOVWF  FE9
0A99E:  MOVLW  07
0A9A0:  ADDWFC 03,W
0A9A2:  MOVWF  FEA
0A9A4:  MOVFF  FEC,8C8
0A9A8:  MOVF   FED,F
0A9AA:  MOVFF  FEF,8C7
0A9AE:  MOVLW  02
0A9B0:  MOVLB  8
0A9B2:  ADDWF  xC7,W
0A9B4:  MOVWF  xC3
0A9B6:  MOVLW  00
0A9B8:  ADDWFC xC8,W
0A9BA:  MOVWF  xC4
....................    e_mode[motor] = 3; 
0A9BC:  BCF    FD8.0
0A9BE:  MOVLB  7
0A9C0:  RLCF   x40,W
0A9C2:  CLRF   03
0A9C4:  ADDLW  66
0A9C6:  MOVWF  FE9
0A9C8:  MOVLW  07
0A9CA:  ADDWFC 03,W
0A9CC:  MOVWF  FEA
0A9CE:  CLRF   FEC
0A9D0:  MOVF   FED,F
0A9D2:  MOVLW  03
0A9D4:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A9D6:  MOVLB  8
0A9D8:  CLRF   xC7
0A9DA:  MOVFF  8C2,8C8
0A9DE:  CLRF   xCC
0A9E0:  CLRF   xCB
0A9E2:  MOVFF  8C4,8CA
0A9E6:  MOVFF  8C3,8C9
0A9EA:  MOVLW  01
0A9EC:  MOVWF  xCD
0A9EE:  MOVLB  0
0A9F0:  CALL   9DA0
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A9F4:  MOVFF  783,8C4
0A9F8:  MOVFF  782,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A9FC:  BCF    FD8.0
0A9FE:  MOVLB  7
0AA00:  RLCF   x40,W
0AA02:  CLRF   03
0AA04:  ADDLW  66
0AA06:  MOVWF  FE9
0AA08:  MOVLW  07
0AA0A:  ADDWFC 03,W
0AA0C:  MOVWF  FEA
0AA0E:  CLRF   FEC
0AA10:  MOVF   FED,F
0AA12:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0AA14:  MOVLB  8
0AA16:  CLRF   xC7
0AA18:  MOVFF  8C2,8C8
0AA1C:  CLRF   xCC
0AA1E:  CLRF   xCB
0AA20:  MOVFF  8C4,8CA
0AA24:  MOVFF  8C3,8C9
0AA28:  MOVLW  01
0AA2A:  MOVWF  xCD
0AA2C:  MOVLB  0
0AA2E:  CALL   9DA0
....................  
....................    e_pos[motor] = 0; 
0AA32:  BCF    FD8.0
0AA34:  MOVLB  7
0AA36:  RLCF   x40,W
0AA38:  CLRF   03
0AA3A:  ADDLW  BF
0AA3C:  MOVWF  FE9
0AA3E:  MOVLW  07
0AA40:  ADDWFC 03,W
0AA42:  MOVWF  FEA
0AA44:  CLRF   FEC
0AA46:  MOVF   FED,F
0AA48:  CLRF   FEF
....................    e_port[motor] = 1; 
0AA4A:  BCF    FD8.0
0AA4C:  RLCF   x40,W
0AA4E:  CLRF   03
0AA50:  ADDLW  C3
0AA52:  MOVWF  FE9
0AA54:  MOVLW  07
0AA56:  ADDWFC 03,W
0AA58:  MOVWF  FEA
0AA5A:  CLRF   FEC
0AA5C:  MOVF   FED,F
0AA5E:  MOVLW  01
0AA60:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0AA62:  BCF    FD8.0
0AA64:  RLCF   x40,W
0AA66:  CLRF   03
0AA68:  ADDLW  66
0AA6A:  MOVWF  FE9
0AA6C:  MOVLW  07
0AA6E:  ADDWFC 03,W
0AA70:  MOVWF  FEA
0AA72:  MOVFF  8C6,FEC
0AA76:  MOVF   FED,F
0AA78:  MOVFF  8C5,FEF
0AA7C:  MOVLB  0
0AA7E:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0E0DC:  BCF    FD8.0
0E0DE:  MOVLB  7
0E0E0:  RLCF   x40,W
0E0E2:  CLRF   03
0E0E4:  ADDLW  5E
0E0E6:  MOVWF  FE9
0E0E8:  MOVLW  07
0E0EA:  ADDWFC 03,W
0E0EC:  MOVWF  FEA
0E0EE:  MOVFF  FEC,889
0E0F2:  MOVF   FED,F
0E0F4:  MOVFF  FEF,888
0E0F8:  MOVLW  02
0E0FA:  MOVLB  8
0E0FC:  ADDWF  x88,W
0E0FE:  MOVWF  x86
0E100:  MOVLW  00
0E102:  ADDWFC x89,W
0E104:  MOVWF  x87
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0E106:  CLRF   xC7
0E108:  MOVFF  885,8C8
0E10C:  CLRF   xCC
0E10E:  CLRF   xCB
0E110:  MOVFF  887,8CA
0E114:  MOVFF  886,8C9
0E118:  MOVLW  02
0E11A:  MOVWF  xCD
0E11C:  MOVLB  0
0E11E:  CALL   9DA0
0E122:  GOTO   E1A2 (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0AA80:  MOVF   2F,W
0AA82:  SUBLW  02
0AA84:  BNZ   AA8A
0AA86:  MOVF   30,F
0AA88:  BZ    AAF2
....................    { 
....................       //setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_256); 
....................       //set up valve timeout variable 
....................       /*ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
....................       enable_interrupts(INT_EXT); 
....................  
....................       start_heartbeat(); 
....................  
....................       enable_interrupts(GLOBAL); 
....................       busy_set();*/ 
....................       valve_align_timeout = 0; 
0AA8A:  CLRF   3A
0AA8C:  CLRF   39
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0AA8E:  MOVLW  D4
0AA90:  MOVWF  FF6
0AA92:  MOVLW  1A
0AA94:  MOVWF  FF7
0AA96:  MOVLW  00
0AA98:  MOVWF  FF8
0AA9A:  CLRF   1B
0AA9C:  BTFSC  FF2.7
0AA9E:  BSF    1B.7
0AAA0:  BCF    FF2.7
0AAA2:  CALL   0E6E
0AAA6:  BTFSC  1B.7
0AAA8:  BSF    FF2.7
....................       motor=0; 
0AAAA:  MOVLB  7
0AAAC:  CLRF   x40
....................       align(0); 
0AAAE:  MOVLB  8
0AAB0:  CLRF   xC2
0AAB2:  MOVLB  0
0AAB4:  RCALL  A8DC
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0AAB6:  MOVLW  01
0AAB8:  MOVLB  7
0AABA:  MOVWF  x40
....................       move_motor(0,0,22000,1); 
0AABC:  MOVLB  8
0AABE:  CLRF   xC7
0AAC0:  CLRF   xC8
0AAC2:  CLRF   xCC
0AAC4:  CLRF   xCB
0AAC6:  MOVLW  55
0AAC8:  MOVWF  xCA
0AACA:  MOVLW  F0
0AACC:  MOVWF  xC9
0AACE:  MOVLW  01
0AAD0:  MOVWF  xCD
0AAD2:  MOVLB  0
0AAD4:  CALL   9DA0
....................        
....................       m_lin_pos[1]=0; 
0AAD8:  MOVLB  7
0AADA:  CLRF   xB6
0AADC:  CLRF   xB5
....................       write16(ADDR_M2_LIN_POS,0); 
0AADE:  MOVLW  B8
0AAE0:  MOVLB  8
0AAE2:  MOVWF  xEE
0AAE4:  CLRF   xF0
0AAE6:  CLRF   xEF
0AAE8:  MOVLB  0
0AAEA:  CALL   4FFC
....................       valve_align_timeout = -1; 
0AAEE:  SETF   3A
0AAF0:  SETF   39
....................    } 
0AAF2:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0C22A:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C22C:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0C22E:  BCF    F8E.3
....................   delay_ms(20); 
0C230:  MOVLW  14
0C232:  MOVLB  9
0C234:  MOVWF  xEC
0C236:  MOVLB  0
0C238:  CALL   2938
....................   output_bit(VMOT,  OFF); 
0C23C:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0C23E:  BCF    F8E.2
0C240:  GOTO   C296 (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C244:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C246:  BSF    F8E.1
....................   delay_ms(50); 
0C248:  MOVLW  32
0C24A:  MOVLB  9
0C24C:  MOVWF  xEC
0C24E:  MOVLB  0
0C250:  CALL   2938
....................   output_bit(HB_IN1,ON);           
0C254:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C256:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0C258:  BSF    F8E.3
0C25A:  GOTO   C296 (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C25E:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C260:  BSF    F8E.1
....................   delay_ms(50); 
0C262:  MOVLW  32
0C264:  MOVLB  9
0C266:  MOVWF  xEC
0C268:  MOVLB  0
0C26A:  CALL   2938
....................   output_bit(HB_IN1,OFF);           
0C26E:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0C270:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0C272:  BSF    F8E.3
0C274:  GOTO   C296 (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0C278:  MOVLB  8
0C27A:  MOVF   xB5,W
0C27C:  XORLW  00
0C27E:  MOVLB  0
0C280:  BZ    C28C
0C282:  XORLW  01
0C284:  BZ    C290
0C286:  XORLW  03
0C288:  BZ    C294
0C28A:  BRA    C296
....................       case 0:  HB_all_OFF(); 
0C28C:  BRA    C22A
....................          break; 
0C28E:  BRA    C296
....................       case 1:  HB_m1_ON(); 
0C290:  BRA    C244
....................          break; 
0C292:  BRA    C296
....................       case 2:  HB_m2_ON(); 
0C294:  BRA    C25E
....................          break; 
....................    } 
0C296:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
15DC6:  MOVLB  8
15DC8:  CLRF   x89
15DCA:  CLRF   x8A
15DCC:  CLRF   x8B
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
15DCE:  MOVLB  0
15DD0:  BRA    15D5C
15DD2:  MOVFF  01,88A
....................       if (serChar) 
15DD6:  MOVLB  8
15DD8:  MOVF   x8A,F
15DDA:  BZ    15E04
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
15DDC:  MOVF   x8A,W
15DDE:  SUBLW  24
15DE0:  BNZ   15DEA
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
15DE2:  MOVLW  02
15DE4:  MOVWF  x8B
....................             break; 
15DE6:  BRA    15E10
....................          }else if (serChar == 'D'){ 
15DE8:  BRA    15E04
15DEA:  MOVF   x8A,W
15DEC:  SUBLW  44
15DEE:  BNZ   15E00
....................             wakeup_char_is_D = 1; 
15DF0:  MOVLW  01
15DF2:  MOVLB  7
15DF4:  MOVWF  xCD
....................             wakeUpReason = WAKE_UP_GOOD; 
15DF6:  MOVLW  02
15DF8:  MOVLB  8
15DFA:  MOVWF  x8B
....................             break; 
15DFC:  BRA    15E10
....................          }else 
15DFE:  BRA    15E04
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
15E00:  MOVLW  01
15E02:  MOVWF  x8B
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
15E04:  INCF   x89,F
15E06:  MOVF   x89,W
15E08:  SUBLW  02
15E0A:  BC    15E0E
....................       { 
....................          break; 
15E0C:  BRA    15E10
....................       } 
15E0E:  BRA    15DCE
....................    } 
....................  
....................    return (wakeUpReason); 
15E10:  MOVFF  88B,01
15E14:  MOVLB  0
15E16:  GOTO   15E2A (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
15CF4:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
15CF6:  BSF    4D.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
15CF8:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
15CFA:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
15CFC:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
15CFE:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
15D00:  BSF    FF2.6
15D02:  GOTO   15D0E (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
15D06:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
15D08:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
15D0A:  BCF    4D.0
....................    set_usart_int(); 
15D0C:  BRA    15CF4
....................    kill_wd(); 
15D0E:  CALL   311E
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
15D12:  BSF    FF2.4
....................    sleep();  
15D14:  MOVFF  FD3,00
15D18:  BCF    FD1.7
15D1A:  BCF    FD3.7
15D1C:  SLEEP 
15D1E:  MOVFF  00,FD3
....................    delay_cycles(1); 
15D22:  NOP   
15D24:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
15E1A:  MOVLB  8
15E1C:  CLRF   x88
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
15E1E:  MOVLB  0
15E20:  RCALL  15D26
....................  
....................    if (TRUE != rtc_alarm) 
15E22:  BTFSC  4D.0
15E24:  BRA    15EF4
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15E26:  RCALL  15D26
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15E28:  BRA    15DC6
15E2A:  MOVFF  01,888
....................       if (WAKE_UP_GOOD == serWakeupReason) 
15E2E:  MOVLB  8
15E30:  MOVF   x88,W
15E32:  SUBLW  02
15E34:  BNZ   15EEC
....................       { 
....................          sleep_mode = FALSE; 
15E36:  BCF    4D.1
....................          start_heartbeat(); 
15E38:  MOVLB  0
15E3A:  CALL   2928
....................          init_hardware(); 
15E3E:  CALL   2962
....................          init_rtc();                      // This is the FAT RTC 
15E42:  CALL   3530
....................          sd_status = init_sdcard(); 
15E46:  CALL   5062
15E4A:  MOVFF  01,2DC
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
15E4E:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
15E50:  MOVLW  01
15E52:  MOVWF  1E
15E54:  MOVLW  A7
15E56:  MOVWF  1D
15E58:  MOVLW  0A
15E5A:  MOVWF  FF6
15E5C:  MOVLW  1B
15E5E:  MOVWF  FF7
15E60:  MOVLW  00
15E62:  MOVWF  FF8
15E64:  CALL   50E6
....................          record_event(); 
15E68:  CALL   8502
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15E6C:  CLRF   32
15E6E:  MOVLW  01
15E70:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
15E72:  MOVLW  02
15E74:  MOVLB  8
15E76:  MOVWF  x89
15E78:  MOVFF  31,88A
15E7C:  MOVLB  0
15E7E:  CALL   343A
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................           
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
15E82:  MOVLB  7
15E84:  MOVF   xCD,F
15E86:  BZ    15EAA
....................             file_list(file_ptr_rel_new); 
15E88:  MOVLW  03
15E8A:  MOVLB  8
15E8C:  MOVWF  x8A
15E8E:  MOVLW  07
15E90:  MOVWF  x89
15E92:  MOVLB  0
15E94:  CALL   BB4C
....................             f_unlink(file_ptr_rel_new); 
15E98:  MOVLW  03
15E9A:  MOVLB  8
15E9C:  MOVWF  x8A
15E9E:  MOVLW  07
15EA0:  MOVWF  x89
15EA2:  MOVLB  0
15EA4:  CALL   BCC6
15EA8:  MOVLB  7
....................          } 
....................          if(sd_status>0) 
15EAA:  MOVLB  2
15EAC:  MOVF   xDC,F
15EAE:  BZ    15EB8
....................          { 
....................             msg_card_fail(); 
15EB0:  MOVLB  0
15EB2:  CALL   50A8
15EB6:  MOVLB  2
....................          } 
....................  
....................           
....................          if (!wakeup_char_is_D){ 
15EB8:  MOVLB  7
15EBA:  MOVF   xCD,F
15EBC:  BNZ   15EE2
....................             fprintf(COM_A, "@RST\r\n"); 
15EBE:  MOVLW  2C
15EC0:  MOVWF  FF6
15EC2:  MOVLW  1B
15EC4:  MOVWF  FF7
15EC6:  MOVLW  00
15EC8:  MOVWF  FF8
15ECA:  CLRF   1B
15ECC:  BTFSC  FF2.7
15ECE:  BSF    1B.7
15ED0:  BCF    FF2.7
15ED2:  MOVLB  0
15ED4:  CALL   0E6E
15ED8:  BTFSC  1B.7
15EDA:  BSF    FF2.7
....................             reset_cpu(); 
15EDC:  RESET
....................          }else{ 
15EDE:  BRA    15EE8
15EE0:  MOVLB  7
....................            //go back to sleep 
....................             wakeup_char_is_D = 0; 
15EE2:  CLRF   xCD
....................             initilizeSleepState(); 
15EE4:  MOVLB  0
15EE6:  RCALL  15D06
....................          } 
....................       } 
15EE8:  BRA    15EF4
15EEA:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
15EEC:  DECFSZ x88,W
15EEE:  BRA    15EF6
....................          { 
....................              
....................             initilizeSleepState(); 
15EF0:  MOVLB  0
15EF2:  RCALL  15D06
15EF4:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
15EF6:  MOVLW  00
15EF8:  BTFSC  4D.0
15EFA:  MOVLW  01
15EFC:  MOVWF  01
15EFE:  MOVLB  0
15F00:  GOTO   15F0A (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
15F04:  RCALL  15C8A
....................    initilizeSleepState(); 
15F06:  RCALL  15D06
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
15F08:  BRA    15E1A
15F0A:  DECFSZ 01,W
15F0C:  BRA    15F12
....................       { 
....................          rtc_alarm = FALSE; 
15F0E:  BCF    4D.0
....................          break; 
15F10:  BRA    15F18
....................       } 
....................  
....................       blip(); 
15F12:  RCALL  15D26
....................       blip(); 
15F14:  RCALL  15D26
15F16:  BRA    15F08
....................    } 
15F18:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0ABEE:  MOVF   FD0,W
0ABF0:  ANDLW  0F
0ABF2:  BTFSS  FD0.4
0ABF4:  MOVLW  00
0ABF6:  BSF    FD0.0
0ABF8:  BSF    FD0.1
0ABFA:  BSF    FD0.4
0ABFC:  BSF    FD8.3
0ABFE:  BSF    FD8.4
0AC00:  ADDLW  F0
0AC02:  BTFSC  FD8.0
0AC04:  BRA    AE10
0AC06:  ADDLW  10
0AC08:  GOTO   AE14
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0AC0C:  MOVLW  34
0AC0E:  MOVWF  FF6
0AC10:  MOVLW  1B
0AC12:  MOVWF  FF7
0AC14:  MOVLW  00
0AC16:  MOVWF  FF8
0AC18:  CLRF   1B
0AC1A:  BTFSC  FF2.7
0AC1C:  BSF    1B.7
0AC1E:  BCF    FF2.7
0AC20:  CALL   0E6E
0AC24:  BTFSC  1B.7
0AC26:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AC28:  MOVLW  01
0AC2A:  MOVWF  1E
0AC2C:  MOVLW  A7
0AC2E:  MOVWF  1D
0AC30:  MOVLW  3C
0AC32:  MOVWF  FF6
0AC34:  MOVLW  1B
0AC36:  MOVWF  FF7
0AC38:  MOVLW  00
0AC3A:  MOVWF  FF8
0AC3C:  CALL   50E6
....................          record_event(); 
0AC40:  CALL   8502
....................          recovery(); 
0AC44:  RCALL  AA80
....................          break; 
0AC46:  BRA    AE10
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AC48:  MOVLW  5A
0AC4A:  MOVWF  FF6
0AC4C:  MOVLW  1B
0AC4E:  MOVWF  FF7
0AC50:  MOVLW  00
0AC52:  MOVWF  FF8
0AC54:  CLRF   1B
0AC56:  BTFSC  FF2.7
0AC58:  BSF    1B.7
0AC5A:  BCF    FF2.7
0AC5C:  CALL   0E6E
0AC60:  BTFSC  1B.7
0AC62:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AC64:  MOVLW  01
0AC66:  MOVWF  1E
0AC68:  MOVLW  A7
0AC6A:  MOVWF  1D
0AC6C:  MOVLW  62
0AC6E:  MOVWF  FF6
0AC70:  MOVLW  1B
0AC72:  MOVWF  FF7
0AC74:  MOVLW  00
0AC76:  MOVWF  FF8
0AC78:  CALL   50E6
....................          record_event(); 
0AC7C:  CALL   8502
....................          recovery(); 
0AC80:  RCALL  AA80
....................          break; 
0AC82:  BRA    AE10
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AC84:  MOVLW  82
0AC86:  MOVWF  FF6
0AC88:  MOVLW  1B
0AC8A:  MOVWF  FF7
0AC8C:  MOVLW  00
0AC8E:  MOVWF  FF8
0AC90:  CLRF   1B
0AC92:  BTFSC  FF2.7
0AC94:  BSF    1B.7
0AC96:  BCF    FF2.7
0AC98:  CALL   0E6E
0AC9C:  BTFSC  1B.7
0AC9E:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0ACA0:  MOVLW  01
0ACA2:  MOVWF  1E
0ACA4:  MOVLW  A7
0ACA6:  MOVWF  1D
0ACA8:  MOVLW  8A
0ACAA:  MOVWF  FF6
0ACAC:  MOVLW  1B
0ACAE:  MOVWF  FF7
0ACB0:  MOVLW  00
0ACB2:  MOVWF  FF8
0ACB4:  MOVLW  05
0ACB6:  MOVLB  8
0ACB8:  MOVWF  xEB
0ACBA:  MOVLB  0
0ACBC:  RCALL  AAF4
0ACBE:  MOVLW  10
0ACC0:  MOVWF  FE9
0ACC2:  MOVFF  26,8F7
0ACC6:  MOVFF  25,8F6
0ACCA:  RCALL  AB26
0ACCC:  MOVLW  92
0ACCE:  MOVWF  FF6
0ACD0:  MOVLW  1B
0ACD2:  MOVWF  FF7
0ACD4:  MOVLW  00
0ACD6:  MOVWF  FF8
0ACD8:  MOVLW  20
0ACDA:  MOVLB  8
0ACDC:  MOVWF  xEB
0ACDE:  MOVLB  0
0ACE0:  RCALL  AAF4
....................          record_event(); 
0ACE2:  CALL   8502
....................          break; 
0ACE6:  BRA    AE10
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0ACE8:  MOVLW  B4
0ACEA:  MOVWF  FF6
0ACEC:  MOVLW  1B
0ACEE:  MOVWF  FF7
0ACF0:  MOVLW  00
0ACF2:  MOVWF  FF8
0ACF4:  CLRF   1B
0ACF6:  BTFSC  FF2.7
0ACF8:  BSF    1B.7
0ACFA:  BCF    FF2.7
0ACFC:  CALL   0E6E
0AD00:  BTFSC  1B.7
0AD02:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0AD04:  MOVLW  01
0AD06:  MOVWF  1E
0AD08:  MOVLW  A7
0AD0A:  MOVWF  1D
0AD0C:  MOVLW  BC
0AD0E:  MOVWF  FF6
0AD10:  MOVLW  1B
0AD12:  MOVWF  FF7
0AD14:  MOVLW  00
0AD16:  MOVWF  FF8
0AD18:  CALL   50E6
....................          record_event(); 
0AD1C:  CALL   8502
....................          break; 
0AD20:  BRA    AE10
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0AD22:  MOVLW  E0
0AD24:  MOVWF  FF6
0AD26:  MOVLW  1B
0AD28:  MOVWF  FF7
0AD2A:  MOVLW  00
0AD2C:  MOVWF  FF8
0AD2E:  CLRF   1B
0AD30:  BTFSC  FF2.7
0AD32:  BSF    1B.7
0AD34:  BCF    FF2.7
0AD36:  CALL   0E6E
0AD3A:  BTFSC  1B.7
0AD3C:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AD3E:  MOVLW  01
0AD40:  MOVWF  1E
0AD42:  MOVLW  A7
0AD44:  MOVWF  1D
0AD46:  MOVLW  E8
0AD48:  MOVWF  FF6
0AD4A:  MOVLW  1B
0AD4C:  MOVWF  FF7
0AD4E:  MOVLW  00
0AD50:  MOVWF  FF8
0AD52:  CALL   50E6
....................          record_event(); 
0AD56:  CALL   8502
....................          recovery(); 
0AD5A:  RCALL  AA80
....................          break; 
0AD5C:  BRA    AE10
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AD5E:  MOVLW  04
0AD60:  MOVWF  FF6
0AD62:  MOVLW  1C
0AD64:  MOVWF  FF7
0AD66:  MOVLW  00
0AD68:  MOVWF  FF8
0AD6A:  CLRF   1B
0AD6C:  BTFSC  FF2.7
0AD6E:  BSF    1B.7
0AD70:  BCF    FF2.7
0AD72:  CALL   0E6E
0AD76:  BTFSC  1B.7
0AD78:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AD7A:  MOVLW  01
0AD7C:  MOVWF  1E
0AD7E:  MOVLW  A7
0AD80:  MOVWF  1D
0AD82:  MOVLW  0C
0AD84:  MOVWF  FF6
0AD86:  MOVLW  1C
0AD88:  MOVWF  FF7
0AD8A:  MOVLW  00
0AD8C:  MOVWF  FF8
0AD8E:  CALL   50E6
....................          record_event(); 
0AD92:  CALL   8502
....................          output_bit(RTC_CS, ENABLE); 
0AD96:  BCF    F91.0
....................          spi_write(0x89); 
0AD98:  MOVF   FC9,W
0AD9A:  MOVLW  89
0AD9C:  MOVWF  FC9
0AD9E:  RRCF   FC7,W
0ADA0:  BNC   AD9E
....................          spi_write(0b11111111); 
0ADA2:  MOVF   FC9,W
0ADA4:  SETF   FC9
0ADA6:  RRCF   FC7,W
0ADA8:  BNC   ADA6
....................          spi_read(0x00); 
0ADAA:  MOVF   FC9,W
0ADAC:  CLRF   FC9
0ADAE:  RRCF   FC7,W
0ADB0:  BNC   ADAE
....................          output_bit(RTC_CS, DISABLE); 
0ADB2:  BSF    F91.0
....................          recovery(); 
0ADB4:  RCALL  AA80
....................          break; 
0ADB6:  BRA    AE10
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0ADB8:  MOVLW  2E
0ADBA:  MOVWF  FF6
0ADBC:  MOVLW  1C
0ADBE:  MOVWF  FF7
0ADC0:  MOVLW  00
0ADC2:  MOVWF  FF8
0ADC4:  CLRF   1B
0ADC6:  BTFSC  FF2.7
0ADC8:  BSF    1B.7
0ADCA:  BCF    FF2.7
0ADCC:  CALL   0E6E
0ADD0:  BTFSC  1B.7
0ADD2:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ADD4:  MOVLW  01
0ADD6:  MOVWF  1E
0ADD8:  MOVLW  A7
0ADDA:  MOVWF  1D
0ADDC:  MOVLW  36
0ADDE:  MOVWF  FF6
0ADE0:  MOVLW  1C
0ADE2:  MOVWF  FF7
0ADE4:  MOVLW  00
0ADE6:  MOVWF  FF8
0ADE8:  CALL   50E6
....................          record_event(); 
0ADEC:  CALL   8502
....................          output_bit(RTC_CS, ENABLE); 
0ADF0:  BCF    F91.0
....................          spi_write(0x89); 
0ADF2:  MOVF   FC9,W
0ADF4:  MOVLW  89
0ADF6:  MOVWF  FC9
0ADF8:  RRCF   FC7,W
0ADFA:  BNC   ADF8
....................          spi_write(0b11111111); 
0ADFC:  MOVF   FC9,W
0ADFE:  SETF   FC9
0AE00:  RRCF   FC7,W
0AE02:  BNC   AE00
....................          spi_read(0x00); 
0AE04:  MOVF   FC9,W
0AE06:  CLRF   FC9
0AE08:  RRCF   FC7,W
0AE0A:  BNC   AE08
....................          output_bit(RTC_CS, DISABLE); 
0AE0C:  BSF    F91.0
....................          recovery(); 
0AE0E:  RCALL  AA80
....................          break; 
....................       }         
....................    } 
0AE10:  GOTO   1B912 (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02AE0:  MOVLW  1E
02AE2:  MOVLB  8
02AE4:  MOVWF  x97
02AE6:  MOVLB  0
02AE8:  RCALL  29F2
02AEA:  MOVFF  02,30
02AEE:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02AF2:  MOVLW  1C
02AF4:  MOVLB  8
02AF6:  MOVWF  x97
02AF8:  MOVLB  0
02AFA:  RCALL  29F2
02AFC:  MOVFF  02,20
02B00:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02B04:  MOVLW  16
02B06:  MOVLB  8
02B08:  MOVWF  x97
02B0A:  MOVLB  0
02B0C:  RCALL  29F2
02B0E:  MOVFF  02,22
02B12:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02B16:  MOVLW  14
02B18:  MOVLB  8
02B1A:  MOVWF  x97
02B1C:  MOVLB  0
02B1E:  RCALL  29F2
02B20:  MOVFF  02,24
02B24:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02B28:  MOVLB  8
02B2A:  CLRF   x97
02B2C:  MOVLB  0
02B2E:  RCALL  29F2
02B30:  MOVFF  02,26
02B34:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02B38:  MOVLW  18
02B3A:  MOVLB  8
02B3C:  MOVWF  x97
02B3E:  MOVLB  0
02B40:  RCALL  29F2
02B42:  MOVFF  02,28
02B46:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02B4A:  MOVLW  02
02B4C:  MOVLB  8
02B4E:  MOVWF  xB7
02B50:  MOVLB  0
02B52:  RCALL  2A4C
02B54:  CLRF   32
02B56:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02B5A:  MOVLW  28
02B5C:  MOVLB  8
02B5E:  MOVWF  xB7
02B60:  MOVLB  0
02B62:  RCALL  2A4C
02B64:  CLRF   34
02B66:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02B6A:  MOVLW  12
02B6C:  MOVLB  8
02B6E:  MOVWF  x97
02B70:  MOVLB  0
02B72:  RCALL  29F2
02B74:  MOVFF  02,36
02B78:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02B7C:  MOVLW  3A
02B7E:  MOVLB  8
02B80:  MOVWF  x97
02B82:  MOVLB  0
02B84:  RCALL  29F2
02B86:  MOVFF  02,38
02B8A:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02B8E:  MOVLW  3C
02B90:  MOVLB  8
02B92:  MOVWF  x97
02B94:  MOVLB  0
02B96:  RCALL  29F2
02B98:  MOVFF  02,3E
02B9C:  MOVFF  01,3D
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02BA0:  MOVLW  3E
02BA2:  MOVLB  8
02BA4:  MOVWF  x97
02BA6:  MOVLB  0
02BA8:  RCALL  29F2
02BAA:  MOVFF  02,40
02BAE:  MOVFF  01,3F
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02BB2:  MOVLW  40
02BB4:  MOVLB  8
02BB6:  MOVWF  x97
02BB8:  MOVLB  0
02BBA:  RCALL  29F2
02BBC:  MOVFF  02,42
02BC0:  MOVFF  01,41
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02BC4:  MOVLW  42
02BC6:  MOVLB  8
02BC8:  MOVWF  x97
02BCA:  MOVLB  0
02BCC:  RCALL  29F2
02BCE:  MOVFF  02,44
02BD2:  MOVFF  01,43
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02BD6:  MOVLW  04
02BD8:  MOVLB  8
02BDA:  MOVWF  xB7
02BDC:  MOVLB  0
02BDE:  RCALL  2A4C
02BE0:  MOVFF  01,72D
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02BE4:  MOVLB  8
02BE6:  CLRF   x86
02BE8:  MOVLW  44
02BEA:  MOVWF  x85
02BEC:  MOVLB  0
02BEE:  RCALL  2A72
02BF0:  MOVFF  03,3F8
02BF4:  MOVFF  02,3F7
02BF8:  MOVFF  01,3F6
02BFC:  MOVFF  00,3F5
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02C00:  MOVLB  8
02C02:  CLRF   x86
02C04:  MOVLW  48
02C06:  MOVWF  x85
02C08:  MOVLB  0
02C0A:  RCALL  2A72
02C0C:  MOVFF  03,3FC
02C10:  MOVFF  02,3FB
02C14:  MOVFF  01,3FA
02C18:  MOVFF  00,3F9
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02C1C:  MOVLB  8
02C1E:  CLRF   x86
02C20:  MOVLW  4C
02C22:  MOVWF  x85
02C24:  MOVLB  0
02C26:  RCALL  2A72
02C28:  MOVFF  03,400
02C2C:  MOVFF  02,3FF
02C30:  MOVFF  01,3FE
02C34:  MOVFF  00,3FD
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02C38:  MOVLB  8
02C3A:  CLRF   x86
02C3C:  MOVLW  52
02C3E:  MOVWF  x85
02C40:  MOVLB  0
02C42:  RCALL  2A72
02C44:  MOVFF  03,404
02C48:  MOVFF  02,403
02C4C:  MOVFF  01,402
02C50:  MOVFF  00,401
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02C54:  MOVLB  8
02C56:  CLRF   x86
02C58:  MOVLW  56
02C5A:  MOVWF  x85
02C5C:  MOVLB  0
02C5E:  RCALL  2A72
02C60:  MOVFF  03,408
02C64:  MOVFF  02,407
02C68:  MOVFF  01,406
02C6C:  MOVFF  00,405
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02C70:  MOVLB  8
02C72:  CLRF   x86
02C74:  MOVLW  5A
02C76:  MOVWF  x85
02C78:  MOVLB  0
02C7A:  RCALL  2A72
02C7C:  MOVFF  03,40C
02C80:  MOVFF  02,40B
02C84:  MOVFF  01,40A
02C88:  MOVFF  00,409
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02C8C:  MOVLB  8
02C8E:  CLRF   x86
02C90:  MOVLW  5E
02C92:  MOVWF  x85
02C94:  MOVLB  0
02C96:  RCALL  2A72
02C98:  MOVFF  03,410
02C9C:  MOVFF  02,40F
02CA0:  MOVFF  01,40E
02CA4:  MOVFF  00,40D
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02CA8:  MOVLB  8
02CAA:  CLRF   x86
02CAC:  MOVLW  62
02CAE:  MOVWF  x85
02CB0:  MOVLB  0
02CB2:  RCALL  2A72
02CB4:  MOVFF  03,414
02CB8:  MOVFF  02,413
02CBC:  MOVFF  01,412
02CC0:  MOVFF  00,411
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02CC4:  MOVLW  20
02CC6:  MOVLB  8
02CC8:  MOVWF  x97
02CCA:  MOVLB  0
02CCC:  RCALL  29F2
02CCE:  MOVFF  02,2A
02CD2:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02CD6:  MOVLW  22
02CD8:  MOVLB  8
02CDA:  MOVWF  x97
02CDC:  MOVLB  0
02CDE:  RCALL  29F2
02CE0:  MOVFF  02,2C
02CE4:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02CE8:  MOVLW  24
02CEA:  MOVLB  8
02CEC:  MOVWF  x97
02CEE:  MOVLB  0
02CF0:  RCALL  29F2
02CF2:  MOVFF  02,2E
02CF6:  MOVFF  01,2D
02CFA:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DED4:  MOVLW  1C
0DED6:  MOVLB  8
0DED8:  MOVWF  xEE
0DEDA:  CLRF   xF0
0DEDC:  CLRF   xEF
0DEDE:  MOVLB  0
0DEE0:  CALL   4FFC
....................    write16(ADDR_SAMPLE,0); 
0DEE4:  MOVLW  16
0DEE6:  MOVLB  8
0DEE8:  MOVWF  xEE
0DEEA:  CLRF   xF0
0DEEC:  CLRF   xEF
0DEEE:  MOVLB  0
0DEF0:  CALL   4FFC
....................    write16(ADDR_INTERVAL,60); 
0DEF4:  MOVLW  14
0DEF6:  MOVLB  8
0DEF8:  MOVWF  xEE
0DEFA:  CLRF   xF0
0DEFC:  MOVLW  3C
0DEFE:  MOVWF  xEF
0DF00:  MOVLB  0
0DF02:  CALL   4FFC
....................    write16(ADDR_SERIALNO,9999); 
0DF06:  MOVLB  8
0DF08:  CLRF   xEE
0DF0A:  MOVLW  27
0DF0C:  MOVWF  xF0
0DF0E:  MOVLW  0F
0DF10:  MOVWF  xEF
0DF12:  MOVLB  0
0DF14:  CALL   4FFC
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DF18:  MOVLW  18
0DF1A:  MOVLB  8
0DF1C:  MOVWF  xEE
0DF1E:  MOVLW  0D
0DF20:  MOVWF  xF0
0DF22:  MOVLW  20
0DF24:  MOVWF  xEF
0DF26:  MOVLB  0
0DF28:  CALL   4FFC
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DF2C:  MOVLW  02
0DF2E:  MOVLB  8
0DF30:  MOVWF  x89
0DF32:  MOVLW  01
0DF34:  MOVWF  x8A
0DF36:  MOVLB  0
0DF38:  CALL   343A
....................    write16(ADDR_MACRO_STEP, 0); 
0DF3C:  MOVLW  3A
0DF3E:  MOVLB  8
0DF40:  MOVWF  xEE
0DF42:  CLRF   xF0
0DF44:  CLRF   xEF
0DF46:  MOVLB  0
0DF48:  CALL   4FFC
....................    write16(ADDR_COM_ERR,3); 
0DF4C:  MOVLW  3C
0DF4E:  MOVLB  8
0DF50:  MOVWF  xEE
0DF52:  CLRF   xF0
0DF54:  MOVLW  03
0DF56:  MOVWF  xEF
0DF58:  MOVLB  0
0DF5A:  CALL   4FFC
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DF5E:  MOVLW  04
0DF60:  MOVLB  8
0DF62:  MOVWF  x89
0DF64:  MOVLW  0A
0DF66:  MOVWF  x8A
0DF68:  MOVLB  0
0DF6A:  CALL   343A
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DF6E:  MOVLB  8
0DF70:  CLRF   x86
0DF72:  MOVLW  44
0DF74:  MOVWF  x85
0DF76:  CLRF   x8A
0DF78:  CLRF   x89
0DF7A:  CLRF   x88
0DF7C:  MOVLW  7F
0DF7E:  MOVWF  x87
0DF80:  MOVLB  0
0DF82:  CALL   CD74
....................    write_float(ADDR_CAL_C1,0); 
0DF86:  MOVLB  8
0DF88:  CLRF   x86
0DF8A:  MOVLW  48
0DF8C:  MOVWF  x85
0DF8E:  CLRF   x8A
0DF90:  CLRF   x89
0DF92:  CLRF   x88
0DF94:  CLRF   x87
0DF96:  MOVLB  0
0DF98:  CALL   CD74
....................    write_float(ADDR_CAL_M2,1); 
0DF9C:  MOVLB  8
0DF9E:  CLRF   x86
0DFA0:  MOVLW  4C
0DFA2:  MOVWF  x85
0DFA4:  CLRF   x8A
0DFA6:  CLRF   x89
0DFA8:  CLRF   x88
0DFAA:  MOVLW  7F
0DFAC:  MOVWF  x87
0DFAE:  MOVLB  0
0DFB0:  CALL   CD74
....................    write_float(ADDR_CAL_C2,0); 
0DFB4:  MOVLB  8
0DFB6:  CLRF   x86
0DFB8:  MOVLW  52
0DFBA:  MOVWF  x85
0DFBC:  CLRF   x8A
0DFBE:  CLRF   x89
0DFC0:  CLRF   x88
0DFC2:  CLRF   x87
0DFC4:  MOVLB  0
0DFC6:  CALL   CD74
....................    write_float(ADDR_CAL_M3,1); 
0DFCA:  MOVLB  8
0DFCC:  CLRF   x86
0DFCE:  MOVLW  56
0DFD0:  MOVWF  x85
0DFD2:  CLRF   x8A
0DFD4:  CLRF   x89
0DFD6:  CLRF   x88
0DFD8:  MOVLW  7F
0DFDA:  MOVWF  x87
0DFDC:  MOVLB  0
0DFDE:  CALL   CD74
....................    write_float(ADDR_CAL_C3,0); 
0DFE2:  MOVLB  8
0DFE4:  CLRF   x86
0DFE6:  MOVLW  5A
0DFE8:  MOVWF  x85
0DFEA:  CLRF   x8A
0DFEC:  CLRF   x89
0DFEE:  CLRF   x88
0DFF0:  CLRF   x87
0DFF2:  MOVLB  0
0DFF4:  CALL   CD74
....................    write_float(ADDR_CAL_M4,1); 
0DFF8:  MOVLB  8
0DFFA:  CLRF   x86
0DFFC:  MOVLW  5E
0DFFE:  MOVWF  x85
0E000:  CLRF   x8A
0E002:  CLRF   x89
0E004:  CLRF   x88
0E006:  MOVLW  7F
0E008:  MOVWF  x87
0E00A:  MOVLB  0
0E00C:  CALL   CD74
....................    write_float(ADDR_CAL_C4,0);  
0E010:  MOVLB  8
0E012:  CLRF   x86
0E014:  MOVLW  62
0E016:  MOVWF  x85
0E018:  CLRF   x8A
0E01A:  CLRF   x89
0E01C:  CLRF   x88
0E01E:  CLRF   x87
0E020:  MOVLB  0
0E022:  CALL   CD74
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0E026:  MOVLW  40
0E028:  MOVLB  8
0E02A:  MOVWF  xEE
0E02C:  MOVLW  4E
0E02E:  MOVWF  xF0
0E030:  MOVLW  20
0E032:  MOVWF  xEF
0E034:  MOVLB  0
0E036:  CALL   4FFC
....................    write16(ADDR_D2_TEMP,20000); 
0E03A:  MOVLW  42
0E03C:  MOVLB  8
0E03E:  MOVWF  xEE
0E040:  MOVLW  4E
0E042:  MOVWF  xF0
0E044:  MOVLW  20
0E046:  MOVWF  xEF
0E048:  MOVLB  0
0E04A:  CALL   4FFC
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0E04E:  MOVLW  20
0E050:  MOVLB  8
0E052:  MOVWF  xEE
0E054:  CLRF   xF0
0E056:  CLRF   xEF
0E058:  MOVLB  0
0E05A:  CALL   4FFC
....................    write16(ADDR_VOLUME,22500);  
0E05E:  MOVLW  22
0E060:  MOVLB  8
0E062:  MOVWF  xEE
0E064:  MOVLW  57
0E066:  MOVWF  xF0
0E068:  MOVLW  E4
0E06A:  MOVWF  xEF
0E06C:  MOVLB  0
0E06E:  CALL   4FFC
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0E072:  MOVF   2F,W
0E074:  SUBLW  02
0E076:  BNZ   E07C
0E078:  MOVF   30,F
0E07A:  BZ    E090
0E07C:  MOVLW  24
0E07E:  MOVLB  8
0E080:  MOVWF  xEE
0E082:  CLRF   xF0
0E084:  MOVLW  02
0E086:  MOVWF  xEF
0E088:  MOVLB  0
0E08A:  CALL   4FFC
0E08E:  BRA    E0A2
....................    else write16(ADDR_PORT,1); 
0E090:  MOVLW  24
0E092:  MOVLB  8
0E094:  MOVWF  xEE
0E096:  CLRF   xF0
0E098:  MOVLW  01
0E09A:  MOVWF  xEF
0E09C:  MOVLB  0
0E09E:  CALL   4FFC
....................     
....................    write16(ADDR_DET_TYPE,1); 
0E0A2:  MOVLW  26
0E0A4:  MOVLB  8
0E0A6:  MOVWF  xEE
0E0A8:  CLRF   xF0
0E0AA:  MOVLW  01
0E0AC:  MOVWF  xEF
0E0AE:  MOVLB  0
0E0B0:  CALL   4FFC
....................     
....................    init_nv_vars(); 
0E0B4:  CALL   2AE0
0E0B8:  GOTO   E0D2 (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
1281E:  MOVLW  02
12820:  MOVWF  FEA
12822:  MOVLW  47
12824:  MOVWF  FE9
12826:  CLRF   00
12828:  CLRF   02
1282A:  MOVLW  51
1282C:  MOVWF  01
1282E:  CALL   354E
12832:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F944:  MOVLW  03
0F946:  MOVWF  FEA
0F948:  MOVLW  25
0F94A:  MOVWF  FE9
0F94C:  CLRF   00
0F94E:  CLRF   02
0F950:  MOVLW  14
0F952:  MOVWF  01
0F954:  CALL   354E
0F958:  GOTO   F978 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
13354:  MOVLB  8
13356:  CLRF   xD4
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
13358:  CLRF   FEA
1335A:  MOVLW  52
1335C:  MOVWF  FE9
1335E:  CLRF   00
13360:  CLRF   02
13362:  MOVLW  14
13364:  MOVWF  01
13366:  MOVLB  0
13368:  CALL   354E
....................  
....................    for(n=0; n<20; n++) { 
1336C:  MOVLB  8
1336E:  CLRF   xD5
13370:  MOVF   xD5,W
13372:  SUBLW  13
13374:  BNC   133BA
....................         c = data_buffer[string_pos];  
13376:  CLRF   03
13378:  MOVLB  2
1337A:  MOVF   x98,W
1337C:  ADDLW  67
1337E:  MOVWF  FE9
13380:  MOVLW  00
13382:  ADDWFC 03,W
13384:  MOVWF  FEA
13386:  MOVFF  FEF,8D4
....................         ++string_pos; 
1338A:  INCF   x98,F
....................         if (c == '\0') return(1); // found end 
1338C:  MOVLB  8
1338E:  MOVF   xD4,F
13390:  BNZ   13398
13392:  MOVLW  01
13394:  MOVWF  01
13396:  BRA    133BE
....................         if (c == ',')  return(0); // found seperator  
13398:  MOVF   xD4,W
1339A:  SUBLW  2C
1339C:  BNZ   133A4
1339E:  MOVLW  00
133A0:  MOVWF  01
133A2:  BRA    133BE
....................         sub_string[n] = c; 
133A4:  CLRF   03
133A6:  MOVF   xD5,W
133A8:  ADDLW  52
133AA:  MOVWF  FE9
133AC:  MOVLW  00
133AE:  ADDWFC 03,W
133B0:  MOVWF  FEA
133B2:  MOVFF  8D4,FEF
133B6:  INCF   xD5,F
133B8:  BRA    13370
....................    } 
....................     
....................    return(2); // failed = bad string 
133BA:  MOVLW  02
133BC:  MOVWF  01
133BE:  MOVLB  0
133C0:  GOTO   136EA (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
135FE:  MOVLW  5A
13600:  MOVWF  FF6
13602:  MOVLW  1C
13604:  MOVWF  FF7
13606:  MOVLW  00
13608:  MOVWF  FF8
1360A:  MOVLW  03
1360C:  MOVWF  FEA
1360E:  MOVLW  3D
13610:  MOVWF  FE9
13612:  CALL   FE8A
13616:  MOVF   01,W
13618:  BZ    1362C
1361A:  XORLW  01
1361C:  BZ    1364C
1361E:  XORLW  03
13620:  BZ    1366C
13622:  XORLW  01
13624:  BZ    1368C
13626:  XORLW  07
13628:  BZ    136AC
1362A:  BRA    136CA
....................       case "NO3" : NO3_array[read_i] = result; 
1362C:  BCF    FD8.0
1362E:  MOVLB  3
13630:  RLCF   x4A,W
13632:  CLRF   03
13634:  ADDLW  4B
13636:  MOVWF  FE9
13638:  MOVLW  03
1363A:  ADDWFC 03,W
1363C:  MOVWF  FEA
1363E:  MOVFF  8D5,FEC
13642:  MOVF   FED,F
13644:  MOVFF  8D4,FEF
....................          break; 
13648:  MOVLB  0
1364A:  BRA    136CA
....................       case "NO2" : NO2_array[read_i] = result; 
1364C:  BCF    FD8.0
1364E:  MOVLB  3
13650:  RLCF   x4A,W
13652:  CLRF   03
13654:  ADDLW  5D
13656:  MOVWF  FE9
13658:  MOVLW  03
1365A:  ADDWFC 03,W
1365C:  MOVWF  FEA
1365E:  MOVFF  8D5,FEC
13662:  MOVF   FED,F
13664:  MOVFF  8D4,FEF
....................          break;    
13668:  MOVLB  0
1366A:  BRA    136CA
....................       case "PO4" : PO4_array[read_i] = result; 
1366C:  BCF    FD8.0
1366E:  MOVLB  3
13670:  RLCF   x4A,W
13672:  CLRF   03
13674:  ADDLW  6F
13676:  MOVWF  FE9
13678:  MOVLW  03
1367A:  ADDWFC 03,W
1367C:  MOVWF  FEA
1367E:  MOVFF  8D5,FEC
13682:  MOVF   FED,F
13684:  MOVFF  8D4,FEF
....................          break; 
13688:  MOVLB  0
1368A:  BRA    136CA
....................       case "NH4" : NH4_array[read_i] = result; 
1368C:  BCF    FD8.0
1368E:  MOVLB  3
13690:  RLCF   x4A,W
13692:  CLRF   03
13694:  ADDLW  81
13696:  MOVWF  FE9
13698:  MOVLW  03
1369A:  ADDWFC 03,W
1369C:  MOVWF  FEA
1369E:  MOVFF  8D5,FEC
136A2:  MOVF   FED,F
136A4:  MOVFF  8D4,FEF
....................          break; 
136A8:  MOVLB  0
136AA:  BRA    136CA
....................       case "SiO" : SiO_array[read_i] = result; 
136AC:  BCF    FD8.0
136AE:  MOVLB  3
136B0:  RLCF   x4A,W
136B2:  CLRF   03
136B4:  ADDLW  93
136B6:  MOVWF  FE9
136B8:  MOVLW  03
136BA:  ADDWFC 03,W
136BC:  MOVWF  FEA
136BE:  MOVFF  8D5,FEC
136C2:  MOVF   FED,F
136C4:  MOVFF  8D4,FEF
....................          break; 
136C8:  MOVLB  0
....................    } 
136CA:  GOTO   13742 (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
136CE:  MOVLB  8
136D0:  CLRF   xCF
136D2:  CLRF   xCE
136D4:  CLRF   xD1
136D6:  CLRF   xD0
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
136D8:  MOVLB  2
136DA:  CLRF   x98
....................     
....................    for (n=0; n<11; ++n){ 
136DC:  MOVLB  8
136DE:  CLRF   xD2
136E0:  MOVF   xD2,W
136E2:  SUBLW  0A
136E4:  BNC   13736
....................       parsed = parse_string(); 
136E6:  MOVLB  0
136E8:  BRA    13354
136EA:  MOVFF  01,8D3
....................       if (parsed == 2) return(0); 
136EE:  MOVLB  8
136F0:  MOVF   xD3,W
136F2:  SUBLW  02
136F4:  BNZ   136FE
136F6:  MOVLW  00
136F8:  MOVWF  01
136FA:  MOVWF  02
136FC:  BRA    1374C
....................       if (n==8) result = atol(sub_string); 
136FE:  MOVF   xD2,W
13700:  SUBLW  08
13702:  BNZ   13718
13704:  CLRF   xD5
13706:  MOVLW  52
13708:  MOVWF  xD4
1370A:  MOVLB  0
1370C:  RCALL  1341A
1370E:  MOVFF  02,8CF
13712:  MOVFF  01,8CE
13716:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
13718:  MOVF   xD2,W
1371A:  SUBLW  0A
1371C:  BNZ   13732
1371E:  CLRF   xD5
13720:  MOVLW  52
13722:  MOVWF  xD4
13724:  MOVLB  0
13726:  RCALL  1341A
13728:  MOVFF  02,8D1
1372C:  MOVFF  01,8D0
13730:  MOVLB  8
13732:  INCF   xD2,F
13734:  BRA    136E0
....................    } 
....................    load_parsed_data(result); 
13736:  MOVFF  8CF,8D5
1373A:  MOVFF  8CE,8D4
1373E:  MOVLB  0
13740:  BRA    135FE
....................    return (temp); 
13742:  MOVLB  8
13744:  MOVFF  8D0,01
13748:  MOVFF  8D1,02
1374C:  MOVLB  0
1374E:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D550:  CLRF   FEA
0D552:  MOVLW  67
0D554:  MOVWF  FE9
0D556:  CLRF   00
0D558:  CLRF   02
0D55A:  MOVLW  A0
0D55C:  MOVWF  01
0D55E:  CALL   354E
0D562:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F95C:  MOVLW  03
0F95E:  MOVWF  FEA
0F960:  MOVLW  3D
0F962:  MOVWF  FE9
0F964:  MOVLW  00
0F966:  CALL   02E4
0F96A:  TBLRD*-
0F96C:  TBLRD*+
0F96E:  MOVF   FF5,W
0F970:  MOVWF  FEE
0F972:  IORLW  00
0F974:  BNZ   F96C
....................  
....................    clear_flag_str(); 
0F976:  BRA    F944
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F978:  MOVLW  08
0F97A:  MOVWF  1E
0F97C:  MOVLW  ED
0F97E:  MOVWF  1D
0F980:  MOVLW  10
0F982:  MOVWF  FE9
0F984:  MOVFF  324,8F7
0F988:  MOVFF  323,8F6
0F98C:  CALL   AB26
....................  
....................    if (macro_flag < 100) { 
0F990:  MOVLB  3
0F992:  MOVF   x24,F
0F994:  BNZ   F9AE
0F996:  MOVF   x23,W
0F998:  SUBLW  63
0F99A:  BNC   F9AE
....................       temp_str[3] = '\0'; 
0F99C:  MOVLB  8
0F99E:  CLRF   xF0
....................       temp_str[2] = temp_str[1]; 
0F9A0:  MOVFF  8EE,8EF
....................       temp_str[1] = temp_str[0]; 
0F9A4:  MOVFF  8ED,8EE
....................       temp_str[0] = '0'; 
0F9A8:  MOVLW  30
0F9AA:  MOVWF  xED
0F9AC:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F9AE:  MOVLB  8
0F9B0:  MOVF   xED,W
0F9B2:  XORLW  30
0F9B4:  MOVLB  0
0F9B6:  BZ    F9DA
0F9B8:  XORLW  01
0F9BA:  BZ    FA00
0F9BC:  XORLW  03
0F9BE:  BZ    FA26
0F9C0:  XORLW  01
0F9C2:  BZ    FA4C
0F9C4:  XORLW  07
0F9C6:  BZ    FA72
0F9C8:  XORLW  01
0F9CA:  BZ    FA98
0F9CC:  XORLW  03
0F9CE:  BTFSC  FD8.2
0F9D0:  BRA    FABE
0F9D2:  XORLW  01
0F9D4:  BTFSC  FD8.2
0F9D6:  BRA    FAE4
0F9D8:  BRA    FB0C
....................       case '0' : strcopy(chem,"NO3"); 
0F9DA:  MOVLW  03
0F9DC:  MOVWF  FEA
0F9DE:  MOVLW  3D
0F9E0:  MOVWF  FE9
0F9E2:  MOVLW  00
0F9E4:  CALL   02FC
0F9E8:  TBLRD*-
0F9EA:  TBLRD*+
0F9EC:  MOVF   FF5,W
0F9EE:  MOVWF  FEE
0F9F0:  IORLW  00
0F9F2:  BNZ   F9EA
....................                  wave_l=543; 
0F9F4:  MOVLW  02
0F9F6:  MOVLB  8
0F9F8:  MOVWF  xEC
0F9FA:  MOVLW  1F
0F9FC:  MOVWF  xEB
....................          break; 
0F9FE:  BRA    FB30
....................       case '1' : strcopy(chem,"PO4"); 
0FA00:  MOVLW  03
0FA02:  MOVWF  FEA
0FA04:  MOVLW  3D
0FA06:  MOVWF  FE9
0FA08:  MOVLW  00
0FA0A:  CALL   0314
0FA0E:  TBLRD*-
0FA10:  TBLRD*+
0FA12:  MOVF   FF5,W
0FA14:  MOVWF  FEE
0FA16:  IORLW  00
0FA18:  BNZ   FA10
....................                  wave_l=880;       
0FA1A:  MOVLW  03
0FA1C:  MOVLB  8
0FA1E:  MOVWF  xEC
0FA20:  MOVLW  70
0FA22:  MOVWF  xEB
....................          break; 
0FA24:  BRA    FB30
....................       case '2' : strcopy(chem,"NH4"); 
0FA26:  MOVLW  03
0FA28:  MOVWF  FEA
0FA2A:  MOVLW  3D
0FA2C:  MOVWF  FE9
0FA2E:  MOVLW  00
0FA30:  CALL   032C
0FA34:  TBLRD*-
0FA36:  TBLRD*+
0FA38:  MOVF   FF5,W
0FA3A:  MOVWF  FEE
0FA3C:  IORLW  00
0FA3E:  BNZ   FA36
....................                  wave_l=660;       
0FA40:  MOVLW  02
0FA42:  MOVLB  8
0FA44:  MOVWF  xEC
0FA46:  MOVLW  94
0FA48:  MOVWF  xEB
....................          break; 
0FA4A:  BRA    FB30
....................       case '3' : strcopy(chem,"SiO"); 
0FA4C:  MOVLW  03
0FA4E:  MOVWF  FEA
0FA50:  MOVLW  3D
0FA52:  MOVWF  FE9
0FA54:  MOVLW  00
0FA56:  CALL   0344
0FA5A:  TBLRD*-
0FA5C:  TBLRD*+
0FA5E:  MOVF   FF5,W
0FA60:  MOVWF  FEE
0FA62:  IORLW  00
0FA64:  BNZ   FA5C
....................                  wave_l=810;       
0FA66:  MOVLW  03
0FA68:  MOVLB  8
0FA6A:  MOVWF  xEC
0FA6C:  MOVLW  2A
0FA6E:  MOVWF  xEB
....................          break; 
0FA70:  BRA    FB30
....................       case '4' : strcopy(chem,"Ure"); 
0FA72:  MOVLW  03
0FA74:  MOVWF  FEA
0FA76:  MOVLW  3D
0FA78:  MOVWF  FE9
0FA7A:  MOVLW  00
0FA7C:  CALL   035C
0FA80:  TBLRD*-
0FA82:  TBLRD*+
0FA84:  MOVF   FF5,W
0FA86:  MOVWF  FEE
0FA88:  IORLW  00
0FA8A:  BNZ   FA82
....................                  wave_l=525;       
0FA8C:  MOVLW  02
0FA8E:  MOVLB  8
0FA90:  MOVWF  xEC
0FA92:  MOVLW  0D
0FA94:  MOVWF  xEB
....................          break; 
0FA96:  BRA    FB30
....................       case '5' : strcopy(chem,"NO2"); 
0FA98:  MOVLW  03
0FA9A:  MOVWF  FEA
0FA9C:  MOVLW  3D
0FA9E:  MOVWF  FE9
0FAA0:  MOVLW  00
0FAA2:  CALL   0374
0FAA6:  TBLRD*-
0FAA8:  TBLRD*+
0FAAA:  MOVF   FF5,W
0FAAC:  MOVWF  FEE
0FAAE:  IORLW  00
0FAB0:  BNZ   FAA8
....................                  wave_l=543;       
0FAB2:  MOVLW  02
0FAB4:  MOVLB  8
0FAB6:  MOVWF  xEC
0FAB8:  MOVLW  1F
0FABA:  MOVWF  xEB
....................          break; 
0FABC:  BRA    FB30
....................       case '6' : strcopy(chem,"Fe_"); 
0FABE:  MOVLW  03
0FAC0:  MOVWF  FEA
0FAC2:  MOVLW  3D
0FAC4:  MOVWF  FE9
0FAC6:  MOVLW  00
0FAC8:  CALL   038C
0FACC:  TBLRD*-
0FACE:  TBLRD*+
0FAD0:  MOVF   FF5,W
0FAD2:  MOVWF  FEE
0FAD4:  IORLW  00
0FAD6:  BNZ   FACE
....................                  wave_l=543;       
0FAD8:  MOVLW  02
0FADA:  MOVLB  8
0FADC:  MOVWF  xEC
0FADE:  MOVLW  1F
0FAE0:  MOVWF  xEB
....................          break; 
0FAE2:  BRA    FB30
....................       case '7' : strcopy(chem,"Cl_"); 
0FAE4:  MOVLW  03
0FAE6:  MOVWF  FEA
0FAE8:  MOVLW  3D
0FAEA:  MOVWF  FE9
0FAEC:  MOVLW  00
0FAEE:  CALL   03A4
0FAF2:  TBLRD*-
0FAF4:  TBLRD*+
0FAF6:  MOVF   FF5,W
0FAF8:  MOVWF  FEE
0FAFA:  IORLW  00
0FAFC:  BNZ   FAF4
....................                  wave_l=560;       
0FAFE:  MOVLW  02
0FB00:  MOVLB  8
0FB02:  MOVWF  xEC
0FB04:  MOVLW  30
0FB06:  MOVWF  xEB
....................          break; 
0FB08:  BRA    FB30
0FB0A:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0FB0C:  MOVLW  03
0FB0E:  MOVWF  FEA
0FB10:  MOVLW  3D
0FB12:  MOVWF  FE9
0FB14:  MOVLW  00
0FB16:  CALL   02E4
0FB1A:  TBLRD*-
0FB1C:  TBLRD*+
0FB1E:  MOVF   FF5,W
0FB20:  MOVWF  FEE
0FB22:  IORLW  00
0FB24:  BNZ   FB1C
....................                  wave_l=999;       
0FB26:  MOVLW  03
0FB28:  MOVLB  8
0FB2A:  MOVWF  xEC
0FB2C:  MOVLW  E7
0FB2E:  MOVWF  xEB
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0FB30:  MOVF   xEE,W
0FB32:  XORLW  31
0FB34:  MOVLB  0
0FB36:  BZ    FB56
0FB38:  XORLW  03
0FB3A:  BZ    FB72
0FB3C:  XORLW  01
0FB3E:  BZ    FB8E
0FB40:  XORLW  07
0FB42:  BZ    FBAA
0FB44:  XORLW  01
0FB46:  BZ    FBC6
0FB48:  XORLW  03
0FB4A:  BZ    FBE2
0FB4C:  XORLW  01
0FB4E:  BZ    FBFE
0FB50:  XORLW  0F
0FB52:  BZ    FC1A
0FB54:  BRA    FC36
....................       case '1' : strcopy(anal,"Smp"); 
0FB56:  MOVLW  03
0FB58:  MOVWF  FEA
0FB5A:  MOVLW  42
0FB5C:  MOVWF  FE9
0FB5E:  MOVLW  00
0FB60:  CALL   03BC
0FB64:  TBLRD*-
0FB66:  TBLRD*+
0FB68:  MOVF   FF5,W
0FB6A:  MOVWF  FEE
0FB6C:  IORLW  00
0FB6E:  BNZ   FB66
....................          break; 
0FB70:  BRA    FC50
....................       case '2' : strcopy(anal,"Std"); 
0FB72:  MOVLW  03
0FB74:  MOVWF  FEA
0FB76:  MOVLW  42
0FB78:  MOVWF  FE9
0FB7A:  MOVLW  00
0FB7C:  CALL   03D4
0FB80:  TBLRD*-
0FB82:  TBLRD*+
0FB84:  MOVF   FF5,W
0FB86:  MOVWF  FEE
0FB88:  IORLW  00
0FB8A:  BNZ   FB82
....................          break; 
0FB8C:  BRA    FC50
....................       case '3' : strcopy(anal,"Cmb"); 
0FB8E:  MOVLW  03
0FB90:  MOVWF  FEA
0FB92:  MOVLW  42
0FB94:  MOVWF  FE9
0FB96:  MOVLW  00
0FB98:  CALL   03EC
0FB9C:  TBLRD*-
0FB9E:  TBLRD*+
0FBA0:  MOVF   FF5,W
0FBA2:  MOVWF  FEE
0FBA4:  IORLW  00
0FBA6:  BNZ   FB9E
....................          break; 
0FBA8:  BRA    FC50
....................       case '4' : strcopy(anal,"Tst"); 
0FBAA:  MOVLW  03
0FBAC:  MOVWF  FEA
0FBAE:  MOVLW  42
0FBB0:  MOVWF  FE9
0FBB2:  MOVLW  00
0FBB4:  CALL   0404
0FBB8:  TBLRD*-
0FBBA:  TBLRD*+
0FBBC:  MOVF   FF5,W
0FBBE:  MOVWF  FEE
0FBC0:  IORLW  00
0FBC2:  BNZ   FBBA
....................          break; 
0FBC4:  BRA    FC50
....................       case '5' : strcopy(anal,"Rbl"); 
0FBC6:  MOVLW  03
0FBC8:  MOVWF  FEA
0FBCA:  MOVLW  42
0FBCC:  MOVWF  FE9
0FBCE:  MOVLW  00
0FBD0:  CALL   041C
0FBD4:  TBLRD*-
0FBD6:  TBLRD*+
0FBD8:  MOVF   FF5,W
0FBDA:  MOVWF  FEE
0FBDC:  IORLW  00
0FBDE:  BNZ   FBD6
....................          break; 
0FBE0:  BRA    FC50
....................       case '6' : strcopy(anal,"Cal"); 
0FBE2:  MOVLW  03
0FBE4:  MOVWF  FEA
0FBE6:  MOVLW  42
0FBE8:  MOVWF  FE9
0FBEA:  MOVLW  00
0FBEC:  CALL   0434
0FBF0:  TBLRD*-
0FBF2:  TBLRD*+
0FBF4:  MOVF   FF5,W
0FBF6:  MOVWF  FEE
0FBF8:  IORLW  00
0FBFA:  BNZ   FBF2
....................          break; 
0FBFC:  BRA    FC50
....................       case '7' : strcopy(anal,"Fls"); 
0FBFE:  MOVLW  03
0FC00:  MOVWF  FEA
0FC02:  MOVLW  42
0FC04:  MOVWF  FE9
0FC06:  MOVLW  00
0FC08:  CALL   044C
0FC0C:  TBLRD*-
0FC0E:  TBLRD*+
0FC10:  MOVF   FF5,W
0FC12:  MOVWF  FEE
0FC14:  IORLW  00
0FC16:  BNZ   FC0E
....................          break; 
0FC18:  BRA    FC50
....................       case '8' : strcopy(anal,"Utl"); 
0FC1A:  MOVLW  03
0FC1C:  MOVWF  FEA
0FC1E:  MOVLW  42
0FC20:  MOVWF  FE9
0FC22:  MOVLW  00
0FC24:  CALL   0464
0FC28:  TBLRD*-
0FC2A:  TBLRD*+
0FC2C:  MOVF   FF5,W
0FC2E:  MOVWF  FEE
0FC30:  IORLW  00
0FC32:  BNZ   FC2A
....................          break;     
0FC34:  BRA    FC50
....................       default  : strcopy(anal,"XXX"); 
0FC36:  MOVLW  03
0FC38:  MOVWF  FEA
0FC3A:  MOVLW  42
0FC3C:  MOVWF  FE9
0FC3E:  MOVLW  00
0FC40:  CALL   02E4
0FC44:  TBLRD*-
0FC46:  TBLRD*+
0FC48:  MOVF   FF5,W
0FC4A:  MOVWF  FEE
0FC4C:  IORLW  00
0FC4E:  BNZ   FC46
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0FC50:  MOVLB  8
0FC52:  MOVF   xEF,W
0FC54:  XORLW  31
0FC56:  MOVLB  0
0FC58:  BZ    FC82
0FC5A:  XORLW  03
0FC5C:  BZ    FCA2
0FC5E:  XORLW  01
0FC60:  BZ    FCC4
0FC62:  XORLW  07
0FC64:  BZ    FCE6
0FC66:  XORLW  01
0FC68:  BZ    FD08
0FC6A:  XORLW  03
0FC6C:  BZ    FD2A
0FC6E:  XORLW  01
0FC70:  BTFSC  FD8.2
0FC72:  BRA    FD4C
0FC74:  XORLW  0F
0FC76:  BTFSC  FD8.2
0FC78:  BRA    FD6E
0FC7A:  XORLW  01
0FC7C:  BTFSC  FD8.2
0FC7E:  BRA    FD90
0FC80:  BRA    FDB4
....................       case '1' : strcopy(read_t,"I0s"); 
0FC82:  MOVLW  03
0FC84:  MOVWF  FEA
0FC86:  MOVLW  46
0FC88:  MOVWF  FE9
0FC8A:  MOVLW  00
0FC8C:  CALL   047C
0FC90:  TBLRD*-
0FC92:  TBLRD*+
0FC94:  MOVF   FF5,W
0FC96:  MOVWF  FEE
0FC98:  IORLW  00
0FC9A:  BNZ   FC92
....................                  read_i = 0; 
0FC9C:  MOVLB  3
0FC9E:  CLRF   x4A
....................          break; 
0FCA0:  BRA    FDD2
....................       case '2' : strcopy(read_t,"I1s"); 
0FCA2:  MOVLW  03
0FCA4:  MOVWF  FEA
0FCA6:  MOVLW  46
0FCA8:  MOVWF  FE9
0FCAA:  MOVLW  00
0FCAC:  CALL   0494
0FCB0:  TBLRD*-
0FCB2:  TBLRD*+
0FCB4:  MOVF   FF5,W
0FCB6:  MOVWF  FEE
0FCB8:  IORLW  00
0FCBA:  BNZ   FCB2
....................                  read_i = 1;       
0FCBC:  MOVLW  01
0FCBE:  MOVLB  3
0FCC0:  MOVWF  x4A
....................          break; 
0FCC2:  BRA    FDD2
....................       case '3' : strcopy(read_t,"I0t"); 
0FCC4:  MOVLW  03
0FCC6:  MOVWF  FEA
0FCC8:  MOVLW  46
0FCCA:  MOVWF  FE9
0FCCC:  MOVLW  00
0FCCE:  CALL   04AC
0FCD2:  TBLRD*-
0FCD4:  TBLRD*+
0FCD6:  MOVF   FF5,W
0FCD8:  MOVWF  FEE
0FCDA:  IORLW  00
0FCDC:  BNZ   FCD4
....................                  read_i = 2;       
0FCDE:  MOVLW  02
0FCE0:  MOVLB  3
0FCE2:  MOVWF  x4A
....................          break; 
0FCE4:  BRA    FDD2
....................       case '4' : strcopy(read_t,"I1t"); 
0FCE6:  MOVLW  03
0FCE8:  MOVWF  FEA
0FCEA:  MOVLW  46
0FCEC:  MOVWF  FE9
0FCEE:  MOVLW  00
0FCF0:  CALL   04C4
0FCF4:  TBLRD*-
0FCF6:  TBLRD*+
0FCF8:  MOVF   FF5,W
0FCFA:  MOVWF  FEE
0FCFC:  IORLW  00
0FCFE:  BNZ   FCF6
....................                  read_i = 3;       
0FD00:  MOVLW  03
0FD02:  MOVLB  3
0FD04:  MOVWF  x4A
....................          break; 
0FD06:  BRA    FDD2
....................       case '5' : strcopy(read_t,"I0r"); 
0FD08:  MOVLW  03
0FD0A:  MOVWF  FEA
0FD0C:  MOVLW  46
0FD0E:  MOVWF  FE9
0FD10:  MOVLW  00
0FD12:  CALL   04DC
0FD16:  TBLRD*-
0FD18:  TBLRD*+
0FD1A:  MOVF   FF5,W
0FD1C:  MOVWF  FEE
0FD1E:  IORLW  00
0FD20:  BNZ   FD18
....................                  read_i = 4;       
0FD22:  MOVLW  04
0FD24:  MOVLB  3
0FD26:  MOVWF  x4A
....................          break; 
0FD28:  BRA    FDD2
....................       case '6' : strcopy(read_t,"I1r"); 
0FD2A:  MOVLW  03
0FD2C:  MOVWF  FEA
0FD2E:  MOVLW  46
0FD30:  MOVWF  FE9
0FD32:  MOVLW  00
0FD34:  CALL   04F4
0FD38:  TBLRD*-
0FD3A:  TBLRD*+
0FD3C:  MOVF   FF5,W
0FD3E:  MOVWF  FEE
0FD40:  IORLW  00
0FD42:  BNZ   FD3A
....................                  read_i = 5;       
0FD44:  MOVLW  05
0FD46:  MOVLB  3
0FD48:  MOVWF  x4A
....................          break; 
0FD4A:  BRA    FDD2
....................       case '7' : strcopy(read_t,"I0u"); 
0FD4C:  MOVLW  03
0FD4E:  MOVWF  FEA
0FD50:  MOVLW  46
0FD52:  MOVWF  FE9
0FD54:  MOVLW  00
0FD56:  CALL   050C
0FD5A:  TBLRD*-
0FD5C:  TBLRD*+
0FD5E:  MOVF   FF5,W
0FD60:  MOVWF  FEE
0FD62:  IORLW  00
0FD64:  BNZ   FD5C
....................                  read_i = 6;       
0FD66:  MOVLW  06
0FD68:  MOVLB  3
0FD6A:  MOVWF  x4A
....................          break; 
0FD6C:  BRA    FDD2
....................       case '8' : strcopy(read_t,"I1u"); 
0FD6E:  MOVLW  03
0FD70:  MOVWF  FEA
0FD72:  MOVLW  46
0FD74:  MOVWF  FE9
0FD76:  MOVLW  00
0FD78:  CALL   0524
0FD7C:  TBLRD*-
0FD7E:  TBLRD*+
0FD80:  MOVF   FF5,W
0FD82:  MOVWF  FEE
0FD84:  IORLW  00
0FD86:  BNZ   FD7E
....................                  read_i = 7;       
0FD88:  MOVLW  07
0FD8A:  MOVLB  3
0FD8C:  MOVWF  x4A
....................          break; 
0FD8E:  BRA    FDD2
....................       case '9' : strcopy(read_t,"Chk"); 
0FD90:  MOVLW  03
0FD92:  MOVWF  FEA
0FD94:  MOVLW  46
0FD96:  MOVWF  FE9
0FD98:  MOVLW  00
0FD9A:  CALL   053C
0FD9E:  TBLRD*-
0FDA0:  TBLRD*+
0FDA2:  MOVF   FF5,W
0FDA4:  MOVWF  FEE
0FDA6:  IORLW  00
0FDA8:  BNZ   FDA0
....................                  read_i = 8;       
0FDAA:  MOVLW  08
0FDAC:  MOVLB  3
0FDAE:  MOVWF  x4A
....................          break;        
0FDB0:  BRA    FDD2
0FDB2:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FDB4:  MOVLW  03
0FDB6:  MOVWF  FEA
0FDB8:  MOVLW  46
0FDBA:  MOVWF  FE9
0FDBC:  MOVLW  00
0FDBE:  CALL   0554
0FDC2:  TBLRD*-
0FDC4:  TBLRD*+
0FDC6:  MOVF   FF5,W
0FDC8:  MOVWF  FEE
0FDCA:  IORLW  00
0FDCC:  BNZ   FDC4
....................                  read_i = 0;       
0FDCE:  MOVLB  3
0FDD0:  CLRF   x4A
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FDD2:  MOVLW  03
0FDD4:  MOVLB  8
0FDD6:  MOVWF  xF9
0FDD8:  MOVLW  25
0FDDA:  MOVWF  xF8
0FDDC:  MOVLW  03
0FDDE:  MOVWF  xFB
0FDE0:  MOVLW  3D
0FDE2:  MOVWF  xFA
0FDE4:  MOVLB  0
0FDE6:  CALL   5506
....................    strcat(flag_str, (char *)","); 
0FDEA:  MOVLW  2C
0FDEC:  MOVLB  8
0FDEE:  MOVWF  xF4
0FDF0:  CLRF   xF5
0FDF2:  MOVLW  03
0FDF4:  MOVWF  xF9
0FDF6:  MOVLW  25
0FDF8:  MOVWF  xF8
0FDFA:  MOVLW  08
0FDFC:  MOVWF  xFB
0FDFE:  MOVLW  F4
0FE00:  MOVWF  xFA
0FE02:  MOVLB  0
0FE04:  CALL   5506
....................    strcat(flag_str, anal); 
0FE08:  MOVLW  03
0FE0A:  MOVLB  8
0FE0C:  MOVWF  xF9
0FE0E:  MOVLW  25
0FE10:  MOVWF  xF8
0FE12:  MOVLW  03
0FE14:  MOVWF  xFB
0FE16:  MOVLW  42
0FE18:  MOVWF  xFA
0FE1A:  MOVLB  0
0FE1C:  CALL   5506
....................    strcat(flag_str, (char *)","); 
0FE20:  MOVLW  2C
0FE22:  MOVLB  8
0FE24:  MOVWF  xF4
0FE26:  CLRF   xF5
0FE28:  MOVLW  03
0FE2A:  MOVWF  xF9
0FE2C:  MOVLW  25
0FE2E:  MOVWF  xF8
0FE30:  MOVLW  08
0FE32:  MOVWF  xFB
0FE34:  MOVLW  F4
0FE36:  MOVWF  xFA
0FE38:  MOVLB  0
0FE3A:  CALL   5506
....................    strcat(flag_str, read_t);   
0FE3E:  MOVLW  03
0FE40:  MOVLB  8
0FE42:  MOVWF  xF9
0FE44:  MOVLW  25
0FE46:  MOVWF  xF8
0FE48:  MOVLW  03
0FE4A:  MOVWF  xFB
0FE4C:  MOVLW  46
0FE4E:  MOVWF  xFA
0FE50:  MOVLB  0
0FE52:  CALL   5506
....................     
....................    return wave_l; 
0FE56:  MOVLB  8
0FE58:  MOVFF  8EB,01
0FE5C:  MOVFF  8EC,02
0FE60:  MOVLB  0
0FE62:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F42A:  MOVF   47,W
0F42C:  SUBLW  4B
0F42E:  BTFSC  FD8.2
0F430:  MOVFF  48,2D6
....................    if (cmd=='L') detector_li = arg; 
0F434:  MOVF   47,W
0F436:  SUBLW  4C
0F438:  BNZ   F442
0F43A:  MOVFF  49,2D8
0F43E:  MOVFF  48,2D7
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F442:  MOVF   1F,W
0F444:  SUBLW  04
0F446:  BNZ   F510
0F448:  MOVF   20,F
0F44A:  BNZ   F510
0F44C:  MOVLW  70
0F44E:  MOVWF  FF6
0F450:  MOVLW  1C
0F452:  MOVWF  FF7
0F454:  MOVLW  00
0F456:  MOVWF  FF8
0F458:  CLRF   1B
0F45A:  BTFSC  FF2.7
0F45C:  BSF    1B.7
0F45E:  BCF    FF2.7
0F460:  MOVLW  06
0F462:  MOVLB  A
0F464:  MOVWF  x40
0F466:  MOVLB  0
0F468:  CALL   1044
0F46C:  BTFSC  1B.7
0F46E:  BSF    FF2.7
0F470:  CLRF   1B
0F472:  BTFSC  FF2.7
0F474:  BSF    1B.7
0F476:  BCF    FF2.7
0F478:  MOVFF  2D5,A40
0F47C:  MOVLW  1B
0F47E:  MOVLB  A
0F480:  MOVWF  x41
0F482:  MOVLB  0
0F484:  CALL   0FC6
0F488:  BTFSC  1B.7
0F48A:  BSF    FF2.7
0F48C:  MOVLW  5D
0F48E:  BTFSS  F9E.4
0F490:  BRA    F48E
0F492:  MOVWF  FAD
0F494:  MOVLW  5B
0F496:  BTFSS  F9E.4
0F498:  BRA    F496
0F49A:  MOVWF  FAD
0F49C:  MOVF   47,W
0F49E:  BTFSS  F9E.4
0F4A0:  BRA    F49E
0F4A2:  MOVWF  FAD
0F4A4:  MOVLW  7C
0F4A6:  MOVWF  FF6
0F4A8:  MOVLW  1C
0F4AA:  MOVWF  FF7
0F4AC:  MOVLW  00
0F4AE:  MOVWF  FF8
0F4B0:  CLRF   1B
0F4B2:  BTFSC  FF2.7
0F4B4:  BSF    1B.7
0F4B6:  BCF    FF2.7
0F4B8:  MOVLW  05
0F4BA:  MOVLB  A
0F4BC:  MOVWF  x40
0F4BE:  MOVLB  0
0F4C0:  CALL   1044
0F4C4:  BTFSC  1B.7
0F4C6:  BSF    FF2.7
0F4C8:  MOVLW  41
0F4CA:  MOVWF  FE9
0F4CC:  CLRF   1B
0F4CE:  BTFSC  FF2.7
0F4D0:  BSF    1B.7
0F4D2:  BCF    FF2.7
0F4D4:  MOVFF  4B,A43
0F4D8:  MOVFF  4A,A42
0F4DC:  MOVFF  49,A41
0F4E0:  MOVFF  48,A40
0F4E4:  CALL   110A
0F4E8:  BTFSC  1B.7
0F4EA:  BSF    FF2.7
0F4EC:  MOVLW  84
0F4EE:  MOVWF  FF6
0F4F0:  MOVLW  1C
0F4F2:  MOVWF  FF7
0F4F4:  MOVLW  00
0F4F6:  MOVWF  FF8
0F4F8:  CLRF   1B
0F4FA:  BTFSC  FF2.7
0F4FC:  BSF    1B.7
0F4FE:  BCF    FF2.7
0F500:  MOVLW  03
0F502:  MOVLB  A
0F504:  MOVWF  x40
0F506:  MOVLB  0
0F508:  CALL   1044
0F50C:  BTFSC  1B.7
0F50E:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F510:  CALL   DAA0
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F514:  MOVLW  2F
0F516:  BTFSS  FA4.4
0F518:  BRA    F516
0F51A:  MOVLB  F
0F51C:  MOVWF  x1C
0F51E:  MOVFF  2D5,8F3
0F522:  MOVLW  1B
0F524:  MOVLB  8
0F526:  MOVWF  xF4
0F528:  MOVLB  0
0F52A:  CALL   DAE8
0F52E:  MOVF   47,W
0F530:  BTFSS  FA4.4
0F532:  BRA    F530
0F534:  MOVLB  F
0F536:  MOVWF  x1C
0F538:  MOVLW  41
0F53A:  MOVWF  FE9
0F53C:  MOVFF  4B,8F6
0F540:  MOVFF  4A,8F5
0F544:  MOVFF  49,8F4
0F548:  MOVFF  48,8F3
0F54C:  MOVLB  0
0F54E:  BRA    F34A
0F550:  MOVLW  0D
0F552:  BTFSS  FA4.4
0F554:  BRA    F552
0F556:  MOVLB  F
0F558:  MOVWF  x1C
0F55A:  MOVLW  0A
0F55C:  BTFSS  FA4.4
0F55E:  BRA    F55C
0F560:  MOVWF  x1C
....................    multidrop_off(); 
0F562:  MOVLB  0
0F564:  CALL   DB8C
0F568:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12E74:  MOVLB  8
12E76:  CLRF   xEC
12E78:  BCF    xED.0
12E7A:  CLRF   xEE
12E7C:  CLRF   xF2
12E7E:  CLRF   xF1
12E80:  CLRF   xF0
12E82:  CLRF   xEF
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12E84:  MOVLW  02
12E86:  MOVWF  FEA
12E88:  MOVLW  47
12E8A:  MOVWF  FE9
12E8C:  CLRF   00
12E8E:  CLRF   02
12E90:  MOVLW  51
12E92:  MOVWF  01
12E94:  MOVLB  0
12E96:  CALL   354E
....................  
....................    det_cmd(); 
12E9A:  CALL   F42A
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12E9E:  CALL   557C
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12EA2:  MOVLB  8
12EA4:  MOVF   xEE,W
12EA6:  SUBLW  02
12EA8:  BZ    12F3C
12EAA:  MOVF   xEE,W
12EAC:  SUBLW  03
12EAE:  BZ    12F3C
12EB0:  MOVF   xEC,W
12EB2:  SUBLW  50
12EB4:  BNC   12F3C
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12EB6:  BTFSS  FA4.5
12EB8:  BRA    12EF0
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12EBA:  MOVLB  0
12EBC:  RCALL  12E5A
12EBE:  MOVFF  01,8EB
....................  
....................          if(startCharacterRcvd) 
12EC2:  MOVLB  8
12EC4:  BTFSS  xED.0
12EC6:  BRA    12EE8
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12EC8:  MOVF   xEC,W
12ECA:  INCF   xEC,F
12ECC:  CLRF   03
12ECE:  ADDLW  47
12ED0:  MOVWF  FE9
12ED2:  MOVLW  02
12ED4:  ADDWFC 03,W
12ED6:  MOVWF  FEA
12ED8:  MOVFF  8EB,FEF
....................             if (CARRIAGE_RET == c) 
12EDC:  MOVF   xEB,W
12EDE:  SUBLW  0D
12EE0:  BNZ   12EE6
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12EE2:  MOVLW  02
12EE4:  MOVWF  xEE
....................             } 
....................          } 
12EE6:  BRA    12EF0
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12EE8:  MOVF   xEB,W
12EEA:  SUBLW  40
12EEC:  BNZ   12EF0
....................             { 
....................                startCharacterRcvd = TRUE; 
12EEE:  BSF    xED.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12EF0:  MOVLW  35
12EF2:  MOVWF  00
12EF4:  DECFSZ 00,F
12EF6:  BRA    12EF4
....................       if (tenMicroSecDelayCounter++ > 500000) 
12EF8:  MOVFF  8F2,8F6
12EFC:  MOVFF  8F1,8F5
12F00:  MOVFF  8F0,8F4
12F04:  MOVFF  8EF,8F3
12F08:  MOVLW  01
12F0A:  ADDWF  xEF,F
12F0C:  BTFSC  FD8.0
12F0E:  INCF   xF0,F
12F10:  BTFSC  FD8.2
12F12:  INCF   xF1,F
12F14:  BTFSC  FD8.2
12F16:  INCF   xF2,F
12F18:  MOVF   xF6,F
12F1A:  BNZ   12F36
12F1C:  MOVF   xF5,W
12F1E:  SUBLW  06
12F20:  BC    12F3A
12F22:  XORLW  FF
12F24:  BNZ   12F36
12F26:  MOVF   xF4,W
12F28:  SUBLW  A0
12F2A:  BC    12F3A
12F2C:  XORLW  FF
12F2E:  BNZ   12F36
12F30:  MOVF   xF3,W
12F32:  SUBLW  20
12F34:  BC    12F3A
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12F36:  MOVLW  03
12F38:  MOVWF  xEE
....................       } 
12F3A:  BRA    12EA4
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12F3C:  MOVF   xEC,W
12F3E:  SUBLW  50
12F40:  BC    12F52
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12F42:  MOVF   xEE,W
12F44:  SUBLW  03
12F46:  BZ    12F52
12F48:  MOVF   xEE,W
12F4A:  SUBLW  02
12F4C:  BZ    12F52
....................       { 
....................          rcvDataType = SOME_DATA; 
12F4E:  MOVLW  01
12F50:  MOVWF  xEE
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12F52:  MOVLB  0
12F54:  CALL   559C
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12F58:  MOVLB  8
12F5A:  MOVFF  8EE,01
12F5E:  MOVLB  0
12F60:  GOTO   130D8 (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
10000:  MOVF   1F,F
10002:  BTFSS  FD8.2
10004:  GOTO   1002E
10008:  MOVF   20,F
1000A:  BTFSS  FD8.2
1000C:  GOTO   1002E
10010:  MOVLB  8
10012:  DECFSZ xEC,W
10014:  BRA    10018
10016:  BRA    1001E
10018:  MOVLB  0
1001A:  GOTO   1002E
1001E:  CLRF   FEA
10020:  MOVLW  67
10022:  MOVWF  FE9
10024:  MOVLB  0
10026:  CALL   79BE
1002A:  GOTO   1004A
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
1002E:  MOVF   20,F
10030:  BTFSS  FD8.2
10032:  GOTO   10040
10036:  MOVF   1F,W
10038:  SUBLW  03
1003A:  BTFSC  FD8.0
1003C:  GOTO   1004A
10040:  CLRF   FEA
10042:  MOVLW  67
10044:  MOVWF  FE9
10046:  CALL   79BE
....................  
....................    if (store==TRUE && sd_status==0) { 
1004A:  MOVLB  8
1004C:  DECFSZ xEB,W
1004E:  GOTO   100B2
10052:  MOVLB  2
10054:  MOVF   xDC,F
10056:  BTFSC  FD8.2
10058:  BRA    10060
1005A:  MOVLB  8
1005C:  GOTO   100B2
....................        
....................       buffer_select = 0; 
10060:  MOVLB  0
10062:  CLRF   x66
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
10064:  MOVLB  8
10066:  CLRF   xED
10068:  MOVLB  0
1006A:  CALL   55AE
....................          append_data(file_ptr_raw_all); 
1006E:  MOVLW  02
10070:  MOVLB  8
10072:  MOVWF  xEE
10074:  MOVLW  DD
10076:  MOVWF  xED
10078:  MOVLB  0
1007A:  CALL   8320
....................       heartbeat(TRUE); 
1007E:  MOVLW  01
10080:  MOVLB  8
10082:  MOVWF  xED
10084:  MOVLB  0
10086:  CALL   55AE
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
1008A:  MOVLB  8
1008C:  CLRF   xED
1008E:  MOVLB  0
10090:  CALL   55AE
....................          append_data(file_ptr_raw_new); 
10094:  MOVLW  02
10096:  MOVLB  8
10098:  MOVWF  xEE
1009A:  MOVLW  EB
1009C:  MOVWF  xED
1009E:  MOVLB  0
100A0:  CALL   8320
....................       heartbeat(TRUE); 
100A4:  MOVLW  01
100A6:  MOVLB  8
100A8:  MOVWF  xED
100AA:  MOVLB  0
100AC:  CALL   55AE
100B0:  MOVLB  8
....................    } 
100B2:  MOVLB  0
100B4:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12F70:  CLRF   xE5
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12F64:  MOVLW  0D
12F66:  MOVLB  8
12F68:  MOVWF  xCE
12F6A:  MOVLW  0A
12F6C:  MOVWF  xCF
12F6E:  CLRF   xD0
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12F72:  MOVLB  0
12F74:  RCALL  1281E
....................    clear_data_buffer(); 
12F76:  CALL   D550
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12F7A:  MOVLW  08
12F7C:  MOVWF  FEA
12F7E:  MOVLW  D1
12F80:  MOVWF  FE9
12F82:  CLRF   00
12F84:  CLRF   02
12F86:  MOVLW  14
12F88:  MOVWF  01
12F8A:  CALL   354E
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12F8E:  MOVLW  01
12F90:  MOVWF  FEA
12F92:  MOVLW  A7
12F94:  MOVWF  FE9
12F96:  CLRF   00
12F98:  CLRF   02
12F9A:  MOVLW  A0
12F9C:  MOVWF  01
12F9E:  CALL   354E
....................  
....................    time_stamp(); 
12FA2:  CALL   5442
....................    strcpy(data_buffer, time_stmp_str); 
12FA6:  CLRF   FEA
12FA8:  MOVLW  67
12FAA:  MOVWF  FE9
12FAC:  MOVLW  02
12FAE:  MOVWF  FE2
12FB0:  MOVLW  99
12FB2:  MOVWF  FE1
12FB4:  MOVF   FE7,F
12FB6:  MOVFF  FE6,FEE
12FBA:  BNZ   12FB4
....................    strcat(data_buffer, (char *)","); 
12FBC:  MOVLW  2C
12FBE:  MOVLB  8
12FC0:  MOVWF  xE9
12FC2:  CLRF   xEA
12FC4:  CLRF   xF9
12FC6:  MOVLW  67
12FC8:  MOVWF  xF8
12FCA:  MOVLW  08
12FCC:  MOVWF  xFB
12FCE:  MOVLW  E9
12FD0:  MOVWF  xFA
12FD2:  MOVLB  0
12FD4:  CALL   5506
....................  
....................    flag_mod=fmod(macro_flag,10); 
12FD8:  MOVFF  324,918
12FDC:  MOVFF  323,917
12FE0:  CALL   C91E
12FE4:  MOVFF  03,8EE
12FE8:  MOVFF  02,8ED
12FEC:  MOVFF  01,8EC
12FF0:  MOVFF  00,8EB
12FF4:  MOVFF  03,8F2
12FF8:  MOVFF  02,8F1
12FFC:  MOVFF  01,8F0
13000:  MOVFF  00,8EF
13004:  MOVLB  8
13006:  CLRF   xF6
13008:  CLRF   xF5
1300A:  MOVLW  20
1300C:  MOVWF  xF4
1300E:  MOVLW  82
13010:  MOVWF  xF3
13012:  MOVLB  0
13014:  BRA    12C1A
13016:  MOVFF  03,916
1301A:  MOVFF  02,915
1301E:  MOVFF  01,914
13022:  MOVFF  00,913
13026:  RCALL  12834
13028:  MOVFF  01,8E8
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
1302C:  MOVLB  8
1302E:  DECFSZ xE8,W
13030:  BRA    13034
13032:  BRA    1303A
13034:  MOVF   xE8,W
13036:  SUBLW  03
13038:  BNZ   13058
....................    { 
....................       clear_proc_time_stmp_str(); 
1303A:  MOVLB  0
1303C:  BRA    12D82
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
1303E:  MOVLW  02
13040:  MOVWF  FEA
13042:  MOVLW  B7
13044:  MOVWF  FE9
13046:  MOVLW  02
13048:  MOVWF  FE2
1304A:  MOVLW  99
1304C:  MOVWF  FE1
1304E:  MOVF   FE7,F
13050:  MOVFF  FE6,FEE
13054:  BNZ   1304E
13056:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
13058:  MOVLB  0
1305A:  CALL   F95C
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
1305E:  MOVLB  8
13060:  CLRF   xEC
13062:  MOVLW  67
13064:  MOVWF  xEB
13066:  MOVLB  0
13068:  RCALL  12D9A
1306A:  MOVFF  02,03
1306E:  MOVF   01,W
13070:  XORLW  FF
13072:  ADDLW  A1
13074:  MOVLB  8
13076:  MOVWF  xEB
13078:  MOVLW  00
1307A:  SUBFWB 02,W
1307C:  MOVWF  xEC
1307E:  MOVLW  01
13080:  SUBWF  xEB,F
13082:  MOVLW  00
13084:  SUBWFB xEC,F
13086:  CLRF   xEE
13088:  MOVLW  67
1308A:  MOVWF  xED
1308C:  MOVLW  03
1308E:  MOVWF  xF0
13090:  MOVLW  25
13092:  MOVWF  xEF
13094:  MOVFF  8EC,8F2
13098:  MOVFF  8EB,8F1
1309C:  MOVLB  0
1309E:  RCALL  12DD6
....................    strcat(data_buffer, (char *)","); 
130A0:  MOVLW  2C
130A2:  MOVLB  8
130A4:  MOVWF  xE9
130A6:  CLRF   xEA
130A8:  CLRF   xF9
130AA:  MOVLW  67
130AC:  MOVWF  xF8
130AE:  MOVLW  08
130B0:  MOVWF  xFB
130B2:  MOVLW  E9
130B4:  MOVWF  xFA
130B6:  MOVLB  0
130B8:  CALL   5506
....................     
....................    cmd = 'S'; 
130BC:  MOVLW  53
130BE:  MOVWF  47
....................    arg = 1; 
130C0:  CLRF   4B
130C2:  CLRF   4A
130C4:  CLRF   49
130C6:  MOVLW  01
130C8:  MOVWF  48
....................  
....................    for(i = 0; i < 6; i++) 
130CA:  MOVLB  8
130CC:  CLRF   xE6
130CE:  MOVF   xE6,W
130D0:  SUBLW  05
130D2:  BNC   130EA
....................    { 
....................       rcvdData = get_slave_data(); 
130D4:  MOVLB  0
130D6:  BRA    12E74
130D8:  MOVFF  01,8E5
....................       if (DATA_COMPLETE == rcvdData) 
130DC:  MOVLB  8
130DE:  MOVF   xE5,W
130E0:  SUBLW  02
130E2:  BNZ   130E6
....................       { 
....................          break; 
130E4:  BRA    130EA
....................       } 
130E6:  INCF   xE6,F
130E8:  BRA    130CE
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
130EA:  CLRF   xEC
130EC:  MOVLW  67
130EE:  MOVWF  xEB
130F0:  MOVLB  0
130F2:  RCALL  12D9A
130F4:  MOVFF  02,03
130F8:  MOVF   01,W
130FA:  XORLW  FF
130FC:  ADDLW  A1
130FE:  MOVLB  8
13100:  MOVWF  xEB
13102:  MOVLW  00
13104:  SUBFWB 02,W
13106:  MOVWF  xEC
13108:  MOVLW  01
1310A:  SUBWF  xEB,F
1310C:  MOVLW  00
1310E:  SUBWFB xEC,F
13110:  CLRF   xEE
13112:  MOVLW  67
13114:  MOVWF  xED
13116:  MOVLW  02
13118:  MOVWF  xF0
1311A:  MOVLW  47
1311C:  MOVWF  xEF
1311E:  MOVFF  8EC,8F2
13122:  MOVFF  8EB,8F1
13126:  MOVLB  0
13128:  RCALL  12DD6
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
1312A:  MOVLW  02
1312C:  MOVLB  8
1312E:  MOVWF  xEC
13130:  MOVLW  47
13132:  MOVWF  xEB
13134:  MOVLB  0
13136:  RCALL  12D9A
13138:  MOVFF  01,8E7
....................    if (rec_len > 0 && rec_len < 12) 
1313C:  MOVLB  8
1313E:  MOVF   xE7,F
13140:  BZ    1314E
13142:  MOVF   xE7,W
13144:  SUBLW  0B
13146:  BNC   1314E
....................    { 
....................       rcvdData = SHORT_DATA; 
13148:  MOVLW  04
1314A:  MOVWF  xE5
....................    } 
1314C:  BRA    13158
....................    else 
....................    { 
....................       if (rec_len > 30) 
1314E:  MOVF   xE7,W
13150:  SUBLW  1E
13152:  BC    13158
....................       { 
....................          rcvdData = LONG_DATA; 
13154:  MOVLW  05
13156:  MOVWF  xE5
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
13158:  MOVLW  02
1315A:  SUBWF  xE5,W
1315C:  ADDLW  FC
1315E:  BC    131CA
13160:  ADDLW  04
13162:  MOVLB  0
13164:  GOTO   1332C
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
13168:  MOVLB  8
1316A:  BRA    131CA
1316C:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
1316E:  MOVLW  08
13170:  MOVWF  1E
13172:  MOVLW  D1
13174:  MOVWF  1D
13176:  MOVLW  88
13178:  MOVWF  FF6
1317A:  MOVLW  1C
1317C:  MOVWF  FF7
1317E:  MOVLW  00
13180:  MOVWF  FF8
13182:  CALL   50E6
....................          break; 
13186:  MOVLB  8
13188:  BRA    131CA
1318A:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
1318C:  MOVLW  08
1318E:  MOVWF  1E
13190:  MOVLW  D1
13192:  MOVWF  1D
13194:  MOVLW  92
13196:  MOVWF  FF6
13198:  MOVLW  1C
1319A:  MOVWF  FF7
1319C:  MOVLW  00
1319E:  MOVWF  FF8
131A0:  CALL   50E6
....................          break; 
131A4:  MOVLB  8
131A6:  BRA    131CA
131A8:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
131AA:  MOVLW  08
131AC:  MOVWF  1E
131AE:  MOVLW  D1
131B0:  MOVWF  1D
131B2:  MOVLW  A2
131B4:  MOVWF  FF6
131B6:  MOVLW  1C
131B8:  MOVWF  FF7
131BA:  MOVLW  00
131BC:  MOVWF  FF8
131BE:  CALL   50E6
....................          break; 
131C2:  MOVLB  8
131C4:  BRA    131CA
131C6:  MOVLB  0
131C8:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
131CA:  CLRF   xEC
131CC:  MOVLW  67
131CE:  MOVWF  xEB
131D0:  MOVLB  0
131D2:  RCALL  12D9A
131D4:  MOVFF  02,03
131D8:  MOVF   01,W
131DA:  XORLW  FF
131DC:  ADDLW  A1
131DE:  MOVLB  8
131E0:  MOVWF  xEB
131E2:  MOVLW  00
131E4:  SUBFWB 02,W
131E6:  MOVWF  xEC
131E8:  MOVLW  01
131EA:  SUBWF  xEB,F
131EC:  MOVLW  00
131EE:  SUBWFB xEC,F
131F0:  CLRF   xEE
131F2:  MOVLW  67
131F4:  MOVWF  xED
131F6:  MOVLW  08
131F8:  MOVWF  xF0
131FA:  MOVLW  D1
131FC:  MOVWF  xEF
131FE:  MOVFF  8EC,8F2
13202:  MOVFF  8EB,8F1
13206:  MOVLB  0
13208:  RCALL  12DD6
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
1320A:  MOVLB  8
1320C:  CLRF   xEC
1320E:  MOVLW  67
13210:  MOVWF  xEB
13212:  MOVLB  0
13214:  RCALL  12D9A
13216:  MOVFF  02,03
1321A:  MOVF   01,W
1321C:  XORLW  FF
1321E:  ADDLW  A1
13220:  MOVLB  8
13222:  MOVWF  xEB
13224:  MOVLW  00
13226:  SUBFWB 02,W
13228:  MOVWF  xEC
1322A:  MOVLW  01
1322C:  SUBWF  xEB,F
1322E:  MOVLW  00
13230:  SUBWFB xEC,F
13232:  CLRF   xEE
13234:  MOVLW  67
13236:  MOVWF  xED
13238:  MOVLW  08
1323A:  MOVWF  xF0
1323C:  MOVLW  CE
1323E:  MOVWF  xEF
13240:  MOVFF  8EC,8F2
13244:  MOVFF  8EB,8F1
13248:  MOVLB  0
1324A:  RCALL  12DD6
....................  
....................    if(DATA_COMPLETE != rcvdData) 
1324C:  MOVLB  8
1324E:  MOVF   xE5,W
13250:  SUBLW  02
13252:  BZ    1330E
....................    {    //housekeeping 
....................       time_stamp(); 
13254:  MOVLB  0
13256:  CALL   5442
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
1325A:  MOVLW  01
1325C:  MOVWF  1E
1325E:  MOVLW  A7
13260:  MOVWF  1D
13262:  MOVLW  B2
13264:  MOVWF  FF6
13266:  MOVLW  1C
13268:  MOVWF  FF7
1326A:  MOVLW  00
1326C:  MOVWF  FF8
1326E:  MOVLW  0A
13270:  MOVLB  8
13272:  MOVWF  xEB
13274:  MOVLB  0
13276:  CALL   AAF4
1327A:  MOVFF  1E,FEA
1327E:  MOVFF  1D,FE9
13282:  CLRF   FEF
13284:  MOVLW  08
13286:  MOVWF  FEA
13288:  MOVLW  D1
1328A:  MOVWF  FE9
1328C:  CALL   FE64
13290:  MOVLW  BE
13292:  MOVWF  FF6
13294:  MOVLW  1C
13296:  MOVWF  FF7
13298:  MOVLW  00
1329A:  MOVWF  FF8
1329C:  MOVLW  06
1329E:  MOVLB  8
132A0:  MOVWF  xEB
132A2:  MOVLB  0
132A4:  CALL   AAF4
132A8:  MOVFF  8E7,8ED
132AC:  MOVLW  1B
132AE:  MOVLB  8
132B0:  MOVWF  xEE
132B2:  MOVLB  0
132B4:  CALL   52A8
132B8:  MOVLW  5D
132BA:  MOVLB  8
132BC:  MOVWF  xFF
132BE:  MOVLB  0
132C0:  CALL   50C6
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
132C4:  MOVLW  01
132C6:  MOVLB  8
132C8:  MOVWF  xEC
132CA:  MOVLW  A7
132CC:  MOVWF  xEB
132CE:  MOVLB  0
132D0:  RCALL  12D9A
132D2:  MOVFF  02,03
132D6:  MOVF   01,W
132D8:  XORLW  FF
132DA:  ADDLW  A1
132DC:  MOVLB  8
132DE:  MOVWF  xEB
132E0:  MOVLW  00
132E2:  SUBFWB 02,W
132E4:  MOVWF  xEC
132E6:  MOVLW  01
132E8:  SUBWF  xEB,F
132EA:  MOVLW  00
132EC:  SUBWFB xEC,F
132EE:  MOVLW  01
132F0:  MOVWF  xEE
132F2:  MOVLW  A7
132F4:  MOVWF  xED
132F6:  CLRF   xF0
132F8:  MOVLW  67
132FA:  MOVWF  xEF
132FC:  MOVFF  8EC,8F2
13300:  MOVFF  8EB,8F1
13304:  MOVLB  0
13306:  RCALL  12DD6
....................       record_event(); 
13308:  CALL   8502
1330C:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
1330E:  MOVFF  8CC,8EB
13312:  MOVFF  8CD,8EC
13316:  MOVLB  0
13318:  CALL   10000
....................  
....................    return (rcvdData); 
1331C:  CLRF   03
1331E:  MOVLB  8
13320:  MOVFF  8E5,01
13324:  MOVFF  03,02
13328:  MOVLB  0
1332A:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
13750:  MOVLB  8
13752:  CLRF   xC4
13754:  MOVF   xC4,W
13756:  SUBLW  02
13758:  BTFSS  FD8.0
1375A:  BRA    13870
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
1375C:  MOVFF  8C2,8CC
13760:  MOVFF  8C3,8CD
13764:  MOVLB  0
13766:  CALL   12F64
1376A:  MOVFF  02,03
1376E:  MOVF   01,W
13770:  SUBLW  02
13772:  BNZ   13780
13774:  MOVF   03,F
13776:  BNZ   13780
....................       { 
....................          break; 
13778:  MOVLB  8
1377A:  BRA    13870
....................       } 
1377C:  BRA    1386C
1377E:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
13780:  MOVLW  01
13782:  MOVLB  8
13784:  ADDWF  xC4,W
13786:  MOVWF  xC5
13788:  MOVLW  C8
1378A:  MOVWF  FF6
1378C:  MOVLW  1C
1378E:  MOVWF  FF7
13790:  MOVLW  00
13792:  MOVWF  FF8
13794:  CLRF   1B
13796:  BTFSC  FF2.7
13798:  BSF    1B.7
1379A:  BCF    FF2.7
1379C:  MOVLW  05
1379E:  MOVLB  A
137A0:  MOVWF  x40
137A2:  MOVLB  0
137A4:  CALL   1044
137A8:  BTFSC  1B.7
137AA:  BSF    FF2.7
137AC:  CLRF   1B
137AE:  BTFSC  FF2.7
137B0:  BSF    1B.7
137B2:  BCF    FF2.7
137B4:  MOVFF  8C5,A40
137B8:  MOVLW  1B
137BA:  MOVLB  A
137BC:  MOVWF  x41
137BE:  MOVLB  0
137C0:  CALL   0FC6
137C4:  BTFSC  1B.7
137C6:  BSF    FF2.7
137C8:  MOVLW  0D
137CA:  BTFSS  F9E.4
137CC:  BRA    137CA
137CE:  MOVWF  FAD
137D0:  MOVLW  0A
137D2:  BTFSS  F9E.4
137D4:  BRA    137D2
137D6:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
137D8:  BCF    F90.7
....................          delay_ms(1000); 
137DA:  MOVLW  04
137DC:  MOVLB  8
137DE:  MOVWF  xC5
137E0:  MOVLW  FA
137E2:  MOVLB  9
137E4:  MOVWF  xEC
137E6:  MOVLB  0
137E8:  CALL   2938
137EC:  MOVLB  8
137EE:  DECFSZ xC5,F
137F0:  BRA    137E0
....................          output_bit(VDET,ON); 
137F2:  BSF    F90.7
....................          delay_ms(1000); 
137F4:  MOVLW  04
137F6:  MOVWF  xC5
137F8:  MOVLW  FA
137FA:  MOVLB  9
137FC:  MOVWF  xEC
137FE:  MOVLB  0
13800:  CALL   2938
13804:  MOVLB  8
13806:  DECFSZ xC5,F
13808:  BRA    137F8
....................          if (LightTargetFlag==0) 
1380A:  MOVLB  2
1380C:  MOVF   xD9,F
1380E:  BNZ   13856
....................          { 
....................           cmd='K'; 
13810:  MOVLW  4B
13812:  MOVWF  47
....................           arg=detector_ch; 
13814:  CLRF   4B
13816:  CLRF   4A
13818:  CLRF   49
1381A:  MOVFF  2D6,48
....................           det_cmd(); 
1381E:  MOVLB  0
13820:  CALL   F42A
....................           delay_ms(1000); 
13824:  MOVLW  04
13826:  MOVLB  8
13828:  MOVWF  xC5
1382A:  MOVLW  FA
1382C:  MOVLB  9
1382E:  MOVWF  xEC
13830:  MOVLB  0
13832:  CALL   2938
13836:  MOVLB  8
13838:  DECFSZ xC5,F
1383A:  BRA    1382A
....................           cmd='L'; 
1383C:  MOVLW  4C
1383E:  MOVWF  47
....................           arg=detector_li; 
13840:  CLRF   4B
13842:  CLRF   4A
13844:  MOVFF  2D8,49
13848:  MOVFF  2D7,48
....................           det_cmd(); 
1384C:  MOVLB  0
1384E:  CALL   F42A
....................          }  
13852:  BRA    1386A
13854:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
13856:  MOVLW  6C
13858:  MOVWF  47
....................           arg=1; 
1385A:  CLRF   4B
1385C:  CLRF   4A
1385E:  CLRF   49
13860:  MOVLW  01
13862:  MOVWF  48
....................           det_cmd(); 
13864:  MOVLB  0
13866:  CALL   F42A
1386A:  MOVLB  8
....................          }  
....................       } 
1386C:  INCF   xC4,F
1386E:  BRA    13754
....................    } 
....................  
....................    parse_data(); 
13870:  MOVLB  0
13872:  RCALL  136CE
....................    data_available = TRUE; 
13874:  MOVLW  01
13876:  MOVLB  3
13878:  MOVWF  x3B
....................    macro_flag = 900; 
1387A:  MOVLW  03
1387C:  MOVWF  x24
1387E:  MOVLW  84
13880:  MOVWF  x23
....................  
....................    return; 
13882:  MOVLB  0
13884:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
13BF0:  MOVLB  8
13BF2:  CLRF   xCD
13BF4:  CLRF   xCC
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
13BF6:  MOVLB  0
13BF8:  RCALL  136CE
13BFA:  MOVFF  02,8CD
13BFE:  MOVFF  01,8CC
....................    return (temp); 
13C02:  MOVLB  8
13C04:  MOVFF  8CC,01
13C08:  MOVFF  8CD,02
13C0C:  MOVLB  0
13C0E:  GOTO   13D20 (RETURN)
.................... } 
....................  
.................... void det_temp() 
13C12:  MOVLB  8
13C14:  CLRF   xC9
13C16:  CLRF   xC8
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
13C18:  MOVLB  2
13C1A:  MOVF   xD5,W
13C1C:  XORLW  01
13C1E:  MOVLB  0
13C20:  BZ    13C28
13C22:  XORLW  03
13C24:  BZ    13C32
13C26:  BRA    13C3C
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
13C28:  MOVFF  42,8CB
13C2C:  MOVFF  41,8CA
....................          break; 
13C30:  BRA    13C48
....................       case 2 : target_temp = nv_d2_temp; 
13C32:  MOVFF  44,8CB
13C36:  MOVFF  43,8CA
....................          break; 
13C3A:  BRA    13C48
....................       default : target_temp = 20000; 
13C3C:  MOVLW  4E
13C3E:  MOVLB  8
13C40:  MOVWF  xCB
13C42:  MOVLW  20
13C44:  MOVWF  xCA
....................          break; 
13C46:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
13C48:  MOVLB  8
13C4A:  CLRF   xC7
13C4C:  MOVLW  3C
13C4E:  MOVWF  xC6
....................    n = 0; 
13C50:  CLRF   xC5
13C52:  CLRF   xC4
....................    store=FALSE; 
13C54:  CLRF   xC2
....................    display=FALSE; 
13C56:  CLRF   xC3
....................  
....................    time_stamp(); 
13C58:  MOVLB  0
13C5A:  CALL   5442
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
13C5E:  MOVLW  01
13C60:  MOVWF  1E
13C62:  MOVLW  A7
13C64:  MOVWF  1D
13C66:  MOVLW  D2
13C68:  MOVWF  FF6
13C6A:  MOVLW  1C
13C6C:  MOVWF  FF7
13C6E:  MOVLW  00
13C70:  MOVWF  FF8
13C72:  MOVLW  16
13C74:  MOVLB  8
13C76:  MOVWF  xEB
13C78:  MOVLB  0
13C7A:  CALL   AAF4
13C7E:  MOVLW  10
13C80:  MOVWF  FE9
13C82:  MOVFF  8CB,8F7
13C86:  MOVFF  8CA,8F6
13C8A:  CALL   AB26
13C8E:  MOVLW  EB
13C90:  MOVWF  FF6
13C92:  MOVLW  1C
13C94:  MOVWF  FF7
13C96:  MOVLW  00
13C98:  MOVWF  FF8
13C9A:  MOVLW  09
13C9C:  MOVLB  8
13C9E:  MOVWF  xEB
13CA0:  MOVLB  0
13CA2:  CALL   AAF4
13CA6:  MOVLW  10
13CA8:  MOVWF  FE9
13CAA:  MOVFF  8C9,8F7
13CAE:  MOVFF  8C8,8F6
13CB2:  CALL   AB26
13CB6:  MOVLW  F7
13CB8:  MOVWF  FF6
13CBA:  MOVLW  1C
13CBC:  MOVWF  FF7
13CBE:  MOVLW  00
13CC0:  MOVWF  FF8
13CC2:  MOVLW  0B
13CC4:  MOVLB  8
13CC6:  MOVWF  xEB
13CC8:  MOVLB  0
13CCA:  CALL   AAF4
13CCE:  MOVLW  10
13CD0:  MOVWF  FE9
13CD2:  MOVFF  8C5,8F7
13CD6:  MOVFF  8C4,8F6
13CDA:  CALL   AB26
13CDE:  MOVLW  05
13CE0:  MOVWF  FF6
13CE2:  MOVLW  1D
13CE4:  MOVWF  FF7
13CE6:  MOVLW  00
13CE8:  MOVWF  FF8
13CEA:  MOVLW  03
13CEC:  MOVLB  8
13CEE:  MOVWF  xEB
13CF0:  MOVLB  0
13CF2:  CALL   AAF4
....................    record_event(); 
13CF6:  CALL   8502
....................  
....................    for (n=1; n<t; ++n) 
13CFA:  MOVLB  8
13CFC:  CLRF   xC5
13CFE:  MOVLW  01
13D00:  MOVWF  xC4
13D02:  MOVF   xC5,W
13D04:  SUBWF  xC7,W
13D06:  BNC   13D62
13D08:  BNZ   13D10
13D0A:  MOVF   xC6,W
13D0C:  SUBWF  xC4,W
13D0E:  BC    13D62
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
13D10:  MOVFF  8C2,8CC
13D14:  MOVFF  8C3,8CD
13D18:  MOVLB  0
13D1A:  CALL   12F64
....................       current_temp=parse_temp(); 
13D1E:  BRA    13BF0
13D20:  MOVFF  02,8C9
13D24:  MOVFF  01,8C8
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
13D28:  MOVLB  8
13D2A:  MOVF   xCB,W
13D2C:  SUBWF  xC9,W
13D2E:  BNC   13D38
13D30:  BNZ   13D40
13D32:  MOVF   xCA,W
13D34:  SUBWF  xC8,W
13D36:  BC    13D40
13D38:  MOVF   xC8,F
13D3A:  BNZ   13D44
13D3C:  MOVF   xC9,F
13D3E:  BNZ   13D44
13D40:  BRA    13D62
13D42:  BRA    13D5A
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13D44:  MOVLW  0A
13D46:  MOVWF  xCC
13D48:  MOVLW  FA
13D4A:  MOVLB  9
13D4C:  MOVWF  xEC
13D4E:  MOVLB  0
13D50:  CALL   2938
13D54:  MOVLB  8
13D56:  DECFSZ xCC,F
13D58:  BRA    13D48
13D5A:  INCF   xC4,F
13D5C:  BTFSC  FD8.2
13D5E:  INCF   xC5,F
13D60:  BRA    13D02
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13D62:  MOVLW  01
13D64:  MOVWF  1E
13D66:  MOVLW  A7
13D68:  MOVWF  1D
13D6A:  MOVLW  0A
13D6C:  MOVWF  FF6
13D6E:  MOVLW  1D
13D70:  MOVWF  FF7
13D72:  MOVLW  00
13D74:  MOVWF  FF8
13D76:  MOVLW  14
13D78:  MOVWF  xEB
13D7A:  MOVLB  0
13D7C:  CALL   AAF4
13D80:  MOVLW  10
13D82:  MOVWF  FE9
13D84:  MOVFF  8CB,8F7
13D88:  MOVFF  8CA,8F6
13D8C:  CALL   AB26
13D90:  MOVLW  21
13D92:  MOVWF  FF6
13D94:  MOVLW  1D
13D96:  MOVWF  FF7
13D98:  MOVLW  00
13D9A:  MOVWF  FF8
13D9C:  MOVLW  09
13D9E:  MOVLB  8
13DA0:  MOVWF  xEB
13DA2:  MOVLB  0
13DA4:  CALL   AAF4
13DA8:  MOVLW  10
13DAA:  MOVWF  FE9
13DAC:  MOVFF  8C9,8F7
13DB0:  MOVFF  8C8,8F6
13DB4:  CALL   AB26
13DB8:  MOVLW  2D
13DBA:  MOVWF  FF6
13DBC:  MOVLW  1D
13DBE:  MOVWF  FF7
13DC0:  MOVLW  00
13DC2:  MOVWF  FF8
13DC4:  MOVLW  0B
13DC6:  MOVLB  8
13DC8:  MOVWF  xEB
13DCA:  MOVLB  0
13DCC:  CALL   AAF4
13DD0:  MOVLW  10
13DD2:  MOVWF  FE9
13DD4:  MOVFF  8C5,8F7
13DD8:  MOVFF  8C4,8F6
13DDC:  CALL   AB26
13DE0:  MOVLW  3B
13DE2:  MOVWF  FF6
13DE4:  MOVLW  1D
13DE6:  MOVWF  FF7
13DE8:  MOVLW  00
13DEA:  MOVWF  FF8
13DEC:  MOVLW  03
13DEE:  MOVLB  8
13DF0:  MOVWF  xEB
13DF2:  MOVLB  0
13DF4:  CALL   AAF4
....................    record_event();    
13DF8:  CALL   8502
13DFC:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
138C8:  MOVLB  8
138CA:  CLRF   xD5
138CC:  CLRF   xD4
138CE:  CLRF   xD3
138D0:  CLRF   xD2
....................    set_adc_channel(1,VSS); 
138D2:  MOVLW  04
138D4:  MOVWF  01
138D6:  MOVF   FC2,W
138D8:  ANDLW  83
138DA:  IORWF  01,W
138DC:  MOVWF  FC2
138DE:  MOVLW  00
138E0:  MOVWF  01
138E2:  MOVF   FC1,W
138E4:  ANDLW  F8
138E6:  IORWF  01,W
138E8:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
138EA:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
138EC:  MOVLW  01
138EE:  MOVWF  xCF
138F0:  MOVF   xCF,W
138F2:  SUBLW  32
138F4:  BNC   1391A
....................       reading=read_adc(); 
138F6:  BSF    FC2.1
138F8:  BTFSC  FC2.1
138FA:  BRA    138F8
138FC:  MOVFF  FC3,8D6
13900:  MOVFF  FC4,8D7
13904:  CLRF   xD8
13906:  CLRF   xD9
....................       delay_ms(5); 
13908:  MOVLW  05
1390A:  MOVLB  9
1390C:  MOVWF  xEC
1390E:  MOVLB  0
13910:  CALL   2938
13914:  MOVLB  8
13916:  INCF   xCF,F
13918:  BRA    138F0
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
1391A:  MOVLW  01
1391C:  MOVWF  xCF
1391E:  MOVF   xCF,W
13920:  SUBLW  64
13922:  BNC   139D0
....................       reading=read_adc(); 
13924:  BSF    FC2.1
13926:  BTFSC  FC2.1
13928:  BRA    13926
1392A:  MOVFF  FC3,8D6
1392E:  MOVFF  FC4,8D7
13932:  CLRF   xD8
13934:  CLRF   xD9
....................       result=(((result*(i-1))+reading)/i); 
13936:  MOVLW  01
13938:  SUBWF  xCF,W
1393A:  MOVWF  xDA
1393C:  MOVFF  8D5,9F9
13940:  MOVFF  8D4,9F8
13944:  MOVFF  8D3,9F7
13948:  MOVFF  8D2,9F6
1394C:  MOVLB  9
1394E:  CLRF   xFD
13950:  CLRF   xFC
13952:  CLRF   xFB
13954:  MOVWF  xFA
13956:  MOVLB  0
13958:  CALL   4818
1395C:  MOVFF  03,8DD
13960:  MOVFF  02,8DC
13964:  MOVFF  01,8DB
13968:  MOVFF  00,8DA
1396C:  MOVLB  8
1396E:  MOVF   xD6,W
13970:  ADDWF  xDA,F
13972:  MOVF   xD7,W
13974:  ADDWFC xDB,F
13976:  MOVF   xD8,W
13978:  ADDWFC xDC,F
1397A:  MOVF   xD9,W
1397C:  ADDWFC xDD,F
1397E:  BCF    FD8.1
13980:  CLRF   1B
13982:  BTFSC  FF2.7
13984:  BSF    1B.7
13986:  BCF    FF2.7
13988:  MOVFF  8DD,A4F
1398C:  MOVFF  8DC,A4E
13990:  MOVFF  8DB,A4D
13994:  MOVFF  8DA,A4C
13998:  MOVLB  A
1399A:  CLRF   x53
1399C:  CLRF   x52
1399E:  CLRF   x51
139A0:  MOVFF  8CF,A50
139A4:  MOVLB  0
139A6:  CALL   1076
139AA:  BTFSC  1B.7
139AC:  BSF    FF2.7
139AE:  MOVFF  03,8D5
139B2:  MOVFF  02,8D4
139B6:  MOVFF  01,8D3
139BA:  MOVFF  00,8D2
....................       delay_ms(5); 
139BE:  MOVLW  05
139C0:  MOVLB  9
139C2:  MOVWF  xEC
139C4:  MOVLB  0
139C6:  CALL   2938
139CA:  MOVLB  8
139CC:  INCF   xCF,F
139CE:  BRA    1391E
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
139D0:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
139D2:  MOVFF  8D5,9F9
139D6:  MOVFF  8D4,9F8
139DA:  MOVFF  8D3,9F7
139DE:  MOVFF  8D2,9F6
139E2:  MOVLB  9
139E4:  CLRF   xFD
139E6:  CLRF   xFC
139E8:  MOVLW  10
139EA:  MOVWF  xFB
139EC:  MOVLW  25
139EE:  MOVWF  xFA
139F0:  MOVLB  0
139F2:  CALL   4818
139F6:  MOVFF  03,8DD
139FA:  MOVFF  02,8DC
139FE:  MOVFF  01,8DB
13A02:  MOVFF  00,8DA
13A06:  BCF    FD8.1
13A08:  CLRF   1B
13A0A:  BTFSC  FF2.7
13A0C:  BSF    1B.7
13A0E:  BCF    FF2.7
13A10:  MOVFF  03,A4F
13A14:  MOVFF  02,A4E
13A18:  MOVFF  01,A4D
13A1C:  MOVFF  00,A4C
13A20:  MOVLB  A
13A22:  CLRF   x53
13A24:  CLRF   x52
13A26:  CLRF   x51
13A28:  MOVLW  64
13A2A:  MOVWF  x50
13A2C:  MOVLB  0
13A2E:  CALL   1076
13A32:  BTFSC  1B.7
13A34:  BSF    FF2.7
13A36:  MOVLW  21
13A38:  MOVLB  8
13A3A:  SUBWF  00,W
13A3C:  MOVWF  xD0
13A3E:  MOVLW  50
13A40:  SUBWFB 01,W
13A42:  MOVWF  xD1
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
13A44:  MOVFF  8D0,01
13A48:  MOVFF  8D1,02
13A4C:  MOVLB  0
13A4E:  GOTO   13AB4 (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
13A5E:  CLRF   xC8
13A60:  CLRF   xC7
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
13A52:  MOVLW  0D
13A54:  MOVLB  8
13A56:  MOVWF  xC4
13A58:  MOVLW  0A
13A5A:  MOVWF  xC5
13A5C:  CLRF   xC6
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
13A62:  MOVLB  0
13A64:  CALL   1281E
....................    clear_data_buffer(); 
13A68:  CALL   D550
....................  
....................    time_stamp(); 
13A6C:  CALL   5442
....................    strcpy(data_buffer, time_stmp_str); 
13A70:  CLRF   FEA
13A72:  MOVLW  67
13A74:  MOVWF  FE9
13A76:  MOVLW  02
13A78:  MOVWF  FE2
13A7A:  MOVLW  99
13A7C:  MOVWF  FE1
13A7E:  MOVF   FE7,F
13A80:  MOVFF  FE6,FEE
13A84:  BNZ   13A7E
....................    strcat(data_buffer, (char *)",Tmp,"); 
13A86:  MOVLW  2C
13A88:  MOVLB  8
13A8A:  MOVWF  xC9
13A8C:  MOVLW  54
13A8E:  MOVWF  xCA
13A90:  MOVLW  6D
13A92:  MOVWF  xCB
13A94:  MOVLW  70
13A96:  MOVWF  xCC
13A98:  MOVLW  2C
13A9A:  MOVWF  xCD
13A9C:  CLRF   xCE
13A9E:  CLRF   xF9
13AA0:  MOVLW  67
13AA2:  MOVWF  xF8
13AA4:  MOVLW  08
13AA6:  MOVWF  xFB
13AA8:  MOVLW  C9
13AAA:  MOVWF  xFA
13AAC:  MOVLB  0
13AAE:  CALL   5506
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
13AB2:  BRA    138C8
13AB4:  MOVFF  02,8C8
13AB8:  MOVFF  01,8C7
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
13ABC:  MOVLW  02
13ABE:  MOVWF  1E
13AC0:  MOVLW  47
13AC2:  MOVWF  1D
13AC4:  MOVLW  45
13AC6:  MOVWF  FE9
13AC8:  MOVLB  8
13ACA:  CLRF   xF0
13ACC:  CLRF   xEF
13ACE:  MOVFF  8C8,8EE
13AD2:  MOVFF  8C7,8ED
13AD6:  MOVLW  03
13AD8:  MOVWF  xF1
13ADA:  MOVLB  0
13ADC:  CALL   5342
....................  
....................    strcat(slave_reply, endofline); 
13AE0:  MOVLW  02
13AE2:  MOVLB  8
13AE4:  MOVWF  xF9
13AE6:  MOVLW  47
13AE8:  MOVWF  xF8
13AEA:  MOVLW  08
13AEC:  MOVWF  xFB
13AEE:  MOVLW  C4
13AF0:  MOVWF  xFA
13AF2:  MOVLB  0
13AF4:  CALL   5506
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13AF8:  MOVLB  8
13AFA:  CLRF   xEC
13AFC:  MOVLW  67
13AFE:  MOVWF  xEB
13B00:  MOVLB  0
13B02:  CALL   12D9A
13B06:  MOVFF  02,03
13B0A:  MOVF   01,W
13B0C:  XORLW  FF
13B0E:  ADDLW  A1
13B10:  MOVLB  8
13B12:  MOVWF  xCF
13B14:  MOVLW  00
13B16:  SUBFWB 02,W
13B18:  MOVWF  xD0
13B1A:  MOVLW  01
13B1C:  SUBWF  xCF,F
13B1E:  MOVLW  00
13B20:  SUBWFB xD0,F
13B22:  CLRF   xEE
13B24:  MOVLW  67
13B26:  MOVWF  xED
13B28:  MOVLW  02
13B2A:  MOVWF  xF0
13B2C:  MOVLW  47
13B2E:  MOVWF  xEF
13B30:  MOVFF  8D0,8F2
13B34:  MOVFF  8CF,8F1
13B38:  MOVLB  0
13B3A:  CALL   12DD6
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
13B3E:  MOVF   1F,F
13B40:  BNZ   13B60
13B42:  MOVF   20,F
13B44:  BNZ   13B60
13B46:  MOVLB  8
13B48:  DECFSZ xC3,W
13B4A:  BRA    13B4E
13B4C:  BRA    13B52
13B4E:  MOVLB  0
13B50:  BRA    13B60
13B52:  CLRF   FEA
13B54:  MOVLW  67
13B56:  MOVWF  FE9
13B58:  MOVLB  0
13B5A:  CALL   79BE
13B5E:  BRA    13B74
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
13B60:  MOVF   20,F
13B62:  BNZ   13B6A
13B64:  MOVF   1F,W
13B66:  SUBLW  03
13B68:  BC    13B74
13B6A:  CLRF   FEA
13B6C:  MOVLW  67
13B6E:  MOVWF  FE9
13B70:  CALL   79BE
....................  
....................    if (store == TRUE && sd_status==0) { 
13B74:  MOVLB  8
13B76:  DECFSZ xC2,W
13B78:  BRA    13BD8
13B7A:  MOVLB  2
13B7C:  MOVF   xDC,F
13B7E:  BTFSC  FD8.2
13B80:  BRA    13B86
13B82:  MOVLB  8
13B84:  BRA    13BD8
....................       buffer_select = 0; 
13B86:  MOVLB  0
13B88:  CLRF   x66
....................       
....................       heartbeat(FALSE); 
13B8A:  MOVLB  8
13B8C:  CLRF   xED
13B8E:  MOVLB  0
13B90:  CALL   55AE
....................          append_data(file_ptr_raw_all); 
13B94:  MOVLW  02
13B96:  MOVLB  8
13B98:  MOVWF  xEE
13B9A:  MOVLW  DD
13B9C:  MOVWF  xED
13B9E:  MOVLB  0
13BA0:  CALL   8320
....................       heartbeat(TRUE); 
13BA4:  MOVLW  01
13BA6:  MOVLB  8
13BA8:  MOVWF  xED
13BAA:  MOVLB  0
13BAC:  CALL   55AE
....................        
....................       heartbeat(FALSE); 
13BB0:  MOVLB  8
13BB2:  CLRF   xED
13BB4:  MOVLB  0
13BB6:  CALL   55AE
....................          append_data(file_ptr_raw_new); 
13BBA:  MOVLW  02
13BBC:  MOVLB  8
13BBE:  MOVWF  xEE
13BC0:  MOVLW  EB
13BC2:  MOVWF  xED
13BC4:  MOVLB  0
13BC6:  CALL   8320
....................       heartbeat(TRUE); 
13BCA:  MOVLW  01
13BCC:  MOVLB  8
13BCE:  MOVWF  xED
13BD0:  MOVLB  0
13BD2:  CALL   55AE
13BD6:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13BD8:  MOVLW  03
13BDA:  MOVLB  3
13BDC:  MOVWF  x24
13BDE:  MOVLW  84
13BE0:  MOVWF  x23
....................     
....................    return (temp); 
13BE2:  MOVLB  8
13BE4:  MOVFF  8C7,01
13BE8:  MOVFF  8C8,02
13BEC:  MOVLB  0
13BEE:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
12730:  MOVLB  8
12732:  MOVF   xC5,W
12734:  ADDLW  FC
12736:  BC    12774
12738:  ADDLW  04
1273A:  MOVLB  0
1273C:  GOTO   1277C
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
12740:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
12742:  BCF    F8C.1
....................          break; 
12744:  MOVLB  8
12746:  BRA    12774
....................       case 1 :  
....................             output_bit(HSW1, ON); 
12748:  BSF    F8C.0
....................          break; 
1274A:  MOVLB  8
1274C:  BRA    12774
....................       case 2 :  
....................             output_bit(HSW2, ON); 
1274E:  BSF    F8C.1
....................          break;  
12750:  MOVLB  8
12752:  BRA    12774
....................       case 3 :  
....................             output_bit(HSW1, ON); 
12754:  BSF    F8C.0
....................             delay_ms(500); 
12756:  MOVLW  02
12758:  MOVLB  8
1275A:  MOVWF  xC6
1275C:  MOVLW  FA
1275E:  MOVLB  9
12760:  MOVWF  xEC
12762:  MOVLB  0
12764:  CALL   2938
12768:  MOVLB  8
1276A:  DECFSZ xC6,F
1276C:  BRA    1275C
....................             output_bit(HSW2, ON); 
1276E:  BSF    F8C.1
....................          break;             
12770:  BRA    12774
12772:  MOVLB  8
....................    } 
....................    heater_stat=set; 
12774:  MOVFF  8C5,4B5
12778:  MOVLB  0
1277A:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F852:  MOVLW  08
0F854:  MOVLB  8
0F856:  MOVWF  xCC
0F858:  CLRF   xCB
....................    LED_level_change=2048; 
0F85A:  MOVWF  xCE
0F85C:  CLRF   xCD
....................     
....................    for (i=0; i<12; i++){ 
0F85E:  CLRF   xCA
0F860:  MOVF   xCA,W
0F862:  SUBLW  0B
0F864:  BNC   F8DC
....................       DAC_set(1,LED_level); 
0F866:  MOVLW  01
0F868:  MOVWF  xD3
0F86A:  MOVFF  8CC,8D5
0F86E:  MOVFF  8CB,8D4
0F872:  MOVLB  0
0F874:  RCALL  F5A0
....................       LED_level_change = LED_level_change/2; 
0F876:  BCF    FD8.0
0F878:  MOVLB  8
0F87A:  RRCF   xCE,F
0F87C:  RRCF   xCD,F
....................       ADC_average(200); 
0F87E:  CLRF   xD4
0F880:  MOVLW  C8
0F882:  MOVWF  xD3
0F884:  MOVLB  0
0F886:  RCALL  F648
....................       output = ADC_val[2]; 
0F888:  MOVFF  4AA,8D0
0F88C:  MOVFF  4A9,8CF
....................       temp = ADC_val[3]; 
0F890:  MOVFF  4AC,8D2
0F894:  MOVFF  4AB,8D1
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F898:  MOVLB  8
0F89A:  MOVF   xC9,W
0F89C:  SUBWF  xD0,W
0F89E:  BNC   F8B2
0F8A0:  BNZ   F8A8
0F8A2:  MOVF   xCF,W
0F8A4:  SUBWF  xC8,W
0F8A6:  BC    F8B2
....................          LED_level=LED_level-LED_level_change; 
0F8A8:  MOVF   xCD,W
0F8AA:  SUBWF  xCB,F
0F8AC:  MOVF   xCE,W
0F8AE:  SUBWFB xCC,F
....................       } 
0F8B0:  BRA    F8D8
....................       else if(output<intensity){ 
0F8B2:  MOVF   xD0,W
0F8B4:  SUBWF  xC9,W
0F8B6:  BNC   F8CA
0F8B8:  BNZ   F8C0
0F8BA:  MOVF   xC8,W
0F8BC:  SUBWF  xCF,W
0F8BE:  BC    F8CA
....................          LED_level=LED_level+LED_level_change; 
0F8C0:  MOVF   xCD,W
0F8C2:  ADDWF  xCB,F
0F8C4:  MOVF   xCE,W
0F8C6:  ADDWFC xCC,F
....................       } 
0F8C8:  BRA    F8D8
....................       else if(output==intensity) break; 
0F8CA:  MOVF   xC8,W
0F8CC:  SUBWF  xCF,W
0F8CE:  BNZ   F8D8
0F8D0:  MOVF   xC9,W
0F8D2:  SUBWF  xD0,W
0F8D4:  BTFSC  FD8.2
0F8D6:  BRA    F8DC
0F8D8:  INCF   xCA,F
0F8DA:  BRA    F860
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F8DC:  MOVLW  01
0F8DE:  MOVWF  xD3
0F8E0:  MOVFF  8CC,8D5
0F8E4:  MOVFF  8CB,8D4
0F8E8:  MOVLB  0
0F8EA:  RCALL  F5A0
0F8EC:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F8EE:  MOVLW  01
0F8F0:  MOVLB  8
0F8F2:  MOVWF  xC7
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F8F4:  MOVF   xC5,F
0F8F6:  BNZ   F8FC
0F8F8:  MOVF   xC6,F
0F8FA:  BZ    F910
0F8FC:  MOVF   xC6,W
0F8FE:  SUBLW  0F
0F900:  BNC   F910
0F902:  MOVFF  8C6,8C9
0F906:  MOVFF  8C5,8C8
0F90A:  MOVLB  0
0F90C:  RCALL  F852
0F90E:  MOVLB  8
....................   if(intensity == 0) { 
0F910:  MOVF   xC5,F
0F912:  BNZ   F936
0F914:  MOVF   xC6,F
0F916:  BNZ   F936
....................       DAC_set(1, 0); 
0F918:  MOVLW  01
0F91A:  MOVWF  xD3
0F91C:  CLRF   xD5
0F91E:  CLRF   xD4
0F920:  MOVLB  0
0F922:  RCALL  F5A0
....................       DAC_set(2, 0); 
0F924:  MOVLW  02
0F926:  MOVLB  8
0F928:  MOVWF  xD3
0F92A:  CLRF   xD5
0F92C:  CLRF   xD4
0F92E:  MOVLB  0
0F930:  RCALL  F5A0
....................    } 
0F932:  BRA    F93A
0F934:  MOVLB  8
....................    else valid=FALSE; 
0F936:  CLRF   xC7
0F938:  MOVLB  0
....................    return(valid); 
0F93A:  MOVLB  8
0F93C:  MOVFF  8C7,01
0F940:  MOVLB  0
0F942:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FEC4:  MOVLW  40
0FEC6:  MOVWF  FF6
0FEC8:  MOVLW  1D
0FECA:  MOVWF  FF7
0FECC:  MOVLW  00
0FECE:  MOVWF  FF8
0FED0:  MOVLW  03
0FED2:  MOVWF  FEA
0FED4:  MOVLW  3D
0FED6:  MOVWF  FE9
0FED8:  RCALL  FE8A
0FEDA:  MOVF   01,W
0FEDC:  BZ    FEF0
0FEDE:  XORLW  01
0FEE0:  BZ    FF10
0FEE2:  XORLW  03
0FEE4:  BZ    FF30
0FEE6:  XORLW  01
0FEE8:  BZ    FF50
0FEEA:  XORLW  07
0FEEC:  BZ    FF70
0FEEE:  BRA    FF8E
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FEF0:  BCF    FD8.0
0FEF2:  MOVLB  3
0FEF4:  RLCF   x4A,W
0FEF6:  CLRF   03
0FEF8:  ADDLW  4B
0FEFA:  MOVWF  FE9
0FEFC:  MOVLW  03
0FEFE:  ADDWFC 03,W
0FF00:  MOVWF  FEA
0FF02:  MOVFF  4A8,FEC
0FF06:  MOVF   FED,F
0FF08:  MOVFF  4A7,FEF
....................          break; 
0FF0C:  MOVLB  0
0FF0E:  BRA    FF8E
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FF10:  BCF    FD8.0
0FF12:  MOVLB  3
0FF14:  RLCF   x4A,W
0FF16:  CLRF   03
0FF18:  ADDLW  5D
0FF1A:  MOVWF  FE9
0FF1C:  MOVLW  03
0FF1E:  ADDWFC 03,W
0FF20:  MOVWF  FEA
0FF22:  MOVFF  4A8,FEC
0FF26:  MOVF   FED,F
0FF28:  MOVFF  4A7,FEF
....................          break;    
0FF2C:  MOVLB  0
0FF2E:  BRA    FF8E
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FF30:  BCF    FD8.0
0FF32:  MOVLB  3
0FF34:  RLCF   x4A,W
0FF36:  CLRF   03
0FF38:  ADDLW  6F
0FF3A:  MOVWF  FE9
0FF3C:  MOVLW  03
0FF3E:  ADDWFC 03,W
0FF40:  MOVWF  FEA
0FF42:  MOVFF  4A8,FEC
0FF46:  MOVF   FED,F
0FF48:  MOVFF  4A7,FEF
....................          break; 
0FF4C:  MOVLB  0
0FF4E:  BRA    FF8E
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FF50:  BCF    FD8.0
0FF52:  MOVLB  3
0FF54:  RLCF   x4A,W
0FF56:  CLRF   03
0FF58:  ADDLW  81
0FF5A:  MOVWF  FE9
0FF5C:  MOVLW  03
0FF5E:  ADDWFC 03,W
0FF60:  MOVWF  FEA
0FF62:  MOVFF  4A8,FEC
0FF66:  MOVF   FED,F
0FF68:  MOVFF  4A7,FEF
....................          break; 
0FF6C:  MOVLB  0
0FF6E:  BRA    FF8E
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FF70:  BCF    FD8.0
0FF72:  MOVLB  3
0FF74:  RLCF   x4A,W
0FF76:  CLRF   03
0FF78:  ADDLW  93
0FF7A:  MOVWF  FE9
0FF7C:  MOVLW  03
0FF7E:  ADDWFC 03,W
0FF80:  MOVWF  FEA
0FF82:  MOVFF  4A8,FEC
0FF86:  MOVF   FED,F
0FF88:  MOVFF  4A7,FEF
....................          break; 
0FF8C:  MOVLB  0
....................    } 
0FF8E:  GOTO   102F8 (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
100B6:  MOVFF  8C3,8D4
100BA:  MOVFF  8C2,8D3
100BE:  CALL   F648
....................     
....................    v_supply = read_supply(); 
100C2:  CALL   5124
100C6:  MOVFF  02,8C8
100CA:  MOVFF  01,8C7
....................        
....................    RTC_reset_HT(); 
100CE:  CALL   34DA
....................    RTC_read(); 
100D2:  CALL   336C
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
100D6:  RCALL  F95C
100D8:  MOVFF  02,8CA
100DC:  MOVFF  01,8C9
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
100E0:  MOVLB  8
100E2:  DECFSZ xC6,W
100E4:  BRA    1010E
100E6:  MOVLW  10
100E8:  MOVWF  FE9
100EA:  CLRF   1B
100EC:  BTFSC  FF2.7
100EE:  BSF    1B.7
100F0:  BCF    FF2.7
100F2:  MOVFF  4AA,A41
100F6:  MOVFF  4A9,A40
100FA:  MOVLB  0
100FC:  CALL   11C6
10100:  BTFSC  1B.7
10102:  BSF    FF2.7
10104:  MOVLW  2C
10106:  BTFSS  F9E.4
10108:  BRA    10106
1010A:  MOVWF  FAD
1010C:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
1010E:  CLRF   1E
10110:  MOVLW  67
10112:  MOVWF  1D
10114:  MOVFF  72A,8ED
10118:  MOVLW  01
1011A:  MOVWF  xEE
1011C:  MOVLB  0
1011E:  CALL   52A8
10122:  MOVLW  2F
10124:  MOVLB  8
10126:  MOVWF  xFF
10128:  MOVLB  0
1012A:  CALL   50C6
1012E:  MOVFF  729,8ED
10132:  MOVLW  01
10134:  MOVLB  8
10136:  MOVWF  xEE
10138:  MOVLB  0
1013A:  CALL   52A8
1013E:  MOVLW  2F
10140:  MOVLB  8
10142:  MOVWF  xFF
10144:  MOVLB  0
10146:  CALL   50C6
1014A:  MOVFF  72B,8ED
1014E:  MOVLW  01
10150:  MOVLB  8
10152:  MOVWF  xEE
10154:  MOVLB  0
10156:  CALL   52A8
1015A:  MOVLW  20
1015C:  MOVLB  8
1015E:  MOVWF  xFF
10160:  MOVLB  0
10162:  CALL   50C6
10166:  MOVFF  727,8ED
1016A:  MOVLW  01
1016C:  MOVLB  8
1016E:  MOVWF  xEE
10170:  MOVLB  0
10172:  CALL   52A8
10176:  MOVLW  3A
10178:  MOVLB  8
1017A:  MOVWF  xFF
1017C:  MOVLB  0
1017E:  CALL   50C6
10182:  MOVFF  726,8ED
10186:  MOVLW  01
10188:  MOVLB  8
1018A:  MOVWF  xEE
1018C:  MOVLB  0
1018E:  CALL   52A8
10192:  MOVLW  3A
10194:  MOVLB  8
10196:  MOVWF  xFF
10198:  MOVLB  0
1019A:  CALL   50C6
1019E:  MOVFF  725,8ED
101A2:  MOVLW  01
101A4:  MOVLB  8
101A6:  MOVWF  xEE
101A8:  MOVLB  0
101AA:  CALL   52A8
101AE:  MOVLW  2C
101B0:  MOVLB  8
101B2:  MOVWF  xFF
101B4:  MOVLB  0
101B6:  CALL   50C6
101BA:  MOVLW  04
101BC:  MOVWF  FE9
101BE:  MOVLB  8
101C0:  CLRF   xF0
101C2:  CLRF   xEF
101C4:  MOVFF  8C8,8EE
101C8:  MOVFF  8C7,8ED
101CC:  MOVLW  02
101CE:  MOVWF  xF1
101D0:  MOVLB  0
101D2:  CALL   5342
101D6:  MOVLW  2C
101D8:  MOVLB  8
101DA:  MOVWF  xFF
101DC:  MOVLB  0
101DE:  CALL   50C6
101E2:  MOVFF  1E,FEA
101E6:  MOVFF  1D,FE9
101EA:  CLRF   FEF
101EC:  MOVLW  03
101EE:  MOVWF  FEA
101F0:  MOVLW  3D
101F2:  MOVWF  FE9
101F4:  RCALL  FE64
101F6:  MOVLW  2C
101F8:  MOVLB  8
101FA:  MOVWF  xFF
101FC:  MOVLB  0
101FE:  CALL   50C6
10202:  MOVFF  1E,FEA
10206:  MOVFF  1D,FE9
1020A:  CLRF   FEF
1020C:  MOVLW  03
1020E:  MOVWF  FEA
10210:  MOVLW  42
10212:  MOVWF  FE9
10214:  RCALL  FE64
10216:  MOVLW  2C
10218:  MOVLB  8
1021A:  MOVWF  xFF
1021C:  MOVLB  0
1021E:  CALL   50C6
10222:  MOVFF  1E,FEA
10226:  MOVFF  1D,FE9
1022A:  CLRF   FEF
1022C:  MOVLW  03
1022E:  MOVWF  FEA
10230:  MOVLW  46
10232:  MOVWF  FE9
10234:  RCALL  FE64
10236:  MOVLW  2C
10238:  MOVLB  8
1023A:  MOVWF  xFF
1023C:  MOVLB  0
1023E:  CALL   50C6
10242:  MOVLW  10
10244:  MOVWF  FE9
10246:  MOVFF  26,8F7
1024A:  MOVFF  25,8F6
1024E:  CALL   AB26
10252:  MOVLW  2C
10254:  MOVLB  8
10256:  MOVWF  xFF
10258:  MOVLB  0
1025A:  CALL   50C6
1025E:  MOVLW  10
10260:  MOVWF  FE9
10262:  MOVFF  8CA,8F7
10266:  MOVFF  8C9,8F6
1026A:  CALL   AB26
1026E:  MOVLW  2C
10270:  MOVLB  8
10272:  MOVWF  xFF
10274:  MOVLB  0
10276:  CALL   50C6
1027A:  MOVFF  4B5,8ED
1027E:  MOVLW  1B
10280:  MOVLB  8
10282:  MOVWF  xEE
10284:  MOVLB  0
10286:  CALL   52A8
1028A:  MOVLW  2C
1028C:  MOVLB  8
1028E:  MOVWF  xFF
10290:  MOVLB  0
10292:  CALL   50C6
10296:  MOVLW  10
10298:  MOVWF  FE9
1029A:  MOVFF  4A8,8F7
1029E:  MOVFF  4A7,8F6
102A2:  CALL   AB26
102A6:  MOVLW  2C
102A8:  MOVLB  8
102AA:  MOVWF  xFF
102AC:  MOVLB  0
102AE:  CALL   50C6
102B2:  MOVLW  10
102B4:  MOVWF  FE9
102B6:  MOVFF  4AE,8F7
102BA:  MOVFF  4AD,8F6
102BE:  CALL   AB26
102C2:  MOVLW  2C
102C4:  MOVLB  8
102C6:  MOVWF  xFF
102C8:  MOVLB  0
102CA:  CALL   50C6
102CE:  MOVLW  10
102D0:  MOVWF  FE9
102D2:  MOVFF  4AC,8F7
102D6:  MOVFF  4AB,8F6
102DA:  CALL   AB26
102DE:  MOVLW  0D
102E0:  MOVLB  8
102E2:  MOVWF  xFF
102E4:  MOVLB  0
102E6:  CALL   50C6
102EA:  MOVLW  0A
102EC:  MOVLB  8
102EE:  MOVWF  xFF
102F0:  MOVLB  0
102F2:  CALL   50C6
....................  
....................    load_scanned_data();  
102F6:  BRA    FEC4
....................  
....................    display_rec(store, display); 
102F8:  MOVFF  8C4,8EB
102FC:  MOVFF  8C5,8EC
10300:  RCALL  10000
....................     
....................    data_available = TRUE; 
10302:  MOVLW  01
10304:  MOVLB  3
10306:  MOVWF  x3B
....................    macro_flag = 900; 
10308:  MOVLW  03
1030A:  MOVWF  x24
1030C:  MOVLW  84
1030E:  MOVWF  x23
10310:  MOVLB  0
10312:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
10314:  MOVLB  8
10316:  CLRF   x8B
10318:  CLRF   x8A
....................    channel=channel-20000; 
1031A:  MOVLW  20
1031C:  SUBWF  x87,F
1031E:  MOVLW  4E
10320:  SUBWFB x88,F
....................     
....................    for (i=0; i<9; i++){ 
10322:  CLRF   x89
10324:  MOVF   x89,W
10326:  SUBLW  08
10328:  BNC   103CA
....................       DAC_set(channel, setting); 
1032A:  MOVFF  887,8D3
1032E:  MOVFF  88B,8D5
10332:  MOVFF  88A,8D4
10336:  MOVLB  0
10338:  CALL   F5A0
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
1033C:  MOVLW  56
1033E:  MOVWF  FF6
10340:  MOVLW  1D
10342:  MOVWF  FF7
10344:  MOVLW  00
10346:  MOVWF  FF8
10348:  CLRF   1B
1034A:  BTFSC  FF2.7
1034C:  BSF    1B.7
1034E:  BCF    FF2.7
10350:  MOVLW  05
10352:  MOVLB  A
10354:  MOVWF  x40
10356:  MOVLB  0
10358:  CALL   1044
1035C:  BTFSC  1B.7
1035E:  BSF    FF2.7
10360:  MOVLW  10
10362:  MOVWF  FE9
10364:  CLRF   1B
10366:  BTFSC  FF2.7
10368:  BSF    1B.7
1036A:  BCF    FF2.7
1036C:  MOVFF  888,A41
10370:  MOVFF  887,A40
10374:  CALL   11C6
10378:  BTFSC  1B.7
1037A:  BSF    FF2.7
1037C:  MOVLW  2C
1037E:  BTFSS  F9E.4
10380:  BRA    1037E
10382:  MOVWF  FAD
10384:  MOVLW  10
10386:  MOVWF  FE9
10388:  CLRF   1B
1038A:  BTFSC  FF2.7
1038C:  BSF    1B.7
1038E:  BCF    FF2.7
10390:  MOVFF  88B,A41
10394:  MOVFF  88A,A40
10398:  CALL   11C6
1039C:  BTFSC  1B.7
1039E:  BSF    FF2.7
103A0:  MOVLW  2C
103A2:  BTFSS  F9E.4
103A4:  BRA    103A2
103A6:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
103A8:  MOVLB  8
103AA:  CLRF   xC3
103AC:  MOVLW  C8
103AE:  MOVWF  xC2
103B0:  CLRF   xC4
103B2:  MOVLW  01
103B4:  MOVWF  xC5
103B6:  MOVWF  xC6
103B8:  MOVLB  0
103BA:  RCALL  100B6
....................       setting = setting+500; 
103BC:  MOVLW  F4
103BE:  MOVLB  8
103C0:  ADDWF  x8A,F
103C2:  MOVLW  01
103C4:  ADDWFC x8B,F
103C6:  INCF   x89,F
103C8:  BRA    10324
....................    } 
103CA:  MOVLB  0
103CC:  GOTO   10528 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
103D0:  MOVLB  8
103D2:  CLRF   x87
103D4:  CLRF   x86
....................     
....................    for (i=0; i<9; i++){ 
103D6:  CLRF   x85
103D8:  MOVF   x85,W
103DA:  SUBLW  08
103DC:  BNC   10456
....................       LED_SAR(intensity); 
103DE:  MOVFF  887,8C9
103E2:  MOVFF  886,8C8
103E6:  MOVLB  0
103E8:  CALL   F852
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
103EC:  MOVLW  64
103EE:  MOVWF  FF6
103F0:  MOVLW  1D
103F2:  MOVWF  FF7
103F4:  MOVLW  00
103F6:  MOVWF  FF8
103F8:  CLRF   1B
103FA:  BTFSC  FF2.7
103FC:  BSF    1B.7
103FE:  BCF    FF2.7
10400:  MOVLW  07
10402:  MOVLB  A
10404:  MOVWF  x40
10406:  MOVLB  0
10408:  CALL   1044
1040C:  BTFSC  1B.7
1040E:  BSF    FF2.7
10410:  MOVLW  10
10412:  MOVWF  FE9
10414:  CLRF   1B
10416:  BTFSC  FF2.7
10418:  BSF    1B.7
1041A:  BCF    FF2.7
1041C:  MOVFF  887,A41
10420:  MOVFF  886,A40
10424:  CALL   11C6
10428:  BTFSC  1B.7
1042A:  BSF    FF2.7
1042C:  MOVLW  2C
1042E:  BTFSS  F9E.4
10430:  BRA    1042E
10432:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
10434:  MOVLB  8
10436:  CLRF   xC3
10438:  MOVLW  C8
1043A:  MOVWF  xC2
1043C:  CLRF   xC4
1043E:  MOVLW  01
10440:  MOVWF  xC5
10442:  MOVWF  xC6
10444:  MOVLB  0
10446:  RCALL  100B6
....................       intensity = intensity+500; 
10448:  MOVLW  F4
1044A:  MOVLB  8
1044C:  ADDWF  x86,F
1044E:  MOVLW  01
10450:  ADDWFC x87,F
10452:  INCF   x85,F
10454:  BRA    103D8
....................    } 
10456:  MOVLB  0
10458:  GOTO   10528 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
030E2:  MOVLB  8
030E4:  CLRF   xB6
030E6:  MOVF   xB6,W
030E8:  SUBLW  20
030EA:  BNC   3100
030EC:  CLRF   03
030EE:  MOVF   xB6,W
030F0:  ADDLW  B7
030F2:  MOVWF  FE9
030F4:  MOVLW  04
030F6:  ADDWFC 03,W
030F8:  MOVWF  FEA
030FA:  CLRF   FEF
030FC:  INCF   xB6,F
030FE:  BRA    30E6
03100:  MOVLB  0
03102:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
03104:  MOVF   2F,W
03106:  SUBLW  02
03108:  BNZ   3112
0310A:  MOVF   30,F
0310C:  BNZ   3112
0310E:  MOVLW  00
03110:  MOVWF  F99
....................    init_valve_status(); 
03112:  RCALL  30E2
....................    bus_pwr_status=0; 
03114:  MOVLB  4
03116:  CLRF   xB6
03118:  MOVLB  0
0311A:  GOTO   1B86E (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0ED8E:  MOVLW  70
0ED90:  MOVWF  FF6
0ED92:  MOVLW  1D
0ED94:  MOVWF  FF7
0ED96:  MOVLW  00
0ED98:  MOVWF  FF8
0ED9A:  CLRF   1B
0ED9C:  BTFSC  FF2.7
0ED9E:  BSF    1B.7
0EDA0:  BCF    FF2.7
0EDA2:  CALL   0E6E
0EDA6:  BTFSC  1B.7
0EDA8:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EDAA:  MOVLW  01
0EDAC:  MOVLB  8
0EDAE:  MOVWF  xB6
0EDB0:  MOVF   xB6,W
0EDB2:  SUBLW  08
0EDB4:  BNC   EE1E
0EDB6:  CLRF   03
0EDB8:  MOVF   xB6,W
0EDBA:  ADDLW  B7
0EDBC:  MOVWF  FE9
0EDBE:  MOVLW  04
0EDC0:  ADDWFC 03,W
0EDC2:  MOVWF  FEA
0EDC4:  MOVFF  FEF,8B7
0EDC8:  CLRF   1B
0EDCA:  BTFSC  FF2.7
0EDCC:  BSF    1B.7
0EDCE:  BCF    FF2.7
0EDD0:  MOVFF  8B6,A40
0EDD4:  MOVLW  01
0EDD6:  MOVLB  A
0EDD8:  MOVWF  x41
0EDDA:  MOVLB  0
0EDDC:  CALL   0FC6
0EDE0:  BTFSC  1B.7
0EDE2:  BSF    FF2.7
0EDE4:  MOVLW  5B
0EDE6:  BTFSS  F9E.4
0EDE8:  BRA    EDE6
0EDEA:  MOVWF  FAD
0EDEC:  CLRF   1B
0EDEE:  BTFSC  FF2.7
0EDF0:  BSF    1B.7
0EDF2:  BCF    FF2.7
0EDF4:  MOVFF  8B7,A40
0EDF8:  MOVLW  1B
0EDFA:  MOVLB  A
0EDFC:  MOVWF  x41
0EDFE:  MOVLB  0
0EE00:  CALL   0FC6
0EE04:  BTFSC  1B.7
0EE06:  BSF    FF2.7
0EE08:  MOVLW  5D
0EE0A:  BTFSS  F9E.4
0EE0C:  BRA    EE0A
0EE0E:  MOVWF  FAD
0EE10:  MOVLW  20
0EE12:  BTFSS  F9E.4
0EE14:  BRA    EE12
0EE16:  MOVWF  FAD
0EE18:  MOVLB  8
0EE1A:  INCF   xB6,F
0EE1C:  BRA    EDB0
....................    fprintf(COM_A, "\r\n"); 
0EE1E:  MOVLW  0D
0EE20:  BTFSS  F9E.4
0EE22:  BRA    EE20
0EE24:  MOVWF  FAD
0EE26:  MOVLW  0A
0EE28:  BTFSS  F9E.4
0EE2A:  BRA    EE28
0EE2C:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EE2E:  MOVLW  76
0EE30:  MOVWF  FF6
0EE32:  MOVLW  1D
0EE34:  MOVWF  FF7
0EE36:  MOVLW  00
0EE38:  MOVWF  FF8
0EE3A:  CLRF   1B
0EE3C:  BTFSC  FF2.7
0EE3E:  BSF    1B.7
0EE40:  BCF    FF2.7
0EE42:  MOVLB  0
0EE44:  CALL   0E6E
0EE48:  BTFSC  1B.7
0EE4A:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EE4C:  MOVLW  09
0EE4E:  MOVLB  8
0EE50:  MOVWF  xB6
0EE52:  MOVF   xB6,W
0EE54:  SUBLW  10
0EE56:  BNC   EEC0
0EE58:  CLRF   03
0EE5A:  MOVF   xB6,W
0EE5C:  ADDLW  B7
0EE5E:  MOVWF  FE9
0EE60:  MOVLW  04
0EE62:  ADDWFC 03,W
0EE64:  MOVWF  FEA
0EE66:  MOVFF  FEF,8B7
0EE6A:  CLRF   1B
0EE6C:  BTFSC  FF2.7
0EE6E:  BSF    1B.7
0EE70:  BCF    FF2.7
0EE72:  MOVFF  8B6,A40
0EE76:  MOVLW  01
0EE78:  MOVLB  A
0EE7A:  MOVWF  x41
0EE7C:  MOVLB  0
0EE7E:  CALL   0FC6
0EE82:  BTFSC  1B.7
0EE84:  BSF    FF2.7
0EE86:  MOVLW  5B
0EE88:  BTFSS  F9E.4
0EE8A:  BRA    EE88
0EE8C:  MOVWF  FAD
0EE8E:  CLRF   1B
0EE90:  BTFSC  FF2.7
0EE92:  BSF    1B.7
0EE94:  BCF    FF2.7
0EE96:  MOVFF  8B7,A40
0EE9A:  MOVLW  1B
0EE9C:  MOVLB  A
0EE9E:  MOVWF  x41
0EEA0:  MOVLB  0
0EEA2:  CALL   0FC6
0EEA6:  BTFSC  1B.7
0EEA8:  BSF    FF2.7
0EEAA:  MOVLW  5D
0EEAC:  BTFSS  F9E.4
0EEAE:  BRA    EEAC
0EEB0:  MOVWF  FAD
0EEB2:  MOVLW  20
0EEB4:  BTFSS  F9E.4
0EEB6:  BRA    EEB4
0EEB8:  MOVWF  FAD
0EEBA:  MOVLB  8
0EEBC:  INCF   xB6,F
0EEBE:  BRA    EE52
....................    fprintf(COM_A, "\r\n"); 
0EEC0:  MOVLW  0D
0EEC2:  BTFSS  F9E.4
0EEC4:  BRA    EEC2
0EEC6:  MOVWF  FAD
0EEC8:  MOVLW  0A
0EECA:  BTFSS  F9E.4
0EECC:  BRA    EECA
0EECE:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EED0:  MOVLW  7C
0EED2:  MOVWF  FF6
0EED4:  MOVLW  1D
0EED6:  MOVWF  FF7
0EED8:  MOVLW  00
0EEDA:  MOVWF  FF8
0EEDC:  CLRF   1B
0EEDE:  BTFSC  FF2.7
0EEE0:  BSF    1B.7
0EEE2:  BCF    FF2.7
0EEE4:  MOVLB  0
0EEE6:  CALL   0E6E
0EEEA:  BTFSC  1B.7
0EEEC:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EEEE:  MOVLW  11
0EEF0:  MOVLB  8
0EEF2:  MOVWF  xB6
0EEF4:  MOVF   xB6,W
0EEF6:  SUBLW  18
0EEF8:  BNC   EF62
0EEFA:  CLRF   03
0EEFC:  MOVF   xB6,W
0EEFE:  ADDLW  B7
0EF00:  MOVWF  FE9
0EF02:  MOVLW  04
0EF04:  ADDWFC 03,W
0EF06:  MOVWF  FEA
0EF08:  MOVFF  FEF,8B7
0EF0C:  CLRF   1B
0EF0E:  BTFSC  FF2.7
0EF10:  BSF    1B.7
0EF12:  BCF    FF2.7
0EF14:  MOVFF  8B6,A40
0EF18:  MOVLW  01
0EF1A:  MOVLB  A
0EF1C:  MOVWF  x41
0EF1E:  MOVLB  0
0EF20:  CALL   0FC6
0EF24:  BTFSC  1B.7
0EF26:  BSF    FF2.7
0EF28:  MOVLW  5B
0EF2A:  BTFSS  F9E.4
0EF2C:  BRA    EF2A
0EF2E:  MOVWF  FAD
0EF30:  CLRF   1B
0EF32:  BTFSC  FF2.7
0EF34:  BSF    1B.7
0EF36:  BCF    FF2.7
0EF38:  MOVFF  8B7,A40
0EF3C:  MOVLW  1B
0EF3E:  MOVLB  A
0EF40:  MOVWF  x41
0EF42:  MOVLB  0
0EF44:  CALL   0FC6
0EF48:  BTFSC  1B.7
0EF4A:  BSF    FF2.7
0EF4C:  MOVLW  5D
0EF4E:  BTFSS  F9E.4
0EF50:  BRA    EF4E
0EF52:  MOVWF  FAD
0EF54:  MOVLW  20
0EF56:  BTFSS  F9E.4
0EF58:  BRA    EF56
0EF5A:  MOVWF  FAD
0EF5C:  MOVLB  8
0EF5E:  INCF   xB6,F
0EF60:  BRA    EEF4
....................    fprintf(COM_A, "\r\n"); 
0EF62:  MOVLW  0D
0EF64:  BTFSS  F9E.4
0EF66:  BRA    EF64
0EF68:  MOVWF  FAD
0EF6A:  MOVLW  0A
0EF6C:  BTFSS  F9E.4
0EF6E:  BRA    EF6C
0EF70:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EF72:  MOVLW  82
0EF74:  MOVWF  FF6
0EF76:  MOVLW  1D
0EF78:  MOVWF  FF7
0EF7A:  MOVLW  00
0EF7C:  MOVWF  FF8
0EF7E:  CLRF   1B
0EF80:  BTFSC  FF2.7
0EF82:  BSF    1B.7
0EF84:  BCF    FF2.7
0EF86:  MOVLB  0
0EF88:  CALL   0E6E
0EF8C:  BTFSC  1B.7
0EF8E:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EF90:  MOVLW  19
0EF92:  MOVLB  8
0EF94:  MOVWF  xB6
0EF96:  MOVF   xB6,W
0EF98:  SUBLW  20
0EF9A:  BNC   F004
0EF9C:  CLRF   03
0EF9E:  MOVF   xB6,W
0EFA0:  ADDLW  B7
0EFA2:  MOVWF  FE9
0EFA4:  MOVLW  04
0EFA6:  ADDWFC 03,W
0EFA8:  MOVWF  FEA
0EFAA:  MOVFF  FEF,8B7
0EFAE:  CLRF   1B
0EFB0:  BTFSC  FF2.7
0EFB2:  BSF    1B.7
0EFB4:  BCF    FF2.7
0EFB6:  MOVFF  8B6,A40
0EFBA:  MOVLW  01
0EFBC:  MOVLB  A
0EFBE:  MOVWF  x41
0EFC0:  MOVLB  0
0EFC2:  CALL   0FC6
0EFC6:  BTFSC  1B.7
0EFC8:  BSF    FF2.7
0EFCA:  MOVLW  5B
0EFCC:  BTFSS  F9E.4
0EFCE:  BRA    EFCC
0EFD0:  MOVWF  FAD
0EFD2:  CLRF   1B
0EFD4:  BTFSC  FF2.7
0EFD6:  BSF    1B.7
0EFD8:  BCF    FF2.7
0EFDA:  MOVFF  8B7,A40
0EFDE:  MOVLW  1B
0EFE0:  MOVLB  A
0EFE2:  MOVWF  x41
0EFE4:  MOVLB  0
0EFE6:  CALL   0FC6
0EFEA:  BTFSC  1B.7
0EFEC:  BSF    FF2.7
0EFEE:  MOVLW  5D
0EFF0:  BTFSS  F9E.4
0EFF2:  BRA    EFF0
0EFF4:  MOVWF  FAD
0EFF6:  MOVLW  20
0EFF8:  BTFSS  F9E.4
0EFFA:  BRA    EFF8
0EFFC:  MOVWF  FAD
0EFFE:  MOVLB  8
0F000:  INCF   xB6,F
0F002:  BRA    EF96
....................    fprintf(COM_A, "\r\n");    
0F004:  MOVLW  0D
0F006:  BTFSS  F9E.4
0F008:  BRA    F006
0F00A:  MOVWF  FAD
0F00C:  MOVLW  0A
0F00E:  BTFSS  F9E.4
0F010:  BRA    F00E
0F012:  MOVWF  FAD
0F014:  MOVLB  0
0F016:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
144D8:  MOVF   1F,W
144DA:  SUBLW  04
144DC:  BNZ   14546
144DE:  MOVF   20,F
144E0:  BNZ   14546
144E2:  MOVLW  88
144E4:  MOVWF  FF6
144E6:  MOVLW  1D
144E8:  MOVWF  FF7
144EA:  MOVLW  00
144EC:  MOVWF  FF8
144EE:  CLRF   1B
144F0:  BTFSC  FF2.7
144F2:  BSF    1B.7
144F4:  BCF    FF2.7
144F6:  MOVLW  0C
144F8:  MOVLB  A
144FA:  MOVWF  x40
144FC:  MOVLB  0
144FE:  CALL   1044
14502:  BTFSC  1B.7
14504:  BSF    FF2.7
14506:  MOVLW  10
14508:  MOVWF  FE9
1450A:  CLRF   1B
1450C:  BTFSC  FF2.7
1450E:  BSF    1B.7
14510:  BCF    FF2.7
14512:  MOVFF  8B7,A41
14516:  MOVFF  8B6,A40
1451A:  CALL   11C6
1451E:  BTFSC  1B.7
14520:  BSF    FF2.7
14522:  MOVLW  97
14524:  MOVWF  FF6
14526:  MOVLW  1D
14528:  MOVWF  FF7
1452A:  MOVLW  00
1452C:  MOVWF  FF8
1452E:  CLRF   1B
14530:  BTFSC  FF2.7
14532:  BSF    1B.7
14534:  BCF    FF2.7
14536:  MOVLW  03
14538:  MOVLB  A
1453A:  MOVWF  x40
1453C:  MOVLB  0
1453E:  CALL   1044
14542:  BTFSC  1B.7
14544:  BSF    FF2.7
....................  
....................    multidrop_on(); 
14546:  CALL   DAA0
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
1454A:  MOVLW  9C
1454C:  MOVWF  FF6
1454E:  MOVLW  1D
14550:  MOVWF  FF7
14552:  MOVLW  00
14554:  MOVWF  FF8
14556:  MOVLW  03
14558:  MOVLB  8
1455A:  MOVWF  xB8
1455C:  MOVLB  0
1455E:  CALL   DAB4
14562:  MOVLW  10
14564:  MOVWF  FE9
14566:  MOVFF  8B7,8B9
1456A:  MOVFF  8B6,8B8
1456E:  BRA    1441E
14570:  MOVLW  0D
14572:  BTFSS  FA4.4
14574:  BRA    14572
14576:  MOVLB  F
14578:  MOVWF  x1C
....................    multidrop_off(); 
1457A:  MOVLB  0
1457C:  CALL   DB8C
....................  
....................    delay_ms(100); 
14580:  MOVLW  64
14582:  MOVLB  9
14584:  MOVWF  xEC
14586:  MOVLB  0
14588:  CALL   2938
1458C:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0DBDE:  MOVF   1F,W
0DBE0:  SUBLW  04
0DBE2:  BNZ   DC4C
0DBE4:  MOVF   20,F
0DBE6:  BNZ   DC4C
0DBE8:  MOVLW  A4
0DBEA:  MOVWF  FF6
0DBEC:  MOVLW  1D
0DBEE:  MOVWF  FF7
0DBF0:  MOVLW  00
0DBF2:  MOVWF  FF8
0DBF4:  CLRF   1B
0DBF6:  BTFSC  FF2.7
0DBF8:  BSF    1B.7
0DBFA:  BCF    FF2.7
0DBFC:  MOVLW  0C
0DBFE:  MOVLB  A
0DC00:  MOVWF  x40
0DC02:  MOVLB  0
0DC04:  CALL   1044
0DC08:  BTFSC  1B.7
0DC0A:  BSF    FF2.7
0DC0C:  CLRF   1B
0DC0E:  BTFSC  FF2.7
0DC10:  BSF    1B.7
0DC12:  BCF    FF2.7
0DC14:  MOVFF  8B6,A40
0DC18:  MOVLW  1B
0DC1A:  MOVLB  A
0DC1C:  MOVWF  x41
0DC1E:  MOVLB  0
0DC20:  CALL   0FC6
0DC24:  BTFSC  1B.7
0DC26:  BSF    FF2.7
0DC28:  MOVLW  B2
0DC2A:  MOVWF  FF6
0DC2C:  MOVLW  1D
0DC2E:  MOVWF  FF7
0DC30:  MOVLW  00
0DC32:  MOVWF  FF8
0DC34:  CLRF   1B
0DC36:  BTFSC  FF2.7
0DC38:  BSF    1B.7
0DC3A:  BCF    FF2.7
0DC3C:  MOVLW  03
0DC3E:  MOVLB  A
0DC40:  MOVWF  x40
0DC42:  MOVLB  0
0DC44:  CALL   1044
0DC48:  BTFSC  1B.7
0DC4A:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0DC4C:  RCALL  DAA0
....................       fprintf(COM_B, "/1c%u\r",chip); 
0DC4E:  MOVLW  B6
0DC50:  MOVWF  FF6
0DC52:  MOVLW  1D
0DC54:  MOVWF  FF7
0DC56:  MOVLW  00
0DC58:  MOVWF  FF8
0DC5A:  MOVLW  03
0DC5C:  MOVLB  8
0DC5E:  MOVWF  xB8
0DC60:  MOVLB  0
0DC62:  RCALL  DAB4
0DC64:  MOVFF  8B6,8F3
0DC68:  MOVLW  1B
0DC6A:  MOVLB  8
0DC6C:  MOVWF  xF4
0DC6E:  MOVLB  0
0DC70:  RCALL  DAE8
0DC72:  MOVLW  0D
0DC74:  BTFSS  FA4.4
0DC76:  BRA    DC74
0DC78:  MOVLB  F
0DC7A:  MOVWF  x1C
....................    multidrop_off(); 
0DC7C:  MOVLB  0
0DC7E:  RCALL  DB8C
....................    delay_ms(100); 
0DC80:  MOVLW  64
0DC82:  MOVLB  9
0DC84:  MOVWF  xEC
0DC86:  MOVLB  0
0DC88:  CALL   2938
....................  
....................    multidrop_on(); 
0DC8C:  RCALL  DAA0
....................      fprintf(COM_B, "/1s256\r"); 
0DC8E:  MOVLW  BE
0DC90:  MOVWF  FF6
0DC92:  MOVLW  1D
0DC94:  MOVWF  FF7
0DC96:  MOVLW  00
0DC98:  MOVWF  FF8
0DC9A:  BRA    DBAE
....................    multidrop_off();  
0DC9C:  RCALL  DB8C
....................    delay_ms(100); 
0DC9E:  MOVLW  64
0DCA0:  MOVLB  9
0DCA2:  MOVWF  xEC
0DCA4:  MOVLB  0
0DCA6:  CALL   2938
0DCAA:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
1458E:  MOVLB  8
14590:  MOVF   xB5,W
14592:  ADDLW  DF
14594:  BTFSC  FD8.0
14596:  BRA    14982
14598:  ADDLW  21
1459A:  MOVLB  0
1459C:  GOTO   149B4
....................       case 0 : sol_chip_cmd(1); 
145A0:  MOVLW  01
145A2:  MOVLB  8
145A4:  MOVWF  xB6
145A6:  MOVLB  0
145A8:  CALL   DBDE
....................                sol_switch_cmd(0); 
145AC:  MOVLB  8
145AE:  CLRF   xB7
145B0:  CLRF   xB6
145B2:  MOVLB  0
145B4:  RCALL  144D8
....................                sol_chip_cmd(2); 
145B6:  MOVLW  02
145B8:  MOVLB  8
145BA:  MOVWF  xB6
145BC:  MOVLB  0
145BE:  CALL   DBDE
....................                sol_switch_cmd(0); 
145C2:  MOVLB  8
145C4:  CLRF   xB7
145C6:  CLRF   xB6
145C8:  MOVLB  0
145CA:  RCALL  144D8
....................                sol_chip_cmd(3); 
145CC:  MOVLW  03
145CE:  MOVLB  8
145D0:  MOVWF  xB6
145D2:  MOVLB  0
145D4:  CALL   DBDE
....................                sol_switch_cmd(0); 
145D8:  MOVLB  8
145DA:  CLRF   xB7
145DC:  CLRF   xB6
145DE:  MOVLB  0
145E0:  RCALL  144D8
....................                sol_chip_cmd(4); 
145E2:  MOVLW  04
145E4:  MOVLB  8
145E6:  MOVWF  xB6
145E8:  MOVLB  0
145EA:  CALL   DBDE
....................                sol_switch_cmd(0); 
145EE:  MOVLB  8
145F0:  CLRF   xB7
145F2:  CLRF   xB6
145F4:  MOVLB  0
145F6:  RCALL  144D8
....................                init_valve_status(); 
145F8:  CALL   30E2
....................          break; 
145FC:  MOVLB  8
145FE:  BRA    14982
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
14600:  MOVLW  01
14602:  MOVLB  8
14604:  MOVWF  xB6
14606:  MOVLB  0
14608:  CALL   DBDE
....................                sol_switch_cmd(1); 
1460C:  MOVLB  8
1460E:  CLRF   xB7
14610:  MOVLW  01
14612:  MOVWF  xB6
14614:  MOVLB  0
14616:  RCALL  144D8
....................          break;     
14618:  MOVLB  8
1461A:  BRA    14982
....................       case 2 : sol_chip_cmd(1); 
1461C:  MOVLW  01
1461E:  MOVLB  8
14620:  MOVWF  xB6
14622:  MOVLB  0
14624:  CALL   DBDE
....................                sol_switch_cmd(2); 
14628:  MOVLB  8
1462A:  CLRF   xB7
1462C:  MOVLW  02
1462E:  MOVWF  xB6
14630:  MOVLB  0
14632:  RCALL  144D8
....................          break;           
14634:  MOVLB  8
14636:  BRA    14982
....................       case 3 : sol_chip_cmd(1); 
14638:  MOVLW  01
1463A:  MOVLB  8
1463C:  MOVWF  xB6
1463E:  MOVLB  0
14640:  CALL   DBDE
....................                sol_switch_cmd(4); 
14644:  MOVLB  8
14646:  CLRF   xB7
14648:  MOVLW  04
1464A:  MOVWF  xB6
1464C:  MOVLB  0
1464E:  RCALL  144D8
....................          break;  
14650:  MOVLB  8
14652:  BRA    14982
....................       case 4 : sol_chip_cmd(1); 
14654:  MOVLW  01
14656:  MOVLB  8
14658:  MOVWF  xB6
1465A:  MOVLB  0
1465C:  CALL   DBDE
....................                sol_switch_cmd(8); 
14660:  MOVLB  8
14662:  CLRF   xB7
14664:  MOVLW  08
14666:  MOVWF  xB6
14668:  MOVLB  0
1466A:  RCALL  144D8
....................          break;  
1466C:  MOVLB  8
1466E:  BRA    14982
....................       case 5 : sol_chip_cmd(1); 
14670:  MOVLW  01
14672:  MOVLB  8
14674:  MOVWF  xB6
14676:  MOVLB  0
14678:  CALL   DBDE
....................                sol_switch_cmd(16); 
1467C:  MOVLB  8
1467E:  CLRF   xB7
14680:  MOVLW  10
14682:  MOVWF  xB6
14684:  MOVLB  0
14686:  RCALL  144D8
....................          break;  
14688:  MOVLB  8
1468A:  BRA    14982
....................       case 6 : sol_chip_cmd(1); 
1468C:  MOVLW  01
1468E:  MOVLB  8
14690:  MOVWF  xB6
14692:  MOVLB  0
14694:  CALL   DBDE
....................                sol_switch_cmd(32); 
14698:  MOVLB  8
1469A:  CLRF   xB7
1469C:  MOVLW  20
1469E:  MOVWF  xB6
146A0:  MOVLB  0
146A2:  RCALL  144D8
....................          break;  
146A4:  MOVLB  8
146A6:  BRA    14982
....................       case 7 : sol_chip_cmd(1); 
146A8:  MOVLW  01
146AA:  MOVLB  8
146AC:  MOVWF  xB6
146AE:  MOVLB  0
146B0:  CALL   DBDE
....................                sol_switch_cmd(64); 
146B4:  MOVLB  8
146B6:  CLRF   xB7
146B8:  MOVLW  40
146BA:  MOVWF  xB6
146BC:  MOVLB  0
146BE:  RCALL  144D8
....................          break;  
146C0:  MOVLB  8
146C2:  BRA    14982
....................       case 8 : sol_chip_cmd(1); 
146C4:  MOVLW  01
146C6:  MOVLB  8
146C8:  MOVWF  xB6
146CA:  MOVLB  0
146CC:  CALL   DBDE
....................                sol_switch_cmd(128); 
146D0:  MOVLB  8
146D2:  CLRF   xB7
146D4:  MOVLW  80
146D6:  MOVWF  xB6
146D8:  MOVLB  0
146DA:  RCALL  144D8
....................          break;   
146DC:  MOVLB  8
146DE:  BRA    14982
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
146E0:  MOVLW  02
146E2:  MOVLB  8
146E4:  MOVWF  xB6
146E6:  MOVLB  0
146E8:  CALL   DBDE
....................                sol_switch_cmd(1); 
146EC:  MOVLB  8
146EE:  CLRF   xB7
146F0:  MOVLW  01
146F2:  MOVWF  xB6
146F4:  MOVLB  0
146F6:  RCALL  144D8
....................          break;     
146F8:  MOVLB  8
146FA:  BRA    14982
....................       case 10 : sol_chip_cmd(2); 
146FC:  MOVLW  02
146FE:  MOVLB  8
14700:  MOVWF  xB6
14702:  MOVLB  0
14704:  CALL   DBDE
....................                sol_switch_cmd(2); 
14708:  MOVLB  8
1470A:  CLRF   xB7
1470C:  MOVLW  02
1470E:  MOVWF  xB6
14710:  MOVLB  0
14712:  RCALL  144D8
....................          break;           
14714:  MOVLB  8
14716:  BRA    14982
....................       case 11 : sol_chip_cmd(2); 
14718:  MOVLW  02
1471A:  MOVLB  8
1471C:  MOVWF  xB6
1471E:  MOVLB  0
14720:  CALL   DBDE
....................                sol_switch_cmd(4); 
14724:  MOVLB  8
14726:  CLRF   xB7
14728:  MOVLW  04
1472A:  MOVWF  xB6
1472C:  MOVLB  0
1472E:  RCALL  144D8
....................          break;  
14730:  MOVLB  8
14732:  BRA    14982
....................       case 12 : sol_chip_cmd(2); 
14734:  MOVLW  02
14736:  MOVLB  8
14738:  MOVWF  xB6
1473A:  MOVLB  0
1473C:  CALL   DBDE
....................                sol_switch_cmd(8); 
14740:  MOVLB  8
14742:  CLRF   xB7
14744:  MOVLW  08
14746:  MOVWF  xB6
14748:  MOVLB  0
1474A:  RCALL  144D8
....................          break;  
1474C:  MOVLB  8
1474E:  BRA    14982
....................       case 13 : sol_chip_cmd(2); 
14750:  MOVLW  02
14752:  MOVLB  8
14754:  MOVWF  xB6
14756:  MOVLB  0
14758:  CALL   DBDE
....................                sol_switch_cmd(16); 
1475C:  MOVLB  8
1475E:  CLRF   xB7
14760:  MOVLW  10
14762:  MOVWF  xB6
14764:  MOVLB  0
14766:  RCALL  144D8
....................          break;  
14768:  MOVLB  8
1476A:  BRA    14982
....................       case 14 : sol_chip_cmd(2); 
1476C:  MOVLW  02
1476E:  MOVLB  8
14770:  MOVWF  xB6
14772:  MOVLB  0
14774:  CALL   DBDE
....................                sol_switch_cmd(32); 
14778:  MOVLB  8
1477A:  CLRF   xB7
1477C:  MOVLW  20
1477E:  MOVWF  xB6
14780:  MOVLB  0
14782:  RCALL  144D8
....................          break;  
14784:  MOVLB  8
14786:  BRA    14982
....................       case 15 : sol_chip_cmd(2); 
14788:  MOVLW  02
1478A:  MOVLB  8
1478C:  MOVWF  xB6
1478E:  MOVLB  0
14790:  CALL   DBDE
....................                sol_switch_cmd(64); 
14794:  MOVLB  8
14796:  CLRF   xB7
14798:  MOVLW  40
1479A:  MOVWF  xB6
1479C:  MOVLB  0
1479E:  RCALL  144D8
....................          break;  
147A0:  MOVLB  8
147A2:  BRA    14982
....................       case 16 : sol_chip_cmd(2); 
147A4:  MOVLW  02
147A6:  MOVLB  8
147A8:  MOVWF  xB6
147AA:  MOVLB  0
147AC:  CALL   DBDE
....................                sol_switch_cmd(128); 
147B0:  MOVLB  8
147B2:  CLRF   xB7
147B4:  MOVLW  80
147B6:  MOVWF  xB6
147B8:  MOVLB  0
147BA:  RCALL  144D8
....................          break;   
147BC:  MOVLB  8
147BE:  BRA    14982
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
147C0:  MOVLW  03
147C2:  MOVLB  8
147C4:  MOVWF  xB6
147C6:  MOVLB  0
147C8:  CALL   DBDE
....................                sol_switch_cmd(1); 
147CC:  MOVLB  8
147CE:  CLRF   xB7
147D0:  MOVLW  01
147D2:  MOVWF  xB6
147D4:  MOVLB  0
147D6:  RCALL  144D8
....................          break;     
147D8:  MOVLB  8
147DA:  BRA    14982
....................       case 18 : sol_chip_cmd(3); 
147DC:  MOVLW  03
147DE:  MOVLB  8
147E0:  MOVWF  xB6
147E2:  MOVLB  0
147E4:  CALL   DBDE
....................                sol_switch_cmd(2); 
147E8:  MOVLB  8
147EA:  CLRF   xB7
147EC:  MOVLW  02
147EE:  MOVWF  xB6
147F0:  MOVLB  0
147F2:  RCALL  144D8
....................          break;           
147F4:  MOVLB  8
147F6:  BRA    14982
....................       case 19 : sol_chip_cmd(3); 
147F8:  MOVLW  03
147FA:  MOVLB  8
147FC:  MOVWF  xB6
147FE:  MOVLB  0
14800:  CALL   DBDE
....................                sol_switch_cmd(4); 
14804:  MOVLB  8
14806:  CLRF   xB7
14808:  MOVLW  04
1480A:  MOVWF  xB6
1480C:  MOVLB  0
1480E:  RCALL  144D8
....................          break;  
14810:  MOVLB  8
14812:  BRA    14982
....................       case 20 : sol_chip_cmd(3); 
14814:  MOVLW  03
14816:  MOVLB  8
14818:  MOVWF  xB6
1481A:  MOVLB  0
1481C:  CALL   DBDE
....................                sol_switch_cmd(8); 
14820:  MOVLB  8
14822:  CLRF   xB7
14824:  MOVLW  08
14826:  MOVWF  xB6
14828:  MOVLB  0
1482A:  RCALL  144D8
....................          break;  
1482C:  MOVLB  8
1482E:  BRA    14982
....................       case 21 : sol_chip_cmd(3); 
14830:  MOVLW  03
14832:  MOVLB  8
14834:  MOVWF  xB6
14836:  MOVLB  0
14838:  CALL   DBDE
....................                sol_switch_cmd(16); 
1483C:  MOVLB  8
1483E:  CLRF   xB7
14840:  MOVLW  10
14842:  MOVWF  xB6
14844:  MOVLB  0
14846:  RCALL  144D8
....................          break;  
14848:  MOVLB  8
1484A:  BRA    14982
....................       case 22 : sol_chip_cmd(3); 
1484C:  MOVLW  03
1484E:  MOVLB  8
14850:  MOVWF  xB6
14852:  MOVLB  0
14854:  CALL   DBDE
....................                sol_switch_cmd(32); 
14858:  MOVLB  8
1485A:  CLRF   xB7
1485C:  MOVLW  20
1485E:  MOVWF  xB6
14860:  MOVLB  0
14862:  RCALL  144D8
....................          break;  
14864:  MOVLB  8
14866:  BRA    14982
....................       case 23 : sol_chip_cmd(3); 
14868:  MOVLW  03
1486A:  MOVLB  8
1486C:  MOVWF  xB6
1486E:  MOVLB  0
14870:  CALL   DBDE
....................                sol_switch_cmd(64); 
14874:  MOVLB  8
14876:  CLRF   xB7
14878:  MOVLW  40
1487A:  MOVWF  xB6
1487C:  MOVLB  0
1487E:  RCALL  144D8
....................          break;  
14880:  MOVLB  8
14882:  BRA    14982
....................       case 24 : sol_chip_cmd(3); 
14884:  MOVLW  03
14886:  MOVLB  8
14888:  MOVWF  xB6
1488A:  MOVLB  0
1488C:  CALL   DBDE
....................                sol_switch_cmd(128); 
14890:  MOVLB  8
14892:  CLRF   xB7
14894:  MOVLW  80
14896:  MOVWF  xB6
14898:  MOVLB  0
1489A:  RCALL  144D8
....................          break;      
1489C:  MOVLB  8
1489E:  BRA    14982
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
148A0:  MOVLW  04
148A2:  MOVLB  8
148A4:  MOVWF  xB6
148A6:  MOVLB  0
148A8:  CALL   DBDE
....................                sol_switch_cmd(1); 
148AC:  MOVLB  8
148AE:  CLRF   xB7
148B0:  MOVLW  01
148B2:  MOVWF  xB6
148B4:  MOVLB  0
148B6:  RCALL  144D8
....................          break;     
148B8:  MOVLB  8
148BA:  BRA    14982
....................       case 26 : sol_chip_cmd(4); 
148BC:  MOVLW  04
148BE:  MOVLB  8
148C0:  MOVWF  xB6
148C2:  MOVLB  0
148C4:  CALL   DBDE
....................                sol_switch_cmd(2); 
148C8:  MOVLB  8
148CA:  CLRF   xB7
148CC:  MOVLW  02
148CE:  MOVWF  xB6
148D0:  MOVLB  0
148D2:  RCALL  144D8
....................          break;           
148D4:  MOVLB  8
148D6:  BRA    14982
....................       case 27 : sol_chip_cmd(4); 
148D8:  MOVLW  04
148DA:  MOVLB  8
148DC:  MOVWF  xB6
148DE:  MOVLB  0
148E0:  CALL   DBDE
....................                sol_switch_cmd(4); 
148E4:  MOVLB  8
148E6:  CLRF   xB7
148E8:  MOVLW  04
148EA:  MOVWF  xB6
148EC:  MOVLB  0
148EE:  RCALL  144D8
....................          break;  
148F0:  MOVLB  8
148F2:  BRA    14982
....................       case 28 : sol_chip_cmd(4); 
148F4:  MOVLW  04
148F6:  MOVLB  8
148F8:  MOVWF  xB6
148FA:  MOVLB  0
148FC:  CALL   DBDE
....................                sol_switch_cmd(8); 
14900:  MOVLB  8
14902:  CLRF   xB7
14904:  MOVLW  08
14906:  MOVWF  xB6
14908:  MOVLB  0
1490A:  RCALL  144D8
....................          break;  
1490C:  MOVLB  8
1490E:  BRA    14982
....................       case 29 : sol_chip_cmd(4); 
14910:  MOVLW  04
14912:  MOVLB  8
14914:  MOVWF  xB6
14916:  MOVLB  0
14918:  CALL   DBDE
....................                sol_switch_cmd(16); 
1491C:  MOVLB  8
1491E:  CLRF   xB7
14920:  MOVLW  10
14922:  MOVWF  xB6
14924:  MOVLB  0
14926:  RCALL  144D8
....................          break;  
14928:  MOVLB  8
1492A:  BRA    14982
....................       case 30 : sol_chip_cmd(4); 
1492C:  MOVLW  04
1492E:  MOVLB  8
14930:  MOVWF  xB6
14932:  MOVLB  0
14934:  CALL   DBDE
....................                sol_switch_cmd(32); 
14938:  MOVLB  8
1493A:  CLRF   xB7
1493C:  MOVLW  20
1493E:  MOVWF  xB6
14940:  MOVLB  0
14942:  RCALL  144D8
....................          break;  
14944:  MOVLB  8
14946:  BRA    14982
....................       case 31 : sol_chip_cmd(4); 
14948:  MOVLW  04
1494A:  MOVLB  8
1494C:  MOVWF  xB6
1494E:  MOVLB  0
14950:  CALL   DBDE
....................                sol_switch_cmd(64); 
14954:  MOVLB  8
14956:  CLRF   xB7
14958:  MOVLW  40
1495A:  MOVWF  xB6
1495C:  MOVLB  0
1495E:  RCALL  144D8
....................          break;  
14960:  MOVLB  8
14962:  BRA    14982
....................       case 32 : sol_chip_cmd(4); 
14964:  MOVLW  04
14966:  MOVLB  8
14968:  MOVWF  xB6
1496A:  MOVLB  0
1496C:  CALL   DBDE
....................                sol_switch_cmd(128); 
14970:  MOVLB  8
14972:  CLRF   xB7
14974:  MOVLW  80
14976:  MOVWF  xB6
14978:  MOVLB  0
1497A:  RCALL  144D8
....................          break; 
1497C:  MOVLB  8
1497E:  BRA    14982
14980:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
14982:  MOVF   xB5,F
14984:  BZ    1499E
14986:  MOVF   xB5,W
14988:  SUBLW  20
1498A:  BNC   1499E
1498C:  CLRF   03
1498E:  MOVF   xB5,W
14990:  ADDLW  B7
14992:  MOVWF  FE9
14994:  MOVLW  04
14996:  ADDWFC 03,W
14998:  MOVWF  FEA
1499A:  MOVLW  01
1499C:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
1499E:  MOVF   1F,W
149A0:  SUBLW  04
149A2:  BNZ   149B0
149A4:  MOVF   20,F
149A6:  BNZ   149B0
149A8:  MOVLB  0
149AA:  CALL   ED8E
149AE:  MOVLB  8
149B0:  MOVLB  0
149B2:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
1052C:  MOVLB  8
1052E:  CLRF   x9D
10530:  MOVF   x9D,W
10532:  SUBLW  07
10534:  BNC   10550
10536:  BCF    FD8.0
10538:  RLCF   x9D,W
1053A:  CLRF   03
1053C:  ADDLW  4B
1053E:  MOVWF  FE9
10540:  MOVLW  03
10542:  ADDWFC 03,W
10544:  MOVWF  FEA
10546:  CLRF   FEC
10548:  MOVF   FED,F
1054A:  CLRF   FEF
1054C:  INCF   x9D,F
1054E:  BRA    10530
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
10550:  CLRF   x9D
10552:  MOVF   x9D,W
10554:  SUBLW  07
10556:  BNC   10572
10558:  BCF    FD8.0
1055A:  RLCF   x9D,W
1055C:  CLRF   03
1055E:  ADDLW  5D
10560:  MOVWF  FE9
10562:  MOVLW  03
10564:  ADDWFC 03,W
10566:  MOVWF  FEA
10568:  CLRF   FEC
1056A:  MOVF   FED,F
1056C:  CLRF   FEF
1056E:  INCF   x9D,F
10570:  BRA    10552
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
10572:  CLRF   x9D
10574:  MOVF   x9D,W
10576:  SUBLW  07
10578:  BNC   10594
1057A:  BCF    FD8.0
1057C:  RLCF   x9D,W
1057E:  CLRF   03
10580:  ADDLW  6F
10582:  MOVWF  FE9
10584:  MOVLW  03
10586:  ADDWFC 03,W
10588:  MOVWF  FEA
1058A:  CLRF   FEC
1058C:  MOVF   FED,F
1058E:  CLRF   FEF
10590:  INCF   x9D,F
10592:  BRA    10574
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
10594:  CLRF   x9D
10596:  MOVF   x9D,W
10598:  SUBLW  07
1059A:  BNC   105B6
1059C:  BCF    FD8.0
1059E:  RLCF   x9D,W
105A0:  CLRF   03
105A2:  ADDLW  81
105A4:  MOVWF  FE9
105A6:  MOVLW  03
105A8:  ADDWFC 03,W
105AA:  MOVWF  FEA
105AC:  CLRF   FEC
105AE:  MOVF   FED,F
105B0:  CLRF   FEF
105B2:  INCF   x9D,F
105B4:  BRA    10596
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
105B6:  CLRF   x9D
105B8:  MOVF   x9D,W
105BA:  SUBLW  07
105BC:  BNC   105D8
105BE:  BCF    FD8.0
105C0:  RLCF   x9D,W
105C2:  CLRF   03
105C4:  ADDLW  93
105C6:  MOVWF  FE9
105C8:  MOVLW  03
105CA:  ADDWFC 03,W
105CC:  MOVWF  FEA
105CE:  CLRF   FEC
105D0:  MOVF   FED,F
105D2:  CLRF   FEF
105D4:  INCF   x9D,F
105D6:  BRA    105B8
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
105D8:  MOVLW  04
105DA:  MOVWF  FEA
105DC:  MOVLW  25
105DE:  MOVWF  FE9
105E0:  CLRF   00
105E2:  CLRF   02
105E4:  MOVLW  44
105E6:  MOVWF  01
105E8:  MOVLB  0
105EA:  CALL   354E
105EE:  GOTO   153F4 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10E7A:  MOVLB  8
10E7C:  CLRF   xC2
10E7E:  MOVF   xC2,W
10E80:  SUBLW  03
10E82:  BNC   10EA2
10E84:  MOVF   xC2,W
10E86:  MULLW  04
10E88:  MOVF   FF3,W
10E8A:  CLRF   03
10E8C:  ADDLW  A5
10E8E:  MOVWF  FE9
10E90:  MOVLW  03
10E92:  ADDWFC 03,W
10E94:  MOVWF  FEA
10E96:  CLRF   FEF
10E98:  CLRF   FEC
10E9A:  CLRF   FEC
10E9C:  CLRF   FEC
10E9E:  INCF   xC2,F
10EA0:  BRA    10E7E
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10EA2:  MOVLB  3
10EA4:  MOVF   x4B,F
10EA6:  BTFSS  FD8.2
10EA8:  BRA    10EAE
10EAA:  MOVF   x4C,F
10EAC:  BZ    10F48
10EAE:  MOVF   x4D,F
10EB0:  BNZ   10EB6
10EB2:  MOVF   x4E,F
10EB4:  BZ    10F48
....................       blank = NO3_array[0]; 
10EB6:  MOVFF  34C,918
10EBA:  MOVFF  34B,917
10EBE:  MOVLB  0
10EC0:  CALL   C91E
10EC4:  MOVFF  03,8C6
10EC8:  MOVFF  02,8C5
10ECC:  MOVFF  01,8C4
10ED0:  MOVFF  00,8C3
....................       react = NO3_array[1]; 
10ED4:  MOVFF  34E,918
10ED8:  MOVFF  34D,917
10EDC:  CALL   C91E
10EE0:  MOVFF  03,8CA
10EE4:  MOVFF  02,8C9
10EE8:  MOVFF  01,8C8
10EEC:  MOVFF  00,8C7
....................       ratio = blank / react; 
10EF0:  MOVFF  8C6,8FE
10EF4:  MOVFF  8C5,8FD
10EF8:  MOVFF  8C4,8FC
10EFC:  MOVFF  8C3,8FB
10F00:  MOVFF  8CA,902
10F04:  MOVFF  8C9,901
10F08:  MOVFF  8C8,900
10F0C:  MOVFF  8C7,8FF
10F10:  CALL   C954
10F14:  MOVFF  03,8CE
10F18:  MOVFF  02,8CD
10F1C:  MOVFF  01,8CC
10F20:  MOVFF  00,8CB
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10F24:  MOVFF  8CE,8D2
10F28:  MOVFF  8CD,8D1
10F2C:  MOVFF  8CC,8D0
10F30:  MOVFF  8CB,8CF
10F34:  RCALL  10BF8
10F36:  MOVFF  03,3A8
10F3A:  MOVFF  02,3A7
10F3E:  MOVFF  01,3A6
10F42:  MOVFF  00,3A5
10F46:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10F48:  MOVF   x4F,F
10F4A:  BNZ   10F50
10F4C:  MOVF   x50,F
10F4E:  BZ    10FEA
10F50:  MOVF   x51,F
10F52:  BNZ   10F58
10F54:  MOVF   x52,F
10F56:  BZ    10FEA
....................       blank = NO3_array[2]; 
10F58:  MOVFF  350,918
10F5C:  MOVFF  34F,917
10F60:  MOVLB  0
10F62:  CALL   C91E
10F66:  MOVFF  03,8C6
10F6A:  MOVFF  02,8C5
10F6E:  MOVFF  01,8C4
10F72:  MOVFF  00,8C3
....................       react = NO3_array[3]; 
10F76:  MOVFF  352,918
10F7A:  MOVFF  351,917
10F7E:  CALL   C91E
10F82:  MOVFF  03,8CA
10F86:  MOVFF  02,8C9
10F8A:  MOVFF  01,8C8
10F8E:  MOVFF  00,8C7
....................       ratio = blank / react;    
10F92:  MOVFF  8C6,8FE
10F96:  MOVFF  8C5,8FD
10F9A:  MOVFF  8C4,8FC
10F9E:  MOVFF  8C3,8FB
10FA2:  MOVFF  8CA,902
10FA6:  MOVFF  8C9,901
10FAA:  MOVFF  8C8,900
10FAE:  MOVFF  8C7,8FF
10FB2:  CALL   C954
10FB6:  MOVFF  03,8CE
10FBA:  MOVFF  02,8CD
10FBE:  MOVFF  01,8CC
10FC2:  MOVFF  00,8CB
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10FC6:  MOVFF  8CE,8D2
10FCA:  MOVFF  8CD,8D1
10FCE:  MOVFF  8CC,8D0
10FD2:  MOVFF  8CB,8CF
10FD6:  RCALL  10BF8
10FD8:  MOVFF  03,3AC
10FDC:  MOVFF  02,3AB
10FE0:  MOVFF  01,3AA
10FE4:  MOVFF  00,3A9
10FE8:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10FEA:  MOVF   x53,F
10FEC:  BNZ   10FF2
10FEE:  MOVF   x54,F
10FF0:  BZ    1108C
10FF2:  MOVF   x55,F
10FF4:  BNZ   10FFA
10FF6:  MOVF   x56,F
10FF8:  BZ    1108C
....................       blank = NO3_array[4]; 
10FFA:  MOVFF  354,918
10FFE:  MOVFF  353,917
11002:  MOVLB  0
11004:  CALL   C91E
11008:  MOVFF  03,8C6
1100C:  MOVFF  02,8C5
11010:  MOVFF  01,8C4
11014:  MOVFF  00,8C3
....................       react = NO3_array[5]; 
11018:  MOVFF  356,918
1101C:  MOVFF  355,917
11020:  CALL   C91E
11024:  MOVFF  03,8CA
11028:  MOVFF  02,8C9
1102C:  MOVFF  01,8C8
11030:  MOVFF  00,8C7
....................       ratio = blank / react; 
11034:  MOVFF  8C6,8FE
11038:  MOVFF  8C5,8FD
1103C:  MOVFF  8C4,8FC
11040:  MOVFF  8C3,8FB
11044:  MOVFF  8CA,902
11048:  MOVFF  8C9,901
1104C:  MOVFF  8C8,900
11050:  MOVFF  8C7,8FF
11054:  CALL   C954
11058:  MOVFF  03,8CE
1105C:  MOVFF  02,8CD
11060:  MOVFF  01,8CC
11064:  MOVFF  00,8CB
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
11068:  MOVFF  8CE,8D2
1106C:  MOVFF  8CD,8D1
11070:  MOVFF  8CC,8D0
11074:  MOVFF  8CB,8CF
11078:  RCALL  10BF8
1107A:  MOVFF  03,3B0
1107E:  MOVFF  02,3AF
11082:  MOVFF  01,3AE
11086:  MOVFF  00,3AD
1108A:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
1108C:  MOVF   x57,F
1108E:  BNZ   11094
11090:  MOVF   x58,F
11092:  BZ    1112E
11094:  MOVF   x59,F
11096:  BNZ   1109C
11098:  MOVF   x5A,F
1109A:  BZ    1112E
....................       blank = NO3_array[6]; 
1109C:  MOVFF  358,918
110A0:  MOVFF  357,917
110A4:  MOVLB  0
110A6:  CALL   C91E
110AA:  MOVFF  03,8C6
110AE:  MOVFF  02,8C5
110B2:  MOVFF  01,8C4
110B6:  MOVFF  00,8C3
....................       react = NO3_array[7]; 
110BA:  MOVFF  35A,918
110BE:  MOVFF  359,917
110C2:  CALL   C91E
110C6:  MOVFF  03,8CA
110CA:  MOVFF  02,8C9
110CE:  MOVFF  01,8C8
110D2:  MOVFF  00,8C7
....................       ratio = blank / react; 
110D6:  MOVFF  8C6,8FE
110DA:  MOVFF  8C5,8FD
110DE:  MOVFF  8C4,8FC
110E2:  MOVFF  8C3,8FB
110E6:  MOVFF  8CA,902
110EA:  MOVFF  8C9,901
110EE:  MOVFF  8C8,900
110F2:  MOVFF  8C7,8FF
110F6:  CALL   C954
110FA:  MOVFF  03,8CE
110FE:  MOVFF  02,8CD
11102:  MOVFF  01,8CC
11106:  MOVFF  00,8CB
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
1110A:  MOVFF  8CE,8D2
1110E:  MOVFF  8CD,8D1
11112:  MOVFF  8CC,8D0
11116:  MOVFF  8CB,8CF
1111A:  RCALL  10BF8
1111C:  MOVFF  03,3B4
11120:  MOVFF  02,3B3
11124:  MOVFF  01,3B2
11128:  MOVFF  00,3B1
1112C:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
1112E:  MOVLW  04
11130:  MOVWF  1E
11132:  MOVLW  25
11134:  MOVWF  1D
11136:  MOVLW  C6
11138:  MOVWF  FF6
1113A:  MOVLW  1D
1113C:  MOVWF  FF7
1113E:  MOVLW  00
11140:  MOVWF  FF8
11142:  MOVLW  06
11144:  MOVLB  8
11146:  MOVWF  xEB
11148:  MOVLB  0
1114A:  CALL   AAF4
1114E:  MOVLW  10
11150:  MOVWF  FE9
11152:  MOVFF  34C,8F7
11156:  MOVFF  34B,8F6
1115A:  CALL   AB26
1115E:  MOVLW  CF
11160:  MOVWF  FF6
11162:  MOVLW  1D
11164:  MOVWF  FF7
11166:  MOVLW  00
11168:  MOVWF  FF8
1116A:  MOVLW  07
1116C:  MOVLB  8
1116E:  MOVWF  xEB
11170:  MOVLB  0
11172:  CALL   AAF4
11176:  MOVLW  10
11178:  MOVWF  FE9
1117A:  MOVFF  34E,8F7
1117E:  MOVFF  34D,8F6
11182:  CALL   AB26
11186:  MOVLW  D9
11188:  MOVWF  FF6
1118A:  MOVLW  1D
1118C:  MOVWF  FF7
1118E:  MOVLW  00
11190:  MOVWF  FF8
11192:  MOVLW  09
11194:  MOVLB  8
11196:  MOVWF  xEB
11198:  MOVLB  0
1119A:  CALL   AAF4
1119E:  MOVLW  89
111A0:  MOVWF  FE9
111A2:  MOVFF  3A8,8D2
111A6:  MOVFF  3A7,8D1
111AA:  MOVFF  3A6,8D0
111AE:  MOVFF  3A5,8CF
111B2:  MOVLW  04
111B4:  MOVLB  8
111B6:  MOVWF  xD3
111B8:  MOVLB  0
111BA:  RCALL  10C64
111BC:  MOVLW  E7
111BE:  MOVWF  FF6
111C0:  MOVLW  1D
111C2:  MOVWF  FF7
111C4:  MOVLW  00
111C6:  MOVWF  FF8
111C8:  MOVLW  07
111CA:  MOVLB  8
111CC:  MOVWF  xEB
111CE:  MOVLB  0
111D0:  CALL   AAF4
111D4:  MOVLW  10
111D6:  MOVWF  FE9
111D8:  MOVFF  350,8F7
111DC:  MOVFF  34F,8F6
111E0:  CALL   AB26
111E4:  MOVLW  F1
111E6:  MOVWF  FF6
111E8:  MOVLW  1D
111EA:  MOVWF  FF7
111EC:  MOVLW  00
111EE:  MOVWF  FF8
111F0:  MOVLW  07
111F2:  MOVLB  8
111F4:  MOVWF  xEB
111F6:  MOVLB  0
111F8:  CALL   AAF4
111FC:  MOVLW  10
111FE:  MOVWF  FE9
11200:  MOVFF  352,8F7
11204:  MOVFF  351,8F6
11208:  CALL   AB26
1120C:  MOVLW  FB
1120E:  MOVWF  FF6
11210:  MOVLW  1D
11212:  MOVWF  FF7
11214:  MOVLW  00
11216:  MOVWF  FF8
11218:  MOVLW  09
1121A:  MOVLB  8
1121C:  MOVWF  xEB
1121E:  MOVLB  0
11220:  CALL   AAF4
11224:  MOVLW  89
11226:  MOVWF  FE9
11228:  MOVFF  3AC,8D2
1122C:  MOVFF  3AB,8D1
11230:  MOVFF  3AA,8D0
11234:  MOVFF  3A9,8CF
11238:  MOVLW  04
1123A:  MOVLB  8
1123C:  MOVWF  xD3
1123E:  MOVLB  0
11240:  RCALL  10C64
11242:  MOVLW  09
11244:  MOVWF  FF6
11246:  MOVLW  1E
11248:  MOVWF  FF7
1124A:  MOVLW  00
1124C:  MOVWF  FF8
1124E:  MOVLW  07
11250:  MOVLB  8
11252:  MOVWF  xEB
11254:  MOVLB  0
11256:  CALL   AAF4
1125A:  MOVLW  10
1125C:  MOVWF  FE9
1125E:  MOVFF  354,8F7
11262:  MOVFF  353,8F6
11266:  CALL   AB26
1126A:  MOVLW  13
1126C:  MOVWF  FF6
1126E:  MOVLW  1E
11270:  MOVWF  FF7
11272:  MOVLW  00
11274:  MOVWF  FF8
11276:  MOVLW  07
11278:  MOVLB  8
1127A:  MOVWF  xEB
1127C:  MOVLB  0
1127E:  CALL   AAF4
11282:  MOVLW  10
11284:  MOVWF  FE9
11286:  MOVFF  356,8F7
1128A:  MOVFF  355,8F6
1128E:  CALL   AB26
11292:  MOVLW  1D
11294:  MOVWF  FF6
11296:  MOVLW  1E
11298:  MOVWF  FF7
1129A:  MOVLW  00
1129C:  MOVWF  FF8
1129E:  MOVLW  09
112A0:  MOVLB  8
112A2:  MOVWF  xEB
112A4:  MOVLB  0
112A6:  CALL   AAF4
112AA:  MOVLW  89
112AC:  MOVWF  FE9
112AE:  MOVFF  3B0,8D2
112B2:  MOVFF  3AF,8D1
112B6:  MOVFF  3AE,8D0
112BA:  MOVFF  3AD,8CF
112BE:  MOVLW  04
112C0:  MOVLB  8
112C2:  MOVWF  xD3
112C4:  MOVLB  0
112C6:  RCALL  10C64
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
112C8:  MOVF   1F,W
112CA:  SUBLW  02
112CC:  BNZ   112D2
112CE:  MOVF   20,F
112D0:  BZ    11312
112D2:  MOVLW  2C
112D4:  MOVWF  FF6
112D6:  MOVLW  1E
112D8:  MOVWF  FF7
112DA:  MOVLW  00
112DC:  MOVWF  FF8
112DE:  CLRF   1B
112E0:  BTFSC  FF2.7
112E2:  BSF    1B.7
112E4:  BCF    FF2.7
112E6:  MOVLW  09
112E8:  MOVLB  A
112EA:  MOVWF  x40
112EC:  MOVLB  0
112EE:  CALL   1044
112F2:  BTFSC  1B.7
112F4:  BSF    FF2.7
112F6:  MOVLW  04
112F8:  MOVWF  FEA
112FA:  MOVLW  25
112FC:  MOVWF  FE9
112FE:  CALL   79BE
11302:  MOVLW  0D
11304:  BTFSS  F9E.4
11306:  BRA    11304
11308:  MOVWF  FAD
1130A:  MOVLW  0A
1130C:  BTFSS  F9E.4
1130E:  BRA    1130C
11310:  MOVWF  FAD
11312:  GOTO   1261E (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
11316:  MOVLB  8
11318:  CLRF   xC2
1131A:  MOVF   xC2,W
1131C:  SUBLW  03
1131E:  BNC   1133E
11320:  MOVF   xC2,W
11322:  MULLW  04
11324:  MOVF   FF3,W
11326:  CLRF   03
11328:  ADDLW  B5
1132A:  MOVWF  FE9
1132C:  MOVLW  03
1132E:  ADDWFC 03,W
11330:  MOVWF  FEA
11332:  CLRF   FEF
11334:  CLRF   FEC
11336:  CLRF   FEC
11338:  CLRF   FEC
1133A:  INCF   xC2,F
1133C:  BRA    1131A
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
1133E:  MOVLB  3
11340:  MOVF   x5D,F
11342:  BTFSS  FD8.2
11344:  BRA    1134A
11346:  MOVF   x5E,F
11348:  BZ    113E4
1134A:  MOVF   x5F,F
1134C:  BNZ   11352
1134E:  MOVF   x60,F
11350:  BZ    113E4
....................       blank = NO2_array[0]; 
11352:  MOVFF  35E,918
11356:  MOVFF  35D,917
1135A:  MOVLB  0
1135C:  CALL   C91E
11360:  MOVFF  03,8C6
11364:  MOVFF  02,8C5
11368:  MOVFF  01,8C4
1136C:  MOVFF  00,8C3
....................       react = NO2_array[1]; 
11370:  MOVFF  360,918
11374:  MOVFF  35F,917
11378:  CALL   C91E
1137C:  MOVFF  03,8CA
11380:  MOVFF  02,8C9
11384:  MOVFF  01,8C8
11388:  MOVFF  00,8C7
....................       ratio = blank / react; 
1138C:  MOVFF  8C6,8FE
11390:  MOVFF  8C5,8FD
11394:  MOVFF  8C4,8FC
11398:  MOVFF  8C3,8FB
1139C:  MOVFF  8CA,902
113A0:  MOVFF  8C9,901
113A4:  MOVFF  8C8,900
113A8:  MOVFF  8C7,8FF
113AC:  CALL   C954
113B0:  MOVFF  03,8CE
113B4:  MOVFF  02,8CD
113B8:  MOVFF  01,8CC
113BC:  MOVFF  00,8CB
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
113C0:  MOVFF  8CE,8D2
113C4:  MOVFF  8CD,8D1
113C8:  MOVFF  8CC,8D0
113CC:  MOVFF  8CB,8CF
113D0:  RCALL  10BF8
113D2:  MOVFF  03,3B8
113D6:  MOVFF  02,3B7
113DA:  MOVFF  01,3B6
113DE:  MOVFF  00,3B5
113E2:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
113E4:  MOVF   x61,F
113E6:  BNZ   113EC
113E8:  MOVF   x62,F
113EA:  BZ    11488
113EC:  MOVF   x63,F
113EE:  BNZ   113F4
113F0:  MOVF   x64,F
113F2:  BZ    11488
....................       blank = NO2_array[2]; 
113F4:  MOVFF  362,918
113F8:  MOVFF  361,917
113FC:  MOVLB  0
113FE:  CALL   C91E
11402:  MOVFF  03,8C6
11406:  MOVFF  02,8C5
1140A:  MOVFF  01,8C4
1140E:  MOVFF  00,8C3
....................       react = NO2_array[3]; 
11412:  MOVFF  364,918
11416:  MOVFF  363,917
1141A:  CALL   C91E
1141E:  MOVFF  03,8CA
11422:  MOVFF  02,8C9
11426:  MOVFF  01,8C8
1142A:  MOVFF  00,8C7
....................       ratio = blank / react;    
1142E:  MOVFF  8C6,8FE
11432:  MOVFF  8C5,8FD
11436:  MOVFF  8C4,8FC
1143A:  MOVFF  8C3,8FB
1143E:  MOVFF  8CA,902
11442:  MOVFF  8C9,901
11446:  MOVFF  8C8,900
1144A:  MOVFF  8C7,8FF
1144E:  CALL   C954
11452:  MOVFF  03,8CE
11456:  MOVFF  02,8CD
1145A:  MOVFF  01,8CC
1145E:  MOVFF  00,8CB
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
11462:  MOVFF  8CE,8D2
11466:  MOVFF  8CD,8D1
1146A:  MOVFF  8CC,8D0
1146E:  MOVFF  8CB,8CF
11472:  CALL   10BF8
11476:  MOVFF  03,3BC
1147A:  MOVFF  02,3BB
1147E:  MOVFF  01,3BA
11482:  MOVFF  00,3B9
11486:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
11488:  MOVF   x65,F
1148A:  BNZ   11490
1148C:  MOVF   x66,F
1148E:  BZ    1152C
11490:  MOVF   x67,F
11492:  BNZ   11498
11494:  MOVF   x68,F
11496:  BZ    1152C
....................       blank = NO2_array[4]; 
11498:  MOVFF  366,918
1149C:  MOVFF  365,917
114A0:  MOVLB  0
114A2:  CALL   C91E
114A6:  MOVFF  03,8C6
114AA:  MOVFF  02,8C5
114AE:  MOVFF  01,8C4
114B2:  MOVFF  00,8C3
....................       react = NO2_array[5]; 
114B6:  MOVFF  368,918
114BA:  MOVFF  367,917
114BE:  CALL   C91E
114C2:  MOVFF  03,8CA
114C6:  MOVFF  02,8C9
114CA:  MOVFF  01,8C8
114CE:  MOVFF  00,8C7
....................       ratio = blank / react; 
114D2:  MOVFF  8C6,8FE
114D6:  MOVFF  8C5,8FD
114DA:  MOVFF  8C4,8FC
114DE:  MOVFF  8C3,8FB
114E2:  MOVFF  8CA,902
114E6:  MOVFF  8C9,901
114EA:  MOVFF  8C8,900
114EE:  MOVFF  8C7,8FF
114F2:  CALL   C954
114F6:  MOVFF  03,8CE
114FA:  MOVFF  02,8CD
114FE:  MOVFF  01,8CC
11502:  MOVFF  00,8CB
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
11506:  MOVFF  8CE,8D2
1150A:  MOVFF  8CD,8D1
1150E:  MOVFF  8CC,8D0
11512:  MOVFF  8CB,8CF
11516:  CALL   10BF8
1151A:  MOVFF  03,3C0
1151E:  MOVFF  02,3BF
11522:  MOVFF  01,3BE
11526:  MOVFF  00,3BD
1152A:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
1152C:  MOVF   x69,F
1152E:  BNZ   11534
11530:  MOVF   x6A,F
11532:  BZ    115D0
11534:  MOVF   x6B,F
11536:  BNZ   1153C
11538:  MOVF   x6C,F
1153A:  BZ    115D0
....................       blank = NO2_array[6]; 
1153C:  MOVFF  36A,918
11540:  MOVFF  369,917
11544:  MOVLB  0
11546:  CALL   C91E
1154A:  MOVFF  03,8C6
1154E:  MOVFF  02,8C5
11552:  MOVFF  01,8C4
11556:  MOVFF  00,8C3
....................       react = NO2_array[7]; 
1155A:  MOVFF  36C,918
1155E:  MOVFF  36B,917
11562:  CALL   C91E
11566:  MOVFF  03,8CA
1156A:  MOVFF  02,8C9
1156E:  MOVFF  01,8C8
11572:  MOVFF  00,8C7
....................       ratio = blank / react; 
11576:  MOVFF  8C6,8FE
1157A:  MOVFF  8C5,8FD
1157E:  MOVFF  8C4,8FC
11582:  MOVFF  8C3,8FB
11586:  MOVFF  8CA,902
1158A:  MOVFF  8C9,901
1158E:  MOVFF  8C8,900
11592:  MOVFF  8C7,8FF
11596:  CALL   C954
1159A:  MOVFF  03,8CE
1159E:  MOVFF  02,8CD
115A2:  MOVFF  01,8CC
115A6:  MOVFF  00,8CB
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
115AA:  MOVFF  8CE,8D2
115AE:  MOVFF  8CD,8D1
115B2:  MOVFF  8CC,8D0
115B6:  MOVFF  8CB,8CF
115BA:  CALL   10BF8
115BE:  MOVFF  03,3C4
115C2:  MOVFF  02,3C3
115C6:  MOVFF  01,3C2
115CA:  MOVFF  00,3C1
115CE:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
115D0:  MOVLW  04
115D2:  MOVWF  1E
115D4:  MOVLW  25
115D6:  MOVWF  1D
115D8:  MOVLW  3A
115DA:  MOVWF  FF6
115DC:  MOVLW  1E
115DE:  MOVWF  FF7
115E0:  MOVLW  00
115E2:  MOVWF  FF8
115E4:  MOVLW  06
115E6:  MOVLB  8
115E8:  MOVWF  xEB
115EA:  MOVLB  0
115EC:  CALL   AAF4
115F0:  MOVLW  10
115F2:  MOVWF  FE9
115F4:  MOVFF  35E,8F7
115F8:  MOVFF  35D,8F6
115FC:  CALL   AB26
11600:  MOVLW  43
11602:  MOVWF  FF6
11604:  MOVLW  1E
11606:  MOVWF  FF7
11608:  MOVLW  00
1160A:  MOVWF  FF8
1160C:  MOVLW  07
1160E:  MOVLB  8
11610:  MOVWF  xEB
11612:  MOVLB  0
11614:  CALL   AAF4
11618:  MOVLW  10
1161A:  MOVWF  FE9
1161C:  MOVFF  360,8F7
11620:  MOVFF  35F,8F6
11624:  CALL   AB26
11628:  MOVLW  4D
1162A:  MOVWF  FF6
1162C:  MOVLW  1E
1162E:  MOVWF  FF7
11630:  MOVLW  00
11632:  MOVWF  FF8
11634:  MOVLW  09
11636:  MOVLB  8
11638:  MOVWF  xEB
1163A:  MOVLB  0
1163C:  CALL   AAF4
11640:  MOVLW  89
11642:  MOVWF  FE9
11644:  MOVFF  3B8,8D2
11648:  MOVFF  3B7,8D1
1164C:  MOVFF  3B6,8D0
11650:  MOVFF  3B5,8CF
11654:  MOVLW  04
11656:  MOVLB  8
11658:  MOVWF  xD3
1165A:  MOVLB  0
1165C:  CALL   10C64
11660:  MOVLW  5B
11662:  MOVWF  FF6
11664:  MOVLW  1E
11666:  MOVWF  FF7
11668:  MOVLW  00
1166A:  MOVWF  FF8
1166C:  MOVLW  07
1166E:  MOVLB  8
11670:  MOVWF  xEB
11672:  MOVLB  0
11674:  CALL   AAF4
11678:  MOVLW  10
1167A:  MOVWF  FE9
1167C:  MOVFF  362,8F7
11680:  MOVFF  361,8F6
11684:  CALL   AB26
11688:  MOVLW  65
1168A:  MOVWF  FF6
1168C:  MOVLW  1E
1168E:  MOVWF  FF7
11690:  MOVLW  00
11692:  MOVWF  FF8
11694:  MOVLW  07
11696:  MOVLB  8
11698:  MOVWF  xEB
1169A:  MOVLB  0
1169C:  CALL   AAF4
116A0:  MOVLW  10
116A2:  MOVWF  FE9
116A4:  MOVFF  364,8F7
116A8:  MOVFF  363,8F6
116AC:  CALL   AB26
116B0:  MOVLW  6F
116B2:  MOVWF  FF6
116B4:  MOVLW  1E
116B6:  MOVWF  FF7
116B8:  MOVLW  00
116BA:  MOVWF  FF8
116BC:  MOVLW  09
116BE:  MOVLB  8
116C0:  MOVWF  xEB
116C2:  MOVLB  0
116C4:  CALL   AAF4
116C8:  MOVLW  89
116CA:  MOVWF  FE9
116CC:  MOVFF  3BC,8D2
116D0:  MOVFF  3BB,8D1
116D4:  MOVFF  3BA,8D0
116D8:  MOVFF  3B9,8CF
116DC:  MOVLW  04
116DE:  MOVLB  8
116E0:  MOVWF  xD3
116E2:  MOVLB  0
116E4:  CALL   10C64
116E8:  MOVLW  7D
116EA:  MOVWF  FF6
116EC:  MOVLW  1E
116EE:  MOVWF  FF7
116F0:  MOVLW  00
116F2:  MOVWF  FF8
116F4:  MOVLW  07
116F6:  MOVLB  8
116F8:  MOVWF  xEB
116FA:  MOVLB  0
116FC:  CALL   AAF4
11700:  MOVLW  10
11702:  MOVWF  FE9
11704:  MOVFF  366,8F7
11708:  MOVFF  365,8F6
1170C:  CALL   AB26
11710:  MOVLW  87
11712:  MOVWF  FF6
11714:  MOVLW  1E
11716:  MOVWF  FF7
11718:  MOVLW  00
1171A:  MOVWF  FF8
1171C:  MOVLW  07
1171E:  MOVLB  8
11720:  MOVWF  xEB
11722:  MOVLB  0
11724:  CALL   AAF4
11728:  MOVLW  10
1172A:  MOVWF  FE9
1172C:  MOVFF  368,8F7
11730:  MOVFF  367,8F6
11734:  CALL   AB26
11738:  MOVLW  91
1173A:  MOVWF  FF6
1173C:  MOVLW  1E
1173E:  MOVWF  FF7
11740:  MOVLW  00
11742:  MOVWF  FF8
11744:  MOVLW  09
11746:  MOVLB  8
11748:  MOVWF  xEB
1174A:  MOVLB  0
1174C:  CALL   AAF4
11750:  MOVLW  89
11752:  MOVWF  FE9
11754:  MOVFF  3C0,8D2
11758:  MOVFF  3BF,8D1
1175C:  MOVFF  3BE,8D0
11760:  MOVFF  3BD,8CF
11764:  MOVLW  04
11766:  MOVLB  8
11768:  MOVWF  xD3
1176A:  MOVLB  0
1176C:  CALL   10C64
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
11770:  MOVF   1F,W
11772:  SUBLW  02
11774:  BNZ   1177A
11776:  MOVF   20,F
11778:  BZ    117BA
1177A:  MOVLW  A0
1177C:  MOVWF  FF6
1177E:  MOVLW  1E
11780:  MOVWF  FF7
11782:  MOVLW  00
11784:  MOVWF  FF8
11786:  CLRF   1B
11788:  BTFSC  FF2.7
1178A:  BSF    1B.7
1178C:  BCF    FF2.7
1178E:  MOVLW  09
11790:  MOVLB  A
11792:  MOVWF  x40
11794:  MOVLB  0
11796:  CALL   1044
1179A:  BTFSC  1B.7
1179C:  BSF    FF2.7
1179E:  MOVLW  04
117A0:  MOVWF  FEA
117A2:  MOVLW  25
117A4:  MOVWF  FE9
117A6:  CALL   79BE
117AA:  MOVLW  0D
117AC:  BTFSS  F9E.4
117AE:  BRA    117AC
117B0:  MOVWF  FAD
117B2:  MOVLW  0A
117B4:  BTFSS  F9E.4
117B6:  BRA    117B4
117B8:  MOVWF  FAD
117BA:  GOTO   1261E (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
117BE:  MOVLB  8
117C0:  CLRF   xC2
117C2:  MOVF   xC2,W
117C4:  SUBLW  03
117C6:  BNC   117E6
117C8:  MOVF   xC2,W
117CA:  MULLW  04
117CC:  MOVF   FF3,W
117CE:  CLRF   03
117D0:  ADDLW  C5
117D2:  MOVWF  FE9
117D4:  MOVLW  03
117D6:  ADDWFC 03,W
117D8:  MOVWF  FEA
117DA:  CLRF   FEF
117DC:  CLRF   FEC
117DE:  CLRF   FEC
117E0:  CLRF   FEC
117E2:  INCF   xC2,F
117E4:  BRA    117C2
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
117E6:  MOVLB  3
117E8:  MOVF   x6F,F
117EA:  BTFSS  FD8.2
117EC:  BRA    117F2
117EE:  MOVF   x70,F
117F0:  BZ    1188E
117F2:  MOVF   x71,F
117F4:  BNZ   117FA
117F6:  MOVF   x72,F
117F8:  BZ    1188E
....................       blank = PO4_array[0]; 
117FA:  MOVFF  370,918
117FE:  MOVFF  36F,917
11802:  MOVLB  0
11804:  CALL   C91E
11808:  MOVFF  03,8C6
1180C:  MOVFF  02,8C5
11810:  MOVFF  01,8C4
11814:  MOVFF  00,8C3
....................       react = PO4_array[1]; 
11818:  MOVFF  372,918
1181C:  MOVFF  371,917
11820:  CALL   C91E
11824:  MOVFF  03,8CA
11828:  MOVFF  02,8C9
1182C:  MOVFF  01,8C8
11830:  MOVFF  00,8C7
....................       ratio = blank / react; 
11834:  MOVFF  8C6,8FE
11838:  MOVFF  8C5,8FD
1183C:  MOVFF  8C4,8FC
11840:  MOVFF  8C3,8FB
11844:  MOVFF  8CA,902
11848:  MOVFF  8C9,901
1184C:  MOVFF  8C8,900
11850:  MOVFF  8C7,8FF
11854:  CALL   C954
11858:  MOVFF  03,8CE
1185C:  MOVFF  02,8CD
11860:  MOVFF  01,8CC
11864:  MOVFF  00,8CB
....................       PO4_abs_array[0] = log10(ratio); 
11868:  MOVFF  8CE,8D2
1186C:  MOVFF  8CD,8D1
11870:  MOVFF  8CC,8D0
11874:  MOVFF  8CB,8CF
11878:  CALL   10BF8
1187C:  MOVFF  03,3C8
11880:  MOVFF  02,3C7
11884:  MOVFF  01,3C6
11888:  MOVFF  00,3C5
1188C:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
1188E:  MOVF   x73,F
11890:  BNZ   11896
11892:  MOVF   x74,F
11894:  BZ    11932
11896:  MOVF   x75,F
11898:  BNZ   1189E
1189A:  MOVF   x76,F
1189C:  BZ    11932
....................       blank = PO4_array[2]; 
1189E:  MOVFF  374,918
118A2:  MOVFF  373,917
118A6:  MOVLB  0
118A8:  CALL   C91E
118AC:  MOVFF  03,8C6
118B0:  MOVFF  02,8C5
118B4:  MOVFF  01,8C4
118B8:  MOVFF  00,8C3
....................       react = PO4_array[3]; 
118BC:  MOVFF  376,918
118C0:  MOVFF  375,917
118C4:  CALL   C91E
118C8:  MOVFF  03,8CA
118CC:  MOVFF  02,8C9
118D0:  MOVFF  01,8C8
118D4:  MOVFF  00,8C7
....................       ratio = blank / react;    
118D8:  MOVFF  8C6,8FE
118DC:  MOVFF  8C5,8FD
118E0:  MOVFF  8C4,8FC
118E4:  MOVFF  8C3,8FB
118E8:  MOVFF  8CA,902
118EC:  MOVFF  8C9,901
118F0:  MOVFF  8C8,900
118F4:  MOVFF  8C7,8FF
118F8:  CALL   C954
118FC:  MOVFF  03,8CE
11900:  MOVFF  02,8CD
11904:  MOVFF  01,8CC
11908:  MOVFF  00,8CB
....................       PO4_abs_array[1] = log10(ratio); 
1190C:  MOVFF  8CE,8D2
11910:  MOVFF  8CD,8D1
11914:  MOVFF  8CC,8D0
11918:  MOVFF  8CB,8CF
1191C:  CALL   10BF8
11920:  MOVFF  03,3CC
11924:  MOVFF  02,3CB
11928:  MOVFF  01,3CA
1192C:  MOVFF  00,3C9
11930:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
11932:  MOVF   x77,F
11934:  BNZ   1193A
11936:  MOVF   x78,F
11938:  BZ    119D6
1193A:  MOVF   x79,F
1193C:  BNZ   11942
1193E:  MOVF   x7A,F
11940:  BZ    119D6
....................       blank = PO4_array[4]; 
11942:  MOVFF  378,918
11946:  MOVFF  377,917
1194A:  MOVLB  0
1194C:  CALL   C91E
11950:  MOVFF  03,8C6
11954:  MOVFF  02,8C5
11958:  MOVFF  01,8C4
1195C:  MOVFF  00,8C3
....................       react = PO4_array[5]; 
11960:  MOVFF  37A,918
11964:  MOVFF  379,917
11968:  CALL   C91E
1196C:  MOVFF  03,8CA
11970:  MOVFF  02,8C9
11974:  MOVFF  01,8C8
11978:  MOVFF  00,8C7
....................       ratio = blank / react; 
1197C:  MOVFF  8C6,8FE
11980:  MOVFF  8C5,8FD
11984:  MOVFF  8C4,8FC
11988:  MOVFF  8C3,8FB
1198C:  MOVFF  8CA,902
11990:  MOVFF  8C9,901
11994:  MOVFF  8C8,900
11998:  MOVFF  8C7,8FF
1199C:  CALL   C954
119A0:  MOVFF  03,8CE
119A4:  MOVFF  02,8CD
119A8:  MOVFF  01,8CC
119AC:  MOVFF  00,8CB
....................       PO4_abs_array[2] = log10(ratio); 
119B0:  MOVFF  8CE,8D2
119B4:  MOVFF  8CD,8D1
119B8:  MOVFF  8CC,8D0
119BC:  MOVFF  8CB,8CF
119C0:  CALL   10BF8
119C4:  MOVFF  03,3D0
119C8:  MOVFF  02,3CF
119CC:  MOVFF  01,3CE
119D0:  MOVFF  00,3CD
119D4:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
119D6:  MOVF   x7B,F
119D8:  BNZ   119DE
119DA:  MOVF   x7C,F
119DC:  BZ    11A7A
119DE:  MOVF   x7D,F
119E0:  BNZ   119E6
119E2:  MOVF   x7E,F
119E4:  BZ    11A7A
....................       blank = PO4_array[6]; 
119E6:  MOVFF  37C,918
119EA:  MOVFF  37B,917
119EE:  MOVLB  0
119F0:  CALL   C91E
119F4:  MOVFF  03,8C6
119F8:  MOVFF  02,8C5
119FC:  MOVFF  01,8C4
11A00:  MOVFF  00,8C3
....................       react = PO4_array[7]; 
11A04:  MOVFF  37E,918
11A08:  MOVFF  37D,917
11A0C:  CALL   C91E
11A10:  MOVFF  03,8CA
11A14:  MOVFF  02,8C9
11A18:  MOVFF  01,8C8
11A1C:  MOVFF  00,8C7
....................       ratio = blank / react; 
11A20:  MOVFF  8C6,8FE
11A24:  MOVFF  8C5,8FD
11A28:  MOVFF  8C4,8FC
11A2C:  MOVFF  8C3,8FB
11A30:  MOVFF  8CA,902
11A34:  MOVFF  8C9,901
11A38:  MOVFF  8C8,900
11A3C:  MOVFF  8C7,8FF
11A40:  CALL   C954
11A44:  MOVFF  03,8CE
11A48:  MOVFF  02,8CD
11A4C:  MOVFF  01,8CC
11A50:  MOVFF  00,8CB
....................       PO4_abs_array[3] = log10(ratio); 
11A54:  MOVFF  8CE,8D2
11A58:  MOVFF  8CD,8D1
11A5C:  MOVFF  8CC,8D0
11A60:  MOVFF  8CB,8CF
11A64:  CALL   10BF8
11A68:  MOVFF  03,3D4
11A6C:  MOVFF  02,3D3
11A70:  MOVFF  01,3D2
11A74:  MOVFF  00,3D1
11A78:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
11A7A:  MOVLW  04
11A7C:  MOVWF  1E
11A7E:  MOVLW  25
11A80:  MOVWF  1D
11A82:  MOVLW  AE
11A84:  MOVWF  FF6
11A86:  MOVLW  1E
11A88:  MOVWF  FF7
11A8A:  MOVLW  00
11A8C:  MOVWF  FF8
11A8E:  MOVLW  06
11A90:  MOVLB  8
11A92:  MOVWF  xEB
11A94:  MOVLB  0
11A96:  CALL   AAF4
11A9A:  MOVLW  10
11A9C:  MOVWF  FE9
11A9E:  MOVFF  370,8F7
11AA2:  MOVFF  36F,8F6
11AA6:  CALL   AB26
11AAA:  MOVLW  B7
11AAC:  MOVWF  FF6
11AAE:  MOVLW  1E
11AB0:  MOVWF  FF7
11AB2:  MOVLW  00
11AB4:  MOVWF  FF8
11AB6:  MOVLW  07
11AB8:  MOVLB  8
11ABA:  MOVWF  xEB
11ABC:  MOVLB  0
11ABE:  CALL   AAF4
11AC2:  MOVLW  10
11AC4:  MOVWF  FE9
11AC6:  MOVFF  372,8F7
11ACA:  MOVFF  371,8F6
11ACE:  CALL   AB26
11AD2:  MOVLW  C1
11AD4:  MOVWF  FF6
11AD6:  MOVLW  1E
11AD8:  MOVWF  FF7
11ADA:  MOVLW  00
11ADC:  MOVWF  FF8
11ADE:  MOVLW  09
11AE0:  MOVLB  8
11AE2:  MOVWF  xEB
11AE4:  MOVLB  0
11AE6:  CALL   AAF4
11AEA:  MOVLW  89
11AEC:  MOVWF  FE9
11AEE:  MOVFF  3C8,8D2
11AF2:  MOVFF  3C7,8D1
11AF6:  MOVFF  3C6,8D0
11AFA:  MOVFF  3C5,8CF
11AFE:  MOVLW  04
11B00:  MOVLB  8
11B02:  MOVWF  xD3
11B04:  MOVLB  0
11B06:  CALL   10C64
11B0A:  MOVLW  CF
11B0C:  MOVWF  FF6
11B0E:  MOVLW  1E
11B10:  MOVWF  FF7
11B12:  MOVLW  00
11B14:  MOVWF  FF8
11B16:  MOVLW  07
11B18:  MOVLB  8
11B1A:  MOVWF  xEB
11B1C:  MOVLB  0
11B1E:  CALL   AAF4
11B22:  MOVLW  10
11B24:  MOVWF  FE9
11B26:  MOVFF  374,8F7
11B2A:  MOVFF  373,8F6
11B2E:  CALL   AB26
11B32:  MOVLW  D9
11B34:  MOVWF  FF6
11B36:  MOVLW  1E
11B38:  MOVWF  FF7
11B3A:  MOVLW  00
11B3C:  MOVWF  FF8
11B3E:  MOVLW  07
11B40:  MOVLB  8
11B42:  MOVWF  xEB
11B44:  MOVLB  0
11B46:  CALL   AAF4
11B4A:  MOVLW  10
11B4C:  MOVWF  FE9
11B4E:  MOVFF  376,8F7
11B52:  MOVFF  375,8F6
11B56:  CALL   AB26
11B5A:  MOVLW  E3
11B5C:  MOVWF  FF6
11B5E:  MOVLW  1E
11B60:  MOVWF  FF7
11B62:  MOVLW  00
11B64:  MOVWF  FF8
11B66:  MOVLW  09
11B68:  MOVLB  8
11B6A:  MOVWF  xEB
11B6C:  MOVLB  0
11B6E:  CALL   AAF4
11B72:  MOVLW  89
11B74:  MOVWF  FE9
11B76:  MOVFF  3CC,8D2
11B7A:  MOVFF  3CB,8D1
11B7E:  MOVFF  3CA,8D0
11B82:  MOVFF  3C9,8CF
11B86:  MOVLW  04
11B88:  MOVLB  8
11B8A:  MOVWF  xD3
11B8C:  MOVLB  0
11B8E:  CALL   10C64
11B92:  MOVLW  F1
11B94:  MOVWF  FF6
11B96:  MOVLW  1E
11B98:  MOVWF  FF7
11B9A:  MOVLW  00
11B9C:  MOVWF  FF8
11B9E:  MOVLW  07
11BA0:  MOVLB  8
11BA2:  MOVWF  xEB
11BA4:  MOVLB  0
11BA6:  CALL   AAF4
11BAA:  MOVLW  10
11BAC:  MOVWF  FE9
11BAE:  MOVFF  378,8F7
11BB2:  MOVFF  377,8F6
11BB6:  CALL   AB26
11BBA:  MOVLW  FB
11BBC:  MOVWF  FF6
11BBE:  MOVLW  1E
11BC0:  MOVWF  FF7
11BC2:  MOVLW  00
11BC4:  MOVWF  FF8
11BC6:  MOVLW  07
11BC8:  MOVLB  8
11BCA:  MOVWF  xEB
11BCC:  MOVLB  0
11BCE:  CALL   AAF4
11BD2:  MOVLW  10
11BD4:  MOVWF  FE9
11BD6:  MOVFF  37A,8F7
11BDA:  MOVFF  379,8F6
11BDE:  CALL   AB26
11BE2:  MOVLW  05
11BE4:  MOVWF  FF6
11BE6:  MOVLW  1F
11BE8:  MOVWF  FF7
11BEA:  MOVLW  00
11BEC:  MOVWF  FF8
11BEE:  MOVLW  09
11BF0:  MOVLB  8
11BF2:  MOVWF  xEB
11BF4:  MOVLB  0
11BF6:  CALL   AAF4
11BFA:  MOVLW  89
11BFC:  MOVWF  FE9
11BFE:  MOVFF  3D0,8D2
11C02:  MOVFF  3CF,8D1
11C06:  MOVFF  3CE,8D0
11C0A:  MOVFF  3CD,8CF
11C0E:  MOVLW  04
11C10:  MOVLB  8
11C12:  MOVWF  xD3
11C14:  MOVLB  0
11C16:  CALL   10C64
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
11C1A:  MOVF   1F,W
11C1C:  SUBLW  02
11C1E:  BNZ   11C24
11C20:  MOVF   20,F
11C22:  BZ    11C64
11C24:  MOVLW  14
11C26:  MOVWF  FF6
11C28:  MOVLW  1F
11C2A:  MOVWF  FF7
11C2C:  MOVLW  00
11C2E:  MOVWF  FF8
11C30:  CLRF   1B
11C32:  BTFSC  FF2.7
11C34:  BSF    1B.7
11C36:  BCF    FF2.7
11C38:  MOVLW  09
11C3A:  MOVLB  A
11C3C:  MOVWF  x40
11C3E:  MOVLB  0
11C40:  CALL   1044
11C44:  BTFSC  1B.7
11C46:  BSF    FF2.7
11C48:  MOVLW  04
11C4A:  MOVWF  FEA
11C4C:  MOVLW  25
11C4E:  MOVWF  FE9
11C50:  CALL   79BE
11C54:  MOVLW  0D
11C56:  BTFSS  F9E.4
11C58:  BRA    11C56
11C5A:  MOVWF  FAD
11C5C:  MOVLW  0A
11C5E:  BTFSS  F9E.4
11C60:  BRA    11C5E
11C62:  MOVWF  FAD
11C64:  GOTO   1261E (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
11C68:  MOVLB  8
11C6A:  CLRF   xC2
11C6C:  MOVF   xC2,W
11C6E:  SUBLW  03
11C70:  BNC   11C90
11C72:  MOVF   xC2,W
11C74:  MULLW  04
11C76:  MOVF   FF3,W
11C78:  CLRF   03
11C7A:  ADDLW  D5
11C7C:  MOVWF  FE9
11C7E:  MOVLW  03
11C80:  ADDWFC 03,W
11C82:  MOVWF  FEA
11C84:  CLRF   FEF
11C86:  CLRF   FEC
11C88:  CLRF   FEC
11C8A:  CLRF   FEC
11C8C:  INCF   xC2,F
11C8E:  BRA    11C6C
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
11C90:  MOVLB  3
11C92:  MOVF   x81,F
11C94:  BTFSS  FD8.2
11C96:  BRA    11C9C
11C98:  MOVF   x82,F
11C9A:  BZ    11D38
11C9C:  MOVF   x83,F
11C9E:  BNZ   11CA4
11CA0:  MOVF   x84,F
11CA2:  BZ    11D38
....................       blank = NH4_array[0]; 
11CA4:  MOVFF  382,918
11CA8:  MOVFF  381,917
11CAC:  MOVLB  0
11CAE:  CALL   C91E
11CB2:  MOVFF  03,8C6
11CB6:  MOVFF  02,8C5
11CBA:  MOVFF  01,8C4
11CBE:  MOVFF  00,8C3
....................       react = NH4_array[1]; 
11CC2:  MOVFF  384,918
11CC6:  MOVFF  383,917
11CCA:  CALL   C91E
11CCE:  MOVFF  03,8CA
11CD2:  MOVFF  02,8C9
11CD6:  MOVFF  01,8C8
11CDA:  MOVFF  00,8C7
....................       ratio = blank / react; 
11CDE:  MOVFF  8C6,8FE
11CE2:  MOVFF  8C5,8FD
11CE6:  MOVFF  8C4,8FC
11CEA:  MOVFF  8C3,8FB
11CEE:  MOVFF  8CA,902
11CF2:  MOVFF  8C9,901
11CF6:  MOVFF  8C8,900
11CFA:  MOVFF  8C7,8FF
11CFE:  CALL   C954
11D02:  MOVFF  03,8CE
11D06:  MOVFF  02,8CD
11D0A:  MOVFF  01,8CC
11D0E:  MOVFF  00,8CB
....................       NH4_abs_array[0] = log10(ratio); 
11D12:  MOVFF  8CE,8D2
11D16:  MOVFF  8CD,8D1
11D1A:  MOVFF  8CC,8D0
11D1E:  MOVFF  8CB,8CF
11D22:  CALL   10BF8
11D26:  MOVFF  03,3D8
11D2A:  MOVFF  02,3D7
11D2E:  MOVFF  01,3D6
11D32:  MOVFF  00,3D5
11D36:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
11D38:  MOVF   x85,F
11D3A:  BNZ   11D40
11D3C:  MOVF   x86,F
11D3E:  BZ    11DDC
11D40:  MOVF   x87,F
11D42:  BNZ   11D48
11D44:  MOVF   x88,F
11D46:  BZ    11DDC
....................       blank = NH4_array[2]; 
11D48:  MOVFF  386,918
11D4C:  MOVFF  385,917
11D50:  MOVLB  0
11D52:  CALL   C91E
11D56:  MOVFF  03,8C6
11D5A:  MOVFF  02,8C5
11D5E:  MOVFF  01,8C4
11D62:  MOVFF  00,8C3
....................       react = NH4_array[3]; 
11D66:  MOVFF  388,918
11D6A:  MOVFF  387,917
11D6E:  CALL   C91E
11D72:  MOVFF  03,8CA
11D76:  MOVFF  02,8C9
11D7A:  MOVFF  01,8C8
11D7E:  MOVFF  00,8C7
....................       ratio = blank / react;    
11D82:  MOVFF  8C6,8FE
11D86:  MOVFF  8C5,8FD
11D8A:  MOVFF  8C4,8FC
11D8E:  MOVFF  8C3,8FB
11D92:  MOVFF  8CA,902
11D96:  MOVFF  8C9,901
11D9A:  MOVFF  8C8,900
11D9E:  MOVFF  8C7,8FF
11DA2:  CALL   C954
11DA6:  MOVFF  03,8CE
11DAA:  MOVFF  02,8CD
11DAE:  MOVFF  01,8CC
11DB2:  MOVFF  00,8CB
....................       NH4_abs_array[1] = log10(ratio); 
11DB6:  MOVFF  8CE,8D2
11DBA:  MOVFF  8CD,8D1
11DBE:  MOVFF  8CC,8D0
11DC2:  MOVFF  8CB,8CF
11DC6:  CALL   10BF8
11DCA:  MOVFF  03,3DC
11DCE:  MOVFF  02,3DB
11DD2:  MOVFF  01,3DA
11DD6:  MOVFF  00,3D9
11DDA:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11DDC:  MOVF   x89,F
11DDE:  BNZ   11DE4
11DE0:  MOVF   x8A,F
11DE2:  BZ    11E80
11DE4:  MOVF   x8B,F
11DE6:  BNZ   11DEC
11DE8:  MOVF   x8C,F
11DEA:  BZ    11E80
....................       blank = NH4_array[4]; 
11DEC:  MOVFF  38A,918
11DF0:  MOVFF  389,917
11DF4:  MOVLB  0
11DF6:  CALL   C91E
11DFA:  MOVFF  03,8C6
11DFE:  MOVFF  02,8C5
11E02:  MOVFF  01,8C4
11E06:  MOVFF  00,8C3
....................       react = NH4_array[5]; 
11E0A:  MOVFF  38C,918
11E0E:  MOVFF  38B,917
11E12:  CALL   C91E
11E16:  MOVFF  03,8CA
11E1A:  MOVFF  02,8C9
11E1E:  MOVFF  01,8C8
11E22:  MOVFF  00,8C7
....................       ratio = blank / react; 
11E26:  MOVFF  8C6,8FE
11E2A:  MOVFF  8C5,8FD
11E2E:  MOVFF  8C4,8FC
11E32:  MOVFF  8C3,8FB
11E36:  MOVFF  8CA,902
11E3A:  MOVFF  8C9,901
11E3E:  MOVFF  8C8,900
11E42:  MOVFF  8C7,8FF
11E46:  CALL   C954
11E4A:  MOVFF  03,8CE
11E4E:  MOVFF  02,8CD
11E52:  MOVFF  01,8CC
11E56:  MOVFF  00,8CB
....................       NH4_abs_array[2] = log10(ratio); 
11E5A:  MOVFF  8CE,8D2
11E5E:  MOVFF  8CD,8D1
11E62:  MOVFF  8CC,8D0
11E66:  MOVFF  8CB,8CF
11E6A:  CALL   10BF8
11E6E:  MOVFF  03,3E0
11E72:  MOVFF  02,3DF
11E76:  MOVFF  01,3DE
11E7A:  MOVFF  00,3DD
11E7E:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11E80:  MOVF   x8D,F
11E82:  BNZ   11E88
11E84:  MOVF   x8E,F
11E86:  BZ    11F24
11E88:  MOVF   x8F,F
11E8A:  BNZ   11E90
11E8C:  MOVF   x90,F
11E8E:  BZ    11F24
....................       blank = NH4_array[6]; 
11E90:  MOVFF  38E,918
11E94:  MOVFF  38D,917
11E98:  MOVLB  0
11E9A:  CALL   C91E
11E9E:  MOVFF  03,8C6
11EA2:  MOVFF  02,8C5
11EA6:  MOVFF  01,8C4
11EAA:  MOVFF  00,8C3
....................       react = NH4_array[7]; 
11EAE:  MOVFF  390,918
11EB2:  MOVFF  38F,917
11EB6:  CALL   C91E
11EBA:  MOVFF  03,8CA
11EBE:  MOVFF  02,8C9
11EC2:  MOVFF  01,8C8
11EC6:  MOVFF  00,8C7
....................       ratio = blank / react; 
11ECA:  MOVFF  8C6,8FE
11ECE:  MOVFF  8C5,8FD
11ED2:  MOVFF  8C4,8FC
11ED6:  MOVFF  8C3,8FB
11EDA:  MOVFF  8CA,902
11EDE:  MOVFF  8C9,901
11EE2:  MOVFF  8C8,900
11EE6:  MOVFF  8C7,8FF
11EEA:  CALL   C954
11EEE:  MOVFF  03,8CE
11EF2:  MOVFF  02,8CD
11EF6:  MOVFF  01,8CC
11EFA:  MOVFF  00,8CB
....................       NH4_abs_array[3] = log10(ratio); 
11EFE:  MOVFF  8CE,8D2
11F02:  MOVFF  8CD,8D1
11F06:  MOVFF  8CC,8D0
11F0A:  MOVFF  8CB,8CF
11F0E:  CALL   10BF8
11F12:  MOVFF  03,3E4
11F16:  MOVFF  02,3E3
11F1A:  MOVFF  01,3E2
11F1E:  MOVFF  00,3E1
11F22:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11F24:  MOVLW  04
11F26:  MOVWF  1E
11F28:  MOVLW  25
11F2A:  MOVWF  1D
11F2C:  MOVLW  22
11F2E:  MOVWF  FF6
11F30:  MOVLW  1F
11F32:  MOVWF  FF7
11F34:  MOVLW  00
11F36:  MOVWF  FF8
11F38:  MOVLW  06
11F3A:  MOVLB  8
11F3C:  MOVWF  xEB
11F3E:  MOVLB  0
11F40:  CALL   AAF4
11F44:  MOVLW  10
11F46:  MOVWF  FE9
11F48:  MOVFF  382,8F7
11F4C:  MOVFF  381,8F6
11F50:  CALL   AB26
11F54:  MOVLW  2B
11F56:  MOVWF  FF6
11F58:  MOVLW  1F
11F5A:  MOVWF  FF7
11F5C:  MOVLW  00
11F5E:  MOVWF  FF8
11F60:  MOVLW  07
11F62:  MOVLB  8
11F64:  MOVWF  xEB
11F66:  MOVLB  0
11F68:  CALL   AAF4
11F6C:  MOVLW  10
11F6E:  MOVWF  FE9
11F70:  MOVFF  384,8F7
11F74:  MOVFF  383,8F6
11F78:  CALL   AB26
11F7C:  MOVLW  35
11F7E:  MOVWF  FF6
11F80:  MOVLW  1F
11F82:  MOVWF  FF7
11F84:  MOVLW  00
11F86:  MOVWF  FF8
11F88:  MOVLW  09
11F8A:  MOVLB  8
11F8C:  MOVWF  xEB
11F8E:  MOVLB  0
11F90:  CALL   AAF4
11F94:  MOVLW  89
11F96:  MOVWF  FE9
11F98:  MOVFF  3D8,8D2
11F9C:  MOVFF  3D7,8D1
11FA0:  MOVFF  3D6,8D0
11FA4:  MOVFF  3D5,8CF
11FA8:  MOVLW  04
11FAA:  MOVLB  8
11FAC:  MOVWF  xD3
11FAE:  MOVLB  0
11FB0:  CALL   10C64
11FB4:  MOVLW  43
11FB6:  MOVWF  FF6
11FB8:  MOVLW  1F
11FBA:  MOVWF  FF7
11FBC:  MOVLW  00
11FBE:  MOVWF  FF8
11FC0:  MOVLW  07
11FC2:  MOVLB  8
11FC4:  MOVWF  xEB
11FC6:  MOVLB  0
11FC8:  CALL   AAF4
11FCC:  MOVLW  10
11FCE:  MOVWF  FE9
11FD0:  MOVFF  386,8F7
11FD4:  MOVFF  385,8F6
11FD8:  CALL   AB26
11FDC:  MOVLW  4D
11FDE:  MOVWF  FF6
11FE0:  MOVLW  1F
11FE2:  MOVWF  FF7
11FE4:  MOVLW  00
11FE6:  MOVWF  FF8
11FE8:  MOVLW  07
11FEA:  MOVLB  8
11FEC:  MOVWF  xEB
11FEE:  MOVLB  0
11FF0:  CALL   AAF4
11FF4:  MOVLW  10
11FF6:  MOVWF  FE9
11FF8:  MOVFF  388,8F7
11FFC:  MOVFF  387,8F6
12000:  CALL   AB26
12004:  MOVLW  57
12006:  MOVWF  FF6
12008:  MOVLW  1F
1200A:  MOVWF  FF7
1200C:  MOVLW  00
1200E:  MOVWF  FF8
12010:  MOVLW  09
12012:  MOVLB  8
12014:  MOVWF  xEB
12016:  MOVLB  0
12018:  CALL   AAF4
1201C:  MOVLW  89
1201E:  MOVWF  FE9
12020:  MOVFF  3DC,8D2
12024:  MOVFF  3DB,8D1
12028:  MOVFF  3DA,8D0
1202C:  MOVFF  3D9,8CF
12030:  MOVLW  04
12032:  MOVLB  8
12034:  MOVWF  xD3
12036:  MOVLB  0
12038:  CALL   10C64
1203C:  MOVLW  65
1203E:  MOVWF  FF6
12040:  MOVLW  1F
12042:  MOVWF  FF7
12044:  MOVLW  00
12046:  MOVWF  FF8
12048:  MOVLW  07
1204A:  MOVLB  8
1204C:  MOVWF  xEB
1204E:  MOVLB  0
12050:  CALL   AAF4
12054:  MOVLW  10
12056:  MOVWF  FE9
12058:  MOVFF  38A,8F7
1205C:  MOVFF  389,8F6
12060:  CALL   AB26
12064:  MOVLW  6F
12066:  MOVWF  FF6
12068:  MOVLW  1F
1206A:  MOVWF  FF7
1206C:  MOVLW  00
1206E:  MOVWF  FF8
12070:  MOVLW  07
12072:  MOVLB  8
12074:  MOVWF  xEB
12076:  MOVLB  0
12078:  CALL   AAF4
1207C:  MOVLW  10
1207E:  MOVWF  FE9
12080:  MOVFF  38C,8F7
12084:  MOVFF  38B,8F6
12088:  CALL   AB26
1208C:  MOVLW  79
1208E:  MOVWF  FF6
12090:  MOVLW  1F
12092:  MOVWF  FF7
12094:  MOVLW  00
12096:  MOVWF  FF8
12098:  MOVLW  09
1209A:  MOVLB  8
1209C:  MOVWF  xEB
1209E:  MOVLB  0
120A0:  CALL   AAF4
120A4:  MOVLW  89
120A6:  MOVWF  FE9
120A8:  MOVFF  3E0,8D2
120AC:  MOVFF  3DF,8D1
120B0:  MOVFF  3DE,8D0
120B4:  MOVFF  3DD,8CF
120B8:  MOVLW  04
120BA:  MOVLB  8
120BC:  MOVWF  xD3
120BE:  MOVLB  0
120C0:  CALL   10C64
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
120C4:  MOVF   1F,W
120C6:  SUBLW  02
120C8:  BNZ   120CE
120CA:  MOVF   20,F
120CC:  BZ    1210E
120CE:  MOVLW  88
120D0:  MOVWF  FF6
120D2:  MOVLW  1F
120D4:  MOVWF  FF7
120D6:  MOVLW  00
120D8:  MOVWF  FF8
120DA:  CLRF   1B
120DC:  BTFSC  FF2.7
120DE:  BSF    1B.7
120E0:  BCF    FF2.7
120E2:  MOVLW  09
120E4:  MOVLB  A
120E6:  MOVWF  x40
120E8:  MOVLB  0
120EA:  CALL   1044
120EE:  BTFSC  1B.7
120F0:  BSF    FF2.7
120F2:  MOVLW  04
120F4:  MOVWF  FEA
120F6:  MOVLW  25
120F8:  MOVWF  FE9
120FA:  CALL   79BE
120FE:  MOVLW  0D
12100:  BTFSS  F9E.4
12102:  BRA    12100
12104:  MOVWF  FAD
12106:  MOVLW  0A
12108:  BTFSS  F9E.4
1210A:  BRA    12108
1210C:  MOVWF  FAD
1210E:  GOTO   1261E (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
12112:  MOVLB  8
12114:  CLRF   xC2
12116:  MOVF   xC2,W
12118:  SUBLW  03
1211A:  BNC   1213A
1211C:  MOVF   xC2,W
1211E:  MULLW  04
12120:  MOVF   FF3,W
12122:  CLRF   03
12124:  ADDLW  E5
12126:  MOVWF  FE9
12128:  MOVLW  03
1212A:  ADDWFC 03,W
1212C:  MOVWF  FEA
1212E:  CLRF   FEF
12130:  CLRF   FEC
12132:  CLRF   FEC
12134:  CLRF   FEC
12136:  INCF   xC2,F
12138:  BRA    12116
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
1213A:  MOVLB  3
1213C:  MOVF   x93,F
1213E:  BTFSS  FD8.2
12140:  BRA    12146
12142:  MOVF   x94,F
12144:  BZ    121E2
12146:  MOVF   x95,F
12148:  BNZ   1214E
1214A:  MOVF   x96,F
1214C:  BZ    121E2
....................       blank = SiO_array[0]; 
1214E:  MOVFF  394,918
12152:  MOVFF  393,917
12156:  MOVLB  0
12158:  CALL   C91E
1215C:  MOVFF  03,8C6
12160:  MOVFF  02,8C5
12164:  MOVFF  01,8C4
12168:  MOVFF  00,8C3
....................       react = SiO_array[1]; 
1216C:  MOVFF  396,918
12170:  MOVFF  395,917
12174:  CALL   C91E
12178:  MOVFF  03,8CA
1217C:  MOVFF  02,8C9
12180:  MOVFF  01,8C8
12184:  MOVFF  00,8C7
....................       ratio = blank / react; 
12188:  MOVFF  8C6,8FE
1218C:  MOVFF  8C5,8FD
12190:  MOVFF  8C4,8FC
12194:  MOVFF  8C3,8FB
12198:  MOVFF  8CA,902
1219C:  MOVFF  8C9,901
121A0:  MOVFF  8C8,900
121A4:  MOVFF  8C7,8FF
121A8:  CALL   C954
121AC:  MOVFF  03,8CE
121B0:  MOVFF  02,8CD
121B4:  MOVFF  01,8CC
121B8:  MOVFF  00,8CB
....................       SiO_abs_array[0] = log10(ratio); 
121BC:  MOVFF  8CE,8D2
121C0:  MOVFF  8CD,8D1
121C4:  MOVFF  8CC,8D0
121C8:  MOVFF  8CB,8CF
121CC:  CALL   10BF8
121D0:  MOVFF  03,3E8
121D4:  MOVFF  02,3E7
121D8:  MOVFF  01,3E6
121DC:  MOVFF  00,3E5
121E0:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
121E2:  MOVF   x97,F
121E4:  BNZ   121EA
121E6:  MOVF   x98,F
121E8:  BZ    12286
121EA:  MOVF   x99,F
121EC:  BNZ   121F2
121EE:  MOVF   x9A,F
121F0:  BZ    12286
....................       blank = SiO_array[2]; 
121F2:  MOVFF  398,918
121F6:  MOVFF  397,917
121FA:  MOVLB  0
121FC:  CALL   C91E
12200:  MOVFF  03,8C6
12204:  MOVFF  02,8C5
12208:  MOVFF  01,8C4
1220C:  MOVFF  00,8C3
....................       react = SiO_array[3]; 
12210:  MOVFF  39A,918
12214:  MOVFF  399,917
12218:  CALL   C91E
1221C:  MOVFF  03,8CA
12220:  MOVFF  02,8C9
12224:  MOVFF  01,8C8
12228:  MOVFF  00,8C7
....................       ratio = blank / react;    
1222C:  MOVFF  8C6,8FE
12230:  MOVFF  8C5,8FD
12234:  MOVFF  8C4,8FC
12238:  MOVFF  8C3,8FB
1223C:  MOVFF  8CA,902
12240:  MOVFF  8C9,901
12244:  MOVFF  8C8,900
12248:  MOVFF  8C7,8FF
1224C:  CALL   C954
12250:  MOVFF  03,8CE
12254:  MOVFF  02,8CD
12258:  MOVFF  01,8CC
1225C:  MOVFF  00,8CB
....................       SiO_abs_array[1] = log10(ratio); 
12260:  MOVFF  8CE,8D2
12264:  MOVFF  8CD,8D1
12268:  MOVFF  8CC,8D0
1226C:  MOVFF  8CB,8CF
12270:  CALL   10BF8
12274:  MOVFF  03,3EC
12278:  MOVFF  02,3EB
1227C:  MOVFF  01,3EA
12280:  MOVFF  00,3E9
12284:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
12286:  MOVF   x9B,F
12288:  BNZ   1228E
1228A:  MOVF   x9C,F
1228C:  BZ    1232A
1228E:  MOVF   x9D,F
12290:  BNZ   12296
12292:  MOVF   x9E,F
12294:  BZ    1232A
....................       blank = SiO_array[4]; 
12296:  MOVFF  39C,918
1229A:  MOVFF  39B,917
1229E:  MOVLB  0
122A0:  CALL   C91E
122A4:  MOVFF  03,8C6
122A8:  MOVFF  02,8C5
122AC:  MOVFF  01,8C4
122B0:  MOVFF  00,8C3
....................       react = SiO_array[5]; 
122B4:  MOVFF  39E,918
122B8:  MOVFF  39D,917
122BC:  CALL   C91E
122C0:  MOVFF  03,8CA
122C4:  MOVFF  02,8C9
122C8:  MOVFF  01,8C8
122CC:  MOVFF  00,8C7
....................       ratio = blank / react; 
122D0:  MOVFF  8C6,8FE
122D4:  MOVFF  8C5,8FD
122D8:  MOVFF  8C4,8FC
122DC:  MOVFF  8C3,8FB
122E0:  MOVFF  8CA,902
122E4:  MOVFF  8C9,901
122E8:  MOVFF  8C8,900
122EC:  MOVFF  8C7,8FF
122F0:  CALL   C954
122F4:  MOVFF  03,8CE
122F8:  MOVFF  02,8CD
122FC:  MOVFF  01,8CC
12300:  MOVFF  00,8CB
....................       SiO_abs_array[2] = log10(ratio); 
12304:  MOVFF  8CE,8D2
12308:  MOVFF  8CD,8D1
1230C:  MOVFF  8CC,8D0
12310:  MOVFF  8CB,8CF
12314:  CALL   10BF8
12318:  MOVFF  03,3F0
1231C:  MOVFF  02,3EF
12320:  MOVFF  01,3EE
12324:  MOVFF  00,3ED
12328:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
1232A:  MOVF   x9F,F
1232C:  BNZ   12332
1232E:  MOVF   xA0,F
12330:  BZ    123CE
12332:  MOVF   xA1,F
12334:  BNZ   1233A
12336:  MOVF   xA2,F
12338:  BZ    123CE
....................       blank = SiO_array[6]; 
1233A:  MOVFF  3A0,918
1233E:  MOVFF  39F,917
12342:  MOVLB  0
12344:  CALL   C91E
12348:  MOVFF  03,8C6
1234C:  MOVFF  02,8C5
12350:  MOVFF  01,8C4
12354:  MOVFF  00,8C3
....................       react = SiO_array[7]; 
12358:  MOVFF  3A2,918
1235C:  MOVFF  3A1,917
12360:  CALL   C91E
12364:  MOVFF  03,8CA
12368:  MOVFF  02,8C9
1236C:  MOVFF  01,8C8
12370:  MOVFF  00,8C7
....................       ratio = blank / react; 
12374:  MOVFF  8C6,8FE
12378:  MOVFF  8C5,8FD
1237C:  MOVFF  8C4,8FC
12380:  MOVFF  8C3,8FB
12384:  MOVFF  8CA,902
12388:  MOVFF  8C9,901
1238C:  MOVFF  8C8,900
12390:  MOVFF  8C7,8FF
12394:  CALL   C954
12398:  MOVFF  03,8CE
1239C:  MOVFF  02,8CD
123A0:  MOVFF  01,8CC
123A4:  MOVFF  00,8CB
....................       SiO_abs_array[3] = log10(ratio); 
123A8:  MOVFF  8CE,8D2
123AC:  MOVFF  8CD,8D1
123B0:  MOVFF  8CC,8D0
123B4:  MOVFF  8CB,8CF
123B8:  CALL   10BF8
123BC:  MOVFF  03,3F4
123C0:  MOVFF  02,3F3
123C4:  MOVFF  01,3F2
123C8:  MOVFF  00,3F1
123CC:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
123CE:  MOVLW  04
123D0:  MOVWF  1E
123D2:  MOVLW  25
123D4:  MOVWF  1D
123D6:  MOVLW  96
123D8:  MOVWF  FF6
123DA:  MOVLW  1F
123DC:  MOVWF  FF7
123DE:  MOVLW  00
123E0:  MOVWF  FF8
123E2:  MOVLW  06
123E4:  MOVLB  8
123E6:  MOVWF  xEB
123E8:  MOVLB  0
123EA:  CALL   AAF4
123EE:  MOVLW  10
123F0:  MOVWF  FE9
123F2:  MOVFF  394,8F7
123F6:  MOVFF  393,8F6
123FA:  CALL   AB26
123FE:  MOVLW  9F
12400:  MOVWF  FF6
12402:  MOVLW  1F
12404:  MOVWF  FF7
12406:  MOVLW  00
12408:  MOVWF  FF8
1240A:  MOVLW  07
1240C:  MOVLB  8
1240E:  MOVWF  xEB
12410:  MOVLB  0
12412:  CALL   AAF4
12416:  MOVLW  10
12418:  MOVWF  FE9
1241A:  MOVFF  396,8F7
1241E:  MOVFF  395,8F6
12422:  CALL   AB26
12426:  MOVLW  A9
12428:  MOVWF  FF6
1242A:  MOVLW  1F
1242C:  MOVWF  FF7
1242E:  MOVLW  00
12430:  MOVWF  FF8
12432:  MOVLW  09
12434:  MOVLB  8
12436:  MOVWF  xEB
12438:  MOVLB  0
1243A:  CALL   AAF4
1243E:  MOVLW  89
12440:  MOVWF  FE9
12442:  MOVFF  3E8,8D2
12446:  MOVFF  3E7,8D1
1244A:  MOVFF  3E6,8D0
1244E:  MOVFF  3E5,8CF
12452:  MOVLW  04
12454:  MOVLB  8
12456:  MOVWF  xD3
12458:  MOVLB  0
1245A:  CALL   10C64
1245E:  MOVLW  B7
12460:  MOVWF  FF6
12462:  MOVLW  1F
12464:  MOVWF  FF7
12466:  MOVLW  00
12468:  MOVWF  FF8
1246A:  MOVLW  07
1246C:  MOVLB  8
1246E:  MOVWF  xEB
12470:  MOVLB  0
12472:  CALL   AAF4
12476:  MOVLW  10
12478:  MOVWF  FE9
1247A:  MOVFF  398,8F7
1247E:  MOVFF  397,8F6
12482:  CALL   AB26
12486:  MOVLW  C1
12488:  MOVWF  FF6
1248A:  MOVLW  1F
1248C:  MOVWF  FF7
1248E:  MOVLW  00
12490:  MOVWF  FF8
12492:  MOVLW  07
12494:  MOVLB  8
12496:  MOVWF  xEB
12498:  MOVLB  0
1249A:  CALL   AAF4
1249E:  MOVLW  10
124A0:  MOVWF  FE9
124A2:  MOVFF  39A,8F7
124A6:  MOVFF  399,8F6
124AA:  CALL   AB26
124AE:  MOVLW  CB
124B0:  MOVWF  FF6
124B2:  MOVLW  1F
124B4:  MOVWF  FF7
124B6:  MOVLW  00
124B8:  MOVWF  FF8
124BA:  MOVLW  09
124BC:  MOVLB  8
124BE:  MOVWF  xEB
124C0:  MOVLB  0
124C2:  CALL   AAF4
124C6:  MOVLW  89
124C8:  MOVWF  FE9
124CA:  MOVFF  3EC,8D2
124CE:  MOVFF  3EB,8D1
124D2:  MOVFF  3EA,8D0
124D6:  MOVFF  3E9,8CF
124DA:  MOVLW  04
124DC:  MOVLB  8
124DE:  MOVWF  xD3
124E0:  MOVLB  0
124E2:  CALL   10C64
124E6:  MOVLW  D9
124E8:  MOVWF  FF6
124EA:  MOVLW  1F
124EC:  MOVWF  FF7
124EE:  MOVLW  00
124F0:  MOVWF  FF8
124F2:  MOVLW  07
124F4:  MOVLB  8
124F6:  MOVWF  xEB
124F8:  MOVLB  0
124FA:  CALL   AAF4
124FE:  MOVLW  10
12500:  MOVWF  FE9
12502:  MOVFF  39C,8F7
12506:  MOVFF  39B,8F6
1250A:  CALL   AB26
1250E:  MOVLW  E3
12510:  MOVWF  FF6
12512:  MOVLW  1F
12514:  MOVWF  FF7
12516:  MOVLW  00
12518:  MOVWF  FF8
1251A:  MOVLW  07
1251C:  MOVLB  8
1251E:  MOVWF  xEB
12520:  MOVLB  0
12522:  CALL   AAF4
12526:  MOVLW  10
12528:  MOVWF  FE9
1252A:  MOVFF  39E,8F7
1252E:  MOVFF  39D,8F6
12532:  CALL   AB26
12536:  MOVLW  ED
12538:  MOVWF  FF6
1253A:  MOVLW  1F
1253C:  MOVWF  FF7
1253E:  MOVLW  00
12540:  MOVWF  FF8
12542:  MOVLW  09
12544:  MOVLB  8
12546:  MOVWF  xEB
12548:  MOVLB  0
1254A:  CALL   AAF4
1254E:  MOVLW  89
12550:  MOVWF  FE9
12552:  MOVFF  3F0,8D2
12556:  MOVFF  3EF,8D1
1255A:  MOVFF  3EE,8D0
1255E:  MOVFF  3ED,8CF
12562:  MOVLW  04
12564:  MOVLB  8
12566:  MOVWF  xD3
12568:  MOVLB  0
1256A:  CALL   10C64
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
1256E:  MOVF   1F,W
12570:  SUBLW  02
12572:  BNZ   12578
12574:  MOVF   20,F
12576:  BZ    125B8
12578:  MOVLW  FC
1257A:  MOVWF  FF6
1257C:  MOVLW  1F
1257E:  MOVWF  FF7
12580:  MOVLW  00
12582:  MOVWF  FF8
12584:  CLRF   1B
12586:  BTFSC  FF2.7
12588:  BSF    1B.7
1258A:  BCF    FF2.7
1258C:  MOVLW  09
1258E:  MOVLB  A
12590:  MOVWF  x40
12592:  MOVLB  0
12594:  CALL   1044
12598:  BTFSC  1B.7
1259A:  BSF    FF2.7
1259C:  MOVLW  04
1259E:  MOVWF  FEA
125A0:  MOVLW  25
125A2:  MOVWF  FE9
125A4:  CALL   79BE
125A8:  MOVLW  0D
125AA:  BTFSS  F9E.4
125AC:  BRA    125AA
125AE:  MOVWF  FAD
125B0:  MOVLW  0A
125B2:  BTFSS  F9E.4
125B4:  BRA    125B2
125B6:  MOVWF  FAD
125B8:  GOTO   1261E (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
125BC:  MOVLW  04
125BE:  MOVWF  FEA
125C0:  MOVLW  25
125C2:  MOVWF  FE9
125C4:  MOVLW  00
125C6:  CALL   056C
125CA:  TBLRD*-
125CC:  TBLRD*+
125CE:  MOVF   FF5,W
125D0:  MOVWF  FEE
125D2:  IORLW  00
125D4:  BNZ   125CC
....................     
....................    switch (chem){ 
125D6:  MOVLW  0A
125D8:  MOVWF  FF6
125DA:  MOVLW  20
125DC:  MOVWF  FF7
125DE:  MOVLW  00
125E0:  MOVWF  FF8
125E2:  MOVLW  03
125E4:  MOVWF  FEA
125E6:  MOVLW  3D
125E8:  MOVWF  FE9
125EA:  CALL   FE8A
125EE:  MOVF   01,W
125F0:  BZ    12604
125F2:  XORLW  01
125F4:  BZ    1260A
125F6:  XORLW  03
125F8:  BZ    12610
125FA:  XORLW  01
125FC:  BZ    12616
125FE:  XORLW  07
12600:  BZ    1261C
12602:  BRA    1261E
....................       case "NO3" : calc_abs_NO3(); 
12604:  GOTO   10E7A
....................          break; 
12608:  BRA    1261E
....................       case "NO2" : calc_abs_NO2 (); 
1260A:  GOTO   11316
....................          break;    
1260E:  BRA    1261E
....................       case "PO4" : calc_abs_PO4(); 
12610:  GOTO   117BE
....................          break; 
12614:  BRA    1261E
....................       case "NH4" : calc_abs_NH4(); 
12616:  GOTO   11C68
....................          break; 
1261A:  BRA    1261E
....................       case "SiO" : calc_abs_SiO(); 
1261C:  BRA    12112
....................          break; 
....................    } 
1261E:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
12620:  CALL   D550
....................     
....................    if (data_available == TRUE) { 
12624:  MOVLB  3
12626:  DECFSZ x3B,W
12628:  BRA    1272C
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
1262A:  MOVLB  8
1262C:  CLRF   xF9
1262E:  MOVLW  67
12630:  MOVWF  xF8
12632:  MOVLW  02
12634:  MOVWF  xFB
12636:  MOVLW  B7
12638:  MOVWF  xFA
1263A:  MOVLB  0
1263C:  CALL   5506
....................       strcat(data_buffer, comma); 
12640:  MOVLB  8
12642:  CLRF   xF9
12644:  MOVLW  67
12646:  MOVWF  xF8
12648:  MOVLW  03
1264A:  MOVWF  xFB
1264C:  MOVLW  39
1264E:  MOVWF  xFA
12650:  MOVLB  0
12652:  CALL   5506
....................       strcat(data_buffer, chem); 
12656:  MOVLB  8
12658:  CLRF   xF9
1265A:  MOVLW  67
1265C:  MOVWF  xF8
1265E:  MOVLW  03
12660:  MOVWF  xFB
12662:  MOVLW  3D
12664:  MOVWF  xFA
12666:  MOVLB  0
12668:  CALL   5506
....................       strcat(data_buffer, comma); 
1266C:  MOVLB  8
1266E:  CLRF   xF9
12670:  MOVLW  67
12672:  MOVWF  xF8
12674:  MOVLW  03
12676:  MOVWF  xFB
12678:  MOVLW  39
1267A:  MOVWF  xFA
1267C:  MOVLB  0
1267E:  CALL   5506
....................       strcat(data_buffer, abs_str); 
12682:  MOVLB  8
12684:  CLRF   xF9
12686:  MOVLW  67
12688:  MOVWF  xF8
1268A:  MOVLW  04
1268C:  MOVWF  xFB
1268E:  MOVLW  25
12690:  MOVWF  xFA
12692:  MOVLB  0
12694:  CALL   5506
....................       strcat(data_buffer, endofline); 
12698:  MOVLB  8
1269A:  CLRF   xF9
1269C:  MOVLW  67
1269E:  MOVWF  xF8
126A0:  MOVLW  07
126A2:  MOVWF  xFB
126A4:  MOVLW  CE
126A6:  MOVWF  xFA
126A8:  MOVLB  0
126AA:  CALL   5506
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
126AE:  MOVF   1F,W
126B0:  SUBLW  04
126B2:  BNZ   126D2
126B4:  MOVF   20,F
126B6:  BNZ   126D2
126B8:  CLRF   FEA
126BA:  MOVLW  67
126BC:  MOVWF  FE9
126BE:  CALL   79BE
126C2:  MOVLW  0D
126C4:  BTFSS  F9E.4
126C6:  BRA    126C4
126C8:  MOVWF  FAD
126CA:  MOVLW  0A
126CC:  BTFSS  F9E.4
126CE:  BRA    126CC
126D0:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
126D2:  MOVLB  2
126D4:  MOVF   xDC,F
126D6:  BNZ   1272A
....................        
....................          buffer_select = 0; 
126D8:  MOVLB  0
126DA:  CLRF   x66
....................           
....................          heartbeat(FALSE); 
126DC:  MOVLB  8
126DE:  CLRF   xED
126E0:  MOVLB  0
126E2:  CALL   55AE
....................             append_data(file_ptr_rel_all); 
126E6:  MOVLW  02
126E8:  MOVLB  8
126EA:  MOVWF  xEE
126EC:  MOVLW  F9
126EE:  MOVWF  xED
126F0:  MOVLB  0
126F2:  CALL   8320
....................          heartbeat(TRUE);          
126F6:  MOVLW  01
126F8:  MOVLB  8
126FA:  MOVWF  xED
126FC:  MOVLB  0
126FE:  CALL   55AE
....................           
....................          heartbeat(FALSE); 
12702:  MOVLB  8
12704:  CLRF   xED
12706:  MOVLB  0
12708:  CALL   55AE
....................             append_data(file_ptr_rel_new);    
1270C:  MOVLW  03
1270E:  MOVLB  8
12710:  MOVWF  xEE
12712:  MOVLW  07
12714:  MOVWF  xED
12716:  MOVLB  0
12718:  CALL   8320
....................          heartbeat(TRUE); 
1271C:  MOVLW  01
1271E:  MOVLB  8
12720:  MOVWF  xED
12722:  MOVLB  0
12724:  CALL   55AE
12728:  MOVLB  2
1272A:  MOVLB  3
....................       } 
....................    } 
1272C:  MOVLB  0
1272E:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D666:  MOVLW  2C
0D668:  MOVLB  8
0D66A:  MOVWF  x9E
0D66C:  CLRF   x9F
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D66E:  MOVLW  0D
0D670:  MOVWF  xA0
0D672:  MOVLW  0A
0D674:  MOVWF  xA1
0D676:  CLRF   xA2
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D678:  MOVLB  0
0D67A:  RCALL  D550
....................    time_stamp(); 
0D67C:  CALL   5442
....................    strcat(data_buffer, time_stmp_str); 
0D680:  MOVLB  8
0D682:  CLRF   xF9
0D684:  MOVLW  67
0D686:  MOVWF  xF8
0D688:  MOVLW  02
0D68A:  MOVWF  xFB
0D68C:  MOVLW  99
0D68E:  MOVWF  xFA
0D690:  MOVLB  0
0D692:  CALL   5506
....................    strcat(data_buffer, comma); 
0D696:  MOVLB  8
0D698:  CLRF   xF9
0D69A:  MOVLW  67
0D69C:  MOVWF  xF8
0D69E:  MOVLW  08
0D6A0:  MOVWF  xFB
0D6A2:  MOVLW  9E
0D6A4:  MOVWF  xFA
0D6A6:  MOVLB  0
0D6A8:  CALL   5506
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D6AC:  MOVLW  08
0D6AE:  MOVWF  1E
0D6B0:  MOVLW  A3
0D6B2:  MOVWF  1D
0D6B4:  MOVFF  89D,8ED
0D6B8:  MOVLW  1B
0D6BA:  MOVLB  8
0D6BC:  MOVWF  xEE
0D6BE:  MOVLB  0
0D6C0:  CALL   52A8
0D6C4:  MOVLW  2C
0D6C6:  MOVLB  8
0D6C8:  MOVWF  xFF
0D6CA:  MOVLB  0
0D6CC:  CALL   50C6
0D6D0:  MOVLW  10
0D6D2:  MOVWF  FE9
0D6D4:  MOVFF  2A,8F7
0D6D8:  MOVFF  29,8F6
0D6DC:  CALL   AB26
0D6E0:  MOVLW  2C
0D6E2:  MOVLB  8
0D6E4:  MOVWF  xFF
0D6E6:  MOVLB  0
0D6E8:  CALL   50C6
0D6EC:  MOVLW  10
0D6EE:  MOVWF  FE9
0D6F0:  MOVFF  24,8F7
0D6F4:  MOVFF  23,8F6
0D6F8:  CALL   AB26
0D6FC:  MOVLW  2C
0D6FE:  MOVLB  8
0D700:  MOVWF  xFF
0D702:  MOVLB  0
0D704:  CALL   50C6
0D708:  MOVLW  10
0D70A:  MOVWF  FE9
0D70C:  MOVFF  2C,8F7
0D710:  MOVFF  2B,8F6
0D714:  CALL   AB26
0D718:  MOVLW  2C
0D71A:  MOVLB  8
0D71C:  MOVWF  xFF
0D71E:  MOVLB  0
0D720:  CALL   50C6
0D724:  MOVLW  10
0D726:  MOVWF  FE9
0D728:  MOVFF  2E,8F7
0D72C:  MOVFF  2D,8F6
0D730:  CALL   AB26
0D734:  MOVLW  2C
0D736:  MOVLB  8
0D738:  MOVWF  xFF
0D73A:  MOVLB  0
0D73C:  CALL   50C6
0D740:  MOVLW  10
0D742:  MOVWF  FE9
0D744:  MOVFF  22,8F7
0D748:  MOVFF  21,8F6
0D74C:  CALL   AB26
0D750:  MOVLW  2C
0D752:  MOVLB  8
0D754:  MOVWF  xFF
0D756:  MOVLB  0
0D758:  CALL   50C6
0D75C:  MOVLW  10
0D75E:  MOVWF  FE9
0D760:  MOVFF  7C8,8F7
0D764:  MOVFF  7C7,8F6
0D768:  CALL   AB26
0D76C:  MOVLW  2C
0D76E:  MOVLB  8
0D770:  MOVWF  xFF
0D772:  MOVLB  0
0D774:  CALL   50C6
0D778:  MOVLW  10
0D77A:  MOVWF  FE9
0D77C:  MOVFF  7B6,8C2
0D780:  MOVFF  7B5,8C1
0D784:  BRA    D564
....................    strcat(data_buffer, config_str); 
0D786:  MOVLB  8
0D788:  CLRF   xF9
0D78A:  MOVLW  67
0D78C:  MOVWF  xF8
0D78E:  MOVLW  08
0D790:  MOVWF  xFB
0D792:  MOVLW  A3
0D794:  MOVWF  xFA
0D796:  MOVLB  0
0D798:  CALL   5506
....................    strcat(data_buffer, endofline); 
0D79C:  MOVLB  8
0D79E:  CLRF   xF9
0D7A0:  MOVLW  67
0D7A2:  MOVWF  xF8
0D7A4:  MOVLW  08
0D7A6:  MOVWF  xFB
0D7A8:  MOVLW  A0
0D7AA:  MOVWF  xFA
0D7AC:  MOVLB  0
0D7AE:  CALL   5506
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D7B2:  CLRF   FEA
0D7B4:  MOVLW  67
0D7B6:  MOVWF  FE9
0D7B8:  CALL   79BE
0D7BC:  MOVLW  0D
0D7BE:  BTFSS  F9E.4
0D7C0:  BRA    D7BE
0D7C2:  MOVWF  FAD
0D7C4:  MOVLW  0A
0D7C6:  BTFSS  F9E.4
0D7C8:  BRA    D7C6
0D7CA:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D7CC:  MOVLB  2
0D7CE:  MOVF   xDC,F
0D7D0:  BNZ   D824
....................     
....................       buffer_select = 0; 
0D7D2:  MOVLB  0
0D7D4:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
0D7D6:  MOVLB  8
0D7D8:  CLRF   xED
0D7DA:  MOVLB  0
0D7DC:  CALL   55AE
....................          append_data(file_ptr_raw_all); 
0D7E0:  MOVLW  02
0D7E2:  MOVLB  8
0D7E4:  MOVWF  xEE
0D7E6:  MOVLW  DD
0D7E8:  MOVWF  xED
0D7EA:  MOVLB  0
0D7EC:  CALL   8320
....................       heartbeat(TRUE);          
0D7F0:  MOVLW  01
0D7F2:  MOVLB  8
0D7F4:  MOVWF  xED
0D7F6:  MOVLB  0
0D7F8:  CALL   55AE
....................        
....................       heartbeat(FALSE); 
0D7FC:  MOVLB  8
0D7FE:  CLRF   xED
0D800:  MOVLB  0
0D802:  CALL   55AE
....................          append_data(file_ptr_raw_new);    
0D806:  MOVLW  02
0D808:  MOVLB  8
0D80A:  MOVWF  xEE
0D80C:  MOVLW  EB
0D80E:  MOVWF  xED
0D810:  MOVLB  0
0D812:  CALL   8320
....................       heartbeat(TRUE); 
0D816:  MOVLW  01
0D818:  MOVLB  8
0D81A:  MOVWF  xED
0D81C:  MOVLB  0
0D81E:  CALL   55AE
0D822:  MOVLB  2
....................    } 
0D824:  MOVLB  0
0D826:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
152BA:  MOVLW  2C
152BC:  MOVLB  8
152BE:  MOVWF  xA0
152C0:  CLRF   xA1
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
152C2:  MOVLW  0D
152C4:  MOVWF  xA2
152C6:  MOVLW  0A
152C8:  MOVWF  xA3
152CA:  CLRF   xA4
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
152CC:  MOVLB  0
152CE:  CALL   D550
....................    time_stamp(); 
152D2:  CALL   5442
....................    strcat(data_buffer, time_stmp_str); 
152D6:  MOVLB  8
152D8:  CLRF   xF9
152DA:  MOVLW  67
152DC:  MOVWF  xF8
152DE:  MOVLW  02
152E0:  MOVWF  xFB
152E2:  MOVLW  99
152E4:  MOVWF  xFA
152E6:  MOVLB  0
152E8:  CALL   5506
....................    strcat(data_buffer, comma); 
152EC:  MOVLB  8
152EE:  CLRF   xF9
152F0:  MOVLW  67
152F2:  MOVWF  xF8
152F4:  MOVLW  08
152F6:  MOVWF  xFB
152F8:  MOVLW  A0
152FA:  MOVWF  xFA
152FC:  MOVLB  0
152FE:  CALL   5506
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
15302:  MOVLW  08
15304:  MOVWF  1E
15306:  MOVLW  A5
15308:  MOVWF  1D
1530A:  MOVFF  89D,8ED
1530E:  MOVLW  1B
15310:  MOVLB  8
15312:  MOVWF  xEE
15314:  MOVLB  0
15316:  CALL   52A8
1531A:  MOVLW  2C
1531C:  MOVLB  8
1531E:  MOVWF  xFF
15320:  MOVLB  0
15322:  CALL   50C6
15326:  MOVLW  10
15328:  MOVWF  FE9
1532A:  MOVFF  89F,8F7
1532E:  MOVFF  89E,8F6
15332:  CALL   AB26
....................    strcat(data_buffer, config_str); 
15336:  MOVLB  8
15338:  CLRF   xF9
1533A:  MOVLW  67
1533C:  MOVWF  xF8
1533E:  MOVLW  08
15340:  MOVWF  xFB
15342:  MOVLW  A5
15344:  MOVWF  xFA
15346:  MOVLB  0
15348:  CALL   5506
....................    strcat(data_buffer, endofline); 
1534C:  MOVLB  8
1534E:  CLRF   xF9
15350:  MOVLW  67
15352:  MOVWF  xF8
15354:  MOVLW  08
15356:  MOVWF  xFB
15358:  MOVLW  A2
1535A:  MOVWF  xFA
1535C:  MOVLB  0
1535E:  CALL   5506
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
15362:  MOVF   1F,W
15364:  SUBLW  04
15366:  BNZ   15386
15368:  MOVF   20,F
1536A:  BNZ   15386
1536C:  CLRF   FEA
1536E:  MOVLW  67
15370:  MOVWF  FE9
15372:  CALL   79BE
15376:  MOVLW  0D
15378:  BTFSS  F9E.4
1537A:  BRA    15378
1537C:  MOVWF  FAD
1537E:  MOVLW  0A
15380:  BTFSS  F9E.4
15382:  BRA    15380
15384:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
15386:  MOVLB  2
15388:  MOVF   xDC,F
1538A:  BNZ   153DE
....................     
....................       buffer_select = 0; 
1538C:  MOVLB  0
1538E:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
15390:  MOVLB  8
15392:  CLRF   xED
15394:  MOVLB  0
15396:  CALL   55AE
....................          append_data(file_ptr_raw_all); 
1539A:  MOVLW  02
1539C:  MOVLB  8
1539E:  MOVWF  xEE
153A0:  MOVLW  DD
153A2:  MOVWF  xED
153A4:  MOVLB  0
153A6:  CALL   8320
....................       heartbeat(TRUE);          
153AA:  MOVLW  01
153AC:  MOVLB  8
153AE:  MOVWF  xED
153B0:  MOVLB  0
153B2:  CALL   55AE
....................        
....................       heartbeat(FALSE); 
153B6:  MOVLB  8
153B8:  CLRF   xED
153BA:  MOVLB  0
153BC:  CALL   55AE
....................          append_data(file_ptr_raw_new);    
153C0:  MOVLW  02
153C2:  MOVLB  8
153C4:  MOVWF  xEE
153C6:  MOVLW  EB
153C8:  MOVWF  xED
153CA:  MOVLB  0
153CC:  CALL   8320
....................       heartbeat(TRUE); 
153D0:  MOVLW  01
153D2:  MOVLB  8
153D4:  MOVWF  xED
153D6:  MOVLB  0
153D8:  CALL   55AE
153DC:  MOVLB  2
....................    } 
153DE:  MOVLB  0
153E0:  GOTO   1557C (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUvY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D398:  BSF    F90.7
....................    delay_ms(500); 
0D39A:  MOVLW  02
0D39C:  MOVLB  8
0D39E:  MOVWF  xC2
0D3A0:  MOVLW  FA
0D3A2:  MOVLB  9
0D3A4:  MOVWF  xEC
0D3A6:  MOVLB  0
0D3A8:  CALL   2938
0D3AC:  MOVLB  8
0D3AE:  DECFSZ xC2,F
0D3B0:  BRA    D3A0
....................    bus_pwr_status=1; 
0D3B2:  MOVLW  01
0D3B4:  MOVLB  4
0D3B6:  MOVWF  xB6
0D3B8:  MOVLB  0
0D3BA:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D3BC:  BCF    F90.7
....................    delay_ms(100); 
0D3BE:  MOVLW  64
0D3C0:  MOVLB  9
0D3C2:  MOVWF  xEC
0D3C4:  MOVLB  0
0D3C6:  CALL   2938
....................    bus_pwr_status=0; 
0D3CA:  MOVLB  4
0D3CC:  CLRF   xB6
0D3CE:  MOVLB  0
0D3D0:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
1805E:  MOVLB  8
18060:  CLRF   x97
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
18062:  CLRF   x97
18064:  MOVF   x97,W
18066:  SUBLW  31
18068:  BNC   1807E
....................       string_arg[i] = 0; 
1806A:  CLRF   03
1806C:  MOVF   x97,W
1806E:  ADDLW  25
18070:  MOVWF  FE9
18072:  MOVLW  08
18074:  ADDWFC 03,W
18076:  MOVWF  FEA
18078:  CLRF   FEF
1807A:  INCF   x97,F
1807C:  BRA    18064
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
1807E:  CLRF   x97
18080:  MOVF   x97,W
18082:  SUBLW  31
18084:  BNC   180FE
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
18086:  CLRF   03
18088:  MOVF   x97,W
1808A:  ADDLW  25
1808C:  MOVWF  FE9
1808E:  MOVLW  08
18090:  ADDWFC 03,W
18092:  MOVWF  FEA
18094:  MOVFF  FEA,89B
18098:  MOVFF  FE9,89A
1809C:  MOVLB  0
1809E:  CALL   0E58
180A2:  MOVFF  89B,FEA
180A6:  MOVFF  89A,FE9
180AA:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
180AE:  DECFSZ 4C,W
180B0:  BRA    180CE
....................       { 
....................          fputc(string_arg[i],COM_A); 
180B2:  CLRF   03
180B4:  MOVLB  8
180B6:  MOVF   x97,W
180B8:  ADDLW  25
180BA:  MOVWF  FE9
180BC:  MOVLW  08
180BE:  ADDWFC 03,W
180C0:  MOVWF  FEA
180C2:  MOVFF  FEF,898
180C6:  MOVF   x98,W
180C8:  MOVLB  0
180CA:  CALL   AEE0
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
180CE:  CLRF   03
180D0:  MOVLB  8
180D2:  MOVF   x97,W
180D4:  ADDLW  25
180D6:  MOVWF  FE9
180D8:  MOVLW  08
180DA:  ADDWFC 03,W
180DC:  MOVWF  FEA
180DE:  MOVF   FEF,W
180E0:  SUBLW  0D
180E2:  BZ    180F8
180E4:  CLRF   03
180E6:  MOVF   x97,W
180E8:  ADDLW  25
180EA:  MOVWF  FE9
180EC:  MOVLW  08
180EE:  ADDWFC 03,W
180F0:  MOVWF  FEA
180F2:  MOVF   FEF,W
180F4:  SUBLW  0A
180F6:  BNZ   180FA
....................       { 
....................          break; 
180F8:  BRA    180FE
....................       } 
180FA:  INCF   x97,F
180FC:  BRA    18080
....................    } 
180FE:  MOVLB  0
18100:  GOTO   18428 (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
182A6:  MOVLB  8
182A8:  CLRF   x97
....................    macro_arg = 0; 
182AA:  CLRF   x99
182AC:  CLRF   x98
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
182AE:  MOVF   x97,W
182B0:  SUBLW  0D
182B2:  BZ    1833E
....................       number = fgetc(COM_A); 
182B4:  MOVLB  0
182B6:  CALL   0E58
182BA:  MOVFF  01,897
....................       if (com_echo == TRUE) 
182BE:  DECFSZ 4C,W
182C0:  BRA    182D2
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
182C2:  MOVLB  8
182C4:  MOVF   x97,W
182C6:  SUBLW  0D
182C8:  BZ    182D4
182CA:  MOVF   x97,W
182CC:  MOVLB  0
182CE:  CALL   AEE0
182D2:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
182D4:  MOVF   x97,W
182D6:  SUBLW  2F
182D8:  BC    1830E
182DA:  MOVF   x97,W
182DC:  SUBLW  39
182DE:  BNC   1830E
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
182E0:  MOVLW  30
182E2:  SUBWF  x97,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
182E4:  MOVFF  899,A11
182E8:  MOVFF  898,A10
182EC:  MOVLB  A
182EE:  CLRF   x13
182F0:  MOVLW  0A
182F2:  MOVWF  x12
182F4:  MOVLB  0
182F6:  CALL   5CC0
182FA:  MOVFF  02,899
182FE:  MOVFF  01,898
....................          macro_arg = macro_arg + number;                // for each number 
18302:  MOVLB  8
18304:  MOVF   x97,W
18306:  ADDWF  x98,F
18308:  MOVLW  00
1830A:  ADDWFC x99,F
....................       } 
1830C:  BRA    1833C
....................       else if (number == CARRIAGE_RET) 
1830E:  MOVF   x97,W
18310:  SUBLW  0D
18312:  BNZ   18334
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
18314:  INCFSZ x98,W
18316:  BRA    1831E
18318:  INCFSZ x99,W
1831A:  BRA    1831E
1831C:  BRA    1832A
1831E:  MOVFF  898,01
18322:  MOVFF  899,02
18326:  BRA    1833E
18328:  BRA    18332
....................          else return(65535); 
1832A:  MOVLW  FF
1832C:  MOVWF  01
1832E:  MOVWF  02
18330:  BRA    1833E
....................       } 
18332:  BRA    1833C
....................       else 
....................       { 
....................          return(65535); 
18334:  MOVLW  FF
18336:  MOVWF  01
18338:  MOVWF  02
1833A:  BRA    1833E
....................       } 
1833C:  BRA    182AE
....................    } 
1833E:  MOVLB  0
18340:  GOTO   18452 (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
17DE8:  MOVF   2F,W
17DEA:  MOVWF  00
17DEC:  MOVF   30,W
17DEE:  MOVWF  03
17DF0:  BNZ   17DF6
17DF2:  MOVF   00,F
17DF4:  BZ    17E1C
17DF6:  MOVF   03,W
17DF8:  BNZ   17E02
17DFA:  MOVLW  03
17DFC:  SUBWF  00,W
17DFE:  BTFSC  FD8.2
17E00:  BRA    17EE0
17E02:  MOVF   03,W
17E04:  BNZ   17E0E
17E06:  MOVLW  01
17E08:  SUBWF  00,W
17E0A:  BTFSC  FD8.2
17E0C:  BRA    17EE0
17E0E:  MOVF   03,W
17E10:  BNZ   17E1A
17E12:  MOVLW  02
17E14:  SUBWF  00,W
17E16:  BTFSC  FD8.2
17E18:  BRA    17F56
17E1A:  BRA    17FC4
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
17E1C:  MOVLB  8
17E1E:  MOVF   x9B,F
17E20:  BNZ   17E50
17E22:  MOVF   x9A,W
17E24:  SUBLW  23
17E26:  BZ    17E4A
17E28:  MOVF   x9A,W
17E2A:  SUBLW  25
17E2C:  BZ    17E4A
17E2E:  MOVF   x9A,W
17E30:  SUBLW  3B
17E32:  BZ    17E4A
17E34:  MOVF   x9A,W
17E36:  SUBLW  4D
17E38:  BZ    17E4A
17E3A:  MOVF   x9A,W
17E3C:  SUBLW  5A
17E3E:  BZ    17E4A
17E40:  MOVF   x9A,W
17E42:  SUBLW  72
17E44:  BZ    17E4A
17E46:  MOVLW  00
17E48:  BRA    17E4C
17E4A:  MOVLW  01
17E4C:  MOVWF  x9C
17E4E:  BRA    17EDC
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
17E50:  MOVF   x9A,W
17E52:  SUBLW  23
17E54:  BZ    17ED8
17E56:  MOVF   x9A,W
17E58:  SUBLW  25
17E5A:  BZ    17ED8
17E5C:  MOVF   x9A,W
17E5E:  SUBLW  2B
17E60:  BZ    17ED8
17E62:  MOVF   x9A,W
17E64:  SUBLW  2D
17E66:  BZ    17ED8
17E68:  MOVF   x9A,W
17E6A:  SUBLW  2F
17E6C:  BZ    17ED8
17E6E:  MOVF   x9A,W
17E70:  SUBLW  3B
17E72:  BZ    17ED8
17E74:  MOVF   x9A,W
17E76:  SUBLW  41
17E78:  BZ    17ED8
17E7A:  MOVF   x9A,W
17E7C:  SUBLW  42
17E7E:  BC    17E86
17E80:  MOVF   x9A,W
17E82:  SUBLW  44
17E84:  BC    17ED8
17E86:  MOVF   x9A,W
17E88:  SUBLW  45
17E8A:  BC    17E92
17E8C:  MOVF   x9A,W
17E8E:  SUBLW  48
17E90:  BC    17ED8
17E92:  MOVF   x9A,W
17E94:  SUBLW  4A
17E96:  BC    17E9E
17E98:  MOVF   x9A,W
17E9A:  SUBLW  4C
17E9C:  BC    17ED8
17E9E:  MOVF   x9A,W
17EA0:  SUBLW  4F
17EA2:  BC    17EAA
17EA4:  MOVF   x9A,W
17EA6:  SUBLW  55
17EA8:  BC    17ED8
17EAA:  MOVF   x9A,W
17EAC:  SUBLW  59
17EAE:  BZ    17ED8
17EB0:  MOVF   x9A,W
17EB2:  SUBLW  64
17EB4:  BZ    17ED8
17EB6:  MOVF   x9A,W
17EB8:  SUBLW  69
17EBA:  BZ    17ED8
17EBC:  MOVF   x9A,W
17EBE:  SUBLW  6C
17EC0:  BZ    17ED8
17EC2:  MOVF   x9A,W
17EC4:  SUBLW  70
17EC6:  BZ    17ED8
17EC8:  MOVF   x9A,W
17ECA:  SUBLW  72
17ECC:  BZ    17ED8
17ECE:  MOVF   x9A,W
17ED0:  SUBLW  76
17ED2:  BZ    17ED8
17ED4:  MOVLW  00
17ED6:  BRA    17EDA
17ED8:  MOVLW  01
17EDA:  MOVWF  x9C
....................          break; 
17EDC:  MOVLB  0
17EDE:  BRA    17FC4
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
17EE0:  MOVLB  8
17EE2:  MOVF   x9B,F
17EE4:  BNZ   17F0E
17EE6:  MOVF   x9A,W
17EE8:  SUBLW  23
17EEA:  BZ    17F08
17EEC:  MOVF   x9A,W
17EEE:  SUBLW  3B
17EF0:  BZ    17F08
17EF2:  MOVF   x9A,W
17EF4:  SUBLW  4A
17EF6:  BZ    17F08
17EF8:  MOVF   x9A,W
17EFA:  SUBLW  4D
17EFC:  BZ    17F08
17EFE:  MOVF   x9A,W
17F00:  SUBLW  50
17F02:  BZ    17F08
17F04:  MOVLW  00
17F06:  BRA    17F0A
17F08:  MOVLW  01
17F0A:  MOVWF  x9C
17F0C:  BRA    17F52
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
17F0E:  MOVF   x9A,W
17F10:  SUBLW  23
17F12:  BZ    17F4E
17F14:  MOVF   x9A,W
17F16:  SUBLW  2B
17F18:  BZ    17F4E
17F1A:  MOVF   x9A,W
17F1C:  SUBLW  2D
17F1E:  BZ    17F4E
17F20:  MOVF   x9A,W
17F22:  SUBLW  3B
17F24:  BZ    17F4E
17F26:  MOVF   x9A,W
17F28:  SUBLW  42
17F2A:  BZ    17F4E
17F2C:  MOVF   x9A,W
17F2E:  SUBLW  47
17F30:  BZ    17F4E
17F32:  MOVF   x9A,W
17F34:  SUBLW  4F
17F36:  BC    17F3E
17F38:  MOVF   x9A,W
17F3A:  SUBLW  52
17F3C:  BC    17F4E
17F3E:  MOVF   x9A,W
17F40:  SUBLW  54
17F42:  BZ    17F4E
17F44:  MOVF   x9A,W
17F46:  SUBLW  59
17F48:  BZ    17F4E
17F4A:  MOVLW  00
17F4C:  BRA    17F50
17F4E:  MOVLW  01
17F50:  MOVWF  x9C
....................          break;   
17F52:  MOVLB  0
17F54:  BRA    17FC4
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17F56:  MOVLB  8
17F58:  MOVF   x9B,F
17F5A:  BNZ   17F7E
17F5C:  MOVF   x9A,W
17F5E:  SUBLW  23
17F60:  BZ    17F78
17F62:  MOVF   x9A,W
17F64:  SUBLW  3B
17F66:  BZ    17F78
17F68:  MOVF   x9A,W
17F6A:  SUBLW  4D
17F6C:  BZ    17F78
17F6E:  MOVF   x9A,W
17F70:  SUBLW  50
17F72:  BZ    17F78
17F74:  MOVLW  00
17F76:  BRA    17F7A
17F78:  MOVLW  01
17F7A:  MOVWF  x9C
17F7C:  BRA    17FC2
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
17F7E:  MOVF   x9A,W
17F80:  SUBLW  23
17F82:  BZ    17FBE
17F84:  MOVF   x9A,W
17F86:  SUBLW  2B
17F88:  BZ    17FBE
17F8A:  MOVF   x9A,W
17F8C:  SUBLW  2D
17F8E:  BZ    17FBE
17F90:  MOVF   x9A,W
17F92:  SUBLW  3B
17F94:  BZ    17FBE
17F96:  MOVF   x9A,W
17F98:  SUBLW  42
17F9A:  BC    17FA2
17F9C:  MOVF   x9A,W
17F9E:  SUBLW  44
17FA0:  BC    17FBE
17FA2:  MOVF   x9A,W
17FA4:  SUBLW  4F
17FA6:  BC    17FAE
17FA8:  MOVF   x9A,W
17FAA:  SUBLW  51
17FAC:  BC    17FBE
17FAE:  MOVF   x9A,W
17FB0:  SUBLW  53
17FB2:  BZ    17FBE
17FB4:  MOVF   x9A,W
17FB6:  SUBLW  59
17FB8:  BZ    17FBE
17FBA:  MOVLW  00
17FBC:  BRA    17FC0
17FBE:  MOVLW  01
17FC0:  MOVWF  x9C
....................          break;   
17FC2:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17FC4:  MOVLB  8
17FC6:  MOVFF  89C,01
17FCA:  MOVLB  0
17FCC:  GOTO   17FF8 (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17FD0:  MOVLW  01
17FD2:  MOVLB  8
17FD4:  MOVWF  x99
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17FD6:  MOVLB  0
17FD8:  CALL   0E58
17FDC:  MOVFF  01,898
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17FE0:  DECFSZ 4C,W
17FE2:  BRA    17FEE
17FE4:  MOVLB  8
17FE6:  MOVF   x98,W
17FE8:  MOVLB  0
17FEA:  CALL   AEE0
....................          valid_macro = check_macro(e, macro); 
17FEE:  MOVFF  898,89A
17FF2:  MOVFF  897,89B
17FF6:  BRA    17DE8
17FF8:  MOVFF  01,899
....................       if (valid_macro == TRUE) { 
17FFC:  MOVLB  8
17FFE:  DECFSZ x99,W
18000:  BRA    1800A
....................          return(e); 
18002:  MOVFF  898,01
18006:  BRA    18016
....................       } 
18008:  BRA    18010
....................       else return(0); 
1800A:  MOVLW  00
1800C:  MOVWF  01
1800E:  BRA    18016
....................    } while (valid_macro == TRUE); 
18010:  DECFSZ x99,W
18012:  BRA    18016
18014:  BRA    17FD6
18016:  MOVLB  0
18018:  GOTO   1840A (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
18390:  BCF    FD8.0
18392:  MOVLB  8
18394:  RLCF   x9A,W
18396:  CLRF   03
18398:  ADDLW  D1
1839A:  MOVWF  FE9
1839C:  MOVLW  07
1839E:  ADDWFC 03,W
183A0:  MOVWF  FEA
183A2:  MOVFF  FEC,8A0
183A6:  MOVF   FED,F
183A8:  MOVFF  FEF,89F
183AC:  MOVFF  89C,A11
183B0:  MOVFF  89B,A10
183B4:  MOVLB  A
183B6:  CLRF   x13
183B8:  MOVLW  03
183BA:  MOVWF  x12
183BC:  MOVLB  0
183BE:  CALL   5CC0
183C2:  MOVF   01,W
183C4:  MOVLB  8
183C6:  ADDWF  x9F,W
183C8:  MOVWF  x9D
183CA:  MOVF   02,W
183CC:  ADDWFC xA0,W
183CE:  MOVWF  x9E
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
183D0:  MOVFF  89E,8A8
183D4:  MOVFF  89D,8A7
183D8:  MOVFF  897,8A9
183DC:  MOVLB  0
183DE:  RCALL  18104
....................     
....................    ++addr; 
183E0:  MOVLB  8
183E2:  INCF   x9D,F
183E4:  BTFSC  FD8.2
183E6:  INCF   x9E,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
183E8:  MOVFF  89E,8A0
183EC:  MOVFF  89D,89F
183F0:  MOVFF  899,8A2
183F4:  MOVFF  898,8A1
183F8:  MOVLB  0
183FA:  BRA    18344
183FC:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
18164:  BCF    FD8.0
18166:  MOVLB  8
18168:  RLCF   x98,W
1816A:  CLRF   03
1816C:  ADDLW  D1
1816E:  MOVWF  FE9
18170:  MOVLW  07
18172:  ADDWFC 03,W
18174:  MOVWF  FEA
18176:  MOVFF  FEC,8A1
1817A:  MOVF   FED,F
1817C:  MOVFF  FEF,8A0
18180:  MOVFF  89A,A11
18184:  MOVFF  899,A10
18188:  MOVLB  A
1818A:  CLRF   x13
1818C:  MOVLW  03
1818E:  MOVWF  x12
18190:  MOVLB  0
18192:  CALL   5CC0
18196:  MOVF   01,W
18198:  MOVLB  8
1819A:  ADDWF  xA0,W
1819C:  MOVWF  x9D
1819E:  MOVF   02,W
181A0:  ADDWFC xA1,W
181A2:  MOVWF  x9E
....................    write_ext_eeprom(addr, macro_cmd); 
181A4:  MOVFF  89E,8A8
181A8:  MOVFF  89D,8A7
181AC:  MOVFF  897,8A9
181B0:  MOVLB  0
181B2:  RCALL  18104
....................     
....................    int i = 0; 
181B4:  MOVLB  8
181B6:  CLRF   x9F
....................    addr = string_address[macro] + (count*50); 
181B8:  BCF    FD8.0
181BA:  RLCF   x98,W
181BC:  CLRF   03
181BE:  ADDLW  FB
181C0:  MOVWF  FE9
181C2:  MOVLW  07
181C4:  ADDWFC 03,W
181C6:  MOVWF  FEA
181C8:  MOVFF  FEC,8A1
181CC:  MOVF   FED,F
181CE:  MOVFF  FEF,8A0
181D2:  MOVFF  89C,A11
181D6:  MOVFF  89B,A10
181DA:  MOVLB  A
181DC:  CLRF   x13
181DE:  MOVLW  32
181E0:  MOVWF  x12
181E2:  MOVLB  0
181E4:  CALL   5CC0
181E8:  MOVF   01,W
181EA:  MOVLB  8
181EC:  ADDWF  xA0,W
181EE:  MOVWF  x9D
181F0:  MOVF   02,W
181F2:  ADDWFC xA1,W
181F4:  MOVWF  x9E
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
181F6:  MOVF   x9C,F
181F8:  BNZ   1824E
181FA:  MOVF   x9B,W
181FC:  SUBLW  14
181FE:  BNC   1824E
....................       for(i = 0; i<50; i++) { 
18200:  CLRF   x9F
18202:  MOVF   x9F,W
18204:  SUBLW  31
18206:  BNC   1824C
....................          write_ext_eeprom(addr + i, string_arg[i]); 
18208:  MOVF   x9F,W
1820A:  ADDWF  x9D,W
1820C:  MOVWF  xA0
1820E:  MOVLW  00
18210:  ADDWFC x9E,W
18212:  MOVWF  xA1
18214:  CLRF   03
18216:  MOVF   x9F,W
18218:  ADDLW  25
1821A:  MOVWF  FE9
1821C:  MOVLW  08
1821E:  ADDWFC 03,W
18220:  MOVWF  FEA
18222:  MOVFF  FEF,8A9
18226:  MOVFF  8A1,8A8
1822A:  MOVFF  8A0,8A7
1822E:  MOVLB  0
18230:  RCALL  18104
....................          if(string_arg[i] == 0){ 
18232:  CLRF   03
18234:  MOVLB  8
18236:  MOVF   x9F,W
18238:  ADDLW  25
1823A:  MOVWF  FE9
1823C:  MOVLW  08
1823E:  ADDWFC 03,W
18240:  MOVWF  FEA
18242:  MOVF   FEF,F
18244:  BNZ   18248
....................             break; 
18246:  BRA    1824C
....................          } 
18248:  INCF   x9F,F
1824A:  BRA    18202
....................       
....................       } 
....................    }else{ 
1824C:  BRA    182A0
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
1824E:  MOVLW  F2
18250:  MOVWF  FF6
18252:  MOVLW  20
18254:  MOVWF  FF7
18256:  MOVLW  00
18258:  MOVWF  FF8
1825A:  CLRF   1B
1825C:  BTFSC  FF2.7
1825E:  BSF    1B.7
18260:  BCF    FF2.7
18262:  MOVLW  1E
18264:  MOVLB  A
18266:  MOVWF  x40
18268:  MOVLB  0
1826A:  CALL   1044
1826E:  BTFSC  1B.7
18270:  BSF    FF2.7
18272:  MOVLW  10
18274:  MOVWF  FE9
18276:  CLRF   1B
18278:  BTFSC  FF2.7
1827A:  BSF    1B.7
1827C:  BCF    FF2.7
1827E:  MOVFF  89A,A41
18282:  MOVFF  899,A40
18286:  CALL   11C6
1828A:  BTFSC  1B.7
1828C:  BSF    FF2.7
1828E:  MOVLW  0A
18290:  BTFSS  F9E.4
18292:  BRA    18290
18294:  MOVWF  FAD
18296:  MOVLW  0D
18298:  BTFSS  F9E.4
1829A:  BRA    18298
1829C:  MOVWF  FAD
1829E:  MOVLB  8
....................    } 
182A0:  MOVLB  0
182A2:  GOTO   18442 (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
185E2:  CALL   105F2
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
185E6:  MOVLW  3B
185E8:  MOVLB  8
185EA:  MOVWF  x97
185EC:  CLRF   x99
185EE:  CLRF   x98
185F0:  CLRF   x9A
185F2:  CLRF   x9C
185F4:  CLRF   x9B
185F6:  MOVLB  0
185F8:  RCALL  18390
....................     
....................    write_macro_line(59, 0, 1, 0); 
185FA:  MOVLW  3B
185FC:  MOVLB  8
185FE:  MOVWF  x97
18600:  CLRF   x99
18602:  CLRF   x98
18604:  MOVLW  01
18606:  MOVWF  x9A
18608:  CLRF   x9C
1860A:  CLRF   x9B
1860C:  MOVLB  0
1860E:  RCALL  18390
....................    write_macro_line(59, 0, 2, 0); 
18610:  MOVLW  3B
18612:  MOVLB  8
18614:  MOVWF  x97
18616:  CLRF   x99
18618:  CLRF   x98
1861A:  MOVLW  02
1861C:  MOVWF  x9A
1861E:  CLRF   x9C
18620:  CLRF   x9B
18622:  MOVLB  0
18624:  RCALL  18390
....................    write_macro_line(59, 0, 3, 0); 
18626:  MOVLW  3B
18628:  MOVLB  8
1862A:  MOVWF  x97
1862C:  CLRF   x99
1862E:  CLRF   x98
18630:  MOVLW  03
18632:  MOVWF  x9A
18634:  CLRF   x9C
18636:  CLRF   x9B
18638:  MOVLB  0
1863A:  RCALL  18390
....................    write_macro_line(59, 0, 4, 0); 
1863C:  MOVLW  3B
1863E:  MOVLB  8
18640:  MOVWF  x97
18642:  CLRF   x99
18644:  CLRF   x98
18646:  MOVLW  04
18648:  MOVWF  x9A
1864A:  CLRF   x9C
1864C:  CLRF   x9B
1864E:  MOVLB  0
18650:  RCALL  18390
....................    write_macro_line(59, 0, 5, 0); 
18652:  MOVLW  3B
18654:  MOVLB  8
18656:  MOVWF  x97
18658:  CLRF   x99
1865A:  CLRF   x98
1865C:  MOVLW  05
1865E:  MOVWF  x9A
18660:  CLRF   x9C
18662:  CLRF   x9B
18664:  MOVLB  0
18666:  RCALL  18390
....................    write_macro_line(59, 0, 6, 0); 
18668:  MOVLW  3B
1866A:  MOVLB  8
1866C:  MOVWF  x97
1866E:  CLRF   x99
18670:  CLRF   x98
18672:  MOVLW  06
18674:  MOVWF  x9A
18676:  CLRF   x9C
18678:  CLRF   x9B
1867A:  MOVLB  0
1867C:  RCALL  18390
....................    write_macro_line(59, 0, 7, 0); 
1867E:  MOVLW  3B
18680:  MOVLB  8
18682:  MOVWF  x97
18684:  CLRF   x99
18686:  CLRF   x98
18688:  MOVLW  07
1868A:  MOVWF  x9A
1868C:  CLRF   x9C
1868E:  CLRF   x9B
18690:  MOVLB  0
18692:  RCALL  18390
....................    write_macro_line(59, 0, 8, 0); 
18694:  MOVLW  3B
18696:  MOVLB  8
18698:  MOVWF  x97
1869A:  CLRF   x99
1869C:  CLRF   x98
1869E:  MOVLW  08
186A0:  MOVWF  x9A
186A2:  CLRF   x9C
186A4:  CLRF   x9B
186A6:  MOVLB  0
186A8:  RCALL  18390
....................     
....................    write_macro_line(59, 0, 9, 0); 
186AA:  MOVLW  3B
186AC:  MOVLB  8
186AE:  MOVWF  x97
186B0:  CLRF   x99
186B2:  CLRF   x98
186B4:  MOVLW  09
186B6:  MOVWF  x9A
186B8:  CLRF   x9C
186BA:  CLRF   x9B
186BC:  MOVLB  0
186BE:  RCALL  18390
....................    write_macro_line(59, 0, 10, 0); 
186C0:  MOVLW  3B
186C2:  MOVLB  8
186C4:  MOVWF  x97
186C6:  CLRF   x99
186C8:  CLRF   x98
186CA:  MOVLW  0A
186CC:  MOVWF  x9A
186CE:  CLRF   x9C
186D0:  CLRF   x9B
186D2:  MOVLB  0
186D4:  RCALL  18390
....................    write_macro_line(59, 0, 11, 0); 
186D6:  MOVLW  3B
186D8:  MOVLB  8
186DA:  MOVWF  x97
186DC:  CLRF   x99
186DE:  CLRF   x98
186E0:  MOVLW  0B
186E2:  MOVWF  x9A
186E4:  CLRF   x9C
186E6:  CLRF   x9B
186E8:  MOVLB  0
186EA:  RCALL  18390
....................    write_macro_line(59, 0, 12, 0); 
186EC:  MOVLW  3B
186EE:  MOVLB  8
186F0:  MOVWF  x97
186F2:  CLRF   x99
186F4:  CLRF   x98
186F6:  MOVLW  0C
186F8:  MOVWF  x9A
186FA:  CLRF   x9C
186FC:  CLRF   x9B
186FE:  MOVLB  0
18700:  RCALL  18390
....................    write_macro_line(59, 0, 13, 0); 
18702:  MOVLW  3B
18704:  MOVLB  8
18706:  MOVWF  x97
18708:  CLRF   x99
1870A:  CLRF   x98
1870C:  MOVLW  0D
1870E:  MOVWF  x9A
18710:  CLRF   x9C
18712:  CLRF   x9B
18714:  MOVLB  0
18716:  RCALL  18390
....................    write_macro_line(59, 0, 14, 0); 
18718:  MOVLW  3B
1871A:  MOVLB  8
1871C:  MOVWF  x97
1871E:  CLRF   x99
18720:  CLRF   x98
18722:  MOVLW  0E
18724:  MOVWF  x9A
18726:  CLRF   x9C
18728:  CLRF   x9B
1872A:  MOVLB  0
1872C:  RCALL  18390
....................    write_macro_line(59, 0, 15, 0); 
1872E:  MOVLW  3B
18730:  MOVLB  8
18732:  MOVWF  x97
18734:  CLRF   x99
18736:  CLRF   x98
18738:  MOVLW  0F
1873A:  MOVWF  x9A
1873C:  CLRF   x9C
1873E:  CLRF   x9B
18740:  MOVLB  0
18742:  RCALL  18390
....................    write_macro_line(59, 0, 16, 0); 
18744:  MOVLW  3B
18746:  MOVLB  8
18748:  MOVWF  x97
1874A:  CLRF   x99
1874C:  CLRF   x98
1874E:  MOVLW  10
18750:  MOVWF  x9A
18752:  CLRF   x9C
18754:  CLRF   x9B
18756:  MOVLB  0
18758:  RCALL  18390
1875A:  GOTO   18792 (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
1801C:  MOVLB  8
1801E:  CLRF   x97
....................     
....................    heartbeat(FALSE); 
18020:  CLRF   xED
18022:  MOVLB  0
18024:  CALL   55AE
....................     
....................    while(mcc != CARRIAGE_RET){ 
18028:  MOVLB  8
1802A:  MOVF   x97,W
1802C:  SUBLW  0D
1802E:  BZ    18050
....................       if (kbhit(COM_A)) { 
18030:  BTFSS  F9E.5
18032:  BRA    1804E
....................          mcc=fgetc(COM_A); 
18034:  MOVLB  0
18036:  CALL   0E58
1803A:  MOVFF  01,897
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
1803E:  DECFSZ 4C,W
18040:  BRA    1804C
18042:  MOVLB  8
18044:  MOVF   x97,W
18046:  MOVLB  0
18048:  CALL   AEE0
1804C:  MOVLB  8
....................       } 
1804E:  BRA    1802A
....................    } 
....................     
....................    heartbeat(TRUE); 
18050:  MOVLW  01
18052:  MOVWF  xED
18054:  MOVLB  0
18056:  CALL   55AE
1805A:  GOTO   1841A (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
183FE:  MOVLB  8
18400:  CLRF   x96
....................     
....................    macro_cmd = get_cmd(macro); 
18402:  MOVFF  88E,897
18406:  MOVLB  0
18408:  BRA    17FD0
1840A:  MOVFF  01,893
....................    if (macro_cmd == 35){  
1840E:  MOVLB  8
18410:  MOVF   x93,W
18412:  SUBLW  23
18414:  BNZ   1841E
....................       macro_comment();        // # = 35 
18416:  MOVLB  0
18418:  BRA    1801C
....................    }else if(macro_cmd == 112){// 112 is p 
1841A:  BRA    184A0
1841C:  MOVLB  8
1841E:  MOVF   x93,W
18420:  SUBLW  70
18422:  BNZ   1844A
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
18424:  MOVLB  0
18426:  BRA    1805E
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
18428:  MOVFF  893,897
1842C:  MOVFF  88E,898
18430:  MOVFF  890,89A
18434:  MOVFF  88F,899
18438:  MOVFF  892,89C
1843C:  MOVFF  891,89B
18440:  BRA    18164
....................       valid_macro = TRUE; 
18442:  MOVLW  01
18444:  MOVLB  8
18446:  MOVWF  x96
....................    }else{ 
18448:  BRA    1849E
....................       if (macro_cmd != 0) { 
1844A:  MOVF   x93,F
1844C:  BZ    18474
....................          macro_arg = get_arg(); 
1844E:  MOVLB  0
18450:  BRA    182A6
18452:  MOVFF  02,895
18456:  MOVFF  01,894
....................          if (macro_arg != 65535) valid_macro = TRUE; 
1845A:  MOVLB  8
1845C:  INCFSZ x94,W
1845E:  BRA    18466
18460:  INCFSZ x95,W
18462:  BRA    18466
18464:  BRA    1846C
18466:  MOVLW  01
18468:  MOVWF  x96
1846A:  BRA    18472
....................          else return(macro_cmd); 
1846C:  MOVFF  893,01
18470:  BRA    184A6
....................       }else return(macro_cmd); 
18472:  BRA    1847A
18474:  MOVFF  893,01
18478:  BRA    184A6
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
1847A:  MOVFF  893,897
1847E:  MOVFF  895,899
18482:  MOVFF  894,898
18486:  MOVFF  88E,89A
1848A:  MOVFF  890,89C
1848E:  MOVFF  88F,89B
18492:  MOVLB  0
18494:  RCALL  18390
....................       return(macro_cmd); 
18496:  MOVLB  8
18498:  MOVFF  893,01
1849C:  BRA    184A6
1849E:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
184A0:  MOVLB  8
184A2:  MOVFF  893,01
184A6:  MOVLB  0
184A8:  GOTO   184EE (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
184AC:  MOVLB  8
184AE:  CLRF   x8D
184B0:  CLRF   x8C
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
184B2:  CLRF   x88
184B4:  CLRF   x87
....................    valid_macro = TRUE; 
184B6:  MOVLW  01
184B8:  MOVWF  x89
....................    macro_cmd = 1; 
184BA:  MOVWF  x8A
....................     
....................    init_ext_eeprom(); 
184BC:  MOVLB  0
184BE:  CALL   105F2
....................     
....................    fprintf(COM_A, ":"); 
184C2:  MOVLW  3A
184C4:  BTFSS  F9E.4
184C6:  BRA    184C4
184C8:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
184CA:  MOVLB  8
184CC:  MOVF   x8A,W
184CE:  SUBLW  3B
184D0:  BZ    18534
184D2:  MOVF   x8A,F
184D4:  BZ    18534
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
184D6:  MOVFF  886,88E
184DA:  MOVFF  888,890
184DE:  MOVFF  887,88F
184E2:  MOVFF  88D,892
184E6:  MOVFF  88C,891
184EA:  MOVLB  0
184EC:  BRA    183FE
184EE:  MOVFF  01,88A
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
184F2:  MOVLB  8
184F4:  MOVF   x8A,W
184F6:  SUBLW  70
184F8:  BNZ   18500
....................          count++; 
184FA:  INCF   x8C,F
184FC:  BTFSC  FD8.2
184FE:  INCF   x8D,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
18500:  MOVF   x8A,W
18502:  SUBLW  23
18504:  BZ    1850C
18506:  INCF   x87,F
18508:  BTFSC  FD8.2
1850A:  INCF   x88,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
1850C:  MOVF   x8A,W
1850E:  SUBLW  3B
18510:  BZ    18532
18512:  MOVLW  16
18514:  MOVWF  FF6
18516:  MOVLW  21
18518:  MOVWF  FF7
1851A:  MOVLW  00
1851C:  MOVWF  FF8
1851E:  CLRF   1B
18520:  BTFSC  FF2.7
18522:  BSF    1B.7
18524:  BCF    FF2.7
18526:  MOVLB  0
18528:  CALL   0E6E
1852C:  BTFSC  1B.7
1852E:  BSF    FF2.7
18530:  MOVLB  8
18532:  BRA    184CC
....................    }       
....................    if (macro_cmd == 0){ 
18534:  MOVF   x8A,F
18536:  BNZ   185CC
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
18538:  MOVLW  1A
1853A:  MOVWF  FF6
1853C:  MOVLW  21
1853E:  MOVWF  FF7
18540:  MOVLW  00
18542:  MOVWF  FF8
18544:  CLRF   1B
18546:  BTFSC  FF2.7
18548:  BSF    1B.7
1854A:  BCF    FF2.7
1854C:  MOVLB  0
1854E:  CALL   0E6E
18552:  BTFSC  1B.7
18554:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
18556:  MOVLW  42
18558:  MOVWF  FF6
1855A:  MOVLW  21
1855C:  MOVWF  FF7
1855E:  MOVLW  00
18560:  MOVWF  FF8
18562:  CLRF   1B
18564:  BTFSC  FF2.7
18566:  BSF    1B.7
18568:  BCF    FF2.7
1856A:  MOVLW  15
1856C:  MOVLB  A
1856E:  MOVWF  x40
18570:  MOVLB  0
18572:  CALL   1044
18576:  BTFSC  1B.7
18578:  BSF    FF2.7
1857A:  MOVLW  10
1857C:  MOVWF  FE9
1857E:  MOVFF  888,8F1
18582:  MOVFF  887,8F0
18586:  CALL   900C
1858A:  MOVLW  5A
1858C:  MOVWF  FF6
1858E:  MOVLW  21
18590:  MOVWF  FF7
18592:  MOVLW  00
18594:  MOVWF  FF8
18596:  CLRF   1B
18598:  BTFSC  FF2.7
1859A:  BSF    1B.7
1859C:  BCF    FF2.7
1859E:  MOVLW  03
185A0:  MOVLB  A
185A2:  MOVWF  x40
185A4:  MOVLB  0
185A6:  CALL   1044
185AA:  BTFSC  1B.7
185AC:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
185AE:  MOVLW  5E
185B0:  MOVWF  FF6
185B2:  MOVLW  21
185B4:  MOVWF  FF7
185B6:  MOVLW  00
185B8:  MOVWF  FF8
185BA:  CLRF   1B
185BC:  BTFSC  FF2.7
185BE:  BSF    1B.7
185C0:  BCF    FF2.7
185C2:  CALL   0E6E
185C6:  BTFSC  1B.7
185C8:  BSF    FF2.7
185CA:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
185CC:  MOVLW  0D
185CE:  BTFSS  F9E.4
185D0:  BRA    185CE
185D2:  MOVWF  FAD
185D4:  MOVLW  0A
185D6:  BTFSS  F9E.4
185D8:  BRA    185D6
185DA:  MOVWF  FAD
185DC:  MOVLB  0
185DE:  GOTO   1877A (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
1879C:  BCF    FD8.0
1879E:  MOVLB  8
187A0:  RLCF   x8B,W
187A2:  CLRF   03
187A4:  ADDLW  D1
187A6:  MOVWF  FE9
187A8:  MOVLW  07
187AA:  ADDWFC 03,W
187AC:  MOVWF  FEA
187AE:  MOVFF  FEC,894
187B2:  MOVF   FED,F
187B4:  MOVFF  FEF,893
187B8:  MOVFF  88D,A11
187BC:  MOVFF  88C,A10
187C0:  MOVLB  A
187C2:  CLRF   x13
187C4:  MOVLW  03
187C6:  MOVWF  x12
187C8:  MOVLB  0
187CA:  CALL   5CC0
187CE:  MOVF   01,W
187D0:  MOVLB  8
187D2:  ADDWF  x93,W
187D4:  MOVWF  x8E
187D6:  MOVF   02,W
187D8:  ADDWFC x94,W
187DA:  MOVWF  x8F
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
187DC:  MOVFF  88F,8CC
187E0:  MOVFF  88E,8CB
187E4:  MOVLB  0
187E6:  CALL   1062A
187EA:  MOVFF  01,890
....................    ++addr; 
187EE:  MOVLB  8
187F0:  INCF   x8E,F
187F2:  BTFSC  FD8.2
187F4:  INCF   x8F,F
....................    macro_arg = read16_ext_eeprom(addr); 
187F6:  MOVFF  88F,8C3
187FA:  MOVFF  88E,8C2
187FE:  MOVLB  0
18800:  CALL   1073E
18804:  MOVFF  02,892
18808:  MOVFF  01,891
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
1880C:  MOVLB  8
1880E:  MOVF   x90,W
18810:  BTFSS  F9E.4
18812:  BRA    18810
18814:  MOVWF  FAD
18816:  MOVLW  10
18818:  MOVWF  FE9
1881A:  CLRF   1B
1881C:  BTFSC  FF2.7
1881E:  BSF    1B.7
18820:  BCF    FF2.7
18822:  MOVFF  892,A41
18826:  MOVFF  891,A40
1882A:  MOVLB  0
1882C:  CALL   11C6
18830:  BTFSC  1B.7
18832:  BSF    FF2.7
18834:  MOVLW  0D
18836:  BTFSS  F9E.4
18838:  BRA    18836
1883A:  MOVWF  FAD
1883C:  MOVLW  0A
1883E:  BTFSS  F9E.4
18840:  BRA    1883E
18842:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
18844:  MOVLB  8
18846:  MOVFF  890,01
1884A:  MOVLB  0
1884C:  GOTO   18880 (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
1436A:  BCF    FD8.0
1436C:  MOVLB  8
1436E:  RLCF   xB7,W
14370:  CLRF   03
14372:  ADDLW  D1
14374:  MOVWF  FE9
14376:  MOVLW  07
14378:  ADDWFC 03,W
1437A:  MOVWF  FEA
1437C:  MOVFF  FEC,8C0
14380:  MOVF   FED,F
14382:  MOVFF  FEF,8BF
14386:  MOVFF  8B9,A11
1438A:  MOVFF  8B8,A10
1438E:  MOVLB  A
14390:  CLRF   x13
14392:  MOVLW  03
14394:  MOVWF  x12
14396:  MOVLB  0
14398:  CALL   5CC0
1439C:  MOVF   01,W
1439E:  MOVLB  8
143A0:  ADDWF  xBF,W
143A2:  MOVWF  xBA
143A4:  MOVF   02,W
143A6:  ADDWFC xC0,W
143A8:  MOVWF  xBB
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
143AA:  MOVFF  8BB,8CC
143AE:  MOVFF  8BA,8CB
143B2:  MOVLB  0
143B4:  CALL   1062A
143B8:  MOVFF  01,8BC
....................    ++addr; 
143BC:  MOVLB  8
143BE:  INCF   xBA,F
143C0:  BTFSC  FD8.2
143C2:  INCF   xBB,F
....................    macro_arg = read16_ext_eeprom(addr); 
143C4:  MOVFF  8BB,8C3
143C8:  MOVFF  8BA,8C2
143CC:  MOVLB  0
143CE:  CALL   1073E
143D2:  MOVFF  02,8BE
143D6:  MOVFF  01,8BD
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
143DA:  MOVLB  8
143DC:  MOVF   xBC,W
143DE:  BTFSS  F9E.4
143E0:  BRA    143DE
143E2:  MOVWF  FAD
143E4:  MOVLW  10
143E6:  MOVWF  FE9
143E8:  CLRF   1B
143EA:  BTFSC  FF2.7
143EC:  BSF    1B.7
143EE:  BCF    FF2.7
143F0:  MOVFF  8BE,A41
143F4:  MOVFF  8BD,A40
143F8:  MOVLB  0
143FA:  CALL   11C6
143FE:  BTFSC  1B.7
14400:  BSF    FF2.7
14402:  MOVLW  0D
14404:  BTFSS  F9E.4
14406:  BRA    14404
14408:  MOVWF  FAD
1440A:  MOVLW  0A
1440C:  BTFSS  F9E.4
1440E:  BRA    1440C
14410:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
14412:  MOVLB  8
14414:  MOVFF  8BC,01
14418:  MOVLB  0
1441A:  GOTO   14BF2 (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
10684:  BCF    FD8.0
10686:  MOVLB  8
10688:  RLCF   xB5,W
1068A:  CLRF   03
1068C:  ADDLW  FB
1068E:  MOVWF  FE9
10690:  MOVLW  07
10692:  ADDWFC 03,W
10694:  MOVWF  FEA
10696:  MOVFF  FEC,8BE
1069A:  MOVF   FED,F
1069C:  MOVFF  FEF,8BD
106A0:  MOVFF  8B9,A11
106A4:  MOVFF  8B8,A10
106A8:  MOVLB  A
106AA:  CLRF   x13
106AC:  MOVLW  32
106AE:  MOVWF  x12
106B0:  MOVLB  0
106B2:  CALL   5CC0
106B6:  MOVF   01,W
106B8:  MOVLB  8
106BA:  ADDWF  xBD,W
106BC:  MOVWF  xBA
106BE:  MOVF   02,W
106C0:  ADDWFC xBE,W
106C2:  MOVWF  xBB
....................     
....................    int i = 0; 
106C4:  CLRF   xBC
....................    for(i = 0; i < 50; i++){ 
106C6:  CLRF   xBC
106C8:  MOVF   xBC,W
106CA:  SUBLW  31
106CC:  BNC   106E2
....................       string_arg[i] = 0; 
106CE:  CLRF   03
106D0:  MOVF   xBC,W
106D2:  ADDLW  25
106D4:  MOVWF  FE9
106D6:  MOVLW  08
106D8:  ADDWFC 03,W
106DA:  MOVWF  FEA
106DC:  CLRF   FEF
106DE:  INCF   xBC,F
106E0:  BRA    106C8
....................    }  
....................    for(i = 0; i < 50; i++){ 
106E2:  CLRF   xBC
106E4:  MOVF   xBC,W
106E6:  SUBLW  31
106E8:  BNC   1073A
....................       string_arg[i] = read_ext_eeprom(addr + i); 
106EA:  CLRF   03
106EC:  MOVF   xBC,W
106EE:  ADDLW  25
106F0:  MOVWF  01
106F2:  MOVLW  08
106F4:  ADDWFC 03,F
106F6:  MOVFF  01,8BD
106FA:  MOVFF  03,8BE
106FE:  MOVF   xBC,W
10700:  ADDWF  xBA,W
10702:  MOVWF  xBF
10704:  MOVLW  00
10706:  ADDWFC xBB,W
10708:  MOVWF  xC0
1070A:  MOVWF  xCC
1070C:  MOVFF  8BF,8CB
10710:  MOVLB  0
10712:  RCALL  1062A
10714:  MOVFF  8BE,FEA
10718:  MOVFF  8BD,FE9
1071C:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
10720:  CLRF   03
10722:  MOVLB  8
10724:  MOVF   xBC,W
10726:  ADDLW  25
10728:  MOVWF  FE9
1072A:  MOVLW  08
1072C:  ADDWFC 03,W
1072E:  MOVWF  FEA
10730:  MOVF   FEF,F
10732:  BNZ   10736
....................          break; 
10734:  BRA    1073A
....................       } 
10736:  INCF   xBC,F
10738:  BRA    106E4
....................    }   
1073A:  MOVLB  0
1073C:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
18850:  MOVLB  8
18852:  CLRF   x8A
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
18854:  CLRF   x88
18856:  CLRF   x87
....................    macro_cmd = 1; 
18858:  MOVLW  01
1885A:  MOVWF  x89
....................     
....................    init_ext_eeprom(); 
1885C:  MOVLB  0
1885E:  CALL   105F2
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
18862:  MOVLB  8
18864:  MOVF   x88,W
18866:  SUBLW  03
18868:  BNC   188B0
1886A:  MOVF   x89,W
1886C:  SUBLW  3B
1886E:  BZ    188B0
....................       macro_cmd = read_macro_line(macro, line); 
18870:  MOVFF  886,88B
18874:  MOVFF  888,88D
18878:  MOVFF  887,88C
1887C:  MOVLB  0
1887E:  BRA    1879C
18880:  MOVFF  01,889
....................       if(macro_cmd == 'p'){ 
18884:  MOVLB  8
18886:  MOVF   x89,W
18888:  SUBLW  70
1888A:  BNZ   188A8
....................          read_macro_line_string(macro,line,count); 
1888C:  MOVFF  886,8B5
18890:  MOVFF  888,8B7
18894:  MOVFF  887,8B6
18898:  CLRF   xB9
1889A:  MOVFF  88A,8B8
1889E:  MOVLB  0
188A0:  CALL   10684
....................          count++; 
188A4:  MOVLB  8
188A6:  INCF   x8A,F
....................       } 
....................       ++line; 
188A8:  INCF   x87,F
188AA:  BTFSC  FD8.2
188AC:  INCF   x88,F
188AE:  BRA    18864
....................    } 
188B0:  MOVLB  0
188B2:  GOTO   188D2 (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D362:  MOVLB  8
0D364:  CLRF   xC5
0D366:  CLRF   xC4
0D368:  MOVF   xC5,W
0D36A:  SUBWF  xC3,W
0D36C:  BNC   D394
0D36E:  BNZ   D376
0D370:  MOVF   xC2,W
0D372:  SUBWF  xC4,W
0D374:  BC    D394
....................       delay_ms(1000); 
0D376:  MOVLW  04
0D378:  MOVWF  xC6
0D37A:  MOVLW  FA
0D37C:  MOVLB  9
0D37E:  MOVWF  xEC
0D380:  MOVLB  0
0D382:  CALL   2938
0D386:  MOVLB  8
0D388:  DECFSZ xC6,F
0D38A:  BRA    D37A
0D38C:  INCF   xC4,F
0D38E:  BTFSC  FD8.2
0D390:  INCF   xC5,F
0D392:  BRA    D368
....................    }  
0D394:  MOVLB  0
0D396:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0D32A:  BCF    FD8.0
0D32C:  MOVLB  7
0D32E:  RLCF   x40,W
0D330:  CLRF   03
0D332:  ADDLW  96
0D334:  MOVWF  FE9
0D336:  MOVLW  07
0D338:  ADDWFC 03,W
0D33A:  MOVWF  FEA
0D33C:  MOVFF  FEC,8C4
0D340:  MOVF   FED,F
0D342:  MOVFF  FEF,8C3
0D346:  MOVLB  8
0D348:  DECFSZ xC3,W
0D34A:  BRA    D356
0D34C:  MOVF   xC4,F
0D34E:  BNZ   D356
....................    { 
....................       macro_status = 'e'; 
0D350:  MOVLW  65
0D352:  MOVWF  xC2
....................    } 
0D354:  BRA    D35A
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D356:  MOVLW  61
0D358:  MOVWF  xC2
....................    } 
....................    return(macro_status); 
0D35A:  MOVFF  8C2,01
0D35E:  MOVLB  0
0D360:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
13886:  DECFSZ 45,W
13888:  BRA    1389C
1388A:  MOVF   46,F
1388C:  BNZ   1389C
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
1388E:  MOVLW  01
13890:  MOVLB  8
13892:  MOVWF  xC2
13894:  MOVWF  xC3
13896:  MOVLB  0
13898:  RCALL  13750
....................    } 
1389A:  BRA    138C6
....................    else if(nv_det_type==2 || nv_det_type==3) 
1389C:  MOVF   45,W
1389E:  SUBLW  02
138A0:  BNZ   138A6
138A2:  MOVF   46,F
138A4:  BZ    138B0
138A6:  MOVF   45,W
138A8:  SUBLW  03
138AA:  BNZ   138C6
138AC:  MOVF   46,F
138AE:  BNZ   138C6
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
138B0:  MOVLB  8
138B2:  CLRF   xC3
138B4:  MOVLW  C8
138B6:  MOVWF  xC2
138B8:  MOVLW  01
138BA:  MOVWF  xC4
138BC:  MOVWF  xC5
138BE:  CLRF   xC6
138C0:  MOVLB  0
138C2:  CALL   100B6
....................    } 
138C6:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
127A4:  DECFSZ 45,W
127A6:  BRA    127C2
127A8:  MOVF   46,F
127AA:  BNZ   127C2
....................       cmd = macro_cmd; 
127AC:  MOVFF  8C2,47
....................       arg = macro_arg; 
127B0:  CLRF   4B
127B2:  CLRF   4A
127B4:  MOVFF  8C4,49
127B8:  MOVFF  8C3,48
....................       det_cmd(); 
127BC:  CALL   F42A
....................    } 
127C0:  BRA    127DC
....................    else if(nv_det_type==2 || nv_det_type==3) { 
127C2:  MOVF   45,W
127C4:  SUBLW  02
127C6:  BNZ   127CC
127C8:  MOVF   46,F
127CA:  BZ    127D6
127CC:  MOVF   45,W
127CE:  SUBLW  03
127D0:  BNZ   127DC
127D2:  MOVF   46,F
127D4:  BNZ   127DC
....................       set_heaters(macro_arg); 
127D6:  MOVFF  8C3,8C5
127DA:  RCALL  12730
....................    } 
127DC:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
127DE:  DECFSZ 45,W
127E0:  BRA    127FC
127E2:  MOVF   46,F
127E4:  BNZ   127FC
....................       cmd = macro_cmd; 
127E6:  MOVFF  8C2,47
....................       arg = macro_arg; 
127EA:  CLRF   4B
127EC:  CLRF   4A
127EE:  MOVFF  8C4,49
127F2:  MOVFF  8C3,48
....................       det_cmd(); 
127F6:  CALL   F42A
....................    } 
127FA:  BRA    1281C
....................    else if(nv_det_type==2 || nv_det_type==3) { 
127FC:  MOVF   45,W
127FE:  SUBLW  02
12800:  BNZ   12806
12802:  MOVF   46,F
12804:  BZ    12810
12806:  MOVF   45,W
12808:  SUBLW  03
1280A:  BNZ   1281C
1280C:  MOVF   46,F
1280E:  BNZ   1281C
....................       set_LED(macro_arg); 
12810:  MOVFF  8C4,8C6
12814:  MOVFF  8C3,8C5
12818:  CALL   F8EE
....................    } 
1281C:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13F5A:  MOVLW  65
13F5C:  MOVLB  8
13F5E:  MOVWF  xC1
....................     
....................    addr = macro_address[macro] + (line*3); 
13F60:  BCF    FD8.0
13F62:  RLCF   xB7,W
13F64:  CLRF   03
13F66:  ADDLW  D1
13F68:  MOVWF  FE9
13F6A:  MOVLW  07
13F6C:  ADDWFC 03,W
13F6E:  MOVWF  FEA
13F70:  MOVFF  FEC,8C3
13F74:  MOVF   FED,F
13F76:  MOVFF  FEF,8C2
13F7A:  MOVFF  8B9,A11
13F7E:  MOVFF  8B8,A10
13F82:  MOVLB  A
13F84:  CLRF   x13
13F86:  MOVLW  03
13F88:  MOVWF  x12
13F8A:  MOVLB  0
13F8C:  CALL   5CC0
13F90:  MOVF   01,W
13F92:  MOVLB  8
13F94:  ADDWF  xC2,W
13F96:  MOVWF  xBC
13F98:  MOVF   02,W
13F9A:  ADDWFC xC3,W
13F9C:  MOVWF  xBD
....................  
....................    init_ext_eeprom(); 
13F9E:  MOVLB  0
13FA0:  CALL   105F2
....................    macro_cmd = read_ext_eeprom(addr); 
13FA4:  MOVFF  8BD,8CC
13FA8:  MOVFF  8BC,8CB
13FAC:  CALL   1062A
13FB0:  MOVFF  01,8BE
....................    ++addr; 
13FB4:  MOVLB  8
13FB6:  INCF   xBC,F
13FB8:  BTFSC  FD8.2
13FBA:  INCF   xBD,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13FBC:  MOVFF  8BD,8C3
13FC0:  MOVFF  8BC,8C2
13FC4:  MOVLB  0
13FC6:  CALL   1073E
13FCA:  MOVFF  02,8C0
13FCE:  MOVFF  01,8BF
....................    //} 
....................    heartbeat(TRUE); 
13FD2:  MOVLW  01
13FD4:  MOVLB  8
13FD6:  MOVWF  xED
13FD8:  MOVLB  0
13FDA:  CALL   55AE
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13FDE:  MOVF   2F,F
13FE0:  BTFSS  FD8.2
13FE2:  BRA    142A6
13FE4:  MOVF   30,F
13FE6:  BTFSS  FD8.2
13FE8:  BRA    142A6
....................       switch(macro_cmd) 
13FEA:  MOVLW  2B
13FEC:  MOVLB  8
13FEE:  SUBWF  xBE,W
13FF0:  ADDLW  B4
13FF2:  BTFSC  FD8.0
13FF4:  BRA    142A8
13FF6:  ADDLW  4C
13FF8:  MOVLB  0
13FFA:  GOTO   142B2
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13FFE:  CALL   125BC
....................             store_rel_data(); 
14002:  CALL   12620
....................             macro_status = 'a'; 
14006:  MOVLW  61
14008:  MOVLB  8
1400A:  MOVWF  xC1
....................             break; 
1400C:  BRA    142A8
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
1400E:  MOVLW  08
14010:  MOVWF  FEA
14012:  MOVLW  25
14014:  MOVWF  FE9
14016:  CALL   79BE
1401A:  MOVLW  0D
1401C:  BTFSS  F9E.4
1401E:  BRA    1401C
14020:  MOVWF  FAD
14022:  MOVLW  0A
14024:  BTFSS  F9E.4
14026:  BRA    14024
14028:  MOVWF  FAD
....................             macro_status = 'a'; 
1402A:  MOVLW  61
1402C:  MOVLB  8
1402E:  MOVWF  xC1
....................             break; 
14030:  BRA    142A8
....................          case 'C' : 
....................             calc_abs_data(); 
14032:  CALL   125BC
....................             break; 
14036:  MOVLB  8
14038:  BRA    142A8
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
1403A:  MOVFF  8C0,8C3
1403E:  MOVFF  8BF,8C2
14042:  CALL   D362
....................             macro_status = 'a'; 
14046:  MOVLW  61
14048:  MOVLB  8
1404A:  MOVWF  xC1
....................             break; 
1404C:  BRA    142A8
....................          case 'F' : macro_flag = macro_arg; 
1404E:  MOVFF  8C0,324
14052:  MOVFF  8BF,323
....................                     macro_status = 'a'; 
14056:  MOVLW  61
14058:  MOVLB  8
1405A:  MOVWF  xC1
....................             break ; 
1405C:  BRA    142A8
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
1405E:  MOVFF  8BF,2D5
....................                     macro_status = 'a'; 
14062:  MOVLW  61
14064:  MOVLB  8
14066:  MOVWF  xC1
....................             break ; 
14068:  BRA    142A8
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
1406A:  MOVFF  8BE,8C2
1406E:  MOVFF  8C0,8C4
14072:  MOVFF  8BF,8C3
14076:  CALL   127A4
....................                     macro_status = 'a'; 
1407A:  MOVLW  61
1407C:  MOVLB  8
1407E:  MOVWF  xC1
....................             break; 
14080:  BRA    142A8
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14082:  MOVFF  8BE,8C2
14086:  MOVFF  8C0,8C4
1408A:  MOVFF  8BF,8C3
1408E:  CALL   127A4
....................                     macro_status = 'a'; 
14092:  MOVLW  61
14094:  MOVLB  8
14096:  MOVWF  xC1
....................             break; 
14098:  BRA    142A8
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
1409A:  MOVFF  8C0,8DC
1409E:  MOVFF  8BF,8DB
140A2:  MOVLB  8
140A4:  CLRF   xDE
140A6:  MOVLW  64
140A8:  MOVWF  xDD
140AA:  MOVLB  0
140AC:  CALL   2CFC
140B0:  MOVFF  02,74D
140B4:  MOVFF  01,74C
....................                     macro_status = 'a'; 
140B8:  MOVLW  61
140BA:  MOVLB  8
140BC:  MOVWF  xC1
....................             break;    
140BE:  BRA    142A8
....................          case 'l' : LightTargetFlag = 1; 
140C0:  MOVLW  01
140C2:  MOVLB  2
140C4:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
140C6:  MOVFF  8BE,8C2
140CA:  MOVFF  8C0,8C4
140CE:  MOVFF  8BF,8C3
140D2:  MOVLB  0
140D4:  CALL   127DE
....................                     delay_ms(10000); 
140D8:  MOVLW  28
140DA:  MOVLB  8
140DC:  MOVWF  xC2
140DE:  MOVLW  FA
140E0:  MOVLB  9
140E2:  MOVWF  xEC
140E4:  MOVLB  0
140E6:  CALL   2938
140EA:  MOVLB  8
140EC:  DECFSZ xC2,F
140EE:  BRA    140DE
....................                     macro_status = 'a'; 
140F0:  MOVLW  61
140F2:  MOVWF  xC1
....................             break;        
140F4:  BRA    142A8
....................          case 'L' : LightTargetFlag = 0; 
140F6:  MOVLB  2
140F8:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
140FA:  MOVFF  8BE,8C2
140FE:  MOVFF  8C0,8C4
14102:  MOVFF  8BF,8C3
14106:  MOVLB  0
14108:  CALL   127DE
....................                     macro_status = 'a'; 
1410C:  MOVLW  61
1410E:  MOVLB  8
14110:  MOVWF  xC1
....................             break; 
14112:  BRA    142A8
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
14114:  MOVFF  8BE,47
....................                     arg = macro_arg; 
14118:  CLRF   4B
1411A:  CLRF   4A
1411C:  MOVFF  8C0,49
14120:  MOVFF  8BF,48
....................                     det_cmd(); 
14124:  CALL   F42A
....................                     macro_status = 'a'; 
14128:  MOVLW  61
1412A:  MOVLB  8
1412C:  MOVWF  xC1
....................             break ; 
1412E:  BRA    142A8
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
14130:  MOVLB  8
14132:  DECFSZ xBF,W
14134:  BRA    14142
14136:  MOVF   xC0,F
14138:  BNZ   14142
1413A:  MOVLB  0
1413C:  CALL   13886
14140:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14142:  MOVF   xBF,W
14144:  SUBLW  02
14146:  BNZ   14158
14148:  MOVF   xC0,F
1414A:  BNZ   14158
1414C:  MOVLW  01
1414E:  MOVWF  xC2
14150:  MOVWF  xC3
14152:  MOVLB  0
14154:  RCALL  13A52
14156:  MOVLB  8
....................                     macro_status = 'a'; 
14158:  MOVLW  61
1415A:  MOVWF  xC1
....................             break ;  
1415C:  BRA    142A8
....................          case 'T' : det_temp(); 
1415E:  RCALL  13C12
....................                     macro_status = 'a'; 
14160:  MOVLW  61
14162:  MOVLB  8
14164:  MOVWF  xC1
....................             break; 
14166:  BRA    142A8
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14168:  MOVLW  01
1416A:  MOVLB  7
1416C:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
1416E:  MOVLB  8
14170:  CLRF   xC7
14172:  CLRF   xC8
14174:  CLRF   xCC
14176:  CLRF   xCB
14178:  MOVFF  8C0,8CA
1417C:  MOVFF  8BF,8C9
14180:  MOVWF  xCD
14182:  MOVLB  0
14184:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14188:  CALL   D32A
1418C:  MOVFF  01,8C1
....................             break; 
14190:  MOVLB  8
14192:  BRA    142A8
....................          case '-' : motor=1; 
14194:  MOVLW  01
14196:  MOVLB  7
14198:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
1419A:  MOVLB  8
1419C:  CLRF   xC7
1419E:  MOVWF  xC8
141A0:  CLRF   xCC
141A2:  CLRF   xCB
141A4:  MOVFF  8C0,8CA
141A8:  MOVFF  8BF,8C9
141AC:  MOVWF  xCD
141AE:  MOVLB  0
141B0:  CALL   9DA0
....................                     macro_status=step_err_status(); 
141B4:  CALL   D32A
141B8:  MOVFF  01,8C1
....................             break; 
141BC:  MOVLB  8
141BE:  BRA    142A8
....................          case 'G' : motor=0; 
141C0:  MOVLB  7
141C2:  CLRF   x40
....................                     align(0); 
141C4:  MOVLB  8
141C6:  CLRF   xC2
141C8:  MOVLB  0
141CA:  CALL   A8DC
....................                     macro_status=step_err_status(); 
141CE:  CALL   D32A
141D2:  MOVFF  01,8C1
....................             break ;           
141D6:  MOVLB  8
141D8:  BRA    142A8
....................          case 'P' : motor=0; 
141DA:  MOVLB  7
141DC:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
141DE:  MOVLW  01
141E0:  MOVLB  8
141E2:  MOVWF  xC7
141E4:  CLRF   xC8
141E6:  CLRF   xCC
141E8:  CLRF   xCB
141EA:  MOVFF  8C0,8CA
141EE:  MOVFF  8BF,8C9
141F2:  MOVWF  xCD
141F4:  MOVLB  0
141F6:  CALL   9DA0
....................                     macro_status=step_err_status(); 
141FA:  CALL   D32A
141FE:  MOVFF  01,8C1
....................             break; 
14202:  MOVLB  8
14204:  BRA    142A8
....................          case 'Q' : motor=0; 
14206:  MOVLB  7
14208:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
1420A:  MOVLB  8
1420C:  CLRF   xC7
1420E:  CLRF   xC8
14210:  CLRF   xCC
14212:  CLRF   xCB
14214:  MOVFF  8C0,8CA
14218:  MOVFF  8BF,8C9
1421C:  MOVLW  01
1421E:  MOVWF  xCD
14220:  MOVLB  0
14222:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14226:  CALL   D32A
1422A:  MOVFF  01,8C1
....................             break; 
1422E:  MOVLB  8
14230:  BRA    142A8
....................          case 'R' : motor=0; 
14232:  MOVLB  7
14234:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
14236:  MOVLB  8
14238:  CLRF   xC7
1423A:  MOVLW  01
1423C:  MOVWF  xC8
1423E:  CLRF   xCC
14240:  CLRF   xCB
14242:  MOVFF  8C0,8CA
14246:  MOVFF  8BF,8C9
1424A:  MOVWF  xCD
1424C:  MOVLB  0
1424E:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14252:  CALL   D32A
14256:  MOVFF  01,8C1
....................             break; 
1425A:  MOVLB  8
1425C:  BRA    142A8
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
1425E:  MOVLB  8
14260:  DECFSZ xBF,W
14262:  BRA    14272
14264:  MOVF   xC0,F
14266:  BNZ   14272
14268:  MOVLB  0
1426A:  CALL   D398
1426E:  BRA    14280
14270:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14272:  MOVF   xBF,F
14274:  BNZ   14282
14276:  MOVF   xC0,F
14278:  BNZ   14282
1427A:  MOVLB  0
1427C:  CALL   D3BC
14280:  MOVLB  8
....................                     macro_status = 'a'; 
14282:  MOVLW  61
14284:  MOVWF  xC1
....................             break; 
14286:  BRA    142A8
....................          case 'v': 
....................             arg = macro_arg; 
14288:  CLRF   4B
1428A:  CLRF   4A
1428C:  MOVFF  8C0,49
14290:  MOVFF  8BF,48
....................             command_v(); 
14294:  RCALL  13DFE
....................             macro_status = 'a'; 
14296:  MOVLW  61
14298:  MOVLB  8
1429A:  MOVWF  xC1
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
1429C:  BRA    142A8
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
1429E:  MOVLW  66
142A0:  MOVLB  8
142A2:  MOVWF  xC1
....................             break ; 
142A4:  BRA    142A8
142A6:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
142A8:  MOVFF  8C1,01
142AC:  MOVLB  0
142AE:  GOTO   14BBA (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
14A16:  MOVLW  65
14A18:  MOVLB  8
14A1A:  MOVWF  xA7
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
14A1C:  BCF    FD8.0
14A1E:  RLCF   x9D,W
14A20:  CLRF   03
14A22:  ADDLW  D1
14A24:  MOVWF  FE9
14A26:  MOVLW  07
14A28:  ADDWFC 03,W
14A2A:  MOVWF  FEA
14A2C:  MOVFF  FEC,8B6
14A30:  MOVF   FED,F
14A32:  MOVFF  FEF,8B5
14A36:  MOVFF  89F,03
14A3A:  MOVFF  89E,FE9
14A3E:  MOVFF  89F,FEA
14A42:  MOVFF  FEC,A11
14A46:  MOVF   FED,F
14A48:  MOVFF  FEF,A10
14A4C:  MOVLB  A
14A4E:  CLRF   x13
14A50:  MOVLW  03
14A52:  MOVWF  x12
14A54:  MOVLB  0
14A56:  CALL   5CC0
14A5A:  MOVF   01,W
14A5C:  MOVLB  8
14A5E:  ADDWF  xB5,W
14A60:  MOVWF  xA2
14A62:  MOVF   02,W
14A64:  ADDWFC xB6,W
14A66:  MOVWF  xA3
....................  
....................    init_ext_eeprom(); 
14A68:  MOVLB  0
14A6A:  CALL   105F2
....................    macro_cmd = read_ext_eeprom(addr); 
14A6E:  MOVFF  8A3,8CC
14A72:  MOVFF  8A2,8CB
14A76:  CALL   1062A
14A7A:  MOVFF  01,8A4
....................    ++addr; 
14A7E:  MOVLB  8
14A80:  INCF   xA2,F
14A82:  BTFSC  FD8.2
14A84:  INCF   xA3,F
....................    if(macro_cmd == 'p'){ 
14A86:  MOVF   xA4,W
14A88:  SUBLW  70
14A8A:  BNZ   14AB0
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
14A8C:  MOVFF  89D,8B5
14A90:  MOVFF  89F,8B7
14A94:  MOVFF  89E,8B6
14A98:  MOVFF  858,8B9
14A9C:  MOVFF  857,8B8
14AA0:  MOVLB  0
14AA2:  CALL   10684
....................       count1++; 
14AA6:  MOVLB  8
14AA8:  INCF   x57,F
14AAA:  BTFSC  FD8.2
14AAC:  INCF   x58,F
....................    }else{ 
14AAE:  BRA    14AC8
....................    macro_arg = read16_ext_eeprom(addr); 
14AB0:  MOVFF  8A3,8C3
14AB4:  MOVFF  8A2,8C2
14AB8:  MOVLB  0
14ABA:  CALL   1073E
14ABE:  MOVFF  02,8A6
14AC2:  MOVFF  01,8A5
14AC6:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
14AC8:  MOVLW  01
14ACA:  MOVWF  xED
14ACC:  MOVLB  0
14ACE:  CALL   55AE
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
14AD2:  MOVF   2F,F
14AD4:  BTFSS  FD8.2
14AD6:  BRA    14F3C
14AD8:  MOVF   30,F
14ADA:  BTFSS  FD8.2
14ADC:  BRA    14F3C
....................       switch(macro_cmd){ 
14ADE:  MOVLW  2B
14AE0:  MOVLB  8
14AE2:  SUBWF  xA4,W
14AE4:  ADDLW  B4
14AE6:  BTFSC  FD8.0
14AE8:  BRA    14F38
14AEA:  ADDLW  4C
14AEC:  MOVLB  0
14AEE:  GOTO   15202
....................          case 'A' : 
....................             calc_abs_data(); 
14AF2:  CALL   125BC
....................             store_rel_data(); 
14AF6:  CALL   12620
....................             macro_status = 'a'; 
14AFA:  MOVLW  61
14AFC:  MOVLB  8
14AFE:  MOVWF  xA7
....................             break; 
14B00:  BRA    14F38
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
14B02:  MOVLW  08
14B04:  MOVWF  FEA
14B06:  MOVLW  25
14B08:  MOVWF  FE9
14B0A:  CALL   79BE
14B0E:  MOVLW  0D
14B10:  BTFSS  F9E.4
14B12:  BRA    14B10
14B14:  MOVWF  FAD
14B16:  MOVLW  0A
14B18:  BTFSS  F9E.4
14B1A:  BRA    14B18
14B1C:  MOVWF  FAD
....................             macro_status = 'a'; 
14B1E:  MOVLW  61
14B20:  MOVLB  8
14B22:  MOVWF  xA7
....................             break; 
14B24:  BRA    14F38
....................          case 'C' : 
....................             calc_abs_data(); 
14B26:  CALL   125BC
....................             break; 
14B2A:  MOVLB  8
14B2C:  BRA    14F38
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
14B2E:  MOVLB  8
14B30:  CLRF   xAB
14B32:  CLRF   xAA
14B34:  CLRF   xA9
14B36:  CLRF   xA8
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14B38:  MOVFF  89F,03
14B3C:  MOVFF  89E,FE9
14B40:  MOVFF  89F,FEA
14B44:  MOVLW  01
14B46:  ADDWF  FEE,F
14B48:  BNC   14B4C
14B4A:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
14B4C:  MOVFF  89E,FE9
14B50:  MOVFF  89F,FEA
14B54:  CLRF   xAF
14B56:  CLRF   xAE
14B58:  MOVFF  FEC,8AD
14B5C:  MOVF   FED,F
14B5E:  MOVFF  FEF,8AC
14B62:  CLRF   xB3
14B64:  CLRF   xB2
14B66:  CLRF   xB1
14B68:  CLRF   xB0
....................                    
....................                   while(count < macro_arg){ 
14B6A:  MOVF   xAB,F
14B6C:  BTFSS  FD8.2
14B6E:  BRA    14CAA
14B70:  MOVF   xAA,F
14B72:  BTFSS  FD8.2
14B74:  BRA    14CAA
14B76:  MOVF   xA9,W
14B78:  SUBWF  xA6,W
14B7A:  BTFSS  FD8.0
14B7C:  BRA    14CAA
14B7E:  BNZ   14B88
14B80:  MOVF   xA5,W
14B82:  SUBWF  xA8,W
14B84:  BTFSC  FD8.0
14B86:  BRA    14CAA
....................                      char curr = 'A'; 
14B88:  MOVLW  41
14B8A:  MOVWF  xB4
....................                      while(curr != '%'){ 
14B8C:  MOVF   xB4,W
14B8E:  SUBLW  25
14B90:  BZ    14BFC
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
14B92:  MOVFF  89F,03
14B96:  MOVFF  89E,FE9
14B9A:  MOVFF  89F,FEA
14B9E:  MOVFF  FEC,8B9
14BA2:  MOVF   FED,F
14BA4:  MOVFF  FEF,8B8
14BA8:  MOVFF  89D,8B7
14BAC:  MOVFF  8A1,8BB
14BB0:  MOVFF  8A0,8BA
14BB4:  MOVLB  0
14BB6:  GOTO   13F5A
....................                         (*line)++; 
14BBA:  MOVFF  89F,03
14BBE:  MOVLB  8
14BC0:  MOVF   x9E,W
14BC2:  MOVWF  FE9
14BC4:  MOVFF  03,FEA
14BC8:  MOVLW  01
14BCA:  ADDWF  FEE,F
14BCC:  BNC   14BD0
14BCE:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
14BD0:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
14BD2:  MOVFF  89F,03
14BD6:  MOVFF  89E,FE9
14BDA:  MOVFF  89F,FEA
14BDE:  MOVFF  FEC,8B9
14BE2:  MOVF   FED,F
14BE4:  MOVFF  FEF,8B8
14BE8:  MOVFF  89D,8B7
14BEC:  MOVLB  0
14BEE:  GOTO   1436A
14BF2:  MOVFF  01,8B4
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14BF6:  BSF    F91.5
14BF8:  MOVLB  8
14BFA:  BRA    14B8C
....................                      } 
....................                      end_line = (*line); 
14BFC:  MOVFF  89E,FE9
14C00:  MOVFF  89F,FEA
14C04:  CLRF   xB3
14C06:  CLRF   xB2
14C08:  MOVFF  FEC,8B1
14C0C:  MOVF   FED,F
14C0E:  MOVFF  FEF,8B0
....................                      count++; 
14C12:  MOVLW  01
14C14:  ADDWF  xA8,F
14C16:  BTFSC  FD8.0
14C18:  INCF   xA9,F
14C1A:  BTFSC  FD8.2
14C1C:  INCF   xAA,F
14C1E:  BTFSC  FD8.2
14C20:  INCF   xAB,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
14C22:  MOVF   xA8,W
14C24:  SUBWF  xA5,W
14C26:  MOVWF  xB5
14C28:  MOVF   xA9,W
14C2A:  SUBWFB xA6,W
14C2C:  MOVWF  xB6
14C2E:  MOVLW  00
14C30:  SUBFWB xAA,W
14C32:  MOVWF  xB7
14C34:  MOVLW  00
14C36:  SUBFWB xAB,W
14C38:  MOVWF  xB8
14C3A:  MOVLW  76
14C3C:  MOVWF  FF6
14C3E:  MOVLW  21
14C40:  MOVWF  FF7
14C42:  MOVLW  00
14C44:  MOVWF  FF8
14C46:  CLRF   1B
14C48:  BTFSC  FF2.7
14C4A:  BSF    1B.7
14C4C:  BCF    FF2.7
14C4E:  MOVLW  11
14C50:  MOVLB  A
14C52:  MOVWF  x40
14C54:  MOVLB  0
14C56:  CALL   1044
14C5A:  BTFSC  1B.7
14C5C:  BSF    FF2.7
14C5E:  MOVLW  41
14C60:  MOVWF  FE9
14C62:  CLRF   1B
14C64:  BTFSC  FF2.7
14C66:  BSF    1B.7
14C68:  BCF    FF2.7
14C6A:  MOVFF  8B8,A43
14C6E:  MOVFF  8B7,A42
14C72:  MOVFF  8B6,A41
14C76:  MOVFF  8B5,A40
14C7A:  CALL   110A
14C7E:  BTFSC  1B.7
14C80:  BSF    FF2.7
14C82:  MOVLW  0D
14C84:  BTFSS  F9E.4
14C86:  BRA    14C84
14C88:  MOVWF  FAD
14C8A:  MOVLW  0A
14C8C:  BTFSS  F9E.4
14C8E:  BRA    14C8C
14C90:  MOVWF  FAD
....................                      (*line) = start_line; 
14C92:  MOVFF  89F,03
14C96:  MOVLB  8
14C98:  MOVFF  89E,FE9
14C9C:  MOVFF  89F,FEA
14CA0:  MOVFF  8AC,FEF
14CA4:  MOVFF  8AD,FEC
14CA8:  BRA    14B6A
....................                   } 
....................                   (*line) = end_line + 1; 
14CAA:  MOVFF  89E,FE9
14CAE:  MOVFF  89F,FEA
14CB2:  MOVLW  01
14CB4:  ADDWF  xB0,W
14CB6:  MOVWF  FEF
14CB8:  MOVLW  00
14CBA:  ADDWFC xB1,W
14CBC:  MOVWF  FEC
....................                   macro_status = 'a'; 
14CBE:  MOVLW  61
14CC0:  MOVWF  xA7
....................             break; 
14CC2:  BRA    14F38
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
14CC4:  MOVFF  8A6,8C3
14CC8:  MOVFF  8A5,8C2
14CCC:  CALL   D362
....................                     macro_status = 'a'; 
14CD0:  MOVLW  61
14CD2:  MOVLB  8
14CD4:  MOVWF  xA7
....................             break; 
14CD6:  BRA    14F38
....................          case 'F' : macro_flag = macro_arg; 
14CD8:  MOVFF  8A6,324
14CDC:  MOVFF  8A5,323
....................                     macro_status = 'a'; 
14CE0:  MOVLW  61
14CE2:  MOVLB  8
14CE4:  MOVWF  xA7
....................             break ; 
14CE6:  BRA    14F38
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14CE8:  MOVFF  8A5,2D5
....................                     macro_status = 'a'; 
14CEC:  MOVLW  61
14CEE:  MOVLB  8
14CF0:  MOVWF  xA7
....................             break ; 
14CF2:  BRA    14F38
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14CF4:  MOVFF  8A4,8C2
14CF8:  MOVFF  8A6,8C4
14CFC:  MOVFF  8A5,8C3
14D00:  CALL   127A4
....................                     macro_status = 'a'; 
14D04:  MOVLW  61
14D06:  MOVLB  8
14D08:  MOVWF  xA7
....................             break; 
14D0A:  BRA    14F38
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14D0C:  MOVFF  8A4,8C2
14D10:  MOVFF  8A6,8C4
14D14:  MOVFF  8A5,8C3
14D18:  CALL   127A4
....................                     macro_status = 'a'; 
14D1C:  MOVLW  61
14D1E:  MOVLB  8
14D20:  MOVWF  xA7
....................             break; 
14D22:  BRA    14F38
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14D24:  MOVFF  8A6,8DC
14D28:  MOVFF  8A5,8DB
14D2C:  MOVLB  8
14D2E:  CLRF   xDE
14D30:  MOVLW  64
14D32:  MOVWF  xDD
14D34:  MOVLB  0
14D36:  CALL   2CFC
14D3A:  MOVFF  02,74D
14D3E:  MOVFF  01,74C
....................                     macro_status = 'a'; 
14D42:  MOVLW  61
14D44:  MOVLB  8
14D46:  MOVWF  xA7
....................             break;    
14D48:  BRA    14F38
....................          case 'l' : LightTargetFlag = 1; 
14D4A:  MOVLW  01
14D4C:  MOVLB  2
14D4E:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
14D50:  MOVFF  8A4,8C2
14D54:  MOVFF  8A6,8C4
14D58:  MOVFF  8A5,8C3
14D5C:  MOVLB  0
14D5E:  CALL   127DE
....................                     delay_ms(10000); 
14D62:  MOVLW  28
14D64:  MOVLB  8
14D66:  MOVWF  xB5
14D68:  MOVLW  FA
14D6A:  MOVLB  9
14D6C:  MOVWF  xEC
14D6E:  MOVLB  0
14D70:  CALL   2938
14D74:  MOVLB  8
14D76:  DECFSZ xB5,F
14D78:  BRA    14D68
....................                     macro_status = 'a'; 
14D7A:  MOVLW  61
14D7C:  MOVWF  xA7
....................             break;        
14D7E:  BRA    14F38
....................          case 'L' : LightTargetFlag = 0; 
14D80:  MOVLB  2
14D82:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
14D84:  MOVFF  8A4,8C2
14D88:  MOVFF  8A6,8C4
14D8C:  MOVFF  8A5,8C3
14D90:  MOVLB  0
14D92:  CALL   127DE
....................                     macro_status = 'a'; 
14D96:  MOVLW  61
14D98:  MOVLB  8
14D9A:  MOVWF  xA7
....................             break; 
14D9C:  BRA    14F38
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
14D9E:  MOVFF  8A4,47
....................                     arg = macro_arg; 
14DA2:  CLRF   4B
14DA4:  CLRF   4A
14DA6:  MOVFF  8A6,49
14DAA:  MOVFF  8A5,48
....................                     det_cmd(); 
14DAE:  CALL   F42A
....................                     macro_status = 'a'; 
14DB2:  MOVLW  61
14DB4:  MOVLB  8
14DB6:  MOVWF  xA7
....................             break ; 
14DB8:  BRA    14F38
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
14DBA:  MOVLB  8
14DBC:  DECFSZ xA5,W
14DBE:  BRA    14DCC
14DC0:  MOVF   xA6,F
14DC2:  BNZ   14DCC
14DC4:  MOVLB  0
14DC6:  CALL   13886
14DCA:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14DCC:  MOVF   xA5,W
14DCE:  SUBLW  02
14DD0:  BNZ   14DE4
14DD2:  MOVF   xA6,F
14DD4:  BNZ   14DE4
14DD6:  MOVLW  01
14DD8:  MOVWF  xC2
14DDA:  MOVWF  xC3
14DDC:  MOVLB  0
14DDE:  CALL   13A52
14DE2:  MOVLB  8
....................                     macro_status = 'a'; 
14DE4:  MOVLW  61
14DE6:  MOVWF  xA7
....................             break ;  
14DE8:  BRA    14F38
....................          case 'T' : det_temp(); 
14DEA:  CALL   13C12
....................                     macro_status = 'a'; 
14DEE:  MOVLW  61
14DF0:  MOVLB  8
14DF2:  MOVWF  xA7
....................             break; 
14DF4:  BRA    14F38
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14DF6:  MOVLW  01
14DF8:  MOVLB  7
14DFA:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14DFC:  MOVLB  8
14DFE:  CLRF   xC7
14E00:  CLRF   xC8
14E02:  CLRF   xCC
14E04:  CLRF   xCB
14E06:  MOVFF  8A6,8CA
14E0A:  MOVFF  8A5,8C9
14E0E:  MOVWF  xCD
14E10:  MOVLB  0
14E12:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14E16:  CALL   D32A
14E1A:  MOVFF  01,8A7
....................             break; 
14E1E:  MOVLB  8
14E20:  BRA    14F38
....................          case '-' : motor=1; 
14E22:  MOVLW  01
14E24:  MOVLB  7
14E26:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14E28:  MOVLB  8
14E2A:  CLRF   xC7
14E2C:  MOVWF  xC8
14E2E:  CLRF   xCC
14E30:  CLRF   xCB
14E32:  MOVFF  8A6,8CA
14E36:  MOVFF  8A5,8C9
14E3A:  MOVWF  xCD
14E3C:  MOVLB  0
14E3E:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14E42:  CALL   D32A
14E46:  MOVFF  01,8A7
....................             break; 
14E4A:  MOVLB  8
14E4C:  BRA    14F38
....................          case 'G' : motor=0; 
14E4E:  MOVLB  7
14E50:  CLRF   x40
....................                     align(0); 
14E52:  MOVLB  8
14E54:  CLRF   xC2
14E56:  MOVLB  0
14E58:  CALL   A8DC
....................                     macro_status=step_err_status(); 
14E5C:  CALL   D32A
14E60:  MOVFF  01,8A7
....................             break ;           
14E64:  MOVLB  8
14E66:  BRA    14F38
....................          case 'P' : motor=0; 
14E68:  MOVLB  7
14E6A:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
14E6C:  MOVLW  01
14E6E:  MOVLB  8
14E70:  MOVWF  xC7
14E72:  CLRF   xC8
14E74:  CLRF   xCC
14E76:  CLRF   xCB
14E78:  MOVFF  8A6,8CA
14E7C:  MOVFF  8A5,8C9
14E80:  MOVWF  xCD
14E82:  MOVLB  0
14E84:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14E88:  CALL   D32A
14E8C:  MOVFF  01,8A7
....................             break; 
14E90:  MOVLB  8
14E92:  BRA    14F38
....................          case 'Q' : motor=0; 
14E94:  MOVLB  7
14E96:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
14E98:  MOVLB  8
14E9A:  CLRF   xC7
14E9C:  CLRF   xC8
14E9E:  CLRF   xCC
14EA0:  CLRF   xCB
14EA2:  MOVFF  8A6,8CA
14EA6:  MOVFF  8A5,8C9
14EAA:  MOVLW  01
14EAC:  MOVWF  xCD
14EAE:  MOVLB  0
14EB0:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14EB4:  CALL   D32A
14EB8:  MOVFF  01,8A7
....................             break; 
14EBC:  MOVLB  8
14EBE:  BRA    14F38
....................          case 'R' : motor=0; 
14EC0:  MOVLB  7
14EC2:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
14EC4:  MOVLB  8
14EC6:  CLRF   xC7
14EC8:  MOVLW  01
14ECA:  MOVWF  xC8
14ECC:  CLRF   xCC
14ECE:  CLRF   xCB
14ED0:  MOVFF  8A6,8CA
14ED4:  MOVFF  8A5,8C9
14ED8:  MOVWF  xCD
14EDA:  MOVLB  0
14EDC:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14EE0:  CALL   D32A
14EE4:  MOVFF  01,8A7
....................             break; 
14EE8:  MOVLB  8
14EEA:  BRA    14F38
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14EEC:  MOVLB  8
14EEE:  DECFSZ xA5,W
14EF0:  BRA    14F00
14EF2:  MOVF   xA6,F
14EF4:  BNZ   14F00
14EF6:  MOVLB  0
14EF8:  CALL   D398
14EFC:  BRA    14F0E
14EFE:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14F00:  MOVF   xA5,F
14F02:  BNZ   14F10
14F04:  MOVF   xA6,F
14F06:  BNZ   14F10
14F08:  MOVLB  0
14F0A:  CALL   D3BC
14F0E:  MOVLB  8
....................                     macro_status = 'a'; 
14F10:  MOVLW  61
14F12:  MOVWF  xA7
....................             break; 
14F14:  BRA    14F38
....................          case 'v':  
....................             arg = macro_arg; 
14F16:  CLRF   4B
14F18:  CLRF   4A
14F1A:  MOVFF  8A6,49
14F1E:  MOVFF  8A5,48
....................             command_v(); 
14F22:  CALL   13DFE
....................             macro_status = 'a'; 
14F26:  MOVLW  61
14F28:  MOVLB  8
14F2A:  MOVWF  xA7
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
14F2C:  BRA    14F38
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14F2E:  MOVLW  66
14F30:  MOVLB  8
14F32:  MOVWF  xA7
....................             break ; 
14F34:  BRA    14F38
14F36:  MOVLB  8
....................       } 
....................    } 
14F38:  BRA    151F8
14F3A:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14F3C:  DECFSZ 2F,W
14F3E:  BRA    14F44
14F40:  MOVF   30,F
14F42:  BZ    14F52
14F44:  MOVF   2F,W
14F46:  SUBLW  03
14F48:  BTFSS  FD8.2
14F4A:  BRA    150D0
14F4C:  MOVF   30,F
14F4E:  BTFSS  FD8.2
14F50:  BRA    150D0
....................       switch(macro_cmd){ 
14F52:  MOVLB  8
14F54:  MOVF   xA4,W
14F56:  XORLW  2B
14F58:  MOVLB  0
14F5A:  BZ    14F88
14F5C:  XORLW  06
14F5E:  BZ    14FB2
14F60:  XORLW  6F
14F62:  BZ    14FDC
14F64:  XORLW  05
14F66:  BZ    14FEE
14F68:  XORLW  17
14F6A:  BZ    15006
14F6C:  XORLW  01
14F6E:  BZ    15030
14F70:  XORLW  03
14F72:  BZ    1505A
14F74:  XORLW  06
14F76:  BTFSC  FD8.2
14F78:  BRA    15084
14F7A:  XORLW  0D
14F7C:  BTFSC  FD8.2
14F7E:  BRA    1509A
14F80:  XORLW  62
14F82:  BTFSC  FD8.2
14F84:  BRA    150C6
14F86:  BRA    150CE
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14F88:  MOVLW  01
14F8A:  MOVLB  7
14F8C:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14F8E:  MOVLB  8
14F90:  CLRF   xC7
14F92:  CLRF   xC8
14F94:  CLRF   xCC
14F96:  CLRF   xCB
14F98:  MOVFF  8A6,8CA
14F9C:  MOVFF  8A5,8C9
14FA0:  MOVWF  xCD
14FA2:  MOVLB  0
14FA4:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14FA8:  CALL   D32A
14FAC:  MOVFF  01,8A7
....................             break; 
14FB0:  BRA    150CE
....................          case '-' : motor=1; 
14FB2:  MOVLW  01
14FB4:  MOVLB  7
14FB6:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14FB8:  MOVLB  8
14FBA:  CLRF   xC7
14FBC:  MOVWF  xC8
14FBE:  CLRF   xCC
14FC0:  CLRF   xCB
14FC2:  MOVFF  8A6,8CA
14FC6:  MOVFF  8A5,8C9
14FCA:  MOVWF  xCD
14FCC:  MOVLB  0
14FCE:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14FD2:  CALL   D32A
14FD6:  MOVFF  01,8A7
....................             break; 
14FDA:  BRA    150CE
....................          case 'B' : h_bridge(macro_arg); 
14FDC:  MOVFF  8A5,8B5
14FE0:  CALL   C278
....................                     macro_status = 'a'; 
14FE4:  MOVLW  61
14FE6:  MOVLB  8
14FE8:  MOVWF  xA7
....................             break;             
14FEA:  MOVLB  0
14FEC:  BRA    150CE
....................          case 'G' : motor=0; 
14FEE:  MOVLB  7
14FF0:  CLRF   x40
....................                     align(0); 
14FF2:  MOVLB  8
14FF4:  CLRF   xC2
14FF6:  MOVLB  0
14FF8:  CALL   A8DC
....................                     macro_status=step_err_status(); 
14FFC:  CALL   D32A
15000:  MOVFF  01,8A7
....................             break ;           
15004:  BRA    150CE
....................          case 'P' : motor=0; 
15006:  MOVLB  7
15008:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1);   
1500A:  MOVLB  8
1500C:  CLRF   xC7
1500E:  CLRF   xC8
15010:  CLRF   xCC
15012:  CLRF   xCB
15014:  MOVFF  8A1,8CA
15018:  MOVFF  8A0,8C9
1501C:  MOVLW  01
1501E:  MOVWF  xCD
15020:  MOVLB  0
15022:  CALL   9DA0
....................                     macro_status=step_err_status(); 
15026:  CALL   D32A
1502A:  MOVFF  01,8A7
....................             break; 
1502E:  BRA    150CE
....................          case 'Q' : motor=0; 
15030:  MOVLB  7
15032:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1); 
15034:  MOVLB  8
15036:  CLRF   xC7
15038:  CLRF   xC8
1503A:  CLRF   xCC
1503C:  CLRF   xCB
1503E:  MOVFF  8A1,8CA
15042:  MOVFF  8A0,8C9
15046:  MOVLW  01
15048:  MOVWF  xCD
1504A:  MOVLB  0
1504C:  CALL   9DA0
....................                     macro_status=step_err_status(); 
15050:  CALL   D32A
15054:  MOVFF  01,8A7
....................             break; 
15058:  BRA    150CE
....................          case 'R' : motor=0; 
1505A:  MOVLB  7
1505C:  CLRF   x40
....................                     move_motor(0,1,mmacro_var,1); 
1505E:  MOVLB  8
15060:  CLRF   xC7
15062:  MOVLW  01
15064:  MOVWF  xC8
15066:  CLRF   xCC
15068:  CLRF   xCB
1506A:  MOVFF  8A1,8CA
1506E:  MOVFF  8A0,8C9
15072:  MOVWF  xCD
15074:  MOVLB  0
15076:  CALL   9DA0
....................                     macro_status=step_err_status(); 
1507A:  CALL   D32A
1507E:  MOVFF  01,8A7
....................             break; 
15082:  BRA    150CE
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
15084:  MOVFF  8A6,8C3
15088:  MOVFF  8A5,8C2
1508C:  CALL   D362
....................                     macro_status = 'a'; 
15090:  MOVLW  61
15092:  MOVLB  8
15094:  MOVWF  xA7
....................             break; 
15096:  MOVLB  0
15098:  BRA    150CE
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
1509A:  MOVLB  8
1509C:  DECFSZ xA5,W
1509E:  BRA    150AE
150A0:  MOVF   xA6,F
150A2:  BNZ   150AE
150A4:  MOVLB  0
150A6:  CALL   D398
150AA:  BRA    150BC
150AC:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
150AE:  MOVF   xA5,F
150B0:  BNZ   150BE
150B2:  MOVF   xA6,F
150B4:  BNZ   150BE
150B6:  MOVLB  0
150B8:  CALL   D3BC
150BC:  MOVLB  8
....................                     macro_status = 'a'; 
150BE:  MOVLW  61
150C0:  MOVWF  xA7
....................             break; 
150C2:  MOVLB  0
150C4:  BRA    150CE
....................          case ';' : macro_status = 'f'; 
150C6:  MOVLW  66
150C8:  MOVLB  8
150CA:  MOVWF  xA7
....................             break;            
150CC:  MOVLB  0
....................       } 
....................    } 
150CE:  BRA    151F6
....................    else if (nv_product==AWS){ 
150D0:  MOVF   2F,W
150D2:  SUBLW  02
150D4:  BTFSS  FD8.2
150D6:  BRA    151F6
150D8:  MOVF   30,F
150DA:  BTFSS  FD8.2
150DC:  BRA    151F6
....................       switch(macro_cmd){ 
150DE:  MOVLB  8
150E0:  MOVF   xA4,W
150E2:  XORLW  2B
150E4:  MOVLB  0
150E6:  BZ    1510C
150E8:  XORLW  06
150EA:  BZ    15136
150EC:  XORLW  6E
150EE:  BZ    15160
150F0:  XORLW  07
150F2:  BZ    15172
150F4:  XORLW  14
150F6:  BZ    15188
150F8:  XORLW  01
150FA:  BZ    1519A
150FC:  XORLW  02
150FE:  BZ    151AC
15100:  XORLW  0A
15102:  BZ    151C2
15104:  XORLW  62
15106:  BTFSC  FD8.2
15108:  BRA    151EE
1510A:  BRA    151F6
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
1510C:  MOVLW  01
1510E:  MOVLB  7
15110:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
15112:  MOVLB  8
15114:  CLRF   xC7
15116:  CLRF   xC8
15118:  CLRF   xCC
1511A:  CLRF   xCB
1511C:  MOVFF  8A6,8CA
15120:  MOVFF  8A5,8C9
15124:  MOVWF  xCD
15126:  MOVLB  0
15128:  CALL   9DA0
....................                     macro_status=step_err_status(); 
1512C:  CALL   D32A
15130:  MOVFF  01,8A7
....................             break; 
15134:  BRA    151F6
....................          case '-' : motor=1; 
15136:  MOVLW  01
15138:  MOVLB  7
1513A:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
1513C:  MOVLB  8
1513E:  CLRF   xC7
15140:  MOVWF  xC8
15142:  CLRF   xCC
15144:  CLRF   xCB
15146:  MOVFF  8A6,8CA
1514A:  MOVFF  8A5,8C9
1514E:  MOVWF  xCD
15150:  MOVLB  0
15152:  CALL   9DA0
....................                     macro_status=step_err_status(); 
15156:  CALL   D32A
1515A:  MOVFF  01,8A7
....................             break; 
1515E:  BRA    151F6
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
15160:  MOVFF  8A5,8B6
15164:  CALL   DBDE
....................                     macro_status = 'a';  
15168:  MOVLW  61
1516A:  MOVLB  8
1516C:  MOVWF  xA7
....................             break;          
1516E:  MOVLB  0
15170:  BRA    151F6
....................          case 'D' : delay_sec(macro_arg); 
15172:  MOVFF  8A6,8C3
15176:  MOVFF  8A5,8C2
1517A:  CALL   D362
....................                     macro_status = 'a'; 
1517E:  MOVLW  61
15180:  MOVLB  8
15182:  MOVWF  xA7
....................             break; 
15184:  MOVLB  0
15186:  BRA    151F6
....................          case 'P' : sol_switch(mmacro_var); 
15188:  MOVFF  8A0,8B5
1518C:  CALL   1458E
....................                     macro_status = 'a'; 
15190:  MOVLW  61
15192:  MOVLB  8
15194:  MOVWF  xA7
....................             break;              
15196:  MOVLB  0
15198:  BRA    151F6
....................          case 'Q' : sol_switch(macro_arg); 
1519A:  MOVFF  8A5,8B5
1519E:  CALL   1458E
....................                     macro_status = 'a'; 
151A2:  MOVLW  61
151A4:  MOVLB  8
151A6:  MOVWF  xA7
....................             break;             
151A8:  MOVLB  0
151AA:  BRA    151F6
....................          case 'S' : sol_switch_cmd(macro_arg); 
151AC:  MOVFF  8A6,8B7
151B0:  MOVFF  8A5,8B6
151B4:  CALL   144D8
....................                     macro_status = 'a'; 
151B8:  MOVLW  61
151BA:  MOVLB  8
151BC:  MOVWF  xA7
....................             break; 
151BE:  MOVLB  0
151C0:  BRA    151F6
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
151C2:  MOVLB  8
151C4:  DECFSZ xA5,W
151C6:  BRA    151D6
151C8:  MOVF   xA6,F
151CA:  BNZ   151D6
151CC:  MOVLB  0
151CE:  CALL   D398
151D2:  BRA    151E4
151D4:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
151D6:  MOVF   xA5,F
151D8:  BNZ   151E6
151DA:  MOVF   xA6,F
151DC:  BNZ   151E6
151DE:  MOVLB  0
151E0:  CALL   D3BC
151E4:  MOVLB  8
....................                     macro_status = 'a'; 
151E6:  MOVLW  61
151E8:  MOVWF  xA7
....................             break;               
151EA:  MOVLB  0
151EC:  BRA    151F6
....................          case ';' : macro_status = 'f'; 
151EE:  MOVLW  66
151F0:  MOVLB  8
151F2:  MOVWF  xA7
....................             break;            
151F4:  MOVLB  0
151F6:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
151F8:  MOVFF  8A7,01
151FC:  MOVLB  0
151FE:  GOTO   15516 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
153E4:  MOVLB  8
153E6:  CLRF   x58
153E8:  CLRF   x57
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
153EA:  MOVLB  0
153EC:  CALL   510E
....................    clear_data_arrays(); 
153F0:  GOTO   1052C
....................     
....................    line = 0;  
153F4:  MOVLB  8
153F6:  CLRF   x9B
153F8:  CLRF   x9A
....................    macro_status = 'a'; 
153FA:  MOVLW  61
153FC:  MOVWF  x9C
....................    data_available = FALSE; 
153FE:  MOVLB  3
15400:  CLRF   x3B
....................    macro_flag = 900; 
15402:  MOVLW  03
15404:  MOVWF  x24
15406:  MOVLW  84
15408:  MOVWF  x23
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
1540A:  MOVLW  01
1540C:  MOVWF  1E
1540E:  MOVLW  A7
15410:  MOVWF  1D
15412:  MOVLW  8E
15414:  MOVWF  FF6
15416:  MOVLW  21
15418:  MOVWF  FF7
1541A:  MOVLW  00
1541C:  MOVWF  FF8
1541E:  MOVLW  07
15420:  MOVLB  8
15422:  MOVWF  xEB
15424:  MOVLB  0
15426:  CALL   AAF4
1542A:  MOVFF  897,8ED
1542E:  MOVLW  1B
15430:  MOVLB  8
15432:  MOVWF  xEE
15434:  MOVLB  0
15436:  CALL   52A8
1543A:  MOVLW  97
1543C:  MOVWF  FF6
1543E:  MOVLW  21
15440:  MOVWF  FF7
15442:  MOVLW  00
15444:  MOVWF  FF8
15446:  MOVLW  09
15448:  MOVLB  8
1544A:  MOVWF  xEB
1544C:  MOVLB  0
1544E:  CALL   AAF4
....................    record_event();    
15452:  CALL   8502
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
15456:  MOVLB  8
15458:  MOVF   x9B,W
1545A:  SUBLW  03
1545C:  BNC   1552E
1545E:  MOVF   x9C,W
15460:  SUBLW  61
15462:  BNZ   1552E
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
15464:  MOVF   1F,W
15466:  SUBLW  04
15468:  BNZ   154FC
1546A:  MOVF   20,F
1546C:  BNZ   154FC
....................                                                macro_status, (line + 1)); 
1546E:  MOVLW  01
15470:  ADDWF  x9A,W
15472:  MOVWF  x9D
15474:  MOVLW  00
15476:  ADDWFC x9B,W
15478:  MOVWF  x9E
1547A:  MOVLW  A2
1547C:  MOVWF  FF6
1547E:  MOVLW  21
15480:  MOVWF  FF7
15482:  MOVLW  00
15484:  MOVWF  FF8
15486:  CLRF   1B
15488:  BTFSC  FF2.7
1548A:  BSF    1B.7
1548C:  BCF    FF2.7
1548E:  MOVLW  05
15490:  MOVLB  A
15492:  MOVWF  x40
15494:  MOVLB  0
15496:  CALL   1044
1549A:  BTFSC  1B.7
1549C:  BSF    FF2.7
1549E:  MOVLB  8
154A0:  MOVF   x9C,W
154A2:  BTFSS  F9E.4
154A4:  BRA    154A2
154A6:  MOVWF  FAD
154A8:  MOVLW  5D
154AA:  BTFSS  F9E.4
154AC:  BRA    154AA
154AE:  MOVWF  FAD
154B0:  MOVLW  5B
154B2:  BTFSS  F9E.4
154B4:  BRA    154B2
154B6:  MOVWF  FAD
154B8:  MOVLW  10
154BA:  MOVWF  FE9
154BC:  CLRF   1B
154BE:  BTFSC  FF2.7
154C0:  BSF    1B.7
154C2:  BCF    FF2.7
154C4:  MOVFF  89E,A41
154C8:  MOVFF  89D,A40
154CC:  MOVLB  0
154CE:  CALL   11C6
154D2:  BTFSC  1B.7
154D4:  BSF    FF2.7
154D6:  MOVLW  AE
154D8:  MOVWF  FF6
154DA:  MOVLW  21
154DC:  MOVWF  FF7
154DE:  MOVLW  00
154E0:  MOVWF  FF8
154E2:  CLRF   1B
154E4:  BTFSC  FF2.7
154E6:  BSF    1B.7
154E8:  BCF    FF2.7
154EA:  MOVLW  03
154EC:  MOVLB  A
154EE:  MOVWF  x40
154F0:  MOVLB  0
154F2:  CALL   1044
154F6:  BTFSC  1B.7
154F8:  BSF    FF2.7
154FA:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
154FC:  MOVFF  897,89D
15500:  MOVLW  08
15502:  MOVWF  x9F
15504:  MOVLW  9A
15506:  MOVWF  x9E
15508:  MOVFF  899,8A1
1550C:  MOVFF  898,8A0
15510:  MOVLB  0
15512:  GOTO   14A16
15516:  MOVFF  01,89C
....................       ++line; 
1551A:  MOVLB  8
1551C:  INCF   x9A,F
1551E:  BTFSC  FD8.2
15520:  INCF   x9B,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
15522:  DECFSZ 50,W
15524:  BRA    1552C
....................          macro_status = 'g'; 
15526:  MOVLW  67
15528:  MOVWF  x9C
....................          break;    
1552A:  BRA    1552E
....................       } 
1552C:  BRA    15458
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
1552E:  MOVF   2F,W
15530:  MOVWF  00
15532:  MOVF   30,W
15534:  MOVWF  03
15536:  MOVF   03,W
15538:  BNZ   15544
1553A:  MOVLW  01
1553C:  SUBWF  00,W
1553E:  MOVLB  0
15540:  BZ    15562
15542:  MOVLB  8
15544:  MOVF   03,W
15546:  BNZ   15552
15548:  MOVLW  03
1554A:  SUBWF  00,W
1554C:  MOVLB  0
1554E:  BZ    15562
15550:  MOVLB  8
15552:  MOVF   03,W
15554:  BNZ   15560
15556:  MOVLW  02
15558:  SUBWF  00,W
1555A:  MOVLB  0
1555C:  BZ    1556E
1555E:  MOVLB  8
15560:  BRA    1557E
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
15562:  MOVFF  897,89D
15566:  CALL   D666
....................          break; 
1556A:  MOVLB  8
1556C:  BRA    1557E
....................       case AWS : store_aws_data(macro,mmacro_var); 
1556E:  MOVFF  897,89D
15572:  MOVFF  899,89F
15576:  MOVFF  898,89E
1557A:  BRA    152BA
....................          break; 
1557C:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
1557E:  MOVLW  61
15580:  SUBWF  x9C,W
15582:  ADDLW  F9
15584:  BC    15670
15586:  ADDLW  07
15588:  MOVLB  0
1558A:  GOTO   1571C
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
1558E:  MOVLW  B2
15590:  MOVWF  FF6
15592:  MOVLW  21
15594:  MOVWF  FF7
15596:  MOVLW  00
15598:  MOVWF  FF8
1559A:  CLRF   1B
1559C:  BTFSC  FF2.7
1559E:  BSF    1B.7
155A0:  BCF    FF2.7
155A2:  CALL   0E6E
155A6:  BTFSC  1B.7
155A8:  BSF    FF2.7
....................          break; 
155AA:  MOVLB  8
155AC:  BRA    15670
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
155AE:  MOVLW  BA
155B0:  MOVWF  FF6
155B2:  MOVLW  21
155B4:  MOVWF  FF7
155B6:  MOVLW  00
155B8:  MOVWF  FF8
155BA:  CLRF   1B
155BC:  BTFSC  FF2.7
155BE:  BSF    1B.7
155C0:  BCF    FF2.7
155C2:  CALL   0E6E
155C6:  BTFSC  1B.7
155C8:  BSF    FF2.7
....................          break; 
155CA:  MOVLB  8
155CC:  BRA    15670
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
155CE:  MOVLW  C2
155D0:  MOVWF  FF6
155D2:  MOVLW  21
155D4:  MOVWF  FF7
155D6:  MOVLW  00
155D8:  MOVWF  FF8
155DA:  CLRF   1B
155DC:  BTFSC  FF2.7
155DE:  BSF    1B.7
155E0:  BCF    FF2.7
155E2:  CALL   0E6E
155E6:  BTFSC  1B.7
155E8:  BSF    FF2.7
....................          break; 
155EA:  MOVLB  8
155EC:  BRA    15670
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
155EE:  MOVLW  CA
155F0:  MOVWF  FF6
155F2:  MOVLW  21
155F4:  MOVWF  FF7
155F6:  MOVLW  00
155F8:  MOVWF  FF8
155FA:  CLRF   1B
155FC:  BTFSC  FF2.7
155FE:  BSF    1B.7
15600:  BCF    FF2.7
15602:  CALL   0E6E
15606:  BTFSC  1B.7
15608:  BSF    FF2.7
....................          break; 
1560A:  MOVLB  8
1560C:  BRA    15670
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
1560E:  MOVLW  D2
15610:  MOVWF  FF6
15612:  MOVLW  21
15614:  MOVWF  FF7
15616:  MOVLW  00
15618:  MOVWF  FF8
1561A:  CLRF   1B
1561C:  BTFSC  FF2.7
1561E:  BSF    1B.7
15620:  BCF    FF2.7
15622:  CALL   0E6E
15626:  BTFSC  1B.7
15628:  BSF    FF2.7
....................          break;    
1562A:  MOVLB  8
1562C:  BRA    15670
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
1562E:  MOVLW  DA
15630:  MOVWF  FF6
15632:  MOVLW  21
15634:  MOVWF  FF7
15636:  MOVLW  00
15638:  MOVWF  FF8
1563A:  CLRF   1B
1563C:  BTFSC  FF2.7
1563E:  BSF    1B.7
15640:  BCF    FF2.7
15642:  CALL   0E6E
15646:  BTFSC  1B.7
15648:  BSF    FF2.7
....................          break;    
1564A:  MOVLB  8
1564C:  BRA    15670
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
1564E:  MOVLW  E2
15650:  MOVWF  FF6
15652:  MOVLW  21
15654:  MOVWF  FF7
15656:  MOVLW  00
15658:  MOVWF  FF8
1565A:  CLRF   1B
1565C:  BTFSC  FF2.7
1565E:  BSF    1B.7
15660:  BCF    FF2.7
15662:  CALL   0E6E
15666:  BTFSC  1B.7
15668:  BSF    FF2.7
....................          break;           
1566A:  MOVLB  8
1566C:  BRA    15670
1566E:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
15670:  MOVLW  01
15672:  MOVWF  1E
15674:  MOVLW  A7
15676:  MOVWF  1D
15678:  MOVLW  EA
1567A:  MOVWF  FF6
1567C:  MOVLW  21
1567E:  MOVWF  FF7
15680:  MOVLW  00
15682:  MOVWF  FF8
15684:  MOVLW  07
15686:  MOVWF  xEB
15688:  MOVLB  0
1568A:  CALL   AAF4
1568E:  MOVFF  897,8ED
15692:  MOVLW  1B
15694:  MOVLB  8
15696:  MOVWF  xEE
15698:  MOVLB  0
1569A:  CALL   52A8
1569E:  MOVLW  F3
156A0:  MOVWF  FF6
156A2:  MOVLW  21
156A4:  MOVWF  FF7
156A6:  MOVLW  00
156A8:  MOVWF  FF8
156AA:  MOVLW  09
156AC:  MOVLB  8
156AE:  MOVWF  xEB
156B0:  MOVLB  0
156B2:  CALL   AAF4
156B6:  MOVFF  89C,8FF
156BA:  CALL   50C6
156BE:  MOVLW  FE
156C0:  MOVWF  FF6
156C2:  MOVLW  21
156C4:  MOVWF  FF7
156C6:  MOVLW  00
156C8:  MOVWF  FF8
156CA:  MOVLW  07
156CC:  MOVLB  8
156CE:  MOVWF  xEB
156D0:  MOVLB  0
156D2:  CALL   AAF4
156D6:  MOVLW  10
156D8:  MOVWF  FE9
156DA:  MOVFF  89B,8F7
156DE:  MOVFF  89A,8F6
156E2:  CALL   AB26
156E6:  MOVLW  08
156E8:  MOVWF  FF6
156EA:  MOVLW  22
156EC:  MOVWF  FF7
156EE:  MOVLW  00
156F0:  MOVWF  FF8
156F2:  MOVLW  03
156F4:  MOVLB  8
156F6:  MOVWF  xEB
156F8:  MOVLB  0
156FA:  CALL   AAF4
....................    record_event(); 
156FE:  CALL   8502
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
15702:  MOVLB  8
15704:  MOVF   x9C,W
15706:  SUBLW  66
15708:  BZ    15718
1570A:  MOVF   x9C,W
1570C:  SUBLW  67
1570E:  BZ    15718
15710:  MOVLB  0
15712:  CALL   AA80
15716:  MOVLB  8
15718:  MOVLB  0
1571A:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15FCA:  MOVLW  01
15FCC:  MOVLB  8
15FCE:  MOVWF  x8F
....................    while (macro_batch == TRUE){ 
15FD0:  DECFSZ x8F,W
15FD2:  BRA    16258
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15FD4:  MOVFF  38,A11
15FD8:  MOVFF  37,A10
15FDC:  MOVLB  A
15FDE:  CLRF   x13
15FE0:  MOVLW  03
15FE2:  MOVWF  x12
15FE4:  MOVLB  0
15FE6:  CALL   5CC0
15FEA:  MOVF   01,W
15FEC:  MOVLB  7
15FEE:  ADDWF  xD1,W
15FF0:  MOVLB  8
15FF2:  MOVWF  x8A
15FF4:  MOVF   02,W
15FF6:  MOVLB  7
15FF8:  ADDWFC xD2,W
15FFA:  MOVLB  8
15FFC:  MOVWF  x8B
....................       init_ext_eeprom(); 
15FFE:  MOVLB  0
16000:  CALL   105F2
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
16004:  MOVFF  88B,8CC
16008:  MOVFF  88A,8CB
1600C:  CALL   1062A
16010:  MOVFF  01,88C
....................       ++addr; 
16014:  MOVLB  8
16016:  INCF   x8A,F
16018:  BTFSC  FD8.2
1601A:  INCF   x8B,F
....................       macro_arg = read16_ext_eeprom(addr); 
1601C:  MOVFF  88B,8C3
16020:  MOVFF  88A,8C2
16024:  MOVLB  0
16026:  CALL   1073E
1602A:  MOVFF  02,88E
1602E:  MOVFF  01,88D
....................       ++addr; 
16032:  MOVLB  8
16034:  INCF   x8A,F
16036:  BTFSC  FD8.2
16038:  INCF   x8B,F
....................       ++addr;      
1603A:  INCF   x8A,F
1603C:  BTFSC  FD8.2
1603E:  INCF   x8B,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
16040:  MOVF   x8C,W
16042:  SUBLW  4D
16044:  BTFSS  FD8.2
16046:  BRA    16170
16048:  MOVF   x8D,F
1604A:  BNZ   16052
1604C:  MOVF   x8E,F
1604E:  BTFSC  FD8.2
16050:  BRA    16170
....................          { 
....................          RTC_reset_HT(); 
16052:  MOVLB  0
16054:  CALL   34DA
....................          RTC_read(); 
16058:  CALL   336C
....................          RTC_display(); 
1605C:  CALL   E2B2
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
16060:  MOVLW  0C
16062:  MOVWF  FF6
16064:  MOVLW  22
16066:  MOVWF  FF7
16068:  MOVLW  00
1606A:  MOVWF  FF8
1606C:  CLRF   1B
1606E:  BTFSC  FF2.7
16070:  BSF    1B.7
16072:  BCF    FF2.7
16074:  MOVLW  09
16076:  MOVLB  A
16078:  MOVWF  x40
1607A:  MOVLB  0
1607C:  CALL   1044
16080:  BTFSC  1B.7
16082:  BSF    FF2.7
16084:  MOVLB  8
16086:  MOVF   x8C,W
16088:  BTFSS  F9E.4
1608A:  BRA    16088
1608C:  MOVWF  FAD
1608E:  MOVLW  10
16090:  MOVWF  FE9
16092:  CLRF   1B
16094:  BTFSC  FF2.7
16096:  BSF    1B.7
16098:  BCF    FF2.7
1609A:  MOVFF  88E,A41
1609E:  MOVFF  88D,A40
160A2:  MOVLB  0
160A4:  CALL   11C6
160A8:  BTFSC  1B.7
160AA:  BSF    FF2.7
160AC:  MOVLW  1A
160AE:  MOVWF  FF6
160B0:  MOVLW  22
160B2:  MOVWF  FF7
160B4:  MOVLW  00
160B6:  MOVWF  FF8
160B8:  CLRF   1B
160BA:  BTFSC  FF2.7
160BC:  BSF    1B.7
160BE:  BCF    FF2.7
160C0:  MOVLW  03
160C2:  MOVLB  A
160C4:  MOVWF  x40
160C6:  MOVLB  0
160C8:  CALL   1044
160CC:  BTFSC  1B.7
160CE:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
160D0:  MOVLW  01
160D2:  ADDWF  21,W
160D4:  MOVLB  8
160D6:  MOVWF  x90
160D8:  MOVLW  00
160DA:  ADDWFC 22,W
160DC:  MOVWF  x91
160DE:  MOVLW  1E
160E0:  MOVWF  FF6
160E2:  MOVLW  22
160E4:  MOVWF  FF7
160E6:  MOVLW  00
160E8:  MOVWF  FF8
160EA:  CLRF   1B
160EC:  BTFSC  FF2.7
160EE:  BSF    1B.7
160F0:  BCF    FF2.7
160F2:  MOVLW  07
160F4:  MOVLB  A
160F6:  MOVWF  x40
160F8:  MOVLB  0
160FA:  CALL   1044
160FE:  BTFSC  1B.7
16100:  BSF    FF2.7
16102:  MOVLW  09
16104:  MOVWF  FE9
16106:  CLRF   1B
16108:  BTFSC  FF2.7
1610A:  BSF    1B.7
1610C:  BCF    FF2.7
1610E:  MOVFF  891,A41
16112:  MOVFF  890,A40
16116:  CALL   11C6
1611A:  BTFSC  1B.7
1611C:  BSF    FF2.7
1611E:  MOVLW  2A
16120:  MOVWF  FF6
16122:  MOVLW  22
16124:  MOVWF  FF7
16126:  MOVLW  00
16128:  MOVWF  FF8
1612A:  CLRF   1B
1612C:  BTFSC  FF2.7
1612E:  BSF    1B.7
16130:  BCF    FF2.7
16132:  MOVLW  04
16134:  MOVLB  A
16136:  MOVWF  x40
16138:  MOVLB  0
1613A:  CALL   1044
1613E:  BTFSC  1B.7
16140:  BSF    FF2.7
16142:  MOVLW  09
16144:  MOVWF  FE9
16146:  CLRF   1B
16148:  BTFSC  FF2.7
1614A:  BSF    1B.7
1614C:  BCF    FF2.7
1614E:  MOVFF  28,A41
16152:  MOVFF  27,A40
16156:  CALL   11C6
1615A:  BTFSC  1B.7
1615C:  BSF    FF2.7
1615E:  MOVLW  0D
16160:  BTFSS  F9E.4
16162:  BRA    16160
16164:  MOVWF  FAD
16166:  MOVLW  0A
16168:  BTFSS  F9E.4
1616A:  BRA    16168
1616C:  MOVWF  FAD
1616E:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
16170:  MOVF   28,W
16172:  SUBWF  22,W
16174:  BNC   16182
16176:  BNZ   1617E
16178:  MOVF   27,W
1617A:  SUBWF  21,W
1617C:  BNC   16182
....................          {macro_cmd = 'Z';} 
1617E:  MOVLW  5A
16180:  MOVWF  x8C
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
16182:  MOVF   x8C,W
16184:  XORLW  72
16186:  MOVLB  0
16188:  BZ    1619C
1618A:  XORLW  57
1618C:  BZ    161BE
1618E:  XORLW  68
16190:  BZ    161F4
16192:  XORLW  17
16194:  BZ    1622A
16196:  XORLW  61
16198:  BZ    16236
1619A:  BRA    16240
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
1619C:  INCF   37,F
1619E:  BTFSC  FD8.2
161A0:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
161A2:  MOVLB  8
161A4:  CLRF   x60
161A6:  CLRF   x5F
161A8:  MOVFF  38,85E
161AC:  MOVFF  37,85D
....................                master_macro_loop_count = macro_arg; 
161B0:  CLRF   x5C
161B2:  CLRF   x5B
161B4:  MOVFF  88E,85A
161B8:  MOVFF  88D,859
....................             break; 
161BC:  BRA    1624C
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
161BE:  MOVLB  8
161C0:  MOVF   x5C,F
161C2:  BNZ   161D2
161C4:  MOVF   x5B,F
161C6:  BNZ   161D2
161C8:  MOVF   x5A,F
161CA:  BNZ   161D2
161CC:  MOVF   x59,W
161CE:  SUBLW  01
161D0:  BC    161EC
....................                   nv_macro_step = master_macro_loop_start; 
161D2:  MOVFF  85E,38
161D6:  MOVFF  85D,37
....................                   master_macro_loop_count--; 
161DA:  MOVLW  FF
161DC:  ADDWF  x59,F
161DE:  BTFSS  FD8.0
161E0:  ADDWF  x5A,F
161E2:  BTFSS  FD8.0
161E4:  ADDWF  x5B,F
161E6:  BTFSS  FD8.0
161E8:  ADDWF  x5C,F
....................                }else{ 
161EA:  BRA    161F2
....................                   nv_macro_step++; 
161EC:  INCF   37,F
161EE:  BTFSC  FD8.2
161F0:  INCF   38,F
....................                } 
....................             break; 
161F2:  BRA    1624C
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
161F4:  MOVLB  8
161F6:  MOVF   x8E,F
161F8:  BNZ   16228
161FA:  MOVF   x8D,W
161FC:  SUBLW  14
161FE:  BNC   16228
....................                   play_macro(macro_arg,0);     // casts to int8 
16200:  MOVFF  88D,897
16204:  CLRF   x99
16206:  CLRF   x98
16208:  MOVLB  0
1620A:  CALL   153E4
....................                   delay_ms(100); 
1620E:  MOVLW  64
16210:  MOVLB  9
16212:  MOVWF  xEC
16214:  MOVLB  0
16216:  CALL   2938
....................                   ++nv_sample; 
1621A:  INCF   21,F
1621C:  BTFSC  FD8.2
1621E:  INCF   22,F
....................                   ++nv_macro_step; 
16220:  INCF   37,F
16222:  BTFSC  FD8.2
16224:  INCF   38,F
16226:  MOVLB  8
....................                } 
....................                break; 
16228:  BRA    1624C
....................             case 'Z' : ++nv_macro_step; 
1622A:  INCF   37,F
1622C:  BTFSC  FD8.2
1622E:  INCF   38,F
....................                        macro_batch = FALSE; 
16230:  MOVLB  8
16232:  CLRF   x8F
....................                break; 
16234:  BRA    1624C
....................             case ';' : nv_macro_step = 0; 
16236:  CLRF   38
16238:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
1623A:  MOVLB  8
1623C:  BRA    1624C
1623E:  MOVLB  0
....................             default  : cmd_err(); 
16240:  CALL   BFE8
....................                        macro_cmd = 'e'; 
16244:  MOVLW  65
16246:  MOVLB  8
16248:  MOVWF  x8C
....................                        macro_batch = FALSE; 
1624A:  CLRF   x8F
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
1624C:  DECFSZ 50,W
1624E:  BRA    16256
....................             macro_cmd = ';'; 
16250:  MOVLW  3B
16252:  MOVWF  x8C
....................             break;         // 17 = CTRL-Q (quit) 
16254:  BRA    16258
....................          } 
16256:  BRA    15FD0
....................    } 
....................    return (macro_cmd); 
16258:  MOVFF  88C,01
1625C:  MOVLB  0
1625E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D3D2:  MOVLB  8
0D3D4:  MOVF   x8C,W
0D3D6:  XORLW  2B
0D3D8:  MOVLB  0
0D3DA:  BZ    D40A
0D3DC:  XORLW  06
0D3DE:  BZ    D432
0D3E0:  XORLW  6F
0D3E2:  BZ    D45A
0D3E4:  XORLW  05
0D3E6:  BZ    D46C
0D3E8:  XORLW  17
0D3EA:  BZ    D482
0D3EC:  XORLW  01
0D3EE:  BZ    D4B2
0D3F0:  XORLW  03
0D3F2:  BTFSC  FD8.2
0D3F4:  BRA    D4DA
0D3F6:  XORLW  06
0D3F8:  BTFSC  FD8.2
0D3FA:  BRA    D502
0D3FC:  XORLW  0D
0D3FE:  BTFSC  FD8.2
0D400:  BRA    D516
0D402:  XORLW  62
0D404:  BTFSC  FD8.2
0D406:  BRA    D53E
0D408:  BRA    D546
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D40A:  MOVLW  01
0D40C:  MOVLB  7
0D40E:  MOVWF  x40
....................                  move_motor(0,0,macro_arg,1); 
0D410:  MOVLB  8
0D412:  CLRF   xC7
0D414:  CLRF   xC8
0D416:  CLRF   xCC
0D418:  CLRF   xCB
0D41A:  MOVFF  88E,8CA
0D41E:  MOVFF  88D,8C9
0D422:  MOVWF  xCD
0D424:  MOVLB  0
0D426:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D42A:  RCALL  D32A
0D42C:  MOVFF  01,88F
....................          break; 
0D430:  BRA    D546
....................       case '-' : motor=1; 
0D432:  MOVLW  01
0D434:  MOVLB  7
0D436:  MOVWF  x40
....................                  move_motor(0,1,macro_arg,1); 
0D438:  MOVLB  8
0D43A:  CLRF   xC7
0D43C:  MOVWF  xC8
0D43E:  CLRF   xCC
0D440:  CLRF   xCB
0D442:  MOVFF  88E,8CA
0D446:  MOVFF  88D,8C9
0D44A:  MOVWF  xCD
0D44C:  MOVLB  0
0D44E:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D452:  RCALL  D32A
0D454:  MOVFF  01,88F
....................          break; 
0D458:  BRA    D546
....................       case 'B' : h_bridge(macro_arg); 
0D45A:  MOVFF  88D,8B5
0D45E:  CALL   C278
....................                  macro_status = 'a'; 
0D462:  MOVLW  61
0D464:  MOVLB  8
0D466:  MOVWF  x8F
....................          break; 
0D468:  MOVLB  0
0D46A:  BRA    D546
....................       case 'G' : motor=0; 
0D46C:  MOVLB  7
0D46E:  CLRF   x40
....................                  align(0); 
0D470:  MOVLB  8
0D472:  CLRF   xC2
0D474:  MOVLB  0
0D476:  CALL   A8DC
....................                  macro_status=step_err_status(); 
0D47A:  RCALL  D32A
0D47C:  MOVFF  01,88F
....................          break ;           
0D480:  BRA    D546
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D482:  MOVFF  88E,2E
0D486:  MOVFF  88D,2D
....................                  motor=0; 
0D48A:  MOVLB  7
0D48C:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1);   
0D48E:  MOVLB  8
0D490:  CLRF   xC7
0D492:  CLRF   xC8
0D494:  CLRF   xCC
0D496:  CLRF   xCB
0D498:  MOVFF  88E,8CA
0D49C:  MOVFF  88D,8C9
0D4A0:  MOVLW  01
0D4A2:  MOVWF  xCD
0D4A4:  MOVLB  0
0D4A6:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D4AA:  RCALL  D32A
0D4AC:  MOVFF  01,88F
....................          break; 
0D4B0:  BRA    D546
....................       case 'Q' : motor=0; 
0D4B2:  MOVLB  7
0D4B4:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1); 
0D4B6:  MOVLB  8
0D4B8:  CLRF   xC7
0D4BA:  CLRF   xC8
0D4BC:  CLRF   xCC
0D4BE:  CLRF   xCB
0D4C0:  MOVFF  88E,8CA
0D4C4:  MOVFF  88D,8C9
0D4C8:  MOVLW  01
0D4CA:  MOVWF  xCD
0D4CC:  MOVLB  0
0D4CE:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D4D2:  RCALL  D32A
0D4D4:  MOVFF  01,88F
....................          break; 
0D4D8:  BRA    D546
....................       case 'R' : motor=0; 
0D4DA:  MOVLB  7
0D4DC:  CLRF   x40
....................                  move_motor(0,1,macro_arg,1); 
0D4DE:  MOVLB  8
0D4E0:  CLRF   xC7
0D4E2:  MOVLW  01
0D4E4:  MOVWF  xC8
0D4E6:  CLRF   xCC
0D4E8:  CLRF   xCB
0D4EA:  MOVFF  88E,8CA
0D4EE:  MOVFF  88D,8C9
0D4F2:  MOVWF  xCD
0D4F4:  MOVLB  0
0D4F6:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D4FA:  RCALL  D32A
0D4FC:  MOVFF  01,88F
....................          break; 
0D500:  BRA    D546
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D502:  MOVFF  88E,8C3
0D506:  MOVFF  88D,8C2
0D50A:  RCALL  D362
....................                  macro_status = 'a'; 
0D50C:  MOVLW  61
0D50E:  MOVLB  8
0D510:  MOVWF  x8F
....................          break; 
0D512:  MOVLB  0
0D514:  BRA    D546
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D516:  MOVLB  8
0D518:  DECFSZ x8D,W
0D51A:  BRA    D528
0D51C:  MOVF   x8E,F
0D51E:  BNZ   D528
0D520:  MOVLB  0
0D522:  RCALL  D398
0D524:  BRA    D534
0D526:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D528:  MOVF   x8D,F
0D52A:  BNZ   D536
0D52C:  MOVF   x8E,F
0D52E:  BNZ   D536
0D530:  MOVLB  0
0D532:  RCALL  D3BC
0D534:  MOVLB  8
....................                  macro_status = 'a'; 
0D536:  MOVLW  61
0D538:  MOVWF  x8F
....................          break;           
0D53A:  MOVLB  0
0D53C:  BRA    D546
....................       case ';' : macro_status = 'f'; 
0D53E:  MOVLW  66
0D540:  MOVLB  8
0D542:  MOVWF  x8F
....................          break;            
0D544:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D546:  MOVLB  8
0D548:  MOVFF  88F,01
0D54C:  MOVLB  0
0D54E:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D828:  MOVF   2E,F
0D82A:  BNZ   D832
0D82C:  MOVF   2D,W
0D82E:  SUBLW  01
0D830:  BC    D844
0D832:  MOVF   2E,F
0D834:  BNZ   D844
0D836:  MOVF   2D,W
0D838:  SUBLW  30
0D83A:  BNC   D844
0D83C:  DECFSZ 2F,W
0D83E:  BRA    D844
0D840:  MOVF   30,F
0D842:  BZ    D862
0D844:  MOVF   2E,F
0D846:  BNZ   D84E
0D848:  MOVF   2D,W
0D84A:  SUBLW  01
0D84C:  BC    D86C
0D84E:  MOVF   2E,F
0D850:  BNZ   D86C
0D852:  MOVF   2D,W
0D854:  SUBLW  32
0D856:  BNC   D86C
0D858:  MOVF   2F,W
0D85A:  SUBLW  03
0D85C:  BNZ   D86C
0D85E:  MOVF   30,F
0D860:  BNZ   D86C
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D862:  MOVLW  61
0D864:  MOVLB  8
0D866:  MOVWF  x8B
....................    } 
0D868:  BRA    D874
0D86A:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D86C:  MOVLW  65
0D86E:  MOVLB  8
0D870:  MOVWF  x8B
....................       goto end_macro;       
0D872:  BRA    D924
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D874:  MOVLW  59
0D876:  MOVWF  x8C
0D878:  CLRF   x8E
0D87A:  MOVLW  01
0D87C:  MOVWF  x8D
0D87E:  MOVLB  0
0D880:  RCALL  D3D2
0D882:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D886:  MOVLB  8
0D888:  MOVF   x8B,W
0D88A:  SUBLW  61
0D88C:  BTFSS  FD8.2
0D88E:  BRA    D924
....................    macro_status = play_wms_macro_cmd('G',1); 
0D890:  MOVLW  47
0D892:  MOVWF  x8C
0D894:  CLRF   x8E
0D896:  MOVLW  01
0D898:  MOVWF  x8D
0D89A:  MOVLB  0
0D89C:  RCALL  D3D2
0D89E:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8A2:  MOVLB  8
0D8A4:  MOVF   x8B,W
0D8A6:  SUBLW  61
0D8A8:  BTFSS  FD8.2
0D8AA:  BRA    D924
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D8AC:  MOVLW  2D
0D8AE:  MOVWF  x8C
0D8B0:  MOVFF  2C,88E
0D8B4:  MOVFF  2B,88D
0D8B8:  MOVLB  0
0D8BA:  RCALL  D3D2
0D8BC:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8C0:  MOVLB  8
0D8C2:  MOVF   x8B,W
0D8C4:  SUBLW  61
0D8C6:  BTFSS  FD8.2
0D8C8:  BRA    D924
....................    macro_status = play_wms_macro_cmd('P',port); 
0D8CA:  MOVLW  50
0D8CC:  MOVWF  x8C
0D8CE:  MOVFF  88A,88E
0D8D2:  MOVFF  889,88D
0D8D6:  MOVLB  0
0D8D8:  RCALL  D3D2
0D8DA:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro;    
0D8DE:  MOVLB  8
0D8E0:  MOVF   x8B,W
0D8E2:  SUBLW  61
0D8E4:  BTFSS  FD8.2
0D8E6:  BRA    D924
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D8E8:  MOVLW  2B
0D8EA:  MOVWF  x8C
0D8EC:  MOVFF  2C,88E
0D8F0:  MOVFF  2B,88D
0D8F4:  MOVLB  0
0D8F6:  RCALL  D3D2
0D8F8:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8FC:  MOVLB  8
0D8FE:  MOVF   x8B,W
0D900:  SUBLW  61
0D902:  BTFSS  FD8.2
0D904:  BRA    D924
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D906:  MOVLW  59
0D908:  MOVWF  x8C
0D90A:  CLRF   x8E
0D90C:  CLRF   x8D
0D90E:  MOVLB  0
0D910:  RCALL  D3D2
0D912:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D916:  MOVLB  8
0D918:  MOVF   x8B,W
0D91A:  SUBLW  61
0D91C:  BTFSS  FD8.2
0D91E:  BRA    D924
....................    macro_status='f';  
0D920:  MOVLW  66
0D922:  MOVWF  x8B
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D924:  CLRF   x9D
0D926:  MOVLB  0
0D928:  RCALL  D666
....................    
....................    switch(macro_status){ 
0D92A:  MOVLW  61
0D92C:  MOVLB  8
0D92E:  SUBWF  x8B,W
0D930:  ADDLW  FA
0D932:  BC    DA06
0D934:  ADDLW  06
0D936:  MOVLB  0
0D938:  GOTO   DA0A
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D93C:  MOVF   1F,F
0D93E:  BNZ   D944
0D940:  MOVF   20,F
0D942:  BZ    D960
0D944:  MOVLW  36
0D946:  MOVWF  FF6
0D948:  MOVLW  22
0D94A:  MOVWF  FF7
0D94C:  MOVLW  00
0D94E:  MOVWF  FF8
0D950:  CLRF   1B
0D952:  BTFSC  FF2.7
0D954:  BSF    1B.7
0D956:  BCF    FF2.7
0D958:  CALL   0E6E
0D95C:  BTFSC  1B.7
0D95E:  BSF    FF2.7
....................          break; 
0D960:  MOVLB  8
0D962:  BRA    DA06
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D964:  MOVLW  3E
0D966:  MOVWF  FF6
0D968:  MOVLW  22
0D96A:  MOVWF  FF7
0D96C:  MOVLW  00
0D96E:  MOVWF  FF8
0D970:  CLRF   1B
0D972:  BTFSC  FF2.7
0D974:  BSF    1B.7
0D976:  BCF    FF2.7
0D978:  CALL   0E6E
0D97C:  BTFSC  1B.7
0D97E:  BSF    FF2.7
....................          break; 
0D980:  MOVLB  8
0D982:  BRA    DA06
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D984:  MOVLW  46
0D986:  MOVWF  FF6
0D988:  MOVLW  22
0D98A:  MOVWF  FF7
0D98C:  MOVLW  00
0D98E:  MOVWF  FF8
0D990:  CLRF   1B
0D992:  BTFSC  FF2.7
0D994:  BSF    1B.7
0D996:  BCF    FF2.7
0D998:  CALL   0E6E
0D99C:  BTFSC  1B.7
0D99E:  BSF    FF2.7
....................          break; 
0D9A0:  MOVLB  8
0D9A2:  BRA    DA06
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D9A4:  MOVLW  4E
0D9A6:  MOVWF  FF6
0D9A8:  MOVLW  22
0D9AA:  MOVWF  FF7
0D9AC:  MOVLW  00
0D9AE:  MOVWF  FF8
0D9B0:  CLRF   1B
0D9B2:  BTFSC  FF2.7
0D9B4:  BSF    1B.7
0D9B6:  BCF    FF2.7
0D9B8:  CALL   0E6E
0D9BC:  BTFSC  1B.7
0D9BE:  BSF    FF2.7
....................          break; 
0D9C0:  MOVLB  8
0D9C2:  BRA    DA06
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D9C4:  MOVLW  56
0D9C6:  MOVWF  FF6
0D9C8:  MOVLW  22
0D9CA:  MOVWF  FF7
0D9CC:  MOVLW  00
0D9CE:  MOVWF  FF8
0D9D0:  CLRF   1B
0D9D2:  BTFSC  FF2.7
0D9D4:  BSF    1B.7
0D9D6:  BCF    FF2.7
0D9D8:  CALL   0E6E
0D9DC:  BTFSC  1B.7
0D9DE:  BSF    FF2.7
....................          break;    
0D9E0:  MOVLB  8
0D9E2:  BRA    DA06
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D9E4:  MOVLW  5E
0D9E6:  MOVWF  FF6
0D9E8:  MOVLW  22
0D9EA:  MOVWF  FF7
0D9EC:  MOVLW  00
0D9EE:  MOVWF  FF8
0D9F0:  CLRF   1B
0D9F2:  BTFSC  FF2.7
0D9F4:  BSF    1B.7
0D9F6:  BCF    FF2.7
0D9F8:  CALL   0E6E
0D9FC:  BTFSC  1B.7
0D9FE:  BSF    FF2.7
....................          break;           
0DA00:  MOVLB  8
0DA02:  BRA    DA06
0DA04:  MOVLB  8
....................    } 
0DA06:  MOVLB  0
0DA08:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
164A0:  MOVLB  8
164A2:  MOVF   x88,W
164A4:  BTFSC  FD8.2
164A6:  DECF   x89,F
164A8:  DECF   x88,F
....................    addr = macro_address[0] + (step*9); 
164AA:  MOVFF  889,A11
164AE:  MOVFF  888,A10
164B2:  MOVLB  A
164B4:  CLRF   x13
164B6:  MOVLW  09
164B8:  MOVWF  x12
164BA:  MOVLB  0
164BC:  CALL   5CC0
164C0:  MOVF   01,W
164C2:  MOVLB  7
164C4:  ADDWF  xD1,W
164C6:  MOVLB  8
164C8:  MOVWF  x8A
164CA:  MOVF   02,W
164CC:  MOVLB  7
164CE:  ADDWFC xD2,W
164D0:  MOVLB  8
164D2:  MOVWF  x8B
....................     
....................    init_ext_eeprom(); 
164D4:  MOVLB  0
164D6:  CALL   105F2
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
164DA:  MOVFF  88B,8CC
164DE:  MOVFF  88A,8CB
164E2:  CALL   1062A
164E6:  MOVFF  01,88C
....................    ++addr; 
164EA:  MOVLB  8
164EC:  INCF   x8A,F
164EE:  BTFSC  FD8.2
164F0:  INCF   x8B,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
164F2:  MOVFF  88B,8C3
164F6:  MOVFF  88A,8C2
164FA:  MOVLB  0
164FC:  CALL   1073E
16500:  MOVFF  02,890
16504:  MOVFF  01,88F
....................    ++addr; 
16508:  MOVLB  8
1650A:  INCF   x8A,F
1650C:  BTFSC  FD8.2
1650E:  INCF   x8B,F
....................    ++addr; 
16510:  INCF   x8A,F
16512:  BTFSC  FD8.2
16514:  INCF   x8B,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
16516:  MOVFF  88B,8CC
1651A:  MOVFF  88A,8CB
1651E:  MOVLB  0
16520:  CALL   1062A
16524:  MOVFF  01,88D
....................    ++addr; 
16528:  MOVLB  8
1652A:  INCF   x8A,F
1652C:  BTFSC  FD8.2
1652E:  INCF   x8B,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
16530:  MOVFF  88B,8C3
16534:  MOVFF  88A,8C2
16538:  MOVLB  0
1653A:  CALL   1073E
1653E:  MOVFF  02,892
16542:  MOVFF  01,891
....................    ++addr; 
16546:  MOVLB  8
16548:  INCF   x8A,F
1654A:  BTFSC  FD8.2
1654C:  INCF   x8B,F
....................    ++addr; 
1654E:  INCF   x8A,F
16550:  BTFSC  FD8.2
16552:  INCF   x8B,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
16554:  MOVFF  88B,8CC
16558:  MOVFF  88A,8CB
1655C:  MOVLB  0
1655E:  CALL   1062A
16562:  MOVFF  01,88E
....................    ++addr; 
16566:  MOVLB  8
16568:  INCF   x8A,F
1656A:  BTFSC  FD8.2
1656C:  INCF   x8B,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
1656E:  MOVFF  88B,8C3
16572:  MOVFF  88A,8C2
16576:  MOVLB  0
16578:  CALL   1073E
1657C:  MOVFF  02,894
16580:  MOVFF  01,893
....................    ++addr; 
16584:  MOVLB  8
16586:  INCF   x8A,F
16588:  BTFSC  FD8.2
1658A:  INCF   x8B,F
....................    ++addr; 
1658C:  INCF   x8A,F
1658E:  BTFSC  FD8.2
16590:  INCF   x8B,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16592:  MOVFF  88B,8CC
16596:  MOVFF  88A,8CB
1659A:  MOVLB  0
1659C:  CALL   1062A
165A0:  MOVFF  01,895
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
165A4:  MOVLB  8
165A6:  MOVF   x8C,W
165A8:  SUBLW  4A
165AA:  BTFSS  FD8.2
165AC:  BRA    16682
165AE:  MOVF   x8D,W
165B0:  SUBLW  50
165B2:  BNZ   16682
165B4:  MOVF   x8E,W
165B6:  SUBLW  4D
165B8:  BNZ   16682
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
165BA:  MOVF   x8C,W
165BC:  BTFSS  F9E.4
165BE:  BRA    165BC
165C0:  MOVWF  FAD
165C2:  MOVLW  10
165C4:  MOVWF  FE9
165C6:  CLRF   1B
165C8:  BTFSC  FF2.7
165CA:  BSF    1B.7
165CC:  BCF    FF2.7
165CE:  MOVFF  890,A41
165D2:  MOVFF  88F,A40
165D6:  MOVLB  0
165D8:  CALL   11C6
165DC:  BTFSC  1B.7
165DE:  BSF    FF2.7
165E0:  MOVLW  2C
165E2:  BTFSS  F9E.4
165E4:  BRA    165E2
165E6:  MOVWF  FAD
165E8:  MOVLB  8
165EA:  MOVF   x8D,W
165EC:  BTFSS  F9E.4
165EE:  BRA    165EC
165F0:  MOVWF  FAD
165F2:  MOVLW  10
165F4:  MOVWF  FE9
165F6:  CLRF   1B
165F8:  BTFSC  FF2.7
165FA:  BSF    1B.7
165FC:  BCF    FF2.7
165FE:  MOVFF  892,A41
16602:  MOVFF  891,A40
16606:  MOVLB  0
16608:  CALL   11C6
1660C:  BTFSC  1B.7
1660E:  BSF    FF2.7
16610:  MOVLW  2C
16612:  BTFSS  F9E.4
16614:  BRA    16612
16616:  MOVWF  FAD
16618:  MOVLB  8
1661A:  MOVF   x8E,W
1661C:  BTFSS  F9E.4
1661E:  BRA    1661C
16620:  MOVWF  FAD
16622:  MOVLW  10
16624:  MOVWF  FE9
16626:  CLRF   1B
16628:  BTFSC  FF2.7
1662A:  BSF    1B.7
1662C:  BCF    FF2.7
1662E:  MOVFF  894,A41
16632:  MOVFF  893,A40
16636:  MOVLB  0
16638:  CALL   11C6
1663C:  BTFSC  1B.7
1663E:  BSF    FF2.7
16640:  MOVLW  0D
16642:  BTFSS  F9E.4
16644:  BRA    16642
16646:  MOVWF  FAD
16648:  MOVLW  0A
1664A:  BTFSS  F9E.4
1664C:  BRA    1664A
1664E:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
16650:  MOVFF  890,24
16654:  MOVFF  88F,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
16658:  MOVLB  8
1665A:  MOVF   x93,F
1665C:  BNZ   16662
1665E:  MOVF   x94,F
16660:  BZ    16680
16662:  MOVF   x94,F
16664:  BNZ   16680
16666:  MOVF   x93,W
16668:  SUBLW  10
1666A:  BNC   16680
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
1666C:  MOVFF  893,897
16670:  MOVFF  892,899
16674:  MOVFF  891,898
16678:  MOVLB  0
1667A:  CALL   153E4
1667E:  MOVLB  8
....................       } 
....................    } 
16680:  BRA    1668E
....................    else { 
....................       cmd_err(); 
16682:  MOVLB  0
16684:  CALL   BFE8
....................       macro_end = 59; 
16688:  MOVLW  3B
1668A:  MOVLB  8
1668C:  MOVWF  x95
....................    } 
....................     
....................    return (macro_end); 
1668E:  MOVFF  895,01
16692:  MOVLB  0
16694:  GOTO   1677E (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
16880:  MOVLB  8
16882:  MOVF   x8C,W
16884:  BTFSC  FD8.2
16886:  DECF   x8D,F
16888:  DECF   x8C,F
....................    addr = macro_address[0] + (step*6); 
1688A:  MOVFF  88D,A11
1688E:  MOVFF  88C,A10
16892:  MOVLB  A
16894:  CLRF   x13
16896:  MOVLW  06
16898:  MOVWF  x12
1689A:  MOVLB  0
1689C:  CALL   5CC0
168A0:  MOVF   01,W
168A2:  MOVLB  7
168A4:  ADDWF  xD1,W
168A6:  MOVLB  8
168A8:  MOVWF  x8E
168AA:  MOVF   02,W
168AC:  MOVLB  7
168AE:  ADDWFC xD2,W
168B0:  MOVLB  8
168B2:  MOVWF  x8F
....................     
....................    init_ext_eeprom(); 
168B4:  MOVLB  0
168B6:  CALL   105F2
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
168BA:  MOVFF  88F,8CC
168BE:  MOVFF  88E,8CB
168C2:  CALL   1062A
168C6:  MOVFF  01,890
....................    ++addr; 
168CA:  MOVLB  8
168CC:  INCF   x8E,F
168CE:  BTFSC  FD8.2
168D0:  INCF   x8F,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
168D2:  MOVFF  88F,8C3
168D6:  MOVFF  88E,8C2
168DA:  MOVLB  0
168DC:  CALL   1073E
168E0:  MOVFF  02,893
168E4:  MOVFF  01,892
....................    ++addr; 
168E8:  MOVLB  8
168EA:  INCF   x8E,F
168EC:  BTFSC  FD8.2
168EE:  INCF   x8F,F
....................    ++addr; 
168F0:  INCF   x8E,F
168F2:  BTFSC  FD8.2
168F4:  INCF   x8F,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
168F6:  MOVFF  88F,8CC
168FA:  MOVFF  88E,8CB
168FE:  MOVLB  0
16900:  CALL   1062A
16904:  MOVFF  01,891
....................    ++addr; 
16908:  MOVLB  8
1690A:  INCF   x8E,F
1690C:  BTFSC  FD8.2
1690E:  INCF   x8F,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
16910:  MOVFF  88F,8C3
16914:  MOVFF  88E,8C2
16918:  MOVLB  0
1691A:  CALL   1073E
1691E:  MOVFF  02,895
16922:  MOVFF  01,894
....................    ++addr; 
16926:  MOVLB  8
16928:  INCF   x8E,F
1692A:  BTFSC  FD8.2
1692C:  INCF   x8F,F
....................    ++addr; 
1692E:  INCF   x8E,F
16930:  BTFSC  FD8.2
16932:  INCF   x8F,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16934:  MOVFF  88F,8CC
16938:  MOVFF  88E,8CB
1693C:  MOVLB  0
1693E:  CALL   1062A
16942:  MOVFF  01,896
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
16946:  MOVLB  8
16948:  MOVF   x90,W
1694A:  SUBLW  50
1694C:  BNZ   169F0
1694E:  MOVF   x91,W
16950:  SUBLW  4D
16952:  BNZ   169F0
....................        
....................       RTC_read(); 
16954:  MOVLB  0
16956:  CALL   336C
....................       RTC_display(); 
1695A:  CALL   E2B2
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
1695E:  MOVLB  8
16960:  MOVF   x90,W
16962:  BTFSS  F9E.4
16964:  BRA    16962
16966:  MOVWF  FAD
16968:  MOVLW  10
1696A:  MOVWF  FE9
1696C:  CLRF   1B
1696E:  BTFSC  FF2.7
16970:  BSF    1B.7
16972:  BCF    FF2.7
16974:  MOVFF  893,A41
16978:  MOVFF  892,A40
1697C:  MOVLB  0
1697E:  CALL   11C6
16982:  BTFSC  1B.7
16984:  BSF    FF2.7
16986:  MOVLW  2C
16988:  BTFSS  F9E.4
1698A:  BRA    16988
1698C:  MOVWF  FAD
1698E:  MOVLB  8
16990:  MOVF   x91,W
16992:  BTFSS  F9E.4
16994:  BRA    16992
16996:  MOVWF  FAD
16998:  MOVLW  10
1699A:  MOVWF  FE9
1699C:  CLRF   1B
1699E:  BTFSC  FF2.7
169A0:  BSF    1B.7
169A2:  BCF    FF2.7
169A4:  MOVFF  895,A41
169A8:  MOVFF  894,A40
169AC:  MOVLB  0
169AE:  CALL   11C6
169B2:  BTFSC  1B.7
169B4:  BSF    FF2.7
169B6:  MOVLW  0D
169B8:  BTFSS  F9E.4
169BA:  BRA    169B8
169BC:  MOVWF  FAD
169BE:  MOVLW  0A
169C0:  BTFSS  F9E.4
169C2:  BRA    169C0
169C4:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
169C6:  MOVLB  8
169C8:  MOVF   x94,F
169CA:  BNZ   169D0
169CC:  MOVF   x95,F
169CE:  BZ    169EE
169D0:  MOVF   x95,F
169D2:  BNZ   169EE
169D4:  MOVF   x94,W
169D6:  SUBLW  10
169D8:  BNC   169EE
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
169DA:  MOVFF  894,897
169DE:  MOVFF  893,899
169E2:  MOVFF  892,898
169E6:  MOVLB  0
169E8:  CALL   153E4
169EC:  MOVLB  8
....................       } 
....................    } 
169EE:  BRA    169FC
....................    else { 
....................       cmd_err(); 
169F0:  MOVLB  0
169F2:  CALL   BFE8
....................       macro_end = 59; 
169F6:  MOVLW  3B
169F8:  MOVLB  8
169FA:  MOVWF  x96
....................    } 
....................     
....................    return (macro_end); 
169FC:  MOVFF  896,01
16A00:  MOVLB  0
16A02:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
1627E:  MOVF   24,W
16280:  SUBWF  36,W
16282:  BTFSS  FD8.0
16284:  BRA    1648C
16286:  BNZ   16290
16288:  MOVF   23,W
1628A:  SUBWF  35,W
1628C:  BTFSS  FD8.0
1628E:  BRA    1648C
16290:  MOVF   33,F
16292:  BTFSS  FD8.2
16294:  BRA    1648C
16296:  MOVF   34,F
16298:  BTFSS  FD8.2
1629A:  BRA    1648C
....................       { 
....................          nv_elapsed = 0; 
1629C:  CLRF   36
1629E:  CLRF   35
....................  
....................          init_hardware(); 
162A0:  CALL   2962
....................          sd_status = init_sdcard(); 
162A4:  CALL   5062
162A8:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
162AC:  MOVLB  2
162AE:  MOVF   xDC,F
162B0:  BZ    162BA
162B2:  MOVLB  0
162B4:  CALL   50A8
162B8:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
162BA:  MOVLW  01
162BC:  MOVWF  1E
162BE:  MOVLW  A7
162C0:  MOVWF  1D
162C2:  MOVLW  66
162C4:  MOVWF  FF6
162C6:  MOVLW  22
162C8:  MOVWF  FF7
162CA:  MOVLW  00
162CC:  MOVWF  FF8
162CE:  MOVLW  14
162D0:  MOVLB  8
162D2:  MOVWF  xEB
162D4:  MOVLB  0
162D6:  CALL   AAF4
162DA:  MOVLW  10
162DC:  MOVWF  FE9
162DE:  MOVFF  22,8F7
162E2:  MOVFF  21,8F6
162E6:  CALL   AB26
162EA:  MOVLW  7D
162EC:  MOVWF  FF6
162EE:  MOVLW  22
162F0:  MOVWF  FF7
162F2:  MOVLW  00
162F4:  MOVWF  FF8
162F6:  MOVLW  09
162F8:  MOVLB  8
162FA:  MOVWF  xEB
162FC:  MOVLB  0
162FE:  CALL   AAF4
....................          record_event();          
16302:  CALL   8502
....................              
....................          macro_cmd = master_macro_eco(); 
16306:  RCALL  15FCA
16308:  MOVFF  01,887
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
1630C:  MOVLW  16
1630E:  MOVLB  8
16310:  MOVWF  xEE
16312:  MOVFF  22,8F0
16316:  MOVFF  21,8EF
1631A:  MOVLB  0
1631C:  CALL   4FFC
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
16320:  MOVLW  3A
16322:  MOVLB  8
16324:  MOVWF  xEE
16326:  MOVFF  38,8F0
1632A:  MOVFF  37,8EF
1632E:  MOVLB  0
16330:  CALL   4FFC
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
16334:  DECFSZ 50,W
16336:  BRA    1635A
....................          { 
....................             disable_interrupts (INT_EXT); 
16338:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
1633A:  CLRF   32
1633C:  MOVLW  01
1633E:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16340:  MOVLW  02
16342:  MOVLB  8
16344:  MOVWF  x89
16346:  MOVFF  31,88A
1634A:  MOVLB  0
1634C:  CALL   343A
....................             busy_clear(); 
16350:  CALL   AED8
....................             return (user_quit); 
16354:  MOVFF  50,01
16358:  BRA    1649C
....................          } 
....................  
....................          motor_sleep_rdy(); 
1635A:  CALL   29C0
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
1635E:  MOVLW  01
16360:  MOVWF  1E
16362:  MOVLW  A7
16364:  MOVWF  1D
16366:  MOVLW  88
16368:  MOVWF  FF6
1636A:  MOVLW  22
1636C:  MOVWF  FF7
1636E:  MOVLW  00
16370:  MOVWF  FF8
16372:  MOVLW  14
16374:  MOVLB  8
16376:  MOVWF  xEB
16378:  MOVLB  0
1637A:  CALL   AAF4
1637E:  MOVLW  10
16380:  MOVWF  FE9
16382:  MOVFF  22,8F7
16386:  MOVFF  21,8F6
1638A:  CALL   AB26
1638E:  MOVLW  9F
16390:  MOVWF  FF6
16392:  MOVLW  22
16394:  MOVWF  FF7
16396:  MOVLW  00
16398:  MOVWF  FF8
1639A:  MOVLW  0C
1639C:  MOVLB  8
1639E:  MOVWF  xEB
163A0:  MOVLB  0
163A2:  CALL   AAF4
....................          record_event();  
163A6:  CALL   8502
....................           
....................          if (macro_cmd == 'e') 
163AA:  MOVLB  8
163AC:  MOVF   x87,W
163AE:  SUBLW  65
163B0:  BNZ   16404
....................          { 
....................             disable_interrupts (INT_EXT); 
163B2:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
163B4:  MOVLW  01
163B6:  MOVWF  1E
163B8:  MOVLW  A7
163BA:  MOVWF  1D
163BC:  MOVLW  AC
163BE:  MOVWF  FF6
163C0:  MOVLW  22
163C2:  MOVWF  FF7
163C4:  MOVLW  00
163C6:  MOVWF  FF8
163C8:  MOVLW  14
163CA:  MOVWF  xEB
163CC:  MOVLB  0
163CE:  CALL   AAF4
163D2:  MOVLW  10
163D4:  MOVWF  FE9
163D6:  MOVFF  22,8F7
163DA:  MOVFF  21,8F6
163DE:  CALL   AB26
163E2:  MOVLW  C3
163E4:  MOVWF  FF6
163E6:  MOVLW  22
163E8:  MOVWF  FF7
163EA:  MOVLW  00
163EC:  MOVWF  FF8
163EE:  MOVLW  09
163F0:  MOVLB  8
163F2:  MOVWF  xEB
163F4:  MOVLB  0
163F6:  CALL   AAF4
....................             record_event();  
163FA:  CALL   8502
....................             cmd_err(); 
163FE:  CALL   BFE8
16402:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16404:  MOVF   28,W
16406:  SUBWF  22,W
16408:  BNC   1648E
1640A:  BNZ   16412
1640C:  MOVF   27,W
1640E:  SUBWF  21,W
16410:  BNC   1648E
....................          { 
....................             disable_interrupts (INT_EXT); 
16412:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16414:  MOVLW  01
16416:  MOVWF  1E
16418:  MOVLW  A7
1641A:  MOVWF  1D
1641C:  MOVLW  CE
1641E:  MOVWF  FF6
16420:  MOVLW  22
16422:  MOVWF  FF7
16424:  MOVLW  00
16426:  MOVWF  FF8
16428:  MOVLW  14
1642A:  MOVWF  xEB
1642C:  MOVLB  0
1642E:  CALL   AAF4
16432:  MOVLW  10
16434:  MOVWF  FE9
16436:  MOVFF  22,8F7
1643A:  MOVFF  21,8F6
1643E:  CALL   AB26
16442:  MOVLW  E5
16444:  MOVWF  FF6
16446:  MOVLW  22
16448:  MOVWF  FF7
1644A:  MOVLW  00
1644C:  MOVWF  FF8
1644E:  MOVLW  0F
16450:  MOVLB  8
16452:  MOVWF  xEB
16454:  MOVLB  0
16456:  CALL   AAF4
....................             record_event();   
1645A:  CALL   8502
....................             msg_max(); 
1645E:  RCALL  16260
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
16460:  CLRF   34
16462:  MOVLW  01
16464:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
16466:  MOVLW  28
16468:  MOVLB  8
1646A:  MOVWF  x89
1646C:  MOVFF  33,88A
16470:  MOVLB  0
16472:  CALL   343A
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
16476:  CLRF   32
16478:  MOVLW  01
1647A:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
1647C:  MOVLW  02
1647E:  MOVLB  8
16480:  MOVWF  x89
16482:  MOVFF  31,88A
16486:  MOVLB  0
16488:  CALL   343A
1648C:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
1648E:  MOVLB  0
16490:  RCALL  15F04
16492:  BRA    1627E
....................    } 
....................     
....................    busy_clear(); 
16494:  CALL   AED8
....................    return (user_quit); 
16498:  MOVFF  50,01
1649C:  GOTO   16DC0 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16698:  MOVF   24,W
1669A:  SUBWF  36,W
1669C:  BTFSS  FD8.0
1669E:  BRA    1686E
166A0:  BNZ   166AA
166A2:  MOVF   23,W
166A4:  SUBWF  35,W
166A6:  BTFSS  FD8.0
166A8:  BRA    1686E
....................       { 
....................          nv_elapsed = 0; 
166AA:  CLRF   36
166AC:  CLRF   35
....................  
....................          init_hardware(); 
166AE:  CALL   2962
....................          sd_status = init_sdcard(); 
166B2:  CALL   5062
166B6:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
166BA:  MOVLB  2
166BC:  MOVF   xDC,F
166BE:  BZ    166C8
166C0:  MOVLB  0
166C2:  CALL   50A8
166C6:  MOVLB  2
....................  
....................          ++nv_sample; 
166C8:  INCF   21,F
166CA:  BTFSC  FD8.2
166CC:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
166CE:  MOVLW  40
166D0:  BTFSS  F9E.4
166D2:  BRA    166D0
166D4:  MOVWF  FAD
166D6:  MOVLW  53
166D8:  BTFSS  F9E.4
166DA:  BRA    166D8
166DC:  MOVWF  FAD
166DE:  MOVLW  09
166E0:  MOVWF  FE9
166E2:  CLRF   1B
166E4:  BTFSC  FF2.7
166E6:  BSF    1B.7
166E8:  BCF    FF2.7
166EA:  MOVFF  22,A41
166EE:  MOVFF  21,A40
166F2:  MOVLB  0
166F4:  CALL   11C6
166F8:  BTFSC  1B.7
166FA:  BSF    FF2.7
166FC:  MOVLW  0D
166FE:  BTFSS  F9E.4
16700:  BRA    166FE
16702:  MOVWF  FAD
16704:  MOVLW  0A
16706:  BTFSS  F9E.4
16708:  BRA    16706
1670A:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
1670C:  MOVLW  01
1670E:  MOVWF  1E
16710:  MOVLW  A7
16712:  MOVWF  1D
16714:  MOVLW  F6
16716:  MOVWF  FF6
16718:  MOVLW  22
1671A:  MOVWF  FF7
1671C:  MOVLW  00
1671E:  MOVWF  FF8
16720:  MOVLW  14
16722:  MOVLB  8
16724:  MOVWF  xEB
16726:  MOVLB  0
16728:  CALL   AAF4
1672C:  MOVLW  10
1672E:  MOVWF  FE9
16730:  MOVFF  22,8F7
16734:  MOVFF  21,8F6
16738:  CALL   AB26
1673C:  MOVLW  0D
1673E:  MOVWF  FF6
16740:  MOVLW  23
16742:  MOVWF  FF7
16744:  MOVLW  00
16746:  MOVWF  FF8
16748:  MOVLW  09
1674A:  MOVLB  8
1674C:  MOVWF  xEB
1674E:  MOVLB  0
16750:  CALL   AAF4
....................          record_event();   
16754:  CALL   8502
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16758:  MOVLW  16
1675A:  MOVLB  8
1675C:  MOVWF  xEE
1675E:  MOVFF  22,8F0
16762:  MOVFF  21,8EF
16766:  MOVLB  0
16768:  CALL   4FFC
....................  
....................          if (nv_macro_mode==TRUE) 
1676C:  DECFSZ 29,W
1676E:  BRA    16784
16770:  MOVF   2A,F
16772:  BNZ   16784
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
16774:  MOVFF  22,889
16778:  MOVFF  21,888
1677C:  BRA    164A0
1677E:  MOVFF  01,887
....................          } 
16782:  BRA    167EC
....................          else 
....................          { 
....................             time_stamp(); 
16784:  CALL   5442
....................             play_wms_hard_macro(nv_port); 
16788:  MOVFF  2E,88A
1678C:  MOVFF  2D,889
16790:  CALL   D828
....................             ++nv_port; 
16794:  INCF   2D,F
16796:  BTFSC  FD8.2
16798:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
1679A:  MOVF   2E,F
1679C:  BNZ   167A4
1679E:  MOVF   2D,W
167A0:  SUBLW  01
167A2:  BC    167B6
167A4:  MOVF   2E,F
167A6:  BNZ   167B6
167A8:  MOVF   2D,W
167AA:  SUBLW  30
167AC:  BNC   167B6
167AE:  DECFSZ 2F,W
167B0:  BRA    167B6
167B2:  MOVF   30,F
167B4:  BZ    167D4
167B6:  MOVF   2E,F
167B8:  BNZ   167C0
167BA:  MOVF   2D,W
167BC:  SUBLW  01
167BE:  BC    167EA
167C0:  MOVF   2E,F
167C2:  BNZ   167EA
167C4:  MOVF   2D,W
167C6:  SUBLW  32
167C8:  BNC   167EA
167CA:  MOVF   2F,W
167CC:  SUBLW  03
167CE:  BNZ   167EA
167D0:  MOVF   30,F
167D2:  BNZ   167EA
....................             { 
....................                write16(ADDR_PORT, nv_port);             
167D4:  MOVLW  24
167D6:  MOVLB  8
167D8:  MOVWF  xEE
167DA:  MOVFF  2E,8F0
167DE:  MOVFF  2D,8EF
167E2:  MOVLB  0
167E4:  CALL   4FFC
....................             } 
167E8:  BRA    167EC
....................             else disable_interrupts (INT_EXT); 
167EA:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
167EC:  DECFSZ 50,W
167EE:  BRA    16812
....................          { 
....................             disable_interrupts (INT_EXT); 
167F0:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
167F2:  CLRF   32
167F4:  MOVLW  01
167F6:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
167F8:  MOVLW  02
167FA:  MOVLB  8
167FC:  MOVWF  x89
167FE:  MOVFF  31,88A
16802:  MOVLB  0
16804:  CALL   343A
....................             busy_clear(); 
16808:  CALL   AED8
....................             return (user_quit); 
1680C:  MOVFF  50,01
16810:  BRA    1687C
....................          } 
....................           
....................          motor_sleep_rdy(); 
16812:  CALL   29C0
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16816:  MOVLW  01
16818:  MOVWF  1E
1681A:  MOVLW  A7
1681C:  MOVWF  1D
1681E:  MOVLW  18
16820:  MOVWF  FF6
16822:  MOVLW  23
16824:  MOVWF  FF7
16826:  MOVLW  00
16828:  MOVWF  FF8
1682A:  MOVLW  14
1682C:  MOVLB  8
1682E:  MOVWF  xEB
16830:  MOVLB  0
16832:  CALL   AAF4
16836:  MOVLW  10
16838:  MOVWF  FE9
1683A:  MOVFF  22,8F7
1683E:  MOVFF  21,8F6
16842:  CALL   AB26
16846:  MOVLW  2F
16848:  MOVWF  FF6
1684A:  MOVLW  23
1684C:  MOVWF  FF7
1684E:  MOVLW  00
16850:  MOVWF  FF8
16852:  MOVLW  0C
16854:  MOVLB  8
16856:  MOVWF  xEB
16858:  MOVLB  0
1685A:  CALL   AAF4
....................          record_event();  
1685E:  CALL   8502
....................           
....................          if (macro_end == ';') 
16862:  MOVLB  8
16864:  MOVF   x87,W
16866:  SUBLW  3B
16868:  BNZ   1686C
....................          { 
....................             disable_interrupts (INT_EXT); 
1686A:  BCF    FF2.4
1686C:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
1686E:  CALL   15F04
16872:  BRA    16698
....................    } 
....................    busy_clear(); 
16874:  CALL   AED8
....................    return (user_quit); 
16878:  MOVFF  50,01
1687C:  GOTO   16DC8 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16A04:  MOVF   24,W
16A06:  SUBWF  36,W
16A08:  BTFSS  FD8.0
16A0A:  BRA    16BC4
16A0C:  BNZ   16A16
16A0E:  MOVF   23,W
16A10:  SUBWF  35,W
16A12:  BTFSS  FD8.0
16A14:  BRA    16BC4
....................       { 
....................          nv_elapsed = 0; 
16A16:  CLRF   36
16A18:  CLRF   35
....................  
....................          init_hardware(); 
16A1A:  CALL   2962
....................          sd_status = init_sdcard(); 
16A1E:  CALL   5062
16A22:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
16A26:  MOVLB  2
16A28:  MOVF   xDC,F
16A2A:  BZ    16A34
16A2C:  MOVLB  0
16A2E:  CALL   50A8
16A32:  MOVLB  2
....................  
....................          ++nv_sample; 
16A34:  INCF   21,F
16A36:  BTFSC  FD8.2
16A38:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
16A3A:  MOVLW  40
16A3C:  BTFSS  F9E.4
16A3E:  BRA    16A3C
16A40:  MOVWF  FAD
16A42:  MOVLW  53
16A44:  BTFSS  F9E.4
16A46:  BRA    16A44
16A48:  MOVWF  FAD
16A4A:  MOVLW  09
16A4C:  MOVWF  FE9
16A4E:  CLRF   1B
16A50:  BTFSC  FF2.7
16A52:  BSF    1B.7
16A54:  BCF    FF2.7
16A56:  MOVFF  22,A41
16A5A:  MOVFF  21,A40
16A5E:  MOVLB  0
16A60:  CALL   11C6
16A64:  BTFSC  1B.7
16A66:  BSF    FF2.7
16A68:  MOVLW  0D
16A6A:  BTFSS  F9E.4
16A6C:  BRA    16A6A
16A6E:  MOVWF  FAD
16A70:  MOVLW  0A
16A72:  BTFSS  F9E.4
16A74:  BRA    16A72
16A76:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16A78:  MOVLW  01
16A7A:  MOVWF  1E
16A7C:  MOVLW  A7
16A7E:  MOVWF  1D
16A80:  MOVLW  3C
16A82:  MOVWF  FF6
16A84:  MOVLW  23
16A86:  MOVWF  FF7
16A88:  MOVLW  00
16A8A:  MOVWF  FF8
16A8C:  MOVLW  14
16A8E:  MOVLB  8
16A90:  MOVWF  xEB
16A92:  MOVLB  0
16A94:  CALL   AAF4
16A98:  MOVLW  10
16A9A:  MOVWF  FE9
16A9C:  MOVFF  22,8F7
16AA0:  MOVFF  21,8F6
16AA4:  CALL   AB26
16AA8:  MOVLW  53
16AAA:  MOVWF  FF6
16AAC:  MOVLW  23
16AAE:  MOVWF  FF7
16AB0:  MOVLW  00
16AB2:  MOVWF  FF8
16AB4:  MOVLW  09
16AB6:  MOVLB  8
16AB8:  MOVWF  xEB
16ABA:  MOVLB  0
16ABC:  CALL   AAF4
....................          record_event();   
16AC0:  CALL   8502
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16AC4:  MOVLW  16
16AC6:  MOVLB  8
16AC8:  MOVWF  xEE
16ACA:  MOVFF  22,8F0
16ACE:  MOVFF  21,8EF
16AD2:  MOVLB  0
16AD4:  CALL   4FFC
....................  
....................          macro_end = master_macro_aws(nv_sample); 
16AD8:  MOVFF  22,88D
16ADC:  MOVFF  21,88C
16AE0:  RCALL  16880
16AE2:  MOVFF  01,887
....................           
....................          if (user_quit == TRUE) 
16AE6:  DECFSZ 50,W
16AE8:  BRA    16B0C
....................          { 
....................             disable_interrupts (INT_EXT); 
16AEA:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
16AEC:  CLRF   32
16AEE:  MOVLW  01
16AF0:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16AF2:  MOVLW  02
16AF4:  MOVLB  8
16AF6:  MOVWF  x89
16AF8:  MOVFF  31,88A
16AFC:  MOVLB  0
16AFE:  CALL   343A
....................             busy_clear(); 
16B02:  CALL   AED8
....................             return (user_quit); 
16B06:  MOVFF  50,01
16B0A:  BRA    16BD6
....................          } 
....................           
....................          motor_sleep_rdy(); 
16B0C:  CALL   29C0
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16B10:  MOVLW  01
16B12:  MOVWF  1E
16B14:  MOVLW  A7
16B16:  MOVWF  1D
16B18:  MOVLW  5E
16B1A:  MOVWF  FF6
16B1C:  MOVLW  23
16B1E:  MOVWF  FF7
16B20:  MOVLW  00
16B22:  MOVWF  FF8
16B24:  MOVLW  14
16B26:  MOVLB  8
16B28:  MOVWF  xEB
16B2A:  MOVLB  0
16B2C:  CALL   AAF4
16B30:  MOVLW  10
16B32:  MOVWF  FE9
16B34:  MOVFF  22,8F7
16B38:  MOVFF  21,8F6
16B3C:  CALL   AB26
16B40:  MOVLW  75
16B42:  MOVWF  FF6
16B44:  MOVLW  23
16B46:  MOVWF  FF7
16B48:  MOVLW  00
16B4A:  MOVWF  FF8
16B4C:  MOVLW  0C
16B4E:  MOVLB  8
16B50:  MOVWF  xEB
16B52:  MOVLB  0
16B54:  CALL   AAF4
....................          record_event();  
16B58:  CALL   8502
....................           
....................          if (macro_end == ';') 
16B5C:  MOVLB  8
16B5E:  MOVF   x87,W
16B60:  SUBLW  3B
16B62:  BNZ   16B66
....................          { 
....................             disable_interrupts (INT_EXT); 
16B64:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16B66:  MOVF   28,W
16B68:  SUBWF  22,W
16B6A:  BNC   16BC6
16B6C:  BNZ   16B74
16B6E:  MOVF   27,W
16B70:  SUBWF  21,W
16B72:  BNC   16BC6
....................          { 
....................             disable_interrupts (INT_EXT); 
16B74:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16B76:  MOVLW  01
16B78:  MOVWF  1E
16B7A:  MOVLW  A7
16B7C:  MOVWF  1D
16B7E:  MOVLW  82
16B80:  MOVWF  FF6
16B82:  MOVLW  23
16B84:  MOVWF  FF7
16B86:  MOVLW  00
16B88:  MOVWF  FF8
16B8A:  MOVLW  14
16B8C:  MOVWF  xEB
16B8E:  MOVLB  0
16B90:  CALL   AAF4
16B94:  MOVLW  10
16B96:  MOVWF  FE9
16B98:  MOVFF  22,8F7
16B9C:  MOVFF  21,8F6
16BA0:  CALL   AB26
16BA4:  MOVLW  99
16BA6:  MOVWF  FF6
16BA8:  MOVLW  23
16BAA:  MOVWF  FF7
16BAC:  MOVLW  00
16BAE:  MOVWF  FF8
16BB0:  MOVLW  0F
16BB2:  MOVLB  8
16BB4:  MOVWF  xEB
16BB6:  MOVLB  0
16BB8:  CALL   AAF4
....................             record_event();   
16BBC:  CALL   8502
....................             msg_max(); 
16BC0:  CALL   16260
16BC4:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
16BC6:  MOVLB  0
16BC8:  CALL   15F04
16BCC:  BRA    16A04
....................    } 
....................    busy_clear(); 
16BCE:  CALL   AED8
....................    return (user_quit); 
16BD2:  MOVFF  50,01
16BD6:  GOTO   16DD0 (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
16BDA:  CALL   29E8
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
16BDE:  MOVLW  01
16BE0:  MOVWF  1E
16BE2:  MOVLW  A7
16BE4:  MOVWF  1D
16BE6:  MOVLW  AA
16BE8:  MOVWF  FF6
16BEA:  MOVLW  23
16BEC:  MOVWF  FF7
16BEE:  MOVLW  00
16BF0:  MOVWF  FF8
16BF2:  CALL   50E6
....................    record_event(); 
16BF6:  CALL   8502
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
16BFA:  MOVLW  01
16BFC:  MOVWF  1E
16BFE:  MOVLW  A7
16C00:  MOVWF  1D
16C02:  MOVLW  C4
16C04:  MOVWF  FF6
16C06:  MOVLW  23
16C08:  MOVWF  FF7
16C0A:  MOVLW  00
16C0C:  MOVWF  FF8
16C0E:  MOVLW  0C
16C10:  MOVLB  8
16C12:  MOVWF  xEB
16C14:  MOVLB  0
16C16:  CALL   AAF4
16C1A:  MOVLW  10
16C1C:  MOVWF  FE9
16C1E:  MOVFF  26,8F7
16C22:  MOVFF  25,8F6
16C26:  CALL   AB26
16C2A:  MOVLW  D3
16C2C:  MOVWF  FF6
16C2E:  MOVLW  23
16C30:  MOVWF  FF7
16C32:  MOVLW  00
16C34:  MOVWF  FF8
16C36:  MOVLW  06
16C38:  MOVLB  8
16C3A:  MOVWF  xEB
16C3C:  MOVLB  0
16C3E:  CALL   AAF4
16C42:  MOVLW  10
16C44:  MOVWF  FE9
16C46:  MOVFF  24,8F7
16C4A:  MOVFF  23,8F6
16C4E:  CALL   AB26
16C52:  MOVLW  DC
16C54:  MOVWF  FF6
16C56:  MOVLW  23
16C58:  MOVWF  FF7
16C5A:  MOVLW  00
16C5C:  MOVWF  FF8
16C5E:  MOVLW  06
16C60:  MOVLB  8
16C62:  MOVWF  xEB
16C64:  MOVLB  0
16C66:  CALL   AAF4
16C6A:  MOVLW  10
16C6C:  MOVWF  FE9
16C6E:  MOVFF  28,8F7
16C72:  MOVFF  27,8F6
16C76:  CALL   AB26
16C7A:  MOVLW  E5
16C7C:  MOVWF  FF6
16C7E:  MOVLW  23
16C80:  MOVWF  FF7
16C82:  MOVLW  00
16C84:  MOVWF  FF8
16C86:  MOVLW  03
16C88:  MOVLB  8
16C8A:  MOVWF  xEB
16C8C:  MOVLB  0
16C8E:  CALL   AAF4
....................    record_event(); 
16C92:  CALL   8502
....................     
....................    user_quit = FALSE; 
16C96:  CLRF   50
....................     
....................    nv_cmd_mode = FALSE; 
16C98:  CLRF   32
16C9A:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
16C9C:  MOVLW  02
16C9E:  MOVLB  8
16CA0:  MOVWF  x89
16CA2:  MOVFF  31,88A
16CA6:  MOVLB  0
16CA8:  CALL   343A
....................  
....................    RTC_set_AFE(); 
16CAC:  GOTO   1574A
....................    // check if start is earlier than now 
....................    RTC_late(); 
16CB0:  CALL   157A2
....................    // show clock 
....................    RTC_display(); 
16CB4:  CALL   E2B2
....................    // show alarm 
....................    RTC_display_alarm(); 
16CB8:  CALL   E512
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
16CBC:  CALL   15C68
....................  
....................    if (alarm_passed == FALSE){ 
16CC0:  BTFSC  4D.3
16CC2:  BRA    16CC4
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
16CC4:  MOVLW  00
16CC6:  BTFSC  4D.3
16CC8:  MOVLW  01
16CCA:  MOVLB  8
16CCC:  MOVWF  x87
16CCE:  MOVLW  01
16CD0:  MOVWF  1E
16CD2:  MOVLW  A7
16CD4:  MOVWF  1D
16CD6:  MOVLW  EA
16CD8:  MOVWF  FF6
16CDA:  MOVLW  23
16CDC:  MOVWF  FF7
16CDE:  MOVLW  00
16CE0:  MOVWF  FF8
16CE2:  MOVLW  14
16CE4:  MOVWF  xEB
16CE6:  MOVLB  0
16CE8:  CALL   AAF4
16CEC:  MOVLW  10
16CEE:  MOVWF  FE9
16CF0:  MOVFF  22,8F7
16CF4:  MOVFF  21,8F6
16CF8:  CALL   AB26
16CFC:  MOVLW  01
16CFE:  MOVWF  FF6
16D00:  MOVLW  24
16D02:  MOVWF  FF7
16D04:  MOVLW  00
16D06:  MOVWF  FF8
16D08:  MOVLW  08
16D0A:  MOVLB  8
16D0C:  MOVWF  xEB
16D0E:  MOVLB  0
16D10:  CALL   AAF4
16D14:  MOVFF  887,8ED
16D18:  MOVLW  1B
16D1A:  MOVLB  8
16D1C:  MOVWF  xEE
16D1E:  MOVLB  0
16D20:  CALL   52A8
16D24:  MOVLW  0B
16D26:  MOVWF  FF6
16D28:  MOVLW  24
16D2A:  MOVWF  FF7
16D2C:  MOVLW  00
16D2E:  MOVWF  FF8
16D30:  MOVLW  03
16D32:  MOVLB  8
16D34:  MOVWF  xEB
16D36:  MOVLB  0
16D38:  CALL   AAF4
....................    record_event();  
16D3C:  CALL   8502
....................  
....................    while (TRUE == RTC_read_flags_running) 
16D40:  BTFSS  4D.2
16D42:  BRA    16D46
....................    { 
....................       ; 
16D44:  BRA    16D40
....................    } 
....................    RTC_read_flags_running = TRUE; 
16D46:  BSF    4D.2
16D48:  CLRF   1B
16D4A:  BTFSC  FF2.7
16D4C:  BSF    1B.7
16D4E:  BCF    FF2.7
....................    RTC_read_flags(); 
16D50:  CALL   0DF8
16D54:  BTFSC  1B.7
16D56:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
16D58:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
16D5A:  CALL   29C0
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
16D5E:  BTFSC  4D.3
16D60:  BRA    16D82
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16D62:  MOVLW  01
16D64:  MOVWF  1E
16D66:  MOVLW  A7
16D68:  MOVWF  1D
16D6A:  MOVLW  10
16D6C:  MOVWF  FF6
16D6E:  MOVLW  24
16D70:  MOVWF  FF7
16D72:  MOVLW  00
16D74:  MOVWF  FF8
16D76:  CALL   50E6
....................       record_event(); 
16D7A:  CALL   8502
....................       go_to_sleep(); 
16D7E:  CALL   15F04
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16D82:  GOTO   15F1A
....................    nv_elapsed = nv_interval; 
16D86:  MOVFF  24,36
16D8A:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
16D8E:  MOVFF  2F,00
16D92:  MOVF   30,W
16D94:  MOVWF  03
16D96:  BNZ   16D9C
16D98:  MOVF   00,F
16D9A:  BZ    16DBC
16D9C:  MOVF   03,W
16D9E:  BNZ   16DA6
16DA0:  MOVLW  01
16DA2:  SUBWF  00,W
16DA4:  BZ    16DC6
16DA6:  MOVF   03,W
16DA8:  BNZ   16DB0
16DAA:  MOVLW  03
16DAC:  SUBWF  00,W
16DAE:  BZ    16DC6
16DB0:  MOVF   03,W
16DB2:  BNZ   16DBA
16DB4:  MOVLW  02
16DB6:  SUBWF  00,W
16DB8:  BZ    16DCE
16DBA:  BRA    16DD4
....................       case ECO: user_quit = auto_sample_eco(); 
16DBC:  GOTO   1627E
16DC0:  MOVFF  01,50
....................          break; 
16DC4:  BRA    16DD4
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
16DC6:  BRA    16698
16DC8:  MOVFF  01,50
....................          break; 
16DCC:  BRA    16DD4
....................       case AWS: user_quit = auto_sample_aws(); 
16DCE:  BRA    16A04
16DD0:  MOVFF  01,50
....................          break;          
....................    } 
....................    return(user_quit); 
16DD4:  MOVFF  50,01
16DD8:  GOTO   16EEA (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BFB8:  MOVF   48,F
0BFBA:  BNZ   BFC8
0BFBC:  MOVF   49,F
0BFBE:  BNZ   BFC8
0BFC0:  MOVF   4A,F
0BFC2:  BNZ   BFC8
0BFC4:  MOVF   4B,F
0BFC6:  BZ    BFE0
0BFC8:  MOVF   4B,F
0BFCA:  BNZ   BFE0
0BFCC:  MOVF   4A,F
0BFCE:  BNZ   BFE0
0BFD0:  MOVF   49,F
0BFD2:  BNZ   BFE0
0BFD4:  MOVF   48,W
0BFD6:  SUBLW  02
0BFD8:  BNC   BFE0
....................       detector = arg; 
0BFDA:  MOVFF  48,2D5
....................    } 
0BFDE:  BRA    BFE4
....................    else cmd_arg(); 
0BFE0:  CALL   B326
0BFE4:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0C006:  MOVF   48,F
0C008:  BNZ   C016
0C00A:  MOVF   49,F
0C00C:  BNZ   C016
0C00E:  MOVF   4A,F
0C010:  BNZ   C016
0C012:  MOVF   4B,F
0C014:  BZ    C070
0C016:  MOVF   4B,F
0C018:  BNZ   C070
0C01A:  MOVF   4A,W
0C01C:  SUBLW  00
0C01E:  BNC   C070
....................       switch (detector){ 
0C020:  MOVLB  2
0C022:  MOVF   xD5,W
0C024:  XORLW  01
0C026:  MOVLB  0
0C028:  BZ    C030
0C02A:  XORLW  03
0C02C:  BZ    C04E
0C02E:  BRA    C06C
....................          case 1 : nv_d1_temp = arg; 
0C030:  MOVFF  49,42
0C034:  MOVFF  48,41
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0C038:  MOVLW  40
0C03A:  MOVLB  8
0C03C:  MOVWF  xEE
0C03E:  MOVFF  42,8F0
0C042:  MOVFF  41,8EF
0C046:  MOVLB  0
0C048:  CALL   4FFC
....................             break; 
0C04C:  BRA    C06E
....................          case 2 : nv_d2_temp = arg; 
0C04E:  MOVFF  49,44
0C052:  MOVFF  48,43
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0C056:  MOVLW  42
0C058:  MOVLB  8
0C05A:  MOVWF  xEE
0C05C:  MOVFF  44,8F0
0C060:  MOVFF  43,8EF
0C064:  MOVLB  0
0C066:  CALL   4FFC
....................             break; 
0C06A:  BRA    C06E
....................          default : cmd_err(); 
0C06C:  RCALL  BFE8
....................             break; 
....................       } 
....................    } 
0C06E:  BRA    C116
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0C070:  MOVF   48,F
0C072:  BNZ   C112
0C074:  MOVF   49,F
0C076:  BNZ   C112
0C078:  MOVF   4A,F
0C07A:  BNZ   C112
0C07C:  MOVF   4B,F
0C07E:  BNZ   C112
0C080:  MOVLW  26
0C082:  MOVWF  FF6
0C084:  MOVLW  24
0C086:  MOVWF  FF7
0C088:  MOVLW  00
0C08A:  MOVWF  FF8
0C08C:  CLRF   1B
0C08E:  BTFSC  FF2.7
0C090:  BSF    1B.7
0C092:  BCF    FF2.7
0C094:  MOVLW  03
0C096:  MOVLB  A
0C098:  MOVWF  x40
0C09A:  MOVLB  0
0C09C:  CALL   1044
0C0A0:  BTFSC  1B.7
0C0A2:  BSF    FF2.7
0C0A4:  MOVLW  10
0C0A6:  MOVWF  FE9
0C0A8:  CLRF   1B
0C0AA:  BTFSC  FF2.7
0C0AC:  BSF    1B.7
0C0AE:  BCF    FF2.7
0C0B0:  MOVFF  42,A41
0C0B4:  MOVFF  41,A40
0C0B8:  CALL   11C6
0C0BC:  BTFSC  1B.7
0C0BE:  BSF    FF2.7
0C0C0:  MOVLW  2C
0C0C2:  MOVWF  FF6
0C0C4:  MOVLW  24
0C0C6:  MOVWF  FF7
0C0C8:  MOVLW  00
0C0CA:  MOVWF  FF8
0C0CC:  CLRF   1B
0C0CE:  BTFSC  FF2.7
0C0D0:  BSF    1B.7
0C0D2:  BCF    FF2.7
0C0D4:  MOVLW  04
0C0D6:  MOVLB  A
0C0D8:  MOVWF  x40
0C0DA:  MOVLB  0
0C0DC:  CALL   1044
0C0E0:  BTFSC  1B.7
0C0E2:  BSF    FF2.7
0C0E4:  MOVLW  10
0C0E6:  MOVWF  FE9
0C0E8:  CLRF   1B
0C0EA:  BTFSC  FF2.7
0C0EC:  BSF    1B.7
0C0EE:  BCF    FF2.7
0C0F0:  MOVFF  44,A41
0C0F4:  MOVFF  43,A40
0C0F8:  CALL   11C6
0C0FC:  BTFSC  1B.7
0C0FE:  BSF    FF2.7
0C100:  MOVLW  0D
0C102:  BTFSS  F9E.4
0C104:  BRA    C102
0C106:  MOVWF  FAD
0C108:  MOVLW  0A
0C10A:  BTFSS  F9E.4
0C10C:  BRA    C10A
0C10E:  MOVWF  FAD
0C110:  BRA    C116
....................    else cmd_arg(); 
0C112:  CALL   B326
0C116:  GOTO   C17C (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0C11A:  MOVF   4B,F
0C11C:  BNZ   C14A
0C11E:  MOVF   4A,F
0C120:  BNZ   C14A
0C122:  MOVF   49,F
0C124:  BNZ   C14A
0C126:  MOVF   48,W
0C128:  SUBLW  01
0C12A:  BNC   C14A
....................       nv_macro_mode = arg; 
0C12C:  MOVFF  49,2A
0C130:  MOVFF  48,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0C134:  MOVLW  20
0C136:  MOVLB  8
0C138:  MOVWF  xEE
0C13A:  MOVFF  2A,8F0
0C13E:  MOVFF  29,8EF
0C142:  MOVLB  0
0C144:  CALL   4FFC
....................    } 
0C148:  BRA    C14E
....................    else cmd_arg(); 
0C14A:  CALL   B326
0C14E:  GOTO   C17C (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0C152:  MOVF   2F,W
0C154:  MOVWF  00
0C156:  MOVF   30,W
0C158:  MOVWF  03
0C15A:  BNZ   C160
0C15C:  MOVF   00,F
0C15E:  BZ    C176
0C160:  MOVF   03,W
0C162:  BNZ   C16A
0C164:  MOVLW  01
0C166:  SUBWF  00,W
0C168:  BZ    C17A
0C16A:  MOVF   03,W
0C16C:  BNZ   C174
0C16E:  MOVLW  03
0C170:  SUBWF  00,W
0C172:  BZ    C17A
0C174:  BRA    C17C
....................       case ECO : commandAe(); 
0C176:  BRA    C006
....................          break; 
0C178:  BRA    C17C
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0C17A:  BRA    C11A
....................          break; 
....................    } 
0C17C:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0C180:  MOVF   48,F
0C182:  BNZ   C190
0C184:  MOVF   49,F
0C186:  BNZ   C190
0C188:  MOVF   4A,F
0C18A:  BNZ   C190
0C18C:  MOVF   4B,F
0C18E:  BZ    C1C0
0C190:  MOVF   4B,F
0C192:  BNZ   C1C0
0C194:  MOVF   4A,F
0C196:  BNZ   C1C0
0C198:  MOVF   49,F
0C19A:  BNZ   C1C0
0C19C:  MOVF   48,W
0C19E:  SUBLW  03
0C1A0:  BNC   C1C0
....................       nv_det_type = arg; 
0C1A2:  MOVFF  49,46
0C1A6:  MOVFF  48,45
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0C1AA:  MOVLW  26
0C1AC:  MOVLB  8
0C1AE:  MOVWF  xEE
0C1B0:  MOVFF  46,8F0
0C1B4:  MOVFF  45,8EF
0C1B8:  MOVLB  0
0C1BA:  CALL   4FFC
....................    } 
0C1BE:  BRA    C226
....................    else if(arg==0) { 
0C1C0:  MOVF   48,F
0C1C2:  BNZ   C222
0C1C4:  MOVF   49,F
0C1C6:  BNZ   C222
0C1C8:  MOVF   4A,F
0C1CA:  BNZ   C222
0C1CC:  MOVF   4B,F
0C1CE:  BNZ   C222
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0C1D0:  MOVLW  36
0C1D2:  MOVWF  FF6
0C1D4:  MOVLW  24
0C1D6:  MOVWF  FF7
0C1D8:  MOVLW  00
0C1DA:  MOVWF  FF8
0C1DC:  CLRF   1B
0C1DE:  BTFSC  FF2.7
0C1E0:  BSF    1B.7
0C1E2:  BCF    FF2.7
0C1E4:  MOVLW  05
0C1E6:  MOVLB  A
0C1E8:  MOVWF  x40
0C1EA:  MOVLB  0
0C1EC:  CALL   1044
0C1F0:  BTFSC  1B.7
0C1F2:  BSF    FF2.7
0C1F4:  MOVLW  10
0C1F6:  MOVWF  FE9
0C1F8:  CLRF   1B
0C1FA:  BTFSC  FF2.7
0C1FC:  BSF    1B.7
0C1FE:  BCF    FF2.7
0C200:  MOVFF  46,A41
0C204:  MOVFF  45,A40
0C208:  CALL   11C6
0C20C:  BTFSC  1B.7
0C20E:  BSF    FF2.7
0C210:  MOVLW  0D
0C212:  BTFSS  F9E.4
0C214:  BRA    C212
0C216:  MOVWF  FAD
0C218:  MOVLW  0A
0C21A:  BTFSS  F9E.4
0C21C:  BRA    C21A
0C21E:  MOVWF  FAD
....................    } 
0C220:  BRA    C226
....................    else cmd_arg(); 
0C222:  CALL   B326
0C226:  GOTO   C2E8 (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0C298:  MOVF   4B,F
0C29A:  BNZ   C2B6
0C29C:  MOVF   4A,F
0C29E:  BNZ   C2B6
0C2A0:  MOVF   49,F
0C2A2:  BNZ   C2B6
0C2A4:  MOVF   48,W
0C2A6:  SUBLW  03
0C2A8:  BNC   C2B6
....................       hb_cmd=arg; 
0C2AA:  MOVFF  48,885
....................       h_bridge(hb_cmd); 
0C2AE:  MOVFF  885,8B5
0C2B2:  RCALL  C278
....................    } 
0C2B4:  BRA    C2BA
....................    else cmd_arg(); 
0C2B6:  CALL   B326
0C2BA:  GOTO   C2E8 (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0C2BE:  MOVF   2F,W
0C2C0:  MOVWF  00
0C2C2:  MOVF   30,W
0C2C4:  MOVWF  03
0C2C6:  BNZ   C2CC
0C2C8:  MOVF   00,F
0C2CA:  BZ    C2E2
0C2CC:  MOVF   03,W
0C2CE:  BNZ   C2D6
0C2D0:  MOVLW  01
0C2D2:  SUBWF  00,W
0C2D4:  BZ    C2E6
0C2D6:  MOVF   03,W
0C2D8:  BNZ   C2E0
0C2DA:  MOVLW  03
0C2DC:  SUBWF  00,W
0C2DE:  BZ    C2E6
0C2E0:  BRA    C2E8
....................       case ECO : commandBe(); 
0C2E2:  BRA    C180
....................          break; 
0C2E4:  BRA    C2E8
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0C2E6:  BRA    C298
....................          break; 
....................    } 
0C2E8:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CDE2:  MOVF   48,W
0CDE4:  MOVWF  00
0CDE6:  MOVF   49,W
0CDE8:  MOVWF  03
0CDEA:  BNZ   CDF0
0CDEC:  MOVF   00,F
0CDEE:  BZ    CE52
0CDF0:  MOVF   03,W
0CDF2:  BNZ   CDFC
0CDF4:  MOVLW  01
0CDF6:  SUBWF  00,W
0CDF8:  BTFSC  FD8.2
0CDFA:  BRA    D042
0CDFC:  MOVF   03,W
0CDFE:  BNZ   CE08
0CE00:  MOVLW  02
0CE02:  SUBWF  00,W
0CE04:  BTFSC  FD8.2
0CE06:  BRA    D09E
0CE08:  MOVF   03,W
0CE0A:  BNZ   CE14
0CE0C:  MOVLW  03
0CE0E:  SUBWF  00,W
0CE10:  BTFSC  FD8.2
0CE12:  BRA    D0FA
0CE14:  MOVF   03,W
0CE16:  BNZ   CE20
0CE18:  MOVLW  04
0CE1A:  SUBWF  00,W
0CE1C:  BTFSC  FD8.2
0CE1E:  BRA    D156
0CE20:  MOVF   03,W
0CE22:  BNZ   CE2C
0CE24:  MOVLW  05
0CE26:  SUBWF  00,W
0CE28:  BTFSC  FD8.2
0CE2A:  BRA    D1B2
0CE2C:  MOVF   03,W
0CE2E:  BNZ   CE38
0CE30:  MOVLW  06
0CE32:  SUBWF  00,W
0CE34:  BTFSC  FD8.2
0CE36:  BRA    D20E
0CE38:  MOVF   03,W
0CE3A:  BNZ   CE44
0CE3C:  MOVLW  07
0CE3E:  SUBWF  00,W
0CE40:  BTFSC  FD8.2
0CE42:  BRA    D26A
0CE44:  MOVF   03,W
0CE46:  BNZ   CE50
0CE48:  MOVLW  08
0CE4A:  SUBWF  00,W
0CE4C:  BTFSC  FD8.2
0CE4E:  BRA    D2C6
0CE50:  BRA    D322
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CE52:  MOVLW  42
0CE54:  MOVWF  FF6
0CE56:  MOVLW  24
0CE58:  MOVWF  FF7
0CE5A:  MOVLW  00
0CE5C:  MOVWF  FF8
0CE5E:  CLRF   1B
0CE60:  BTFSC  FF2.7
0CE62:  BSF    1B.7
0CE64:  BCF    FF2.7
0CE66:  MOVLW  04
0CE68:  MOVLB  A
0CE6A:  MOVWF  x40
0CE6C:  MOVLB  0
0CE6E:  CALL   1044
0CE72:  BTFSC  1B.7
0CE74:  BSF    FF2.7
0CE76:  MOVLW  89
0CE78:  MOVWF  FE9
0CE7A:  MOVFF  3F8,888
0CE7E:  MOVFF  3F7,887
0CE82:  MOVFF  3F6,886
0CE86:  MOVFF  3F5,885
0CE8A:  MOVLW  05
0CE8C:  MOVLB  8
0CE8E:  MOVWF  x89
0CE90:  MOVLB  0
0CE92:  RCALL  C69C
0CE94:  MOVLW  2C
0CE96:  BTFSS  F9E.4
0CE98:  BRA    CE96
0CE9A:  MOVWF  FAD
0CE9C:  MOVLW  89
0CE9E:  MOVWF  FE9
0CEA0:  MOVFF  3FC,888
0CEA4:  MOVFF  3FB,887
0CEA8:  MOVFF  3FA,886
0CEAC:  MOVFF  3F9,885
0CEB0:  MOVLW  05
0CEB2:  MOVLB  8
0CEB4:  MOVWF  x89
0CEB6:  MOVLB  0
0CEB8:  CALL   C69C
0CEBC:  MOVLW  0D
0CEBE:  BTFSS  F9E.4
0CEC0:  BRA    CEBE
0CEC2:  MOVWF  FAD
0CEC4:  MOVLW  0A
0CEC6:  BTFSS  F9E.4
0CEC8:  BRA    CEC6
0CECA:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CECC:  MOVLW  54
0CECE:  MOVWF  FF6
0CED0:  MOVLW  24
0CED2:  MOVWF  FF7
0CED4:  MOVLW  00
0CED6:  MOVWF  FF8
0CED8:  CLRF   1B
0CEDA:  BTFSC  FF2.7
0CEDC:  BSF    1B.7
0CEDE:  BCF    FF2.7
0CEE0:  MOVLW  04
0CEE2:  MOVLB  A
0CEE4:  MOVWF  x40
0CEE6:  MOVLB  0
0CEE8:  CALL   1044
0CEEC:  BTFSC  1B.7
0CEEE:  BSF    FF2.7
0CEF0:  MOVLW  89
0CEF2:  MOVWF  FE9
0CEF4:  MOVFF  400,888
0CEF8:  MOVFF  3FF,887
0CEFC:  MOVFF  3FE,886
0CF00:  MOVFF  3FD,885
0CF04:  MOVLW  05
0CF06:  MOVLB  8
0CF08:  MOVWF  x89
0CF0A:  MOVLB  0
0CF0C:  CALL   C69C
0CF10:  MOVLW  2C
0CF12:  BTFSS  F9E.4
0CF14:  BRA    CF12
0CF16:  MOVWF  FAD
0CF18:  MOVLW  89
0CF1A:  MOVWF  FE9
0CF1C:  MOVFF  404,888
0CF20:  MOVFF  403,887
0CF24:  MOVFF  402,886
0CF28:  MOVFF  401,885
0CF2C:  MOVLW  05
0CF2E:  MOVLB  8
0CF30:  MOVWF  x89
0CF32:  MOVLB  0
0CF34:  CALL   C69C
0CF38:  MOVLW  0D
0CF3A:  BTFSS  F9E.4
0CF3C:  BRA    CF3A
0CF3E:  MOVWF  FAD
0CF40:  MOVLW  0A
0CF42:  BTFSS  F9E.4
0CF44:  BRA    CF42
0CF46:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CF48:  MOVLW  66
0CF4A:  MOVWF  FF6
0CF4C:  MOVLW  24
0CF4E:  MOVWF  FF7
0CF50:  MOVLW  00
0CF52:  MOVWF  FF8
0CF54:  CLRF   1B
0CF56:  BTFSC  FF2.7
0CF58:  BSF    1B.7
0CF5A:  BCF    FF2.7
0CF5C:  MOVLW  04
0CF5E:  MOVLB  A
0CF60:  MOVWF  x40
0CF62:  MOVLB  0
0CF64:  CALL   1044
0CF68:  BTFSC  1B.7
0CF6A:  BSF    FF2.7
0CF6C:  MOVLW  89
0CF6E:  MOVWF  FE9
0CF70:  MOVFF  408,888
0CF74:  MOVFF  407,887
0CF78:  MOVFF  406,886
0CF7C:  MOVFF  405,885
0CF80:  MOVLW  05
0CF82:  MOVLB  8
0CF84:  MOVWF  x89
0CF86:  MOVLB  0
0CF88:  CALL   C69C
0CF8C:  MOVLW  2C
0CF8E:  BTFSS  F9E.4
0CF90:  BRA    CF8E
0CF92:  MOVWF  FAD
0CF94:  MOVLW  89
0CF96:  MOVWF  FE9
0CF98:  MOVFF  40C,888
0CF9C:  MOVFF  40B,887
0CFA0:  MOVFF  40A,886
0CFA4:  MOVFF  409,885
0CFA8:  MOVLW  05
0CFAA:  MOVLB  8
0CFAC:  MOVWF  x89
0CFAE:  MOVLB  0
0CFB0:  CALL   C69C
0CFB4:  MOVLW  0D
0CFB6:  BTFSS  F9E.4
0CFB8:  BRA    CFB6
0CFBA:  MOVWF  FAD
0CFBC:  MOVLW  0A
0CFBE:  BTFSS  F9E.4
0CFC0:  BRA    CFBE
0CFC2:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CFC4:  MOVLW  78
0CFC6:  MOVWF  FF6
0CFC8:  MOVLW  24
0CFCA:  MOVWF  FF7
0CFCC:  MOVLW  00
0CFCE:  MOVWF  FF8
0CFD0:  CLRF   1B
0CFD2:  BTFSC  FF2.7
0CFD4:  BSF    1B.7
0CFD6:  BCF    FF2.7
0CFD8:  MOVLW  05
0CFDA:  MOVLB  A
0CFDC:  MOVWF  x40
0CFDE:  MOVLB  0
0CFE0:  CALL   1044
0CFE4:  BTFSC  1B.7
0CFE6:  BSF    FF2.7
0CFE8:  MOVLW  89
0CFEA:  MOVWF  FE9
0CFEC:  MOVFF  410,888
0CFF0:  MOVFF  40F,887
0CFF4:  MOVFF  40E,886
0CFF8:  MOVFF  40D,885
0CFFC:  MOVLW  05
0CFFE:  MOVLB  8
0D000:  MOVWF  x89
0D002:  MOVLB  0
0D004:  CALL   C69C
0D008:  MOVLW  2C
0D00A:  BTFSS  F9E.4
0D00C:  BRA    D00A
0D00E:  MOVWF  FAD
0D010:  MOVLW  89
0D012:  MOVWF  FE9
0D014:  MOVFF  414,888
0D018:  MOVFF  413,887
0D01C:  MOVFF  412,886
0D020:  MOVFF  411,885
0D024:  MOVLW  05
0D026:  MOVLB  8
0D028:  MOVWF  x89
0D02A:  MOVLB  0
0D02C:  CALL   C69C
0D030:  MOVLW  0D
0D032:  BTFSS  F9E.4
0D034:  BRA    D032
0D036:  MOVWF  FAD
0D038:  MOVLW  0A
0D03A:  BTFSS  F9E.4
0D03C:  BRA    D03A
0D03E:  MOVWF  FAD
....................                   break; 
0D040:  BRA    D326
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0D042:  MOVLW  8C
0D044:  MOVWF  FF6
0D046:  MOVLW  24
0D048:  MOVWF  FF7
0D04A:  MOVLW  00
0D04C:  MOVWF  FF8
0D04E:  CLRF   1B
0D050:  BTFSC  FF2.7
0D052:  BSF    1B.7
0D054:  BCF    FF2.7
0D056:  CALL   0E6E
0D05A:  BTFSC  1B.7
0D05C:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0D05E:  RCALL  CD2E
0D060:  MOVFF  03,3F8
0D064:  MOVFF  02,3F7
0D068:  MOVFF  01,3F6
0D06C:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");   
0D070:  MOVLW  0D
0D072:  BTFSS  F9E.4
0D074:  BRA    D072
0D076:  MOVWF  FAD
0D078:  MOVLW  0A
0D07A:  BTFSS  F9E.4
0D07C:  BRA    D07A
0D07E:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0D080:  MOVLB  8
0D082:  CLRF   x86
0D084:  MOVLW  44
0D086:  MOVWF  x85
0D088:  MOVFF  3F8,88A
0D08C:  MOVFF  3F7,889
0D090:  MOVFF  3F6,888
0D094:  MOVFF  3F5,887
0D098:  MOVLB  0
0D09A:  RCALL  CD74
....................          break; 
0D09C:  BRA    D326
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0D09E:  MOVLW  94
0D0A0:  MOVWF  FF6
0D0A2:  MOVLW  24
0D0A4:  MOVWF  FF7
0D0A6:  MOVLW  00
0D0A8:  MOVWF  FF8
0D0AA:  CLRF   1B
0D0AC:  BTFSC  FF2.7
0D0AE:  BSF    1B.7
0D0B0:  BCF    FF2.7
0D0B2:  CALL   0E6E
0D0B6:  BTFSC  1B.7
0D0B8:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0D0BA:  RCALL  CD2E
0D0BC:  MOVFF  03,3FC
0D0C0:  MOVFF  02,3FB
0D0C4:  MOVFF  01,3FA
0D0C8:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n");  
0D0CC:  MOVLW  0D
0D0CE:  BTFSS  F9E.4
0D0D0:  BRA    D0CE
0D0D2:  MOVWF  FAD
0D0D4:  MOVLW  0A
0D0D6:  BTFSS  F9E.4
0D0D8:  BRA    D0D6
0D0DA:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0D0DC:  MOVLB  8
0D0DE:  CLRF   x86
0D0E0:  MOVLW  48
0D0E2:  MOVWF  x85
0D0E4:  MOVFF  3FC,88A
0D0E8:  MOVFF  3FB,889
0D0EC:  MOVFF  3FA,888
0D0F0:  MOVFF  3F9,887
0D0F4:  MOVLB  0
0D0F6:  RCALL  CD74
....................          break; 
0D0F8:  BRA    D326
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0D0FA:  MOVLW  9C
0D0FC:  MOVWF  FF6
0D0FE:  MOVLW  24
0D100:  MOVWF  FF7
0D102:  MOVLW  00
0D104:  MOVWF  FF8
0D106:  CLRF   1B
0D108:  BTFSC  FF2.7
0D10A:  BSF    1B.7
0D10C:  BCF    FF2.7
0D10E:  CALL   0E6E
0D112:  BTFSC  1B.7
0D114:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0D116:  RCALL  CD2E
0D118:  MOVFF  03,400
0D11C:  MOVFF  02,3FF
0D120:  MOVFF  01,3FE
0D124:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n"); 
0D128:  MOVLW  0D
0D12A:  BTFSS  F9E.4
0D12C:  BRA    D12A
0D12E:  MOVWF  FAD
0D130:  MOVLW  0A
0D132:  BTFSS  F9E.4
0D134:  BRA    D132
0D136:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0D138:  MOVLB  8
0D13A:  CLRF   x86
0D13C:  MOVLW  4C
0D13E:  MOVWF  x85
0D140:  MOVFF  400,88A
0D144:  MOVFF  3FF,889
0D148:  MOVFF  3FE,888
0D14C:  MOVFF  3FD,887
0D150:  MOVLB  0
0D152:  RCALL  CD74
....................          break; 
0D154:  BRA    D326
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0D156:  MOVLW  A4
0D158:  MOVWF  FF6
0D15A:  MOVLW  24
0D15C:  MOVWF  FF7
0D15E:  MOVLW  00
0D160:  MOVWF  FF8
0D162:  CLRF   1B
0D164:  BTFSC  FF2.7
0D166:  BSF    1B.7
0D168:  BCF    FF2.7
0D16A:  CALL   0E6E
0D16E:  BTFSC  1B.7
0D170:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0D172:  RCALL  CD2E
0D174:  MOVFF  03,404
0D178:  MOVFF  02,403
0D17C:  MOVFF  01,402
0D180:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");  
0D184:  MOVLW  0D
0D186:  BTFSS  F9E.4
0D188:  BRA    D186
0D18A:  MOVWF  FAD
0D18C:  MOVLW  0A
0D18E:  BTFSS  F9E.4
0D190:  BRA    D18E
0D192:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0D194:  MOVLB  8
0D196:  CLRF   x86
0D198:  MOVLW  52
0D19A:  MOVWF  x85
0D19C:  MOVFF  3FC,88A
0D1A0:  MOVFF  3FB,889
0D1A4:  MOVFF  3FA,888
0D1A8:  MOVFF  3F9,887
0D1AC:  MOVLB  0
0D1AE:  RCALL  CD74
....................          break; 
0D1B0:  BRA    D326
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0D1B2:  MOVLW  AC
0D1B4:  MOVWF  FF6
0D1B6:  MOVLW  24
0D1B8:  MOVWF  FF7
0D1BA:  MOVLW  00
0D1BC:  MOVWF  FF8
0D1BE:  CLRF   1B
0D1C0:  BTFSC  FF2.7
0D1C2:  BSF    1B.7
0D1C4:  BCF    FF2.7
0D1C6:  CALL   0E6E
0D1CA:  BTFSC  1B.7
0D1CC:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0D1CE:  RCALL  CD2E
0D1D0:  MOVFF  03,408
0D1D4:  MOVFF  02,407
0D1D8:  MOVFF  01,406
0D1DC:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");   
0D1E0:  MOVLW  0D
0D1E2:  BTFSS  F9E.4
0D1E4:  BRA    D1E2
0D1E6:  MOVWF  FAD
0D1E8:  MOVLW  0A
0D1EA:  BTFSS  F9E.4
0D1EC:  BRA    D1EA
0D1EE:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0D1F0:  MOVLB  8
0D1F2:  CLRF   x86
0D1F4:  MOVLW  56
0D1F6:  MOVWF  x85
0D1F8:  MOVFF  408,88A
0D1FC:  MOVFF  407,889
0D200:  MOVFF  406,888
0D204:  MOVFF  405,887
0D208:  MOVLB  0
0D20A:  RCALL  CD74
....................          break; 
0D20C:  BRA    D326
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0D20E:  MOVLW  B4
0D210:  MOVWF  FF6
0D212:  MOVLW  24
0D214:  MOVWF  FF7
0D216:  MOVLW  00
0D218:  MOVWF  FF8
0D21A:  CLRF   1B
0D21C:  BTFSC  FF2.7
0D21E:  BSF    1B.7
0D220:  BCF    FF2.7
0D222:  CALL   0E6E
0D226:  BTFSC  1B.7
0D228:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0D22A:  RCALL  CD2E
0D22C:  MOVFF  03,40C
0D230:  MOVFF  02,40B
0D234:  MOVFF  01,40A
0D238:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");  
0D23C:  MOVLW  0D
0D23E:  BTFSS  F9E.4
0D240:  BRA    D23E
0D242:  MOVWF  FAD
0D244:  MOVLW  0A
0D246:  BTFSS  F9E.4
0D248:  BRA    D246
0D24A:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0D24C:  MOVLB  8
0D24E:  CLRF   x86
0D250:  MOVLW  5A
0D252:  MOVWF  x85
0D254:  MOVFF  40C,88A
0D258:  MOVFF  40B,889
0D25C:  MOVFF  40A,888
0D260:  MOVFF  409,887
0D264:  MOVLB  0
0D266:  RCALL  CD74
....................          break; 
0D268:  BRA    D326
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0D26A:  MOVLW  BC
0D26C:  MOVWF  FF6
0D26E:  MOVLW  24
0D270:  MOVWF  FF7
0D272:  MOVLW  00
0D274:  MOVWF  FF8
0D276:  CLRF   1B
0D278:  BTFSC  FF2.7
0D27A:  BSF    1B.7
0D27C:  BCF    FF2.7
0D27E:  CALL   0E6E
0D282:  BTFSC  1B.7
0D284:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0D286:  RCALL  CD2E
0D288:  MOVFF  03,410
0D28C:  MOVFF  02,40F
0D290:  MOVFF  01,40E
0D294:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");   
0D298:  MOVLW  0D
0D29A:  BTFSS  F9E.4
0D29C:  BRA    D29A
0D29E:  MOVWF  FAD
0D2A0:  MOVLW  0A
0D2A2:  BTFSS  F9E.4
0D2A4:  BRA    D2A2
0D2A6:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0D2A8:  MOVLB  8
0D2AA:  CLRF   x86
0D2AC:  MOVLW  5E
0D2AE:  MOVWF  x85
0D2B0:  MOVFF  410,88A
0D2B4:  MOVFF  40F,889
0D2B8:  MOVFF  40E,888
0D2BC:  MOVFF  40D,887
0D2C0:  MOVLB  0
0D2C2:  RCALL  CD74
....................          break; 
0D2C4:  BRA    D326
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0D2C6:  MOVLW  C6
0D2C8:  MOVWF  FF6
0D2CA:  MOVLW  24
0D2CC:  MOVWF  FF7
0D2CE:  MOVLW  00
0D2D0:  MOVWF  FF8
0D2D2:  CLRF   1B
0D2D4:  BTFSC  FF2.7
0D2D6:  BSF    1B.7
0D2D8:  BCF    FF2.7
0D2DA:  CALL   0E6E
0D2DE:  BTFSC  1B.7
0D2E0:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0D2E2:  RCALL  CD2E
0D2E4:  MOVFF  03,414
0D2E8:  MOVFF  02,413
0D2EC:  MOVFF  01,412
0D2F0:  MOVFF  00,411
....................                fprintf(COM_A,"\r\n");  
0D2F4:  MOVLW  0D
0D2F6:  BTFSS  F9E.4
0D2F8:  BRA    D2F6
0D2FA:  MOVWF  FAD
0D2FC:  MOVLW  0A
0D2FE:  BTFSS  F9E.4
0D300:  BRA    D2FE
0D302:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0D304:  MOVLB  8
0D306:  CLRF   x86
0D308:  MOVLW  62
0D30A:  MOVWF  x85
0D30C:  MOVFF  414,88A
0D310:  MOVFF  413,889
0D314:  MOVFF  412,888
0D318:  MOVFF  411,887
0D31C:  MOVLB  0
0D31E:  RCALL  CD74
....................          break;         
0D320:  BRA    D326
....................       default: cmd_arg(); 
0D322:  CALL   B326
....................          break; 
....................    } 
0D326:  GOTO   DD1C (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0DA36:  MOVF   4B,F
0DA38:  BNZ   DA48
0DA3A:  MOVF   4A,F
0DA3C:  BNZ   DA48
0DA3E:  MOVF   49,F
0DA40:  BNZ   DA48
0DA42:  MOVF   48,W
0DA44:  SUBLW  01
0DA46:  BC    DA98
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0DA48:  MOVF   4B,F
0DA4A:  BNZ   DA62
0DA4C:  MOVF   4A,F
0DA4E:  BNZ   DA62
0DA50:  MOVF   49,F
0DA52:  BNZ   DA62
0DA54:  MOVF   48,W
0DA56:  SUBLW  30
0DA58:  BNC   DA62
0DA5A:  DECFSZ 2F,W
0DA5C:  BRA    DA62
0DA5E:  MOVF   30,F
0DA60:  BZ    DA7E
0DA62:  MOVF   4B,F
0DA64:  BNZ   DA92
0DA66:  MOVF   4A,F
0DA68:  BNZ   DA92
0DA6A:  MOVF   49,F
0DA6C:  BNZ   DA92
0DA6E:  MOVF   48,W
0DA70:  SUBLW  32
0DA72:  BNC   DA92
0DA74:  MOVF   2F,W
0DA76:  SUBLW  03
0DA78:  BNZ   DA92
0DA7A:  MOVF   30,F
0DA7C:  BNZ   DA92
....................          port=arg; 
0DA7E:  MOVFF  49,886
0DA82:  MOVFF  48,885
....................          play_wms_hard_macro(port);    
0DA86:  MOVFF  886,88A
0DA8A:  MOVFF  885,889
0DA8E:  RCALL  D828
....................       } 
0DA90:  BRA    DA96
....................       else cmd_arg(); 
0DA92:  CALL   B326
....................    } 
0DA96:  BRA    DA9C
....................    else cmd_arg(); 
0DA98:  CALL   B326
0DA9C:  GOTO   DD1C (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0DCAC:  MOVF   48,F
0DCAE:  BNZ   DCBC
0DCB0:  MOVF   49,F
0DCB2:  BNZ   DCBC
0DCB4:  MOVF   4A,F
0DCB6:  BNZ   DCBC
0DCB8:  MOVF   4B,F
0DCBA:  BZ    DCDA
0DCBC:  MOVF   4B,F
0DCBE:  BNZ   DCDA
0DCC0:  MOVF   4A,F
0DCC2:  BNZ   DCDA
0DCC4:  MOVF   49,F
0DCC6:  BNZ   DCDA
0DCC8:  MOVF   48,W
0DCCA:  SUBLW  04
0DCCC:  BNC   DCDA
....................       chip=arg; 
0DCCE:  MOVFF  48,885
....................       sol_chip_cmd(chip); 
0DCD2:  MOVFF  885,8B6
0DCD6:  RCALL  DBDE
....................    } 
0DCD8:  BRA    DCDE
....................    else cmd_arg();    
0DCDA:  CALL   B326
0DCDE:  GOTO   DD1C (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0DCE2:  MOVF   2F,W
0DCE4:  MOVWF  00
0DCE6:  MOVF   30,W
0DCE8:  MOVWF  03
0DCEA:  BNZ   DCF0
0DCEC:  MOVF   00,F
0DCEE:  BZ    DD10
0DCF0:  MOVF   03,W
0DCF2:  BNZ   DCFA
0DCF4:  MOVLW  01
0DCF6:  SUBWF  00,W
0DCF8:  BZ    DD16
0DCFA:  MOVF   03,W
0DCFC:  BNZ   DD04
0DCFE:  MOVLW  03
0DD00:  SUBWF  00,W
0DD02:  BZ    DD16
0DD04:  MOVF   03,W
0DD06:  BNZ   DD0E
0DD08:  MOVLW  02
0DD0A:  SUBWF  00,W
0DD0C:  BZ    DD1A
0DD0E:  BRA    DD1C
....................       case ECO : commandCe(); 
0DD10:  GOTO   CDE2
....................          break; 
0DD14:  BRA    DD1C
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0DD16:  BRA    DA36
....................          break; 
0DD18:  BRA    DD1C
....................       case AWS : commandCa(); 
0DD1A:  BRA    DCAC
....................          break;          
....................    } 
0DD1C:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0DD20:  MOVF   48,W
0DD22:  MOVWF  00
0DD24:  MOVF   49,W
0DD26:  MOVWF  03
0DD28:  BNZ   DD2E
0DD2A:  MOVF   00,F
0DD2C:  BZ    DD4E
0DD2E:  MOVF   03,W
0DD30:  BNZ   DD38
0DD32:  MOVLW  01
0DD34:  SUBWF  00,W
0DD36:  BZ    DD60
0DD38:  MOVF   03,W
0DD3A:  BNZ   DD42
0DD3C:  MOVLW  02
0DD3E:  SUBWF  00,W
0DD40:  BZ    DD82
0DD42:  MOVF   03,W
0DD44:  BNZ   DD4C
0DD46:  MOVLW  03
0DD48:  SUBWF  00,W
0DD4A:  BZ    DD94
0DD4C:  BRA    DDB6
....................       case 0 : file_list(file_ptr_raw_all); 
0DD4E:  MOVLW  02
0DD50:  MOVLB  8
0DD52:  MOVWF  x8A
0DD54:  MOVLW  DD
0DD56:  MOVWF  x89
0DD58:  MOVLB  0
0DD5A:  CALL   BB4C
....................          break; 
0DD5E:  BRA    DDBA
....................       case 1 : file_list(file_ptr_raw_new); 
0DD60:  MOVLW  02
0DD62:  MOVLB  8
0DD64:  MOVWF  x8A
0DD66:  MOVLW  EB
0DD68:  MOVWF  x89
0DD6A:  MOVLB  0
0DD6C:  CALL   BB4C
....................                f_unlink(file_ptr_raw_new); 
0DD70:  MOVLW  02
0DD72:  MOVLB  8
0DD74:  MOVWF  x8A
0DD76:  MOVLW  EB
0DD78:  MOVWF  x89
0DD7A:  MOVLB  0
0DD7C:  CALL   BCC6
....................          break; 
0DD80:  BRA    DDBA
....................       case 2 : file_list(file_ptr_rel_all); 
0DD82:  MOVLW  02
0DD84:  MOVLB  8
0DD86:  MOVWF  x8A
0DD88:  MOVLW  F9
0DD8A:  MOVWF  x89
0DD8C:  MOVLB  0
0DD8E:  CALL   BB4C
....................          break; 
0DD92:  BRA    DDBA
....................       case 3 : file_list(file_ptr_rel_new); 
0DD94:  MOVLW  03
0DD96:  MOVLB  8
0DD98:  MOVWF  x8A
0DD9A:  MOVLW  07
0DD9C:  MOVWF  x89
0DD9E:  MOVLB  0
0DDA0:  CALL   BB4C
....................                f_unlink(file_ptr_rel_new); 
0DDA4:  MOVLW  03
0DDA6:  MOVLB  8
0DDA8:  MOVWF  x8A
0DDAA:  MOVLW  07
0DDAC:  MOVWF  x89
0DDAE:  MOVLB  0
0DDB0:  CALL   BCC6
....................          break;  
0DDB4:  BRA    DDBA
....................       default : cmd_arg(); 
0DDB6:  CALL   B326
....................          break; 
....................    } 
0DDBA:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DDBE:  MOVF   48,W
0DDC0:  MOVWF  00
0DDC2:  MOVF   49,W
0DDC4:  MOVWF  03
0DDC6:  BNZ   DDCC
0DDC8:  MOVF   00,F
0DDCA:  BZ    DDD8
0DDCC:  MOVF   03,W
0DDCE:  BNZ   DDD6
0DDD0:  MOVLW  02
0DDD2:  SUBWF  00,W
0DDD4:  BZ    DE52
0DDD6:  BRA    DECC
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DDD8:  MOVLW  D0
0DDDA:  MOVWF  FF6
0DDDC:  MOVLW  24
0DDDE:  MOVWF  FF7
0DDE0:  MOVLW  00
0DDE2:  MOVWF  FF8
0DDE4:  CLRF   1B
0DDE6:  BTFSC  FF2.7
0DDE8:  BSF    1B.7
0DDEA:  BCF    FF2.7
0DDEC:  CALL   0E6E
0DDF0:  BTFSC  1B.7
0DDF2:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DDF4:  CALL   0E58
0DDF8:  MOVFF  01,885
....................       if(result == 'Y'){ 
0DDFC:  MOVLB  8
0DDFE:  MOVF   x85,W
0DE00:  SUBLW  59
0DE02:  BNZ   DE32
....................       f_unlink(file_ptr_raw_all); 
0DE04:  MOVLW  02
0DE06:  MOVWF  x8A
0DE08:  MOVLW  DD
0DE0A:  MOVWF  x89
0DE0C:  MOVLB  0
0DE0E:  CALL   BCC6
....................       printf("File deleted!\n\r"); 
0DE12:  MOVLW  0C
0DE14:  MOVWF  FF6
0DE16:  MOVLW  25
0DE18:  MOVWF  FF7
0DE1A:  MOVLW  00
0DE1C:  MOVWF  FF8
0DE1E:  CLRF   1B
0DE20:  BTFSC  FF2.7
0DE22:  BSF    1B.7
0DE24:  BCF    FF2.7
0DE26:  CALL   0E6E
0DE2A:  BTFSC  1B.7
0DE2C:  BSF    FF2.7
....................       }else{ 
0DE2E:  BRA    DE50
0DE30:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DE32:  MOVLW  1C
0DE34:  MOVWF  FF6
0DE36:  MOVLW  25
0DE38:  MOVWF  FF7
0DE3A:  MOVLW  00
0DE3C:  MOVWF  FF8
0DE3E:  CLRF   1B
0DE40:  BTFSC  FF2.7
0DE42:  BSF    1B.7
0DE44:  BCF    FF2.7
0DE46:  MOVLB  0
0DE48:  CALL   0E6E
0DE4C:  BTFSC  1B.7
0DE4E:  BSF    FF2.7
....................       } 
....................          break; 
0DE50:  BRA    DED0
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DE52:  MOVLW  32
0DE54:  MOVWF  FF6
0DE56:  MOVLW  25
0DE58:  MOVWF  FF7
0DE5A:  MOVLW  00
0DE5C:  MOVWF  FF8
0DE5E:  CLRF   1B
0DE60:  BTFSC  FF2.7
0DE62:  BSF    1B.7
0DE64:  BCF    FF2.7
0DE66:  CALL   0E6E
0DE6A:  BTFSC  1B.7
0DE6C:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DE6E:  CALL   0E58
0DE72:  MOVFF  01,885
....................          if(result == 'Y'){ 
0DE76:  MOVLB  8
0DE78:  MOVF   x85,W
0DE7A:  SUBLW  59
0DE7C:  BNZ   DEAC
....................             f_unlink(file_ptr_rel_all); 
0DE7E:  MOVLW  02
0DE80:  MOVWF  x8A
0DE82:  MOVLW  F9
0DE84:  MOVWF  x89
0DE86:  MOVLB  0
0DE88:  CALL   BCC6
....................             printf("File deleted!\n\r"); 
0DE8C:  MOVLW  76
0DE8E:  MOVWF  FF6
0DE90:  MOVLW  25
0DE92:  MOVWF  FF7
0DE94:  MOVLW  00
0DE96:  MOVWF  FF8
0DE98:  CLRF   1B
0DE9A:  BTFSC  FF2.7
0DE9C:  BSF    1B.7
0DE9E:  BCF    FF2.7
0DEA0:  CALL   0E6E
0DEA4:  BTFSC  1B.7
0DEA6:  BSF    FF2.7
....................          }else{ 
0DEA8:  BRA    DECA
0DEAA:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DEAC:  MOVLW  86
0DEAE:  MOVWF  FF6
0DEB0:  MOVLW  25
0DEB2:  MOVWF  FF7
0DEB4:  MOVLW  00
0DEB6:  MOVWF  FF8
0DEB8:  CLRF   1B
0DEBA:  BTFSC  FF2.7
0DEBC:  BSF    1B.7
0DEBE:  BCF    FF2.7
0DEC0:  MOVLB  0
0DEC2:  CALL   0E6E
0DEC6:  BTFSC  1B.7
0DEC8:  BSF    FF2.7
....................          } 
....................          break; 
0DECA:  BRA    DED0
....................       default : cmd_arg(); 
0DECC:  CALL   B326
....................          break;          
....................    } 
0DED0:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0E0BC:  MOVF   48,W
0E0BE:  SUBLW  95
0E0C0:  BNZ   E0D4
0E0C2:  MOVF   49,W
0E0C4:  SUBLW  15
0E0C6:  BNZ   E0D4
0E0C8:  MOVF   4A,F
0E0CA:  BNZ   E0D4
0E0CC:  MOVF   4B,F
0E0CE:  BNZ   E0D4
....................       reset_nv_vars(); 
0E0D0:  BRA    DED4
....................    } 
0E0D2:  BRA    E0D8
....................    else cmd_arg(); 
0E0D4:  CALL   B326
0E0D8:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0E126:  MOVF   2F,F
0E128:  BNZ   E12E
0E12A:  MOVF   30,F
0E12C:  BZ    E140
0E12E:  DECFSZ 2F,W
0E130:  BRA    E136
0E132:  MOVF   30,F
0E134:  BZ    E140
0E136:  MOVF   2F,W
0E138:  SUBLW  03
0E13A:  BNZ   E1B2
0E13C:  MOVF   30,F
0E13E:  BNZ   E1B2
....................    { 
....................       busy_set(); 
0E140:  CALL   29E8
....................  
....................       switch(arg) 
0E144:  MOVFF  48,00
0E148:  MOVF   49,W
0E14A:  MOVWF  03
0E14C:  BNZ   E154
0E14E:  MOVLW  01
0E150:  SUBWF  00,W
0E152:  BZ    E16A
0E154:  MOVF   03,W
0E156:  BNZ   E15E
0E158:  MOVLW  02
0E15A:  SUBWF  00,W
0E15C:  BZ    E17A
0E15E:  MOVF   03,W
0E160:  BNZ   E168
0E162:  MOVLW  03
0E164:  SUBWF  00,W
0E166:  BZ    E1A4
0E168:  BRA    E1AA
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0E16A:  MOVLB  7
0E16C:  CLRF   x40
....................             align(0); 
0E16E:  MOVLB  8
0E170:  CLRF   xC2
0E172:  MOVLB  0
0E174:  CALL   A8DC
....................             break; 
0E178:  BRA    E1AE
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0E17A:  MOVF   48,W
0E17C:  SUBLW  02
0E17E:  BNZ   E1A2
0E180:  MOVF   49,F
0E182:  BNZ   E1A2
0E184:  MOVF   4A,F
0E186:  BNZ   E1A2
0E188:  MOVF   4B,F
0E18A:  BNZ   E1A2
0E18C:  MOVF   1F,W
0E18E:  SUBLW  04
0E190:  BNZ   E1A2
0E192:  MOVF   20,F
0E194:  BNZ   E1A2
....................             { 
....................                motor=0; 
0E196:  MOVLB  7
0E198:  CLRF   x40
....................                cal_disk(0); 
0E19A:  MOVLB  8
0E19C:  CLRF   x85
0E19E:  MOVLB  0
0E1A0:  BRA    E0DC
....................             } 
....................             break; 
0E1A2:  BRA    E1AE
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0E1A4:  CALL   AA80
....................             break; 
0E1A8:  BRA    E1AE
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0E1AA:  CALL   B326
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0E1AE:  CALL   AED8
....................    } 
0E1B2:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E68C:  DECFSZ 48,W
0E68E:  BRA    EAAC
0E690:  MOVF   49,F
0E692:  BTFSS  FD8.2
0E694:  BRA    EAAC
0E696:  MOVF   4A,F
0E698:  BTFSS  FD8.2
0E69A:  BRA    EAAC
0E69C:  MOVF   4B,F
0E69E:  BTFSS  FD8.2
0E6A0:  BRA    EAAC
....................       v_supply = read_supply(); 
0E6A2:  CALL   5124
0E6A6:  MOVFF  02,886
0E6AA:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0E6AE:  CALL   34DA
....................       RTC_read(); 
0E6B2:  CALL   336C
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E6B6:  MOVLW  9C
0E6B8:  MOVWF  FF6
0E6BA:  MOVLW  25
0E6BC:  MOVWF  FF7
0E6BE:  MOVLW  00
0E6C0:  MOVWF  FF8
0E6C2:  CLRF   1B
0E6C4:  BTFSC  FF2.7
0E6C6:  BSF    1B.7
0E6C8:  BCF    FF2.7
0E6CA:  MOVLW  04
0E6CC:  MOVLB  A
0E6CE:  MOVWF  x40
0E6D0:  MOVLB  0
0E6D2:  CALL   1044
0E6D6:  BTFSC  1B.7
0E6D8:  BSF    FF2.7
0E6DA:  MOVLW  10
0E6DC:  MOVWF  FE9
0E6DE:  CLRF   1B
0E6E0:  BTFSC  FF2.7
0E6E2:  BSF    1B.7
0E6E4:  BCF    FF2.7
0E6E6:  MOVFF  26,A41
0E6EA:  MOVFF  25,A40
0E6EE:  CALL   11C6
0E6F2:  BTFSC  1B.7
0E6F4:  BSF    FF2.7
0E6F6:  MOVLW  20
0E6F8:  BTFSS  F9E.4
0E6FA:  BRA    E6F8
0E6FC:  MOVWF  FAD
0E6FE:  MOVLW  49
0E700:  BTFSS  F9E.4
0E702:  BRA    E700
0E704:  MOVWF  FAD
0E706:  MOVLW  10
0E708:  MOVWF  FE9
0E70A:  CLRF   1B
0E70C:  BTFSC  FF2.7
0E70E:  BSF    1B.7
0E710:  BCF    FF2.7
0E712:  MOVFF  24,A41
0E716:  MOVFF  23,A40
0E71A:  CALL   11C6
0E71E:  BTFSC  1B.7
0E720:  BSF    FF2.7
0E722:  MOVLW  20
0E724:  BTFSS  F9E.4
0E726:  BRA    E724
0E728:  MOVWF  FAD
0E72A:  MOVLW  4E
0E72C:  BTFSS  F9E.4
0E72E:  BRA    E72C
0E730:  MOVWF  FAD
0E732:  MOVLW  10
0E734:  MOVWF  FE9
0E736:  CLRF   1B
0E738:  BTFSC  FF2.7
0E73A:  BSF    1B.7
0E73C:  BCF    FF2.7
0E73E:  MOVFF  22,A41
0E742:  MOVFF  21,A40
0E746:  CALL   11C6
0E74A:  BTFSC  1B.7
0E74C:  BSF    FF2.7
0E74E:  MOVLW  2F
0E750:  BTFSS  F9E.4
0E752:  BRA    E750
0E754:  MOVWF  FAD
0E756:  MOVLW  10
0E758:  MOVWF  FE9
0E75A:  CLRF   1B
0E75C:  BTFSC  FF2.7
0E75E:  BSF    1B.7
0E760:  BCF    FF2.7
0E762:  MOVFF  28,A41
0E766:  MOVFF  27,A40
0E76A:  CALL   11C6
0E76E:  BTFSC  1B.7
0E770:  BSF    FF2.7
0E772:  MOVLW  20
0E774:  BTFSS  F9E.4
0E776:  BRA    E774
0E778:  MOVWF  FAD
0E77A:  MOVLW  58
0E77C:  BTFSS  F9E.4
0E77E:  BRA    E77C
0E780:  MOVWF  FAD
0E782:  MOVLW  10
0E784:  MOVWF  FE9
0E786:  CLRF   1B
0E788:  BTFSC  FF2.7
0E78A:  BSF    1B.7
0E78C:  BCF    FF2.7
0E78E:  MOVFF  20,A41
0E792:  MOVFF  1F,A40
0E796:  CALL   11C6
0E79A:  BTFSC  1B.7
0E79C:  BSF    FF2.7
0E79E:  MOVLW  20
0E7A0:  BTFSS  F9E.4
0E7A2:  BRA    E7A0
0E7A4:  MOVWF  FAD
0E7A6:  MOVLW  55
0E7A8:  BTFSS  F9E.4
0E7AA:  BRA    E7A8
0E7AC:  MOVWF  FAD
0E7AE:  CLRF   1B
0E7B0:  BTFSC  FF2.7
0E7B2:  BSF    1B.7
0E7B4:  BCF    FF2.7
0E7B6:  MOVFF  740,A40
0E7BA:  MOVLW  1B
0E7BC:  MOVLB  A
0E7BE:  MOVWF  x41
0E7C0:  MOVLB  0
0E7C2:  CALL   0FC6
0E7C6:  BTFSC  1B.7
0E7C8:  BSF    FF2.7
0E7CA:  MOVLW  20
0E7CC:  BTFSS  F9E.4
0E7CE:  BRA    E7CC
0E7D0:  MOVWF  FAD
0E7D2:  MOVLW  04
0E7D4:  MOVWF  FE9
0E7D6:  MOVLB  8
0E7D8:  CLRF   x8A
0E7DA:  CLRF   x89
0E7DC:  MOVFF  886,888
0E7E0:  MOVFF  885,887
0E7E4:  MOVLW  02
0E7E6:  MOVWF  x8B
0E7E8:  MOVLB  0
0E7EA:  RCALL  E1B6
0E7EC:  MOVLW  C0
0E7EE:  MOVWF  FF6
0E7F0:  MOVLW  25
0E7F2:  MOVWF  FF7
0E7F4:  MOVLW  00
0E7F6:  MOVWF  FF8
0E7F8:  CLRF   1B
0E7FA:  BTFSC  FF2.7
0E7FC:  BSF    1B.7
0E7FE:  BCF    FF2.7
0E800:  MOVLW  03
0E802:  MOVLB  A
0E804:  MOVWF  x40
0E806:  MOVLB  0
0E808:  CALL   1044
0E80C:  BTFSC  1B.7
0E80E:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E810:  MOVLW  C4
0E812:  MOVWF  FF6
0E814:  MOVLW  25
0E816:  MOVWF  FF7
0E818:  MOVLW  00
0E81A:  MOVWF  FF8
0E81C:  CLRF   1B
0E81E:  BTFSC  FF2.7
0E820:  BSF    1B.7
0E822:  BCF    FF2.7
0E824:  MOVLW  09
0E826:  MOVLB  A
0E828:  MOVWF  x40
0E82A:  MOVLB  0
0E82C:  CALL   1044
0E830:  BTFSC  1B.7
0E832:  BSF    FF2.7
0E834:  MOVLW  10
0E836:  MOVWF  FE9
0E838:  CLRF   1B
0E83A:  BTFSC  FF2.7
0E83C:  BSF    1B.7
0E83E:  BCF    FF2.7
0E840:  MOVFF  7C4,A41
0E844:  MOVFF  7C3,A40
0E848:  CALL   11C6
0E84C:  BTFSC  1B.7
0E84E:  BSF    FF2.7
0E850:  MOVLW  D0
0E852:  MOVWF  FF6
0E854:  MOVLW  25
0E856:  MOVWF  FF7
0E858:  MOVLW  00
0E85A:  MOVWF  FF8
0E85C:  CLRF   1B
0E85E:  BTFSC  FF2.7
0E860:  BSF    1B.7
0E862:  BCF    FF2.7
0E864:  MOVLW  05
0E866:  MOVLB  A
0E868:  MOVWF  x40
0E86A:  MOVLB  0
0E86C:  CALL   1044
0E870:  BTFSC  1B.7
0E872:  BSF    FF2.7
0E874:  MOVLW  10
0E876:  MOVWF  FE9
0E878:  MOVFF  7B6,8F1
0E87C:  MOVFF  7B5,8F0
0E880:  CALL   900C
0E884:  MOVLW  0D
0E886:  BTFSS  F9E.4
0E888:  BRA    E886
0E88A:  MOVWF  FAD
0E88C:  MOVLW  0A
0E88E:  BTFSS  F9E.4
0E890:  BRA    E88E
0E892:  MOVWF  FAD
....................       RTC_display(); 
0E894:  RCALL  E2B2
....................       if (RTCfmt == 0) 
0E896:  MOVF   4F,F
0E898:  BTFSS  FD8.2
0E89A:  BRA    E9A0
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E89C:  MOVLW  DC
0E89E:  MOVWF  FF6
0E8A0:  MOVLW  25
0E8A2:  MOVWF  FF7
0E8A4:  MOVLW  00
0E8A6:  MOVWF  FF8
0E8A8:  CLRF   1B
0E8AA:  BTFSC  FF2.7
0E8AC:  BSF    1B.7
0E8AE:  BCF    FF2.7
0E8B0:  MOVLW  05
0E8B2:  MOVLB  A
0E8B4:  MOVWF  x40
0E8B6:  MOVLB  0
0E8B8:  CALL   1044
0E8BC:  BTFSC  1B.7
0E8BE:  BSF    FF2.7
0E8C0:  CLRF   1B
0E8C2:  BTFSC  FF2.7
0E8C4:  BSF    1B.7
0E8C6:  BCF    FF2.7
0E8C8:  MOVFF  73A,A40
0E8CC:  MOVLW  01
0E8CE:  MOVLB  A
0E8D0:  MOVWF  x41
0E8D2:  MOVLB  0
0E8D4:  CALL   0FC6
0E8D8:  BTFSC  1B.7
0E8DA:  BSF    FF2.7
0E8DC:  MOVLW  2F
0E8DE:  BTFSS  F9E.4
0E8E0:  BRA    E8DE
0E8E2:  MOVWF  FAD
0E8E4:  CLRF   1B
0E8E6:  BTFSC  FF2.7
0E8E8:  BSF    1B.7
0E8EA:  BCF    FF2.7
0E8EC:  MOVFF  73B,A40
0E8F0:  MOVLW  01
0E8F2:  MOVLB  A
0E8F4:  MOVWF  x41
0E8F6:  MOVLB  0
0E8F8:  CALL   0FC6
0E8FC:  BTFSC  1B.7
0E8FE:  BSF    FF2.7
0E900:  MOVLW  2F
0E902:  BTFSS  F9E.4
0E904:  BRA    E902
0E906:  MOVWF  FAD
0E908:  CLRF   1B
0E90A:  BTFSC  FF2.7
0E90C:  BSF    1B.7
0E90E:  BCF    FF2.7
0E910:  MOVFF  73C,A40
0E914:  MOVLW  01
0E916:  MOVLB  A
0E918:  MOVWF  x41
0E91A:  MOVLB  0
0E91C:  CALL   0FC6
0E920:  BTFSC  1B.7
0E922:  BSF    FF2.7
0E924:  MOVLW  20
0E926:  BTFSS  F9E.4
0E928:  BRA    E926
0E92A:  MOVWF  FAD
0E92C:  CLRF   1B
0E92E:  BTFSC  FF2.7
0E930:  BSF    1B.7
0E932:  BCF    FF2.7
0E934:  MOVFF  73D,A40
0E938:  MOVLW  01
0E93A:  MOVLB  A
0E93C:  MOVWF  x41
0E93E:  MOVLB  0
0E940:  CALL   0FC6
0E944:  BTFSC  1B.7
0E946:  BSF    FF2.7
0E948:  MOVLW  3A
0E94A:  BTFSS  F9E.4
0E94C:  BRA    E94A
0E94E:  MOVWF  FAD
0E950:  CLRF   1B
0E952:  BTFSC  FF2.7
0E954:  BSF    1B.7
0E956:  BCF    FF2.7
0E958:  MOVFF  73E,A40
0E95C:  MOVLW  01
0E95E:  MOVLB  A
0E960:  MOVWF  x41
0E962:  MOVLB  0
0E964:  CALL   0FC6
0E968:  BTFSC  1B.7
0E96A:  BSF    FF2.7
0E96C:  MOVLW  3A
0E96E:  BTFSS  F9E.4
0E970:  BRA    E96E
0E972:  MOVWF  FAD
0E974:  CLRF   1B
0E976:  BTFSC  FF2.7
0E978:  BSF    1B.7
0E97A:  BCF    FF2.7
0E97C:  MOVFF  73F,A40
0E980:  MOVLW  01
0E982:  MOVLB  A
0E984:  MOVWF  x41
0E986:  MOVLB  0
0E988:  CALL   0FC6
0E98C:  BTFSC  1B.7
0E98E:  BSF    FF2.7
0E990:  MOVLW  0D
0E992:  BTFSS  F9E.4
0E994:  BRA    E992
0E996:  MOVWF  FAD
0E998:  MOVLW  0A
0E99A:  BTFSS  F9E.4
0E99C:  BRA    E99A
0E99E:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E9A0:  DECFSZ 4F,W
0E9A2:  BRA    EAA8
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E9A4:  MOVLW  02
0E9A6:  MOVWF  FF6
0E9A8:  MOVLW  26
0E9AA:  MOVWF  FF7
0E9AC:  MOVLW  00
0E9AE:  MOVWF  FF8
0E9B0:  CLRF   1B
0E9B2:  BTFSC  FF2.7
0E9B4:  BSF    1B.7
0E9B6:  BCF    FF2.7
0E9B8:  MOVLW  05
0E9BA:  MOVLB  A
0E9BC:  MOVWF  x40
0E9BE:  MOVLB  0
0E9C0:  CALL   1044
0E9C4:  BTFSC  1B.7
0E9C6:  BSF    FF2.7
0E9C8:  CLRF   1B
0E9CA:  BTFSC  FF2.7
0E9CC:  BSF    1B.7
0E9CE:  BCF    FF2.7
0E9D0:  MOVFF  73B,A40
0E9D4:  MOVLW  01
0E9D6:  MOVLB  A
0E9D8:  MOVWF  x41
0E9DA:  MOVLB  0
0E9DC:  CALL   0FC6
0E9E0:  BTFSC  1B.7
0E9E2:  BSF    FF2.7
0E9E4:  MOVLW  2F
0E9E6:  BTFSS  F9E.4
0E9E8:  BRA    E9E6
0E9EA:  MOVWF  FAD
0E9EC:  CLRF   1B
0E9EE:  BTFSC  FF2.7
0E9F0:  BSF    1B.7
0E9F2:  BCF    FF2.7
0E9F4:  MOVFF  73A,A40
0E9F8:  MOVLW  01
0E9FA:  MOVLB  A
0E9FC:  MOVWF  x41
0E9FE:  MOVLB  0
0EA00:  CALL   0FC6
0EA04:  BTFSC  1B.7
0EA06:  BSF    FF2.7
0EA08:  MOVLW  2F
0EA0A:  BTFSS  F9E.4
0EA0C:  BRA    EA0A
0EA0E:  MOVWF  FAD
0EA10:  CLRF   1B
0EA12:  BTFSC  FF2.7
0EA14:  BSF    1B.7
0EA16:  BCF    FF2.7
0EA18:  MOVFF  73C,A40
0EA1C:  MOVLW  01
0EA1E:  MOVLB  A
0EA20:  MOVWF  x41
0EA22:  MOVLB  0
0EA24:  CALL   0FC6
0EA28:  BTFSC  1B.7
0EA2A:  BSF    FF2.7
0EA2C:  MOVLW  20
0EA2E:  BTFSS  F9E.4
0EA30:  BRA    EA2E
0EA32:  MOVWF  FAD
0EA34:  CLRF   1B
0EA36:  BTFSC  FF2.7
0EA38:  BSF    1B.7
0EA3A:  BCF    FF2.7
0EA3C:  MOVFF  73D,A40
0EA40:  MOVLW  01
0EA42:  MOVLB  A
0EA44:  MOVWF  x41
0EA46:  MOVLB  0
0EA48:  CALL   0FC6
0EA4C:  BTFSC  1B.7
0EA4E:  BSF    FF2.7
0EA50:  MOVLW  3A
0EA52:  BTFSS  F9E.4
0EA54:  BRA    EA52
0EA56:  MOVWF  FAD
0EA58:  CLRF   1B
0EA5A:  BTFSC  FF2.7
0EA5C:  BSF    1B.7
0EA5E:  BCF    FF2.7
0EA60:  MOVFF  73E,A40
0EA64:  MOVLW  01
0EA66:  MOVLB  A
0EA68:  MOVWF  x41
0EA6A:  MOVLB  0
0EA6C:  CALL   0FC6
0EA70:  BTFSC  1B.7
0EA72:  BSF    FF2.7
0EA74:  MOVLW  3A
0EA76:  BTFSS  F9E.4
0EA78:  BRA    EA76
0EA7A:  MOVWF  FAD
0EA7C:  CLRF   1B
0EA7E:  BTFSC  FF2.7
0EA80:  BSF    1B.7
0EA82:  BCF    FF2.7
0EA84:  MOVFF  73F,A40
0EA88:  MOVLW  01
0EA8A:  MOVLB  A
0EA8C:  MOVWF  x41
0EA8E:  MOVLB  0
0EA90:  CALL   0FC6
0EA94:  BTFSC  1B.7
0EA96:  BSF    FF2.7
0EA98:  MOVLW  0D
0EA9A:  BTFSS  F9E.4
0EA9C:  BRA    EA9A
0EA9E:  MOVWF  FAD
0EAA0:  MOVLW  0A
0EAA2:  BTFSS  F9E.4
0EAA4:  BRA    EAA2
0EAA6:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0EAA8:  RCALL  E43C
....................       RTC_display_alarm(); 
0EAAA:  RCALL  E512
....................    } 
0EAAC:  GOTO   F2C0 (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0EAB0:  DECFSZ 48,W
0EAB2:  BRA    ED8A
0EAB4:  MOVF   49,F
0EAB6:  BTFSS  FD8.2
0EAB8:  BRA    ED8A
0EABA:  MOVF   4A,F
0EABC:  BTFSS  FD8.2
0EABE:  BRA    ED8A
0EAC0:  MOVF   4B,F
0EAC2:  BTFSS  FD8.2
0EAC4:  BRA    ED8A
....................       v_supply = read_supply(); 
0EAC6:  CALL   5124
0EACA:  MOVFF  02,886
0EACE:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0EAD2:  CALL   34DA
....................       RTC_read(); 
0EAD6:  CALL   336C
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0EADA:  MOVLW  41
0EADC:  BTFSS  F9E.4
0EADE:  BRA    EADC
0EAE0:  MOVWF  FAD
0EAE2:  MOVLW  10
0EAE4:  MOVWF  FE9
0EAE6:  CLRF   1B
0EAE8:  BTFSC  FF2.7
0EAEA:  BSF    1B.7
0EAEC:  BCF    FF2.7
0EAEE:  MOVFF  2A,A41
0EAF2:  MOVFF  29,A40
0EAF6:  CALL   11C6
0EAFA:  BTFSC  1B.7
0EAFC:  BSF    FF2.7
0EAFE:  MOVLW  20
0EB00:  BTFSS  F9E.4
0EB02:  BRA    EB00
0EB04:  MOVWF  FAD
0EB06:  MOVLW  49
0EB08:  BTFSS  F9E.4
0EB0A:  BRA    EB08
0EB0C:  MOVWF  FAD
0EB0E:  MOVLW  10
0EB10:  MOVWF  FE9
0EB12:  CLRF   1B
0EB14:  BTFSC  FF2.7
0EB16:  BSF    1B.7
0EB18:  BCF    FF2.7
0EB1A:  MOVFF  24,A41
0EB1E:  MOVFF  23,A40
0EB22:  CALL   11C6
0EB26:  BTFSC  1B.7
0EB28:  BSF    FF2.7
0EB2A:  MOVLW  20
0EB2C:  BTFSS  F9E.4
0EB2E:  BRA    EB2C
0EB30:  MOVWF  FAD
0EB32:  MOVLW  4C
0EB34:  BTFSS  F9E.4
0EB36:  BRA    EB34
0EB38:  MOVWF  FAD
0EB3A:  MOVLW  10
0EB3C:  MOVWF  FE9
0EB3E:  CLRF   1B
0EB40:  BTFSC  FF2.7
0EB42:  BSF    1B.7
0EB44:  BCF    FF2.7
0EB46:  MOVFF  2C,A41
0EB4A:  MOVFF  2B,A40
0EB4E:  CALL   11C6
0EB52:  BTFSC  1B.7
0EB54:  BSF    FF2.7
0EB56:  MOVLW  20
0EB58:  BTFSS  F9E.4
0EB5A:  BRA    EB58
0EB5C:  MOVWF  FAD
0EB5E:  MOVLW  51
0EB60:  BTFSS  F9E.4
0EB62:  BRA    EB60
0EB64:  MOVWF  FAD
0EB66:  MOVLW  10
0EB68:  MOVWF  FE9
0EB6A:  CLRF   1B
0EB6C:  BTFSC  FF2.7
0EB6E:  BSF    1B.7
0EB70:  BCF    FF2.7
0EB72:  MOVFF  2E,A41
0EB76:  MOVFF  2D,A40
0EB7A:  CALL   11C6
0EB7E:  BTFSC  1B.7
0EB80:  BSF    FF2.7
0EB82:  MOVLW  20
0EB84:  BTFSS  F9E.4
0EB86:  BRA    EB84
0EB88:  MOVWF  FAD
0EB8A:  MOVLW  53
0EB8C:  BTFSS  F9E.4
0EB8E:  BRA    EB8C
0EB90:  MOVWF  FAD
0EB92:  MOVLW  10
0EB94:  MOVWF  FE9
0EB96:  CLRF   1B
0EB98:  BTFSC  FF2.7
0EB9A:  BSF    1B.7
0EB9C:  BCF    FF2.7
0EB9E:  MOVFF  22,A41
0EBA2:  MOVFF  21,A40
0EBA6:  CALL   11C6
0EBAA:  BTFSC  1B.7
0EBAC:  BSF    FF2.7
0EBAE:  MOVLW  20
0EBB0:  BTFSS  F9E.4
0EBB2:  BRA    EBB0
0EBB4:  MOVWF  FAD
0EBB6:  MOVLW  04
0EBB8:  MOVWF  FE9
0EBBA:  MOVLB  8
0EBBC:  CLRF   x8A
0EBBE:  CLRF   x89
0EBC0:  MOVFF  886,888
0EBC4:  MOVFF  885,887
0EBC8:  MOVLW  02
0EBCA:  MOVWF  x8B
0EBCC:  MOVLB  0
0EBCE:  CALL   E1B6
0EBD2:  MOVLW  46
0EBD4:  MOVWF  FF6
0EBD6:  MOVLW  26
0EBD8:  MOVWF  FF7
0EBDA:  MOVLW  00
0EBDC:  MOVWF  FF8
0EBDE:  CLRF   1B
0EBE0:  BTFSC  FF2.7
0EBE2:  BSF    1B.7
0EBE4:  BCF    FF2.7
0EBE6:  MOVLW  03
0EBE8:  MOVLB  A
0EBEA:  MOVWF  x40
0EBEC:  MOVLB  0
0EBEE:  CALL   1044
0EBF2:  BTFSC  1B.7
0EBF4:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0EBF6:  MOVLW  4A
0EBF8:  MOVWF  FF6
0EBFA:  MOVLW  26
0EBFC:  MOVWF  FF7
0EBFE:  MOVLW  00
0EC00:  MOVWF  FF8
0EC02:  CLRF   1B
0EC04:  BTFSC  FF2.7
0EC06:  BSF    1B.7
0EC08:  BCF    FF2.7
0EC0A:  MOVLW  09
0EC0C:  MOVLB  A
0EC0E:  MOVWF  x40
0EC10:  MOVLB  0
0EC12:  CALL   1044
0EC16:  BTFSC  1B.7
0EC18:  BSF    FF2.7
0EC1A:  MOVLW  10
0EC1C:  MOVWF  FE9
0EC1E:  CLRF   1B
0EC20:  BTFSC  FF2.7
0EC22:  BSF    1B.7
0EC24:  BCF    FF2.7
0EC26:  MOVFF  7C4,A41
0EC2A:  MOVFF  7C3,A40
0EC2E:  CALL   11C6
0EC32:  BTFSC  1B.7
0EC34:  BSF    FF2.7
0EC36:  MOVLW  56
0EC38:  MOVWF  FF6
0EC3A:  MOVLW  26
0EC3C:  MOVWF  FF7
0EC3E:  MOVLW  00
0EC40:  MOVWF  FF8
0EC42:  CLRF   1B
0EC44:  BTFSC  FF2.7
0EC46:  BSF    1B.7
0EC48:  BCF    FF2.7
0EC4A:  MOVLW  05
0EC4C:  MOVLB  A
0EC4E:  MOVWF  x40
0EC50:  MOVLB  0
0EC52:  CALL   1044
0EC56:  BTFSC  1B.7
0EC58:  BSF    FF2.7
0EC5A:  MOVLW  10
0EC5C:  MOVWF  FE9
0EC5E:  MOVFF  7B6,8F1
0EC62:  MOVFF  7B5,8F0
0EC66:  CALL   900C
0EC6A:  MOVLW  0D
0EC6C:  BTFSS  F9E.4
0EC6E:  BRA    EC6C
0EC70:  MOVWF  FAD
0EC72:  MOVLW  0A
0EC74:  BTFSS  F9E.4
0EC76:  BRA    EC74
0EC78:  MOVWF  FAD
....................       RTC_display(); 
0EC7A:  CALL   E2B2
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EC7E:  MOVLW  62
0EC80:  MOVWF  FF6
0EC82:  MOVLW  26
0EC84:  MOVWF  FF7
0EC86:  MOVLW  00
0EC88:  MOVWF  FF8
0EC8A:  CLRF   1B
0EC8C:  BTFSC  FF2.7
0EC8E:  BSF    1B.7
0EC90:  BCF    FF2.7
0EC92:  MOVLW  05
0EC94:  MOVLB  A
0EC96:  MOVWF  x40
0EC98:  MOVLB  0
0EC9A:  CALL   1044
0EC9E:  BTFSC  1B.7
0ECA0:  BSF    FF2.7
0ECA2:  CLRF   1B
0ECA4:  BTFSC  FF2.7
0ECA6:  BSF    1B.7
0ECA8:  BCF    FF2.7
0ECAA:  MOVFF  73A,A40
0ECAE:  MOVLW  01
0ECB0:  MOVLB  A
0ECB2:  MOVWF  x41
0ECB4:  MOVLB  0
0ECB6:  CALL   0FC6
0ECBA:  BTFSC  1B.7
0ECBC:  BSF    FF2.7
0ECBE:  MOVLW  2F
0ECC0:  BTFSS  F9E.4
0ECC2:  BRA    ECC0
0ECC4:  MOVWF  FAD
0ECC6:  CLRF   1B
0ECC8:  BTFSC  FF2.7
0ECCA:  BSF    1B.7
0ECCC:  BCF    FF2.7
0ECCE:  MOVFF  73B,A40
0ECD2:  MOVLW  01
0ECD4:  MOVLB  A
0ECD6:  MOVWF  x41
0ECD8:  MOVLB  0
0ECDA:  CALL   0FC6
0ECDE:  BTFSC  1B.7
0ECE0:  BSF    FF2.7
0ECE2:  MOVLW  2F
0ECE4:  BTFSS  F9E.4
0ECE6:  BRA    ECE4
0ECE8:  MOVWF  FAD
0ECEA:  CLRF   1B
0ECEC:  BTFSC  FF2.7
0ECEE:  BSF    1B.7
0ECF0:  BCF    FF2.7
0ECF2:  MOVFF  73C,A40
0ECF6:  MOVLW  01
0ECF8:  MOVLB  A
0ECFA:  MOVWF  x41
0ECFC:  MOVLB  0
0ECFE:  CALL   0FC6
0ED02:  BTFSC  1B.7
0ED04:  BSF    FF2.7
0ED06:  MOVLW  20
0ED08:  BTFSS  F9E.4
0ED0A:  BRA    ED08
0ED0C:  MOVWF  FAD
0ED0E:  CLRF   1B
0ED10:  BTFSC  FF2.7
0ED12:  BSF    1B.7
0ED14:  BCF    FF2.7
0ED16:  MOVFF  73D,A40
0ED1A:  MOVLW  01
0ED1C:  MOVLB  A
0ED1E:  MOVWF  x41
0ED20:  MOVLB  0
0ED22:  CALL   0FC6
0ED26:  BTFSC  1B.7
0ED28:  BSF    FF2.7
0ED2A:  MOVLW  3A
0ED2C:  BTFSS  F9E.4
0ED2E:  BRA    ED2C
0ED30:  MOVWF  FAD
0ED32:  CLRF   1B
0ED34:  BTFSC  FF2.7
0ED36:  BSF    1B.7
0ED38:  BCF    FF2.7
0ED3A:  MOVFF  73E,A40
0ED3E:  MOVLW  01
0ED40:  MOVLB  A
0ED42:  MOVWF  x41
0ED44:  MOVLB  0
0ED46:  CALL   0FC6
0ED4A:  BTFSC  1B.7
0ED4C:  BSF    FF2.7
0ED4E:  MOVLW  3A
0ED50:  BTFSS  F9E.4
0ED52:  BRA    ED50
0ED54:  MOVWF  FAD
0ED56:  CLRF   1B
0ED58:  BTFSC  FF2.7
0ED5A:  BSF    1B.7
0ED5C:  BCF    FF2.7
0ED5E:  MOVFF  73F,A40
0ED62:  MOVLW  01
0ED64:  MOVLB  A
0ED66:  MOVWF  x41
0ED68:  MOVLB  0
0ED6A:  CALL   0FC6
0ED6E:  BTFSC  1B.7
0ED70:  BSF    FF2.7
0ED72:  MOVLW  0D
0ED74:  BTFSS  F9E.4
0ED76:  BRA    ED74
0ED78:  MOVWF  FAD
0ED7A:  MOVLW  0A
0ED7C:  BTFSS  F9E.4
0ED7E:  BRA    ED7C
0ED80:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0ED82:  CALL   E43C
....................       RTC_display_alarm(); 
0ED86:  CALL   E512
....................    } 
0ED8A:  GOTO   F2C0 (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0F018:  DECFSZ 48,W
0F01A:  BRA    F280
0F01C:  MOVF   49,F
0F01E:  BTFSS  FD8.2
0F020:  BRA    F280
0F022:  MOVF   4A,F
0F024:  BTFSS  FD8.2
0F026:  BRA    F280
0F028:  MOVF   4B,F
0F02A:  BTFSS  FD8.2
0F02C:  BRA    F280
....................       v_supply = read_supply(); 
0F02E:  CALL   5124
0F032:  MOVFF  02,886
0F036:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0F03A:  CALL   34DA
....................       RTC_read(); 
0F03E:  CALL   336C
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0F042:  MOVLW  49
0F044:  BTFSS  F9E.4
0F046:  BRA    F044
0F048:  MOVWF  FAD
0F04A:  MOVLW  10
0F04C:  MOVWF  FE9
0F04E:  CLRF   1B
0F050:  BTFSC  FF2.7
0F052:  BSF    1B.7
0F054:  BCF    FF2.7
0F056:  MOVFF  24,A41
0F05A:  MOVFF  23,A40
0F05E:  CALL   11C6
0F062:  BTFSC  1B.7
0F064:  BSF    FF2.7
0F066:  MOVLW  20
0F068:  BTFSS  F9E.4
0F06A:  BRA    F068
0F06C:  MOVWF  FAD
0F06E:  MOVLW  4E
0F070:  BTFSS  F9E.4
0F072:  BRA    F070
0F074:  MOVWF  FAD
0F076:  MOVLW  10
0F078:  MOVWF  FE9
0F07A:  CLRF   1B
0F07C:  BTFSC  FF2.7
0F07E:  BSF    1B.7
0F080:  BCF    FF2.7
0F082:  MOVFF  22,A41
0F086:  MOVFF  21,A40
0F08A:  CALL   11C6
0F08E:  BTFSC  1B.7
0F090:  BSF    FF2.7
0F092:  MOVLW  2F
0F094:  BTFSS  F9E.4
0F096:  BRA    F094
0F098:  MOVWF  FAD
0F09A:  MOVLW  10
0F09C:  MOVWF  FE9
0F09E:  CLRF   1B
0F0A0:  BTFSC  FF2.7
0F0A2:  BSF    1B.7
0F0A4:  BCF    FF2.7
0F0A6:  MOVFF  28,A41
0F0AA:  MOVFF  27,A40
0F0AE:  CALL   11C6
0F0B2:  BTFSC  1B.7
0F0B4:  BSF    FF2.7
0F0B6:  MOVLW  20
0F0B8:  BTFSS  F9E.4
0F0BA:  BRA    F0B8
0F0BC:  MOVWF  FAD
0F0BE:  MOVLW  50
0F0C0:  BTFSS  F9E.4
0F0C2:  BRA    F0C0
0F0C4:  MOVWF  FAD
0F0C6:  MOVLW  10
0F0C8:  MOVWF  FE9
0F0CA:  CLRF   1B
0F0CC:  BTFSC  FF2.7
0F0CE:  BSF    1B.7
0F0D0:  BCF    FF2.7
0F0D2:  MOVFF  2E,A41
0F0D6:  MOVFF  2D,A40
0F0DA:  CALL   11C6
0F0DE:  BTFSC  1B.7
0F0E0:  BSF    FF2.7
0F0E2:  MOVLW  20
0F0E4:  BTFSS  F9E.4
0F0E6:  BRA    F0E4
0F0E8:  MOVWF  FAD
0F0EA:  MOVLW  04
0F0EC:  MOVWF  FE9
0F0EE:  MOVLB  8
0F0F0:  CLRF   x8A
0F0F2:  CLRF   x89
0F0F4:  MOVFF  886,888
0F0F8:  MOVFF  885,887
0F0FC:  MOVLW  02
0F0FE:  MOVWF  x8B
0F100:  MOVLB  0
0F102:  CALL   E1B6
0F106:  MOVLW  A0
0F108:  MOVWF  FF6
0F10A:  MOVLW  26
0F10C:  MOVWF  FF7
0F10E:  MOVLW  00
0F110:  MOVWF  FF8
0F112:  CLRF   1B
0F114:  BTFSC  FF2.7
0F116:  BSF    1B.7
0F118:  BCF    FF2.7
0F11A:  MOVLW  03
0F11C:  MOVLB  A
0F11E:  MOVWF  x40
0F120:  MOVLB  0
0F122:  CALL   1044
0F126:  BTFSC  1B.7
0F128:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0F12A:  MOVLW  A4
0F12C:  MOVWF  FF6
0F12E:  MOVLW  26
0F130:  MOVWF  FF7
0F132:  MOVLW  00
0F134:  MOVWF  FF8
0F136:  CLRF   1B
0F138:  BTFSC  FF2.7
0F13A:  BSF    1B.7
0F13C:  BCF    FF2.7
0F13E:  MOVLW  09
0F140:  MOVLB  A
0F142:  MOVWF  x40
0F144:  MOVLB  0
0F146:  CALL   1044
0F14A:  BTFSC  1B.7
0F14C:  BSF    FF2.7
0F14E:  MOVLW  10
0F150:  MOVWF  FE9
0F152:  MOVFF  7B6,8F1
0F156:  MOVFF  7B5,8F0
0F15A:  CALL   900C
0F15E:  MOVLW  0D
0F160:  BTFSS  F9E.4
0F162:  BRA    F160
0F164:  MOVWF  FAD
0F166:  MOVLW  0A
0F168:  BTFSS  F9E.4
0F16A:  BRA    F168
0F16C:  MOVWF  FAD
....................       display_valve_status(); 
0F16E:  RCALL  ED8E
....................       RTC_display(); 
0F170:  CALL   E2B2
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0F174:  MOVLW  B4
0F176:  MOVWF  FF6
0F178:  MOVLW  26
0F17A:  MOVWF  FF7
0F17C:  MOVLW  00
0F17E:  MOVWF  FF8
0F180:  CLRF   1B
0F182:  BTFSC  FF2.7
0F184:  BSF    1B.7
0F186:  BCF    FF2.7
0F188:  MOVLW  05
0F18A:  MOVLB  A
0F18C:  MOVWF  x40
0F18E:  MOVLB  0
0F190:  CALL   1044
0F194:  BTFSC  1B.7
0F196:  BSF    FF2.7
0F198:  CLRF   1B
0F19A:  BTFSC  FF2.7
0F19C:  BSF    1B.7
0F19E:  BCF    FF2.7
0F1A0:  MOVFF  73A,A40
0F1A4:  MOVLW  01
0F1A6:  MOVLB  A
0F1A8:  MOVWF  x41
0F1AA:  MOVLB  0
0F1AC:  CALL   0FC6
0F1B0:  BTFSC  1B.7
0F1B2:  BSF    FF2.7
0F1B4:  MOVLW  2F
0F1B6:  BTFSS  F9E.4
0F1B8:  BRA    F1B6
0F1BA:  MOVWF  FAD
0F1BC:  CLRF   1B
0F1BE:  BTFSC  FF2.7
0F1C0:  BSF    1B.7
0F1C2:  BCF    FF2.7
0F1C4:  MOVFF  73B,A40
0F1C8:  MOVLW  01
0F1CA:  MOVLB  A
0F1CC:  MOVWF  x41
0F1CE:  MOVLB  0
0F1D0:  CALL   0FC6
0F1D4:  BTFSC  1B.7
0F1D6:  BSF    FF2.7
0F1D8:  MOVLW  2F
0F1DA:  BTFSS  F9E.4
0F1DC:  BRA    F1DA
0F1DE:  MOVWF  FAD
0F1E0:  CLRF   1B
0F1E2:  BTFSC  FF2.7
0F1E4:  BSF    1B.7
0F1E6:  BCF    FF2.7
0F1E8:  MOVFF  73C,A40
0F1EC:  MOVLW  01
0F1EE:  MOVLB  A
0F1F0:  MOVWF  x41
0F1F2:  MOVLB  0
0F1F4:  CALL   0FC6
0F1F8:  BTFSC  1B.7
0F1FA:  BSF    FF2.7
0F1FC:  MOVLW  20
0F1FE:  BTFSS  F9E.4
0F200:  BRA    F1FE
0F202:  MOVWF  FAD
0F204:  CLRF   1B
0F206:  BTFSC  FF2.7
0F208:  BSF    1B.7
0F20A:  BCF    FF2.7
0F20C:  MOVFF  73D,A40
0F210:  MOVLW  01
0F212:  MOVLB  A
0F214:  MOVWF  x41
0F216:  MOVLB  0
0F218:  CALL   0FC6
0F21C:  BTFSC  1B.7
0F21E:  BSF    FF2.7
0F220:  MOVLW  3A
0F222:  BTFSS  F9E.4
0F224:  BRA    F222
0F226:  MOVWF  FAD
0F228:  CLRF   1B
0F22A:  BTFSC  FF2.7
0F22C:  BSF    1B.7
0F22E:  BCF    FF2.7
0F230:  MOVFF  73E,A40
0F234:  MOVLW  01
0F236:  MOVLB  A
0F238:  MOVWF  x41
0F23A:  MOVLB  0
0F23C:  CALL   0FC6
0F240:  BTFSC  1B.7
0F242:  BSF    FF2.7
0F244:  MOVLW  3A
0F246:  BTFSS  F9E.4
0F248:  BRA    F246
0F24A:  MOVWF  FAD
0F24C:  CLRF   1B
0F24E:  BTFSC  FF2.7
0F250:  BSF    1B.7
0F252:  BCF    FF2.7
0F254:  MOVFF  73F,A40
0F258:  MOVLW  01
0F25A:  MOVLB  A
0F25C:  MOVWF  x41
0F25E:  MOVLB  0
0F260:  CALL   0FC6
0F264:  BTFSC  1B.7
0F266:  BSF    FF2.7
0F268:  MOVLW  0D
0F26A:  BTFSS  F9E.4
0F26C:  BRA    F26A
0F26E:  MOVWF  FAD
0F270:  MOVLW  0A
0F272:  BTFSS  F9E.4
0F274:  BRA    F272
0F276:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0F278:  CALL   E43C
....................       RTC_display_alarm(); 
0F27C:  CALL   E512
....................    } 
0F280:  GOTO   F2C0 (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0F284:  MOVF   2F,W
0F286:  MOVWF  00
0F288:  MOVF   30,W
0F28A:  MOVWF  03
0F28C:  BNZ   F292
0F28E:  MOVF   00,F
0F290:  BZ    F2B2
0F292:  MOVF   03,W
0F294:  BNZ   F29C
0F296:  MOVLW  01
0F298:  SUBWF  00,W
0F29A:  BZ    F2B8
0F29C:  MOVF   03,W
0F29E:  BNZ   F2A6
0F2A0:  MOVLW  03
0F2A2:  SUBWF  00,W
0F2A4:  BZ    F2B8
0F2A6:  MOVF   03,W
0F2A8:  BNZ   F2B0
0F2AA:  MOVLW  02
0F2AC:  SUBWF  00,W
0F2AE:  BZ    F2BE
0F2B0:  BRA    F2C0
....................       case ECO : commandHe(); 
0F2B2:  GOTO   E68C
....................          break; 
0F2B6:  BRA    F2C0
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0F2B8:  GOTO   EAB0
....................          break; 
0F2BC:  BRA    F2C0
....................       case AWS : commandHa(); 
0F2BE:  BRA    F018
....................          break;          
....................    } 
0F2C0:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0F2C4:  MOVF   48,F
0F2C6:  BNZ   F2D4
0F2C8:  MOVF   49,F
0F2CA:  BNZ   F2D4
0F2CC:  MOVF   4A,F
0F2CE:  BNZ   F2D4
0F2D0:  MOVF   4B,F
0F2D2:  BZ    F308
0F2D4:  MOVF   4B,F
0F2D6:  BNZ   F308
0F2D8:  MOVF   4A,F
0F2DA:  BNZ   F308
0F2DC:  MOVF   49,W
0F2DE:  SUBLW  FD
0F2E0:  BNC   F308
0F2E2:  BNZ   F2EA
0F2E4:  MOVF   48,W
0F2E6:  SUBLW  20
0F2E8:  BNC   F308
....................       nv_interval = arg; 
0F2EA:  MOVFF  49,24
0F2EE:  MOVFF  48,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0F2F2:  MOVLW  14
0F2F4:  MOVLB  8
0F2F6:  MOVWF  xEE
0F2F8:  MOVFF  24,8F0
0F2FC:  MOVFF  23,8EF
0F300:  MOVLB  0
0F302:  CALL   4FFC
....................    } 
0F306:  BRA    F30C
....................    else cmd_arg(); 
0F308:  CALL   B326
0F30C:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0F310:  MOVF   4B,F
0F312:  BNZ   F342
0F314:  MOVF   4A,F
0F316:  BNZ   F342
0F318:  MOVF   49,W
0F31A:  SUBLW  27
0F31C:  BNC   F342
0F31E:  BNZ   F326
0F320:  MOVF   48,W
0F322:  SUBLW  0F
0F324:  BNC   F342
....................       nv_serial = arg; 
0F326:  MOVFF  49,26
0F32A:  MOVFF  48,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0F32E:  MOVLB  8
0F330:  CLRF   xEE
0F332:  MOVFF  26,8F0
0F336:  MOVFF  25,8EF
0F33A:  MOVLB  0
0F33C:  CALL   4FFC
....................    } 
0F340:  BRA    F346
....................    else cmd_arg(); 
0F342:  CALL   B326
0F346:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F56A:  MOVF   2F,F
0F56C:  BNZ   F59C
0F56E:  MOVF   30,F
0F570:  BNZ   F59C
....................        
....................       if (arg > 0 && arg < 3){ 
0F572:  MOVF   48,F
0F574:  BNZ   F582
0F576:  MOVF   49,F
0F578:  BNZ   F582
0F57A:  MOVF   4A,F
0F57C:  BNZ   F582
0F57E:  MOVF   4B,F
0F580:  BZ    F598
0F582:  MOVF   4B,F
0F584:  BNZ   F598
0F586:  MOVF   4A,F
0F588:  BNZ   F598
0F58A:  MOVF   49,F
0F58C:  BNZ   F598
0F58E:  MOVF   48,W
0F590:  SUBLW  02
0F592:  BNC   F598
....................          det_cmd(); 
0F594:  RCALL  F42A
....................       } 
0F596:  BRA    F59C
....................       else cmd_arg(); 
0F598:  CALL   B326
....................        
....................    } 
0F59C:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
1045C:  MOVF   4B,F
1045E:  BNZ   104CA
10460:  MOVF   4A,F
10462:  BNZ   104CA
10464:  MOVF   49,W
10466:  SUBLW  0F
10468:  BNC   104CA
....................       switch (nv_det_type){ 
1046A:  MOVFF  45,00
1046E:  MOVF   46,W
10470:  MOVWF  03
10472:  BNZ   1047A
10474:  MOVLW  01
10476:  SUBWF  00,W
10478:  BZ    10490
1047A:  MOVF   03,W
1047C:  BNZ   10484
1047E:  MOVLW  02
10480:  SUBWF  00,W
10482:  BZ    10496
10484:  MOVF   03,W
10486:  BNZ   1048E
10488:  MOVLW  03
1048A:  SUBWF  00,W
1048C:  BZ    104B4
1048E:  BRA    104C8
....................          case 1 : det_cmd(); 
10490:  CALL   F42A
....................             break; 
10494:  BRA    104C8
....................          case 2 : DAC_set(1,arg); 
10496:  MOVFF  49,886
1049A:  MOVFF  48,885
1049E:  MOVLW  01
104A0:  MOVLB  8
104A2:  MOVWF  xD3
104A4:  MOVFF  49,8D5
104A8:  MOVFF  48,8D4
104AC:  MOVLB  0
104AE:  CALL   F5A0
....................             break; 
104B2:  BRA    104C8
....................          case 3 : set_LED(arg); 
104B4:  MOVFF  49,886
104B8:  MOVFF  48,885
104BC:  MOVFF  49,8C6
104C0:  MOVFF  48,8C5
104C4:  CALL   F8EE
....................             break; 
....................       } 
....................    } 
104C8:  BRA    10528
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
104CA:  MOVF   4B,F
104CC:  BNZ   104E2
104CE:  MOVF   4A,F
104D0:  BNZ   104E2
104D2:  MOVF   49,W
104D4:  SUBLW  4D
104D6:  BC    1050C
104D8:  XORLW  FF
104DA:  BNZ   104E2
104DC:  MOVF   48,W
104DE:  SUBLW  20
104E0:  BC    1050C
104E2:  MOVF   4B,F
104E4:  BNZ   1050C
104E6:  MOVF   4A,F
104E8:  BNZ   1050C
104EA:  MOVF   49,W
104EC:  SUBLW  4E
104EE:  BNC   1050C
104F0:  BNZ   104F8
104F2:  MOVF   48,W
104F4:  SUBLW  22
104F6:  BNC   1050C
104F8:  MOVFF  49,886
104FC:  MOVFF  48,885
10500:  MOVFF  49,888
10504:  MOVFF  48,887
10508:  BRA    10314
1050A:  BRA    10528
....................    else if(arg==30001)set_LED_test(); 
1050C:  MOVF   48,W
1050E:  SUBLW  31
10510:  BNZ   10524
10512:  MOVF   49,W
10514:  SUBLW  75
10516:  BNZ   10524
10518:  MOVF   4A,F
1051A:  BNZ   10524
1051C:  MOVF   4B,F
1051E:  BNZ   10524
10520:  BRA    103D0
10522:  BRA    10528
....................    else cmd_arg(); 
10524:  CALL   B326
10528:  GOTO   FFF8 (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
*
0FF92:  MOVF   4B,F
0FF94:  BNZ   FFC6
0FF96:  MOVF   4A,F
0FF98:  BNZ   FFC6
0FF9A:  MOVF   49,W
0FF9C:  SUBLW  57
0FF9E:  BNC   FFC6
0FFA0:  BNZ   FFA8
0FFA2:  MOVF   48,W
0FFA4:  SUBLW  E4
0FFA6:  BNC   FFC6
....................       nv_volume = arg; 
0FFA8:  MOVFF  49,2C
0FFAC:  MOVFF  48,2B
....................       write16(ADDR_VOLUME, nv_volume); 
0FFB0:  MOVLW  22
0FFB2:  MOVLB  8
0FFB4:  MOVWF  xEE
0FFB6:  MOVFF  2C,8F0
0FFBA:  MOVFF  2B,8EF
0FFBE:  MOVLB  0
0FFC0:  CALL   4FFC
....................    } 
0FFC4:  BRA    FFCA
....................    else cmd_arg(); 
0FFC6:  CALL   B326
0FFCA:  GOTO   FFF8 (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
0FFCE:  MOVF   2F,W
0FFD0:  MOVWF  00
0FFD2:  MOVF   30,W
0FFD4:  MOVWF  03
0FFD6:  BNZ   FFDC
0FFD8:  MOVF   00,F
0FFDA:  BZ    FFF2
0FFDC:  MOVF   03,W
0FFDE:  BNZ   FFE6
0FFE0:  MOVLW  01
0FFE2:  SUBWF  00,W
0FFE4:  BZ    FFF6
0FFE6:  MOVF   03,W
0FFE8:  BNZ   FFF0
0FFEA:  MOVLW  03
0FFEC:  SUBWF  00,W
0FFEE:  BZ    FFF6
0FFF0:  BRA    FFF8
....................       case ECO : commandLe(); 
0FFF2:  BRA    1045C
....................          break; 
0FFF4:  BRA    FFF8
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
0FFF6:  BRA    FF92
....................          break; 
....................    } 
0FFF8:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
16DDC:  CALL   29E8
....................     
....................    user_quit = FALSE; 
16DE0:  CLRF   50
....................     
....................    if(arg > 0 && arg < 21) 
16DE2:  MOVF   48,F
16DE4:  BNZ   16DF2
16DE6:  MOVF   49,F
16DE8:  BNZ   16DF2
16DEA:  MOVF   4A,F
16DEC:  BNZ   16DF2
16DEE:  MOVF   4B,F
16DF0:  BZ    16E6E
16DF2:  MOVF   4B,F
16DF4:  BNZ   16E6E
16DF6:  MOVF   4A,F
16DF8:  BNZ   16E6E
16DFA:  MOVF   49,F
16DFC:  BNZ   16E6E
16DFE:  MOVF   48,W
16E00:  SUBLW  14
16E02:  BNC   16E6E
....................    { 
....................       macro = arg; 
16E04:  MOVFF  48,886
....................       switch(nv_product){ 
16E08:  MOVFF  2F,00
16E0C:  MOVF   30,W
16E0E:  MOVWF  03
16E10:  BNZ   16E16
16E12:  MOVF   00,F
16E14:  BZ    16E36
16E16:  MOVF   03,W
16E18:  BNZ   16E20
16E1A:  MOVLW  01
16E1C:  SUBWF  00,W
16E1E:  BZ    16E36
16E20:  MOVF   03,W
16E22:  BNZ   16E2A
16E24:  MOVLW  03
16E26:  SUBWF  00,W
16E28:  BZ    16E36
16E2A:  MOVF   03,W
16E2C:  BNZ   16E34
16E2E:  MOVLW  02
16E30:  SUBWF  00,W
16E32:  BZ    16E5C
16E34:  BRA    16E6C
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
16E36:  MOVLW  01
16E38:  MOVLB  7
16E3A:  ADDWF  xC3,W
16E3C:  MOVLB  8
16E3E:  MOVWF  x87
16E40:  MOVLW  00
16E42:  MOVLB  7
16E44:  ADDWFC xC4,W
16E46:  MOVLB  8
16E48:  MOVWF  x88
16E4A:  MOVFF  886,897
16E4E:  MOVWF  x99
16E50:  MOVFF  887,898
16E54:  MOVLB  0
16E56:  CALL   153E4
....................             break; 
16E5A:  BRA    16E6C
....................          case AWS : play_macro(macro,nv_port); 
16E5C:  MOVFF  886,897
16E60:  MOVFF  2E,899
16E64:  MOVFF  2D,898
16E68:  CALL   153E4
....................             break; 
....................       } 
....................    }    
16E6C:  BRA    16EF4
....................    else if (arg == 0) 
16E6E:  MOVF   48,F
16E70:  BNZ   16EF0
16E72:  MOVF   49,F
16E74:  BNZ   16EF0
16E76:  MOVF   4A,F
16E78:  BNZ   16EF0
16E7A:  MOVF   4B,F
16E7C:  BNZ   16EF0
....................    { 
....................       //start watchdog at beginning of logging mode 
....................       //RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
16E7E:  BCF    F91.0
....................       spi_write(0x89); 
16E80:  MOVF   FC9,W
16E82:  MOVLW  89
16E84:  MOVWF  FC9
16E86:  RRCF   FC7,W
16E88:  BNC   16E86
....................       spi_write(0b11111111); 
16E8A:  MOVF   FC9,W
16E8C:  SETF   FC9
16E8E:  RRCF   FC7,W
16E90:  BNC   16E8E
....................       spi_read(0x00); 
16E92:  MOVF   FC9,W
16E94:  CLRF   FC9
16E96:  RRCF   FC7,W
16E98:  BNC   16E96
....................       output_bit(RTC_CS, DISABLE); 
16E9A:  BSF    F91.0
....................        
....................       MaxSamples=FALSE; 
16E9C:  CLRF   34
16E9E:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
16EA0:  MOVLW  28
16EA2:  MOVLB  8
16EA4:  MOVWF  x89
16EA6:  MOVFF  33,88A
16EAA:  MOVLB  0
16EAC:  CALL   343A
....................       if (LoggingReentry != TRUE) 
16EB0:  MOVLB  8
16EB2:  DECFSZ x85,W
16EB4:  BRA    16EB8
16EB6:  BRA    16ED0
....................       { 
....................          nv_sample = 0; 
16EB8:  CLRF   22
16EBA:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
16EBC:  MOVLW  16
16EBE:  MOVWF  xEE
16EC0:  MOVFF  22,8F0
16EC4:  MOVFF  21,8EF
16EC8:  MOVLB  0
16ECA:  CALL   4FFC
16ECE:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
16ED0:  CLRF   x85
....................       nv_macro_step = 0; 
16ED2:  CLRF   38
16ED4:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
16ED6:  MOVLW  3A
16ED8:  MOVWF  xEE
16EDA:  MOVFF  38,8F0
16EDE:  MOVFF  37,8EF
16EE2:  MOVLB  0
16EE4:  CALL   4FFC
....................       user_quit = auto_sample_ready(); 
16EE8:  BRA    16BDA
16EEA:  MOVFF  01,50
....................    } 
16EEE:  BRA    16EF4
....................    else cmd_arg(); 
16EF0:  CALL   B326
....................     
....................    busy_clear(); 
16EF4:  CALL   AED8
16EF8:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
16EFA:  MOVF   48,F
16EFC:  BNZ   16F0A
16EFE:  MOVF   49,F
16F00:  BNZ   16F0A
16F02:  MOVF   4A,F
16F04:  BNZ   16F0A
16F06:  MOVF   4B,F
16F08:  BZ    16F3E
16F0A:  MOVF   4B,F
16F0C:  BNZ   16F3E
16F0E:  MOVF   4A,F
16F10:  BNZ   16F3E
16F12:  MOVF   49,W
16F14:  SUBLW  0D
16F16:  BNC   16F3E
16F18:  BNZ   16F20
16F1A:  MOVF   48,W
16F1C:  SUBLW  AC
16F1E:  BNC   16F3E
....................       nv_max_samples = arg; 
16F20:  MOVFF  49,28
16F24:  MOVFF  48,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
16F28:  MOVLW  18
16F2A:  MOVLB  8
16F2C:  MOVWF  xEE
16F2E:  MOVFF  28,8F0
16F32:  MOVFF  27,8EF
16F36:  MOVLB  0
16F38:  CALL   4FFC
....................    } 
16F3C:  BRA    16F84
....................    else if(arg == 0) { 
16F3E:  MOVF   48,F
16F40:  BNZ   16F80
16F42:  MOVF   49,F
16F44:  BNZ   16F80
16F46:  MOVF   4A,F
16F48:  BNZ   16F80
16F4A:  MOVF   4B,F
16F4C:  BNZ   16F80
....................       nv_sample = 0; 
16F4E:  CLRF   22
16F50:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16F52:  MOVLW  16
16F54:  MOVLB  8
16F56:  MOVWF  xEE
16F58:  MOVFF  22,8F0
16F5C:  MOVFF  21,8EF
16F60:  MOVLB  0
16F62:  CALL   4FFC
....................       nv_macro_step = 0; 
16F66:  CLRF   38
16F68:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16F6A:  MOVLW  3A
16F6C:  MOVLB  8
16F6E:  MOVWF  xEE
16F70:  MOVFF  38,8F0
16F74:  MOVFF  37,8EF
16F78:  MOVLB  0
16F7A:  CALL   4FFC
....................    } 
16F7E:  BRA    16F84
....................    else cmd_arg(); 
16F80:  CALL   B326
16F84:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
170AA:  DECFSZ 48,W
170AC:  BRA    170C6
170AE:  MOVF   49,F
170B0:  BNZ   170C6
170B2:  MOVF   4A,F
170B4:  BNZ   170C6
170B6:  MOVF   4B,F
170B8:  BNZ   170C6
....................    { 
....................       bus_on(); 
170BA:  CALL   D398
....................       open_pipe(); 
170BE:  BRA    16FA0
....................       bus_off(); 
170C0:  CALL   D3BC
....................    } 
170C4:  BRA    170CA
....................    else cmd_arg(); 
170C6:  CALL   B326
170CA:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
17188:  MOVLB  7
1718A:  DECFSZ x41,W
1718C:  BRA    17190
1718E:  CLRF   x40
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
17190:  MOVF   48,F
17192:  BNZ   171A2
17194:  MOVF   49,F
17196:  BNZ   171A2
17198:  MOVF   4A,F
1719A:  BNZ   171A2
1719C:  MOVF   4B,F
1719E:  BTFSC  FD8.2
171A0:  BRA    1726A
171A2:  BCF    FD8.0
171A4:  RLCF   x40,W
171A6:  CLRF   03
171A8:  ADDLW  62
171AA:  MOVWF  FE9
171AC:  MOVLW  07
171AE:  ADDWFC 03,W
171B0:  MOVWF  FEA
171B2:  MOVFF  FEC,03
171B6:  MOVF   FED,F
171B8:  MOVFF  FEF,01
171BC:  MOVF   4B,F
171BE:  BNZ   1726A
171C0:  MOVF   4A,F
171C2:  BNZ   1726A
171C4:  MOVF   49,W
171C6:  SUBWF  03,W
171C8:  BNC   1726A
171CA:  BNZ   171D2
171CC:  MOVF   48,W
171CE:  SUBWF  01,W
171D0:  BNC   1726A
....................       if(e_mode[motor]==2){     // if port mode then move 
171D2:  BCF    FD8.0
171D4:  RLCF   x40,W
171D6:  CLRF   03
171D8:  ADDLW  66
171DA:  MOVWF  FE9
171DC:  MOVLW  07
171DE:  ADDWFC 03,W
171E0:  MOVWF  FEA
171E2:  MOVFF  FEC,886
171E6:  MOVF   FED,F
171E8:  MOVFF  FEF,885
171EC:  MOVLB  8
171EE:  MOVF   x85,W
171F0:  SUBLW  02
171F2:  BNZ   17260
171F4:  MOVF   x86,F
171F6:  BNZ   17260
....................          switch (nv_product){ 
171F8:  MOVF   2F,W
171FA:  MOVWF  00
171FC:  MOVF   30,W
171FE:  MOVWF  03
17200:  MOVF   03,W
17202:  BNZ   1720C
17204:  MOVF   00,F
17206:  MOVLB  0
17208:  BZ    1722A
1720A:  MOVLB  8
1720C:  MOVF   03,W
1720E:  BNZ   1721A
17210:  MOVLW  01
17212:  SUBWF  00,W
17214:  MOVLB  0
17216:  BZ    1723C
17218:  MOVLB  8
1721A:  MOVF   03,W
1721C:  BNZ   17228
1721E:  MOVLW  03
17220:  SUBWF  00,W
17222:  MOVLB  0
17224:  BZ    1724E
17226:  MOVLB  8
17228:  BRA    1725E
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
1722A:  MOVLW  01
1722C:  MOVLB  8
1722E:  MOVWF  x85
17230:  CLRF   x86
17232:  MOVWF  x87
17234:  MOVLB  0
17236:  RCALL  170CE
....................                break;             
17238:  MOVLB  8
1723A:  BRA    1725E
....................             case WMS4: command_move(0,0,1); 
1723C:  MOVLB  8
1723E:  CLRF   x85
17240:  CLRF   x86
17242:  MOVLW  01
17244:  MOVWF  x87
17246:  MOVLB  0
17248:  RCALL  170CE
....................                break; 
1724A:  MOVLB  8
1724C:  BRA    1725E
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
1724E:  MOVLB  8
17250:  CLRF   x85
17252:  CLRF   x86
17254:  MOVLW  01
17256:  MOVWF  x87
17258:  MOVLB  0
1725A:  RCALL  170CE
....................                break; 
1725C:  MOVLB  8
....................          } 
....................       } 
1725E:  BRA    17268
....................       else cmd_err();                           // else error 
17260:  MOVLB  0
17262:  CALL   BFE8
17266:  MOVLB  8
....................    } 
17268:  BRA    17272
....................    else cmd_arg(); 
1726A:  MOVLB  0
1726C:  CALL   B326
17270:  MOVLB  8
17272:  MOVLB  0
17274:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
17276:  MOVF   4B,F
17278:  BNZ   172A6
1727A:  MOVF   4A,F
1727C:  BNZ   172A6
1727E:  MOVF   49,F
17280:  BNZ   172A6
17282:  MOVF   48,W
17284:  SUBLW  30
17286:  BNC   172A6
....................       nv_port = arg; 
17288:  MOVFF  49,2E
1728C:  MOVFF  48,2D
....................       write16(ADDR_PORT, nv_port); 
17290:  MOVLW  24
17292:  MOVLB  8
17294:  MOVWF  xEE
17296:  MOVFF  2E,8F0
1729A:  MOVFF  2D,8EF
1729E:  MOVLB  0
172A0:  CALL   4FFC
....................    } 
172A4:  BRA    172AA
....................    else cmd_arg(); 
172A6:  CALL   B326
172AA:  GOTO   172E6 (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
172AE:  MOVF   2F,W
172B0:  MOVWF  00
172B2:  MOVF   30,W
172B4:  MOVWF  03
172B6:  BNZ   172BC
172B8:  MOVF   00,F
172BA:  BZ    172DC
172BC:  MOVF   03,W
172BE:  BNZ   172C6
172C0:  MOVLW  01
172C2:  SUBWF  00,W
172C4:  BZ    172E0
172C6:  MOVF   03,W
172C8:  BNZ   172D0
172CA:  MOVLW  03
172CC:  SUBWF  00,W
172CE:  BZ    172E0
172D0:  MOVF   03,W
172D2:  BNZ   172DA
172D4:  MOVLW  02
172D6:  SUBWF  00,W
172D8:  BZ    172E4
172DA:  BRA    172E6
....................       case ECO : commandPe(); 
172DC:  RCALL  17188
....................          break; 
172DE:  BRA    172E6
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
172E0:  RCALL  17188
....................          break; 
172E2:  BRA    172E6
....................       case AWS : commandPa(); 
172E4:  BRA    17276
....................          break;          
....................    } 
172E6:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
17332:  MOVLB  4
17334:  DECFSZ xB6,W
17336:  BRA    17362
....................     
....................       if(arg<33){ 
17338:  MOVF   4B,F
1733A:  BNZ   1735A
1733C:  MOVF   4A,F
1733E:  BNZ   1735A
17340:  MOVF   49,F
17342:  BNZ   1735A
17344:  MOVF   48,W
17346:  SUBLW  20
17348:  BNC   1735A
....................          valve=arg;    
1734A:  MOVFF  48,885
....................          sol_switch(valve); 
1734E:  MOVFF  885,8B5
17352:  MOVLB  0
17354:  CALL   1458E
....................       }  
17358:  BRA    17360
....................       else cmd_arg(); 
1735A:  MOVLB  0
1735C:  CALL   B326
....................    } 
17360:  BRA    17368
....................    else cmd_err(); 
17362:  MOVLB  0
17364:  CALL   BFE8
17368:  GOTO   17398 (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
172EA:  MOVF   48,F
172EC:  BNZ   172FA
172EE:  MOVF   49,F
172F0:  BNZ   172FA
172F2:  MOVF   4A,F
172F4:  BNZ   172FA
172F6:  MOVF   4B,F
172F8:  BZ    1732A
172FA:  MOVF   4B,F
172FC:  BNZ   1732A
172FE:  MOVF   4A,F
17300:  BNZ   1732A
17302:  MOVF   49,F
17304:  BNZ   1732A
17306:  MOVF   48,W
17308:  SUBLW  32
1730A:  BNC   1732A
....................       nv_port = arg; 
1730C:  MOVFF  49,2E
17310:  MOVFF  48,2D
....................       write16(ADDR_SAMPLE, nv_port); 
17314:  MOVLW  16
17316:  MOVLB  8
17318:  MOVWF  xEE
1731A:  MOVFF  2E,8F0
1731E:  MOVFF  2D,8EF
17322:  MOVLB  0
17324:  CALL   4FFC
....................    } 
17328:  BRA    1732E
....................    else cmd_arg(); 
1732A:  CALL   B326
1732E:  GOTO   17398 (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
1736C:  MOVF   2F,W
1736E:  MOVWF  00
17370:  MOVF   30,W
17372:  MOVWF  03
17374:  BNZ   1737C
17376:  MOVLW  01
17378:  SUBWF  00,W
1737A:  BZ    17392
1737C:  MOVF   03,W
1737E:  BNZ   17386
17380:  MOVLW  03
17382:  SUBWF  00,W
17384:  BZ    17392
17386:  MOVF   03,W
17388:  BNZ   17390
1738A:  MOVLW  02
1738C:  SUBWF  00,W
1738E:  BZ    17396
17390:  BRA    17398
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
17392:  BRA    172EA
....................          break; 
17394:  BRA    17398
....................       case AWS : commandQa(); 
17396:  BRA    17332
....................          break;          
....................    } 
17398:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
1739C:  CALL   29E8
....................     
....................    nv_macro_step = 0; 
173A0:  CLRF   38
173A2:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
173A4:  MOVLW  3A
173A6:  MOVLB  8
173A8:  MOVWF  xEE
173AA:  MOVFF  38,8F0
173AE:  MOVFF  37,8EF
173B2:  MOVLB  0
173B4:  CALL   4FFC
....................     
....................    user_quit = FALSE; 
173B8:  CLRF   50
....................     
....................    if (arg > 0 && arg < 3501){ 
173BA:  MOVF   48,F
173BC:  BNZ   173CA
173BE:  MOVF   49,F
173C0:  BNZ   173CA
173C2:  MOVF   4A,F
173C4:  BNZ   173CA
173C6:  MOVF   4B,F
173C8:  BZ    17476
173CA:  MOVF   4B,F
173CC:  BNZ   17476
173CE:  MOVF   4A,F
173D0:  BNZ   17476
173D2:  MOVF   49,W
173D4:  SUBLW  0D
173D6:  BNC   17476
173D8:  BNZ   173E0
173DA:  MOVF   48,W
173DC:  SUBLW  AC
173DE:  BNC   17476
....................       samples = arg; 
173E0:  MOVFF  49,887
173E4:  MOVFF  48,886
....................       user_quit = FALSE; 
173E8:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
173EA:  MOVLB  8
173EC:  CLRF   x89
173EE:  CLRF   x88
173F0:  MOVF   x89,W
173F2:  SUBWF  x87,W
173F4:  BNC   17474
173F6:  BNZ   173FE
173F8:  MOVF   x86,W
173FA:  SUBWF  x88,W
173FC:  BC    17474
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
173FE:  MOVLW  01
17400:  ADDWF  x88,W
17402:  MOVWF  x8A
17404:  MOVLW  00
17406:  ADDWFC x89,W
17408:  MOVWF  x8B
1740A:  MOVLW  DA
1740C:  MOVWF  FF6
1740E:  MOVLW  26
17410:  MOVWF  FF7
17412:  MOVLW  00
17414:  MOVWF  FF8
17416:  CLRF   1B
17418:  BTFSC  FF2.7
1741A:  BSF    1B.7
1741C:  BCF    FF2.7
1741E:  MOVLW  05
17420:  MOVLB  A
17422:  MOVWF  x40
17424:  MOVLB  0
17426:  CALL   1044
1742A:  BTFSC  1B.7
1742C:  BSF    FF2.7
1742E:  MOVLW  09
17430:  MOVWF  FE9
17432:  CLRF   1B
17434:  BTFSC  FF2.7
17436:  BSF    1B.7
17438:  BCF    FF2.7
1743A:  MOVFF  88B,A41
1743E:  MOVFF  88A,A40
17442:  CALL   11C6
17446:  BTFSC  1B.7
17448:  BSF    FF2.7
1744A:  MOVLW  0D
1744C:  BTFSS  F9E.4
1744E:  BRA    1744C
17450:  MOVWF  FAD
17452:  MOVLW  0A
17454:  BTFSS  F9E.4
17456:  BRA    17454
17458:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
1745A:  CALL   15FCA
1745E:  MOVFF  01,885
....................          if (macro_cmd == ';') break; 
17462:  MOVLB  8
17464:  MOVF   x85,W
17466:  SUBLW  3B
17468:  BTFSC  FD8.2
1746A:  BRA    17474
1746C:  INCF   x88,F
1746E:  BTFSC  FD8.2
17470:  INCF   x89,F
17472:  BRA    173F0
17474:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
17476:  CALL   AED8
1747A:  GOTO   1763A (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
1747E:  MOVF   48,F
17480:  BNZ   1748E
17482:  MOVF   49,F
17484:  BNZ   1748E
17486:  MOVF   4A,F
17488:  BNZ   1748E
1748A:  MOVF   4B,F
1748C:  BZ    174D2
1748E:  MOVF   4B,F
17490:  BNZ   174D2
17492:  MOVF   4A,F
17494:  BNZ   174D2
17496:  MOVF   49,F
17498:  BNZ   174D2
1749A:  MOVF   48,W
1749C:  SUBLW  2F
1749E:  BNC   174D2
....................       n=arg; 
174A0:  MOVFF  48,888
....................       port=2; 
174A4:  MOVLB  8
174A6:  CLRF   x86
174A8:  MOVLW  02
174AA:  MOVWF  x85
....................       for(i=0;i<n;++i){ 
174AC:  CLRF   x87
174AE:  MOVF   x88,W
174B0:  SUBWF  x87,W
174B2:  BC    174CE
....................          play_wms_hard_macro(port); 
174B4:  MOVFF  886,88A
174B8:  MOVFF  885,889
174BC:  MOVLB  0
174BE:  CALL   D828
....................          ++port; 
174C2:  MOVLB  8
174C4:  INCF   x85,F
174C6:  BTFSC  FD8.2
174C8:  INCF   x86,F
174CA:  INCF   x87,F
174CC:  BRA    174AE
....................       } 
....................    } 
174CE:  BRA    174D8
174D0:  MOVLB  0
....................    else cmd_arg(); 
174D2:  CALL   B326
174D6:  MOVLB  8
174D8:  MOVLB  0
174DA:  GOTO   1763A (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
174DE:  CALL   29E8
....................     
....................    nv_macro_step = 0; 
174E2:  CLRF   38
174E4:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
174E6:  MOVLW  3A
174E8:  MOVLB  8
174EA:  MOVWF  xEE
174EC:  MOVFF  38,8F0
174F0:  MOVFF  37,8EF
174F4:  MOVLB  0
174F6:  CALL   4FFC
....................     
....................    user_quit = FALSE; 
174FA:  CLRF   50
....................     
....................    if (arg > 0 && arg < 241){ 
174FC:  MOVF   48,F
174FE:  BNZ   1750E
17500:  MOVF   49,F
17502:  BNZ   1750E
17504:  MOVF   4A,F
17506:  BNZ   1750E
17508:  MOVF   4B,F
1750A:  BTFSC  FD8.2
1750C:  BRA    175FA
1750E:  MOVF   4B,F
17510:  BTFSS  FD8.2
17512:  BRA    175FA
17514:  MOVF   4A,F
17516:  BTFSS  FD8.2
17518:  BRA    175FA
1751A:  MOVF   49,F
1751C:  BTFSS  FD8.2
1751E:  BRA    175FA
17520:  MOVF   48,W
17522:  SUBLW  F0
17524:  BNC   175FA
....................       samples = arg; 
17526:  MOVFF  49,887
1752A:  MOVFF  48,886
....................       user_quit = FALSE; 
1752E:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
17530:  MOVLB  8
17532:  CLRF   x89
17534:  CLRF   x88
17536:  MOVF   x89,W
17538:  SUBWF  x87,W
1753A:  BNC   175F8
1753C:  BNZ   17544
1753E:  MOVF   x86,W
17540:  SUBWF  x88,W
17542:  BC    175F8
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
17544:  MOVLW  01
17546:  ADDWF  x88,W
17548:  MOVWF  x8A
1754A:  MOVLW  00
1754C:  ADDWFC x89,W
1754E:  MOVWF  x8B
17550:  MOVLW  E8
17552:  MOVWF  FF6
17554:  MOVLW  26
17556:  MOVWF  FF7
17558:  MOVLW  00
1755A:  MOVWF  FF8
1755C:  CLRF   1B
1755E:  BTFSC  FF2.7
17560:  BSF    1B.7
17562:  BCF    FF2.7
17564:  MOVLW  05
17566:  MOVLB  A
17568:  MOVWF  x40
1756A:  MOVLB  0
1756C:  CALL   1044
17570:  BTFSC  1B.7
17572:  BSF    FF2.7
17574:  MOVLW  09
17576:  MOVWF  FE9
17578:  CLRF   1B
1757A:  BTFSC  FF2.7
1757C:  BSF    1B.7
1757E:  BCF    FF2.7
17580:  MOVFF  88B,A41
17584:  MOVFF  88A,A40
17588:  CALL   11C6
1758C:  BTFSC  1B.7
1758E:  BSF    FF2.7
17590:  MOVLW  0D
17592:  BTFSS  F9E.4
17594:  BRA    17592
17596:  MOVWF  FAD
17598:  MOVLW  0A
1759A:  BTFSS  F9E.4
1759C:  BRA    1759A
1759E:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
175A0:  MOVLW  01
175A2:  MOVLB  8
175A4:  ADDWF  x88,W
175A6:  MOVWF  x8A
175A8:  MOVLW  00
175AA:  ADDWFC x89,W
175AC:  MOVWF  x8B
175AE:  MOVWF  x8D
175B0:  MOVFF  88A,88C
175B4:  MOVLB  0
175B6:  CALL   16880
175BA:  MOVFF  01,885
....................          ++nv_sample;                     // increment sample number 
175BE:  INCF   21,F
175C0:  BTFSC  FD8.2
175C2:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
175C4:  MOVLW  16
175C6:  MOVLB  8
175C8:  MOVWF  xEE
175CA:  MOVFF  22,8F0
175CE:  MOVFF  21,8EF
175D2:  MOVLB  0
175D4:  CALL   4FFC
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
175D8:  MOVF   27,W
175DA:  SUBWF  21,W
175DC:  BNZ   175E4
175DE:  MOVF   28,W
175E0:  SUBWF  22,W
175E2:  BZ    175EC
175E4:  MOVLB  8
175E6:  MOVF   x85,W
175E8:  SUBLW  3B
175EA:  BNZ   175F0
175EC:  MOVLB  8
175EE:  BRA    175F8
175F0:  INCF   x88,F
175F2:  BTFSC  FD8.2
175F4:  INCF   x89,F
175F6:  BRA    17536
175F8:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
175FA:  CALL   AED8
175FE:  GOTO   1763A (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
17602:  MOVF   2F,W
17604:  MOVWF  00
17606:  MOVF   30,W
17608:  MOVWF  03
1760A:  BNZ   17610
1760C:  MOVF   00,F
1760E:  BZ    17630
17610:  MOVF   03,W
17612:  BNZ   1761A
17614:  MOVLW  01
17616:  SUBWF  00,W
17618:  BZ    17634
1761A:  MOVF   03,W
1761C:  BNZ   17624
1761E:  MOVLW  03
17620:  SUBWF  00,W
17622:  BZ    17634
17624:  MOVF   03,W
17626:  BNZ   1762E
17628:  MOVLW  02
1762A:  SUBWF  00,W
1762C:  BZ    17638
1762E:  BRA    1763A
....................       case ECO : commandRe(); 
17630:  BRA    1739C
....................          break; 
17632:  BRA    1763A
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
17634:  BRA    1747E
....................          break; 
17636:  BRA    1763A
....................       case AWS : commandRa(); 
17638:  BRA    174DE
....................          break;          
....................    } 
1763A:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
1763E:  CALL   29E8
....................     
....................    switch(arg){ 
17642:  MOVFF  48,00
17646:  MOVF   49,W
17648:  MOVWF  03
1764A:  BNZ   17652
1764C:  MOVLW  01
1764E:  SUBWF  00,W
17650:  BZ    1765E
17652:  MOVF   03,W
17654:  BNZ   1765C
17656:  MOVLW  02
17658:  SUBWF  00,W
1765A:  BZ    176A2
1765C:  BRA    176B2
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
1765E:  DECFSZ 45,W
17660:  BRA    17676
17662:  MOVF   46,F
17664:  BNZ   17676
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
17666:  MOVLB  8
17668:  CLRF   xC2
1766A:  MOVLW  01
1766C:  MOVWF  xC3
1766E:  MOVLB  0
17670:  CALL   13750
....................       } 
17674:  BRA    176A0
....................       else if(nv_det_type==2 || nv_det_type==3) 
17676:  MOVF   45,W
17678:  SUBLW  02
1767A:  BNZ   17680
1767C:  MOVF   46,F
1767E:  BZ    1768A
17680:  MOVF   45,W
17682:  SUBLW  03
17684:  BNZ   176A0
17686:  MOVF   46,F
17688:  BNZ   176A0
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
1768A:  MOVLB  8
1768C:  CLRF   xC3
1768E:  MOVLW  C8
17690:  MOVWF  xC2
17692:  CLRF   xC4
17694:  MOVLW  01
17696:  MOVWF  xC5
17698:  CLRF   xC6
1769A:  MOVLB  0
1769C:  CALL   100B6
....................       } 
....................       break;                                                        //200 scans,don't store,display 
176A0:  BRA    176B6
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
176A2:  MOVLB  8
176A4:  CLRF   xC2
176A6:  MOVLW  01
176A8:  MOVWF  xC3
176AA:  MOVLB  0
176AC:  CALL   13A52
....................       break; 
176B0:  BRA    176B6
....................    default: cmd_arg(); 
176B2:  CALL   B326
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
176B6:  CALL   AED8
176BA:  GOTO   17766 (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
176BE:  MOVF   4B,F
176C0:  BNZ   176F2
176C2:  MOVF   4A,F
176C4:  BNZ   176F2
176C6:  MOVF   49,W
176C8:  SUBLW  04
176CA:  BNC   176F2
176CC:  BNZ   176D4
176CE:  MOVF   48,W
176D0:  SUBLW  00
176D2:  BNC   176F2
....................       nv_sample = arg; 
176D4:  MOVFF  49,22
176D8:  MOVFF  48,21
....................       write16(ADDR_SAMPLE, nv_sample); 
176DC:  MOVLW  16
176DE:  MOVLB  8
176E0:  MOVWF  xEE
176E2:  MOVFF  22,8F0
176E6:  MOVFF  21,8EF
176EA:  MOVLB  0
176EC:  CALL   4FFC
....................    } 
176F0:  BRA    176F6
....................    else cmd_arg(); 
176F2:  CALL   B326
176F6:  GOTO   17766 (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
176FA:  MOVF   4B,F
176FC:  BNZ   17726
176FE:  MOVF   4A,F
17700:  BNZ   17726
17702:  MOVF   49,W
17704:  SUBLW  01
17706:  BNC   17726
17708:  BNZ   17710
1770A:  MOVF   48,W
1770C:  SUBLW  02
1770E:  BNC   17726
....................       setting = arg; 
17710:  MOVFF  49,886
17714:  MOVFF  48,885
....................       sol_switch_cmd(setting); 
17718:  MOVFF  886,8B7
1771C:  MOVFF  885,8B6
17720:  CALL   144D8
....................    } 
17724:  BRA    1772A
....................    else cmd_arg(); 
17726:  CALL   B326
1772A:  GOTO   17766 (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
1772E:  MOVF   2F,W
17730:  MOVWF  00
17732:  MOVF   30,W
17734:  MOVWF  03
17736:  BNZ   1773C
17738:  MOVF   00,F
1773A:  BZ    1775C
1773C:  MOVF   03,W
1773E:  BNZ   17746
17740:  MOVLW  01
17742:  SUBWF  00,W
17744:  BZ    17760
17746:  MOVF   03,W
17748:  BNZ   17750
1774A:  MOVLW  03
1774C:  SUBWF  00,W
1774E:  BZ    17760
17750:  MOVF   03,W
17752:  BNZ   1775A
17754:  MOVLW  02
17756:  SUBWF  00,W
17758:  BZ    17764
1775A:  BRA    17766
....................       case ECO : commandSe(); 
1775C:  BRA    1763E
....................          break; 
1775E:  BRA    17766
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
17760:  BRA    176BE
....................          break; 
17762:  BRA    17766
....................       case AWS : commandSa(); 
17764:  BRA    176FA
....................          break;          
....................    } 
17766:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
17D56:  MOVLW  F6
17D58:  MOVWF  FF6
17D5A:  MOVLW  26
17D5C:  MOVWF  FF7
17D5E:  MOVLW  00
17D60:  MOVWF  FF8
17D62:  CLRF   1B
17D64:  BTFSC  FF2.7
17D66:  BSF    1B.7
17D68:  BCF    FF2.7
17D6A:  CALL   0E6E
17D6E:  BTFSC  1B.7
17D70:  BSF    FF2.7
....................    fputc('>',COM_A); 
17D72:  MOVLW  3E
17D74:  CALL   AEE0
....................    RTCfmt=fgetc(COM_A); 
17D78:  CALL   0E58
17D7C:  MOVFF  01,4F
....................    if (com_echo == TRUE) 
17D80:  DECFSZ 4C,W
17D82:  BRA    17D8A
....................       { 
....................       fputc(RTCfmt,COM_A); 
17D84:  MOVF   4F,W
17D86:  CALL   AEE0
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
17D8A:  MOVLW  30
17D8C:  SUBWF  4F,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
17D8E:  MOVF   4F,W
17D90:  SUBLW  01
17D92:  BNC   17DC8
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
17D94:  MOVLW  22
17D96:  MOVWF  FF6
17D98:  MOVLW  27
17D9A:  MOVWF  FF7
17D9C:  MOVLW  00
17D9E:  MOVWF  FF8
17DA0:  CALL   AEAE
17DA4:  MOVLW  0D
17DA6:  BTFSS  F9E.4
17DA8:  BRA    17DA6
17DAA:  MOVWF  FAD
17DAC:  MOVLW  0A
17DAE:  BTFSS  F9E.4
17DB0:  BRA    17DAE
17DB2:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
17DB4:  MOVLW  1A
17DB6:  MOVLB  8
17DB8:  MOVWF  xEE
17DBA:  CLRF   xF0
17DBC:  MOVFF  4F,8EF
17DC0:  MOVLB  0
17DC2:  CALL   4FFC
....................       }  
17DC6:  BRA    17DCC
....................    else cmd_arg(); 
17DC8:  CALL   B326
....................     
....................    if(arg == 1) 
17DCC:  DECFSZ 48,W
17DCE:  BRA    17DE0
17DD0:  MOVF   49,F
17DD2:  BNZ   17DE0
17DD4:  MOVF   4A,F
17DD6:  BNZ   17DE0
17DD8:  MOVF   4B,F
17DDA:  BNZ   17DE0
....................    { 
....................       RTC_Set(); 
17DDC:  BRA    17C0C
....................    } 
17DDE:  BRA    17DE4
....................    else cmd_arg(); 
17DE0:  CALL   B326
17DE4:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
1875E:  MOVF   4B,F
18760:  BNZ   1877C
18762:  MOVF   4A,F
18764:  BNZ   1877C
18766:  MOVF   49,F
18768:  BNZ   1877C
1876A:  MOVF   48,W
1876C:  SUBLW  14
1876E:  BNC   1877C
....................       macro = arg; 
18770:  MOVFF  48,885
....................       upload_macro(macro);    
18774:  MOVFF  885,886
18778:  BRA    184AC
....................    }    
1877A:  BRA    18798
....................    else if (arg == 5525){ 
1877C:  MOVF   48,W
1877E:  SUBLW  95
18780:  BNZ   18794
18782:  MOVF   49,W
18784:  SUBLW  15
18786:  BNZ   18794
18788:  MOVF   4A,F
1878A:  BNZ   18794
1878C:  MOVF   4B,F
1878E:  BNZ   18794
....................       write_blank_macros(); 
18790:  BRA    185E2
....................    } 
18792:  BRA    18798
....................    else cmd_arg(); 
18794:  CALL   B326
18798:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
188B6:  MOVF   4B,F
188B8:  BNZ   188D4
188BA:  MOVF   4A,F
188BC:  BNZ   188D4
188BE:  MOVF   49,F
188C0:  BNZ   188D4
188C2:  MOVF   48,W
188C4:  SUBLW  14
188C6:  BNC   188D4
....................       macro = arg;  
188C8:  MOVFF  48,885
....................       read_macro(macro); 
188CC:  MOVFF  885,886
188D0:  BRA    18850
....................    }    
188D2:  BRA    188D8
....................    else cmd_arg(); 
188D4:  CALL   B326
188D8:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
18A2A:  DECFSZ 48,W
18A2C:  BRA    18A46
18A2E:  MOVF   49,F
18A30:  BNZ   18A46
18A32:  MOVF   4A,F
18A34:  BNZ   18A46
18A36:  MOVF   4B,F
18A38:  BNZ   18A46
....................       //fprintf(COM_A,"1\r\n"); 
....................       RTC_alarm(); 
18A3A:  BRA    188DC
....................       //fprintf(COM_A,"2\r\n"); 
....................       RTC_late(); 
18A3C:  CALL   157A2
....................       //fprintf(COM_A,"3\r\n"); 
....................       RTC_alarm_status(); 
18A40:  CALL   15C68
....................       //fprintf(COM_A,"4\r\n"); 
....................    } 
18A44:  BRA    18A4A
....................    else cmd_arg(); 
18A46:  CALL   B326
18A4A:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
18A4E:  MOVF   48,W
18A50:  MOVWF  00
18A52:  MOVF   49,W
18A54:  MOVWF  03
18A56:  BNZ   18A5C
18A58:  MOVF   00,F
18A5A:  BZ    18A90
18A5C:  MOVF   03,W
18A5E:  BNZ   18A66
18A60:  MOVLW  02
18A62:  SUBWF  00,W
18A64:  BZ    18A90
18A66:  MOVF   03,W
18A68:  BNZ   18A70
18A6A:  MOVLW  03
18A6C:  SUBWF  00,W
18A6E:  BZ    18A90
18A70:  MOVF   03,W
18A72:  BNZ   18A7A
18A74:  MOVLW  04
18A76:  SUBWF  00,W
18A78:  BZ    18A90
18A7A:  MOVF   03,W
18A7C:  BNZ   18A84
18A7E:  MOVLW  05
18A80:  SUBWF  00,W
18A82:  BZ    18A90
18A84:  MOVF   03,W
18A86:  BNZ   18A8E
18A88:  MOVLW  06
18A8A:  SUBWF  00,W
18A8C:  BZ    18A90
18A8E:  BRA    18AAE
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
18A90:  MOVFF  49,20
18A94:  MOVFF  48,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
18A98:  MOVLW  1C
18A9A:  MOVLB  8
18A9C:  MOVWF  xEE
18A9E:  MOVFF  20,8F0
18AA2:  MOVFF  1F,8EF
18AA6:  MOVLB  0
18AA8:  CALL   4FFC
....................          break; 
18AAC:  BRA    18AB2
....................       default: cmd_arg(); 
18AAE:  CALL   B326
....................          break; 
....................    } 
18AB2:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
18AB6:  CALL   29E8
....................     
....................    switch(arg){ 
18ABA:  MOVFF  48,00
18ABE:  MOVF   49,W
18AC0:  MOVWF  03
18AC2:  BNZ   18AC8
18AC4:  MOVF   00,F
18AC6:  BZ    18B4C
18AC8:  MOVF   03,W
18ACA:  BNZ   18AD2
18ACC:  MOVLW  0A
18ACE:  SUBWF  00,W
18AD0:  BZ    18B4C
18AD2:  MOVF   03,W
18AD4:  BNZ   18ADC
18AD6:  MOVLW  01
18AD8:  SUBWF  00,W
18ADA:  BZ    18B54
18ADC:  MOVF   03,W
18ADE:  BNZ   18AE6
18AE0:  MOVLW  0B
18AE2:  SUBWF  00,W
18AE4:  BZ    18B54
18AE6:  MOVF   03,W
18AE8:  BNZ   18AF0
18AEA:  MOVLW  14
18AEC:  SUBWF  00,W
18AEE:  BZ    18B5E
18AF0:  MOVF   03,W
18AF2:  BNZ   18AFA
18AF4:  MOVLW  15
18AF6:  SUBWF  00,W
18AF8:  BZ    18B64
18AFA:  MOVF   03,W
18AFC:  BNZ   18B04
18AFE:  MOVLW  1E
18B00:  SUBWF  00,W
18B02:  BZ    18B6A
18B04:  MOVF   03,W
18B06:  BNZ   18B0E
18B08:  MOVLW  1F
18B0A:  SUBWF  00,W
18B0C:  BZ    18B70
18B0E:  MOVF   03,W
18B10:  BNZ   18B18
18B12:  MOVLW  28
18B14:  SUBWF  00,W
18B16:  BZ    18B76
18B18:  MOVF   03,W
18B1A:  BNZ   18B22
18B1C:  MOVLW  29
18B1E:  SUBWF  00,W
18B20:  BZ    18B7C
18B22:  MOVF   03,W
18B24:  BNZ   18B2C
18B26:  MOVLW  32
18B28:  SUBWF  00,W
18B2A:  BZ    18B82
18B2C:  MOVF   03,W
18B2E:  BNZ   18B36
18B30:  MOVLW  33
18B32:  SUBWF  00,W
18B34:  BZ    18B88
18B36:  MOVF   03,W
18B38:  BNZ   18B40
18B3A:  MOVLW  3C
18B3C:  SUBWF  00,W
18B3E:  BZ    18B8E
18B40:  MOVF   03,W
18B42:  BNZ   18B4A
18B44:  MOVLW  3D
18B46:  SUBWF  00,W
18B48:  BZ    18B9C
18B4A:  BRA    18BAE
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
18B4C:  BCF    F90.7
....................                bus_pwr_status=0; 
18B4E:  MOVLB  4
18B50:  CLRF   xB6
....................          break; 
18B52:  BRA    18BB4
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18B54:  BSF    F90.7
....................                bus_pwr_status=1; 
18B56:  MOVLW  01
18B58:  MOVLB  4
18B5A:  MOVWF  xB6
....................          break; 
18B5C:  BRA    18BB4
....................       case 20: output_bit(VMOT,OFF); 
18B5E:  BCF    F8E.1
....................          break; 
18B60:  MOVLB  4
18B62:  BRA    18BB4
....................       case 21: output_bit(VMOT,ON); 
18B64:  BSF    F8E.1
....................          break; 
18B66:  MOVLB  4
18B68:  BRA    18BB4
....................       case 30: output_bit(VENC1,OFF); 
18B6A:  BCF    F8E.6
....................          break; 
18B6C:  MOVLB  4
18B6E:  BRA    18BB4
....................       case 31: output_bit(VENC1,ON); 
18B70:  BSF    F8E.6
....................          break; 
18B72:  MOVLB  4
18B74:  BRA    18BB4
....................       case 40: output_bit(VENC2,OFF); 
18B76:  BCF    F8E.7
....................          break; 
18B78:  MOVLB  4
18B7A:  BRA    18BB4
....................       case 41: output_bit(VENC2,ON); 
18B7C:  BSF    F8E.7
....................          break; 
18B7E:  MOVLB  4
18B80:  BRA    18BB4
....................       case 50: output_bit(VHBRDG,OFF); 
18B82:  BCF    F8E.2
....................          break; 
18B84:  MOVLB  4
18B86:  BRA    18BB4
....................       case 51: output_bit(VHBRDG,ON); 
18B88:  BSF    F8E.2
....................          break;          
18B8A:  MOVLB  4
18B8C:  BRA    18BB4
....................       case 60: set_heaters(0); 
18B8E:  MOVLB  8
18B90:  CLRF   xC5
18B92:  MOVLB  0
18B94:  CALL   12730
....................          break; 
18B98:  MOVLB  4
18B9A:  BRA    18BB4
....................       case 61: set_heaters(3); 
18B9C:  MOVLW  03
18B9E:  MOVLB  8
18BA0:  MOVWF  xC5
18BA2:  MOVLB  0
18BA4:  CALL   12730
....................          break; 
18BA8:  MOVLB  4
18BAA:  BRA    18BB4
18BAC:  MOVLB  0
....................       default : cmd_arg(); 
18BAE:  CALL   B326
....................          break;          
18BB2:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
18BB4:  MOVLB  0
18BB6:  CALL   AED8
18BBA:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
18BBE:  MOVF   48,F
18BC0:  BNZ   18BDC
18BC2:  MOVF   49,F
18BC4:  BNZ   18BDC
18BC6:  MOVF   4A,F
18BC8:  BNZ   18BDC
18BCA:  MOVF   4B,F
18BCC:  BNZ   18BDC
....................       motor_sleep_rdy(); 
18BCE:  CALL   29C0
....................       shutdown(); 
18BD2:  CALL   15C8A
....................       go_to_sleep(); 
18BD6:  CALL   15F04
....................    } 
18BDA:  BRA    18BE0
....................    else cmd_arg(); 
18BDC:  CALL   B326
18BE0:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
18D0E:  DECFSZ 48,W
18D10:  BRA    18D22
18D12:  MOVF   49,F
18D14:  BNZ   18D22
18D16:  MOVF   4A,F
18D18:  BNZ   18D22
18D1A:  MOVF   4B,F
18D1C:  BNZ   18D22
18D1E:  BRA    18C08
18D20:  BRA    18D26
....................    else cmd_arg(); 
18D22:  CALL   B326
18D26:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
18D2A:  MOVF   4B,F
18D2C:  BNZ   18DBC
18D2E:  MOVF   4A,F
18D30:  BNZ   18DBC
18D32:  MOVF   49,W
18D34:  SUBLW  27
18D36:  BNC   18DBC
18D38:  BNZ   18D40
18D3A:  MOVF   48,W
18D3C:  SUBLW  10
18D3E:  BNC   18DBC
....................       m_bklsh[motor] = arg; 
18D40:  BCF    FD8.0
18D42:  MOVLB  7
18D44:  RLCF   x40,W
18D46:  CLRF   03
18D48:  ADDLW  72
18D4A:  MOVWF  FE9
18D4C:  MOVLW  07
18D4E:  ADDWFC 03,W
18D50:  MOVWF  FEA
18D52:  MOVFF  48,FEF
18D56:  MOVFF  49,FEC
....................       switch(motor){ 
18D5A:  MOVF   x40,W
18D5C:  XORLW  00
18D5E:  MOVLB  0
18D60:  BZ    18D68
18D62:  XORLW  01
18D64:  BZ    18D92
18D66:  BRA    18DBA
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
18D68:  BCF    FD8.0
18D6A:  MOVLB  7
18D6C:  RLCF   x40,W
18D6E:  CLRF   03
18D70:  ADDLW  72
18D72:  MOVWF  FE9
18D74:  MOVLW  07
18D76:  ADDWFC 03,W
18D78:  MOVWF  FEA
18D7A:  MOVFF  FEC,8F0
18D7E:  MOVF   FED,F
18D80:  MOVFF  FEF,8EF
18D84:  MOVLW  72
18D86:  MOVLB  8
18D88:  MOVWF  xEE
18D8A:  MOVLB  0
18D8C:  CALL   4FFC
....................             break; 
18D90:  BRA    18DBA
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
18D92:  BCF    FD8.0
18D94:  MOVLB  7
18D96:  RLCF   x40,W
18D98:  CLRF   03
18D9A:  ADDLW  72
18D9C:  MOVWF  FE9
18D9E:  MOVLW  07
18DA0:  ADDWFC 03,W
18DA2:  MOVWF  FEA
18DA4:  MOVFF  FEC,8F0
18DA8:  MOVF   FED,F
18DAA:  MOVFF  FEF,8EF
18DAE:  MOVLW  74
18DB0:  MOVLB  8
18DB2:  MOVWF  xEE
18DB4:  MOVLB  0
18DB6:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
18DBA:  BRA    18DC0
....................    else cmd_arg();    
18DBC:  CALL   B326
18DC0:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... //Set watchdog temporarily (arg should be dec equivalent of bcd) 
.................... //c0,c1 services watchdog 
.................... //probably don't use this anyway 
.................... void command_c(){ 
....................    if(arg == 0){ 
18DC4:  MOVF   48,F
18DC6:  BNZ   18DD8
18DC8:  MOVF   49,F
18DCA:  BNZ   18DD8
18DCC:  MOVF   4A,F
18DCE:  BNZ   18DD8
18DD0:  MOVF   4B,F
18DD2:  BNZ   18DD8
....................       output_bit(PIN_J7,0); 
18DD4:  BCF    F91.7
....................    }else if(arg == 1){ 
18DD6:  BRA    18E10
18DD8:  DECFSZ 48,W
18DDA:  BRA    18DEC
18DDC:  MOVF   49,F
18DDE:  BNZ   18DEC
18DE0:  MOVF   4A,F
18DE2:  BNZ   18DEC
18DE4:  MOVF   4B,F
18DE6:  BNZ   18DEC
....................       output_bit(PIN_J7,1); 
18DE8:  BSF    F91.7
....................    }else{ 
18DEA:  BRA    18E10
....................       RTC_reset_HT(); 
18DEC:  CALL   34DA
....................       output_bit(RTC_CS, ENABLE); 
18DF0:  BCF    F91.0
....................       spi_write(0x89); 
18DF2:  MOVF   FC9,W
18DF4:  MOVLW  89
18DF6:  MOVWF  FC9
18DF8:  RRCF   FC7,W
18DFA:  BNC   18DF8
....................       spi_write(arg); 
18DFC:  MOVF   FC9,W
18DFE:  MOVFF  48,FC9
18E02:  RRCF   FC7,W
18E04:  BNC   18E02
....................       spi_read(0x00); 
18E06:  MOVF   FC9,W
18E08:  CLRF   FC9
18E0A:  RRCF   FC7,W
18E0C:  BNC   18E0A
....................       output_bit(RTC_CS, DISABLE); 
18E0E:  BSF    F91.0
....................    } 
18E10:  GOTO   1B2E6 (RETURN)
.................... } 
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
18E14:  MOVF   4B,F
18E16:  BNZ   18EA2
18E18:  MOVF   4A,F
18E1A:  BNZ   18EA2
18E1C:  MOVF   49,F
18E1E:  BNZ   18EA2
18E20:  MOVF   48,W
18E22:  SUBLW  01
18E24:  BNC   18EA2
....................       m_pos_dir[motor] = arg; 
18E26:  BCF    FD8.0
18E28:  MOVLB  7
18E2A:  RLCF   x40,W
18E2C:  CLRF   03
18E2E:  ADDLW  4E
18E30:  MOVWF  FE9
18E32:  MOVLW  07
18E34:  ADDWFC 03,W
18E36:  MOVWF  FEA
18E38:  MOVFF  48,FEF
18E3C:  MOVFF  49,FEC
....................       switch(motor){ 
18E40:  MOVF   x40,W
18E42:  XORLW  00
18E44:  MOVLB  0
18E46:  BZ    18E4E
18E48:  XORLW  01
18E4A:  BZ    18E78
18E4C:  BRA    18EA0
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
18E4E:  BCF    FD8.0
18E50:  MOVLB  7
18E52:  RLCF   x40,W
18E54:  CLRF   03
18E56:  ADDLW  4E
18E58:  MOVWF  FE9
18E5A:  MOVLW  07
18E5C:  ADDWFC 03,W
18E5E:  MOVWF  FEA
18E60:  MOVFF  FEC,8F0
18E64:  MOVF   FED,F
18E66:  MOVFF  FEF,8EF
18E6A:  MOVLW  92
18E6C:  MOVLB  8
18E6E:  MOVWF  xEE
18E70:  MOVLB  0
18E72:  CALL   4FFC
....................             break; 
18E76:  BRA    18EA0
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
18E78:  BCF    FD8.0
18E7A:  MOVLB  7
18E7C:  RLCF   x40,W
18E7E:  CLRF   03
18E80:  ADDLW  4E
18E82:  MOVWF  FE9
18E84:  MOVLW  07
18E86:  ADDWFC 03,W
18E88:  MOVWF  FEA
18E8A:  MOVFF  FEC,8F0
18E8E:  MOVF   FED,F
18E90:  MOVFF  FEF,8EF
18E94:  MOVLW  94
18E96:  MOVLB  8
18E98:  MOVWF  xEE
18E9A:  MOVLB  0
18E9C:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
18EA0:  BRA    18EA6
....................    else cmd_arg();    
18EA2:  CALL   B326
18EA6:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
18EAA:  MOVF   4B,F
18EAC:  BNZ   18F3C
18EAE:  MOVF   4A,F
18EB0:  BNZ   18F3C
18EB2:  MOVF   49,W
18EB4:  SUBLW  27
18EB6:  BNC   18F3C
18EB8:  BNZ   18EC0
18EBA:  MOVF   48,W
18EBC:  SUBLW  10
18EBE:  BNC   18F3C
....................       e_cpr[motor] = arg; 
18EC0:  BCF    FD8.0
18EC2:  MOVLB  7
18EC4:  RLCF   x40,W
18EC6:  CLRF   03
18EC8:  ADDLW  5E
18ECA:  MOVWF  FE9
18ECC:  MOVLW  07
18ECE:  ADDWFC 03,W
18ED0:  MOVWF  FEA
18ED2:  MOVFF  48,FEF
18ED6:  MOVFF  49,FEC
....................       switch(motor){ 
18EDA:  MOVF   x40,W
18EDC:  XORLW  00
18EDE:  MOVLB  0
18EE0:  BZ    18EE8
18EE2:  XORLW  01
18EE4:  BZ    18F12
18EE6:  BRA    18F3A
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
18EE8:  BCF    FD8.0
18EEA:  MOVLB  7
18EEC:  RLCF   x40,W
18EEE:  CLRF   03
18EF0:  ADDLW  5E
18EF2:  MOVWF  FE9
18EF4:  MOVLW  07
18EF6:  ADDWFC 03,W
18EF8:  MOVWF  FEA
18EFA:  MOVFF  FEC,8F0
18EFE:  MOVF   FED,F
18F00:  MOVFF  FEF,8EF
18F04:  MOVLW  A2
18F06:  MOVLB  8
18F08:  MOVWF  xEE
18F0A:  MOVLB  0
18F0C:  CALL   4FFC
....................             break; 
18F10:  BRA    18F3A
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
18F12:  BCF    FD8.0
18F14:  MOVLB  7
18F16:  RLCF   x40,W
18F18:  CLRF   03
18F1A:  ADDLW  5E
18F1C:  MOVWF  FE9
18F1E:  MOVLW  07
18F20:  ADDWFC 03,W
18F22:  MOVWF  FEA
18F24:  MOVFF  FEC,8F0
18F28:  MOVF   FED,F
18F2A:  MOVFF  FEF,8EF
18F2E:  MOVLW  A4
18F30:  MOVLB  8
18F32:  MOVWF  xEE
18F34:  MOVLB  0
18F36:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
18F3A:  BRA    18F40
....................    else cmd_arg();    
18F3C:  CALL   B326
18F40:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18F44:  MOVF   4B,F
18F46:  BNZ   18F5C
18F48:  MOVF   4A,F
18F4A:  BNZ   18F5C
18F4C:  MOVF   49,F
18F4E:  BNZ   18F5C
18F50:  MOVF   48,W
18F52:  SUBLW  01
18F54:  BNC   18F5C
18F56:  MOVFF  48,741
18F5A:  BRA    18F60
....................    else cmd_arg();    
18F5C:  CALL   B326
18F60:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18F64:  MOVF   4B,F
18F66:  BNZ   18FF6
18F68:  MOVF   4A,F
18F6A:  BNZ   18FF6
18F6C:  MOVF   49,W
18F6E:  SUBLW  EA
18F70:  BNC   18FF6
18F72:  BNZ   18F7A
18F74:  MOVF   48,W
18F76:  SUBLW  60
18F78:  BNC   18FF6
....................       m_gb_err[motor] = arg; 
18F7A:  BCF    FD8.0
18F7C:  MOVLB  7
18F7E:  RLCF   x40,W
18F80:  CLRF   03
18F82:  ADDLW  5A
18F84:  MOVWF  FE9
18F86:  MOVLW  07
18F88:  ADDWFC 03,W
18F8A:  MOVWF  FEA
18F8C:  MOVFF  48,FEF
18F90:  MOVFF  49,FEC
....................       switch(motor){ 
18F94:  MOVF   x40,W
18F96:  XORLW  00
18F98:  MOVLB  0
18F9A:  BZ    18FA2
18F9C:  XORLW  01
18F9E:  BZ    18FCC
18FA0:  BRA    18FF4
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18FA2:  BCF    FD8.0
18FA4:  MOVLB  7
18FA6:  RLCF   x40,W
18FA8:  CLRF   03
18FAA:  ADDLW  5A
18FAC:  MOVWF  FE9
18FAE:  MOVLW  07
18FB0:  ADDWFC 03,W
18FB2:  MOVWF  FEA
18FB4:  MOVFF  FEC,8F0
18FB8:  MOVF   FED,F
18FBA:  MOVFF  FEF,8EF
18FBE:  MOVLW  9E
18FC0:  MOVLB  8
18FC2:  MOVWF  xEE
18FC4:  MOVLB  0
18FC6:  CALL   4FFC
....................             break; 
18FCA:  BRA    18FF4
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
18FCC:  BCF    FD8.0
18FCE:  MOVLB  7
18FD0:  RLCF   x40,W
18FD2:  CLRF   03
18FD4:  ADDLW  5A
18FD6:  MOVWF  FE9
18FD8:  MOVLW  07
18FDA:  ADDWFC 03,W
18FDC:  MOVWF  FEA
18FDE:  MOVFF  FEC,8F0
18FE2:  MOVF   FED,F
18FE4:  MOVFF  FEF,8EF
18FE8:  MOVLW  A0
18FEA:  MOVLB  8
18FEC:  MOVWF  xEE
18FEE:  MOVLB  0
18FF0:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
18FF4:  BRA    18FFA
....................    else cmd_arg();    
18FF6:  CALL   B326
18FFA:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
18FFE:  MOVF   4B,F
19000:  BNZ   190CA
19002:  MOVF   4A,F
19004:  BNZ   190CA
19006:  MOVF   49,F
19008:  BNZ   190CA
1900A:  MOVF   48,W
1900C:  SUBLW  64
1900E:  BNC   190CA
....................       hold_pc=arg; 
19010:  MOVFF  49,886
19014:  MOVFF  48,885
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
19018:  BCF    FD8.0
1901A:  MOVLB  7
1901C:  RLCF   x40,W
1901E:  CLRF   03
19020:  ADDLW  52
19022:  MOVWF  FE9
19024:  MOVLW  07
19026:  ADDWFC 03,W
19028:  MOVWF  FEA
1902A:  MOVFF  886,A11
1902E:  MOVFF  885,A10
19032:  MOVLW  01
19034:  MOVLB  A
19036:  MOVWF  x13
19038:  SETF   x12
1903A:  MOVLB  0
1903C:  CALL   5CC0
19040:  MOVFF  02,88A
19044:  MOVFF  01,889
19048:  MOVFF  02,8DC
1904C:  MOVFF  01,8DB
19050:  MOVLB  8
19052:  CLRF   xDE
19054:  MOVLW  64
19056:  MOVWF  xDD
19058:  MOVLB  0
1905A:  CALL   2CFC
1905E:  MOVFF  01,FEF
19062:  MOVFF  02,FEC
....................       switch(motor){ 
19066:  MOVLB  7
19068:  MOVF   x40,W
1906A:  XORLW  00
1906C:  MOVLB  0
1906E:  BZ    19076
19070:  XORLW  01
19072:  BZ    190A0
19074:  BRA    190C8
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
19076:  BCF    FD8.0
19078:  MOVLB  7
1907A:  RLCF   x40,W
1907C:  CLRF   03
1907E:  ADDLW  52
19080:  MOVWF  FE9
19082:  MOVLW  07
19084:  ADDWFC 03,W
19086:  MOVWF  FEA
19088:  MOVFF  FEC,8F0
1908C:  MOVF   FED,F
1908E:  MOVFF  FEF,8EF
19092:  MOVLW  96
19094:  MOVLB  8
19096:  MOVWF  xEE
19098:  MOVLB  0
1909A:  CALL   4FFC
....................             break; 
1909E:  BRA    190C8
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
190A0:  BCF    FD8.0
190A2:  MOVLB  7
190A4:  RLCF   x40,W
190A6:  CLRF   03
190A8:  ADDLW  52
190AA:  MOVWF  FE9
190AC:  MOVLW  07
190AE:  ADDWFC 03,W
190B0:  MOVWF  FEA
190B2:  MOVFF  FEC,8F0
190B6:  MOVF   FED,F
190B8:  MOVFF  FEF,8EF
190BC:  MOVLW  98
190BE:  MOVLB  8
190C0:  MOVWF  xEE
190C2:  MOVLB  0
190C4:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
190C8:  BRA    190CE
....................    else cmd_arg();    
190CA:  CALL   B326
190CE:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
190D2:  MOVF   4B,F
190D4:  BNZ   191A6
190D6:  MOVF   4A,F
190D8:  BNZ   191A6
190DA:  MOVF   49,W
190DC:  SUBLW  EA
190DE:  BNC   191A6
190E0:  BNZ   190E8
190E2:  MOVF   48,W
190E4:  SUBLW  60
190E6:  BNC   191A6
....................       m_stp_int[motor] = (arg/100); 
190E8:  BCF    FD8.0
190EA:  MOVLB  7
190EC:  RLCF   x40,W
190EE:  CLRF   03
190F0:  ADDLW  4A
190F2:  MOVWF  FE9
190F4:  MOVLW  07
190F6:  ADDWFC 03,W
190F8:  MOVWF  FEA
190FA:  MOVFF  FEA,888
190FE:  MOVFF  FE9,887
19102:  BCF    FD8.1
19104:  CLRF   1B
19106:  BTFSC  FF2.7
19108:  BSF    1B.7
1910A:  BCF    FF2.7
1910C:  MOVFF  4B,A4F
19110:  MOVFF  4A,A4E
19114:  MOVFF  49,A4D
19118:  MOVFF  48,A4C
1911C:  MOVLB  A
1911E:  CLRF   x53
19120:  CLRF   x52
19122:  CLRF   x51
19124:  MOVLW  64
19126:  MOVWF  x50
19128:  MOVLB  0
1912A:  CALL   1076
1912E:  BTFSC  1B.7
19130:  BSF    FF2.7
19132:  MOVFF  888,FEA
19136:  MOVFF  887,FE9
1913A:  MOVFF  00,FEF
1913E:  MOVFF  01,FEC
....................       switch(motor){ 
19142:  MOVLB  7
19144:  MOVF   x40,W
19146:  XORLW  00
19148:  MOVLB  0
1914A:  BZ    19152
1914C:  XORLW  01
1914E:  BZ    1917C
19150:  BRA    191A4
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
19152:  BCF    FD8.0
19154:  MOVLB  7
19156:  RLCF   x40,W
19158:  CLRF   03
1915A:  ADDLW  4A
1915C:  MOVWF  FE9
1915E:  MOVLW  07
19160:  ADDWFC 03,W
19162:  MOVWF  FEA
19164:  MOVFF  FEC,8F0
19168:  MOVF   FED,F
1916A:  MOVFF  FEF,8EF
1916E:  MOVLW  8E
19170:  MOVLB  8
19172:  MOVWF  xEE
19174:  MOVLB  0
19176:  CALL   4FFC
....................             break; 
1917A:  BRA    191A4
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
1917C:  BCF    FD8.0
1917E:  MOVLB  7
19180:  RLCF   x40,W
19182:  CLRF   03
19184:  ADDLW  4A
19186:  MOVWF  FE9
19188:  MOVLW  07
1918A:  ADDWFC 03,W
1918C:  MOVWF  FEA
1918E:  MOVFF  FEC,8F0
19192:  MOVF   FED,F
19194:  MOVFF  FEF,8EF
19198:  MOVLW  90
1919A:  MOVLB  8
1919C:  MOVWF  xEE
1919E:  MOVLB  0
191A0:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
191A4:  BRA    191AA
....................    else cmd_arg();    
191A6:  CALL   B326
191AA:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
191AE:  MOVF   4B,F
191B0:  BNZ   19240
191B2:  MOVF   4A,F
191B4:  BNZ   19240
191B6:  MOVF   49,W
191B8:  SUBLW  27
191BA:  BNC   19240
191BC:  BNZ   191C4
191BE:  MOVF   48,W
191C0:  SUBLW  10
191C2:  BNC   19240
....................       m_run[motor] = arg; 
191C4:  BCF    FD8.0
191C6:  MOVLB  7
191C8:  RLCF   x40,W
191CA:  CLRF   03
191CC:  ADDLW  6E
191CE:  MOVWF  FE9
191D0:  MOVLW  07
191D2:  ADDWFC 03,W
191D4:  MOVWF  FEA
191D6:  MOVFF  48,FEF
191DA:  MOVFF  49,FEC
....................       switch(motor){ 
191DE:  MOVF   x40,W
191E0:  XORLW  00
191E2:  MOVLB  0
191E4:  BZ    191EC
191E6:  XORLW  01
191E8:  BZ    19216
191EA:  BRA    1923E
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
191EC:  BCF    FD8.0
191EE:  MOVLB  7
191F0:  RLCF   x40,W
191F2:  CLRF   03
191F4:  ADDLW  6E
191F6:  MOVWF  FE9
191F8:  MOVLW  07
191FA:  ADDWFC 03,W
191FC:  MOVWF  FEA
191FE:  MOVFF  FEC,8F0
19202:  MOVF   FED,F
19204:  MOVFF  FEF,8EF
19208:  MOVLW  76
1920A:  MOVLB  8
1920C:  MOVWF  xEE
1920E:  MOVLB  0
19210:  CALL   4FFC
....................             break; 
19214:  BRA    1923E
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
19216:  BCF    FD8.0
19218:  MOVLB  7
1921A:  RLCF   x40,W
1921C:  CLRF   03
1921E:  ADDLW  6E
19220:  MOVWF  FE9
19222:  MOVLW  07
19224:  ADDWFC 03,W
19226:  MOVWF  FEA
19228:  MOVFF  FEC,8F0
1922C:  MOVF   FED,F
1922E:  MOVFF  FEF,8EF
19232:  MOVLW  78
19234:  MOVLB  8
19236:  MOVWF  xEE
19238:  MOVLB  0
1923A:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1923E:  BRA    19244
....................    else cmd_arg();    
19240:  CALL   B326
19244:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
19248:  MOVF   4B,F
1924A:  BNZ   192D6
1924C:  MOVF   4A,F
1924E:  BNZ   192D6
19250:  MOVF   49,F
19252:  BNZ   192D6
19254:  MOVF   48,W
19256:  SUBLW  03
19258:  BNC   192D6
....................       e_mode[motor] = arg; 
1925A:  BCF    FD8.0
1925C:  MOVLB  7
1925E:  RLCF   x40,W
19260:  CLRF   03
19262:  ADDLW  66
19264:  MOVWF  FE9
19266:  MOVLW  07
19268:  ADDWFC 03,W
1926A:  MOVWF  FEA
1926C:  MOVFF  48,FEF
19270:  MOVFF  49,FEC
....................       switch(motor){ 
19274:  MOVF   x40,W
19276:  XORLW  00
19278:  MOVLB  0
1927A:  BZ    19282
1927C:  XORLW  01
1927E:  BZ    192AC
19280:  BRA    192D4
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
19282:  BCF    FD8.0
19284:  MOVLB  7
19286:  RLCF   x40,W
19288:  CLRF   03
1928A:  ADDLW  66
1928C:  MOVWF  FE9
1928E:  MOVLW  07
19290:  ADDWFC 03,W
19292:  MOVWF  FEA
19294:  MOVFF  FEC,8F0
19298:  MOVF   FED,F
1929A:  MOVFF  FEF,8EF
1929E:  MOVLW  82
192A0:  MOVLB  8
192A2:  MOVWF  xEE
192A4:  MOVLB  0
192A6:  CALL   4FFC
....................             break; 
192AA:  BRA    192D4
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
192AC:  BCF    FD8.0
192AE:  MOVLB  7
192B0:  RLCF   x40,W
192B2:  CLRF   03
192B4:  ADDLW  66
192B6:  MOVWF  FE9
192B8:  MOVLW  07
192BA:  ADDWFC 03,W
192BC:  MOVWF  FEA
192BE:  MOVFF  FEC,8F0
192C2:  MOVF   FED,F
192C4:  MOVFF  FEF,8EF
192C8:  MOVLW  84
192CA:  MOVLB  8
192CC:  MOVWF  xEE
192CE:  MOVLB  0
192D0:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
192D4:  BRA    192DA
....................    else cmd_arg();    
192D6:  CALL   B326
192DA:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
19F3E:  MOVF   4B,F
19F40:  BNZ   19FCC
19F42:  MOVF   4A,F
19F44:  BNZ   19FCC
19F46:  MOVF   49,F
19F48:  BNZ   19FCC
19F4A:  MOVF   48,W
19F4C:  SUBLW  01
19F4E:  BNC   19FCC
....................       m_mode[motor] = arg; 
19F50:  BCF    FD8.0
19F52:  MOVLB  7
19F54:  RLCF   x40,W
19F56:  CLRF   03
19F58:  ADDLW  46
19F5A:  MOVWF  FE9
19F5C:  MOVLW  07
19F5E:  ADDWFC 03,W
19F60:  MOVWF  FEA
19F62:  MOVFF  48,FEF
19F66:  MOVFF  49,FEC
....................       switch(motor){ 
19F6A:  MOVF   x40,W
19F6C:  XORLW  00
19F6E:  MOVLB  0
19F70:  BZ    19F78
19F72:  XORLW  01
19F74:  BZ    19FA2
19F76:  BRA    19FCA
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19F78:  BCF    FD8.0
19F7A:  MOVLB  7
19F7C:  RLCF   x40,W
19F7E:  CLRF   03
19F80:  ADDLW  46
19F82:  MOVWF  FE9
19F84:  MOVLW  07
19F86:  ADDWFC 03,W
19F88:  MOVWF  FEA
19F8A:  MOVFF  FEC,8F0
19F8E:  MOVF   FED,F
19F90:  MOVFF  FEF,8EF
19F94:  MOVLW  8A
19F96:  MOVLB  8
19F98:  MOVWF  xEE
19F9A:  MOVLB  0
19F9C:  CALL   4FFC
....................             break; 
19FA0:  BRA    19FCA
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19FA2:  BCF    FD8.0
19FA4:  MOVLB  7
19FA6:  RLCF   x40,W
19FA8:  CLRF   03
19FAA:  ADDLW  46
19FAC:  MOVWF  FE9
19FAE:  MOVLW  07
19FB0:  ADDWFC 03,W
19FB2:  MOVWF  FEA
19FB4:  MOVFF  FEC,8F0
19FB8:  MOVF   FED,F
19FBA:  MOVFF  FEF,8EF
19FBE:  MOVLW  8C
19FC0:  MOVLB  8
19FC2:  MOVWF  xEE
19FC4:  MOVLB  0
19FC6:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
19FCA:  BRA    19FD0
....................    else cmd_arg();    
19FCC:  CALL   B326
19FD0:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19FD4:  MOVF   4B,F
19FD6:  BNZ   1A062
19FD8:  MOVF   4A,F
19FDA:  BNZ   1A062
19FDC:  MOVF   49,F
19FDE:  BNZ   1A062
19FE0:  MOVF   48,W
19FE2:  SUBLW  01
19FE4:  BNC   1A062
....................       e_index[motor] = arg; 
19FE6:  BCF    FD8.0
19FE8:  MOVLB  7
19FEA:  RLCF   x40,W
19FEC:  CLRF   03
19FEE:  ADDLW  7A
19FF0:  MOVWF  FE9
19FF2:  MOVLW  07
19FF4:  ADDWFC 03,W
19FF6:  MOVWF  FEA
19FF8:  MOVFF  48,FEF
19FFC:  MOVFF  49,FEC
....................       switch(motor){ 
1A000:  MOVF   x40,W
1A002:  XORLW  00
1A004:  MOVLB  0
1A006:  BZ    1A00E
1A008:  XORLW  01
1A00A:  BZ    1A038
1A00C:  BRA    1A060
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
1A00E:  BCF    FD8.0
1A010:  MOVLB  7
1A012:  RLCF   x40,W
1A014:  CLRF   03
1A016:  ADDLW  7A
1A018:  MOVWF  FE9
1A01A:  MOVLW  07
1A01C:  ADDWFC 03,W
1A01E:  MOVWF  FEA
1A020:  MOVFF  FEC,8F0
1A024:  MOVF   FED,F
1A026:  MOVFF  FEF,8EF
1A02A:  MOVLW  BA
1A02C:  MOVLB  8
1A02E:  MOVWF  xEE
1A030:  MOVLB  0
1A032:  CALL   4FFC
....................             break; 
1A036:  BRA    1A060
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
1A038:  BCF    FD8.0
1A03A:  MOVLB  7
1A03C:  RLCF   x40,W
1A03E:  CLRF   03
1A040:  ADDLW  7A
1A042:  MOVWF  FE9
1A044:  MOVLW  07
1A046:  ADDWFC 03,W
1A048:  MOVWF  FEA
1A04A:  MOVFF  FEC,8F0
1A04E:  MOVF   FED,F
1A050:  MOVFF  FEF,8EF
1A054:  MOVLW  BC
1A056:  MOVLB  8
1A058:  MOVWF  xEE
1A05A:  MOVLB  0
1A05C:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1A060:  BRA    1A066
....................    else cmd_arg();    
1A062:  CALL   B326
1A066:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
1A06A:  MOVF   4B,F
1A06C:  BNZ   1A0FC
1A06E:  MOVF   4A,F
1A070:  BNZ   1A0FC
1A072:  MOVF   49,W
1A074:  SUBLW  01
1A076:  BNC   1A0FC
1A078:  BNZ   1A080
1A07A:  MOVF   48,W
1A07C:  SUBLW  0A
1A07E:  BNC   1A0FC
....................        evn_so[motor] = arg; 
1A080:  BCF    FD8.0
1A082:  MOVLB  7
1A084:  RLCF   x40,W
1A086:  CLRF   03
1A088:  ADDLW  7E
1A08A:  MOVWF  FE9
1A08C:  MOVLW  07
1A08E:  ADDWFC 03,W
1A090:  MOVWF  FEA
1A092:  MOVFF  48,FEF
1A096:  MOVFF  49,FEC
....................        switch(motor){ 
1A09A:  MOVF   x40,W
1A09C:  XORLW  00
1A09E:  MOVLB  0
1A0A0:  BZ    1A0A8
1A0A2:  XORLW  01
1A0A4:  BZ    1A0D2
1A0A6:  BRA    1A0FA
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
1A0A8:  BCF    FD8.0
1A0AA:  MOVLB  7
1A0AC:  RLCF   x40,W
1A0AE:  CLRF   03
1A0B0:  ADDLW  7E
1A0B2:  MOVWF  FE9
1A0B4:  MOVLW  07
1A0B6:  ADDWFC 03,W
1A0B8:  MOVWF  FEA
1A0BA:  MOVFF  FEC,8F0
1A0BE:  MOVF   FED,F
1A0C0:  MOVFF  FEF,8EF
1A0C4:  MOVLW  BE
1A0C6:  MOVLB  8
1A0C8:  MOVWF  xEE
1A0CA:  MOVLB  0
1A0CC:  CALL   4FFC
....................             break; 
1A0D0:  BRA    1A0FA
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
1A0D2:  BCF    FD8.0
1A0D4:  MOVLB  7
1A0D6:  RLCF   x40,W
1A0D8:  CLRF   03
1A0DA:  ADDLW  7E
1A0DC:  MOVWF  FE9
1A0DE:  MOVLW  07
1A0E0:  ADDWFC 03,W
1A0E2:  MOVWF  FEA
1A0E4:  MOVFF  FEC,8F0
1A0E8:  MOVF   FED,F
1A0EA:  MOVFF  FEF,8EF
1A0EE:  MOVLW  C0
1A0F0:  MOVLB  8
1A0F2:  MOVWF  xEE
1A0F4:  MOVLB  0
1A0F6:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1A0FA:  BRA    1A100
....................    else cmd_arg();    
1A0FC:  CALL   B326
1A100:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
1A104:  MOVF   4B,F
1A106:  BNZ   1A196
1A108:  MOVF   4A,F
1A10A:  BNZ   1A196
1A10C:  MOVF   49,W
1A10E:  SUBLW  03
1A110:  BNC   1A196
1A112:  BNZ   1A11A
1A114:  MOVF   48,W
1A116:  SUBLW  E8
1A118:  BNC   1A196
....................       e_ppr[motor] = arg; 
1A11A:  BCF    FD8.0
1A11C:  MOVLB  7
1A11E:  RLCF   x40,W
1A120:  CLRF   03
1A122:  ADDLW  62
1A124:  MOVWF  FE9
1A126:  MOVLW  07
1A128:  ADDWFC 03,W
1A12A:  MOVWF  FEA
1A12C:  MOVFF  48,FEF
1A130:  MOVFF  49,FEC
....................       switch(motor){ 
1A134:  MOVF   x40,W
1A136:  XORLW  00
1A138:  MOVLB  0
1A13A:  BZ    1A142
1A13C:  XORLW  01
1A13E:  BZ    1A16C
1A140:  BRA    1A194
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
1A142:  BCF    FD8.0
1A144:  MOVLB  7
1A146:  RLCF   x40,W
1A148:  CLRF   03
1A14A:  ADDLW  62
1A14C:  MOVWF  FE9
1A14E:  MOVLW  07
1A150:  ADDWFC 03,W
1A152:  MOVWF  FEA
1A154:  MOVFF  FEC,8F0
1A158:  MOVF   FED,F
1A15A:  MOVFF  FEF,8EF
1A15E:  MOVLW  A6
1A160:  MOVLB  8
1A162:  MOVWF  xEE
1A164:  MOVLB  0
1A166:  CALL   4FFC
....................             break; 
1A16A:  BRA    1A194
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
1A16C:  BCF    FD8.0
1A16E:  MOVLB  7
1A170:  RLCF   x40,W
1A172:  CLRF   03
1A174:  ADDLW  62
1A176:  MOVWF  FE9
1A178:  MOVLW  07
1A17A:  ADDWFC 03,W
1A17C:  MOVWF  FEA
1A17E:  MOVFF  FEC,8F0
1A182:  MOVF   FED,F
1A184:  MOVFF  FEF,8EF
1A188:  MOVLW  A8
1A18A:  MOVLB  8
1A18C:  MOVWF  xEE
1A18E:  MOVLB  0
1A190:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1A194:  BRA    1A19A
....................    else cmd_arg();    
1A196:  CALL   B326
1A19A:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
1A19E:  MOVF   48,F
1A1A0:  BNZ   1A1B2
1A1A2:  MOVF   49,F
1A1A4:  BNZ   1A1B2
1A1A6:  MOVF   4A,F
1A1A8:  BNZ   1A1B2
1A1AA:  MOVF   4B,F
1A1AC:  BNZ   1A1B2
1A1AE:  BCF    F8E.1
1A1B0:  BRA    1A1B6
....................    else cmd_arg();    
1A1B2:  CALL   B326
1A1B6:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1AC9A:  MOVF   48,F
1AC9C:  BNZ   1ACEC
1AC9E:  MOVF   49,F
1ACA0:  BNZ   1ACEC
1ACA2:  MOVF   4A,F
1ACA4:  BNZ   1ACEC
1ACA6:  MOVF   4B,F
1ACA8:  BNZ   1ACEC
....................       switch (nv_product) { 
1ACAA:  MOVFF  2F,00
1ACAE:  MOVF   30,W
1ACB0:  MOVWF  03
1ACB2:  BNZ   1ACB8
1ACB4:  MOVF   00,F
1ACB6:  BZ    1ACD8
1ACB8:  MOVF   03,W
1ACBA:  BNZ   1ACC2
1ACBC:  MOVLW  01
1ACBE:  SUBWF  00,W
1ACC0:  BZ    1ACDE
1ACC2:  MOVF   03,W
1ACC4:  BNZ   1ACCC
1ACC6:  MOVLW  02
1ACC8:  SUBWF  00,W
1ACCA:  BZ    1ACE4
1ACCC:  MOVF   03,W
1ACCE:  BNZ   1ACD6
1ACD0:  MOVLW  03
1ACD2:  SUBWF  00,W
1ACD4:  BZ    1ACE8
1ACD6:  BRA    1ACEA
....................          case ECO : rst_step_vars_eco(); 
1ACD8:  GOTO   1A1BA
....................             break; 
1ACDC:  BRA    1ACEA
....................          case WMS4 : rst_step_vars_wms4(); 
1ACDE:  GOTO   1A4A4
....................             break; 
1ACE2:  BRA    1ACEA
....................          case AWS : rst_step_vars_aws(); 
1ACE4:  BRA    1A750
....................             break;             
1ACE6:  BRA    1ACEA
....................          case WMS2 : rst_step_vars_wms2(); 
1ACE8:  BRA    1A9EA
....................             break; 
....................       } 
....................    }  
1ACEA:  BRA    1ACF0
....................    else cmd_arg(); 
1ACEC:  CALL   B326
1ACF0:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1ACF4:  MOVF   4B,F
1ACF6:  BTFSS  FD8.2
1ACF8:  BRA    1ADFA
1ACFA:  MOVF   4A,W
1ACFC:  SUBLW  00
1ACFE:  BTFSS  FD8.0
1AD00:  BRA    1ADFA
....................       m_spr[motor] = arg; 
1AD02:  BCF    FD8.0
1AD04:  MOVLB  7
1AD06:  RLCF   x40,W
1AD08:  CLRF   03
1AD0A:  ADDLW  76
1AD0C:  MOVWF  FE9
1AD0E:  MOVLW  07
1AD10:  ADDWFC 03,W
1AD12:  MOVWF  FEA
1AD14:  MOVFF  48,FEF
1AD18:  MOVFF  49,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1AD1C:  BCF    FD8.0
1AD1E:  RLCF   x40,W
1AD20:  CLRF   03
1AD22:  ADDLW  AB
1AD24:  MOVWF  01
1AD26:  MOVLW  07
1AD28:  ADDWFC 03,F
1AD2A:  MOVFF  01,885
1AD2E:  MOVLB  8
1AD30:  MOVFF  03,886
1AD34:  BCF    FD8.0
1AD36:  MOVLB  7
1AD38:  RLCF   x40,W
1AD3A:  CLRF   03
1AD3C:  ADDLW  76
1AD3E:  MOVWF  FE9
1AD40:  MOVLW  07
1AD42:  ADDWFC 03,W
1AD44:  MOVWF  FEA
1AD46:  MOVFF  FEC,8DC
1AD4A:  MOVF   FED,F
1AD4C:  MOVFF  FEF,8DB
1AD50:  BCF    FD8.0
1AD52:  RLCF   x40,W
1AD54:  CLRF   03
1AD56:  ADDLW  62
1AD58:  MOVWF  FE9
1AD5A:  MOVLW  07
1AD5C:  ADDWFC 03,W
1AD5E:  MOVWF  FEA
1AD60:  MOVFF  FEC,03
1AD64:  MOVF   FED,F
1AD66:  MOVFF  FEF,8DD
1AD6A:  MOVFF  03,88A
1AD6E:  MOVFF  03,8DE
1AD72:  MOVLB  0
1AD74:  CALL   2CFC
1AD78:  MOVFF  02,888
1AD7C:  BCF    FD8.0
1AD7E:  MOVLB  8
1AD80:  RLCF   01,W
1AD82:  MOVWF  02
1AD84:  RLCF   x88,W
1AD86:  MOVFF  886,FEA
1AD8A:  MOVFF  885,FE9
1AD8E:  MOVWF  FEC
1AD90:  MOVF   FED,F
1AD92:  MOVFF  02,FEF
....................       switch(motor){ 
1AD96:  MOVLB  7
1AD98:  MOVF   x40,W
1AD9A:  XORLW  00
1AD9C:  MOVLB  0
1AD9E:  BZ    1ADA6
1ADA0:  XORLW  01
1ADA2:  BZ    1ADD0
1ADA4:  BRA    1ADF8
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1ADA6:  BCF    FD8.0
1ADA8:  MOVLB  7
1ADAA:  RLCF   x40,W
1ADAC:  CLRF   03
1ADAE:  ADDLW  76
1ADB0:  MOVWF  FE9
1ADB2:  MOVLW  07
1ADB4:  ADDWFC 03,W
1ADB6:  MOVWF  FEA
1ADB8:  MOVFF  FEC,8F0
1ADBC:  MOVF   FED,F
1ADBE:  MOVFF  FEF,8EF
1ADC2:  MOVLW  AE
1ADC4:  MOVLB  8
1ADC6:  MOVWF  xEE
1ADC8:  MOVLB  0
1ADCA:  CALL   4FFC
....................             break; 
1ADCE:  BRA    1ADF8
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1ADD0:  BCF    FD8.0
1ADD2:  MOVLB  7
1ADD4:  RLCF   x40,W
1ADD6:  CLRF   03
1ADD8:  ADDLW  76
1ADDA:  MOVWF  FE9
1ADDC:  MOVLW  07
1ADDE:  ADDWFC 03,W
1ADE0:  MOVWF  FEA
1ADE2:  MOVFF  FEC,8F0
1ADE6:  MOVF   FED,F
1ADE8:  MOVFF  FEF,8EF
1ADEC:  MOVLW  B0
1ADEE:  MOVLB  8
1ADF0:  MOVWF  xEE
1ADF2:  MOVLB  0
1ADF4:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1ADF8:  BRA    1ADFE
....................    else cmd_arg();    
1ADFA:  CALL   B326
1ADFE:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1AE02:  MOVF   4B,F
1AE04:  BNZ   1AE90
1AE06:  MOVF   4A,F
1AE08:  BNZ   1AE90
1AE0A:  MOVF   49,F
1AE0C:  BNZ   1AE90
1AE0E:  MOVF   48,W
1AE10:  SUBLW  02
1AE12:  BNC   1AE90
....................       e_type[motor] = arg; 
1AE14:  BCF    FD8.0
1AE16:  MOVLB  7
1AE18:  RLCF   x40,W
1AE1A:  CLRF   03
1AE1C:  ADDLW  6A
1AE1E:  MOVWF  FE9
1AE20:  MOVLW  07
1AE22:  ADDWFC 03,W
1AE24:  MOVWF  FEA
1AE26:  MOVFF  48,FEF
1AE2A:  MOVFF  49,FEC
....................       switch(motor){ 
1AE2E:  MOVF   x40,W
1AE30:  XORLW  00
1AE32:  MOVLB  0
1AE34:  BZ    1AE3C
1AE36:  XORLW  01
1AE38:  BZ    1AE66
1AE3A:  BRA    1AE8E
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1AE3C:  BCF    FD8.0
1AE3E:  MOVLB  7
1AE40:  RLCF   x40,W
1AE42:  CLRF   03
1AE44:  ADDLW  6A
1AE46:  MOVWF  FE9
1AE48:  MOVLW  07
1AE4A:  ADDWFC 03,W
1AE4C:  MOVWF  FEA
1AE4E:  MOVFF  FEC,8F0
1AE52:  MOVF   FED,F
1AE54:  MOVFF  FEF,8EF
1AE58:  MOVLW  7A
1AE5A:  MOVLB  8
1AE5C:  MOVWF  xEE
1AE5E:  MOVLB  0
1AE60:  CALL   4FFC
....................             break; 
1AE64:  BRA    1AE8E
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1AE66:  BCF    FD8.0
1AE68:  MOVLB  7
1AE6A:  RLCF   x40,W
1AE6C:  CLRF   03
1AE6E:  ADDLW  6A
1AE70:  MOVWF  FE9
1AE72:  MOVLW  07
1AE74:  ADDWFC 03,W
1AE76:  MOVWF  FEA
1AE78:  MOVFF  FEC,8F0
1AE7C:  MOVF   FED,F
1AE7E:  MOVFF  FEF,8EF
1AE82:  MOVLW  7C
1AE84:  MOVLB  8
1AE86:  MOVWF  xEE
1AE88:  MOVLB  0
1AE8A:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1AE8E:  BRA    1AE94
....................    else cmd_arg();    
1AE90:  CALL   B326
1AE94:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... //currently used to test dio pins 
.................... void command_v(){ 
....................    if(arg == 00){ 
*
13DFE:  MOVF   48,F
13E00:  BNZ   13E12
13E02:  MOVF   49,F
13E04:  BNZ   13E12
13E06:  MOVF   4A,F
13E08:  BNZ   13E12
13E0A:  MOVF   4B,F
13E0C:  BNZ   13E12
....................       output_bit(PIN_D0,0); 
13E0E:  BCF    F8C.0
....................    }else if(arg == 01){ 
13E10:  BRA    13F58
13E12:  DECFSZ 48,W
13E14:  BRA    13E26
13E16:  MOVF   49,F
13E18:  BNZ   13E26
13E1A:  MOVF   4A,F
13E1C:  BNZ   13E26
13E1E:  MOVF   4B,F
13E20:  BNZ   13E26
....................       output_bit(PIN_D0,1); 
13E22:  BSF    F8C.0
....................    }else if(arg == 10){ 
13E24:  BRA    13F58
13E26:  MOVF   48,W
13E28:  SUBLW  0A
13E2A:  BNZ   13E3C
13E2C:  MOVF   49,F
13E2E:  BNZ   13E3C
13E30:  MOVF   4A,F
13E32:  BNZ   13E3C
13E34:  MOVF   4B,F
13E36:  BNZ   13E3C
....................       output_bit(PIN_D1,0); 
13E38:  BCF    F8C.1
....................    }else if(arg == 11){ 
13E3A:  BRA    13F58
13E3C:  MOVF   48,W
13E3E:  SUBLW  0B
13E40:  BNZ   13E52
13E42:  MOVF   49,F
13E44:  BNZ   13E52
13E46:  MOVF   4A,F
13E48:  BNZ   13E52
13E4A:  MOVF   4B,F
13E4C:  BNZ   13E52
....................       output_bit(PIN_D1,1); 
13E4E:  BSF    F8C.1
....................    }else if(arg == 20){ 
13E50:  BRA    13F58
13E52:  MOVF   48,W
13E54:  SUBLW  14
13E56:  BNZ   13E68
13E58:  MOVF   49,F
13E5A:  BNZ   13E68
13E5C:  MOVF   4A,F
13E5E:  BNZ   13E68
13E60:  MOVF   4B,F
13E62:  BNZ   13E68
....................       output_bit(PIN_D2,0); 
13E64:  BCF    F8C.2
....................    }else if(arg == 21){ 
13E66:  BRA    13F58
13E68:  MOVF   48,W
13E6A:  SUBLW  15
13E6C:  BNZ   13E7E
13E6E:  MOVF   49,F
13E70:  BNZ   13E7E
13E72:  MOVF   4A,F
13E74:  BNZ   13E7E
13E76:  MOVF   4B,F
13E78:  BNZ   13E7E
....................       output_bit(PIN_D2,1); 
13E7A:  BSF    F8C.2
....................    }else if(arg == 30){ 
13E7C:  BRA    13F58
13E7E:  MOVF   48,W
13E80:  SUBLW  1E
13E82:  BNZ   13E94
13E84:  MOVF   49,F
13E86:  BNZ   13E94
13E88:  MOVF   4A,F
13E8A:  BNZ   13E94
13E8C:  MOVF   4B,F
13E8E:  BNZ   13E94
....................       output_bit(PIN_D3,0); 
13E90:  BCF    F8C.3
....................    }else if(arg == 31){ 
13E92:  BRA    13F58
13E94:  MOVF   48,W
13E96:  SUBLW  1F
13E98:  BNZ   13EAA
13E9A:  MOVF   49,F
13E9C:  BNZ   13EAA
13E9E:  MOVF   4A,F
13EA0:  BNZ   13EAA
13EA2:  MOVF   4B,F
13EA4:  BNZ   13EAA
....................       output_bit(PIN_D3,1); 
13EA6:  BSF    F8C.3
....................    }else if(arg == 40){ 
13EA8:  BRA    13F58
13EAA:  MOVF   48,W
13EAC:  SUBLW  28
13EAE:  BNZ   13EC0
13EB0:  MOVF   49,F
13EB2:  BNZ   13EC0
13EB4:  MOVF   4A,F
13EB6:  BNZ   13EC0
13EB8:  MOVF   4B,F
13EBA:  BNZ   13EC0
....................       output_bit(PIN_D4,0); 
13EBC:  BCF    F8C.4
....................    }else if(arg == 41){ 
13EBE:  BRA    13F58
13EC0:  MOVF   48,W
13EC2:  SUBLW  29
13EC4:  BNZ   13ED6
13EC6:  MOVF   49,F
13EC8:  BNZ   13ED6
13ECA:  MOVF   4A,F
13ECC:  BNZ   13ED6
13ECE:  MOVF   4B,F
13ED0:  BNZ   13ED6
....................       output_bit(PIN_D4,1); 
13ED2:  BSF    F8C.4
....................    }else if(arg == 50){ 
13ED4:  BRA    13F58
13ED6:  MOVF   48,W
13ED8:  SUBLW  32
13EDA:  BNZ   13EEC
13EDC:  MOVF   49,F
13EDE:  BNZ   13EEC
13EE0:  MOVF   4A,F
13EE2:  BNZ   13EEC
13EE4:  MOVF   4B,F
13EE6:  BNZ   13EEC
....................       output_bit(PIN_D5,0); 
13EE8:  BCF    F8C.5
....................    }else if(arg == 51){ 
13EEA:  BRA    13F58
13EEC:  MOVF   48,W
13EEE:  SUBLW  33
13EF0:  BNZ   13F02
13EF2:  MOVF   49,F
13EF4:  BNZ   13F02
13EF6:  MOVF   4A,F
13EF8:  BNZ   13F02
13EFA:  MOVF   4B,F
13EFC:  BNZ   13F02
....................       output_bit(PIN_D5,1); 
13EFE:  BSF    F8C.5
....................    }else if(arg == 60){ 
13F00:  BRA    13F58
13F02:  MOVF   48,W
13F04:  SUBLW  3C
13F06:  BNZ   13F18
13F08:  MOVF   49,F
13F0A:  BNZ   13F18
13F0C:  MOVF   4A,F
13F0E:  BNZ   13F18
13F10:  MOVF   4B,F
13F12:  BNZ   13F18
....................       output_bit(PIN_D6,0); 
13F14:  BCF    F8C.6
....................    }else if(arg == 61){ 
13F16:  BRA    13F58
13F18:  MOVF   48,W
13F1A:  SUBLW  3D
13F1C:  BNZ   13F2E
13F1E:  MOVF   49,F
13F20:  BNZ   13F2E
13F22:  MOVF   4A,F
13F24:  BNZ   13F2E
13F26:  MOVF   4B,F
13F28:  BNZ   13F2E
....................       output_bit(PIN_D6,1); 
13F2A:  BSF    F8C.6
....................    }else if(arg == 70){ 
13F2C:  BRA    13F58
13F2E:  MOVF   48,W
13F30:  SUBLW  46
13F32:  BNZ   13F44
13F34:  MOVF   49,F
13F36:  BNZ   13F44
13F38:  MOVF   4A,F
13F3A:  BNZ   13F44
13F3C:  MOVF   4B,F
13F3E:  BNZ   13F44
....................       output_bit(PIN_D7,0); 
13F40:  BCF    F8C.7
....................    }else if(arg == 71){ 
13F42:  BRA    13F58
13F44:  MOVF   48,W
13F46:  SUBLW  47
13F48:  BNZ   13F58
13F4A:  MOVF   49,F
13F4C:  BNZ   13F58
13F4E:  MOVF   4A,F
13F50:  BNZ   13F58
13F52:  MOVF   4B,F
13F54:  BNZ   13F58
....................       output_bit(PIN_D7,1); 
13F56:  BSF    F8C.7
....................    } 
13F58:  RETURN 0
.................... } 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1AED0:  MOVF   4B,F
1AED2:  BNZ   1AF9C
1AED4:  MOVF   4A,F
1AED6:  BNZ   1AF9C
1AED8:  MOVF   49,F
1AEDA:  BNZ   1AF9C
1AEDC:  MOVF   48,W
1AEDE:  SUBLW  64
1AEE0:  BNC   1AF9C
....................       drive_pc=arg; 
1AEE2:  MOVFF  49,886
1AEE6:  MOVFF  48,885
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1AEEA:  BCF    FD8.0
1AEEC:  MOVLB  7
1AEEE:  RLCF   x40,W
1AEF0:  CLRF   03
1AEF2:  ADDLW  56
1AEF4:  MOVWF  FE9
1AEF6:  MOVLW  07
1AEF8:  ADDWFC 03,W
1AEFA:  MOVWF  FEA
1AEFC:  MOVFF  886,A11
1AF00:  MOVFF  885,A10
1AF04:  MOVLW  01
1AF06:  MOVLB  A
1AF08:  MOVWF  x13
1AF0A:  SETF   x12
1AF0C:  MOVLB  0
1AF0E:  CALL   5CC0
1AF12:  MOVFF  02,88A
1AF16:  MOVFF  01,889
1AF1A:  MOVFF  02,8DC
1AF1E:  MOVFF  01,8DB
1AF22:  MOVLB  8
1AF24:  CLRF   xDE
1AF26:  MOVLW  64
1AF28:  MOVWF  xDD
1AF2A:  MOVLB  0
1AF2C:  CALL   2CFC
1AF30:  MOVFF  01,FEF
1AF34:  MOVFF  02,FEC
....................       switch(motor){ 
1AF38:  MOVLB  7
1AF3A:  MOVF   x40,W
1AF3C:  XORLW  00
1AF3E:  MOVLB  0
1AF40:  BZ    1AF48
1AF42:  XORLW  01
1AF44:  BZ    1AF72
1AF46:  BRA    1AF9A
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1AF48:  BCF    FD8.0
1AF4A:  MOVLB  7
1AF4C:  RLCF   x40,W
1AF4E:  CLRF   03
1AF50:  ADDLW  56
1AF52:  MOVWF  FE9
1AF54:  MOVLW  07
1AF56:  ADDWFC 03,W
1AF58:  MOVWF  FEA
1AF5A:  MOVFF  FEC,8F0
1AF5E:  MOVF   FED,F
1AF60:  MOVFF  FEF,8EF
1AF64:  MOVLW  9A
1AF66:  MOVLB  8
1AF68:  MOVWF  xEE
1AF6A:  MOVLB  0
1AF6C:  CALL   4FFC
....................             break; 
1AF70:  BRA    1AF9A
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1AF72:  BCF    FD8.0
1AF74:  MOVLB  7
1AF76:  RLCF   x40,W
1AF78:  CLRF   03
1AF7A:  ADDLW  56
1AF7C:  MOVWF  FE9
1AF7E:  MOVLW  07
1AF80:  ADDWFC 03,W
1AF82:  MOVWF  FEA
1AF84:  MOVFF  FEC,8F0
1AF88:  MOVF   FED,F
1AF8A:  MOVFF  FEF,8EF
1AF8E:  MOVLW  9C
1AF90:  MOVLB  8
1AF92:  MOVWF  xEE
1AF94:  MOVLB  0
1AF96:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1AF9A:  BRA    1AFA0
....................    else cmd_arg();    
1AF9C:  CALL   B326
1AFA0:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1AFA4:  MOVF   4B,F
1AFA6:  BNZ   1B036
1AFA8:  MOVF   4A,F
1AFAA:  BNZ   1B036
1AFAC:  MOVF   49,W
1AFAE:  SUBLW  27
1AFB0:  BNC   1B036
1AFB2:  BNZ   1AFBA
1AFB4:  MOVF   48,W
1AFB6:  SUBLW  0F
1AFB8:  BNC   1B036
....................        align_os[motor] = arg; 
1AFBA:  BCF    FD8.0
1AFBC:  MOVLB  7
1AFBE:  RLCF   x40,W
1AFC0:  CLRF   03
1AFC2:  ADDLW  82
1AFC4:  MOVWF  FE9
1AFC6:  MOVLW  07
1AFC8:  ADDWFC 03,W
1AFCA:  MOVWF  FEA
1AFCC:  MOVFF  48,FEF
1AFD0:  MOVFF  49,FEC
....................        switch(motor){ 
1AFD4:  MOVF   x40,W
1AFD6:  XORLW  00
1AFD8:  MOVLB  0
1AFDA:  BZ    1AFE2
1AFDC:  XORLW  01
1AFDE:  BZ    1B00C
1AFE0:  BRA    1B034
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1AFE2:  BCF    FD8.0
1AFE4:  MOVLB  7
1AFE6:  RLCF   x40,W
1AFE8:  CLRF   03
1AFEA:  ADDLW  82
1AFEC:  MOVWF  FE9
1AFEE:  MOVLW  07
1AFF0:  ADDWFC 03,W
1AFF2:  MOVWF  FEA
1AFF4:  MOVFF  FEC,8F0
1AFF8:  MOVF   FED,F
1AFFA:  MOVFF  FEF,8EF
1AFFE:  MOVLW  C2
1B000:  MOVLB  8
1B002:  MOVWF  xEE
1B004:  MOVLB  0
1B006:  CALL   4FFC
....................             break; 
1B00A:  BRA    1B034
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1B00C:  BCF    FD8.0
1B00E:  MOVLB  7
1B010:  RLCF   x40,W
1B012:  CLRF   03
1B014:  ADDLW  82
1B016:  MOVWF  FE9
1B018:  MOVLW  07
1B01A:  ADDWFC 03,W
1B01C:  MOVWF  FEA
1B01E:  MOVFF  FEC,8F0
1B022:  MOVF   FED,F
1B024:  MOVFF  FEF,8EF
1B028:  MOVLW  C4
1B02A:  MOVLB  8
1B02C:  MOVWF  xEE
1B02E:  MOVLB  0
1B030:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1B034:  BRA    1B03A
....................    else cmd_arg();    
1B036:  CALL   B326
1B03A:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1B03E:  MOVF   4B,F
1B040:  BNZ   1B0CC
1B042:  MOVF   4A,F
1B044:  BNZ   1B0CC
1B046:  MOVF   49,F
1B048:  BNZ   1B0CC
1B04A:  MOVF   48,W
1B04C:  SUBLW  01
1B04E:  BNC   1B0CC
....................       m_ctrl[motor] = arg; 
1B050:  BCF    FD8.0
1B052:  MOVLB  7
1B054:  RLCF   x40,W
1B056:  CLRF   03
1B058:  ADDLW  42
1B05A:  MOVWF  FE9
1B05C:  MOVLW  07
1B05E:  ADDWFC 03,W
1B060:  MOVWF  FEA
1B062:  MOVFF  48,FEF
1B066:  MOVFF  49,FEC
....................       switch(motor){ 
1B06A:  MOVF   x40,W
1B06C:  XORLW  00
1B06E:  MOVLB  0
1B070:  BZ    1B078
1B072:  XORLW  01
1B074:  BZ    1B0A2
1B076:  BRA    1B0CA
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1B078:  BCF    FD8.0
1B07A:  MOVLB  7
1B07C:  RLCF   x40,W
1B07E:  CLRF   03
1B080:  ADDLW  42
1B082:  MOVWF  FE9
1B084:  MOVLW  07
1B086:  ADDWFC 03,W
1B088:  MOVWF  FEA
1B08A:  MOVFF  FEC,8F0
1B08E:  MOVF   FED,F
1B090:  MOVFF  FEF,8EF
1B094:  MOVLW  86
1B096:  MOVLB  8
1B098:  MOVWF  xEE
1B09A:  MOVLB  0
1B09C:  CALL   4FFC
....................             break; 
1B0A0:  BRA    1B0CA
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1B0A2:  BCF    FD8.0
1B0A4:  MOVLB  7
1B0A6:  RLCF   x40,W
1B0A8:  CLRF   03
1B0AA:  ADDLW  42
1B0AC:  MOVWF  FE9
1B0AE:  MOVLW  07
1B0B0:  ADDWFC 03,W
1B0B2:  MOVWF  FEA
1B0B4:  MOVFF  FEC,8F0
1B0B8:  MOVF   FED,F
1B0BA:  MOVFF  FEF,8EF
1B0BE:  MOVLW  88
1B0C0:  MOVLB  8
1B0C2:  MOVWF  xEE
1B0C4:  MOVLB  0
1B0C6:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1B0CA:  BRA    1B0D0
....................    else cmd_arg();    
1B0CC:  CALL   B326
1B0D0:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1AE98:  MOVF   48,W
1AE9A:  MOVWF  00
1AE9C:  MOVF   49,W
1AE9E:  MOVWF  03
1AEA0:  BNZ   1AEA8
1AEA2:  MOVLW  01
1AEA4:  SUBWF  00,W
1AEA6:  BZ    1AEB4
1AEA8:  MOVF   03,W
1AEAA:  BNZ   1AEB2
1AEAC:  MOVLW  02
1AEAE:  SUBWF  00,W
1AEB0:  BZ    1AEBA
1AEB2:  BRA    1AEC4
....................       case 1: motor = 0; 
1AEB4:  MOVLB  7
1AEB6:  CLRF   x40
....................          break; 
1AEB8:  BRA    1AECA
....................       case 2: motor = 1; 
1AEBA:  MOVLW  01
1AEBC:  MOVLB  7
1AEBE:  MOVWF  x40
....................          break; 
1AEC0:  BRA    1AECA
1AEC2:  MOVLB  0
....................       default : cmd_arg(); 
1AEC4:  CALL   B326
....................          break; 
1AEC8:  MOVLB  7
....................    } 
1AECA:  MOVLB  0
1AECC:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1B0D4:  MOVF   48,F
1B0D6:  BNZ   1B0E4
1B0D8:  MOVF   49,F
1B0DA:  BNZ   1B0E4
1B0DC:  MOVF   4A,F
1B0DE:  BNZ   1B0E4
1B0E0:  MOVF   4B,F
1B0E2:  BZ    1B142
1B0E4:  MOVF   4B,F
1B0E6:  BNZ   1B142
1B0E8:  MOVF   4A,F
1B0EA:  BNZ   1B142
1B0EC:  MOVF   49,F
1B0EE:  BNZ   1B142
1B0F0:  MOVF   48,W
1B0F2:  SUBLW  02
1B0F4:  BNC   1B142
....................       switch(arg){ 
1B0F6:  MOVFF  48,00
1B0FA:  MOVF   49,W
1B0FC:  MOVWF  03
1B0FE:  BNZ   1B106
1B100:  MOVLW  01
1B102:  SUBWF  00,W
1B104:  BZ    1B112
1B106:  MOVF   03,W
1B108:  BNZ   1B110
1B10A:  MOVLW  02
1B10C:  SUBWF  00,W
1B10E:  BZ    1B12A
1B110:  BRA    1B140
....................          case 1 : e_pos[0] = 0; 
1B112:  MOVLB  7
1B114:  CLRF   xC0
1B116:  CLRF   xBF
....................                   write16(ADDR_E1_POS, 0); 
1B118:  MOVLW  7E
1B11A:  MOVLB  8
1B11C:  MOVWF  xEE
1B11E:  CLRF   xF0
1B120:  CLRF   xEF
1B122:  MOVLB  0
1B124:  CALL   4FFC
....................             break; 
1B128:  BRA    1B140
....................          case 2 : e_pos[1] = 0; 
1B12A:  MOVLB  7
1B12C:  CLRF   xC2
1B12E:  CLRF   xC1
....................                   write16(ADDR_E2_POS, 0); 
1B130:  MOVLW  80
1B132:  MOVLB  8
1B134:  MOVWF  xEE
1B136:  CLRF   xF0
1B138:  CLRF   xEF
1B13A:  MOVLB  0
1B13C:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1B140:  BRA    1B146
....................    else cmd_arg();  
1B142:  CALL   B326
1B146:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
192DE:  DECFSZ 48,W
192E0:  GOTO   19F36
192E4:  MOVF   49,F
192E6:  BTFSS  FD8.2
192E8:  GOTO   19F36
192EC:  MOVF   4A,F
192EE:  BTFSS  FD8.2
192F0:  GOTO   19F36
192F4:  MOVF   4B,F
192F6:  BTFSS  FD8.2
192F8:  GOTO   19F36
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
192FC:  MOVFF  753,A11
19300:  MOVFF  752,A10
19304:  MOVLB  A
19306:  CLRF   x13
19308:  MOVLW  64
1930A:  MOVWF  x12
1930C:  MOVLB  0
1930E:  CALL   5CC0
19312:  MOVFF  02,88C
19316:  MOVFF  01,88B
1931A:  MOVFF  02,8DC
1931E:  MOVFF  01,8DB
19322:  MOVLW  01
19324:  MOVLB  8
19326:  MOVWF  xDE
19328:  SETF   xDD
1932A:  MOVLB  0
1932C:  CALL   2CFC
19330:  MOVFF  02,886
19334:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
19338:  MOVFF  757,A11
1933C:  MOVFF  756,A10
19340:  MOVLB  A
19342:  CLRF   x13
19344:  MOVLW  64
19346:  MOVWF  x12
19348:  MOVLB  0
1934A:  CALL   5CC0
1934E:  MOVFF  02,88C
19352:  MOVFF  01,88B
19356:  MOVFF  02,8DC
1935A:  MOVFF  01,8DB
1935E:  MOVLW  01
19360:  MOVLB  8
19362:  MOVWF  xDE
19364:  SETF   xDD
19366:  MOVLB  0
19368:  CALL   2CFC
1936C:  MOVFF  02,888
19370:  MOVFF  01,887
....................       step_us  =   m_stp_int[0]*100; 
19374:  MOVFF  74B,A11
19378:  MOVFF  74A,A10
1937C:  MOVLB  A
1937E:  CLRF   x13
19380:  MOVLW  64
19382:  MOVWF  x12
19384:  MOVLB  0
19386:  CALL   5CC0
1938A:  MOVFF  02,88A
1938E:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
19392:  MOVLW  3A
19394:  MOVWF  FF6
19396:  MOVLW  27
19398:  MOVWF  FF7
1939A:  MOVLW  00
1939C:  MOVWF  FF8
1939E:  CLRF   1B
193A0:  BTFSC  FF2.7
193A2:  BSF    1B.7
193A4:  BCF    FF2.7
193A6:  CALL   0E6E
193AA:  BTFSC  1B.7
193AC:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
193AE:  MOVLW  62
193B0:  BTFSS  F9E.4
193B2:  BRA    193B0
193B4:  MOVWF  FAD
193B6:  MOVLW  3A
193B8:  BTFSS  F9E.4
193BA:  BRA    193B8
193BC:  MOVWF  FAD
193BE:  MOVLW  10
193C0:  MOVWF  FE9
193C2:  CLRF   1B
193C4:  BTFSC  FF2.7
193C6:  BSF    1B.7
193C8:  BCF    FF2.7
193CA:  MOVFF  773,A41
193CE:  MOVFF  772,A40
193D2:  CALL   11C6
193D6:  BTFSC  1B.7
193D8:  BSF    FF2.7
193DA:  MOVLW  0D
193DC:  BTFSS  F9E.4
193DE:  BRA    193DC
193E0:  MOVWF  FAD
193E2:  MOVLW  0A
193E4:  BTFSS  F9E.4
193E6:  BRA    193E4
193E8:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
193EA:  MOVLW  63
193EC:  BTFSS  F9E.4
193EE:  BRA    193EC
193F0:  MOVWF  FAD
193F2:  MOVLW  3A
193F4:  BTFSS  F9E.4
193F6:  BRA    193F4
193F8:  MOVWF  FAD
193FA:  MOVLW  41
193FC:  MOVWF  FE9
193FE:  CLRF   1B
19400:  BTFSC  FF2.7
19402:  BSF    1B.7
19404:  BCF    FF2.7
19406:  MOVFF  7A5,A43
1940A:  MOVFF  7A4,A42
1940E:  MOVFF  7A3,A41
19412:  MOVFF  7A2,A40
19416:  CALL   110A
1941A:  BTFSC  1B.7
1941C:  BSF    FF2.7
1941E:  MOVLW  2F
19420:  BTFSS  F9E.4
19422:  BRA    19420
19424:  MOVWF  FAD
19426:  MOVLW  10
19428:  MOVWF  FE9
1942A:  CLRF   1B
1942C:  BTFSC  FF2.7
1942E:  BSF    1B.7
19430:  BCF    FF2.7
19432:  MOVFF  7BC,A41
19436:  MOVFF  7BB,A40
1943A:  CALL   11C6
1943E:  BTFSC  1B.7
19440:  BSF    FF2.7
19442:  MOVLW  2F
19444:  BTFSS  F9E.4
19446:  BRA    19444
19448:  MOVWF  FAD
1944A:  MOVLW  10
1944C:  MOVWF  FE9
1944E:  CLRF   1B
19450:  BTFSC  FF2.7
19452:  BSF    1B.7
19454:  BCF    FF2.7
19456:  MOVFF  7C0,A41
1945A:  MOVFF  7BF,A40
1945E:  CALL   11C6
19462:  BTFSC  1B.7
19464:  BSF    FF2.7
19466:  MOVLW  0D
19468:  BTFSS  F9E.4
1946A:  BRA    19468
1946C:  MOVWF  FAD
1946E:  MOVLW  0A
19470:  BTFSS  F9E.4
19472:  BRA    19470
19474:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
19476:  MOVLW  64
19478:  BTFSS  F9E.4
1947A:  BRA    19478
1947C:  MOVWF  FAD
1947E:  MOVLW  3A
19480:  BTFSS  F9E.4
19482:  BRA    19480
19484:  MOVWF  FAD
19486:  MOVLW  10
19488:  MOVWF  FE9
1948A:  CLRF   1B
1948C:  BTFSC  FF2.7
1948E:  BSF    1B.7
19490:  BCF    FF2.7
19492:  MOVFF  74F,A41
19496:  MOVFF  74E,A40
1949A:  CALL   11C6
1949E:  BTFSC  1B.7
194A0:  BSF    FF2.7
194A2:  MOVLW  0D
194A4:  BTFSS  F9E.4
194A6:  BRA    194A4
194A8:  MOVWF  FAD
194AA:  MOVLW  0A
194AC:  BTFSS  F9E.4
194AE:  BRA    194AC
194B0:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
194B2:  MOVLW  65
194B4:  BTFSS  F9E.4
194B6:  BRA    194B4
194B8:  MOVWF  FAD
194BA:  MOVLW  3A
194BC:  BTFSS  F9E.4
194BE:  BRA    194BC
194C0:  MOVWF  FAD
194C2:  MOVLW  10
194C4:  MOVWF  FE9
194C6:  CLRF   1B
194C8:  BTFSC  FF2.7
194CA:  BSF    1B.7
194CC:  BCF    FF2.7
194CE:  MOVFF  75F,A41
194D2:  MOVFF  75E,A40
194D6:  CALL   11C6
194DA:  BTFSC  1B.7
194DC:  BSF    FF2.7
194DE:  MOVLW  0D
194E0:  BTFSS  F9E.4
194E2:  BRA    194E0
194E4:  MOVWF  FAD
194E6:  MOVLW  0A
194E8:  BTFSS  F9E.4
194EA:  BRA    194E8
194EC:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
194EE:  MOVLW  66
194F0:  BTFSS  F9E.4
194F2:  BRA    194F0
194F4:  MOVWF  FAD
194F6:  MOVLW  3A
194F8:  BTFSS  F9E.4
194FA:  BRA    194F8
194FC:  MOVWF  FAD
194FE:  CLRF   1B
19500:  BTFSC  FF2.7
19502:  BSF    1B.7
19504:  BCF    FF2.7
19506:  MOVFF  741,A40
1950A:  MOVLW  1B
1950C:  MOVLB  A
1950E:  MOVWF  x41
19510:  MOVLB  0
19512:  CALL   0FC6
19516:  BTFSC  1B.7
19518:  BSF    FF2.7
1951A:  MOVLW  0D
1951C:  BTFSS  F9E.4
1951E:  BRA    1951C
19520:  MOVWF  FAD
19522:  MOVLW  0A
19524:  BTFSS  F9E.4
19526:  BRA    19524
19528:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
1952A:  MOVLW  67
1952C:  BTFSS  F9E.4
1952E:  BRA    1952C
19530:  MOVWF  FAD
19532:  MOVLW  3A
19534:  BTFSS  F9E.4
19536:  BRA    19534
19538:  MOVWF  FAD
1953A:  MOVLW  10
1953C:  MOVWF  FE9
1953E:  CLRF   1B
19540:  BTFSC  FF2.7
19542:  BSF    1B.7
19544:  BCF    FF2.7
19546:  MOVFF  75B,A41
1954A:  MOVFF  75A,A40
1954E:  CALL   11C6
19552:  BTFSC  1B.7
19554:  BSF    FF2.7
19556:  MOVLW  0D
19558:  BTFSS  F9E.4
1955A:  BRA    19558
1955C:  MOVWF  FAD
1955E:  MOVLW  0A
19560:  BTFSS  F9E.4
19562:  BRA    19560
19564:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19566:  MOVLW  68
19568:  BTFSS  F9E.4
1956A:  BRA    19568
1956C:  MOVWF  FAD
1956E:  MOVLW  3A
19570:  BTFSS  F9E.4
19572:  BRA    19570
19574:  MOVWF  FAD
19576:  MOVLW  10
19578:  MOVWF  FE9
1957A:  CLRF   1B
1957C:  BTFSC  FF2.7
1957E:  BSF    1B.7
19580:  BCF    FF2.7
19582:  MOVFF  886,A41
19586:  MOVFF  885,A40
1958A:  CALL   11C6
1958E:  BTFSC  1B.7
19590:  BSF    FF2.7
19592:  MOVLW  0D
19594:  BTFSS  F9E.4
19596:  BRA    19594
19598:  MOVWF  FAD
1959A:  MOVLW  0A
1959C:  BTFSS  F9E.4
1959E:  BRA    1959C
195A0:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
195A2:  MOVLW  69
195A4:  BTFSS  F9E.4
195A6:  BRA    195A4
195A8:  MOVWF  FAD
195AA:  MOVLW  3A
195AC:  BTFSS  F9E.4
195AE:  BRA    195AC
195B0:  MOVWF  FAD
195B2:  MOVLW  10
195B4:  MOVWF  FE9
195B6:  CLRF   1B
195B8:  BTFSC  FF2.7
195BA:  BSF    1B.7
195BC:  BCF    FF2.7
195BE:  MOVFF  88A,A41
195C2:  MOVFF  889,A40
195C6:  CALL   11C6
195CA:  BTFSC  1B.7
195CC:  BSF    FF2.7
195CE:  MOVLW  0D
195D0:  BTFSS  F9E.4
195D2:  BRA    195D0
195D4:  MOVWF  FAD
195D6:  MOVLW  0A
195D8:  BTFSS  F9E.4
195DA:  BRA    195D8
195DC:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
195DE:  MOVLW  6A
195E0:  BTFSS  F9E.4
195E2:  BRA    195E0
195E4:  MOVWF  FAD
195E6:  MOVLW  3A
195E8:  BTFSS  F9E.4
195EA:  BRA    195E8
195EC:  MOVWF  FAD
195EE:  MOVLW  10
195F0:  MOVWF  FE9
195F2:  CLRF   1B
195F4:  BTFSC  FF2.7
195F6:  BSF    1B.7
195F8:  BCF    FF2.7
195FA:  MOVFF  76F,A41
195FE:  MOVFF  76E,A40
19602:  CALL   11C6
19606:  BTFSC  1B.7
19608:  BSF    FF2.7
1960A:  MOVLW  0D
1960C:  BTFSS  F9E.4
1960E:  BRA    1960C
19610:  MOVWF  FAD
19612:  MOVLW  0A
19614:  BTFSS  F9E.4
19616:  BRA    19614
19618:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
1961A:  MOVLW  6B
1961C:  BTFSS  F9E.4
1961E:  BRA    1961C
19620:  MOVWF  FAD
19622:  MOVLW  3A
19624:  BTFSS  F9E.4
19626:  BRA    19624
19628:  MOVWF  FAD
1962A:  MOVLW  10
1962C:  MOVWF  FE9
1962E:  CLRF   1B
19630:  BTFSC  FF2.7
19632:  BSF    1B.7
19634:  BCF    FF2.7
19636:  MOVFF  767,A41
1963A:  MOVFF  766,A40
1963E:  CALL   11C6
19642:  BTFSC  1B.7
19644:  BSF    FF2.7
19646:  MOVLW  0D
19648:  BTFSS  F9E.4
1964A:  BRA    19648
1964C:  MOVWF  FAD
1964E:  MOVLW  0A
19650:  BTFSS  F9E.4
19652:  BRA    19650
19654:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
19656:  MOVLW  6D
19658:  BTFSS  F9E.4
1965A:  BRA    19658
1965C:  MOVWF  FAD
1965E:  MOVLW  3A
19660:  BTFSS  F9E.4
19662:  BRA    19660
19664:  MOVWF  FAD
19666:  MOVLW  10
19668:  MOVWF  FE9
1966A:  CLRF   1B
1966C:  BTFSC  FF2.7
1966E:  BSF    1B.7
19670:  BCF    FF2.7
19672:  MOVFF  747,A41
19676:  MOVFF  746,A40
1967A:  CALL   11C6
1967E:  BTFSC  1B.7
19680:  BSF    FF2.7
19682:  MOVLW  0D
19684:  BTFSS  F9E.4
19686:  BRA    19684
19688:  MOVWF  FAD
1968A:  MOVLW  0A
1968C:  BTFSS  F9E.4
1968E:  BRA    1968C
19690:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
19692:  MOVLW  6E
19694:  BTFSS  F9E.4
19696:  BRA    19694
19698:  MOVWF  FAD
1969A:  MOVLW  3A
1969C:  BTFSS  F9E.4
1969E:  BRA    1969C
196A0:  MOVWF  FAD
196A2:  MOVLW  10
196A4:  MOVWF  FE9
196A6:  CLRF   1B
196A8:  BTFSC  FF2.7
196AA:  BSF    1B.7
196AC:  BCF    FF2.7
196AE:  MOVFF  77B,A41
196B2:  MOVFF  77A,A40
196B6:  CALL   11C6
196BA:  BTFSC  1B.7
196BC:  BSF    FF2.7
196BE:  MOVLW  0D
196C0:  BTFSS  F9E.4
196C2:  BRA    196C0
196C4:  MOVWF  FAD
196C6:  MOVLW  0A
196C8:  BTFSS  F9E.4
196CA:  BRA    196C8
196CC:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
196CE:  MOVLW  6F
196D0:  BTFSS  F9E.4
196D2:  BRA    196D0
196D4:  MOVWF  FAD
196D6:  MOVLW  3A
196D8:  BTFSS  F9E.4
196DA:  BRA    196D8
196DC:  MOVWF  FAD
196DE:  MOVLW  10
196E0:  MOVWF  FE9
196E2:  CLRF   1B
196E4:  BTFSC  FF2.7
196E6:  BSF    1B.7
196E8:  BCF    FF2.7
196EA:  MOVFF  77F,A41
196EE:  MOVFF  77E,A40
196F2:  CALL   11C6
196F6:  BTFSC  1B.7
196F8:  BSF    FF2.7
196FA:  MOVLW  0D
196FC:  BTFSS  F9E.4
196FE:  BRA    196FC
19700:  MOVWF  FAD
19702:  MOVLW  0A
19704:  BTFSS  F9E.4
19706:  BRA    19704
19708:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
1970A:  MOVLW  70
1970C:  BTFSS  F9E.4
1970E:  BRA    1970C
19710:  MOVWF  FAD
19712:  MOVLW  3A
19714:  BTFSS  F9E.4
19716:  BRA    19714
19718:  MOVWF  FAD
1971A:  MOVLW  10
1971C:  MOVWF  FE9
1971E:  CLRF   1B
19720:  BTFSC  FF2.7
19722:  BSF    1B.7
19724:  BCF    FF2.7
19726:  MOVFF  7C4,A41
1972A:  MOVFF  7C3,A40
1972E:  CALL   11C6
19732:  BTFSC  1B.7
19734:  BSF    FF2.7
19736:  MOVLW  2F
19738:  BTFSS  F9E.4
1973A:  BRA    19738
1973C:  MOVWF  FAD
1973E:  MOVLW  10
19740:  MOVWF  FE9
19742:  CLRF   1B
19744:  BTFSC  FF2.7
19746:  BSF    1B.7
19748:  BCF    FF2.7
1974A:  MOVFF  763,A41
1974E:  MOVFF  762,A40
19752:  CALL   11C6
19756:  BTFSC  1B.7
19758:  BSF    FF2.7
1975A:  MOVLW  0D
1975C:  BTFSS  F9E.4
1975E:  BRA    1975C
19760:  MOVWF  FAD
19762:  MOVLW  0A
19764:  BTFSS  F9E.4
19766:  BRA    19764
19768:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
1976A:  MOVLW  71
1976C:  BTFSS  F9E.4
1976E:  BRA    1976C
19770:  MOVWF  FAD
19772:  MOVLW  3A
19774:  BTFSS  F9E.4
19776:  BRA    19774
19778:  MOVWF  FAD
1977A:  MOVLW  10
1977C:  MOVWF  FE9
1977E:  CLRF   1B
19780:  BTFSC  FF2.7
19782:  BSF    1B.7
19784:  BCF    FF2.7
19786:  MOVFF  797,A41
1978A:  MOVFF  796,A40
1978E:  CALL   11C6
19792:  BTFSC  1B.7
19794:  BSF    FF2.7
19796:  MOVLW  0D
19798:  BTFSS  F9E.4
1979A:  BRA    19798
1979C:  MOVWF  FAD
1979E:  MOVLW  0A
197A0:  BTFSS  F9E.4
197A2:  BRA    197A0
197A4:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
197A6:  MOVLW  73
197A8:  BTFSS  F9E.4
197AA:  BRA    197A8
197AC:  MOVWF  FAD
197AE:  MOVLW  3A
197B0:  BTFSS  F9E.4
197B2:  BRA    197B0
197B4:  MOVWF  FAD
197B6:  MOVLW  10
197B8:  MOVWF  FE9
197BA:  CLRF   1B
197BC:  BTFSC  FF2.7
197BE:  BSF    1B.7
197C0:  BCF    FF2.7
197C2:  MOVFF  777,A41
197C6:  MOVFF  776,A40
197CA:  CALL   11C6
197CE:  BTFSC  1B.7
197D0:  BSF    FF2.7
197D2:  MOVLW  0D
197D4:  BTFSS  F9E.4
197D6:  BRA    197D4
197D8:  MOVWF  FAD
197DA:  MOVLW  0A
197DC:  BTFSS  F9E.4
197DE:  BRA    197DC
197E0:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
197E2:  MOVLW  74
197E4:  BTFSS  F9E.4
197E6:  BRA    197E4
197E8:  MOVWF  FAD
197EA:  MOVLW  3A
197EC:  BTFSS  F9E.4
197EE:  BRA    197EC
197F0:  MOVWF  FAD
197F2:  MOVLW  10
197F4:  MOVWF  FE9
197F6:  CLRF   1B
197F8:  BTFSC  FF2.7
197FA:  BSF    1B.7
197FC:  BCF    FF2.7
197FE:  MOVFF  76B,A41
19802:  MOVFF  76A,A40
19806:  CALL   11C6
1980A:  BTFSC  1B.7
1980C:  BSF    FF2.7
1980E:  MOVLW  0D
19810:  BTFSS  F9E.4
19812:  BRA    19810
19814:  MOVWF  FAD
19816:  MOVLW  0A
19818:  BTFSS  F9E.4
1981A:  BRA    19818
1981C:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
1981E:  MOVLW  01
19820:  MOVLB  7
19822:  ADDWF  x40,W
19824:  MOVLB  8
19826:  MOVWF  x8B
19828:  MOVLW  75
1982A:  BTFSS  F9E.4
1982C:  BRA    1982A
1982E:  MOVWF  FAD
19830:  MOVLW  3A
19832:  BTFSS  F9E.4
19834:  BRA    19832
19836:  MOVWF  FAD
19838:  CLRF   1B
1983A:  BTFSC  FF2.7
1983C:  BSF    1B.7
1983E:  BCF    FF2.7
19840:  MOVFF  88B,A40
19844:  MOVLW  1B
19846:  MOVLB  A
19848:  MOVWF  x41
1984A:  MOVLB  0
1984C:  CALL   0FC6
19850:  BTFSC  1B.7
19852:  BSF    FF2.7
19854:  MOVLW  0D
19856:  BTFSS  F9E.4
19858:  BRA    19856
1985A:  MOVWF  FAD
1985C:  MOVLW  0A
1985E:  BTFSS  F9E.4
19860:  BRA    1985E
19862:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19864:  MOVLW  77
19866:  BTFSS  F9E.4
19868:  BRA    19866
1986A:  MOVWF  FAD
1986C:  MOVLW  3A
1986E:  BTFSS  F9E.4
19870:  BRA    1986E
19872:  MOVWF  FAD
19874:  MOVLW  10
19876:  MOVWF  FE9
19878:  CLRF   1B
1987A:  BTFSC  FF2.7
1987C:  BSF    1B.7
1987E:  BCF    FF2.7
19880:  MOVFF  888,A41
19884:  MOVFF  887,A40
19888:  CALL   11C6
1988C:  BTFSC  1B.7
1988E:  BSF    FF2.7
19890:  MOVLW  0D
19892:  BTFSS  F9E.4
19894:  BRA    19892
19896:  MOVWF  FAD
19898:  MOVLW  0A
1989A:  BTFSS  F9E.4
1989C:  BRA    1989A
1989E:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
198A0:  MOVLW  78
198A2:  BTFSS  F9E.4
198A4:  BRA    198A2
198A6:  MOVWF  FAD
198A8:  MOVLW  3A
198AA:  BTFSS  F9E.4
198AC:  BRA    198AA
198AE:  MOVWF  FAD
198B0:  MOVLW  10
198B2:  MOVWF  FE9
198B4:  CLRF   1B
198B6:  BTFSC  FF2.7
198B8:  BSF    1B.7
198BA:  BCF    FF2.7
198BC:  MOVFF  783,A41
198C0:  MOVFF  782,A40
198C4:  CALL   11C6
198C8:  BTFSC  1B.7
198CA:  BSF    FF2.7
198CC:  MOVLW  0D
198CE:  BTFSS  F9E.4
198D0:  BRA    198CE
198D2:  MOVWF  FAD
198D4:  MOVLW  0A
198D6:  BTFSS  F9E.4
198D8:  BRA    198D6
198DA:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
198DC:  MOVLW  79
198DE:  BTFSS  F9E.4
198E0:  BRA    198DE
198E2:  MOVWF  FAD
198E4:  MOVLW  3A
198E6:  BTFSS  F9E.4
198E8:  BRA    198E6
198EA:  MOVWF  FAD
198EC:  MOVLW  10
198EE:  MOVWF  FE9
198F0:  CLRF   1B
198F2:  BTFSC  FF2.7
198F4:  BSF    1B.7
198F6:  BCF    FF2.7
198F8:  MOVFF  743,A41
198FC:  MOVFF  742,A40
19900:  CALL   11C6
19904:  BTFSC  1B.7
19906:  BSF    FF2.7
19908:  MOVLW  0D
1990A:  BTFSS  F9E.4
1990C:  BRA    1990A
1990E:  MOVWF  FAD
19910:  MOVLW  0A
19912:  BTFSS  F9E.4
19914:  BRA    19912
19916:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19918:  MOVFF  755,A11
1991C:  MOVFF  754,A10
19920:  MOVLB  A
19922:  CLRF   x13
19924:  MOVLW  64
19926:  MOVWF  x12
19928:  MOVLB  0
1992A:  CALL   5CC0
1992E:  MOVFF  02,88C
19932:  MOVFF  01,88B
19936:  MOVFF  02,8DC
1993A:  MOVFF  01,8DB
1993E:  MOVLW  01
19940:  MOVLB  8
19942:  MOVWF  xDE
19944:  SETF   xDD
19946:  MOVLB  0
19948:  CALL   2CFC
1994C:  MOVFF  02,886
19950:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19954:  MOVFF  759,A11
19958:  MOVFF  758,A10
1995C:  MOVLB  A
1995E:  CLRF   x13
19960:  MOVLW  64
19962:  MOVWF  x12
19964:  MOVLB  0
19966:  CALL   5CC0
1996A:  MOVFF  02,88C
1996E:  MOVFF  01,88B
19972:  MOVFF  02,8DC
19976:  MOVFF  01,8DB
1997A:  MOVLW  01
1997C:  MOVLB  8
1997E:  MOVWF  xDE
19980:  SETF   xDD
19982:  MOVLB  0
19984:  CALL   2CFC
19988:  MOVFF  02,888
1998C:  MOVFF  01,887
....................       step_us  =   m_stp_int[1]*100; 
19990:  MOVFF  74D,A11
19994:  MOVFF  74C,A10
19998:  MOVLB  A
1999A:  CLRF   x13
1999C:  MOVLW  64
1999E:  MOVWF  x12
199A0:  MOVLB  0
199A2:  CALL   5CC0
199A6:  MOVFF  02,88A
199AA:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
199AE:  MOVLW  46
199B0:  MOVWF  FF6
199B2:  MOVLW  27
199B4:  MOVWF  FF7
199B6:  MOVLW  00
199B8:  MOVWF  FF8
199BA:  CLRF   1B
199BC:  BTFSC  FF2.7
199BE:  BSF    1B.7
199C0:  BCF    FF2.7
199C2:  CALL   0E6E
199C6:  BTFSC  1B.7
199C8:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
199CA:  MOVLW  62
199CC:  BTFSS  F9E.4
199CE:  BRA    199CC
199D0:  MOVWF  FAD
199D2:  MOVLW  3A
199D4:  BTFSS  F9E.4
199D6:  BRA    199D4
199D8:  MOVWF  FAD
199DA:  MOVLW  10
199DC:  MOVWF  FE9
199DE:  CLRF   1B
199E0:  BTFSC  FF2.7
199E2:  BSF    1B.7
199E4:  BCF    FF2.7
199E6:  MOVFF  775,A41
199EA:  MOVFF  774,A40
199EE:  CALL   11C6
199F2:  BTFSC  1B.7
199F4:  BSF    FF2.7
199F6:  MOVLW  0D
199F8:  BTFSS  F9E.4
199FA:  BRA    199F8
199FC:  MOVWF  FAD
199FE:  MOVLW  0A
19A00:  BTFSS  F9E.4
19A02:  BRA    19A00
19A04:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
19A06:  MOVLW  63
19A08:  BTFSS  F9E.4
19A0A:  BRA    19A08
19A0C:  MOVWF  FAD
19A0E:  MOVLW  3A
19A10:  BTFSS  F9E.4
19A12:  BRA    19A10
19A14:  MOVWF  FAD
19A16:  MOVLW  41
19A18:  MOVWF  FE9
19A1A:  CLRF   1B
19A1C:  BTFSC  FF2.7
19A1E:  BSF    1B.7
19A20:  BCF    FF2.7
19A22:  MOVFF  7A9,A43
19A26:  MOVFF  7A8,A42
19A2A:  MOVFF  7A7,A41
19A2E:  MOVFF  7A6,A40
19A32:  CALL   110A
19A36:  BTFSC  1B.7
19A38:  BSF    FF2.7
19A3A:  MOVLW  2F
19A3C:  BTFSS  F9E.4
19A3E:  BRA    19A3C
19A40:  MOVWF  FAD
19A42:  MOVLW  10
19A44:  MOVWF  FE9
19A46:  CLRF   1B
19A48:  BTFSC  FF2.7
19A4A:  BSF    1B.7
19A4C:  BCF    FF2.7
19A4E:  MOVFF  7BE,A41
19A52:  MOVFF  7BD,A40
19A56:  CALL   11C6
19A5A:  BTFSC  1B.7
19A5C:  BSF    FF2.7
19A5E:  MOVLW  2F
19A60:  BTFSS  F9E.4
19A62:  BRA    19A60
19A64:  MOVWF  FAD
19A66:  MOVLW  10
19A68:  MOVWF  FE9
19A6A:  CLRF   1B
19A6C:  BTFSC  FF2.7
19A6E:  BSF    1B.7
19A70:  BCF    FF2.7
19A72:  MOVFF  7C2,A41
19A76:  MOVFF  7C1,A40
19A7A:  CALL   11C6
19A7E:  BTFSC  1B.7
19A80:  BSF    FF2.7
19A82:  MOVLW  0D
19A84:  BTFSS  F9E.4
19A86:  BRA    19A84
19A88:  MOVWF  FAD
19A8A:  MOVLW  0A
19A8C:  BTFSS  F9E.4
19A8E:  BRA    19A8C
19A90:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
19A92:  MOVLW  64
19A94:  BTFSS  F9E.4
19A96:  BRA    19A94
19A98:  MOVWF  FAD
19A9A:  MOVLW  3A
19A9C:  BTFSS  F9E.4
19A9E:  BRA    19A9C
19AA0:  MOVWF  FAD
19AA2:  MOVLW  10
19AA4:  MOVWF  FE9
19AA6:  CLRF   1B
19AA8:  BTFSC  FF2.7
19AAA:  BSF    1B.7
19AAC:  BCF    FF2.7
19AAE:  MOVFF  751,A41
19AB2:  MOVFF  750,A40
19AB6:  CALL   11C6
19ABA:  BTFSC  1B.7
19ABC:  BSF    FF2.7
19ABE:  MOVLW  0D
19AC0:  BTFSS  F9E.4
19AC2:  BRA    19AC0
19AC4:  MOVWF  FAD
19AC6:  MOVLW  0A
19AC8:  BTFSS  F9E.4
19ACA:  BRA    19AC8
19ACC:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
19ACE:  MOVLW  65
19AD0:  BTFSS  F9E.4
19AD2:  BRA    19AD0
19AD4:  MOVWF  FAD
19AD6:  MOVLW  3A
19AD8:  BTFSS  F9E.4
19ADA:  BRA    19AD8
19ADC:  MOVWF  FAD
19ADE:  MOVLW  10
19AE0:  MOVWF  FE9
19AE2:  CLRF   1B
19AE4:  BTFSC  FF2.7
19AE6:  BSF    1B.7
19AE8:  BCF    FF2.7
19AEA:  MOVFF  761,A41
19AEE:  MOVFF  760,A40
19AF2:  CALL   11C6
19AF6:  BTFSC  1B.7
19AF8:  BSF    FF2.7
19AFA:  MOVLW  0D
19AFC:  BTFSS  F9E.4
19AFE:  BRA    19AFC
19B00:  MOVWF  FAD
19B02:  MOVLW  0A
19B04:  BTFSS  F9E.4
19B06:  BRA    19B04
19B08:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19B0A:  MOVLW  66
19B0C:  BTFSS  F9E.4
19B0E:  BRA    19B0C
19B10:  MOVWF  FAD
19B12:  MOVLW  3A
19B14:  BTFSS  F9E.4
19B16:  BRA    19B14
19B18:  MOVWF  FAD
19B1A:  CLRF   1B
19B1C:  BTFSC  FF2.7
19B1E:  BSF    1B.7
19B20:  BCF    FF2.7
19B22:  MOVFF  741,A40
19B26:  MOVLW  1B
19B28:  MOVLB  A
19B2A:  MOVWF  x41
19B2C:  MOVLB  0
19B2E:  CALL   0FC6
19B32:  BTFSC  1B.7
19B34:  BSF    FF2.7
19B36:  MOVLW  0D
19B38:  BTFSS  F9E.4
19B3A:  BRA    19B38
19B3C:  MOVWF  FAD
19B3E:  MOVLW  0A
19B40:  BTFSS  F9E.4
19B42:  BRA    19B40
19B44:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
19B46:  MOVLW  67
19B48:  BTFSS  F9E.4
19B4A:  BRA    19B48
19B4C:  MOVWF  FAD
19B4E:  MOVLW  3A
19B50:  BTFSS  F9E.4
19B52:  BRA    19B50
19B54:  MOVWF  FAD
19B56:  MOVLW  10
19B58:  MOVWF  FE9
19B5A:  CLRF   1B
19B5C:  BTFSC  FF2.7
19B5E:  BSF    1B.7
19B60:  BCF    FF2.7
19B62:  MOVFF  75D,A41
19B66:  MOVFF  75C,A40
19B6A:  CALL   11C6
19B6E:  BTFSC  1B.7
19B70:  BSF    FF2.7
19B72:  MOVLW  0D
19B74:  BTFSS  F9E.4
19B76:  BRA    19B74
19B78:  MOVWF  FAD
19B7A:  MOVLW  0A
19B7C:  BTFSS  F9E.4
19B7E:  BRA    19B7C
19B80:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19B82:  MOVLW  68
19B84:  BTFSS  F9E.4
19B86:  BRA    19B84
19B88:  MOVWF  FAD
19B8A:  MOVLW  3A
19B8C:  BTFSS  F9E.4
19B8E:  BRA    19B8C
19B90:  MOVWF  FAD
19B92:  MOVLW  10
19B94:  MOVWF  FE9
19B96:  CLRF   1B
19B98:  BTFSC  FF2.7
19B9A:  BSF    1B.7
19B9C:  BCF    FF2.7
19B9E:  MOVFF  886,A41
19BA2:  MOVFF  885,A40
19BA6:  CALL   11C6
19BAA:  BTFSC  1B.7
19BAC:  BSF    FF2.7
19BAE:  MOVLW  0D
19BB0:  BTFSS  F9E.4
19BB2:  BRA    19BB0
19BB4:  MOVWF  FAD
19BB6:  MOVLW  0A
19BB8:  BTFSS  F9E.4
19BBA:  BRA    19BB8
19BBC:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
19BBE:  MOVLW  69
19BC0:  BTFSS  F9E.4
19BC2:  BRA    19BC0
19BC4:  MOVWF  FAD
19BC6:  MOVLW  3A
19BC8:  BTFSS  F9E.4
19BCA:  BRA    19BC8
19BCC:  MOVWF  FAD
19BCE:  MOVLW  10
19BD0:  MOVWF  FE9
19BD2:  CLRF   1B
19BD4:  BTFSC  FF2.7
19BD6:  BSF    1B.7
19BD8:  BCF    FF2.7
19BDA:  MOVFF  88A,A41
19BDE:  MOVFF  889,A40
19BE2:  CALL   11C6
19BE6:  BTFSC  1B.7
19BE8:  BSF    FF2.7
19BEA:  MOVLW  0D
19BEC:  BTFSS  F9E.4
19BEE:  BRA    19BEC
19BF0:  MOVWF  FAD
19BF2:  MOVLW  0A
19BF4:  BTFSS  F9E.4
19BF6:  BRA    19BF4
19BF8:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
19BFA:  MOVLW  6A
19BFC:  BTFSS  F9E.4
19BFE:  BRA    19BFC
19C00:  MOVWF  FAD
19C02:  MOVLW  3A
19C04:  BTFSS  F9E.4
19C06:  BRA    19C04
19C08:  MOVWF  FAD
19C0A:  MOVLW  10
19C0C:  MOVWF  FE9
19C0E:  CLRF   1B
19C10:  BTFSC  FF2.7
19C12:  BSF    1B.7
19C14:  BCF    FF2.7
19C16:  MOVFF  771,A41
19C1A:  MOVFF  770,A40
19C1E:  CALL   11C6
19C22:  BTFSC  1B.7
19C24:  BSF    FF2.7
19C26:  MOVLW  0D
19C28:  BTFSS  F9E.4
19C2A:  BRA    19C28
19C2C:  MOVWF  FAD
19C2E:  MOVLW  0A
19C30:  BTFSS  F9E.4
19C32:  BRA    19C30
19C34:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
19C36:  MOVLW  6B
19C38:  BTFSS  F9E.4
19C3A:  BRA    19C38
19C3C:  MOVWF  FAD
19C3E:  MOVLW  3A
19C40:  BTFSS  F9E.4
19C42:  BRA    19C40
19C44:  MOVWF  FAD
19C46:  MOVLW  10
19C48:  MOVWF  FE9
19C4A:  CLRF   1B
19C4C:  BTFSC  FF2.7
19C4E:  BSF    1B.7
19C50:  BCF    FF2.7
19C52:  MOVFF  769,A41
19C56:  MOVFF  768,A40
19C5A:  CALL   11C6
19C5E:  BTFSC  1B.7
19C60:  BSF    FF2.7
19C62:  MOVLW  0D
19C64:  BTFSS  F9E.4
19C66:  BRA    19C64
19C68:  MOVWF  FAD
19C6A:  MOVLW  0A
19C6C:  BTFSS  F9E.4
19C6E:  BRA    19C6C
19C70:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
19C72:  MOVLW  6D
19C74:  BTFSS  F9E.4
19C76:  BRA    19C74
19C78:  MOVWF  FAD
19C7A:  MOVLW  3A
19C7C:  BTFSS  F9E.4
19C7E:  BRA    19C7C
19C80:  MOVWF  FAD
19C82:  MOVLW  10
19C84:  MOVWF  FE9
19C86:  CLRF   1B
19C88:  BTFSC  FF2.7
19C8A:  BSF    1B.7
19C8C:  BCF    FF2.7
19C8E:  MOVFF  749,A41
19C92:  MOVFF  748,A40
19C96:  CALL   11C6
19C9A:  BTFSC  1B.7
19C9C:  BSF    FF2.7
19C9E:  MOVLW  0D
19CA0:  BTFSS  F9E.4
19CA2:  BRA    19CA0
19CA4:  MOVWF  FAD
19CA6:  MOVLW  0A
19CA8:  BTFSS  F9E.4
19CAA:  BRA    19CA8
19CAC:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
19CAE:  MOVLW  6E
19CB0:  BTFSS  F9E.4
19CB2:  BRA    19CB0
19CB4:  MOVWF  FAD
19CB6:  MOVLW  3A
19CB8:  BTFSS  F9E.4
19CBA:  BRA    19CB8
19CBC:  MOVWF  FAD
19CBE:  MOVLW  10
19CC0:  MOVWF  FE9
19CC2:  CLRF   1B
19CC4:  BTFSC  FF2.7
19CC6:  BSF    1B.7
19CC8:  BCF    FF2.7
19CCA:  MOVFF  77D,A41
19CCE:  MOVFF  77C,A40
19CD2:  CALL   11C6
19CD6:  BTFSC  1B.7
19CD8:  BSF    FF2.7
19CDA:  MOVLW  0D
19CDC:  BTFSS  F9E.4
19CDE:  BRA    19CDC
19CE0:  MOVWF  FAD
19CE2:  MOVLW  0A
19CE4:  BTFSS  F9E.4
19CE6:  BRA    19CE4
19CE8:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
19CEA:  MOVLW  6F
19CEC:  BTFSS  F9E.4
19CEE:  BRA    19CEC
19CF0:  MOVWF  FAD
19CF2:  MOVLW  3A
19CF4:  BTFSS  F9E.4
19CF6:  BRA    19CF4
19CF8:  MOVWF  FAD
19CFA:  MOVLW  10
19CFC:  MOVWF  FE9
19CFE:  CLRF   1B
19D00:  BTFSC  FF2.7
19D02:  BSF    1B.7
19D04:  BCF    FF2.7
19D06:  MOVFF  781,A41
19D0A:  MOVFF  780,A40
19D0E:  CALL   11C6
19D12:  BTFSC  1B.7
19D14:  BSF    FF2.7
19D16:  MOVLW  0D
19D18:  BTFSS  F9E.4
19D1A:  BRA    19D18
19D1C:  MOVWF  FAD
19D1E:  MOVLW  0A
19D20:  BTFSS  F9E.4
19D22:  BRA    19D20
19D24:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
19D26:  MOVLW  70
19D28:  BTFSS  F9E.4
19D2A:  BRA    19D28
19D2C:  MOVWF  FAD
19D2E:  MOVLW  3A
19D30:  BTFSS  F9E.4
19D32:  BRA    19D30
19D34:  MOVWF  FAD
19D36:  MOVLW  10
19D38:  MOVWF  FE9
19D3A:  CLRF   1B
19D3C:  BTFSC  FF2.7
19D3E:  BSF    1B.7
19D40:  BCF    FF2.7
19D42:  MOVFF  7C6,A41
19D46:  MOVFF  7C5,A40
19D4A:  CALL   11C6
19D4E:  BTFSC  1B.7
19D50:  BSF    FF2.7
19D52:  MOVLW  2F
19D54:  BTFSS  F9E.4
19D56:  BRA    19D54
19D58:  MOVWF  FAD
19D5A:  MOVLW  10
19D5C:  MOVWF  FE9
19D5E:  CLRF   1B
19D60:  BTFSC  FF2.7
19D62:  BSF    1B.7
19D64:  BCF    FF2.7
19D66:  MOVFF  765,A41
19D6A:  MOVFF  764,A40
19D6E:  CALL   11C6
19D72:  BTFSC  1B.7
19D74:  BSF    FF2.7
19D76:  MOVLW  0D
19D78:  BTFSS  F9E.4
19D7A:  BRA    19D78
19D7C:  MOVWF  FAD
19D7E:  MOVLW  0A
19D80:  BTFSS  F9E.4
19D82:  BRA    19D80
19D84:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
19D86:  MOVLW  71
19D88:  BTFSS  F9E.4
19D8A:  BRA    19D88
19D8C:  MOVWF  FAD
19D8E:  MOVLW  3A
19D90:  BTFSS  F9E.4
19D92:  BRA    19D90
19D94:  MOVWF  FAD
19D96:  MOVLW  10
19D98:  MOVWF  FE9
19D9A:  CLRF   1B
19D9C:  BTFSC  FF2.7
19D9E:  BSF    1B.7
19DA0:  BCF    FF2.7
19DA2:  MOVFF  799,A41
19DA6:  MOVFF  798,A40
19DAA:  CALL   11C6
19DAE:  BTFSC  1B.7
19DB0:  BSF    FF2.7
19DB2:  MOVLW  0D
19DB4:  BTFSS  F9E.4
19DB6:  BRA    19DB4
19DB8:  MOVWF  FAD
19DBA:  MOVLW  0A
19DBC:  BTFSS  F9E.4
19DBE:  BRA    19DBC
19DC0:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
19DC2:  MOVLW  73
19DC4:  BTFSS  F9E.4
19DC6:  BRA    19DC4
19DC8:  MOVWF  FAD
19DCA:  MOVLW  3A
19DCC:  BTFSS  F9E.4
19DCE:  BRA    19DCC
19DD0:  MOVWF  FAD
19DD2:  MOVLW  10
19DD4:  MOVWF  FE9
19DD6:  CLRF   1B
19DD8:  BTFSC  FF2.7
19DDA:  BSF    1B.7
19DDC:  BCF    FF2.7
19DDE:  MOVFF  779,A41
19DE2:  MOVFF  778,A40
19DE6:  CALL   11C6
19DEA:  BTFSC  1B.7
19DEC:  BSF    FF2.7
19DEE:  MOVLW  0D
19DF0:  BTFSS  F9E.4
19DF2:  BRA    19DF0
19DF4:  MOVWF  FAD
19DF6:  MOVLW  0A
19DF8:  BTFSS  F9E.4
19DFA:  BRA    19DF8
19DFC:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
19DFE:  MOVLW  74
19E00:  BTFSS  F9E.4
19E02:  BRA    19E00
19E04:  MOVWF  FAD
19E06:  MOVLW  3A
19E08:  BTFSS  F9E.4
19E0A:  BRA    19E08
19E0C:  MOVWF  FAD
19E0E:  MOVLW  10
19E10:  MOVWF  FE9
19E12:  CLRF   1B
19E14:  BTFSC  FF2.7
19E16:  BSF    1B.7
19E18:  BCF    FF2.7
19E1A:  MOVFF  76D,A41
19E1E:  MOVFF  76C,A40
19E22:  CALL   11C6
19E26:  BTFSC  1B.7
19E28:  BSF    FF2.7
19E2A:  MOVLW  0D
19E2C:  BTFSS  F9E.4
19E2E:  BRA    19E2C
19E30:  MOVWF  FAD
19E32:  MOVLW  0A
19E34:  BTFSS  F9E.4
19E36:  BRA    19E34
19E38:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19E3A:  MOVLW  01
19E3C:  MOVLB  7
19E3E:  ADDWF  x40,W
19E40:  MOVLB  8
19E42:  MOVWF  x8B
19E44:  MOVLW  75
19E46:  BTFSS  F9E.4
19E48:  BRA    19E46
19E4A:  MOVWF  FAD
19E4C:  MOVLW  3A
19E4E:  BTFSS  F9E.4
19E50:  BRA    19E4E
19E52:  MOVWF  FAD
19E54:  CLRF   1B
19E56:  BTFSC  FF2.7
19E58:  BSF    1B.7
19E5A:  BCF    FF2.7
19E5C:  MOVFF  88B,A40
19E60:  MOVLW  1B
19E62:  MOVLB  A
19E64:  MOVWF  x41
19E66:  MOVLB  0
19E68:  CALL   0FC6
19E6C:  BTFSC  1B.7
19E6E:  BSF    FF2.7
19E70:  MOVLW  0D
19E72:  BTFSS  F9E.4
19E74:  BRA    19E72
19E76:  MOVWF  FAD
19E78:  MOVLW  0A
19E7A:  BTFSS  F9E.4
19E7C:  BRA    19E7A
19E7E:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19E80:  MOVLW  77
19E82:  BTFSS  F9E.4
19E84:  BRA    19E82
19E86:  MOVWF  FAD
19E88:  MOVLW  3A
19E8A:  BTFSS  F9E.4
19E8C:  BRA    19E8A
19E8E:  MOVWF  FAD
19E90:  MOVLW  10
19E92:  MOVWF  FE9
19E94:  CLRF   1B
19E96:  BTFSC  FF2.7
19E98:  BSF    1B.7
19E9A:  BCF    FF2.7
19E9C:  MOVFF  888,A41
19EA0:  MOVFF  887,A40
19EA4:  CALL   11C6
19EA8:  BTFSC  1B.7
19EAA:  BSF    FF2.7
19EAC:  MOVLW  0D
19EAE:  BTFSS  F9E.4
19EB0:  BRA    19EAE
19EB2:  MOVWF  FAD
19EB4:  MOVLW  0A
19EB6:  BTFSS  F9E.4
19EB8:  BRA    19EB6
19EBA:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
19EBC:  MOVLW  78
19EBE:  BTFSS  F9E.4
19EC0:  BRA    19EBE
19EC2:  MOVWF  FAD
19EC4:  MOVLW  3A
19EC6:  BTFSS  F9E.4
19EC8:  BRA    19EC6
19ECA:  MOVWF  FAD
19ECC:  MOVLW  10
19ECE:  MOVWF  FE9
19ED0:  CLRF   1B
19ED2:  BTFSC  FF2.7
19ED4:  BSF    1B.7
19ED6:  BCF    FF2.7
19ED8:  MOVFF  785,A41
19EDC:  MOVFF  784,A40
19EE0:  CALL   11C6
19EE4:  BTFSC  1B.7
19EE6:  BSF    FF2.7
19EE8:  MOVLW  0D
19EEA:  BTFSS  F9E.4
19EEC:  BRA    19EEA
19EEE:  MOVWF  FAD
19EF0:  MOVLW  0A
19EF2:  BTFSS  F9E.4
19EF4:  BRA    19EF2
19EF6:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
19EF8:  MOVLW  79
19EFA:  BTFSS  F9E.4
19EFC:  BRA    19EFA
19EFE:  MOVWF  FAD
19F00:  MOVLW  3A
19F02:  BTFSS  F9E.4
19F04:  BRA    19F02
19F06:  MOVWF  FAD
19F08:  MOVLW  10
19F0A:  MOVWF  FE9
19F0C:  CLRF   1B
19F0E:  BTFSC  FF2.7
19F10:  BSF    1B.7
19F12:  BCF    FF2.7
19F14:  MOVFF  745,A41
19F18:  MOVFF  744,A40
19F1C:  CALL   11C6
19F20:  BTFSC  1B.7
19F22:  BSF    FF2.7
19F24:  MOVLW  0D
19F26:  BTFSS  F9E.4
19F28:  BRA    19F26
19F2A:  MOVWF  FAD
19F2C:  MOVLW  0A
19F2E:  BTFSS  F9E.4
19F30:  BRA    19F2E
19F32:  MOVWF  FAD
....................    } 
19F34:  BRA    19F3A
....................    else cmd_arg(); 
19F36:  CALL   B326
19F3A:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BF6E:  MOVF   48,W
0BF70:  SUBLW  0D
0BF72:  BNZ   BF92
0BF74:  MOVF   49,W
0BF76:  SUBLW  07
0BF78:  BNZ   BF92
0BF7A:  MOVF   4A,F
0BF7C:  BNZ   BF92
0BF7E:  MOVF   4B,F
0BF80:  BNZ   BF92
0BF82:  MOVLW  03
0BF84:  MOVLB  8
0BF86:  MOVWF  x8A
0BF88:  MOVLW  15
0BF8A:  MOVWF  x89
0BF8C:  MOVLB  0
0BF8E:  RCALL  BB4C
0BF90:  BRA    BFB4
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BF92:  MOVF   48,W
0BF94:  SUBLW  98
0BF96:  BNZ   BFB4
0BF98:  MOVF   49,W
0BF9A:  SUBLW  07
0BF9C:  BNZ   BFB4
0BF9E:  MOVF   4A,F
0BFA0:  BNZ   BFB4
0BFA2:  MOVF   4B,F
0BFA4:  BNZ   BFB4
0BFA6:  MOVLW  03
0BFA8:  MOVLB  8
0BFAA:  MOVWF  x8A
0BFAC:  MOVLW  15
0BFAE:  MOVWF  x89
0BFB0:  MOVLB  0
0BFB2:  RCALL  BCC6
0BFB4:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0B380:  MOVF   48,W
0B382:  MOVWF  00
0B384:  MOVFF  49,03
0B388:  MOVLW  15
0B38A:  SUBWF  49,W
0B38C:  BNZ   B394
0B38E:  MOVLW  95
0B390:  SUBWF  00,W
0B392:  BZ    B3BA
0B394:  MOVLW  15
0B396:  SUBWF  03,W
0B398:  BNZ   B3A0
0B39A:  MOVLW  96
0B39C:  SUBWF  00,W
0B39E:  BZ    B3EC
0B3A0:  MOVLW  15
0B3A2:  SUBWF  03,W
0B3A4:  BNZ   B3AC
0B3A6:  MOVLW  97
0B3A8:  SUBWF  00,W
0B3AA:  BZ    B422
0B3AC:  MOVLW  15
0B3AE:  SUBWF  03,W
0B3B0:  BNZ   B3B8
0B3B2:  MOVLW  98
0B3B4:  SUBWF  00,W
0B3B6:  BZ    B458
0B3B8:  BRA    B48C
....................       case 5525 : nv_product = ECO; 
0B3BA:  CLRF   30
0B3BC:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B3BE:  MOVLW  1E
0B3C0:  MOVLB  8
0B3C2:  MOVWF  xEE
0B3C4:  CLRF   xF0
0B3C6:  CLRF   xEF
0B3C8:  MOVLB  0
0B3CA:  CALL   4FFC
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B3CE:  MOVLW  01
0B3D0:  MOVWF  1E
0B3D2:  MOVLW  A7
0B3D4:  MOVWF  1D
0B3D6:  MOVLW  52
0B3D8:  MOVWF  FF6
0B3DA:  MOVLW  27
0B3DC:  MOVWF  FF7
0B3DE:  MOVLW  00
0B3E0:  MOVWF  FF8
0B3E2:  CALL   50E6
....................                   record_event(); 
0B3E6:  CALL   8502
....................          break; 
0B3EA:  BRA    B48C
....................       case 5526 : nv_product = WMS4; 
0B3EC:  CLRF   30
0B3EE:  MOVLW  01
0B3F0:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B3F2:  MOVLW  1E
0B3F4:  MOVLB  8
0B3F6:  MOVWF  xEE
0B3F8:  CLRF   xF0
0B3FA:  MOVLW  01
0B3FC:  MOVWF  xEF
0B3FE:  MOVLB  0
0B400:  CALL   4FFC
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B404:  MOVLW  01
0B406:  MOVWF  1E
0B408:  MOVLW  A7
0B40A:  MOVWF  1D
0B40C:  MOVLW  62
0B40E:  MOVWF  FF6
0B410:  MOVLW  27
0B412:  MOVWF  FF7
0B414:  MOVLW  00
0B416:  MOVWF  FF8
0B418:  CALL   50E6
....................                   record_event();                   
0B41C:  CALL   8502
....................          break;    
0B420:  BRA    B48C
....................       case 5527 : nv_product = AWS; 
0B422:  CLRF   30
0B424:  MOVLW  02
0B426:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B428:  MOVLW  1E
0B42A:  MOVLB  8
0B42C:  MOVWF  xEE
0B42E:  CLRF   xF0
0B430:  MOVLW  02
0B432:  MOVWF  xEF
0B434:  MOVLB  0
0B436:  CALL   4FFC
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B43A:  MOVLW  01
0B43C:  MOVWF  1E
0B43E:  MOVLW  A7
0B440:  MOVWF  1D
0B442:  MOVLW  78
0B444:  MOVWF  FF6
0B446:  MOVLW  27
0B448:  MOVWF  FF7
0B44A:  MOVLW  00
0B44C:  MOVWF  FF8
0B44E:  CALL   50E6
....................                   record_event();                   
0B452:  CALL   8502
....................          break;   
0B456:  BRA    B48C
....................       case 5528 : nv_product = WMS2; 
0B458:  CLRF   30
0B45A:  MOVLW  03
0B45C:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B45E:  MOVLW  1E
0B460:  MOVLB  8
0B462:  MOVWF  xEE
0B464:  CLRF   xF0
0B466:  MOVLW  03
0B468:  MOVWF  xEF
0B46A:  MOVLB  0
0B46C:  CALL   4FFC
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B470:  MOVLW  01
0B472:  MOVWF  1E
0B474:  MOVLW  A7
0B476:  MOVWF  1D
0B478:  MOVLW  88
0B47A:  MOVWF  FF6
0B47C:  MOVLW  27
0B47E:  MOVWF  FF7
0B480:  MOVLW  00
0B482:  MOVWF  FF8
0B484:  CALL   50E6
....................                   record_event();                   
0B488:  CALL   8502
....................          break;            
....................    } 
0B48C:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0B344:  MOVF   48,W
0B346:  MOVWF  00
0B348:  MOVF   49,W
0B34A:  MOVWF  03
0B34C:  BNZ   B352
0B34E:  MOVF   00,F
0B350:  BZ    B368
0B352:  MOVF   03,W
0B354:  BNZ   B35C
0B356:  MOVLW  01
0B358:  SUBWF  00,W
0B35A:  BZ    B36E
0B35C:  MOVF   03,W
0B35E:  BNZ   B366
0B360:  MOVLW  02
0B362:  SUBWF  00,W
0B364:  BZ    B374
0B366:  BRA    B37A
....................       case 0 : kill_wd(); 
0B368:  CALL   311E
....................          break; 
0B36C:  BRA    B37C
....................       case 1 : start_heartbeat(); 
0B36E:  CALL   2928
....................          break; 
0B372:  BRA    B37C
....................       case 2 : suspend_heartbeat(); 
0B374:  CALL   557C
....................          break; 
0B378:  BRA    B37C
....................       default : cmd_arg(); 
0B37A:  RCALL  B326
....................          break; 
....................    } 
0B37C:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0B284:  MOVF   48,W
0B286:  MOVWF  00
0B288:  MOVF   49,W
0B28A:  MOVWF  03
0B28C:  BNZ   B292
0B28E:  MOVF   00,F
0B290:  BZ    B2A0
0B292:  MOVLW  15
0B294:  SUBWF  03,W
0B296:  BNZ   B29E
0B298:  MOVLW  95
0B29A:  SUBWF  00,W
0B29C:  BZ    B2FE
0B29E:  BRA    B322
....................       case 0:     signon(); 
0B2A0:  CALL   3170
....................                   fprintf(COM_A, __DATE__); 
0B2A4:  MOVLW  9E
0B2A6:  MOVWF  FF6
0B2A8:  MOVLW  27
0B2AA:  MOVWF  FF7
0B2AC:  MOVLW  00
0B2AE:  MOVWF  FF8
0B2B0:  CLRF   1B
0B2B2:  BTFSC  FF2.7
0B2B4:  BSF    1B.7
0B2B6:  BCF    FF2.7
0B2B8:  CALL   0E6E
0B2BC:  BTFSC  1B.7
0B2BE:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B2C0:  MOVLW  0D
0B2C2:  BTFSS  F9E.4
0B2C4:  BRA    B2C2
0B2C6:  MOVWF  FAD
0B2C8:  MOVLW  0A
0B2CA:  BTFSS  F9E.4
0B2CC:  BRA    B2CA
0B2CE:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0B2D0:  MOVLW  A8
0B2D2:  MOVWF  FF6
0B2D4:  MOVLW  27
0B2D6:  MOVWF  FF7
0B2D8:  MOVLW  00
0B2DA:  MOVWF  FF8
0B2DC:  CLRF   1B
0B2DE:  BTFSC  FF2.7
0B2E0:  BSF    1B.7
0B2E2:  BCF    FF2.7
0B2E4:  CALL   0E6E
0B2E8:  BTFSC  1B.7
0B2EA:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B2EC:  MOVLW  0D
0B2EE:  BTFSS  F9E.4
0B2F0:  BRA    B2EE
0B2F2:  MOVWF  FAD
0B2F4:  MOVLW  0A
0B2F6:  BTFSS  F9E.4
0B2F8:  BRA    B2F6
0B2FA:  MOVWF  FAD
....................          break; 
0B2FC:  BRA    B322
....................       case 5525 : kill_wd(); 
0B2FE:  CALL   311E
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0B302:  MOVLW  B2
0B304:  MOVWF  FF6
0B306:  MOVLW  27
0B308:  MOVWF  FF7
0B30A:  MOVLW  00
0B30C:  MOVWF  FF8
0B30E:  CLRF   1B
0B310:  BTFSC  FF2.7
0B312:  BSF    1B.7
0B314:  BCF    FF2.7
0B316:  CALL   0E6E
0B31A:  BTFSC  1B.7
0B31C:  BSF    FF2.7
....................                   load_program(); 
0B31E:  CALL   1F800
....................          break; 
....................    } 
0B322:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
18BE2:  MOVF   48,W
18BE4:  MOVWF  00
18BE6:  MOVF   49,W
18BE8:  MOVWF  03
18BEA:  BNZ   18BF0
18BEC:  MOVF   00,F
18BEE:  BZ    18BFC
18BF0:  MOVF   03,W
18BF2:  BNZ   18BFA
18BF4:  MOVLW  01
18BF6:  SUBWF  00,W
18BF8:  BZ    18C00
18BFA:  BRA    18C04
....................       case 0 : cmd_set=0;  // user 
18BFC:  CLRF   51
....................          break; 
18BFE:  BRA    18C04
....................       case 1 : cmd_set=1;  // full 
18C00:  MOVLW  01
18C02:  MOVWF  51
....................          break; 
....................    } 
18C04:  GOTO   1B2E6 (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1B14A:  CALL   AED8
....................     
....................    switch (cmd) 
1B14E:  MOVLW  23
1B150:  SUBWF  47,W
1B152:  ADDLW  A8
1B154:  BTFSC  FD8.0
1B156:  BRA    1B2E6
1B158:  ADDLW  58
1B15A:  GOTO   1B2EA
....................    { 
....................       case '&': commandFW(); 
1B15E:  GOTO   B284
....................          break; 
1B162:  BRA    1B2E6
....................       case '#': command_hash(); 
1B164:  GOTO   B344
....................          break;          
1B168:  BRA    1B2E6
....................       case '%': command_prod(); 
1B16A:  GOTO   B380
....................          break; 
1B16E:  BRA    1B2E6
....................       case '*': command_star(); 
1B170:  GOTO   BF6E
....................          break;       
1B174:  BRA    1B2E6
....................       // standard commands 
....................       case '/': command_addr(); 
1B176:  GOTO   BFB8
....................          break; 
1B17A:  BRA    1B2E6
....................       case 'A': commandA(); 
1B17C:  GOTO   C152
....................          break; 
1B180:  BRA    1B2E6
....................       case 'B': commandB(); 
1B182:  GOTO   C2BE
....................          break; 
1B186:  BRA    1B2E6
....................       case 'C': commandC(); 
1B188:  GOTO   DCE2
....................          break; 
1B18C:  BRA    1B2E6
....................       case 'D': commandD(); 
1B18E:  GOTO   DD20
....................          break; 
1B192:  BRA    1B2E6
....................       case 'E': commandE(); 
1B194:  GOTO   DDBE
....................          break;          
1B198:  BRA    1B2E6
....................       case 'F': commandF(); 
1B19A:  GOTO   E0BC
....................          break;          
1B19E:  BRA    1B2E6
....................       case 'G': commandG(); 
1B1A0:  GOTO   E126
....................          break; 
1B1A4:  BRA    1B2E6
....................       case 'H': commandH(); 
1B1A6:  GOTO   F284
....................          break; 
1B1AA:  BRA    1B2E6
....................       case 'I': commandI(); 
1B1AC:  GOTO   F2C4
....................          break;    
1B1B0:  BRA    1B2E6
....................       case 'J': commandJ(); 
1B1B2:  GOTO   F310
....................          break;      
1B1B6:  BRA    1B2E6
....................       case 'K': commandK(); 
1B1B8:  GOTO   F56A
....................          break;    
1B1BC:  BRA    1B2E6
....................       case 'L': commandL(); 
1B1BE:  GOTO   FFCE
....................          break;             
1B1C2:  BRA    1B2E6
....................       case 'M': commandM(FALSE); 
1B1C4:  MOVLB  8
1B1C6:  CLRF   x85
1B1C8:  MOVLB  0
1B1CA:  CALL   16DDC
....................          break;   
1B1CE:  BRA    1B2E6
....................       case 'N': commandN(); 
1B1D0:  GOTO   16EFA
....................          break;          
1B1D4:  BRA    1B2E6
....................       case 'O': commandO(); 
1B1D6:  GOTO   170AA
....................          break;    
1B1DA:  BRA    1B2E6
....................       case 'P': commandP(); 
1B1DC:  GOTO   172AE
....................          break;  
1B1E0:  BRA    1B2E6
....................       case 'Q': commandQ(); 
1B1E2:  GOTO   1736C
....................          break;              
1B1E6:  BRA    1B2E6
....................       case 'R': commandR(); 
1B1E8:  GOTO   17602
....................          break;    
1B1EC:  BRA    1B2E6
....................       case 'S': commandS(); 
1B1EE:  GOTO   1772E
....................          break;  
1B1F2:  BRA    1B2E6
....................       case 'T': commandT(); 
1B1F4:  GOTO   17D56
....................          break;            
1B1F8:  BRA    1B2E6
....................       case 'U': commandU(); 
1B1FA:  GOTO   1875E
....................          break;           
1B1FE:  BRA    1B2E6
....................       case 'V': commandV(); 
1B200:  GOTO   188B6
....................          break; 
1B204:  BRA    1B2E6
....................       case 'W': commandW(); 
1B206:  GOTO   18A2A
....................          break; 
1B20A:  BRA    1B2E6
....................       case 'X': commandX(); 
1B20C:  GOTO   18A4E
....................          break; 
1B210:  BRA    1B2E6
....................       case 'Y': commandY(); 
1B212:  GOTO   18AB6
....................          break;  
1B216:  BRA    1B2E6
....................       case 'Z': commandZ(); 
1B218:  CALL   18BBE
....................          break;    
1B21C:  BRA    1B2E6
....................       // stepper 
....................       case '^': command_set(); 
1B21E:  GOTO   18BE2
....................          break;       
1B222:  BRA    1B2E6
....................       case '+': if(m_fixed==1) motor=1; 
1B224:  MOVLB  7
1B226:  DECFSZ x41,W
1B228:  BRA    1B22E
1B22A:  MOVLW  01
1B22C:  MOVWF  x40
....................                 command_move(0,0,1); 
1B22E:  MOVLB  8
1B230:  CLRF   x85
1B232:  CLRF   x86
1B234:  MOVLW  01
1B236:  MOVWF  x87
1B238:  MOVLB  0
1B23A:  CALL   170CE
....................          break; 
1B23E:  BRA    1B2E6
....................       case '-': if(m_fixed==1) motor=1; 
1B240:  MOVLB  7
1B242:  DECFSZ x41,W
1B244:  BRA    1B24A
1B246:  MOVLW  01
1B248:  MOVWF  x40
....................                 command_move(0,1,1); 
1B24A:  MOVLB  8
1B24C:  CLRF   x85
1B24E:  MOVLW  01
1B250:  MOVWF  x86
1B252:  MOVWF  x87
1B254:  MOVLB  0
1B256:  CALL   170CE
....................          break; 
1B25A:  BRA    1B2E6
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1B25C:  GOTO   18D0E
....................          break;     
1B260:  BRA    1B2E6
....................       case 'b': command_b(); 
1B262:  GOTO   18D2A
....................          break; 
1B266:  BRA    1B2E6
....................       case 'c': command_c(); 
1B268:  GOTO   18DC4
....................          break; 
1B26C:  BRA    1B2E6
....................       case 'd': command_d(); 
1B26E:  GOTO   18E14
....................          break;          
1B272:  BRA    1B2E6
....................       case 'e': command_e(); 
1B274:  GOTO   18EAA
....................          break;       
1B278:  BRA    1B2E6
....................       case 'f': command_f(); 
1B27A:  GOTO   18F44
....................          break; 
1B27E:  BRA    1B2E6
....................       case 'g': command_g(); 
1B280:  GOTO   18F64
....................          break;          
1B284:  BRA    1B2E6
....................       case 'h': command_h(); 
1B286:  GOTO   18FFE
....................          break; 
1B28A:  BRA    1B2E6
....................       case 'i': command_i(); 
1B28C:  GOTO   190D2
....................          break;   
1B290:  BRA    1B2E6
....................       case 'j': command_j(); 
1B292:  GOTO   191AE
....................          break;           
1B296:  BRA    1B2E6
....................       case 'k': command_k(); 
1B298:  GOTO   19248
....................          break;          
1B29C:  BRA    1B2E6
....................       case 'l': step_var_list(); 
1B29E:  GOTO   192DE
....................          break;          
1B2A2:  BRA    1B2E6
....................       case 'm': command_m(); 
1B2A4:  GOTO   19F3E
....................          break;    
1B2A8:  BRA    1B2E6
....................       case 'n': command_n(); 
1B2AA:  GOTO   19FD4
....................          break; 
1B2AE:  BRA    1B2E6
....................       case 'o': command_o(); 
1B2B0:  GOTO   1A06A
....................          break;    
1B2B4:  BRA    1B2E6
....................       case 'p': command_p(); 
1B2B6:  GOTO   1A104
....................          break;   
1B2BA:  BRA    1B2E6
....................       case 'q': command_q(); 
1B2BC:  GOTO   1A19E
....................          break; 
1B2C0:  BRA    1B2E6
....................       case 'r': command_r(); 
1B2C2:  BRA    1AC9A
....................          break;    
1B2C4:  BRA    1B2E6
....................       case 's': command_s(); 
1B2C6:  BRA    1ACF4
....................          break;           
1B2C8:  BRA    1B2E6
....................       case 't': command_t(); 
1B2CA:  BRA    1AE02
....................          break;          
1B2CC:  BRA    1B2E6
....................       case 'u': command_u(); 
1B2CE:  BRA    1AE98
....................          break; 
1B2D0:  BRA    1B2E6
....................       case 'v': command_v(); 
1B2D2:  CALL   13DFE
....................          break; 
1B2D6:  BRA    1B2E6
....................       case 'w': command_w(); 
1B2D8:  BRA    1AED0
....................          break; 
1B2DA:  BRA    1B2E6
....................       case 'x': command_x(); 
1B2DC:  BRA    1AFA4
....................          break;    
1B2DE:  BRA    1B2E6
....................       case 'y': command_y(); 
1B2E0:  BRA    1B03E
....................          break;  
1B2E2:  BRA    1B2E6
....................       case 'z': command_z(); 
1B2E4:  BRA    1B0D4
....................          break;           
....................    } 
1B2E6:  GOTO   1B40A (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg2() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0B1C0:  MOVF   51,F
0B1C2:  BNZ   B214
0B1C4:  MOVLB  8
0B1C6:  MOVF   x85,W
0B1C8:  SUBLW  24
0B1CA:  BC    B1D2
0B1CC:  MOVF   x85,W
0B1CE:  SUBLW  26
0B1D0:  BC    B20C
0B1D2:  MOVF   x85,W
0B1D4:  SUBLW  29
0B1D6:  BC    B1DE
0B1D8:  MOVF   x85,W
0B1DA:  SUBLW  2B
0B1DC:  BC    B20C
0B1DE:  MOVF   x85,W
0B1E0:  SUBLW  2D
0B1E2:  BZ    B20C
0B1E4:  MOVF   x85,W
0B1E6:  SUBLW  2F
0B1E8:  BZ    B20C
0B1EA:  MOVF   x85,W
0B1EC:  SUBLW  40
0B1EE:  BC    B1F6
0B1F0:  MOVF   x85,W
0B1F2:  SUBLW  42
0B1F4:  BC    B20C
0B1F6:  MOVF   x85,W
0B1F8:  SUBLW  43
0B1FA:  BC    B202
0B1FC:  MOVF   x85,W
0B1FE:  SUBLW  5A
0B200:  BC    B20C
0B202:  MOVF   x85,W
0B204:  SUBLW  5E
0B206:  BZ    B20C
0B208:  MOVLW  00
0B20A:  BRA    B20E
0B20C:  MOVLW  01
0B20E:  MOVWF  x86
0B210:  BRA    B276
0B212:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0B214:  DECFSZ 51,W
0B216:  BRA    B278
0B218:  MOVLB  8
0B21A:  MOVF   x85,W
0B21C:  SUBLW  23
0B21E:  BZ    B272
0B220:  MOVF   x85,W
0B222:  SUBLW  24
0B224:  BC    B22C
0B226:  MOVF   x85,W
0B228:  SUBLW  26
0B22A:  BC    B272
0B22C:  MOVF   x85,W
0B22E:  SUBLW  29
0B230:  BC    B238
0B232:  MOVF   x85,W
0B234:  SUBLW  2B
0B236:  BC    B272
0B238:  MOVF   x85,W
0B23A:  SUBLW  2D
0B23C:  BZ    B272
0B23E:  MOVF   x85,W
0B240:  SUBLW  2F
0B242:  BZ    B272
0B244:  MOVF   x85,W
0B246:  SUBLW  40
0B248:  BC    B250
0B24A:  MOVF   x85,W
0B24C:  SUBLW  42
0B24E:  BC    B272
0B250:  MOVF   x85,W
0B252:  SUBLW  43
0B254:  BC    B25C
0B256:  MOVF   x85,W
0B258:  SUBLW  5A
0B25A:  BC    B272
0B25C:  MOVF   x85,W
0B25E:  SUBLW  5E
0B260:  BZ    B272
0B262:  MOVF   x85,W
0B264:  SUBLW  60
0B266:  BC    B26E
0B268:  MOVF   x85,W
0B26A:  SUBLW  7A
0B26C:  BC    B272
0B26E:  MOVLW  00
0B270:  BRA    B274
0B272:  MOVLW  01
0B274:  MOVWF  x86
0B276:  MOVLB  0
....................    return(valid); 
0B278:  MOVLB  8
0B27A:  MOVFF  886,01
0B27E:  MOVLB  0
0B280:  GOTO   1B3C2 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(!check_cmd(cmd)) 
*
1B3BA:  MOVFF  47,885
1B3BE:  GOTO   B1C0
1B3C2:  MOVF   01,F
1B3C4:  BNZ   1B3E8
....................       fputs("\r\n@INV", COM_A); 
1B3C6:  MOVLW  F0
1B3C8:  MOVWF  FF6
1B3CA:  MOVLW  27
1B3CC:  MOVWF  FF7
1B3CE:  MOVLW  00
1B3D0:  MOVWF  FF8
1B3D2:  CALL   AEAE
1B3D6:  MOVLW  0D
1B3D8:  BTFSS  F9E.4
1B3DA:  BRA    1B3D8
1B3DC:  MOVWF  FAD
1B3DE:  MOVLW  0A
1B3E0:  BTFSS  F9E.4
1B3E2:  BRA    1B3E0
1B3E4:  MOVWF  FAD
1B3E6:  BRA    1B40A
....................    else{ 
....................       fputs("\r\n@OK! ", COM_A); 
1B3E8:  MOVLW  F8
1B3EA:  MOVWF  FF6
1B3EC:  MOVLW  27
1B3EE:  MOVWF  FF7
1B3F0:  MOVLW  00
1B3F2:  MOVWF  FF8
1B3F4:  CALL   AEAE
1B3F8:  MOVLW  0D
1B3FA:  BTFSS  F9E.4
1B3FC:  BRA    1B3FA
1B3FE:  MOVWF  FAD
1B400:  MOVLW  0A
1B402:  BTFSS  F9E.4
1B404:  BRA    1B402
1B406:  MOVWF  FAD
....................       select_cmd(); 
1B408:  BRA    1B14A
....................    } 
1B40A:  GOTO   1B61E (RETURN)
.................... } 
.................... void proc_cmd2() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
....................    else fputs("@INV", COM_A); 
.................... } 
....................  
.................... void command_prompt(){ 
1B40E:  MOVLB  8
1B410:  CLRF   x64
1B412:  CLRF   x65
1B414:  CLRF   x66
....................    int8 good_val = FALSE; 
....................    int8 i = 0; 
....................    char temp = 0; 
....................    char input_string[30]; 
....................     
....................    //Disable rtc watchdog 
....................    output_bit(RTC_CS, ENABLE); 
1B416:  BCF    F91.0
....................    spi_write(0x89); 
1B418:  MOVF   FC9,W
1B41A:  MOVLW  89
1B41C:  MOVWF  FC9
1B41E:  RRCF   FC7,W
1B420:  BNC   1B41E
....................    spi_write(0b00000000); 
1B422:  MOVF   FC9,W
1B424:  CLRF   FC9
1B426:  RRCF   FC7,W
1B428:  BNC   1B426
....................    spi_read(0x00); 
1B42A:  MOVF   FC9,W
1B42C:  CLRF   FC9
1B42E:  RRCF   FC7,W
1B430:  BNC   1B42E
....................    output_bit(RTC_CS, DISABLE); 
1B432:  BSF    F91.0
....................     
....................     
....................    nv_cmd_mode = TRUE; 
1B434:  CLRF   32
1B436:  MOVLW  01
1B438:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1B43A:  MOVLW  02
1B43C:  MOVWF  x89
1B43E:  MOVFF  31,88A
1B442:  MOVLB  0
1B444:  CALL   343A
....................     
....................    fputs("@CMD", COM_A); 
1B448:  MOVLW  06
1B44A:  MOVWF  FF6
1B44C:  MOVLW  28
1B44E:  MOVWF  FF7
1B450:  MOVLW  00
1B452:  MOVWF  FF8
1B454:  CALL   AEAE
1B458:  MOVLW  0D
1B45A:  BTFSS  F9E.4
1B45C:  BRA    1B45A
1B45E:  MOVWF  FAD
1B460:  MOVLW  0A
1B462:  BTFSS  F9E.4
1B464:  BRA    1B462
1B466:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1B468:  MOVLW  01
1B46A:  MOVWF  1E
1B46C:  MOVLW  A7
1B46E:  MOVWF  1D
1B470:  MOVLW  0C
1B472:  MOVWF  FF6
1B474:  MOVLW  28
1B476:  MOVWF  FF7
1B478:  MOVLW  00
1B47A:  MOVWF  FF8
1B47C:  CALL   50E6
....................    record_event(); 
1B480:  CALL   8502
....................     
....................    busy_clear(); 
1B484:  CALL   AED8
....................     
....................    cmd_set=0; // user 
1B488:  CLRF   51
....................     
....................    do { 
....................       for(i = 0; i<30; i++){ 
1B48A:  MOVLB  8
1B48C:  CLRF   x65
1B48E:  MOVF   x65,W
1B490:  SUBLW  1D
1B492:  BNC   1B4A8
....................          input_string[i] = 0; 
1B494:  CLRF   03
1B496:  MOVF   x65,W
1B498:  ADDLW  67
1B49A:  MOVWF  FE9
1B49C:  MOVLW  08
1B49E:  ADDWFC 03,W
1B4A0:  MOVWF  FEA
1B4A2:  CLRF   FEF
1B4A4:  INCF   x65,F
1B4A6:  BRA    1B48E
....................    
....................       } 
....................       i = 0; 
1B4A8:  CLRF   x65
....................       fputc('>',COM_A); 
1B4AA:  MOVLW  3E
1B4AC:  MOVLB  0
1B4AE:  CALL   AEE0
....................       temp = 0; 
1B4B2:  MOVLB  8
1B4B4:  CLRF   x66
....................       while(temp != CARRIAGE_RET){ 
1B4B6:  MOVF   x66,W
1B4B8:  SUBLW  0D
1B4BA:  BZ    1B552
....................          temp = fgetc(COM_A); 
1B4BC:  MOVLB  0
1B4BE:  CALL   0E58
1B4C2:  MOVFF  01,866
....................          //Backspace character 
....................          if(temp != 8){ 
1B4C6:  MOVLB  8
1B4C8:  MOVF   x66,W
1B4CA:  SUBLW  08
1B4CC:  BZ    1B4F8
....................             if (com_echo == TRUE) 
1B4CE:  DECFSZ 4C,W
1B4D0:  BRA    1B4DC
....................             { 
....................                fputc(temp,COM_A); 
1B4D2:  MOVF   x66,W
1B4D4:  MOVLB  0
1B4D6:  CALL   AEE0
1B4DA:  MOVLB  8
....................             } 
....................             if(temp!= CARRIAGE_RET){ 
1B4DC:  MOVF   x66,W
1B4DE:  SUBLW  0D
1B4E0:  BZ    1B4F6
....................                input_string[i] = temp; 
1B4E2:  CLRF   03
1B4E4:  MOVF   x65,W
1B4E6:  ADDLW  67
1B4E8:  MOVWF  FE9
1B4EA:  MOVLW  08
1B4EC:  ADDWFC 03,W
1B4EE:  MOVWF  FEA
1B4F0:  MOVFF  866,FEF
....................                i++; 
1B4F4:  INCF   x65,F
....................             } 
....................          }else{ 
1B4F6:  BRA    1B550
....................             //backspace code 
....................             if(i != 0){ 
1B4F8:  MOVF   x65,F
1B4FA:  BZ    1B550
....................                input_string[i-1] = 0; 
1B4FC:  MOVLW  01
1B4FE:  SUBWF  x65,W
1B500:  CLRF   03
1B502:  ADDLW  67
1B504:  MOVWF  FE9
1B506:  MOVLW  08
1B508:  ADDWFC 03,W
1B50A:  MOVWF  FEA
1B50C:  CLRF   FEF
....................                i--; 
1B50E:  DECF   x65,F
....................                //Clear buffer and overwrite with previous minus one character 
....................                fputc('\r',COM_A); 
1B510:  MOVLW  0D
1B512:  MOVLB  0
1B514:  CALL   AEE0
....................                fprintf(COM_A,"                                       "); 
1B518:  MOVLW  1E
1B51A:  MOVWF  FF6
1B51C:  MOVLW  28
1B51E:  MOVWF  FF7
1B520:  MOVLW  00
1B522:  MOVWF  FF8
1B524:  CLRF   1B
1B526:  BTFSC  FF2.7
1B528:  BSF    1B.7
1B52A:  BCF    FF2.7
1B52C:  CALL   0E6E
1B530:  BTFSC  1B.7
1B532:  BSF    FF2.7
....................                fputc('\r',COM_A); 
1B534:  MOVLW  0D
1B536:  CALL   AEE0
....................                fprintf(COM_A,">"); 
1B53A:  MOVLW  3E
1B53C:  BTFSS  F9E.4
1B53E:  BRA    1B53C
1B540:  MOVWF  FAD
....................                fprintf(COM_A,input_string); 
1B542:  MOVLW  08
1B544:  MOVWF  FEA
1B546:  MOVLW  67
1B548:  MOVWF  FE9
1B54A:  CALL   79BE
1B54E:  MOVLB  8
....................                 
....................             } 
....................          } 
1B550:  BRA    1B4B6
....................       } 
....................       cmd = input_string[0]; 
1B552:  MOVFF  867,47
....................       if (cmd == '?'){ 
1B556:  MOVF   47,W
1B558:  SUBLW  3F
1B55A:  BNZ   1B566
....................          msg_busy(); 
1B55C:  MOVLB  0
1B55E:  GOTO   AEE8
....................       }else if (input_string[1] == 0){ 
1B562:  BRA    1B61E
1B564:  MOVLB  8
1B566:  MOVF   x68,F
1B568:  BNZ   1B592
....................          fputs("\r\n@ARG ", COM_A); 
1B56A:  MOVLW  46
1B56C:  MOVWF  FF6
1B56E:  MOVLW  28
1B570:  MOVWF  FF7
1B572:  MOVLW  00
1B574:  MOVWF  FF8
1B576:  MOVLB  0
1B578:  CALL   AEAE
1B57C:  MOVLW  0D
1B57E:  BTFSS  F9E.4
1B580:  BRA    1B57E
1B582:  MOVWF  FAD
1B584:  MOVLW  0A
1B586:  BTFSS  F9E.4
1B588:  BRA    1B586
1B58A:  MOVWF  FAD
....................          good_val = FALSE; 
1B58C:  MOVLB  8
1B58E:  CLRF   x64
....................       }else{ 
1B590:  BRA    1B620
....................       i = 1; 
1B592:  MOVLW  01
1B594:  MOVWF  x65
....................       //fputs("\r\n",COM_A); 
....................       //Check that argument is digits only 
....................       while(input_string[i] != 0){ 
1B596:  CLRF   03
1B598:  MOVF   x65,W
1B59A:  ADDLW  67
1B59C:  MOVWF  FE9
1B59E:  MOVLW  08
1B5A0:  ADDWFC 03,W
1B5A2:  MOVWF  FEA
1B5A4:  MOVF   FEF,F
1B5A6:  BZ    1B5F8
....................       //fputc(input_string[i],COM_A); 
....................          if(!isdigit(input_string[i])){ 
1B5A8:  CLRF   03
1B5AA:  MOVF   x65,W
1B5AC:  ADDLW  67
1B5AE:  MOVWF  FE9
1B5B0:  MOVLW  08
1B5B2:  ADDWFC 03,W
1B5B4:  MOVWF  FEA
1B5B6:  MOVFF  FEF,885
1B5BA:  MOVF   x85,W
1B5BC:  SUBLW  2F
1B5BE:  BC    1B5C6
1B5C0:  MOVF   x85,W
1B5C2:  SUBLW  39
1B5C4:  BC    1B5F0
....................             fputs("\r\n@ARG ", COM_A); 
1B5C6:  MOVLW  4E
1B5C8:  MOVWF  FF6
1B5CA:  MOVLW  28
1B5CC:  MOVWF  FF7
1B5CE:  MOVLW  00
1B5D0:  MOVWF  FF8
1B5D2:  MOVLB  0
1B5D4:  CALL   AEAE
1B5D8:  MOVLW  0D
1B5DA:  BTFSS  F9E.4
1B5DC:  BRA    1B5DA
1B5DE:  MOVWF  FAD
1B5E0:  MOVLW  0A
1B5E2:  BTFSS  F9E.4
1B5E4:  BRA    1B5E2
1B5E6:  MOVWF  FAD
....................             good_val = FALSE; 
1B5E8:  MOVLB  8
1B5EA:  CLRF   x64
....................             break; 
1B5EC:  BRA    1B5F8
....................          }else{ 
1B5EE:  BRA    1B5F4
....................             good_val = TRUE; 
1B5F0:  MOVLW  01
1B5F2:  MOVWF  x64
....................          } 
....................          i++; 
1B5F4:  INCF   x65,F
1B5F6:  BRA    1B596
....................       } 
....................       if(!good_val){ 
1B5F8:  MOVF   x64,F
1B5FA:  BNZ   1B5FE
....................          continue; 
1B5FC:  BRA    1B620
....................       } 
....................       //convert arg from string to int32 
....................       arg = atoi32(input_string+1); 
1B5FE:  MOVLW  08
1B600:  MOVWF  x86
1B602:  MOVLW  68
1B604:  MOVWF  x85
1B606:  MOVLB  0
1B608:  GOTO   AF2A
1B60C:  MOVFF  03,4B
1B610:  MOVFF  02,4A
1B614:  MOVFF  01,49
1B618:  MOVFF  00,48
....................        
....................       proc_cmd(); 
1B61C:  BRA    1B3BA
1B61E:  MOVLB  8
....................       } 
....................        
....................       /*if (cmd == '?') msg_busy(); 
....................       else{  
....................             proc_cmd(); 
....................              
....................       }*/ 
....................    } while(nv_cmd_mode == TRUE); 
1B620:  DECFSZ 31,W
1B622:  BRA    1B62A
1B624:  MOVF   32,F
1B626:  BTFSC  FD8.2
1B628:  BRA    1B48C
1B62A:  MOVLB  0
1B62C:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void command_prompt2() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................    char temp_cmd = 0; 
....................    nv_cmd_mode = TRUE; 
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
....................     
....................    fputs("@CMD", COM_A); 
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
....................    record_event(); 
....................     
....................    busy_clear(); 
....................     
....................    cmd_set=0; // user 
....................     
....................    do { 
....................       fputc('>',COM_A); 
....................       cmd=fgetc(COM_A); 
....................          temp_cmd = cmd; 
....................          if (com_echo == TRUE) 
....................          { 
....................             fputc(cmd,COM_A); 
....................          } 
....................          if (cmd == '?') msg_busy(); 
....................          else proc_cmd(); 
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
.................... } 
....................  
....................  
.................... void main() 
1B62E:  CLRF   FF8
1B630:  BCF    FD0.7
1B632:  BSF    07.7
1B634:  MOVLW  70
1B636:  MOVWF  FD3
1B638:  MOVLW  40
1B63A:  MOVWF  F9B
1B63C:  CLRF   F64
1B63E:  CLRF   1C
1B640:  BSF    F65.3
1B642:  MOVWF  FAF
1B644:  MOVLW  03
1B646:  MOVWF  FD4
1B648:  MOVLW  A6
1B64A:  MOVWF  FAC
1B64C:  MOVLW  90
1B64E:  MOVWF  FAB
1B650:  MOVLB  F
1B652:  BSF    x20.3
1B654:  MOVLW  82
1B656:  MOVWF  x1E
1B658:  MOVLW  06
1B65A:  MOVWF  x1F
1B65C:  MOVLW  A6
1B65E:  MOVWF  x21
1B660:  MOVLW  90
1B662:  MOVWF  x22
1B664:  BSF    F65.3
1B666:  MOVLW  40
1B668:  MOVWF  FAF
1B66A:  MOVLW  03
1B66C:  MOVWF  FD4
1B66E:  MOVLW  A6
1B670:  MOVWF  FAC
1B672:  MOVLW  90
1B674:  MOVWF  FAB
1B676:  CLRF   1E
1B678:  CLRF   1D
1B67A:  SETF   3A
1B67C:  SETF   39
1B67E:  SETF   3C
1B680:  SETF   3B
1B682:  CLRF   46
1B684:  MOVLW  01
1B686:  MOVWF  45
1B688:  MOVWF  4C
1B68A:  BCF    4D.0
1B68C:  BCF    4D.1
1B68E:  BCF    4D.2
1B690:  MOVLB  0
1B692:  CLRF   x66
1B694:  MOVLB  2
1B696:  MOVWF  xD9
1B698:  MOVLB  3
1B69A:  CLRF   x3B
1B69C:  MOVLB  4
1B69E:  CLRF   xE7
1B6A0:  MOVWF  xED
1B6A2:  MOVLW  04
1B6A4:  MOVLB  7
1B6A6:  MOVWF  x13
1B6A8:  MOVLW  EE
1B6AA:  MOVWF  x12
1B6AC:  CLRF   xCD
1B6AE:  MOVLB  8
1B6B0:  CLRF   x58
1B6B2:  CLRF   x57
1B6B4:  CLRF   x5C
1B6B6:  CLRF   x5B
1B6B8:  CLRF   x5A
1B6BA:  CLRF   x59
1B6BC:  CLRF   x60
1B6BE:  CLRF   x5F
1B6C0:  CLRF   x5E
1B6C2:  CLRF   x5D
1B6C4:  MOVLW  00
1B6C6:  MOVLB  F
1B6C8:  MOVWF  x23
1B6CA:  MOVWF  x24
1B6CC:  MOVWF  x25
1B6CE:  BCF    FC1.3
1B6D0:  BCF    FC1.4
1B6D2:  BCF    FC1.5
1B6D4:  CLRF   x2E
1B6D6:  CLRF   x2F
1B6D8:  CLRF   x54
1B6DA:  BRA    1B79C
1B6DC:  DATA 44,02
1B6DE:  DATA DD,20
1B6E0:  DATA 64,72
1B6E2:  DATA 61,77
1B6E4:  DATA 5F,61
1B6E6:  DATA 6C,6C
1B6E8:  DATA 2E,63
1B6EA:  DATA 73,76
1B6EC:  DATA 00,20
1B6EE:  DATA 64,72
1B6F0:  DATA 61,77
1B6F2:  DATA 5F,6E
1B6F4:  DATA 65,77
1B6F6:  DATA 2E,63
1B6F8:  DATA 73,76
1B6FA:  DATA 00,20
1B6FC:  DATA 64,72
1B6FE:  DATA 65,6C
1B700:  DATA 5F,61
1B702:  DATA 6C,6C
1B704:  DATA 2E,63
1B706:  DATA 73,76
1B708:  DATA 00,20
1B70A:  DATA 64,72
1B70C:  DATA 65,6C
1B70E:  DATA 5F,6E
1B710:  DATA 65,77
1B712:  DATA 2E,63
1B714:  DATA 73,76
1B716:  DATA 00,20
1B718:  DATA 65,76
1B71A:  DATA 65,6E
1B71C:  DATA 74,73
1B71E:  DATA 2E,74
1B720:  DATA 78,74
1B722:  DATA 00,02
1B724:  DATA 03,39
1B726:  DATA 2C,00
1B728:  DATA 02,04
1B72A:  DATA D8,00
1B72C:  DATA 00,10
1B72E:  DATA 07,14
1B730:  DATA 46,41
1B732:  DATA 54,31
1B734:  DATA 32,46
1B736:  DATA 41,54
1B738:  DATA 31,36
1B73A:  DATA 46,41
1B73C:  DATA 54,33
1B73E:  DATA 32,00
1B740:  DATA 57,07
1B742:  DATA CE,0D
1B744:  DATA 0A,00
1B746:  DATA 00,03
1B748:  DATA 00,0F
1B74A:  DATA 00,1B
1B74C:  DATA 00,27
1B74E:  DATA 00,33
1B750:  DATA 00,3F
1B752:  DATA 00,4B
1B754:  DATA 00,57
1B756:  DATA 00,63
1B758:  DATA 00,6F
1B75A:  DATA 00,7B
1B75C:  DATA 00,87
1B75E:  DATA 00,93
1B760:  DATA 00,9F
1B762:  DATA 00,AB
1B764:  DATA 00,B7
1B766:  DATA 00,C3
1B768:  DATA 48,B1
1B76A:  DATA 70,D4
1B76C:  DATA 98,F7
1B76E:  DATA C0,1A
1B770:  DATA 00,CF
1B772:  DATA 28,F2
1B774:  DATA 50,15
1B776:  DATA 78,38
1B778:  DATA A0,5B
1B77A:  DATA C8,7E
1B77C:  DATA F0,A1
1B77E:  DATA 18,C5
1B780:  DATA 40,E8
1B782:  DATA 68,0B
1B784:  DATA 90,2E
1B786:  DATA B8,51
1B788:  DATA E0,74
1B78A:  DATA 08,98
1B78C:  DATA 30,BB
1B78E:  DATA 58,DE
1B790:  DATA 80,01
1B792:  DATA A8,24
1B794:  DATA D0,47
1B796:  DATA F8,6A
1B798:  DATA 20,8E
1B79A:  DATA 00,00
1B79C:  MOVLW  01
1B79E:  MOVWF  FF8
1B7A0:  MOVLW  B6
1B7A2:  MOVWF  FF7
1B7A4:  MOVLW  DC
1B7A6:  MOVWF  FF6
1B7A8:  TBLRD*+
1B7AA:  MOVF   FF5,W
1B7AC:  MOVWF  00
1B7AE:  XORLW  00
1B7B0:  BZ    1B7D8
1B7B2:  TBLRD*+
1B7B4:  MOVF   FF5,W
1B7B6:  MOVWF  01
1B7B8:  BTFSC  FE8.7
1B7BA:  BRA    1B7C6
1B7BC:  ANDLW  0F
1B7BE:  MOVWF  FEA
1B7C0:  TBLRD*+
1B7C2:  MOVFF  FF5,FE9
1B7C6:  BTFSC  01.6
1B7C8:  TBLRD*+
1B7CA:  BTFSS  01.6
1B7CC:  TBLRD*+
1B7CE:  MOVFF  FF5,FEE
1B7D2:  DCFSNZ 00,F
1B7D4:  BRA    1B7A8
1B7D6:  BRA    1B7CA
1B7D8:  CLRF   FF8
1B7DA:  MOVLB  8
1B7DC:  CLRF   x61
1B7DE:  CLRF   x63
1B7E0:  CLRF   x62
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B7E2:  BCF    FF2.6
1B7E4:  BCF    FF2.7
1B7E6:  BTFSC  FF2.7
1B7E8:  BRA    1B7E4
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B7EA:  BCF    FC6.5
1B7EC:  MOVLW  21
1B7EE:  MOVWF  FC6
1B7F0:  MOVLW  40
1B7F2:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B7F4:  BCF    F67.5
1B7F6:  MOVLW  21
1B7F8:  MOVWF  F67
1B7FA:  MOVLW  40
1B7FC:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B7FE:  MOVLW  00
1B800:  MOVLB  F
1B802:  MOVWF  x23
1B804:  MOVWF  x24
1B806:  MOVLW  1F
1B808:  MOVWF  x25
1B80A:  BCF    FC1.3
1B80C:  BSF    FC1.4
1B80E:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B810:  MOVF   FC0,W
1B812:  ANDLW  C0
1B814:  IORLW  07
1B816:  MOVWF  FC0
1B818:  BSF    FC0.7
1B81A:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B81C:  MOVLW  87
1B81E:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B820:  MOVLW  37
1B822:  MOVWF  FCD
1B824:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B826:  MOVLB  0
1B828:  GOTO   28EC
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B82C:  CLRF   FB0
1B82E:  MOVLW  07
1B830:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B832:  MOVLW  04
1B834:  MOVLB  F
1B836:  MOVWF  x2E
1B838:  MOVWF  x2F
1B83A:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B83C:  MOVLW  70
1B83E:  MOVWF  FD3
1B840:  MOVLW  40
1B842:  MOVWF  F9B
1B844:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B846:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B848:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B84A:  MOVLB  0
1B84C:  CALL   2928
....................  
....................    enable_interrupts(GLOBAL); 
1B850:  MOVLW  C0
1B852:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
1B854:  CALL   2962
....................    motor_sleep_rdy(); 
1B858:  CALL   29C0
....................  
....................    sleep_mode = FALSE;    
1B85C:  BCF    4D.1
....................    busy_set(); 
1B85E:  CALL   29E8
....................     
....................    init_nv_vars(); 
1B862:  CALL   2AE0
....................    get_step_vars(); 
1B866:  CALL   2D42
....................    init_aws(); 
1B86A:  GOTO   3104
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B86E:  CALL   311E
....................    blink(); 
1B872:  GOTO   3124
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B876:  CALL   3170
....................     
....................    RTC_read(); 
1B87A:  CALL   336C
....................    RTC_last_power(); 
1B87E:  GOTO   346A
....................    RTC_reset_HT();   
1B882:  CALL   34DA
....................    RTC_read(); 
1B886:  CALL   336C
1B88A:  CLRF   1B
1B88C:  BTFSC  FF2.7
1B88E:  BSF    1B.7
1B890:  BCF    FF2.7
....................    RTC_read_flags(); 
1B892:  CALL   0DF8
1B896:  BTFSC  1B.7
1B898:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B89A:  MOVF   3F,F
1B89C:  BNZ   1B8A2
1B89E:  MOVF   40,F
1B8A0:  BZ    1B8F2
1B8A2:  MOVLW  6E
1B8A4:  MOVWF  FF6
1B8A6:  MOVLW  28
1B8A8:  MOVWF  FF7
1B8AA:  MOVLW  00
1B8AC:  MOVWF  FF8
1B8AE:  CLRF   1B
1B8B0:  BTFSC  FF2.7
1B8B2:  BSF    1B.7
1B8B4:  BCF    FF2.7
1B8B6:  MOVLW  04
1B8B8:  MOVLB  A
1B8BA:  MOVWF  x40
1B8BC:  MOVLB  0
1B8BE:  CALL   1044
1B8C2:  BTFSC  1B.7
1B8C4:  BSF    FF2.7
1B8C6:  MOVLW  10
1B8C8:  MOVWF  FE9
1B8CA:  CLRF   1B
1B8CC:  BTFSC  FF2.7
1B8CE:  BSF    1B.7
1B8D0:  BCF    FF2.7
1B8D2:  MOVFF  40,A41
1B8D6:  MOVFF  3F,A40
1B8DA:  CALL   11C6
1B8DE:  BTFSC  1B.7
1B8E0:  BSF    FF2.7
1B8E2:  MOVLW  0D
1B8E4:  BTFSS  F9E.4
1B8E6:  BRA    1B8E4
1B8E8:  MOVWF  FAD
1B8EA:  MOVLW  0A
1B8EC:  BTFSS  F9E.4
1B8EE:  BRA    1B8EC
1B8F0:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B8F2:  CALL   3530
....................    sd_status = init_sdcard(); 
1B8F6:  CALL   5062
1B8FA:  MOVFF  01,2DC
....................    if(sd_status>0) msg_card_fail(); 
1B8FE:  MOVLB  2
1B900:  MOVF   xDC,F
1B902:  BZ    1B90C
1B904:  MOVLB  0
1B906:  CALL   50A8
1B90A:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
1B90C:  MOVLB  0
1B90E:  GOTO   ABEE
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B912:  MOVLB  7
1B914:  MOVF   x96,F
1B916:  BNZ   1B924
1B918:  MOVF   x97,F
1B91A:  BNZ   1B924
1B91C:  MOVF   x98,F
1B91E:  BNZ   1B924
1B920:  MOVF   x99,F
1B922:  BZ    1B92C
1B924:  MOVLB  0
1B926:  CALL   9D2A
1B92A:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B92C:  MOVF   xAF,F
1B92E:  BNZ   1B9B2
1B930:  MOVF   xB0,F
1B932:  BNZ   1B9B2
....................       e_port[0]=0; 
1B934:  CLRF   xC4
1B936:  CLRF   xC3
....................       write16(ADDR_E1_PORT,0); 
1B938:  MOVLW  AA
1B93A:  MOVLB  8
1B93C:  MOVWF  xEE
1B93E:  CLRF   xF0
1B940:  CLRF   xEF
1B942:  MOVLB  0
1B944:  CALL   4FFC
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B948:  MOVLW  78
1B94A:  MOVWF  FF6
1B94C:  MOVLW  28
1B94E:  MOVWF  FF7
1B950:  MOVLW  00
1B952:  MOVWF  FF8
1B954:  CLRF   1B
1B956:  BTFSC  FF2.7
1B958:  BSF    1B.7
1B95A:  BCF    FF2.7
1B95C:  MOVLW  05
1B95E:  MOVLB  A
1B960:  MOVWF  x40
1B962:  MOVLB  0
1B964:  CALL   1044
1B968:  BTFSC  1B.7
1B96A:  BSF    FF2.7
1B96C:  MOVLW  10
1B96E:  MOVWF  FE9
1B970:  CLRF   1B
1B972:  BTFSC  FF2.7
1B974:  BSF    1B.7
1B976:  BCF    FF2.7
1B978:  MOVFF  7B0,A41
1B97C:  MOVFF  7AF,A40
1B980:  CALL   11C6
1B984:  BTFSC  1B.7
1B986:  BSF    FF2.7
1B988:  MOVLW  2C
1B98A:  BTFSS  F9E.4
1B98C:  BRA    1B98A
1B98E:  MOVWF  FAD
1B990:  MOVLW  10
1B992:  MOVWF  FE9
1B994:  MOVFF  7C4,8F1
1B998:  MOVFF  7C3,8F0
1B99C:  CALL   900C
1B9A0:  MOVLW  0D
1B9A2:  BTFSS  F9E.4
1B9A4:  BRA    1B9A2
1B9A6:  MOVWF  FAD
1B9A8:  MOVLW  0A
1B9AA:  BTFSS  F9E.4
1B9AC:  BRA    1B9AA
1B9AE:  MOVWF  FAD
1B9B0:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B9B2:  MOVF   xB1,F
1B9B4:  BNZ   1BA38
1B9B6:  MOVF   xB2,F
1B9B8:  BNZ   1BA38
....................       m_lin_pos[1]=-1; 
1B9BA:  SETF   xB6
1B9BC:  SETF   xB5
....................       write16(ADDR_M2_LIN_POS, -1); 
1B9BE:  MOVLW  B8
1B9C0:  MOVLB  8
1B9C2:  MOVWF  xEE
1B9C4:  SETF   xF0
1B9C6:  SETF   xEF
1B9C8:  MOVLB  0
1B9CA:  CALL   4FFC
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B9CE:  MOVLW  88
1B9D0:  MOVWF  FF6
1B9D2:  MOVLW  28
1B9D4:  MOVWF  FF7
1B9D6:  MOVLW  00
1B9D8:  MOVWF  FF8
1B9DA:  CLRF   1B
1B9DC:  BTFSC  FF2.7
1B9DE:  BSF    1B.7
1B9E0:  BCF    FF2.7
1B9E2:  MOVLW  05
1B9E4:  MOVLB  A
1B9E6:  MOVWF  x40
1B9E8:  MOVLB  0
1B9EA:  CALL   1044
1B9EE:  BTFSC  1B.7
1B9F0:  BSF    FF2.7
1B9F2:  MOVLW  10
1B9F4:  MOVWF  FE9
1B9F6:  CLRF   1B
1B9F8:  BTFSC  FF2.7
1B9FA:  BSF    1B.7
1B9FC:  BCF    FF2.7
1B9FE:  MOVFF  7B2,A41
1BA02:  MOVFF  7B1,A40
1BA06:  CALL   11C6
1BA0A:  BTFSC  1B.7
1BA0C:  BSF    FF2.7
1BA0E:  MOVLW  2C
1BA10:  BTFSS  F9E.4
1BA12:  BRA    1BA10
1BA14:  MOVWF  FAD
1BA16:  MOVLW  10
1BA18:  MOVWF  FE9
1BA1A:  MOVFF  7B6,8F1
1BA1E:  MOVFF  7B5,8F0
1BA22:  CALL   900C
1BA26:  MOVLW  0D
1BA28:  BTFSS  F9E.4
1BA2A:  BRA    1BA28
1BA2C:  MOVWF  FAD
1BA2E:  MOVLW  0A
1BA30:  BTFSS  F9E.4
1BA32:  BRA    1BA30
1BA34:  MOVWF  FAD
1BA36:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1BA38:  MOVF   31,F
1BA3A:  BNZ   1BADE
1BA3C:  MOVF   32,F
1BA3E:  BNZ   1BADE
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1BA40:  MOVLW  98
1BA42:  MOVWF  FF6
1BA44:  MOVLW  28
1BA46:  MOVWF  FF7
1BA48:  MOVLW  00
1BA4A:  MOVWF  FF8
1BA4C:  CLRF   1B
1BA4E:  BTFSC  FF2.7
1BA50:  BSF    1B.7
1BA52:  BCF    FF2.7
1BA54:  MOVLB  0
1BA56:  CALL   0E6E
1BA5A:  BTFSC  1B.7
1BA5C:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1BA5E:  MOVLB  8
1BA60:  MOVF   x63,F
1BA62:  BNZ   1BA90
1BA64:  MOVF   x62,W
1BA66:  SUBLW  63
1BA68:  BNC   1BA90
1BA6A:  MOVF   x61,W
1BA6C:  SUBLW  1B
1BA6E:  BZ    1BA90
....................       { 
....................          EscNum=TestForEsc(); 
1BA70:  MOVLB  0
1BA72:  GOTO   AE54
1BA76:  MOVFF  01,861
....................          if(EscNum == ESCAPE) command_prompt(); 
1BA7A:  MOVLB  8
1BA7C:  MOVF   x61,W
1BA7E:  SUBLW  1B
1BA80:  BNZ   1BA88
1BA82:  MOVLB  0
1BA84:  RCALL  1B40E
1BA86:  MOVLB  8
....................          EscCount++; 
1BA88:  INCF   x62,F
1BA8A:  BTFSC  FD8.2
1BA8C:  INCF   x63,F
1BA8E:  BRA    1BA60
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1BA90:  DECFSZ 33,W
1BA92:  BRA    1BAA8
1BA94:  MOVF   34,F
1BA96:  BNZ   1BAA8
....................       { 
....................          arg=0; 
1BA98:  CLRF   4B
1BA9A:  CLRF   4A
1BA9C:  CLRF   49
1BA9E:  CLRF   48
....................          commandZ(); 
1BAA0:  MOVLB  0
1BAA2:  CALL   18BBE
1BAA6:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1BAA8:  MOVLW  D0
1BAAA:  MOVWF  FF6
1BAAC:  MOVLW  28
1BAAE:  MOVWF  FF7
1BAB0:  MOVLW  00
1BAB2:  MOVWF  FF8
1BAB4:  CLRF   1B
1BAB6:  BTFSC  FF2.7
1BAB8:  BSF    1B.7
1BABA:  BCF    FF2.7
1BABC:  MOVLB  0
1BABE:  CALL   0E6E
1BAC2:  BTFSC  1B.7
1BAC4:  BSF    FF2.7
....................       arg = 0; 
1BAC6:  CLRF   4B
1BAC8:  CLRF   4A
1BACA:  CLRF   49
1BACC:  CLRF   48
....................       commandM(TRUE); 
1BACE:  MOVLW  01
1BAD0:  MOVLB  8
1BAD2:  MOVWF  x85
1BAD4:  MOVLB  0
1BAD6:  CALL   16DDC
....................    } 
1BADA:  BRA    1BAE2
1BADC:  MOVLB  7
....................    else 
....................    { 
....................       command_prompt(); 
1BADE:  MOVLB  0
1BAE0:  RCALL  1B40E
....................    } 
....................  
....................    reset_cpu(); 
1BAE2:  RESET
.................... } 
....................  
1BAE4:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 2878   PUT NOBROWNOUT BORV18 ZPBORM NOWDT WDT1024
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
