CCS PCH C Compiler, Version 5.071d, 1               23-Jun-17 13:55
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   113242 bytes (86%)
                           Largest free fragment is 17466
               RAM used:   2143 (55%) at main() level
                           2609 (68%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1AF18
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0ECA
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0EF4
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   18EA
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E00
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   16CC
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   1742
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E5A
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
.................... /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 3F,40
00668:  DATA 42,53
0066A:  DATA 59,0D
0066C:  DATA 0A,00
0066E:  DATA 40,52
00670:  DATA 44,59
00672:  DATA 0D,0A
00674:  DATA 00,00
00676:  DATA 40,46
00678:  DATA 53,3A
0067A:  DATA 44,69
0067C:  DATA 73,63
0067E:  DATA 6F,76
00680:  DATA 65,72
00682:  DATA 79,0D
00684:  DATA 0A,00
00686:  DATA 40,46
00688:  DATA 53,3A
0068A:  DATA 55,6E
0068C:  DATA 61,62
0068E:  DATA 6C,65
00690:  DATA 20,74
00692:  DATA 6F,20
00694:  DATA 70,75
00696:  DATA 74,20
00698:  DATA 63,61
0069A:  DATA 72,64
0069C:  DATA 20,69
0069E:  DATA 6E,20
006A0:  DATA 69,64
006A2:  DATA 6C,65
006A4:  DATA 20,73
006A6:  DATA 74,61
006A8:  DATA 74,65
006AA:  DATA 2C,20
006AC:  DATA 72,65
006AE:  DATA 73,70
006B0:  DATA 6F,6E
006B2:  DATA 73,65
006B4:  DATA 20,3D
006B6:  DATA 20,25
006B8:  DATA 30,32
006BA:  DATA 78,0D
006BC:  DATA 0A,00
006BE:  DATA 40,46
006C0:  DATA 53,3A
006C2:  DATA 43,61
006C4:  DATA 72,64
006C6:  DATA 20,69
006C8:  DATA 64,6C
006CA:  DATA 65,2C
006CC:  DATA 20,72
006CE:  DATA 65,73
006D0:  DATA 70,6F
006D2:  DATA 6E,73
006D4:  DATA 65,20
006D6:  DATA 3D,20
006D8:  DATA 25,30
006DA:  DATA 32,78
006DC:  DATA 0D,0A
006DE:  DATA 00,00
006E0:  DATA 40,46
006E2:  DATA 53,3A
006E4:  DATA 52,65
006E6:  DATA 73,70
006E8:  DATA 6F,6E
006EA:  DATA 73,65
006EC:  DATA 20,74
006EE:  DATA 6F,20
006F0:  DATA 53,44
006F2:  DATA 20,76
006F4:  DATA 65,72
006F6:  DATA 20,32
006F8:  DATA 20,74
006FA:  DATA 65,73
006FC:  DATA 74,20
006FE:  DATA 43,4D
00700:  DATA 44,38
00702:  DATA 20,3D
00704:  DATA 20,25
00706:  DATA 78,0D
00708:  DATA 0A,00
0070A:  DATA 40,46
0070C:  DATA 53,3A
0070E:  DATA 50,6F
00710:  DATA 73,73
00712:  DATA 69,62
00714:  DATA 6C,65
00716:  DATA 20,53
00718:  DATA 44,76
0071A:  DATA 32,20
0071C:  DATA 63,61
0071E:  DATA 72,64
00720:  DATA 20,64
00722:  DATA 65,74
00724:  DATA 65,63
00726:  DATA 74,65
00728:  DATA 64,0D
0072A:  DATA 0A,00
0072C:  DATA 40,46
0072E:  DATA 53,3A
00730:  DATA 56,6F
00732:  DATA 6C,74
00734:  DATA 61,67
00736:  DATA 65,20
00738:  DATA 72,61
0073A:  DATA 6E,67
0073C:  DATA 65,20
0073E:  DATA 63,68
00740:  DATA 65,63
00742:  DATA 6B,2C
00744:  DATA 20,6F
00746:  DATA 63,72
00748:  DATA 20,3D
0074A:  DATA 20,25
0074C:  DATA 30,32
0074E:  DATA 78,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,0D
0075C:  DATA 0A,00
0075E:  DATA 40,46
00760:  DATA 53,3A
00762:  DATA 43,61
00764:  DATA 72,64
00766:  DATA 20,56
00768:  DATA 64,64
0076A:  DATA 20,72
0076C:  DATA 61,6E
0076E:  DATA 67,65
00770:  DATA 20,3D
00772:  DATA 20,32
00774:  DATA 2E,37
00776:  DATA 2D,33
00778:  DATA 2E,36
0077A:  DATA 20,76
0077C:  DATA 6F,6C
0077E:  DATA 74,73
00780:  DATA 0D,0A
00782:  DATA 00,00
00784:  DATA 40,46
00786:  DATA 53,3A
00788:  DATA 53,65
0078A:  DATA 6E,64
0078C:  DATA 69,6E
0078E:  DATA 67,20
00790:  DATA 41,43
00792:  DATA 4D,44
00794:  DATA 34,31
00796:  DATA 20,63
00798:  DATA 6F,6D
0079A:  DATA 6D,61
0079C:  DATA 6E,64
0079E:  DATA 20,74
007A0:  DATA 6F,20
007A2:  DATA 53,44
007A4:  DATA 20,76
007A6:  DATA 65,72
007A8:  DATA 20,32
007AA:  DATA 20,63
007AC:  DATA 61,72
007AE:  DATA 64,0D
007B0:  DATA 0A,00
007B2:  DATA 40,46
007B4:  DATA 53,3A
007B6:  DATA 52,65
007B8:  DATA 73,70
007BA:  DATA 6F,6E
007BC:  DATA 73,65
007BE:  DATA 20,66
007C0:  DATA 72,6F
007C2:  DATA 6D,20
007C4:  DATA 73,65
007C6:  DATA 6E,64
007C8:  DATA 69,6E
007CA:  DATA 67,20
007CC:  DATA 41,43
007CE:  DATA 4D,44
007D0:  DATA 34,31
007D2:  DATA 20,3D
007D4:  DATA 20,25
007D6:  DATA 30,32
007D8:  DATA 78,2C
007DA:  DATA 20,54
007DC:  DATA 69,6D
007DE:  DATA 65,72
007E0:  DATA 20,3D
007E2:  DATA 20,25
007E4:  DATA 6C,75
007E6:  DATA 0D,0A
007E8:  DATA 00,00
007EA:  DATA 40,46
007EC:  DATA 53,3A
007EE:  DATA 52,65
007F0:  DATA 73,70
007F2:  DATA 6F,6E
007F4:  DATA 73,65
007F6:  DATA 20,74
007F8:  DATA 6F,20
007FA:  DATA 43,4D
007FC:  DATA 44,35
007FE:  DATA 38,20
00800:  DATA 3D,20
00802:  DATA 25,78
00804:  DATA 0D,0A
00806:  DATA 00,00
00808:  DATA 40,46
0080A:  DATA 53,3A
0080C:  DATA 53,65
0080E:  DATA 6E,74
00810:  DATA 20,43
00812:  DATA 4D,44
00814:  DATA 20,35
00816:  DATA 38,2C
00818:  DATA 20,54
0081A:  DATA 69,6D
0081C:  DATA 65,72
0081E:  DATA 20,76
00820:  DATA 61,6C
00822:  DATA 75,65
00824:  DATA 20,3D
00826:  DATA 20,25
00828:  DATA 6C,75
0082A:  DATA 2C,20
0082C:  DATA 6F,63
0082E:  DATA 72,20
00830:  DATA 3D,20
00832:  DATA 25,30
00834:  DATA 32,78
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 0D,0A
00844:  DATA 00,00
00846:  DATA 40,46
00848:  DATA 53,3A
0084A:  DATA 43,61
0084C:  DATA 72,64
0084E:  DATA 20,43
00850:  DATA 41,4E
00852:  DATA 4E,4F
00854:  DATA 54,20
00856:  DATA 77,6F
00858:  DATA 72,6B
0085A:  DATA 20,56
0085C:  DATA 64,64
0085E:  DATA 20,72
00860:  DATA 61,6E
00862:  DATA 67,65
00864:  DATA 20,6F
00866:  DATA 66,20
00868:  DATA 32,2E
0086A:  DATA 37,2D
0086C:  DATA 33,2E
0086E:  DATA 36,20
00870:  DATA 76,6F
00872:  DATA 6C,74
00874:  DATA 73,0D
00876:  DATA 0A,00
00878:  DATA 40,46
0087A:  DATA 53,3A
0087C:  DATA 4E,6F
0087E:  DATA 74,20
00880:  DATA 61,6E
00882:  DATA 20,53
00884:  DATA 44,53
00886:  DATA 43,20
00888:  DATA 6F,72
0088A:  DATA 20,53
0088C:  DATA 44,48
0088E:  DATA 43,20
00890:  DATA 63,61
00892:  DATA 72,64
00894:  DATA 2C,20
00896:  DATA 54,65
00898:  DATA 73,74
0089A:  DATA 69,6E
0089C:  DATA 67,20
0089E:  DATA 66,6F
008A0:  DATA 72,20
008A2:  DATA 53,44
008A4:  DATA 20,56
008A6:  DATA 65,72
008A8:  DATA 31,20
008AA:  DATA 6F,72
008AC:  DATA 20,4D
008AE:  DATA 4D,43
008B0:  DATA 20,43
008B2:  DATA 61,72
008B4:  DATA 64,0D
008B6:  DATA 0A,00
008B8:  DATA 40,46
008BA:  DATA 53,3A
008BC:  DATA 52,65
008BE:  DATA 73,70
008C0:  DATA 6F,6E
008C2:  DATA 73,65
008C4:  DATA 20,66
008C6:  DATA 72,6F
008C8:  DATA 6D,20
008CA:  DATA 47,4F
008CC:  DATA 5F,49
008CE:  DATA 44,4C
008D0:  DATA 45,20
008D2:  DATA 3D,20
008D4:  DATA 25,30
008D6:  DATA 32,78
008D8:  DATA 0D,0A
008DA:  DATA 00,00
008DC:  DATA 40,46
008DE:  DATA 53,3A
008E0:  DATA 52,65
008E2:  DATA 73,70
008E4:  DATA 6F,6E
008E6:  DATA 73,65
008E8:  DATA 20,66
008EA:  DATA 72,6F
008EC:  DATA 6D,20
008EE:  DATA 53,44
008F0:  DATA 5F,43
008F2:  DATA 4D,44
008F4:  DATA 5F,53
008F6:  DATA 45,4E
008F8:  DATA 44,5F
008FA:  DATA 4F,50
008FC:  DATA 5F,43
008FE:  DATA 4F,4E
00900:  DATA 44,20
00902:  DATA 3D,20
00904:  DATA 25,30
00906:  DATA 32,78
00908:  DATA 2C,20
0090A:  DATA 54,69
0090C:  DATA 6D,65
0090E:  DATA 72,20
00910:  DATA 3D,20
00912:  DATA 25,6C
00914:  DATA 75,0D
00916:  DATA 0A,00
00918:  DATA 40,46
0091A:  DATA 53,3A
0091C:  DATA 41,74
0091E:  DATA 74,65
00920:  DATA 6D,70
00922:  DATA 74,69
00924:  DATA 6E,67
00926:  DATA 20,53
00928:  DATA 44,76
0092A:  DATA 31,20
0092C:  DATA 76,65
0092E:  DATA 72,73
00930:  DATA 75,73
00932:  DATA 20,4D
00934:  DATA 4D,43
00936:  DATA 20,49
00938:  DATA 44,2C
0093A:  DATA 20,52
0093C:  DATA 65,73
0093E:  DATA 70,6F
00940:  DATA 6E,73
00942:  DATA 65,20
00944:  DATA 66,72
00946:  DATA 6F,6D
00948:  DATA 20,53
0094A:  DATA 44,5F
0094C:  DATA 43,4D
0094E:  DATA 44,5F
00950:  DATA 41,50
00952:  DATA 50,4C
00954:  DATA 5F,43
00956:  DATA 4D,44
00958:  DATA 20,3D
0095A:  DATA 20,25
0095C:  DATA 30,32
0095E:  DATA 78,0D
00960:  DATA 0A,00
00962:  DATA 40,46
00964:  DATA 53,3A
00966:  DATA 49,6E
00968:  DATA 76,61
0096A:  DATA 6C,69
0096C:  DATA 64,20
0096E:  DATA 72,65
00970:  DATA 73,70
00972:  DATA 6F,6E
00974:  DATA 73,65
00976:  DATA 20,74
00978:  DATA 6F,20
0097A:  DATA 53,44
0097C:  DATA 5F,41
0097E:  DATA 43,4D
00980:  DATA 44,34
00982:  DATA 31,2C
00984:  DATA 20,72
00986:  DATA 65,73
00988:  DATA 70,6F
0098A:  DATA 6E,73
0098C:  DATA 65,20
0098E:  DATA 3D,20
00990:  DATA 25,30
00992:  DATA 32,58
00994:  DATA 2C,20
00996:  DATA 72,65
00998:  DATA 69,6E
0099A:  DATA 69,74
0099C:  DATA 69,61
0099E:  DATA 6C,69
009A0:  DATA 7A,69
009A2:  DATA 6E,67
009A4:  DATA 20,61
009A6:  DATA 73,20
009A8:  DATA 4D,4D
009AA:  DATA 43,0D
009AC:  DATA 0A,00
009AE:  DATA 40,46
009B0:  DATA 53,3A
009B2:  DATA 46,61
009B4:  DATA 69,6C
009B6:  DATA 65,64
009B8:  DATA 20,74
009BA:  DATA 6F,20
009BC:  DATA 69,6E
009BE:  DATA 69,74
009C0:  DATA 69,61
009C2:  DATA 6C,69
009C4:  DATA 7A,65
009C6:  DATA 20,61
009C8:  DATA 73,20
009CA:  DATA 4D,4D
009CC:  DATA 43,2C
009CE:  DATA 20,72
009D0:  DATA 65,73
009D2:  DATA 70,6F
009D4:  DATA 6E,73
009D6:  DATA 65,20
009D8:  DATA 3D,20
009DA:  DATA 25,30
009DC:  DATA 32,58
009DE:  DATA 2C,20
009E0:  DATA 65,78
009E2:  DATA 69,74
009E4:  DATA 69,6E
009E6:  DATA 67,0D
009E8:  DATA 0A,00
009EA:  DATA 40,46
009EC:  DATA 53,3A
009EE:  DATA 43,61
009F0:  DATA 72,64
009F2:  DATA 20,66
009F4:  DATA 61,69
009F6:  DATA 6C,65
009F8:  DATA 64,20
009FA:  DATA 74,6F
009FC:  DATA 20,72
009FE:  DATA 65,73
00A00:  DATA 70,6F
00A02:  DATA 6E,64
00A04:  DATA 20,63
00A06:  DATA 6F,72
00A08:  DATA 72,65
00A0A:  DATA 63,6C
00A0C:  DATA 79,20
00A0E:  DATA 61,66
00A10:  DATA 74,65
00A12:  DATA 72,20
00A14:  DATA 53,44
00A16:  DATA 5F,43
00A18:  DATA 4D,44
00A1A:  DATA 5F,53
00A1C:  DATA 45,4E
00A1E:  DATA 44,5F
00A20:  DATA 4F,50
00A22:  DATA 5F,43
00A24:  DATA 4F,4E
00A26:  DATA 44,2C
00A28:  DATA 20,72
00A2A:  DATA 65,73
00A2C:  DATA 70,6F
00A2E:  DATA 6E,73
00A30:  DATA 65,20
00A32:  DATA 3D,20
00A34:  DATA 25,30
00A36:  DATA 32,58
00A38:  DATA 2C,20
00A3A:  DATA 54,69
00A3C:  DATA 6D,65
00A3E:  DATA 72,20
00A40:  DATA 3D,20
00A42:  DATA 25,6C
00A44:  DATA 75,0D
00A46:  DATA 0A,00
00A48:  DATA 40,46
00A4A:  DATA 53,3A
00A4C:  DATA 53,65
00A4E:  DATA 74,74
00A50:  DATA 69,6E
00A52:  DATA 67,20
00A54:  DATA 62,6C
00A56:  DATA 6F,63
00A58:  DATA 6B,20
00A5A:  DATA 6C,65
00A5C:  DATA 6E,67
00A5E:  DATA 74,68
00A60:  DATA 0D,0A
00A62:  DATA 00,00
00A64:  DATA 40,46
00A66:  DATA 53,3A
00A68:  DATA 45,72
00A6A:  DATA 72,6F
00A6C:  DATA 72,20
00A6E:  DATA 73,65
00A70:  DATA 74,74
00A72:  DATA 69,6E
00A74:  DATA 67,20
00A76:  DATA 62,6C
00A78:  DATA 6F,63
00A7A:  DATA 6B,20
00A7C:  DATA 6C,65
00A7E:  DATA 6E,67
00A80:  DATA 74,68
00A82:  DATA 2C,20
00A84:  DATA 72,65
00A86:  DATA 73,70
00A88:  DATA 6F,6E
00A8A:  DATA 73,65
00A8C:  DATA 20,3D
00A8E:  DATA 20,25
00A90:  DATA 30,32
00A92:  DATA 78,2C
00A94:  DATA 20,74
00A96:  DATA 69,6D
00A98:  DATA 65,72
00A9A:  DATA 20,3D
00A9C:  DATA 20,25
00A9E:  DATA 6C,75
00AA0:  DATA 0D,0A
00AA2:  DATA 00,00
00AA4:  DATA 40,46
00AA6:  DATA 53,3A
00AA8:  DATA 43,61
00AAA:  DATA 72,64
00AAC:  DATA 20,54
00AAE:  DATA 79,70
00AB0:  DATA 65,20
00AB2:  DATA 44,69
00AB4:  DATA 73,63
00AB6:  DATA 6F,76
00AB8:  DATA 65,72
00ABA:  DATA 79,20
00ABC:  DATA 45,72
00ABE:  DATA 72,6F
00AC0:  DATA 72,0D
00AC2:  DATA 0A,00
00AC4:  DATA 40,46
00AC6:  DATA 53,3A
00AC8:  DATA 4D,4D
00ACA:  DATA 43,20
00ACC:  DATA 43,61
00ACE:  DATA 72,64
00AD0:  DATA 20,66
00AD2:  DATA 6F,75
00AD4:  DATA 6E,64
00AD6:  DATA 0D,0A
00AD8:  DATA 00,00
00ADA:  DATA 40,46
00ADC:  DATA 53,3A
00ADE:  DATA 53,44
00AE0:  DATA 76,31
00AE2:  DATA 20,43
00AE4:  DATA 61,72
00AE6:  DATA 64,20
00AE8:  DATA 66,6F
00AEA:  DATA 75,6E
00AEC:  DATA 64,0D
00AEE:  DATA 0A,00
00AF0:  DATA 40,46
00AF2:  DATA 53,3A
00AF4:  DATA 53,44
00AF6:  DATA 53,43
00AF8:  DATA 20,43
00AFA:  DATA 61,72
00AFC:  DATA 64,20
00AFE:  DATA 66,6F
00B00:  DATA 75,6E
00B02:  DATA 64,0D
00B04:  DATA 0A,00
00B06:  DATA 40,46
00B08:  DATA 53,3A
00B0A:  DATA 53,44
00B0C:  DATA 48,43
00B0E:  DATA 20,43
00B10:  DATA 61,72
00B12:  DATA 64,20
00B14:  DATA 66,6F
00B16:  DATA 75,6E
00B18:  DATA 64,0D
00B1A:  DATA 0A,00
00B1C:  DATA 40,46
00B1E:  DATA 53,3A
00B20:  DATA 43,61
00B22:  DATA 72,64
00B24:  DATA 20,54
00B26:  DATA 79,70
00B28:  DATA 65,20
00B2A:  DATA 44,69
00B2C:  DATA 73,63
00B2E:  DATA 6F,76
00B30:  DATA 65,72
00B32:  DATA 79,20
00B34:  DATA 45,72
00B36:  DATA 72,6F
00B38:  DATA 72,2C
00B3A:  DATA 20,43
00B3C:  DATA 61,72
00B3E:  DATA 64,20
00B40:  DATA 3D,20
00B42:  DATA 25,30
00B44:  DATA 32,58
00B46:  DATA 0D,0A
00B48:  DATA 00,00
00B4A:  DATA 40,46
00B4C:  DATA 53,3A
00B4E:  DATA 43,61
00B50:  DATA 72,64
00B52:  DATA 20,72
00B54:  DATA 65,73
00B56:  DATA 65,74
00B58:  DATA 20,73
00B5A:  DATA 75,63
00B5C:  DATA 63,65
00B5E:  DATA 73,73
00B60:  DATA 20,2D
00B62:  DATA 20,43
00B64:  DATA 6D,64
00B66:  DATA 20,74
00B68:  DATA 6F,20
00B6A:  DATA 52,65
00B6C:  DATA 61,64
00B6E:  DATA 79,20
00B70:  DATA 63,6F
00B72:  DATA 75,6E
00B74:  DATA 74,20
00B76:  DATA 3D,20
00B78:  DATA 25,6C
00B7A:  DATA 75,0D
00B7C:  DATA 0A,00
00B7E:  DATA 40,46
00B80:  DATA 53,3A
00B82:  DATA 53,50
00B84:  DATA 49,20
00B86:  DATA 62,75
00B88:  DATA 73,20
00B8A:  DATA 73,70
00B8C:  DATA 65,65
00B8E:  DATA 64,20
00B90:  DATA 73,65
00B92:  DATA 74,20
00B94:  DATA 74,6F
00B96:  DATA 20,68
00B98:  DATA 69,67
00B9A:  DATA 68,0D
00B9C:  DATA 0A,00
00B9E:  DATA 40,46
00BA0:  DATA 53,3A
00BA2:  DATA 43,61
00BA4:  DATA 72,64
00BA6:  DATA 20,61
00BA8:  DATA 63,74
00BAA:  DATA 69,76
00BAC:  DATA 61,74
00BAE:  DATA 65,20
00BB0:  DATA 66,61
00BB2:  DATA 69,6C
00BB4:  DATA 75,72
00BB6:  DATA 65,2C
00BB8:  DATA 20,72
00BBA:  DATA 65,73
00BBC:  DATA 70,6F
00BBE:  DATA 6E,73
00BC0:  DATA 65,20
00BC2:  DATA 3D,20
00BC4:  DATA 25,30
00BC6:  DATA 32,58
00BC8:  DATA 2C,20
00BCA:  DATA 54,69
00BCC:  DATA 6D,65
00BCE:  DATA 72,20
00BD0:  DATA 3D,20
00BD2:  DATA 25,6C
00BD4:  DATA 75,0D
00BD6:  DATA 0A,00
00BD8:  DATA 40,46
00BDA:  DATA 53,3A
00BDC:  DATA 43,61
00BDE:  DATA 72,64
00BE0:  DATA 20,61
00BE2:  DATA 63,74
00BE4:  DATA 69,76
00BE6:  DATA 61,74
00BE8:  DATA 65,20
00BEA:  DATA 73,75
00BEC:  DATA 63,63
00BEE:  DATA 65,73
00BF0:  DATA 73,20
00BF2:  DATA 6F,6E
00BF4:  DATA 20,61
00BF6:  DATA 74,74
00BF8:  DATA 65,6D
00BFA:  DATA 70,74
00BFC:  DATA 20,25
00BFE:  DATA 6C,75
00C00:  DATA 0D,0A
00C02:  DATA 00,00
00C04:  DATA 46,41
00C06:  DATA 54,20
00C08:  DATA 61,74
00C0A:  DATA 20,73
00C0C:  DATA 65,63
00C0E:  DATA 74,6F
00C10:  DATA 72,20
00C12:  DATA 30,0D
00C14:  DATA 0A,00
00C16:  DATA 54,59
00C18:  DATA 50,45
00C1A:  DATA 20,63
00C1C:  DATA 6F,6D
00C1E:  DATA 6D,61
00C20:  DATA 6E,64
00C22:  DATA 20,45
00C24:  DATA 52,52
00C26:  DATA 4F,52
00C28:  DATA 0D,0A
00C2A:  DATA 00,00
00C2C:  DATA 40,46
00C2E:  DATA 53,3A
00C30:  DATA 20,25
00C32:  DATA 73,0D
00C34:  DATA 0A,00
00C36:  DATA 40,46
00C38:  DATA 53,3A
00C3A:  DATA 20,25
00C3C:  DATA 73,0D
00C3E:  DATA 0A,00
00C40:  DATA 2A,2A
00C42:  DATA 20,40
00C44:  DATA 46,53
00C46:  DATA 3A,20
00C48:  DATA 45,52
00C4A:  DATA 52,4F
00C4C:  DATA 52,0D
00C4E:  DATA 0A,00
00C50:  DATA 20,20
00C52:  DATA 20,4E
00C54:  DATA 6F,45
00C56:  DATA 72,72
00C58:  DATA 6F,72
00C5A:  DATA 0D,0A
00C5C:  DATA 00,00
00C5E:  DATA 20,20
00C60:  DATA 20,4D
00C62:  DATA 65,64
00C64:  DATA 69,61
00C66:  DATA 20,4E
00C68:  DATA 6F,74
00C6A:  DATA 20,52
00C6C:  DATA 65,61
00C6E:  DATA 64,79
00C70:  DATA 0D,0A
00C72:  DATA 00,00
00C74:  DATA 20,20
00C76:  DATA 20,46
00C78:  DATA 69,6C
00C7A:  DATA 65,20
00C7C:  DATA 4E,6F
00C7E:  DATA 74,20
00C80:  DATA 46,6F
00C82:  DATA 75,6E
00C84:  DATA 64,0D
00C86:  DATA 0A,00
00C88:  DATA 20,20
00C8A:  DATA 20,49
00C8C:  DATA 6E,76
00C8E:  DATA 61,6C
00C90:  DATA 69,64
00C92:  DATA 20,50
00C94:  DATA 61,74
00C96:  DATA 68,0D
00C98:  DATA 0A,00
00C9A:  DATA 20,20
00C9C:  DATA 20,49
00C9E:  DATA 6E,76
00CA0:  DATA 61,6C
00CA2:  DATA 69,64
00CA4:  DATA 20,4E
00CA6:  DATA 61,6D
00CA8:  DATA 65,0D
00CAA:  DATA 0A,00
00CAC:  DATA 20,20
00CAE:  DATA 20,41
00CB0:  DATA 63,63
00CB2:  DATA 65,73
00CB4:  DATA 73,20
00CB6:  DATA 44,65
00CB8:  DATA 6E,69
00CBA:  DATA 65,64
00CBC:  DATA 0D,0A
00CBE:  DATA 00,00
00CC0:  DATA 20,20
00CC2:  DATA 20,44
00CC4:  DATA 69,73
00CC6:  DATA 6B,20
00CC8:  DATA 46,75
00CCA:  DATA 6C,6C
00CCC:  DATA 0D,0A
00CCE:  DATA 00,00
00CD0:  DATA 20,20
00CD2:  DATA 20,52
00CD4:  DATA 65,61
00CD6:  DATA 64,2F
00CD8:  DATA 57,72
00CDA:  DATA 69,74
00CDC:  DATA 65,20
00CDE:  DATA 45,72
00CE0:  DATA 72,6F
00CE2:  DATA 72,0D
00CE4:  DATA 0A,00
00CE6:  DATA 20,20
00CE8:  DATA 20,49
00CEA:  DATA 6E,63
00CEC:  DATA 6F,72
00CEE:  DATA 72,65
00CF0:  DATA 63,74
00CF2:  DATA 20,4D
00CF4:  DATA 65,64
00CF6:  DATA 69,61
00CF8:  DATA 20,43
00CFA:  DATA 68,61
00CFC:  DATA 6E,67
00CFE:  DATA 65,0D
00D00:  DATA 0A,00
00D02:  DATA 20,20
00D04:  DATA 20,57
00D06:  DATA 72,69
00D08:  DATA 74,65
00D0A:  DATA 20,50
00D0C:  DATA 72,6F
00D0E:  DATA 74,65
00D10:  DATA 63,74
00D12:  DATA 65,64
00D14:  DATA 0D,0A
00D16:  DATA 00,00
00D18:  DATA 20,20
00D1A:  DATA 20,4E
00D1C:  DATA 6F,74
00D1E:  DATA 20,45
00D20:  DATA 6E,61
00D22:  DATA 62,6C
00D24:  DATA 65,64
00D26:  DATA 0D,0A
00D28:  DATA 00,00
00D2A:  DATA 20,20
00D2C:  DATA 20,4E
00D2E:  DATA 6F,20
00D30:  DATA 46,69
00D32:  DATA 6C,65
00D34:  DATA 20,53
00D36:  DATA 79,73
00D38:  DATA 74,65
00D3A:  DATA 6D,0D
00D3C:  DATA 0A,00
00D3E:  DATA 61,70
00D40:  DATA 70,65
00D42:  DATA 6E,64
00D44:  DATA 3A,20
00D46:  DATA 46,53
00D48:  DATA 20,45
00D4A:  DATA 52,52
00D4C:  DATA 4F,52
00D4E:  DATA 20,6F
00D50:  DATA 6E,20
00D52:  DATA 66,69
00D54:  DATA 6C,65
00D56:  DATA 5F,6F
00D58:  DATA 70,65
00D5A:  DATA 6E,0D
00D5C:  DATA 0A,00
00D5E:  DATA 40,46
00D60:  DATA 53,3A
00D62:  DATA 57,72
00D64:  DATA 69,74
00D66:  DATA 69,6E
00D68:  DATA 67,0D
00D6A:  DATA 0A,5B
00D6C:  DATA 25,73
00D6E:  DATA 5D,0D
00D70:  DATA 0A,00
00D72:  DATA 40,46
00D74:  DATA 53,3A
00D76:  DATA 45,52
00D78:  DATA 52,4F
00D7A:  DATA 52,5B
00D7C:  DATA 61,70
00D7E:  DATA 70,65
00D80:  DATA 6E,64
00D82:  DATA 5D,0D
00D84:  DATA 0A,00
00D86:  DATA 40,46
00D88:  DATA 53,3A
00D8A:  DATA 43,6C
00D8C:  DATA 6F,73
00D8E:  DATA 69,6E
00D90:  DATA 67,0D
00D92:  DATA 0A,00
00D94:  DATA 40,52
00D96:  DATA 54,43
00D98:  DATA 3A,25
00D9A:  DATA 30,32
00D9C:  DATA 75,2F
00D9E:  DATA 00,00
00DA0:  DATA 40,52
00DA2:  DATA 54,43
00DA4:  DATA 3A,25
00DA6:  DATA 30,32
00DA8:  DATA 75,2F
00DAA:  DATA 00,00
00DAC:  DATA 40,41
00DAE:  DATA 4C,4D
00DB0:  DATA 3A,25
00DB2:  DATA 30,32
00DB4:  DATA 75,2F
00DB6:  DATA 00,00
00DB8:  DATA 40,41
00DBA:  DATA 4C,4D
00DBC:  DATA 3A,25
00DBE:  DATA 30,32
00DC0:  DATA 75,2F
00DC2:  DATA 00,00
00DC4:  DATA 40,41
00DC6:  DATA 4C,4D
00DC8:  DATA 0D,0A
00DCA:  DATA 00,00
*
00E30:  TBLRD*+
00E32:  MOVF   FF5,F
00E34:  BZ    0E58
00E36:  MOVFF  FF6,A10
00E3A:  MOVFF  FF7,A11
00E3E:  MOVFF  FF8,A12
00E42:  MOVF   FF5,W
00E44:  BTFSS  F9E.4
00E46:  BRA    0E44
00E48:  MOVWF  FAD
00E4A:  MOVFF  A10,FF6
00E4E:  MOVFF  A11,FF7
00E52:  MOVFF  A12,FF8
00E56:  BRA    0E30
00E58:  RETURN 0
*
00EBA:  DATA 3F,40
00EBC:  DATA 42,53
00EBE:  DATA 59,0D
00EC0:  DATA 0A,00
00EC2:  DATA 40,52
00EC4:  DATA 44,59
00EC6:  DATA 0D,0A
00EC8:  DATA 00,00
*
00F0A:  DATA 40,5B
00F0C:  DATA 4F,5D
00F0E:  DATA 0D,0A
00F10:  DATA 00,00
00F12:  DATA 40,43
00F14:  DATA 4D,44
00F16:  DATA 20,74
00F18:  DATA 6F,6F
00F1A:  DATA 20,6C
00F1C:  DATA 6F,6E
00F1E:  DATA 67,0D
00F20:  DATA 0A,00
00F22:  DATA 40,5B
00F24:  DATA 43,5D
00F26:  DATA 0D,0A
00F28:  DATA 00,00
00F2A:  DATA 40,53
00F2C:  DATA 4C,45
00F2E:  DATA 45,50
00F30:  DATA 0D,0A
00F32:  DATA 00,00
00F34:  DATA 40,4D
00F36:  DATA 45,52
00F38:  DATA 2C,25
00F3A:  DATA 4C,75
00F3C:  DATA 2C,25
00F3E:  DATA 4C,75
00F40:  DATA 0D,0A
00F42:  DATA 00,00
00F44:  DATA 6D,3A
00F46:  DATA 25,75
00F48:  DATA 2C,25
00F4A:  DATA 75,20
00F4C:  DATA 63,3A
00F4E:  DATA 25,4C
00F50:  DATA 75,2C
00F52:  DATA 25,4C
00F54:  DATA 75,2C
00F56:  DATA 25,4C
00F58:  DATA 75,0D
00F5A:  DATA 0A,00
00F5C:  MOVLB  A
00F5E:  MOVF   x1B,W
00F60:  CLRF   01
00F62:  SUBWF  x1A,W
00F64:  BC    0F6C
00F66:  MOVFF  A1A,00
00F6A:  BRA    0F84
00F6C:  CLRF   00
00F6E:  MOVLW  08
00F70:  MOVWF  x1C
00F72:  RLCF   x1A,F
00F74:  RLCF   00,F
00F76:  MOVF   x1B,W
00F78:  SUBWF  00,W
00F7A:  BTFSC  FD8.0
00F7C:  MOVWF  00
00F7E:  RLCF   01,F
00F80:  DECFSZ x1C,F
00F82:  BRA    0F72
00F84:  MOVLB  0
00F86:  RETURN 0
00F88:  MOVF   01,W
00F8A:  MOVFF  A18,A1A
00F8E:  MOVLW  64
00F90:  MOVLB  A
00F92:  MOVWF  x1B
00F94:  MOVLB  0
00F96:  RCALL  0F5C
00F98:  MOVFF  00,A18
00F9C:  MOVF   01,W
00F9E:  MOVLW  30
00FA0:  BNZ   0FB2
00FA2:  MOVLB  A
00FA4:  BTFSS  x19.1
00FA6:  BRA    0FC4
00FA8:  BTFSC  x19.3
00FAA:  BRA    0FC4
00FAC:  BTFSC  x19.4
00FAE:  MOVLW  20
00FB0:  BRA    0FBA
00FB2:  MOVLB  A
00FB4:  BCF    x19.3
00FB6:  BCF    x19.4
00FB8:  BSF    x19.0
00FBA:  ADDWF  01,F
00FBC:  MOVF   01,W
00FBE:  BTFSS  F9E.4
00FC0:  BRA    0FBE
00FC2:  MOVWF  FAD
00FC4:  MOVFF  A18,A1A
00FC8:  MOVLW  0A
00FCA:  MOVWF  x1B
00FCC:  MOVLB  0
00FCE:  RCALL  0F5C
00FD0:  MOVFF  00,A18
00FD4:  MOVF   01,W
00FD6:  MOVLW  30
00FD8:  BNZ   0FEA
00FDA:  MOVLB  A
00FDC:  BTFSC  x19.3
00FDE:  BRA    0FF6
00FE0:  BTFSS  x19.0
00FE2:  BRA    0FF6
00FE4:  BTFSC  x19.4
00FE6:  MOVLW  20
00FE8:  MOVLB  0
00FEA:  ADDWF  01,F
00FEC:  MOVF   01,W
00FEE:  BTFSS  F9E.4
00FF0:  BRA    0FEE
00FF2:  MOVWF  FAD
00FF4:  MOVLB  A
00FF6:  MOVLW  30
00FF8:  ADDWF  x18,F
00FFA:  MOVF   x18,W
00FFC:  BTFSS  F9E.4
00FFE:  BRA    0FFC
01000:  MOVWF  FAD
01002:  MOVLB  0
01004:  RETURN 0
01006:  TBLRD*+
01008:  MOVFF  FF6,A19
0100C:  MOVFF  FF7,A1A
01010:  MOVFF  FF8,A1B
01014:  MOVF   FF5,W
01016:  BTFSS  F9E.4
01018:  BRA    1016
0101A:  MOVWF  FAD
0101C:  MOVFF  A19,FF6
01020:  MOVFF  A1A,FF7
01024:  MOVFF  A1B,FF8
01028:  MOVLB  A
0102A:  DECFSZ x18,F
0102C:  BRA    1030
0102E:  BRA    1034
01030:  MOVLB  0
01032:  BRA    1006
01034:  MOVLB  0
01036:  RETURN 0
01038:  BTFSC  FD8.1
0103A:  BRA    1044
0103C:  MOVLW  0A
0103E:  MOVWF  FEA
01040:  MOVLW  2C
01042:  MOVWF  FE9
01044:  CLRF   00
01046:  CLRF   01
01048:  CLRF   02
0104A:  CLRF   03
0104C:  MOVLB  A
0104E:  CLRF   x2C
01050:  CLRF   x2D
01052:  CLRF   x2E
01054:  CLRF   x2F
01056:  MOVF   x2B,W
01058:  IORWF  x2A,W
0105A:  IORWF  x29,W
0105C:  IORWF  x28,W
0105E:  BZ    10B8
01060:  MOVLW  20
01062:  MOVWF  x30
01064:  BCF    FD8.0
01066:  RLCF   x24,F
01068:  RLCF   x25,F
0106A:  RLCF   x26,F
0106C:  RLCF   x27,F
0106E:  RLCF   x2C,F
01070:  RLCF   x2D,F
01072:  RLCF   x2E,F
01074:  RLCF   x2F,F
01076:  MOVF   x2B,W
01078:  SUBWF  x2F,W
0107A:  BNZ   108C
0107C:  MOVF   x2A,W
0107E:  SUBWF  x2E,W
01080:  BNZ   108C
01082:  MOVF   x29,W
01084:  SUBWF  x2D,W
01086:  BNZ   108C
01088:  MOVF   x28,W
0108A:  SUBWF  x2C,W
0108C:  BNC   10AC
0108E:  MOVF   x28,W
01090:  SUBWF  x2C,F
01092:  MOVF   x29,W
01094:  BTFSS  FD8.0
01096:  INCFSZ x29,W
01098:  SUBWF  x2D,F
0109A:  MOVF   x2A,W
0109C:  BTFSS  FD8.0
0109E:  INCFSZ x2A,W
010A0:  SUBWF  x2E,F
010A2:  MOVF   x2B,W
010A4:  BTFSS  FD8.0
010A6:  INCFSZ x2B,W
010A8:  SUBWF  x2F,F
010AA:  BSF    FD8.0
010AC:  RLCF   00,F
010AE:  RLCF   01,F
010B0:  RLCF   02,F
010B2:  RLCF   03,F
010B4:  DECFSZ x30,F
010B6:  BRA    1064
010B8:  MOVFF  A2C,FEF
010BC:  MOVFF  A2D,FEC
010C0:  MOVFF  A2E,FEC
010C4:  MOVFF  A2F,FEC
010C8:  MOVLB  0
010CA:  RETURN 0
010CC:  MOVF   FE9,W
010CE:  MOVLB  A
010D0:  MOVWF  x1C
010D2:  MOVLW  3B
010D4:  MOVWF  x23
010D6:  MOVLW  9A
010D8:  MOVWF  x22
010DA:  MOVLW  CA
010DC:  MOVWF  x21
010DE:  CLRF   x20
010E0:  MOVLW  0A
010E2:  MOVWF  x1E
010E4:  BSF    FD8.1
010E6:  MOVLW  0A
010E8:  MOVWF  FEA
010EA:  MOVLW  18
010EC:  MOVWF  FE9
010EE:  MOVFF  A1B,A27
010F2:  MOVFF  A1A,A26
010F6:  MOVFF  A19,A25
010FA:  MOVFF  A18,A24
010FE:  MOVFF  A23,A2B
01102:  MOVFF  A22,A2A
01106:  MOVFF  A21,A29
0110A:  MOVFF  A20,A28
0110E:  MOVLB  0
01110:  RCALL  1038
01112:  MOVF   01,W
01114:  MOVF   00,F
01116:  BNZ   113E
01118:  MOVLB  A
0111A:  MOVF   x1E,W
0111C:  XORLW  01
0111E:  BTFSS  FD8.2
01120:  BRA    1126
01122:  MOVLB  0
01124:  BRA    113E
01126:  MOVF   x1C,W
01128:  BZ    1142
0112A:  ANDLW  0F
0112C:  SUBWF  x1E,W
0112E:  BZ    1132
01130:  BC    114E
01132:  BTFSC  x1C.7
01134:  BRA    114E
01136:  BTFSC  x1C.6
01138:  BRA    1142
0113A:  MOVLW  20
0113C:  BRA    1144
0113E:  MOVLB  A
01140:  CLRF   x1C
01142:  MOVLW  30
01144:  ADDWF  00,F
01146:  MOVF   00,W
01148:  BTFSS  F9E.4
0114A:  BRA    1148
0114C:  MOVWF  FAD
0114E:  BCF    FD8.1
01150:  MOVFF  A23,A27
01154:  MOVFF  A22,A26
01158:  MOVFF  A21,A25
0115C:  MOVFF  A20,A24
01160:  CLRF   x2B
01162:  CLRF   x2A
01164:  CLRF   x29
01166:  MOVLW  0A
01168:  MOVWF  x28
0116A:  MOVLB  0
0116C:  RCALL  1038
0116E:  MOVFF  03,A23
01172:  MOVFF  02,A22
01176:  MOVFF  01,A21
0117A:  MOVFF  00,A20
0117E:  MOVLB  A
01180:  DECFSZ x1E,F
01182:  BRA    10E4
01184:  MOVLB  0
01186:  RETURN 0
01188:  MOVFF  FEA,A20
0118C:  MOVFF  FE9,A1F
01190:  MOVLB  A
01192:  SWAPF  x19,W
01194:  IORLW  F0
01196:  MOVWF  x1B
01198:  ADDWF  x1B,F
0119A:  ADDLW  E2
0119C:  MOVWF  x1C
0119E:  ADDLW  32
011A0:  MOVWF  x1E
011A2:  MOVF   x19,W
011A4:  ANDLW  0F
011A6:  ADDWF  x1C,F
011A8:  ADDWF  x1C,F
011AA:  ADDWF  x1E,F
011AC:  ADDLW  E9
011AE:  MOVWF  x1D
011B0:  ADDWF  x1D,F
011B2:  ADDWF  x1D,F
011B4:  SWAPF  x18,W
011B6:  ANDLW  0F
011B8:  ADDWF  x1D,F
011BA:  ADDWF  x1E,F
011BC:  RLCF   x1D,F
011BE:  RLCF   x1E,F
011C0:  COMF   x1E,F
011C2:  RLCF   x1E,F
011C4:  MOVF   x18,W
011C6:  ANDLW  0F
011C8:  ADDWF  x1E,F
011CA:  RLCF   x1B,F
011CC:  MOVLW  07
011CE:  MOVWF  x1A
011D0:  MOVLW  0A
011D2:  DECF   x1D,F
011D4:  ADDWF  x1E,F
011D6:  BNC   11D2
011D8:  DECF   x1C,F
011DA:  ADDWF  x1D,F
011DC:  BNC   11D8
011DE:  DECF   x1B,F
011E0:  ADDWF  x1C,F
011E2:  BNC   11DE
011E4:  DECF   x1A,F
011E6:  ADDWF  x1B,F
011E8:  BNC   11E4
011EA:  MOVLW  0A
011EC:  MOVWF  FEA
011EE:  MOVLW  1A
011F0:  MOVWF  FE9
011F2:  MOVLW  07
011F4:  ANDWF  x1F,W
011F6:  BCF    x1F.6
011F8:  ADDWF  FE9,F
011FA:  MOVLW  00
011FC:  ADDWFC FEA,F
011FE:  MOVF   FE9,W
01200:  SUBLW  1E
01202:  BNZ   120C
01204:  MOVF   FEA,W
01206:  SUBLW  0A
01208:  BNZ   120C
0120A:  BSF    x1F.6
0120C:  MOVF   FEF,W
0120E:  MOVWF  00
01210:  BNZ   1222
01212:  BTFSC  x1F.6
01214:  BRA    1222
01216:  BTFSC  x1F.4
01218:  BRA    1232
0121A:  BTFSC  x1F.3
0121C:  BRA    1222
0121E:  MOVLW  20
01220:  BRA    1228
01222:  BSF    x1F.3
01224:  BCF    x1F.4
01226:  MOVLW  30
01228:  ADDWF  00,F
0122A:  MOVF   00,W
0122C:  BTFSS  F9E.4
0122E:  BRA    122C
01230:  MOVWF  FAD
01232:  MOVF   FEE,W
01234:  BTFSS  x1F.6
01236:  BRA    11FE
01238:  MOVLB  0
0123A:  RETURN 0
*
01A40:  DATA 40,4C
01A42:  DATA 50,43
01A44:  DATA 2C,25
01A46:  DATA 4C,75
01A48:  DATA 2C,25
01A4A:  DATA 4C,64
01A4C:  DATA 0D,0A
01A4E:  DATA 00,00
01A50:  DATA 40,4D
01A52:  DATA 4D,45
01A54:  DATA 2C,25
01A56:  DATA 75,2C
01A58:  DATA 25,4C
01A5A:  DATA 64,2C
01A5C:  DATA 25,4C
01A5E:  DATA 75,2C
01A60:  DATA 25,4C
01A62:  DATA 75,2C
01A64:  DATA 25,4C
01A66:  DATA 64,2C
01A68:  DATA 25,4C
01A6A:  DATA 64,0D
01A6C:  DATA 0A,00
01A6E:  DATA 56,41
01A70:  DATA 4C,56
01A72:  DATA 45,20
01A74:  DATA 53,54
01A76:  DATA 4F,50
01A78:  DATA 20,25
01A7A:  DATA 4C,75
01A7C:  DATA 2C,25
01A7E:  DATA 4C,75
01A80:  DATA 0D,0A
01A82:  DATA 00,00
01A84:  DATA 69,6E
01A86:  DATA 64,3A
01A88:  DATA 25,75
01A8A:  DATA 20,2F
01A8C:  DATA 20,70
01A8E:  DATA 68,61
01A90:  DATA 3A,25
01A92:  DATA 75,0D
01A94:  DATA 0A,00
01A96:  DATA 40,52
01A98:  DATA 45,43
01A9A:  DATA 20,2D
01A9C:  DATA 20,68
01A9E:  DATA 6F,6D
01AA0:  DATA 69,6E
01AA2:  DATA 67,20
01AA4:  DATA 73,79
01AA6:  DATA 72,69
01AA8:  DATA 6E,67
01AAA:  DATA 65,20
01AAC:  DATA 61,6E
01AAE:  DATA 64,20
01AB0:  DATA 61,6C
01AB2:  DATA 69,67
01AB4:  DATA 6E,69
01AB6:  DATA 6E,67
01AB8:  DATA 20,76
01ABA:  DATA 61,6C
01ABC:  DATA 76,65
01ABE:  DATA 20,74
01AC0:  DATA 6F,20
01AC2:  DATA 70,6F
01AC4:  DATA 72,74
01AC6:  DATA 20,31
01AC8:  DATA 0D,0A
01ACA:  DATA 00,00
01ACC:  DATA 2C,73
01ACE:  DATA 65,72
01AD0:  DATA 69,61
01AD2:  DATA 6C,20
01AD4:  DATA 77,61
01AD6:  DATA 6B,65
01AD8:  DATA 2D,75
01ADA:  DATA 70,2C
01ADC:  DATA 53,44
01ADE:  DATA 20,69
01AE0:  DATA 6E,69
01AE2:  DATA 74,69
01AE4:  DATA 61,6C
01AE6:  DATA 69,7A
01AE8:  DATA 65,64
01AEA:  DATA 0D,0A
01AEC:  DATA 00,00
01AEE:  DATA 40,52
01AF0:  DATA 53,54
01AF2:  DATA 0D,0A
01AF4:  DATA 00,00
01AF6:  DATA 40,57
01AF8:  DATA 44,54
01AFA:  DATA 0D,0A
01AFC:  DATA 00,00
01AFE:  DATA 2C,72
01B00:  DATA 65,73
01B02:  DATA 74,61
01B04:  DATA 72,74
01B06:  DATA 20,63
01B08:  DATA 61,75
01B0A:  DATA 73,65
01B0C:  DATA 2C,57
01B0E:  DATA 44,20
01B10:  DATA 74,69
01B12:  DATA 6D,65
01B14:  DATA 2D,6F
01B16:  DATA 75,74
01B18:  DATA 0D,0A
01B1A:  DATA 00,00
01B1C:  DATA 40,57
01B1E:  DATA 44,53
01B20:  DATA 0D,0A
01B22:  DATA 00,00
01B24:  DATA 2C,72
01B26:  DATA 65,73
01B28:  DATA 74,61
01B2A:  DATA 72,74
01B2C:  DATA 20,63
01B2E:  DATA 61,75
01B30:  DATA 73,65
01B32:  DATA 2C,57
01B34:  DATA 44,20
01B36:  DATA 66,72
01B38:  DATA 6F,6D
01B3A:  DATA 20,73
01B3C:  DATA 6C,65
01B3E:  DATA 65,70
01B40:  DATA 0D,0A
01B42:  DATA 00,00
01B44:  DATA 40,4E
01B46:  DATA 50,55
01B48:  DATA 0D,0A
01B4A:  DATA 00,00
01B4C:  DATA 2C,69
01B4E:  DATA 64,23
01B50:  DATA 5B,25
01B52:  DATA 4C,75
01B54:  DATA 5D,2C
01B56:  DATA 70,6F
01B58:  DATA 77,65
01B5A:  DATA 72,20
01B5C:  DATA 61,70
01B5E:  DATA 70,6C
01B60:  DATA 69,65
01B62:  DATA 64,2C
01B64:  DATA 53,44
01B66:  DATA 20,69
01B68:  DATA 6E,69
01B6A:  DATA 74,69
01B6C:  DATA 61,6C
01B6E:  DATA 69,7A
01B70:  DATA 65,64
01B72:  DATA 0D,0A
01B74:  DATA 00,00
01B76:  DATA 40,52
01B78:  DATA 53,54
01B7A:  DATA 0D,0A
01B7C:  DATA 00,00
01B7E:  DATA 2C,72
01B80:  DATA 65,73
01B82:  DATA 74,61
01B84:  DATA 72,74
01B86:  DATA 20,63
01B88:  DATA 61,75
01B8A:  DATA 73,65
01B8C:  DATA 2C,72
01B8E:  DATA 65,73
01B90:  DATA 65,74
01B92:  DATA 20,69
01B94:  DATA 6E,73
01B96:  DATA 74,72
01B98:  DATA 75,63
01B9A:  DATA 74,69
01B9C:  DATA 6F,6E
01B9E:  DATA 0D,0A
01BA0:  DATA 00,00
01BA2:  DATA 40,42
01BA4:  DATA 4F,52
01BA6:  DATA 0D,0A
01BA8:  DATA 00,00
01BAA:  DATA 2C,72
01BAC:  DATA 65,73
01BAE:  DATA 74,61
01BB0:  DATA 72,74
01BB2:  DATA 20,63
01BB4:  DATA 61,75
01BB6:  DATA 73,65
01BB8:  DATA 2C,62
01BBA:  DATA 72,6F
01BBC:  DATA 77,6E
01BBE:  DATA 2D,6F
01BC0:  DATA 75,74
01BC2:  DATA 0D,0A
01BC4:  DATA 00,00
01BC6:  DATA 40,4D
01BC8:  DATA 52,53
01BCA:  DATA 0D,0A
01BCC:  DATA 00,00
01BCE:  DATA 2C,72
01BD0:  DATA 65,73
01BD2:  DATA 74,61
01BD4:  DATA 72,74
01BD6:  DATA 20,63
01BD8:  DATA 61,75
01BDA:  DATA 73,65
01BDC:  DATA 2C,4D
01BDE:  DATA 43,4C
01BE0:  DATA 52,20
01BE2:  DATA 66,72
01BE4:  DATA 6F,6D
01BE6:  DATA 20,73
01BE8:  DATA 6C,65
01BEA:  DATA 65,70
01BEC:  DATA 0D,0A
01BEE:  DATA 00,00
01BF0:  DATA 40,4D
01BF2:  DATA 52,52
01BF4:  DATA 0D,0A
01BF6:  DATA 00,00
01BF8:  DATA 2C,72
01BFA:  DATA 65,73
01BFC:  DATA 74,61
01BFE:  DATA 72,74
01C00:  DATA 20,63
01C02:  DATA 61,75
01C04:  DATA 73,65
01C06:  DATA 2C,4D
01C08:  DATA 43,4C
01C0A:  DATA 52,20
01C0C:  DATA 77,68
01C0E:  DATA 65,6E
01C10:  DATA 20,72
01C12:  DATA 75,6E
01C14:  DATA 6E,69
01C16:  DATA 6E,67
01C18:  DATA 0D,0A
01C1A:  DATA 00,00
01C1C:  DATA 4E,4F
01C1E:  DATA 33,00
01C20:  DATA 4E,4F
01C22:  DATA 32,00
01C24:  DATA 50,4F
01C26:  DATA 34,00
01C28:  DATA 4E,48
01C2A:  DATA 34,00
01C2C:  DATA 53,69
01C2E:  DATA 4F,00
01C30:  DATA 00,00
01C32:  DATA 40,44
01C34:  DATA 45,54
01C36:  DATA 5B,2F
01C38:  DATA 25,75
01C3A:  DATA 5D,5B
01C3C:  DATA 25,63
01C3E:  DATA 5D,41
01C40:  DATA 52,47
01C42:  DATA 5B,25
01C44:  DATA 4C,75
01C46:  DATA 5D,0D
01C48:  DATA 0A,00
01C4A:  DATA 20,74
01C4C:  DATA 69,6D
01C4E:  DATA 65,2D
01C50:  DATA 6F,75
01C52:  DATA 74,00
01C54:  DATA 20,64
01C56:  DATA 61,74
01C58:  DATA 61,20
01C5A:  DATA 74,6F
01C5C:  DATA 6F,20
01C5E:  DATA 73,68
01C60:  DATA 6F,72
01C62:  DATA 74,00
01C64:  DATA 20,64
01C66:  DATA 61,74
01C68:  DATA 61,20
01C6A:  DATA 74,6F
01C6C:  DATA 6F,20
01C6E:  DATA 6C,6F
01C70:  DATA 6E,67
01C72:  DATA 00,00
01C74:  DATA 2C,64
01C76:  DATA 65,74
01C78:  DATA 65,63
01C7A:  DATA 74,6F
01C7C:  DATA 72,5B
01C7E:  DATA 25,73
01C80:  DATA 5D,2C
01C82:  DATA 6C,65
01C84:  DATA 6E,5B
01C86:  DATA 25,75
01C88:  DATA 5D,00
01C8A:  DATA 40,52
01C8C:  DATA 54,59
01C8E:  DATA 2C,25
01C90:  DATA 75,0D
01C92:  DATA 0A,00
01C94:  DATA 2C,73
01C96:  DATA 74,61
01C98:  DATA 72,74
01C9A:  DATA 20,68
01C9C:  DATA 65,61
01C9E:  DATA 74,69
01CA0:  DATA 6E,67
01CA2:  DATA 2C,74
01CA4:  DATA 61,72
01CA6:  DATA 67,65
01CA8:  DATA 74,5B
01CAA:  DATA 25,4C
01CAC:  DATA 75,5D
01CAE:  DATA 2C,61
01CB0:  DATA 63,74
01CB2:  DATA 75,61
01CB4:  DATA 6C,5B
01CB6:  DATA 25,4C
01CB8:  DATA 75,5D
01CBA:  DATA 2C,72
01CBC:  DATA 65,61
01CBE:  DATA 64,69
01CC0:  DATA 6E,67
01CC2:  DATA 73,5B
01CC4:  DATA 25,4C
01CC6:  DATA 75,5D
01CC8:  DATA 0D,0A
01CCA:  DATA 00,00
01CCC:  DATA 2C,65
01CCE:  DATA 6E,64
01CD0:  DATA 20,68
01CD2:  DATA 65,61
01CD4:  DATA 74,69
01CD6:  DATA 6E,67
01CD8:  DATA 2C,74
01CDA:  DATA 61,72
01CDC:  DATA 67,65
01CDE:  DATA 74,5B
01CE0:  DATA 25,4C
01CE2:  DATA 75,5D
01CE4:  DATA 2C,61
01CE6:  DATA 63,74
01CE8:  DATA 75,61
01CEA:  DATA 6C,5B
01CEC:  DATA 25,4C
01CEE:  DATA 75,5D
01CF0:  DATA 2C,72
01CF2:  DATA 65,61
01CF4:  DATA 64,69
01CF6:  DATA 6E,67
01CF8:  DATA 73,5B
01CFA:  DATA 25,4C
01CFC:  DATA 75,5D
01CFE:  DATA 0D,0A
01D00:  DATA 00,00
01D02:  DATA 4E,4F
01D04:  DATA 33,00
01D06:  DATA 4E,4F
01D08:  DATA 32,00
01D0A:  DATA 50,4F
01D0C:  DATA 34,00
01D0E:  DATA 4E,48
01D10:  DATA 34,00
01D12:  DATA 53,69
01D14:  DATA 4F,00
01D16:  DATA 00,00
01D18:  DATA 40,44
01D1A:  DATA 41,43
01D1C:  DATA 2C,25
01D1E:  DATA 4C,75
01D20:  DATA 2C,25
01D22:  DATA 4C,75
01D24:  DATA 2C,00
01D26:  DATA 40,53
01D28:  DATA 41,52
01D2A:  DATA 2C,31
01D2C:  DATA 2C,25
01D2E:  DATA 4C,75
01D30:  DATA 2C,00
01D32:  DATA 40,56
01D34:  DATA 41,4C
01D36:  DATA 20,00
01D38:  DATA 40,56
01D3A:  DATA 41,4C
01D3C:  DATA 20,00
01D3E:  DATA 40,56
01D40:  DATA 41,4C
01D42:  DATA 20,00
01D44:  DATA 40,56
01D46:  DATA 41,4C
01D48:  DATA 20,00
01D4A:  DATA 40,53
01D4C:  DATA 4F,4C
01D4E:  DATA 5B,2F
01D50:  DATA 31,5D
01D52:  DATA 5B,73
01D54:  DATA 5D,5B
01D56:  DATA 25,4C
01D58:  DATA 75,5D
01D5A:  DATA 0D,0A
01D5C:  DATA 00,00
01D5E:  DATA 2F,31
01D60:  DATA 73,25
01D62:  DATA 4C,75
01D64:  DATA 0D,00
01D66:  DATA 40,53
01D68:  DATA 4F,4C
01D6A:  DATA 5B,2F
01D6C:  DATA 31,5D
01D6E:  DATA 5B,63
01D70:  DATA 5D,5B
01D72:  DATA 25,75
01D74:  DATA 5D,0D
01D76:  DATA 0A,00
01D78:  DATA 2F,31
01D7A:  DATA 63,25
01D7C:  DATA 75,0D
01D7E:  DATA 00,00
01D80:  DATA 2F,31
01D82:  DATA 73,32
01D84:  DATA 35,36
01D86:  DATA 0D,00
01D88:  DATA 28,49
01D8A:  DATA 30,73
01D8C:  DATA 29,2C
01D8E:  DATA 25,4C
01D90:  DATA 75,2C
01D92:  DATA 28,49
01D94:  DATA 31,73
01D96:  DATA 29,2C
01D98:  DATA 25,4C
01D9A:  DATA 75,2C
01D9C:  DATA 28,41
01D9E:  DATA 62,73
01DA0:  DATA 2D,73
01DA2:  DATA 29,2C
01DA4:  DATA 25,31
01DA6:  DATA 2E,34
01DA8:  DATA 67,2C
01DAA:  DATA 28,49
01DAC:  DATA 30,74
01DAE:  DATA 29,2C
01DB0:  DATA 25,4C
01DB2:  DATA 75,2C
01DB4:  DATA 28,49
01DB6:  DATA 31,74
01DB8:  DATA 29,2C
01DBA:  DATA 25,4C
01DBC:  DATA 75,2C
01DBE:  DATA 28,41
01DC0:  DATA 62,73
01DC2:  DATA 2D,74
01DC4:  DATA 29,2C
01DC6:  DATA 25,31
01DC8:  DATA 2E,34
01DCA:  DATA 67,2C
01DCC:  DATA 28,49
01DCE:  DATA 30,72
01DD0:  DATA 29,2C
01DD2:  DATA 25,4C
01DD4:  DATA 75,2C
01DD6:  DATA 28,49
01DD8:  DATA 31,72
01DDA:  DATA 29,2C
01DDC:  DATA 25,4C
01DDE:  DATA 75,2C
01DE0:  DATA 28,41
01DE2:  DATA 62,73
01DE4:  DATA 2D,72
01DE6:  DATA 29,2C
01DE8:  DATA 25,31
01DEA:  DATA 2E,34
01DEC:  DATA 67,00
01DEE:  DATA 40,41
01DF0:  DATA 62,73
01DF2:  DATA 2C,4E
01DF4:  DATA 4F,33
01DF6:  DATA 2C,25
01DF8:  DATA 73,0D
01DFA:  DATA 0A,00
01DFC:  DATA 28,49
01DFE:  DATA 30,73
01E00:  DATA 29,2C
01E02:  DATA 25,4C
01E04:  DATA 75,2C
01E06:  DATA 28,49
01E08:  DATA 31,73
01E0A:  DATA 29,2C
01E0C:  DATA 25,4C
01E0E:  DATA 75,2C
01E10:  DATA 28,41
01E12:  DATA 62,73
01E14:  DATA 2D,73
01E16:  DATA 29,2C
01E18:  DATA 25,31
01E1A:  DATA 2E,34
01E1C:  DATA 67,2C
01E1E:  DATA 28,49
01E20:  DATA 30,74
01E22:  DATA 29,2C
01E24:  DATA 25,4C
01E26:  DATA 75,2C
01E28:  DATA 28,49
01E2A:  DATA 31,74
01E2C:  DATA 29,2C
01E2E:  DATA 25,4C
01E30:  DATA 75,2C
01E32:  DATA 28,41
01E34:  DATA 62,73
01E36:  DATA 2D,74
01E38:  DATA 29,2C
01E3A:  DATA 25,31
01E3C:  DATA 2E,34
01E3E:  DATA 67,2C
01E40:  DATA 28,49
01E42:  DATA 30,72
01E44:  DATA 29,2C
01E46:  DATA 25,4C
01E48:  DATA 75,2C
01E4A:  DATA 28,49
01E4C:  DATA 31,72
01E4E:  DATA 29,2C
01E50:  DATA 25,4C
01E52:  DATA 75,2C
01E54:  DATA 28,41
01E56:  DATA 62,73
01E58:  DATA 2D,72
01E5A:  DATA 29,2C
01E5C:  DATA 25,31
01E5E:  DATA 2E,34
01E60:  DATA 67,00
01E62:  DATA 40,41
01E64:  DATA 62,73
01E66:  DATA 2C,4E
01E68:  DATA 4F,32
01E6A:  DATA 2C,25
01E6C:  DATA 73,0D
01E6E:  DATA 0A,00
01E70:  DATA 28,49
01E72:  DATA 30,73
01E74:  DATA 29,2C
01E76:  DATA 25,4C
01E78:  DATA 75,2C
01E7A:  DATA 28,49
01E7C:  DATA 31,73
01E7E:  DATA 29,2C
01E80:  DATA 25,4C
01E82:  DATA 75,2C
01E84:  DATA 28,41
01E86:  DATA 62,73
01E88:  DATA 2D,73
01E8A:  DATA 29,2C
01E8C:  DATA 25,31
01E8E:  DATA 2E,34
01E90:  DATA 67,2C
01E92:  DATA 28,49
01E94:  DATA 30,74
01E96:  DATA 29,2C
01E98:  DATA 25,4C
01E9A:  DATA 75,2C
01E9C:  DATA 28,49
01E9E:  DATA 31,74
01EA0:  DATA 29,2C
01EA2:  DATA 25,4C
01EA4:  DATA 75,2C
01EA6:  DATA 28,41
01EA8:  DATA 62,73
01EAA:  DATA 2D,74
01EAC:  DATA 29,2C
01EAE:  DATA 25,31
01EB0:  DATA 2E,34
01EB2:  DATA 67,2C
01EB4:  DATA 28,49
01EB6:  DATA 30,72
01EB8:  DATA 29,2C
01EBA:  DATA 25,4C
01EBC:  DATA 75,2C
01EBE:  DATA 28,49
01EC0:  DATA 31,72
01EC2:  DATA 29,2C
01EC4:  DATA 25,4C
01EC6:  DATA 75,2C
01EC8:  DATA 28,41
01ECA:  DATA 62,73
01ECC:  DATA 2D,72
01ECE:  DATA 29,2C
01ED0:  DATA 25,31
01ED2:  DATA 2E,34
01ED4:  DATA 67,00
01ED6:  DATA 40,41
01ED8:  DATA 62,73
01EDA:  DATA 2C,50
01EDC:  DATA 4F,34
01EDE:  DATA 2C,25
01EE0:  DATA 73,0D
01EE2:  DATA 0A,00
01EE4:  DATA 28,49
01EE6:  DATA 30,73
01EE8:  DATA 29,2C
01EEA:  DATA 25,4C
01EEC:  DATA 75,2C
01EEE:  DATA 28,49
01EF0:  DATA 31,73
01EF2:  DATA 29,2C
01EF4:  DATA 25,4C
01EF6:  DATA 75,2C
01EF8:  DATA 28,41
01EFA:  DATA 62,73
01EFC:  DATA 2D,73
01EFE:  DATA 29,2C
01F00:  DATA 25,31
01F02:  DATA 2E,34
01F04:  DATA 67,2C
01F06:  DATA 28,49
01F08:  DATA 30,74
01F0A:  DATA 29,2C
01F0C:  DATA 25,4C
01F0E:  DATA 75,2C
01F10:  DATA 28,49
01F12:  DATA 31,74
01F14:  DATA 29,2C
01F16:  DATA 25,4C
01F18:  DATA 75,2C
01F1A:  DATA 28,41
01F1C:  DATA 62,73
01F1E:  DATA 2D,74
01F20:  DATA 29,2C
01F22:  DATA 25,31
01F24:  DATA 2E,34
01F26:  DATA 67,2C
01F28:  DATA 28,49
01F2A:  DATA 30,72
01F2C:  DATA 29,2C
01F2E:  DATA 25,4C
01F30:  DATA 75,2C
01F32:  DATA 28,49
01F34:  DATA 31,72
01F36:  DATA 29,2C
01F38:  DATA 25,4C
01F3A:  DATA 75,2C
01F3C:  DATA 28,41
01F3E:  DATA 62,73
01F40:  DATA 2D,72
01F42:  DATA 29,2C
01F44:  DATA 25,31
01F46:  DATA 2E,34
01F48:  DATA 67,00
01F4A:  DATA 40,41
01F4C:  DATA 62,73
01F4E:  DATA 2C,4E
01F50:  DATA 48,34
01F52:  DATA 2C,25
01F54:  DATA 73,0D
01F56:  DATA 0A,00
01F58:  DATA 28,49
01F5A:  DATA 30,73
01F5C:  DATA 29,2C
01F5E:  DATA 25,4C
01F60:  DATA 75,2C
01F62:  DATA 28,49
01F64:  DATA 31,73
01F66:  DATA 29,2C
01F68:  DATA 25,4C
01F6A:  DATA 75,2C
01F6C:  DATA 28,41
01F6E:  DATA 62,73
01F70:  DATA 2D,73
01F72:  DATA 29,2C
01F74:  DATA 25,31
01F76:  DATA 2E,34
01F78:  DATA 67,2C
01F7A:  DATA 28,49
01F7C:  DATA 30,74
01F7E:  DATA 29,2C
01F80:  DATA 25,4C
01F82:  DATA 75,2C
01F84:  DATA 28,49
01F86:  DATA 31,74
01F88:  DATA 29,2C
01F8A:  DATA 25,4C
01F8C:  DATA 75,2C
01F8E:  DATA 28,41
01F90:  DATA 62,73
01F92:  DATA 2D,74
01F94:  DATA 29,2C
01F96:  DATA 25,31
01F98:  DATA 2E,34
01F9A:  DATA 67,2C
01F9C:  DATA 28,49
01F9E:  DATA 30,72
01FA0:  DATA 29,2C
01FA2:  DATA 25,4C
01FA4:  DATA 75,2C
01FA6:  DATA 28,49
01FA8:  DATA 31,72
01FAA:  DATA 29,2C
01FAC:  DATA 25,4C
01FAE:  DATA 75,2C
01FB0:  DATA 28,41
01FB2:  DATA 62,73
01FB4:  DATA 2D,72
01FB6:  DATA 29,2C
01FB8:  DATA 25,31
01FBA:  DATA 2E,34
01FBC:  DATA 67,00
01FBE:  DATA 40,41
01FC0:  DATA 42,53
01FC2:  DATA 2C,53
01FC4:  DATA 69,4F
01FC6:  DATA 2C,25
01FC8:  DATA 73,0D
01FCA:  DATA 0A,00
01FCC:  DATA 4E,4F
01FCE:  DATA 33,00
01FD0:  DATA 4E,4F
01FD2:  DATA 32,00
01FD4:  DATA 50,4F
01FD6:  DATA 34,00
01FD8:  DATA 4E,48
01FDA:  DATA 34,00
01FDC:  DATA 53,69
01FDE:  DATA 4F,00
01FE0:  DATA 00,00
01FE2:  DATA 28,6D
01FE4:  DATA 29,2C
01FE6:  DATA 25,33
01FE8:  DATA 2E,33
01FEA:  DATA 67,2C
01FEC:  DATA 28,63
01FEE:  DATA 29,2C
01FF0:  DATA 25,33
01FF2:  DATA 2E,33
01FF4:  DATA 67,00
01FF6:  DATA 28,43
01FF8:  DATA 73,29
01FFA:  DATA 2C,25
01FFC:  DATA 33,2E
01FFE:  DATA 33,67
02000:  DATA 0D,0A
02002:  DATA 00,00
02004:  DATA 40,43
02006:  DATA 4F,4E
02008:  DATA 2C,4E
0200A:  DATA 4F,33
0200C:  DATA 2C,25
0200E:  DATA 73,0D
02010:  DATA 0A,00
02012:  DATA 28,6D
02014:  DATA 29,2C
02016:  DATA 25,33
02018:  DATA 2E,33
0201A:  DATA 67,2C
0201C:  DATA 28,63
0201E:  DATA 29,2C
02020:  DATA 25,33
02022:  DATA 2E,33
02024:  DATA 67,00
02026:  DATA 28,43
02028:  DATA 73,29
0202A:  DATA 2C,25
0202C:  DATA 33,2E
0202E:  DATA 33,67
02030:  DATA 0D,0A
02032:  DATA 00,00
02034:  DATA 40,43
02036:  DATA 4F,4E
02038:  DATA 2C,50
0203A:  DATA 4F,34
0203C:  DATA 2C,25
0203E:  DATA 73,0D
02040:  DATA 0A,00
02042:  DATA 28,6D
02044:  DATA 29,2C
02046:  DATA 25,33
02048:  DATA 2E,33
0204A:  DATA 67,2C
0204C:  DATA 28,63
0204E:  DATA 29,2C
02050:  DATA 25,33
02052:  DATA 2E,33
02054:  DATA 67,00
02056:  DATA 28,43
02058:  DATA 73,29
0205A:  DATA 2C,25
0205C:  DATA 33,2E
0205E:  DATA 33,67
02060:  DATA 0D,0A
02062:  DATA 00,00
02064:  DATA 40,43
02066:  DATA 4F,4E
02068:  DATA 2C,4E
0206A:  DATA 48,34
0206C:  DATA 2C,25
0206E:  DATA 73,0D
02070:  DATA 0A,00
02072:  DATA 28,6D
02074:  DATA 29,2C
02076:  DATA 25,33
02078:  DATA 2E,33
0207A:  DATA 67,2C
0207C:  DATA 28,63
0207E:  DATA 29,2C
02080:  DATA 25,33
02082:  DATA 2E,33
02084:  DATA 67,00
02086:  DATA 28,43
02088:  DATA 73,29
0208A:  DATA 2C,25
0208C:  DATA 33,2E
0208E:  DATA 33,67
02090:  DATA 0D,0A
02092:  DATA 00,00
02094:  DATA 40,43
02096:  DATA 4F,4E
02098:  DATA 2C,53
0209A:  DATA 69,4F
0209C:  DATA 2C,25
0209E:  DATA 73,0D
020A0:  DATA 0A,00
020A2:  DATA 4E,4F
020A4:  DATA 33,00
020A6:  DATA 50,4F
020A8:  DATA 34,00
020AA:  DATA 4E,48
020AC:  DATA 34,00
020AE:  DATA 53,69
020B0:  DATA 4F,00
020B2:  DATA 00,00
020B4:  DATA 4D,45
020B6:  DATA 4D,4F
020B8:  DATA 52,59
020BA:  DATA 20,4F
020BC:  DATA 56,45
020BE:  DATA 52,46
020C0:  DATA 4C,4F
020C2:  DATA 57,20
020C4:  DATA 45,52
020C6:  DATA 52,4F
020C8:  DATA 52,20
020CA:  DATA 40,20
020CC:  DATA 4C,69
020CE:  DATA 6E,65
020D0:  DATA 20,3A
020D2:  DATA 25,4C
020D4:  DATA 75,0A
020D6:  DATA 0D,00
020D8:  DATA 0D,0A
020DA:  DATA 3A,00
020DC:  DATA 0D,0A
020DE:  DATA 57,41
020E0:  DATA 52,4E
020E2:  DATA 49,4E
020E4:  DATA 47,3A
020E6:  DATA 20,49
020E8:  DATA 4E,56
020EA:  DATA 41,4C
020EC:  DATA 49,44
020EE:  DATA 20,43
020F0:  DATA 4F,4D
020F2:  DATA 4D,41
020F4:  DATA 4E,44
020F6:  DATA 20,49
020F8:  DATA 4E,20
020FA:  DATA 4D,41
020FC:  DATA 43,52
020FE:  DATA 4F,21
02100:  DATA 0D,0A
02102:  DATA 00,00
02104:  DATA 42,61
02106:  DATA 64,20
02108:  DATA 63,6F
0210A:  DATA 6D,6D
0210C:  DATA 61,6E
0210E:  DATA 64,20
02110:  DATA 61,74
02112:  DATA 20,6C
02114:  DATA 69,6E
02116:  DATA 65,3A
02118:  DATA 20,25
0211A:  DATA 4C,64
0211C:  DATA 20,0D
0211E:  DATA 0A,00
02120:  DATA 50,6C
02122:  DATA 65,61
02124:  DATA 73,65
02126:  DATA 20,72
02128:  DATA 65,2D
0212A:  DATA 75,70
0212C:  DATA 6C,6F
0212E:  DATA 61,64
02130:  DATA 20,6D
02132:  DATA 61,63
02134:  DATA 72,6F
02136:  DATA 00,00
02138:  DATA 49,74
0213A:  DATA 65,72
0213C:  DATA 61,74
0213E:  DATA 69,6F
02140:  DATA 6E,73
02142:  DATA 20,6C
02144:  DATA 65,66
02146:  DATA 74,3A
02148:  DATA 20,25
0214A:  DATA 4C,75
0214C:  DATA 0D,0A
0214E:  DATA 00,00
02150:  DATA 2C,6D
02152:  DATA 61,63
02154:  DATA 72,6F
02156:  DATA 5B,25
02158:  DATA 75,5D
0215A:  DATA 2C,73
0215C:  DATA 74,61
0215E:  DATA 72,74
02160:  DATA 0D,0A
02162:  DATA 00,00
02164:  DATA 40,4D
02166:  DATA 43,4C
02168:  DATA 5B,25
0216A:  DATA 63,5D
0216C:  DATA 5B,25
0216E:  DATA 4C,75
02170:  DATA 5D,0D
02172:  DATA 0A,00
02174:  DATA 40,4C
02176:  DATA 4E,45
02178:  DATA 0D,0A
0217A:  DATA 00,00
0217C:  DATA 40,52
0217E:  DATA 55,4E
02180:  DATA 0D,0A
02182:  DATA 00,00
02184:  DATA 40,42
02186:  DATA 41,44
02188:  DATA 0D,0A
0218A:  DATA 00,00
0218C:  DATA 40,54
0218E:  DATA 2F,4F
02190:  DATA 0D,0A
02192:  DATA 00,00
02194:  DATA 40,45
02196:  DATA 52,52
02198:  DATA 0D,0A
0219A:  DATA 00,00
0219C:  DATA 40,45
0219E:  DATA 4E,44
021A0:  DATA 0D,0A
021A2:  DATA 00,00
021A4:  DATA 40,48
021A6:  DATA 4C,54
021A8:  DATA 0D,0A
021AA:  DATA 00,00
021AC:  DATA 2C,6D
021AE:  DATA 61,63
021B0:  DATA 72,6F
021B2:  DATA 5B,25
021B4:  DATA 75,5D
021B6:  DATA 2C,73
021B8:  DATA 74,61
021BA:  DATA 74,75
021BC:  DATA 73,5B
021BE:  DATA 25,63
021C0:  DATA 5D,2C
021C2:  DATA 6C,69
021C4:  DATA 6E,65
021C6:  DATA 5B,25
021C8:  DATA 4C,75
021CA:  DATA 5D,0D
021CC:  DATA 0A,00
021CE:  DATA 40,52
021D0:  DATA 75,6E
021D2:  DATA 6E,69
021D4:  DATA 6E,67
021D6:  DATA 20,25
021D8:  DATA 63,25
021DA:  DATA 4C,75
021DC:  DATA 20,0D
021DE:  DATA 0A,00
021E0:  DATA 40,4D
021E2:  DATA 61,63
021E4:  DATA 72,6F
021E6:  DATA 20,25
021E8:  DATA 30,34
021EA:  DATA 4C,75
021EC:  DATA 20,6F
021EE:  DATA 66,20
021F0:  DATA 25,30
021F2:  DATA 34,4C
021F4:  DATA 75,0D
021F6:  DATA 0A,00
021F8:  DATA 40,4C
021FA:  DATA 4E,45
021FC:  DATA 0D,0A
021FE:  DATA 00,00
02200:  DATA 40,52
02202:  DATA 55,4E
02204:  DATA 0D,0A
02206:  DATA 00,00
02208:  DATA 40,42
0220A:  DATA 41,44
0220C:  DATA 0D,0A
0220E:  DATA 00,00
02210:  DATA 40,54
02212:  DATA 2F,4F
02214:  DATA 0D,0A
02216:  DATA 00,00
02218:  DATA 40,45
0221A:  DATA 52,52
0221C:  DATA 0D,0A
0221E:  DATA 00,00
02220:  DATA 40,45
02222:  DATA 4E,44
02224:  DATA 0D,0A
02226:  DATA 00,00
02228:  DATA 2C,61
0222A:  DATA 75,74
0222C:  DATA 6F,2D
0222E:  DATA 73,61
02230:  DATA 6D,70
02232:  DATA 6C,65
02234:  DATA 2C,73
02236:  DATA 61,6D
02238:  DATA 70,6C
0223A:  DATA 65,5B
0223C:  DATA 25,4C
0223E:  DATA 75,5D
02240:  DATA 2C,73
02242:  DATA 74,61
02244:  DATA 72,74
02246:  DATA 0D,0A
02248:  DATA 00,00
0224A:  DATA 2C,61
0224C:  DATA 75,74
0224E:  DATA 6F,2D
02250:  DATA 73,61
02252:  DATA 6D,70
02254:  DATA 6C,65
02256:  DATA 2C,73
02258:  DATA 61,6D
0225A:  DATA 70,6C
0225C:  DATA 65,5B
0225E:  DATA 25,4C
02260:  DATA 75,5D
02262:  DATA 2C,63
02264:  DATA 6F,6D
02266:  DATA 70,6C
02268:  DATA 65,74
0226A:  DATA 65,0D
0226C:  DATA 0A,00
0226E:  DATA 2C,61
02270:  DATA 75,74
02272:  DATA 6F,2D
02274:  DATA 73,61
02276:  DATA 6D,70
02278:  DATA 6C,65
0227A:  DATA 2C,73
0227C:  DATA 61,6D
0227E:  DATA 70,6C
02280:  DATA 65,5B
02282:  DATA 25,4C
02284:  DATA 75,5D
02286:  DATA 2C,65
02288:  DATA 72,72
0228A:  DATA 6F,72
0228C:  DATA 0D,0A
0228E:  DATA 00,00
02290:  DATA 2C,61
02292:  DATA 75,74
02294:  DATA 6F,2D
02296:  DATA 73,61
02298:  DATA 6D,70
0229A:  DATA 6C,65
0229C:  DATA 2C,73
0229E:  DATA 61,6D
022A0:  DATA 70,6C
022A2:  DATA 65,5B
022A4:  DATA 25,4C
022A6:  DATA 75,5D
022A8:  DATA 2C,6D
022AA:  DATA 61,78
022AC:  DATA 20,73
022AE:  DATA 61,6D
022B0:  DATA 70,6C
022B2:  DATA 65,73
022B4:  DATA 0D,0A
022B6:  DATA 00,00
022B8:  DATA 2C,61
022BA:  DATA 75,74
022BC:  DATA 6F,2D
022BE:  DATA 73,61
022C0:  DATA 6D,70
022C2:  DATA 6C,65
022C4:  DATA 2C,73
022C6:  DATA 61,6D
022C8:  DATA 70,6C
022CA:  DATA 65,5B
022CC:  DATA 25,4C
022CE:  DATA 75,5D
022D0:  DATA 2C,73
022D2:  DATA 74,61
022D4:  DATA 72,74
022D6:  DATA 0D,0A
022D8:  DATA 00,00
022DA:  DATA 2C,61
022DC:  DATA 75,74
022DE:  DATA 6F,2D
022E0:  DATA 73,61
022E2:  DATA 6D,70
022E4:  DATA 6C,65
022E6:  DATA 2C,73
022E8:  DATA 61,6D
022EA:  DATA 70,6C
022EC:  DATA 65,5B
022EE:  DATA 25,4C
022F0:  DATA 75,5D
022F2:  DATA 2C,63
022F4:  DATA 6F,6D
022F6:  DATA 70,6C
022F8:  DATA 65,74
022FA:  DATA 65,0D
022FC:  DATA 0A,00
022FE:  DATA 2C,61
02300:  DATA 75,74
02302:  DATA 6F,2D
02304:  DATA 73,61
02306:  DATA 6D,70
02308:  DATA 6C,65
0230A:  DATA 2C,73
0230C:  DATA 61,6D
0230E:  DATA 70,6C
02310:  DATA 65,5B
02312:  DATA 25,4C
02314:  DATA 75,5D
02316:  DATA 2C,73
02318:  DATA 74,61
0231A:  DATA 72,74
0231C:  DATA 0D,0A
0231E:  DATA 00,00
02320:  DATA 2C,61
02322:  DATA 75,74
02324:  DATA 6F,2D
02326:  DATA 73,61
02328:  DATA 6D,70
0232A:  DATA 6C,65
0232C:  DATA 2C,73
0232E:  DATA 61,6D
02330:  DATA 70,6C
02332:  DATA 65,5B
02334:  DATA 25,4C
02336:  DATA 75,5D
02338:  DATA 2C,63
0233A:  DATA 6F,6D
0233C:  DATA 70,6C
0233E:  DATA 65,74
02340:  DATA 65,0D
02342:  DATA 0A,00
02344:  DATA 2C,61
02346:  DATA 75,74
02348:  DATA 6F,2D
0234A:  DATA 73,61
0234C:  DATA 6D,70
0234E:  DATA 6C,65
02350:  DATA 2C,73
02352:  DATA 61,6D
02354:  DATA 70,6C
02356:  DATA 65,5B
02358:  DATA 25,4C
0235A:  DATA 75,5D
0235C:  DATA 2C,6D
0235E:  DATA 61,78
02360:  DATA 20,73
02362:  DATA 61,6D
02364:  DATA 70,6C
02366:  DATA 65,73
02368:  DATA 0D,0A
0236A:  DATA 00,00
0236C:  DATA 2C,61
0236E:  DATA 75,74
02370:  DATA 6F,2D
02372:  DATA 73,61
02374:  DATA 6D,70
02376:  DATA 6C,65
02378:  DATA 2C,69
0237A:  DATA 6E,69
0237C:  DATA 74,69
0237E:  DATA 61,6C
02380:  DATA 69,7A
02382:  DATA 65,0D
02384:  DATA 0A,00
02386:  DATA 2C,68
02388:  DATA 65,61
0238A:  DATA 64,65
0238C:  DATA 72,2C
0238E:  DATA 69,64
02390:  DATA 23,5B
02392:  DATA 25,4C
02394:  DATA 75,5D
02396:  DATA 2C,69
02398:  DATA 6E,74
0239A:  DATA 5B,25
0239C:  DATA 4C,75
0239E:  DATA 5D,2C
023A0:  DATA 6D,61
023A2:  DATA 78,5B
023A4:  DATA 25,4C
023A6:  DATA 75,5D
023A8:  DATA 0D,0A
023AA:  DATA 00,00
023AC:  DATA 2C,61
023AE:  DATA 75,74
023B0:  DATA 6F,2D
023B2:  DATA 73,61
023B4:  DATA 6D,70
023B6:  DATA 6C,65
023B8:  DATA 2C,73
023BA:  DATA 61,6D
023BC:  DATA 70,6C
023BE:  DATA 65,5B
023C0:  DATA 25,4C
023C2:  DATA 75,5D
023C4:  DATA 2C,61
023C6:  DATA 6C,61
023C8:  DATA 72,6D
023CA:  DATA 5B,25
023CC:  DATA 75,5D
023CE:  DATA 0D,0A
023D0:  DATA 00,00
023D2:  DATA 2C,61
023D4:  DATA 75,74
023D6:  DATA 6F,2D
023D8:  DATA 73,61
023DA:  DATA 6D,70
023DC:  DATA 6C,65
023DE:  DATA 2C,73
023E0:  DATA 6C,65
023E2:  DATA 65,70
023E4:  DATA 0D,0A
023E6:  DATA 00,00
023E8:  DATA 74,31
023EA:  DATA 3A,25
023EC:  DATA 4C,75
023EE:  DATA 20,74
023F0:  DATA 32,3A
023F2:  DATA 25,4C
023F4:  DATA 75,0D
023F6:  DATA 0A,00
023F8:  DATA 40,44
023FA:  DATA 45,54
023FC:  DATA 2C,25
023FE:  DATA 4C,75
02400:  DATA 0D,0A
02402:  DATA 00,00
02404:  DATA 4E,4F
02406:  DATA 33,2C
02408:  DATA 25,31
0240A:  DATA 2E,35
0240C:  DATA 67,2C
0240E:  DATA 25,31
02410:  DATA 2E,35
02412:  DATA 67,0D
02414:  DATA 0A,00
02416:  DATA 50,4F
02418:  DATA 34,2C
0241A:  DATA 25,31
0241C:  DATA 2E,35
0241E:  DATA 67,2C
02420:  DATA 25,31
02422:  DATA 2E,35
02424:  DATA 67,0D
02426:  DATA 0A,00
02428:  DATA 4E,48
0242A:  DATA 34,2C
0242C:  DATA 25,31
0242E:  DATA 2E,35
02430:  DATA 67,2C
02432:  DATA 25,31
02434:  DATA 2E,35
02436:  DATA 67,0D
02438:  DATA 0A,00
0243A:  DATA 53,69
0243C:  DATA 4F,34
0243E:  DATA 2C,25
02440:  DATA 31,2E
02442:  DATA 35,67
02444:  DATA 2C,25
02446:  DATA 31,2E
02448:  DATA 35,67
0244A:  DATA 0D,0A
0244C:  DATA 00,00
0244E:  DATA 4E,4F
02450:  DATA 33,28
02452:  DATA 6D,29
02454:  DATA 3A,00
02456:  DATA 4E,4F
02458:  DATA 33,28
0245A:  DATA 63,29
0245C:  DATA 3A,00
0245E:  DATA 50,4F
02460:  DATA 34,28
02462:  DATA 6D,29
02464:  DATA 3A,00
02466:  DATA 50,4F
02468:  DATA 34,28
0246A:  DATA 63,29
0246C:  DATA 3A,00
0246E:  DATA 4E,48
02470:  DATA 34,28
02472:  DATA 6D,29
02474:  DATA 3A,00
02476:  DATA 4E,48
02478:  DATA 34,28
0247A:  DATA 63,29
0247C:  DATA 3A,00
0247E:  DATA 53,69
02480:  DATA 4F,34
02482:  DATA 28,6D
02484:  DATA 29,3A
02486:  DATA 00,00
02488:  DATA 53,69
0248A:  DATA 4F,34
0248C:  DATA 28,63
0248E:  DATA 29,3A
02490:  DATA 00,00
02492:  DATA 41,72
02494:  DATA 65,20
02496:  DATA 79,6F
02498:  DATA 75,20
0249A:  DATA 73,75
0249C:  DATA 72,65
0249E:  DATA 20,79
024A0:  DATA 6F,75
024A2:  DATA 20,77
024A4:  DATA 61,6E
024A6:  DATA 74,20
024A8:  DATA 74,6F
024AA:  DATA 20,65
024AC:  DATA 72,61
024AE:  DATA 73,65
024B0:  DATA 20,74
024B2:  DATA 68,65
024B4:  DATA 20,72
024B6:  DATA 61,77
024B8:  DATA 20,64
024BA:  DATA 61,74
024BC:  DATA 61,20
024BE:  DATA 66,69
024C0:  DATA 6C,65
024C2:  DATA 3F,20
024C4:  DATA 59,20
024C6:  DATA 6F,72
024C8:  DATA 20,4E
024CA:  DATA 21,0D
024CC:  DATA 0A,00
024CE:  DATA 46,69
024D0:  DATA 6C,65
024D2:  DATA 20,64
024D4:  DATA 65,6C
024D6:  DATA 65,74
024D8:  DATA 65,64
024DA:  DATA 21,0A
024DC:  DATA 0D,00
024DE:  DATA 4F,70
024E0:  DATA 65,72
024E2:  DATA 61,74
024E4:  DATA 69,6F
024E6:  DATA 6E,20
024E8:  DATA 63,61
024EA:  DATA 6E,63
024EC:  DATA 65,6C
024EE:  DATA 65,64
024F0:  DATA 21,0D
024F2:  DATA 0A,00
024F4:  DATA 41,72
024F6:  DATA 65,20
024F8:  DATA 79,6F
024FA:  DATA 75,20
024FC:  DATA 73,75
024FE:  DATA 72,65
02500:  DATA 20,79
02502:  DATA 6F,75
02504:  DATA 20,77
02506:  DATA 61,6E
02508:  DATA 74,20
0250A:  DATA 74,6F
0250C:  DATA 20,65
0250E:  DATA 72,61
02510:  DATA 73,65
02512:  DATA 20,74
02514:  DATA 68,65
02516:  DATA 20,63
02518:  DATA 61,6C
0251A:  DATA 63,75
0251C:  DATA 6C,61
0251E:  DATA 74,65
02520:  DATA 64,20
02522:  DATA 64,61
02524:  DATA 74,61
02526:  DATA 20,66
02528:  DATA 69,6C
0252A:  DATA 65,3F
0252C:  DATA 20,59
0252E:  DATA 20,6F
02530:  DATA 72,20
02532:  DATA 4E,21
02534:  DATA 0D,0A
02536:  DATA 00,00
02538:  DATA 46,69
0253A:  DATA 6C,65
0253C:  DATA 20,64
0253E:  DATA 65,6C
02540:  DATA 65,74
02542:  DATA 65,64
02544:  DATA 21,0A
02546:  DATA 0D,00
02548:  DATA 4F,70
0254A:  DATA 65,72
0254C:  DATA 61,74
0254E:  DATA 69,6F
02550:  DATA 6E,20
02552:  DATA 63,61
02554:  DATA 6E,63
02556:  DATA 65,6C
02558:  DATA 65,64
0255A:  DATA 21,0D
0255C:  DATA 0A,00
0255E:  DATA 40,49
02560:  DATA 44,23
02562:  DATA 25,4C
02564:  DATA 75,20
02566:  DATA 49,25
02568:  DATA 4C,75
0256A:  DATA 20,4E
0256C:  DATA 25,4C
0256E:  DATA 75,2F
02570:  DATA 25,4C
02572:  DATA 75,20
02574:  DATA 58,25
02576:  DATA 4C,75
02578:  DATA 20,55
0257A:  DATA 25,75
0257C:  DATA 20,25
0257E:  DATA 34,2E
02580:  DATA 32,77
02582:  DATA 56,0D
02584:  DATA 0A,00
02586:  DATA 40,4D
02588:  DATA 4F,54
0258A:  DATA 3A,56
0258C:  DATA 41,4C
0258E:  DATA 3D,25
02590:  DATA 4C,75
02592:  DATA 20,53
02594:  DATA 59,52
02596:  DATA 3D,25
02598:  DATA 4C,64
0259A:  DATA 0D,0A
0259C:  DATA 00,00
0259E:  DATA 40,50
025A0:  DATA 57,52
025A2:  DATA 3A,25
025A4:  DATA 30,32
025A6:  DATA 75,2F
025A8:  DATA 25,30
025AA:  DATA 32,75
025AC:  DATA 2F,25
025AE:  DATA 30,32
025B0:  DATA 75,20
025B2:  DATA 25,30
025B4:  DATA 32,75
025B6:  DATA 3A,25
025B8:  DATA 30,32
025BA:  DATA 75,3A
025BC:  DATA 25,30
025BE:  DATA 32,75
025C0:  DATA 0D,0A
025C2:  DATA 00,00
025C4:  DATA 40,50
025C6:  DATA 57,52
025C8:  DATA 3A,25
025CA:  DATA 30,32
025CC:  DATA 75,2F
025CE:  DATA 25,30
025D0:  DATA 32,75
025D2:  DATA 2F,25
025D4:  DATA 30,32
025D6:  DATA 75,20
025D8:  DATA 25,30
025DA:  DATA 32,75
025DC:  DATA 3A,25
025DE:  DATA 30,32
025E0:  DATA 75,3A
025E2:  DATA 25,30
025E4:  DATA 32,75
025E6:  DATA 0D,0A
025E8:  DATA 00,00
025EA:  DATA 41,25
025EC:  DATA 4C,75
025EE:  DATA 20,49
025F0:  DATA 25,4C
025F2:  DATA 75,20
025F4:  DATA 4C,25
025F6:  DATA 4C,75
025F8:  DATA 20,51
025FA:  DATA 25,4C
025FC:  DATA 75,20
025FE:  DATA 53,25
02600:  DATA 4C,75
02602:  DATA 20,25
02604:  DATA 34,2E
02606:  DATA 32,77
02608:  DATA 56,0D
0260A:  DATA 0A,00
0260C:  DATA 40,4D
0260E:  DATA 4F,54
02610:  DATA 3A,56
02612:  DATA 41,4C
02614:  DATA 3D,25
02616:  DATA 4C,75
02618:  DATA 20,53
0261A:  DATA 59,52
0261C:  DATA 3D,25
0261E:  DATA 4C,64
02620:  DATA 0D,0A
02622:  DATA 00,00
02624:  DATA 40,50
02626:  DATA 57,52
02628:  DATA 3A,25
0262A:  DATA 30,32
0262C:  DATA 75,2F
0262E:  DATA 25,30
02630:  DATA 32,75
02632:  DATA 2F,25
02634:  DATA 30,32
02636:  DATA 75,20
02638:  DATA 25,30
0263A:  DATA 32,75
0263C:  DATA 3A,25
0263E:  DATA 30,32
02640:  DATA 75,3A
02642:  DATA 25,30
02644:  DATA 32,75
02646:  DATA 0D,0A
02648:  DATA 00,00
0264A:  DATA 49,25
0264C:  DATA 4C,75
0264E:  DATA 20,4E
02650:  DATA 25,4C
02652:  DATA 75,2F
02654:  DATA 25,4C
02656:  DATA 75,20
02658:  DATA 50,25
0265A:  DATA 4C,75
0265C:  DATA 20,25
0265E:  DATA 34,2E
02660:  DATA 32,77
02662:  DATA 56,0D
02664:  DATA 0A,00
02666:  DATA 40,4D
02668:  DATA 4F,54
0266A:  DATA 3A,53
0266C:  DATA 59,52
0266E:  DATA 3D,25
02670:  DATA 4C,64
02672:  DATA 0D,0A
02674:  DATA 00,00
02676:  DATA 40,50
02678:  DATA 57,52
0267A:  DATA 3A,25
0267C:  DATA 30,32
0267E:  DATA 75,2F
02680:  DATA 25,30
02682:  DATA 32,75
02684:  DATA 2F,25
02686:  DATA 30,32
02688:  DATA 75,20
0268A:  DATA 25,30
0268C:  DATA 32,75
0268E:  DATA 3A,25
02690:  DATA 30,32
02692:  DATA 75,3A
02694:  DATA 25,30
02696:  DATA 32,75
02698:  DATA 0D,0A
0269A:  DATA 00,00
0269C:  DATA 40,53
0269E:  DATA 4D,50
026A0:  DATA 20,25
026A2:  DATA 30,34
026A4:  DATA 4C,75
026A6:  DATA 0D,0A
026A8:  DATA 00,00
026AA:  DATA 40,53
026AC:  DATA 4D,50
026AE:  DATA 20,25
026B0:  DATA 30,34
026B2:  DATA 4C,75
026B4:  DATA 0D,0A
026B6:  DATA 00,00
026B8:  DATA 45,6E
026BA:  DATA 74,65
026BC:  DATA 72,20
026BE:  DATA 64,61
026C0:  DATA 74,65
026C2:  DATA 20,66
026C4:  DATA 6F,72
026C6:  DATA 6D,61
026C8:  DATA 74,20
026CA:  DATA 30,3D
026CC:  DATA 4D,4D
026CE:  DATA 2F,44
026D0:  DATA 44,2F
026D2:  DATA 59,59
026D4:  DATA 20,20
026D6:  DATA 31,3D
026D8:  DATA 44,44
026DA:  DATA 2F,4D
026DC:  DATA 4D,2F
026DE:  DATA 59,59
026E0:  DATA 0D,0A
026E2:  DATA 00,00
026E4:  DATA 40,4F
026E6:  DATA 4B,21
026E8:  DATA 0D,0A
026EA:  DATA 20,00
026EC:  DATA 40,45
026EE:  DATA 52,52
026F0:  DATA 0D,0A
026F2:  DATA 00,00
026F4:  DATA 40,52
026F6:  DATA 55,4E
026F8:  DATA 0D,0A
026FA:  DATA 00,00
026FC:  DATA 5B,6D
026FE:  DATA 6F,74
02700:  DATA 6F,72
02702:  DATA 3A,31
02704:  DATA 5D,0D
02706:  DATA 0A,00
02708:  DATA 5B,6D
0270A:  DATA 6F,74
0270C:  DATA 6F,72
0270E:  DATA 3A,32
02710:  DATA 5D,0D
02712:  DATA 0A,00
02714:  DATA 2C,45
02716:  DATA 43,4F
02718:  DATA 20,6D
0271A:  DATA 6F,64
0271C:  DATA 65,20
0271E:  DATA 73,65
02720:  DATA 74,0D
02722:  DATA 0A,00
02724:  DATA 2C,57
02726:  DATA 4D,53
02728:  DATA 2D,34
0272A:  DATA 2D,53
0272C:  DATA 44,20
0272E:  DATA 6D,6F
02730:  DATA 64,65
02732:  DATA 20,73
02734:  DATA 65,74
02736:  DATA 0D,0A
02738:  DATA 00,00
0273A:  DATA 2C,41
0273C:  DATA 57,53
0273E:  DATA 20,6D
02740:  DATA 6F,64
02742:  DATA 65,20
02744:  DATA 73,65
02746:  DATA 74,0D
02748:  DATA 0A,00
0274A:  DATA 2C,57
0274C:  DATA 4D,53
0274E:  DATA 2D,34
02750:  DATA 2D,51
02752:  DATA 45,20
02754:  DATA 6D,6F
02756:  DATA 64,65
02758:  DATA 20,73
0275A:  DATA 65,74
0275C:  DATA 0D,0A
0275E:  DATA 00,00
02760:  DATA 32,33
02762:  DATA 2D,4A
02764:  DATA 75,6E
02766:  DATA 2D,31
02768:  DATA 37,00
0276A:  DATA 31,33
0276C:  DATA 3A,35
0276E:  DATA 35,3A
02770:  DATA 30,36
02772:  DATA 00,00
02774:  DATA 53,45
02776:  DATA 4E,44
02778:  DATA 20,48
0277A:  DATA 45,58
0277C:  DATA 20,46
0277E:  DATA 49,4C
02780:  DATA 45,20
02782:  DATA 28,31
02784:  DATA 39,32
02786:  DATA 30,30
02788:  DATA 2C,4E
0278A:  DATA 38,31
0278C:  DATA 2C,58
0278E:  DATA 4F,4E
02790:  DATA 2D,58
02792:  DATA 4F,46
02794:  DATA 46,29
02796:  DATA 0D,0A
02798:  DATA 00,00
0279A:  DATA 40,4F
0279C:  DATA 4B,21
0279E:  DATA 20,00
027A0:  DATA 40,41
027A2:  DATA 52,47
027A4:  DATA 20,00
027A6:  DATA 40,49
027A8:  DATA 4E,56
027AA:  DATA 00,00
027AC:  DATA 40,43
027AE:  DATA 4D,44
027B0:  DATA 00,00
027B2:  DATA 2C,63
027B4:  DATA 6F,6D
027B6:  DATA 6D,61
027B8:  DATA 6E,64
027BA:  DATA 20,70
027BC:  DATA 72,6F
027BE:  DATA 6D,70
027C0:  DATA 74,0D
027C2:  DATA 0A,00
027C4:  DATA 40,53
027C6:  DATA 44,3D
027C8:  DATA 25,4C
027CA:  DATA 75,0D
027CC:  DATA 0A,00
027CE:  DATA 40,4D
027D0:  DATA 43,31
027D2:  DATA 2C,25
027D4:  DATA 4C,75
027D6:  DATA 2C,25
027D8:  DATA 4C,64
027DA:  DATA 0D,0A
027DC:  DATA 00,00
027DE:  DATA 40,4D
027E0:  DATA 43,32
027E2:  DATA 2C,25
027E4:  DATA 4C,75
027E6:  DATA 2C,25
027E8:  DATA 4C,64
027EA:  DATA 0D,0A
027EC:  DATA 00,00
027EE:  DATA 50,72
027F0:  DATA 65,73
027F2:  DATA 73,20
027F4:  DATA 61,6E
027F6:  DATA 64,20
027F8:  DATA 68,6F
027FA:  DATA 6C,64
027FC:  DATA 20,74
027FE:  DATA 68,65
02800:  DATA 20,45
02802:  DATA 73,63
02804:  DATA 20,6B
02806:  DATA 65,79
02808:  DATA 20,74
0280A:  DATA 6F,20
0280C:  DATA 72,65
0280E:  DATA 74,75
02810:  DATA 72,6E
02812:  DATA 20,74
02814:  DATA 6F,20
02816:  DATA 43,6F
02818:  DATA 6D,6D
0281A:  DATA 61,6E
0281C:  DATA 64,20
0281E:  DATA 4D,6F
02820:  DATA 64,65
02822:  DATA 0D,0A
02824:  DATA 00,00
02826:  DATA 52,65
02828:  DATA 74,75
0282A:  DATA 72,6E
0282C:  DATA 69,6E
0282E:  DATA 67,20
02830:  DATA 74,6F
02832:  DATA 20,4C
02834:  DATA 6F,67
02836:  DATA 67,69
02838:  DATA 6E,67
0283A:  DATA 20,4D
0283C:  DATA 6F,64
0283E:  DATA 65,0D
02840:  DATA 0A,00
*
02C52:  CLRF   01
02C54:  CLRF   02
02C56:  CLRF   00
02C58:  CLRF   03
02C5A:  MOVLB  8
02C5C:  MOVF   xBA,W
02C5E:  BNZ   2C64
02C60:  MOVF   xB9,W
02C62:  BZ    2C94
02C64:  MOVLW  10
02C66:  MOVWF  xBB
02C68:  BCF    FD8.0
02C6A:  RLCF   xB7,F
02C6C:  RLCF   xB8,F
02C6E:  RLCF   00,F
02C70:  RLCF   03,F
02C72:  MOVF   xBA,W
02C74:  SUBWF  03,W
02C76:  BNZ   2C7C
02C78:  MOVF   xB9,W
02C7A:  SUBWF  00,W
02C7C:  BNC   2C8C
02C7E:  MOVF   xB9,W
02C80:  SUBWF  00,F
02C82:  BTFSS  FD8.0
02C84:  DECF   03,F
02C86:  MOVF   xBA,W
02C88:  SUBWF  03,F
02C8A:  BSF    FD8.0
02C8C:  RLCF   01,F
02C8E:  RLCF   02,F
02C90:  DECFSZ xBB,F
02C92:  BRA    2C68
02C94:  MOVLB  0
02C96:  RETURN 0
*
034A4:  TSTFSZ 01
034A6:  BRA    34AE
034A8:  TSTFSZ 02
034AA:  BRA    34B0
034AC:  BRA    34BC
034AE:  INCF   02,F
034B0:  MOVFF  00,FEE
034B4:  DECFSZ 01,F
034B6:  BRA    34B0
034B8:  DECFSZ 02,F
034BA:  BRA    34B0
034BC:  RETURN 0
*
0358E:  MOVLB  9
03590:  BTFSC  xC9.7
03592:  BRA    35B4
03594:  MOVLW  0F
03596:  MOVWF  00
03598:  SWAPF  xC8,W
0359A:  ANDWF  00,F
0359C:  MOVLW  0A
0359E:  SUBWF  00,W
035A0:  BC    35A8
035A2:  MOVLW  30
035A4:  ADDWF  00,F
035A6:  BRA    35AC
035A8:  MOVF   xC9,W
035AA:  ADDWF  00,F
035AC:  MOVF   00,W
035AE:  BTFSS  F9E.4
035B0:  BRA    35AE
035B2:  MOVWF  FAD
035B4:  MOVLW  0F
035B6:  ANDWF  xC8,F
035B8:  MOVLW  0A
035BA:  SUBWF  xC8,W
035BC:  BC    35C2
035BE:  MOVLW  30
035C0:  BRA    35C6
035C2:  BCF    xC9.7
035C4:  MOVF   xC9,W
035C6:  ADDWF  xC8,F
035C8:  MOVF   xC8,W
035CA:  BTFSS  F9E.4
035CC:  BRA    35CA
035CE:  MOVWF  FAD
035D0:  MOVLB  0
035D2:  RETURN 0
*
04778:  MOVLB  9
0477A:  CLRF   xDA
0477C:  CLRF   xDB
0477E:  MOVLW  01
04780:  MOVWF  xDC
04782:  CLRF   FDA
04784:  CLRF   FD9
04786:  MOVLW  09
04788:  MOVWF  xDF
0478A:  MOVLW  D2
0478C:  MOVWF  xDE
0478E:  MOVLW  09
04790:  MOVWF  FEA
04792:  MOVLW  D6
04794:  MOVWF  FE9
04796:  MOVFF  9DF,FE2
0479A:  MOVFF  9DE,FE1
0479E:  MOVFF  9DC,9DD
047A2:  BCF    FD8.0
047A4:  MOVF   FE5,W
047A6:  MULWF  FEE
047A8:  MOVF   FF3,W
047AA:  ADDWFC xDA,F
047AC:  MOVF   FF4,W
047AE:  ADDWFC xDB,F
047B0:  DECFSZ xDD,F
047B2:  BRA    47A2
047B4:  MOVFF  9DA,FDE
047B8:  MOVFF  9DB,9DA
047BC:  CLRF   xDB
047BE:  BTFSC  FD8.0
047C0:  INCF   xDB,F
047C2:  INCF   xDE,F
047C4:  BTFSC  FD8.2
047C6:  INCF   xDF,F
047C8:  INCF   xDC,F
047CA:  MOVF   xDC,W
047CC:  SUBLW  05
047CE:  BNZ   478E
047D0:  MOVLB  0
047D2:  RETURN 0
*
0501C:  MOVFF  1E,FEA
05020:  MOVFF  1D,FE9
05024:  MOVLB  8
05026:  MOVFF  8DB,FEF
0502A:  INCF   FE9,F
0502C:  BTFSC  FD8.2
0502E:  INCF   FEA,F
05030:  CLRF   FEF
05032:  INCF   1D,F
05034:  BTFSC  FD8.2
05036:  INCF   1E,F
05038:  MOVLB  0
0503A:  RETURN 0
0503C:  TBLRD*+
0503E:  MOVF   FF5,F
05040:  BZ    5062
05042:  MOVFF  FF6,8C7
05046:  MOVFF  FF7,8C8
0504A:  MOVFF  FF8,8C9
0504E:  MOVFF  FF5,8DB
05052:  RCALL  501C
05054:  MOVFF  8C7,FF6
05058:  MOVFF  8C8,FF7
0505C:  MOVFF  8C9,FF8
05060:  BRA    503C
05062:  RETURN 0
*
051FE:  MOVF   01,W
05200:  CLRF   1B
05202:  BTFSC  FF2.7
05204:  BSF    1B.7
05206:  BCF    FF2.7
05208:  MOVFF  8C9,A1A
0520C:  MOVLW  64
0520E:  MOVLB  A
05210:  MOVWF  x1B
05212:  MOVLB  0
05214:  CALL   0F5C
05218:  BTFSC  1B.7
0521A:  BSF    FF2.7
0521C:  MOVFF  00,8C9
05220:  MOVF   01,W
05222:  MOVLW  30
05224:  BNZ   5236
05226:  MOVLB  8
05228:  BTFSS  xCA.1
0522A:  BRA    524A
0522C:  BTFSC  xCA.3
0522E:  BRA    524A
05230:  BTFSC  xCA.4
05232:  MOVLW  20
05234:  BRA    523E
05236:  MOVLB  8
05238:  BCF    xCA.3
0523A:  BCF    xCA.4
0523C:  BSF    xCA.0
0523E:  ADDWF  01,F
05240:  MOVFF  01,8DB
05244:  MOVLB  0
05246:  RCALL  501C
05248:  MOVLB  8
0524A:  CLRF   1B
0524C:  BTFSC  FF2.7
0524E:  BSF    1B.7
05250:  BCF    FF2.7
05252:  MOVFF  8C9,A1A
05256:  MOVLW  0A
05258:  MOVLB  A
0525A:  MOVWF  x1B
0525C:  MOVLB  0
0525E:  CALL   0F5C
05262:  BTFSC  1B.7
05264:  BSF    FF2.7
05266:  MOVFF  00,8C9
0526A:  MOVF   01,W
0526C:  MOVLW  30
0526E:  BNZ   5280
05270:  MOVLB  8
05272:  BTFSC  xCA.3
05274:  BRA    528A
05276:  BTFSS  xCA.0
05278:  BRA    528A
0527A:  BTFSC  xCA.4
0527C:  MOVLW  20
0527E:  MOVLB  0
05280:  ADDWF  01,F
05282:  MOVFF  01,8DB
05286:  RCALL  501C
05288:  MOVLB  8
0528A:  MOVLW  30
0528C:  ADDWF  xC9,F
0528E:  MOVFF  8C9,8DB
05292:  MOVLB  0
05294:  RCALL  501C
05296:  RETURN 0
05298:  MOVF   FE9,W
0529A:  MOVLB  8
0529C:  MOVWF  xCE
0529E:  MOVLW  3B
052A0:  MOVWF  xD5
052A2:  MOVLW  9A
052A4:  MOVWF  xD4
052A6:  MOVLW  CA
052A8:  MOVWF  xD3
052AA:  CLRF   xD2
052AC:  MOVLW  0A
052AE:  MOVWF  xD0
052B0:  MOVF   xCD,W
052B2:  BTFSS  FD8.2
052B4:  DECF   xCE,F
052B6:  BSF    FD8.1
052B8:  MOVLW  08
052BA:  MOVWF  FEA
052BC:  MOVLW  C9
052BE:  MOVWF  FE9
052C0:  CLRF   1B
052C2:  BTFSC  FF2.7
052C4:  BSF    1B.7
052C6:  BCF    FF2.7
052C8:  MOVFF  8CC,A27
052CC:  MOVFF  8CB,A26
052D0:  MOVFF  8CA,A25
052D4:  MOVFF  8C9,A24
052D8:  MOVFF  8D5,A2B
052DC:  MOVFF  8D4,A2A
052E0:  MOVFF  8D3,A29
052E4:  MOVFF  8D2,A28
052E8:  MOVLB  0
052EA:  CALL   1038
052EE:  BTFSC  1B.7
052F0:  BSF    FF2.7
052F2:  MOVF   01,W
052F4:  MOVF   00,F
052F6:  BNZ   531E
052F8:  MOVLB  8
052FA:  INCF   xCD,W
052FC:  SUBWF  xD0,W
052FE:  BTFSS  FD8.2
05300:  BRA    5306
05302:  MOVLB  0
05304:  BRA    531E
05306:  MOVF   xCE,W
05308:  BZ    5322
0530A:  ANDLW  0F
0530C:  SUBWF  xD0,W
0530E:  BZ    5312
05310:  BC    534E
05312:  BTFSC  xCE.7
05314:  BRA    534E
05316:  BTFSC  xCE.6
05318:  BRA    5322
0531A:  MOVLW  20
0531C:  BRA    5342
0531E:  MOVLB  8
05320:  CLRF   xCE
05322:  MOVF   xCD,W
05324:  SUBWF  xD0,W
05326:  BNZ   5340
05328:  MOVFF  00,8CE
0532C:  MOVLW  2E
0532E:  MOVWF  xDB
05330:  MOVLB  0
05332:  RCALL  501C
05334:  MOVLB  8
05336:  MOVFF  8CE,00
0533A:  MOVLW  20
0533C:  ANDWF  xCE,F
0533E:  MOVLW  00
05340:  MOVLW  30
05342:  ADDWF  00,F
05344:  MOVFF  00,8DB
05348:  MOVLB  0
0534A:  RCALL  501C
0534C:  MOVLB  8
0534E:  BCF    FD8.1
05350:  CLRF   1B
05352:  BTFSC  FF2.7
05354:  BSF    1B.7
05356:  BCF    FF2.7
05358:  MOVFF  8D5,A27
0535C:  MOVFF  8D4,A26
05360:  MOVFF  8D3,A25
05364:  MOVFF  8D2,A24
05368:  MOVLB  A
0536A:  CLRF   x2B
0536C:  CLRF   x2A
0536E:  CLRF   x29
05370:  MOVLW  0A
05372:  MOVWF  x28
05374:  MOVLB  0
05376:  CALL   1038
0537A:  BTFSC  1B.7
0537C:  BSF    FF2.7
0537E:  MOVFF  03,8D5
05382:  MOVFF  02,8D4
05386:  MOVFF  01,8D3
0538A:  MOVFF  00,8D2
0538E:  MOVLB  8
05390:  DECFSZ xD0,F
05392:  BRA    52B6
05394:  MOVLB  0
05396:  RETURN 0
*
05C22:  MOVLB  9
05C24:  MOVF   xE8,W
05C26:  MULWF  xEA
05C28:  MOVFF  FF3,01
05C2C:  MOVFF  FF4,00
05C30:  MULWF  xEB
05C32:  MOVF   FF3,W
05C34:  ADDWF  00,F
05C36:  MOVF   xE9,W
05C38:  MULWF  xEA
05C3A:  MOVF   FF3,W
05C3C:  ADDWFC 00,W
05C3E:  MOVWF  02
05C40:  MOVLB  0
05C42:  RETURN 0
*
078E6:  MOVF   FEF,F
078E8:  BZ    790A
078EA:  MOVFF  FEA,98D
078EE:  MOVFF  FE9,98C
078F2:  MOVF   FEF,W
078F4:  BTFSS  F9E.4
078F6:  BRA    78F4
078F8:  MOVWF  FAD
078FA:  MOVFF  98D,FEA
078FE:  MOVFF  98C,FE9
07902:  INCF   FE9,F
07904:  BTFSC  FD8.2
07906:  INCF   FEA,F
07908:  BRA    78E6
0790A:  RETURN 0
*
08F2E:  MOVFF  FEA,8D4
08F32:  MOVFF  FE9,8D3
08F36:  MOVLB  8
08F38:  BTFSS  xCD.7
08F3A:  BRA    8F4C
08F3C:  BSF    xD3.7
08F3E:  BTFSS  xD3.4
08F40:  INCF   xD3,F
08F42:  COMF   xCC,F
08F44:  COMF   xCD,F
08F46:  INCF   xCC,F
08F48:  BTFSC  FD8.2
08F4A:  INCF   xCD,F
08F4C:  SWAPF  xCD,W
08F4E:  IORLW  F0
08F50:  MOVWF  xCF
08F52:  ADDWF  xCF,F
08F54:  ADDLW  E2
08F56:  MOVWF  xD0
08F58:  ADDLW  32
08F5A:  MOVWF  xD2
08F5C:  MOVF   xCD,W
08F5E:  ANDLW  0F
08F60:  ADDWF  xD0,F
08F62:  ADDWF  xD0,F
08F64:  ADDWF  xD2,F
08F66:  ADDLW  E9
08F68:  MOVWF  xD1
08F6A:  ADDWF  xD1,F
08F6C:  ADDWF  xD1,F
08F6E:  SWAPF  xCC,W
08F70:  ANDLW  0F
08F72:  ADDWF  xD1,F
08F74:  ADDWF  xD2,F
08F76:  RLCF   xD1,F
08F78:  RLCF   xD2,F
08F7A:  COMF   xD2,F
08F7C:  RLCF   xD2,F
08F7E:  MOVF   xCC,W
08F80:  ANDLW  0F
08F82:  ADDWF  xD2,F
08F84:  RLCF   xCF,F
08F86:  MOVLW  07
08F88:  MOVWF  xCE
08F8A:  MOVLW  0A
08F8C:  DECF   xD1,F
08F8E:  ADDWF  xD2,F
08F90:  BNC   8F8C
08F92:  DECF   xD0,F
08F94:  ADDWF  xD1,F
08F96:  BNC   8F92
08F98:  DECF   xCF,F
08F9A:  ADDWF  xD0,F
08F9C:  BNC   8F98
08F9E:  DECF   xCE,F
08FA0:  ADDWF  xCF,F
08FA2:  BNC   8F9E
08FA4:  MOVLW  08
08FA6:  MOVWF  FEA
08FA8:  MOVLW  CE
08FAA:  MOVWF  FE9
08FAC:  MOVLW  07
08FAE:  ANDWF  xD3,W
08FB0:  BCF    xD3.6
08FB2:  MOVF   FED,F
08FB4:  ANDWF  xD3,W
08FB6:  BNZ   8FC6
08FB8:  BTFSC  xD3.4
08FBA:  MOVF   FEE,F
08FBC:  BTFSC  xD3.4
08FBE:  BRA    8FC6
08FC0:  MOVLW  20
08FC2:  MOVWF  00
08FC4:  BRA    9008
08FC6:  ADDWF  FE9,F
08FC8:  MOVLW  00
08FCA:  ADDWFC FEA,F
08FCC:  MOVF   FE9,W
08FCE:  SUBLW  D2
08FD0:  BNZ   8FDA
08FD2:  MOVF   FEA,W
08FD4:  SUBLW  08
08FD6:  BNZ   8FDA
08FD8:  BSF    xD3.6
08FDA:  MOVF   FEF,W
08FDC:  MOVWF  00
08FDE:  BNZ   8FF0
08FE0:  BTFSC  xD3.6
08FE2:  BRA    8FF0
08FE4:  BTFSC  xD3.4
08FE6:  BRA    9010
08FE8:  BTFSC  xD3.3
08FEA:  BRA    8FF0
08FEC:  MOVLW  20
08FEE:  BRA    9006
08FF0:  BTFSS  xD3.7
08FF2:  BRA    9000
08FF4:  MOVLW  2D
08FF6:  MOVWF  00
08FF8:  MOVF   FED,W
08FFA:  BCF    xD3.6
08FFC:  BCF    xD3.7
08FFE:  BRA    9008
09000:  BSF    xD3.3
09002:  BCF    xD3.4
09004:  MOVLW  30
09006:  ADDWF  00,F
09008:  MOVF   00,W
0900A:  BTFSS  F9E.4
0900C:  BRA    900A
0900E:  MOVWF  FAD
09010:  MOVF   FEE,W
09012:  BTFSS  xD3.6
09014:  BRA    8FCC
09016:  MOVLB  0
09018:  RETURN 0
*
094AE:  MOVF   FE9,W
094B0:  MOVLB  8
094B2:  MOVWF  xD2
094B4:  BTFSS  xD1.7
094B6:  BRA    94D2
094B8:  DECF   xD2,F
094BA:  BSF    xD2.5
094BC:  COMF   xCE,F
094BE:  COMF   xCF,F
094C0:  COMF   xD0,F
094C2:  COMF   xD1,F
094C4:  INCF   xCE,F
094C6:  BTFSC  FD8.2
094C8:  INCF   xCF,F
094CA:  BTFSC  FD8.2
094CC:  INCF   xD0,F
094CE:  BTFSC  FD8.2
094D0:  INCF   xD1,F
094D2:  MOVLW  3B
094D4:  MOVWF  xD9
094D6:  MOVLW  9A
094D8:  MOVWF  xD8
094DA:  MOVLW  CA
094DC:  MOVWF  xD7
094DE:  CLRF   xD6
094E0:  MOVLW  0A
094E2:  MOVWF  xD4
094E4:  BSF    FD8.1
094E6:  MOVLW  08
094E8:  MOVWF  FEA
094EA:  MOVLW  CE
094EC:  MOVWF  FE9
094EE:  CLRF   1B
094F0:  BTFSC  FF2.7
094F2:  BSF    1B.7
094F4:  BCF    FF2.7
094F6:  MOVFF  8D1,A27
094FA:  MOVFF  8D0,A26
094FE:  MOVFF  8CF,A25
09502:  MOVFF  8CE,A24
09506:  MOVFF  8D9,A2B
0950A:  MOVFF  8D8,A2A
0950E:  MOVFF  8D7,A29
09512:  MOVFF  8D6,A28
09516:  MOVLB  0
09518:  CALL   1038
0951C:  BTFSC  1B.7
0951E:  BSF    FF2.7
09520:  MOVF   01,W
09522:  MOVF   00,F
09524:  BNZ   954C
09526:  MOVLB  8
09528:  MOVF   xD4,W
0952A:  XORLW  01
0952C:  BTFSS  FD8.2
0952E:  BRA    9534
09530:  MOVLB  0
09532:  BRA    954C
09534:  MOVF   xD2,W
09536:  BZ    9552
09538:  ANDLW  0F
0953A:  SUBWF  xD4,W
0953C:  BZ    9540
0953E:  BC    9590
09540:  BTFSC  xD2.7
09542:  BRA    9590
09544:  BTFSC  xD2.6
09546:  BRA    9552
09548:  MOVLW  20
0954A:  BRA    9586
0954C:  MOVLW  20
0954E:  MOVLB  8
09550:  ANDWF  xD2,F
09552:  BTFSS  xD2.5
09554:  BRA    956A
09556:  BCF    xD2.5
09558:  MOVFF  00,8D2
0955C:  MOVLW  2D
0955E:  BTFSS  F9E.4
09560:  BRA    955E
09562:  MOVWF  FAD
09564:  MOVFF  8D2,00
09568:  CLRF   xD2
0956A:  MOVLW  30
0956C:  BTFSS  xD2.5
0956E:  BRA    9586
09570:  BCF    xD2.5
09572:  MOVFF  00,8D2
09576:  MOVLW  2D
09578:  BTFSS  F9E.4
0957A:  BRA    9578
0957C:  MOVWF  FAD
0957E:  MOVFF  8D2,00
09582:  CLRF   xD2
09584:  MOVLW  30
09586:  ADDWF  00,F
09588:  MOVF   00,W
0958A:  BTFSS  F9E.4
0958C:  BRA    958A
0958E:  MOVWF  FAD
09590:  BCF    FD8.1
09592:  CLRF   1B
09594:  BTFSC  FF2.7
09596:  BSF    1B.7
09598:  BCF    FF2.7
0959A:  MOVFF  8D9,A27
0959E:  MOVFF  8D8,A26
095A2:  MOVFF  8D7,A25
095A6:  MOVFF  8D6,A24
095AA:  MOVLB  A
095AC:  CLRF   x2B
095AE:  CLRF   x2A
095B0:  CLRF   x29
095B2:  MOVLW  0A
095B4:  MOVWF  x28
095B6:  MOVLB  0
095B8:  CALL   1038
095BC:  BTFSC  1B.7
095BE:  BSF    FF2.7
095C0:  MOVFF  03,8D9
095C4:  MOVFF  02,8D8
095C8:  MOVFF  01,8D7
095CC:  MOVFF  00,8D6
095D0:  MOVLB  8
095D2:  DECFSZ xD4,F
095D4:  BRA    94E4
095D6:  MOVLB  0
095D8:  RETURN 0
*
0A6A2:  ADDWF  FE8,W
0A6A4:  CLRF   FF7
0A6A6:  RLCF   FF7,F
0A6A8:  ADDLW  C3
0A6AA:  MOVWF  FF6
0A6AC:  MOVLW  A6
0A6AE:  ADDWFC FF7,F
0A6B0:  MOVLW  00
0A6B2:  MOVWF  FF8
0A6B4:  MOVWF  FFB
0A6B6:  TBLRD*-
0A6B8:  MOVF   FF5,W
0A6BA:  MOVWF  FFA
0A6BC:  TBLRD*
0A6BE:  MOVF   FF5,W
0A6C0:  MOVWF  FF9
0A6C2:  DATA FE,9F
0A6C4:  DATA 1E,A0
0A6C6:  DATA 46,A0
0A6C8:  DATA 76,A0
0A6CA:  DATA 9E,A0
*
0AA0E:  TBLRD*+
0AA10:  MOVFF  FF6,8C8
0AA14:  MOVFF  FF7,8C9
0AA18:  MOVFF  FF8,8CA
0AA1C:  MOVFF  FF5,8DB
0AA20:  CALL   501C
0AA24:  MOVFF  8C8,FF6
0AA28:  MOVFF  8C9,FF7
0AA2C:  MOVFF  8CA,FF8
0AA30:  MOVLB  8
0AA32:  DECFSZ xC7,F
0AA34:  BRA    AA38
0AA36:  BRA    AA3C
0AA38:  MOVLB  0
0AA3A:  BRA    AA0E
0AA3C:  MOVLB  0
0AA3E:  RETURN 0
0AA40:  MOVFF  FEA,8DA
0AA44:  MOVFF  FE9,8D9
0AA48:  MOVLB  8
0AA4A:  SWAPF  xD3,W
0AA4C:  IORLW  F0
0AA4E:  MOVWF  xD5
0AA50:  ADDWF  xD5,F
0AA52:  ADDLW  E2
0AA54:  MOVWF  xD6
0AA56:  ADDLW  32
0AA58:  MOVWF  xD8
0AA5A:  MOVF   xD3,W
0AA5C:  ANDLW  0F
0AA5E:  ADDWF  xD6,F
0AA60:  ADDWF  xD6,F
0AA62:  ADDWF  xD8,F
0AA64:  ADDLW  E9
0AA66:  MOVWF  xD7
0AA68:  ADDWF  xD7,F
0AA6A:  ADDWF  xD7,F
0AA6C:  SWAPF  xD2,W
0AA6E:  ANDLW  0F
0AA70:  ADDWF  xD7,F
0AA72:  ADDWF  xD8,F
0AA74:  RLCF   xD7,F
0AA76:  RLCF   xD8,F
0AA78:  COMF   xD8,F
0AA7A:  RLCF   xD8,F
0AA7C:  MOVF   xD2,W
0AA7E:  ANDLW  0F
0AA80:  ADDWF  xD8,F
0AA82:  RLCF   xD5,F
0AA84:  MOVLW  07
0AA86:  MOVWF  xD4
0AA88:  MOVLW  0A
0AA8A:  DECF   xD7,F
0AA8C:  ADDWF  xD8,F
0AA8E:  BNC   AA8A
0AA90:  DECF   xD6,F
0AA92:  ADDWF  xD7,F
0AA94:  BNC   AA90
0AA96:  DECF   xD5,F
0AA98:  ADDWF  xD6,F
0AA9A:  BNC   AA96
0AA9C:  DECF   xD4,F
0AA9E:  ADDWF  xD5,F
0AAA0:  BNC   AA9C
0AAA2:  MOVLW  08
0AAA4:  MOVWF  FEA
0AAA6:  MOVLW  D4
0AAA8:  MOVWF  FE9
0AAAA:  MOVLW  07
0AAAC:  ANDWF  xD9,W
0AAAE:  BCF    xD9.6
0AAB0:  ADDWF  FE9,F
0AAB2:  MOVLW  00
0AAB4:  ADDWFC FEA,F
0AAB6:  MOVF   FE9,W
0AAB8:  SUBLW  D8
0AABA:  BNZ   AAC4
0AABC:  MOVF   FEA,W
0AABE:  SUBLW  08
0AAC0:  BNZ   AAC4
0AAC2:  BSF    xD9.6
0AAC4:  MOVF   FEF,W
0AAC6:  MOVWF  00
0AAC8:  BNZ   AADA
0AACA:  BTFSC  xD9.6
0AACC:  BRA    AADA
0AACE:  BTFSC  xD9.4
0AAD0:  BRA    AAFE
0AAD2:  BTFSC  xD9.3
0AAD4:  BRA    AADA
0AAD6:  MOVLW  20
0AAD8:  BRA    AAE0
0AADA:  BSF    xD9.3
0AADC:  BCF    xD9.4
0AADE:  MOVLW  30
0AAE0:  ADDWF  00,F
0AAE2:  MOVFF  FEA,8D3
0AAE6:  MOVFF  FE9,8D2
0AAEA:  MOVFF  00,8DB
0AAEE:  MOVLB  0
0AAF0:  CALL   501C
0AAF4:  MOVFF  8D3,FEA
0AAF8:  MOVFF  8D2,FE9
0AAFC:  MOVLB  8
0AAFE:  MOVF   FEE,W
0AB00:  BTFSS  xD9.6
0AB02:  BRA    AAB6
0AB04:  MOVLB  0
0AB06:  RETURN 0
*
0ACF2:  ADDWF  FE8,W
0ACF4:  CLRF   FF7
0ACF6:  RLCF   FF7,F
0ACF8:  ADDLW  13
0ACFA:  MOVWF  FF6
0ACFC:  MOVLW  AD
0ACFE:  ADDWFC FF7,F
0AD00:  MOVLW  00
0AD02:  MOVWF  FF8
0AD04:  MOVWF  FFB
0AD06:  TBLRD*-
0AD08:  MOVF   FF5,W
0AD0A:  MOVWF  FFA
0AD0C:  TBLRD*
0AD0E:  MOVF   FF5,W
0AD10:  MOVWF  FF9
0AD12:  DATA 02,AC
0AD14:  DATA EE,AC
0AD16:  DATA EE,AC
0AD18:  DATA 62,AB
0AD1A:  DATA EE,AC
0AD1C:  DATA EE,AC
0AD1E:  DATA EE,AC
0AD20:  DATA 26,AB
0AD22:  DATA EE,AC
0AD24:  DATA EE,AC
0AD26:  DATA EE,AC
0AD28:  DATA 78,AC
0AD2A:  DATA 9E,AB
0AD2C:  DATA EE,AC
0AD2E:  DATA 3C,AC
0AD30:  DATA B4,AC
*
0AD8C:  TBLRD*+
0AD8E:  MOVF   FF5,F
0AD90:  BZ    ADB4
0AD92:  MOVFF  FF6,861
0AD96:  MOVFF  FF7,862
0AD9A:  MOVFF  FF8,863
0AD9E:  MOVF   FF5,W
0ADA0:  BTFSS  F9E.4
0ADA2:  BRA    ADA0
0ADA4:  MOVWF  FAD
0ADA6:  MOVFF  861,FF6
0ADAA:  MOVFF  862,FF7
0ADAE:  MOVFF  863,FF8
0ADB2:  BRA    AD8C
0ADB4:  RETURN 0
*
0BF40:  MOVLB  8
0BF42:  MOVF   xEF,W
0BF44:  BTFSC  FD8.2
0BF46:  BRA    C02A
0BF48:  MOVWF  00
0BF4A:  MOVF   xF3,W
0BF4C:  BTFSC  FD8.2
0BF4E:  BRA    C02A
0BF50:  ADDWF  00,F
0BF52:  BNC   BF5C
0BF54:  MOVLW  81
0BF56:  ADDWF  00,F
0BF58:  BC    C02A
0BF5A:  BRA    BF64
0BF5C:  MOVLW  7F
0BF5E:  SUBWF  00,F
0BF60:  BNC   C02A
0BF62:  BZ    C02A
0BF64:  MOVFF  8F0,8F7
0BF68:  MOVF   xF4,W
0BF6A:  XORWF  xF7,F
0BF6C:  BSF    xF0.7
0BF6E:  BSF    xF4.7
0BF70:  MOVF   xF2,W
0BF72:  MULWF  xF6
0BF74:  MOVFF  FF4,8F9
0BF78:  MOVF   xF1,W
0BF7A:  MULWF  xF5
0BF7C:  MOVFF  FF4,03
0BF80:  MOVFF  FF3,8F8
0BF84:  MULWF  xF6
0BF86:  MOVF   FF3,W
0BF88:  ADDWF  xF9,F
0BF8A:  MOVF   FF4,W
0BF8C:  ADDWFC xF8,F
0BF8E:  MOVLW  00
0BF90:  ADDWFC 03,F
0BF92:  MOVF   xF2,W
0BF94:  MULWF  xF5
0BF96:  MOVF   FF3,W
0BF98:  ADDWF  xF9,F
0BF9A:  MOVF   FF4,W
0BF9C:  ADDWFC xF8,F
0BF9E:  MOVLW  00
0BFA0:  CLRF   02
0BFA2:  ADDWFC 03,F
0BFA4:  ADDWFC 02,F
0BFA6:  MOVF   xF0,W
0BFA8:  MULWF  xF6
0BFAA:  MOVF   FF3,W
0BFAC:  ADDWF  xF8,F
0BFAE:  MOVF   FF4,W
0BFB0:  ADDWFC 03,F
0BFB2:  MOVLW  00
0BFB4:  ADDWFC 02,F
0BFB6:  MOVF   xF0,W
0BFB8:  MULWF  xF5
0BFBA:  MOVF   FF3,W
0BFBC:  ADDWF  03,F
0BFBE:  MOVF   FF4,W
0BFC0:  ADDWFC 02,F
0BFC2:  MOVLW  00
0BFC4:  CLRF   01
0BFC6:  ADDWFC 01,F
0BFC8:  MOVF   xF2,W
0BFCA:  MULWF  xF4
0BFCC:  MOVF   FF3,W
0BFCE:  ADDWF  xF8,F
0BFD0:  MOVF   FF4,W
0BFD2:  ADDWFC 03,F
0BFD4:  MOVLW  00
0BFD6:  ADDWFC 02,F
0BFD8:  ADDWFC 01,F
0BFDA:  MOVF   xF1,W
0BFDC:  MULWF  xF4
0BFDE:  MOVF   FF3,W
0BFE0:  ADDWF  03,F
0BFE2:  MOVF   FF4,W
0BFE4:  ADDWFC 02,F
0BFE6:  MOVLW  00
0BFE8:  ADDWFC 01,F
0BFEA:  MOVF   xF0,W
0BFEC:  MULWF  xF4
0BFEE:  MOVF   FF3,W
0BFF0:  ADDWF  02,F
0BFF2:  MOVF   FF4,W
0BFF4:  ADDWFC 01,F
0BFF6:  INCF   00,F
0BFF8:  BTFSC  01.7
0BFFA:  BRA    C006
0BFFC:  RLCF   xF8,F
0BFFE:  RLCF   03,F
0C000:  RLCF   02,F
0C002:  RLCF   01,F
0C004:  DECF   00,F
0C006:  MOVLW  00
0C008:  BTFSS  xF8.7
0C00A:  BRA    C020
0C00C:  INCF   03,F
0C00E:  ADDWFC 02,F
0C010:  ADDWFC 01,F
0C012:  MOVF   01,W
0C014:  BNZ   C020
0C016:  MOVF   02,W
0C018:  BNZ   C020
0C01A:  MOVF   03,W
0C01C:  BNZ   C020
0C01E:  INCF   00,F
0C020:  BTFSC  xF7.7
0C022:  BSF    01.7
0C024:  BTFSS  xF7.7
0C026:  BCF    01.7
0C028:  BRA    C032
0C02A:  CLRF   00
0C02C:  CLRF   01
0C02E:  CLRF   02
0C030:  CLRF   03
0C032:  MOVLB  0
0C034:  RETURN 0
0C036:  MOVLW  80
0C038:  BTFSS  FD8.1
0C03A:  BRA    C040
0C03C:  MOVLB  8
0C03E:  XORWF  xF8,F
0C040:  MOVLB  8
0C042:  CLRF   xFD
0C044:  CLRF   xFE
0C046:  MOVFF  8F4,8FC
0C04A:  MOVF   xF8,W
0C04C:  XORWF  xFC,F
0C04E:  MOVF   xF3,W
0C050:  BTFSC  FD8.2
0C052:  BRA    C290
0C054:  MOVWF  xFB
0C056:  MOVWF  00
0C058:  MOVF   xF7,W
0C05A:  BTFSC  FD8.2
0C05C:  BRA    C2A4
0C05E:  SUBWF  xFB,F
0C060:  BTFSC  FD8.2
0C062:  BRA    C1A4
0C064:  BNC   C100
0C066:  MOVFF  8F8,901
0C06A:  MOVLB  9
0C06C:  BSF    x01.7
0C06E:  MOVFF  8F9,900
0C072:  MOVFF  8FA,8FF
0C076:  MOVLB  8
0C078:  CLRF   xFE
0C07A:  BCF    FD8.0
0C07C:  MOVLB  9
0C07E:  RRCF   x01,F
0C080:  RRCF   x00,F
0C082:  MOVLB  8
0C084:  RRCF   xFF,F
0C086:  RRCF   xFE,F
0C088:  DECFSZ xFB,F
0C08A:  BRA    C078
0C08C:  BTFSS  xFC.7
0C08E:  BRA    C096
0C090:  BSF    xFD.0
0C092:  BRA    C2D4
0C094:  BCF    xFD.0
0C096:  BCF    xFB.0
0C098:  BSF    xFD.4
0C09A:  MOVLW  08
0C09C:  MOVWF  FEA
0C09E:  MOVLW  F6
0C0A0:  MOVWF  FE9
0C0A2:  BRA    C308
0C0A4:  BCF    xFD.4
0C0A6:  BTFSC  xFC.7
0C0A8:  BRA    C0C2
0C0AA:  BTFSS  xFB.0
0C0AC:  BRA    C0E2
0C0AE:  MOVLB  9
0C0B0:  RRCF   x01,F
0C0B2:  RRCF   x00,F
0C0B4:  MOVLB  8
0C0B6:  RRCF   xFF,F
0C0B8:  RRCF   xFE,F
0C0BA:  INCF   00,F
0C0BC:  BTFSC  FD8.2
0C0BE:  BRA    C2C6
0C0C0:  BRA    C0E2
0C0C2:  MOVLB  9
0C0C4:  BTFSC  x01.7
0C0C6:  BRA    C0E8
0C0C8:  BCF    FD8.0
0C0CA:  MOVLB  8
0C0CC:  RLCF   xFE,F
0C0CE:  RLCF   xFF,F
0C0D0:  MOVLB  9
0C0D2:  RLCF   x00,F
0C0D4:  RLCF   x01,F
0C0D6:  DECFSZ 00,F
0C0D8:  BRA    C0DE
0C0DA:  MOVLB  8
0C0DC:  BRA    C2C6
0C0DE:  BRA    C0C4
0C0E0:  MOVLB  8
0C0E2:  BSF    xFD.6
0C0E4:  BRA    C1F2
0C0E6:  BCF    xFD.6
0C0E8:  MOVFF  8F4,8FC
0C0EC:  MOVLB  8
0C0EE:  BTFSS  xF4.7
0C0F0:  BRA    C0F8
0C0F2:  MOVLB  9
0C0F4:  BSF    x01.7
0C0F6:  BRA    C2B6
0C0F8:  MOVLB  9
0C0FA:  BCF    x01.7
0C0FC:  BRA    C2B6
0C0FE:  MOVLB  8
0C100:  MOVFF  8F7,8FB
0C104:  MOVFF  8F7,00
0C108:  MOVF   xF3,W
0C10A:  SUBWF  xFB,F
0C10C:  MOVFF  8F4,901
0C110:  MOVLB  9
0C112:  BSF    x01.7
0C114:  MOVFF  8F5,900
0C118:  MOVFF  8F6,8FF
0C11C:  MOVLB  8
0C11E:  CLRF   xFE
0C120:  BCF    FD8.0
0C122:  MOVLB  9
0C124:  RRCF   x01,F
0C126:  RRCF   x00,F
0C128:  MOVLB  8
0C12A:  RRCF   xFF,F
0C12C:  RRCF   xFE,F
0C12E:  DECFSZ xFB,F
0C130:  BRA    C11E
0C132:  BTFSS  xFC.7
0C134:  BRA    C13C
0C136:  BSF    xFD.1
0C138:  BRA    C2D4
0C13A:  BCF    xFD.1
0C13C:  BCF    xFB.0
0C13E:  BSF    xFD.5
0C140:  MOVLW  08
0C142:  MOVWF  FEA
0C144:  MOVLW  FA
0C146:  MOVWF  FE9
0C148:  BRA    C308
0C14A:  BCF    xFD.5
0C14C:  BTFSC  xFC.7
0C14E:  BRA    C168
0C150:  BTFSS  xFB.0
0C152:  BRA    C188
0C154:  MOVLB  9
0C156:  RRCF   x01,F
0C158:  RRCF   x00,F
0C15A:  MOVLB  8
0C15C:  RRCF   xFF,F
0C15E:  RRCF   xFE,F
0C160:  INCF   00,F
0C162:  BTFSC  FD8.2
0C164:  BRA    C2C6
0C166:  BRA    C188
0C168:  MOVLB  9
0C16A:  BTFSC  x01.7
0C16C:  BRA    C18E
0C16E:  BCF    FD8.0
0C170:  MOVLB  8
0C172:  RLCF   xFE,F
0C174:  RLCF   xFF,F
0C176:  MOVLB  9
0C178:  RLCF   x00,F
0C17A:  RLCF   x01,F
0C17C:  DECFSZ 00,F
0C17E:  BRA    C184
0C180:  MOVLB  8
0C182:  BRA    C2C6
0C184:  BRA    C16A
0C186:  MOVLB  8
0C188:  BSF    xFD.7
0C18A:  BRA    C1F2
0C18C:  BCF    xFD.7
0C18E:  MOVFF  8F8,8FC
0C192:  MOVLB  8
0C194:  BTFSS  xF8.7
0C196:  BRA    C19E
0C198:  MOVLB  9
0C19A:  BSF    x01.7
0C19C:  BRA    C2B6
0C19E:  MOVLB  9
0C1A0:  BCF    x01.7
0C1A2:  BRA    C2B6
0C1A4:  MOVFF  8F8,901
0C1A8:  MOVLB  9
0C1AA:  BSF    x01.7
0C1AC:  MOVFF  8F9,900
0C1B0:  MOVFF  8FA,8FF
0C1B4:  MOVLB  8
0C1B6:  BTFSS  xFC.7
0C1B8:  BRA    C1C6
0C1BA:  MOVLB  9
0C1BC:  BCF    x01.7
0C1BE:  MOVLB  8
0C1C0:  BSF    xFD.2
0C1C2:  BRA    C2D4
0C1C4:  BCF    xFD.2
0C1C6:  CLRF   xFE
0C1C8:  BCF    xFB.0
0C1CA:  MOVLW  08
0C1CC:  MOVWF  FEA
0C1CE:  MOVLW  F6
0C1D0:  MOVWF  FE9
0C1D2:  BRA    C308
0C1D4:  BTFSC  xFC.7
0C1D6:  BRA    C226
0C1D8:  MOVFF  8F4,8FC
0C1DC:  BTFSS  xFB.0
0C1DE:  BRA    C1F2
0C1E0:  MOVLB  9
0C1E2:  RRCF   x01,F
0C1E4:  RRCF   x00,F
0C1E6:  MOVLB  8
0C1E8:  RRCF   xFF,F
0C1EA:  RRCF   xFE,F
0C1EC:  INCF   00,F
0C1EE:  BTFSC  FD8.2
0C1F0:  BRA    C2C6
0C1F2:  BTFSS  xFE.7
0C1F4:  BRA    C21C
0C1F6:  INCF   xFF,F
0C1F8:  BNZ   C21C
0C1FA:  MOVLB  9
0C1FC:  INCF   x00,F
0C1FE:  BTFSC  FD8.2
0C200:  BRA    C206
0C202:  MOVLB  8
0C204:  BRA    C21C
0C206:  INCF   x01,F
0C208:  BTFSC  FD8.2
0C20A:  BRA    C210
0C20C:  MOVLB  8
0C20E:  BRA    C21C
0C210:  RRCF   x01,F
0C212:  RRCF   x00,F
0C214:  MOVLB  8
0C216:  RRCF   xFF,F
0C218:  INCF   00,F
0C21A:  BZ    C2C6
0C21C:  BTFSC  xFD.6
0C21E:  BRA    C0E6
0C220:  BTFSC  xFD.7
0C222:  BRA    C18C
0C224:  BRA    C280
0C226:  MOVLW  80
0C228:  MOVLB  9
0C22A:  XORWF  x01,F
0C22C:  BTFSS  x01.7
0C22E:  BRA    C23C
0C230:  MOVLB  8
0C232:  BRA    C2D4
0C234:  MOVFF  8F8,8FC
0C238:  BRA    C260
0C23A:  MOVLB  9
0C23C:  MOVFF  8F4,8FC
0C240:  MOVF   x01,F
0C242:  BTFSC  FD8.2
0C244:  BRA    C24A
0C246:  MOVLB  8
0C248:  BRA    C260
0C24A:  MOVF   x00,F
0C24C:  BTFSC  FD8.2
0C24E:  BRA    C254
0C250:  MOVLB  8
0C252:  BRA    C260
0C254:  MOVLB  8
0C256:  MOVF   xFF,F
0C258:  BNZ   C260
0C25A:  CLRF   00
0C25C:  MOVLB  9
0C25E:  BRA    C2B6
0C260:  MOVLB  9
0C262:  BTFSS  x01.7
0C264:  BRA    C26A
0C266:  MOVLB  8
0C268:  BRA    C280
0C26A:  BCF    FD8.0
0C26C:  MOVLB  8
0C26E:  RLCF   xFE,F
0C270:  RLCF   xFF,F
0C272:  MOVLB  9
0C274:  RLCF   x00,F
0C276:  RLCF   x01,F
0C278:  DECFSZ 00,F
0C27A:  BRA    C262
0C27C:  MOVLB  8
0C27E:  BRA    C2C6
0C280:  BTFSS  xFC.7
0C282:  BRA    C28A
0C284:  MOVLB  9
0C286:  BSF    x01.7
0C288:  BRA    C2B6
0C28A:  MOVLB  9
0C28C:  BCF    x01.7
0C28E:  BRA    C2B6
0C290:  MOVFF  8F7,00
0C294:  MOVFF  8F8,901
0C298:  MOVFF  8F9,900
0C29C:  MOVFF  8FA,8FF
0C2A0:  MOVLB  9
0C2A2:  BRA    C2B6
0C2A4:  MOVFF  8F3,00
0C2A8:  MOVFF  8F4,901
0C2AC:  MOVFF  8F5,900
0C2B0:  MOVFF  8F6,8FF
0C2B4:  MOVLB  9
0C2B6:  MOVFF  901,01
0C2BA:  MOVFF  900,02
0C2BE:  MOVFF  8FF,03
0C2C2:  BRA    C35E
0C2C4:  MOVLB  8
0C2C6:  CLRF   00
0C2C8:  CLRF   01
0C2CA:  CLRF   02
0C2CC:  CLRF   03
0C2CE:  MOVLB  9
0C2D0:  BRA    C35E
0C2D2:  MOVLB  8
0C2D4:  CLRF   xFE
0C2D6:  COMF   xFF,F
0C2D8:  MOVLB  9
0C2DA:  COMF   x00,F
0C2DC:  COMF   x01,F
0C2DE:  MOVLB  8
0C2E0:  COMF   xFE,F
0C2E2:  INCF   xFE,F
0C2E4:  BNZ   C2FA
0C2E6:  INCF   xFF,F
0C2E8:  BNZ   C2FA
0C2EA:  MOVLB  9
0C2EC:  INCF   x00,F
0C2EE:  BTFSC  FD8.2
0C2F0:  BRA    C2F6
0C2F2:  MOVLB  8
0C2F4:  BRA    C2FA
0C2F6:  INCF   x01,F
0C2F8:  MOVLB  8
0C2FA:  BTFSC  xFD.0
0C2FC:  BRA    C094
0C2FE:  BTFSC  xFD.1
0C300:  BRA    C13A
0C302:  BTFSC  xFD.2
0C304:  BRA    C1C4
0C306:  BRA    C234
0C308:  MOVF   FEF,W
0C30A:  ADDWF  xFF,F
0C30C:  BNC   C326
0C30E:  MOVLB  9
0C310:  INCF   x00,F
0C312:  BTFSC  FD8.2
0C314:  BRA    C31A
0C316:  MOVLB  8
0C318:  BRA    C326
0C31A:  INCF   x01,F
0C31C:  BTFSS  FD8.2
0C31E:  BRA    C324
0C320:  MOVLB  8
0C322:  BSF    xFB.0
0C324:  MOVLB  8
0C326:  MOVF   FED,F
0C328:  MOVF   FEF,W
0C32A:  MOVLB  9
0C32C:  ADDWF  x00,F
0C32E:  BNC   C33C
0C330:  INCF   x01,F
0C332:  BTFSS  FD8.2
0C334:  BRA    C33C
0C336:  MOVLB  8
0C338:  BSF    xFB.0
0C33A:  MOVLB  9
0C33C:  MOVF   FED,F
0C33E:  MOVF   FEF,W
0C340:  BTFSC  FEF.7
0C342:  BRA    C346
0C344:  XORLW  80
0C346:  ADDWF  x01,F
0C348:  BTFSS  FD8.0
0C34A:  BRA    C350
0C34C:  MOVLB  8
0C34E:  BSF    xFB.0
0C350:  MOVLB  8
0C352:  BTFSC  xFD.4
0C354:  BRA    C0A4
0C356:  BTFSC  xFD.5
0C358:  BRA    C14A
0C35A:  BRA    C1D4
0C35C:  MOVLB  9
0C35E:  MOVLB  0
0C360:  RETURN 0
0C362:  MOVLB  8
0C364:  MOVF   xB8,W
0C366:  SUBLW  B6
0C368:  MOVWF  xB8
0C36A:  CLRF   03
0C36C:  MOVFF  8B9,8BC
0C370:  BSF    xB9.7
0C372:  BCF    FD8.0
0C374:  RRCF   xB9,F
0C376:  RRCF   xBA,F
0C378:  RRCF   xBB,F
0C37A:  RRCF   03,F
0C37C:  RRCF   02,F
0C37E:  RRCF   01,F
0C380:  RRCF   00,F
0C382:  DECFSZ xB8,F
0C384:  BRA    C372
0C386:  BTFSS  xBC.7
0C388:  BRA    C3A0
0C38A:  COMF   00,F
0C38C:  COMF   01,F
0C38E:  COMF   02,F
0C390:  COMF   03,F
0C392:  INCF   00,F
0C394:  BTFSC  FD8.2
0C396:  INCF   01,F
0C398:  BTFSC  FD8.2
0C39A:  INCF   02,F
0C39C:  BTFSC  FD8.2
0C39E:  INCF   03,F
0C3A0:  MOVLB  0
0C3A2:  RETURN 0
0C3A4:  MOVF   FE9,W
0C3A6:  MOVLB  8
0C3A8:  MOVWF  x66
0C3AA:  MOVF   x65,W
0C3AC:  MOVWF  x68
0C3AE:  BZ    C3E6
0C3B0:  MOVFF  864,8F2
0C3B4:  MOVFF  863,8F1
0C3B8:  MOVFF  862,8F0
0C3BC:  MOVFF  861,8EF
0C3C0:  CLRF   xF6
0C3C2:  CLRF   xF5
0C3C4:  MOVLW  20
0C3C6:  MOVWF  xF4
0C3C8:  MOVLW  82
0C3CA:  MOVWF  xF3
0C3CC:  MOVLB  0
0C3CE:  RCALL  BF40
0C3D0:  MOVFF  03,864
0C3D4:  MOVFF  02,863
0C3D8:  MOVFF  01,862
0C3DC:  MOVFF  00,861
0C3E0:  MOVLB  8
0C3E2:  DECFSZ x68,F
0C3E4:  BRA    C3B0
0C3E6:  MOVLW  7E
0C3E8:  MOVWF  00
0C3EA:  CLRF   01
0C3EC:  BTFSC  x62.7
0C3EE:  BSF    01.7
0C3F0:  CLRF   02
0C3F2:  CLRF   03
0C3F4:  BCF    FD8.1
0C3F6:  MOVFF  864,8F6
0C3FA:  MOVFF  863,8F5
0C3FE:  MOVFF  862,8F4
0C402:  MOVFF  861,8F3
0C406:  MOVFF  03,8FA
0C40A:  MOVFF  02,8F9
0C40E:  MOVFF  01,8F8
0C412:  MOVWF  xF7
0C414:  MOVLB  0
0C416:  RCALL  C036
0C418:  MOVFF  03,864
0C41C:  MOVFF  02,863
0C420:  MOVFF  01,862
0C424:  MOVFF  00,861
0C428:  MOVFF  864,8BB
0C42C:  MOVFF  863,8BA
0C430:  MOVFF  862,8B9
0C434:  MOVFF  861,8B8
0C438:  RCALL  C362
0C43A:  MOVFF  03,864
0C43E:  MOVFF  02,863
0C442:  MOVFF  01,862
0C446:  MOVFF  00,861
0C44A:  MOVLB  8
0C44C:  BTFSS  x64.7
0C44E:  BRA    C46A
0C450:  DECF   x66,F
0C452:  BSF    x66.5
0C454:  COMF   x61,F
0C456:  COMF   x62,F
0C458:  COMF   x63,F
0C45A:  COMF   x64,F
0C45C:  INCF   x61,F
0C45E:  BTFSC  FD8.2
0C460:  INCF   x62,F
0C462:  BTFSC  FD8.2
0C464:  INCF   x63,F
0C466:  BTFSC  FD8.2
0C468:  INCF   x64,F
0C46A:  MOVLW  3B
0C46C:  MOVWF  x6D
0C46E:  MOVLW  9A
0C470:  MOVWF  x6C
0C472:  MOVLW  CA
0C474:  MOVWF  x6B
0C476:  CLRF   x6A
0C478:  MOVLW  0A
0C47A:  MOVWF  x68
0C47C:  MOVF   x65,W
0C47E:  BTFSC  FD8.2
0C480:  INCF   x66,F
0C482:  BSF    FD8.1
0C484:  MOVLW  08
0C486:  MOVWF  FEA
0C488:  MOVLW  61
0C48A:  MOVWF  FE9
0C48C:  CLRF   1B
0C48E:  BTFSC  FF2.7
0C490:  BSF    1B.7
0C492:  BCF    FF2.7
0C494:  MOVFF  864,A27
0C498:  MOVFF  863,A26
0C49C:  MOVFF  862,A25
0C4A0:  MOVFF  861,A24
0C4A4:  MOVFF  86D,A2B
0C4A8:  MOVFF  86C,A2A
0C4AC:  MOVFF  86B,A29
0C4B0:  MOVFF  86A,A28
0C4B4:  MOVLB  0
0C4B6:  CALL   1038
0C4BA:  BTFSC  1B.7
0C4BC:  BSF    FF2.7
0C4BE:  MOVF   01,W
0C4C0:  MOVF   00,F
0C4C2:  BNZ   C4EA
0C4C4:  MOVLB  8
0C4C6:  INCF   x65,W
0C4C8:  SUBWF  x68,W
0C4CA:  BTFSS  FD8.2
0C4CC:  BRA    C4D2
0C4CE:  MOVLB  0
0C4D0:  BRA    C4EA
0C4D2:  MOVF   x66,W
0C4D4:  BZ    C4F0
0C4D6:  ANDLW  0F
0C4D8:  SUBWF  x68,W
0C4DA:  BZ    C4DE
0C4DC:  BC    C556
0C4DE:  BTFSC  x66.7
0C4E0:  BRA    C556
0C4E2:  BTFSC  x66.6
0C4E4:  BRA    C4F0
0C4E6:  MOVLW  20
0C4E8:  BRA    C54C
0C4EA:  MOVLW  20
0C4EC:  MOVLB  8
0C4EE:  ANDWF  x66,F
0C4F0:  BTFSS  x66.5
0C4F2:  BRA    C50E
0C4F4:  BCF    x66.5
0C4F6:  MOVF   x65,W
0C4F8:  BTFSS  FD8.2
0C4FA:  DECF   x66,F
0C4FC:  MOVF   00,W
0C4FE:  MOVWF  x66
0C500:  MOVLW  2D
0C502:  BTFSS  F9E.4
0C504:  BRA    C502
0C506:  MOVWF  FAD
0C508:  MOVF   x66,W
0C50A:  MOVWF  00
0C50C:  CLRF   x66
0C50E:  MOVF   x65,W
0C510:  SUBWF  x68,W
0C512:  BNZ   C52A
0C514:  MOVF   00,W
0C516:  MOVWF  x66
0C518:  MOVLW  2E
0C51A:  BTFSS  F9E.4
0C51C:  BRA    C51A
0C51E:  MOVWF  FAD
0C520:  MOVF   x66,W
0C522:  MOVWF  00
0C524:  MOVLW  20
0C526:  ANDWF  x66,F
0C528:  MOVLW  00
0C52A:  MOVLW  30
0C52C:  BTFSS  x66.5
0C52E:  BRA    C54C
0C530:  BCF    x66.5
0C532:  MOVF   x65,W
0C534:  BTFSS  FD8.2
0C536:  DECF   x66,F
0C538:  MOVF   00,W
0C53A:  MOVWF  x66
0C53C:  MOVLW  2D
0C53E:  BTFSS  F9E.4
0C540:  BRA    C53E
0C542:  MOVWF  FAD
0C544:  MOVF   x66,W
0C546:  MOVWF  00
0C548:  CLRF   x66
0C54A:  MOVLW  30
0C54C:  ADDWF  00,F
0C54E:  MOVF   00,W
0C550:  BTFSS  F9E.4
0C552:  BRA    C550
0C554:  MOVWF  FAD
0C556:  BCF    FD8.1
0C558:  CLRF   1B
0C55A:  BTFSC  FF2.7
0C55C:  BSF    1B.7
0C55E:  BCF    FF2.7
0C560:  MOVFF  86D,A27
0C564:  MOVFF  86C,A26
0C568:  MOVFF  86B,A25
0C56C:  MOVFF  86A,A24
0C570:  MOVLB  A
0C572:  CLRF   x2B
0C574:  CLRF   x2A
0C576:  CLRF   x29
0C578:  MOVLW  0A
0C57A:  MOVWF  x28
0C57C:  MOVLB  0
0C57E:  CALL   1038
0C582:  BTFSC  1B.7
0C584:  BSF    FF2.7
0C586:  MOVFF  03,86D
0C58A:  MOVFF  02,86C
0C58E:  MOVFF  01,86B
0C592:  MOVFF  00,86A
0C596:  MOVLB  8
0C598:  DECFSZ x68,F
0C59A:  BRA    C482
0C59C:  MOVLB  0
0C59E:  RETURN 0
*
0C622:  MOVLW  8E
0C624:  MOVWF  00
0C626:  MOVFF  8F4,01
0C62A:  MOVFF  8F3,02
0C62E:  CLRF   03
0C630:  MOVF   01,F
0C632:  BNZ   C646
0C634:  MOVFF  02,01
0C638:  CLRF   02
0C63A:  MOVLW  08
0C63C:  SUBWF  00,F
0C63E:  MOVF   01,F
0C640:  BNZ   C646
0C642:  CLRF   00
0C644:  BRA    C656
0C646:  BCF    FD8.0
0C648:  BTFSC  01.7
0C64A:  BRA    C654
0C64C:  RLCF   02,F
0C64E:  RLCF   01,F
0C650:  DECF   00,F
0C652:  BRA    C646
0C654:  BCF    01.7
0C656:  RETURN 0
0C658:  MOVLB  8
0C65A:  MOVF   xD7,W
0C65C:  BTFSC  FD8.2
0C65E:  BRA    C7AA
0C660:  MOVWF  xE3
0C662:  MOVF   xDB,W
0C664:  BTFSC  FD8.2
0C666:  BRA    C7AA
0C668:  SUBWF  xE3,F
0C66A:  BNC   C676
0C66C:  MOVLW  7F
0C66E:  ADDWF  xE3,F
0C670:  BTFSC  FD8.0
0C672:  BRA    C7AA
0C674:  BRA    C682
0C676:  MOVLW  81
0C678:  SUBWF  xE3,F
0C67A:  BTFSS  FD8.0
0C67C:  BRA    C7AA
0C67E:  BTFSC  FD8.2
0C680:  BRA    C7AA
0C682:  MOVFF  8E3,00
0C686:  CLRF   01
0C688:  CLRF   02
0C68A:  CLRF   03
0C68C:  CLRF   xE2
0C68E:  MOVFF  8D8,8E1
0C692:  BSF    xE1.7
0C694:  MOVFF  8D9,8E0
0C698:  MOVFF  8DA,8DF
0C69C:  MOVLW  19
0C69E:  MOVWF  xE3
0C6A0:  MOVF   xDE,W
0C6A2:  SUBWF  xDF,F
0C6A4:  BC    C6C0
0C6A6:  MOVLW  01
0C6A8:  SUBWF  xE0,F
0C6AA:  BC    C6C0
0C6AC:  SUBWF  xE1,F
0C6AE:  BC    C6C0
0C6B0:  SUBWF  xE2,F
0C6B2:  BC    C6C0
0C6B4:  INCF   xE2,F
0C6B6:  INCF   xE1,F
0C6B8:  INCF   xE0,F
0C6BA:  MOVF   xDE,W
0C6BC:  ADDWF  xDF,F
0C6BE:  BRA    C710
0C6C0:  MOVF   xDD,W
0C6C2:  SUBWF  xE0,F
0C6C4:  BC    C6EA
0C6C6:  MOVLW  01
0C6C8:  SUBWF  xE1,F
0C6CA:  BC    C6EA
0C6CC:  SUBWF  xE2,F
0C6CE:  BC    C6EA
0C6D0:  INCF   xE2,F
0C6D2:  INCF   xE1,F
0C6D4:  MOVF   xDD,W
0C6D6:  ADDWF  xE0,F
0C6D8:  MOVF   xDE,W
0C6DA:  ADDWF  xDF,F
0C6DC:  BNC   C710
0C6DE:  INCF   xE0,F
0C6E0:  BNZ   C710
0C6E2:  INCF   xE1,F
0C6E4:  BNZ   C710
0C6E6:  INCF   xE2,F
0C6E8:  BRA    C710
0C6EA:  MOVF   xDC,W
0C6EC:  IORLW  80
0C6EE:  SUBWF  xE1,F
0C6F0:  BC    C70E
0C6F2:  MOVLW  01
0C6F4:  SUBWF  xE2,F
0C6F6:  BC    C70E
0C6F8:  INCF   xE2,F
0C6FA:  MOVF   xDC,W
0C6FC:  IORLW  80
0C6FE:  ADDWF  xE1,F
0C700:  MOVF   xDD,W
0C702:  ADDWF  xE0,F
0C704:  BNC   C6D8
0C706:  INCF   xE1,F
0C708:  BNZ   C6D8
0C70A:  INCF   xE2,F
0C70C:  BRA    C6D8
0C70E:  BSF    03.0
0C710:  DECFSZ xE3,F
0C712:  BRA    C716
0C714:  BRA    C72C
0C716:  BCF    FD8.0
0C718:  RLCF   xDF,F
0C71A:  RLCF   xE0,F
0C71C:  RLCF   xE1,F
0C71E:  RLCF   xE2,F
0C720:  BCF    FD8.0
0C722:  RLCF   03,F
0C724:  RLCF   02,F
0C726:  RLCF   01,F
0C728:  RLCF   xE4,F
0C72A:  BRA    C6A0
0C72C:  BTFSS  xE4.0
0C72E:  BRA    C73C
0C730:  BCF    FD8.0
0C732:  RRCF   01,F
0C734:  RRCF   02,F
0C736:  RRCF   03,F
0C738:  RRCF   xE4,F
0C73A:  BRA    C740
0C73C:  DECF   00,F
0C73E:  BZ    C7AA
0C740:  BTFSC  xE4.7
0C742:  BRA    C780
0C744:  BCF    FD8.0
0C746:  RLCF   xDF,F
0C748:  RLCF   xE0,F
0C74A:  RLCF   xE1,F
0C74C:  RLCF   xE2,F
0C74E:  MOVF   xDE,W
0C750:  SUBWF  xDF,F
0C752:  BC    C762
0C754:  MOVLW  01
0C756:  SUBWF  xE0,F
0C758:  BC    C762
0C75A:  SUBWF  xE1,F
0C75C:  BC    C762
0C75E:  SUBWF  xE2,F
0C760:  BNC   C796
0C762:  MOVF   xDD,W
0C764:  SUBWF  xE0,F
0C766:  BC    C772
0C768:  MOVLW  01
0C76A:  SUBWF  xE1,F
0C76C:  BC    C772
0C76E:  SUBWF  xE2,F
0C770:  BNC   C796
0C772:  MOVF   xDC,W
0C774:  IORLW  80
0C776:  SUBWF  xE1,F
0C778:  BC    C780
0C77A:  MOVLW  01
0C77C:  SUBWF  xE2,F
0C77E:  BNC   C796
0C780:  INCF   03,F
0C782:  BNZ   C796
0C784:  INCF   02,F
0C786:  BNZ   C796
0C788:  INCF   01,F
0C78A:  BNZ   C796
0C78C:  INCF   00,F
0C78E:  BZ    C7AA
0C790:  RRCF   01,F
0C792:  RRCF   02,F
0C794:  RRCF   03,F
0C796:  MOVFF  8D8,8E3
0C79A:  MOVF   xDC,W
0C79C:  XORWF  xE3,F
0C79E:  BTFSS  xE3.7
0C7A0:  BRA    C7A6
0C7A2:  BSF    01.7
0C7A4:  BRA    C7B2
0C7A6:  BCF    01.7
0C7A8:  BRA    C7B2
0C7AA:  CLRF   00
0C7AC:  CLRF   01
0C7AE:  CLRF   02
0C7B0:  CLRF   03
0C7B2:  MOVLB  0
0C7B4:  RETURN 0
*
0D240:  MOVFF  FEA,8A5
0D244:  MOVFF  FE9,8A4
0D248:  MOVLB  8
0D24A:  BTFSS  x9E.7
0D24C:  BRA    D25E
0D24E:  BSF    xA4.7
0D250:  BTFSS  xA4.4
0D252:  INCF   xA4,F
0D254:  COMF   x9D,F
0D256:  COMF   x9E,F
0D258:  INCF   x9D,F
0D25A:  BTFSC  FD8.2
0D25C:  INCF   x9E,F
0D25E:  SWAPF  x9E,W
0D260:  IORLW  F0
0D262:  MOVWF  xA0
0D264:  ADDWF  xA0,F
0D266:  ADDLW  E2
0D268:  MOVWF  xA1
0D26A:  ADDLW  32
0D26C:  MOVWF  xA3
0D26E:  MOVF   x9E,W
0D270:  ANDLW  0F
0D272:  ADDWF  xA1,F
0D274:  ADDWF  xA1,F
0D276:  ADDWF  xA3,F
0D278:  ADDLW  E9
0D27A:  MOVWF  xA2
0D27C:  ADDWF  xA2,F
0D27E:  ADDWF  xA2,F
0D280:  SWAPF  x9D,W
0D282:  ANDLW  0F
0D284:  ADDWF  xA2,F
0D286:  ADDWF  xA3,F
0D288:  RLCF   xA2,F
0D28A:  RLCF   xA3,F
0D28C:  COMF   xA3,F
0D28E:  RLCF   xA3,F
0D290:  MOVF   x9D,W
0D292:  ANDLW  0F
0D294:  ADDWF  xA3,F
0D296:  RLCF   xA0,F
0D298:  MOVLW  07
0D29A:  MOVWF  x9F
0D29C:  MOVLW  0A
0D29E:  DECF   xA2,F
0D2A0:  ADDWF  xA3,F
0D2A2:  BNC   D29E
0D2A4:  DECF   xA1,F
0D2A6:  ADDWF  xA2,F
0D2A8:  BNC   D2A4
0D2AA:  DECF   xA0,F
0D2AC:  ADDWF  xA1,F
0D2AE:  BNC   D2AA
0D2B0:  DECF   x9F,F
0D2B2:  ADDWF  xA0,F
0D2B4:  BNC   D2B0
0D2B6:  MOVLW  08
0D2B8:  MOVWF  FEA
0D2BA:  MOVLW  9F
0D2BC:  MOVWF  FE9
0D2BE:  MOVLW  07
0D2C0:  ANDWF  xA4,W
0D2C2:  BCF    xA4.6
0D2C4:  MOVF   FED,F
0D2C6:  ANDWF  xA4,W
0D2C8:  BNZ   D2D8
0D2CA:  BTFSC  xA4.4
0D2CC:  MOVF   FEE,F
0D2CE:  BTFSC  xA4.4
0D2D0:  BRA    D2D8
0D2D2:  MOVLW  20
0D2D4:  MOVWF  00
0D2D6:  BRA    D31A
0D2D8:  ADDWF  FE9,F
0D2DA:  MOVLW  00
0D2DC:  ADDWFC FEA,F
0D2DE:  MOVF   FE9,W
0D2E0:  SUBLW  A3
0D2E2:  BNZ   D2EC
0D2E4:  MOVF   FEA,W
0D2E6:  SUBLW  08
0D2E8:  BNZ   D2EC
0D2EA:  BSF    xA4.6
0D2EC:  MOVF   FEF,W
0D2EE:  MOVWF  00
0D2F0:  BNZ   D302
0D2F2:  BTFSC  xA4.6
0D2F4:  BRA    D302
0D2F6:  BTFSC  xA4.4
0D2F8:  BRA    D336
0D2FA:  BTFSC  xA4.3
0D2FC:  BRA    D302
0D2FE:  MOVLW  20
0D300:  BRA    D318
0D302:  BTFSS  xA4.7
0D304:  BRA    D312
0D306:  MOVLW  2D
0D308:  MOVWF  00
0D30A:  MOVF   FED,W
0D30C:  BCF    xA4.6
0D30E:  BCF    xA4.7
0D310:  BRA    D31A
0D312:  BSF    xA4.3
0D314:  BCF    xA4.4
0D316:  MOVLW  30
0D318:  ADDWF  00,F
0D31A:  MOVFF  FEA,89E
0D31E:  MOVFF  FE9,89D
0D322:  MOVFF  00,8DB
0D326:  MOVLB  0
0D328:  CALL   501C
0D32C:  MOVFF  89E,FEA
0D330:  MOVFF  89D,FE9
0D334:  MOVLB  8
0D336:  MOVF   FEE,W
0D338:  BTFSS  xA4.6
0D33A:  BRA    D2DE
0D33C:  MOVLB  0
0D33E:  GOTO   D462 (RETURN)
*
0D6E6:  ADDWF  FE8,W
0D6E8:  CLRF   FF7
0D6EA:  RLCF   FF7,F
0D6EC:  ADDLW  07
0D6EE:  MOVWF  FF6
0D6F0:  MOVLW  D7
0D6F2:  ADDWFC FF7,F
0D6F4:  MOVLW  00
0D6F6:  MOVWF  FF8
0D6F8:  MOVWF  FFB
0D6FA:  TBLRD*-
0D6FC:  MOVF   FF5,W
0D6FE:  MOVWF  FFA
0D700:  TBLRD*
0D702:  MOVF   FF5,W
0D704:  MOVWF  FF9
0D706:  DATA 18,D6
0D708:  DATA 40,D6
0D70A:  DATA 60,D6
0D70C:  DATA 80,D6
0D70E:  DATA A0,D6
0D710:  DATA C0,D6
*
0D790:  TBLRD*+
0D792:  MOVFF  FF6,895
0D796:  MOVFF  FF7,896
0D79A:  MOVFF  FF8,897
0D79E:  MOVF   FF5,W
0D7A0:  BTFSS  FA4.4
0D7A2:  BRA    D7A0
0D7A4:  MOVLB  F
0D7A6:  MOVWF  x1C
0D7A8:  MOVFF  895,FF6
0D7AC:  MOVFF  896,FF7
0D7B0:  MOVFF  897,FF8
0D7B4:  MOVLB  8
0D7B6:  DECFSZ x94,F
0D7B8:  BRA    D7BC
0D7BA:  BRA    D7C0
0D7BC:  MOVLB  0
0D7BE:  BRA    D790
0D7C0:  MOVLB  0
0D7C2:  RETURN 0
0D7C4:  MOVF   01,W
0D7C6:  CLRF   1B
0D7C8:  BTFSC  FF2.7
0D7CA:  BSF    1B.7
0D7CC:  BCF    FF2.7
0D7CE:  MOVFF  8CF,A1A
0D7D2:  MOVLW  64
0D7D4:  MOVLB  A
0D7D6:  MOVWF  x1B
0D7D8:  MOVLB  0
0D7DA:  CALL   0F5C
0D7DE:  BTFSC  1B.7
0D7E0:  BSF    FF2.7
0D7E2:  MOVFF  00,8CF
0D7E6:  MOVF   01,W
0D7E8:  MOVLW  30
0D7EA:  BNZ   D7FC
0D7EC:  MOVLB  8
0D7EE:  BTFSS  xD0.1
0D7F0:  BRA    D812
0D7F2:  BTFSC  xD0.3
0D7F4:  BRA    D812
0D7F6:  BTFSC  xD0.4
0D7F8:  MOVLW  20
0D7FA:  BRA    D804
0D7FC:  MOVLB  8
0D7FE:  BCF    xD0.3
0D800:  BCF    xD0.4
0D802:  BSF    xD0.0
0D804:  ADDWF  01,F
0D806:  MOVF   01,W
0D808:  BTFSS  FA4.4
0D80A:  BRA    D808
0D80C:  MOVLB  F
0D80E:  MOVWF  x1C
0D810:  MOVLB  8
0D812:  CLRF   1B
0D814:  BTFSC  FF2.7
0D816:  BSF    1B.7
0D818:  BCF    FF2.7
0D81A:  MOVFF  8CF,A1A
0D81E:  MOVLW  0A
0D820:  MOVLB  A
0D822:  MOVWF  x1B
0D824:  MOVLB  0
0D826:  CALL   0F5C
0D82A:  BTFSC  1B.7
0D82C:  BSF    FF2.7
0D82E:  MOVFF  00,8CF
0D832:  MOVF   01,W
0D834:  MOVLW  30
0D836:  BNZ   D848
0D838:  MOVLB  8
0D83A:  BTFSC  xD0.3
0D83C:  BRA    D856
0D83E:  BTFSS  xD0.0
0D840:  BRA    D856
0D842:  BTFSC  xD0.4
0D844:  MOVLW  20
0D846:  MOVLB  0
0D848:  ADDWF  01,F
0D84A:  MOVF   01,W
0D84C:  BTFSS  FA4.4
0D84E:  BRA    D84C
0D850:  MOVLB  F
0D852:  MOVWF  x1C
0D854:  MOVLB  8
0D856:  MOVLW  30
0D858:  ADDWF  xCF,F
0D85A:  MOVF   xCF,W
0D85C:  BTFSS  FA4.4
0D85E:  BRA    D85C
0D860:  MOVLB  F
0D862:  MOVWF  x1C
0D864:  MOVLB  0
0D866:  RETURN 0
*
0D88A:  TBLRD*+
0D88C:  MOVF   FF5,F
0D88E:  BZ    D8B6
0D890:  MOVFF  FF6,893
0D894:  MOVFF  FF7,894
0D898:  MOVFF  FF8,895
0D89C:  MOVF   FF5,W
0D89E:  BTFSS  FA4.4
0D8A0:  BRA    D89E
0D8A2:  MOVLB  F
0D8A4:  MOVWF  x1C
0D8A6:  MOVFF  893,FF6
0D8AA:  MOVFF  894,FF7
0D8AE:  MOVFF  895,FF8
0D8B2:  MOVLB  0
0D8B4:  BRA    D88A
0D8B6:  GOTO   D978 (RETURN)
*
0DE8E:  MOVF   FE9,W
0DE90:  MOVLB  8
0DE92:  MOVWF  x68
0DE94:  MOVLW  3B
0DE96:  MOVWF  x6F
0DE98:  MOVLW  9A
0DE9A:  MOVWF  x6E
0DE9C:  MOVLW  CA
0DE9E:  MOVWF  x6D
0DEA0:  CLRF   x6C
0DEA2:  MOVLW  0A
0DEA4:  MOVWF  x6A
0DEA6:  MOVF   x67,W
0DEA8:  BTFSS  FD8.2
0DEAA:  DECF   x68,F
0DEAC:  BSF    FD8.1
0DEAE:  MOVLW  08
0DEB0:  MOVWF  FEA
0DEB2:  MOVLW  63
0DEB4:  MOVWF  FE9
0DEB6:  CLRF   1B
0DEB8:  BTFSC  FF2.7
0DEBA:  BSF    1B.7
0DEBC:  BCF    FF2.7
0DEBE:  MOVFF  866,A27
0DEC2:  MOVFF  865,A26
0DEC6:  MOVFF  864,A25
0DECA:  MOVFF  863,A24
0DECE:  MOVFF  86F,A2B
0DED2:  MOVFF  86E,A2A
0DED6:  MOVFF  86D,A29
0DEDA:  MOVFF  86C,A28
0DEDE:  MOVLB  0
0DEE0:  CALL   1038
0DEE4:  BTFSC  1B.7
0DEE6:  BSF    FF2.7
0DEE8:  MOVF   01,W
0DEEA:  MOVF   00,F
0DEEC:  BNZ   DF14
0DEEE:  MOVLB  8
0DEF0:  INCF   x67,W
0DEF2:  SUBWF  x6A,W
0DEF4:  BTFSS  FD8.2
0DEF6:  BRA    DEFC
0DEF8:  MOVLB  0
0DEFA:  BRA    DF14
0DEFC:  MOVF   x68,W
0DEFE:  BZ    DF18
0DF00:  ANDLW  0F
0DF02:  SUBWF  x6A,W
0DF04:  BZ    DF08
0DF06:  BC    DF40
0DF08:  BTFSC  x68.7
0DF0A:  BRA    DF40
0DF0C:  BTFSC  x68.6
0DF0E:  BRA    DF18
0DF10:  MOVLW  20
0DF12:  BRA    DF36
0DF14:  MOVLB  8
0DF16:  CLRF   x68
0DF18:  MOVF   x67,W
0DF1A:  SUBWF  x6A,W
0DF1C:  BNZ   DF34
0DF1E:  MOVFF  00,868
0DF22:  MOVLW  2E
0DF24:  BTFSS  F9E.4
0DF26:  BRA    DF24
0DF28:  MOVWF  FAD
0DF2A:  MOVFF  868,00
0DF2E:  MOVLW  20
0DF30:  ANDWF  x68,F
0DF32:  MOVLW  00
0DF34:  MOVLW  30
0DF36:  ADDWF  00,F
0DF38:  MOVF   00,W
0DF3A:  BTFSS  F9E.4
0DF3C:  BRA    DF3A
0DF3E:  MOVWF  FAD
0DF40:  BCF    FD8.1
0DF42:  CLRF   1B
0DF44:  BTFSC  FF2.7
0DF46:  BSF    1B.7
0DF48:  BCF    FF2.7
0DF4A:  MOVFF  86F,A27
0DF4E:  MOVFF  86E,A26
0DF52:  MOVFF  86D,A25
0DF56:  MOVFF  86C,A24
0DF5A:  MOVLB  A
0DF5C:  CLRF   x2B
0DF5E:  CLRF   x2A
0DF60:  CLRF   x29
0DF62:  MOVLW  0A
0DF64:  MOVWF  x28
0DF66:  MOVLB  0
0DF68:  CALL   1038
0DF6C:  BTFSC  1B.7
0DF6E:  BSF    FF2.7
0DF70:  MOVFF  03,86F
0DF74:  MOVFF  02,86E
0DF78:  MOVFF  01,86D
0DF7C:  MOVFF  00,86C
0DF80:  MOVLB  8
0DF82:  DECFSZ x6A,F
0DF84:  BRA    DEAC
0DF86:  MOVLB  0
0DF88:  RETURN 0
*
0F022:  MOVF   FE9,W
0F024:  MOVLB  8
0F026:  MOVWF  xD3
0F028:  MOVLW  3B
0F02A:  MOVWF  xDA
0F02C:  MOVLW  9A
0F02E:  MOVWF  xD9
0F030:  MOVLW  CA
0F032:  MOVWF  xD8
0F034:  CLRF   xD7
0F036:  MOVLW  0A
0F038:  MOVWF  xD5
0F03A:  BSF    FD8.1
0F03C:  MOVLW  08
0F03E:  MOVWF  FEA
0F040:  MOVLW  CF
0F042:  MOVWF  FE9
0F044:  CLRF   1B
0F046:  BTFSC  FF2.7
0F048:  BSF    1B.7
0F04A:  BCF    FF2.7
0F04C:  MOVFF  8D2,A27
0F050:  MOVFF  8D1,A26
0F054:  MOVFF  8D0,A25
0F058:  MOVFF  8CF,A24
0F05C:  MOVFF  8DA,A2B
0F060:  MOVFF  8D9,A2A
0F064:  MOVFF  8D8,A29
0F068:  MOVFF  8D7,A28
0F06C:  MOVLB  0
0F06E:  CALL   1038
0F072:  BTFSC  1B.7
0F074:  BSF    FF2.7
0F076:  MOVF   01,W
0F078:  MOVF   00,F
0F07A:  BNZ   F0A2
0F07C:  MOVLB  8
0F07E:  MOVF   xD5,W
0F080:  XORLW  01
0F082:  BTFSS  FD8.2
0F084:  BRA    F08A
0F086:  MOVLB  0
0F088:  BRA    F0A2
0F08A:  MOVF   xD3,W
0F08C:  BZ    F0A6
0F08E:  ANDLW  0F
0F090:  SUBWF  xD5,W
0F092:  BZ    F096
0F094:  BC    F0B6
0F096:  BTFSC  xD3.7
0F098:  BRA    F0B6
0F09A:  BTFSC  xD3.6
0F09C:  BRA    F0A6
0F09E:  MOVLW  20
0F0A0:  BRA    F0A8
0F0A2:  MOVLB  8
0F0A4:  CLRF   xD3
0F0A6:  MOVLW  30
0F0A8:  ADDWF  00,F
0F0AA:  MOVF   00,W
0F0AC:  BTFSS  FA4.4
0F0AE:  BRA    F0AC
0F0B0:  MOVLB  F
0F0B2:  MOVWF  x1C
0F0B4:  MOVLB  8
0F0B6:  BCF    FD8.1
0F0B8:  CLRF   1B
0F0BA:  BTFSC  FF2.7
0F0BC:  BSF    1B.7
0F0BE:  BCF    FF2.7
0F0C0:  MOVFF  8DA,A27
0F0C4:  MOVFF  8D9,A26
0F0C8:  MOVFF  8D8,A25
0F0CC:  MOVFF  8D7,A24
0F0D0:  MOVLB  A
0F0D2:  CLRF   x2B
0F0D4:  CLRF   x2A
0F0D6:  CLRF   x29
0F0D8:  MOVLW  0A
0F0DA:  MOVWF  x28
0F0DC:  MOVLB  0
0F0DE:  CALL   1038
0F0E2:  BTFSC  1B.7
0F0E4:  BSF    FF2.7
0F0E6:  MOVFF  03,8DA
0F0EA:  MOVFF  02,8D9
0F0EE:  MOVFF  01,8D8
0F0F2:  MOVFF  00,8D7
0F0F6:  MOVLB  8
0F0F8:  DECFSZ xD5,F
0F0FA:  BRA    F03A
0F0FC:  MOVLB  0
0F0FE:  GOTO   F228 (RETURN)
*
0F2F8:  ADDWF  FE8,W
0F2FA:  CLRF   FF7
0F2FC:  RLCF   FF7,F
0F2FE:  ADDLW  19
0F300:  MOVWF  FF6
0F302:  MOVLW  F3
0F304:  ADDWFC FF7,F
0F306:  MOVLW  00
0F308:  MOVWF  FF8
0F30A:  MOVWF  FFB
0F30C:  TBLRD*-
0F30E:  MOVF   FF5,W
0F310:  MOVWF  FFA
0F312:  TBLRD*
0F314:  MOVF   FF5,W
0F316:  MOVWF  FF9
0F318:  DATA B8,F2
0F31A:  DATA C0,F2
0F31C:  DATA C8,F2
0F31E:  DATA D0,F2
*
0FB2E:  MOVF   FEF,F
0FB30:  BZ    FB52
0FB32:  MOVFF  FEA,8C8
0FB36:  MOVFF  FE9,8C7
0FB3A:  MOVFF  FEF,8DB
0FB3E:  CALL   501C
0FB42:  MOVFF  8C8,FEA
0FB46:  MOVFF  8C7,FE9
0FB4A:  INCF   FE9,F
0FB4C:  BTFSC  FD8.2
0FB4E:  INCF   FEA,F
0FB50:  BRA    FB2E
0FB52:  RETURN 0
0FB54:  MOVFF  FEA,FE2
0FB58:  MOVFF  FE9,FE1
0FB5C:  CLRF   01
0FB5E:  BSF    00.0
0FB60:  TBLRD*+
0FB62:  MOVF   FF5,W
0FB64:  BTFSS  00.0
0FB66:  BRA    FB72
0FB68:  SUBWF  FEE,W
0FB6A:  BNZ   FB72
0FB6C:  MOVF   FF5,F
0FB6E:  BNZ   FB60
0FB70:  BRA    FB8C
0FB72:  BCF    00.0
0FB74:  MOVF   FF5,F
0FB76:  BNZ   FB60
0FB78:  INCF   01,F
0FB7A:  BSF    00.0
0FB7C:  MOVFF  FE2,FEA
0FB80:  MOVFF  FE1,FE9
0FB84:  TBLRD*
0FB86:  MOVF   FF5,F
0FB88:  BNZ   FB60
0FB8A:  SETF   01
0FB8C:  RETURN 0
*
10460:  MOVFF  8F0,8F7
10464:  MOVLB  8
10466:  MOVF   xF4,W
10468:  XORWF  xF7,F
1046A:  BTFSS  xF7.7
1046C:  BRA    10478
1046E:  BCF    FD8.2
10470:  BCF    FD8.0
10472:  BTFSC  xF0.7
10474:  BSF    FD8.0
10476:  BRA    104D6
10478:  MOVFF  8F0,8F7
1047C:  MOVFF  8F3,8F8
10480:  MOVF   xEF,W
10482:  SUBWF  xF8,F
10484:  BZ    10492
10486:  BTFSS  xF7.7
10488:  BRA    104D6
1048A:  MOVF   FD8,W
1048C:  XORLW  01
1048E:  MOVWF  FD8
10490:  BRA    104D6
10492:  MOVFF  8F4,8F8
10496:  MOVF   xF0,W
10498:  SUBWF  xF8,F
1049A:  BZ    104A8
1049C:  BTFSS  xF7.7
1049E:  BRA    104D6
104A0:  MOVF   FD8,W
104A2:  XORLW  01
104A4:  MOVWF  FD8
104A6:  BRA    104D6
104A8:  MOVFF  8F5,8F8
104AC:  MOVF   xF1,W
104AE:  SUBWF  xF8,F
104B0:  BZ    104BE
104B2:  BTFSS  xF7.7
104B4:  BRA    104D6
104B6:  MOVF   FD8,W
104B8:  XORLW  01
104BA:  MOVWF  FD8
104BC:  BRA    104D6
104BE:  MOVFF  8F6,8F8
104C2:  MOVF   xF2,W
104C4:  SUBWF  xF8,F
104C6:  BZ    104D4
104C8:  BTFSS  xF7.7
104CA:  BRA    104D6
104CC:  MOVF   FD8,W
104CE:  XORLW  01
104D0:  MOVWF  FD8
104D2:  BRA    104D6
104D4:  BCF    FD8.0
104D6:  MOVLB  0
104D8:  RETURN 0
104DA:  MOVLW  8E
104DC:  MOVWF  00
104DE:  MOVFF  8C9,01
104E2:  MOVFF  8C8,02
104E6:  CLRF   03
104E8:  BTFSS  01.7
104EA:  BRA    104F6
104EC:  COMF   01,F
104EE:  COMF   02,F
104F0:  INCF   02,F
104F2:  BNZ   104F6
104F4:  INCF   01,F
104F6:  MOVF   01,F
104F8:  BNZ   1050C
104FA:  MOVFF  02,01
104FE:  CLRF   02
10500:  MOVLW  08
10502:  SUBWF  00,F
10504:  MOVF   01,F
10506:  BNZ   1050C
10508:  CLRF   00
1050A:  BRA    10528
1050C:  BCF    FD8.0
1050E:  BTFSC  01.7
10510:  BRA    1051A
10512:  RLCF   02,F
10514:  RLCF   01,F
10516:  DECF   00,F
10518:  BRA    1050C
1051A:  MOVLB  8
1051C:  BTFSS  xC9.7
1051E:  BRA    10524
10520:  MOVLB  0
10522:  BRA    10528
10524:  BCF    01.7
10526:  MOVLB  0
10528:  RETURN 0
*
10926:  MOVF   FE9,W
10928:  MOVLB  8
1092A:  MOVWF  xB0
1092C:  MOVF   xAF,W
1092E:  MOVWF  xB2
10930:  BZ    1096A
10932:  MOVFF  8AE,8F2
10936:  MOVFF  8AD,8F1
1093A:  MOVFF  8AC,8F0
1093E:  MOVFF  8AB,8EF
10942:  CLRF   xF6
10944:  CLRF   xF5
10946:  MOVLW  20
10948:  MOVWF  xF4
1094A:  MOVLW  82
1094C:  MOVWF  xF3
1094E:  MOVLB  0
10950:  CALL   BF40
10954:  MOVFF  03,8AE
10958:  MOVFF  02,8AD
1095C:  MOVFF  01,8AC
10960:  MOVFF  00,8AB
10964:  MOVLB  8
10966:  DECFSZ xB2,F
10968:  BRA    10932
1096A:  MOVLW  7E
1096C:  MOVWF  00
1096E:  CLRF   01
10970:  BTFSC  xAC.7
10972:  BSF    01.7
10974:  CLRF   02
10976:  CLRF   03
10978:  BCF    FD8.1
1097A:  MOVFF  8AE,8F6
1097E:  MOVFF  8AD,8F5
10982:  MOVFF  8AC,8F4
10986:  MOVFF  8AB,8F3
1098A:  MOVFF  03,8FA
1098E:  MOVFF  02,8F9
10992:  MOVFF  01,8F8
10996:  MOVWF  xF7
10998:  MOVLB  0
1099A:  CALL   C036
1099E:  MOVFF  03,8AE
109A2:  MOVFF  02,8AD
109A6:  MOVFF  01,8AC
109AA:  MOVFF  00,8AB
109AE:  MOVFF  8AE,8BB
109B2:  MOVFF  8AD,8BA
109B6:  MOVFF  8AC,8B9
109BA:  MOVFF  8AB,8B8
109BE:  CALL   C362
109C2:  MOVFF  03,8AE
109C6:  MOVFF  02,8AD
109CA:  MOVFF  01,8AC
109CE:  MOVFF  00,8AB
109D2:  MOVLB  8
109D4:  BTFSS  xAE.7
109D6:  BRA    109F2
109D8:  DECF   xB0,F
109DA:  BSF    xB0.5
109DC:  COMF   xAB,F
109DE:  COMF   xAC,F
109E0:  COMF   xAD,F
109E2:  COMF   xAE,F
109E4:  INCF   xAB,F
109E6:  BTFSC  FD8.2
109E8:  INCF   xAC,F
109EA:  BTFSC  FD8.2
109EC:  INCF   xAD,F
109EE:  BTFSC  FD8.2
109F0:  INCF   xAE,F
109F2:  MOVLW  3B
109F4:  MOVWF  xB7
109F6:  MOVLW  9A
109F8:  MOVWF  xB6
109FA:  MOVLW  CA
109FC:  MOVWF  xB5
109FE:  CLRF   xB4
10A00:  MOVLW  0A
10A02:  MOVWF  xB2
10A04:  MOVF   xAF,W
10A06:  BTFSC  FD8.2
10A08:  INCF   xB0,F
10A0A:  BSF    FD8.1
10A0C:  MOVLW  08
10A0E:  MOVWF  FEA
10A10:  MOVLW  AB
10A12:  MOVWF  FE9
10A14:  CLRF   1B
10A16:  BTFSC  FF2.7
10A18:  BSF    1B.7
10A1A:  BCF    FF2.7
10A1C:  MOVFF  8AE,A27
10A20:  MOVFF  8AD,A26
10A24:  MOVFF  8AC,A25
10A28:  MOVFF  8AB,A24
10A2C:  MOVFF  8B7,A2B
10A30:  MOVFF  8B6,A2A
10A34:  MOVFF  8B5,A29
10A38:  MOVFF  8B4,A28
10A3C:  MOVLB  0
10A3E:  CALL   1038
10A42:  BTFSC  1B.7
10A44:  BSF    FF2.7
10A46:  MOVF   01,W
10A48:  MOVF   00,F
10A4A:  BNZ   10A72
10A4C:  MOVLB  8
10A4E:  INCF   xAF,W
10A50:  SUBWF  xB2,W
10A52:  BTFSS  FD8.2
10A54:  BRA    10A5A
10A56:  MOVLB  0
10A58:  BRA    10A72
10A5A:  MOVF   xB0,W
10A5C:  BZ    10A78
10A5E:  ANDLW  0F
10A60:  SUBWF  xB2,W
10A62:  BZ    10A66
10A64:  BC    10AEE
10A66:  BTFSC  xB0.7
10A68:  BRA    10AEE
10A6A:  BTFSC  xB0.6
10A6C:  BRA    10A78
10A6E:  MOVLW  20
10A70:  BRA    10AE0
10A72:  MOVLW  20
10A74:  MOVLB  8
10A76:  ANDWF  xB0,F
10A78:  BTFSS  xB0.5
10A7A:  BRA    10A9A
10A7C:  BCF    xB0.5
10A7E:  MOVF   xAF,W
10A80:  BTFSS  FD8.2
10A82:  DECF   xB0,F
10A84:  MOVF   00,W
10A86:  MOVWF  xB0
10A88:  MOVLW  2D
10A8A:  MOVWF  xDB
10A8C:  MOVLB  0
10A8E:  CALL   501C
10A92:  MOVLB  8
10A94:  MOVF   xB0,W
10A96:  MOVWF  00
10A98:  CLRF   xB0
10A9A:  MOVF   xAF,W
10A9C:  SUBWF  xB2,W
10A9E:  BNZ   10ABA
10AA0:  MOVF   00,W
10AA2:  MOVWF  xB0
10AA4:  MOVLW  2E
10AA6:  MOVWF  xDB
10AA8:  MOVLB  0
10AAA:  CALL   501C
10AAE:  MOVLB  8
10AB0:  MOVF   xB0,W
10AB2:  MOVWF  00
10AB4:  MOVLW  20
10AB6:  ANDWF  xB0,F
10AB8:  MOVLW  00
10ABA:  MOVLW  30
10ABC:  BTFSS  xB0.5
10ABE:  BRA    10AE0
10AC0:  BCF    xB0.5
10AC2:  MOVF   xAF,W
10AC4:  BTFSS  FD8.2
10AC6:  DECF   xB0,F
10AC8:  MOVF   00,W
10ACA:  MOVWF  xB0
10ACC:  MOVLW  2D
10ACE:  MOVWF  xDB
10AD0:  MOVLB  0
10AD2:  CALL   501C
10AD6:  MOVLB  8
10AD8:  MOVF   xB0,W
10ADA:  MOVWF  00
10ADC:  CLRF   xB0
10ADE:  MOVLW  30
10AE0:  ADDWF  00,F
10AE2:  MOVFF  00,8DB
10AE6:  MOVLB  0
10AE8:  CALL   501C
10AEC:  MOVLB  8
10AEE:  BCF    FD8.1
10AF0:  CLRF   1B
10AF2:  BTFSC  FF2.7
10AF4:  BSF    1B.7
10AF6:  BCF    FF2.7
10AF8:  MOVFF  8B7,A27
10AFC:  MOVFF  8B6,A26
10B00:  MOVFF  8B5,A25
10B04:  MOVFF  8B4,A24
10B08:  MOVLB  A
10B0A:  CLRF   x2B
10B0C:  CLRF   x2A
10B0E:  CLRF   x29
10B10:  MOVLW  0A
10B12:  MOVWF  x28
10B14:  MOVLB  0
10B16:  CALL   1038
10B1A:  BTFSC  1B.7
10B1C:  BSF    FF2.7
10B1E:  MOVFF  03,8B7
10B22:  MOVFF  02,8B6
10B26:  MOVFF  01,8B5
10B2A:  MOVFF  00,8B4
10B2E:  MOVLB  8
10B30:  DECFSZ xB2,F
10B32:  BRA    10A0A
10B34:  MOVLB  0
10B36:  RETURN 0
*
12438:  ADDWF  FE8,W
1243A:  CLRF   FF7
1243C:  RLCF   FF7,F
1243E:  ADDLW  59
12440:  MOVWF  FF6
12442:  MOVLW  24
12444:  ADDWFC FF7,F
12446:  MOVLW  01
12448:  MOVWF  FF8
1244A:  MOVWF  FFB
1244C:  TBLRD*-
1244E:  MOVF   FF5,W
12450:  MOVWF  FFA
12452:  TBLRD*
12454:  MOVF   FF5,W
12456:  MOVWF  FF9
12458:  DATA FC,23
1245A:  DATA 04,24
1245C:  DATA 0A,24
1245E:  DATA 10,24
*
124F0:  MOVLW  8E
124F2:  MOVWF  00
124F4:  MOVLB  8
124F6:  MOVF   xEF,W
124F8:  SUBWF  00,F
124FA:  MOVFF  8F0,02
124FE:  MOVFF  8F1,01
12502:  BSF    02.7
12504:  MOVF   00,F
12506:  BZ    1251A
12508:  BCF    FD8.0
1250A:  MOVF   02,F
1250C:  BNZ   12512
1250E:  MOVF   01,F
12510:  BZ    1251A
12512:  RRCF   02,F
12514:  RRCF   01,F
12516:  DECFSZ 00,F
12518:  BRA    12508
1251A:  BTFSS  xF0.7
1251C:  BRA    12528
1251E:  COMF   01,F
12520:  COMF   02,F
12522:  INCF   01,F
12524:  BTFSC  FD8.2
12526:  INCF   02,F
12528:  MOVLB  0
1252A:  RETURN 0
*
12FE8:  ADDWF  FE8,W
12FEA:  CLRF   FF7
12FEC:  RLCF   FF7,F
12FEE:  ADDLW  09
12FF0:  MOVWF  FF6
12FF2:  MOVLW  30
12FF4:  ADDWFC FF7,F
12FF6:  MOVLW  01
12FF8:  MOVWF  FF8
12FFA:  MOVWF  FFB
12FFC:  TBLRD*-
12FFE:  MOVF   FF5,W
13000:  MOVWF  FFA
13002:  TBLRD*
13004:  MOVF   FF5,W
13006:  MOVWF  FF9
13008:  DATA 24,2E
1300A:  DATA 2A,2E
1300C:  DATA 48,2E
1300E:  DATA 66,2E
*
13080:  MOVLB  8
13082:  MOVF   xB9,W
13084:  XORWF  xBB,W
13086:  ANDLW  80
13088:  MOVWF  xBD
1308A:  BTFSS  xB9.7
1308C:  BRA    13098
1308E:  COMF   xB8,F
13090:  COMF   xB9,F
13092:  INCF   xB8,F
13094:  BTFSC  FD8.2
13096:  INCF   xB9,F
13098:  BTFSS  xBB.7
1309A:  BRA    130A6
1309C:  COMF   xBA,F
1309E:  COMF   xBB,F
130A0:  INCF   xBA,F
130A2:  BTFSC  FD8.2
130A4:  INCF   xBB,F
130A6:  MOVF   xB8,W
130A8:  MULWF  xBA
130AA:  MOVFF  FF3,01
130AE:  MOVFF  FF4,00
130B2:  MULWF  xBB
130B4:  MOVF   FF3,W
130B6:  ADDWF  00,F
130B8:  MOVF   xB9,W
130BA:  MULWF  xBA
130BC:  MOVF   FF3,W
130BE:  ADDWFC 00,W
130C0:  MOVWF  02
130C2:  BTFSS  xBD.7
130C4:  BRA    130D0
130C6:  COMF   01,F
130C8:  COMF   02,F
130CA:  INCF   01,F
130CC:  BTFSC  FD8.2
130CE:  INCF   02,F
130D0:  MOVLB  0
130D2:  GOTO   131B0 (RETURN)
*
13DFA:  ADDWF  FE8,W
13DFC:  CLRF   FF7
13DFE:  RLCF   FF7,F
13E00:  ADDLW  1B
13E02:  MOVWF  FF6
13E04:  MOVLW  3E
13E06:  ADDWFC FF7,F
13E08:  MOVLW  01
13E0A:  MOVWF  FF8
13E0C:  MOVWF  FFB
13E0E:  TBLRD*-
13E10:  MOVF   FF5,W
13E12:  MOVWF  FFA
13E14:  TBLRD*
13E16:  MOVF   FF5,W
13E18:  MOVWF  FF9
13E1A:  DATA C6,3C
13E1C:  DATA EE,3D
13E1E:  DATA F2,3C
13E20:  DATA EE,3D
13E22:  DATA BE,3B
13E24:  DATA EE,3D
13E26:  DATA EE,3D
13E28:  DATA EE,3D
13E2A:  DATA EE,3D
13E2C:  DATA EE,3D
13E2E:  DATA EE,3D
13E30:  DATA EE,3D
13E32:  DATA EE,3D
13E34:  DATA EE,3D
13E36:  DATA EE,3D
13E38:  DATA EE,3D
13E3A:  DATA E6,3D
13E3C:  DATA EE,3D
13E3E:  DATA EE,3D
13E40:  DATA EE,3D
13E42:  DATA EE,3D
13E44:  DATA EE,3D
13E46:  DATA 5E,3B
13E48:  DATA EE,3D
13E4A:  DATA 92,3B
13E4C:  DATA 9A,3B
13E4E:  DATA EE,3D
13E50:  DATA AE,3B
13E52:  DATA 1E,3D
13E54:  DATA E2,3B
13E56:  DATA EE,3D
13E58:  DATA EE,3D
13E5A:  DATA 74,3C
13E5C:  DATA 56,3C
13E5E:  DATA EE,3D
13E60:  DATA EE,3D
13E62:  DATA EE,3D
13E64:  DATA 38,3D
13E66:  DATA 64,3D
13E68:  DATA 90,3D
13E6A:  DATA 90,3C
13E6C:  DATA BC,3C
13E6E:  DATA EE,3D
13E70:  DATA EE,3D
13E72:  DATA EE,3D
13E74:  DATA EE,3D
13E76:  DATA BC,3D
13E78:  DATA EE,3D
13E7A:  DATA EE,3D
13E7C:  DATA EE,3D
13E7E:  DATA EE,3D
13E80:  DATA EE,3D
13E82:  DATA EE,3D
13E84:  DATA EE,3D
13E86:  DATA EE,3D
13E88:  DATA EE,3D
13E8A:  DATA EE,3D
13E8C:  DATA CA,3B
13E8E:  DATA EE,3D
13E90:  DATA EE,3D
13E92:  DATA EE,3D
13E94:  DATA EE,3D
13E96:  DATA FA,3B
13E98:  DATA EE,3D
13E9A:  DATA EE,3D
13E9C:  DATA 20,3C
13E9E:  DATA EE,3D
13EA0:  DATA EE,3D
13EA2:  DATA EE,3D
13EA4:  DATA 6E,3B
*
13F5A:  MOVFF  FEA,89C
13F5E:  MOVFF  FE9,89B
13F62:  MOVLB  8
13F64:  SWAPF  x95,W
13F66:  IORLW  F0
13F68:  MOVWF  x97
13F6A:  ADDWF  x97,F
13F6C:  ADDLW  E2
13F6E:  MOVWF  x98
13F70:  ADDLW  32
13F72:  MOVWF  x9A
13F74:  MOVF   x95,W
13F76:  ANDLW  0F
13F78:  ADDWF  x98,F
13F7A:  ADDWF  x98,F
13F7C:  ADDWF  x9A,F
13F7E:  ADDLW  E9
13F80:  MOVWF  x99
13F82:  ADDWF  x99,F
13F84:  ADDWF  x99,F
13F86:  SWAPF  x94,W
13F88:  ANDLW  0F
13F8A:  ADDWF  x99,F
13F8C:  ADDWF  x9A,F
13F8E:  RLCF   x99,F
13F90:  RLCF   x9A,F
13F92:  COMF   x9A,F
13F94:  RLCF   x9A,F
13F96:  MOVF   x94,W
13F98:  ANDLW  0F
13F9A:  ADDWF  x9A,F
13F9C:  RLCF   x97,F
13F9E:  MOVLW  07
13FA0:  MOVWF  x96
13FA2:  MOVLW  0A
13FA4:  DECF   x99,F
13FA6:  ADDWF  x9A,F
13FA8:  BNC   13FA4
13FAA:  DECF   x98,F
13FAC:  ADDWF  x99,F
13FAE:  BNC   13FAA
13FB0:  DECF   x97,F
13FB2:  ADDWF  x98,F
13FB4:  BNC   13FB0
13FB6:  DECF   x96,F
13FB8:  ADDWF  x97,F
13FBA:  BNC   13FB6
13FBC:  MOVLW  08
13FBE:  MOVWF  FEA
13FC0:  MOVLW  96
13FC2:  MOVWF  FE9
13FC4:  MOVLW  07
13FC6:  ANDWF  x9B,W
13FC8:  BCF    x9B.6
13FCA:  ADDWF  FE9,F
13FCC:  MOVLW  00
13FCE:  ADDWFC FEA,F
13FD0:  MOVF   FE9,W
13FD2:  SUBLW  9A
13FD4:  BNZ   13FDE
13FD6:  MOVF   FEA,W
13FD8:  SUBLW  08
13FDA:  BNZ   13FDE
13FDC:  BSF    x9B.6
13FDE:  MOVF   FEF,W
13FE0:  MOVWF  00
13FE2:  BNZ   13FF4
13FE4:  BTFSC  x9B.6
13FE6:  BRA    13FF4
13FE8:  BTFSC  x9B.4
13FEA:  BRA    14008
13FEC:  BTFSC  x9B.3
13FEE:  BRA    13FF4
13FF0:  MOVLW  20
13FF2:  BRA    13FFA
13FF4:  BSF    x9B.3
13FF6:  BCF    x9B.4
13FF8:  MOVLW  30
13FFA:  ADDWF  00,F
13FFC:  MOVF   00,W
13FFE:  BTFSS  FA4.4
14000:  BRA    13FFE
14002:  MOVLB  F
14004:  MOVWF  x1C
14006:  MOVLB  8
14008:  MOVF   FEE,W
1400A:  BTFSS  x9B.6
1400C:  BRA    13FD0
1400E:  MOVLB  0
14010:  GOTO   140AC (RETURN)
*
144F0:  ADDWF  FE8,W
144F2:  CLRF   FF7
144F4:  RLCF   FF7,F
144F6:  ADDLW  11
144F8:  MOVWF  FF6
144FA:  MOVLW  45
144FC:  ADDWFC FF7,F
144FE:  MOVLW  01
14500:  MOVWF  FF8
14502:  MOVWF  FFB
14504:  TBLRD*-
14506:  MOVF   FF5,W
14508:  MOVWF  FFA
1450A:  TBLRD*
1450C:  MOVF   FF5,W
1450E:  MOVWF  FF9
14510:  DATA DC,40
14512:  DATA 3C,41
14514:  DATA 58,41
14516:  DATA 74,41
14518:  DATA 90,41
1451A:  DATA AC,41
1451C:  DATA C8,41
1451E:  DATA E4,41
14520:  DATA 00,42
14522:  DATA 1C,42
14524:  DATA 38,42
14526:  DATA 54,42
14528:  DATA 70,42
1452A:  DATA 8C,42
1452C:  DATA A8,42
1452E:  DATA C4,42
14530:  DATA E0,42
14532:  DATA FC,42
14534:  DATA 18,43
14536:  DATA 34,43
14538:  DATA 50,43
1453A:  DATA 6C,43
1453C:  DATA 88,43
1453E:  DATA A4,43
14540:  DATA C0,43
14542:  DATA DC,43
14544:  DATA F8,43
14546:  DATA 14,44
14548:  DATA 30,44
1454A:  DATA 4C,44
1454C:  DATA 68,44
1454E:  DATA 84,44
14550:  DATA A0,44
*
14D26:  ADDWF  FE8,W
14D28:  CLRF   FF7
14D2A:  RLCF   FF7,F
14D2C:  ADDLW  47
14D2E:  MOVWF  FF6
14D30:  MOVLW  4D
14D32:  ADDWFC FF7,F
14D34:  MOVLW  01
14D36:  MOVWF  FF8
14D38:  MOVWF  FFB
14D3A:  TBLRD*-
14D3C:  MOVF   FF5,W
14D3E:  MOVWF  FFA
14D40:  TBLRD*
14D42:  MOVF   FF5,W
14D44:  MOVWF  FF9
14D46:  DATA 32,49
14D48:  DATA 5A,4A
14D4A:  DATA 5E,49
14D4C:  DATA 5A,4A
14D4E:  DATA 24,48
14D50:  DATA 5A,4A
14D52:  DATA 5A,4A
14D54:  DATA 5A,4A
14D56:  DATA 5A,4A
14D58:  DATA 5A,4A
14D5A:  DATA 5A,4A
14D5C:  DATA 5A,4A
14D5E:  DATA 5A,4A
14D60:  DATA 5A,4A
14D62:  DATA 5A,4A
14D64:  DATA 5A,4A
14D66:  DATA 52,4A
14D68:  DATA 5A,4A
14D6A:  DATA 5A,4A
14D6C:  DATA 5A,4A
14D6E:  DATA 5A,4A
14D70:  DATA 5A,4A
14D72:  DATA 2E,46
14D74:  DATA 5A,4A
14D76:  DATA 62,46
14D78:  DATA 00,48
14D7A:  DATA 5A,4A
14D7C:  DATA 14,48
14D7E:  DATA 8A,49
14D80:  DATA 48,48
14D82:  DATA 5A,4A
14D84:  DATA 5A,4A
14D86:  DATA DA,48
14D88:  DATA BC,48
14D8A:  DATA 5A,4A
14D8C:  DATA 5A,4A
14D8E:  DATA 5A,4A
14D90:  DATA A4,49
14D92:  DATA D0,49
14D94:  DATA FC,49
14D96:  DATA F6,48
14D98:  DATA 26,49
14D9A:  DATA 5A,4A
14D9C:  DATA 5A,4A
14D9E:  DATA 5A,4A
14DA0:  DATA 5A,4A
14DA2:  DATA 28,4A
14DA4:  DATA 5A,4A
14DA6:  DATA 5A,4A
14DA8:  DATA 5A,4A
14DAA:  DATA 5A,4A
14DAC:  DATA 5A,4A
14DAE:  DATA 5A,4A
14DB0:  DATA 5A,4A
14DB2:  DATA 5A,4A
14DB4:  DATA 5A,4A
14DB6:  DATA 5A,4A
14DB8:  DATA 30,48
14DBA:  DATA 5A,4A
14DBC:  DATA 5A,4A
14DBE:  DATA 5A,4A
14DC0:  DATA 5A,4A
14DC2:  DATA 60,48
14DC4:  DATA 5A,4A
14DC6:  DATA 5A,4A
14DC8:  DATA 86,48
14DCA:  DATA 5A,4A
14DCC:  DATA 5A,4A
14DCE:  DATA 5A,4A
14DD0:  DATA 3E,46
14DD2:  DATA 5A,4A
14DD4:  DATA 6A,46
*
15238:  ADDWF  FE8,W
1523A:  CLRF   FF7
1523C:  RLCF   FF7,F
1523E:  ADDLW  59
15240:  MOVWF  FF6
15242:  MOVLW  52
15244:  ADDWFC FF7,F
15246:  MOVLW  01
15248:  MOVWF  FF8
1524A:  MOVWF  FFB
1524C:  TBLRD*-
1524E:  MOVF   FF5,W
15250:  MOVWF  FFA
15252:  TBLRD*
15254:  MOVF   FF5,W
15256:  MOVWF  FF9
15258:  DATA AA,50
1525A:  DATA CA,50
1525C:  DATA EA,50
1525E:  DATA 0A,51
15260:  DATA 2A,51
15262:  DATA 4A,51
15264:  DATA 6A,51
*
1AC9E:  ADDWF  FE8,W
1ACA0:  CLRF   FF7
1ACA2:  RLCF   FF7,F
1ACA4:  ADDLW  BF
1ACA6:  MOVWF  FF6
1ACA8:  MOVLW  AC
1ACAA:  ADDWFC FF7,F
1ACAC:  MOVLW  01
1ACAE:  MOVWF  FF8
1ACB0:  MOVWF  FFB
1ACB2:  TBLRD*-
1ACB4:  MOVF   FF5,W
1ACB6:  MOVWF  FFA
1ACB8:  TBLRD*
1ACBA:  MOVF   FF5,W
1ACBC:  MOVWF  FF9
1ACBE:  DATA 24,AB
1ACC0:  DATA 9A,AC
1ACC2:  DATA 2A,AB
1ACC4:  DATA 1E,AB
1ACC6:  DATA 9A,AC
1ACC8:  DATA 9A,AC
1ACCA:  DATA 9A,AC
1ACCC:  DATA 30,AB
1ACCE:  DATA E4,AB
1ACD0:  DATA 9A,AC
1ACD2:  DATA 00,AC
1ACD4:  DATA 9A,AC
1ACD6:  DATA 36,AB
1ACD8:  DATA 9A,AC
1ACDA:  DATA 9A,AC
1ACDC:  DATA 9A,AC
1ACDE:  DATA 9A,AC
1ACE0:  DATA 9A,AC
1ACE2:  DATA 9A,AC
1ACE4:  DATA 9A,AC
1ACE6:  DATA 9A,AC
1ACE8:  DATA 9A,AC
1ACEA:  DATA 9A,AC
1ACEC:  DATA 9A,AC
1ACEE:  DATA 9A,AC
1ACF0:  DATA 9A,AC
1ACF2:  DATA 9A,AC
1ACF4:  DATA 9A,AC
1ACF6:  DATA 9A,AC
1ACF8:  DATA 9A,AC
1ACFA:  DATA 3C,AB
1ACFC:  DATA 42,AB
1ACFE:  DATA 48,AB
1AD00:  DATA 4E,AB
1AD02:  DATA 54,AB
1AD04:  DATA 5A,AB
1AD06:  DATA 60,AB
1AD08:  DATA 66,AB
1AD0A:  DATA 6C,AB
1AD0C:  DATA 72,AB
1AD0E:  DATA 78,AB
1AD10:  DATA 7E,AB
1AD12:  DATA 84,AB
1AD14:  DATA 90,AB
1AD16:  DATA 96,AB
1AD18:  DATA 9C,AB
1AD1A:  DATA A2,AB
1AD1C:  DATA A8,AB
1AD1E:  DATA AE,AB
1AD20:  DATA B4,AB
1AD22:  DATA BA,AB
1AD24:  DATA C0,AB
1AD26:  DATA C6,AB
1AD28:  DATA CC,AB
1AD2A:  DATA D2,AB
1AD2C:  DATA D8,AB
1AD2E:  DATA 9A,AC
1AD30:  DATA 9A,AC
1AD32:  DATA 9A,AC
1AD34:  DATA DE,AB
1AD36:  DATA 9A,AC
1AD38:  DATA 9A,AC
1AD3A:  DATA 1C,AC
1AD3C:  DATA 22,AC
1AD3E:  DATA 9A,AC
1AD40:  DATA 28,AC
1AD42:  DATA 2E,AC
1AD44:  DATA 34,AC
1AD46:  DATA 3A,AC
1AD48:  DATA 40,AC
1AD4A:  DATA 46,AC
1AD4C:  DATA 4C,AC
1AD4E:  DATA 52,AC
1AD50:  DATA 58,AC
1AD52:  DATA 5E,AC
1AD54:  DATA 64,AC
1AD56:  DATA 6A,AC
1AD58:  DATA 70,AC
1AD5A:  DATA 76,AC
1AD5C:  DATA 7C,AC
1AD5E:  DATA 80,AC
1AD60:  DATA 84,AC
1AD62:  DATA 88,AC
1AD64:  DATA 9A,AC
1AD66:  DATA 8C,AC
1AD68:  DATA 90,AC
1AD6A:  DATA 94,AC
1AD6C:  DATA 98,AC
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8D0
1F8BA:  MOVFF  FF7,8D1
1F8BE:  MOVFF  FF8,8D2
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8D0,FF6
1F8CE:  MOVFF  8D1,FF7
1F8D2:  MOVFF  8D2,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8D1
1F8E0:  MOVFF  FF7,8D2
1F8E4:  MOVFF  FF8,8D3
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8D1,FF6
1F8F4:  MOVFF  8D2,FF7
1F8F8:  MOVFF  8D3,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xD0,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xD1.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xD0,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xD1,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xD0,F
1F936:  MOVLW  0A
1F938:  SUBWF  xD0,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xD1.7
1F942:  MOVF   xD1,W
1F944:  ADDWF  xD0,F
1F946:  MOVF   xD0,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xD3,W
1F956:  CLRF   01
1F958:  SUBWF  xD2,W
1F95A:  BC    1F962
1F95C:  MOVFF  8D2,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xD4
1F968:  RLCF   xD2,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xD3,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xD4,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8D0,8D2
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xD3
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8D0
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xD1.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xD1.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xD1.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xD1.3
1F9AC:  BCF    xD1.4
1F9AE:  BSF    xD1.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8D0,8D2
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xD3
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8D0
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xD1.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xD1.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xD1.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xD0,F
1F9F0:  MOVF   xD0,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8D0,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8D1,01
1FA60:  MOVFF  8D0,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... #ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... #else 
....................    #FUSES NOMCLR 
.................... #endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... #FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... #FUSES WDT_SW                    // WDT is s/w controlled 
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
0288E:  MOVLW  09
02890:  MOVWF  FEA
02892:  MOVLW  C8
02894:  MOVWF  FE9
02896:  MOVF   FEF,W
02898:  BZ    28B6
0289A:  MOVLW  14
0289C:  MOVWF  01
0289E:  CLRF   00
028A0:  DECFSZ 00,F
028A2:  BRA    28A0
028A4:  DECFSZ 01,F
028A6:  BRA    289E
028A8:  MOVLW  BF
028AA:  MOVWF  00
028AC:  DECFSZ 00,F
028AE:  BRA    28AC
028B0:  BRA    28B2
028B2:  DECFSZ FEF,F
028B4:  BRA    289A
028B6:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E1A:  BTFSS  F9E.5
00E1C:  BRA    0E1A
00E1E:  MOVFF  FAB,1C
00E22:  MOVFF  FAE,01
00E26:  BTFSS  1C.1
00E28:  BRA    0E2E
00E2A:  BCF    FAB.4
00E2C:  BSF    FAB.4
00E2E:  RETURN 0
*
0ADBE:  BTFSS  F9E.4
0ADC0:  BRA    ADBE
0ADC2:  MOVWF  FAD
0ADC4:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12B16:  BTFSS  FA4.5
12B18:  BRA    12B16
12B1A:  MOVLB  F
12B1C:  MOVFF  F22,1C
12B20:  MOVFF  F1D,01
12B24:  BTFSS  1C.1
12B26:  BRA    12B2C
12B28:  BCF    x22.4
12B2A:  BSF    x22.4
12B2C:  MOVLB  0
12B2E:  RETURN 0
*
16A2C:  BTFSS  FA4.4
16A2E:  BRA    16A2C
16A30:  MOVLB  F
16A32:  MOVWF  x1C
16A34:  MOVLB  0
16A36:  GOTO   16AD0 (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xD6
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xD7
1F850:  MOVF   xD7,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8D5,03
1F85A:  MOVFF  8D4,FE9
1F85E:  MOVFF  8D5,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xD6,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8D8
1F870:  MOVFF  8D4,FE9
1F874:  MOVFF  8D5,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xD8,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xD6
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xD6,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8D8
1F88C:  MOVFF  8D4,FE9
1F890:  MOVFF  8D5,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xD8,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xD6
....................       }  
1F89C:  MOVF   xD7,W
1F89E:  INCF   xD7,F
1F8A0:  INCF   xD4,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xD5,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8D6,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xD4,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8D1,03
1FA84:  MOVFF  8D0,FE9
1FA88:  MOVFF  8D1,FEA
1FA8C:  MOVFF  FEF,8D5
1FA90:  MOVFF  8D3,03
1FA94:  MOVFF  8D2,FE9
1FA98:  MOVFF  8D3,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xD5,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8D1,03
1FAA6:  MOVFF  8D0,FE9
1FAAA:  MOVFF  8D1,FEA
1FAAE:  MOVFF  FEF,8D5
1FAB2:  MOVFF  8D3,03
1FAB6:  MOVFF  8D2,FE9
1FABA:  MOVFF  8D3,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xD5,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8D1,03
1FAD4:  MOVFF  8D0,FE9
1FAD8:  MOVFF  8D1,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8D1,03
1FAEA:  MOVF   xD0,W
1FAEC:  INCF   xD0,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xD1,F
1FAF2:  MOVFF  8D3,03
1FAF6:  MOVF   xD2,W
1FAF8:  INCF   xD2,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xD3,F
1FAFE:  DECF   xD4,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x61.1
1FB0E:  CLRF   x6B
1FB10:  CLRF   x6A
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xC8
1FB2A:  MOVLB  0
1FB2C:  CALL   288E
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x61.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x67
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x67,W
1FB3C:  ADDLW  90
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x67,W
1FB50:  INCF   x67,F
1FB52:  CLRF   03
1FB54:  ADDLW  90
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x67,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x61.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   x90,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xD5
1FB80:  MOVLW  91
1FB82:  MOVWF  xD4
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,866
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xD5
1FB92:  MOVLW  93
1FB94:  MOVWF  xD4
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8D0
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xD5
1FBA4:  MOVLW  95
1FBA6:  MOVWF  xD4
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8D0,869
1FBB0:  MOVFF  01,868
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xD5
1FBBA:  MOVLW  97
1FBBC:  MOVWF  xD4
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,863
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  86A,86E
1FBCA:  MOVFF  86B,86F
1FBCE:  MOVFF  868,86C
1FBD2:  MOVFF  869,86D
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x63,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x61.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x61.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x6F,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x6E,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x6D,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x6F,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x6E,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x6F,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x6E,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x62
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x65
1FC26:  MOVLW  03
1FC28:  SUBWF  x67,W
1FC2A:  SUBWF  x65,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x65,W
1FC32:  ADDLW  90
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8D0
1FC3E:  MOVFF  03,8D1
1FC42:  MOVFF  03,8D5
1FC46:  MOVFF  01,8D4
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x62,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x65,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x62,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x62
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x67,W
1FC68:  CLRF   03
1FC6A:  ADDLW  90
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8D0
1FC76:  MOVFF  03,8D1
1FC7A:  MOVFF  03,8D5
1FC7E:  MOVFF  01,8D4
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x62,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x61.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x63,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x65
1FCAE:  CLRF   x64
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x67,W
1FCB4:  SUBWF  x65,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x64,W
1FCBA:  INCF   x64,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  70
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8D0
1FCCA:  MOVFF  03,8D1
1FCCE:  CLRF   03
1FCD0:  MOVF   x65,W
1FCD2:  ADDLW  90
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8D2
1FCDE:  MOVFF  03,8D3
1FCE2:  MOVFF  03,8D5
1FCE6:  MOVFF  01,8D4
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8D1,FEA
1FCF2:  MOVFF  8D0,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x65,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xD0
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  86F,8D0
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xD1
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  86E,8D0
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xD1
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  86D,8D0
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xD1
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  86C,8D0
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xD1
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  866,8D0
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xD1
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  86E,FF8
1FD80:  MOVFF  86D,FF7
1FD84:  MOVFF  86C,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  70
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  866,8D0
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  86E,FF8
1FD9A:  MOVFF  86D,FF7
1FD9E:  MOVFF  86C,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  90
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xD1
1FDAE:  MOVFF  866,8D0
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xD1
1FDBC:  MOVLW  70
1FDBE:  MOVWF  xD0
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xD3
1FDC4:  MOVLW  90
1FDC6:  MOVWF  xD2
1FDC8:  MOVFF  866,8D4
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x61.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x63,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xD5
1FE02:  MOVLW  99
1FE04:  MOVWF  xD4
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8D0
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xD5
1FE14:  MOVLW  9B
1FE16:  MOVWF  xD4
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8D0,86B
1FE20:  MOVFF  01,86A
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xD0
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  86A,8D0
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xD1
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x61.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x61.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xD0
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xC8
1FE8E:  MOVLB  0
1FE90:  CALL   288E
1FE94:  MOVLB  8
1FE96:  DECFSZ xD0,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
054CE:  BCF    FF2.5
....................    restart_wdt(); 
054D0:  CLRWDT
054D2:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
054D4:  CLRF   FCF
054D6:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
054D8:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
054DA:  MOVF   2F,W
054DC:  SUBLW  02
054DE:  BNZ   54E6
054E0:  MOVF   30,F
054E2:  BNZ   54E6
054E4:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
054E6:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
054E8:  BSF    F9D.0
054EA:  GOTO   54FE (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
054EE:  MOVLW  0B
054F0:  MOVWF  FD7
054F2:  MOVLW  DC
054F4:  MOVWF  FD6
....................    restart_wdt(); 
054F6:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
054F8:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
054FA:  BSF    FF2.5
....................    setup_led_pulse(); 
054FC:  BRA    54D4
054FE:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
05500:  MOVLB  8
05502:  MOVF   xC9,W
05504:  XORLW  00
05506:  MOVLB  0
05508:  BZ    5510
0550A:  XORLW  01
0550C:  BZ    5514
0550E:  BRA    5516
....................       case 0 : suspend_heartbeat(); 
05510:  RCALL  54CE
....................          break; 
05512:  BRA    5516
....................       case 1 : restart_heartbeat(); 
05514:  RCALL  54EE
....................          break; 
....................    } 
05516:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
03074:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
03076:  BCF    FD1.0
03078:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
0287E:  MOVLW  0B
02880:  MOVWF  FD7
02882:  MOVLW  DC
02884:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
02886:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
02888:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
0288A:  BSF    FD1.0
0288C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
07858:  MOVFF  98D,993
0785C:  MOVFF  98C,992
07860:  MOVLB  9
07862:  MOVF   x90,F
07864:  BNZ   786A
07866:  MOVF   x91,F
07868:  BZ    78B4
0786A:  MOVFF  98F,03
0786E:  MOVFF  98E,FE9
07872:  MOVFF  98F,FEA
07876:  MOVF   FEF,F
07878:  BZ    78B4
....................      *s++ = *s2++; 
0787A:  MOVFF  993,995
0787E:  MOVF   x92,W
07880:  INCF   x92,F
07882:  BTFSC  FD8.2
07884:  INCF   x93,F
07886:  MOVWF  x94
07888:  MOVFF  98F,03
0788C:  MOVF   x8E,W
0788E:  INCF   x8E,F
07890:  BTFSC  FD8.2
07892:  INCF   x8F,F
07894:  MOVWF  FE9
07896:  MOVFF  03,FEA
0789A:  MOVFF  FEF,996
0789E:  MOVFF  995,FEA
078A2:  MOVFF  994,FE9
078A6:  MOVFF  996,FEF
078AA:  MOVF   x90,W
078AC:  BTFSC  FD8.2
078AE:  DECF   x91,F
078B0:  DECF   x90,F
078B2:  BRA    7862
....................   for (; n > 0; n--) 
078B4:  MOVF   x90,F
078B6:  BNZ   78BC
078B8:  MOVF   x91,F
078BA:  BZ    78DA
....................      *s++ = '\0'; 
078BC:  MOVFF  993,03
078C0:  MOVF   x92,W
078C2:  INCF   x92,F
078C4:  BTFSC  FD8.2
078C6:  INCF   x93,F
078C8:  MOVWF  FE9
078CA:  MOVFF  03,FEA
078CE:  CLRF   FEF
078D0:  MOVF   x90,W
078D2:  BTFSC  FD8.2
078D4:  DECF   x91,F
078D6:  DECF   x90,F
078D8:  BRA    78B4
....................  
....................   return(s1); 
078DA:  MOVFF  98C,01
078DE:  MOVFF  98D,02
078E2:  MOVLB  0
078E4:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0545C:  MOVFF  8D5,8D9
05460:  MOVFF  8D4,8D8
05464:  MOVFF  8D9,03
05468:  MOVLB  8
0546A:  MOVFF  8D8,FE9
0546E:  MOVFF  8D9,FEA
05472:  MOVF   FEF,F
05474:  BZ    5482
05476:  INCF   xD8,F
05478:  BTFSC  FD8.2
0547A:  INCF   xD9,F
0547C:  MOVLB  0
0547E:  BRA    5464
05480:  MOVLB  8
....................    while(*s2 != '\0') 
05482:  MOVFF  8D7,03
05486:  MOVFF  8D6,FE9
0548A:  MOVFF  8D7,FEA
0548E:  MOVF   FEF,F
05490:  BZ    54B8
....................    { 
....................       *s = *s2; 
05492:  MOVFF  8D6,FE9
05496:  MOVFF  8D7,FEA
0549A:  MOVFF  FEF,8DC
0549E:  MOVFF  8D9,FEA
054A2:  MOVFF  8D8,FE9
054A6:  MOVFF  8DC,FEF
....................       ++s; 
054AA:  INCF   xD8,F
054AC:  BTFSC  FD8.2
054AE:  INCF   xD9,F
....................       ++s2; 
054B0:  INCF   xD6,F
054B2:  BTFSC  FD8.2
054B4:  INCF   xD7,F
054B6:  BRA    5482
....................    } 
....................  
....................    *s = '\0'; 
054B8:  MOVFF  8D8,FE9
054BC:  MOVFF  8D9,FEA
054C0:  CLRF   FEF
....................    return(s1); 
054C2:  MOVFF  8D4,01
054C6:  MOVFF  8D5,02
054CA:  MOVLB  0
054CC:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12A92:  MOVFF  8CA,8D0
12A96:  MOVFF  8C9,8CF
12A9A:  MOVFF  8D0,03
12A9E:  MOVLB  8
12AA0:  MOVFF  8CF,FE9
12AA4:  MOVFF  8D0,FEA
12AA8:  MOVF   FEF,F
12AAA:  BZ    12AB8
12AAC:  INCF   xCF,F
12AAE:  BTFSC  FD8.2
12AB0:  INCF   xD0,F
12AB2:  MOVLB  0
12AB4:  BRA    12A9A
12AB6:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12AB8:  MOVFF  8CC,03
12ABC:  MOVFF  8CB,FE9
12AC0:  MOVFF  8CC,FEA
12AC4:  MOVF   FEF,F
12AC6:  BZ    12B00
12AC8:  MOVF   xCE,F
12ACA:  BNZ   12AD2
12ACC:  MOVF   xCD,W
12ACE:  SUBLW  00
12AD0:  BC    12B00
....................    { 
....................       *s = *s2; 
12AD2:  MOVFF  8CB,FE9
12AD6:  MOVFF  8CC,FEA
12ADA:  MOVFF  FEF,8D3
12ADE:  MOVFF  8D0,FEA
12AE2:  MOVFF  8CF,FE9
12AE6:  MOVFF  8D3,FEF
....................       ++s; 
12AEA:  INCF   xCF,F
12AEC:  BTFSC  FD8.2
12AEE:  INCF   xD0,F
....................       ++s2; 
12AF0:  INCF   xCB,F
12AF2:  BTFSC  FD8.2
12AF4:  INCF   xCC,F
....................       --n; 
12AF6:  MOVF   xCD,W
12AF8:  BTFSC  FD8.2
12AFA:  DECF   xCE,F
12AFC:  DECF   xCD,F
12AFE:  BRA    12AB8
....................    } 
....................  
....................    *s = '\0'; 
12B00:  MOVFF  8CF,FE9
12B04:  MOVFF  8D0,FEA
12B08:  CLRF   FEF
....................    return(s1); 
12B0A:  MOVFF  8C9,01
12B0E:  MOVFF  8CA,02
12B12:  MOVLB  0
12B14:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
04598:  MOVFF  9C6,9CC
0459C:  MOVFF  9C5,9CB
045A0:  MOVFF  9C8,9CE
045A4:  MOVFF  9C7,9CD
045A8:  MOVLB  9
045AA:  MOVF   xCA,F
045AC:  BNZ   45B4
045AE:  MOVF   xC9,W
045B0:  SUBLW  00
045B2:  BC    4614
.................... { 
....................    if(*su1!=*su2) 
045B4:  MOVFF  9CB,FE9
045B8:  MOVFF  9CC,FEA
045BC:  MOVFF  FEF,9CF
045C0:  MOVFF  9CE,03
045C4:  MOVFF  9CD,FE9
045C8:  MOVFF  9CE,FEA
045CC:  MOVF   FEF,W
045CE:  SUBWF  xCF,W
045D0:  BZ    45FE
....................       return ((*su1<*su2)?-1:1); 
045D2:  MOVFF  9CC,03
045D6:  MOVFF  9CB,FE9
045DA:  MOVFF  03,FEA
045DE:  MOVFF  FEF,9CF
045E2:  MOVFF  9CE,03
045E6:  MOVFF  9CD,FE9
045EA:  MOVFF  9CE,FEA
045EE:  MOVF   FEF,W
045F0:  SUBWF  xCF,W
045F2:  BC    45F8
045F4:  MOVLW  FF
045F6:  BRA    45FA
045F8:  MOVLW  01
045FA:  MOVWF  01
045FC:  BRA    4618
045FE:  INCF   xCB,F
04600:  BTFSC  FD8.2
04602:  INCF   xCC,F
04604:  INCF   xCD,F
04606:  BTFSC  FD8.2
04608:  INCF   xCE,F
0460A:  MOVF   xC9,W
0460C:  BTFSC  FD8.2
0460E:  DECF   xCA,F
04610:  DECF   xC9,F
04612:  BRA    45AA
.................... } 
.................... return 0; 
04614:  MOVLW  00
04616:  MOVWF  01
04618:  MOVLB  0
0461A:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12A56:  MOVFF  8C8,8CA
12A5A:  MOVFF  8C7,8C9
12A5E:  MOVFF  8CA,03
12A62:  MOVLB  8
12A64:  MOVFF  8C9,FE9
12A68:  MOVFF  8CA,FEA
12A6C:  MOVF   FEF,F
12A6E:  BZ    12A7C
12A70:  INCF   xC9,F
12A72:  BTFSC  FD8.2
12A74:  INCF   xCA,F
12A76:  MOVLB  0
12A78:  BRA    12A5E
12A7A:  MOVLB  8
....................    return(sc - s); 
12A7C:  MOVF   xC7,W
12A7E:  SUBWF  xC9,W
12A80:  MOVWF  00
12A82:  MOVF   xC8,W
12A84:  SUBWFB xCA,W
12A86:  MOVWF  03
12A88:  MOVFF  00,01
12A8C:  MOVWF  02
12A8E:  MOVLB  0
12A90:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
130D6:  MOVLB  8
130D8:  CLRF   xB6
....................    sign = 0; 
130DA:  CLRF   xB4
....................    base = 10; 
130DC:  MOVLW  0A
130DE:  MOVWF  xB5
....................    result = 0; 
130E0:  CLRF   xB3
130E2:  CLRF   xB2
....................  
....................    if (!s) 
130E4:  MOVF   xB0,W
130E6:  IORWF  xB1,W
130E8:  BNZ   130F2
....................       return 0; 
130EA:  MOVLW  00
130EC:  MOVWF  01
130EE:  MOVWF  02
130F0:  BRA    132B6
....................    c = s[index++]; 
130F2:  MOVF   xB6,W
130F4:  INCF   xB6,F
130F6:  ADDWF  xB0,W
130F8:  MOVWF  FE9
130FA:  MOVLW  00
130FC:  ADDWFC xB1,W
130FE:  MOVWF  FEA
13100:  MOVFF  FEF,8B7
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
13104:  MOVF   xB7,W
13106:  SUBLW  2D
13108:  BNZ   13122
....................    { 
....................       sign = 1;         // Set the sign to negative 
1310A:  MOVLW  01
1310C:  MOVWF  xB4
....................       c = s[index++]; 
1310E:  MOVF   xB6,W
13110:  INCF   xB6,F
13112:  ADDWF  xB0,W
13114:  MOVWF  FE9
13116:  MOVLW  00
13118:  ADDWFC xB1,W
1311A:  MOVWF  FEA
1311C:  MOVFF  FEF,8B7
....................    } 
13120:  BRA    1313A
....................    else if (c == '+') 
13122:  MOVF   xB7,W
13124:  SUBLW  2B
13126:  BNZ   1313A
....................    { 
....................       c = s[index++]; 
13128:  MOVF   xB6,W
1312A:  INCF   xB6,F
1312C:  ADDWF  xB0,W
1312E:  MOVWF  FE9
13130:  MOVLW  00
13132:  ADDWFC xB1,W
13134:  MOVWF  FEA
13136:  MOVFF  FEF,8B7
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1313A:  MOVF   xB7,W
1313C:  SUBLW  2F
1313E:  BTFSC  FD8.0
13140:  BRA    1329A
13142:  MOVF   xB7,W
13144:  SUBLW  39
13146:  BTFSS  FD8.0
13148:  BRA    1329A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1314A:  MOVF   xB7,W
1314C:  SUBLW  30
1314E:  BNZ   1318C
13150:  MOVF   xB6,W
13152:  ADDWF  xB0,W
13154:  MOVWF  FE9
13156:  MOVLW  00
13158:  ADDWFC xB1,W
1315A:  MOVWF  FEA
1315C:  MOVF   FEF,W
1315E:  SUBLW  78
13160:  BZ    13174
13162:  MOVF   xB6,W
13164:  ADDWF  xB0,W
13166:  MOVWF  FE9
13168:  MOVLW  00
1316A:  ADDWFC xB1,W
1316C:  MOVWF  FEA
1316E:  MOVF   FEF,W
13170:  SUBLW  58
13172:  BNZ   1318C
....................       { 
....................          base = 16; 
13174:  MOVLW  10
13176:  MOVWF  xB5
....................          index++; 
13178:  INCF   xB6,F
....................          c = s[index++]; 
1317A:  MOVF   xB6,W
1317C:  INCF   xB6,F
1317E:  ADDWF  xB0,W
13180:  MOVWF  FE9
13182:  MOVLW  00
13184:  ADDWFC xB1,W
13186:  MOVWF  FEA
13188:  MOVFF  FEF,8B7
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1318C:  MOVF   xB5,W
1318E:  SUBLW  0A
13190:  BNZ   131D6
....................       { 
....................          while (c >= '0' && c <= '9') 
13192:  MOVF   xB7,W
13194:  SUBLW  2F
13196:  BC    131D4
13198:  MOVF   xB7,W
1319A:  SUBLW  39
1319C:  BNC   131D4
....................          { 
....................             result = 10*result + (c - '0'); 
1319E:  CLRF   xB9
131A0:  MOVLW  0A
131A2:  MOVWF  xB8
131A4:  MOVFF  8B3,8BB
131A8:  MOVFF  8B2,8BA
131AC:  MOVLB  0
131AE:  BRA    13080
131B0:  MOVLW  30
131B2:  MOVLB  8
131B4:  SUBWF  xB7,W
131B6:  ADDWF  01,W
131B8:  MOVWF  xB2
131BA:  MOVLW  00
131BC:  ADDWFC 02,W
131BE:  MOVWF  xB3
....................             c = s[index++]; 
131C0:  MOVF   xB6,W
131C2:  INCF   xB6,F
131C4:  ADDWF  xB0,W
131C6:  MOVWF  FE9
131C8:  MOVLW  00
131CA:  ADDWFC xB1,W
131CC:  MOVWF  FEA
131CE:  MOVFF  FEF,8B7
131D2:  BRA    13192
....................          } 
....................       } 
131D4:  BRA    1329A
....................       else if (base == 16)    // The number is a hexa number 
131D6:  MOVF   xB5,W
131D8:  SUBLW  10
131DA:  BNZ   1329A
....................       { 
....................          c = toupper(c); 
131DC:  MOVF   xB7,W
131DE:  SUBLW  60
131E0:  BC    131EE
131E2:  MOVF   xB7,W
131E4:  SUBLW  7A
131E6:  BNC   131EE
131E8:  MOVF   xB7,W
131EA:  ANDLW  DF
131EC:  BRA    131F0
131EE:  MOVF   xB7,W
131F0:  MOVWF  xB7
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
131F2:  MOVF   xB7,W
131F4:  SUBLW  2F
131F6:  BC    131FE
131F8:  MOVF   xB7,W
131FA:  SUBLW  39
131FC:  BC    1320A
131FE:  MOVF   xB7,W
13200:  SUBLW  40
13202:  BC    1329A
13204:  MOVF   xB7,W
13206:  SUBLW  46
13208:  BNC   1329A
....................          { 
....................             if (c >= '0' && c <= '9') 
1320A:  MOVF   xB7,W
1320C:  SUBLW  2F
1320E:  BC    13244
13210:  MOVF   xB7,W
13212:  SUBLW  39
13214:  BNC   13244
....................                result = (result << 4) + (c - '0'); 
13216:  RLCF   xB2,W
13218:  MOVWF  xB8
1321A:  RLCF   xB3,W
1321C:  MOVWF  xB9
1321E:  RLCF   xB8,F
13220:  RLCF   xB9,F
13222:  RLCF   xB8,F
13224:  RLCF   xB9,F
13226:  RLCF   xB8,F
13228:  RLCF   xB9,F
1322A:  MOVLW  F0
1322C:  ANDWF  xB8,F
1322E:  MOVLW  30
13230:  SUBWF  xB7,W
13232:  ADDWF  xB8,W
13234:  MOVWF  01
13236:  MOVLW  00
13238:  ADDWFC xB9,W
1323A:  MOVWF  03
1323C:  MOVFF  01,8B2
13240:  MOVWF  xB3
13242:  BRA    13270
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
13244:  RLCF   xB2,W
13246:  MOVWF  xB8
13248:  RLCF   xB3,W
1324A:  MOVWF  xB9
1324C:  RLCF   xB8,F
1324E:  RLCF   xB9,F
13250:  RLCF   xB8,F
13252:  RLCF   xB9,F
13254:  RLCF   xB8,F
13256:  RLCF   xB9,F
13258:  MOVLW  F0
1325A:  ANDWF  xB8,F
1325C:  MOVLW  41
1325E:  SUBWF  xB7,W
13260:  ADDLW  0A
13262:  ADDWF  xB8,W
13264:  MOVWF  01
13266:  MOVLW  00
13268:  ADDWFC xB9,W
1326A:  MOVFF  01,8B2
1326E:  MOVWF  xB3
....................  
....................             c = s[index++];c = toupper(c); 
13270:  MOVF   xB6,W
13272:  INCF   xB6,F
13274:  ADDWF  xB0,W
13276:  MOVWF  FE9
13278:  MOVLW  00
1327A:  ADDWFC xB1,W
1327C:  MOVWF  FEA
1327E:  MOVFF  FEF,8B7
13282:  MOVF   xB7,W
13284:  SUBLW  60
13286:  BC    13294
13288:  MOVF   xB7,W
1328A:  SUBLW  7A
1328C:  BNC   13294
1328E:  MOVF   xB7,W
13290:  ANDLW  DF
13292:  BRA    13296
13294:  MOVF   xB7,W
13296:  MOVWF  xB7
13298:  BRA    131F2
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1329A:  MOVF   xB5,W
1329C:  SUBLW  0A
1329E:  BNZ   132AE
132A0:  DECFSZ xB4,W
132A2:  BRA    132AE
....................       result = -result; 
132A4:  COMF   xB2,F
132A6:  COMF   xB3,F
132A8:  INCF   xB2,F
132AA:  BTFSC  FD8.2
132AC:  INCF   xB3,F
....................  
....................    return(result); 
132AE:  MOVFF  8B2,01
132B2:  MOVFF  8B3,02
132B6:  MOVLB  0
132B8:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0C7B6:  MOVLB  8
0C7B8:  CLRF   x80
0C7BA:  CLRF   x7F
0C7BC:  CLRF   x7E
0C7BE:  MOVLW  7F
0C7C0:  MOVWF  x7D
0C7C2:  CLRF   x84
0C7C4:  CLRF   x83
0C7C6:  CLRF   x82
0C7C8:  CLRF   x81
0C7CA:  BSF    x85.0
0C7CC:  BCF    x85.1
0C7CE:  BCF    x85.2
0C7D0:  CLRF   x87
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0C7D2:  MOVF   x79,W
0C7D4:  IORWF  x7A,W
0C7D6:  BNZ   C7E2
....................       return 0; 
0C7D8:  CLRF   00
0C7DA:  CLRF   01
0C7DC:  CLRF   02
0C7DE:  CLRF   03
0C7E0:  BRA    CA06
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0C7E2:  MOVF   x87,W
0C7E4:  INCF   x87,F
0C7E6:  ADDWF  x79,W
0C7E8:  MOVWF  FE9
0C7EA:  MOVLW  00
0C7EC:  ADDWFC x7A,W
0C7EE:  MOVWF  FEA
0C7F0:  MOVFF  FEF,886
0C7F4:  MOVF   x86,F
0C7F6:  BTFSC  FD8.2
0C7F8:  BRA    C98A
....................    { 
....................       if (skip && !isspace(c)) 
0C7FA:  BTFSS  x85.0
0C7FC:  BRA    C81C
0C7FE:  MOVF   x86,W
0C800:  SUBLW  20
0C802:  BZ    C81C
....................       { 
....................          skip = 0; 
0C804:  BCF    x85.0
....................          if (c == '+') 
0C806:  MOVF   x86,W
0C808:  SUBLW  2B
0C80A:  BNZ   C812
....................          { 
....................             sign = 0; 
0C80C:  BCF    x85.1
....................             continue; 
0C80E:  BRA    C972
....................          }             
0C810:  BRA    C81C
....................          else if (c == '-') 
0C812:  MOVF   x86,W
0C814:  SUBLW  2D
0C816:  BNZ   C81C
....................          { 
....................             sign = 1; 
0C818:  BSF    x85.1
....................             continue; 
0C81A:  BRA    C972
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0C81C:  BTFSC  x85.0
0C81E:  BRA    C82E
0C820:  MOVF   x86,W
0C822:  SUBLW  2E
0C824:  BNZ   C82E
0C826:  BTFSC  x85.2
0C828:  BRA    C82E
....................          point = 1; 
0C82A:  BSF    x85.2
0C82C:  BRA    C972
....................       else if (!skip && isdigit(c)) 
0C82E:  BTFSC  x85.0
0C830:  BRA    C96C
0C832:  MOVF   x86,W
0C834:  SUBLW  2F
0C836:  BTFSC  FD8.0
0C838:  BRA    C96C
0C83A:  MOVF   x86,W
0C83C:  SUBLW  39
0C83E:  BTFSS  FD8.0
0C840:  BRA    C96C
....................       { 
....................          c -= '0'; 
0C842:  MOVLW  30
0C844:  SUBWF  x86,F
....................          if (point) 
0C846:  BTFSS  x85.2
0C848:  BRA    C8F4
....................          { 
....................             pow10 = pow10 * 10.0; 
0C84A:  MOVFF  880,8F2
0C84E:  MOVFF  87F,8F1
0C852:  MOVFF  87E,8F0
0C856:  MOVFF  87D,8EF
0C85A:  CLRF   xF6
0C85C:  CLRF   xF5
0C85E:  MOVLW  20
0C860:  MOVWF  xF4
0C862:  MOVLW  82
0C864:  MOVWF  xF3
0C866:  MOVLB  0
0C868:  CALL   BF40
0C86C:  MOVFF  03,880
0C870:  MOVFF  02,87F
0C874:  MOVFF  01,87E
0C878:  MOVFF  00,87D
....................             result += (float)c / pow10;    
0C87C:  MOVLB  8
0C87E:  CLRF   xF4
0C880:  MOVFF  886,8F3
0C884:  MOVLB  0
0C886:  RCALL  C622
0C888:  MOVFF  03,88B
0C88C:  MOVFF  02,88A
0C890:  MOVFF  01,889
0C894:  MOVFF  00,888
0C898:  MOVFF  03,8DA
0C89C:  MOVFF  02,8D9
0C8A0:  MOVFF  01,8D8
0C8A4:  MOVFF  00,8D7
0C8A8:  MOVFF  880,8DE
0C8AC:  MOVFF  87F,8DD
0C8B0:  MOVFF  87E,8DC
0C8B4:  MOVFF  87D,8DB
0C8B8:  RCALL  C658
0C8BA:  BCF    FD8.1
0C8BC:  MOVFF  884,8F6
0C8C0:  MOVFF  883,8F5
0C8C4:  MOVFF  882,8F4
0C8C8:  MOVFF  881,8F3
0C8CC:  MOVFF  03,8FA
0C8D0:  MOVFF  02,8F9
0C8D4:  MOVFF  01,8F8
0C8D8:  MOVFF  00,8F7
0C8DC:  CALL   C036
0C8E0:  MOVFF  03,884
0C8E4:  MOVFF  02,883
0C8E8:  MOVFF  01,882
0C8EC:  MOVFF  00,881
....................          } 
0C8F0:  BRA    C968
0C8F2:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0C8F4:  CLRF   xF2
0C8F6:  CLRF   xF1
0C8F8:  MOVLW  20
0C8FA:  MOVWF  xF0
0C8FC:  MOVLW  82
0C8FE:  MOVWF  xEF
0C900:  MOVFF  884,8F6
0C904:  MOVFF  883,8F5
0C908:  MOVFF  882,8F4
0C90C:  MOVFF  881,8F3
0C910:  MOVLB  0
0C912:  CALL   BF40
0C916:  MOVFF  03,88B
0C91A:  MOVFF  02,88A
0C91E:  MOVFF  01,889
0C922:  MOVFF  00,888
0C926:  MOVLB  8
0C928:  CLRF   xF4
0C92A:  MOVFF  886,8F3
0C92E:  MOVLB  0
0C930:  RCALL  C622
0C932:  BCF    FD8.1
0C934:  MOVFF  88B,8F6
0C938:  MOVFF  88A,8F5
0C93C:  MOVFF  889,8F4
0C940:  MOVFF  888,8F3
0C944:  MOVFF  03,8FA
0C948:  MOVFF  02,8F9
0C94C:  MOVFF  01,8F8
0C950:  MOVFF  00,8F7
0C954:  CALL   C036
0C958:  MOVFF  03,884
0C95C:  MOVFF  02,883
0C960:  MOVFF  01,882
0C964:  MOVFF  00,881
....................          } 
....................       } 
0C968:  BRA    C974
0C96A:  MOVLB  8
....................       else if (!skip) 
0C96C:  BTFSC  x85.0
0C96E:  BRA    C972
....................          break; 
0C970:  BRA    C98A
0C972:  MOVLB  0
0C974:  MOVLB  8
0C976:  MOVF   x87,W
0C978:  INCF   x87,F
0C97A:  ADDWF  x79,W
0C97C:  MOVWF  FE9
0C97E:  MOVLW  00
0C980:  ADDWFC x7A,W
0C982:  MOVWF  FEA
0C984:  MOVFF  FEF,886
0C988:  BRA    C7F4
....................    } 
....................  
....................    if (sign) 
0C98A:  BTFSS  x85.1
0C98C:  BRA    C9C2
....................       result = -1*result; 
0C98E:  CLRF   xF2
0C990:  CLRF   xF1
0C992:  MOVLW  80
0C994:  MOVWF  xF0
0C996:  MOVLW  7F
0C998:  MOVWF  xEF
0C99A:  MOVFF  884,8F6
0C99E:  MOVFF  883,8F5
0C9A2:  MOVFF  882,8F4
0C9A6:  MOVFF  881,8F3
0C9AA:  MOVLB  0
0C9AC:  CALL   BF40
0C9B0:  MOVFF  03,884
0C9B4:  MOVFF  02,883
0C9B8:  MOVFF  01,882
0C9BC:  MOVFF  00,881
0C9C0:  MOVLB  8
....................        
....................    if(endptr) 
0C9C2:  MOVF   x7B,W
0C9C4:  IORWF  x7C,W
0C9C6:  BZ    C9F6
....................    { 
....................       if (ptr) { 
0C9C8:  MOVF   x87,F
0C9CA:  BZ    C9E4
....................          ptr--; 
0C9CC:  DECF   x87,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0C9CE:  MOVFF  87B,FE9
0C9D2:  MOVFF  87C,FEA
0C9D6:  MOVF   x87,W
0C9D8:  ADDWF  x79,W
0C9DA:  MOVWF  FEF
0C9DC:  MOVLW  00
0C9DE:  ADDWFC x7A,W
0C9E0:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0C9E2:  BRA    C9F6
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0C9E4:  MOVFF  87B,FE9
0C9E8:  MOVFF  87C,FEA
0C9EC:  MOVFF  87A,FEC
0C9F0:  MOVF   FED,F
0C9F2:  MOVFF  879,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0C9F6:  MOVFF  881,00
0C9FA:  MOVFF  882,01
0C9FE:  MOVFF  883,02
0CA02:  MOVFF  884,03
0CA06:  MOVLB  0
0CA08:  GOTO   CA30 (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
1252C:  MOVLB  8
1252E:  BCF    xEE.0
....................    y = x; 
12530:  MOVFF  8E2,8E7
12534:  MOVFF  8E1,8E6
12538:  MOVFF  8E0,8E5
1253C:  MOVFF  8DF,8E4
....................  
....................    if (x < 0) 
12540:  MOVFF  8E2,8F2
12544:  MOVFF  8E1,8F1
12548:  MOVFF  8E0,8F0
1254C:  MOVFF  8DF,8EF
12550:  CLRF   xF6
12552:  CLRF   xF5
12554:  CLRF   xF4
12556:  CLRF   xF3
12558:  MOVLB  0
1255A:  CALL   10460
1255E:  BNC   1256C
....................    { 
....................       s = 1; 
12560:  MOVLB  8
12562:  BSF    xEE.0
....................       y = -y; 
12564:  MOVF   xE5,W
12566:  XORLW  80
12568:  MOVWF  xE5
1256A:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
1256C:  MOVFF  8E7,8F2
12570:  MOVFF  8E6,8F1
12574:  MOVFF  8E5,8F0
12578:  MOVFF  8E4,8EF
1257C:  MOVLB  8
1257E:  CLRF   xF6
12580:  CLRF   xF5
12582:  CLRF   xF4
12584:  MOVLW  8E
12586:  MOVWF  xF3
12588:  MOVLB  0
1258A:  CALL   10460
1258E:  BC    12592
12590:  BNZ   125C2
....................       res = (float32)(unsigned int16)y; 
12592:  MOVFF  8E7,8F2
12596:  MOVFF  8E6,8F1
1259A:  MOVFF  8E5,8F0
1259E:  MOVFF  8E4,8EF
125A2:  RCALL  124F0
125A4:  MOVFF  02,8F4
125A8:  MOVFF  01,8F3
125AC:  CALL   C622
125B0:  MOVFF  03,8EB
125B4:  MOVFF  02,8EA
125B8:  MOVFF  01,8E9
125BC:  MOVFF  00,8E8
125C0:  BRA    12764
....................  
....................  else if (y < 10000000.0) 
125C2:  MOVFF  8E7,8F2
125C6:  MOVFF  8E6,8F1
125CA:  MOVFF  8E5,8F0
125CE:  MOVFF  8E4,8EF
125D2:  MOVLW  80
125D4:  MOVLB  8
125D6:  MOVWF  xF6
125D8:  MOVLW  96
125DA:  MOVWF  xF5
125DC:  MOVLW  18
125DE:  MOVWF  xF4
125E0:  MOVLW  96
125E2:  MOVWF  xF3
125E4:  MOVLB  0
125E6:  CALL   10460
125EA:  BTFSS  FD8.0
125EC:  BRA    12754
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
125EE:  MOVFF  8E7,8F2
125F2:  MOVFF  8E6,8F1
125F6:  MOVFF  8E5,8F0
125FA:  MOVFF  8E4,8EF
125FE:  MOVLB  8
12600:  CLRF   xF6
12602:  CLRF   xF5
12604:  CLRF   xF4
12606:  MOVLW  70
12608:  MOVWF  xF3
1260A:  MOVLB  0
1260C:  CALL   BF40
12610:  MOVFF  03,8F2
12614:  MOVFF  02,8F1
12618:  MOVFF  01,8F0
1261C:  MOVFF  00,8EF
12620:  RCALL  124F0
12622:  MOVFF  02,8ED
12626:  MOVFF  01,8EC
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
1262A:  MOVFF  8E7,8F2
1262E:  MOVFF  8E6,8F1
12632:  MOVFF  8E5,8F0
12636:  MOVFF  8E4,8EF
1263A:  MOVLB  8
1263C:  CLRF   xF6
1263E:  CLRF   xF5
12640:  CLRF   xF4
12642:  MOVLW  70
12644:  MOVWF  xF3
12646:  MOVLB  0
12648:  CALL   BF40
1264C:  MOVFF  03,8F2
12650:  MOVFF  02,8F1
12654:  MOVFF  01,8F0
12658:  MOVFF  00,8EF
1265C:  MOVFF  8ED,8F4
12660:  MOVFF  8EC,8F3
12664:  CALL   C622
12668:  BSF    FD8.1
1266A:  MOVFF  8F2,8F6
1266E:  MOVFF  8F1,8F5
12672:  MOVFF  8F0,8F4
12676:  MOVFF  8EF,8F3
1267A:  MOVFF  03,8FA
1267E:  MOVFF  02,8F9
12682:  MOVFF  01,8F8
12686:  MOVFF  00,8F7
1268A:  CALL   C036
1268E:  MOVLB  8
12690:  CLRF   xF2
12692:  CLRF   xF1
12694:  CLRF   xF0
12696:  MOVLW  8E
12698:  MOVWF  xEF
1269A:  MOVFF  03,8F6
1269E:  MOVFF  02,8F5
126A2:  MOVFF  01,8F4
126A6:  MOVFF  00,8F3
126AA:  MOVLB  0
126AC:  CALL   BF40
126B0:  MOVFF  03,8E7
126B4:  MOVFF  02,8E6
126B8:  MOVFF  01,8E5
126BC:  MOVFF  00,8E4
....................       res = 32768.0*(float32)l; 
126C0:  MOVFF  8ED,8F4
126C4:  MOVFF  8EC,8F3
126C8:  CALL   C622
126CC:  MOVLB  8
126CE:  CLRF   xF2
126D0:  CLRF   xF1
126D2:  CLRF   xF0
126D4:  MOVLW  8E
126D6:  MOVWF  xEF
126D8:  MOVFF  03,8F6
126DC:  MOVFF  02,8F5
126E0:  MOVFF  01,8F4
126E4:  MOVFF  00,8F3
126E8:  MOVLB  0
126EA:  CALL   BF40
126EE:  MOVFF  03,8EB
126F2:  MOVFF  02,8EA
126F6:  MOVFF  01,8E9
126FA:  MOVFF  00,8E8
....................       res += (float32)(unsigned int16)y; 
126FE:  MOVFF  8E7,8F2
12702:  MOVFF  8E6,8F1
12706:  MOVFF  8E5,8F0
1270A:  MOVFF  8E4,8EF
1270E:  RCALL  124F0
12710:  MOVFF  02,8F4
12714:  MOVFF  01,8F3
12718:  CALL   C622
1271C:  BCF    FD8.1
1271E:  MOVFF  8EB,8F6
12722:  MOVFF  8EA,8F5
12726:  MOVFF  8E9,8F4
1272A:  MOVFF  8E8,8F3
1272E:  MOVFF  03,8FA
12732:  MOVFF  02,8F9
12736:  MOVFF  01,8F8
1273A:  MOVFF  00,8F7
1273E:  CALL   C036
12742:  MOVFF  03,8EB
12746:  MOVFF  02,8EA
1274A:  MOVFF  01,8E9
1274E:  MOVFF  00,8E8
....................    } 
12752:  BRA    12764
....................  
....................  else 
....................   res = y; 
12754:  MOVFF  8E7,8EB
12758:  MOVFF  8E6,8EA
1275C:  MOVFF  8E5,8E9
12760:  MOVFF  8E4,8E8
....................  
....................  y = y - (float32)(unsigned int16)y; 
12764:  MOVFF  8E7,8F2
12768:  MOVFF  8E6,8F1
1276C:  MOVFF  8E5,8F0
12770:  MOVFF  8E4,8EF
12774:  RCALL  124F0
12776:  MOVFF  02,8F4
1277A:  MOVFF  01,8F3
1277E:  CALL   C622
12782:  BSF    FD8.1
12784:  MOVFF  8E7,8F6
12788:  MOVFF  8E6,8F5
1278C:  MOVFF  8E5,8F4
12790:  MOVFF  8E4,8F3
12794:  MOVFF  03,8FA
12798:  MOVFF  02,8F9
1279C:  MOVFF  01,8F8
127A0:  MOVFF  00,8F7
127A4:  CALL   C036
127A8:  MOVFF  03,8E7
127AC:  MOVFF  02,8E6
127B0:  MOVFF  01,8E5
127B4:  MOVFF  00,8E4
....................  
....................  if (s) 
127B8:  MOVLB  8
127BA:  BTFSS  xEE.0
127BC:  BRA    127C4
....................   res = -res; 
127BE:  MOVF   xE9,W
127C0:  XORLW  80
127C2:  MOVWF  xE9
....................  
....................  if (y != 0) 
127C4:  MOVFF  8E7,8F2
127C8:  MOVFF  8E6,8F1
127CC:  MOVFF  8E5,8F0
127D0:  MOVFF  8E4,8EF
127D4:  CLRF   xF6
127D6:  CLRF   xF5
127D8:  CLRF   xF4
127DA:  CLRF   xF3
127DC:  MOVLB  0
127DE:  CALL   10460
127E2:  BZ    1285C
....................  { 
....................   if (s == 1 && n == 0) 
127E4:  MOVLB  8
127E6:  BTFSS  xEE.0
127E8:  BRA    12822
127EA:  MOVF   xE3,F
127EC:  BNZ   12822
....................    res -= 1.0; 
127EE:  BSF    FD8.1
127F0:  MOVFF  8EB,8F6
127F4:  MOVFF  8EA,8F5
127F8:  MOVFF  8E9,8F4
127FC:  MOVFF  8E8,8F3
12800:  CLRF   xFA
12802:  CLRF   xF9
12804:  CLRF   xF8
12806:  MOVLW  7F
12808:  MOVWF  xF7
1280A:  MOVLB  0
1280C:  CALL   C036
12810:  MOVFF  03,8EB
12814:  MOVFF  02,8EA
12818:  MOVFF  01,8E9
1281C:  MOVFF  00,8E8
12820:  MOVLB  8
....................  
....................   if (s == 0 && n == 1) 
12822:  BTFSC  xEE.0
12824:  BRA    1285E
12826:  DECFSZ xE3,W
12828:  BRA    1285E
....................    res += 1.0; 
1282A:  BCF    FD8.1
1282C:  MOVFF  8EB,8F6
12830:  MOVFF  8EA,8F5
12834:  MOVFF  8E9,8F4
12838:  MOVFF  8E8,8F3
1283C:  CLRF   xFA
1283E:  CLRF   xF9
12840:  CLRF   xF8
12842:  MOVLW  7F
12844:  MOVWF  xF7
12846:  MOVLB  0
12848:  CALL   C036
1284C:  MOVFF  03,8EB
12850:  MOVFF  02,8EA
12854:  MOVFF  01,8E9
12858:  MOVFF  00,8E8
1285C:  MOVLB  8
....................  } 
....................  if (x == 0) 
1285E:  MOVFF  8E2,8F2
12862:  MOVFF  8E1,8F1
12866:  MOVFF  8E0,8F0
1286A:  MOVFF  8DF,8EF
1286E:  CLRF   xF6
12870:  CLRF   xF5
12872:  CLRF   xF4
12874:  CLRF   xF3
12876:  MOVLB  0
12878:  CALL   10460
1287C:  BNZ   1288A
....................     res = 0; 
1287E:  MOVLB  8
12880:  CLRF   xEB
12882:  CLRF   xEA
12884:  CLRF   xE9
12886:  CLRF   xE8
12888:  MOVLB  0
....................  
....................  return (res); 
1288A:  MOVFF  8E8,00
1288E:  MOVFF  8E9,01
12892:  MOVFF  8EA,02
12896:  MOVFF  8EB,03
1289A:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
128BA:  MOVFF  8DE,8E2
128BE:  MOVFF  8DD,8E1
128C2:  MOVFF  8DC,8E0
128C6:  MOVFF  8DB,8DF
128CA:  MOVLB  8
128CC:  CLRF   xE3
128CE:  MOVLB  0
128D0:  RCALL  1252C
128D2:  GOTO   129DE (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
1289C:  MOVFF  8DE,8E2
128A0:  MOVFF  8DD,8E1
128A4:  MOVFF  8DC,8E0
128A8:  MOVFF  8DB,8DF
128AC:  MOVLW  01
128AE:  MOVLB  8
128B0:  MOVWF  xE3
128B2:  MOVLB  0
128B4:  RCALL  1252C
128B6:  GOTO   12996 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
128D6:  MOVFF  8D2,8F2
128DA:  MOVFF  8D1,8F1
128DE:  MOVFF  8D0,8F0
128E2:  MOVFF  8CF,8EF
128E6:  MOVLB  8
128E8:  CLRF   xF6
128EA:  CLRF   xF5
128EC:  CLRF   xF4
128EE:  CLRF   xF3
128F0:  MOVLB  0
128F2:  CALL   10460
128F6:  BTFSC  FD8.2
128F8:  BRA    12A3A
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
128FA:  MOVFF  8CE,8DA
128FE:  MOVFF  8CD,8D9
12902:  MOVFF  8CC,8D8
12906:  MOVFF  8CB,8D7
1290A:  MOVFF  8D2,8DE
1290E:  MOVFF  8D1,8DD
12912:  MOVFF  8D0,8DC
12916:  MOVFF  8CF,8DB
1291A:  CALL   C658
1291E:  MOVFF  03,8DA
12922:  MOVFF  02,8D9
12926:  MOVFF  01,8D8
1292A:  MOVFF  00,8D7
1292E:  MOVFF  03,8F2
12932:  MOVFF  02,8F1
12936:  MOVFF  01,8F0
1293A:  MOVFF  00,8EF
1293E:  MOVLB  8
12940:  CLRF   xF6
12942:  CLRF   xF5
12944:  CLRF   xF4
12946:  CLRF   xF3
12948:  MOVLB  0
1294A:  CALL   10460
1294E:  BNC   12998
12950:  MOVFF  8CE,8DA
12954:  MOVFF  8CD,8D9
12958:  MOVFF  8CC,8D8
1295C:  MOVFF  8CB,8D7
12960:  MOVFF  8D2,8DE
12964:  MOVFF  8D1,8DD
12968:  MOVFF  8D0,8DC
1296C:  MOVFF  8CF,8DB
12970:  CALL   C658
12974:  MOVFF  03,8DA
12978:  MOVFF  02,8D9
1297C:  MOVFF  01,8D8
12980:  MOVFF  00,8D7
12984:  MOVFF  03,8DE
12988:  MOVFF  02,8DD
1298C:  MOVFF  01,8DC
12990:  MOVFF  00,8DB
12994:  BRA    1289C
12996:  BRA    129DE
12998:  MOVFF  8CE,8DA
1299C:  MOVFF  8CD,8D9
129A0:  MOVFF  8CC,8D8
129A4:  MOVFF  8CB,8D7
129A8:  MOVFF  8D2,8DE
129AC:  MOVFF  8D1,8DD
129B0:  MOVFF  8D0,8DC
129B4:  MOVFF  8CF,8DB
129B8:  CALL   C658
129BC:  MOVFF  03,8DA
129C0:  MOVFF  02,8D9
129C4:  MOVFF  01,8D8
129C8:  MOVFF  00,8D7
129CC:  MOVFF  03,8DE
129D0:  MOVFF  02,8DD
129D4:  MOVFF  01,8DC
129D8:  MOVFF  00,8DB
129DC:  BRA    128BA
129DE:  MOVFF  03,8D6
129E2:  MOVFF  02,8D5
129E6:  MOVFF  01,8D4
129EA:  MOVFF  00,8D3
....................       return(x-(i*y)); 
129EE:  MOVFF  8D6,8F2
129F2:  MOVFF  8D5,8F1
129F6:  MOVFF  8D4,8F0
129FA:  MOVFF  8D3,8EF
129FE:  MOVFF  8D2,8F6
12A02:  MOVFF  8D1,8F5
12A06:  MOVFF  8D0,8F4
12A0A:  MOVFF  8CF,8F3
12A0E:  CALL   BF40
12A12:  BSF    FD8.1
12A14:  MOVFF  8CE,8F6
12A18:  MOVFF  8CD,8F5
12A1C:  MOVFF  8CC,8F4
12A20:  MOVFF  8CB,8F3
12A24:  MOVFF  03,8FA
12A28:  MOVFF  02,8F9
12A2C:  MOVFF  01,8F8
12A30:  MOVFF  00,8F7
12A34:  CALL   C036
12A38:  BRA    12A3A
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12A3A:  GOTO   12CD2 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
1052A:  MOVFF  8B6,8BA
1052E:  MOVFF  8B5,8B9
10532:  MOVFF  8B4,8B8
10536:  MOVFF  8B3,8B7
....................  
....................    if (y != 1.0) 
1053A:  MOVFF  8BA,8F2
1053E:  MOVFF  8B9,8F1
10542:  MOVFF  8B8,8F0
10546:  MOVFF  8B7,8EF
1054A:  MOVLB  8
1054C:  CLRF   xF6
1054E:  CLRF   xF5
10550:  CLRF   xF4
10552:  MOVLW  7F
10554:  MOVWF  xF3
10556:  MOVLB  0
10558:  RCALL  10460
1055A:  BTFSC  FD8.2
1055C:  BRA    1089A
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
1055E:  MOVLW  08
10560:  MOVLB  8
10562:  MOVWF  xC9
10564:  MOVLW  B7
10566:  MOVWF  FE9
10568:  MOVFF  8C9,FEA
1056C:  MOVLW  7E
1056E:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
10570:  BSF    FD8.1
10572:  MOVFF  8BA,8F6
10576:  MOVFF  8B9,8F5
1057A:  MOVFF  8B8,8F4
1057E:  MOVFF  8B7,8F3
10582:  CLRF   xFA
10584:  CLRF   xF9
10586:  CLRF   xF8
10588:  MOVLW  7F
1058A:  MOVWF  xF7
1058C:  MOVLB  0
1058E:  CALL   C036
10592:  MOVFF  03,8CB
10596:  MOVFF  02,8CA
1059A:  MOVFF  01,8C9
1059E:  MOVFF  00,8C8
105A2:  BCF    FD8.1
105A4:  MOVFF  8BA,8F6
105A8:  MOVFF  8B9,8F5
105AC:  MOVFF  8B8,8F4
105B0:  MOVFF  8B7,8F3
105B4:  MOVLB  8
105B6:  CLRF   xFA
105B8:  CLRF   xF9
105BA:  CLRF   xF8
105BC:  MOVLW  7F
105BE:  MOVWF  xF7
105C0:  MOVLB  0
105C2:  CALL   C036
105C6:  MOVFF  8CB,8DA
105CA:  MOVFF  8CA,8D9
105CE:  MOVFF  8C9,8D8
105D2:  MOVFF  8C8,8D7
105D6:  MOVFF  03,8DE
105DA:  MOVFF  02,8DD
105DE:  MOVFF  01,8DC
105E2:  MOVFF  00,8DB
105E6:  CALL   C658
105EA:  MOVFF  03,8BA
105EE:  MOVFF  02,8B9
105F2:  MOVFF  01,8B8
105F6:  MOVFF  00,8B7
....................  
....................       y2=y*y; 
105FA:  MOVFF  8BA,8F2
105FE:  MOVFF  8B9,8F1
10602:  MOVFF  8B8,8F0
10606:  MOVFF  8B7,8EF
1060A:  MOVFF  8BA,8F6
1060E:  MOVFF  8B9,8F5
10612:  MOVFF  8B8,8F4
10616:  MOVFF  8B7,8F3
1061A:  CALL   BF40
1061E:  MOVFF  03,8C6
10622:  MOVFF  02,8C5
10626:  MOVFF  01,8C4
1062A:  MOVFF  00,8C3
....................  
....................       res = pl[0]*y2 + pl[1]; 
1062E:  MOVLW  99
10630:  MOVLB  8
10632:  MOVWF  xF2
10634:  MOVLW  47
10636:  MOVWF  xF1
10638:  MOVLW  8A
1063A:  MOVWF  xF0
1063C:  MOVLW  7F
1063E:  MOVWF  xEF
10640:  MOVFF  8C6,8F6
10644:  MOVFF  8C5,8F5
10648:  MOVFF  8C4,8F4
1064C:  MOVFF  8C3,8F3
10650:  MOVLB  0
10652:  CALL   BF40
10656:  MOVFF  03,8CB
1065A:  MOVFF  02,8CA
1065E:  MOVFF  01,8C9
10662:  MOVFF  00,8C8
10666:  BCF    FD8.1
10668:  MOVFF  03,8F6
1066C:  MOVFF  02,8F5
10670:  MOVFF  01,8F4
10674:  MOVFF  00,8F3
10678:  MOVLB  8
1067A:  CLRF   xFA
1067C:  CLRF   xF9
1067E:  CLRF   xF8
10680:  MOVLW  80
10682:  MOVWF  xF7
10684:  MOVLB  0
10686:  CALL   C036
1068A:  MOVFF  03,8BE
1068E:  MOVFF  02,8BD
10692:  MOVFF  01,8BC
10696:  MOVFF  00,8BB
....................  
....................       r = ql[0]*y2 + ql[1]; 
1069A:  MOVLW  4C
1069C:  MOVLB  8
1069E:  MOVWF  xF2
106A0:  MOVLW  F3
106A2:  MOVWF  xF1
106A4:  MOVLW  3A
106A6:  MOVWF  xF0
106A8:  MOVLW  7B
106AA:  MOVWF  xEF
106AC:  MOVFF  8C6,8F6
106B0:  MOVFF  8C5,8F5
106B4:  MOVFF  8C4,8F4
106B8:  MOVFF  8C3,8F3
106BC:  MOVLB  0
106BE:  CALL   BF40
106C2:  MOVFF  03,8CB
106C6:  MOVFF  02,8CA
106CA:  MOVFF  01,8C9
106CE:  MOVFF  00,8C8
106D2:  BCF    FD8.1
106D4:  MOVFF  03,8F6
106D8:  MOVFF  02,8F5
106DC:  MOVFF  01,8F4
106E0:  MOVFF  00,8F3
106E4:  MOVLW  2B
106E6:  MOVLB  8
106E8:  MOVWF  xFA
106EA:  MOVLW  9D
106EC:  MOVWF  xF9
106EE:  MOVLW  DF
106F0:  MOVWF  xF8
106F2:  MOVLW  7E
106F4:  MOVWF  xF7
106F6:  MOVLB  0
106F8:  CALL   C036
106FC:  MOVFF  03,8C2
10700:  MOVFF  02,8C1
10704:  MOVFF  01,8C0
10708:  MOVFF  00,8BF
....................       r = r*y2 + 1.0; 
1070C:  MOVFF  8C2,8F2
10710:  MOVFF  8C1,8F1
10714:  MOVFF  8C0,8F0
10718:  MOVFF  8BF,8EF
1071C:  MOVFF  8C6,8F6
10720:  MOVFF  8C5,8F5
10724:  MOVFF  8C4,8F4
10728:  MOVFF  8C3,8F3
1072C:  CALL   BF40
10730:  MOVFF  03,8CB
10734:  MOVFF  02,8CA
10738:  MOVFF  01,8C9
1073C:  MOVFF  00,8C8
10740:  BCF    FD8.1
10742:  MOVFF  03,8F6
10746:  MOVFF  02,8F5
1074A:  MOVFF  01,8F4
1074E:  MOVFF  00,8F3
10752:  MOVLB  8
10754:  CLRF   xFA
10756:  CLRF   xF9
10758:  CLRF   xF8
1075A:  MOVLW  7F
1075C:  MOVWF  xF7
1075E:  MOVLB  0
10760:  CALL   C036
10764:  MOVFF  03,8C2
10768:  MOVFF  02,8C1
1076C:  MOVFF  01,8C0
10770:  MOVFF  00,8BF
....................  
....................       res = y*res/r; 
10774:  MOVFF  8BA,8F2
10778:  MOVFF  8B9,8F1
1077C:  MOVFF  8B8,8F0
10780:  MOVFF  8B7,8EF
10784:  MOVFF  8BE,8F6
10788:  MOVFF  8BD,8F5
1078C:  MOVFF  8BC,8F4
10790:  MOVFF  8BB,8F3
10794:  CALL   BF40
10798:  MOVFF  03,8CB
1079C:  MOVFF  02,8CA
107A0:  MOVFF  01,8C9
107A4:  MOVFF  00,8C8
107A8:  MOVFF  03,8DA
107AC:  MOVFF  02,8D9
107B0:  MOVFF  01,8D8
107B4:  MOVFF  00,8D7
107B8:  MOVFF  8C2,8DE
107BC:  MOVFF  8C1,8DD
107C0:  MOVFF  8C0,8DC
107C4:  MOVFF  8BF,8DB
107C8:  CALL   C658
107CC:  MOVFF  03,8BE
107D0:  MOVFF  02,8BD
107D4:  MOVFF  01,8BC
107D8:  MOVFF  00,8BB
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
107DC:  MOVLW  08
107DE:  MOVLB  8
107E0:  MOVWF  xC9
107E2:  MOVLW  B3
107E4:  MOVWF  FE9
107E6:  MOVFF  8C9,FEA
107EA:  MOVLW  7E
107EC:  SUBWF  FEF,W
107EE:  MOVWF  xC7
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
107F0:  BTFSS  xC7.7
107F2:  BRA    1081C
....................          r = -(float32)-n; 
107F4:  MOVLW  00
107F6:  BSF    FD8.0
107F8:  SUBFWB xC7,W
107FA:  CLRF   xC9
107FC:  MOVWF  xC8
107FE:  BTFSC  xC8.7
10800:  DECF   xC9,F
10802:  MOVLB  0
10804:  RCALL  104DA
10806:  MOVFF  00,8BF
1080A:  MOVF   01,W
1080C:  XORLW  80
1080E:  MOVLB  8
10810:  MOVWF  xC0
10812:  MOVFF  02,8C1
10816:  MOVFF  03,8C2
1081A:  BRA    1083C
....................       else 
....................          r = (float32)n; 
1081C:  CLRF   xC9
1081E:  MOVFF  8C7,8C8
10822:  BTFSC  xC8.7
10824:  DECF   xC9,F
10826:  MOVLB  0
10828:  RCALL  104DA
1082A:  MOVFF  03,8C2
1082E:  MOVFF  02,8C1
10832:  MOVFF  01,8C0
10836:  MOVFF  00,8BF
1083A:  MOVLB  8
....................  
....................       res += r*LN2; 
1083C:  MOVFF  8C2,8F2
10840:  MOVFF  8C1,8F1
10844:  MOVFF  8C0,8F0
10848:  MOVFF  8BF,8EF
1084C:  MOVLW  18
1084E:  MOVWF  xF6
10850:  MOVLW  72
10852:  MOVWF  xF5
10854:  MOVLW  31
10856:  MOVWF  xF4
10858:  MOVLW  7E
1085A:  MOVWF  xF3
1085C:  MOVLB  0
1085E:  CALL   BF40
10862:  BCF    FD8.1
10864:  MOVFF  8BE,8F6
10868:  MOVFF  8BD,8F5
1086C:  MOVFF  8BC,8F4
10870:  MOVFF  8BB,8F3
10874:  MOVFF  03,8FA
10878:  MOVFF  02,8F9
1087C:  MOVFF  01,8F8
10880:  MOVFF  00,8F7
10884:  CALL   C036
10888:  MOVFF  03,8BE
1088C:  MOVFF  02,8BD
10890:  MOVFF  01,8BC
10894:  MOVFF  00,8BB
....................    } 
10898:  BRA    108A6
....................  
....................    else 
....................       res = 0.0; 
1089A:  MOVLB  8
1089C:  CLRF   xBE
1089E:  CLRF   xBD
108A0:  CLRF   xBC
108A2:  CLRF   xBB
108A4:  MOVLB  0
....................  
....................    return(res); 
108A6:  MOVFF  8BB,00
108AA:  MOVFF  8BC,01
108AE:  MOVFF  8BD,02
108B2:  MOVFF  8BE,03
108B6:  GOTO   108CC (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
108BA:  MOVFF  8AE,8B6
108BE:  MOVFF  8AD,8B5
108C2:  MOVFF  8AC,8B4
108C6:  MOVFF  8AB,8B3
108CA:  BRA    1052A
108CC:  MOVFF  03,8B2
108D0:  MOVFF  02,8B1
108D4:  MOVFF  01,8B0
108D8:  MOVFF  00,8AF
....................    r = r*LN10_INV; 
108DC:  MOVFF  8B2,8F2
108E0:  MOVFF  8B1,8F1
108E4:  MOVFF  8B0,8F0
108E8:  MOVFF  8AF,8EF
108EC:  MOVLW  D9
108EE:  MOVLB  8
108F0:  MOVWF  xF6
108F2:  MOVLW  5B
108F4:  MOVWF  xF5
108F6:  MOVLW  5E
108F8:  MOVWF  xF4
108FA:  MOVLW  7D
108FC:  MOVWF  xF3
108FE:  MOVLB  0
10900:  CALL   BF40
10904:  MOVFF  03,8B2
10908:  MOVFF  02,8B1
1090C:  MOVFF  01,8B0
10910:  MOVFF  00,8AF
....................    return(r); 
10914:  MOVFF  8AF,00
10918:  MOVFF  8B0,01
1091C:  MOVFF  8B1,02
10920:  MOVFF  8B2,03
10924:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
0FFE4:  BCF    FC6.5
0FFE6:  MOVLW  21
0FFE8:  MOVWF  FC6
0FFEA:  MOVLW  40
0FFEC:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
0FFEE:  BSF    F91.2
....................    output_high(EEP_WP); 
0FFF0:  BSF    F91.3
0FFF2:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
*
102C8:  BCF    F91.2
....................    spi_write(0x05);  
102CA:  MOVF   FC9,W
102CC:  MOVLW  05
102CE:  MOVWF  FC9
102D0:  RRCF   FC7,W
102D2:  BNC   102D0
....................    data = spi_read(0);  
102D4:  MOVF   FC9,W
102D6:  CLRF   FC9
102D8:  RRCF   FC7,W
102DA:  BNC   102D8
102DC:  MOVFF  FC9,8AA
....................    output_high(EEP_CS);  
102E0:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
102E2:  MOVLW  00
102E4:  MOVLB  8
102E6:  BTFSS  xAA.0
102E8:  MOVLW  01
102EA:  MOVWF  01
102EC:  MOVLB  0
102EE:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
17B10:  MOVLB  8
17B12:  CLRF   xC9
17B14:  MOVLB  0
17B16:  CALL   5500
....................       while(!ext_eeprom_ready()); 
17B1A:  CALL   102C8
17B1E:  MOVF   01,F
17B20:  BZ    17B1A
....................     
....................       output_low(EEP_CS);  
17B22:  BCF    F91.2
....................       spi_write(0x06);  
17B24:  MOVF   FC9,W
17B26:  MOVLW  06
17B28:  MOVWF  FC9
17B2A:  RRCF   FC7,W
17B2C:  BNC   17B2A
....................       output_high(EEP_CS);  
17B2E:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
17B30:  BCF    F91.2
....................       spi_write(0x02);  
17B32:  MOVF   FC9,W
17B34:  MOVLW  02
17B36:  MOVWF  FC9
17B38:  RRCF   FC7,W
17B3A:  BNC   17B38
....................       spi_write(address >> 8);  
17B3C:  MOVFF  884,886
17B40:  MOVLB  8
17B42:  CLRF   x87
17B44:  MOVF   FC9,W
17B46:  MOVFF  884,FC9
17B4A:  RRCF   FC7,W
17B4C:  BNC   17B4A
....................       spi_write(address);  
17B4E:  MOVF   FC9,W
17B50:  MOVFF  883,FC9
17B54:  RRCF   FC7,W
17B56:  BNC   17B54
....................       spi_write(data);  
17B58:  MOVF   FC9,W
17B5A:  MOVFF  885,FC9
17B5E:  RRCF   FC7,W
17B60:  BNC   17B5E
....................       output_high(EEP_CS);  
17B62:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
17B64:  MOVLW  01
17B66:  MOVWF  xC9
17B68:  MOVLB  0
17B6A:  CALL   5500
17B6E:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
102F0:  MOVLB  8
102F2:  CLRF   xC9
102F4:  MOVLB  0
102F6:  CALL   5500
....................     
....................       while(!ext_eeprom_ready()); 
102FA:  RCALL  102C8
102FC:  MOVF   01,F
102FE:  BZ    102FA
....................        
....................       output_low(EEP_CS);  
10300:  BCF    F91.2
....................       spi_write(0x03);  
10302:  MOVF   FC9,W
10304:  MOVLW  03
10306:  MOVWF  FC9
10308:  RRCF   FC7,W
1030A:  BNC   10308
....................       spi_write(address >> 8);  
1030C:  MOVFF  8A8,8AA
10310:  MOVLB  8
10312:  CLRF   xAB
10314:  MOVF   FC9,W
10316:  MOVFF  8A8,FC9
1031A:  RRCF   FC7,W
1031C:  BNC   1031A
....................       spi_write(address);  
1031E:  MOVF   FC9,W
10320:  MOVFF  8A7,FC9
10324:  RRCF   FC7,W
10326:  BNC   10324
....................        
....................       data = spi_read(0);  
10328:  MOVF   FC9,W
1032A:  CLRF   FC9
1032C:  RRCF   FC7,W
1032E:  BNC   1032C
10330:  MOVFF  FC9,8A9
....................       output_high(EEP_CS);  
10334:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
10336:  MOVLW  01
10338:  MOVWF  xC9
1033A:  MOVLB  0
1033C:  CALL   5500
....................     
....................    return(data);  
10340:  MOVLB  8
10342:  MOVFF  8A9,01
10346:  MOVLB  0
10348:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
03390:  MOVF   FF2,W
03392:  MOVWF  00
03394:  BCF    FF2.7
03396:  CLRF   F63
03398:  MOVFF  865,F62
0339C:  MOVFF  866,F61
033A0:  BCF    F7F.6
033A2:  BCF    F7F.7
033A4:  BSF    F7F.2
033A6:  MOVLB  F
033A8:  MOVLW  55
033AA:  MOVWF  F7E
033AC:  MOVLW  AA
033AE:  MOVWF  F7E
033B0:  BSF    F7F.1
033B2:  BTFSC  F7F.1
033B4:  BRA    33B2
033B6:  BCF    F7F.2
033B8:  MOVF   00,W
033BA:  IORWF  FF2,F
033BC:  MOVLB  0
033BE:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
029A2:  MOVLB  8
029A4:  CLRF   x94
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
029A6:  MOVFF  FF2,895
029AA:  BCF    FF2.7
029AC:  CLRF   F63
029AE:  MOVFF  893,F62
029B2:  BCF    F7F.6
029B4:  BCF    F7F.7
029B6:  BSF    F7F.0
029B8:  MOVF   F61,W
029BA:  BTFSC  x95.7
029BC:  BSF    FF2.7
029BE:  MOVWF  x94
....................    return(data); 
029C0:  MOVFF  894,01
029C4:  MOVLB  0
029C6:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04F52:  MOVLB  8
04F54:  CLRF   xCD
04F56:  MOVF   xCD,W
04F58:  SUBLW  01
04F5A:  BNC   4FB4
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
04F5C:  MOVF   xCA,W
04F5E:  ADDWF  xCD,W
04F60:  MOVWF  xCE
04F62:  MOVLW  08
04F64:  MOVWF  xD0
04F66:  MOVLW  CB
04F68:  MOVWF  xCF
04F6A:  MOVF   xCD,W
04F6C:  ADDWF  xCF,W
04F6E:  MOVWF  01
04F70:  MOVLW  00
04F72:  ADDWFC xD0,W
04F74:  MOVWF  03
04F76:  MOVF   01,W
04F78:  MOVWF  FE9
04F7A:  MOVFF  03,FEA
04F7E:  MOVFF  FEF,8CF
04F82:  MOVF   FF2,W
04F84:  MOVWF  00
04F86:  BCF    FF2.7
04F88:  CLRF   F63
04F8A:  MOVFF  8CE,F62
04F8E:  MOVFF  8CF,F61
04F92:  BCF    F7F.6
04F94:  BCF    F7F.7
04F96:  BSF    F7F.2
04F98:  MOVLB  F
04F9A:  MOVLW  55
04F9C:  MOVWF  F7E
04F9E:  MOVLW  AA
04FA0:  MOVWF  F7E
04FA2:  BSF    F7F.1
04FA4:  BTFSC  F7F.1
04FA6:  BRA    4FA4
04FA8:  BCF    F7F.2
04FAA:  MOVF   00,W
04FAC:  IORWF  FF2,F
04FAE:  MOVLB  8
04FB0:  INCF   xCD,F
04FB2:  BRA    4F56
....................     }  
04FB4:  MOVLB  0
04FB6:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
02948:  MOVLB  8
0294A:  CLRF   x76
0294C:  CLRF   x75
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
0294E:  CLRF   x74
02950:  MOVF   x74,W
02952:  SUBLW  01
02954:  BNC   2996
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02956:  MOVLW  08
02958:  MOVWF  x78
0295A:  MOVLW  75
0295C:  MOVWF  x77
0295E:  MOVF   x74,W
02960:  ADDWF  x77,W
02962:  MOVWF  01
02964:  MOVLW  00
02966:  ADDWFC x78,W
02968:  MOVWF  03
0296A:  MOVF   01,W
0296C:  MOVWF  FE9
0296E:  MOVFF  03,FEA
02972:  MOVF   x73,W
02974:  ADDWF  x74,W
02976:  MOVWF  x79
02978:  MOVFF  FF2,87A
0297C:  BCF    FF2.7
0297E:  CLRF   F63
02980:  MOVFF  879,F62
02984:  BCF    F7F.6
02986:  BCF    F7F.7
02988:  BSF    F7F.0
0298A:  MOVF   F61,W
0298C:  BTFSC  x7A.7
0298E:  BSF    FF2.7
02990:  MOVWF  FEF
02992:  INCF   x74,F
02994:  BRA    2950
....................    } 
....................  
....................    return(data);  
02996:  MOVFF  875,01
0299A:  MOVFF  876,02
0299E:  MOVLB  0
029A0:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CA52:  MOVLB  8
0CA54:  CLRF   x67
0CA56:  MOVF   x67,W
0CA58:  SUBLW  03
0CA5A:  BNC   CABC
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CA5C:  MOVF   x67,W
0CA5E:  ADDWF  x61,W
0CA60:  MOVWF  x68
0CA62:  MOVLW  00
0CA64:  ADDWFC x62,W
0CA66:  MOVWF  x69
0CA68:  MOVLW  08
0CA6A:  MOVWF  x6B
0CA6C:  MOVLW  63
0CA6E:  MOVWF  x6A
0CA70:  MOVF   x67,W
0CA72:  ADDWF  x6A,W
0CA74:  MOVWF  01
0CA76:  MOVLW  00
0CA78:  ADDWFC x6B,W
0CA7A:  MOVWF  03
0CA7C:  MOVF   01,W
0CA7E:  MOVWF  FE9
0CA80:  MOVFF  03,FEA
0CA84:  MOVFF  FEF,86A
0CA88:  MOVF   FF2,W
0CA8A:  MOVWF  00
0CA8C:  BCF    FF2.7
0CA8E:  MOVFF  869,F63
0CA92:  MOVFF  868,F62
0CA96:  MOVFF  86A,F61
0CA9A:  BCF    F7F.6
0CA9C:  BCF    F7F.7
0CA9E:  BSF    F7F.2
0CAA0:  MOVLB  F
0CAA2:  MOVLW  55
0CAA4:  MOVWF  F7E
0CAA6:  MOVLW  AA
0CAA8:  MOVWF  F7E
0CAAA:  BSF    F7F.1
0CAAC:  BTFSC  F7F.1
0CAAE:  BRA    CAAC
0CAB0:  BCF    F7F.2
0CAB2:  MOVF   00,W
0CAB4:  IORWF  FF2,F
0CAB6:  MOVLB  8
0CAB8:  INCF   x67,F
0CABA:  BRA    CA56
....................    } 
0CABC:  MOVLB  0
0CABE:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
029C8:  MOVLB  8
029CA:  CLRF   x67
029CC:  CLRF   x66
029CE:  CLRF   x65
029D0:  CLRF   x64
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
029D2:  CLRF   x63
029D4:  MOVF   x63,W
029D6:  SUBLW  03
029D8:  BNC   2A22
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
029DA:  MOVLW  08
029DC:  MOVWF  x69
029DE:  MOVLW  64
029E0:  MOVWF  x68
029E2:  MOVF   x63,W
029E4:  ADDWF  x68,W
029E6:  MOVWF  01
029E8:  MOVLW  00
029EA:  ADDWFC x69,W
029EC:  MOVWF  03
029EE:  MOVF   01,W
029F0:  MOVWF  FE9
029F2:  MOVFF  03,FEA
029F6:  MOVF   x63,W
029F8:  ADDWF  x61,W
029FA:  MOVWF  x6A
029FC:  MOVLW  00
029FE:  ADDWFC x62,W
02A00:  MOVWF  x6B
02A02:  MOVFF  FF2,86C
02A06:  BCF    FF2.7
02A08:  MOVFF  86B,F63
02A0C:  MOVFF  86A,F62
02A10:  BCF    F7F.6
02A12:  BCF    F7F.7
02A14:  BSF    F7F.0
02A16:  MOVF   F61,W
02A18:  BTFSC  x6C.7
02A1A:  BSF    FF2.7
02A1C:  MOVWF  FEF
02A1E:  INCF   x63,F
02A20:  BRA    29D4
....................    } 
....................  
....................    return(data);  
02A22:  MOVFF  864,00
02A26:  MOVFF  865,01
02A2A:  MOVFF  866,02
02A2E:  MOVFF  867,03
02A32:  MOVLB  0
02A34:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
17D50:  MOVLB  8
17D52:  CLRF   x7F
17D54:  MOVF   x7F,W
17D56:  SUBLW  01
17D58:  BNC   17D96
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
17D5A:  MOVF   x7F,W
17D5C:  ADDWF  x7B,W
17D5E:  MOVWF  x80
17D60:  MOVLW  00
17D62:  ADDWFC x7C,W
17D64:  MOVWF  x81
17D66:  MOVLW  08
17D68:  MOVWF  x83
17D6A:  MOVLW  7D
17D6C:  MOVWF  x82
17D6E:  MOVF   x7F,W
17D70:  ADDWF  x82,W
17D72:  MOVWF  01
17D74:  MOVLW  00
17D76:  ADDWFC x83,W
17D78:  MOVWF  03
17D7A:  MOVFF  01,FE9
17D7E:  MOVWF  FEA
17D80:  MOVFF  FEF,885
17D84:  MOVFF  881,884
17D88:  MOVFF  880,883
17D8C:  MOVLB  0
17D8E:  RCALL  17B10
17D90:  MOVLB  8
17D92:  INCF   x7F,F
17D94:  BRA    17D54
....................     }  
17D96:  MOVLB  0
17D98:  GOTO   17E08 (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
10404:  MOVLB  8
10406:  CLRF   xA2
10408:  CLRF   xA1
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
1040A:  CLRF   xA0
1040C:  MOVF   xA0,W
1040E:  SUBLW  01
10410:  BNC   10454
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
10412:  MOVLW  08
10414:  MOVWF  xA4
10416:  MOVLW  A1
10418:  MOVWF  xA3
1041A:  MOVF   xA0,W
1041C:  ADDWF  xA3,W
1041E:  MOVWF  01
10420:  MOVLW  00
10422:  ADDWFC xA4,W
10424:  MOVWF  03
10426:  MOVFF  01,8A3
1042A:  MOVWF  xA4
1042C:  MOVF   xA0,W
1042E:  ADDWF  x9E,W
10430:  MOVWF  xA5
10432:  MOVLW  00
10434:  ADDWFC x9F,W
10436:  MOVWF  xA6
10438:  MOVWF  xA8
1043A:  MOVFF  8A5,8A7
1043E:  MOVLB  0
10440:  RCALL  102F0
10442:  MOVFF  8A4,FEA
10446:  MOVFF  8A3,FE9
1044A:  MOVFF  01,FEF
1044E:  MOVLB  8
10450:  INCF   xA0,F
10452:  BRA    1040C
....................    } 
....................    return(data);  
10454:  MOVFF  8A1,01
10458:  MOVFF  8A2,02
1045C:  MOVLB  0
1045E:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
15836:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
15838:  MOVF   2F,W
1583A:  SUBLW  02
1583C:  BNZ   15844
1583E:  MOVF   30,F
15840:  BNZ   15844
15842:  BSF    F90.6
....................    delay_ms(32); 
15844:  MOVLW  20
15846:  MOVLB  9
15848:  MOVWF  xC8
1584A:  MOVLB  0
1584C:  CALL   288E
....................    output_bit(BOARD_LED, OFF); 
15850:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15852:  MOVF   2F,W
15854:  SUBLW  02
15856:  BNZ   1585E
15858:  MOVF   30,F
1585A:  BNZ   1585E
1585C:  BCF    F90.6
....................    delay_ms(32); 
1585E:  MOVLW  20
15860:  MOVLB  9
15862:  MOVWF  xC8
15864:  MOVLB  0
15866:  CALL   288E
1586A:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
030C6:  MOVF   2F,W
030C8:  MOVWF  00
030CA:  MOVF   30,W
030CC:  MOVWF  03
030CE:  BNZ   30D4
030D0:  MOVF   00,F
030D2:  BZ    30F6
030D4:  MOVF   03,W
030D6:  BNZ   30DE
030D8:  MOVLW  01
030DA:  SUBWF  00,W
030DC:  BZ    3148
030DE:  MOVF   03,W
030E0:  BNZ   30E8
030E2:  MOVLW  02
030E4:  SUBWF  00,W
030E6:  BZ    319A
030E8:  MOVF   03,W
030EA:  BNZ   30F4
030EC:  MOVLW  03
030EE:  SUBWF  00,W
030F0:  BTFSC  FD8.2
030F2:  BRA    31EC
030F4:  BRA    323E
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
030F6:  MOVLW  BE
030F8:  MOVWF  FF6
030FA:  MOVLW  05
030FC:  MOVWF  FF7
030FE:  MOVLW  00
03100:  MOVWF  FF8
03102:  CLRF   1B
03104:  BTFSC  FF2.7
03106:  BSF    1B.7
03108:  BCF    FF2.7
0310A:  MOVLW  06
0310C:  MOVLB  A
0310E:  MOVWF  x18
03110:  MOVLB  0
03112:  CALL   1006
03116:  BTFSC  1B.7
03118:  BSF    FF2.7
0311A:  MOVLW  CA
0311C:  MOVWF  FF6
0311E:  MOVLW  05
03120:  MOVWF  FF7
03122:  MOVLW  00
03124:  MOVWF  FF8
03126:  CLRF   1B
03128:  BTFSC  FF2.7
0312A:  BSF    1B.7
0312C:  BCF    FF2.7
0312E:  CALL   0E30
03132:  BTFSC  1B.7
03134:  BSF    FF2.7
03136:  MOVLW  0D
03138:  BTFSS  F9E.4
0313A:  BRA    3138
0313C:  MOVWF  FAD
0313E:  MOVLW  0A
03140:  BTFSS  F9E.4
03142:  BRA    3140
03144:  MOVWF  FAD
....................          break; 
03146:  BRA    328E
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
03148:  MOVLW  D2
0314A:  MOVWF  FF6
0314C:  MOVLW  05
0314E:  MOVWF  FF7
03150:  MOVLW  00
03152:  MOVWF  FF8
03154:  CLRF   1B
03156:  BTFSC  FF2.7
03158:  BSF    1B.7
0315A:  BCF    FF2.7
0315C:  MOVLW  09
0315E:  MOVLB  A
03160:  MOVWF  x18
03162:  MOVLB  0
03164:  CALL   1006
03168:  BTFSC  1B.7
0316A:  BSF    FF2.7
0316C:  MOVLW  E0
0316E:  MOVWF  FF6
03170:  MOVLW  05
03172:  MOVWF  FF7
03174:  MOVLW  00
03176:  MOVWF  FF8
03178:  CLRF   1B
0317A:  BTFSC  FF2.7
0317C:  BSF    1B.7
0317E:  BCF    FF2.7
03180:  CALL   0E30
03184:  BTFSC  1B.7
03186:  BSF    FF2.7
03188:  MOVLW  0D
0318A:  BTFSS  F9E.4
0318C:  BRA    318A
0318E:  MOVWF  FAD
03190:  MOVLW  0A
03192:  BTFSS  F9E.4
03194:  BRA    3192
03196:  MOVWF  FAD
....................          break;  
03198:  BRA    328E
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
0319A:  MOVLW  E8
0319C:  MOVWF  FF6
0319E:  MOVLW  05
031A0:  MOVWF  FF7
031A2:  MOVLW  00
031A4:  MOVWF  FF8
031A6:  CLRF   1B
031A8:  BTFSC  FF2.7
031AA:  BSF    1B.7
031AC:  BCF    FF2.7
031AE:  MOVLW  06
031B0:  MOVLB  A
031B2:  MOVWF  x18
031B4:  MOVLB  0
031B6:  CALL   1006
031BA:  BTFSC  1B.7
031BC:  BSF    FF2.7
031BE:  MOVLW  F4
031C0:  MOVWF  FF6
031C2:  MOVLW  05
031C4:  MOVWF  FF7
031C6:  MOVLW  00
031C8:  MOVWF  FF8
031CA:  CLRF   1B
031CC:  BTFSC  FF2.7
031CE:  BSF    1B.7
031D0:  BCF    FF2.7
031D2:  CALL   0E30
031D6:  BTFSC  1B.7
031D8:  BSF    FF2.7
031DA:  MOVLW  0D
031DC:  BTFSS  F9E.4
031DE:  BRA    31DC
031E0:  MOVWF  FAD
031E2:  MOVLW  0A
031E4:  BTFSS  F9E.4
031E6:  BRA    31E4
031E8:  MOVWF  FAD
....................          break; 
031EA:  BRA    328E
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
031EC:  MOVLW  FC
031EE:  MOVWF  FF6
031F0:  MOVLW  05
031F2:  MOVWF  FF7
031F4:  MOVLW  00
031F6:  MOVWF  FF8
031F8:  CLRF   1B
031FA:  BTFSC  FF2.7
031FC:  BSF    1B.7
031FE:  BCF    FF2.7
03200:  MOVLW  09
03202:  MOVLB  A
03204:  MOVWF  x18
03206:  MOVLB  0
03208:  CALL   1006
0320C:  BTFSC  1B.7
0320E:  BSF    FF2.7
03210:  MOVLW  0A
03212:  MOVWF  FF6
03214:  MOVLW  06
03216:  MOVWF  FF7
03218:  MOVLW  00
0321A:  MOVWF  FF8
0321C:  CLRF   1B
0321E:  BTFSC  FF2.7
03220:  BSF    1B.7
03222:  BCF    FF2.7
03224:  CALL   0E30
03228:  BTFSC  1B.7
0322A:  BSF    FF2.7
0322C:  MOVLW  0D
0322E:  BTFSS  F9E.4
03230:  BRA    322E
03232:  MOVWF  FAD
03234:  MOVLW  0A
03236:  BTFSS  F9E.4
03238:  BRA    3236
0323A:  MOVWF  FAD
....................          break;           
0323C:  BRA    328E
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
0323E:  MOVLW  12
03240:  MOVWF  FF6
03242:  MOVLW  06
03244:  MOVWF  FF7
03246:  MOVLW  00
03248:  MOVWF  FF8
0324A:  CLRF   1B
0324C:  BTFSC  FF2.7
0324E:  BSF    1B.7
03250:  BCF    FF2.7
03252:  MOVLW  06
03254:  MOVLB  A
03256:  MOVWF  x18
03258:  MOVLB  0
0325A:  CALL   1006
0325E:  BTFSC  1B.7
03260:  BSF    FF2.7
03262:  MOVLW  1E
03264:  MOVWF  FF6
03266:  MOVLW  06
03268:  MOVWF  FF7
0326A:  MOVLW  00
0326C:  MOVWF  FF8
0326E:  CLRF   1B
03270:  BTFSC  FF2.7
03272:  BSF    1B.7
03274:  BCF    FF2.7
03276:  CALL   0E30
0327A:  BTFSC  1B.7
0327C:  BSF    FF2.7
0327E:  MOVLW  0D
03280:  BTFSS  F9E.4
03282:  BRA    3280
03284:  MOVWF  FAD
03286:  MOVLW  0A
03288:  BTFSS  F9E.4
0328A:  BRA    3288
0328C:  MOVWF  FAD
....................          break; 
....................    } 
0328E:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
17206:  MOVLW  26
17208:  MOVWF  FF6
1720A:  MOVLW  06
1720C:  MOVWF  FF7
1720E:  MOVLW  00
17210:  MOVWF  FF8
17212:  CLRF   1B
17214:  BTFSC  FF2.7
17216:  BSF    1B.7
17218:  BCF    FF2.7
1721A:  CALL   0E30
1721E:  BTFSC  1B.7
17220:  BSF    FF2.7
17222:  GOTO   175CC (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0AF7A:  MOVLW  2E
0AF7C:  MOVWF  FF6
0AF7E:  MOVLW  06
0AF80:  MOVWF  FF7
0AF82:  MOVLW  00
0AF84:  MOVWF  FF8
0AF86:  CLRF   1B
0AF88:  BTFSC  FF2.7
0AF8A:  BSF    1B.7
0AF8C:  BCF    FF2.7
0AF8E:  CALL   0E30
0AF92:  BTFSC  1B.7
0AF94:  BSF    FF2.7
0AF96:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BC3C:  MOVLW  36
0BC3E:  MOVWF  FF6
0BC40:  MOVLW  06
0BC42:  MOVWF  FF7
0BC44:  MOVLW  00
0BC46:  MOVWF  FF8
0BC48:  CLRF   1B
0BC4A:  BTFSC  FF2.7
0BC4C:  BSF    1B.7
0BC4E:  BCF    FF2.7
0BC50:  CALL   0E30
0BC54:  BTFSC  1B.7
0BC56:  BSF    FF2.7
0BC58:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
035D4:  MOVLW  4E
035D6:  MOVWF  FF6
035D8:  MOVLW  06
035DA:  MOVWF  FF7
035DC:  MOVLW  00
035DE:  MOVWF  FF8
035E0:  CLRF   1B
035E2:  BTFSC  FF2.7
035E4:  BSF    1B.7
035E6:  BCF    FF2.7
035E8:  CALL   0E30
035EC:  BTFSC  1B.7
035EE:  BSF    FF2.7
035F0:  GOTO   4346 (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
04FFE:  MOVLW  56
05000:  MOVWF  FF6
05002:  MOVLW  06
05004:  MOVWF  FF7
05006:  MOVLW  00
05008:  MOVWF  FF8
0500A:  CLRF   1B
0500C:  BTFSC  FF2.7
0500E:  BSF    1B.7
05010:  BCF    FF2.7
05012:  CALL   0E30
05016:  BTFSC  1B.7
05018:  BSF    FF2.7
0501A:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
15D22:  MOVLW  5E
15D24:  MOVWF  FF6
15D26:  MOVLW  06
15D28:  MOVWF  FF7
15D2A:  MOVLW  00
15D2C:  MOVWF  FF8
15D2E:  CLRF   1B
15D30:  BTFSC  FF2.7
15D32:  BSF    1B.7
15D34:  BCF    FF2.7
15D36:  CALL   0E30
15D3A:  BTFSC  1B.7
15D3C:  BSF    FF2.7
15D3E:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
*
0ADC6:  DECFSZ 4A,W
0ADC8:  BRA    ADE8
0ADCA:  MOVLW  66
0ADCC:  MOVWF  FF6
0ADCE:  MOVLW  06
0ADD0:  MOVWF  FF7
0ADD2:  MOVLW  00
0ADD4:  MOVWF  FF8
0ADD6:  CLRF   1B
0ADD8:  BTFSC  FF2.7
0ADDA:  BSF    1B.7
0ADDC:  BCF    FF2.7
0ADDE:  CALL   0E30
0ADE2:  BTFSC  1B.7
0ADE4:  BSF    FF2.7
0ADE6:  BRA    AE04
....................    else fprintf(COM_A, "@RDY\r\n"); 
0ADE8:  MOVLW  6E
0ADEA:  MOVWF  FF6
0ADEC:  MOVLW  06
0ADEE:  MOVWF  FF7
0ADF0:  MOVLW  00
0ADF2:  MOVWF  FF8
0ADF4:  CLRF   1B
0ADF6:  BTFSC  FF2.7
0ADF8:  BSF    1B.7
0ADFA:  BCF    FF2.7
0ADFC:  CALL   0E30
0AE00:  BTFSC  1B.7
0AE02:  BSF    FF2.7
0AE04:  GOTO   1AF0E (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
034BE:  MOVLW  0A
034C0:  MOVLB  A
034C2:  MOVWF  x0D
034C4:  MOVLW  04
034C6:  MOVFF  A0D,A0B
034CA:  MOVWF  x0A
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
034CC:  MOVF   FC9,W
034CE:  SETF   FC9
034D0:  RRCF   FC7,W
034D2:  BNC   34D0
....................    SD_spi_read(sdcmd); 
034D4:  MOVF   FC9,W
034D6:  MOVFF  A03,FC9
034DA:  RRCF   FC7,W
034DC:  BNC   34DA
....................    SD_spi_read(value[3]); 
034DE:  MOVLW  03
034E0:  ADDWF  x0A,W
034E2:  MOVWF  FE9
034E4:  MOVLW  00
034E6:  ADDWFC x0B,W
034E8:  MOVWF  FEA
034EA:  MOVFF  FEF,A0C
034EE:  MOVF   FC9,W
034F0:  MOVFF  A0C,FC9
034F4:  RRCF   FC7,W
034F6:  BNC   34F4
....................    SD_spi_read(value[2]); 
034F8:  MOVLW  02
034FA:  ADDWF  x0A,W
034FC:  MOVWF  FE9
034FE:  MOVLW  00
03500:  ADDWFC x0B,W
03502:  MOVWF  FEA
03504:  MOVFF  FEF,A0C
03508:  MOVF   FC9,W
0350A:  MOVFF  A0C,FC9
0350E:  RRCF   FC7,W
03510:  BNC   350E
....................    SD_spi_read(value[1]); 
03512:  MOVLW  01
03514:  ADDWF  x0A,W
03516:  MOVWF  FE9
03518:  MOVLW  00
0351A:  ADDWFC x0B,W
0351C:  MOVWF  FEA
0351E:  MOVFF  FEF,A0C
03522:  MOVF   FC9,W
03524:  MOVFF  A0C,FC9
03528:  RRCF   FC7,W
0352A:  BNC   3528
....................    SD_spi_read(value[0]); 
0352C:  MOVFF  A0A,FE9
03530:  MOVFF  A0B,FEA
03534:  MOVFF  FEF,A0C
03538:  MOVF   FC9,W
0353A:  MOVFF  A0C,FC9
0353E:  RRCF   FC7,W
03540:  BNC   353E
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
03542:  MOVF   x03,W
03544:  SUBLW  48
03546:  BNZ   3554
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
03548:  MOVF   FC9,W
0354A:  MOVLW  87
0354C:  MOVWF  FC9
0354E:  RRCF   FC7,W
03550:  BNC   354E
03552:  BRA    355E
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
03554:  MOVF   FC9,W
03556:  MOVLW  95
03558:  MOVWF  FC9
0355A:  RRCF   FC7,W
0355C:  BNC   355A
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
0355E:  CLRF   x08
....................    response = SD_spi_read(0xFF); 
03560:  MOVF   FC9,W
03562:  SETF   FC9
03564:  RRCF   FC7,W
03566:  BNC   3564
03568:  MOVFF  FC9,A09
....................    while ((response == 0xFF) && (i < 100)) 
0356C:  INCFSZ x09,W
0356E:  BRA    3586
03570:  MOVF   x08,W
03572:  SUBLW  63
03574:  BNC   3586
....................       { 
....................       i++; 
03576:  INCF   x08,F
....................       response = SD_spi_read(0xFF); 
03578:  MOVF   FC9,W
0357A:  SETF   FC9
0357C:  RRCF   FC7,W
0357E:  BNC   357C
03580:  MOVFF  FC9,A09
03584:  BRA    356C
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
03586:  MOVFF  A09,01
0358A:  MOVLB  0
0358C:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
04352:  MOVLW  50
04354:  MOVLB  A
04356:  MOVWF  x03
04358:  MOVFF  A02,A07
0435C:  MOVFF  A01,A06
04360:  MOVFF  A00,A05
04364:  MOVFF  9FF,A04
04368:  MOVLB  0
0436A:  CALL   34BE
0436E:  MOVF   01,W
04370:  BZ    4378
04372:  XORLW  40
04374:  BZ    438E
04376:  BRA    4394
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
04378:  MOVFF  A02,4E8
0437C:  MOVFF  A01,4E7
04380:  MOVFF  A00,4E6
04384:  MOVFF  9FF,4E5
....................          return(TRUE); 
04388:  MOVLW  01
0438A:  MOVWF  01
0438C:  BRA    4398
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
0438E:  MOVLW  00
04390:  MOVWF  01
04392:  BRA    4398
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
04394:  MOVLW  00
04396:  MOVWF  01
....................       } 
04398:  GOTO   4484 (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
0439C:  MOVF   FC9,W
0439E:  SETF   FC9
043A0:  RRCF   FC7,W
043A2:  BNC   43A0
043A4:  MOVFF  FC9,A07
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
043A8:  MOVLB  A
043AA:  CLRF   x06
043AC:  CLRF   x05
043AE:  MOVF   x06,W
043B0:  SUBLW  27
043B2:  BNC   43DC
043B4:  BNZ   43BC
043B6:  MOVF   x05,W
043B8:  SUBLW  0F
043BA:  BNC   43DC
043BC:  INCFSZ x07,W
043BE:  BRA    43DC
....................       { 
....................       delay_us(10); 
043C0:  MOVLW  35
043C2:  MOVWF  00
043C4:  DECFSZ 00,F
043C6:  BRA    43C4
....................       response = SD_spi_read(0xFF);  
043C8:  MOVF   FC9,W
043CA:  SETF   FC9
043CC:  RRCF   FC7,W
043CE:  BNC   43CC
043D0:  MOVFF  FC9,A07
043D4:  INCF   x05,F
043D6:  BTFSC  FD8.2
043D8:  INCF   x06,F
043DA:  BRA    43AE
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
043DC:  MOVF   x07,W
043DE:  SUBLW  FE
043E0:  BZ    43F0
....................       { 
....................       if (!response) 
043E2:  MOVF   x07,F
043E4:  BNZ   43EA
....................          response = 0xFE; 
043E6:  MOVLW  FE
043E8:  MOVWF  x07
....................       return(response); 
043EA:  MOVFF  A07,01
043EE:  BRA    444A
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
043F0:  CLRF   x06
043F2:  CLRF   x05
043F4:  MOVF   x04,F
043F6:  BNZ   440A
043F8:  MOVF   x03,F
043FA:  BNZ   440A
043FC:  MOVF   x06,W
043FE:  SUBWF  x02,W
04400:  BNC   442E
04402:  BNZ   440A
04404:  MOVF   x01,W
04406:  SUBWF  x05,W
04408:  BC    442E
....................       ptr[i]=SD_spi_read(0xFF); 
0440A:  MOVLB  9
0440C:  MOVF   xFF,W
0440E:  MOVLB  A
04410:  ADDWF  x05,W
04412:  MOVWF  FE9
04414:  MOVF   x00,W
04416:  ADDWFC x06,W
04418:  MOVWF  FEA
0441A:  MOVF   FC9,W
0441C:  SETF   FC9
0441E:  RRCF   FC7,W
04420:  BNC   441E
04422:  MOVFF  FC9,FEF
04426:  INCF   x05,F
04428:  BTFSC  FD8.2
0442A:  INCF   x06,F
0442C:  BRA    43F4
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
0442E:  MOVF   FC9,W
04430:  SETF   FC9
04432:  RRCF   FC7,W
04434:  BNC   4432
....................    SD_spi_read(0xFF); 
04436:  MOVF   FC9,W
04438:  SETF   FC9
0443A:  RRCF   FC7,W
0443C:  BNC   443A
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
0443E:  MOVF   FC9,W
04440:  SETF   FC9
04442:  RRCF   FC7,W
04444:  BNC   4442
....................    return(0); 
04446:  MOVLW  00
04448:  MOVWF  01
0444A:  MOVLB  0
0444C:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
057C0:  MOVLW  C3
057C2:  MOVLB  A
057C4:  MOVWF  x07
057C6:  MOVLW  50
057C8:  MOVWF  x06
....................    SD_spi_read(0xFF); 
057CA:  MOVF   FC9,W
057CC:  SETF   FC9
057CE:  RRCF   FC7,W
057D0:  BNC   57CE
....................    do 
....................       { 
....................       delay_us(10); 
057D2:  MOVLW  35
057D4:  MOVWF  00
057D6:  DECFSZ 00,F
057D8:  BRA    57D6
....................       response = SD_spi_read(0xFF); 
057DA:  MOVF   FC9,W
057DC:  SETF   FC9
057DE:  RRCF   FC7,W
057E0:  BNC   57DE
057E2:  MOVFF  FC9,A05
....................       Timer--; 
057E6:  MOVF   x06,W
057E8:  BTFSC  FD8.2
057EA:  DECF   x07,F
057EC:  DECF   x06,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
057EE:  INCFSZ x05,W
057F0:  BRA    57F4
057F2:  BRA    57FA
057F4:  MOVF   x06,W
057F6:  IORWF  x07,W
057F8:  BNZ   57D2
....................       ; 
....................  
....................    return (response); 
057FA:  MOVFF  A05,01
057FE:  MOVLB  0
05800:  GOTO   5810 (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
05804:  MOVLW  02
05806:  MOVLB  A
05808:  MOVWF  x04
0580A:  CLRF   x03
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
0580C:  MOVLB  0
0580E:  BRA    57C0
05810:  INCFSZ 01,W
05812:  BRA    5816
05814:  BRA    581C
....................       return (FALSE); 
05816:  MOVLW  00
05818:  MOVWF  01
0581A:  BRA    58C0
....................  
....................    SD_spi_write(token);               // transmit data token 
0581C:  MOVF   FC9,W
0581E:  MOVFF  A01,FC9
05822:  RRCF   FC7,W
05824:  BNC   5822
....................    if (token != 0xFD) 
05826:  MOVLB  A
05828:  MOVF   x01,W
0582A:  SUBLW  FD
0582C:  BZ    58BA
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
0582E:  MOVFF  A04,03
05832:  MOVF   x03,W
05834:  BTFSC  FD8.2
05836:  DECF   x04,F
05838:  DECF   x03,F
0583A:  IORWF  03,W
0583C:  BZ    586A
....................          SD_spi_write(*ptr++); 
0583E:  MOVFF  A00,03
05842:  MOVLB  9
05844:  MOVF   xFF,W
05846:  INCF   xFF,F
05848:  BTFSS  FD8.2
0584A:  BRA    5852
0584C:  MOVLB  A
0584E:  INCF   x00,F
05850:  MOVLB  9
05852:  MOVWF  FE9
05854:  MOVFF  03,FEA
05858:  MOVFF  FEF,A05
0585C:  MOVF   FC9,W
0585E:  MOVFF  A05,FC9
05862:  RRCF   FC7,W
05864:  BNC   5862
05866:  MOVLB  A
05868:  BRA    582E
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
0586A:  MOVF   FC9,W
0586C:  SETF   FC9
0586E:  RRCF   FC7,W
05870:  BNC   586E
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
05872:  MOVF   FC9,W
05874:  SETF   FC9
05876:  RRCF   FC7,W
05878:  BNC   5876
....................       response = SD_spi_read(0xFF);      // Receive data response 
0587A:  MOVF   FC9,W
0587C:  SETF   FC9
0587E:  RRCF   FC7,W
05880:  BNC   587E
05882:  MOVFF  FC9,A02
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
05886:  CLRF   x04
05888:  CLRF   x03
0588A:  MOVF   x04,W
0588C:  SUBLW  C3
0588E:  BNC   58BA
05890:  BNZ   5898
05892:  MOVF   x03,W
05894:  SUBLW  4F
05896:  BNC   58BA
....................          { 
....................          delay_us(10); 
05898:  MOVLW  35
0589A:  MOVWF  00
0589C:  DECFSZ 00,F
0589E:  BRA    589C
....................          response = SD_spi_read(0xFF);   // digest prior operation 
058A0:  MOVF   FC9,W
058A2:  SETF   FC9
058A4:  RRCF   FC7,W
058A6:  BNC   58A4
058A8:  MOVFF  FC9,A02
....................          if (response != 0x00) 
058AC:  MOVF   x02,F
058AE:  BZ    58B2
....................             break; 
058B0:  BRA    58BA
058B2:  INCF   x03,F
058B4:  BTFSC  FD8.2
058B6:  INCF   x04,F
058B8:  BRA    588A
....................          } 
....................  
....................       } 
....................    return(TRUE); 
058BA:  MOVLW  01
058BC:  MOVWF  01
058BE:  MOVLB  0
058C0:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
058C2:  MOVLB  4
058C4:  BTFSS  xE9.0
058C6:  BRA    58CE
....................       return (RES_NOTRDY); 
058C8:  MOVLW  03
058CA:  MOVWF  01
058CC:  BRA    5A08
....................  
....................    if (Media_Status & STA_PROTECT) 
058CE:  BTFSS  xE9.2
058D0:  BRA    58D8
....................       return (RES_WRPRT); 
058D2:  MOVLW  02
058D4:  MOVWF  01
058D6:  BRA    5A08
....................  
....................    if (!SectorCount) 
058D8:  MOVLB  9
058DA:  MOVF   xFE,F
058DC:  BNZ   58E8
....................       return (RES_PARERR); 
058DE:  MOVLW  04
058E0:  MOVWF  01
058E2:  MOVLB  4
058E4:  BRA    5A08
058E6:  MOVLB  9
....................  
....................    SelectSD; 
058E8:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
058EA:  MOVLB  4
058EC:  MOVF   xE3,W
058EE:  SUBLW  05
058F0:  BZ    590C
....................       SectorNumber *= 512; 
058F2:  BCF    FD8.0
058F4:  MOVFF  9FC,9FD
058F8:  MOVFF  9FB,9FC
058FC:  MOVFF  9FA,9FB
05900:  MOVLB  9
05902:  CLRF   xFA
05904:  RLCF   xFB,F
05906:  RLCF   xFC,F
05908:  RLCF   xFD,F
0590A:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
0590C:  MOVLB  9
0590E:  DECFSZ xFE,W
05910:  BRA    5952
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
05912:  MOVLW  58
05914:  MOVLB  A
05916:  MOVWF  x03
05918:  MOVFF  9FD,A07
0591C:  MOVFF  9FC,A06
05920:  MOVFF  9FB,A05
05924:  MOVFF  9FA,A04
05928:  MOVLB  0
0592A:  CALL   34BE
0592E:  MOVF   01,F
05930:  BNZ   594E
....................          if (SD_write_data(Buffer, 0xFE)) 
05932:  MOVFF  9F9,A00
05936:  MOVFF  9F8,9FF
0593A:  MOVLW  FE
0593C:  MOVLB  A
0593E:  MOVWF  x01
05940:  MOVLB  0
05942:  RCALL  5804
05944:  MOVF   01,F
05946:  BZ    594E
....................             SectorCount = 0; 
05948:  MOVLB  9
0594A:  CLRF   xFE
0594C:  MOVLB  0
....................       } 
0594E:  BRA    59EE
05950:  MOVLB  9
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
05952:  MOVLB  4
05954:  MOVF   xE3,W
05956:  ANDLW  03
05958:  BZ    5986
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
0595A:  MOVLW  77
0595C:  MOVLB  A
0595E:  MOVWF  x03
05960:  CLRF   x07
05962:  CLRF   x06
05964:  CLRF   x05
05966:  CLRF   x04
05968:  MOVLB  0
0596A:  CALL   34BE
....................          SD_cmd(SD_ACMD23, SectorCount); 
0596E:  MOVLW  57
05970:  MOVLB  A
05972:  MOVWF  x03
05974:  CLRF   x07
05976:  CLRF   x06
05978:  CLRF   x05
0597A:  MOVFF  9FE,A04
0597E:  MOVLB  0
05980:  CALL   34BE
05984:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05986:  MOVLW  59
05988:  MOVLB  A
0598A:  MOVWF  x03
0598C:  MOVFF  9FD,A07
05990:  MOVFF  9FC,A06
05994:  MOVFF  9FB,A05
05998:  MOVFF  9FA,A04
0599C:  MOVLB  0
0599E:  CALL   34BE
059A2:  MOVF   01,F
059A4:  BNZ   59EE
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
059A6:  MOVFF  9F9,A00
059AA:  MOVFF  9F8,9FF
059AE:  MOVLW  FC
059B0:  MOVLB  A
059B2:  MOVWF  x01
059B4:  MOVLB  0
059B6:  RCALL  5804
059B8:  MOVF   01,F
059BA:  BNZ   59BE
....................                break; 
059BC:  BRA    59D0
....................             Buffer += 512; 
059BE:  MOVLW  02
059C0:  MOVLB  9
059C2:  ADDWF  xF9,F
....................             } while (--SectorCount); 
059C4:  DECF   xFE,F
059C6:  BTFSC  FD8.2
059C8:  BRA    59CE
059CA:  MOVLB  0
059CC:  BRA    59A6
059CE:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
059D0:  MOVLB  A
059D2:  CLRF   x00
059D4:  MOVLB  9
059D6:  CLRF   xFF
059D8:  MOVLW  FD
059DA:  MOVLB  A
059DC:  MOVWF  x01
059DE:  MOVLB  0
059E0:  RCALL  5804
059E2:  MOVF   01,F
059E4:  BNZ   59EE
....................             SectorCount = 1; 
059E6:  MOVLW  01
059E8:  MOVLB  9
059EA:  MOVWF  xFE
059EC:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
059EE:  BSF    F91.1
....................    SD_spi_read(0xFF); 
059F0:  MOVF   FC9,W
059F2:  SETF   FC9
059F4:  RRCF   FC7,W
059F6:  BNC   59F4
....................    return SectorCount ? RES_ERROR : RES_OK; 
059F8:  MOVLB  9
059FA:  MOVF   xFE,F
059FC:  BZ    5A02
059FE:  MOVLW  01
05A00:  BRA    5A04
05A02:  MOVLW  00
05A04:  MOVWF  01
05A06:  MOVLB  4
05A08:  MOVLB  0
05A0A:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
0444E:  MOVLB  4
04450:  BTFSS  xE9.0
04452:  BRA    445A
....................       return (RES_NOTRDY); 
04454:  MOVLW  03
04456:  MOVWF  01
04458:  BRA    4594
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
0445A:  MOVLB  9
0445C:  MOVF   xFE,W
0445E:  SUBLW  01
04460:  BNC   4466
04462:  MOVF   xFE,F
04464:  BNZ   4470
....................       return(RES_PARERR); 
04466:  MOVLW  04
04468:  MOVWF  01
0446A:  MOVLB  4
0446C:  BRA    4594
0446E:  MOVLB  9
....................  
....................    SelectSD; 
04470:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
04472:  MOVLB  A
04474:  CLRF   x02
04476:  CLRF   x01
04478:  MOVLW  02
0447A:  MOVWF  x00
0447C:  MOVLB  9
0447E:  CLRF   xFF
04480:  MOVLB  0
04482:  BRA    4352
04484:  MOVF   01,F
04486:  BNZ   4494
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
04488:  BSF    F91.1
....................       return(RES_ERROR); 
0448A:  MOVLW  01
0448C:  MOVWF  01
0448E:  MOVLB  4
04490:  BRA    4594
04492:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
04494:  MOVLB  4
04496:  MOVF   xE3,W
04498:  SUBLW  05
0449A:  BZ    44B6
....................       SectorNumber *= 512; 
0449C:  BCF    FD8.0
0449E:  MOVFF  9FC,9FD
044A2:  MOVFF  9FB,9FC
044A6:  MOVFF  9FA,9FB
044AA:  MOVLB  9
044AC:  CLRF   xFA
044AE:  RLCF   xFB,F
044B0:  RLCF   xFC,F
044B2:  RLCF   xFD,F
044B4:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
044B6:  MOVLB  9
044B8:  DECFSZ xFE,W
044BA:  BRA    4514
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
044BC:  MOVLW  51
044BE:  MOVLB  A
044C0:  MOVWF  x03
044C2:  MOVFF  9FD,A07
044C6:  MOVFF  9FC,A06
044CA:  MOVFF  9FB,A05
044CE:  MOVFF  9FA,A04
044D2:  MOVLB  0
044D4:  CALL   34BE
044D8:  MOVF   01,F
044DA:  BZ    44E8
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
044DC:  BSF    F91.1
....................          return(RES_PARERR); 
044DE:  MOVLW  04
044E0:  MOVWF  01
044E2:  MOVLB  4
044E4:  BRA    4594
044E6:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
044E8:  MOVFF  9F9,A00
044EC:  MOVFF  9F8,9FF
044F0:  MOVLB  A
044F2:  CLRF   x04
044F4:  CLRF   x03
044F6:  MOVLW  02
044F8:  MOVWF  x02
044FA:  CLRF   x01
044FC:  MOVLB  0
044FE:  RCALL  439C
04500:  MOVF   01,F
04502:  BZ    4510
....................          { 
....................          DeselectSD; 
04504:  BSF    F91.1
....................          return(RES_ERROR); 
04506:  MOVLW  01
04508:  MOVWF  01
0450A:  MOVLB  4
0450C:  BRA    4594
0450E:  MOVLB  0
....................          } 
....................       } 
04510:  BRA    458C
04512:  MOVLB  9
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
04514:  MOVLW  52
04516:  MOVLB  A
04518:  MOVWF  x03
0451A:  MOVFF  9FD,A07
0451E:  MOVFF  9FC,A06
04522:  MOVFF  9FB,A05
04526:  MOVFF  9FA,A04
0452A:  MOVLB  0
0452C:  CALL   34BE
04530:  MOVF   01,F
04532:  BZ    4540
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
04534:  BSF    F91.1
....................          return(RES_PARERR); 
04536:  MOVLW  04
04538:  MOVWF  01
0453A:  MOVLB  4
0453C:  BRA    4594
0453E:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
04540:  MOVFF  9F9,A00
04544:  MOVFF  9F8,9FF
04548:  MOVLB  A
0454A:  CLRF   x04
0454C:  CLRF   x03
0454E:  MOVLW  02
04550:  MOVWF  x02
04552:  CLRF   x01
04554:  MOVLB  0
04556:  RCALL  439C
04558:  MOVF   01,F
0455A:  BZ    4568
....................             { 
....................             DeselectSD; 
0455C:  BSF    F91.1
....................             return(RES_ERROR); 
0455E:  MOVLW  01
04560:  MOVWF  01
04562:  MOVLB  4
04564:  BRA    4594
04566:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
04568:  MOVLW  02
0456A:  MOVLB  9
0456C:  ADDWF  xF9,F
....................          } while (--SectorCount); 
0456E:  DECF   xFE,F
04570:  BTFSC  FD8.2
04572:  BRA    4578
04574:  MOVLB  0
04576:  BRA    4540
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
04578:  MOVLW  4C
0457A:  MOVLB  A
0457C:  MOVWF  x03
0457E:  CLRF   x07
04580:  CLRF   x06
04582:  CLRF   x05
04584:  CLRF   x04
04586:  MOVLB  0
04588:  CALL   34BE
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
0458C:  BSF    F91.1
....................    return(RES_OK); 
0458E:  MOVLW  00
04590:  MOVWF  01
04592:  MOVLB  4
04594:  MOVLB  0
04596:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
05518:  MOVLB  4
0551A:  BCF    xE9.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
0551C:  BCF    xE9.2
....................  
....................    return(Media_Status); 
0551E:  MOVFF  4E9,01
05522:  MOVLB  0
05524:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
035F4:  MOVLB  9
035F6:  CLRF   xC7
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
035F8:  MOVLB  4
035FA:  CLRF   xE3
....................  
....................    DeselectSD; 
035FC:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
035FE:  MOVLW  0A
03600:  MOVLB  9
03602:  MOVWF  xC8
03604:  MOVLB  0
03606:  CALL   288E
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
0360A:  BCF    FC6.5
0360C:  MOVLW  22
0360E:  MOVWF  FC6
03610:  MOVLW  40
03612:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
03614:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
03616:  MOVLB  9
03618:  CLRF   xBF
0361A:  MOVF   xBF,W
0361C:  SUBLW  09
0361E:  BNC   362C
....................       SD_spi_read(0xFF); 
03620:  MOVF   FC9,W
03622:  SETF   FC9
03624:  RRCF   FC7,W
03626:  BNC   3624
03628:  INCF   xBF,F
0362A:  BRA    361A
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
0362C:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
0362E:  MOVF   1F,W
03630:  SUBLW  04
03632:  BNZ   3658
03634:  MOVF   20,F
03636:  BNZ   3658
03638:  MOVLW  76
0363A:  MOVWF  FF6
0363C:  MOVLW  06
0363E:  MOVWF  FF7
03640:  MOVLW  00
03642:  MOVWF  FF8
03644:  CLRF   1B
03646:  BTFSC  FF2.7
03648:  BSF    1B.7
0364A:  BCF    FF2.7
0364C:  MOVLB  0
0364E:  CALL   0E30
03652:  BTFSC  1B.7
03654:  BSF    FF2.7
03656:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
03658:  MOVLW  40
0365A:  MOVLB  A
0365C:  MOVWF  x03
0365E:  CLRF   x07
03660:  CLRF   x06
03662:  CLRF   x05
03664:  CLRF   x04
03666:  MOVLB  0
03668:  RCALL  34BE
0366A:  MOVFF  01,9C0
....................    if (response > 1 ) 
0366E:  MOVLB  9
03670:  MOVF   xC0,W
03672:  SUBLW  01
03674:  BC    36CA
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
03676:  MOVF   1F,W
03678:  SUBLW  04
0367A:  BNZ   36C4
0367C:  MOVF   20,F
0367E:  BNZ   36C4
03680:  MOVLW  86
03682:  MOVWF  FF6
03684:  MOVLW  06
03686:  MOVWF  FF7
03688:  MOVLW  00
0368A:  MOVWF  FF8
0368C:  CLRF   1B
0368E:  BTFSC  FF2.7
03690:  BSF    1B.7
03692:  BCF    FF2.7
03694:  MOVLW  31
03696:  MOVLB  A
03698:  MOVWF  x18
0369A:  MOVLB  0
0369C:  CALL   1006
036A0:  BTFSC  1B.7
036A2:  BSF    FF2.7
036A4:  MOVFF  9C0,9C8
036A8:  MOVLW  57
036AA:  MOVLB  9
036AC:  MOVWF  xC9
036AE:  MOVLB  0
036B0:  RCALL  358E
036B2:  MOVLW  0D
036B4:  BTFSS  F9E.4
036B6:  BRA    36B4
036B8:  MOVWF  FAD
036BA:  MOVLW  0A
036BC:  BTFSS  F9E.4
036BE:  BRA    36BC
036C0:  MOVWF  FAD
036C2:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
036C4:  BSF    xC7.0
....................       goto Exit_disk_initialize; 
036C6:  GOTO   4348
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
036CA:  MOVF   1F,W
036CC:  SUBLW  04
036CE:  BNZ   3718
036D0:  MOVF   20,F
036D2:  BNZ   3718
036D4:  MOVLW  BE
036D6:  MOVWF  FF6
036D8:  MOVLW  06
036DA:  MOVWF  FF7
036DC:  MOVLW  00
036DE:  MOVWF  FF8
036E0:  CLRF   1B
036E2:  BTFSC  FF2.7
036E4:  BSF    1B.7
036E6:  BCF    FF2.7
036E8:  MOVLW  1A
036EA:  MOVLB  A
036EC:  MOVWF  x18
036EE:  MOVLB  0
036F0:  CALL   1006
036F4:  BTFSC  1B.7
036F6:  BSF    FF2.7
036F8:  MOVFF  9C0,9C8
036FC:  MOVLW  57
036FE:  MOVLB  9
03700:  MOVWF  xC9
03702:  MOVLB  0
03704:  RCALL  358E
03706:  MOVLW  0D
03708:  BTFSS  F9E.4
0370A:  BRA    3708
0370C:  MOVWF  FAD
0370E:  MOVLW  0A
03710:  BTFSS  F9E.4
03712:  BRA    3710
03714:  MOVWF  FAD
03716:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
03718:  MOVLW  48
0371A:  MOVLB  A
0371C:  MOVWF  x03
0371E:  CLRF   x07
03720:  CLRF   x06
03722:  MOVLW  01
03724:  MOVWF  x05
03726:  MOVLW  AA
03728:  MOVWF  x04
0372A:  MOVLB  0
0372C:  RCALL  34BE
0372E:  MOVFF  01,9C0
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
03732:  MOVF   1F,W
03734:  SUBLW  04
03736:  BNZ   377E
03738:  MOVF   20,F
0373A:  BNZ   377E
0373C:  MOVLW  E0
0373E:  MOVWF  FF6
03740:  MOVLW  06
03742:  MOVWF  FF7
03744:  MOVLW  00
03746:  MOVWF  FF8
03748:  CLRF   1B
0374A:  BTFSC  FF2.7
0374C:  BSF    1B.7
0374E:  BCF    FF2.7
03750:  MOVLW  25
03752:  MOVLB  A
03754:  MOVWF  x18
03756:  MOVLB  0
03758:  CALL   1006
0375C:  BTFSC  1B.7
0375E:  BSF    FF2.7
03760:  MOVFF  9C0,9C8
03764:  MOVLW  57
03766:  MOVLB  9
03768:  MOVWF  xC9
0376A:  MOVLB  0
0376C:  RCALL  358E
0376E:  MOVLW  0D
03770:  BTFSS  F9E.4
03772:  BRA    3770
03774:  MOVWF  FAD
03776:  MOVLW  0A
03778:  BTFSS  F9E.4
0377A:  BRA    3778
0377C:  MOVWF  FAD
....................    if (response == 1)  
0377E:  MOVLB  9
03780:  DECFSZ xC0,W
03782:  BRA    3B54
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
03784:  MOVF   1F,W
03786:  SUBLW  04
03788:  BNZ   37AE
0378A:  MOVF   20,F
0378C:  BNZ   37AE
0378E:  MOVLW  0A
03790:  MOVWF  FF6
03792:  MOVLW  07
03794:  MOVWF  FF7
03796:  MOVLW  00
03798:  MOVWF  FF8
0379A:  CLRF   1B
0379C:  BTFSC  FF2.7
0379E:  BSF    1B.7
037A0:  BCF    FF2.7
037A2:  MOVLB  0
037A4:  CALL   0E30
037A8:  BTFSC  1B.7
037AA:  BSF    FF2.7
037AC:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
037AE:  CLRF   xBF
037B0:  MOVF   xBF,W
037B2:  SUBLW  03
037B4:  BNC   37D4
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
037B6:  CLRF   03
037B8:  MOVF   xBF,W
037BA:  ADDLW  C1
037BC:  MOVWF  FE9
037BE:  MOVLW  09
037C0:  ADDWFC 03,W
037C2:  MOVWF  FEA
037C4:  MOVF   FC9,W
037C6:  SETF   FC9
037C8:  RRCF   FC7,W
037CA:  BNC   37C8
037CC:  MOVFF  FC9,FEF
037D0:  INCF   xBF,F
037D2:  BRA    37B0
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
037D4:  MOVF   1F,W
037D6:  SUBLW  04
037D8:  BNZ   384C
037DA:  MOVF   20,F
037DC:  BNZ   384C
037DE:  MOVLW  2C
037E0:  MOVWF  FF6
037E2:  MOVLW  07
037E4:  MOVWF  FF7
037E6:  MOVLW  00
037E8:  MOVWF  FF8
037EA:  CLRF   1B
037EC:  BTFSC  FF2.7
037EE:  BSF    1B.7
037F0:  BCF    FF2.7
037F2:  MOVLW  1F
037F4:  MOVLB  A
037F6:  MOVWF  x18
037F8:  MOVLB  0
037FA:  CALL   1006
037FE:  BTFSC  1B.7
03800:  BSF    FF2.7
03802:  MOVFF  9C1,9C8
03806:  MOVLW  57
03808:  MOVLB  9
0380A:  MOVWF  xC9
0380C:  MOVLB  0
0380E:  RCALL  358E
03810:  MOVFF  9C2,9C8
03814:  MOVLW  57
03816:  MOVLB  9
03818:  MOVWF  xC9
0381A:  MOVLB  0
0381C:  RCALL  358E
0381E:  MOVFF  9C3,9C8
03822:  MOVLW  57
03824:  MOVLB  9
03826:  MOVWF  xC9
03828:  MOVLB  0
0382A:  RCALL  358E
0382C:  MOVFF  9C4,9C8
03830:  MOVLW  57
03832:  MOVLB  9
03834:  MOVWF  xC9
03836:  MOVLB  0
03838:  RCALL  358E
0383A:  MOVLW  0D
0383C:  BTFSS  F9E.4
0383E:  BRA    383C
03840:  MOVWF  FAD
03842:  MOVLW  0A
03844:  BTFSS  F9E.4
03846:  BRA    3844
03848:  MOVWF  FAD
0384A:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
0384C:  DECFSZ xC3,W
0384E:  BRA    3B2A
03850:  MOVF   xC4,W
03852:  SUBLW  AA
03854:  BTFSS  FD8.2
03856:  BRA    3B2A
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
03858:  MOVF   1F,W
0385A:  SUBLW  04
0385C:  BNZ   3882
0385E:  MOVF   20,F
03860:  BNZ   3882
03862:  MOVLW  5E
03864:  MOVWF  FF6
03866:  MOVLW  07
03868:  MOVWF  FF7
0386A:  MOVLW  00
0386C:  MOVWF  FF8
0386E:  CLRF   1B
03870:  BTFSC  FF2.7
03872:  BSF    1B.7
03874:  BCF    FF2.7
03876:  MOVLB  0
03878:  CALL   0E30
0387C:  BTFSC  1B.7
0387E:  BSF    FF2.7
03880:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
03882:  MOVF   1F,W
03884:  SUBLW  04
03886:  BNZ   38AC
03888:  MOVF   20,F
0388A:  BNZ   38AC
0388C:  MOVLW  84
0388E:  MOVWF  FF6
03890:  MOVLW  07
03892:  MOVWF  FF7
03894:  MOVLW  00
03896:  MOVWF  FF8
03898:  CLRF   1B
0389A:  BTFSC  FF2.7
0389C:  BSF    1B.7
0389E:  BCF    FF2.7
038A0:  MOVLB  0
038A2:  CALL   0E30
038A6:  BTFSC  1B.7
038A8:  BSF    FF2.7
038AA:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
038AC:  CLRF   xC6
038AE:  CLRF   xC5
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
038B0:  MOVLW  77
038B2:  MOVLB  A
038B4:  MOVWF  x03
038B6:  CLRF   x07
038B8:  CLRF   x06
038BA:  CLRF   x05
038BC:  CLRF   x04
038BE:  MOVLB  0
038C0:  RCALL  34BE
038C2:  MOVFF  01,9C0
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
038C6:  MOVLW  69
038C8:  MOVLB  A
038CA:  MOVWF  x03
038CC:  MOVLW  40
038CE:  MOVWF  x07
038D0:  CLRF   x06
038D2:  CLRF   x05
038D4:  CLRF   x04
038D6:  MOVLB  0
038D8:  RCALL  34BE
038DA:  MOVFF  01,9C0
....................          while (response && (Timer < 50000)) 
038DE:  MOVLB  9
038E0:  MOVF   xC0,F
038E2:  BZ    3934
038E4:  MOVF   xC6,W
038E6:  SUBLW  C3
038E8:  BNC   3934
038EA:  BNZ   38F2
038EC:  MOVF   xC5,W
038EE:  SUBLW  4F
038F0:  BNC   3934
....................          { 
....................             delay_us(20); 
038F2:  MOVLW  6A
038F4:  MOVWF  00
038F6:  DECFSZ 00,F
038F8:  BRA    38F6
038FA:  NOP   
....................             Timer++; 
038FC:  INCF   xC5,F
038FE:  BTFSC  FD8.2
03900:  INCF   xC6,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
03902:  MOVLW  77
03904:  MOVLB  A
03906:  MOVWF  x03
03908:  CLRF   x07
0390A:  CLRF   x06
0390C:  CLRF   x05
0390E:  CLRF   x04
03910:  MOVLB  0
03912:  RCALL  34BE
03914:  MOVFF  01,9C0
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
03918:  MOVLW  69
0391A:  MOVLB  A
0391C:  MOVWF  x03
0391E:  MOVLW  40
03920:  MOVWF  x07
03922:  CLRF   x06
03924:  CLRF   x05
03926:  CLRF   x04
03928:  MOVLB  0
0392A:  RCALL  34BE
0392C:  MOVFF  01,9C0
03930:  BRA    38DE
03932:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
03934:  MOVF   1F,W
03936:  SUBLW  04
03938:  BNZ   39C2
0393A:  MOVF   20,F
0393C:  BNZ   39C2
0393E:  MOVLW  B2
03940:  MOVWF  FF6
03942:  MOVLW  07
03944:  MOVWF  FF7
03946:  MOVLW  00
03948:  MOVWF  FF8
0394A:  CLRF   1B
0394C:  BTFSC  FF2.7
0394E:  BSF    1B.7
03950:  BCF    FF2.7
03952:  MOVLW  23
03954:  MOVLB  A
03956:  MOVWF  x18
03958:  MOVLB  0
0395A:  CALL   1006
0395E:  BTFSC  1B.7
03960:  BSF    FF2.7
03962:  MOVFF  9C0,9C8
03966:  MOVLW  57
03968:  MOVLB  9
0396A:  MOVWF  xC9
0396C:  MOVLB  0
0396E:  RCALL  358E
03970:  MOVLW  D9
03972:  MOVWF  FF6
03974:  MOVLW  07
03976:  MOVWF  FF7
03978:  MOVLW  00
0397A:  MOVWF  FF8
0397C:  CLRF   1B
0397E:  BTFSC  FF2.7
03980:  BSF    1B.7
03982:  BCF    FF2.7
03984:  MOVLW  0A
03986:  MOVLB  A
03988:  MOVWF  x18
0398A:  MOVLB  0
0398C:  CALL   1006
03990:  BTFSC  1B.7
03992:  BSF    FF2.7
03994:  MOVLW  10
03996:  MOVWF  FE9
03998:  CLRF   1B
0399A:  BTFSC  FF2.7
0399C:  BSF    1B.7
0399E:  BCF    FF2.7
039A0:  MOVFF  9C6,A19
039A4:  MOVFF  9C5,A18
039A8:  CALL   1188
039AC:  BTFSC  1B.7
039AE:  BSF    FF2.7
039B0:  MOVLW  0D
039B2:  BTFSS  F9E.4
039B4:  BRA    39B2
039B6:  MOVWF  FAD
039B8:  MOVLW  0A
039BA:  BTFSS  F9E.4
039BC:  BRA    39BA
039BE:  MOVWF  FAD
039C0:  MOVLB  9
....................          if (!response) 
039C2:  MOVF   xC0,F
039C4:  BTFSS  FD8.2
039C6:  BRA    3B28
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
039C8:  MOVLW  7A
039CA:  MOVLB  A
039CC:  MOVWF  x03
039CE:  MOVLW  40
039D0:  MOVWF  x07
039D2:  CLRF   x06
039D4:  CLRF   x05
039D6:  CLRF   x04
039D8:  MOVLB  0
039DA:  RCALL  34BE
039DC:  MOVFF  01,9C0
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
039E0:  MOVF   1F,W
039E2:  SUBLW  04
039E4:  BNZ   3A2C
039E6:  MOVF   20,F
039E8:  BNZ   3A2C
039EA:  MOVLW  EA
039EC:  MOVWF  FF6
039EE:  MOVLW  07
039F0:  MOVWF  FF7
039F2:  MOVLW  00
039F4:  MOVWF  FF8
039F6:  CLRF   1B
039F8:  BTFSC  FF2.7
039FA:  BSF    1B.7
039FC:  BCF    FF2.7
039FE:  MOVLW  18
03A00:  MOVLB  A
03A02:  MOVWF  x18
03A04:  MOVLB  0
03A06:  CALL   1006
03A0A:  BTFSC  1B.7
03A0C:  BSF    FF2.7
03A0E:  MOVFF  9C0,9C8
03A12:  MOVLW  57
03A14:  MOVLB  9
03A16:  MOVWF  xC9
03A18:  MOVLB  0
03A1A:  RCALL  358E
03A1C:  MOVLW  0D
03A1E:  BTFSS  F9E.4
03A20:  BRA    3A1E
03A22:  MOVWF  FAD
03A24:  MOVLW  0A
03A26:  BTFSS  F9E.4
03A28:  BRA    3A26
03A2A:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03A2C:  MOVLB  9
03A2E:  MOVF   xC0,F
03A30:  BTFSS  FD8.2
03A32:  BRA    3B28
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03A34:  CLRF   xBF
03A36:  MOVF   xBF,W
03A38:  SUBLW  03
03A3A:  BNC   3A5A
....................                   ocr[i] = SD_spi_read(0xFF); 
03A3C:  CLRF   03
03A3E:  MOVF   xBF,W
03A40:  ADDLW  C1
03A42:  MOVWF  FE9
03A44:  MOVLW  09
03A46:  ADDWFC 03,W
03A48:  MOVWF  FEA
03A4A:  MOVF   FC9,W
03A4C:  SETF   FC9
03A4E:  RRCF   FC7,W
03A50:  BNC   3A4E
03A52:  MOVFF  FC9,FEF
03A56:  INCF   xBF,F
03A58:  BRA    3A36
....................                if (ocr[0] & 0x40) 
03A5A:  BTFSS  xC1.6
03A5C:  BRA    3A68
....................                   Card = SDHC; 
03A5E:  MOVLW  05
03A60:  MOVLB  4
03A62:  MOVWF  xE3
03A64:  BRA    3A6E
03A66:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03A68:  MOVLW  04
03A6A:  MOVLB  4
03A6C:  MOVWF  xE3
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03A6E:  MOVF   1F,W
03A70:  SUBLW  04
03A72:  BNZ   3B26
03A74:  MOVF   20,F
03A76:  BNZ   3B26
03A78:  MOVLW  08
03A7A:  MOVWF  FF6
03A7C:  MOVLW  08
03A7E:  MOVWF  FF7
03A80:  MOVLW  00
03A82:  MOVWF  FF8
03A84:  CLRF   1B
03A86:  BTFSC  FF2.7
03A88:  BSF    1B.7
03A8A:  BCF    FF2.7
03A8C:  MOVLW  1F
03A8E:  MOVLB  A
03A90:  MOVWF  x18
03A92:  MOVLB  0
03A94:  CALL   1006
03A98:  BTFSC  1B.7
03A9A:  BSF    FF2.7
03A9C:  MOVLW  10
03A9E:  MOVWF  FE9
03AA0:  CLRF   1B
03AA2:  BTFSC  FF2.7
03AA4:  BSF    1B.7
03AA6:  BCF    FF2.7
03AA8:  MOVFF  9C6,A19
03AAC:  MOVFF  9C5,A18
03AB0:  CALL   1188
03AB4:  BTFSC  1B.7
03AB6:  BSF    FF2.7
03AB8:  MOVLW  2A
03ABA:  MOVWF  FF6
03ABC:  MOVLW  08
03ABE:  MOVWF  FF7
03AC0:  MOVLW  00
03AC2:  MOVWF  FF8
03AC4:  CLRF   1B
03AC6:  BTFSC  FF2.7
03AC8:  BSF    1B.7
03ACA:  BCF    FF2.7
03ACC:  MOVLW  08
03ACE:  MOVLB  A
03AD0:  MOVWF  x18
03AD2:  MOVLB  0
03AD4:  CALL   1006
03AD8:  BTFSC  1B.7
03ADA:  BSF    FF2.7
03ADC:  MOVFF  9C1,9C8
03AE0:  MOVLW  57
03AE2:  MOVLB  9
03AE4:  MOVWF  xC9
03AE6:  MOVLB  0
03AE8:  RCALL  358E
03AEA:  MOVFF  9C2,9C8
03AEE:  MOVLW  57
03AF0:  MOVLB  9
03AF2:  MOVWF  xC9
03AF4:  MOVLB  0
03AF6:  RCALL  358E
03AF8:  MOVFF  9C3,9C8
03AFC:  MOVLW  57
03AFE:  MOVLB  9
03B00:  MOVWF  xC9
03B02:  MOVLB  0
03B04:  RCALL  358E
03B06:  MOVFF  9C4,9C8
03B0A:  MOVLW  57
03B0C:  MOVLB  9
03B0E:  MOVWF  xC9
03B10:  MOVLB  0
03B12:  RCALL  358E
03B14:  MOVLW  0D
03B16:  BTFSS  F9E.4
03B18:  BRA    3B16
03B1A:  MOVWF  FAD
03B1C:  MOVLW  0A
03B1E:  BTFSS  F9E.4
03B20:  BRA    3B1E
03B22:  MOVWF  FAD
03B24:  MOVLB  4
03B26:  MOVLB  9
....................             } 
....................          } 
....................       } 
03B28:  BRA    3B54
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03B2A:  MOVF   1F,W
03B2C:  SUBLW  04
03B2E:  BNZ   3B54
03B30:  MOVF   20,F
03B32:  BNZ   3B54
03B34:  MOVLW  46
03B36:  MOVWF  FF6
03B38:  MOVLW  08
03B3A:  MOVWF  FF7
03B3C:  MOVLW  00
03B3E:  MOVWF  FF8
03B40:  CLRF   1B
03B42:  BTFSC  FF2.7
03B44:  BSF    1B.7
03B46:  BCF    FF2.7
03B48:  MOVLB  0
03B4A:  CALL   0E30
03B4E:  BTFSC  1B.7
03B50:  BSF    FF2.7
03B52:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03B54:  MOVLB  4
03B56:  MOVF   xE3,F
03B58:  BTFSS  FD8.2
03B5A:  BRA    402A
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03B5C:  MOVF   1F,W
03B5E:  SUBLW  04
03B60:  BNZ   3B86
03B62:  MOVF   20,F
03B64:  BNZ   3B86
03B66:  MOVLW  78
03B68:  MOVWF  FF6
03B6A:  MOVLW  08
03B6C:  MOVWF  FF7
03B6E:  MOVLW  00
03B70:  MOVWF  FF8
03B72:  CLRF   1B
03B74:  BTFSC  FF2.7
03B76:  BSF    1B.7
03B78:  BCF    FF2.7
03B7A:  MOVLB  0
03B7C:  CALL   0E30
03B80:  BTFSC  1B.7
03B82:  BSF    FF2.7
03B84:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03B86:  MOVLW  40
03B88:  MOVLB  A
03B8A:  MOVWF  x03
03B8C:  CLRF   x07
03B8E:  CLRF   x06
03B90:  CLRF   x05
03B92:  CLRF   x04
03B94:  MOVLB  0
03B96:  RCALL  34BE
03B98:  MOVFF  01,9C0
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03B9C:  MOVF   1F,W
03B9E:  SUBLW  04
03BA0:  BNZ   3BE8
03BA2:  MOVF   20,F
03BA4:  BNZ   3BE8
03BA6:  MOVLW  B8
03BA8:  MOVWF  FF6
03BAA:  MOVLW  08
03BAC:  MOVWF  FF7
03BAE:  MOVLW  00
03BB0:  MOVWF  FF8
03BB2:  CLRF   1B
03BB4:  BTFSC  FF2.7
03BB6:  BSF    1B.7
03BB8:  BCF    FF2.7
03BBA:  MOVLW  1C
03BBC:  MOVLB  A
03BBE:  MOVWF  x18
03BC0:  MOVLB  0
03BC2:  CALL   1006
03BC6:  BTFSC  1B.7
03BC8:  BSF    FF2.7
03BCA:  MOVFF  9C0,9C8
03BCE:  MOVLW  57
03BD0:  MOVLB  9
03BD2:  MOVWF  xC9
03BD4:  MOVLB  0
03BD6:  RCALL  358E
03BD8:  MOVLW  0D
03BDA:  BTFSS  F9E.4
03BDC:  BRA    3BDA
03BDE:  MOVWF  FAD
03BE0:  MOVLW  0A
03BE2:  BTFSS  F9E.4
03BE4:  BRA    3BE2
03BE6:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03BE8:  MOVLB  9
03BEA:  DECFSZ xC0,W
03BEC:  BRA    3BF0
03BEE:  BRA    3BFA
03BF0:  MOVF   xC0,F
03BF2:  BZ    3BFA
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03BF4:  BSF    xC7.0
....................          goto Exit_disk_initialize; 
03BF6:  GOTO   4348
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03BFA:  CLRF   xC6
03BFC:  CLRF   xC5
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03BFE:  MOVLW  41
03C00:  MOVLB  A
03C02:  MOVWF  x03
03C04:  CLRF   x07
03C06:  CLRF   x06
03C08:  CLRF   x05
03C0A:  CLRF   x04
03C0C:  MOVLB  0
03C0E:  RCALL  34BE
03C10:  MOVFF  01,9C0
....................          if (response != 0x00 ) 
03C14:  MOVLB  9
03C16:  MOVF   xC0,F
03C18:  BZ    3C22
....................             delay_us(10); 
03C1A:  MOVLW  35
03C1C:  MOVWF  00
03C1E:  DECFSZ 00,F
03C20:  BRA    3C1E
....................          Timer++; 
03C22:  INCF   xC5,F
03C24:  BTFSC  FD8.2
03C26:  INCF   xC6,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03C28:  MOVF   xC0,F
03C2A:  BZ    3C3A
03C2C:  MOVF   xC6,W
03C2E:  SUBLW  C3
03C30:  BNC   3C3A
03C32:  BNZ   3BFE
03C34:  MOVF   xC5,W
03C36:  SUBLW  4F
03C38:  BC    3BFE
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03C3A:  MOVF   1F,W
03C3C:  SUBLW  04
03C3E:  BNZ   3CC8
03C40:  MOVF   20,F
03C42:  BNZ   3CC8
03C44:  MOVLW  DC
03C46:  MOVWF  FF6
03C48:  MOVLW  08
03C4A:  MOVWF  FF7
03C4C:  MOVLW  00
03C4E:  MOVWF  FF8
03C50:  CLRF   1B
03C52:  BTFSC  FF2.7
03C54:  BSF    1B.7
03C56:  BCF    FF2.7
03C58:  MOVLW  28
03C5A:  MOVLB  A
03C5C:  MOVWF  x18
03C5E:  MOVLB  0
03C60:  CALL   1006
03C64:  BTFSC  1B.7
03C66:  BSF    FF2.7
03C68:  MOVFF  9C0,9C8
03C6C:  MOVLW  57
03C6E:  MOVLB  9
03C70:  MOVWF  xC9
03C72:  MOVLB  0
03C74:  RCALL  358E
03C76:  MOVLW  08
03C78:  MOVWF  FF6
03C7A:  MOVLW  09
03C7C:  MOVWF  FF7
03C7E:  MOVLW  00
03C80:  MOVWF  FF8
03C82:  CLRF   1B
03C84:  BTFSC  FF2.7
03C86:  BSF    1B.7
03C88:  BCF    FF2.7
03C8A:  MOVLW  0A
03C8C:  MOVLB  A
03C8E:  MOVWF  x18
03C90:  MOVLB  0
03C92:  CALL   1006
03C96:  BTFSC  1B.7
03C98:  BSF    FF2.7
03C9A:  MOVLW  10
03C9C:  MOVWF  FE9
03C9E:  CLRF   1B
03CA0:  BTFSC  FF2.7
03CA2:  BSF    1B.7
03CA4:  BCF    FF2.7
03CA6:  MOVFF  9C6,A19
03CAA:  MOVFF  9C5,A18
03CAE:  CALL   1188
03CB2:  BTFSC  1B.7
03CB4:  BSF    FF2.7
03CB6:  MOVLW  0D
03CB8:  BTFSS  F9E.4
03CBA:  BRA    3CB8
03CBC:  MOVWF  FAD
03CBE:  MOVLW  0A
03CC0:  BTFSS  F9E.4
03CC2:  BRA    3CC0
03CC4:  MOVWF  FAD
03CC6:  MOVLB  9
....................       if(response) 
03CC8:  MOVF   xC0,F
03CCA:  BZ    3CD0
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03CCC:  BSF    xC7.0
....................          goto Exit_disk_initialize; 
03CCE:  BRA    4348
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03CD0:  MOVLW  77
03CD2:  MOVLB  A
03CD4:  MOVWF  x03
03CD6:  CLRF   x07
03CD8:  CLRF   x06
03CDA:  CLRF   x05
03CDC:  CLRF   x04
03CDE:  MOVLB  0
03CE0:  CALL   34BE
03CE4:  MOVFF  01,9C0
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03CE8:  MOVF   1F,W
03CEA:  SUBLW  04
03CEC:  BNZ   3D34
03CEE:  MOVF   20,F
03CF0:  BNZ   3D34
03CF2:  MOVLW  18
03CF4:  MOVWF  FF6
03CF6:  MOVLW  09
03CF8:  MOVWF  FF7
03CFA:  MOVLW  00
03CFC:  MOVWF  FF8
03CFE:  CLRF   1B
03D00:  BTFSC  FF2.7
03D02:  BSF    1B.7
03D04:  BCF    FF2.7
03D06:  MOVLW  43
03D08:  MOVLB  A
03D0A:  MOVWF  x18
03D0C:  MOVLB  0
03D0E:  CALL   1006
03D12:  BTFSC  1B.7
03D14:  BSF    FF2.7
03D16:  MOVFF  9C0,9C8
03D1A:  MOVLW  57
03D1C:  MOVLB  9
03D1E:  MOVWF  xC9
03D20:  MOVLB  0
03D22:  RCALL  358E
03D24:  MOVLW  0D
03D26:  BTFSS  F9E.4
03D28:  BRA    3D26
03D2A:  MOVWF  FAD
03D2C:  MOVLW  0A
03D2E:  BTFSS  F9E.4
03D30:  BRA    3D2E
03D32:  MOVWF  FAD
....................       if (response) 
03D34:  MOVLB  9
03D36:  MOVF   xC0,F
03D38:  BZ    3D44
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03D3A:  MOVLW  02
03D3C:  MOVLB  4
03D3E:  MOVWF  xE3
....................          } 
03D40:  BRA    3F3E
03D42:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03D44:  MOVLW  69
03D46:  MOVLB  A
03D48:  MOVWF  x03
03D4A:  CLRF   x07
03D4C:  CLRF   x06
03D4E:  CLRF   x05
03D50:  CLRF   x04
03D52:  MOVLB  0
03D54:  CALL   34BE
03D58:  MOVFF  01,9C0
....................          if (response <= 1 ) 
03D5C:  MOVLB  9
03D5E:  MOVF   xC0,W
03D60:  SUBLW  01
03D62:  BNC   3D6E
....................             Card = SDv1; 
03D64:  MOVLW  03
03D66:  MOVLB  4
03D68:  MOVWF  xE3
03D6A:  BRA    3F3E
03D6C:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03D6E:  MOVF   1F,W
03D70:  SUBLW  04
03D72:  BNZ   3DD2
03D74:  MOVF   20,F
03D76:  BNZ   3DD2
03D78:  MOVLW  62
03D7A:  MOVWF  FF6
03D7C:  MOVLW  09
03D7E:  MOVWF  FF7
03D80:  MOVLW  00
03D82:  MOVWF  FF8
03D84:  CLRF   1B
03D86:  BTFSC  FF2.7
03D88:  BSF    1B.7
03D8A:  BCF    FF2.7
03D8C:  MOVLW  2E
03D8E:  MOVLB  A
03D90:  MOVWF  x18
03D92:  MOVLB  0
03D94:  CALL   1006
03D98:  BTFSC  1B.7
03D9A:  BSF    FF2.7
03D9C:  MOVFF  9C0,9C8
03DA0:  MOVLW  37
03DA2:  MOVLB  9
03DA4:  MOVWF  xC9
03DA6:  MOVLB  0
03DA8:  CALL   358E
03DAC:  MOVLW  94
03DAE:  MOVWF  FF6
03DB0:  MOVLW  09
03DB2:  MOVWF  FF7
03DB4:  MOVLW  00
03DB6:  MOVWF  FF8
03DB8:  CLRF   1B
03DBA:  BTFSC  FF2.7
03DBC:  BSF    1B.7
03DBE:  BCF    FF2.7
03DC0:  MOVLW  19
03DC2:  MOVLB  A
03DC4:  MOVWF  x18
03DC6:  MOVLB  0
03DC8:  CALL   1006
03DCC:  BTFSC  1B.7
03DCE:  BSF    FF2.7
03DD0:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03DD2:  MOVLW  40
03DD4:  MOVLB  A
03DD6:  MOVWF  x03
03DD8:  CLRF   x07
03DDA:  CLRF   x06
03DDC:  CLRF   x05
03DDE:  CLRF   x04
03DE0:  MOVLB  0
03DE2:  CALL   34BE
03DE6:  MOVFF  01,9C0
....................             if ((response !=0x01) && (response != 0)) 
03DEA:  MOVLB  9
03DEC:  DECFSZ xC0,W
03DEE:  BRA    3DF2
03DF0:  BRA    3E5E
03DF2:  MOVF   xC0,F
03DF4:  BZ    3E5E
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03DF6:  MOVF   1F,W
03DF8:  SUBLW  04
03DFA:  BNZ   3E5A
03DFC:  MOVF   20,F
03DFE:  BNZ   3E5A
03E00:  MOVLW  AE
03E02:  MOVWF  FF6
03E04:  MOVLW  09
03E06:  MOVWF  FF7
03E08:  MOVLW  00
03E0A:  MOVWF  FF8
03E0C:  CLRF   1B
03E0E:  BTFSC  FF2.7
03E10:  BSF    1B.7
03E12:  BCF    FF2.7
03E14:  MOVLW  2C
03E16:  MOVLB  A
03E18:  MOVWF  x18
03E1A:  MOVLB  0
03E1C:  CALL   1006
03E20:  BTFSC  1B.7
03E22:  BSF    FF2.7
03E24:  MOVFF  9C0,9C8
03E28:  MOVLW  37
03E2A:  MOVLB  9
03E2C:  MOVWF  xC9
03E2E:  MOVLB  0
03E30:  CALL   358E
03E34:  MOVLW  DE
03E36:  MOVWF  FF6
03E38:  MOVLW  09
03E3A:  MOVWF  FF7
03E3C:  MOVLW  00
03E3E:  MOVWF  FF8
03E40:  CLRF   1B
03E42:  BTFSC  FF2.7
03E44:  BSF    1B.7
03E46:  BCF    FF2.7
03E48:  MOVLW  0B
03E4A:  MOVLB  A
03E4C:  MOVWF  x18
03E4E:  MOVLB  0
03E50:  CALL   1006
03E54:  BTFSC  1B.7
03E56:  BSF    FF2.7
03E58:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03E5A:  BSF    xC7.0
....................                goto Exit_disk_initialize; 
03E5C:  BRA    4348
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03E5E:  CLRF   xC6
03E60:  CLRF   xC5
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03E62:  MOVLW  41
03E64:  MOVLB  A
03E66:  MOVWF  x03
03E68:  CLRF   x07
03E6A:  CLRF   x06
03E6C:  CLRF   x05
03E6E:  CLRF   x04
03E70:  MOVLB  0
03E72:  CALL   34BE
03E76:  MOVFF  01,9C0
....................                if (response != 0x00 ) 
03E7A:  MOVLB  9
03E7C:  MOVF   xC0,F
03E7E:  BZ    3E88
....................                   delay_us(10); 
03E80:  MOVLW  35
03E82:  MOVWF  00
03E84:  DECFSZ 00,F
03E86:  BRA    3E84
....................                Timer++; 
03E88:  INCF   xC5,F
03E8A:  BTFSC  FD8.2
03E8C:  INCF   xC6,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03E8E:  MOVF   xC0,F
03E90:  BZ    3EA0
03E92:  MOVF   xC6,W
03E94:  SUBLW  C3
03E96:  BNC   3EA0
03E98:  BNZ   3E62
03E9A:  MOVF   xC5,W
03E9C:  SUBLW  4F
03E9E:  BC    3E62
....................     
....................             if(response) 
03EA0:  MOVF   xC0,F
03EA2:  BZ    3F38
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03EA4:  MOVF   1F,W
03EA6:  SUBLW  04
03EA8:  BNZ   3F34
03EAA:  MOVF   20,F
03EAC:  BNZ   3F34
03EAE:  MOVLW  EA
03EB0:  MOVWF  FF6
03EB2:  MOVLW  09
03EB4:  MOVWF  FF7
03EB6:  MOVLW  00
03EB8:  MOVWF  FF8
03EBA:  CLRF   1B
03EBC:  BTFSC  FF2.7
03EBE:  BSF    1B.7
03EC0:  BCF    FF2.7
03EC2:  MOVLW  4A
03EC4:  MOVLB  A
03EC6:  MOVWF  x18
03EC8:  MOVLB  0
03ECA:  CALL   1006
03ECE:  BTFSC  1B.7
03ED0:  BSF    FF2.7
03ED2:  MOVFF  9C0,9C8
03ED6:  MOVLW  37
03ED8:  MOVLB  9
03EDA:  MOVWF  xC9
03EDC:  MOVLB  0
03EDE:  CALL   358E
03EE2:  MOVLW  38
03EE4:  MOVWF  FF6
03EE6:  MOVLW  0A
03EE8:  MOVWF  FF7
03EEA:  MOVLW  00
03EEC:  MOVWF  FF8
03EEE:  CLRF   1B
03EF0:  BTFSC  FF2.7
03EF2:  BSF    1B.7
03EF4:  BCF    FF2.7
03EF6:  MOVLW  0A
03EF8:  MOVLB  A
03EFA:  MOVWF  x18
03EFC:  MOVLB  0
03EFE:  CALL   1006
03F02:  BTFSC  1B.7
03F04:  BSF    FF2.7
03F06:  MOVLW  10
03F08:  MOVWF  FE9
03F0A:  CLRF   1B
03F0C:  BTFSC  FF2.7
03F0E:  BSF    1B.7
03F10:  BCF    FF2.7
03F12:  MOVFF  9C6,A19
03F16:  MOVFF  9C5,A18
03F1A:  CALL   1188
03F1E:  BTFSC  1B.7
03F20:  BSF    FF2.7
03F22:  MOVLW  0D
03F24:  BTFSS  F9E.4
03F26:  BRA    3F24
03F28:  MOVWF  FAD
03F2A:  MOVLW  0A
03F2C:  BTFSS  F9E.4
03F2E:  BRA    3F2C
03F30:  MOVWF  FAD
03F32:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03F34:  BSF    xC7.0
....................                goto Exit_disk_initialize; 
03F36:  BRA    4348
....................                } 
....................  
....................             Card = MMC; 
03F38:  MOVLW  02
03F3A:  MOVLB  4
03F3C:  MOVWF  xE3
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03F3E:  MOVF   1F,W
03F40:  SUBLW  04
03F42:  BNZ   3F68
03F44:  MOVF   20,F
03F46:  BNZ   3F68
03F48:  MOVLW  48
03F4A:  MOVWF  FF6
03F4C:  MOVLW  0A
03F4E:  MOVWF  FF7
03F50:  MOVLW  00
03F52:  MOVWF  FF8
03F54:  CLRF   1B
03F56:  BTFSC  FF2.7
03F58:  BSF    1B.7
03F5A:  BCF    FF2.7
03F5C:  MOVLB  0
03F5E:  CALL   0E30
03F62:  BTFSC  1B.7
03F64:  BSF    FF2.7
03F66:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
03F68:  MOVLW  50
03F6A:  MOVLB  A
03F6C:  MOVWF  x03
03F6E:  CLRF   x07
03F70:  CLRF   x06
03F72:  MOVLW  02
03F74:  MOVWF  x05
03F76:  CLRF   x04
03F78:  MOVLB  0
03F7A:  CALL   34BE
03F7E:  MOVFF  01,9C0
....................       if ((Timer == 50000) || (response > 1))    
03F82:  MOVLB  9
03F84:  MOVF   xC5,W
03F86:  SUBLW  50
03F88:  BNZ   3F90
03F8A:  MOVF   xC6,W
03F8C:  SUBLW  C3
03F8E:  BZ    3F96
03F90:  MOVF   xC0,W
03F92:  SUBLW  01
03F94:  BC    402C
....................       { 
....................          Card = None; 
03F96:  MOVLB  4
03F98:  CLRF   xE3
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
03F9A:  MOVF   1F,W
03F9C:  SUBLW  04
03F9E:  BNZ   402A
03FA0:  MOVF   20,F
03FA2:  BNZ   402A
03FA4:  MOVLW  64
03FA6:  MOVWF  FF6
03FA8:  MOVLW  0A
03FAA:  MOVWF  FF7
03FAC:  MOVLW  00
03FAE:  MOVWF  FF8
03FB0:  CLRF   1B
03FB2:  BTFSC  FF2.7
03FB4:  BSF    1B.7
03FB6:  BCF    FF2.7
03FB8:  MOVLW  2B
03FBA:  MOVLB  A
03FBC:  MOVWF  x18
03FBE:  MOVLB  0
03FC0:  CALL   1006
03FC4:  BTFSC  1B.7
03FC6:  BSF    FF2.7
03FC8:  MOVFF  9C0,9C8
03FCC:  MOVLW  57
03FCE:  MOVLB  9
03FD0:  MOVWF  xC9
03FD2:  MOVLB  0
03FD4:  CALL   358E
03FD8:  MOVLW  93
03FDA:  MOVWF  FF6
03FDC:  MOVLW  0A
03FDE:  MOVWF  FF7
03FE0:  MOVLW  00
03FE2:  MOVWF  FF8
03FE4:  CLRF   1B
03FE6:  BTFSC  FF2.7
03FE8:  BSF    1B.7
03FEA:  BCF    FF2.7
03FEC:  MOVLW  0A
03FEE:  MOVLB  A
03FF0:  MOVWF  x18
03FF2:  MOVLB  0
03FF4:  CALL   1006
03FF8:  BTFSC  1B.7
03FFA:  BSF    FF2.7
03FFC:  MOVLW  10
03FFE:  MOVWF  FE9
04000:  CLRF   1B
04002:  BTFSC  FF2.7
04004:  BSF    1B.7
04006:  BCF    FF2.7
04008:  MOVFF  9C6,A19
0400C:  MOVFF  9C5,A18
04010:  CALL   1188
04014:  BTFSC  1B.7
04016:  BSF    FF2.7
04018:  MOVLW  0D
0401A:  BTFSS  F9E.4
0401C:  BRA    401A
0401E:  MOVWF  FAD
04020:  MOVLW  0A
04022:  BTFSS  F9E.4
04024:  BRA    4022
04026:  MOVWF  FAD
04028:  MOVLB  4
0402A:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
0402C:  MOVLB  4
0402E:  MOVF   xE3,F
04030:  BNZ   4064
....................    { 
....................       if (nv_report_mode == 4) 
04032:  MOVF   1F,W
04034:  SUBLW  04
04036:  BNZ   405C
04038:  MOVF   20,F
0403A:  BNZ   405C
....................          printf("@FS:Card Type Discovery Error\r\n"); 
0403C:  MOVLW  A4
0403E:  MOVWF  FF6
04040:  MOVLW  0A
04042:  MOVWF  FF7
04044:  MOVLW  00
04046:  MOVWF  FF8
04048:  CLRF   1B
0404A:  BTFSC  FF2.7
0404C:  BSF    1B.7
0404E:  BCF    FF2.7
04050:  MOVLB  0
04052:  CALL   0E30
04056:  BTFSC  1B.7
04058:  BSF    FF2.7
0405A:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
0405C:  MOVLB  9
0405E:  BSF    xC7.0
....................       goto Exit_disk_initialize; 
04060:  BRA    4348
04062:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
04064:  MOVF   xE3,W
04066:  XORLW  02
04068:  MOVLB  0
0406A:  BZ    407A
0406C:  XORLW  01
0406E:  BZ    40A2
04070:  XORLW  07
04072:  BZ    40CA
04074:  XORLW  01
04076:  BZ    40F2
04078:  BRA    411A
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
0407A:  MOVF   1F,W
0407C:  SUBLW  04
0407E:  BNZ   40A0
04080:  MOVF   20,F
04082:  BNZ   40A0
04084:  MOVLW  C4
04086:  MOVWF  FF6
04088:  MOVLW  0A
0408A:  MOVWF  FF7
0408C:  MOVLW  00
0408E:  MOVWF  FF8
04090:  CLRF   1B
04092:  BTFSC  FF2.7
04094:  BSF    1B.7
04096:  BCF    FF2.7
04098:  CALL   0E30
0409C:  BTFSC  1B.7
0409E:  BSF    FF2.7
....................          break; 
040A0:  BRA    4170
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
040A2:  MOVF   1F,W
040A4:  SUBLW  04
040A6:  BNZ   40C8
040A8:  MOVF   20,F
040AA:  BNZ   40C8
040AC:  MOVLW  DA
040AE:  MOVWF  FF6
040B0:  MOVLW  0A
040B2:  MOVWF  FF7
040B4:  MOVLW  00
040B6:  MOVWF  FF8
040B8:  CLRF   1B
040BA:  BTFSC  FF2.7
040BC:  BSF    1B.7
040BE:  BCF    FF2.7
040C0:  CALL   0E30
040C4:  BTFSC  1B.7
040C6:  BSF    FF2.7
....................          break; 
040C8:  BRA    4170
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
040CA:  MOVF   1F,W
040CC:  SUBLW  04
040CE:  BNZ   40F0
040D0:  MOVF   20,F
040D2:  BNZ   40F0
040D4:  MOVLW  F0
040D6:  MOVWF  FF6
040D8:  MOVLW  0A
040DA:  MOVWF  FF7
040DC:  MOVLW  00
040DE:  MOVWF  FF8
040E0:  CLRF   1B
040E2:  BTFSC  FF2.7
040E4:  BSF    1B.7
040E6:  BCF    FF2.7
040E8:  CALL   0E30
040EC:  BTFSC  1B.7
040EE:  BSF    FF2.7
....................          break; 
040F0:  BRA    4170
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
040F2:  MOVF   1F,W
040F4:  SUBLW  04
040F6:  BNZ   4118
040F8:  MOVF   20,F
040FA:  BNZ   4118
040FC:  MOVLW  06
040FE:  MOVWF  FF6
04100:  MOVLW  0B
04102:  MOVWF  FF7
04104:  MOVLW  00
04106:  MOVWF  FF8
04108:  CLRF   1B
0410A:  BTFSC  FF2.7
0410C:  BSF    1B.7
0410E:  BCF    FF2.7
04110:  CALL   0E30
04114:  BTFSC  1B.7
04116:  BSF    FF2.7
....................          break; 
04118:  BRA    4170
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
0411A:  MOVF   1F,W
0411C:  SUBLW  04
0411E:  BNZ   4168
04120:  MOVF   20,F
04122:  BNZ   4168
04124:  MOVLW  1C
04126:  MOVWF  FF6
04128:  MOVLW  0B
0412A:  MOVWF  FF7
0412C:  MOVLW  00
0412E:  MOVWF  FF8
04130:  CLRF   1B
04132:  BTFSC  FF2.7
04134:  BSF    1B.7
04136:  BCF    FF2.7
04138:  MOVLW  26
0413A:  MOVLB  A
0413C:  MOVWF  x18
0413E:  MOVLB  0
04140:  CALL   1006
04144:  BTFSC  1B.7
04146:  BSF    FF2.7
04148:  MOVFF  4E3,9C8
0414C:  MOVLW  37
0414E:  MOVLB  9
04150:  MOVWF  xC9
04152:  MOVLB  0
04154:  CALL   358E
04158:  MOVLW  0D
0415A:  BTFSS  F9E.4
0415C:  BRA    415A
0415E:  MOVWF  FAD
04160:  MOVLW  0A
04162:  BTFSS  F9E.4
04164:  BRA    4162
04166:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
04168:  MOVLB  9
0416A:  BSF    xC7.0
....................          goto Exit_disk_initialize; 
0416C:  BRA    4348
0416E:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
04170:  MOVLB  9
04172:  BCF    xC7.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
04174:  MOVF   1F,W
04176:  SUBLW  04
04178:  BNZ   41D0
0417A:  MOVF   20,F
0417C:  BNZ   41D0
0417E:  MOVLW  4A
04180:  MOVWF  FF6
04182:  MOVLW  0B
04184:  MOVWF  FF7
04186:  MOVLW  00
04188:  MOVWF  FF8
0418A:  CLRF   1B
0418C:  BTFSC  FF2.7
0418E:  BSF    1B.7
04190:  BCF    FF2.7
04192:  MOVLW  2E
04194:  MOVLB  A
04196:  MOVWF  x18
04198:  MOVLB  0
0419A:  CALL   1006
0419E:  BTFSC  1B.7
041A0:  BSF    FF2.7
041A2:  MOVLW  10
041A4:  MOVWF  FE9
041A6:  CLRF   1B
041A8:  BTFSC  FF2.7
041AA:  BSF    1B.7
041AC:  BCF    FF2.7
041AE:  MOVFF  9C6,A19
041B2:  MOVFF  9C5,A18
041B6:  CALL   1188
041BA:  BTFSC  1B.7
041BC:  BSF    FF2.7
041BE:  MOVLW  0D
041C0:  BTFSS  F9E.4
041C2:  BRA    41C0
041C4:  MOVWF  FAD
041C6:  MOVLW  0A
041C8:  BTFSS  F9E.4
041CA:  BRA    41C8
041CC:  MOVWF  FAD
041CE:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
041D0:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
041D2:  BCF    FC6.5
041D4:  MOVLW  20
041D6:  MOVWF  FC6
041D8:  MOVLW  40
041DA:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
041DC:  BCF    F9E.3
....................    SelectSD; 
041DE:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
041E0:  MOVF   1F,W
041E2:  SUBLW  04
041E4:  BNZ   420A
041E6:  MOVF   20,F
041E8:  BNZ   420A
041EA:  MOVLW  7E
041EC:  MOVWF  FF6
041EE:  MOVLW  0B
041F0:  MOVWF  FF7
041F2:  MOVLW  00
041F4:  MOVWF  FF8
041F6:  CLRF   1B
041F8:  BTFSC  FF2.7
041FA:  BSF    1B.7
041FC:  BCF    FF2.7
041FE:  MOVLB  0
04200:  CALL   0E30
04204:  BTFSC  1B.7
04206:  BSF    FF2.7
04208:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
0420A:  CLRF   xC6
0420C:  CLRF   xC5
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
0420E:  MOVLW  41
04210:  MOVLB  A
04212:  MOVWF  x03
04214:  CLRF   x07
04216:  CLRF   x06
04218:  CLRF   x05
0421A:  CLRF   x04
0421C:  MOVLB  0
0421E:  CALL   34BE
04222:  MOVFF  01,9C0
....................       if (response != 0x00 ) 
04226:  MOVLB  9
04228:  MOVF   xC0,F
0422A:  BZ    4234
....................          delay_us(10); 
0422C:  MOVLW  35
0422E:  MOVWF  00
04230:  DECFSZ 00,F
04232:  BRA    4230
....................  
....................       Timer++; 
04234:  INCF   xC5,F
04236:  BTFSC  FD8.2
04238:  INCF   xC6,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
0423A:  MOVF   xC0,F
0423C:  BZ    424C
0423E:  MOVF   xC6,W
04240:  SUBLW  C3
04242:  BNC   424C
04244:  BNZ   420E
04246:  MOVF   xC5,W
04248:  SUBLW  4F
0424A:  BC    420E
....................  
....................    if (response != 0x00) 
0424C:  MOVF   xC0,F
0424E:  BZ    42E4
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
04250:  MOVF   1F,W
04252:  SUBLW  04
04254:  BNZ   42E0
04256:  MOVF   20,F
04258:  BNZ   42E0
0425A:  MOVLW  9E
0425C:  MOVWF  FF6
0425E:  MOVLW  0B
04260:  MOVWF  FF7
04262:  MOVLW  00
04264:  MOVWF  FF8
04266:  CLRF   1B
04268:  BTFSC  FF2.7
0426A:  BSF    1B.7
0426C:  BCF    FF2.7
0426E:  MOVLW  26
04270:  MOVLB  A
04272:  MOVWF  x18
04274:  MOVLB  0
04276:  CALL   1006
0427A:  BTFSC  1B.7
0427C:  BSF    FF2.7
0427E:  MOVFF  9C0,9C8
04282:  MOVLW  37
04284:  MOVLB  9
04286:  MOVWF  xC9
04288:  MOVLB  0
0428A:  CALL   358E
0428E:  MOVLW  C8
04290:  MOVWF  FF6
04292:  MOVLW  0B
04294:  MOVWF  FF7
04296:  MOVLW  00
04298:  MOVWF  FF8
0429A:  CLRF   1B
0429C:  BTFSC  FF2.7
0429E:  BSF    1B.7
042A0:  BCF    FF2.7
042A2:  MOVLW  0A
042A4:  MOVLB  A
042A6:  MOVWF  x18
042A8:  MOVLB  0
042AA:  CALL   1006
042AE:  BTFSC  1B.7
042B0:  BSF    FF2.7
042B2:  MOVLW  10
042B4:  MOVWF  FE9
042B6:  CLRF   1B
042B8:  BTFSC  FF2.7
042BA:  BSF    1B.7
042BC:  BCF    FF2.7
042BE:  MOVFF  9C6,A19
042C2:  MOVFF  9C5,A18
042C6:  CALL   1188
042CA:  BTFSC  1B.7
042CC:  BSF    FF2.7
042CE:  MOVLW  0D
042D0:  BTFSS  F9E.4
042D2:  BRA    42D0
042D4:  MOVWF  FAD
042D6:  MOVLW  0A
042D8:  BTFSS  F9E.4
042DA:  BRA    42D8
042DC:  MOVWF  FAD
042DE:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
042E0:  BSF    xC7.0
....................       goto Exit_disk_initialize; 
042E2:  BRA    4348
....................    } 
....................  
....................    if (nv_report_mode == 4) 
042E4:  MOVF   1F,W
042E6:  SUBLW  04
042E8:  BNZ   4340
042EA:  MOVF   20,F
042EC:  BNZ   4340
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
042EE:  MOVLW  D8
042F0:  MOVWF  FF6
042F2:  MOVLW  0B
042F4:  MOVWF  FF7
042F6:  MOVLW  00
042F8:  MOVWF  FF8
042FA:  CLRF   1B
042FC:  BTFSC  FF2.7
042FE:  BSF    1B.7
04300:  BCF    FF2.7
04302:  MOVLW  25
04304:  MOVLB  A
04306:  MOVWF  x18
04308:  MOVLB  0
0430A:  CALL   1006
0430E:  BTFSC  1B.7
04310:  BSF    FF2.7
04312:  MOVLW  10
04314:  MOVWF  FE9
04316:  CLRF   1B
04318:  BTFSC  FF2.7
0431A:  BSF    1B.7
0431C:  BCF    FF2.7
0431E:  MOVFF  9C6,A19
04322:  MOVFF  9C5,A18
04326:  CALL   1188
0432A:  BTFSC  1B.7
0432C:  BSF    FF2.7
0432E:  MOVLW  0D
04330:  BTFSS  F9E.4
04332:  BRA    4330
04334:  MOVWF  FAD
04336:  MOVLW  0A
04338:  BTFSS  F9E.4
0433A:  BRA    4338
0433C:  MOVWF  FAD
0433E:  MOVLB  9
....................  
....................    msg_card_ok(); 
04340:  MOVLB  0
04342:  GOTO   35D4
04346:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
04348:  BSF    F91.1
....................    return(SDCardStatus); 
0434A:  MOVFF  9C7,01
0434E:  MOVLB  0
04350:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05A0C:  MOVLW  20
05A0E:  MOVLB  7
05A10:  ADDWF  x0E,W
05A12:  MOVWF  FE9
05A14:  MOVLW  00
05A16:  ADDWFC x0F,W
05A18:  MOVWF  FEA
05A1A:  MOVFF  FEF,9F0
05A1E:  MOVFF  FEC,9F1
05A22:  MOVFF  FEC,9F2
05A26:  MOVFF  FEC,9F3
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05A2A:  MOVLB  9
05A2C:  MOVF   xEC,W
05A2E:  SUBWF  xF0,W
05A30:  BNZ   5A46
05A32:  MOVF   xED,W
05A34:  SUBWF  xF1,W
05A36:  BNZ   5A46
05A38:  MOVF   xEE,W
05A3A:  SUBWF  xF2,W
05A3C:  BNZ   5A46
05A3E:  MOVF   xEF,W
05A40:  SUBWF  xF3,W
05A42:  BTFSC  FD8.2
05A44:  BRA    5C1A
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05A46:  MOVLW  06
05A48:  MOVLB  7
05A4A:  ADDWF  x0E,W
05A4C:  MOVWF  FE9
05A4E:  MOVLW  00
05A50:  ADDWFC x0F,W
05A52:  MOVWF  FEA
05A54:  MOVF   FEF,F
05A56:  BTFSC  FD8.2
05A58:  BRA    5BA4
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05A5A:  MOVLW  24
05A5C:  ADDWF  x0E,W
05A5E:  MOVWF  01
05A60:  MOVLW  00
05A62:  ADDWFC x0F,W
05A64:  MOVWF  03
05A66:  MOVFF  01,9F6
05A6A:  MOVLB  9
05A6C:  MOVWF  xF7
05A6E:  MOVWF  xF9
05A70:  MOVFF  01,9F8
05A74:  MOVFF  9F3,9FD
05A78:  MOVFF  9F2,9FC
05A7C:  MOVFF  9F1,9FB
05A80:  MOVFF  9F0,9FA
05A84:  MOVLW  01
05A86:  MOVWF  xFE
05A88:  MOVLB  0
05A8A:  RCALL  58C2
05A8C:  MOVFF  01,9F4
....................             if (response != RES_OK) 
05A90:  MOVLB  9
05A92:  MOVF   xF4,F
05A94:  BZ    5A9C
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05A96:  MOVLW  00
05A98:  MOVWF  01
05A9A:  BRA    5C1E
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05A9C:  MOVLW  06
05A9E:  MOVLB  7
05AA0:  ADDWF  x0E,W
05AA2:  MOVWF  FE9
05AA4:  MOVLW  00
05AA6:  ADDWFC x0F,W
05AA8:  MOVWF  FEA
05AAA:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05AAC:  MOVLW  10
05AAE:  ADDWF  x0E,W
05AB0:  MOVWF  FE9
05AB2:  MOVLW  00
05AB4:  ADDWFC x0F,W
05AB6:  MOVWF  FEA
05AB8:  MOVFF  FEF,9F6
05ABC:  MOVFF  FEC,9F7
05AC0:  MOVFF  FEC,9F8
05AC4:  MOVFF  FEC,9F9
05AC8:  MOVLW  08
05ACA:  ADDWF  x0E,W
05ACC:  MOVWF  FE9
05ACE:  MOVLW  00
05AD0:  ADDWFC x0F,W
05AD2:  MOVWF  FEA
05AD4:  MOVFF  FEF,00
05AD8:  MOVFF  FEC,01
05ADC:  MOVFF  FEC,02
05AE0:  MOVFF  FEC,03
05AE4:  MOVLB  9
05AE6:  MOVF   xF6,W
05AE8:  ADDWF  00,F
05AEA:  MOVF   xF7,W
05AEC:  ADDWFC 01,F
05AEE:  MOVF   xF8,W
05AF0:  ADDWFC 02,F
05AF2:  MOVF   xF9,W
05AF4:  ADDWFC 03,F
05AF6:  MOVF   xF3,W
05AF8:  SUBWF  03,W
05AFA:  BNC   5BA2
05AFC:  BNZ   5B14
05AFE:  MOVF   xF2,W
05B00:  SUBWF  02,W
05B02:  BNC   5BA2
05B04:  BNZ   5B14
05B06:  MOVF   xF1,W
05B08:  SUBWF  01,W
05B0A:  BNC   5BA2
05B0C:  BNZ   5B14
05B0E:  MOVF   00,W
05B10:  SUBWF  xF0,W
05B12:  BC    5BA2
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05B14:  MOVLW  03
05B16:  MOVLB  7
05B18:  ADDWF  x0E,W
05B1A:  MOVWF  FE9
05B1C:  MOVLW  00
05B1E:  ADDWFC x0F,W
05B20:  MOVWF  FEA
05B22:  MOVFF  FEF,9F5
05B26:  MOVLB  9
05B28:  MOVF   xF5,W
05B2A:  SUBLW  01
05B2C:  BC    5BA2
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05B2E:  MOVLW  08
05B30:  MOVLB  7
05B32:  ADDWF  x0E,W
05B34:  MOVWF  FE9
05B36:  MOVLW  00
05B38:  ADDWFC x0F,W
05B3A:  MOVWF  FEA
05B3C:  MOVFF  FEF,00
05B40:  MOVFF  FEC,01
05B44:  MOVFF  FEC,02
05B48:  MOVFF  FEC,03
05B4C:  MOVF   00,W
05B4E:  MOVLB  9
05B50:  ADDWF  xF0,F
05B52:  MOVF   01,W
05B54:  ADDWFC xF1,F
05B56:  MOVF   02,W
05B58:  ADDWFC xF2,F
05B5A:  MOVF   03,W
05B5C:  ADDWFC xF3,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05B5E:  MOVLW  24
05B60:  MOVLB  7
05B62:  ADDWF  x0E,W
05B64:  MOVWF  01
05B66:  MOVLW  00
05B68:  ADDWFC x0F,W
05B6A:  MOVWF  03
05B6C:  MOVFF  01,9F6
05B70:  MOVLB  9
05B72:  MOVWF  xF7
05B74:  MOVWF  xF9
05B76:  MOVFF  01,9F8
05B7A:  MOVFF  9F3,9FD
05B7E:  MOVFF  9F2,9FC
05B82:  MOVFF  9F1,9FB
05B86:  MOVFF  9F0,9FA
05B8A:  MOVLW  01
05B8C:  MOVWF  xFE
05B8E:  MOVLB  0
05B90:  RCALL  58C2
05B92:  MOVF   01,F
05B94:  BZ    5B9C
....................                      break; 
05B96:  MOVLB  9
05B98:  BRA    5BA2
05B9A:  MOVLB  0
05B9C:  MOVLB  9
05B9E:  DECF   xF5,F
05BA0:  BRA    5B28
05BA2:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05BA4:  MOVLB  9
05BA6:  MOVF   xEC,F
05BA8:  BNZ   5BB6
05BAA:  MOVF   xED,F
05BAC:  BNZ   5BB6
05BAE:  MOVF   xEE,F
05BB0:  BNZ   5BB6
05BB2:  MOVF   xEF,F
05BB4:  BZ    5C1A
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05BB6:  MOVLW  24
05BB8:  MOVLB  7
05BBA:  ADDWF  x0E,W
05BBC:  MOVWF  01
05BBE:  MOVLW  00
05BC0:  ADDWFC x0F,W
05BC2:  MOVWF  03
05BC4:  MOVFF  01,9F6
05BC8:  MOVLB  9
05BCA:  MOVWF  xF7
05BCC:  MOVWF  xF9
05BCE:  MOVFF  01,9F8
05BD2:  MOVFF  9EF,9FD
05BD6:  MOVFF  9EE,9FC
05BDA:  MOVFF  9ED,9FB
05BDE:  MOVFF  9EC,9FA
05BE2:  MOVLW  01
05BE4:  MOVWF  xFE
05BE6:  MOVLB  0
05BE8:  CALL   444E
05BEC:  MOVF   01,F
05BEE:  BZ    5BFA
....................             return FALSE; 
05BF0:  MOVLW  00
05BF2:  MOVWF  01
05BF4:  MOVLB  9
05BF6:  BRA    5C1E
05BF8:  MOVLB  0
....................          fs->winsect = sector; 
05BFA:  MOVLW  20
05BFC:  MOVLB  7
05BFE:  ADDWF  x0E,W
05C00:  MOVWF  FE9
05C02:  MOVLW  00
05C04:  ADDWFC x0F,W
05C06:  MOVWF  FEA
05C08:  MOVFF  9EC,FEF
05C0C:  MOVFF  9ED,FEC
05C10:  MOVFF  9EE,FEC
05C14:  MOVFF  9EF,FEC
05C18:  MOVLB  9
....................          } 
....................       } 
....................    return (TRUE); 
05C1A:  MOVLW  01
05C1C:  MOVWF  01
05C1E:  MOVLB  0
05C20:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05C44:  MOVLB  9
05C46:  MOVF   xDB,F
05C48:  BNZ   5C5A
05C4A:  MOVF   xDA,F
05C4C:  BNZ   5C5A
05C4E:  MOVF   xD9,F
05C50:  BNZ   5C5A
05C52:  MOVF   xD8,W
05C54:  SUBLW  01
05C56:  BTFSC  FD8.0
05C58:  BRA    5F6A
05C5A:  MOVLW  0C
05C5C:  MOVLB  7
05C5E:  ADDWF  x0E,W
05C60:  MOVWF  FE9
05C62:  MOVLW  00
05C64:  ADDWFC x0F,W
05C66:  MOVWF  FEA
05C68:  MOVFF  FEF,00
05C6C:  MOVFF  FEC,01
05C70:  MOVFF  FEC,02
05C74:  MOVFF  FEC,03
05C78:  MOVLB  9
05C7A:  MOVF   xDB,W
05C7C:  SUBWF  03,W
05C7E:  BTFSS  FD8.0
05C80:  BRA    5F6A
05C82:  BNZ   5CA0
05C84:  MOVF   xDA,W
05C86:  SUBWF  02,W
05C88:  BTFSS  FD8.0
05C8A:  BRA    5F6A
05C8C:  BNZ   5CA0
05C8E:  MOVF   xD9,W
05C90:  SUBWF  01,W
05C92:  BTFSS  FD8.0
05C94:  BRA    5F6A
05C96:  BNZ   5CA0
05C98:  MOVF   00,W
05C9A:  SUBWF  xD8,W
05C9C:  BTFSC  FD8.0
05C9E:  BRA    5F6A
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05CA0:  MOVLW  10
05CA2:  MOVLB  7
05CA4:  ADDWF  x0E,W
05CA6:  MOVWF  FE9
05CA8:  MOVLW  00
05CAA:  ADDWFC x0F,W
05CAC:  MOVWF  FEA
05CAE:  MOVFF  FEF,9E0
05CB2:  MOVFF  FEC,9E1
05CB6:  MOVFF  FEC,9E2
05CBA:  MOVFF  FEC,9E3
....................       switch (fs->fs_type)  
05CBE:  MOVF   x0E,W
05CC0:  MOVWF  FE9
05CC2:  MOVF   x0F,W
05CC4:  MOVWF  FEA
05CC6:  MOVF   FEF,W
05CC8:  XORLW  01
05CCA:  MOVLB  0
05CCC:  BZ    5CDC
05CCE:  XORLW  03
05CD0:  BTFSC  FD8.2
05CD2:  BRA    5E22
05CD4:  XORLW  01
05CD6:  BTFSC  FD8.2
05CD8:  BRA    5EA4
05CDA:  BRA    5F6C
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05CDC:  MOVFF  9D9,9E9
05CE0:  MOVFF  9D8,9E8
05CE4:  MOVLB  9
05CE6:  CLRF   xEB
05CE8:  MOVLW  03
05CEA:  MOVWF  xEA
05CEC:  MOVLB  0
05CEE:  RCALL  5C22
05CF0:  BCF    FD8.0
05CF2:  MOVLB  9
05CF4:  RRCF   02,W
05CF6:  MOVWF  xDF
05CF8:  RRCF   01,W
05CFA:  MOVWF  xDE
....................             if (!move_window(fatsect + bc / 512))  
05CFC:  BCF    FD8.0
05CFE:  CLRF   03
05D00:  RRCF   xDF,W
05D02:  MOVWF  02
05D04:  ADDWF  xE0,W
05D06:  MOVWF  xE4
05D08:  MOVF   03,W
05D0A:  ADDWFC xE1,W
05D0C:  MOVWF  xE5
05D0E:  MOVLW  00
05D10:  ADDWFC xE2,W
05D12:  MOVWF  xE6
05D14:  MOVLW  00
05D16:  ADDWFC xE3,W
05D18:  MOVWF  xE7
05D1A:  MOVWF  xEF
05D1C:  MOVFF  9E6,9EE
05D20:  MOVFF  9E5,9ED
05D24:  MOVFF  9E4,9EC
05D28:  MOVLB  0
05D2A:  RCALL  5A0C
05D2C:  MOVF   01,F
05D2E:  BNZ   5D32
....................                break; 
05D30:  BRA    5F6C
....................             wc = fs->win[bc % 512]; 
05D32:  MOVLB  9
05D34:  MOVF   xDF,W
05D36:  ANDLW  01
05D38:  MOVWF  xE5
05D3A:  MOVLW  24
05D3C:  ADDWF  xDE,W
05D3E:  MOVWF  01
05D40:  MOVLW  00
05D42:  ADDWFC xE5,W
05D44:  MOVWF  03
05D46:  MOVF   01,W
05D48:  MOVLB  7
05D4A:  ADDWF  x0E,W
05D4C:  MOVWF  FE9
05D4E:  MOVF   x0F,W
05D50:  ADDWFC 03,W
05D52:  MOVWF  FEA
05D54:  MOVLB  9
05D56:  CLRF   xDD
05D58:  MOVFF  FEF,9DC
....................             bc++; 
05D5C:  INCF   xDE,F
05D5E:  BTFSC  FD8.2
05D60:  INCF   xDF,F
....................             if (!move_window(fatsect + bc / 512))  
05D62:  BCF    FD8.0
05D64:  CLRF   03
05D66:  RRCF   xDF,W
05D68:  MOVWF  02
05D6A:  ADDWF  xE0,W
05D6C:  MOVWF  xE4
05D6E:  MOVF   03,W
05D70:  ADDWFC xE1,W
05D72:  MOVWF  xE5
05D74:  MOVLW  00
05D76:  ADDWFC xE2,W
05D78:  MOVWF  xE6
05D7A:  MOVLW  00
05D7C:  ADDWFC xE3,W
05D7E:  MOVWF  xE7
05D80:  MOVWF  xEF
05D82:  MOVFF  9E6,9EE
05D86:  MOVFF  9E5,9ED
05D8A:  MOVFF  9E4,9EC
05D8E:  MOVLB  0
05D90:  RCALL  5A0C
05D92:  MOVF   01,F
05D94:  BNZ   5D98
....................                break; 
05D96:  BRA    5F6C
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05D98:  MOVLB  9
05D9A:  MOVF   xDF,W
05D9C:  ANDLW  01
05D9E:  MOVWF  xE5
05DA0:  MOVLW  24
05DA2:  ADDWF  xDE,W
05DA4:  MOVWF  01
05DA6:  MOVLW  00
05DA8:  ADDWFC xE5,W
05DAA:  MOVWF  03
05DAC:  MOVF   01,W
05DAE:  MOVLB  7
05DB0:  ADDWF  x0E,W
05DB2:  MOVWF  FE9
05DB4:  MOVF   x0F,W
05DB6:  ADDWFC 03,W
05DB8:  MOVWF  FEA
05DBA:  MOVF   FEF,W
05DBC:  MOVLB  9
05DBE:  MOVWF  xE6
05DC0:  MOVLW  00
05DC2:  IORWF  xDC,F
05DC4:  MOVF   xE6,W
05DC6:  IORWF  xDD,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05DC8:  MOVF   xD8,W
05DCA:  ANDLW  01
05DCC:  MOVWF  00
05DCE:  CLRF   01
05DD0:  CLRF   02
05DD2:  CLRF   03
05DD4:  MOVF   00,F
05DD6:  BNZ   5DE4
05DD8:  MOVF   01,F
05DDA:  BNZ   5DE4
05DDC:  MOVF   02,F
05DDE:  BNZ   5DE4
05DE0:  MOVF   03,F
05DE2:  BZ    5E0A
05DE4:  RRCF   xDD,W
05DE6:  MOVWF  03
05DE8:  RRCF   xDC,W
05DEA:  MOVWF  02
05DEC:  RRCF   03,F
05DEE:  RRCF   02,F
05DF0:  RRCF   03,F
05DF2:  RRCF   02,F
05DF4:  RRCF   03,F
05DF6:  RRCF   02,F
05DF8:  MOVLW  0F
05DFA:  ANDWF  03,F
05DFC:  MOVFF  02,00
05E00:  MOVFF  03,01
05E04:  CLRF   02
05E06:  CLRF   03
05E08:  BRA    5E1E
05E0A:  MOVFF  9DC,00
05E0E:  MOVF   xDD,W
05E10:  ANDLW  0F
05E12:  MOVWF  03
05E14:  MOVF   xDC,W
05E16:  MOVFF  03,01
05E1A:  CLRF   02
05E1C:  CLRF   03
05E1E:  BRA    5F78
05E20:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05E22:  MOVFF  9D9,00
05E26:  MOVFF  9DA,01
05E2A:  MOVFF  9DB,02
05E2E:  CLRF   03
05E30:  MOVF   00,W
05E32:  MOVLB  9
05E34:  ADDWF  xE0,W
05E36:  MOVWF  xE4
05E38:  MOVF   xDA,W
05E3A:  ADDWFC xE1,W
05E3C:  MOVWF  xE5
05E3E:  MOVF   xDB,W
05E40:  ADDWFC xE2,W
05E42:  MOVWF  xE6
05E44:  MOVF   03,W
05E46:  ADDWFC xE3,W
05E48:  MOVWF  xE7
05E4A:  MOVWF  xEF
05E4C:  MOVFF  9E6,9EE
05E50:  MOVFF  9E5,9ED
05E54:  MOVFF  9E4,9EC
05E58:  MOVLB  0
05E5A:  RCALL  5A0C
05E5C:  MOVF   01,F
05E5E:  BNZ   5E62
....................                break; 
05E60:  BRA    5F6C
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05E62:  BCF    FD8.0
05E64:  MOVLB  9
05E66:  RLCF   xD8,W
05E68:  MOVWF  xE4
05E6A:  RLCF   xD9,W
05E6C:  MOVWF  xE5
05E6E:  MOVLW  01
05E70:  ANDWF  xE5,F
05E72:  MOVLW  24
05E74:  ADDWF  xE4,W
05E76:  MOVWF  01
05E78:  MOVLW  00
05E7A:  ADDWFC xE5,W
05E7C:  MOVWF  03
05E7E:  MOVF   01,W
05E80:  MOVLB  7
05E82:  ADDWF  x0E,W
05E84:  MOVWF  01
05E86:  MOVF   x0F,W
05E88:  ADDWFC 03,F
05E8A:  MOVFF  01,FE9
05E8E:  MOVFF  03,FEA
05E92:  MOVFF  FEF,00
05E96:  MOVFF  FEC,01
05E9A:  CLRF   02
05E9C:  CLRF   03
05E9E:  MOVLB  9
05EA0:  BRA    5F78
05EA2:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05EA4:  MOVLB  9
05EA6:  RRCF   xDB,W
05EA8:  MOVWF  03
05EAA:  RRCF   xDA,W
05EAC:  MOVWF  02
05EAE:  RRCF   xD9,W
05EB0:  MOVWF  01
05EB2:  RRCF   xD8,W
05EB4:  MOVWF  00
05EB6:  RRCF   03,F
05EB8:  RRCF   02,F
05EBA:  RRCF   01,F
05EBC:  RRCF   00,F
05EBE:  RRCF   03,F
05EC0:  RRCF   02,F
05EC2:  RRCF   01,F
05EC4:  RRCF   00,F
05EC6:  RRCF   03,F
05EC8:  RRCF   02,F
05ECA:  RRCF   01,F
05ECC:  RRCF   00,F
05ECE:  RRCF   03,F
05ED0:  RRCF   02,F
05ED2:  RRCF   01,F
05ED4:  RRCF   00,F
05ED6:  RRCF   03,F
05ED8:  RRCF   02,F
05EDA:  RRCF   01,F
05EDC:  RRCF   00,F
05EDE:  RRCF   03,F
05EE0:  RRCF   02,F
05EE2:  RRCF   01,F
05EE4:  RRCF   00,F
05EE6:  MOVLW  01
05EE8:  ANDWF  03,F
05EEA:  MOVF   00,W
05EEC:  ADDWF  xE0,W
05EEE:  MOVWF  xE4
05EF0:  MOVF   01,W
05EF2:  ADDWFC xE1,W
05EF4:  MOVWF  xE5
05EF6:  MOVF   02,W
05EF8:  ADDWFC xE2,W
05EFA:  MOVWF  xE6
05EFC:  MOVF   03,W
05EFE:  ADDWFC xE3,W
05F00:  MOVWF  xE7
05F02:  MOVWF  xEF
05F04:  MOVFF  9E6,9EE
05F08:  MOVFF  9E5,9ED
05F0C:  MOVFF  9E4,9EC
05F10:  MOVLB  0
05F12:  RCALL  5A0C
05F14:  MOVF   01,F
05F16:  BNZ   5F1A
....................                break; 
05F18:  BRA    5F6C
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05F1A:  MOVLB  9
05F1C:  RLCF   xD8,W
05F1E:  MOVWF  xE4
05F20:  RLCF   xD9,W
05F22:  MOVWF  xE5
05F24:  RLCF   xE4,F
05F26:  RLCF   xE5,F
05F28:  MOVLW  FC
05F2A:  ANDWF  xE4,F
05F2C:  MOVLW  01
05F2E:  ANDWF  xE5,F
05F30:  MOVLW  24
05F32:  ADDWF  xE4,W
05F34:  MOVWF  01
05F36:  MOVLW  00
05F38:  ADDWFC xE5,W
05F3A:  MOVWF  03
05F3C:  MOVF   01,W
05F3E:  MOVLB  7
05F40:  ADDWF  x0E,W
05F42:  MOVWF  01
05F44:  MOVF   x0F,W
05F46:  ADDWFC 03,F
05F48:  MOVFF  01,FE9
05F4C:  MOVFF  03,FEA
05F50:  MOVFF  FEF,00
05F54:  MOVFF  FEC,01
05F58:  MOVFF  FEC,02
05F5C:  MOVFF  FEC,9E9
05F60:  MOVLB  9
05F62:  MOVF   xE9,W
05F64:  ANDLW  0F
05F66:  MOVWF  03
05F68:  BRA    5F78
05F6A:  MOVLB  0
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
05F6C:  MOVLW  01
05F6E:  MOVWF  00
05F70:  CLRF   01
05F72:  CLRF   02
05F74:  CLRF   03
05F76:  MOVLB  9
05F78:  MOVLB  0
05F7A:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
0653E:  MOVLW  10
06540:  MOVLB  7
06542:  ADDWF  x0E,W
06544:  MOVWF  FE9
06546:  MOVLW  00
06548:  ADDWFC x0F,W
0654A:  MOVWF  FEA
0654C:  MOVFF  FEF,9E4
06550:  MOVFF  FEC,9E5
06554:  MOVFF  FEC,9E6
06558:  MOVFF  FEC,9E7
....................    switch (fs->fs_type)  
0655C:  MOVF   x0E,W
0655E:  MOVWF  FE9
06560:  MOVF   x0F,W
06562:  MOVWF  FEA
06564:  MOVF   FEF,W
06566:  XORLW  01
06568:  MOVLB  0
0656A:  BZ    657A
0656C:  XORLW  03
0656E:  BTFSC  FD8.2
06570:  BRA    6752
06572:  XORLW  01
06574:  BTFSC  FD8.2
06576:  BRA    67D6
06578:  BRA    689E
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
0657A:  MOVFF  9D9,9E9
0657E:  MOVFF  9D8,9E8
06582:  MOVLB  9
06584:  CLRF   xEB
06586:  MOVLW  03
06588:  MOVWF  xEA
0658A:  MOVLB  0
0658C:  CALL   5C22
06590:  BCF    FD8.0
06592:  MOVLB  9
06594:  RRCF   02,W
06596:  MOVWF  xE1
06598:  RRCF   01,W
0659A:  MOVWF  xE0
....................          if (!move_window(fatsect + bc / 512)) 
0659C:  BCF    FD8.0
0659E:  CLRF   03
065A0:  RRCF   xE1,W
065A2:  MOVWF  02
065A4:  ADDWF  xE4,W
065A6:  MOVWF  xE8
065A8:  MOVF   03,W
065AA:  ADDWFC xE5,W
065AC:  MOVWF  xE9
065AE:  MOVLW  00
065B0:  ADDWFC xE6,W
065B2:  MOVWF  xEA
065B4:  MOVLW  00
065B6:  ADDWFC xE7,W
065B8:  MOVWF  xEB
065BA:  MOVWF  xEF
065BC:  MOVFF  9EA,9EE
065C0:  MOVFF  9E9,9ED
065C4:  MOVFF  9E8,9EC
065C8:  MOVLB  0
065CA:  CALL   5A0C
065CE:  MOVF   01,F
065D0:  BNZ   65D8
....................             return (FALSE); 
065D2:  MOVLW  00
065D4:  MOVWF  01
065D6:  BRA    68BC
....................          p = &fs->win[bc % 512]; 
065D8:  MOVLB  9
065DA:  MOVF   xE1,W
065DC:  ANDLW  01
065DE:  MOVWF  xE9
065E0:  MOVLW  24
065E2:  ADDWF  xE0,W
065E4:  MOVWF  01
065E6:  MOVLW  00
065E8:  ADDWFC xE9,W
065EA:  MOVWF  03
065EC:  MOVF   01,W
065EE:  MOVLB  7
065F0:  ADDWF  x0E,W
065F2:  MOVWF  01
065F4:  MOVF   x0F,W
065F6:  ADDWFC 03,F
065F8:  MOVFF  01,9E2
065FC:  MOVLB  9
065FE:  MOVFF  03,9E3
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
06602:  MOVFF  9E2,9E8
06606:  MOVFF  9E3,9E9
0660A:  MOVF   xD8,W
0660C:  ANDLW  01
0660E:  MOVWF  00
06610:  CLRF   01
06612:  CLRF   02
06614:  CLRF   03
06616:  MOVF   00,F
06618:  BNZ   6626
0661A:  MOVF   01,F
0661C:  BNZ   6626
0661E:  MOVF   02,F
06620:  BNZ   6626
06622:  MOVF   03,F
06624:  BZ    6646
06626:  MOVFF  9E3,03
0662A:  MOVFF  9E2,FE9
0662E:  MOVFF  9E3,FEA
06632:  MOVF   FEF,W
06634:  ANDLW  0F
06636:  MOVWF  xEA
06638:  SWAPF  xDC,W
0663A:  MOVWF  00
0663C:  MOVLW  F0
0663E:  ANDWF  00,F
06640:  MOVF   00,W
06642:  IORWF  xEA,W
06644:  BRA    6648
06646:  MOVF   xDC,W
06648:  MOVFF  9E9,FEA
0664C:  MOVFF  9E8,FE9
06650:  MOVWF  FEF
....................          fs->winflag = 1; 
06652:  MOVLW  06
06654:  MOVLB  7
06656:  ADDWF  x0E,W
06658:  MOVWF  FE9
0665A:  MOVLW  00
0665C:  ADDWFC x0F,W
0665E:  MOVWF  FEA
06660:  MOVLW  01
06662:  MOVWF  FEF
....................          bc++; 
06664:  MOVLB  9
06666:  INCF   xE0,F
06668:  BTFSC  FD8.2
0666A:  INCF   xE1,F
....................          if (!move_window(fatsect + bc / 512)) 
0666C:  BCF    FD8.0
0666E:  CLRF   03
06670:  RRCF   xE1,W
06672:  MOVWF  02
06674:  ADDWF  xE4,W
06676:  MOVWF  xE8
06678:  MOVF   03,W
0667A:  ADDWFC xE5,W
0667C:  MOVWF  xE9
0667E:  MOVLW  00
06680:  ADDWFC xE6,W
06682:  MOVWF  xEA
06684:  MOVLW  00
06686:  ADDWFC xE7,W
06688:  MOVWF  xEB
0668A:  MOVWF  xEF
0668C:  MOVFF  9EA,9EE
06690:  MOVFF  9E9,9ED
06694:  MOVFF  9E8,9EC
06698:  MOVLB  0
0669A:  CALL   5A0C
0669E:  MOVF   01,F
066A0:  BNZ   66A8
....................             return (FALSE); 
066A2:  MOVLW  00
066A4:  MOVWF  01
066A6:  BRA    68BC
....................          p = &fs->win[bc % 512]; 
066A8:  MOVLB  9
066AA:  MOVF   xE1,W
066AC:  ANDLW  01
066AE:  MOVWF  xE9
066B0:  MOVLW  24
066B2:  ADDWF  xE0,W
066B4:  MOVWF  01
066B6:  MOVLW  00
066B8:  ADDWFC xE9,W
066BA:  MOVWF  03
066BC:  MOVF   01,W
066BE:  MOVLB  7
066C0:  ADDWF  x0E,W
066C2:  MOVWF  01
066C4:  MOVF   x0F,W
066C6:  ADDWFC 03,F
066C8:  MOVFF  01,9E2
066CC:  MOVLB  9
066CE:  MOVFF  03,9E3
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
066D2:  MOVFF  9E2,9E8
066D6:  MOVFF  9E3,9E9
066DA:  MOVF   xD8,W
066DC:  ANDLW  01
066DE:  MOVWF  00
066E0:  CLRF   01
066E2:  CLRF   02
066E4:  CLRF   03
066E6:  MOVF   00,F
066E8:  BNZ   66F6
066EA:  MOVF   01,F
066EC:  BNZ   66F6
066EE:  MOVF   02,F
066F0:  BNZ   66F6
066F2:  MOVF   03,F
066F4:  BZ    6726
066F6:  RRCF   xDF,W
066F8:  MOVWF  03
066FA:  RRCF   xDE,W
066FC:  MOVWF  02
066FE:  RRCF   xDD,W
06700:  MOVWF  01
06702:  RRCF   xDC,W
06704:  MOVWF  00
06706:  RRCF   03,F
06708:  RRCF   02,F
0670A:  RRCF   01,F
0670C:  RRCF   00,F
0670E:  RRCF   03,F
06710:  RRCF   02,F
06712:  RRCF   01,F
06714:  RRCF   00,F
06716:  RRCF   03,F
06718:  RRCF   02,F
0671A:  RRCF   01,F
0671C:  RRCF   00,F
0671E:  MOVLW  0F
06720:  ANDWF  03,F
06722:  MOVF   00,W
06724:  BRA    6746
06726:  MOVFF  9E2,FE9
0672A:  MOVFF  9E3,FEA
0672E:  MOVF   FEF,W
06730:  ANDLW  F0
06732:  MOVWF  xEB
06734:  MOVFF  9DD,00
06738:  MOVFF  9DE,01
0673C:  MOVFF  9DF,02
06740:  MOVF   xDD,W
06742:  ANDLW  0F
06744:  IORWF  xEB,W
06746:  MOVFF  9E9,FEA
0674A:  MOVFF  9E8,FE9
0674E:  MOVWF  FEF
....................          break; 
06750:  BRA    68A6
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
06752:  MOVFF  9D9,00
06756:  MOVFF  9DA,01
0675A:  MOVFF  9DB,02
0675E:  CLRF   03
06760:  MOVF   00,W
06762:  MOVLB  9
06764:  ADDWF  xE4,W
06766:  MOVWF  xE8
06768:  MOVF   xDA,W
0676A:  ADDWFC xE5,W
0676C:  MOVWF  xE9
0676E:  MOVF   xDB,W
06770:  ADDWFC xE6,W
06772:  MOVWF  xEA
06774:  MOVF   03,W
06776:  ADDWFC xE7,W
06778:  MOVWF  xEB
0677A:  MOVWF  xEF
0677C:  MOVFF  9EA,9EE
06780:  MOVFF  9E9,9ED
06784:  MOVFF  9E8,9EC
06788:  MOVLB  0
0678A:  CALL   5A0C
0678E:  MOVF   01,F
06790:  BNZ   6798
....................             return (FALSE); 
06792:  MOVLW  00
06794:  MOVWF  01
06796:  BRA    68BC
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
06798:  BCF    FD8.0
0679A:  MOVLB  9
0679C:  RLCF   xD8,W
0679E:  MOVWF  xE8
067A0:  RLCF   xD9,W
067A2:  MOVWF  xE9
067A4:  MOVLW  01
067A6:  ANDWF  xE9,F
067A8:  MOVLW  24
067AA:  ADDWF  xE8,W
067AC:  MOVWF  01
067AE:  MOVLW  00
067B0:  ADDWFC xE9,W
067B2:  MOVWF  03
067B4:  MOVF   01,W
067B6:  MOVLB  7
067B8:  ADDWF  x0E,W
067BA:  MOVWF  01
067BC:  MOVF   x0F,W
067BE:  ADDWFC 03,F
067C0:  MOVFF  01,FE9
067C4:  MOVFF  03,FEA
067C8:  MOVFF  9DD,FEC
067CC:  MOVF   FED,F
067CE:  MOVFF  9DC,FEF
....................          break; 
067D2:  MOVLB  9
067D4:  BRA    68A6
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
067D6:  MOVLB  9
067D8:  RRCF   xDB,W
067DA:  MOVWF  03
067DC:  RRCF   xDA,W
067DE:  MOVWF  02
067E0:  RRCF   xD9,W
067E2:  MOVWF  01
067E4:  RRCF   xD8,W
067E6:  MOVWF  00
067E8:  RRCF   03,F
067EA:  RRCF   02,F
067EC:  RRCF   01,F
067EE:  RRCF   00,F
067F0:  RRCF   03,F
067F2:  RRCF   02,F
067F4:  RRCF   01,F
067F6:  RRCF   00,F
067F8:  RRCF   03,F
067FA:  RRCF   02,F
067FC:  RRCF   01,F
067FE:  RRCF   00,F
06800:  RRCF   03,F
06802:  RRCF   02,F
06804:  RRCF   01,F
06806:  RRCF   00,F
06808:  RRCF   03,F
0680A:  RRCF   02,F
0680C:  RRCF   01,F
0680E:  RRCF   00,F
06810:  RRCF   03,F
06812:  RRCF   02,F
06814:  RRCF   01,F
06816:  RRCF   00,F
06818:  MOVLW  01
0681A:  ANDWF  03,F
0681C:  MOVF   00,W
0681E:  ADDWF  xE4,W
06820:  MOVWF  xE8
06822:  MOVF   01,W
06824:  ADDWFC xE5,W
06826:  MOVWF  xE9
06828:  MOVF   02,W
0682A:  ADDWFC xE6,W
0682C:  MOVWF  xEA
0682E:  MOVF   03,W
06830:  ADDWFC xE7,W
06832:  MOVWF  xEB
06834:  MOVWF  xEF
06836:  MOVFF  9EA,9EE
0683A:  MOVFF  9E9,9ED
0683E:  MOVFF  9E8,9EC
06842:  MOVLB  0
06844:  CALL   5A0C
06848:  MOVF   01,F
0684A:  BNZ   6852
....................             return (FALSE); 
0684C:  MOVLW  00
0684E:  MOVWF  01
06850:  BRA    68BC
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
06852:  MOVLB  9
06854:  RLCF   xD8,W
06856:  MOVWF  xE8
06858:  RLCF   xD9,W
0685A:  MOVWF  xE9
0685C:  RLCF   xE8,F
0685E:  RLCF   xE9,F
06860:  MOVLW  FC
06862:  ANDWF  xE8,F
06864:  MOVLW  01
06866:  ANDWF  xE9,F
06868:  MOVLW  24
0686A:  ADDWF  xE8,W
0686C:  MOVWF  01
0686E:  MOVLW  00
06870:  ADDWFC xE9,W
06872:  MOVWF  03
06874:  MOVF   01,W
06876:  MOVLB  7
06878:  ADDWF  x0E,W
0687A:  MOVWF  01
0687C:  MOVF   x0F,W
0687E:  ADDWFC 03,F
06880:  MOVFF  01,FE9
06884:  MOVFF  03,FEA
06888:  MOVFF  9DC,FEF
0688C:  MOVFF  9DD,FEC
06890:  MOVFF  9DE,FEC
06894:  MOVFF  9DF,FEC
....................          break; 
06898:  MOVLB  9
0689A:  BRA    68A6
0689C:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
0689E:  MOVLW  00
068A0:  MOVWF  01
068A2:  BRA    68BC
068A4:  MOVLB  9
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
068A6:  MOVLW  06
068A8:  MOVLB  7
068AA:  ADDWF  x0E,W
068AC:  MOVWF  FE9
068AE:  MOVLW  00
068B0:  ADDWFC x0F,W
068B2:  MOVWF  FEA
068B4:  MOVLW  01
068B6:  MOVWF  FEF
....................    return (TRUE); 
068B8:  MOVWF  01
068BA:  MOVLB  0
068BC:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06E98:  MOVFF  9BA,9DB
06E9C:  MOVFF  9B9,9DA
06EA0:  MOVFF  9B8,9D9
06EA4:  MOVFF  9B7,9D8
06EA8:  CALL   5C44
06EAC:  MOVFF  03,9BE
06EB0:  MOVFF  02,9BD
06EB4:  MOVFF  01,9BC
06EB8:  MOVFF  00,9BB
06EBC:  MOVLB  9
06EBE:  MOVF   xBE,F
06EC0:  BNZ   6ED0
06EC2:  MOVF   xBD,F
06EC4:  BNZ   6ED0
06EC6:  MOVF   xBC,F
06EC8:  BNZ   6ED0
06ECA:  MOVF   xBB,W
06ECC:  SUBLW  01
06ECE:  BC    6F30
....................       { 
....................       if (!put_cluster(clust, 0)) 
06ED0:  MOVFF  9BA,9DB
06ED4:  MOVFF  9B9,9DA
06ED8:  MOVFF  9B8,9D9
06EDC:  MOVFF  9B7,9D8
06EE0:  CLRF   xDF
06EE2:  CLRF   xDE
06EE4:  CLRF   xDD
06EE6:  CLRF   xDC
06EE8:  MOVLB  0
06EEA:  CALL   653E
06EEE:  MOVF   01,F
06EF0:  BNZ   6EF8
....................          return FALSE; 
06EF2:  MOVLW  00
06EF4:  MOVWF  01
06EF6:  BRA    6F36
....................       clust = nxt; 
06EF8:  MOVFF  9BE,9BA
06EFC:  MOVFF  9BD,9B9
06F00:  MOVFF  9BC,9B8
06F04:  MOVFF  9BB,9B7
06F08:  MOVFF  9BA,9DB
06F0C:  MOVFF  9B9,9DA
06F10:  MOVFF  9B8,9D9
06F14:  MOVFF  9B7,9D8
06F18:  CALL   5C44
06F1C:  MOVFF  03,9BE
06F20:  MOVFF  02,9BD
06F24:  MOVFF  01,9BC
06F28:  MOVFF  00,9BB
06F2C:  BRA    6EBC
06F2E:  MOVLB  9
....................       } 
....................    return TRUE; 
06F30:  MOVLW  01
06F32:  MOVWF  01
06F34:  MOVLB  0
06F36:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
068BE:  MOVLW  0C
068C0:  MOVLB  7
068C2:  ADDWF  x0E,W
068C4:  MOVWF  FE9
068C6:  MOVLW  00
068C8:  ADDWFC x0F,W
068CA:  MOVWF  FEA
068CC:  MOVFF  FEF,9D4
068D0:  MOVFF  FEC,9D5
068D4:  MOVFF  FEC,9D6
068D8:  MOVFF  FEC,9D7
....................    if (clust == 0)  
068DC:  MOVLB  9
068DE:  MOVF   xC4,F
068E0:  BNZ   694A
068E2:  MOVF   xC5,F
068E4:  BNZ   694A
068E6:  MOVF   xC6,F
068E8:  BNZ   694A
068EA:  MOVF   xC7,F
068EC:  BNZ   694A
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
068EE:  MOVLW  1C
068F0:  MOVLB  7
068F2:  ADDWF  x0E,W
068F4:  MOVWF  FE9
068F6:  MOVLW  00
068F8:  ADDWFC x0F,W
068FA:  MOVWF  FEA
068FC:  MOVFF  FEF,9D0
06900:  MOVFF  FEC,9D1
06904:  MOVFF  FEC,9D2
06908:  MOVFF  FEC,9D3
....................       if (scl < 2 || scl >= mcl) scl = 1; 
0690C:  MOVLB  9
0690E:  MOVF   xD3,F
06910:  BNZ   6920
06912:  MOVF   xD2,F
06914:  BNZ   6920
06916:  MOVF   xD1,F
06918:  BNZ   6920
0691A:  MOVF   xD0,W
0691C:  SUBLW  01
0691E:  BC    693E
06920:  MOVF   xD7,W
06922:  SUBWF  xD3,W
06924:  BNC   6948
06926:  BNZ   693E
06928:  MOVF   xD6,W
0692A:  SUBWF  xD2,W
0692C:  BNC   6948
0692E:  BNZ   693E
06930:  MOVF   xD5,W
06932:  SUBWF  xD1,W
06934:  BNC   6948
06936:  BNZ   693E
06938:  MOVF   xD4,W
0693A:  SUBWF  xD0,W
0693C:  BNC   6948
0693E:  CLRF   xD3
06940:  CLRF   xD2
06942:  CLRF   xD1
06944:  MOVLW  01
06946:  MOVWF  xD0
....................       } 
06948:  BRA    69CE
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
0694A:  MOVFF  9C7,9DB
0694E:  MOVFF  9C6,9DA
06952:  MOVFF  9C5,9D9
06956:  MOVFF  9C4,9D8
0695A:  MOVLB  0
0695C:  CALL   5C44
06960:  MOVFF  03,9CB
06964:  MOVFF  02,9CA
06968:  MOVFF  01,9C9
0696C:  MOVFF  00,9C8
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06970:  MOVLB  9
06972:  MOVF   xCB,F
06974:  BNZ   698E
06976:  MOVF   xCA,F
06978:  BNZ   698E
0697A:  MOVF   xC9,F
0697C:  BNZ   698E
0697E:  MOVF   xC8,W
06980:  SUBLW  01
06982:  BNC   698E
06984:  CLRF   00
06986:  CLRF   01
06988:  CLRF   02
0698A:  CLRF   03
0698C:  BRA    6B50
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
0698E:  MOVF   xCB,W
06990:  SUBWF  xD7,W
06992:  BNC   69BE
06994:  BNZ   69AC
06996:  MOVF   xCA,W
06998:  SUBWF  xD6,W
0699A:  BNC   69BE
0699C:  BNZ   69AC
0699E:  MOVF   xC9,W
069A0:  SUBWF  xD5,W
069A2:  BNC   69BE
069A4:  BNZ   69AC
069A6:  MOVF   xD4,W
069A8:  SUBWF  xC8,W
069AA:  BC    69BE
069AC:  MOVFF  9C8,00
069B0:  MOVFF  9C9,01
069B4:  MOVFF  9CA,02
069B8:  MOVFF  9CB,03
069BC:  BRA    6B50
....................       scl = clust; 
069BE:  MOVFF  9C7,9D3
069C2:  MOVFF  9C6,9D2
069C6:  MOVFF  9C5,9D1
069CA:  MOVFF  9C4,9D0
....................       } 
....................       ncl = scl;                  // Scan start cluster 
069CE:  MOVFF  9D3,9CF
069D2:  MOVFF  9D2,9CE
069D6:  MOVFF  9D1,9CD
069DA:  MOVFF  9D0,9CC
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
069DE:  MOVLW  01
069E0:  ADDWF  xCC,F
069E2:  BTFSC  FD8.0
069E4:  INCF   xCD,F
069E6:  BTFSC  FD8.2
069E8:  INCF   xCE,F
069EA:  BTFSC  FD8.2
069EC:  INCF   xCF,F
....................       if (ncl >= mcl)  
069EE:  MOVF   xD7,W
069F0:  SUBWF  xCF,W
069F2:  BNC   6A30
069F4:  BNZ   6A0C
069F6:  MOVF   xD6,W
069F8:  SUBWF  xCE,W
069FA:  BNC   6A30
069FC:  BNZ   6A0C
069FE:  MOVF   xD5,W
06A00:  SUBWF  xCD,W
06A02:  BNC   6A30
06A04:  BNZ   6A0C
06A06:  MOVF   xD4,W
06A08:  SUBWF  xCC,W
06A0A:  BNC   6A30
....................          {         // Wrap around 
....................          ncl = 2; 
06A0C:  CLRF   xCF
06A0E:  CLRF   xCE
06A10:  CLRF   xCD
06A12:  MOVLW  02
06A14:  MOVWF  xCC
....................          if (scl == 1) return 0;      // No free custer was found 
06A16:  DECFSZ xD0,W
06A18:  BRA    6A30
06A1A:  MOVF   xD1,F
06A1C:  BNZ   6A30
06A1E:  MOVF   xD2,F
06A20:  BNZ   6A30
06A22:  MOVF   xD3,F
06A24:  BNZ   6A30
06A26:  CLRF   00
06A28:  CLRF   01
06A2A:  CLRF   02
06A2C:  CLRF   03
06A2E:  BRA    6B50
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06A30:  MOVF   xD0,W
06A32:  SUBWF  xCC,W
06A34:  BNZ   6A52
06A36:  MOVF   xD1,W
06A38:  SUBWF  xCD,W
06A3A:  BNZ   6A52
06A3C:  MOVF   xD2,W
06A3E:  SUBWF  xCE,W
06A40:  BNZ   6A52
06A42:  MOVF   xD3,W
06A44:  SUBWF  xCF,W
06A46:  BNZ   6A52
06A48:  CLRF   00
06A4A:  CLRF   01
06A4C:  CLRF   02
06A4E:  CLRF   03
06A50:  BRA    6B50
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06A52:  MOVFF  9CF,9DB
06A56:  MOVFF  9CE,9DA
06A5A:  MOVFF  9CD,9D9
06A5E:  MOVFF  9CC,9D8
06A62:  MOVLB  0
06A64:  CALL   5C44
06A68:  MOVFF  03,9CB
06A6C:  MOVFF  02,9CA
06A70:  MOVFF  01,9C9
06A74:  MOVFF  00,9C8
....................       if (cstat == 1) return 0;      // Any error occured 
06A78:  MOVLB  9
06A7A:  DECFSZ xC8,W
06A7C:  BRA    6A94
06A7E:  MOVF   xC9,F
06A80:  BNZ   6A94
06A82:  MOVF   xCA,F
06A84:  BNZ   6A94
06A86:  MOVF   xCB,F
06A88:  BNZ   6A94
06A8A:  CLRF   00
06A8C:  CLRF   01
06A8E:  CLRF   02
06A90:  CLRF   03
06A92:  BRA    6B50
....................       } while (cstat);            // Repeat until find a free cluster 
06A94:  MOVF   xC8,F
06A96:  BNZ   69DE
06A98:  MOVF   xC9,F
06A9A:  BNZ   69DE
06A9C:  MOVF   xCA,F
06A9E:  BNZ   69DE
06AA0:  MOVF   xCB,F
06AA2:  BNZ   69DE
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06AA4:  MOVFF  9CF,9DB
06AA8:  MOVFF  9CE,9DA
06AAC:  MOVFF  9CD,9D9
06AB0:  MOVFF  9CC,9D8
06AB4:  MOVLW  0F
06AB6:  MOVWF  xDF
06AB8:  SETF   xDE
06ABA:  SETF   xDD
06ABC:  SETF   xDC
06ABE:  MOVLB  0
06AC0:  RCALL  653E
06AC2:  MOVF   01,F
06AC4:  BNZ   6AD4
06AC6:  CLRF   00
06AC8:  CLRF   01
06ACA:  CLRF   02
06ACC:  CLRF   03
06ACE:  MOVLB  9
06AD0:  BRA    6B50
06AD2:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06AD4:  MOVLB  9
06AD6:  MOVF   xC4,F
06AD8:  BNZ   6AE6
06ADA:  MOVF   xC5,F
06ADC:  BNZ   6AE6
06ADE:  MOVF   xC6,F
06AE0:  BNZ   6AE6
06AE2:  MOVF   xC7,F
06AE4:  BZ    6B20
06AE6:  MOVFF  9C7,9DB
06AEA:  MOVFF  9C6,9DA
06AEE:  MOVFF  9C5,9D9
06AF2:  MOVFF  9C4,9D8
06AF6:  MOVFF  9CF,9DF
06AFA:  MOVFF  9CE,9DE
06AFE:  MOVFF  9CD,9DD
06B02:  MOVFF  9CC,9DC
06B06:  MOVLB  0
06B08:  RCALL  653E
06B0A:  MOVF   01,F
06B0C:  BTFSC  FD8.2
06B0E:  BRA    6B14
06B10:  MOVLB  9
06B12:  BRA    6B20
06B14:  CLRF   00
06B16:  CLRF   01
06B18:  CLRF   02
06B1A:  CLRF   03
06B1C:  MOVLB  9
06B1E:  BRA    6B50
....................    fs->last_clust = ncl; 
06B20:  MOVLW  1C
06B22:  MOVLB  7
06B24:  ADDWF  x0E,W
06B26:  MOVWF  FE9
06B28:  MOVLW  00
06B2A:  ADDWFC x0F,W
06B2C:  MOVWF  FEA
06B2E:  MOVFF  9CC,FEF
06B32:  MOVFF  9CD,FEC
06B36:  MOVFF  9CE,FEC
06B3A:  MOVFF  9CF,FEC
....................  
....................    return ncl;      // Return new cluster number 
06B3E:  MOVFF  9CC,00
06B42:  MOVFF  9CD,01
06B46:  MOVFF  9CE,02
06B4A:  MOVFF  9CF,03
06B4E:  MOVLB  9
06B50:  MOVLB  0
06B52:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
05588:  MOVLW  02
0558A:  MOVLB  9
0558C:  SUBWF  xCB,F
0558E:  MOVLW  00
05590:  SUBWFB xCC,F
05592:  SUBWFB xCD,F
05594:  SUBWFB xCE,F
....................    if (clust >= fs->max_clust)  
05596:  MOVLW  0C
05598:  MOVLB  7
0559A:  ADDWF  x0E,W
0559C:  MOVWF  FE9
0559E:  MOVLW  00
055A0:  ADDWFC x0F,W
055A2:  MOVWF  FEA
055A4:  MOVFF  FEF,00
055A8:  MOVFF  FEC,01
055AC:  MOVFF  FEC,02
055B0:  MOVFF  FEC,03
055B4:  MOVF   03,W
055B6:  MOVLB  9
055B8:  SUBWF  xCE,W
055BA:  BNC   55DE
055BC:  BNZ   55D4
055BE:  MOVF   02,W
055C0:  SUBWF  xCD,W
055C2:  BNC   55DE
055C4:  BNZ   55D4
055C6:  MOVF   01,W
055C8:  SUBWF  xCC,W
055CA:  BNC   55DE
055CC:  BNZ   55D4
055CE:  MOVF   00,W
055D0:  SUBWF  xCB,W
055D2:  BNC   55DE
....................       return 0;      // Invalid cluster#  
055D4:  CLRF   00
055D6:  CLRF   01
055D8:  CLRF   02
055DA:  CLRF   03
055DC:  BRA    565E
....................    return (clust * fs->sects_clust + fs->database); 
055DE:  MOVLW  02
055E0:  MOVLB  7
055E2:  ADDWF  x0E,W
055E4:  MOVWF  FE9
055E6:  MOVLW  00
055E8:  ADDWFC x0F,W
055EA:  MOVWF  FEA
055EC:  MOVFF  FEF,9D6
055F0:  MOVLB  9
055F2:  MOVFF  FEA,9D1
055F6:  MOVFF  FE9,9D0
055FA:  MOVFF  9CE,9D5
055FE:  MOVFF  9CD,9D4
05602:  MOVFF  9CC,9D3
05606:  MOVFF  9CB,9D2
0560A:  CLRF   xD9
0560C:  CLRF   xD8
0560E:  CLRF   xD7
05610:  MOVLB  0
05612:  CALL   4778
05616:  MOVFF  9D1,FEA
0561A:  MOVFF  9D0,FE9
0561E:  MOVFF  03,9D2
05622:  MOVFF  02,9D1
05626:  MOVFF  01,9D0
0562A:  MOVFF  00,9CF
0562E:  MOVLW  18
05630:  MOVLB  7
05632:  ADDWF  x0E,W
05634:  MOVWF  FE9
05636:  MOVLW  00
05638:  ADDWFC x0F,W
0563A:  MOVWF  FEA
0563C:  MOVFF  FEF,00
05640:  MOVFF  FEC,01
05644:  MOVFF  FEC,02
05648:  MOVFF  FEC,03
0564C:  MOVLB  9
0564E:  MOVF   xCF,W
05650:  ADDWF  00,F
05652:  MOVF   xD0,W
05654:  ADDWFC 01,F
05656:  MOVF   xD1,W
05658:  ADDWFC 02,F
0565A:  MOVF   xD2,W
0565C:  ADDWFC 03,F
0565E:  MOVLB  0
05660:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
0461C:  MOVLW  24
0461E:  MOVLB  7
04620:  ADDWF  x0E,W
04622:  MOVWF  01
04624:  MOVLW  00
04626:  ADDWFC x0F,W
04628:  MOVWF  03
0462A:  MOVFF  01,9C3
0462E:  MOVLB  9
04630:  MOVWF  xC4
04632:  MOVWF  FEA
04634:  MOVFF  01,FE9
04638:  CLRF   00
0463A:  MOVLW  02
0463C:  MOVWF  02
0463E:  CLRF   01
04640:  MOVLB  0
04642:  CALL   34A4
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
04646:  MOVLW  24
04648:  MOVLB  7
0464A:  ADDWF  x0E,W
0464C:  MOVWF  01
0464E:  MOVLW  00
04650:  ADDWFC x0F,W
04652:  MOVWF  03
04654:  MOVFF  01,9C3
04658:  MOVLB  9
0465A:  MOVWF  xC4
0465C:  MOVWF  xF9
0465E:  MOVFF  01,9F8
04662:  MOVFF  9C2,9FD
04666:  MOVFF  9C1,9FC
0466A:  MOVFF  9C0,9FB
0466E:  MOVFF  9BF,9FA
04672:  MOVLW  01
04674:  MOVWF  xFE
04676:  MOVLB  0
04678:  RCALL  444E
0467A:  MOVF   01,F
0467C:  BTFSS  FD8.2
0467E:  BRA    476E
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
04680:  MOVLW  22
04682:  MOVLB  7
04684:  ADDWF  x0E,W
04686:  MOVWF  01
04688:  MOVLW  02
0468A:  ADDWFC x0F,W
0468C:  MOVWF  03
0468E:  MOVFF  01,FE9
04692:  MOVWF  FEA
04694:  MOVFF  FEC,9C4
04698:  MOVF   FED,F
0469A:  MOVFF  FEF,9C3
0469E:  MOVLB  9
046A0:  MOVF   xC3,W
046A2:  SUBLW  55
046A4:  BNZ   4770
046A6:  MOVF   xC4,W
046A8:  SUBLW  AA
046AA:  BNZ   4770
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
046AC:  MOVLW  5A
046AE:  MOVLB  7
046B0:  ADDWF  x0E,W
046B2:  MOVWF  01
046B4:  MOVLW  00
046B6:  ADDWFC x0F,W
046B8:  MOVWF  03
046BA:  MOVFF  01,9C3
046BE:  MOVLB  9
046C0:  MOVWF  xC4
046C2:  MOVWF  xC6
046C4:  MOVFF  01,9C5
046C8:  MOVLW  07
046CA:  MOVWF  xC8
046CC:  MOVLW  10
046CE:  MOVWF  xC7
046D0:  CLRF   xCA
046D2:  MOVLW  05
046D4:  MOVWF  xC9
046D6:  MOVLB  0
046D8:  RCALL  4598
046DA:  MOVF   01,F
046DC:  BNZ   46E4
....................             return (FS_FAT12); 
046DE:  MOVLW  01
046E0:  MOVWF  01
046E2:  BRA    4776
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
046E4:  MOVLW  5A
046E6:  MOVLB  7
046E8:  ADDWF  x0E,W
046EA:  MOVWF  01
046EC:  MOVLW  00
046EE:  ADDWFC x0F,W
046F0:  MOVWF  03
046F2:  MOVFF  01,9C3
046F6:  MOVLB  9
046F8:  MOVWF  xC4
046FA:  MOVWF  xC6
046FC:  MOVFF  01,9C5
04700:  MOVLW  07
04702:  MOVWF  xC8
04704:  MOVLW  15
04706:  MOVWF  xC7
04708:  CLRF   xCA
0470A:  MOVLW  05
0470C:  MOVWF  xC9
0470E:  MOVLB  0
04710:  RCALL  4598
04712:  MOVF   01,F
04714:  BNZ   471C
....................             return (FS_FAT16); 
04716:  MOVLW  02
04718:  MOVWF  01
0471A:  BRA    4776
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
0471C:  MOVLW  76
0471E:  MOVLB  7
04720:  ADDWF  x0E,W
04722:  MOVWF  01
04724:  MOVLW  00
04726:  ADDWFC x0F,W
04728:  MOVWF  03
0472A:  MOVFF  01,9C3
0472E:  MOVLB  9
04730:  MOVWF  xC4
04732:  MOVWF  xC6
04734:  MOVFF  01,9C5
04738:  MOVLW  07
0473A:  MOVWF  xC8
0473C:  MOVLW  1A
0473E:  MOVWF  xC7
04740:  CLRF   xCA
04742:  MOVLW  05
04744:  MOVWF  xC9
04746:  MOVLB  0
04748:  RCALL  4598
0474A:  MOVF   01,F
0474C:  BNZ   476E
0474E:  MOVLW  4C
04750:  MOVLB  7
04752:  ADDWF  x0E,W
04754:  MOVWF  FE9
04756:  MOVLW  00
04758:  ADDWFC x0F,W
0475A:  MOVWF  FEA
0475C:  MOVF   FEF,F
0475E:  BTFSC  FD8.2
04760:  BRA    4766
04762:  MOVLB  0
04764:  BRA    476E
....................             return (FS_FAT32); 
04766:  MOVLW  03
04768:  MOVWF  01
0476A:  MOVLB  0
0476C:  BRA    4776
0476E:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
04770:  MOVLW  00
04772:  MOVWF  01
04774:  MOVLB  0
04776:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
05F7C:  MOVLW  0C
05F7E:  MOVLB  9
05F80:  ADDWF  xC1,W
05F82:  MOVWF  FE9
05F84:  MOVLW  00
05F86:  ADDWFC xC2,W
05F88:  MOVWF  FEA
05F8A:  MOVFF  FEC,9CA
05F8E:  MOVF   FED,F
05F90:  MOVFF  FEF,9C9
05F94:  MOVLW  01
05F96:  ADDWF  xC9,W
05F98:  MOVWF  xC7
05F9A:  MOVLW  00
05F9C:  ADDWFC xCA,W
05F9E:  MOVWF  xC8
....................    if ((idx & 15) == 0)  
05FA0:  MOVF   xC7,W
05FA2:  ANDLW  0F
05FA4:  MOVWF  xC9
05FA6:  CLRF   xCA
05FA8:  MOVF   xC9,F
05FAA:  BTFSS  FD8.2
05FAC:  BRA    6138
05FAE:  MOVF   xCA,F
05FB0:  BTFSS  FD8.2
05FB2:  BRA    6138
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
05FB4:  MOVLW  08
05FB6:  ADDWF  xC1,W
05FB8:  MOVWF  FE9
05FBA:  MOVLW  00
05FBC:  ADDWFC xC2,W
05FBE:  MOVWF  FEA
05FC0:  MOVLW  01
05FC2:  ADDWF  FEE,F
05FC4:  MOVLW  00
05FC6:  ADDWFC FEE,F
05FC8:  ADDWFC FEE,F
05FCA:  ADDWFC FED,F
....................       if (!scan->clust)  
05FCC:  MOVLW  04
05FCE:  ADDWF  xC1,W
05FD0:  MOVWF  FE9
05FD2:  MOVLW  00
05FD4:  ADDWFC xC2,W
05FD6:  MOVWF  FEA
05FD8:  MOVF   FEF,F
05FDA:  BNZ   6018
05FDC:  MOVF   FEC,F
05FDE:  BNZ   6018
05FE0:  MOVF   FEC,F
05FE2:  BNZ   6018
05FE4:  MOVF   FEC,F
05FE6:  BNZ   6018
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
05FE8:  MOVLW  04
05FEA:  MOVLB  7
05FEC:  ADDWF  x0E,W
05FEE:  MOVWF  FE9
05FF0:  MOVLW  00
05FF2:  ADDWFC x0F,W
05FF4:  MOVWF  FEA
05FF6:  MOVFF  FEC,03
05FFA:  MOVF   FED,F
05FFC:  MOVFF  FEF,01
06000:  MOVF   03,W
06002:  MOVLB  9
06004:  SUBWF  xC8,W
06006:  BNC   6016
06008:  BNZ   6010
0600A:  MOVF   01,W
0600C:  SUBWF  xC7,W
0600E:  BNC   6016
....................             return (FALSE);   // Reached to end of table  
06010:  MOVLW  00
06012:  MOVWF  01
06014:  BRA    6152
....................          }  
06016:  BRA    6138
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
06018:  RRCF   xC8,W
0601A:  MOVWF  xCA
0601C:  RRCF   xC7,W
0601E:  MOVWF  xC9
06020:  RRCF   xCA,F
06022:  RRCF   xC9,F
06024:  RRCF   xCA,F
06026:  RRCF   xC9,F
06028:  RRCF   xCA,F
0602A:  RRCF   xC9,F
0602C:  MOVLW  0F
0602E:  ANDWF  xCA,F
06030:  MOVLW  02
06032:  MOVLB  7
06034:  ADDWF  x0E,W
06036:  MOVWF  FE9
06038:  MOVLW  00
0603A:  ADDWFC x0F,W
0603C:  MOVWF  FEA
0603E:  MOVLW  01
06040:  SUBWF  FEF,W
06042:  MOVLB  9
06044:  ANDWF  xC9,F
06046:  CLRF   xCA
06048:  MOVF   xC9,F
0604A:  BTFSS  FD8.2
0604C:  BRA    6138
0604E:  MOVF   xCA,F
06050:  BTFSS  FD8.2
06052:  BRA    6138
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
06054:  MOVLW  04
06056:  ADDWF  xC1,W
06058:  MOVWF  FE9
0605A:  MOVLW  00
0605C:  ADDWFC xC2,W
0605E:  MOVWF  FEA
06060:  MOVFF  FEF,9D8
06064:  MOVFF  FEC,9D9
06068:  MOVFF  FEC,9DA
0606C:  MOVFF  FEC,9DB
06070:  MOVLB  0
06072:  RCALL  5C44
06074:  MOVFF  03,9C6
06078:  MOVFF  02,9C5
0607C:  MOVFF  01,9C4
06080:  MOVFF  00,9C3
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06084:  MOVLW  0C
06086:  MOVLB  7
06088:  ADDWF  x0E,W
0608A:  MOVWF  FE9
0608C:  MOVLW  00
0608E:  ADDWFC x0F,W
06090:  MOVWF  FEA
06092:  MOVFF  FEF,00
06096:  MOVFF  FEC,01
0609A:  MOVFF  FEC,02
0609E:  MOVFF  FEC,03
060A2:  MOVF   03,W
060A4:  MOVLB  9
060A6:  SUBWF  xC6,W
060A8:  BNC   60C2
060AA:  BNZ   60D4
060AC:  MOVF   02,W
060AE:  SUBWF  xC5,W
060B0:  BNC   60C2
060B2:  BNZ   60D4
060B4:  MOVF   01,W
060B6:  SUBWF  xC4,W
060B8:  BNC   60C2
060BA:  BNZ   60D4
060BC:  MOVF   00,W
060BE:  SUBWF  xC3,W
060C0:  BC    60D4
060C2:  MOVF   xC6,F
060C4:  BNZ   60DA
060C6:  MOVF   xC5,F
060C8:  BNZ   60DA
060CA:  MOVF   xC4,F
060CC:  BNZ   60DA
060CE:  MOVF   xC3,W
060D0:  SUBLW  01
060D2:  BNC   60DA
....................                return (FALSE); 
060D4:  MOVLW  00
060D6:  MOVWF  01
060D8:  BRA    6152
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
060DA:  MOVLW  04
060DC:  ADDWF  xC1,W
060DE:  MOVWF  FE9
060E0:  MOVLW  00
060E2:  ADDWFC xC2,W
060E4:  MOVWF  FEA
060E6:  MOVFF  9C3,FEF
060EA:  MOVFF  9C4,FEC
060EE:  MOVFF  9C5,FEC
060F2:  MOVFF  9C6,FEC
....................             scan->sect = clust2sect(clust); 
060F6:  MOVLW  08
060F8:  ADDWF  xC1,W
060FA:  MOVWF  01
060FC:  MOVLW  00
060FE:  ADDWFC xC2,W
06100:  MOVWF  03
06102:  MOVFF  01,9C9
06106:  MOVWF  xCA
06108:  MOVFF  9C6,9CE
0610C:  MOVFF  9C5,9CD
06110:  MOVFF  9C4,9CC
06114:  MOVFF  9C3,9CB
06118:  MOVLB  0
0611A:  CALL   5588
0611E:  MOVFF  9CA,FEA
06122:  MOVFF  9C9,FE9
06126:  MOVFF  00,FEF
0612A:  MOVFF  01,FEC
0612E:  MOVFF  02,FEC
06132:  MOVFF  03,FEC
06136:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
06138:  MOVLW  0C
0613A:  ADDWF  xC1,W
0613C:  MOVWF  FE9
0613E:  MOVLW  00
06140:  ADDWFC xC2,W
06142:  MOVWF  FEA
06144:  MOVFF  9C8,FEC
06148:  MOVF   FED,F
0614A:  MOVFF  9C7,FEF
....................    return (TRUE); 
0614E:  MOVLW  01
06150:  MOVWF  01
06152:  MOVLB  0
06154:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
05662:  MOVFF  9C4,FEA
05666:  MOVFF  9C3,FE9
0566A:  MOVLW  20
0566C:  MOVWF  00
0566E:  CLRF   02
05670:  MOVLW  0B
05672:  MOVWF  01
05674:  CALL   34A4
....................    a = 0; b = 0x18;            // NT flag 
05678:  MOVLB  9
0567A:  CLRF   xC8
0567C:  MOVLW  18
0567E:  MOVWF  xC9
....................    n = 0; t = 8; 
05680:  CLRF   xC5
05682:  MOVLW  08
05684:  MOVWF  xC6
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
05686:  MOVFF  9C1,FE9
0568A:  MOVFF  9C2,FEA
0568E:  MOVFF  FEC,9CB
05692:  MOVF   FED,F
05694:  MOVFF  FEF,9CA
....................       c = *ptr; 
05698:  MOVFF  9CA,FE9
0569C:  MOVFF  9CB,FEA
056A0:  MOVFF  FEF,9C7
....................       (*path)++; 
056A4:  MOVFF  9C2,03
056A8:  MOVFF  9C1,FE9
056AC:  MOVFF  9C2,FEA
056B0:  MOVLW  01
056B2:  ADDWF  FEE,F
056B4:  BNC   56B8
056B6:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
056B8:  MOVF   xC7,W
056BA:  SUBLW  20
056BC:  BNC   56C0
....................          c = 0; 
056BE:  CLRF   xC7
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
056C0:  MOVF   xC7,F
056C2:  BZ    56D0
056C4:  MOVF   xC7,W
056C6:  SUBLW  2F
056C8:  BZ    56D0
056CA:  MOVF   xC7,W
056CC:  SUBLW  5C
056CE:  BNZ   56EE
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
056D0:  MOVF   xC5,F
056D2:  BNZ   56D6
....................             break; 
056D4:  BRA    57B6
....................          dirname[11] = a & b;  
056D6:  MOVLW  0B
056D8:  ADDWF  xC3,W
056DA:  MOVWF  FE9
056DC:  MOVLW  00
056DE:  ADDWFC xC4,W
056E0:  MOVWF  FEA
056E2:  MOVF   xC8,W
056E4:  ANDWF  xC9,W
056E6:  MOVWF  FEF
....................             return (c); 
056E8:  MOVFF  9C7,01
056EC:  BRA    57BA
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
056EE:  MOVF   xC7,W
056F0:  SUBLW  20
056F2:  BC    56FA
056F4:  MOVF   xC7,W
056F6:  SUBLW  7F
056F8:  BNZ   56FC
....................          break;   // reject invisible characters 
056FA:  BRA    57B6
....................       if (c == '.')  
056FC:  MOVF   xC7,W
056FE:  SUBLW  2E
05700:  BNZ   571E
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
05702:  BTFSC  xC8.0
05704:  BRA    571C
05706:  MOVF   xC5,W
05708:  SUBLW  00
0570A:  BC    571C
0570C:  MOVF   xC5,W
0570E:  SUBLW  08
05710:  BNC   571C
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
05712:  MOVLW  08
05714:  MOVWF  xC5
05716:  MOVLW  0B
05718:  MOVWF  xC6
....................             continue; 
0571A:  BRA    57B4
....................             } 
....................          break; 
0571C:  BRA    57B6
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
0571E:  MOVF   xC7,W
05720:  SUBLW  22
05722:  BNZ   5726
....................          break;               // Reject "  
05724:  BRA    57B6
....................  
....................       if (c <= ')')  
05726:  MOVF   xC7,W
05728:  SUBLW  29
0572A:  BNC   572E
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
0572C:  BRA    5798
....................  
....................       if (c <= ',') 
0572E:  MOVF   xC7,W
05730:  SUBLW  2C
05732:  BNC   5736
....................          break;               // Reject * + ,  
05734:  BRA    57B6
....................  
....................       if (c <= '9')  
05736:  MOVF   xC7,W
05738:  SUBLW  39
0573A:  BNC   573E
....................          goto md_l1;            // Accept - 0-9  
0573C:  BRA    5798
....................  
....................       if (c <= '?')  
0573E:  MOVF   xC7,W
05740:  SUBLW  3F
05742:  BNC   5746
....................          break;               // Reject : ; < = > ?  
05744:  BRA    57B6
....................  
....................       if (!(a & 1))  
05746:  BTFSC  xC8.0
05748:  BRA    5798
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
0574A:  MOVF   xC7,W
0574C:  SUBLW  7C
0574E:  BNZ   5752
....................             break;            // Reject |  
05750:  BRA    57B6
....................  
....................          if ((c >= '[') && (c <= ']')) 
05752:  MOVF   xC7,W
05754:  SUBLW  5A
05756:  BC    5760
05758:  MOVF   xC7,W
0575A:  SUBLW  5D
0575C:  BNC   5760
....................             break;// Reject [ \ ]  
0575E:  BRA    57B6
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
05760:  MOVF   xC7,W
05762:  SUBLW  40
05764:  BC    577A
05766:  MOVF   xC7,W
05768:  SUBLW  5A
0576A:  BNC   577A
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
0576C:  MOVF   xC6,W
0576E:  SUBLW  08
05770:  BNZ   5778
05772:  BCF    xC9.3
05774:  MOVF   xC9,W
05776:  BRA    577A
05778:  BCF    xC9.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
0577A:  MOVF   xC7,W
0577C:  SUBLW  60
0577E:  BC    5798
05780:  MOVF   xC7,W
05782:  SUBLW  7A
05784:  BNC   5798
....................             {      // Convert to upper case  
....................             c -= 0x20; 
05786:  MOVLW  20
05788:  SUBWF  xC7,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
0578A:  MOVF   xC6,W
0578C:  SUBLW  08
0578E:  BNZ   5796
05790:  BSF    xC8.3
05792:  MOVF   xC8,W
05794:  BRA    5798
05796:  BSF    xC8.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
05798:  BCF    xC8.0
....................    md_l2: 
....................       if (n >= t)  
0579A:  MOVF   xC6,W
0579C:  SUBWF  xC5,W
0579E:  BNC   57A2
....................          break; 
057A0:  BRA    57B6
....................       dirname[n++] = c; 
057A2:  MOVF   xC5,W
057A4:  INCF   xC5,F
057A6:  ADDWF  xC3,W
057A8:  MOVWF  FE9
057AA:  MOVLW  00
057AC:  ADDWFC xC4,W
057AE:  MOVWF  FEA
057B0:  MOVFF  9C7,FEF
057B4:  BRA    5686
....................       } 
....................    return 1; 
057B6:  MOVLW  01
057B8:  MOVWF  01
057BA:  MOVLB  0
057BC:  GOTO   62F8 (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
06156:  MOVLB  9
06158:  CLRF   xC0
0615A:  CLRF   xBF
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
0615C:  MOVLW  14
0615E:  MOVLB  7
06160:  ADDWF  x0E,W
06162:  MOVWF  FE9
06164:  MOVLW  00
06166:  ADDWFC x0F,W
06168:  MOVWF  FEA
0616A:  MOVFF  FEF,9BA
0616E:  MOVFF  FEC,9BB
06172:  MOVFF  FEC,9BC
06176:  MOVFF  FEC,9BD
....................    if (fs->fs_type == FS_FAT32)  
0617A:  MOVFF  70E,FE9
0617E:  MOVFF  70F,FEA
06182:  MOVF   FEF,W
06184:  SUBLW  03
06186:  BNZ   620A
....................       { 
....................       scan->clust = scan->sclust = clust; 
06188:  MOVLW  04
0618A:  MOVLB  9
0618C:  ADDWF  xB2,W
0618E:  MOVWF  01
06190:  MOVLW  00
06192:  ADDWFC xB3,W
06194:  MOVFF  01,9C1
06198:  MOVFF  9B2,FE9
0619C:  MOVFF  9B3,FEA
061A0:  MOVFF  9BA,FEF
061A4:  MOVFF  9BB,FEC
061A8:  MOVFF  9BC,FEC
061AC:  MOVFF  9BD,FEC
061B0:  MOVWF  FEA
061B2:  MOVFF  9C1,FE9
061B6:  MOVFF  9BA,FEF
061BA:  MOVFF  9BB,FEC
061BE:  MOVFF  9BC,FEC
061C2:  MOVFF  9BD,FEC
....................       scan->sect = clust2sect(clust); 
061C6:  MOVLW  08
061C8:  ADDWF  xB2,W
061CA:  MOVWF  01
061CC:  MOVLW  00
061CE:  ADDWFC xB3,W
061D0:  MOVWF  03
061D2:  MOVFF  01,9C1
061D6:  MOVWF  xC2
061D8:  MOVFF  9BD,9CE
061DC:  MOVFF  9BC,9CD
061E0:  MOVFF  9BB,9CC
061E4:  MOVFF  9BA,9CB
061E8:  MOVLB  0
061EA:  CALL   5588
061EE:  MOVFF  9C2,FEA
061F2:  MOVFF  9C1,FE9
061F6:  MOVFF  00,FEF
061FA:  MOVFF  01,FEC
061FE:  MOVFF  02,FEC
06202:  MOVFF  03,FEC
....................       } 
06206:  BRA    626A
06208:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
0620A:  MOVLW  04
0620C:  MOVLB  9
0620E:  ADDWF  xB2,W
06210:  MOVWF  01
06212:  MOVLW  00
06214:  ADDWFC xB3,W
06216:  MOVWF  03
06218:  MOVFF  9B2,FE9
0621C:  MOVFF  9B3,FEA
06220:  MOVF   FEE,F
06222:  MOVF   FEE,F
06224:  CLRF   FEC
06226:  MOVF   FED,F
06228:  CLRF   FEF
0622A:  MOVF   FED,F
0622C:  CLRF   FEF
0622E:  MOVF   FED,F
06230:  CLRF   FEF
06232:  MOVLW  00
06234:  MOVFF  03,FEA
06238:  MOVFF  01,FE9
0623C:  MOVFF  00,FEF
06240:  MOVFF  01,FEC
06244:  MOVFF  02,FEC
06248:  MOVFF  03,FEC
....................       scan->sect = clust; 
0624C:  MOVLW  08
0624E:  ADDWF  xB2,W
06250:  MOVWF  FE9
06252:  MOVLW  00
06254:  ADDWFC xB3,W
06256:  MOVWF  FEA
06258:  MOVFF  9BA,FEF
0625C:  MOVFF  9BB,FEC
06260:  MOVFF  9BC,FEC
06264:  MOVFF  9BD,FEC
06268:  MOVLB  0
....................       } 
....................    scan->index = 0; 
0626A:  MOVLW  0C
0626C:  MOVLB  9
0626E:  ADDWF  xB2,W
06270:  MOVWF  FE9
06272:  MOVLW  00
06274:  ADDWFC xB3,W
06276:  MOVWF  FEA
06278:  CLRF   FEC
0627A:  MOVF   FED,F
0627C:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
0627E:  MOVFF  9B7,03
06282:  MOVFF  9B6,FE9
06286:  MOVFF  9B7,FEA
0628A:  MOVF   FEF,W
0628C:  SUBLW  20
0628E:  BZ    62B4
06290:  MOVFF  9B7,03
06294:  MOVFF  9B6,FE9
06298:  MOVFF  9B7,FEA
0629C:  MOVF   FEF,W
0629E:  SUBLW  2F
062A0:  BZ    62B4
062A2:  MOVFF  9B7,03
062A6:  MOVFF  9B6,FE9
062AA:  MOVFF  9B7,FEA
062AE:  MOVF   FEF,W
062B0:  SUBLW  5C
062B2:  BNZ   62BC
....................        path++; 
062B4:  INCF   xB6,F
062B6:  BTFSC  FD8.2
062B8:  INCF   xB7,F
062BA:  BRA    627E
....................  
....................    if ((BYTE)*path < ' ')  
062BC:  MOVFF  9B7,03
062C0:  MOVFF  9B6,FE9
062C4:  MOVFF  9B7,FEA
062C8:  MOVF   FEF,W
062CA:  SUBLW  1F
062CC:  BNC   62E2
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
062CE:  MOVFF  9B8,FE9
062D2:  MOVFF  9B9,FEA
062D6:  CLRF   FEC
062D8:  MOVF   FED,F
062DA:  CLRF   FEF
....................       return (FR_OK); 
062DC:  MOVLW  00
062DE:  MOVWF  01
062E0:  BRA    653A
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
062E2:  MOVLW  09
062E4:  MOVWF  xC2
062E6:  MOVLW  B6
062E8:  MOVWF  xC1
062EA:  MOVFF  9B5,9C4
062EE:  MOVFF  9B4,9C3
062F2:  MOVLB  0
062F4:  GOTO   5662
062F8:  MOVFF  01,9BE
....................       if (ds == 1)  
062FC:  MOVLB  9
062FE:  DECFSZ xBE,W
06300:  BRA    6308
....................          return (FR_INVALID_NAME); 
06302:  MOVLW  04
06304:  MOVWF  01
06306:  BRA    653A
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
06308:  MOVLW  08
0630A:  ADDWF  xB2,W
0630C:  MOVWF  FE9
0630E:  MOVLW  00
06310:  ADDWFC xB3,W
06312:  MOVWF  FEA
06314:  MOVFF  FEF,9EC
06318:  MOVFF  FEC,9ED
0631C:  MOVFF  FEC,9EE
06320:  MOVFF  FEC,9EF
06324:  MOVLB  0
06326:  CALL   5A0C
0632A:  MOVF   01,F
0632C:  BNZ   6338
....................             return (FR_RW_ERROR); 
0632E:  MOVLW  07
06330:  MOVWF  01
06332:  MOVLB  9
06334:  BRA    653A
06336:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
06338:  MOVLW  0C
0633A:  MOVLB  9
0633C:  ADDWF  xB2,W
0633E:  MOVWF  FE9
06340:  MOVLW  00
06342:  ADDWFC xB3,W
06344:  MOVWF  FEA
06346:  MOVFF  FEC,9C2
0634A:  MOVF   FED,F
0634C:  MOVFF  FEF,9C1
06350:  MOVLW  0F
06352:  ANDWF  xC1,F
06354:  CLRF   xC2
06356:  RLCF   xC1,F
06358:  RLCF   xC2,F
0635A:  RLCF   xC1,F
0635C:  RLCF   xC2,F
0635E:  RLCF   xC1,F
06360:  RLCF   xC2,F
06362:  RLCF   xC1,F
06364:  RLCF   xC2,F
06366:  RLCF   xC1,F
06368:  RLCF   xC2,F
0636A:  MOVLW  E0
0636C:  ANDWF  xC1,F
0636E:  MOVLW  24
06370:  ADDWF  xC1,W
06372:  MOVWF  01
06374:  MOVLW  00
06376:  ADDWFC xC2,W
06378:  MOVWF  03
0637A:  MOVF   01,W
0637C:  MOVLB  7
0637E:  ADDWF  x0E,W
06380:  MOVWF  01
06382:  MOVF   x0F,W
06384:  ADDWFC 03,F
06386:  MOVFF  01,9BF
0638A:  MOVLB  9
0638C:  MOVFF  03,9C0
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
06390:  MOVFF  9C0,03
06394:  MOVFF  9BF,FE9
06398:  MOVFF  9C0,FEA
0639C:  MOVF   FEF,F
0639E:  BNZ   63AE
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
063A0:  MOVF   xBE,F
063A2:  BNZ   63A8
063A4:  MOVLW  02
063A6:  BRA    63AA
063A8:  MOVLW  03
063AA:  MOVWF  01
063AC:  BRA    653A
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
063AE:  MOVFF  9C0,03
063B2:  MOVFF  9BF,FE9
063B6:  MOVFF  9C0,FEA
063BA:  MOVF   FEF,W
063BC:  SUBLW  E5
063BE:  BZ    6400
063C0:  MOVLW  0B
063C2:  ADDWF  xBF,W
063C4:  MOVWF  01
063C6:  MOVLW  00
063C8:  ADDWFC xC0,W
063CA:  MOVWF  03
063CC:  MOVFF  01,FE9
063D0:  MOVWF  FEA
063D2:  BTFSC  FEF.3
063D4:  BRA    6400
063D6:  MOVFF  9C0,9C6
063DA:  MOVFF  9BF,9C5
063DE:  MOVFF  9B5,9C8
063E2:  MOVFF  9B4,9C7
063E6:  CLRF   xCA
063E8:  MOVLW  0B
063EA:  MOVWF  xC9
063EC:  MOVLB  0
063EE:  CALL   4598
063F2:  MOVF   01,F
063F4:  BTFSC  FD8.2
063F6:  BRA    63FC
063F8:  MOVLB  9
063FA:  BRA    6400
....................              break; 
063FC:  BRA    6428
063FE:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
06400:  MOVFF  9B3,9C2
06404:  MOVFF  9B2,9C1
06408:  MOVLB  0
0640A:  RCALL  5F7C
0640C:  MOVF   01,F
0640E:  BNZ   6422
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06410:  MOVLB  9
06412:  MOVF   xBE,F
06414:  BNZ   641A
06416:  MOVLW  02
06418:  BRA    641C
0641A:  MOVLW  03
0641C:  MOVWF  01
0641E:  BRA    653A
06420:  MOVLB  0
06422:  MOVLB  9
06424:  BRA    6308
06426:  MOVLB  0
....................          } 
....................       if (!ds)  
06428:  MOVLB  9
0642A:  MOVF   xBE,F
0642C:  BNZ   6446
....................          {  
....................          *win_dir = dptr;  
0642E:  MOVFF  9B8,FE9
06432:  MOVFF  9B9,FEA
06436:  MOVFF  9C0,FEC
0643A:  MOVF   FED,F
0643C:  MOVFF  9BF,FEF
....................          return (FR_OK); 
06440:  MOVLW  00
06442:  MOVWF  01
06444:  BRA    653A
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
06446:  MOVLW  0B
06448:  ADDWF  xBF,W
0644A:  MOVWF  01
0644C:  MOVLW  00
0644E:  ADDWFC xC0,W
06450:  MOVWF  03
06452:  MOVFF  01,FE9
06456:  MOVWF  FEA
06458:  BTFSC  FEF.4
0645A:  BRA    6462
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
0645C:  MOVLW  03
0645E:  MOVWF  01
06460:  BRA    653A
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
06462:  MOVLW  14
06464:  ADDWF  xBF,W
06466:  MOVWF  01
06468:  MOVLW  00
0646A:  ADDWFC xC0,W
0646C:  MOVWF  03
0646E:  MOVFF  01,FE9
06472:  MOVWF  FEA
06474:  MOVFF  FEC,9BD
06478:  MOVF   FED,F
0647A:  MOVFF  FEF,9C1
0647E:  MOVFF  9C1,9BC
06482:  CLRF   xC1
06484:  CLRF   xC2
06486:  MOVLW  1A
06488:  ADDWF  xBF,W
0648A:  MOVWF  01
0648C:  MOVLW  00
0648E:  ADDWFC xC0,W
06490:  MOVFF  01,FE9
06494:  MOVWF  FEA
06496:  MOVFF  FEC,03
0649A:  MOVF   FED,F
0649C:  MOVF   FEF,W
0649E:  IORWF  xC1,W
064A0:  MOVWF  xBA
064A2:  MOVF   03,W
064A4:  IORWF  xC2,W
064A6:  MOVWF  xBB
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
064A8:  MOVLW  04
064AA:  ADDWF  xB2,W
064AC:  MOVWF  01
064AE:  MOVLW  00
064B0:  ADDWFC xB3,W
064B2:  MOVFF  01,9C1
064B6:  MOVFF  9B2,FE9
064BA:  MOVFF  9B3,FEA
064BE:  MOVFF  9BA,FEF
064C2:  MOVFF  9BB,FEC
064C6:  MOVFF  9BC,FEC
064CA:  MOVFF  9BD,FEC
064CE:  MOVWF  FEA
064D0:  MOVFF  9C1,FE9
064D4:  MOVFF  9BA,FEF
064D8:  MOVFF  9BB,FEC
064DC:  MOVFF  9BC,FEC
064E0:  MOVFF  9BD,FEC
....................       scan->sect = clust2sect(clust); 
064E4:  MOVLW  08
064E6:  ADDWF  xB2,W
064E8:  MOVWF  01
064EA:  MOVLW  00
064EC:  ADDWFC xB3,W
064EE:  MOVWF  03
064F0:  MOVFF  01,9C1
064F4:  MOVWF  xC2
064F6:  MOVFF  9BD,9CE
064FA:  MOVFF  9BC,9CD
064FE:  MOVFF  9BB,9CC
06502:  MOVFF  9BA,9CB
06506:  MOVLB  0
06508:  CALL   5588
0650C:  MOVFF  9C2,FEA
06510:  MOVFF  9C1,FE9
06514:  MOVFF  00,FEF
06518:  MOVFF  01,FEC
0651C:  MOVFF  02,FEC
06520:  MOVFF  03,FEC
....................       scan->index = 0; 
06524:  MOVLW  0C
06526:  MOVLB  9
06528:  ADDWF  xB2,W
0652A:  MOVWF  FE9
0652C:  MOVLW  00
0652E:  ADDWFC xB3,W
06530:  MOVWF  FEA
06532:  CLRF   FEC
06534:  MOVF   FED,F
06536:  CLRF   FEF
06538:  BRA    62E2
....................       } 
0653A:  MOVLB  0
0653C:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06B54:  MOVLB  9
06B56:  MOVFF  9B2,FE9
06B5A:  MOVFF  9B3,FEA
06B5E:  MOVFF  FEF,9B4
06B62:  MOVFF  FEC,9B5
06B66:  MOVFF  FEC,9B6
06B6A:  MOVFF  FEC,9B7
....................    if (clust) {   // Dyanmic directory table  
06B6E:  MOVF   xB4,F
06B70:  BNZ   6B7E
06B72:  MOVF   xB5,F
06B74:  BNZ   6B7E
06B76:  MOVF   xB6,F
06B78:  BNZ   6B7E
06B7A:  MOVF   xB7,F
06B7C:  BZ    6BDE
....................       scan->clust = clust; 
06B7E:  MOVLW  04
06B80:  ADDWF  xB2,W
06B82:  MOVWF  FE9
06B84:  MOVLW  00
06B86:  ADDWFC xB3,W
06B88:  MOVWF  FEA
06B8A:  MOVFF  9B4,FEF
06B8E:  MOVFF  9B5,FEC
06B92:  MOVFF  9B6,FEC
06B96:  MOVFF  9B7,FEC
....................       scan->sect = clust2sect(clust); 
06B9A:  MOVLW  08
06B9C:  ADDWF  xB2,W
06B9E:  MOVWF  01
06BA0:  MOVLW  00
06BA2:  ADDWFC xB3,W
06BA4:  MOVWF  03
06BA6:  MOVFF  01,9C0
06BAA:  MOVWF  xC1
06BAC:  MOVFF  9B7,9CE
06BB0:  MOVFF  9B6,9CD
06BB4:  MOVFF  9B5,9CC
06BB8:  MOVFF  9B4,9CB
06BBC:  MOVLB  0
06BBE:  CALL   5588
06BC2:  MOVFF  9C1,FEA
06BC6:  MOVFF  9C0,FE9
06BCA:  MOVFF  00,FEF
06BCE:  MOVFF  01,FEC
06BD2:  MOVFF  02,FEC
06BD6:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06BDA:  BRA    6C28
06BDC:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06BDE:  MOVLW  08
06BE0:  ADDWF  xB2,W
06BE2:  MOVWF  01
06BE4:  MOVLW  00
06BE6:  ADDWFC xB3,W
06BE8:  MOVWF  03
06BEA:  MOVFF  01,9C0
06BEE:  MOVWF  xC1
06BF0:  MOVLW  14
06BF2:  MOVLB  7
06BF4:  ADDWF  x0E,W
06BF6:  MOVWF  FE9
06BF8:  MOVLW  00
06BFA:  ADDWFC x0F,W
06BFC:  MOVWF  FEA
06BFE:  MOVFF  FEF,00
06C02:  MOVFF  FEC,01
06C06:  MOVFF  FEC,02
06C0A:  MOVFF  FEC,03
06C0E:  MOVFF  9C1,FEA
06C12:  MOVFF  9C0,FE9
06C16:  MOVFF  00,FEF
06C1A:  MOVFF  01,FEC
06C1E:  MOVFF  02,FEC
06C22:  MOVFF  03,FEC
06C26:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06C28:  MOVLW  0C
06C2A:  MOVLB  9
06C2C:  ADDWF  xB2,W
06C2E:  MOVWF  FE9
06C30:  MOVLW  00
06C32:  ADDWFC xB3,W
06C34:  MOVWF  FEA
06C36:  CLRF   FEC
06C38:  MOVF   FED,F
06C3A:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06C3C:  MOVLW  08
06C3E:  ADDWF  xB2,W
06C40:  MOVWF  FE9
06C42:  MOVLW  00
06C44:  ADDWFC xB3,W
06C46:  MOVWF  FEA
06C48:  MOVFF  FEF,9EC
06C4C:  MOVFF  FEC,9ED
06C50:  MOVFF  FEC,9EE
06C54:  MOVFF  FEC,9EF
06C58:  MOVLB  0
06C5A:  CALL   5A0C
06C5E:  MOVF   01,F
06C60:  BNZ   6C6A
....................          return (NULL); 
06C62:  MOVLW  00
06C64:  MOVWF  01
06C66:  MOVWF  02
06C68:  BRA    6E92
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06C6A:  MOVLW  0C
06C6C:  MOVLB  9
06C6E:  ADDWF  xB2,W
06C70:  MOVWF  FE9
06C72:  MOVLW  00
06C74:  ADDWFC xB3,W
06C76:  MOVWF  FEA
06C78:  MOVFF  FEC,9C1
06C7C:  MOVF   FED,F
06C7E:  MOVFF  FEF,9C0
06C82:  MOVLW  0F
06C84:  ANDWF  xC0,F
06C86:  CLRF   xC1
06C88:  RLCF   xC0,F
06C8A:  RLCF   xC1,F
06C8C:  RLCF   xC0,F
06C8E:  RLCF   xC1,F
06C90:  RLCF   xC0,F
06C92:  RLCF   xC1,F
06C94:  RLCF   xC0,F
06C96:  RLCF   xC1,F
06C98:  RLCF   xC0,F
06C9A:  RLCF   xC1,F
06C9C:  MOVLW  E0
06C9E:  ANDWF  xC0,F
06CA0:  MOVLW  24
06CA2:  ADDWF  xC0,W
06CA4:  MOVWF  01
06CA6:  MOVLW  00
06CA8:  ADDWFC xC1,W
06CAA:  MOVWF  03
06CAC:  MOVF   01,W
06CAE:  MOVLB  7
06CB0:  ADDWF  x0E,W
06CB2:  MOVWF  01
06CB4:  MOVF   x0F,W
06CB6:  ADDWFC 03,F
06CB8:  MOVFF  01,9BE
06CBC:  MOVLB  9
06CBE:  MOVFF  03,9BF
....................       c = *dptr; 
06CC2:  MOVFF  9BE,FE9
06CC6:  MOVFF  9BF,FEA
06CCA:  MOVFF  FEF,9BC
....................       if ((c == 0) || (c == 0xE5))  
06CCE:  MOVF   xBC,F
06CD0:  BZ    6CD8
06CD2:  MOVF   xBC,W
06CD4:  SUBLW  E5
06CD6:  BNZ   6CE6
....................          return (dptr);      // Found an empty entry!  
06CD8:  MOVFF  9BE,01
06CDC:  MOVFF  9BF,02
06CE0:  MOVLB  0
06CE2:  BRA    6E92
06CE4:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06CE6:  MOVFF  9B3,9C2
06CEA:  MOVFF  9B2,9C1
06CEE:  MOVLB  0
06CF0:  CALL   5F7C
06CF4:  MOVF   01,F
06CF6:  BTFSC  FD8.2
06CF8:  BRA    6CFE
06CFA:  MOVLB  9
06CFC:  BRA    6C3C
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06CFE:  MOVLB  9
06D00:  MOVF   xB4,F
06D02:  BNZ   6D1C
06D04:  MOVF   xB5,F
06D06:  BNZ   6D1C
06D08:  MOVF   xB6,F
06D0A:  BNZ   6D1C
06D0C:  MOVF   xB7,F
06D0E:  BNZ   6D1C
....................        return (NULL); 
06D10:  MOVLW  00
06D12:  MOVWF  01
06D14:  MOVWF  02
06D16:  MOVLB  0
06D18:  BRA    6E92
06D1A:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06D1C:  MOVLW  04
06D1E:  ADDWF  xB2,W
06D20:  MOVWF  FE9
06D22:  MOVLW  00
06D24:  ADDWFC xB3,W
06D26:  MOVWF  FEA
06D28:  MOVFF  FEF,9C4
06D2C:  MOVFF  FEC,9C5
06D30:  MOVFF  FEC,9C6
06D34:  MOVFF  FEC,9C7
06D38:  MOVLB  0
06D3A:  RCALL  68BE
06D3C:  MOVFF  03,9B7
06D40:  MOVFF  02,9B6
06D44:  MOVFF  01,9B5
06D48:  MOVFF  00,9B4
....................    if (!(clust))  
06D4C:  MOVLB  9
06D4E:  MOVF   xB4,F
06D50:  BNZ   6D6A
06D52:  MOVF   xB5,F
06D54:  BNZ   6D6A
06D56:  MOVF   xB6,F
06D58:  BNZ   6D6A
06D5A:  MOVF   xB7,F
06D5C:  BNZ   6D6A
....................       return (NULL); 
06D5E:  MOVLW  00
06D60:  MOVWF  01
06D62:  MOVWF  02
06D64:  MOVLB  0
06D66:  BRA    6E92
06D68:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06D6A:  CLRF   xEF
06D6C:  CLRF   xEE
06D6E:  CLRF   xED
06D70:  CLRF   xEC
06D72:  MOVLB  0
06D74:  CALL   5A0C
06D78:  MOVF   01,F
06D7A:  BNZ   6D84
....................       return (0); 
06D7C:  MOVLW  00
06D7E:  MOVWF  01
06D80:  MOVWF  02
06D82:  BRA    6E92
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06D84:  MOVLW  20
06D86:  MOVLB  7
06D88:  ADDWF  x0E,W
06D8A:  MOVWF  01
06D8C:  MOVLW  00
06D8E:  ADDWFC x0F,W
06D90:  MOVWF  03
06D92:  MOVFF  01,9C0
06D96:  MOVLB  9
06D98:  MOVWF  xC1
06D9A:  MOVFF  9B7,9CE
06D9E:  MOVFF  9B6,9CD
06DA2:  MOVFF  9B5,9CC
06DA6:  MOVFF  9B4,9CB
06DAA:  MOVLB  0
06DAC:  CALL   5588
06DB0:  MOVFF  03,9BB
06DB4:  MOVFF  02,9BA
06DB8:  MOVFF  01,9B9
06DBC:  MOVFF  00,9B8
06DC0:  MOVFF  9C1,FEA
06DC4:  MOVFF  9C0,FE9
06DC8:  MOVFF  9B8,FEF
06DCC:  MOVFF  9B9,FEC
06DD0:  MOVFF  9BA,FEC
06DD4:  MOVFF  9BB,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06DD8:  MOVLW  24
06DDA:  MOVLB  7
06DDC:  ADDWF  x0E,W
06DDE:  MOVWF  01
06DE0:  MOVLW  00
06DE2:  ADDWFC x0F,W
06DE4:  MOVWF  03
06DE6:  MOVFF  01,9C0
06DEA:  MOVLB  9
06DEC:  MOVWF  xC1
06DEE:  MOVWF  FEA
06DF0:  MOVFF  01,FE9
06DF4:  CLRF   00
06DF6:  MOVLW  02
06DF8:  MOVWF  02
06DFA:  CLRF   01
06DFC:  MOVLB  0
06DFE:  CALL   34A4
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06E02:  MOVLW  02
06E04:  MOVLB  7
06E06:  ADDWF  x0E,W
06E08:  MOVWF  FE9
06E0A:  MOVLW  00
06E0C:  ADDWFC x0F,W
06E0E:  MOVWF  FEA
06E10:  MOVFF  FEF,9BD
06E14:  MOVLB  9
06E16:  MOVF   xBD,F
06E18:  BZ    6E72
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06E1A:  MOVLW  24
06E1C:  MOVLB  7
06E1E:  ADDWF  x0E,W
06E20:  MOVWF  01
06E22:  MOVLW  00
06E24:  ADDWFC x0F,W
06E26:  MOVWF  03
06E28:  MOVFF  01,9C0
06E2C:  MOVLB  9
06E2E:  MOVWF  xC1
06E30:  MOVWF  xF9
06E32:  MOVFF  01,9F8
06E36:  MOVFF  9BB,9FD
06E3A:  MOVFF  9BA,9FC
06E3E:  MOVFF  9B9,9FB
06E42:  MOVFF  9B8,9FA
06E46:  MOVLW  01
06E48:  MOVWF  xFE
06E4A:  MOVLB  0
06E4C:  CALL   58C2
06E50:  MOVF   01,F
06E52:  BZ    6E5C
....................          return (NULL); 
06E54:  MOVLW  00
06E56:  MOVWF  01
06E58:  MOVWF  02
06E5A:  BRA    6E92
....................       sector++; 
06E5C:  MOVLW  01
06E5E:  MOVLB  9
06E60:  ADDWF  xB8,F
06E62:  BTFSC  FD8.0
06E64:  INCF   xB9,F
06E66:  BTFSC  FD8.2
06E68:  INCF   xBA,F
06E6A:  BTFSC  FD8.2
06E6C:  INCF   xBB,F
06E6E:  DECF   xBD,F
06E70:  BRA    6E16
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06E72:  MOVLW  06
06E74:  MOVLB  7
06E76:  ADDWF  x0E,W
06E78:  MOVWF  FE9
06E7A:  MOVLW  00
06E7C:  ADDWFC x0F,W
06E7E:  MOVWF  FEA
06E80:  MOVLW  01
06E82:  MOVWF  FEF
....................    return (fs->win); 
06E84:  MOVLW  24
06E86:  ADDWF  x0E,W
06E88:  MOVWF  01
06E8A:  MOVLW  00
06E8C:  ADDWFC x0F,W
06E8E:  MOVWF  03
06E90:  MOVWF  02
06E92:  MOVLB  0
06E94:  GOTO   712A (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
05526:  MOVLB  7
05528:  MOVF   x0E,W
0552A:  IORWF  x0F,W
0552C:  BNZ   5534
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
0552E:  MOVLW  0B
05530:  MOVWF  01
05532:  BRA    5584
....................  
....................    if (disk_status() & STA_NOINIT)  
05534:  MOVLB  0
05536:  RCALL  5518
05538:  BTFSS  01.0
0553A:  BRA    5566
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
0553C:  MOVLW  01
0553E:  MOVLB  7
05540:  ADDWF  x0E,W
05542:  MOVWF  FE9
05544:  MOVLW  00
05546:  ADDWFC x0F,W
05548:  MOVWF  FEA
0554A:  MOVF   FEF,F
0554C:  BZ    5556
....................          return (FR_INCORRECT_DISK_CHANGE); 
0554E:  MOVLW  09
05550:  MOVWF  01
05552:  BRA    5584
05554:  BRA    5562
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
05556:  MOVLB  0
05558:  CALL   47D4
0555C:  MOVF   01,W
0555E:  MOVLB  7
05560:  BRA    5584
....................       }  
05562:  BRA    5580
05564:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
05566:  MOVLB  7
05568:  MOVFF  70E,FE9
0556C:  MOVFF  70F,FEA
05570:  MOVF   FEF,F
05572:  BNZ   5580
....................          return (f_mountdrv());      // Initialize file system and return resulut  
05574:  MOVLB  0
05576:  CALL   47D4
0557A:  MOVF   01,W
0557C:  MOVLB  7
0557E:  BRA    5584
....................       } 
....................    return FR_OK;                  // File system is valid  
05580:  MOVLW  00
05582:  MOVWF  01
05584:  MOVLB  0
05586:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B5F2:  MOVLB  8
0B5F4:  MOVF   xA4,W
0B5F6:  XORLW  00
0B5F8:  MOVLB  0
0B5FA:  BZ    B634
0B5FC:  XORLW  04
0B5FE:  BZ    B650
0B600:  XORLW  05
0B602:  BZ    B66C
0B604:  XORLW  03
0B606:  BZ    B688
0B608:  XORLW  01
0B60A:  BZ    B6A4
0B60C:  XORLW  06
0B60E:  BZ    B6C0
0B610:  XORLW  03
0B612:  BZ    B6DC
0B614:  XORLW  01
0B616:  BTFSC  FD8.2
0B618:  BRA    B6F8
0B61A:  XORLW  0E
0B61C:  BTFSC  FD8.2
0B61E:  BRA    B714
0B620:  XORLW  03
0B622:  BTFSC  FD8.2
0B624:  BRA    B730
0B626:  XORLW  01
0B628:  BTFSC  FD8.2
0B62A:  BRA    B74C
0B62C:  XORLW  07
0B62E:  BTFSC  FD8.2
0B630:  BRA    B768
0B632:  BRA    B784
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B634:  MOVFF  8A6,FEA
0B638:  MOVFF  8A5,FE9
0B63C:  MOVLW  00
0B63E:  CALL   0106
0B642:  TBLRD*-
0B644:  TBLRD*+
0B646:  MOVF   FF5,W
0B648:  MOVWF  FEE
0B64A:  IORLW  00
0B64C:  BNZ   B644
....................          break; 
0B64E:  BRA    B79E
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B650:  MOVFF  8A6,FEA
0B654:  MOVFF  8A5,FE9
0B658:  MOVLW  00
0B65A:  CALL   0124
0B65E:  TBLRD*-
0B660:  TBLRD*+
0B662:  MOVF   FF5,W
0B664:  MOVWF  FEE
0B666:  IORLW  00
0B668:  BNZ   B660
....................          break; 
0B66A:  BRA    B79E
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B66C:  MOVFF  8A6,FEA
0B670:  MOVFF  8A5,FE9
0B674:  MOVLW  00
0B676:  CALL   014A
0B67A:  TBLRD*-
0B67C:  TBLRD*+
0B67E:  MOVF   FF5,W
0B680:  MOVWF  FEE
0B682:  IORLW  00
0B684:  BNZ   B67C
....................          break; 
0B686:  BRA    B79E
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0B688:  MOVFF  8A6,FEA
0B68C:  MOVFF  8A5,FE9
0B690:  MOVLW  00
0B692:  CALL   016E
0B696:  TBLRD*-
0B698:  TBLRD*+
0B69A:  MOVF   FF5,W
0B69C:  MOVWF  FEE
0B69E:  IORLW  00
0B6A0:  BNZ   B698
....................          break; 
0B6A2:  BRA    B79E
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0B6A4:  MOVFF  8A6,FEA
0B6A8:  MOVFF  8A5,FE9
0B6AC:  MOVLW  00
0B6AE:  CALL   0192
0B6B2:  TBLRD*-
0B6B4:  TBLRD*+
0B6B6:  MOVF   FF5,W
0B6B8:  MOVWF  FEE
0B6BA:  IORLW  00
0B6BC:  BNZ   B6B4
....................          break; 
0B6BE:  BRA    B79E
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0B6C0:  MOVFF  8A6,FEA
0B6C4:  MOVFF  8A5,FE9
0B6C8:  MOVLW  00
0B6CA:  CALL   01B6
0B6CE:  TBLRD*-
0B6D0:  TBLRD*+
0B6D2:  MOVF   FF5,W
0B6D4:  MOVWF  FEE
0B6D6:  IORLW  00
0B6D8:  BNZ   B6D0
....................          break; 
0B6DA:  BRA    B79E
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0B6DC:  MOVFF  8A6,FEA
0B6E0:  MOVFF  8A5,FE9
0B6E4:  MOVLW  00
0B6E6:  CALL   01D8
0B6EA:  TBLRD*-
0B6EC:  TBLRD*+
0B6EE:  MOVF   FF5,W
0B6F0:  MOVWF  FEE
0B6F2:  IORLW  00
0B6F4:  BNZ   B6EC
....................          break; 
0B6F6:  BRA    B79E
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0B6F8:  MOVFF  8A6,FEA
0B6FC:  MOVFF  8A5,FE9
0B700:  MOVLW  00
0B702:  CALL   01F8
0B706:  TBLRD*-
0B708:  TBLRD*+
0B70A:  MOVF   FF5,W
0B70C:  MOVWF  FEE
0B70E:  IORLW  00
0B710:  BNZ   B708
....................          break; 
0B712:  BRA    B79E
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0B714:  MOVFF  8A6,FEA
0B718:  MOVFF  8A5,FE9
0B71C:  MOVLW  00
0B71E:  CALL   0216
0B722:  TBLRD*-
0B724:  TBLRD*+
0B726:  MOVF   FF5,W
0B728:  MOVWF  FEE
0B72A:  IORLW  00
0B72C:  BNZ   B724
....................          break; 
0B72E:  BRA    B79E
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0B730:  MOVFF  8A6,FEA
0B734:  MOVFF  8A5,FE9
0B738:  MOVLW  00
0B73A:  CALL   0242
0B73E:  TBLRD*-
0B740:  TBLRD*+
0B742:  MOVF   FF5,W
0B744:  MOVWF  FEE
0B746:  IORLW  00
0B748:  BNZ   B740
....................          break; 
0B74A:  BRA    B79E
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0B74C:  MOVFF  8A6,FEA
0B750:  MOVFF  8A5,FE9
0B754:  MOVLW  00
0B756:  CALL   0266
0B75A:  TBLRD*-
0B75C:  TBLRD*+
0B75E:  MOVF   FF5,W
0B760:  MOVWF  FEE
0B762:  IORLW  00
0B764:  BNZ   B75C
....................          break; 
0B766:  BRA    B79E
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0B768:  MOVFF  8A6,FEA
0B76C:  MOVFF  8A5,FE9
0B770:  MOVLW  00
0B772:  CALL   028A
0B776:  TBLRD*-
0B778:  TBLRD*+
0B77A:  MOVF   FF5,W
0B77C:  MOVWF  FEE
0B77E:  IORLW  00
0B780:  BNZ   B778
....................          break; 
0B782:  BRA    B79E
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0B784:  MOVFF  8A6,FEA
0B788:  MOVFF  8A5,FE9
0B78C:  MOVLW  00
0B78E:  CALL   02AC
0B792:  TBLRD*-
0B794:  TBLRD*+
0B796:  MOVF   FF5,W
0B798:  MOVWF  FEE
0B79A:  IORLW  00
0B79C:  BNZ   B794
....................       } 
0B79E:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
047D4:  MOVLB  7
047D6:  MOVF   x0E,W
047D8:  IORWF  x0F,W
047DA:  BNZ   47E2
....................       return (FR_NOT_ENABLED); 
047DC:  MOVLW  0B
047DE:  MOVWF  01
047E0:  BRA    4D6E
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
047E2:  MOVFF  70F,FEA
047E6:  MOVFF  70E,FE9
047EA:  CLRF   00
047EC:  MOVLW  02
047EE:  MOVWF  02
047F0:  MOVLW  24
047F2:  MOVWF  01
047F4:  MOVLB  0
047F6:  CALL   34A4
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
047FA:  CALL   35F4
047FE:  MOVFF  01,4E9
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
04802:  MOVLB  4
04804:  BTFSS  xE9.0
04806:  BRA    4814
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
04808:  MOVLB  0
0480A:  CALL   35F4
0480E:  MOVFF  01,4E9
04812:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
04814:  BTFSS  xE9.0
04816:  BRA    4822
04818:  MOVLW  01
0481A:  MOVWF  01
0481C:  MOVLB  7
0481E:  BRA    4D6E
04820:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
04822:  MOVLB  9
04824:  CLRF   xB6
04826:  CLRF   xB5
04828:  CLRF   xB4
0482A:  CLRF   xB3
0482C:  MOVFF  9B6,9C2
04830:  MOVFF  9B5,9C1
04834:  MOVFF  9B4,9C0
04838:  MOVFF  9B3,9BF
0483C:  MOVLB  0
0483E:  RCALL  461C
04840:  MOVFF  01,9B2
....................    if (!fat)  
04844:  MOVLB  9
04846:  MOVF   xB2,F
04848:  BNZ   48B8
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
0484A:  MOVLW  E6
0484C:  MOVLB  7
0484E:  ADDWF  x0E,W
04850:  MOVWF  FE9
04852:  MOVLW  01
04854:  ADDWFC x0F,W
04856:  MOVWF  FEA
04858:  MOVF   FEF,F
0485A:  BZ    4898
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
0485C:  MOVLW  EA
0485E:  ADDWF  x0E,W
04860:  MOVWF  01
04862:  MOVLW  01
04864:  ADDWFC x0F,W
04866:  MOVFF  01,FE9
0486A:  MOVWF  FEA
0486C:  MOVFF  FEF,9B3
04870:  MOVFF  FEC,9B4
04874:  MOVFF  FEC,9B5
04878:  MOVFF  FEC,9B6
....................          fat = check_fs(sect);            // Check the partition  
0487C:  MOVFF  9B6,9C2
04880:  MOVFF  9B5,9C1
04884:  MOVFF  9B4,9C0
04888:  MOVFF  9B3,9BF
0488C:  MOVLB  0
0488E:  RCALL  461C
04890:  MOVFF  01,9B2
....................          } 
04894:  BRA    48B6
04896:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
04898:  MOVLW  04
0489A:  MOVWF  FF6
0489C:  MOVLW  0C
0489E:  MOVWF  FF7
048A0:  MOVLW  00
048A2:  MOVWF  FF8
048A4:  CLRF   1B
048A6:  BTFSC  FF2.7
048A8:  BSF    1B.7
048AA:  BCF    FF2.7
048AC:  MOVLB  0
048AE:  CALL   0E30
048B2:  BTFSC  1B.7
048B4:  BSF    FF2.7
048B6:  MOVLB  9
....................       } 
....................    if (!fat)  
048B8:  MOVF   xB2,F
048BA:  BNZ   48C6
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
048BC:  MOVLW  0C
048BE:  MOVWF  01
048C0:  MOVLB  7
048C2:  BRA    4D6E
048C4:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
048C6:  MOVLB  7
048C8:  MOVFF  70E,FE9
048CC:  MOVFF  70F,FEA
048D0:  MOVFF  9B2,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
048D4:  MOVLB  9
048D6:  MOVF   xB2,W
048D8:  SUBLW  03
048DA:  BNZ   4940
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
048DC:  MOVLW  08
048DE:  MOVLB  7
048E0:  ADDWF  x0E,W
048E2:  MOVWF  01
048E4:  MOVLW  00
048E6:  ADDWFC x0F,W
048E8:  MOVWF  03
048EA:  MOVFF  01,9BF
048EE:  MOVLB  9
048F0:  MOVWF  xC0
048F2:  MOVLW  48
048F4:  MOVLB  7
048F6:  ADDWF  x0E,W
048F8:  MOVWF  01
048FA:  MOVLW  00
048FC:  ADDWFC x0F,W
048FE:  MOVFF  01,FE9
04902:  MOVWF  FEA
04904:  MOVFF  FEF,00
04908:  MOVFF  FEC,01
0490C:  MOVFF  FEC,02
04910:  MOVFF  FEC,03
04914:  MOVFF  03,9C4
04918:  MOVFF  02,9C3
0491C:  MOVFF  01,9C2
04920:  MOVFF  00,9C1
04924:  MOVFF  9C0,FEA
04928:  MOVFF  9BF,FE9
0492C:  MOVFF  00,FEF
04930:  MOVFF  01,FEC
04934:  MOVFF  02,FEC
04938:  MOVFF  03,FEC
0493C:  BRA    4998
0493E:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
04940:  MOVLW  08
04942:  MOVLB  7
04944:  ADDWF  x0E,W
04946:  MOVWF  01
04948:  MOVLW  00
0494A:  ADDWFC x0F,W
0494C:  MOVWF  03
0494E:  MOVFF  01,9BF
04952:  MOVLB  9
04954:  MOVWF  xC0
04956:  MOVLW  3A
04958:  MOVLB  7
0495A:  ADDWF  x0E,W
0495C:  MOVWF  01
0495E:  MOVLW  00
04960:  ADDWFC x0F,W
04962:  MOVFF  01,FE9
04966:  MOVWF  FEA
04968:  MOVFF  FEC,03
0496C:  MOVF   FED,F
0496E:  MOVFF  FEF,9C1
04972:  MOVLB  9
04974:  MOVFF  03,9C2
04978:  MOVFF  9C0,FEA
0497C:  MOVFF  9BF,FE9
04980:  MOVF   FEE,F
04982:  MOVF   FEE,F
04984:  CLRF   FEC
04986:  MOVF   FED,F
04988:  CLRF   FEF
0498A:  MOVF   FED,F
0498C:  MOVFF  03,FEF
04990:  MOVF   FED,F
04992:  MOVFF  9C1,FEF
04996:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
04998:  MOVLW  02
0499A:  ADDWF  x0E,W
0499C:  MOVWF  01
0499E:  MOVLW  00
049A0:  ADDWFC x0F,W
049A2:  MOVWF  03
049A4:  MOVLW  31
049A6:  MOVLB  7
049A8:  ADDWF  x0E,W
049AA:  MOVWF  FE9
049AC:  MOVLW  00
049AE:  ADDWFC x0F,W
049B0:  MOVWF  FEA
049B2:  MOVFF  FEF,9C1
049B6:  MOVLB  9
049B8:  MOVFF  03,FEA
049BC:  MOVFF  01,FE9
049C0:  MOVFF  9C1,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
049C4:  MOVLW  03
049C6:  MOVLB  7
049C8:  ADDWF  x0E,W
049CA:  MOVWF  01
049CC:  MOVLW  00
049CE:  ADDWFC x0F,W
049D0:  MOVWF  03
049D2:  MOVLW  34
049D4:  MOVLB  7
049D6:  ADDWF  x0E,W
049D8:  MOVWF  FE9
049DA:  MOVLW  00
049DC:  ADDWFC x0F,W
049DE:  MOVWF  FEA
049E0:  MOVFF  FEF,9C1
049E4:  MOVLB  9
049E6:  MOVFF  03,FEA
049EA:  MOVFF  01,FE9
049EE:  MOVFF  9C1,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
049F2:  MOVLW  10
049F4:  MOVLB  7
049F6:  ADDWF  x0E,W
049F8:  MOVWF  01
049FA:  MOVLW  00
049FC:  ADDWFC x0F,W
049FE:  MOVWF  03
04A00:  MOVFF  01,9BF
04A04:  MOVLB  9
04A06:  MOVWF  xC0
04A08:  MOVLW  32
04A0A:  MOVLB  7
04A0C:  ADDWF  x0E,W
04A0E:  MOVWF  01
04A10:  MOVLW  00
04A12:  ADDWFC x0F,W
04A14:  MOVFF  01,FE9
04A18:  MOVWF  FEA
04A1A:  MOVFF  FEC,03
04A1E:  MOVF   FED,F
04A20:  MOVF   FEF,W
04A22:  MOVLB  9
04A24:  ADDWF  xB3,W
04A26:  MOVWF  00
04A28:  MOVF   03,W
04A2A:  ADDWFC xB4,W
04A2C:  MOVWF  01
04A2E:  MOVLW  00
04A30:  ADDWFC xB5,W
04A32:  MOVWF  02
04A34:  MOVLW  00
04A36:  ADDWFC xB6,W
04A38:  MOVFF  9C0,FEA
04A3C:  MOVFF  9BF,FE9
04A40:  MOVFF  00,FEF
04A44:  MOVFF  01,FEC
04A48:  MOVFF  02,FEC
04A4C:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04A4E:  MOVLW  04
04A50:  MOVLB  7
04A52:  ADDWF  x0E,W
04A54:  MOVWF  01
04A56:  MOVLW  00
04A58:  ADDWFC x0F,W
04A5A:  MOVWF  03
04A5C:  MOVFF  01,9BF
04A60:  MOVLB  9
04A62:  MOVWF  xC0
04A64:  MOVLW  35
04A66:  MOVLB  7
04A68:  ADDWF  x0E,W
04A6A:  MOVWF  01
04A6C:  MOVLW  00
04A6E:  ADDWFC x0F,W
04A70:  MOVFF  01,FE9
04A74:  MOVWF  FEA
04A76:  MOVFF  FEC,03
04A7A:  MOVF   FED,F
04A7C:  MOVFF  FEF,9C1
04A80:  MOVLB  9
04A82:  MOVFF  9C0,FEA
04A86:  MOVFF  9BF,FE9
04A8A:  MOVFF  03,FEC
04A8E:  MOVF   FED,F
04A90:  MOVFF  9C1,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04A94:  MOVLW  08
04A96:  MOVLB  7
04A98:  ADDWF  x0E,W
04A9A:  MOVWF  FE9
04A9C:  MOVLW  00
04A9E:  ADDWFC x0F,W
04AA0:  MOVWF  FEA
04AA2:  MOVFF  FEF,9D2
04AA6:  MOVFF  FEC,9D3
04AAA:  MOVFF  FEC,9D4
04AAE:  MOVFF  FEC,9D5
04AB2:  MOVLW  03
04AB4:  ADDWF  x0E,W
04AB6:  MOVWF  FE9
04AB8:  MOVLW  00
04ABA:  ADDWFC x0F,W
04ABC:  MOVWF  FEA
04ABE:  MOVFF  FEF,9D6
04AC2:  MOVLB  9
04AC4:  MOVFF  FEA,9C5
04AC8:  MOVFF  FE9,9C4
04ACC:  CLRF   xD9
04ACE:  CLRF   xD8
04AD0:  CLRF   xD7
04AD2:  MOVLB  0
04AD4:  RCALL  4778
04AD6:  MOVFF  9C5,FEA
04ADA:  MOVFF  9C4,FE9
04ADE:  MOVFF  03,9C2
04AE2:  MOVFF  02,9C1
04AE6:  MOVFF  01,9C0
04AEA:  MOVFF  00,9BF
04AEE:  MOVLW  10
04AF0:  MOVLB  7
04AF2:  ADDWF  x0E,W
04AF4:  MOVWF  FE9
04AF6:  MOVLW  00
04AF8:  ADDWFC x0F,W
04AFA:  MOVWF  FEA
04AFC:  MOVFF  FEF,00
04B00:  MOVFF  FEC,01
04B04:  MOVFF  FEC,02
04B08:  MOVFF  FEC,03
04B0C:  MOVF   00,W
04B0E:  MOVLB  9
04B10:  ADDWF  xBF,W
04B12:  MOVWF  xB7
04B14:  MOVF   01,W
04B16:  ADDWFC xC0,W
04B18:  MOVWF  xB8
04B1A:  MOVF   02,W
04B1C:  ADDWFC xC1,W
04B1E:  MOVWF  xB9
04B20:  MOVF   03,W
04B22:  ADDWFC xC2,W
04B24:  MOVWF  xBA
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04B26:  MOVF   xB2,W
04B28:  SUBLW  03
04B2A:  BNZ   4B9C
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04B2C:  MOVLW  14
04B2E:  MOVLB  7
04B30:  ADDWF  x0E,W
04B32:  MOVWF  01
04B34:  MOVLW  00
04B36:  ADDWFC x0F,W
04B38:  MOVWF  03
04B3A:  MOVFF  01,9BF
04B3E:  MOVLB  9
04B40:  MOVWF  xC0
04B42:  MOVLW  50
04B44:  MOVLB  7
04B46:  ADDWF  x0E,W
04B48:  MOVWF  01
04B4A:  MOVLW  00
04B4C:  ADDWFC x0F,W
04B4E:  MOVFF  01,FE9
04B52:  MOVWF  FEA
04B54:  MOVFF  FEF,00
04B58:  MOVFF  FEC,01
04B5C:  MOVFF  FEC,02
04B60:  MOVFF  FEC,03
04B64:  MOVFF  9C0,FEA
04B68:  MOVFF  9BF,FE9
04B6C:  MOVFF  00,FEF
04B70:  MOVFF  01,FEC
04B74:  MOVFF  02,FEC
04B78:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04B7C:  MOVLW  18
04B7E:  ADDWF  x0E,W
04B80:  MOVWF  FE9
04B82:  MOVLW  00
04B84:  ADDWFC x0F,W
04B86:  MOVWF  FEA
04B88:  MOVFF  9B7,FEF
04B8C:  MOVFF  9B8,FEC
04B90:  MOVFF  9B9,FEC
04B94:  MOVFF  9BA,FEC
....................       }  
04B98:  BRA    4C28
04B9A:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04B9C:  MOVLW  14
04B9E:  MOVLB  7
04BA0:  ADDWF  x0E,W
04BA2:  MOVWF  FE9
04BA4:  MOVLW  00
04BA6:  ADDWFC x0F,W
04BA8:  MOVWF  FEA
04BAA:  MOVFF  9B7,FEF
04BAE:  MOVFF  9B8,FEC
04BB2:  MOVFF  9B9,FEC
04BB6:  MOVFF  9BA,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04BBA:  MOVLW  18
04BBC:  ADDWF  x0E,W
04BBE:  MOVWF  01
04BC0:  MOVLW  00
04BC2:  ADDWFC x0F,W
04BC4:  MOVFF  01,9BF
04BC8:  MOVLB  9
04BCA:  MOVWF  xC0
04BCC:  MOVLW  04
04BCE:  MOVLB  7
04BD0:  ADDWF  x0E,W
04BD2:  MOVWF  FE9
04BD4:  MOVLW  00
04BD6:  ADDWFC x0F,W
04BD8:  MOVWF  FEA
04BDA:  MOVFF  FEC,9C2
04BDE:  MOVF   FED,F
04BE0:  MOVFF  FEF,9C1
04BE4:  MOVLB  9
04BE6:  RRCF   xC2,F
04BE8:  RRCF   xC1,F
04BEA:  RRCF   xC2,F
04BEC:  RRCF   xC1,F
04BEE:  RRCF   xC2,F
04BF0:  RRCF   xC1,F
04BF2:  RRCF   xC2,F
04BF4:  RRCF   xC1,F
04BF6:  MOVLW  0F
04BF8:  ANDWF  xC2,F
04BFA:  MOVF   xC1,W
04BFC:  ADDWF  xB7,W
04BFE:  MOVWF  00
04C00:  MOVF   xC2,W
04C02:  ADDWFC xB8,W
04C04:  MOVWF  01
04C06:  MOVLW  00
04C08:  ADDWFC xB9,W
04C0A:  MOVWF  02
04C0C:  MOVLW  00
04C0E:  ADDWFC xBA,W
04C10:  MOVFF  9C0,FEA
04C14:  MOVFF  9BF,FE9
04C18:  MOVFF  00,FEF
04C1C:  MOVFF  01,FEC
04C20:  MOVFF  02,FEC
04C24:  MOVWF  FEC
04C26:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04C28:  MOVLW  44
04C2A:  ADDWF  x0E,W
04C2C:  MOVWF  01
04C2E:  MOVLW  00
04C30:  ADDWFC x0F,W
04C32:  MOVFF  01,FE9
04C36:  MOVWF  FEA
04C38:  MOVFF  FEF,9BB
04C3C:  MOVFF  FEC,9BC
04C40:  MOVFF  FEC,9BD
04C44:  MOVFF  FEC,9BE
....................    if (!maxsect)  
04C48:  MOVLB  9
04C4A:  MOVF   xBB,F
04C4C:  BNZ   4C7C
04C4E:  MOVF   xBC,F
04C50:  BNZ   4C7C
04C52:  MOVF   xBD,F
04C54:  BNZ   4C7C
04C56:  MOVF   xBE,F
04C58:  BNZ   4C7C
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04C5A:  MOVLW  37
04C5C:  MOVLB  7
04C5E:  ADDWF  x0E,W
04C60:  MOVWF  01
04C62:  MOVLW  00
04C64:  ADDWFC x0F,W
04C66:  MOVFF  01,FE9
04C6A:  MOVWF  FEA
04C6C:  MOVLB  9
04C6E:  CLRF   xBE
04C70:  CLRF   xBD
04C72:  MOVFF  FEC,9BC
04C76:  MOVF   FED,F
04C78:  MOVFF  FEF,9BB
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04C7C:  MOVLW  0C
04C7E:  MOVLB  7
04C80:  ADDWF  x0E,W
04C82:  MOVWF  01
04C84:  MOVLW  00
04C86:  ADDWFC x0F,W
04C88:  MOVWF  03
04C8A:  MOVFF  01,9BF
04C8E:  MOVLB  9
04C90:  MOVWF  xC0
04C92:  MOVLW  18
04C94:  MOVLB  7
04C96:  ADDWF  x0E,W
04C98:  MOVWF  FE9
04C9A:  MOVLW  00
04C9C:  ADDWFC x0F,W
04C9E:  MOVWF  FEA
04CA0:  MOVFF  FEF,00
04CA4:  MOVFF  FEC,01
04CA8:  MOVFF  FEC,02
04CAC:  MOVFF  FEC,03
04CB0:  MOVF   00,W
04CB2:  MOVLB  9
04CB4:  SUBWF  xBB,W
04CB6:  MOVWF  xC1
04CB8:  MOVF   01,W
04CBA:  SUBWFB xBC,W
04CBC:  MOVWF  xC2
04CBE:  MOVF   02,W
04CC0:  SUBWFB xBD,W
04CC2:  MOVWF  xC3
04CC4:  MOVF   03,W
04CC6:  SUBWFB xBE,W
04CC8:  MOVWF  xC4
04CCA:  MOVF   xB3,W
04CCC:  ADDWF  xC1,F
04CCE:  MOVF   xB4,W
04CD0:  ADDWFC xC2,F
04CD2:  MOVF   xB5,W
04CD4:  ADDWFC xC3,F
04CD6:  MOVF   xB6,W
04CD8:  ADDWFC xC4,F
04CDA:  MOVLW  02
04CDC:  MOVLB  7
04CDE:  ADDWF  x0E,W
04CE0:  MOVWF  FE9
04CE2:  MOVLW  00
04CE4:  ADDWFC x0F,W
04CE6:  MOVWF  FEA
04CE8:  MOVFF  FEF,A28
04CEC:  MOVLB  9
04CEE:  MOVFF  FEA,9C7
04CF2:  MOVFF  FE9,9C6
04CF6:  BCF    FD8.1
04CF8:  CLRF   1B
04CFA:  BTFSC  FF2.7
04CFC:  BSF    1B.7
04CFE:  BCF    FF2.7
04D00:  MOVFF  9C4,A27
04D04:  MOVFF  9C3,A26
04D08:  MOVFF  9C2,A25
04D0C:  MOVFF  9C1,A24
04D10:  MOVLB  A
04D12:  CLRF   x2B
04D14:  CLRF   x2A
04D16:  CLRF   x29
04D18:  MOVLB  0
04D1A:  CALL   1038
04D1E:  BTFSC  1B.7
04D20:  BSF    FF2.7
04D22:  MOVFF  9C7,FEA
04D26:  MOVFF  9C6,FE9
04D2A:  MOVFF  03,9C4
04D2E:  MOVFF  02,9C3
04D32:  MOVFF  01,9C2
04D36:  MOVFF  00,9C1
04D3A:  MOVLW  02
04D3C:  MOVLB  9
04D3E:  ADDWF  00,W
04D40:  MOVWF  00
04D42:  MOVLW  00
04D44:  ADDWFC 01,W
04D46:  MOVWF  01
04D48:  MOVLW  00
04D4A:  ADDWFC 02,W
04D4C:  MOVWF  02
04D4E:  MOVLW  00
04D50:  ADDWFC 03,W
04D52:  MOVFF  9C0,FEA
04D56:  MOVFF  9BF,FE9
04D5A:  MOVFF  00,FEF
04D5E:  MOVFF  01,FEC
04D62:  MOVFF  02,FEC
04D66:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04D68:  MOVLW  00
04D6A:  MOVWF  01
04D6C:  MOVLB  7
04D6E:  MOVLB  0
04D70:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
070A8:  CALL   5526
070AC:  MOVFF  01,99F
....................    if (result != FR_OK)  
070B0:  MOVLB  9
070B2:  MOVF   x9F,F
070B4:  BZ    70BC
....................       return (result); 
070B6:  MOVFF  99F,01
070BA:  BRA    74EC
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
070BC:  MOVF   x90,W
070BE:  ANDLW  0A
070C0:  BZ    70D8
070C2:  MOVLB  0
070C4:  CALL   5518
070C8:  BTFSC  01.2
070CA:  BRA    70D0
070CC:  MOVLB  9
070CE:  BRA    70D8
....................          return (FR_WRITE_PROTECTED); 
070D0:  MOVLW  0A
070D2:  MOVWF  01
070D4:  MOVLB  9
070D6:  BRA    74EC
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
070D8:  MOVLW  09
070DA:  MOVWF  xB3
070DC:  MOVLW  91
070DE:  MOVWF  xB2
070E0:  MOVLW  09
070E2:  MOVWF  xB5
070E4:  MOVLW  A2
070E6:  MOVWF  xB4
070E8:  MOVFF  98F,9B7
070EC:  MOVFF  98E,9B6
070F0:  MOVLW  09
070F2:  MOVWF  xB9
070F4:  MOVLW  A0
070F6:  MOVWF  xB8
070F8:  MOVLB  0
070FA:  CALL   6156
070FE:  MOVFF  01,99F
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
07102:  MOVLB  9
07104:  MOVF   x90,W
07106:  ANDLW  18
07108:  BTFSC  FD8.2
0710A:  BRA    732E
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
0710C:  MOVF   x9F,F
0710E:  BZ    7196
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
07110:  BSF    x90.3
....................          if (result != FR_NO_FILE) 
07112:  MOVF   x9F,W
07114:  SUBLW  02
07116:  BZ    711E
....................             return (result); 
07118:  MOVFF  99F,01
0711C:  BRA    74EC
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
0711E:  MOVLW  09
07120:  MOVWF  xB3
07122:  MOVLW  91
07124:  MOVWF  xB2
07126:  MOVLB  0
07128:  BRA    6B54
0712A:  MOVFF  02,9A1
0712E:  MOVFF  01,9A0
....................          if (dir_ptr == NULL) 
07132:  MOVLB  9
07134:  MOVF   xA0,F
07136:  BNZ   7142
07138:  MOVF   xA1,F
0713A:  BNZ   7142
....................             return (FR_DENIED); 
0713C:  MOVLW  05
0713E:  MOVWF  01
07140:  BRA    74EC
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
07142:  MOVFF  9A1,FEA
07146:  MOVFF  9A0,FE9
0714A:  MOVLW  09
0714C:  MOVWF  FE2
0714E:  MOVLW  A2
07150:  MOVWF  FE1
07152:  MOVLW  0B
07154:  MOVWF  01
07156:  MOVFF  FE6,FEE
0715A:  DECFSZ 01,F
0715C:  BRA    7156
....................          *(dir_ptr+12) = fn[11]; 
0715E:  MOVLW  0C
07160:  ADDWF  xA0,W
07162:  MOVWF  01
07164:  MOVLW  00
07166:  ADDWFC xA1,W
07168:  MOVFF  01,FE9
0716C:  MOVWF  FEA
0716E:  MOVFF  9AD,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
07172:  MOVLW  0D
07174:  ADDWF  xA0,W
07176:  MOVWF  xB2
07178:  MOVLW  00
0717A:  ADDWFC xA1,W
0717C:  MOVWF  xB3
0717E:  MOVWF  FEA
07180:  MOVFF  9B2,FE9
07184:  CLRF   00
07186:  CLRF   02
07188:  MOVLW  13
0718A:  MOVWF  01
0718C:  MOVLB  0
0718E:  CALL   34A4
....................       }  
07192:  BRA    72A8
07194:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
07196:  MOVF   xA0,F
07198:  BNZ   719E
0719A:  MOVF   xA1,F
0719C:  BZ    71B6
0719E:  MOVLW  0B
071A0:  ADDWF  xA0,W
071A2:  MOVWF  01
071A4:  MOVLW  00
071A6:  ADDWFC xA1,W
071A8:  MOVWF  03
071AA:  MOVFF  01,FE9
071AE:  MOVWF  FEA
071B0:  MOVF   FEF,W
071B2:  ANDLW  11
071B4:  BZ    71BC
....................             return (FR_DENIED); 
071B6:  MOVLW  05
071B8:  MOVWF  01
071BA:  BRA    74EC
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
071BC:  BTFSS  x90.3
071BE:  BRA    72A6
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
071C0:  MOVLW  20
071C2:  MOVLB  7
071C4:  ADDWF  x0E,W
071C6:  MOVWF  FE9
071C8:  MOVLW  00
071CA:  ADDWFC x0F,W
071CC:  MOVWF  FEA
071CE:  MOVFF  FEF,9AE
071D2:  MOVFF  FEC,9AF
071D6:  MOVFF  FEC,9B0
071DA:  MOVFF  FEC,9B1
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
071DE:  MOVLW  14
071E0:  MOVLB  9
071E2:  ADDWF  xA0,W
071E4:  MOVWF  01
071E6:  MOVLW  00
071E8:  ADDWFC xA1,W
071EA:  MOVWF  03
071EC:  MOVFF  01,FE9
071F0:  MOVWF  FEA
071F2:  MOVFF  FEC,9BA
071F6:  MOVF   FED,F
071F8:  MOVFF  FEF,9B2
071FC:  CLRF   xB4
071FE:  MOVFF  9B2,9B9
07202:  CLRF   xB2
07204:  CLRF   xB3
07206:  MOVLW  1A
07208:  ADDWF  xA0,W
0720A:  MOVWF  01
0720C:  MOVLW  00
0720E:  ADDWFC xA1,W
07210:  MOVFF  01,FE9
07214:  MOVWF  FEA
07216:  MOVFF  FEC,03
0721A:  MOVF   FED,F
0721C:  MOVF   FEF,W
0721E:  IORWF  xB2,F
07220:  MOVF   03,W
07222:  IORWF  xB3,F
07224:  MOVFF  9B3,9B8
07228:  MOVFF  9B2,9B7
0722C:  MOVLB  0
0722E:  RCALL  6E98
07230:  MOVF   01,F
07232:  BZ    724C
07234:  MOVFF  9B1,9EF
07238:  MOVFF  9B0,9EE
0723C:  MOVFF  9AF,9ED
07240:  MOVFF  9AE,9EC
07244:  CALL   5A0C
07248:  MOVF   01,F
0724A:  BNZ   7256
....................                return (FR_RW_ERROR); 
0724C:  MOVLW  07
0724E:  MOVWF  01
07250:  MOVLB  9
07252:  BRA    74EC
07254:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
07256:  MOVLW  14
07258:  MOVLB  9
0725A:  ADDWF  xA0,W
0725C:  MOVWF  01
0725E:  MOVLW  00
07260:  ADDWFC xA1,W
07262:  MOVFF  01,FE9
07266:  MOVWF  FEA
07268:  CLRF   FEC
0726A:  MOVF   FED,F
0726C:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
0726E:  MOVLW  1A
07270:  ADDWF  xA0,W
07272:  MOVWF  01
07274:  MOVLW  00
07276:  ADDWFC xA1,W
07278:  MOVFF  01,FE9
0727C:  MOVWF  FEA
0727E:  CLRF   FEC
07280:  MOVF   FED,F
07282:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
07284:  MOVLW  1C
07286:  ADDWF  xA0,W
07288:  MOVWF  01
0728A:  MOVLW  00
0728C:  ADDWFC xA1,W
0728E:  MOVFF  01,FE9
07292:  MOVWF  FEA
07294:  MOVF   FEE,F
07296:  MOVF   FEE,F
07298:  CLRF   FEC
0729A:  MOVF   FED,F
0729C:  CLRF   FEF
0729E:  MOVF   FED,F
072A0:  CLRF   FEF
072A2:  MOVF   FED,F
072A4:  CLRF   FEF
072A6:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
072A8:  MOVLB  9
072AA:  BTFSS  x90.3
072AC:  BRA    732C
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
072AE:  MOVLW  0B
072B0:  ADDWF  xA0,W
072B2:  MOVWF  01
072B4:  MOVLW  00
072B6:  ADDWFC xA1,W
072B8:  MOVFF  01,FE9
072BC:  MOVWF  FEA
072BE:  MOVLW  20
072C0:  MOVWF  FEF
....................          dw = get_fattime(); 
072C2:  MOVLB  0
072C4:  RCALL  6F38
072C6:  MOVFF  03,9B1
072CA:  MOVFF  02,9B0
072CE:  MOVFF  01,9AF
072D2:  MOVFF  00,9AE
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
072D6:  MOVLW  0E
072D8:  MOVLB  9
072DA:  ADDWF  xA0,W
072DC:  MOVWF  01
072DE:  MOVLW  00
072E0:  ADDWFC xA1,W
072E2:  MOVFF  01,FE9
072E6:  MOVWF  FEA
072E8:  MOVFF  9AE,FEF
072EC:  MOVFF  9AF,FEC
072F0:  MOVFF  9B0,FEC
072F4:  MOVFF  9B1,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
072F8:  MOVLW  16
072FA:  ADDWF  xA0,W
072FC:  MOVWF  01
072FE:  MOVLW  00
07300:  ADDWFC xA1,W
07302:  MOVFF  01,FE9
07306:  MOVWF  FEA
07308:  MOVFF  9AE,FEF
0730C:  MOVFF  9AF,FEC
07310:  MOVFF  9B0,FEC
07314:  MOVFF  9B1,FEC
....................          fs->winflag = 1; 
07318:  MOVLW  06
0731A:  MOVLB  7
0731C:  ADDWF  x0E,W
0731E:  MOVWF  FE9
07320:  MOVLW  00
07322:  ADDWFC x0F,W
07324:  MOVWF  FEA
07326:  MOVLW  01
07328:  MOVWF  FEF
0732A:  MOVLB  9
....................       } 
....................    } 
0732C:  BRA    737C
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
0732E:  MOVF   x9F,F
07330:  BZ    7338
....................          return (result);      // Trace failed  
07332:  MOVFF  99F,01
07336:  BRA    74EC
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
07338:  MOVF   xA0,F
0733A:  BNZ   7340
0733C:  MOVF   xA1,F
0733E:  BZ    7356
07340:  MOVLW  0B
07342:  ADDWF  xA0,W
07344:  MOVWF  01
07346:  MOVLW  00
07348:  ADDWFC xA1,W
0734A:  MOVWF  03
0734C:  MOVFF  01,FE9
07350:  MOVWF  FEA
07352:  BTFSS  FEF.4
07354:  BRA    735C
....................          return (FR_NO_FILE); 
07356:  MOVLW  02
07358:  MOVWF  01
0735A:  BRA    74EC
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
0735C:  BTFSS  x90.1
0735E:  BRA    737C
07360:  MOVLW  0B
07362:  ADDWF  xA0,W
07364:  MOVWF  01
07366:  MOVLW  00
07368:  ADDWFC xA1,W
0736A:  MOVWF  03
0736C:  MOVFF  01,FE9
07370:  MOVWF  FEA
07372:  BTFSS  FEF.0
07374:  BRA    737C
....................          return (FR_DENIED); 
07376:  MOVLW  05
07378:  MOVWF  01
0737A:  BRA    74EC
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
0737C:  MOVLW  1A
0737E:  ADDWF  x8C,W
07380:  MOVWF  FE9
07382:  MOVLW  00
07384:  ADDWFC x8D,W
07386:  MOVWF  FEA
07388:  MOVF   x90,W
0738A:  ANDLW  03
0738C:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
0738E:  MOVLW  14
07390:  ADDWF  x8C,W
07392:  MOVWF  01
07394:  MOVLW  00
07396:  ADDWFC x8D,W
07398:  MOVWF  03
0739A:  MOVFF  01,9B2
0739E:  MOVWF  xB3
073A0:  MOVLW  20
073A2:  MOVLB  7
073A4:  ADDWF  x0E,W
073A6:  MOVWF  FE9
073A8:  MOVLW  00
073AA:  ADDWFC x0F,W
073AC:  MOVWF  FEA
073AE:  MOVFF  FEF,00
073B2:  MOVFF  FEC,01
073B6:  MOVFF  FEC,02
073BA:  MOVFF  FEC,03
073BE:  MOVFF  9B3,FEA
073C2:  MOVFF  9B2,FE9
073C6:  MOVFF  00,FEF
073CA:  MOVFF  01,FEC
073CE:  MOVFF  02,FEC
073D2:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
073D6:  MOVLW  18
073D8:  MOVLB  9
073DA:  ADDWF  x8C,W
073DC:  MOVWF  FE9
073DE:  MOVLW  00
073E0:  ADDWFC x8D,W
073E2:  MOVWF  FEA
073E4:  MOVFF  9A1,FEC
073E8:  MOVF   FED,F
073EA:  MOVFF  9A0,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
073EE:  MOVLW  08
073F0:  ADDWF  x8C,W
073F2:  MOVWF  01
073F4:  MOVLW  00
073F6:  ADDWFC x8D,W
073F8:  MOVWF  03
073FA:  MOVFF  01,9B2
073FE:  MOVWF  xB3
07400:  MOVLW  14
07402:  ADDWF  xA0,W
07404:  MOVWF  01
07406:  MOVLW  00
07408:  ADDWFC xA1,W
0740A:  MOVWF  03
0740C:  MOVFF  01,FE9
07410:  MOVWF  FEA
07412:  MOVFF  FEC,9B7
07416:  MOVF   FED,F
07418:  MOVFF  FEF,9B4
0741C:  CLRF   xB6
0741E:  MOVFF  9B4,9B6
07422:  CLRF   xB4
07424:  CLRF   xB5
07426:  MOVLW  1A
07428:  ADDWF  xA0,W
0742A:  MOVWF  01
0742C:  MOVLW  00
0742E:  ADDWFC xA1,W
07430:  MOVFF  01,FE9
07434:  MOVWF  FEA
07436:  MOVFF  FEC,03
0743A:  MOVF   FED,F
0743C:  MOVF   FEF,W
0743E:  IORWF  xB4,W
07440:  MOVWF  00
07442:  MOVF   03,W
07444:  IORWF  xB5,W
07446:  MOVFF  9B6,02
0744A:  MOVFF  9B7,03
0744E:  MOVFF  9B3,FEA
07452:  MOVFF  9B2,FE9
07456:  MOVFF  00,FEF
0745A:  MOVWF  FEC
0745C:  MOVFF  9B6,FEC
07460:  MOVFF  9B7,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
07464:  MOVLW  04
07466:  ADDWF  x8C,W
07468:  MOVWF  01
0746A:  MOVLW  00
0746C:  ADDWFC x8D,W
0746E:  MOVWF  03
07470:  MOVFF  01,9B2
07474:  MOVWF  xB3
07476:  MOVLW  1C
07478:  ADDWF  xA0,W
0747A:  MOVWF  01
0747C:  MOVLW  00
0747E:  ADDWFC xA1,W
07480:  MOVFF  01,FE9
07484:  MOVWF  FEA
07486:  MOVFF  FEF,00
0748A:  MOVFF  FEC,01
0748E:  MOVFF  FEC,02
07492:  MOVFF  FEC,03
07496:  MOVFF  9B3,FEA
0749A:  MOVFF  9B2,FE9
0749E:  MOVFF  00,FEF
074A2:  MOVFF  01,FEC
074A6:  MOVFF  02,FEC
074AA:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
074AE:  MOVFF  98C,FE9
074B2:  MOVFF  98D,FEA
074B6:  MOVF   FEE,F
074B8:  MOVF   FEE,F
074BA:  CLRF   FEC
074BC:  MOVF   FED,F
074BE:  CLRF   FEF
074C0:  MOVF   FED,F
074C2:  CLRF   FEF
074C4:  MOVF   FED,F
074C6:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
074C8:  MOVLW  1B
074CA:  ADDWF  x8C,W
074CC:  MOVWF  FE9
074CE:  MOVLW  00
074D0:  ADDWFC x8D,W
074D2:  MOVWF  FEA
074D4:  MOVLW  01
074D6:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
074D8:  MOVLB  7
074DA:  ADDWF  x0E,W
074DC:  MOVWF  FE9
074DE:  MOVLW  00
074E0:  ADDWFC x0F,W
074E2:  MOVWF  FEA
074E4:  INCF   FEF,F
....................    return (FR_OK); 
074E6:  MOVLW  00
074E8:  MOVWF  01
074EA:  MOVLB  9
074EC:  MOVLB  0
074EE:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B0E4:  MOVFF  8A7,8BC
0B0E8:  MOVFF  8A6,8BB
....................       *br = 0; 
0B0EC:  MOVLB  8
0B0EE:  MOVFF  8AA,FE9
0B0F2:  MOVFF  8AB,FEA
0B0F6:  CLRF   FEC
0B0F8:  MOVF   FED,F
0B0FA:  CLRF   FEF
....................       if (!fs)  
0B0FC:  MOVLB  7
0B0FE:  MOVF   x0E,W
0B100:  IORWF  x0F,W
0B102:  BNZ   B10A
....................          return (FR_NOT_ENABLED); 
0B104:  MOVLW  0B
0B106:  MOVWF  01
0B108:  BRA    B5EC
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B10A:  MOVLB  0
0B10C:  CALL   5518
0B110:  BTFSC  01.0
0B112:  BRA    B124
0B114:  MOVLB  7
0B116:  MOVFF  70E,FE9
0B11A:  MOVFF  70F,FEA
0B11E:  MOVF   FEF,F
0B120:  BNZ   B12C
0B122:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B124:  MOVLW  01
0B126:  MOVWF  01
0B128:  MOVLB  7
0B12A:  BRA    B5EC
....................     
....................       if (fp->flag & FA__ERROR) 
0B12C:  MOVLW  1A
0B12E:  MOVLB  8
0B130:  ADDWF  xA4,W
0B132:  MOVWF  FE9
0B134:  MOVLW  00
0B136:  ADDWFC xA5,W
0B138:  MOVWF  FEA
0B13A:  BTFSS  FEF.7
0B13C:  BRA    B148
....................          return (FR_RW_ERROR);   // Check error flag  
0B13E:  MOVLW  07
0B140:  MOVWF  01
0B142:  MOVLB  7
0B144:  BRA    B5EC
0B146:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B148:  MOVLW  1A
0B14A:  ADDWF  xA4,W
0B14C:  MOVWF  FE9
0B14E:  MOVLW  00
0B150:  ADDWFC xA5,W
0B152:  MOVWF  FEA
0B154:  BTFSC  FEF.0
0B156:  BRA    B162
....................          return (FR_DENIED);      // Check access mode  
0B158:  MOVLW  05
0B15A:  MOVWF  01
0B15C:  MOVLB  7
0B15E:  BRA    B5EC
0B160:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B162:  MOVLW  04
0B164:  ADDWF  xA4,W
0B166:  MOVWF  FE9
0B168:  MOVLW  00
0B16A:  ADDWFC xA5,W
0B16C:  MOVWF  FEA
0B16E:  MOVFF  FEF,8BD
0B172:  MOVFF  FEC,8BE
0B176:  MOVFF  FEC,8BF
0B17A:  MOVFF  FEC,8C0
0B17E:  MOVFF  8A4,FE9
0B182:  MOVFF  8A5,FEA
0B186:  MOVFF  FEF,00
0B18A:  MOVFF  FEC,01
0B18E:  MOVFF  FEC,02
0B192:  MOVFF  FEC,03
0B196:  MOVF   00,W
0B198:  SUBWF  xBD,W
0B19A:  MOVWF  xB4
0B19C:  MOVF   01,W
0B19E:  SUBWFB xBE,W
0B1A0:  MOVWF  xB5
0B1A2:  MOVF   02,W
0B1A4:  SUBWFB xBF,W
0B1A6:  MOVWF  xB6
0B1A8:  MOVF   03,W
0B1AA:  SUBWFB xC0,W
0B1AC:  MOVWF  xB7
....................       if (btr > ln) 
0B1AE:  MOVF   xB7,F
0B1B0:  BNZ   B1CC
0B1B2:  MOVF   xB6,F
0B1B4:  BNZ   B1CC
0B1B6:  MOVF   xB5,W
0B1B8:  SUBWF  xA9,W
0B1BA:  BNC   B1CC
0B1BC:  BNZ   B1C4
0B1BE:  MOVF   xA8,W
0B1C0:  SUBWF  xB4,W
0B1C2:  BC    B1CC
....................          btr = ln;            // Truncate read count by number of bytes left  
0B1C4:  MOVFF  8B5,8A9
0B1C8:  MOVFF  8B4,8A8
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B1CC:  MOVF   xA8,W
0B1CE:  IORWF  xA9,W
0B1D0:  BTFSC  FD8.2
0B1D2:  BRA    B5CA
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B1D4:  MOVFF  8A4,FE9
0B1D8:  MOVFF  8A5,FEA
0B1DC:  MOVFF  FEF,8BD
0B1E0:  MOVFF  FEC,8BE
0B1E4:  MOVFF  FEC,8BF
0B1E8:  MOVFF  FEC,8C0
0B1EC:  MOVLW  01
0B1EE:  ANDWF  xBE,F
0B1F0:  CLRF   xBF
0B1F2:  CLRF   xC0
0B1F4:  MOVF   xBD,F
0B1F6:  BTFSS  FD8.2
0B1F8:  BRA    B472
0B1FA:  MOVF   xBE,F
0B1FC:  BTFSS  FD8.2
0B1FE:  BRA    B472
0B200:  MOVF   xBF,F
0B202:  BTFSS  FD8.2
0B204:  BRA    B472
0B206:  MOVF   xC0,F
0B208:  BTFSS  FD8.2
0B20A:  BRA    B472
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B20C:  MOVLW  1B
0B20E:  ADDWF  xA4,W
0B210:  MOVWF  FE9
0B212:  MOVLW  00
0B214:  ADDWFC xA5,W
0B216:  MOVWF  FEA
0B218:  DECF   FEF,F
0B21A:  BZ    B252
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B21C:  MOVLW  10
0B21E:  ADDWF  xA4,W
0B220:  MOVWF  FE9
0B222:  MOVLW  00
0B224:  ADDWFC xA5,W
0B226:  MOVWF  FEA
0B228:  MOVFF  FEF,8BD
0B22C:  MOVFF  FEC,8BE
0B230:  MOVFF  FEC,8BF
0B234:  MOVFF  FEC,8C0
0B238:  MOVLW  01
0B23A:  ADDWF  xBD,W
0B23C:  MOVWF  xB0
0B23E:  MOVLW  00
0B240:  ADDWFC xBE,W
0B242:  MOVWF  xB1
0B244:  MOVLW  00
0B246:  ADDWFC xBF,W
0B248:  MOVWF  xB2
0B24A:  MOVLW  00
0B24C:  ADDWFC xC0,W
0B24E:  MOVWF  xB3
....................                }  
0B250:  BRA    B38E
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B252:  MOVFF  8A4,FE9
0B256:  MOVFF  8A5,FEA
0B25A:  MOVFF  FEF,8BD
0B25E:  MOVFF  FEC,8BE
0B262:  MOVFF  FEC,8BF
0B266:  MOVFF  FEC,8C0
0B26A:  MOVF   xBD,F
0B26C:  BNZ   B298
0B26E:  MOVF   xBE,F
0B270:  BNZ   B298
0B272:  MOVF   xBF,F
0B274:  BNZ   B298
0B276:  MOVF   xC0,F
0B278:  BNZ   B298
0B27A:  MOVLW  08
0B27C:  ADDWF  xA4,W
0B27E:  MOVWF  FE9
0B280:  MOVLW  00
0B282:  ADDWFC xA5,W
0B284:  MOVWF  FEA
0B286:  MOVFF  FEF,00
0B28A:  MOVFF  FEC,01
0B28E:  MOVFF  FEC,02
0B292:  MOVFF  FEC,03
0B296:  BRA    B2BC
0B298:  MOVLW  0C
0B29A:  ADDWF  xA4,W
0B29C:  MOVWF  FE9
0B29E:  MOVLW  00
0B2A0:  ADDWFC xA5,W
0B2A2:  MOVWF  FEA
0B2A4:  MOVFF  FEF,9D8
0B2A8:  MOVFF  FEC,9D9
0B2AC:  MOVFF  FEC,9DA
0B2B0:  MOVFF  FEC,9DB
0B2B4:  MOVLB  0
0B2B6:  CALL   5C44
0B2BA:  MOVLB  8
0B2BC:  MOVFF  03,8AF
0B2C0:  MOVFF  02,8AE
0B2C4:  MOVFF  01,8AD
0B2C8:  MOVFF  00,8AC
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B2CC:  MOVF   xAF,F
0B2CE:  BNZ   B2DE
0B2D0:  MOVF   xAE,F
0B2D2:  BNZ   B2DE
0B2D4:  MOVF   xAD,F
0B2D6:  BNZ   B2DE
0B2D8:  MOVF   xAC,W
0B2DA:  SUBLW  01
0B2DC:  BC    B31C
0B2DE:  MOVLW  0C
0B2E0:  MOVLB  7
0B2E2:  ADDWF  x0E,W
0B2E4:  MOVWF  FE9
0B2E6:  MOVLW  00
0B2E8:  ADDWFC x0F,W
0B2EA:  MOVWF  FEA
0B2EC:  MOVFF  FEF,00
0B2F0:  MOVFF  FEC,01
0B2F4:  MOVFF  FEC,02
0B2F8:  MOVFF  FEC,03
0B2FC:  MOVF   03,W
0B2FE:  MOVLB  8
0B300:  SUBWF  xAF,W
0B302:  BNC   B31E
0B304:  BNZ   B31C
0B306:  MOVF   02,W
0B308:  SUBWF  xAE,W
0B30A:  BNC   B31E
0B30C:  BNZ   B31C
0B30E:  MOVF   01,W
0B310:  SUBWF  xAD,W
0B312:  BNC   B31E
0B314:  BNZ   B31C
0B316:  MOVF   00,W
0B318:  SUBWF  xAC,W
0B31A:  BNC   B31E
....................                   goto fr_error; 
0B31C:  BRA    B5D4
....................                fp->curr_clust = clust;            // Current cluster  
0B31E:  MOVLW  0C
0B320:  ADDWF  xA4,W
0B322:  MOVWF  FE9
0B324:  MOVLW  00
0B326:  ADDWFC xA5,W
0B328:  MOVWF  FEA
0B32A:  MOVFF  8AC,FEF
0B32E:  MOVFF  8AD,FEC
0B332:  MOVFF  8AE,FEC
0B336:  MOVFF  8AF,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B33A:  MOVFF  8AF,9CE
0B33E:  MOVFF  8AE,9CD
0B342:  MOVFF  8AD,9CC
0B346:  MOVFF  8AC,9CB
0B34A:  MOVLB  0
0B34C:  CALL   5588
0B350:  MOVFF  03,8B3
0B354:  MOVFF  02,8B2
0B358:  MOVFF  01,8B1
0B35C:  MOVFF  00,8B0
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B360:  MOVLW  1B
0B362:  MOVLB  8
0B364:  ADDWF  xA4,W
0B366:  MOVWF  01
0B368:  MOVLW  00
0B36A:  ADDWFC xA5,W
0B36C:  MOVWF  03
0B36E:  MOVLW  02
0B370:  MOVLB  7
0B372:  ADDWF  x0E,W
0B374:  MOVWF  FE9
0B376:  MOVLW  00
0B378:  ADDWFC x0F,W
0B37A:  MOVWF  FEA
0B37C:  MOVFF  FEF,8BF
0B380:  MOVLB  8
0B382:  MOVFF  03,FEA
0B386:  MOVFF  01,FE9
0B38A:  MOVFF  8BF,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B38E:  MOVLW  10
0B390:  ADDWF  xA4,W
0B392:  MOVWF  FE9
0B394:  MOVLW  00
0B396:  ADDWFC xA5,W
0B398:  MOVWF  FEA
0B39A:  MOVFF  8B0,FEF
0B39E:  MOVFF  8B1,FEC
0B3A2:  MOVFF  8B2,FEC
0B3A6:  MOVFF  8B3,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B3AA:  BCF    FD8.0
0B3AC:  RRCF   xA9,W
0B3AE:  MOVWF  xBA
....................             if (cc)  
0B3B0:  MOVF   xBA,F
0B3B2:  BZ    B472
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B3B4:  MOVLW  1B
0B3B6:  ADDWF  xA4,W
0B3B8:  MOVWF  FE9
0B3BA:  MOVLW  00
0B3BC:  ADDWFC xA5,W
0B3BE:  MOVWF  FEA
0B3C0:  MOVF   FEF,W
0B3C2:  SUBWF  xBA,W
0B3C4:  BZ    B3D8
0B3C6:  BNC   B3D8
....................                   cc = fp->sect_clust; 
0B3C8:  MOVLW  1B
0B3CA:  ADDWF  xA4,W
0B3CC:  MOVWF  FE9
0B3CE:  MOVLW  00
0B3D0:  ADDWFC xA5,W
0B3D2:  MOVWF  FEA
0B3D4:  MOVFF  FEF,8BA
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B3D8:  MOVFF  8BC,9F9
0B3DC:  MOVFF  8BB,9F8
0B3E0:  MOVFF  8B3,9FD
0B3E4:  MOVFF  8B2,9FC
0B3E8:  MOVFF  8B1,9FB
0B3EC:  MOVFF  8B0,9FA
0B3F0:  MOVFF  8BA,9FE
0B3F4:  MOVLB  0
0B3F6:  CALL   444E
0B3FA:  MOVF   01,F
0B3FC:  BZ    B404
....................                   goto fr_error; 
0B3FE:  MOVLB  8
0B400:  BRA    B5D4
0B402:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B404:  MOVLW  1B
0B406:  MOVLB  8
0B408:  ADDWF  xA4,W
0B40A:  MOVWF  FE9
0B40C:  MOVLW  00
0B40E:  ADDWFC xA5,W
0B410:  MOVWF  FEA
0B412:  MOVLW  01
0B414:  SUBWF  xBA,W
0B416:  SUBWF  FEF,W
0B418:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B41A:  MOVLW  10
0B41C:  ADDWF  xA4,W
0B41E:  MOVWF  FE9
0B420:  MOVLW  00
0B422:  ADDWFC xA5,W
0B424:  MOVWF  FEA
0B426:  MOVLW  01
0B428:  SUBWF  xBA,W
0B42A:  ADDWF  FEF,W
0B42C:  MOVWF  00
0B42E:  MOVLW  00
0B430:  ADDWFC FEC,W
0B432:  MOVWF  01
0B434:  MOVLW  00
0B436:  ADDWFC FEC,W
0B438:  MOVWF  02
0B43A:  MOVLW  00
0B43C:  ADDWFC FEC,W
0B43E:  MOVF   FED,F
0B440:  MOVF   FED,F
0B442:  MOVF   FED,F
0B444:  MOVFF  00,FEF
0B448:  MOVFF  01,FEC
0B44C:  MOVFF  02,FEC
0B450:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B452:  MOVLB  9
0B454:  CLRF   xE9
0B456:  MOVFF  8BA,9E8
0B45A:  MOVLW  02
0B45C:  MOVWF  xEB
0B45E:  CLRF   xEA
0B460:  MOVLB  0
0B462:  CALL   5C22
0B466:  MOVFF  02,8B9
0B46A:  MOVFF  01,8B8
....................                continue; 
0B46E:  BRA    B566
0B470:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B472:  MOVLW  10
0B474:  ADDWF  xA4,W
0B476:  MOVWF  FE9
0B478:  MOVLW  00
0B47A:  ADDWFC xA5,W
0B47C:  MOVWF  FEA
0B47E:  MOVFF  FEF,9EC
0B482:  MOVFF  FEC,9ED
0B486:  MOVFF  FEC,9EE
0B48A:  MOVFF  FEC,9EF
0B48E:  MOVLB  0
0B490:  CALL   5A0C
0B494:  MOVF   01,F
0B496:  BNZ   B49E
....................                goto fr_error; 
0B498:  MOVLB  8
0B49A:  BRA    B5D4
0B49C:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B49E:  MOVLB  8
0B4A0:  MOVFF  8A4,FE9
0B4A4:  MOVFF  8A5,FEA
0B4A8:  MOVFF  FEF,8BD
0B4AC:  MOVFF  FEC,8BE
0B4B0:  MOVFF  FEC,8BF
0B4B4:  MOVFF  FEC,8C0
0B4B8:  MOVF   xBE,W
0B4BA:  ANDLW  01
0B4BC:  MOVWF  01
0B4BE:  MOVLW  00
0B4C0:  BSF    FD8.0
0B4C2:  SUBFWB xBD,W
0B4C4:  MOVWF  xB8
0B4C6:  MOVLW  02
0B4C8:  SUBFWB 01,W
0B4CA:  MOVWF  xB9
....................          if (rcnt > btr) 
0B4CC:  MOVF   xA9,W
0B4CE:  SUBWF  xB9,W
0B4D0:  BNC   B4E2
0B4D2:  BNZ   B4DA
0B4D4:  MOVF   xB8,W
0B4D6:  SUBWF  xA8,W
0B4D8:  BC    B4E2
....................             rcnt = btr; 
0B4DA:  MOVFF  8A9,8B9
0B4DE:  MOVFF  8A8,8B8
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B4E2:  MOVFF  8A4,FE9
0B4E6:  MOVFF  8A5,FEA
0B4EA:  MOVFF  FEF,8BD
0B4EE:  MOVFF  FEC,8BE
0B4F2:  MOVFF  FEC,8BF
0B4F6:  MOVFF  FEC,8C0
0B4FA:  MOVLW  01
0B4FC:  ANDWF  xBE,F
0B4FE:  CLRF   xBF
0B500:  CLRF   xC0
0B502:  MOVLW  24
0B504:  ADDWF  xBD,W
0B506:  MOVWF  00
0B508:  MOVLW  00
0B50A:  ADDWFC xBE,W
0B50C:  MOVWF  01
0B50E:  MOVLW  00
0B510:  ADDWFC xBF,W
0B512:  MOVWF  02
0B514:  MOVLW  00
0B516:  ADDWFC xC0,W
0B518:  MOVWF  03
0B51A:  MOVFF  01,03
0B51E:  MOVF   00,W
0B520:  MOVLB  7
0B522:  ADDWF  x0E,W
0B524:  MOVWF  01
0B526:  MOVF   x0F,W
0B528:  ADDWFC 03,F
0B52A:  MOVFF  01,8C1
0B52E:  MOVLB  8
0B530:  MOVFF  03,8C2
0B534:  MOVFF  8BC,FEA
0B538:  MOVFF  8BB,FE9
0B53C:  MOVFF  03,FE2
0B540:  MOVFF  01,FE1
0B544:  MOVFF  8B9,02
0B548:  MOVFF  8B8,01
0B54C:  MOVF   01,F
0B54E:  BZ    B554
0B550:  INCF   02,F
0B552:  BRA    B558
0B554:  MOVF   02,F
0B556:  BZ    B564
0B558:  MOVFF  FE6,FEE
0B55C:  DECFSZ 01,F
0B55E:  BRA    B558
0B560:  DECFSZ 02,F
0B562:  BRA    B558
0B564:  MOVLB  0
0B566:  MOVLB  8
0B568:  MOVF   xB8,W
0B56A:  ADDWF  xBB,F
0B56C:  MOVF   xB9,W
0B56E:  ADDWFC xBC,F
0B570:  MOVFF  8A4,FE9
0B574:  MOVFF  8A5,FEA
0B578:  MOVF   xB8,W
0B57A:  ADDWF  FEF,W
0B57C:  MOVWF  00
0B57E:  MOVF   xB9,W
0B580:  ADDWFC FEC,W
0B582:  MOVWF  01
0B584:  MOVLW  00
0B586:  ADDWFC FEC,W
0B588:  MOVWF  02
0B58A:  MOVLW  00
0B58C:  ADDWFC FEC,W
0B58E:  MOVWF  03
0B590:  MOVF   FED,F
0B592:  MOVF   FED,F
0B594:  MOVF   FED,F
0B596:  MOVFF  00,FEF
0B59A:  MOVFF  01,FEC
0B59E:  MOVFF  02,FEC
0B5A2:  MOVWF  FEC
0B5A4:  MOVFF  8AA,FE9
0B5A8:  MOVFF  8AB,FEA
0B5AC:  MOVF   xB8,W
0B5AE:  ADDWF  FEF,W
0B5B0:  MOVWF  01
0B5B2:  MOVF   xB9,W
0B5B4:  ADDWFC FEC,W
0B5B6:  MOVWF  03
0B5B8:  MOVF   FED,F
0B5BA:  MOVFF  01,FEF
0B5BE:  MOVWF  FEC
0B5C0:  MOVF   xB8,W
0B5C2:  SUBWF  xA8,F
0B5C4:  MOVF   xB9,W
0B5C6:  SUBWFB xA9,F
0B5C8:  BRA    B1CC
....................          } 
....................       return (FR_OK); 
0B5CA:  MOVLW  00
0B5CC:  MOVWF  01
0B5CE:  MOVLB  7
0B5D0:  BRA    B5EC
0B5D2:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B5D4:  MOVLW  1A
0B5D6:  ADDWF  xA4,W
0B5D8:  MOVWF  FE9
0B5DA:  MOVLW  00
0B5DC:  ADDWFC xA5,W
0B5DE:  MOVWF  FEA
0B5E0:  MOVF   FEF,W
0B5E2:  IORLW  80
0B5E4:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B5E6:  MOVLW  07
0B5E8:  MOVWF  01
0B5EA:  MOVLB  7
0B5EC:  MOVLB  0
0B5EE:  GOTO   B7EA (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
0794A:  MOVFF  98F,9A0
0794E:  MOVFF  98E,99F
....................       *bw = 0; 
07952:  MOVLB  9
07954:  MOVFF  992,FE9
07958:  MOVFF  993,FEA
0795C:  CLRF   FEC
0795E:  MOVF   FED,F
07960:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07962:  CLRF   x9D
07964:  CLRF   x9C
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07966:  MOVLB  7
07968:  MOVF   x0E,W
0796A:  IORWF  x0F,W
0796C:  BNZ   7974
....................          return (FR_NOT_ENABLED); 
0796E:  MOVLW  0B
07970:  MOVWF  01
07972:  BRA    8010
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07974:  MOVLB  0
07976:  CALL   5518
0797A:  BTFSC  01.0
0797C:  BRA    798E
0797E:  MOVLB  7
07980:  MOVFF  70E,FE9
07984:  MOVFF  70F,FEA
07988:  MOVF   FEF,F
0798A:  BNZ   7996
0798C:  MOVLB  0
....................          return (FR_NOT_READY); 
0798E:  MOVLW  01
07990:  MOVWF  01
07992:  MOVLB  7
07994:  BRA    8010
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
07996:  MOVLW  1A
07998:  MOVLB  9
0799A:  ADDWF  x8C,W
0799C:  MOVWF  FE9
0799E:  MOVLW  00
079A0:  ADDWFC x8D,W
079A2:  MOVWF  FEA
079A4:  BTFSS  FEF.7
079A6:  BRA    79B2
....................          return (FR_RW_ERROR);         // Check error flag  
079A8:  MOVLW  07
079AA:  MOVWF  01
079AC:  MOVLB  7
079AE:  BRA    8010
079B0:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
079B2:  MOVLW  1A
079B4:  ADDWF  x8C,W
079B6:  MOVWF  FE9
079B8:  MOVLW  00
079BA:  ADDWFC x8D,W
079BC:  MOVWF  FEA
079BE:  BTFSC  FEF.1
079C0:  BRA    79CC
....................          return (FR_DENIED);            // Check access mode  
079C2:  MOVLW  05
079C4:  MOVWF  01
079C6:  MOVLB  7
079C8:  BRA    8010
079CA:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
079CC:  MOVLW  04
079CE:  ADDWF  x8C,W
079D0:  MOVWF  FE9
079D2:  MOVLW  00
079D4:  ADDWFC x8D,W
079D6:  MOVWF  FEA
079D8:  MOVFF  FEF,9A1
079DC:  MOVFF  FEC,9A2
079E0:  MOVFF  FEC,9A3
079E4:  MOVFF  FEC,9A4
079E8:  MOVF   x90,W
079EA:  ADDWF  xA1,F
079EC:  MOVF   x91,W
079EE:  ADDWFC xA2,F
079F0:  MOVLW  00
079F2:  ADDWFC xA3,F
079F4:  ADDWFC xA4,F
079F6:  MOVLW  04
079F8:  ADDWF  x8C,W
079FA:  MOVWF  FE9
079FC:  MOVLW  00
079FE:  ADDWFC x8D,W
07A00:  MOVWF  FEA
07A02:  MOVFF  FEF,00
07A06:  MOVFF  FEC,01
07A0A:  MOVFF  FEC,02
07A0E:  MOVFF  FEC,03
07A12:  MOVF   xA4,W
07A14:  SUBWF  03,W
07A16:  BNC   7A34
07A18:  BNZ   7A30
07A1A:  MOVF   xA3,W
07A1C:  SUBWF  02,W
07A1E:  BNC   7A34
07A20:  BNZ   7A30
07A22:  MOVF   xA2,W
07A24:  SUBWF  01,W
07A26:  BNC   7A34
07A28:  BNZ   7A30
07A2A:  MOVF   00,W
07A2C:  SUBWF  xA1,W
07A2E:  BC    7A34
....................          btw = 0;                  // File size cannot reach 4GB  
07A30:  CLRF   x91
07A32:  CLRF   x90
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07A34:  MOVF   x90,W
07A36:  IORWF  x91,W
07A38:  BTFSC  FD8.2
07A3A:  BRA    7F44
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07A3C:  MOVFF  98C,FE9
07A40:  MOVFF  98D,FEA
07A44:  MOVFF  FEF,9A1
07A48:  MOVFF  FEC,9A2
07A4C:  MOVFF  FEC,9A3
07A50:  MOVFF  FEC,9A4
07A54:  MOVLW  01
07A56:  ANDWF  xA2,F
07A58:  CLRF   xA3
07A5A:  CLRF   xA4
07A5C:  MOVF   xA1,F
07A5E:  BTFSS  FD8.2
07A60:  BRA    7DDE
07A62:  MOVF   xA2,F
07A64:  BTFSS  FD8.2
07A66:  BRA    7DDE
07A68:  MOVF   xA3,F
07A6A:  BTFSS  FD8.2
07A6C:  BRA    7DDE
07A6E:  MOVF   xA4,F
07A70:  BTFSS  FD8.2
07A72:  BRA    7DDE
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07A74:  MOVLW  1B
07A76:  ADDWF  x8C,W
07A78:  MOVWF  FE9
07A7A:  MOVLW  00
07A7C:  ADDWFC x8D,W
07A7E:  MOVWF  FEA
07A80:  DECF   FEF,F
07A82:  BZ    7ABA
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07A84:  MOVLW  10
07A86:  ADDWF  x8C,W
07A88:  MOVWF  FE9
07A8A:  MOVLW  00
07A8C:  ADDWFC x8D,W
07A8E:  MOVWF  FEA
07A90:  MOVFF  FEF,9A1
07A94:  MOVFF  FEC,9A2
07A98:  MOVFF  FEC,9A3
07A9C:  MOVFF  FEC,9A4
07AA0:  MOVLW  01
07AA2:  ADDWF  xA1,W
07AA4:  MOVWF  x98
07AA6:  MOVLW  00
07AA8:  ADDWFC xA2,W
07AAA:  MOVWF  x99
07AAC:  MOVLW  00
07AAE:  ADDWFC xA3,W
07AB0:  MOVWF  x9A
07AB2:  MOVLW  00
07AB4:  ADDWFC xA4,W
07AB6:  MOVWF  x9B
....................                }  
07AB8:  BRA    7C50
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07ABA:  MOVFF  98C,FE9
07ABE:  MOVFF  98D,FEA
07AC2:  MOVFF  FEF,9A1
07AC6:  MOVFF  FEC,9A2
07ACA:  MOVFF  FEC,9A3
07ACE:  MOVFF  FEC,9A4
07AD2:  MOVF   xA1,F
07AD4:  BNZ   7B5A
07AD6:  MOVF   xA2,F
07AD8:  BNZ   7B5A
07ADA:  MOVF   xA3,F
07ADC:  BNZ   7B5A
07ADE:  MOVF   xA4,F
07AE0:  BNZ   7B5A
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07AE2:  MOVLW  08
07AE4:  ADDWF  x8C,W
07AE6:  MOVWF  FE9
07AE8:  MOVLW  00
07AEA:  ADDWFC x8D,W
07AEC:  MOVWF  FEA
07AEE:  MOVFF  FEF,994
07AF2:  MOVFF  FEC,995
07AF6:  MOVFF  FEC,996
07AFA:  MOVFF  FEC,997
....................                   if (clust == 0)            // No cluster is created  
07AFE:  MOVF   x94,F
07B00:  BNZ   7B58
07B02:  MOVF   x95,F
07B04:  BNZ   7B58
07B06:  MOVF   x96,F
07B08:  BNZ   7B58
07B0A:  MOVF   x97,F
07B0C:  BNZ   7B58
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07B0E:  MOVLW  08
07B10:  ADDWF  x8C,W
07B12:  MOVWF  01
07B14:  MOVLW  00
07B16:  ADDWFC x8D,W
07B18:  MOVWF  03
07B1A:  MOVFF  01,9A1
07B1E:  MOVWF  xA2
07B20:  CLRF   xC7
07B22:  CLRF   xC6
07B24:  CLRF   xC5
07B26:  CLRF   xC4
07B28:  MOVLB  0
07B2A:  CALL   68BE
07B2E:  MOVFF  03,997
07B32:  MOVFF  02,996
07B36:  MOVFF  01,995
07B3A:  MOVFF  00,994
07B3E:  MOVFF  9A2,FEA
07B42:  MOVFF  9A1,FE9
07B46:  MOVFF  994,FEF
07B4A:  MOVFF  995,FEC
07B4E:  MOVFF  996,FEC
07B52:  MOVFF  997,FEC
07B56:  MOVLB  9
....................                   } 
07B58:  BRA    7B8E
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07B5A:  MOVLW  0C
07B5C:  ADDWF  x8C,W
07B5E:  MOVWF  FE9
07B60:  MOVLW  00
07B62:  ADDWFC x8D,W
07B64:  MOVWF  FEA
07B66:  MOVFF  FEF,9C4
07B6A:  MOVFF  FEC,9C5
07B6E:  MOVFF  FEC,9C6
07B72:  MOVFF  FEC,9C7
07B76:  MOVLB  0
07B78:  CALL   68BE
07B7C:  MOVFF  03,997
07B80:  MOVFF  02,996
07B84:  MOVFF  01,995
07B88:  MOVFF  00,994
07B8C:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07B8E:  MOVF   x97,F
07B90:  BNZ   7BA0
07B92:  MOVF   x96,F
07B94:  BNZ   7BA0
07B96:  MOVF   x95,F
07B98:  BNZ   7BA0
07B9A:  MOVF   x94,W
07B9C:  SUBLW  01
07B9E:  BC    7BDE
07BA0:  MOVLW  0C
07BA2:  MOVLB  7
07BA4:  ADDWF  x0E,W
07BA6:  MOVWF  FE9
07BA8:  MOVLW  00
07BAA:  ADDWFC x0F,W
07BAC:  MOVWF  FEA
07BAE:  MOVFF  FEF,00
07BB2:  MOVFF  FEC,01
07BB6:  MOVFF  FEC,02
07BBA:  MOVFF  FEC,03
07BBE:  MOVF   03,W
07BC0:  MOVLB  9
07BC2:  SUBWF  x97,W
07BC4:  BNC   7BE0
07BC6:  BNZ   7BDE
07BC8:  MOVF   02,W
07BCA:  SUBWF  x96,W
07BCC:  BNC   7BE0
07BCE:  BNZ   7BDE
07BD0:  MOVF   01,W
07BD2:  SUBWF  x95,W
07BD4:  BNC   7BE0
07BD6:  BNZ   7BDE
07BD8:  MOVF   00,W
07BDA:  SUBWF  x94,W
07BDC:  BNC   7BE0
....................                   break; 
07BDE:  BRA    7F44
....................                fp->curr_clust = clust;            // Current cluster  
07BE0:  MOVLW  0C
07BE2:  ADDWF  x8C,W
07BE4:  MOVWF  FE9
07BE6:  MOVLW  00
07BE8:  ADDWFC x8D,W
07BEA:  MOVWF  FEA
07BEC:  MOVFF  994,FEF
07BF0:  MOVFF  995,FEC
07BF4:  MOVFF  996,FEC
07BF8:  MOVFF  997,FEC
....................                sect = clust2sect(clust);         // Current sector  
07BFC:  MOVFF  997,9CE
07C00:  MOVFF  996,9CD
07C04:  MOVFF  995,9CC
07C08:  MOVFF  994,9CB
07C0C:  MOVLB  0
07C0E:  CALL   5588
07C12:  MOVFF  03,99B
07C16:  MOVFF  02,99A
07C1A:  MOVFF  01,999
07C1E:  MOVFF  00,998
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07C22:  MOVLW  1B
07C24:  MOVLB  9
07C26:  ADDWF  x8C,W
07C28:  MOVWF  01
07C2A:  MOVLW  00
07C2C:  ADDWFC x8D,W
07C2E:  MOVWF  03
07C30:  MOVLW  02
07C32:  MOVLB  7
07C34:  ADDWF  x0E,W
07C36:  MOVWF  FE9
07C38:  MOVLW  00
07C3A:  ADDWFC x0F,W
07C3C:  MOVWF  FEA
07C3E:  MOVFF  FEF,9A3
07C42:  MOVLB  9
07C44:  MOVFF  03,FEA
07C48:  MOVFF  01,FE9
07C4C:  MOVFF  9A3,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07C50:  MOVLW  10
07C52:  ADDWF  x8C,W
07C54:  MOVWF  FE9
07C56:  MOVLW  00
07C58:  ADDWFC x8D,W
07C5A:  MOVWF  FEA
07C5C:  MOVFF  998,FEF
07C60:  MOVFF  999,FEC
07C64:  MOVFF  99A,FEC
07C68:  MOVFF  99B,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07C6C:  BCF    FD8.0
07C6E:  RRCF   x91,W
07C70:  MOVWF  x9E
....................             if (cc)  
07C72:  MOVF   x9E,F
07C74:  BZ    7D2E
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07C76:  MOVLW  1B
07C78:  ADDWF  x8C,W
07C7A:  MOVWF  FE9
07C7C:  MOVLW  00
07C7E:  ADDWFC x8D,W
07C80:  MOVWF  FEA
07C82:  MOVF   FEF,W
07C84:  SUBWF  x9E,W
07C86:  BZ    7C9A
07C88:  BNC   7C9A
....................                   cc = fp->sect_clust; 
07C8A:  MOVLW  1B
07C8C:  ADDWF  x8C,W
07C8E:  MOVWF  FE9
07C90:  MOVLW  00
07C92:  ADDWFC x8D,W
07C94:  MOVWF  FEA
07C96:  MOVFF  FEF,99E
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07C9A:  MOVFF  9A0,9F9
07C9E:  MOVFF  99F,9F8
07CA2:  MOVFF  99B,9FD
07CA6:  MOVFF  99A,9FC
07CAA:  MOVFF  999,9FB
07CAE:  MOVFF  998,9FA
07CB2:  MOVFF  99E,9FE
07CB6:  MOVLB  0
07CB8:  CALL   58C2
07CBC:  MOVF   01,F
07CBE:  BZ    7CC2
....................                   goto fw_error; 
07CC0:  BRA    7FF6
....................                fp->sect_clust -= cc - 1; 
07CC2:  MOVLW  1B
07CC4:  MOVLB  9
07CC6:  ADDWF  x8C,W
07CC8:  MOVWF  FE9
07CCA:  MOVLW  00
07CCC:  ADDWFC x8D,W
07CCE:  MOVWF  FEA
07CD0:  MOVLW  01
07CD2:  SUBWF  x9E,W
07CD4:  SUBWF  FEF,W
07CD6:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07CD8:  MOVLW  10
07CDA:  ADDWF  x8C,W
07CDC:  MOVWF  FE9
07CDE:  MOVLW  00
07CE0:  ADDWFC x8D,W
07CE2:  MOVWF  FEA
07CE4:  MOVLW  01
07CE6:  SUBWF  x9E,W
07CE8:  ADDWF  FEF,W
07CEA:  MOVWF  00
07CEC:  MOVLW  00
07CEE:  ADDWFC FEC,W
07CF0:  MOVWF  01
07CF2:  MOVLW  00
07CF4:  ADDWFC FEC,W
07CF6:  MOVWF  02
07CF8:  MOVLW  00
07CFA:  ADDWFC FEC,W
07CFC:  MOVF   FED,F
07CFE:  MOVF   FED,F
07D00:  MOVF   FED,F
07D02:  MOVFF  00,FEF
07D06:  MOVFF  01,FEC
07D0A:  MOVFF  02,FEC
07D0E:  MOVWF  FEC
....................                wcnt = cc * 512; 
07D10:  CLRF   xE9
07D12:  MOVFF  99E,9E8
07D16:  MOVLW  02
07D18:  MOVWF  xEB
07D1A:  CLRF   xEA
07D1C:  MOVLB  0
07D1E:  CALL   5C22
07D22:  MOVFF  02,99D
07D26:  MOVFF  01,99C
....................                continue; 
07D2A:  BRA    7EE0
07D2C:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07D2E:  MOVFF  98C,FE9
07D32:  MOVFF  98D,FEA
07D36:  MOVFF  FEF,9A1
07D3A:  MOVFF  FEC,9A2
07D3E:  MOVFF  FEC,9A3
07D42:  MOVFF  FEC,9A4
07D46:  MOVLW  04
07D48:  ADDWF  x8C,W
07D4A:  MOVWF  FE9
07D4C:  MOVLW  00
07D4E:  ADDWFC x8D,W
07D50:  MOVWF  FEA
07D52:  MOVFF  FEF,00
07D56:  MOVFF  FEC,01
07D5A:  MOVFF  FEC,02
07D5E:  MOVFF  FEC,03
07D62:  MOVF   03,W
07D64:  SUBWF  xA4,W
07D66:  BNC   7DDE
07D68:  BNZ   7D80
07D6A:  MOVF   02,W
07D6C:  SUBWF  xA3,W
07D6E:  BNC   7DDE
07D70:  BNZ   7D80
07D72:  MOVF   01,W
07D74:  SUBWF  xA2,W
07D76:  BNC   7DDE
07D78:  BNZ   7D80
07D7A:  MOVF   00,W
07D7C:  SUBWF  xA1,W
07D7E:  BNC   7DDE
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07D80:  CLRF   xEF
07D82:  CLRF   xEE
07D84:  CLRF   xED
07D86:  CLRF   xEC
07D88:  MOVLB  0
07D8A:  CALL   5A0C
07D8E:  MOVF   01,F
07D90:  BNZ   7D94
....................                   goto fw_error; 
07D92:  BRA    7FF6
....................                fs->winsect = fp->curr_sect; 
07D94:  MOVLW  20
07D96:  MOVLB  7
07D98:  ADDWF  x0E,W
07D9A:  MOVWF  01
07D9C:  MOVLW  00
07D9E:  ADDWFC x0F,W
07DA0:  MOVWF  03
07DA2:  MOVFF  01,9A1
07DA6:  MOVLB  9
07DA8:  MOVWF  xA2
07DAA:  MOVLW  10
07DAC:  ADDWF  x8C,W
07DAE:  MOVWF  FE9
07DB0:  MOVLW  00
07DB2:  ADDWFC x8D,W
07DB4:  MOVWF  FEA
07DB6:  MOVFF  FEF,00
07DBA:  MOVFF  FEC,01
07DBE:  MOVFF  FEC,02
07DC2:  MOVFF  FEC,03
07DC6:  MOVFF  9A2,FEA
07DCA:  MOVFF  9A1,FE9
07DCE:  MOVFF  00,FEF
07DD2:  MOVFF  01,FEC
07DD6:  MOVFF  02,FEC
07DDA:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07DDE:  MOVLW  10
07DE0:  ADDWF  x8C,W
07DE2:  MOVWF  FE9
07DE4:  MOVLW  00
07DE6:  ADDWFC x8D,W
07DE8:  MOVWF  FEA
07DEA:  MOVFF  FEF,9EC
07DEE:  MOVFF  FEC,9ED
07DF2:  MOVFF  FEC,9EE
07DF6:  MOVFF  FEC,9EF
07DFA:  MOVLB  0
07DFC:  CALL   5A0C
07E00:  MOVF   01,F
07E02:  BNZ   7E06
....................             goto fw_error;               // Move sector window 
07E04:  BRA    7FF6
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07E06:  MOVLB  9
07E08:  MOVFF  98C,FE9
07E0C:  MOVFF  98D,FEA
07E10:  MOVFF  FEF,9A1
07E14:  MOVFF  FEC,9A2
07E18:  MOVFF  FEC,9A3
07E1C:  MOVFF  FEC,9A4
07E20:  MOVF   xA2,W
07E22:  ANDLW  01
07E24:  MOVWF  01
07E26:  MOVLW  00
07E28:  BSF    FD8.0
07E2A:  SUBFWB xA1,W
07E2C:  MOVWF  x9C
07E2E:  MOVLW  02
07E30:  SUBFWB 01,W
07E32:  MOVWF  x9D
....................          if (wcnt > btw) 
07E34:  MOVF   x91,W
07E36:  SUBWF  x9D,W
07E38:  BNC   7E4A
07E3A:  BNZ   7E42
07E3C:  MOVF   x9C,W
07E3E:  SUBWF  x90,W
07E40:  BC    7E4A
....................             wcnt = btw; 
07E42:  MOVFF  991,99D
07E46:  MOVFF  990,99C
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07E4A:  MOVFF  98C,FE9
07E4E:  MOVFF  98D,FEA
07E52:  MOVFF  FEF,9A1
07E56:  MOVFF  FEC,9A2
07E5A:  MOVFF  FEC,9A3
07E5E:  MOVFF  FEC,9A4
07E62:  MOVLW  01
07E64:  ANDWF  xA2,F
07E66:  CLRF   xA3
07E68:  CLRF   xA4
07E6A:  MOVLW  24
07E6C:  ADDWF  xA1,W
07E6E:  MOVWF  00
07E70:  MOVLW  00
07E72:  ADDWFC xA2,W
07E74:  MOVWF  01
07E76:  MOVLW  00
07E78:  ADDWFC xA3,W
07E7A:  MOVWF  02
07E7C:  MOVLW  00
07E7E:  ADDWFC xA4,W
07E80:  MOVWF  03
07E82:  MOVFF  01,03
07E86:  MOVF   00,W
07E88:  MOVLB  7
07E8A:  ADDWF  x0E,W
07E8C:  MOVWF  01
07E8E:  MOVF   x0F,W
07E90:  ADDWFC 03,F
07E92:  MOVFF  01,9A5
07E96:  MOVLB  9
07E98:  MOVFF  03,9A6
07E9C:  MOVFF  03,FEA
07EA0:  MOVFF  01,FE9
07EA4:  MOVFF  9A0,FE2
07EA8:  MOVFF  99F,FE1
07EAC:  MOVFF  99D,02
07EB0:  MOVFF  99C,01
07EB4:  MOVF   01,F
07EB6:  BZ    7EBC
07EB8:  INCF   02,F
07EBA:  BRA    7EC0
07EBC:  MOVF   02,F
07EBE:  BZ    7ECC
07EC0:  MOVFF  FE6,FEE
07EC4:  DECFSZ 01,F
07EC6:  BRA    7EC0
07EC8:  DECFSZ 02,F
07ECA:  BRA    7EC0
....................          fs->winflag = 1; 
07ECC:  MOVLW  06
07ECE:  MOVLB  7
07ED0:  ADDWF  x0E,W
07ED2:  MOVWF  FE9
07ED4:  MOVLW  00
07ED6:  ADDWFC x0F,W
07ED8:  MOVWF  FEA
07EDA:  MOVLW  01
07EDC:  MOVWF  FEF
07EDE:  MOVLB  0
07EE0:  MOVLB  9
07EE2:  MOVF   x9C,W
07EE4:  ADDWF  x9F,F
07EE6:  MOVF   x9D,W
07EE8:  ADDWFC xA0,F
07EEA:  MOVFF  98C,FE9
07EEE:  MOVFF  98D,FEA
07EF2:  MOVF   x9C,W
07EF4:  ADDWF  FEF,W
07EF6:  MOVWF  00
07EF8:  MOVF   x9D,W
07EFA:  ADDWFC FEC,W
07EFC:  MOVWF  01
07EFE:  MOVLW  00
07F00:  ADDWFC FEC,W
07F02:  MOVWF  02
07F04:  MOVLW  00
07F06:  ADDWFC FEC,W
07F08:  MOVWF  03
07F0A:  MOVF   FED,F
07F0C:  MOVF   FED,F
07F0E:  MOVF   FED,F
07F10:  MOVFF  00,FEF
07F14:  MOVFF  01,FEC
07F18:  MOVFF  02,FEC
07F1C:  MOVWF  FEC
07F1E:  MOVFF  992,FE9
07F22:  MOVFF  993,FEA
07F26:  MOVF   x9C,W
07F28:  ADDWF  FEF,W
07F2A:  MOVWF  01
07F2C:  MOVF   x9D,W
07F2E:  ADDWFC FEC,W
07F30:  MOVWF  03
07F32:  MOVF   FED,F
07F34:  MOVFF  01,FEF
07F38:  MOVWF  FEC
07F3A:  MOVF   x9C,W
07F3C:  SUBWF  x90,F
07F3E:  MOVF   x9D,W
07F40:  SUBWFB x91,F
07F42:  BRA    7A34
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
07F44:  MOVFF  98C,FE9
07F48:  MOVFF  98D,FEA
07F4C:  MOVFF  FEF,9A1
07F50:  MOVFF  FEC,9A2
07F54:  MOVFF  FEC,9A3
07F58:  MOVFF  FEC,9A4
07F5C:  MOVLW  04
07F5E:  ADDWF  x8C,W
07F60:  MOVWF  FE9
07F62:  MOVLW  00
07F64:  ADDWFC x8D,W
07F66:  MOVWF  FEA
07F68:  MOVFF  FEF,00
07F6C:  MOVFF  FEC,01
07F70:  MOVFF  FEC,02
07F74:  MOVFF  FEC,03
07F78:  MOVF   03,W
07F7A:  SUBWF  xA4,W
07F7C:  BNC   7FDA
07F7E:  BNZ   7F96
07F80:  MOVF   02,W
07F82:  SUBWF  xA3,W
07F84:  BNC   7FDA
07F86:  BNZ   7F96
07F88:  MOVF   01,W
07F8A:  SUBWF  xA2,W
07F8C:  BNC   7FDA
07F8E:  BNZ   7F96
07F90:  MOVF   xA1,W
07F92:  SUBWF  00,W
07F94:  BC    7FDA
....................          fp->fsize = fp->fptr;      // Update file size if needed  
07F96:  MOVLW  04
07F98:  ADDWF  x8C,W
07F9A:  MOVWF  01
07F9C:  MOVLW  00
07F9E:  ADDWFC x8D,W
07FA0:  MOVWF  03
07FA2:  MOVFF  01,9A1
07FA6:  MOVFF  03,9A2
07FAA:  MOVFF  98C,FE9
07FAE:  MOVFF  98D,FEA
07FB2:  MOVFF  FEF,00
07FB6:  MOVFF  FEC,01
07FBA:  MOVFF  FEC,02
07FBE:  MOVFF  FEC,03
07FC2:  MOVFF  9A2,FEA
07FC6:  MOVFF  9A1,FE9
07FCA:  MOVFF  00,FEF
07FCE:  MOVFF  01,FEC
07FD2:  MOVFF  02,FEC
07FD6:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
07FDA:  MOVLW  1A
07FDC:  ADDWF  x8C,W
07FDE:  MOVWF  FE9
07FE0:  MOVLW  00
07FE2:  ADDWFC x8D,W
07FE4:  MOVWF  FEA
07FE6:  MOVF   FEF,W
07FE8:  IORLW  20
07FEA:  MOVWF  FEF
....................       return (FR_OK); 
07FEC:  MOVLW  00
07FEE:  MOVWF  01
07FF0:  MOVLB  7
07FF2:  BRA    8010
07FF4:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07FF6:  MOVLW  1A
07FF8:  MOVLB  9
07FFA:  ADDWF  x8C,W
07FFC:  MOVWF  FE9
07FFE:  MOVLW  00
08000:  ADDWFC x8D,W
08002:  MOVWF  FEA
08004:  MOVF   FEF,W
08006:  IORLW  80
08008:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0800A:  MOVLW  07
0800C:  MOVWF  01
0800E:  MOVLB  7
08010:  MOVLB  0
08012:  GOTO   83B6 (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
074F0:  MOVLB  7
074F2:  MOVF   x0E,W
074F4:  IORWF  x0F,W
074F6:  BNZ   74FE
....................          return (FR_NOT_ENABLED); 
074F8:  MOVLW  0B
074FA:  MOVWF  01
074FC:  BRA    7852
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
074FE:  MOVLB  0
07500:  CALL   5518
07504:  BTFSC  01.0
07506:  BRA    7518
07508:  MOVLB  7
0750A:  MOVFF  70E,FE9
0750E:  MOVFF  70F,FEA
07512:  MOVF   FEF,F
07514:  BNZ   7520
07516:  MOVLB  0
....................          return (FR_NOT_READY); 
07518:  MOVLW  01
0751A:  MOVWF  01
0751C:  MOVLB  7
0751E:  BRA    7852
....................     
....................       if (fp->flag & FA__ERROR) 
07520:  MOVLW  1A
07522:  MOVLB  9
07524:  ADDWF  x8C,W
07526:  MOVWF  FE9
07528:  MOVLW  00
0752A:  ADDWFC x8D,W
0752C:  MOVWF  FEA
0752E:  BTFSS  FEF.7
07530:  BRA    753C
....................          return (FR_RW_ERROR); 
07532:  MOVLW  07
07534:  MOVWF  01
07536:  MOVLB  7
07538:  BRA    7852
0753A:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
0753C:  MOVLW  04
0753E:  ADDWF  x8C,W
07540:  MOVWF  FE9
07542:  MOVLW  00
07544:  ADDWFC x8D,W
07546:  MOVWF  FEA
07548:  MOVFF  FEF,00
0754C:  MOVFF  FEC,01
07550:  MOVFF  FEC,02
07554:  MOVFF  FEC,03
07558:  MOVF   03,W
0755A:  SUBWF  x91,W
0755C:  BNC   7592
0755E:  BNZ   7576
07560:  MOVF   02,W
07562:  SUBWF  x90,W
07564:  BNC   7592
07566:  BNZ   7576
07568:  MOVF   01,W
0756A:  SUBWF  x8F,W
0756C:  BNC   7592
0756E:  BNZ   7576
07570:  MOVF   x8E,W
07572:  SUBWF  00,W
07574:  BC    7592
....................          ofs = fp->fsize;               // Clip offset by file size  
07576:  MOVLW  04
07578:  ADDWF  x8C,W
0757A:  MOVWF  FE9
0757C:  MOVLW  00
0757E:  ADDWFC x8D,W
07580:  MOVWF  FEA
07582:  MOVFF  FEF,98E
07586:  MOVFF  FEC,98F
0758A:  MOVFF  FEC,990
0758E:  MOVFF  FEC,991
....................       fp->fptr = ofs;  
07592:  MOVFF  98C,FE9
07596:  MOVF   x8D,W
07598:  MOVWF  FEA
0759A:  MOVFF  98E,FEF
0759E:  MOVFF  98F,FEC
075A2:  MOVFF  990,FEC
075A6:  MOVFF  991,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
075AA:  MOVLW  1B
075AC:  ADDWF  x8C,W
075AE:  MOVWF  FE9
075B0:  MOVLW  00
075B2:  ADDWFC x8D,W
075B4:  MOVWF  FEA
075B6:  MOVLW  01
075B8:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
075BA:  MOVF   x8E,F
075BC:  BNZ   75CC
075BE:  MOVF   x8F,F
075C0:  BNZ   75CC
075C2:  MOVF   x90,F
075C4:  BNZ   75CC
075C6:  MOVF   x91,F
075C8:  BTFSC  FD8.2
075CA:  BRA    7830
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
075CC:  MOVLW  01
075CE:  SUBWF  x8E,W
075D0:  MOVLW  00
075D2:  SUBWFB x8F,W
075D4:  MOVWF  x98
075D6:  MOVLW  00
075D8:  SUBWFB x90,W
075DA:  MOVWF  x99
075DC:  MOVLW  00
075DE:  SUBWFB x91,W
075E0:  MOVWF  x9A
075E2:  BCF    FD8.0
075E4:  CLRF   x91
075E6:  RRCF   x9A,W
075E8:  MOVWF  x90
075EA:  RRCF   x99,W
075EC:  MOVWF  x8F
075EE:  RRCF   x98,W
075F0:  MOVWF  x8E
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
075F2:  MOVLW  02
075F4:  MOVLB  7
075F6:  ADDWF  x0E,W
075F8:  MOVWF  FE9
075FA:  MOVLW  00
075FC:  ADDWFC x0F,W
075FE:  MOVWF  FEA
07600:  MOVFF  FEF,996
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
07604:  MOVLW  1B
07606:  MOVLB  9
07608:  ADDWF  x8C,W
0760A:  MOVWF  01
0760C:  MOVLW  00
0760E:  ADDWFC x8D,W
07610:  MOVWF  03
07612:  MOVFF  01,997
07616:  MOVWF  x98
07618:  MOVFF  FEA,99A
0761C:  MOVFF  FE9,999
07620:  BSF    FD8.1
07622:  MOVLW  09
07624:  MOVWF  FEA
07626:  MOVLW  9B
07628:  MOVWF  FE9
0762A:  CLRF   1B
0762C:  BTFSC  FF2.7
0762E:  BSF    1B.7
07630:  BCF    FF2.7
07632:  MOVFF  991,A27
07636:  MOVFF  990,A26
0763A:  MOVFF  98F,A25
0763E:  MOVFF  98E,A24
07642:  MOVLB  A
07644:  CLRF   x2B
07646:  CLRF   x2A
07648:  CLRF   x29
0764A:  MOVFF  996,A28
0764E:  MOVLB  0
07650:  CALL   1038
07654:  BTFSC  1B.7
07656:  BSF    FF2.7
07658:  MOVFF  99B,00
0765C:  MOVFF  99C,01
07660:  MOVFF  99D,02
07664:  MOVFF  99E,03
07668:  MOVFF  99A,FEA
0766C:  MOVFF  999,FE9
07670:  MOVF   00,W
07672:  MOVLB  9
07674:  SUBWF  x96,W
07676:  MOVWF  00
07678:  MOVLW  00
0767A:  SUBFWB 01,F
0767C:  SUBFWB 02,F
0767E:  SUBFWB 03,F
07680:  MOVFF  998,FEA
07684:  MOVFF  997,FE9
07688:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
0768C:  BCF    FD8.1
0768E:  CLRF   1B
07690:  BTFSC  FF2.7
07692:  BSF    1B.7
07694:  BCF    FF2.7
07696:  MOVFF  991,A27
0769A:  MOVFF  990,A26
0769E:  MOVFF  98F,A25
076A2:  MOVFF  98E,A24
076A6:  MOVLB  A
076A8:  CLRF   x2B
076AA:  CLRF   x2A
076AC:  CLRF   x29
076AE:  MOVFF  996,A28
076B2:  MOVLB  0
076B4:  CALL   1038
076B8:  BTFSC  1B.7
076BA:  BSF    FF2.7
076BC:  MOVFF  03,991
076C0:  MOVFF  02,990
076C4:  MOVFF  01,98F
076C8:  MOVFF  00,98E
....................          clust = fp->org_clust;            // Seek to current cluster  
076CC:  MOVLW  08
076CE:  MOVLB  9
076D0:  ADDWF  x8C,W
076D2:  MOVWF  FE9
076D4:  MOVLW  00
076D6:  ADDWFC x8D,W
076D8:  MOVWF  FEA
076DA:  MOVFF  FEF,992
076DE:  MOVFF  FEC,993
076E2:  MOVFF  FEC,994
076E6:  MOVFF  FEC,995
....................     
....................          while (ofs--) 
076EA:  MOVFF  991,03
076EE:  MOVFF  990,02
076F2:  MOVFF  98F,01
076F6:  MOVFF  98E,00
076FA:  MOVLW  FF
076FC:  ADDWF  x8E,F
076FE:  BTFSS  FD8.0
07700:  ADDWF  x8F,F
07702:  BTFSS  FD8.0
07704:  ADDWF  x90,F
07706:  BTFSS  FD8.0
07708:  ADDWF  x91,F
0770A:  MOVF   00,F
0770C:  BNZ   771A
0770E:  MOVF   01,F
07710:  BNZ   771A
07712:  MOVF   02,F
07714:  BNZ   771A
07716:  MOVF   03,F
07718:  BZ    7744
....................             clust = get_cluster(clust); 
0771A:  MOVFF  995,9DB
0771E:  MOVFF  994,9DA
07722:  MOVFF  993,9D9
07726:  MOVFF  992,9D8
0772A:  MOVLB  0
0772C:  CALL   5C44
07730:  MOVFF  03,995
07734:  MOVFF  02,994
07738:  MOVFF  01,993
0773C:  MOVFF  00,992
07740:  MOVLB  9
07742:  BRA    76EA
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
07744:  MOVF   x95,F
07746:  BNZ   7756
07748:  MOVF   x94,F
0774A:  BNZ   7756
0774C:  MOVF   x93,F
0774E:  BNZ   7756
07750:  MOVF   x92,W
07752:  SUBLW  01
07754:  BC    7794
07756:  MOVLW  0C
07758:  MOVLB  7
0775A:  ADDWF  x0E,W
0775C:  MOVWF  FE9
0775E:  MOVLW  00
07760:  ADDWFC x0F,W
07762:  MOVWF  FEA
07764:  MOVFF  FEF,00
07768:  MOVFF  FEC,01
0776C:  MOVFF  FEC,02
07770:  MOVFF  FEC,03
07774:  MOVF   03,W
07776:  MOVLB  9
07778:  SUBWF  x95,W
0777A:  BNC   7796
0777C:  BNZ   7794
0777E:  MOVF   02,W
07780:  SUBWF  x94,W
07782:  BNC   7796
07784:  BNZ   7794
07786:  MOVF   01,W
07788:  SUBWF  x93,W
0778A:  BNC   7796
0778C:  BNZ   7794
0778E:  MOVF   00,W
07790:  SUBWF  x92,W
07792:  BNC   7796
....................             goto fk_error; 
07794:  BRA    783A
....................     
....................          fp->curr_clust = clust; 
07796:  MOVLW  0C
07798:  ADDWF  x8C,W
0779A:  MOVWF  FE9
0779C:  MOVLW  00
0779E:  ADDWFC x8D,W
077A0:  MOVWF  FEA
077A2:  MOVFF  992,FEF
077A6:  MOVFF  993,FEC
077AA:  MOVFF  994,FEC
077AE:  MOVFF  995,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
077B2:  MOVLW  10
077B4:  ADDWF  x8C,W
077B6:  MOVWF  01
077B8:  MOVLW  00
077BA:  ADDWFC x8D,W
077BC:  MOVWF  03
077BE:  MOVFF  01,997
077C2:  MOVWF  x98
077C4:  MOVFF  995,9CE
077C8:  MOVFF  994,9CD
077CC:  MOVFF  993,9CC
077D0:  MOVFF  992,9CB
077D4:  MOVLB  0
077D6:  CALL   5588
077DA:  MOVFF  03,99C
077DE:  MOVFF  02,99B
077E2:  MOVFF  01,99A
077E6:  MOVFF  00,999
077EA:  MOVLB  9
077EC:  MOVF   x96,W
077EE:  ADDWF  x99,F
077F0:  MOVLW  00
077F2:  ADDWFC x9A,F
077F4:  ADDWFC x9B,F
077F6:  ADDWFC x9C,F
077F8:  MOVLW  1B
077FA:  ADDWF  x8C,W
077FC:  MOVWF  FE9
077FE:  MOVLW  00
07800:  ADDWFC x8D,W
07802:  MOVWF  FEA
07804:  MOVF   FEF,W
07806:  SUBWF  x99,W
07808:  MOVWF  00
0780A:  MOVLW  00
0780C:  SUBWFB x9A,W
0780E:  MOVWF  01
07810:  MOVLW  00
07812:  SUBWFB x9B,W
07814:  MOVWF  02
07816:  MOVLW  00
07818:  SUBWFB x9C,W
0781A:  MOVFF  998,FEA
0781E:  MOVFF  997,FE9
07822:  MOVFF  00,FEF
07826:  MOVFF  01,FEC
0782A:  MOVFF  02,FEC
0782E:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
07830:  MOVLW  00
07832:  MOVWF  01
07834:  MOVLB  7
07836:  BRA    7852
07838:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0783A:  MOVLW  1A
0783C:  ADDWF  x8C,W
0783E:  MOVWF  FE9
07840:  MOVLW  00
07842:  ADDWFC x8D,W
07844:  MOVWF  FEA
07846:  MOVF   FEF,W
07848:  IORLW  80
0784A:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0784C:  MOVLW  07
0784E:  MOVWF  01
07850:  MOVLB  7
07852:  MOVLB  0
07854:  GOTO   82CE (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
08016:  MOVLB  7
08018:  MOVF   x0E,W
0801A:  IORWF  x0F,W
0801C:  BNZ   8024
....................       return (FR_NOT_ENABLED); 
0801E:  MOVLW  0B
08020:  MOVWF  01
08022:  BRA    81F0
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
08024:  MOVLB  0
08026:  CALL   5518
0802A:  BTFSC  01.0
0802C:  BRA    803E
0802E:  MOVLB  7
08030:  MOVFF  70E,FE9
08034:  MOVFF  70F,FEA
08038:  MOVF   FEF,F
0803A:  BNZ   8046
0803C:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
0803E:  MOVLW  09
08040:  MOVWF  01
08042:  MOVLB  7
08044:  BRA    81F0
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
08046:  MOVLW  1A
08048:  MOVLB  9
0804A:  ADDWF  x8F,W
0804C:  MOVWF  FE9
0804E:  MOVLW  00
08050:  ADDWFC x90,W
08052:  MOVWF  FEA
08054:  BTFSS  FEF.5
08056:  BRA    81CE
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
08058:  MOVLW  14
0805A:  ADDWF  x8F,W
0805C:  MOVWF  FE9
0805E:  MOVLW  00
08060:  ADDWFC x90,W
08062:  MOVWF  FEA
08064:  MOVFF  FEF,9EC
08068:  MOVFF  FEC,9ED
0806C:  MOVFF  FEC,9EE
08070:  MOVFF  FEC,9EF
08074:  MOVLB  0
08076:  CALL   5A0C
0807A:  MOVF   01,F
0807C:  BNZ   8088
....................          return (FR_RW_ERROR); 
0807E:  MOVLW  07
08080:  MOVWF  01
08082:  MOVLB  7
08084:  BRA    81F0
08086:  MOVLB  0
....................       ptr = fp->dir_ptr; 
08088:  MOVLW  18
0808A:  MOVLB  9
0808C:  ADDWF  x8F,W
0808E:  MOVWF  FE9
08090:  MOVLW  00
08092:  ADDWFC x90,W
08094:  MOVWF  FEA
08096:  MOVFF  FEC,992
0809A:  MOVF   FED,F
0809C:  MOVFF  FEF,991
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
080A0:  MOVLW  0B
080A2:  ADDWF  x91,W
080A4:  MOVWF  01
080A6:  MOVLW  00
080A8:  ADDWFC x92,W
080AA:  MOVFF  01,FE9
080AE:  MOVWF  FEA
080B0:  MOVF   FEF,W
080B2:  IORLW  20
080B4:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
080B6:  MOVLW  1C
080B8:  ADDWF  x91,W
080BA:  MOVWF  01
080BC:  MOVLW  00
080BE:  ADDWFC x92,W
080C0:  MOVWF  03
080C2:  MOVFF  01,993
080C6:  MOVWF  x94
080C8:  MOVLW  04
080CA:  ADDWF  x8F,W
080CC:  MOVWF  FE9
080CE:  MOVLW  00
080D0:  ADDWFC x90,W
080D2:  MOVWF  FEA
080D4:  MOVFF  FEF,00
080D8:  MOVFF  FEC,01
080DC:  MOVFF  FEC,02
080E0:  MOVFF  FEC,03
080E4:  MOVFF  994,FEA
080E8:  MOVFF  993,FE9
080EC:  MOVFF  00,FEF
080F0:  MOVFF  01,FEC
080F4:  MOVFF  02,FEC
080F8:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
080FC:  MOVLW  1A
080FE:  ADDWF  x91,W
08100:  MOVWF  01
08102:  MOVLW  00
08104:  ADDWFC x92,W
08106:  MOVWF  03
08108:  MOVFF  01,993
0810C:  MOVWF  x94
0810E:  MOVLW  08
08110:  ADDWF  x8F,W
08112:  MOVWF  FE9
08114:  MOVLW  00
08116:  ADDWFC x90,W
08118:  MOVWF  FEA
0811A:  MOVFF  FEF,00
0811E:  MOVFF  FEC,01
08122:  MOVFF  FEC,02
08126:  MOVFF  FEC,03
0812A:  MOVFF  994,FEA
0812E:  MOVFF  993,FE9
08132:  MOVFF  00,FEF
08136:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
0813A:  MOVLW  14
0813C:  ADDWF  x91,W
0813E:  MOVWF  01
08140:  MOVLW  00
08142:  ADDWFC x92,W
08144:  MOVWF  03
08146:  MOVFF  01,993
0814A:  MOVWF  x94
0814C:  MOVLW  08
0814E:  ADDWF  x8F,W
08150:  MOVWF  FE9
08152:  MOVLW  00
08154:  ADDWFC x90,W
08156:  MOVWF  FEA
08158:  MOVFF  FEF,995
0815C:  MOVFF  FEC,996
08160:  MOVFF  FEC,00
08164:  MOVFF  FEC,01
08168:  MOVFF  994,FEA
0816C:  MOVFF  993,FE9
08170:  MOVFF  00,FEF
08174:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
08178:  MOVLW  16
0817A:  ADDWF  x91,W
0817C:  MOVWF  01
0817E:  MOVLW  00
08180:  ADDWFC x92,W
08182:  MOVWF  03
08184:  MOVFF  01,993
08188:  MOVWF  x94
0818A:  MOVLB  0
0818C:  CALL   6F38
08190:  MOVFF  994,FEA
08194:  MOVFF  993,FE9
08198:  MOVFF  00,FEF
0819C:  MOVFF  01,FEC
081A0:  MOVFF  02,FEC
081A4:  MOVFF  03,FEC
....................       fs->winflag = 1; 
081A8:  MOVLW  06
081AA:  MOVLB  7
081AC:  ADDWF  x0E,W
081AE:  MOVWF  FE9
081B0:  MOVLW  00
081B2:  ADDWFC x0F,W
081B4:  MOVWF  FEA
081B6:  MOVLW  01
081B8:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
081BA:  MOVLW  1A
081BC:  MOVLB  9
081BE:  ADDWF  x8F,W
081C0:  MOVWF  FE9
081C2:  MOVLW  00
081C4:  ADDWFC x90,W
081C6:  MOVWF  FEA
081C8:  MOVF   FEF,W
081CA:  ANDLW  DF
081CC:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
081CE:  CLRF   xEF
081D0:  CLRF   xEE
081D2:  CLRF   xED
081D4:  CLRF   xEC
081D6:  MOVLB  0
081D8:  CALL   5A0C
081DC:  MOVF   01,F
081DE:  BNZ   81EA
....................       return (FR_RW_ERROR); 
081E0:  MOVLW  07
081E2:  MOVWF  01
081E4:  MOVLB  7
081E6:  BRA    81F0
081E8:  MOVLB  0
....................  
....................    return (FR_OK); 
081EA:  MOVLW  00
081EC:  MOVWF  01
081EE:  MOVLB  7
081F0:  MOVLB  0
081F2:  GOTO   8200 (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
081F6:  MOVFF  98D,990
081FA:  MOVFF  98C,98F
081FE:  BRA    8016
08200:  MOVFF  01,98E
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
08204:  MOVLB  9
08206:  MOVF   x8E,F
08208:  BNZ   823A
....................       { 
....................       fp->flag = 0; 
0820A:  MOVLW  1A
0820C:  ADDWF  x8C,W
0820E:  MOVWF  FE9
08210:  MOVLW  00
08212:  ADDWFC x8D,W
08214:  MOVWF  FEA
08216:  CLRF   FEF
....................       if (fs->files) 
08218:  MOVLW  01
0821A:  MOVLB  7
0821C:  ADDWF  x0E,W
0821E:  MOVWF  FE9
08220:  MOVLW  00
08222:  ADDWFC x0F,W
08224:  MOVWF  FEA
08226:  MOVF   FEF,F
08228:  BZ    8238
....................          fs->files--; 
0822A:  MOVLW  01
0822C:  ADDWF  x0E,W
0822E:  MOVWF  FE9
08230:  MOVLW  00
08232:  ADDWFC x0F,W
08234:  MOVWF  FEA
08236:  DECF   FEF,F
08238:  MOVLB  9
....................       } 
....................    return (res); 
0823A:  MOVFF  98E,01
0823E:  MOVLB  0
08240:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0B91A:  CALL   5526
0B91E:  MOVFF  01,864
....................    if (res != FR_OK)  
0B922:  MOVLB  8
0B924:  MOVF   x64,F
0B926:  BZ    B92E
....................       return (res); 
0B928:  MOVFF  864,01
0B92C:  BRA    BBBE
....................  
....................    if (disk_status() & STA_PROTECT) 
0B92E:  MOVLB  0
0B930:  CALL   5518
0B934:  BTFSS  01.2
0B936:  BRA    B942
....................       return (FR_WRITE_PROTECTED); 
0B938:  MOVLW  0A
0B93A:  MOVWF  01
0B93C:  MOVLB  8
0B93E:  BRA    BBBE
0B940:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0B942:  MOVLW  08
0B944:  MOVLB  9
0B946:  MOVWF  xB3
0B948:  MOVLW  71
0B94A:  MOVWF  xB2
0B94C:  MOVLW  08
0B94E:  MOVWF  xB5
0B950:  MOVLW  7F
0B952:  MOVWF  xB4
0B954:  MOVFF  863,9B7
0B958:  MOVFF  862,9B6
0B95C:  MOVLW  08
0B95E:  MOVWF  xB9
0B960:  MOVLW  65
0B962:  MOVWF  xB8
0B964:  MOVLB  0
0B966:  CALL   6156
0B96A:  MOVFF  01,864
....................  
....................    if (res != FR_OK)  
0B96E:  MOVLB  8
0B970:  MOVF   x64,F
0B972:  BZ    B97A
....................       return (res);            // Trace failed  
0B974:  MOVFF  864,01
0B978:  BRA    BBBE
....................  
....................    if (dir_ptr == NULL)  
0B97A:  MOVF   x65,F
0B97C:  BNZ   B988
0B97E:  MOVF   x66,F
0B980:  BNZ   B988
....................       return (FR_NO_FILE);      // It is a root directory  
0B982:  MOVLW  02
0B984:  MOVWF  01
0B986:  BRA    BBBE
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0B988:  MOVLW  0B
0B98A:  ADDWF  x65,W
0B98C:  MOVWF  01
0B98E:  MOVLW  00
0B990:  ADDWFC x66,W
0B992:  MOVWF  03
0B994:  MOVFF  01,FE9
0B998:  MOVWF  FEA
0B99A:  BTFSS  FEF.0
0B99C:  BRA    B9A4
....................       return (FR_DENIED);         // It is a R/O item  
0B99E:  MOVLW  05
0B9A0:  MOVWF  01
0B9A2:  BRA    BBBE
....................  
....................    dsect = fs->winsect; 
0B9A4:  MOVLW  20
0B9A6:  MOVLB  7
0B9A8:  ADDWF  x0E,W
0B9AA:  MOVWF  FE9
0B9AC:  MOVLW  00
0B9AE:  ADDWFC x0F,W
0B9B0:  MOVWF  FEA
0B9B2:  MOVFF  FEF,86D
0B9B6:  MOVFF  FEC,86E
0B9BA:  MOVFF  FEC,86F
0B9BE:  MOVFF  FEC,870
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0B9C2:  MOVLW  14
0B9C4:  MOVLB  8
0B9C6:  ADDWF  x65,W
0B9C8:  MOVWF  01
0B9CA:  MOVLW  00
0B9CC:  ADDWFC x66,W
0B9CE:  MOVWF  03
0B9D0:  MOVFF  01,FE9
0B9D4:  MOVWF  FEA
0B9D6:  MOVFF  FEC,86C
0B9DA:  MOVF   FED,F
0B9DC:  MOVFF  FEF,88B
0B9E0:  MOVFF  88B,86B
0B9E4:  CLRF   x8B
0B9E6:  CLRF   x8C
0B9E8:  MOVLW  1A
0B9EA:  ADDWF  x65,W
0B9EC:  MOVWF  01
0B9EE:  MOVLW  00
0B9F0:  ADDWFC x66,W
0B9F2:  MOVFF  01,FE9
0B9F6:  MOVWF  FEA
0B9F8:  MOVFF  FEC,03
0B9FC:  MOVF   FED,F
0B9FE:  MOVF   FEF,W
0BA00:  IORWF  x8B,W
0BA02:  MOVWF  x69
0BA04:  MOVF   03,W
0BA06:  IORWF  x8C,W
0BA08:  MOVWF  x6A
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BA0A:  MOVLW  0B
0BA0C:  ADDWF  x65,W
0BA0E:  MOVWF  01
0BA10:  MOVLW  00
0BA12:  ADDWFC x66,W
0BA14:  MOVWF  03
0BA16:  MOVFF  01,FE9
0BA1A:  MOVWF  FEA
0BA1C:  BTFSS  FEF.4
0BA1E:  BRA    BB32
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BA20:  MOVFF  86C,878
0BA24:  MOVFF  86B,877
0BA28:  MOVFF  86A,876
0BA2C:  MOVFF  869,875
....................       dirscan.sect = clust2sect(dclust); 
0BA30:  MOVFF  86C,9CE
0BA34:  MOVFF  86B,9CD
0BA38:  MOVFF  86A,9CC
0BA3C:  MOVFF  869,9CB
0BA40:  MOVLB  0
0BA42:  CALL   5588
0BA46:  MOVFF  03,87C
0BA4A:  MOVFF  02,87B
0BA4E:  MOVFF  01,87A
0BA52:  MOVFF  00,879
....................       dirscan.index = 0; 
0BA56:  MOVLB  8
0BA58:  CLRF   x7E
0BA5A:  CLRF   x7D
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BA5C:  MOVFF  87C,9EF
0BA60:  MOVFF  87B,9EE
0BA64:  MOVFF  87A,9ED
0BA68:  MOVFF  879,9EC
0BA6C:  MOVLB  0
0BA6E:  CALL   5A0C
0BA72:  MOVF   01,F
0BA74:  BNZ   BA80
....................             return (FR_RW_ERROR); 
0BA76:  MOVLW  07
0BA78:  MOVWF  01
0BA7A:  MOVLB  8
0BA7C:  BRA    BBBE
0BA7E:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BA80:  MOVLB  8
0BA82:  MOVF   x7D,W
0BA84:  ANDLW  0F
0BA86:  MOVWF  x8B
0BA88:  CLRF   x8C
0BA8A:  RLCF   x8B,F
0BA8C:  RLCF   x8C,F
0BA8E:  RLCF   x8B,F
0BA90:  RLCF   x8C,F
0BA92:  RLCF   x8B,F
0BA94:  RLCF   x8C,F
0BA96:  RLCF   x8B,F
0BA98:  RLCF   x8C,F
0BA9A:  RLCF   x8B,F
0BA9C:  RLCF   x8C,F
0BA9E:  MOVLW  E0
0BAA0:  ANDWF  x8B,F
0BAA2:  MOVLW  24
0BAA4:  ADDWF  x8B,W
0BAA6:  MOVWF  01
0BAA8:  MOVLW  00
0BAAA:  ADDWFC x8C,W
0BAAC:  MOVWF  03
0BAAE:  MOVF   01,W
0BAB0:  MOVLB  7
0BAB2:  ADDWF  x0E,W
0BAB4:  MOVWF  01
0BAB6:  MOVF   x0F,W
0BAB8:  ADDWFC 03,F
0BABA:  MOVFF  01,867
0BABE:  MOVLB  8
0BAC0:  MOVFF  03,868
....................          if (*sdir == 0) 
0BAC4:  MOVFF  868,03
0BAC8:  MOVFF  867,FE9
0BACC:  MOVFF  868,FEA
0BAD0:  MOVF   FEF,F
0BAD2:  BNZ   BAD6
....................             break; 
0BAD4:  BRA    BB32
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BAD6:  MOVFF  868,03
0BADA:  MOVFF  867,FE9
0BADE:  MOVFF  868,FEA
0BAE2:  MOVF   FEF,W
0BAE4:  SUBLW  E5
0BAE6:  BZ    BB16
0BAE8:  MOVFF  868,03
0BAEC:  MOVFF  867,FE9
0BAF0:  MOVFF  868,FEA
0BAF4:  MOVF   FEF,W
0BAF6:  SUBLW  2E
0BAF8:  BZ    BB16
0BAFA:  MOVLW  0B
0BAFC:  ADDWF  x67,W
0BAFE:  MOVWF  01
0BB00:  MOVLW  00
0BB02:  ADDWFC x68,W
0BB04:  MOVWF  03
0BB06:  MOVFF  01,FE9
0BB0A:  MOVWF  FEA
0BB0C:  BTFSC  FEF.3
0BB0E:  BRA    BB16
....................             return (FR_DENIED);   // The directory is not empty  
0BB10:  MOVLW  05
0BB12:  MOVWF  01
0BB14:  BRA    BBBE
....................          } while (next_dir_ptr(&dirscan)); 
0BB16:  MOVLW  08
0BB18:  MOVLB  9
0BB1A:  MOVWF  xC2
0BB1C:  MOVLW  71
0BB1E:  MOVWF  xC1
0BB20:  MOVLB  0
0BB22:  CALL   5F7C
0BB26:  MOVF   01,F
0BB28:  BTFSC  FD8.2
0BB2A:  BRA    BB30
0BB2C:  MOVLB  8
0BB2E:  BRA    BA5C
0BB30:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BB32:  MOVFF  870,9EF
0BB36:  MOVFF  86F,9EE
0BB3A:  MOVFF  86E,9ED
0BB3E:  MOVFF  86D,9EC
0BB42:  MOVLB  0
0BB44:  CALL   5A0C
0BB48:  MOVF   01,F
0BB4A:  BNZ   BB56
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BB4C:  MOVLW  07
0BB4E:  MOVWF  01
0BB50:  MOVLB  8
0BB52:  BRA    BBBE
0BB54:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BB56:  MOVLB  8
0BB58:  MOVFF  865,FE9
0BB5C:  MOVFF  866,FEA
0BB60:  MOVLW  E5
0BB62:  MOVWF  FEF
....................    fs->winflag = 1; 
0BB64:  MOVLW  06
0BB66:  MOVLB  7
0BB68:  ADDWF  x0E,W
0BB6A:  MOVWF  FE9
0BB6C:  MOVLW  00
0BB6E:  ADDWFC x0F,W
0BB70:  MOVWF  FEA
0BB72:  MOVLW  01
0BB74:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BB76:  MOVFF  86C,9BA
0BB7A:  MOVFF  86B,9B9
0BB7E:  MOVFF  86A,9B8
0BB82:  MOVFF  869,9B7
0BB86:  MOVLB  0
0BB88:  CALL   6E98
0BB8C:  MOVF   01,F
0BB8E:  BNZ   BB9A
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BB90:  MOVLW  07
0BB92:  MOVWF  01
0BB94:  MOVLB  8
0BB96:  BRA    BBBE
0BB98:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BB9A:  MOVLB  9
0BB9C:  CLRF   xEF
0BB9E:  CLRF   xEE
0BBA0:  CLRF   xED
0BBA2:  CLRF   xEC
0BBA4:  MOVLB  0
0BBA6:  CALL   5A0C
0BBAA:  MOVF   01,F
0BBAC:  BNZ   BBB8
....................       return (FR_RW_ERROR); 
0BBAE:  MOVLW  07
0BBB0:  MOVWF  01
0BBB2:  MOVLB  8
0BBB4:  BRA    BBBE
0BBB6:  MOVLB  0
....................  
....................    return (FR_OK); 
0BBB8:  MOVLW  00
0BBBA:  MOVWF  01
0BBBC:  MOVLB  8
0BBBE:  MOVLB  0
0BBC0:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0790C:  MOVFF  98D,98F
07910:  MOVFF  98C,98E
07914:  MOVFF  98F,03
07918:  MOVLB  9
0791A:  MOVFF  98E,FE9
0791E:  MOVFF  98F,FEA
07922:  MOVF   FEF,F
07924:  BZ    7932
07926:  INCF   x8E,F
07928:  BTFSC  FD8.2
0792A:  INCF   x8F,F
0792C:  MOVLB  0
0792E:  BRA    7914
07930:  MOVLB  9
....................    return(sc - s); 
07932:  MOVF   x8C,W
07934:  SUBWF  x8E,W
07936:  MOVWF  00
07938:  MOVF   x8D,W
0793A:  SUBWFB x8F,W
0793C:  MOVWF  03
0793E:  MOVFF  00,01
07942:  MOVWF  02
07944:  MOVLB  0
07946:  GOTO   8386 (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
03486:  MOVLB  4
03488:  CLRF   xE2
0348A:  MOVLW  01
0348C:  MOVWF  xE1
....................    rtc.year=10; 
0348E:  MOVLW  0A
03490:  MOVWF  xE0
....................    rtc.month=1; 
03492:  MOVLW  01
03494:  MOVWF  xDF
....................    rtc.day=1; 
03496:  MOVWF  xDE
....................    rtc.hour=0; 
03498:  CLRF   xDD
....................    rtc.min=0; 
0349A:  CLRF   xDC
....................    rtc.sec=0; 
0349C:  CLRF   xDB
....................    rtc.ms100=0; 
0349E:  CLRF   xDA
034A0:  MOVLB  0
034A2:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
06F38:  MOVLB  9
06F3A:  CLRF   xB9
06F3C:  CLRF   xB8
06F3E:  CLRF   xB7
06F40:  MOVFF  4E0,9B6
06F44:  MOVLW  14
06F46:  ADDWF  xB6,F
06F48:  MOVLW  00
06F4A:  ADDWFC xB7,F
06F4C:  ADDWFC xB8,F
06F4E:  ADDWFC xB9,F
06F50:  BCF    FD8.0
06F52:  CLRF   xB2
06F54:  CLRF   xB3
06F56:  CLRF   xB4
06F58:  RLCF   xB6,W
06F5A:  MOVWF  xB5
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
06F5C:  CLRF   xB9
06F5E:  CLRF   xB8
06F60:  CLRF   xB7
06F62:  MOVFF  4DF,9B6
06F66:  MOVLW  0F
06F68:  ANDWF  xB6,F
06F6A:  CLRF   xB7
06F6C:  CLRF   xB8
06F6E:  CLRF   xB9
06F70:  CLRF   00
06F72:  CLRF   01
06F74:  RLCF   xB6,W
06F76:  MOVWF  02
06F78:  RLCF   xB7,W
06F7A:  MOVWF  03
06F7C:  RLCF   02,F
06F7E:  RLCF   03,F
06F80:  RLCF   02,F
06F82:  RLCF   03,F
06F84:  RLCF   02,F
06F86:  RLCF   03,F
06F88:  RLCF   02,F
06F8A:  RLCF   03,F
06F8C:  MOVLW  E0
06F8E:  ANDWF  02,F
06F90:  MOVF   00,W
06F92:  IORWF  xB2,F
06F94:  MOVF   01,W
06F96:  IORWF  xB3,F
06F98:  MOVF   02,W
06F9A:  IORWF  xB4,F
06F9C:  MOVF   03,W
06F9E:  IORWF  xB5,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
06FA0:  CLRF   xB9
06FA2:  CLRF   xB8
06FA4:  CLRF   xB7
06FA6:  MOVFF  4DE,9B6
06FAA:  MOVLW  1F
06FAC:  ANDWF  xB6,F
06FAE:  CLRF   xB7
06FB0:  CLRF   xB8
06FB2:  CLRF   xB9
06FB4:  CLRF   00
06FB6:  CLRF   01
06FB8:  MOVF   00,W
06FBA:  IORWF  xB2,F
06FBC:  MOVF   01,W
06FBE:  IORWF  xB3,F
06FC0:  MOVF   xB6,W
06FC2:  IORWF  xB4,F
06FC4:  MOVF   xB7,W
06FC6:  IORWF  xB5,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
06FC8:  CLRF   xB9
06FCA:  CLRF   xB8
06FCC:  CLRF   xB7
06FCE:  MOVFF  4DD,9B6
06FD2:  MOVLW  1F
06FD4:  ANDWF  xB6,F
06FD6:  CLRF   xB7
06FD8:  CLRF   xB8
06FDA:  CLRF   xB9
06FDC:  CLRF   00
06FDE:  RLCF   xB6,W
06FE0:  MOVWF  01
06FE2:  RLCF   xB7,W
06FE4:  MOVWF  02
06FE6:  RLCF   xB8,W
06FE8:  MOVWF  03
06FEA:  RLCF   01,F
06FEC:  RLCF   02,F
06FEE:  RLCF   03,F
06FF0:  RLCF   01,F
06FF2:  RLCF   02,F
06FF4:  RLCF   03,F
06FF6:  MOVLW  F8
06FF8:  ANDWF  01,F
06FFA:  MOVF   00,W
06FFC:  IORWF  xB2,F
06FFE:  MOVF   01,W
07000:  IORWF  xB3,F
07002:  MOVF   02,W
07004:  IORWF  xB4,F
07006:  MOVF   03,W
07008:  IORWF  xB5,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
0700A:  CLRF   xB9
0700C:  CLRF   xB8
0700E:  CLRF   xB7
07010:  MOVFF  4DC,9B6
07014:  MOVLW  3F
07016:  ANDWF  xB6,F
07018:  CLRF   xB7
0701A:  CLRF   xB8
0701C:  CLRF   xB9
0701E:  RLCF   xB6,W
07020:  MOVWF  00
07022:  RLCF   xB7,W
07024:  MOVWF  01
07026:  RLCF   xB8,W
07028:  MOVWF  02
0702A:  RLCF   xB9,W
0702C:  MOVWF  03
0702E:  RLCF   00,F
07030:  RLCF   01,F
07032:  RLCF   02,F
07034:  RLCF   03,F
07036:  RLCF   00,F
07038:  RLCF   01,F
0703A:  RLCF   02,F
0703C:  RLCF   03,F
0703E:  RLCF   00,F
07040:  RLCF   01,F
07042:  RLCF   02,F
07044:  RLCF   03,F
07046:  RLCF   00,F
07048:  RLCF   01,F
0704A:  RLCF   02,F
0704C:  RLCF   03,F
0704E:  MOVLW  E0
07050:  ANDWF  00,F
07052:  MOVF   00,W
07054:  IORWF  xB2,F
07056:  MOVF   01,W
07058:  IORWF  xB3,F
0705A:  MOVF   02,W
0705C:  IORWF  xB4,F
0705E:  MOVF   03,W
07060:  IORWF  xB5,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
07062:  CLRF   xB9
07064:  CLRF   xB8
07066:  CLRF   xB7
07068:  MOVFF  4DB,9B6
0706C:  MOVLW  3F
0706E:  ANDWF  xB6,F
07070:  CLRF   xB7
07072:  CLRF   xB8
07074:  CLRF   xB9
07076:  BCF    FD8.0
07078:  RRCF   xB9,W
0707A:  MOVWF  03
0707C:  RRCF   xB8,W
0707E:  MOVWF  02
07080:  RRCF   xB7,W
07082:  MOVWF  01
07084:  RRCF   xB6,W
07086:  IORWF  xB2,F
07088:  MOVF   01,W
0708A:  IORWF  xB3,F
0708C:  MOVF   02,W
0708E:  IORWF  xB4,F
07090:  MOVF   03,W
07092:  IORWF  xB5,F
....................    return (work); 
07094:  MOVFF  9B2,00
07098:  MOVFF  9B3,01
0709C:  MOVFF  9B4,02
070A0:  MOVFF  9B5,03
070A4:  MOVLB  0
070A6:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0B7A0:  MOVLW  08
0B7A2:  MOVLB  9
0B7A4:  MOVWF  x8D
0B7A6:  MOVLW  63
0B7A8:  MOVWF  x8C
0B7AA:  MOVFF  862,98F
0B7AE:  MOVFF  861,98E
0B7B2:  MOVLW  01
0B7B4:  MOVWF  x90
0B7B6:  MOVLB  0
0B7B8:  CALL   70A8
0B7BC:  MOVFF  01,87F
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0B7C0:  MOVLB  8
0B7C2:  MOVF   x7F,F
0B7C4:  BTFSS  FD8.2
0B7C6:  BRA    B8C8
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0B7C8:  MOVLW  08
0B7CA:  MOVWF  xA5
0B7CC:  MOVLW  63
0B7CE:  MOVWF  xA4
0B7D0:  MOVLW  08
0B7D2:  MOVWF  xA7
0B7D4:  MOVLW  80
0B7D6:  MOVWF  xA6
0B7D8:  CLRF   xA9
0B7DA:  MOVLW  20
0B7DC:  MOVWF  xA8
0B7DE:  MOVLW  08
0B7E0:  MOVWF  xAB
0B7E2:  MOVLW  A2
0B7E4:  MOVWF  xAA
0B7E6:  MOVLB  0
0B7E8:  BRA    B0E4
0B7EA:  MOVFF  01,87F
....................          for (i = 0; i < br; i++) 
0B7EE:  MOVLB  8
0B7F0:  CLRF   xA1
0B7F2:  CLRF   xA0
0B7F4:  MOVF   xA1,W
0B7F6:  SUBWF  xA3,W
0B7F8:  BNC   B824
0B7FA:  BNZ   B802
0B7FC:  MOVF   xA2,W
0B7FE:  SUBWF  xA0,W
0B800:  BC    B824
....................          { 
....................             putc(mesg[i]); 
0B802:  MOVLW  80
0B804:  ADDWF  xA0,W
0B806:  MOVWF  FE9
0B808:  MOVLW  08
0B80A:  ADDWFC xA1,W
0B80C:  MOVWF  FEA
0B80E:  MOVFF  FEF,8A4
0B812:  MOVF   xA4,W
0B814:  MOVLB  0
0B816:  CALL   ADBE
0B81A:  MOVLB  8
0B81C:  INCF   xA0,F
0B81E:  BTFSC  FD8.2
0B820:  INCF   xA1,F
0B822:  BRA    B7F4
....................          } 
....................       } while ((result == FR_OK) && br); 
0B824:  MOVF   x7F,F
0B826:  BNZ   B82E
0B828:  MOVF   xA2,W
0B82A:  IORWF  xA3,W
0B82C:  BNZ   B7C8
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0B82E:  MOVF   x7F,F
0B830:  BZ    B8A4
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0B832:  MOVLW  16
0B834:  MOVWF  FF6
0B836:  MOVLW  0C
0B838:  MOVWF  FF7
0B83A:  MOVLW  00
0B83C:  MOVWF  FF8
0B83E:  CLRF   1B
0B840:  BTFSC  FF2.7
0B842:  BSF    1B.7
0B844:  BCF    FF2.7
0B846:  MOVLB  0
0B848:  CALL   0E30
0B84C:  BTFSC  1B.7
0B84E:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0B850:  MOVFF  87F,8A4
0B854:  MOVLW  08
0B856:  MOVLB  8
0B858:  MOVWF  xA6
0B85A:  MOVLW  80
0B85C:  MOVWF  xA5
0B85E:  MOVLB  0
0B860:  RCALL  B5F2
....................          printf("@FS: %s\r\n",mesg); 
0B862:  MOVLW  2C
0B864:  MOVWF  FF6
0B866:  MOVLW  0C
0B868:  MOVWF  FF7
0B86A:  MOVLW  00
0B86C:  MOVWF  FF8
0B86E:  CLRF   1B
0B870:  BTFSC  FF2.7
0B872:  BSF    1B.7
0B874:  BCF    FF2.7
0B876:  MOVLW  05
0B878:  MOVLB  A
0B87A:  MOVWF  x18
0B87C:  MOVLB  0
0B87E:  CALL   1006
0B882:  BTFSC  1B.7
0B884:  BSF    FF2.7
0B886:  MOVLW  08
0B888:  MOVWF  FEA
0B88A:  MOVLW  80
0B88C:  MOVWF  FE9
0B88E:  CALL   78E6
0B892:  MOVLW  0D
0B894:  BTFSS  F9E.4
0B896:  BRA    B894
0B898:  MOVWF  FAD
0B89A:  MOVLW  0A
0B89C:  BTFSS  F9E.4
0B89E:  BRA    B89C
0B8A0:  MOVWF  FAD
0B8A2:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0B8A4:  MOVLW  08
0B8A6:  MOVLB  9
0B8A8:  MOVWF  x8D
0B8AA:  MOVLW  63
0B8AC:  MOVWF  x8C
0B8AE:  MOVLB  0
0B8B0:  CALL   81F6
....................       printf("\r\n");       
0B8B4:  MOVLW  0D
0B8B6:  BTFSS  F9E.4
0B8B8:  BRA    B8B6
0B8BA:  MOVWF  FAD
0B8BC:  MOVLW  0A
0B8BE:  BTFSS  F9E.4
0B8C0:  BRA    B8BE
0B8C2:  MOVWF  FAD
....................    } 
0B8C4:  BRA    B918
0B8C6:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0B8C8:  MOVFF  87F,8A4
0B8CC:  MOVLW  08
0B8CE:  MOVWF  xA6
0B8D0:  MOVLW  80
0B8D2:  MOVWF  xA5
0B8D4:  MOVLB  0
0B8D6:  RCALL  B5F2
....................       printf("@FS: %s\r\n",mesg); 
0B8D8:  MOVLW  36
0B8DA:  MOVWF  FF6
0B8DC:  MOVLW  0C
0B8DE:  MOVWF  FF7
0B8E0:  MOVLW  00
0B8E2:  MOVWF  FF8
0B8E4:  CLRF   1B
0B8E6:  BTFSC  FF2.7
0B8E8:  BSF    1B.7
0B8EA:  BCF    FF2.7
0B8EC:  MOVLW  05
0B8EE:  MOVLB  A
0B8F0:  MOVWF  x18
0B8F2:  MOVLB  0
0B8F4:  CALL   1006
0B8F8:  BTFSC  1B.7
0B8FA:  BSF    FF2.7
0B8FC:  MOVLW  08
0B8FE:  MOVWF  FEA
0B900:  MOVLW  80
0B902:  MOVWF  FE9
0B904:  CALL   78E6
0B908:  MOVLW  0D
0B90A:  BTFSS  F9E.4
0B90C:  BRA    B90A
0B90E:  MOVWF  FAD
0B910:  MOVLW  0A
0B912:  BTFSS  F9E.4
0B914:  BRA    B912
0B916:  MOVWF  FAD
....................    } 
0B918:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04D72:  MOVLW  40
04D74:  MOVWF  FF6
04D76:  MOVLW  0C
04D78:  MOVWF  FF7
04D7A:  MOVLW  00
04D7C:  MOVWF  FF8
04D7E:  CLRF   1B
04D80:  BTFSC  FF2.7
04D82:  BSF    1B.7
04D84:  BCF    FF2.7
04D86:  CALL   0E30
04D8A:  BTFSC  1B.7
04D8C:  BSF    FF2.7
....................    if (status & FR_OK) 
04D8E:  ANDLW  00
04D90:  BZ    4DAE
....................       printf("   NoError\r\n"); 
04D92:  MOVLW  50
04D94:  MOVWF  FF6
04D96:  MOVLW  0C
04D98:  MOVWF  FF7
04D9A:  MOVLW  00
04D9C:  MOVWF  FF8
04D9E:  CLRF   1B
04DA0:  BTFSC  FF2.7
04DA2:  BSF    1B.7
04DA4:  BCF    FF2.7
04DA6:  CALL   0E30
04DAA:  BTFSC  1B.7
04DAC:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04DAE:  MOVLB  8
04DB0:  BTFSS  x66.0
04DB2:  BRA    4DD4
....................       printf("   Media Not Ready\r\n"); 
04DB4:  MOVLW  5E
04DB6:  MOVWF  FF6
04DB8:  MOVLW  0C
04DBA:  MOVWF  FF7
04DBC:  MOVLW  00
04DBE:  MOVWF  FF8
04DC0:  CLRF   1B
04DC2:  BTFSC  FF2.7
04DC4:  BSF    1B.7
04DC6:  BCF    FF2.7
04DC8:  MOVLB  0
04DCA:  CALL   0E30
04DCE:  BTFSC  1B.7
04DD0:  BSF    FF2.7
04DD2:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04DD4:  BTFSS  x66.1
04DD6:  BRA    4DF8
....................       printf("   File Not Found\r\n"); 
04DD8:  MOVLW  74
04DDA:  MOVWF  FF6
04DDC:  MOVLW  0C
04DDE:  MOVWF  FF7
04DE0:  MOVLW  00
04DE2:  MOVWF  FF8
04DE4:  CLRF   1B
04DE6:  BTFSC  FF2.7
04DE8:  BSF    1B.7
04DEA:  BCF    FF2.7
04DEC:  MOVLB  0
04DEE:  CALL   0E30
04DF2:  BTFSC  1B.7
04DF4:  BSF    FF2.7
04DF6:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04DF8:  MOVF   x66,W
04DFA:  ANDLW  03
04DFC:  BZ    4E1E
....................       printf("   Invalid Path\r\n"); 
04DFE:  MOVLW  88
04E00:  MOVWF  FF6
04E02:  MOVLW  0C
04E04:  MOVWF  FF7
04E06:  MOVLW  00
04E08:  MOVWF  FF8
04E0A:  CLRF   1B
04E0C:  BTFSC  FF2.7
04E0E:  BSF    1B.7
04E10:  BCF    FF2.7
04E12:  MOVLB  0
04E14:  CALL   0E30
04E18:  BTFSC  1B.7
04E1A:  BSF    FF2.7
04E1C:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04E1E:  BTFSS  x66.2
04E20:  BRA    4E42
....................       printf("   Invalid Name\r\n"); 
04E22:  MOVLW  9A
04E24:  MOVWF  FF6
04E26:  MOVLW  0C
04E28:  MOVWF  FF7
04E2A:  MOVLW  00
04E2C:  MOVWF  FF8
04E2E:  CLRF   1B
04E30:  BTFSC  FF2.7
04E32:  BSF    1B.7
04E34:  BCF    FF2.7
04E36:  MOVLB  0
04E38:  CALL   0E30
04E3C:  BTFSC  1B.7
04E3E:  BSF    FF2.7
04E40:  MOVLB  8
....................    if (status & FR_DENIED) 
04E42:  MOVF   x66,W
04E44:  ANDLW  05
04E46:  BZ    4E68
....................       printf("   Access Denied\r\n"); 
04E48:  MOVLW  AC
04E4A:  MOVWF  FF6
04E4C:  MOVLW  0C
04E4E:  MOVWF  FF7
04E50:  MOVLW  00
04E52:  MOVWF  FF8
04E54:  CLRF   1B
04E56:  BTFSC  FF2.7
04E58:  BSF    1B.7
04E5A:  BCF    FF2.7
04E5C:  MOVLB  0
04E5E:  CALL   0E30
04E62:  BTFSC  1B.7
04E64:  BSF    FF2.7
04E66:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04E68:  MOVF   x66,W
04E6A:  ANDLW  06
04E6C:  BZ    4E8E
....................       printf("   Disk Full\r\n"); 
04E6E:  MOVLW  C0
04E70:  MOVWF  FF6
04E72:  MOVLW  0C
04E74:  MOVWF  FF7
04E76:  MOVLW  00
04E78:  MOVWF  FF8
04E7A:  CLRF   1B
04E7C:  BTFSC  FF2.7
04E7E:  BSF    1B.7
04E80:  BCF    FF2.7
04E82:  MOVLB  0
04E84:  CALL   0E30
04E88:  BTFSC  1B.7
04E8A:  BSF    FF2.7
04E8C:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04E8E:  MOVF   x66,W
04E90:  ANDLW  07
04E92:  BZ    4EB4
....................       printf("   Read/Write Error\r\n"); 
04E94:  MOVLW  D0
04E96:  MOVWF  FF6
04E98:  MOVLW  0C
04E9A:  MOVWF  FF7
04E9C:  MOVLW  00
04E9E:  MOVWF  FF8
04EA0:  CLRF   1B
04EA2:  BTFSC  FF2.7
04EA4:  BSF    1B.7
04EA6:  BCF    FF2.7
04EA8:  MOVLB  0
04EAA:  CALL   0E30
04EAE:  BTFSC  1B.7
04EB0:  BSF    FF2.7
04EB2:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04EB4:  MOVF   x66,W
04EB6:  ANDLW  09
04EB8:  BZ    4EDA
....................       printf("   Incorrect Media Change\r\n"); 
04EBA:  MOVLW  E6
04EBC:  MOVWF  FF6
04EBE:  MOVLW  0C
04EC0:  MOVWF  FF7
04EC2:  MOVLW  00
04EC4:  MOVWF  FF8
04EC6:  CLRF   1B
04EC8:  BTFSC  FF2.7
04ECA:  BSF    1B.7
04ECC:  BCF    FF2.7
04ECE:  MOVLB  0
04ED0:  CALL   0E30
04ED4:  BTFSC  1B.7
04ED6:  BSF    FF2.7
04ED8:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04EDA:  MOVF   x66,W
04EDC:  ANDLW  0A
04EDE:  BZ    4F00
....................       printf("   Write Protected\r\n"); 
04EE0:  MOVLW  02
04EE2:  MOVWF  FF6
04EE4:  MOVLW  0D
04EE6:  MOVWF  FF7
04EE8:  MOVLW  00
04EEA:  MOVWF  FF8
04EEC:  CLRF   1B
04EEE:  BTFSC  FF2.7
04EF0:  BSF    1B.7
04EF2:  BCF    FF2.7
04EF4:  MOVLB  0
04EF6:  CALL   0E30
04EFA:  BTFSC  1B.7
04EFC:  BSF    FF2.7
04EFE:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04F00:  MOVF   x66,W
04F02:  ANDLW  0B
04F04:  BZ    4F26
....................       printf("   Not Enabled\r\n"); 
04F06:  MOVLW  18
04F08:  MOVWF  FF6
04F0A:  MOVLW  0D
04F0C:  MOVWF  FF7
04F0E:  MOVLW  00
04F10:  MOVWF  FF8
04F12:  CLRF   1B
04F14:  BTFSC  FF2.7
04F16:  BSF    1B.7
04F18:  BCF    FF2.7
04F1A:  MOVLB  0
04F1C:  CALL   0E30
04F20:  BTFSC  1B.7
04F22:  BSF    FF2.7
04F24:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04F26:  MOVF   x66,W
04F28:  ANDLW  0C
04F2A:  BZ    4F4C
....................       printf("   No File System\r\n"); 
04F2C:  MOVLW  2A
04F2E:  MOVWF  FF6
04F30:  MOVLW  0D
04F32:  MOVWF  FF7
04F34:  MOVLW  00
04F36:  MOVWF  FF8
04F38:  CLRF   1B
04F3A:  BTFSC  FF2.7
04F3C:  BSF    1B.7
04F3E:  BCF    FF2.7
04F40:  MOVLB  0
04F42:  CALL   0E30
04F46:  BTFSC  1B.7
04F48:  BSF    FF2.7
04F4A:  MOVLB  8
04F4C:  MOVLB  0
04F4E:  GOTO   4FD8 (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
08242:  MOVLW  08
08244:  MOVWF  FEA
08246:  MOVLW  EC
08248:  MOVWF  FE9
0824A:  CLRF   00
0824C:  CLRF   02
0824E:  MOVLW  A0
08250:  MOVWF  01
08252:  CALL   34A4
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
08256:  MOVLW  08
08258:  MOVLB  9
0825A:  MOVWF  x8D
0825C:  MOVLW  CB
0825E:  MOVWF  x8C
08260:  MOVFF  8CA,98F
08264:  MOVFF  8C9,98E
08268:  MOVLW  12
0826A:  MOVWF  x90
0826C:  MOVLB  0
0826E:  CALL   70A8
08272:  MOVFF  01,8E7
....................    if (result) 
08276:  MOVLB  8
08278:  MOVF   xE7,F
0827A:  BZ    829E
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
0827C:  MOVLW  3E
0827E:  MOVWF  FF6
08280:  MOVLW  0D
08282:  MOVWF  FF7
08284:  MOVLW  00
08286:  MOVWF  FF8
08288:  CLRF   1B
0828A:  BTFSC  FF2.7
0828C:  BSF    1B.7
0828E:  BCF    FF2.7
08290:  MOVLB  0
08292:  CALL   0E30
08296:  BTFSC  1B.7
08298:  BSF    FF2.7
....................    } 
0829A:  BRA    841A
0829C:  MOVLB  8
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
0829E:  MOVF   xCF,F
082A0:  BNZ   82AE
082A2:  MOVF   xD0,F
082A4:  BNZ   82AE
082A6:  MOVF   xD1,F
082A8:  BNZ   82AE
082AA:  MOVF   xD2,F
082AC:  BZ    82D4
....................          result = f_lseek(&fdst, fdst.fsize);  
082AE:  MOVLW  08
082B0:  MOVLB  9
082B2:  MOVWF  x8D
082B4:  MOVLW  CB
082B6:  MOVWF  x8C
082B8:  MOVFF  8D2,991
082BC:  MOVFF  8D1,990
082C0:  MOVFF  8D0,98F
082C4:  MOVFF  8CF,98E
082C8:  MOVLB  0
082CA:  GOTO   74F0
082CE:  MOVFF  01,8E7
082D2:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
082D4:  MOVLB  0
082D6:  MOVF   x62,F
082D8:  BNZ   82F6
082DA:  MOVLW  08
082DC:  MOVLB  9
082DE:  MOVWF  x8D
082E0:  MOVLW  EC
082E2:  MOVWF  x8C
082E4:  CLRF   x8F
082E6:  MOVLW  63
082E8:  MOVWF  x8E
082EA:  CLRF   x91
082EC:  MOVLW  9F
082EE:  MOVWF  x90
082F0:  MOVLB  0
082F2:  CALL   7858
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
082F6:  DECFSZ x62,W
082F8:  BRA    8318
082FA:  MOVLW  08
082FC:  MOVLB  9
082FE:  MOVWF  x8D
08300:  MOVLW  EC
08302:  MOVWF  x8C
08304:  MOVLW  01
08306:  MOVWF  x8F
08308:  MOVLW  03
0830A:  MOVWF  x8E
0830C:  CLRF   x91
0830E:  MOVLW  9F
08310:  MOVWF  x90
08312:  MOVLB  0
08314:  CALL   7858
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
08318:  MOVF   20,F
0831A:  BNZ   8322
0831C:  MOVF   1F,W
0831E:  SUBLW  04
08320:  BC    8376
08322:  MOVLW  5E
08324:  MOVWF  FF6
08326:  MOVLW  0D
08328:  MOVWF  FF7
0832A:  MOVLW  00
0832C:  MOVWF  FF8
0832E:  CLRF   1B
08330:  BTFSC  FF2.7
08332:  BSF    1B.7
08334:  BCF    FF2.7
08336:  MOVLW  0E
08338:  MOVLB  A
0833A:  MOVWF  x18
0833C:  MOVLB  0
0833E:  CALL   1006
08342:  BTFSC  1B.7
08344:  BSF    FF2.7
08346:  MOVLW  08
08348:  MOVWF  FEA
0834A:  MOVLW  EC
0834C:  MOVWF  FE9
0834E:  CALL   78E6
08352:  MOVLW  6E
08354:  MOVWF  FF6
08356:  MOVLW  0D
08358:  MOVWF  FF7
0835A:  MOVLW  00
0835C:  MOVWF  FF8
0835E:  CLRF   1B
08360:  BTFSC  FF2.7
08362:  BSF    1B.7
08364:  BCF    FF2.7
08366:  MOVLW  03
08368:  MOVLB  A
0836A:  MOVWF  x18
0836C:  MOVLB  0
0836E:  CALL   1006
08372:  BTFSC  1B.7
08374:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
08376:  MOVLW  08
08378:  MOVLB  9
0837A:  MOVWF  x8D
0837C:  MOVLW  EC
0837E:  MOVWF  x8C
08380:  MOVLB  0
08382:  GOTO   790C
08386:  MOVFF  02,8E9
0838A:  MOVFF  01,8E8
....................       result = f_write(&fdst, mesg, btw, &bw); 
0838E:  MOVLW  08
08390:  MOVLB  9
08392:  MOVWF  x8D
08394:  MOVLW  CB
08396:  MOVWF  x8C
08398:  MOVLW  08
0839A:  MOVWF  x8F
0839C:  MOVLW  EC
0839E:  MOVWF  x8E
083A0:  MOVFF  8E9,991
083A4:  MOVFF  8E8,990
083A8:  MOVLW  08
083AA:  MOVWF  x93
083AC:  MOVLW  EA
083AE:  MOVWF  x92
083B0:  MOVLB  0
083B2:  GOTO   794A
083B6:  MOVFF  01,8E7
....................       if (result) 
083BA:  MOVLB  8
083BC:  MOVF   xE7,F
083BE:  BZ    83E2
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
083C0:  MOVLW  72
083C2:  MOVWF  FF6
083C4:  MOVLW  0D
083C6:  MOVWF  FF7
083C8:  MOVLW  00
083CA:  MOVWF  FF8
083CC:  CLRF   1B
083CE:  BTFSC  FF2.7
083D0:  BSF    1B.7
083D2:  BCF    FF2.7
083D4:  MOVLB  0
083D6:  CALL   0E30
083DA:  BTFSC  1B.7
083DC:  BSF    FF2.7
....................       } 
083DE:  BRA    840A
083E0:  MOVLB  8
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
083E2:  MOVF   20,F
083E4:  BNZ   83EC
083E6:  MOVF   1F,W
083E8:  SUBLW  04
083EA:  BC    840C
083EC:  MOVLW  86
083EE:  MOVWF  FF6
083F0:  MOVLW  0D
083F2:  MOVWF  FF7
083F4:  MOVLW  00
083F6:  MOVWF  FF8
083F8:  CLRF   1B
083FA:  BTFSC  FF2.7
083FC:  BSF    1B.7
083FE:  BCF    FF2.7
08400:  MOVLB  0
08402:  CALL   0E30
08406:  BTFSC  1B.7
08408:  BSF    FF2.7
0840A:  MOVLB  8
....................       } 
....................  
....................       f_close(&fdst); 
0840C:  MOVLW  08
0840E:  MOVLB  9
08410:  MOVWF  x8D
08412:  MOVLW  CB
08414:  MOVWF  x8C
08416:  MOVLB  0
08418:  RCALL  81F6
....................    } 
....................  
....................    return (result); 
0841A:  MOVLB  8
0841C:  MOVFF  8E7,01
08420:  MOVLB  0
08422:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
175E0:  CLRF   1B
175E2:  BTFSC  FF2.7
175E4:  BSF    1B.7
175E6:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
175E8:  MOVFF  863,A1A
175EC:  MOVLW  0A
175EE:  MOVLB  A
175F0:  MOVWF  x1B
175F2:  MOVLB  0
175F4:  CALL   0F5C
175F8:  BTFSC  1B.7
175FA:  BSF    FF2.7
175FC:  MOVFF  01,864
....................    nibl=data-(nibh*10); 
17600:  MOVLB  8
17602:  MOVF   x64,W
17604:  MULLW  0A
17606:  MOVF   FF3,W
17608:  SUBWF  x63,W
1760A:  MOVWF  x65
....................  
....................    return((nibh<<4)|nibl); 
1760C:  SWAPF  x64,W
1760E:  MOVWF  00
17610:  MOVLW  F0
17612:  ANDWF  00,F
17614:  MOVF   00,W
17616:  IORWF  x65,W
17618:  MOVWF  01
1761A:  MOVLB  0
1761C:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
03290:  MOVFF  8CA,8CB
....................    data=(i>>4)*10; 
03294:  MOVLB  8
03296:  SWAPF  xCB,W
03298:  MOVWF  00
0329A:  MOVLW  0F
0329C:  ANDWF  00,F
0329E:  MOVF   00,W
032A0:  MULLW  0A
032A2:  MOVFF  FF3,8CA
....................    data=data+(i<<4>>4); 
032A6:  SWAPF  xCB,W
032A8:  MOVWF  00
032AA:  MOVLW  F0
032AC:  ANDWF  00,F
032AE:  MOVF   00,W
032B0:  SWAPF  00,F
032B2:  MOVLW  0F
032B4:  ANDWF  00,F
032B6:  MOVF   00,W
032B8:  ADDWF  xCA,F
....................  
....................    return data; 
032BA:  MOVFF  8CA,01
032BE:  MOVLB  0
032C0:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03430:  MOVLB  8
03432:  CLRF   xA7
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
03434:  BCF    FC6.5
03436:  MOVLW  21
03438:  MOVWF  FC6
0343A:  MOVLW  40
0343C:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0343E:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
03440:  MOVF   FC9,W
03442:  MOVLW  0C
03444:  MOVWF  FC9
03446:  RRCF   FC7,W
03448:  BNC   3446
0344A:  MOVFF  FC9,8A7
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0344E:  MOVF   FC9,W
03450:  MOVFF  8A7,FC9
03454:  RRCF   FC7,W
03456:  BNC   3454
03458:  MOVFF  FC9,72C
....................    output_bit(RTC_CS, DISABLE); 
0345C:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
0345E:  MOVLB  7
03460:  BCF    x2C.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
03462:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
03464:  MOVF   FC9,W
03466:  MOVLW  8C
03468:  MOVWF  FC9
0346A:  RRCF   FC7,W
0346C:  BNC   346A
0346E:  MOVFF  FC9,8A7
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
03472:  MOVF   FC9,W
03474:  MOVFF  72C,FC9
03478:  RRCF   FC7,W
0347A:  BNC   3478
0347C:  MOVFF  FC9,8A7
....................    output_bit(RTC_CS, DISABLE); 
03480:  BSF    F91.0
03482:  MOVLB  0
03484:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0DF8A:  MOVLW  1A
0DF8C:  MOVLB  8
0DF8E:  MOVWF  x73
0DF90:  MOVLB  0
0DF92:  CALL   2948
0DF96:  MOVFF  01,4B
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0DF9A:  MOVF   4B,F
0DF9C:  BNZ   E00A
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0DF9E:  MOVLW  94
0DFA0:  MOVWF  FF6
0DFA2:  MOVLW  0D
0DFA4:  MOVWF  FF7
0DFA6:  MOVLW  00
0DFA8:  MOVWF  FF8
0DFAA:  CLRF   1B
0DFAC:  BTFSC  FF2.7
0DFAE:  BSF    1B.7
0DFB0:  BCF    FF2.7
0DFB2:  MOVLW  05
0DFB4:  MOVLB  A
0DFB6:  MOVWF  x18
0DFB8:  MOVLB  0
0DFBA:  CALL   1006
0DFBE:  BTFSC  1B.7
0DFC0:  BSF    FF2.7
0DFC2:  CLRF   1B
0DFC4:  BTFSC  FF2.7
0DFC6:  BSF    1B.7
0DFC8:  BCF    FF2.7
0DFCA:  MOVFF  726,A18
0DFCE:  MOVLW  01
0DFD0:  MOVLB  A
0DFD2:  MOVWF  x19
0DFD4:  MOVLB  0
0DFD6:  CALL   0F88
0DFDA:  BTFSC  1B.7
0DFDC:  BSF    FF2.7
0DFDE:  MOVLW  2F
0DFE0:  BTFSS  F9E.4
0DFE2:  BRA    DFE0
0DFE4:  MOVWF  FAD
0DFE6:  CLRF   1B
0DFE8:  BTFSC  FF2.7
0DFEA:  BSF    1B.7
0DFEC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0DFEE:  MOVFF  725,A18
0DFF2:  MOVLW  01
0DFF4:  MOVLB  A
0DFF6:  MOVWF  x19
0DFF8:  MOVLB  0
0DFFA:  CALL   0F88
0DFFE:  BTFSC  1B.7
0E000:  BSF    FF2.7
0E002:  MOVLW  2F
0E004:  BTFSS  F9E.4
0E006:  BRA    E004
0E008:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E00A:  DECFSZ 4B,W
0E00C:  BRA    E07A
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E00E:  MOVLW  A0
0E010:  MOVWF  FF6
0E012:  MOVLW  0D
0E014:  MOVWF  FF7
0E016:  MOVLW  00
0E018:  MOVWF  FF8
0E01A:  CLRF   1B
0E01C:  BTFSC  FF2.7
0E01E:  BSF    1B.7
0E020:  BCF    FF2.7
0E022:  MOVLW  05
0E024:  MOVLB  A
0E026:  MOVWF  x18
0E028:  MOVLB  0
0E02A:  CALL   1006
0E02E:  BTFSC  1B.7
0E030:  BSF    FF2.7
0E032:  CLRF   1B
0E034:  BTFSC  FF2.7
0E036:  BSF    1B.7
0E038:  BCF    FF2.7
0E03A:  MOVFF  725,A18
0E03E:  MOVLW  01
0E040:  MOVLB  A
0E042:  MOVWF  x19
0E044:  MOVLB  0
0E046:  CALL   0F88
0E04A:  BTFSC  1B.7
0E04C:  BSF    FF2.7
0E04E:  MOVLW  2F
0E050:  BTFSS  F9E.4
0E052:  BRA    E050
0E054:  MOVWF  FAD
0E056:  CLRF   1B
0E058:  BTFSC  FF2.7
0E05A:  BSF    1B.7
0E05C:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E05E:  MOVFF  726,A18
0E062:  MOVLW  01
0E064:  MOVLB  A
0E066:  MOVWF  x19
0E068:  MOVLB  0
0E06A:  CALL   0F88
0E06E:  BTFSC  1B.7
0E070:  BSF    FF2.7
0E072:  MOVLW  2F
0E074:  BTFSS  F9E.4
0E076:  BRA    E074
0E078:  MOVWF  FAD
0E07A:  CLRF   1B
0E07C:  BTFSC  FF2.7
0E07E:  BSF    1B.7
0E080:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E082:  MOVFF  727,A18
0E086:  MOVLW  01
0E088:  MOVLB  A
0E08A:  MOVWF  x19
0E08C:  MOVLB  0
0E08E:  CALL   0F88
0E092:  BTFSC  1B.7
0E094:  BSF    FF2.7
0E096:  MOVLW  20
0E098:  BTFSS  F9E.4
0E09A:  BRA    E098
0E09C:  MOVWF  FAD
0E09E:  CLRF   1B
0E0A0:  BTFSC  FF2.7
0E0A2:  BSF    1B.7
0E0A4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E0A6:  MOVFF  723,A18
0E0AA:  MOVLW  01
0E0AC:  MOVLB  A
0E0AE:  MOVWF  x19
0E0B0:  MOVLB  0
0E0B2:  CALL   0F88
0E0B6:  BTFSC  1B.7
0E0B8:  BSF    FF2.7
0E0BA:  MOVLW  3A
0E0BC:  BTFSS  F9E.4
0E0BE:  BRA    E0BC
0E0C0:  MOVWF  FAD
0E0C2:  CLRF   1B
0E0C4:  BTFSC  FF2.7
0E0C6:  BSF    1B.7
0E0C8:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E0CA:  MOVFF  722,A18
0E0CE:  MOVLW  01
0E0D0:  MOVLB  A
0E0D2:  MOVWF  x19
0E0D4:  MOVLB  0
0E0D6:  CALL   0F88
0E0DA:  BTFSC  1B.7
0E0DC:  BSF    FF2.7
0E0DE:  MOVLW  3A
0E0E0:  BTFSS  F9E.4
0E0E2:  BRA    E0E0
0E0E4:  MOVWF  FAD
0E0E6:  CLRF   1B
0E0E8:  BTFSC  FF2.7
0E0EA:  BSF    1B.7
0E0EC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E0EE:  MOVFF  721,A18
0E0F2:  MOVLW  01
0E0F4:  MOVLB  A
0E0F6:  MOVWF  x19
0E0F8:  MOVLB  0
0E0FA:  CALL   0F88
0E0FE:  BTFSC  1B.7
0E100:  BSF    FF2.7
0E102:  MOVLW  0A
0E104:  BTFSS  F9E.4
0E106:  BRA    E104
0E108:  MOVWF  FAD
0E10A:  MOVLW  0D
0E10C:  BTFSS  F9E.4
0E10E:  BRA    E10C
0E110:  MOVWF  FAD
0E112:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
032C2:  MOVLB  8
032C4:  CLRF   xC9
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
032C6:  BCF    FC6.5
032C8:  MOVLW  21
032CA:  MOVWF  FC6
032CC:  MOVLW  40
032CE:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
032D0:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
032D2:  MOVF   FC9,W
032D4:  CLRF   FC9
032D6:  RRCF   FC7,W
032D8:  BNC   32D6
032DA:  MOVFF  FC9,8C9
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
032DE:  MOVF   FC9,W
032E0:  MOVFF  8C9,FC9
032E4:  RRCF   FC7,W
032E6:  BNC   32E4
032E8:  MOVFF  FC9,728
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
032EC:  MOVF   FC9,W
032EE:  MOVFF  8C9,FC9
032F2:  RRCF   FC7,W
032F4:  BNC   32F2
032F6:  MOVFF  FC9,721
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
032FA:  MOVF   FC9,W
032FC:  MOVFF  8C9,FC9
03300:  RRCF   FC7,W
03302:  BNC   3300
03304:  MOVFF  FC9,722
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
03308:  MOVF   FC9,W
0330A:  MOVFF  8C9,FC9
0330E:  RRCF   FC7,W
03310:  BNC   330E
03312:  MOVFF  FC9,723
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
03316:  MOVF   FC9,W
03318:  MOVFF  8C9,FC9
0331C:  RRCF   FC7,W
0331E:  BNC   331C
03320:  MOVFF  FC9,724
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
03324:  MOVF   FC9,W
03326:  MOVFF  8C9,FC9
0332A:  RRCF   FC7,W
0332C:  BNC   332A
0332E:  MOVFF  FC9,725
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
03332:  MOVF   FC9,W
03334:  MOVFF  8C9,FC9
03338:  RRCF   FC7,W
0333A:  BNC   3338
0333C:  MOVFF  FC9,726
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
03340:  MOVF   FC9,W
03342:  MOVFF  8C9,FC9
03346:  RRCF   FC7,W
03348:  BNC   3346
0334A:  MOVFF  FC9,727
....................    output_bit(RTC_CS, DISABLE); 
0334E:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
03350:  MOVFF  721,8CA
03354:  MOVLB  0
03356:  RCALL  3290
03358:  MOVFF  01,721
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
0335C:  MOVFF  722,8CA
03360:  RCALL  3290
03362:  MOVFF  01,722
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
03366:  MOVFF  723,8CA
0336A:  RCALL  3290
0336C:  MOVFF  01,723
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
03370:  MOVFF  725,8CA
03374:  RCALL  3290
03376:  MOVFF  01,725
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
0337A:  MOVFF  726,8CA
0337E:  RCALL  3290
03380:  MOVFF  01,726
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
03384:  MOVFF  727,8CA
03388:  RCALL  3290
0338A:  MOVFF  01,727
0338E:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DCC:  MOVLB  A
00DCE:  CLRF   x0F
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DD0:  BCF    FC6.5
00DD2:  MOVLW  21
00DD4:  MOVWF  FC6
00DD6:  MOVLW  40
00DD8:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00DDA:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00DDC:  MOVF   FC9,W
00DDE:  MOVLW  0F
00DE0:  MOVWF  FC9
00DE2:  RRCF   FC7,W
00DE4:  BNC   0DE2
00DE6:  MOVFF  FC9,A0F
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00DEA:  MOVF   FC9,W
00DEC:  MOVFF  A0F,FC9
00DF0:  RRCF   FC7,W
00DF2:  BNC   0DF0
00DF4:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
00DF8:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00DFA:  BCF    49.2
00DFC:  MOVLB  0
00DFE:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E1EA:  MOVF   4B,F
0E1EC:  BNZ   E25A
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E1EE:  MOVLW  AC
0E1F0:  MOVWF  FF6
0E1F2:  MOVLW  0D
0E1F4:  MOVWF  FF7
0E1F6:  MOVLW  00
0E1F8:  MOVWF  FF8
0E1FA:  CLRF   1B
0E1FC:  BTFSC  FF2.7
0E1FE:  BSF    1B.7
0E200:  BCF    FF2.7
0E202:  MOVLW  05
0E204:  MOVLB  A
0E206:  MOVWF  x18
0E208:  MOVLB  0
0E20A:  CALL   1006
0E20E:  BTFSC  1B.7
0E210:  BSF    FF2.7
0E212:  CLRF   1B
0E214:  BTFSC  FF2.7
0E216:  BSF    1B.7
0E218:  BCF    FF2.7
0E21A:  MOVFF  72A,A18
0E21E:  MOVLW  01
0E220:  MOVLB  A
0E222:  MOVWF  x19
0E224:  MOVLB  0
0E226:  CALL   0F88
0E22A:  BTFSC  1B.7
0E22C:  BSF    FF2.7
0E22E:  MOVLW  2F
0E230:  BTFSS  F9E.4
0E232:  BRA    E230
0E234:  MOVWF  FAD
0E236:  CLRF   1B
0E238:  BTFSC  FF2.7
0E23A:  BSF    1B.7
0E23C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E23E:  MOVFF  72B,A18
0E242:  MOVLW  01
0E244:  MOVLB  A
0E246:  MOVWF  x19
0E248:  MOVLB  0
0E24A:  CALL   0F88
0E24E:  BTFSC  1B.7
0E250:  BSF    FF2.7
0E252:  MOVLW  2F
0E254:  BTFSS  F9E.4
0E256:  BRA    E254
0E258:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E25A:  DECFSZ 4B,W
0E25C:  BRA    E2CA
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E25E:  MOVLW  B8
0E260:  MOVWF  FF6
0E262:  MOVLW  0D
0E264:  MOVWF  FF7
0E266:  MOVLW  00
0E268:  MOVWF  FF8
0E26A:  CLRF   1B
0E26C:  BTFSC  FF2.7
0E26E:  BSF    1B.7
0E270:  BCF    FF2.7
0E272:  MOVLW  05
0E274:  MOVLB  A
0E276:  MOVWF  x18
0E278:  MOVLB  0
0E27A:  CALL   1006
0E27E:  BTFSC  1B.7
0E280:  BSF    FF2.7
0E282:  CLRF   1B
0E284:  BTFSC  FF2.7
0E286:  BSF    1B.7
0E288:  BCF    FF2.7
0E28A:  MOVFF  72B,A18
0E28E:  MOVLW  01
0E290:  MOVLB  A
0E292:  MOVWF  x19
0E294:  MOVLB  0
0E296:  CALL   0F88
0E29A:  BTFSC  1B.7
0E29C:  BSF    FF2.7
0E29E:  MOVLW  2F
0E2A0:  BTFSS  F9E.4
0E2A2:  BRA    E2A0
0E2A4:  MOVWF  FAD
0E2A6:  CLRF   1B
0E2A8:  BTFSC  FF2.7
0E2AA:  BSF    1B.7
0E2AC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E2AE:  MOVFF  72A,A18
0E2B2:  MOVLW  01
0E2B4:  MOVLB  A
0E2B6:  MOVWF  x19
0E2B8:  MOVLB  0
0E2BA:  CALL   0F88
0E2BE:  BTFSC  1B.7
0E2C0:  BSF    FF2.7
0E2C2:  MOVLW  2F
0E2C4:  BTFSS  F9E.4
0E2C6:  BRA    E2C4
0E2C8:  MOVWF  FAD
0E2CA:  CLRF   1B
0E2CC:  BTFSC  FF2.7
0E2CE:  BSF    1B.7
0E2D0:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E2D2:  MOVFF  729,A18
0E2D6:  MOVLW  01
0E2D8:  MOVLB  A
0E2DA:  MOVWF  x19
0E2DC:  MOVLB  0
0E2DE:  CALL   0F88
0E2E2:  BTFSC  1B.7
0E2E4:  BSF    FF2.7
0E2E6:  MOVLW  20
0E2E8:  BTFSS  F9E.4
0E2EA:  BRA    E2E8
0E2EC:  MOVWF  FAD
0E2EE:  CLRF   1B
0E2F0:  BTFSC  FF2.7
0E2F2:  BSF    1B.7
0E2F4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E2F6:  MOVFF  72C,A18
0E2FA:  MOVLW  01
0E2FC:  MOVLB  A
0E2FE:  MOVWF  x19
0E300:  MOVLB  0
0E302:  CALL   0F88
0E306:  BTFSC  1B.7
0E308:  BSF    FF2.7
0E30A:  MOVLW  3A
0E30C:  BTFSS  F9E.4
0E30E:  BRA    E30C
0E310:  MOVWF  FAD
0E312:  CLRF   1B
0E314:  BTFSC  FF2.7
0E316:  BSF    1B.7
0E318:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E31A:  MOVFF  72D,A18
0E31E:  MOVLW  01
0E320:  MOVLB  A
0E322:  MOVWF  x19
0E324:  MOVLB  0
0E326:  CALL   0F88
0E32A:  BTFSC  1B.7
0E32C:  BSF    FF2.7
0E32E:  MOVLW  3A
0E330:  BTFSS  F9E.4
0E332:  BRA    E330
0E334:  MOVWF  FAD
0E336:  CLRF   1B
0E338:  BTFSC  FF2.7
0E33A:  BSF    1B.7
0E33C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E33E:  MOVFF  72E,A18
0E342:  MOVLW  01
0E344:  MOVLB  A
0E346:  MOVWF  x19
0E348:  MOVLB  0
0E34A:  CALL   0F88
0E34E:  BTFSC  1B.7
0E350:  BSF    FF2.7
0E352:  MOVLW  0A
0E354:  BTFSS  F9E.4
0E356:  BRA    E354
0E358:  MOVWF  FAD
0E35A:  MOVLW  0D
0E35C:  BTFSS  F9E.4
0E35E:  BRA    E35C
0E360:  MOVWF  FAD
0E362:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E114:  MOVLB  8
0E116:  CLRF   x93
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E118:  BCF    FC6.5
0E11A:  MOVLW  21
0E11C:  MOVWF  FC6
0E11E:  MOVLW  40
0E120:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E122:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E124:  MOVF   FC9,W
0E126:  MOVLW  0A
0E128:  MOVWF  FC9
0E12A:  RRCF   FC7,W
0E12C:  BNC   E12A
0E12E:  MOVFF  FC9,893
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E132:  MOVF   FC9,W
0E134:  MOVFF  893,FC9
0E138:  RRCF   FC7,W
0E13A:  BNC   E138
0E13C:  MOVFF  FC9,72A
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E140:  MOVF   FC9,W
0E142:  MOVFF  893,FC9
0E146:  RRCF   FC7,W
0E148:  BNC   E146
0E14A:  MOVFF  FC9,72B
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E14E:  MOVF   FC9,W
0E150:  MOVFF  893,FC9
0E154:  RRCF   FC7,W
0E156:  BNC   E154
0E158:  MOVFF  FC9,72C
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E15C:  MOVF   FC9,W
0E15E:  MOVFF  893,FC9
0E162:  RRCF   FC7,W
0E164:  BNC   E162
0E166:  MOVFF  FC9,72D
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E16A:  MOVF   FC9,W
0E16C:  MOVFF  893,FC9
0E170:  RRCF   FC7,W
0E172:  BNC   E170
0E174:  MOVFF  FC9,72E
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E178:  MOVF   FC9,W
0E17A:  MOVFF  893,FC9
0E17E:  RRCF   FC7,W
0E180:  BNC   E17E
0E182:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
0E186:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E188:  MOVLW  1F
0E18A:  MOVLB  7
0E18C:  ANDWF  x2A,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E18E:  MOVFF  72A,8CA
0E192:  MOVLB  0
0E194:  CALL   3290
0E198:  MOVFF  01,72A
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E19C:  MOVLW  3F
0E19E:  MOVLB  7
0E1A0:  ANDWF  x2B,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E1A2:  MOVFF  72B,8CA
0E1A6:  MOVLB  0
0E1A8:  CALL   3290
0E1AC:  MOVFF  01,72B
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E1B0:  MOVLW  3F
0E1B2:  MOVLB  7
0E1B4:  ANDWF  x2C,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E1B6:  MOVFF  72C,8CA
0E1BA:  MOVLB  0
0E1BC:  CALL   3290
0E1C0:  MOVFF  01,72C
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E1C4:  MOVLB  7
0E1C6:  BCF    x2D.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E1C8:  MOVFF  72D,8CA
0E1CC:  MOVLB  0
0E1CE:  CALL   3290
0E1D2:  MOVFF  01,72D
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E1D6:  MOVLB  7
0E1D8:  BCF    x2E.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E1DA:  MOVFF  72E,8CA
0E1DE:  MOVLB  0
0E1E0:  CALL   3290
0E1E4:  MOVFF  01,72E
0E1E8:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
17226:  MOVLW  08
17228:  MOVWF  FEA
1722A:  MOVLW  65
1722C:  MOVWF  FE9
1722E:  CLRF   00
17230:  CLRF   02
17232:  MOVLW  0C
17234:  MOVWF  01
17236:  CALL   34A4
....................  
....................    time_error = 0; 
1723A:  MOVLB  8
1723C:  CLRF   x71
....................     
....................    fputc('[', COM_A); 
1723E:  MOVLW  5B
17240:  MOVLB  0
17242:  CALL   ADBE
....................     
....................    for (n=0; n<12; ++n){ 
17246:  MOVLB  8
17248:  CLRF   x64
1724A:  MOVF   x64,W
1724C:  SUBLW  0B
1724E:  BNC   17294
....................       c = fgetc(COM_A); 
17250:  MOVLB  0
17252:  CALL   0E1A
17256:  MOVFF  01,863
....................       if (com_echo == TRUE) 
1725A:  DECFSZ 48,W
1725C:  BRA    17268
....................       { 
....................          fputc(c, COM_A); 
1725E:  MOVLB  8
17260:  MOVF   x63,W
17262:  MOVLB  0
17264:  CALL   ADBE
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
17268:  MOVLB  8
1726A:  MOVF   x63,W
1726C:  SUBLW  2F
1726E:  BC    1728A
17270:  MOVF   x63,W
17272:  SUBLW  39
17274:  BNC   1728A
17276:  CLRF   03
17278:  MOVF   x64,W
1727A:  ADDLW  65
1727C:  MOVWF  FE9
1727E:  MOVLW  08
17280:  ADDWFC 03,W
17282:  MOVWF  FEA
17284:  MOVFF  863,FEF
17288:  BRA    17290
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
1728A:  MOVLW  01
1728C:  MOVWF  x71
....................          break; 
1728E:  BRA    17294
....................       } 
17290:  INCF   x64,F
17292:  BRA    1724A
....................    } 
....................     
....................    if (time_error == 0){ 
17294:  MOVF   x71,F
17296:  BTFSS  FD8.2
17298:  BRA    175D0
....................     
....................       fputc(']', COM_A); 
1729A:  MOVLW  5D
1729C:  MOVLB  0
1729E:  CALL   ADBE
....................        
....................       for (n=0; n<12; ++n){ 
172A2:  MOVLB  8
172A4:  CLRF   x64
172A6:  MOVF   x64,W
172A8:  SUBLW  0B
172AA:  BNC   172DC
....................          t_entry[n] = (t_entry[n] - 48); 
172AC:  CLRF   03
172AE:  MOVF   x64,W
172B0:  ADDLW  65
172B2:  MOVWF  01
172B4:  MOVLW  08
172B6:  ADDWFC 03,F
172B8:  MOVFF  03,873
172BC:  CLRF   03
172BE:  MOVF   x64,W
172C0:  ADDLW  65
172C2:  MOVWF  FE9
172C4:  MOVLW  08
172C6:  ADDWFC 03,W
172C8:  MOVWF  FEA
172CA:  MOVLW  30
172CC:  SUBWF  FEF,W
172CE:  MOVFF  873,FEA
172D2:  MOVFF  01,FE9
172D6:  MOVWF  FEF
172D8:  INCF   x64,F
172DA:  BRA    172A6
....................       } 
....................        
....................       if (RTCfmt == 0) 
172DC:  MOVF   4B,F
172DE:  BNZ   1731C
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
172E0:  MOVF   x65,W
172E2:  MULLW  0A
172E4:  MOVF   FF3,W
172E6:  ADDWF  x66,W
172E8:  MOVLB  7
172EA:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
172EC:  MOVF   x34,F
172EE:  BZ    172F6
172F0:  MOVF   x34,W
172F2:  SUBLW  0C
172F4:  BC    172FE
172F6:  MOVLW  02
172F8:  MOVLB  8
172FA:  MOVWF  x71
172FC:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
172FE:  MOVLB  8
17300:  MOVF   x67,W
17302:  MULLW  0A
17304:  MOVF   FF3,W
17306:  ADDWF  x68,W
17308:  MOVLB  7
1730A:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
1730C:  MOVF   x33,F
1730E:  BZ    17316
17310:  MOVF   x33,W
17312:  SUBLW  1F
17314:  BC    1731E
17316:  MOVLW  02
17318:  MOVLB  8
1731A:  MOVWF  x71
1731C:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
1731E:  DECFSZ 4B,W
17320:  BRA    17362
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
17322:  MOVLB  8
17324:  MOVF   x65,W
17326:  MULLW  0A
17328:  MOVF   FF3,W
1732A:  ADDWF  x66,W
1732C:  MOVLB  7
1732E:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17330:  MOVF   x33,F
17332:  BZ    1733A
17334:  MOVF   x33,W
17336:  SUBLW  1F
17338:  BC    17342
1733A:  MOVLW  02
1733C:  MOVLB  8
1733E:  MOVWF  x71
17340:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
17342:  MOVLB  8
17344:  MOVF   x67,W
17346:  MULLW  0A
17348:  MOVF   FF3,W
1734A:  ADDWF  x68,W
1734C:  MOVLB  7
1734E:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17350:  MOVF   x34,F
17352:  BZ    1735A
17354:  MOVF   x34,W
17356:  SUBLW  0C
17358:  BC    17362
1735A:  MOVLW  02
1735C:  MOVLB  8
1735E:  MOVWF  x71
17360:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
17362:  MOVLB  8
17364:  MOVF   x69,W
17366:  MULLW  0A
17368:  MOVF   FF3,W
1736A:  ADDWF  x6A,W
1736C:  MOVLB  7
1736E:  MOVWF  x35
....................       if (RTC_Yr_Data > 99) time_error = 2;  
17370:  MOVF   x35,W
17372:  SUBLW  63
17374:  BC    1737E
17376:  MOVLW  02
17378:  MOVLB  8
1737A:  MOVWF  x71
1737C:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
1737E:  MOVLB  8
17380:  MOVF   x6B,W
17382:  MULLW  0A
17384:  MOVF   FF3,W
17386:  ADDWF  x6C,W
17388:  MOVLB  7
1738A:  MOVWF  x32
....................       if (RTC_Hr_Data > 24) time_error = 2;  
1738C:  MOVF   x32,W
1738E:  SUBLW  18
17390:  BC    1739A
17392:  MOVLW  02
17394:  MOVLB  8
17396:  MOVWF  x71
17398:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
1739A:  MOVLB  8
1739C:  MOVF   x6D,W
1739E:  MULLW  0A
173A0:  MOVF   FF3,W
173A2:  ADDWF  x6E,W
173A4:  MOVLB  7
173A6:  MOVWF  x31
....................       if (RTC_Min_Data > 60) time_error = 2;  
173A8:  MOVF   x31,W
173AA:  SUBLW  3C
173AC:  BC    173B6
173AE:  MOVLW  02
173B0:  MOVLB  8
173B2:  MOVWF  x71
173B4:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
173B6:  MOVLB  8
173B8:  MOVF   x6F,W
173BA:  MULLW  0A
173BC:  MOVF   FF3,W
173BE:  ADDWF  x70,W
173C0:  MOVLB  7
173C2:  MOVWF  x30
....................       if (RTC_Sec_Data > 60) time_error = 2; 
173C4:  MOVF   x30,W
173C6:  SUBLW  3C
173C8:  BC    173D2
173CA:  MOVLW  02
173CC:  MOVLB  8
173CE:  MOVWF  x71
173D0:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
173D2:  MOVF   4B,F
173D4:  BTFSS  FD8.2
173D6:  BRA    174CA
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
173D8:  MOVLW  0A
173DA:  BTFSS  F9E.4
173DC:  BRA    173DA
173DE:  MOVWF  FAD
173E0:  MOVLW  0D
173E2:  BTFSS  F9E.4
173E4:  BRA    173E2
173E6:  MOVWF  FAD
173E8:  CLRF   1B
173EA:  BTFSC  FF2.7
173EC:  BSF    1B.7
173EE:  BCF    FF2.7
173F0:  MOVFF  734,A18
173F4:  MOVLW  01
173F6:  MOVLB  A
173F8:  MOVWF  x19
173FA:  MOVLB  0
173FC:  CALL   0F88
17400:  BTFSC  1B.7
17402:  BSF    FF2.7
17404:  MOVLW  2F
17406:  BTFSS  F9E.4
17408:  BRA    17406
1740A:  MOVWF  FAD
1740C:  CLRF   1B
1740E:  BTFSC  FF2.7
17410:  BSF    1B.7
17412:  BCF    FF2.7
17414:  MOVFF  733,A18
17418:  MOVLW  01
1741A:  MOVLB  A
1741C:  MOVWF  x19
1741E:  MOVLB  0
17420:  CALL   0F88
17424:  BTFSC  1B.7
17426:  BSF    FF2.7
17428:  MOVLW  2F
1742A:  BTFSS  F9E.4
1742C:  BRA    1742A
1742E:  MOVWF  FAD
17430:  CLRF   1B
17432:  BTFSC  FF2.7
17434:  BSF    1B.7
17436:  BCF    FF2.7
17438:  MOVFF  735,A18
1743C:  MOVLW  01
1743E:  MOVLB  A
17440:  MOVWF  x19
17442:  MOVLB  0
17444:  CALL   0F88
17448:  BTFSC  1B.7
1744A:  BSF    FF2.7
1744C:  MOVLW  20
1744E:  BTFSS  F9E.4
17450:  BRA    1744E
17452:  MOVWF  FAD
17454:  CLRF   1B
17456:  BTFSC  FF2.7
17458:  BSF    1B.7
1745A:  BCF    FF2.7
1745C:  MOVFF  732,A18
17460:  MOVLW  01
17462:  MOVLB  A
17464:  MOVWF  x19
17466:  MOVLB  0
17468:  CALL   0F88
1746C:  BTFSC  1B.7
1746E:  BSF    FF2.7
17470:  MOVLW  3A
17472:  BTFSS  F9E.4
17474:  BRA    17472
17476:  MOVWF  FAD
17478:  CLRF   1B
1747A:  BTFSC  FF2.7
1747C:  BSF    1B.7
1747E:  BCF    FF2.7
17480:  MOVFF  731,A18
17484:  MOVLW  01
17486:  MOVLB  A
17488:  MOVWF  x19
1748A:  MOVLB  0
1748C:  CALL   0F88
17490:  BTFSC  1B.7
17492:  BSF    FF2.7
17494:  MOVLW  3A
17496:  BTFSS  F9E.4
17498:  BRA    17496
1749A:  MOVWF  FAD
1749C:  CLRF   1B
1749E:  BTFSC  FF2.7
174A0:  BSF    1B.7
174A2:  BCF    FF2.7
174A4:  MOVFF  730,A18
174A8:  MOVLW  01
174AA:  MOVLB  A
174AC:  MOVWF  x19
174AE:  MOVLB  0
174B0:  CALL   0F88
174B4:  BTFSC  1B.7
174B6:  BSF    FF2.7
174B8:  MOVLW  0A
174BA:  BTFSS  F9E.4
174BC:  BRA    174BA
174BE:  MOVWF  FAD
174C0:  MOVLW  0D
174C2:  BTFSS  F9E.4
174C4:  BRA    174C2
174C6:  MOVWF  FAD
174C8:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
174CA:  DECFSZ 4B,W
174CC:  BRA    175C0
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
174CE:  MOVLW  0A
174D0:  BTFSS  F9E.4
174D2:  BRA    174D0
174D4:  MOVWF  FAD
174D6:  MOVLW  0D
174D8:  BTFSS  F9E.4
174DA:  BRA    174D8
174DC:  MOVWF  FAD
174DE:  CLRF   1B
174E0:  BTFSC  FF2.7
174E2:  BSF    1B.7
174E4:  BCF    FF2.7
174E6:  MOVFF  733,A18
174EA:  MOVLW  01
174EC:  MOVLB  A
174EE:  MOVWF  x19
174F0:  MOVLB  0
174F2:  CALL   0F88
174F6:  BTFSC  1B.7
174F8:  BSF    FF2.7
174FA:  MOVLW  2F
174FC:  BTFSS  F9E.4
174FE:  BRA    174FC
17500:  MOVWF  FAD
17502:  CLRF   1B
17504:  BTFSC  FF2.7
17506:  BSF    1B.7
17508:  BCF    FF2.7
1750A:  MOVFF  734,A18
1750E:  MOVLW  01
17510:  MOVLB  A
17512:  MOVWF  x19
17514:  MOVLB  0
17516:  CALL   0F88
1751A:  BTFSC  1B.7
1751C:  BSF    FF2.7
1751E:  MOVLW  2F
17520:  BTFSS  F9E.4
17522:  BRA    17520
17524:  MOVWF  FAD
17526:  CLRF   1B
17528:  BTFSC  FF2.7
1752A:  BSF    1B.7
1752C:  BCF    FF2.7
1752E:  MOVFF  735,A18
17532:  MOVLW  01
17534:  MOVLB  A
17536:  MOVWF  x19
17538:  MOVLB  0
1753A:  CALL   0F88
1753E:  BTFSC  1B.7
17540:  BSF    FF2.7
17542:  MOVLW  20
17544:  BTFSS  F9E.4
17546:  BRA    17544
17548:  MOVWF  FAD
1754A:  CLRF   1B
1754C:  BTFSC  FF2.7
1754E:  BSF    1B.7
17550:  BCF    FF2.7
17552:  MOVFF  732,A18
17556:  MOVLW  01
17558:  MOVLB  A
1755A:  MOVWF  x19
1755C:  MOVLB  0
1755E:  CALL   0F88
17562:  BTFSC  1B.7
17564:  BSF    FF2.7
17566:  MOVLW  3A
17568:  BTFSS  F9E.4
1756A:  BRA    17568
1756C:  MOVWF  FAD
1756E:  CLRF   1B
17570:  BTFSC  FF2.7
17572:  BSF    1B.7
17574:  BCF    FF2.7
17576:  MOVFF  731,A18
1757A:  MOVLW  01
1757C:  MOVLB  A
1757E:  MOVWF  x19
17580:  MOVLB  0
17582:  CALL   0F88
17586:  BTFSC  1B.7
17588:  BSF    FF2.7
1758A:  MOVLW  3A
1758C:  BTFSS  F9E.4
1758E:  BRA    1758C
17590:  MOVWF  FAD
17592:  CLRF   1B
17594:  BTFSC  FF2.7
17596:  BSF    1B.7
17598:  BCF    FF2.7
1759A:  MOVFF  730,A18
1759E:  MOVLW  01
175A0:  MOVLB  A
175A2:  MOVWF  x19
175A4:  MOVLB  0
175A6:  CALL   0F88
175AA:  BTFSC  1B.7
175AC:  BSF    FF2.7
175AE:  MOVLW  0A
175B0:  BTFSS  F9E.4
175B2:  BRA    175B0
175B4:  MOVWF  FAD
175B6:  MOVLW  0D
175B8:  BTFSS  F9E.4
175BA:  BRA    175B8
175BC:  MOVWF  FAD
175BE:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
175C0:  MOVLB  8
175C2:  MOVF   x71,W
175C4:  SUBLW  02
175C6:  BNZ   175CE
175C8:  MOVLB  0
175CA:  BRA    17206
175CC:  MOVLB  8
....................  
....................    } 
175CE:  BRA    175D8
....................    else cmd_arg(); 
175D0:  MOVLB  0
175D2:  CALL   AF7A
175D6:  MOVLB  8
....................     
....................    return time_error; 
175D8:  MOVFF  871,01
175DC:  MOVLB  0
175DE:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
1761E:  RCALL  17226
17620:  MOVFF  01,861
....................     
....................    if (time_error ==0 ){ 
17624:  MOVLB  8
17626:  MOVF   x61,F
17628:  BTFSS  FD8.2
1762A:  BRA    17762
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1762C:  BCF    FC6.5
1762E:  MOVLW  21
17630:  MOVWF  FC6
17632:  MOVLW  40
17634:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
17636:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
17638:  MOVF   FC9,W
1763A:  MOVLW  86
1763C:  MOVWF  FC9
1763E:  RRCF   FC7,W
17640:  BNC   1763E
17642:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
17646:  MOVFF  734,863
1764A:  MOVLB  0
1764C:  RCALL  175E0
1764E:  MOVFF  01,863
17652:  MOVF   FC9,W
17654:  MOVFF  01,FC9
17658:  RRCF   FC7,W
1765A:  BNC   17658
1765C:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
17660:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17662:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
17664:  MOVF   FC9,W
17666:  MOVLW  85
17668:  MOVWF  FC9
1766A:  RRCF   FC7,W
1766C:  BNC   1766A
1766E:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
17672:  MOVFF  733,863
17676:  RCALL  175E0
17678:  MOVFF  01,863
1767C:  MOVF   FC9,W
1767E:  MOVFF  01,FC9
17682:  RRCF   FC7,W
17684:  BNC   17682
17686:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
1768A:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
1768C:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
1768E:  MOVF   FC9,W
17690:  MOVLW  87
17692:  MOVWF  FC9
17694:  RRCF   FC7,W
17696:  BNC   17694
17698:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
1769C:  MOVFF  735,863
176A0:  RCALL  175E0
176A2:  MOVFF  01,863
176A6:  MOVF   FC9,W
176A8:  MOVFF  01,FC9
176AC:  RRCF   FC7,W
176AE:  BNC   176AC
176B0:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
176B4:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
176B6:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
176B8:  MOVF   FC9,W
176BA:  MOVLW  83
176BC:  MOVWF  FC9
176BE:  RRCF   FC7,W
176C0:  BNC   176BE
176C2:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
176C6:  MOVFF  732,863
176CA:  RCALL  175E0
176CC:  MOVFF  01,863
176D0:  MOVF   FC9,W
176D2:  MOVFF  01,FC9
176D6:  RRCF   FC7,W
176D8:  BNC   176D6
176DA:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
176DE:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
176E0:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
176E2:  MOVF   FC9,W
176E4:  MOVLW  82
176E6:  MOVWF  FC9
176E8:  RRCF   FC7,W
176EA:  BNC   176E8
176EC:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
176F0:  MOVFF  731,863
176F4:  RCALL  175E0
176F6:  MOVFF  01,863
176FA:  MOVF   FC9,W
176FC:  MOVFF  01,FC9
17700:  RRCF   FC7,W
17702:  BNC   17700
17704:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
17708:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
1770A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
1770C:  MOVF   FC9,W
1770E:  MOVLW  81
17710:  MOVWF  FC9
17712:  RRCF   FC7,W
17714:  BNC   17712
17716:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
1771A:  MOVFF  730,863
1771E:  RCALL  175E0
17720:  MOVFF  01,863
17724:  MOVF   FC9,W
17726:  MOVFF  01,FC9
1772A:  RRCF   FC7,W
1772C:  BNC   1772A
1772E:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
17732:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17734:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
17736:  MOVF   FC9,W
17738:  MOVLW  80
1773A:  MOVWF  FC9
1773C:  RRCF   FC7,W
1773E:  BNC   1773C
17740:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
17744:  MOVLB  8
17746:  CLRF   x63
17748:  MOVLB  0
1774A:  RCALL  175E0
1774C:  MOVFF  01,863
17750:  MOVF   FC9,W
17752:  MOVFF  01,FC9
17756:  RRCF   FC7,W
17758:  BNC   17756
1775A:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
1775E:  BSF    F91.0
17760:  MOVLB  8
....................    } 
17762:  MOVLB  0
17764:  GOTO   177F0 (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
182EC:  CALL   E114
....................     
....................    time_error = get_time(); 
182F0:  CALL   17226
182F4:  MOVFF  01,861
....................     
....................    if (time_error == 0 ){ 
182F8:  MOVLB  8
182FA:  MOVF   x61,F
182FC:  BTFSS  FD8.2
182FE:  BRA    18434
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
18300:  MOVFF  735,729
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
18304:  MOVLW  04
18306:  MOVWF  x65
18308:  MOVFF  729,866
1830C:  MOVLB  0
1830E:  CALL   3390
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
18312:  MOVFF  734,863
18316:  CALL   175E0
1831A:  MOVFF  01,734
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
1831E:  MOVLB  7
18320:  BSF    x34.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
18322:  BCF    FC6.5
18324:  MOVLW  21
18326:  MOVWF  FC6
18328:  MOVLW  40
1832A:  MOVWF  FC7
....................       delay_us(10); 
1832C:  MOVLW  35
1832E:  MOVWF  00
18330:  DECFSZ 00,F
18332:  BRA    18330
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
18334:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
18336:  MOVF   FC9,W
18338:  MOVLW  8E
1833A:  MOVWF  FC9
1833C:  RRCF   FC7,W
1833E:  BNC   1833C
18340:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
18344:  MOVFF  730,863
18348:  MOVLB  0
1834A:  CALL   175E0
1834E:  MOVFF  01,863
18352:  MOVF   FC9,W
18354:  MOVFF  01,FC9
18358:  RRCF   FC7,W
1835A:  BNC   18358
1835C:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
18360:  BSF    F91.0
....................       delay_us(1);            // Delays added 1.020A 
18362:  MOVLW  05
18364:  MOVWF  00
18366:  DECFSZ 00,F
18368:  BRA    18366
....................        
....................       output_bit(RTC_CS, ENABLE); 
1836A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
1836C:  MOVF   FC9,W
1836E:  MOVLW  8D
18370:  MOVWF  FC9
18372:  RRCF   FC7,W
18374:  BNC   18372
18376:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
1837A:  MOVFF  731,863
1837E:  CALL   175E0
18382:  MOVFF  01,863
18386:  MOVF   FC9,W
18388:  MOVFF  01,FC9
1838C:  RRCF   FC7,W
1838E:  BNC   1838C
18390:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
18394:  BSF    F91.0
....................       delay_us(1); 
18396:  MOVLW  05
18398:  MOVWF  00
1839A:  DECFSZ 00,F
1839C:  BRA    1839A
....................        
....................       output_bit(RTC_CS, ENABLE); 
1839E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
183A0:  MOVF   FC9,W
183A2:  MOVLW  8C
183A4:  MOVWF  FC9
183A6:  RRCF   FC7,W
183A8:  BNC   183A6
183AA:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
183AE:  MOVFF  732,863
183B2:  CALL   175E0
183B6:  MOVFF  01,863
183BA:  MOVF   FC9,W
183BC:  MOVFF  01,FC9
183C0:  RRCF   FC7,W
183C2:  BNC   183C0
183C4:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
183C8:  BSF    F91.0
....................       delay_us(1);    
183CA:  MOVLW  05
183CC:  MOVWF  00
183CE:  DECFSZ 00,F
183D0:  BRA    183CE
....................        
....................       output_bit(RTC_CS, ENABLE); 
183D2:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
183D4:  MOVF   FC9,W
183D6:  MOVLW  8B
183D8:  MOVWF  FC9
183DA:  RRCF   FC7,W
183DC:  BNC   183DA
183DE:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
183E2:  MOVFF  733,863
183E6:  CALL   175E0
183EA:  MOVFF  01,863
183EE:  MOVF   FC9,W
183F0:  MOVFF  01,FC9
183F4:  RRCF   FC7,W
183F6:  BNC   183F4
183F8:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE);  
183FC:  BSF    F91.0
....................       delay_us(1); 
183FE:  MOVLW  05
18400:  MOVWF  00
18402:  DECFSZ 00,F
18404:  BRA    18402
....................        
....................       output_bit(RTC_CS, ENABLE); 
18406:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8A);        // address - Month 
18408:  MOVF   FC9,W
1840A:  MOVLW  8A
1840C:  MOVWF  FC9
1840E:  RRCF   FC7,W
18410:  BNC   1840E
18412:  MOVFF  FC9,862
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
18416:  MOVF   FC9,W
18418:  MOVFF  734,FC9
1841C:  RRCF   FC7,W
1841E:  BNC   1841C
18420:  MOVFF  FC9,862
....................       output_bit(RTC_CS, DISABLE); 
18424:  BSF    F91.0
....................       delay_us(1); 
18426:  MOVLW  05
18428:  MOVWF  00
1842A:  DECFSZ 00,F
1842C:  BRA    1842A
....................     
....................    RTC_read_alarm(); 
1842E:  CALL   E114
18432:  MOVLB  8
....................    } 
18434:  MOVLB  0
18436:  GOTO   1844C (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
159DC:  BCF    FC6.5
159DE:  MOVLW  21
159E0:  MOVWF  FC6
159E2:  MOVLW  40
159E4:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
159E6:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
159E8:  MOVF   FC9,W
159EA:  MOVLW  8E
159EC:  MOVWF  FC9
159EE:  RRCF   FC7,W
159F0:  BNC   159EE
159F2:  MOVFF  FC9,863
....................    RTC_buffer = spi_read(0b00000000);  // data 
159F6:  MOVF   FC9,W
159F8:  CLRF   FC9
159FA:  RRCF   FC7,W
159FC:  BNC   159FA
159FE:  MOVFF  FC9,863
....................    output_bit(RTC_CS, DISABLE); 
15A02:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A04:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15A06:  MOVF   FC9,W
15A08:  MOVLW  8D
15A0A:  MOVWF  FC9
15A0C:  RRCF   FC7,W
15A0E:  BNC   15A0C
15A10:  MOVFF  FC9,863
....................    RTC_buffer = spi_read(0b10000000);  // data 
15A14:  MOVF   FC9,W
15A16:  MOVLW  80
15A18:  MOVWF  FC9
15A1A:  RRCF   FC7,W
15A1C:  BNC   15A1A
15A1E:  MOVFF  FC9,863
....................    output_bit(RTC_CS, DISABLE); 
15A22:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A24:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15A26:  MOVF   FC9,W
15A28:  MOVLW  8C
15A2A:  MOVWF  FC9
15A2C:  RRCF   FC7,W
15A2E:  BNC   15A2C
15A30:  MOVFF  FC9,863
....................    RTC_buffer = spi_read(0b10000000);  // data 
15A34:  MOVF   FC9,W
15A36:  MOVLW  80
15A38:  MOVWF  FC9
15A3A:  RRCF   FC7,W
15A3C:  BNC   15A3A
15A3E:  MOVFF  FC9,863
....................    output_bit(RTC_CS, DISABLE); 
15A42:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A44:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15A46:  MOVF   FC9,W
15A48:  MOVLW  8B
15A4A:  MOVWF  FC9
15A4C:  RRCF   FC7,W
15A4E:  BNC   15A4C
15A50:  MOVFF  FC9,863
....................    RTC_buffer = spi_read(0b11000000);  // data 
15A54:  MOVF   FC9,W
15A56:  MOVLW  C0
15A58:  MOVWF  FC9
15A5A:  RRCF   FC7,W
15A5C:  BNC   15A5A
15A5E:  MOVFF  FC9,863
....................    output_bit(RTC_CS, DISABLE);    
15A62:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A64:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15A66:  MOVF   FC9,W
15A68:  MOVLW  8A
15A6A:  MOVWF  FC9
15A6C:  RRCF   FC7,W
15A6E:  BNC   15A6C
15A70:  MOVFF  FC9,863
....................    RTC_buffer = spi_read(0b10000000);  // data 
15A74:  MOVF   FC9,W
15A76:  MOVLW  80
15A78:  MOVWF  FC9
15A7A:  RRCF   FC7,W
15A7C:  BNC   15A7A
15A7E:  MOVFF  FC9,863
....................    output_bit(RTC_CS, DISABLE); 
15A82:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15A84:  CALL   E114
15A88:  GOTO   16848 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
15266:  MOVLB  8
15268:  CLRF   x63
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1526A:  BCF    FC6.5
1526C:  MOVLW  21
1526E:  MOVWF  FC6
15270:  MOVLW  40
15272:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15274:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
15276:  MOVF   FC9,W
15278:  MOVLW  0A
1527A:  MOVWF  FC9
1527C:  RRCF   FC7,W
1527E:  BNC   1527C
15280:  MOVFF  FC9,863
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
15284:  MOVF   FC9,W
15286:  MOVFF  863,FC9
1528A:  RRCF   FC7,W
1528C:  BNC   1528A
1528E:  MOVFF  FC9,72A
....................    output_bit(RTC_CS, DISABLE); 
15292:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
15294:  MOVLB  7
15296:  BSF    x2A.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15298:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
1529A:  MOVF   FC9,W
1529C:  MOVLW  8A
1529E:  MOVWF  FC9
152A0:  RRCF   FC7,W
152A2:  BNC   152A0
152A4:  MOVFF  FC9,863
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
152A8:  MOVF   FC9,W
152AA:  MOVFF  72A,FC9
152AE:  RRCF   FC7,W
152B0:  BNC   152AE
152B2:  MOVFF  FC9,863
....................    output_bit(RTC_CS, DISABLE); 
152B6:  BSF    F91.0
152B8:  MOVLB  0
152BA:  GOTO   16772 (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
033C0:  MOVFF  721,73B
....................    rtc_last_min   = RTC_Min_Reg; 
033C4:  MOVFF  722,73A
....................    rtc_last_hour  = RTC_Hr_Reg; 
033C8:  MOVFF  723,739
....................    rtc_last_day   = RTC_DOM_Reg; 
033CC:  MOVFF  725,737
....................    rtc_last_month = RTC_Mon_Reg; 
033D0:  MOVFF  726,736
....................    rtc_last_year  = RTC_Yr_Reg; 
033D4:  MOVFF  727,738
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
033D8:  MOVLW  06
033DA:  MOVLB  8
033DC:  MOVWF  x65
033DE:  MOVFF  736,866
033E2:  MOVLB  0
033E4:  RCALL  3390
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
033E6:  MOVLW  08
033E8:  MOVLB  8
033EA:  MOVWF  x65
033EC:  MOVFF  737,866
033F0:  MOVLB  0
033F2:  RCALL  3390
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
033F4:  MOVLW  0A
033F6:  MOVLB  8
033F8:  MOVWF  x65
033FA:  MOVFF  738,866
033FE:  MOVLB  0
03400:  RCALL  3390
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
03402:  MOVLW  0C
03404:  MOVLB  8
03406:  MOVWF  x65
03408:  MOVFF  739,866
0340C:  MOVLB  0
0340E:  RCALL  3390
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
03410:  MOVLW  0E
03412:  MOVLB  8
03414:  MOVWF  x65
03416:  MOVFF  73A,866
0341A:  MOVLB  0
0341C:  RCALL  3390
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
0341E:  MOVLW  10
03420:  MOVLB  8
03422:  MOVWF  x65
03424:  MOVFF  73B,866
03428:  MOVLB  0
0342A:  RCALL  3390
0342C:  GOTO   1B162 (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
152BE:  MOVLB  8
152C0:  CLRF   x66
152C2:  CLRF   x65
152C4:  CLRF   x64
152C6:  CLRF   x63
152C8:  CLRF   x6A
152CA:  CLRF   x69
152CC:  CLRF   x68
152CE:  CLRF   x67
152D0:  CLRF   x6E
152D2:  CLRF   x6D
152D4:  CLRF   x6C
152D6:  CLRF   x6B
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
152D8:  CLRF   x7B
152DA:  CLRF   x7C
152DC:  MOVLW  1F
152DE:  MOVWF  x7D
152E0:  CLRF   x7E
152E2:  MOVLW  3B
152E4:  MOVWF  x7F
152E6:  CLRF   x80
152E8:  MOVLW  5A
152EA:  MOVWF  x81
152EC:  CLRF   x82
152EE:  MOVLW  78
152F0:  MOVWF  x83
152F2:  CLRF   x84
152F4:  MOVLW  97
152F6:  MOVWF  x85
152F8:  CLRF   x86
152FA:  MOVLW  B5
152FC:  MOVWF  x87
152FE:  CLRF   x88
15300:  MOVLW  D4
15302:  MOVWF  x89
15304:  CLRF   x8A
15306:  MOVLW  F3
15308:  MOVWF  x8B
1530A:  CLRF   x8C
1530C:  MOVLW  11
1530E:  MOVWF  x8D
15310:  MOVLW  01
15312:  MOVWF  x8E
15314:  MOVLW  30
15316:  MOVWF  x8F
15318:  MOVLW  01
1531A:  MOVWF  x90
1531C:  MOVLW  4E
1531E:  MOVWF  x91
15320:  MOVLW  01
15322:  MOVWF  x92
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
15324:  BCF    49.3
....................     
....................    RTC_read(); 
15326:  MOVLB  0
15328:  CALL   32C2
....................    RTC_read_alarm(); 
1532C:  CALL   E114
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
15330:  MOVLW  04
15332:  MOVLB  8
15334:  MOVWF  x93
15336:  MOVLB  0
15338:  CALL   29A2
1533C:  MOVFF  01,729
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
15340:  MOVLB  7
15342:  MOVF   x27,W
15344:  SUBWF  x29,W
15346:  BC    1534C
15348:  BSF    49.3
1534A:  BRA    15774
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
1534C:  MOVF   x29,W
1534E:  SUBWF  x27,W
15350:  BTFSS  FD8.2
15352:  BRA    15774
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
15354:  MOVLW  01
15356:  SUBWF  x26,W
15358:  MOVWF  00
1535A:  BCF    FD8.0
1535C:  RLCF   00,F
1535E:  MOVF   00,W
15360:  CLRF   03
15362:  ADDLW  7B
15364:  MOVWF  FE9
15366:  MOVLW  08
15368:  ADDWFC 03,W
1536A:  MOVWF  FEA
1536C:  MOVFF  FEC,03
15370:  MOVF   FED,F
15372:  MOVFF  FEF,8F3
15376:  MOVFF  03,8F4
1537A:  MOVLB  0
1537C:  CALL   C622
15380:  MOVFF  03,866
15384:  MOVFF  02,865
15388:  MOVFF  01,864
1538C:  MOVFF  00,863
....................          time_now = time_now + RTC_DOM_Reg; 
15390:  MOVLB  8
15392:  CLRF   xF4
15394:  MOVFF  725,8F3
15398:  MOVLB  0
1539A:  CALL   C622
1539E:  BCF    FD8.1
153A0:  MOVFF  866,8F6
153A4:  MOVFF  865,8F5
153A8:  MOVFF  864,8F4
153AC:  MOVFF  863,8F3
153B0:  MOVFF  03,8FA
153B4:  MOVFF  02,8F9
153B8:  MOVFF  01,8F8
153BC:  MOVFF  00,8F7
153C0:  CALL   C036
153C4:  MOVFF  03,866
153C8:  MOVFF  02,865
153CC:  MOVFF  01,864
153D0:  MOVFF  00,863
....................           
....................          hour = RTC_Hr_Reg; 
153D4:  MOVLB  8
153D6:  CLRF   xF4
153D8:  MOVFF  723,8F3
153DC:  MOVLB  0
153DE:  CALL   C622
153E2:  MOVFF  03,872
153E6:  MOVFF  02,871
153EA:  MOVFF  01,870
153EE:  MOVFF  00,86F
....................          minute = RTC_Min_Reg; 
153F2:  MOVLB  8
153F4:  CLRF   xF4
153F6:  MOVFF  722,8F3
153FA:  MOVLB  0
153FC:  CALL   C622
15400:  MOVFF  03,876
15404:  MOVFF  02,875
15408:  MOVFF  01,874
1540C:  MOVFF  00,873
....................          second = RTC_Sec_Reg; 
15410:  MOVLB  8
15412:  CLRF   xF4
15414:  MOVFF  721,8F3
15418:  MOVLB  0
1541A:  CALL   C622
1541E:  MOVFF  03,87A
15422:  MOVFF  02,879
15426:  MOVFF  01,878
1542A:  MOVFF  00,877
....................           
....................          fraction_of_day = (hour / 24); 
1542E:  MOVFF  872,8DA
15432:  MOVFF  871,8D9
15436:  MOVFF  870,8D8
1543A:  MOVFF  86F,8D7
1543E:  MOVLB  8
15440:  CLRF   xDE
15442:  CLRF   xDD
15444:  MOVLW  40
15446:  MOVWF  xDC
15448:  MOVLW  83
1544A:  MOVWF  xDB
1544C:  MOVLB  0
1544E:  CALL   C658
15452:  MOVFF  03,86E
15456:  MOVFF  02,86D
1545A:  MOVFF  01,86C
1545E:  MOVFF  00,86B
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15462:  MOVFF  876,8DA
15466:  MOVFF  875,8D9
1546A:  MOVFF  874,8D8
1546E:  MOVFF  873,8D7
15472:  MOVLB  8
15474:  CLRF   xDE
15476:  CLRF   xDD
15478:  MOVLW  34
1547A:  MOVWF  xDC
1547C:  MOVLW  89
1547E:  MOVWF  xDB
15480:  MOVLB  0
15482:  CALL   C658
15486:  BCF    FD8.1
15488:  MOVFF  86E,8F6
1548C:  MOVFF  86D,8F5
15490:  MOVFF  86C,8F4
15494:  MOVFF  86B,8F3
15498:  MOVFF  03,8FA
1549C:  MOVFF  02,8F9
154A0:  MOVFF  01,8F8
154A4:  MOVFF  00,8F7
154A8:  CALL   C036
154AC:  MOVFF  03,86E
154B0:  MOVFF  02,86D
154B4:  MOVFF  01,86C
154B8:  MOVFF  00,86B
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
154BC:  MOVFF  87A,8DA
154C0:  MOVFF  879,8D9
154C4:  MOVFF  878,8D8
154C8:  MOVFF  877,8D7
154CC:  MOVLB  8
154CE:  CLRF   xDE
154D0:  MOVLW  C0
154D2:  MOVWF  xDD
154D4:  MOVLW  28
154D6:  MOVWF  xDC
154D8:  MOVLW  8F
154DA:  MOVWF  xDB
154DC:  MOVLB  0
154DE:  CALL   C658
154E2:  BCF    FD8.1
154E4:  MOVFF  86E,8F6
154E8:  MOVFF  86D,8F5
154EC:  MOVFF  86C,8F4
154F0:  MOVFF  86B,8F3
154F4:  MOVFF  03,8FA
154F8:  MOVFF  02,8F9
154FC:  MOVFF  01,8F8
15500:  MOVFF  00,8F7
15504:  CALL   C036
15508:  MOVFF  03,86E
1550C:  MOVFF  02,86D
15510:  MOVFF  01,86C
15514:  MOVFF  00,86B
....................           
....................          time_now = time_now + fraction_of_day; 
15518:  BCF    FD8.1
1551A:  MOVFF  866,8F6
1551E:  MOVFF  865,8F5
15522:  MOVFF  864,8F4
15526:  MOVFF  863,8F3
1552A:  MOVFF  86E,8FA
1552E:  MOVFF  86D,8F9
15532:  MOVFF  86C,8F8
15536:  MOVFF  86B,8F7
1553A:  CALL   C036
1553E:  MOVFF  03,866
15542:  MOVFF  02,865
15546:  MOVFF  01,864
1554A:  MOVFF  00,863
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
1554E:  MOVLB  8
15550:  CLRF   xF4
15552:  MOVFF  72C,8F3
15556:  MOVLB  0
15558:  CALL   C622
1555C:  MOVFF  03,872
15560:  MOVFF  02,871
15564:  MOVFF  01,870
15568:  MOVFF  00,86F
....................          minute = RTC_Al_Min_Reg; 
1556C:  MOVLB  8
1556E:  CLRF   xF4
15570:  MOVFF  72D,8F3
15574:  MOVLB  0
15576:  CALL   C622
1557A:  MOVFF  03,876
1557E:  MOVFF  02,875
15582:  MOVFF  01,874
15586:  MOVFF  00,873
....................          second = RTC_Al_Sec_Reg; 
1558A:  MOVLB  8
1558C:  CLRF   xF4
1558E:  MOVFF  72E,8F3
15592:  MOVLB  0
15594:  CALL   C622
15598:  MOVFF  03,87A
1559C:  MOVFF  02,879
155A0:  MOVFF  01,878
155A4:  MOVFF  00,877
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
155A8:  MOVLW  01
155AA:  MOVLB  7
155AC:  SUBWF  x2A,W
155AE:  MOVWF  00
155B0:  BCF    FD8.0
155B2:  RLCF   00,F
155B4:  MOVF   00,W
155B6:  CLRF   03
155B8:  ADDLW  7B
155BA:  MOVWF  FE9
155BC:  MOVLW  08
155BE:  ADDWFC 03,W
155C0:  MOVWF  FEA
155C2:  MOVFF  FEC,03
155C6:  MOVF   FED,F
155C8:  MOVFF  FEF,8F3
155CC:  MOVFF  03,8F4
155D0:  MOVLB  0
155D2:  CALL   C622
155D6:  MOVFF  03,86A
155DA:  MOVFF  02,869
155DE:  MOVFF  01,868
155E2:  MOVFF  00,867
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
155E6:  MOVLB  8
155E8:  CLRF   xF4
155EA:  MOVFF  72B,8F3
155EE:  MOVLB  0
155F0:  CALL   C622
155F4:  BCF    FD8.1
155F6:  MOVFF  86A,8F6
155FA:  MOVFF  869,8F5
155FE:  MOVFF  868,8F4
15602:  MOVFF  867,8F3
15606:  MOVFF  03,8FA
1560A:  MOVFF  02,8F9
1560E:  MOVFF  01,8F8
15612:  MOVFF  00,8F7
15616:  CALL   C036
1561A:  MOVFF  03,86A
1561E:  MOVFF  02,869
15622:  MOVFF  01,868
15626:  MOVFF  00,867
....................           
....................          fraction_of_day = (hour / 24); 
1562A:  MOVFF  872,8DA
1562E:  MOVFF  871,8D9
15632:  MOVFF  870,8D8
15636:  MOVFF  86F,8D7
1563A:  MOVLB  8
1563C:  CLRF   xDE
1563E:  CLRF   xDD
15640:  MOVLW  40
15642:  MOVWF  xDC
15644:  MOVLW  83
15646:  MOVWF  xDB
15648:  MOVLB  0
1564A:  CALL   C658
1564E:  MOVFF  03,86E
15652:  MOVFF  02,86D
15656:  MOVFF  01,86C
1565A:  MOVFF  00,86B
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
1565E:  MOVFF  876,8DA
15662:  MOVFF  875,8D9
15666:  MOVFF  874,8D8
1566A:  MOVFF  873,8D7
1566E:  MOVLB  8
15670:  CLRF   xDE
15672:  CLRF   xDD
15674:  MOVLW  34
15676:  MOVWF  xDC
15678:  MOVLW  89
1567A:  MOVWF  xDB
1567C:  MOVLB  0
1567E:  CALL   C658
15682:  BCF    FD8.1
15684:  MOVFF  86E,8F6
15688:  MOVFF  86D,8F5
1568C:  MOVFF  86C,8F4
15690:  MOVFF  86B,8F3
15694:  MOVFF  03,8FA
15698:  MOVFF  02,8F9
1569C:  MOVFF  01,8F8
156A0:  MOVFF  00,8F7
156A4:  CALL   C036
156A8:  MOVFF  03,86E
156AC:  MOVFF  02,86D
156B0:  MOVFF  01,86C
156B4:  MOVFF  00,86B
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
156B8:  MOVFF  87A,8DA
156BC:  MOVFF  879,8D9
156C0:  MOVFF  878,8D8
156C4:  MOVFF  877,8D7
156C8:  MOVLB  8
156CA:  CLRF   xDE
156CC:  MOVLW  C0
156CE:  MOVWF  xDD
156D0:  MOVLW  28
156D2:  MOVWF  xDC
156D4:  MOVLW  8F
156D6:  MOVWF  xDB
156D8:  MOVLB  0
156DA:  CALL   C658
156DE:  BCF    FD8.1
156E0:  MOVFF  86E,8F6
156E4:  MOVFF  86D,8F5
156E8:  MOVFF  86C,8F4
156EC:  MOVFF  86B,8F3
156F0:  MOVFF  03,8FA
156F4:  MOVFF  02,8F9
156F8:  MOVFF  01,8F8
156FC:  MOVFF  00,8F7
15700:  CALL   C036
15704:  MOVFF  03,86E
15708:  MOVFF  02,86D
1570C:  MOVFF  01,86C
15710:  MOVFF  00,86B
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
15714:  BCF    FD8.1
15716:  MOVFF  86A,8F6
1571A:  MOVFF  869,8F5
1571E:  MOVFF  868,8F4
15722:  MOVFF  867,8F3
15726:  MOVFF  86E,8FA
1572A:  MOVFF  86D,8F9
1572E:  MOVFF  86C,8F8
15732:  MOVFF  86B,8F7
15736:  CALL   C036
1573A:  MOVFF  03,86A
1573E:  MOVFF  02,869
15742:  MOVFF  01,868
15746:  MOVFF  00,867
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
1574A:  MOVFF  86A,8F2
1574E:  MOVFF  869,8F1
15752:  MOVFF  868,8F0
15756:  MOVFF  867,8EF
1575A:  MOVFF  866,8F6
1575E:  MOVFF  865,8F5
15762:  MOVFF  864,8F4
15766:  MOVFF  863,8F3
1576A:  CALL   10460
1576E:  BNC   15772
15770:  BSF    49.3
15772:  MOVLB  7
....................       } 
....................    } 
15774:  MOVLB  0
15776:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
15778:  BTFSS  49.3
1577A:  BRA    15798
1577C:  MOVLW  C4
1577E:  MOVWF  FF6
15780:  MOVLW  0D
15782:  MOVWF  FF7
15784:  MOVLW  00
15786:  MOVWF  FF8
15788:  CLRF   1B
1578A:  BTFSC  FF2.7
1578C:  BSF    1B.7
1578E:  BCF    FF2.7
15790:  CALL   0E30
15794:  BTFSC  1B.7
15796:  BSF    FF2.7
15798:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F278:  BCF    F67.5
0F27A:  MOVLW  32
0F27C:  MOVWF  F67
0F27E:  MOVLW  40
0F280:  MOVWF  F68
....................     
....................    data = 0; 
0F282:  MOVLB  8
0F284:  CLRF   xB3
0F286:  CLRF   xB2
....................     
....................    DAC_MS_byte = 0; 
0F288:  CLRF   xB4
....................    DAC_LS_byte = 0; 
0F28A:  CLRF   xB5
....................     
....................    data = setting & 0b0000111100000000; 
0F28C:  CLRF   xB2
0F28E:  MOVF   xB1,W
0F290:  ANDLW  0F
0F292:  MOVWF  xB3
....................    data = data >> 8; 
0F294:  MOVFF  8B3,8B2
0F298:  CLRF   xB3
....................    DAC_MS_byte = data; 
0F29A:  MOVFF  8B2,8B4
....................     
....................    data = setting & 0b0000000011111111; 
0F29E:  MOVFF  8B0,8B2
0F2A2:  CLRF   xB3
....................    DAC_LS_byte = data; 
0F2A4:  MOVFF  8B2,8B5
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F2A8:  MOVLW  01
0F2AA:  SUBWF  xAF,W
0F2AC:  ADDLW  FC
0F2AE:  BC    F2DA
0F2B0:  ADDLW  04
0F2B2:  MOVLB  0
0F2B4:  GOTO   F2F8
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F2B8:  MOVLW  30
0F2BA:  MOVLB  8
0F2BC:  IORWF  xB4,F
....................          break; 
0F2BE:  BRA    F2DA
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F2C0:  MOVLW  70
0F2C2:  MOVLB  8
0F2C4:  IORWF  xB4,F
....................          break; 
0F2C6:  BRA    F2DA
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F2C8:  MOVLW  B0
0F2CA:  MOVLB  8
0F2CC:  IORWF  xB4,F
....................          break; 
0F2CE:  BRA    F2DA
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F2D0:  MOVLW  F0
0F2D2:  MOVLB  8
0F2D4:  IORWF  xB4,F
....................          break; 
0F2D6:  BRA    F2DA
0F2D8:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F2DA:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F2DC:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F2DE:  MOVF   F6A,W
0F2E0:  MOVFF  8B4,F6A
0F2E4:  RRCF   F68,W
0F2E6:  BNC   F2E4
....................    spi_write2(DAC_LS_byte); 
0F2E8:  MOVF   F6A,W
0F2EA:  MOVFF  8B5,F6A
0F2EE:  RRCF   F68,W
0F2F0:  BNC   F2EE
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F2F2:  BSF    F8C.3
0F2F4:  MOVLB  0
0F2F6:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F320:  MOVLB  8
0F322:  CLRF   xB4
0F324:  CLRF   xB5
0F326:  CLRF   xB6
0F328:  CLRF   xB7
0F32A:  CLRF   xB8
0F32C:  CLRF   xB9
0F32E:  CLRF   xBA
0F330:  CLRF   xBB
0F332:  CLRF   xBC
0F334:  CLRF   xBD
0F336:  CLRF   xBE
0F338:  CLRF   xBF
0F33A:  CLRF   xC0
0F33C:  CLRF   xC1
0F33E:  CLRF   xC2
0F340:  CLRF   xC3
0F342:  CLRF   xC4
0F344:  CLRF   xC5
0F346:  CLRF   xC6
0F348:  CLRF   xC7
0F34A:  CLRF   xC8
0F34C:  CLRF   xC9
0F34E:  CLRF   xCA
0F350:  CLRF   xCB
0F352:  CLRF   xCC
0F354:  CLRF   xCD
0F356:  CLRF   xCE
0F358:  CLRF   xCF
0F35A:  CLRF   xD0
0F35C:  CLRF   xD1
0F35E:  CLRF   xD2
0F360:  CLRF   xD3
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F362:  CLRF   xD4
0F364:  CLRF   xD5
0F366:  CLRF   xD6
0F368:  CLRF   xD7
0F36A:  CLRF   xD8
0F36C:  CLRF   xD9
0F36E:  CLRF   xDA
0F370:  CLRF   xDB
0F372:  CLRF   xDC
0F374:  CLRF   xDD
0F376:  CLRF   xDE
0F378:  CLRF   xDF
0F37A:  CLRF   xE0
0F37C:  CLRF   xE1
0F37E:  CLRF   xE2
0F380:  CLRF   xE3
0F382:  CLRF   xE4
0F384:  CLRF   xE5
0F386:  CLRF   xE6
0F388:  CLRF   xE7
0F38A:  CLRF   xE8
0F38C:  CLRF   xE9
0F38E:  CLRF   xEA
0F390:  CLRF   xEB
0F392:  CLRF   xEC
0F394:  CLRF   xED
0F396:  CLRF   xEE
0F398:  CLRF   xEF
0F39A:  CLRF   xF0
0F39C:  CLRF   xF1
0F39E:  CLRF   xF2
0F3A0:  CLRF   xF3
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F3A2:  CLRF   xB3
0F3A4:  MOVLW  01
0F3A6:  MOVWF  xB2
0F3A8:  MOVLW  01
0F3AA:  ADDWF  xAF,W
0F3AC:  MOVWF  01
0F3AE:  MOVLW  00
0F3B0:  ADDWFC xB0,W
0F3B2:  MOVWF  03
0F3B4:  MOVF   xB3,W
0F3B6:  SUBWF  03,W
0F3B8:  BNC   F49E
0F3BA:  BNZ   F3C2
0F3BC:  MOVF   01,W
0F3BE:  SUBWF  xB2,W
0F3C0:  BC    F49E
....................    { 
....................       for (n=1; n<5; ++n) 
0F3C2:  MOVLW  01
0F3C4:  MOVWF  xB1
0F3C6:  MOVF   xB1,W
0F3C8:  SUBLW  04
0F3CA:  BNC   F496
....................       { 
....................          set_adc_channel(n,VSS); 
0F3CC:  RLCF   xB1,W
0F3CE:  MOVWF  00
0F3D0:  RLCF   00,F
0F3D2:  MOVLW  FC
0F3D4:  ANDWF  00,F
0F3D6:  MOVF   FC2,W
0F3D8:  ANDLW  83
0F3DA:  IORWF  00,W
0F3DC:  MOVWF  FC2
0F3DE:  MOVLW  00
0F3E0:  MOVWF  01
0F3E2:  MOVF   FC1,W
0F3E4:  ANDLW  F8
0F3E6:  IORWF  01,W
0F3E8:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F3EA:  MOVF   xB1,W
0F3EC:  MULLW  04
0F3EE:  MOVF   FF3,W
0F3F0:  CLRF   03
0F3F2:  ADDLW  D4
0F3F4:  MOVWF  FE9
0F3F6:  MOVLW  08
0F3F8:  ADDWFC 03,W
0F3FA:  MOVWF  FEA
0F3FC:  BSF    FC2.1
0F3FE:  BTFSC  FC2.1
0F400:  BRA    F3FE
0F402:  MOVFF  FC3,FEF
0F406:  MOVFF  FC4,FEC
0F40A:  CLRF   FEC
0F40C:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F40E:  MOVF   xB1,W
0F410:  MULLW  04
0F412:  MOVF   FF3,W
0F414:  CLRF   03
0F416:  ADDLW  B4
0F418:  MOVWF  01
0F41A:  MOVLW  08
0F41C:  ADDWFC 03,F
0F41E:  MOVFF  01,8F4
0F422:  MOVFF  03,8F5
0F426:  MOVF   xB1,W
0F428:  MULLW  04
0F42A:  MOVF   FF3,W
0F42C:  CLRF   03
0F42E:  ADDLW  B4
0F430:  MOVWF  FE9
0F432:  MOVLW  08
0F434:  ADDWFC 03,W
0F436:  MOVWF  FEA
0F438:  MOVFF  FEF,8F6
0F43C:  MOVFF  FEC,8F7
0F440:  MOVFF  FEC,8F8
0F444:  MOVFF  FEC,8F9
0F448:  MOVF   xB1,W
0F44A:  MULLW  04
0F44C:  MOVF   FF3,W
0F44E:  CLRF   03
0F450:  ADDLW  D4
0F452:  MOVWF  FE9
0F454:  MOVLW  08
0F456:  ADDWFC 03,W
0F458:  MOVWF  FEA
0F45A:  MOVFF  FEF,00
0F45E:  MOVFF  FEC,01
0F462:  MOVFF  FEC,02
0F466:  MOVFF  FEC,03
0F46A:  MOVF   xF6,W
0F46C:  ADDWF  00,F
0F46E:  MOVF   xF7,W
0F470:  ADDWFC 01,F
0F472:  MOVF   xF8,W
0F474:  ADDWFC 02,F
0F476:  MOVF   xF9,W
0F478:  ADDWFC 03,F
0F47A:  MOVFF  8F5,FEA
0F47E:  MOVFF  8F4,FE9
0F482:  MOVFF  00,FEF
0F486:  MOVFF  01,FEC
0F48A:  MOVFF  02,FEC
0F48E:  MOVFF  03,FEC
0F492:  INCF   xB1,F
0F494:  BRA    F3C6
....................       } 
0F496:  INCF   xB2,F
0F498:  BTFSC  FD8.2
0F49A:  INCF   xB3,F
0F49C:  BRA    F3A8
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F49E:  MOVLW  01
0F4A0:  MOVWF  xB1
0F4A2:  MOVF   xB1,W
0F4A4:  SUBLW  04
0F4A6:  BNC   F518
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F4A8:  BCF    FD8.0
0F4AA:  RLCF   xB1,W
0F4AC:  CLRF   03
0F4AE:  ADDLW  A1
0F4B0:  MOVWF  01
0F4B2:  MOVLW  04
0F4B4:  ADDWFC 03,F
0F4B6:  MOVFF  01,8F4
0F4BA:  MOVFF  03,8F5
0F4BE:  MOVF   xB1,W
0F4C0:  MULLW  04
0F4C2:  MOVF   FF3,W
0F4C4:  CLRF   03
0F4C6:  ADDLW  B4
0F4C8:  MOVWF  FE9
0F4CA:  MOVLW  08
0F4CC:  ADDWFC 03,W
0F4CE:  MOVWF  FEA
0F4D0:  MOVFF  FEF,A24
0F4D4:  MOVFF  FEC,A25
0F4D8:  MOVFF  FEC,A26
0F4DC:  MOVFF  FEC,A27
0F4E0:  BCF    FD8.1
0F4E2:  CLRF   1B
0F4E4:  BTFSC  FF2.7
0F4E6:  BSF    1B.7
0F4E8:  BCF    FF2.7
0F4EA:  MOVLB  A
0F4EC:  CLRF   x2B
0F4EE:  CLRF   x2A
0F4F0:  MOVFF  8B0,A29
0F4F4:  MOVFF  8AF,A28
0F4F8:  MOVLB  0
0F4FA:  CALL   1038
0F4FE:  BTFSC  1B.7
0F500:  BSF    FF2.7
0F502:  MOVFF  8F5,FEA
0F506:  MOVFF  8F4,FE9
0F50A:  MOVFF  00,FEF
0F50E:  MOVFF  01,FEC
0F512:  MOVLB  8
0F514:  INCF   xB1,F
0F516:  BRA    F4A2
....................    } 
0F518:  MOVLB  0
0F51A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    rtc_alarm = TRUE; 
*
00E00:  BSF    49.0
....................    sleep_mode = FALSE; 
00E02:  BCF    49.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E04:  BTFSS  49.2
00E06:  BRA    0E0A
....................    { 
....................       ; 
00E08:  BRA    0E04
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E0A:  BSF    49.2
....................    RTC_read_flags(); 
00E0C:  RCALL  0DCC
....................    ++nv_elapsed; 
00E0E:  INCF   35,F
00E10:  BTFSC  FD8.2
00E12:  INCF   36,F
.................... } 
....................  
00E14:  BCF    FF2.1
00E16:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E5A:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E5C:  BTFSC  49.1
00E5E:  BRA    0EB0
....................    { 
....................       if (kbhit(COM_A)) 
00E60:  BTFSS  F9E.5
00E62:  BRA    0EAE
....................       { 
....................          c = getc(COM_A); 
00E64:  RCALL  0E1A
00E66:  MOVFF  01,A0F
....................          switch (c) 
00E6A:  MOVLB  A
00E6C:  MOVF   x0F,W
00E6E:  XORLW  3F
00E70:  MOVLB  0
00E72:  BZ    0E7E
00E74:  XORLW  2E
00E76:  BZ    0EA2
00E78:  XORLW  0A
00E7A:  BZ    0EA8
00E7C:  BRA    0EAE
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00E7E:  DECFSZ 4A,W
00E80:  BRA    0E92
00E82:  MOVLW  BA
00E84:  MOVWF  FF6
00E86:  MOVLW  0E
00E88:  MOVWF  FF7
00E8A:  MOVLW  00
00E8C:  MOVWF  FF8
00E8E:  RCALL  0E30
00E90:  BRA    0EA0
....................                else fprintf(COM_A, "@RDY\r\n"); 
00E92:  MOVLW  C2
00E94:  MOVWF  FF6
00E96:  MOVLW  0E
00E98:  MOVWF  FF7
00E9A:  MOVLW  00
00E9C:  MOVWF  FF8
00E9E:  RCALL  0E30
....................                break; 
00EA0:  BRA    0EAE
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EA2:  MOVLW  01
00EA4:  MOVWF  4C
....................                break;          
00EA6:  BRA    0EAE
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EA8:  CLRF   32
00EAA:  MOVLW  01
00EAC:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EAE:  BRA    0EB4
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EB0:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00EB2:  BCF    F9E.5
....................    } 
00EB4:  BCF    F9E.5
00EB6:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0ADB6:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0ADB8:  MOVF   FAE,W
....................    busy_status = FALSE; 
0ADBA:  CLRF   4A
0ADBC:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
0293E:  MOVLW  01
02940:  MOVWF  4A
....................    clear_interrupt(INT_RDA); 
02942:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
02944:  BSF    F9D.5
02946:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00ECA:  MOVLW  0B
00ECC:  MOVWF  FD7
00ECE:  MOVLW  DC
00ED0:  MOVWF  FD6
....................    restart_wdt(); 
00ED2:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00ED4:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00ED6:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00ED8:  CLRF   FCF
00EDA:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00EDC:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00EDE:  MOVF   2F,W
00EE0:  SUBLW  02
00EE2:  BNZ   0EEA
00EE4:  MOVF   30,F
00EE6:  BNZ   0EEA
00EE8:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00EEA:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00EEC:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00EEE:  BCF    FF2.2
00EF0:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00EF4:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00EF6:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00EF8:  MOVF   2F,W
00EFA:  SUBLW  02
00EFC:  BNZ   0F04
00EFE:  MOVF   30,F
00F00:  BNZ   0F04
00F02:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F04:  BCF    F9E.0
00F06:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
1586C:  MOVLB  8
1586E:  CLRF   x68
15870:  CLRF   x6C
15872:  CLRF   x6B
15874:  CLRF   x6A
15876:  CLRF   x69
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
15878:  MOVLW  01
1587A:  ADDWF  x69,F
1587C:  BTFSC  FD8.0
1587E:  INCF   x6A,F
15880:  BTFSC  FD8.2
15882:  INCF   x6B,F
15884:  BTFSC  FD8.2
15886:  INCF   x6C,F
15888:  MOVF   x6C,F
1588A:  BNZ   158CC
1588C:  MOVF   x6B,W
1588E:  SUBLW  04
15890:  BNC   158CC
15892:  BNZ   158A2
15894:  MOVF   x6A,W
15896:  SUBLW  93
15898:  BNC   158CC
1589A:  BNZ   158A2
1589C:  MOVF   x69,W
1589E:  SUBLW  DF
158A0:  BNC   158CC
....................    { 
....................       if(kbhit(COM_A)) 
158A2:  BTFSS  F9E.5
158A4:  BRA    158C2
....................       { 
....................          c = fgetc(COM_A); 
158A6:  MOVLB  0
158A8:  CALL   0E1A
158AC:  MOVFF  01,868
....................          if (com_echo == TRUE) 
158B0:  DECFSZ 48,W
158B2:  BRA    158BE
....................          { 
....................             fputc(c, COM_A); 
158B4:  MOVLB  8
158B6:  MOVF   x68,W
158B8:  MOVLB  0
158BA:  CALL   ADBE
....................          } 
....................          break; 
158BE:  MOVLB  8
158C0:  BRA    158CC
....................       } 
....................  
....................       delay_us(10); 
158C2:  MOVLW  35
158C4:  MOVWF  00
158C6:  DECFSZ 00,F
158C8:  BRA    158C6
158CA:  BRA    15878
....................    } 
....................  
....................    return(c); 
158CC:  MOVFF  868,01
158D0:  MOVLB  0
158D2:  GOTO   158E2 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AD32:  MOVLW  58
0AD34:  MOVLB  8
0AD36:  MOVWF  x5F
0AD38:  CLRF   x63
0AD3A:  CLRF   x62
0AD3C:  CLRF   x61
0AD3E:  CLRF   x60
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AD40:  MOVLW  01
0AD42:  ADDWF  x60,F
0AD44:  BTFSC  FD8.0
0AD46:  INCF   x61,F
0AD48:  BTFSC  FD8.2
0AD4A:  INCF   x62,F
0AD4C:  BTFSC  FD8.2
0AD4E:  INCF   x63,F
0AD50:  MOVF   x63,F
0AD52:  BNZ   AD82
0AD54:  MOVF   x62,F
0AD56:  BNZ   AD82
0AD58:  MOVF   x61,W
0AD5A:  SUBLW  C3
0AD5C:  BNC   AD82
0AD5E:  BNZ   AD66
0AD60:  MOVF   x60,W
0AD62:  SUBLW  4F
0AD64:  BNC   AD82
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AD66:  MOVLW  05
0AD68:  MOVWF  00
0AD6A:  DECFSZ 00,F
0AD6C:  BRA    AD6A
....................  
....................       if(kbhit()) 
0AD6E:  BTFSS  F9E.5
0AD70:  BRA    AD80
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AD72:  MOVLB  0
0AD74:  CALL   0E1A
0AD78:  MOVFF  01,85F
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AD7C:  MOVLB  8
0AD7E:  BRA    AD82
....................       } 
0AD80:  BRA    AD40
....................    } 
....................  
....................    return(EscChar); 
0AD82:  MOVFF  85F,01
0AD86:  MOVLB  0
0AD88:  GOTO   1B356 (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0D77C:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0D77E:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0D780:  BSF    F8F.3
....................    delay_ms(10); 
0D782:  MOVLW  0A
0D784:  MOVLB  9
0D786:  MOVWF  xC8
0D788:  MOVLB  0
0D78A:  CALL   288E
0D78E:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0D868:  MOVLB  8
0D86A:  CLRF   xD0
0D86C:  CLRF   xCF
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0D86E:  MOVLB  F
0D870:  BTFSC  x21.1
0D872:  BRA    D880
....................       ++c; 
0D874:  MOVLB  8
0D876:  INCF   xCF,F
0D878:  BTFSC  FD8.2
0D87A:  INCF   xD0,F
0D87C:  BRA    D86E
0D87E:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0D880:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0D882:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0D884:  BCF    F8F.3
0D886:  MOVLB  0
0D888:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
0FFF4:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0FFF6:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0FFF8:  BCF    F8F.3
0FFFA:  GOTO   16B26 (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
*
16A3A:  MOVLB  8
16A3C:  CLRF   x61
16A3E:  CLRF   x62
16A40:  CLRF   xB3
16A42:  CLRF   xB4
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16A44:  MOVLW  0A
16A46:  MOVWF  FF6
16A48:  MOVLW  0F
16A4A:  MOVWF  FF7
16A4C:  MOVLW  00
16A4E:  MOVWF  FF8
16A50:  CLRF   1B
16A52:  BTFSC  FF2.7
16A54:  BSF    1B.7
16A56:  BCF    FF2.7
16A58:  MOVLB  0
16A5A:  CALL   0E30
16A5E:  BTFSC  1B.7
16A60:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16A62:  MOVLB  8
16A64:  MOVF   x62,W
16A66:  SUBLW  04
16A68:  BZ    16B20
....................    { 
....................        if (kbhit(COM_A)) 
16A6A:  BTFSS  F9E.5
16A6C:  BRA    16B04
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16A6E:  MOVLB  0
16A70:  CALL   0E1A
16A74:  MOVFF  01,861
....................           if (com_echo == TRUE) 
16A78:  DECFSZ 48,W
16A7A:  BRA    16A86
....................           { 
....................              fputc(charFromA, COM_A); 
16A7C:  MOVLB  8
16A7E:  MOVF   x61,W
16A80:  MOVLB  0
16A82:  CALL   ADBE
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16A86:  MOVLB  8
16A88:  MOVF   xB4,W
16A8A:  SUBLW  4F
16A8C:  BNC   16AE2
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16A8E:  MOVF   xB4,W
16A90:  INCF   xB4,F
16A92:  CLRF   03
16A94:  ADDLW  63
16A96:  MOVWF  FE9
16A98:  MOVLW  08
16A9A:  ADDWFC 03,W
16A9C:  MOVWF  FEA
16A9E:  MOVFF  861,FEF
....................              if (CARRIAGE_RET == charFromA) 
16AA2:  MOVF   x61,W
16AA4:  SUBLW  0D
16AA6:  BNZ   16AE0
....................              { 
....................                 multidrop_on(); 
16AA8:  MOVLB  0
16AAA:  CALL   D77C
....................                 for (index = 0 ; index < charCount; index++) 
16AAE:  MOVLB  8
16AB0:  CLRF   xB3
16AB2:  MOVF   xB4,W
16AB4:  SUBWF  xB3,W
16AB6:  BC    16AD6
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
16AB8:  CLRF   03
16ABA:  MOVF   xB3,W
16ABC:  ADDLW  63
16ABE:  MOVWF  FE9
16AC0:  MOVLW  08
16AC2:  ADDWFC 03,W
16AC4:  MOVWF  FEA
16AC6:  MOVFF  FEF,8B5
16ACA:  MOVF   xB5,W
16ACC:  MOVLB  0
16ACE:  BRA    16A2C
16AD0:  MOVLB  8
16AD2:  INCF   xB3,F
16AD4:  BRA    16AB2
....................                 } 
....................                 charCount = 0; 
16AD6:  CLRF   xB4
....................                 multidrop_off(); 
16AD8:  MOVLB  0
16ADA:  CALL   D868
16ADE:  MOVLB  8
....................              } 
....................           } 
16AE0:  BRA    16B04
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
16AE2:  MOVLW  12
16AE4:  MOVWF  FF6
16AE6:  MOVLW  0F
16AE8:  MOVWF  FF7
16AEA:  MOVLW  00
16AEC:  MOVWF  FF8
16AEE:  CLRF   1B
16AF0:  BTFSC  FF2.7
16AF2:  BSF    1B.7
16AF4:  BCF    FF2.7
16AF6:  MOVLB  0
16AF8:  CALL   0E30
16AFC:  BTFSC  1B.7
16AFE:  BSF    FF2.7
....................              charCount = 0; 
16B00:  MOVLB  8
16B02:  CLRF   xB4
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
16B04:  BTFSS  FA4.5
16B06:  BRA    16B1E
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
16B08:  MOVLB  0
16B0A:  CALL   12B16
16B0E:  MOVFF  01,862
....................           fputc(charFromB, COM_A);                  // send data via USART 
16B12:  MOVLB  8
16B14:  MOVF   x62,W
16B16:  MOVLB  0
16B18:  CALL   ADBE
16B1C:  MOVLB  8
....................        } 
16B1E:  BRA    16A64
....................    } 
....................  
....................    multidrop_shdn(); 
16B20:  MOVLB  0
16B22:  GOTO   FFF4
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
16B26:  MOVLW  22
16B28:  MOVWF  FF6
16B2A:  MOVLW  0F
16B2C:  MOVWF  FF7
16B2E:  MOVLW  00
16B30:  MOVWF  FF8
16B32:  CLRF   1B
16B34:  BTFSC  FF2.7
16B36:  BSF    1B.7
16B38:  BCF    FF2.7
16B3A:  CALL   0E30
16B3E:  BTFSC  1B.7
16B40:  BSF    FF2.7
16B42:  GOTO   16B5C (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C5A0:  MOVLB  8
0C5A2:  DECF   x7B,F
....................    len=0; 
0C5A4:  CLRF   x7C
....................    do { 
....................      c=getc(); 
0C5A6:  MOVLB  0
0C5A8:  CALL   0E1A
0C5AC:  MOVFF  01,87D
....................      if(c==8) {  // Backspace 
0C5B0:  MOVLB  8
0C5B2:  MOVF   x7D,W
0C5B4:  SUBLW  08
0C5B6:  BNZ   C5DA
....................         if(len>0) { 
0C5B8:  MOVF   x7C,F
0C5BA:  BZ    C5D8
....................           len--; 
0C5BC:  DECF   x7C,F
....................           putc(c); 
0C5BE:  MOVF   x7D,W
0C5C0:  MOVLB  0
0C5C2:  CALL   ADBE
....................           putc(' '); 
0C5C6:  MOVLW  20
0C5C8:  CALL   ADBE
....................           putc(c); 
0C5CC:  MOVLB  8
0C5CE:  MOVF   x7D,W
0C5D0:  MOVLB  0
0C5D2:  CALL   ADBE
0C5D6:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C5D8:  BRA    C608
0C5DA:  MOVF   x7D,W
0C5DC:  SUBLW  1F
0C5DE:  BC    C608
0C5E0:  MOVF   x7D,W
0C5E2:  SUBLW  7E
0C5E4:  BNC   C608
....................        if(len<=max) { 
0C5E6:  MOVF   x7C,W
0C5E8:  SUBWF  x7B,W
0C5EA:  BNC   C608
....................          s[len++]=c; 
0C5EC:  MOVF   x7C,W
0C5EE:  INCF   x7C,F
0C5F0:  ADDWF  x79,W
0C5F2:  MOVWF  FE9
0C5F4:  MOVLW  00
0C5F6:  ADDWFC x7A,W
0C5F8:  MOVWF  FEA
0C5FA:  MOVFF  87D,FEF
....................          putc(c); 
0C5FE:  MOVF   x7D,W
0C600:  MOVLB  0
0C602:  CALL   ADBE
0C606:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C608:  MOVF   x7D,W
0C60A:  SUBLW  0D
0C60C:  BNZ   C5A6
....................    s[len]=0; 
0C60E:  MOVF   x7C,W
0C610:  ADDWF  x79,W
0C612:  MOVWF  FE9
0C614:  MOVLW  00
0C616:  ADDWFC x7A,W
0C618:  MOVWF  FEA
0C61A:  CLRF   FEF
0C61C:  MOVLB  0
0C61E:  GOTO   CA1E (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CA0C:  MOVLW  08
0CA0E:  MOVLB  8
0CA10:  MOVWF  x7A
0CA12:  MOVLW  61
0CA14:  MOVWF  x79
0CA16:  MOVLW  14
0CA18:  MOVWF  x7B
0CA1A:  MOVLB  0
0CA1C:  BRA    C5A0
....................   f = atof(s); 
0CA1E:  MOVLW  08
0CA20:  MOVLB  8
0CA22:  MOVWF  x7A
0CA24:  MOVLW  61
0CA26:  MOVWF  x79
0CA28:  CLRF   x7C
0CA2A:  CLRF   x7B
0CA2C:  MOVLB  0
0CA2E:  BRA    C7B6
0CA30:  MOVFF  03,878
0CA34:  MOVFF  02,877
0CA38:  MOVFF  01,876
0CA3C:  MOVFF  00,875
....................   return(f); 
0CA40:  MOVFF  875,00
0CA44:  MOVFF  876,01
0CA48:  MOVFF  877,02
0CA4C:  MOVFF  878,03
0CA50:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
028B8:  MOVLW  2F
028BA:  MOVWF  F92
....................    set_tris_b(0b00110111); 
028BC:  MOVLW  37
028BE:  MOVWF  F93
....................    set_tris_c(0b10010000); 
028C0:  MOVLW  90
028C2:  MOVWF  F94
....................    set_tris_d(0b00100000); 
028C4:  MOVLW  20
028C6:  MOVWF  F95
....................    set_tris_e(0b01000000); 
028C8:  MOVLW  40
028CA:  MOVWF  F96
....................    set_tris_f(0b00000000); 
028CC:  MOVLW  00
028CE:  MOVWF  F97
....................    set_tris_g(0b11100100); 
028D0:  MOVLW  E4
028D2:  MOVWF  F98
....................    set_tris_h(0b01000000); 
028D4:  MOVLW  40
028D6:  MOVWF  F99
....................    set_tris_j(0b00000000); 
028D8:  MOVLW  00
028DA:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
028DC:  BCF    F8E.3
....................    output_low(HB_IN1); 
028DE:  BCF    F8E.4
....................    output_low(HB_IN2); 
028E0:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
028E2:  BCF    F91.3
....................    output_high(EEP_CS);        
028E4:  BSF    F91.2
....................    output_high(RTC_CS); 
028E6:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
028E8:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
028EA:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
028EC:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
028EE:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
028F0:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
028F2:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
028F4:  BCF    F8F.3
....................    delay_ms(20);   
028F6:  MOVLW  14
028F8:  MOVLB  9
028FA:  MOVWF  xC8
028FC:  MOVLB  0
028FE:  RCALL  288E
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
02900:  BCF    F8E.1
....................    output_low(VDET);     
02902:  BCF    F90.7
....................    bus_pwr_status=0; 
02904:  MOVLB  4
02906:  CLRF   xB2
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
02908:  BSF    F8C.2
....................    output_high(DAC_CS); 
0290A:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
0290C:  BCF    F8C.0
....................    output_low(HSW2); 
0290E:  BCF    F8C.1
....................    heater_stat=0; 
02910:  CLRF   xB1
02912:  MOVLB  0
02914:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
1579A:  BSF    F91.1
....................    output_low(EEP_WP);        
1579C:  BCF    F91.3
....................    output_high(EEP_CS);        
1579E:  BSF    F91.2
....................    output_high(RTC_CS);  
157A0:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
157A2:  BCF    F8E.3
....................    output_low(HB_IN1);        
157A4:  BCF    F8E.4
....................    output_low(HB_IN2); 
157A6:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
157A8:  BCF    F8C.2
....................    output_low(DAC_CS); 
157AA:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
157AC:  BCF    F8C.0
....................    output_low(HSW2); 
157AE:  BCF    F8C.1
....................    heater_stat=0; 
157B0:  MOVLB  4
157B2:  CLRF   xB1
....................    // Power switches 
....................    output_low(VMOT);         
157B4:  BCF    F8E.1
....................    output_low(VDET);  
157B6:  BCF    F90.7
....................    bus_pwr_status=0; 
157B8:  CLRF   xB2
....................    output_low(VENC1);         
157BA:  BCF    F8E.6
....................    output_low(VENC2);         
157BC:  BCF    F8E.7
....................    output_low(VHBRDG);  
157BE:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
157C0:  MOVLW  2A
157C2:  MOVWF  FF6
157C4:  MOVLW  0F
157C6:  MOVWF  FF7
157C8:  MOVLW  00
157CA:  MOVWF  FF8
157CC:  CLRF   1B
157CE:  BTFSC  FF2.7
157D0:  BSF    1B.7
157D2:  BCF    FF2.7
157D4:  MOVLB  0
157D6:  CALL   0E30
157DA:  BTFSC  1B.7
157DC:  BSF    FF2.7
....................    delay_ms(50); 
157DE:  MOVLW  32
157E0:  MOVLB  9
157E2:  MOVWF  xC8
157E4:  MOVLB  0
157E6:  CALL   288E
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
157EA:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
157EC:  BSF    F91.6
....................    output_low(MD1_TXEN); 
157EE:  BCF    F91.5
....................    output_low(MD2_SHDN);    
157F0:  BCF    F8F.0
....................    output_low(MD2_REN); 
157F2:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
157F4:  BCF    F8F.3
....................  
....................    delay_ms(30); 
157F6:  MOVLW  1E
157F8:  MOVLB  9
157FA:  MOVWF  xC8
157FC:  MOVLB  0
157FE:  CALL   288E
15802:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
04FB8:  MOVLB  8
04FBA:  CLRF   x65
04FBC:  MOVF   x65,W
04FBE:  SUBLW  02
04FC0:  BNC   4FE6
....................       FS_Status = f_mountdrv(); 
04FC2:  MOVLB  0
04FC4:  RCALL  47D4
04FC6:  MOVFF  01,720
....................       if (FS_Status) 
04FCA:  MOVLB  7
04FCC:  MOVF   x20,F
04FCE:  BZ    4FDA
....................          { 
....................          display_file_result(FS_Status); 
04FD0:  MOVFF  720,866
04FD4:  MOVLB  0
04FD6:  BRA    4D72
....................          } 
04FD8:  BRA    4FE0
....................       else break; 
04FDA:  MOVLB  8
04FDC:  BRA    4FE6
04FDE:  MOVLB  0
04FE0:  MOVLB  8
04FE2:  INCF   x65,F
04FE4:  BRA    4FBC
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
04FE6:  MOVLW  3E
04FE8:  MOVWF  xCA
04FEA:  CLRF   xCC
04FEC:  MOVFF  720,8CB
04FF0:  MOVLB  0
04FF2:  RCALL  4F52
....................     
....................    return(FS_Status); 
04FF4:  MOVLB  7
04FF6:  MOVFF  720,01
04FFA:  MOVLB  0
04FFC:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
0307A:  MOVLW  01
0307C:  MOVLB  8
0307E:  MOVWF  x5F
03080:  MOVF   x5F,W
03082:  SUBLW  03
03084:  BNC   30C0
....................    { 
....................       output_bit(BOARD_LED, ON); 
03086:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
03088:  MOVF   2F,W
0308A:  SUBLW  02
0308C:  BNZ   3094
0308E:  MOVF   30,F
03090:  BNZ   3094
03092:  BSF    F90.6
....................       delay_ms(32); 
03094:  MOVLW  20
03096:  MOVLB  9
03098:  MOVWF  xC8
0309A:  MOVLB  0
0309C:  CALL   288E
....................       output_bit(BOARD_LED, OFF); 
030A0:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
030A2:  MOVF   2F,W
030A4:  SUBLW  02
030A6:  BNZ   30AE
030A8:  MOVF   30,F
030AA:  BNZ   30AE
030AC:  BCF    F90.6
....................       delay_ms(32); 
030AE:  MOVLW  20
030B0:  MOVLB  9
030B2:  MOVWF  xC8
030B4:  MOVLB  0
030B6:  CALL   288E
030BA:  MOVLB  8
030BC:  INCF   x5F,F
030BE:  BRA    3080
....................    } 
030C0:  MOVLB  0
030C2:  GOTO   1B156 (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
0507A:  MOVLB  8
0507C:  CLRF   xCF
0507E:  CLRF   xCE
05080:  CLRF   xCD
05082:  CLRF   xCC
....................    set_adc_channel(0,VSS); 
05084:  MOVLW  00
05086:  MOVWF  01
05088:  MOVF   FC2,W
0508A:  ANDLW  83
0508C:  IORWF  01,W
0508E:  MOVWF  FC2
05090:  MOVLW  00
05092:  MOVWF  01
05094:  MOVF   FC1,W
05096:  ANDLW  F8
05098:  IORWF  01,W
0509A:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
0509C:  MOVLW  01
0509E:  MOVWF  xC9
050A0:  MOVF   xC9,W
050A2:  SUBLW  32
050A4:  BNC   50CA
....................       reading=read_adc(); 
050A6:  BSF    FC2.1
050A8:  BTFSC  FC2.1
050AA:  BRA    50A8
050AC:  MOVFF  FC3,8D0
050B0:  MOVFF  FC4,8D1
050B4:  CLRF   xD2
050B6:  CLRF   xD3
....................       delay_ms(5); 
050B8:  MOVLW  05
050BA:  MOVLB  9
050BC:  MOVWF  xC8
050BE:  MOVLB  0
050C0:  CALL   288E
050C4:  MOVLB  8
050C6:  INCF   xC9,F
050C8:  BRA    50A0
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
050CA:  MOVLW  01
050CC:  MOVWF  xC9
050CE:  MOVF   xC9,W
050D0:  SUBLW  64
050D2:  BNC   5180
....................       reading=read_adc(); 
050D4:  BSF    FC2.1
050D6:  BTFSC  FC2.1
050D8:  BRA    50D6
050DA:  MOVFF  FC3,8D0
050DE:  MOVFF  FC4,8D1
050E2:  CLRF   xD2
050E4:  CLRF   xD3
....................       result=(((result*(i-1))+reading)/i); 
050E6:  MOVLW  01
050E8:  SUBWF  xC9,W
050EA:  MOVWF  xD4
050EC:  MOVFF  8CF,9D5
050F0:  MOVFF  8CE,9D4
050F4:  MOVFF  8CD,9D3
050F8:  MOVFF  8CC,9D2
050FC:  MOVLB  9
050FE:  CLRF   xD9
05100:  CLRF   xD8
05102:  CLRF   xD7
05104:  MOVWF  xD6
05106:  MOVLB  0
05108:  CALL   4778
0510C:  MOVFF  03,8D7
05110:  MOVFF  02,8D6
05114:  MOVFF  01,8D5
05118:  MOVFF  00,8D4
0511C:  MOVLB  8
0511E:  MOVF   xD0,W
05120:  ADDWF  xD4,F
05122:  MOVF   xD1,W
05124:  ADDWFC xD5,F
05126:  MOVF   xD2,W
05128:  ADDWFC xD6,F
0512A:  MOVF   xD3,W
0512C:  ADDWFC xD7,F
0512E:  BCF    FD8.1
05130:  CLRF   1B
05132:  BTFSC  FF2.7
05134:  BSF    1B.7
05136:  BCF    FF2.7
05138:  MOVFF  8D7,A27
0513C:  MOVFF  8D6,A26
05140:  MOVFF  8D5,A25
05144:  MOVFF  8D4,A24
05148:  MOVLB  A
0514A:  CLRF   x2B
0514C:  CLRF   x2A
0514E:  CLRF   x29
05150:  MOVFF  8C9,A28
05154:  MOVLB  0
05156:  CALL   1038
0515A:  BTFSC  1B.7
0515C:  BSF    FF2.7
0515E:  MOVFF  03,8CF
05162:  MOVFF  02,8CE
05166:  MOVFF  01,8CD
0516A:  MOVFF  00,8CC
....................       delay_ms(5); 
0516E:  MOVLW  05
05170:  MOVLB  9
05172:  MOVWF  xC8
05174:  MOVLB  0
05176:  CALL   288E
0517A:  MOVLB  8
0517C:  INCF   xC9,F
0517E:  BRA    50CE
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
05180:  MOVFF  8CF,9D5
05184:  MOVFF  8CE,9D4
05188:  MOVFF  8CD,9D3
0518C:  MOVFF  8CC,9D2
05190:  MOVLB  9
05192:  CLRF   xD9
05194:  CLRF   xD8
05196:  CLRF   xD7
05198:  MOVLW  64
0519A:  MOVWF  xD6
0519C:  MOVLB  0
0519E:  CALL   4778
051A2:  MOVFF  03,8D7
051A6:  MOVFF  02,8D6
051AA:  MOVFF  01,8D5
051AE:  MOVFF  00,8D4
051B2:  BCF    FD8.1
051B4:  CLRF   1B
051B6:  BTFSC  FF2.7
051B8:  BSF    1B.7
051BA:  BCF    FF2.7
051BC:  MOVFF  03,A27
051C0:  MOVFF  02,A26
051C4:  MOVFF  01,A25
051C8:  MOVFF  00,A24
051CC:  MOVLB  A
051CE:  CLRF   x2B
051D0:  CLRF   x2A
051D2:  MOVLW  01
051D4:  MOVWF  x29
051D6:  MOVLW  10
051D8:  MOVWF  x28
051DA:  MOVLB  0
051DC:  CALL   1038
051E0:  BTFSC  1B.7
051E2:  BSF    FF2.7
051E4:  MOVLW  56
051E6:  MOVLB  8
051E8:  ADDWF  00,W
051EA:  MOVWF  xCA
051EC:  MOVLW  00
051EE:  ADDWFC 01,W
051F0:  MOVWF  xCB
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
051F2:  MOVFF  8CA,01
051F6:  MOVFF  8CB,02
051FA:  MOVLB  0
051FC:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
05064:  MOVLW  02
05066:  MOVWF  FEA
05068:  MOVLW  95
0506A:  MOVWF  FE9
0506C:  CLRF   00
0506E:  CLRF   02
05070:  MOVLW  1E
05072:  MOVWF  01
05074:  CALL   34A4
05078:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12A3E:  MOVLW  02
12A40:  MOVWF  FEA
12A42:  MOVLW  B3
12A44:  MOVWF  FE9
12A46:  CLRF   00
12A48:  CLRF   02
12A4A:  MOVLW  1E
12A4C:  MOVWF  01
12A4E:  CALL   34A4
12A52:  GOTO   12CFA (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
05398:  RCALL  5064
....................     
....................    v_supply = read_supply(); 
0539A:  RCALL  507A
0539C:  MOVFF  02,8C8
053A0:  MOVFF  01,8C7
....................    RTC_read(); 
053A4:  CALL   32C2
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
053A8:  MOVLW  02
053AA:  MOVWF  1E
053AC:  MOVLW  95
053AE:  MOVWF  1D
053B0:  MOVFF  726,8C9
053B4:  MOVLW  01
053B6:  MOVLB  8
053B8:  MOVWF  xCA
053BA:  MOVLB  0
053BC:  RCALL  51FE
053BE:  MOVLW  2F
053C0:  MOVLB  8
053C2:  MOVWF  xDB
053C4:  MOVLB  0
053C6:  RCALL  501C
053C8:  MOVFF  725,8C9
053CC:  MOVLW  01
053CE:  MOVLB  8
053D0:  MOVWF  xCA
053D2:  MOVLB  0
053D4:  RCALL  51FE
053D6:  MOVLW  2F
053D8:  MOVLB  8
053DA:  MOVWF  xDB
053DC:  MOVLB  0
053DE:  RCALL  501C
053E0:  MOVFF  727,8C9
053E4:  MOVLW  01
053E6:  MOVLB  8
053E8:  MOVWF  xCA
053EA:  MOVLB  0
053EC:  RCALL  51FE
053EE:  MOVLW  20
053F0:  MOVLB  8
053F2:  MOVWF  xDB
053F4:  MOVLB  0
053F6:  RCALL  501C
053F8:  MOVFF  723,8C9
053FC:  MOVLW  01
053FE:  MOVLB  8
05400:  MOVWF  xCA
05402:  MOVLB  0
05404:  RCALL  51FE
05406:  MOVLW  3A
05408:  MOVLB  8
0540A:  MOVWF  xDB
0540C:  MOVLB  0
0540E:  RCALL  501C
05410:  MOVFF  722,8C9
05414:  MOVLW  01
05416:  MOVLB  8
05418:  MOVWF  xCA
0541A:  MOVLB  0
0541C:  RCALL  51FE
0541E:  MOVLW  3A
05420:  MOVLB  8
05422:  MOVWF  xDB
05424:  MOVLB  0
05426:  RCALL  501C
05428:  MOVFF  721,8C9
0542C:  MOVLW  01
0542E:  MOVLB  8
05430:  MOVWF  xCA
05432:  MOVLB  0
05434:  RCALL  51FE
05436:  MOVLW  2C
05438:  MOVLB  8
0543A:  MOVWF  xDB
0543C:  MOVLB  0
0543E:  RCALL  501C
05440:  MOVLW  44
05442:  MOVWF  FE9
05444:  MOVLB  8
05446:  CLRF   xCC
05448:  CLRF   xCB
0544A:  MOVFF  8C8,8CA
0544E:  MOVFF  8C7,8C9
05452:  MOVLW  02
05454:  MOVWF  xCD
05456:  MOVLB  0
05458:  RCALL  5298
0545A:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
08424:  MOVLB  2
08426:  MOVF   xD8,F
08428:  BNZ   84A4
....................    { 
....................       strcopy(event_buffer,""); 
0842A:  MOVLW  01
0842C:  MOVWF  FEA
0842E:  MOVLW  03
08430:  MOVWF  FE9
08432:  MOVLW  00
08434:  MOVLB  0
08436:  CALL   02CE
0843A:  TBLRD*-
0843C:  TBLRD*+
0843E:  MOVF   FF5,W
08440:  MOVWF  FEE
08442:  IORLW  00
08444:  BNZ   843C
....................       time_stamp(); 
08446:  CALL   5398
....................       strcat(event_buffer, time_stmp_str); 
0844A:  MOVLW  01
0844C:  MOVLB  8
0844E:  MOVWF  xD5
08450:  MOVLW  03
08452:  MOVWF  xD4
08454:  MOVLW  02
08456:  MOVWF  xD7
08458:  MOVLW  95
0845A:  MOVWF  xD6
0845C:  MOVLB  0
0845E:  CALL   545C
....................       strcat(event_buffer, event_str); 
08462:  MOVLW  01
08464:  MOVLB  8
08466:  MOVWF  xD5
08468:  MOVLW  03
0846A:  MOVWF  xD4
0846C:  MOVLW  01
0846E:  MOVWF  xD7
08470:  MOVLW  A3
08472:  MOVWF  xD6
08474:  MOVLB  0
08476:  CALL   545C
....................       buffer_select = 1; 
0847A:  MOVLW  01
0847C:  MOVWF  x62
....................     
....................       heartbeat(FALSE); 
0847E:  MOVLB  8
08480:  CLRF   xC9
08482:  MOVLB  0
08484:  CALL   5500
....................          append_data(file_ptr_events); 
08488:  MOVLW  03
0848A:  MOVLB  8
0848C:  MOVWF  xCA
0848E:  MOVLW  11
08490:  MOVWF  xC9
08492:  MOVLB  0
08494:  RCALL  8242
....................       heartbeat(TRUE); 
08496:  MOVLW  01
08498:  MOVLB  8
0849A:  MOVWF  xC9
0849C:  MOVLB  0
0849E:  CALL   5500
084A2:  MOVLB  2
....................    } 
084A4:  MOVLB  0
084A6:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
02842:  BCF    F8B.2
02844:  MOVLW  0C
02846:  MOVWF  FBB
02848:  CLRF   FBE
0284A:  CLRF   FBF
0284C:  MOVLW  01
0284E:  MOVWF  F9C
02850:  MOVLW  F8
02852:  MOVLB  F
02854:  ANDWF  x2D,F
02856:  MOVLW  00
02858:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
0285A:  BCF    F8B.1
0285C:  MOVLW  0C
0285E:  MOVWF  x4E
02860:  CLRF   x51
02862:  CLRF   x52
02864:  MOVLW  01
02866:  MOVWF  x1B
02868:  MOVLW  C7
0286A:  ANDWF  x2D,F
0286C:  MOVLW  00
0286E:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
02870:  IORLW  05
02872:  MOVWF  FCA
02874:  MOVLW  7F
02876:  MOVWF  FCB
02878:  MOVLB  0
0287A:  GOTO   1B10C (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09C4C:  MOVLW  34
09C4E:  MOVWF  FF6
09C50:  MOVLW  0F
09C52:  MOVWF  FF7
09C54:  MOVLW  00
09C56:  MOVWF  FF8
09C58:  CLRF   1B
09C5A:  BTFSC  FF2.7
09C5C:  BSF    1B.7
09C5E:  BCF    FF2.7
09C60:  MOVLW  05
09C62:  MOVLB  A
09C64:  MOVWF  x18
09C66:  MOVLB  0
09C68:  CALL   1006
09C6C:  BTFSC  1B.7
09C6E:  BSF    FF2.7
09C70:  MOVLW  10
09C72:  MOVWF  FE9
09C74:  CLRF   1B
09C76:  BTFSC  FF2.7
09C78:  BSF    1B.7
09C7A:  BCF    FF2.7
09C7C:  MOVFF  793,A19
09C80:  MOVFF  792,A18
09C84:  CALL   1188
09C88:  BTFSC  1B.7
09C8A:  BSF    FF2.7
09C8C:  MOVLW  2C
09C8E:  BTFSS  F9E.4
09C90:  BRA    9C8E
09C92:  MOVWF  FAD
09C94:  MOVLW  10
09C96:  MOVWF  FE9
09C98:  CLRF   1B
09C9A:  BTFSC  FF2.7
09C9C:  BSF    1B.7
09C9E:  BCF    FF2.7
09CA0:  MOVFF  795,A19
09CA4:  MOVFF  794,A18
09CA8:  CALL   1188
09CAC:  BTFSC  1B.7
09CAE:  BSF    FF2.7
09CB0:  MOVLW  0D
09CB2:  BTFSS  F9E.4
09CB4:  BRA    9CB2
09CB6:  MOVWF  FAD
09CB8:  MOVLW  0A
09CBA:  BTFSS  F9E.4
09CBC:  BRA    9CBA
09CBE:  MOVWF  FAD
09CC0:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02C98:  MOVLW  86
02C9A:  MOVLB  8
02C9C:  MOVWF  x73
02C9E:  MOVLB  0
02CA0:  RCALL  2948
02CA2:  MOVFF  02,73F
02CA6:  MOVFF  01,73E
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02CAA:  MOVLW  8A
02CAC:  MOVLB  8
02CAE:  MOVWF  x73
02CB0:  MOVLB  0
02CB2:  RCALL  2948
02CB4:  MOVFF  02,743
02CB8:  MOVFF  01,742
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02CBC:  MOVLW  8E
02CBE:  MOVLB  8
02CC0:  MOVWF  x73
02CC2:  MOVLB  0
02CC4:  RCALL  2948
02CC6:  MOVFF  02,747
02CCA:  MOVFF  01,746
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02CCE:  MOVLW  92
02CD0:  MOVLB  8
02CD2:  MOVWF  x73
02CD4:  MOVLB  0
02CD6:  RCALL  2948
02CD8:  MOVFF  02,74B
02CDC:  MOVFF  01,74A
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02CE0:  MOVLW  96
02CE2:  MOVLB  8
02CE4:  MOVWF  x73
02CE6:  MOVLB  0
02CE8:  RCALL  2948
02CEA:  MOVFF  02,74F
02CEE:  MOVFF  01,74E
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02CF2:  MOVLW  9A
02CF4:  MOVLB  8
02CF6:  MOVWF  x73
02CF8:  MOVLB  0
02CFA:  RCALL  2948
02CFC:  MOVFF  02,753
02D00:  MOVFF  01,752
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02D04:  MOVLW  9E
02D06:  MOVLB  8
02D08:  MOVWF  x73
02D0A:  MOVLB  0
02D0C:  RCALL  2948
02D0E:  MOVFF  02,757
02D12:  MOVFF  01,756
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02D16:  MOVLW  A2
02D18:  MOVLB  8
02D1A:  MOVWF  x73
02D1C:  MOVLB  0
02D1E:  RCALL  2948
02D20:  MOVFF  02,75B
02D24:  MOVFF  01,75A
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02D28:  MOVLW  A6
02D2A:  MOVLB  8
02D2C:  MOVWF  x73
02D2E:  MOVLB  0
02D30:  RCALL  2948
02D32:  MOVFF  02,75F
02D36:  MOVFF  01,75E
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02D3A:  MOVLW  82
02D3C:  MOVLB  8
02D3E:  MOVWF  x73
02D40:  MOVLB  0
02D42:  RCALL  2948
02D44:  MOVFF  02,763
02D48:  MOVFF  01,762
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02D4C:  MOVLW  7E
02D4E:  MOVLB  8
02D50:  MOVWF  x73
02D52:  MOVLB  0
02D54:  RCALL  2948
02D56:  MOVFF  02,7BC
02D5A:  MOVFF  01,7BB
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02D5E:  MOVLW  AA
02D60:  MOVLB  8
02D62:  MOVWF  x73
02D64:  MOVLB  0
02D66:  RCALL  2948
02D68:  MOVFF  02,7C0
02D6C:  MOVFF  01,7BF
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02D70:  MOVLW  7A
02D72:  MOVLB  8
02D74:  MOVWF  x73
02D76:  MOVLB  0
02D78:  RCALL  2948
02D7A:  MOVFF  02,767
02D7E:  MOVFF  01,766
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02D82:  MOVLW  76
02D84:  MOVLB  8
02D86:  MOVWF  x73
02D88:  MOVLB  0
02D8A:  RCALL  2948
02D8C:  MOVFF  02,76B
02D90:  MOVFF  01,76A
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02D94:  MOVLW  72
02D96:  MOVLB  8
02D98:  MOVWF  x73
02D9A:  MOVLB  0
02D9C:  RCALL  2948
02D9E:  MOVFF  02,76F
02DA2:  MOVFF  01,76E
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02DA6:  MOVLW  6E
02DA8:  MOVLB  8
02DAA:  MOVWF  x73
02DAC:  MOVLB  0
02DAE:  RCALL  2948
02DB0:  MOVFF  02,793
02DB4:  MOVFF  01,792
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02DB8:  MOVLW  AE
02DBA:  MOVLB  8
02DBC:  MOVWF  x73
02DBE:  MOVLB  0
02DC0:  RCALL  2948
02DC2:  MOVFF  02,773
02DC6:  MOVFF  01,772
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02DCA:  MOVLW  B2
02DCC:  MOVLB  8
02DCE:  MOVWF  x73
02DD0:  MOVLB  0
02DD2:  RCALL  2948
02DD4:  MOVFF  02,7AC
02DD8:  MOVFF  01,7AB
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02DDC:  MOVLW  B6
02DDE:  MOVLB  8
02DE0:  MOVWF  x73
02DE2:  MOVLB  0
02DE4:  RCALL  2948
02DE6:  MOVFF  02,7B0
02DEA:  MOVFF  01,7AF
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02DEE:  MOVLW  BA
02DF0:  MOVLB  8
02DF2:  MOVWF  x73
02DF4:  MOVLB  0
02DF6:  RCALL  2948
02DF8:  MOVFF  02,777
02DFC:  MOVFF  01,776
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02E00:  MOVLW  BE
02E02:  MOVLB  8
02E04:  MOVWF  x73
02E06:  MOVLB  0
02E08:  RCALL  2948
02E0A:  MOVFF  02,77B
02E0E:  MOVFF  01,77A
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02E12:  MOVLW  C2
02E14:  MOVLB  8
02E16:  MOVWF  x73
02E18:  MOVLB  0
02E1A:  RCALL  2948
02E1C:  MOVFF  02,77F
02E20:  MOVFF  01,77E
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02E24:  MOVLW  88
02E26:  MOVLB  8
02E28:  MOVWF  x73
02E2A:  MOVLB  0
02E2C:  RCALL  2948
02E2E:  MOVFF  02,741
02E32:  MOVFF  01,740
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02E36:  MOVLW  8C
02E38:  MOVLB  8
02E3A:  MOVWF  x73
02E3C:  MOVLB  0
02E3E:  RCALL  2948
02E40:  MOVFF  02,745
02E44:  MOVFF  01,744
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02E48:  MOVLW  90
02E4A:  MOVLB  8
02E4C:  MOVWF  x73
02E4E:  MOVLB  0
02E50:  RCALL  2948
02E52:  MOVFF  02,749
02E56:  MOVFF  01,748
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02E5A:  MOVLW  94
02E5C:  MOVLB  8
02E5E:  MOVWF  x73
02E60:  MOVLB  0
02E62:  RCALL  2948
02E64:  MOVFF  02,74D
02E68:  MOVFF  01,74C
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02E6C:  MOVLW  98
02E6E:  MOVLB  8
02E70:  MOVWF  x73
02E72:  MOVLB  0
02E74:  RCALL  2948
02E76:  MOVFF  02,751
02E7A:  MOVFF  01,750
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02E7E:  MOVLW  9C
02E80:  MOVLB  8
02E82:  MOVWF  x73
02E84:  MOVLB  0
02E86:  RCALL  2948
02E88:  MOVFF  02,755
02E8C:  MOVFF  01,754
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02E90:  MOVLW  A0
02E92:  MOVLB  8
02E94:  MOVWF  x73
02E96:  MOVLB  0
02E98:  RCALL  2948
02E9A:  MOVFF  02,759
02E9E:  MOVFF  01,758
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02EA2:  MOVLW  A4
02EA4:  MOVLB  8
02EA6:  MOVWF  x73
02EA8:  MOVLB  0
02EAA:  RCALL  2948
02EAC:  MOVFF  02,75D
02EB0:  MOVFF  01,75C
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02EB4:  MOVLW  A8
02EB6:  MOVLB  8
02EB8:  MOVWF  x73
02EBA:  MOVLB  0
02EBC:  RCALL  2948
02EBE:  MOVFF  02,761
02EC2:  MOVFF  01,760
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02EC6:  MOVLW  84
02EC8:  MOVLB  8
02ECA:  MOVWF  x73
02ECC:  MOVLB  0
02ECE:  RCALL  2948
02ED0:  MOVFF  02,765
02ED4:  MOVFF  01,764
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02ED8:  MOVLW  80
02EDA:  MOVLB  8
02EDC:  MOVWF  x73
02EDE:  MOVLB  0
02EE0:  RCALL  2948
02EE2:  MOVFF  02,7BE
02EE6:  MOVFF  01,7BD
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02EEA:  MOVLW  AC
02EEC:  MOVLB  8
02EEE:  MOVWF  x73
02EF0:  MOVLB  0
02EF2:  RCALL  2948
02EF4:  MOVFF  02,7C2
02EF8:  MOVFF  01,7C1
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02EFC:  MOVLW  7C
02EFE:  MOVLB  8
02F00:  MOVWF  x73
02F02:  MOVLB  0
02F04:  RCALL  2948
02F06:  MOVFF  02,769
02F0A:  MOVFF  01,768
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02F0E:  MOVLW  78
02F10:  MOVLB  8
02F12:  MOVWF  x73
02F14:  MOVLB  0
02F16:  RCALL  2948
02F18:  MOVFF  02,76D
02F1C:  MOVFF  01,76C
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02F20:  MOVLW  74
02F22:  MOVLB  8
02F24:  MOVWF  x73
02F26:  MOVLB  0
02F28:  RCALL  2948
02F2A:  MOVFF  02,771
02F2E:  MOVFF  01,770
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02F32:  MOVLW  70
02F34:  MOVLB  8
02F36:  MOVWF  x73
02F38:  MOVLB  0
02F3A:  RCALL  2948
02F3C:  MOVFF  02,795
02F40:  MOVFF  01,794
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02F44:  MOVLW  B0
02F46:  MOVLB  8
02F48:  MOVWF  x73
02F4A:  MOVLB  0
02F4C:  RCALL  2948
02F4E:  MOVFF  02,775
02F52:  MOVFF  01,774
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
02F56:  MOVLW  B4
02F58:  MOVLB  8
02F5A:  MOVWF  x73
02F5C:  MOVLB  0
02F5E:  RCALL  2948
02F60:  MOVFF  02,7AE
02F64:  MOVFF  01,7AD
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
02F68:  MOVLW  B8
02F6A:  MOVLB  8
02F6C:  MOVWF  x73
02F6E:  MOVLB  0
02F70:  RCALL  2948
02F72:  MOVFF  02,7B2
02F76:  MOVFF  01,7B1
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
02F7A:  MOVLW  BC
02F7C:  MOVLB  8
02F7E:  MOVWF  x73
02F80:  MOVLB  0
02F82:  RCALL  2948
02F84:  MOVFF  02,779
02F88:  MOVFF  01,778
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
02F8C:  MOVLW  C0
02F8E:  MOVLB  8
02F90:  MOVWF  x73
02F92:  MOVLB  0
02F94:  RCALL  2948
02F96:  MOVFF  02,77D
02F9A:  MOVFF  01,77C
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
02F9E:  MOVLW  C4
02FA0:  MOVLB  8
02FA2:  MOVWF  x73
02FA4:  MOVLB  0
02FA6:  RCALL  2948
02FA8:  MOVFF  02,781
02FAC:  MOVFF  01,780
....................     
....................    motor=0; 
02FB0:  MOVLB  7
02FB2:  CLRF   x3C
....................    m_fixed=1; 
02FB4:  MOVLW  01
02FB6:  MOVWF  x3D
....................    m_step_cnt[0]=0; 
02FB8:  CLRF   xA1
02FBA:  CLRF   xA0
02FBC:  CLRF   x9F
02FBE:  CLRF   x9E
....................    m_step_cnt[1]=0; 
02FC0:  CLRF   xA5
02FC2:  CLRF   xA4
02FC4:  CLRF   xA3
02FC6:  CLRF   xA2
....................    e_cha_cnt[0]=0; 
02FC8:  CLRF   xB8
02FCA:  CLRF   xB7
....................    e_cha_cnt[1]=0;  
02FCC:  CLRF   xBA
02FCE:  CLRF   xB9
....................    m_gb_cnt[0]=0; 
02FD0:  CLRF   x97
02FD2:  CLRF   x96
....................    m_gb_cnt[1]=0; 
02FD4:  CLRF   x99
02FD6:  CLRF   x98
....................    e_mode_rst[0]=0; 
02FD8:  CLRF   x9B
02FDA:  CLRF   x9A
....................    e_mode_rst[1]=0;    
02FDC:  CLRF   x9D
02FDE:  CLRF   x9C
....................    e_port_dist[0]=0; 
02FE0:  CLRF   xB4
02FE2:  CLRF   xB3
....................    e_port_dist[1]=0; 
02FE4:  CLRF   xB6
02FE6:  CLRF   xB5
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
02FE8:  MOVFF  773,8B8
02FEC:  MOVFF  772,8B7
02FF0:  MOVFF  75F,8BA
02FF4:  MOVFF  75E,8B9
02FF8:  MOVLB  0
02FFA:  RCALL  2C52
02FFC:  BCF    FD8.0
02FFE:  MOVLB  8
03000:  RLCF   01,W
03002:  MOVLB  7
03004:  MOVWF  xA7
03006:  MOVLB  8
03008:  RLCF   02,W
0300A:  MOVLB  7
0300C:  MOVWF  xA8
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
0300E:  MOVFF  775,8B8
03012:  MOVFF  774,8B7
03016:  MOVFF  761,8BA
0301A:  MOVFF  760,8B9
0301E:  MOVLB  0
03020:  RCALL  2C52
03022:  BCF    FD8.0
03024:  MOVLB  8
03026:  RLCF   01,W
03028:  MOVLB  7
0302A:  MOVWF  xA9
0302C:  MOVLB  8
0302E:  RLCF   02,W
03030:  MOVLB  7
03032:  MOVWF  xAA
03034:  MOVLB  0
03036:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
19B7A:  MOVLW  86
19B7C:  MOVLB  8
19B7E:  MOVWF  xCA
19B80:  CLRF   xCC
19B82:  MOVLW  01
19B84:  MOVWF  xCB
19B86:  MOVLB  0
19B88:  CALL   4F52
....................    write16(ADDR_M1_MODE,FULL); 
19B8C:  MOVLW  8A
19B8E:  MOVLB  8
19B90:  MOVWF  xCA
19B92:  CLRF   xCC
19B94:  CLRF   xCB
19B96:  MOVLB  0
19B98:  CALL   4F52
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
19B9C:  MOVLW  8E
19B9E:  MOVLB  8
19BA0:  MOVWF  xCA
19BA2:  CLRF   xCC
19BA4:  MOVLW  0A
19BA6:  MOVWF  xCB
19BA8:  MOVLB  0
19BAA:  CALL   4F52
....................    write16(ADDR_M1_POS_DIR,0); 
19BAE:  MOVLW  92
19BB0:  MOVLB  8
19BB2:  MOVWF  xCA
19BB4:  CLRF   xCC
19BB6:  CLRF   xCB
19BB8:  MOVLB  0
19BBA:  CALL   4F52
....................    write16(ADDR_M1_PWM_HLD,0); 
19BBE:  MOVLW  96
19BC0:  MOVLB  8
19BC2:  MOVWF  xCA
19BC4:  CLRF   xCC
19BC6:  CLRF   xCB
19BC8:  MOVLB  0
19BCA:  CALL   4F52
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
19BCE:  MOVLW  9A
19BD0:  MOVLB  8
19BD2:  MOVWF  xCA
19BD4:  CLRF   xCC
19BD6:  MOVLW  7F
19BD8:  MOVWF  xCB
19BDA:  MOVLB  0
19BDC:  CALL   4F52
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
19BE0:  MOVLW  9E
19BE2:  MOVLB  8
19BE4:  MOVWF  xCA
19BE6:  MOVLW  17
19BE8:  MOVWF  xCC
19BEA:  MOVLW  70
19BEC:  MOVWF  xCB
19BEE:  MOVLB  0
19BF0:  CALL   4F52
....................    write16(ADDR_E1_CPR,16); 
19BF4:  MOVLW  A2
19BF6:  MOVLB  8
19BF8:  MOVWF  xCA
19BFA:  CLRF   xCC
19BFC:  MOVLW  10
19BFE:  MOVWF  xCB
19C00:  MOVLB  0
19C02:  CALL   4F52
....................    write16(ADDR_E1_PPR,16); 
19C06:  MOVLW  A6
19C08:  MOVLB  8
19C0A:  MOVWF  xCA
19C0C:  CLRF   xCC
19C0E:  MOVLW  10
19C10:  MOVWF  xCB
19C12:  MOVLB  0
19C14:  CALL   4F52
....................    write16(ADDR_E1_MODE,2); 
19C18:  MOVLW  82
19C1A:  MOVLB  8
19C1C:  MOVWF  xCA
19C1E:  CLRF   xCC
19C20:  MOVLW  02
19C22:  MOVWF  xCB
19C24:  MOVLB  0
19C26:  CALL   4F52
....................    write16(ADDR_E1_POS,0); 
19C2A:  MOVLW  7E
19C2C:  MOVLB  8
19C2E:  MOVWF  xCA
19C30:  CLRF   xCC
19C32:  CLRF   xCB
19C34:  MOVLB  0
19C36:  CALL   4F52
....................    write16(ADDR_E1_PORT,0); 
19C3A:  MOVLW  AA
19C3C:  MOVLB  8
19C3E:  MOVWF  xCA
19C40:  CLRF   xCC
19C42:  CLRF   xCB
19C44:  MOVLB  0
19C46:  CALL   4F52
....................    write16(ADDR_E1_TYPE,2); 
19C4A:  MOVLW  7A
19C4C:  MOVLB  8
19C4E:  MOVWF  xCA
19C50:  CLRF   xCC
19C52:  MOVLW  02
19C54:  MOVWF  xCB
19C56:  MOVLB  0
19C58:  CALL   4F52
....................    write16(ADDR_M1_RUN,270); 
19C5C:  MOVLW  76
19C5E:  MOVLB  8
19C60:  MOVWF  xCA
19C62:  MOVLW  01
19C64:  MOVWF  xCC
19C66:  MOVLW  0E
19C68:  MOVWF  xCB
19C6A:  MOVLB  0
19C6C:  CALL   4F52
....................    write16(ADDR_M1_BKLSH,0); 
19C70:  MOVLW  72
19C72:  MOVLB  8
19C74:  MOVWF  xCA
19C76:  CLRF   xCC
19C78:  CLRF   xCB
19C7A:  MOVLB  0
19C7C:  CALL   4F52
....................    write16(ADDR_M1_ERROR,0);   
19C80:  MOVLW  6E
19C82:  MOVLB  8
19C84:  MOVWF  xCA
19C86:  CLRF   xCC
19C88:  CLRF   xCB
19C8A:  MOVLB  0
19C8C:  CALL   4F52
....................    write16(ADDR_M1_SPR,38400); 
19C90:  MOVLW  AE
19C92:  MOVLB  8
19C94:  MOVWF  xCA
19C96:  MOVLW  96
19C98:  MOVWF  xCC
19C9A:  CLRF   xCB
19C9C:  MOVLB  0
19C9E:  CALL   4F52
....................    write16(ADDR_M1_COMP,0); 
19CA2:  MOVLW  B2
19CA4:  MOVLB  8
19CA6:  MOVWF  xCA
19CA8:  CLRF   xCC
19CAA:  CLRF   xCB
19CAC:  MOVLB  0
19CAE:  CALL   4F52
....................    write16(ADDR_M1_LIN_POS,0); 
19CB2:  MOVLW  B6
19CB4:  MOVLB  8
19CB6:  MOVWF  xCA
19CB8:  CLRF   xCC
19CBA:  CLRF   xCB
19CBC:  MOVLB  0
19CBE:  CALL   4F52
....................    write16(ADDR_E1_INDEX,1); 
19CC2:  MOVLW  BA
19CC4:  MOVLB  8
19CC6:  MOVWF  xCA
19CC8:  CLRF   xCC
19CCA:  MOVLW  01
19CCC:  MOVWF  xCB
19CCE:  MOVLB  0
19CD0:  CALL   4F52
....................    write16(ADDR_M1_EVN_SO,0); 
19CD4:  MOVLW  BE
19CD6:  MOVLB  8
19CD8:  MOVWF  xCA
19CDA:  CLRF   xCC
19CDC:  CLRF   xCB
19CDE:  MOVLB  0
19CE0:  CALL   4F52
....................    write16(ADDR_M1_ALIGN_OS,0); 
19CE4:  MOVLW  C2
19CE6:  MOVLB  8
19CE8:  MOVWF  xCA
19CEA:  CLRF   xCC
19CEC:  CLRF   xCB
19CEE:  MOVLB  0
19CF0:  CALL   4F52
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
19CF4:  MOVLW  88
19CF6:  MOVLB  8
19CF8:  MOVWF  xCA
19CFA:  CLRF   xCC
19CFC:  MOVLW  01
19CFE:  MOVWF  xCB
19D00:  MOVLB  0
19D02:  CALL   4F52
....................    write16(ADDR_M2_MODE,HALF); 
19D06:  MOVLW  8C
19D08:  MOVLB  8
19D0A:  MOVWF  xCA
19D0C:  CLRF   xCC
19D0E:  MOVLW  01
19D10:  MOVWF  xCB
19D12:  MOVLB  0
19D14:  CALL   4F52
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
19D18:  MOVLW  90
19D1A:  MOVLB  8
19D1C:  MOVWF  xCA
19D1E:  CLRF   xCC
19D20:  MOVLW  05
19D22:  MOVWF  xCB
19D24:  MOVLB  0
19D26:  CALL   4F52
....................    write16(ADDR_M2_POS_DIR,0); 
19D2A:  MOVLW  94
19D2C:  MOVLB  8
19D2E:  MOVWF  xCA
19D30:  CLRF   xCC
19D32:  CLRF   xCB
19D34:  MOVLB  0
19D36:  CALL   4F52
....................    write16(ADDR_M2_PWM_HLD,0); 
19D3A:  MOVLW  98
19D3C:  MOVLB  8
19D3E:  MOVWF  xCA
19D40:  CLRF   xCC
19D42:  CLRF   xCB
19D44:  MOVLB  0
19D46:  CALL   4F52
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
19D4A:  MOVLW  9C
19D4C:  MOVLB  8
19D4E:  MOVWF  xCA
19D50:  CLRF   xCC
19D52:  MOVLW  7F
19D54:  MOVWF  xCB
19D56:  MOVLB  0
19D58:  CALL   4F52
....................    write16(ADDR_M2_GB_ERR,0); 
19D5C:  MOVLW  A0
19D5E:  MOVLB  8
19D60:  MOVWF  xCA
19D62:  CLRF   xCC
19D64:  CLRF   xCB
19D66:  MOVLB  0
19D68:  CALL   4F52
....................    write16(ADDR_E2_CPR,0); 
19D6C:  MOVLW  A4
19D6E:  MOVLB  8
19D70:  MOVWF  xCA
19D72:  CLRF   xCC
19D74:  CLRF   xCB
19D76:  MOVLB  0
19D78:  CALL   4F52
....................    write16(ADDR_E2_PPR,0);   
19D7C:  MOVLW  A8
19D7E:  MOVLB  8
19D80:  MOVWF  xCA
19D82:  CLRF   xCC
19D84:  CLRF   xCB
19D86:  MOVLB  0
19D88:  CALL   4F52
....................    write16(ADDR_E2_MODE,0); 
19D8C:  MOVLW  84
19D8E:  MOVLB  8
19D90:  MOVWF  xCA
19D92:  CLRF   xCC
19D94:  CLRF   xCB
19D96:  MOVLB  0
19D98:  CALL   4F52
....................    write16(ADDR_E2_POS,0); 
19D9C:  MOVLW  80
19D9E:  MOVLB  8
19DA0:  MOVWF  xCA
19DA2:  CLRF   xCC
19DA4:  CLRF   xCB
19DA6:  MOVLB  0
19DA8:  CALL   4F52
....................    write16(ADDR_E2_PORT,0); 
19DAC:  MOVLW  AC
19DAE:  MOVLB  8
19DB0:  MOVWF  xCA
19DB2:  CLRF   xCC
19DB4:  CLRF   xCB
19DB6:  MOVLB  0
19DB8:  CALL   4F52
....................    write16(ADDR_E2_TYPE,0); 
19DBC:  MOVLW  7C
19DBE:  MOVLB  8
19DC0:  MOVWF  xCA
19DC2:  CLRF   xCC
19DC4:  CLRF   xCB
19DC6:  MOVLB  0
19DC8:  CALL   4F52
....................    write16(ADDR_M2_RUN,0); 
19DCC:  MOVLW  78
19DCE:  MOVLB  8
19DD0:  MOVWF  xCA
19DD2:  CLRF   xCC
19DD4:  CLRF   xCB
19DD6:  MOVLB  0
19DD8:  CALL   4F52
....................    write16(ADDR_M2_BKLSH,0); 
19DDC:  MOVLW  74
19DDE:  MOVLB  8
19DE0:  MOVWF  xCA
19DE2:  CLRF   xCC
19DE4:  CLRF   xCB
19DE6:  MOVLB  0
19DE8:  CALL   4F52
....................    write16(ADDR_M2_ERROR,0);   
19DEC:  MOVLW  70
19DEE:  MOVLB  8
19DF0:  MOVWF  xCA
19DF2:  CLRF   xCC
19DF4:  CLRF   xCB
19DF6:  MOVLB  0
19DF8:  CALL   4F52
....................    write16(ADDR_M2_SPR,0); 
19DFC:  MOVLW  B0
19DFE:  MOVLB  8
19E00:  MOVWF  xCA
19E02:  CLRF   xCC
19E04:  CLRF   xCB
19E06:  MOVLB  0
19E08:  CALL   4F52
....................    write16(ADDR_M2_COMP,0); 
19E0C:  MOVLW  B4
19E0E:  MOVLB  8
19E10:  MOVWF  xCA
19E12:  CLRF   xCC
19E14:  CLRF   xCB
19E16:  MOVLB  0
19E18:  CALL   4F52
....................    write16(ADDR_M2_LIN_POS,0);    
19E1C:  MOVLW  B8
19E1E:  MOVLB  8
19E20:  MOVWF  xCA
19E22:  CLRF   xCC
19E24:  CLRF   xCB
19E26:  MOVLB  0
19E28:  CALL   4F52
....................    write16(ADDR_E2_INDEX,0); 
19E2C:  MOVLW  BC
19E2E:  MOVLB  8
19E30:  MOVWF  xCA
19E32:  CLRF   xCC
19E34:  CLRF   xCB
19E36:  MOVLB  0
19E38:  CALL   4F52
....................    write16(ADDR_M2_EVN_SO,0); 
19E3C:  MOVLW  C0
19E3E:  MOVLB  8
19E40:  MOVWF  xCA
19E42:  CLRF   xCC
19E44:  CLRF   xCB
19E46:  MOVLB  0
19E48:  CALL   4F52
....................    write16(ADDR_M2_ALIGN_OS,0); 
19E4C:  MOVLW  C4
19E4E:  MOVLB  8
19E50:  MOVWF  xCA
19E52:  CLRF   xCC
19E54:  CLRF   xCB
19E56:  MOVLB  0
19E58:  CALL   4F52
....................     
....................    get_step_vars(); 
19E5C:  CALL   2C98
19E60:  GOTO   1A6AA (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
19E64:  MOVLW  86
19E66:  MOVLB  8
19E68:  MOVWF  xCA
19E6A:  CLRF   xCC
19E6C:  MOVLW  01
19E6E:  MOVWF  xCB
19E70:  MOVLB  0
19E72:  CALL   4F52
....................    write16(ADDR_M1_MODE,FULL); 
19E76:  MOVLW  8A
19E78:  MOVLB  8
19E7A:  MOVWF  xCA
19E7C:  CLRF   xCC
19E7E:  CLRF   xCB
19E80:  MOVLB  0
19E82:  CALL   4F52
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
19E86:  MOVLW  8E
19E88:  MOVLB  8
19E8A:  MOVWF  xCA
19E8C:  CLRF   xCC
19E8E:  MOVLW  14
19E90:  MOVWF  xCB
19E92:  MOVLB  0
19E94:  CALL   4F52
....................    write16(ADDR_M1_POS_DIR,1); 
19E98:  MOVLW  92
19E9A:  MOVLB  8
19E9C:  MOVWF  xCA
19E9E:  CLRF   xCC
19EA0:  MOVLW  01
19EA2:  MOVWF  xCB
19EA4:  MOVLB  0
19EA6:  CALL   4F52
....................    write16(ADDR_M1_PWM_HLD,51); 
19EAA:  MOVLW  96
19EAC:  MOVLB  8
19EAE:  MOVWF  xCA
19EB0:  CLRF   xCC
19EB2:  MOVLW  33
19EB4:  MOVWF  xCB
19EB6:  MOVLB  0
19EB8:  CALL   4F52
....................    write16(ADDR_M1_PWM_DRV,511); 
19EBC:  MOVLW  9A
19EBE:  MOVLB  8
19EC0:  MOVWF  xCA
19EC2:  MOVLW  01
19EC4:  MOVWF  xCC
19EC6:  SETF   xCB
19EC8:  MOVLB  0
19ECA:  CALL   4F52
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
19ECE:  MOVLW  9E
19ED0:  MOVLB  8
19ED2:  MOVWF  xCA
19ED4:  MOVLW  02
19ED6:  MOVWF  xCC
19ED8:  MOVLW  9E
19EDA:  MOVWF  xCB
19EDC:  MOVLB  0
19EDE:  CALL   4F52
....................    write16(ADDR_E1_CPR,24); 
19EE2:  MOVLW  A2
19EE4:  MOVLB  8
19EE6:  MOVWF  xCA
19EE8:  CLRF   xCC
19EEA:  MOVLW  18
19EEC:  MOVWF  xCB
19EEE:  MOVLB  0
19EF0:  CALL   4F52
....................    write16(ADDR_E1_PPR,48); 
19EF4:  MOVLW  A6
19EF6:  MOVLB  8
19EF8:  MOVWF  xCA
19EFA:  CLRF   xCC
19EFC:  MOVLW  30
19EFE:  MOVWF  xCB
19F00:  MOVLB  0
19F02:  CALL   4F52
....................    write16(ADDR_E1_MODE,2); 
19F06:  MOVLW  82
19F08:  MOVLB  8
19F0A:  MOVWF  xCA
19F0C:  CLRF   xCC
19F0E:  MOVLW  02
19F10:  MOVWF  xCB
19F12:  MOVLB  0
19F14:  CALL   4F52
....................    write16(ADDR_E1_POS,0); 
19F18:  MOVLW  7E
19F1A:  MOVLB  8
19F1C:  MOVWF  xCA
19F1E:  CLRF   xCC
19F20:  CLRF   xCB
19F22:  MOVLB  0
19F24:  CALL   4F52
....................    write16(ADDR_E1_PORT,0); 
19F28:  MOVLW  AA
19F2A:  MOVLB  8
19F2C:  MOVWF  xCA
19F2E:  CLRF   xCC
19F30:  CLRF   xCB
19F32:  MOVLB  0
19F34:  CALL   4F52
....................    write16(ADDR_E1_TYPE,2); 
19F38:  MOVLW  7A
19F3A:  MOVLB  8
19F3C:  MOVWF  xCA
19F3E:  CLRF   xCC
19F40:  MOVLW  02
19F42:  MOVWF  xCB
19F44:  MOVLB  0
19F46:  CALL   4F52
....................    write16(ADDR_M1_RUN,34); 
19F4A:  MOVLW  76
19F4C:  MOVLB  8
19F4E:  MOVWF  xCA
19F50:  CLRF   xCC
19F52:  MOVLW  22
19F54:  MOVWF  xCB
19F56:  MOVLB  0
19F58:  CALL   4F52
....................    write16(ADDR_M1_BKLSH,0); 
19F5C:  MOVLW  72
19F5E:  MOVLB  8
19F60:  MOVWF  xCA
19F62:  CLRF   xCC
19F64:  CLRF   xCB
19F66:  MOVLB  0
19F68:  CALL   4F52
....................    write16(ADDR_M1_ERROR,0);   
19F6C:  MOVLW  6E
19F6E:  MOVLB  8
19F70:  MOVWF  xCA
19F72:  CLRF   xCC
19F74:  CLRF   xCB
19F76:  MOVLB  0
19F78:  CALL   4F52
....................    write16(ADDR_M1_SPR,6400); 
19F7C:  MOVLW  AE
19F7E:  MOVLB  8
19F80:  MOVWF  xCA
19F82:  MOVLW  19
19F84:  MOVWF  xCC
19F86:  CLRF   xCB
19F88:  MOVLB  0
19F8A:  CALL   4F52
....................    write16(ADDR_M1_COMP,0); 
19F8E:  MOVLW  B2
19F90:  MOVLB  8
19F92:  MOVWF  xCA
19F94:  CLRF   xCC
19F96:  CLRF   xCB
19F98:  MOVLB  0
19F9A:  CALL   4F52
....................    write16(ADDR_M1_LIN_POS,0); 
19F9E:  MOVLW  B6
19FA0:  MOVLB  8
19FA2:  MOVWF  xCA
19FA4:  CLRF   xCC
19FA6:  CLRF   xCB
19FA8:  MOVLB  0
19FAA:  CALL   4F52
....................    write16(ADDR_E1_INDEX,1);    
19FAE:  MOVLW  BA
19FB0:  MOVLB  8
19FB2:  MOVWF  xCA
19FB4:  CLRF   xCC
19FB6:  MOVLW  01
19FB8:  MOVWF  xCB
19FBA:  MOVLB  0
19FBC:  CALL   4F52
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
19FC0:  MOVLW  88
19FC2:  MOVLB  8
19FC4:  MOVWF  xCA
19FC6:  CLRF   xCC
19FC8:  MOVLW  01
19FCA:  MOVWF  xCB
19FCC:  MOVLB  0
19FCE:  CALL   4F52
....................    write16(ADDR_M2_MODE,HALF); 
19FD2:  MOVLW  8C
19FD4:  MOVLB  8
19FD6:  MOVWF  xCA
19FD8:  CLRF   xCC
19FDA:  MOVLW  01
19FDC:  MOVWF  xCB
19FDE:  MOVLB  0
19FE0:  CALL   4F52
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
19FE4:  MOVLW  90
19FE6:  MOVLB  8
19FE8:  MOVWF  xCA
19FEA:  CLRF   xCC
19FEC:  MOVLW  28
19FEE:  MOVWF  xCB
19FF0:  MOVLB  0
19FF2:  CALL   4F52
....................    write16(ADDR_M2_POS_DIR,0); 
19FF6:  MOVLW  94
19FF8:  MOVLB  8
19FFA:  MOVWF  xCA
19FFC:  CLRF   xCC
19FFE:  CLRF   xCB
1A000:  MOVLB  0
1A002:  CALL   4F52
....................    write16(ADDR_M2_PWM_HLD,0); 
1A006:  MOVLW  98
1A008:  MOVLB  8
1A00A:  MOVWF  xCA
1A00C:  CLRF   xCC
1A00E:  CLRF   xCB
1A010:  MOVLB  0
1A012:  CALL   4F52
....................    write16(ADDR_M2_PWM_DRV,511); 
1A016:  MOVLW  9C
1A018:  MOVLB  8
1A01A:  MOVWF  xCA
1A01C:  MOVLW  01
1A01E:  MOVWF  xCC
1A020:  SETF   xCB
1A022:  MOVLB  0
1A024:  CALL   4F52
....................    write16(ADDR_M2_GB_ERR,0); 
1A028:  MOVLW  A0
1A02A:  MOVLB  8
1A02C:  MOVWF  xCA
1A02E:  CLRF   xCC
1A030:  CLRF   xCB
1A032:  MOVLB  0
1A034:  CALL   4F52
....................    write16(ADDR_E2_CPR,0); 
1A038:  MOVLW  A4
1A03A:  MOVLB  8
1A03C:  MOVWF  xCA
1A03E:  CLRF   xCC
1A040:  CLRF   xCB
1A042:  MOVLB  0
1A044:  CALL   4F52
....................    write16(ADDR_E2_PPR,0);   
1A048:  MOVLW  A8
1A04A:  MOVLB  8
1A04C:  MOVWF  xCA
1A04E:  CLRF   xCC
1A050:  CLRF   xCB
1A052:  MOVLB  0
1A054:  CALL   4F52
....................    write16(ADDR_E2_MODE,0); 
1A058:  MOVLW  84
1A05A:  MOVLB  8
1A05C:  MOVWF  xCA
1A05E:  CLRF   xCC
1A060:  CLRF   xCB
1A062:  MOVLB  0
1A064:  CALL   4F52
....................    write16(ADDR_E2_POS,0); 
1A068:  MOVLW  80
1A06A:  MOVLB  8
1A06C:  MOVWF  xCA
1A06E:  CLRF   xCC
1A070:  CLRF   xCB
1A072:  MOVLB  0
1A074:  CALL   4F52
....................    write16(ADDR_E2_PORT,0); 
1A078:  MOVLW  AC
1A07A:  MOVLB  8
1A07C:  MOVWF  xCA
1A07E:  CLRF   xCC
1A080:  CLRF   xCB
1A082:  MOVLB  0
1A084:  CALL   4F52
....................    write16(ADDR_E2_TYPE,0); 
1A088:  MOVLW  7C
1A08A:  MOVLB  8
1A08C:  MOVWF  xCA
1A08E:  CLRF   xCC
1A090:  CLRF   xCB
1A092:  MOVLB  0
1A094:  CALL   4F52
....................    write16(ADDR_M2_RUN,0); 
1A098:  MOVLW  78
1A09A:  MOVLB  8
1A09C:  MOVWF  xCA
1A09E:  CLRF   xCC
1A0A0:  CLRF   xCB
1A0A2:  MOVLB  0
1A0A4:  CALL   4F52
....................    write16(ADDR_M2_BKLSH,0); 
1A0A8:  MOVLW  74
1A0AA:  MOVLB  8
1A0AC:  MOVWF  xCA
1A0AE:  CLRF   xCC
1A0B0:  CLRF   xCB
1A0B2:  MOVLB  0
1A0B4:  CALL   4F52
....................    write16(ADDR_M2_ERROR,0);   
1A0B8:  MOVLW  70
1A0BA:  MOVLB  8
1A0BC:  MOVWF  xCA
1A0BE:  CLRF   xCC
1A0C0:  CLRF   xCB
1A0C2:  MOVLB  0
1A0C4:  CALL   4F52
....................    write16(ADDR_M2_SPR,0); 
1A0C8:  MOVLW  B0
1A0CA:  MOVLB  8
1A0CC:  MOVWF  xCA
1A0CE:  CLRF   xCC
1A0D0:  CLRF   xCB
1A0D2:  MOVLB  0
1A0D4:  CALL   4F52
....................    write16(ADDR_M2_COMP,0); 
1A0D8:  MOVLW  B4
1A0DA:  MOVLB  8
1A0DC:  MOVWF  xCA
1A0DE:  CLRF   xCC
1A0E0:  CLRF   xCB
1A0E2:  MOVLB  0
1A0E4:  CALL   4F52
....................    write16(ADDR_M2_LIN_POS,0);   
1A0E8:  MOVLW  B8
1A0EA:  MOVLB  8
1A0EC:  MOVWF  xCA
1A0EE:  CLRF   xCC
1A0F0:  CLRF   xCB
1A0F2:  MOVLB  0
1A0F4:  CALL   4F52
....................    write16(ADDR_E2_INDEX,0);    
1A0F8:  MOVLW  BC
1A0FA:  MOVLB  8
1A0FC:  MOVWF  xCA
1A0FE:  CLRF   xCC
1A100:  CLRF   xCB
1A102:  MOVLB  0
1A104:  CALL   4F52
....................     
....................    get_step_vars(); 
1A108:  CALL   2C98
1A10C:  GOTO   1A6AA (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A110:  MOVLW  86
1A112:  MOVLB  8
1A114:  MOVWF  xCA
1A116:  CLRF   xCC
1A118:  MOVLW  01
1A11A:  MOVWF  xCB
1A11C:  MOVLB  0
1A11E:  CALL   4F52
....................    write16(ADDR_M1_MODE,FULL); 
1A122:  MOVLW  8A
1A124:  MOVLB  8
1A126:  MOVWF  xCA
1A128:  CLRF   xCC
1A12A:  CLRF   xCB
1A12C:  MOVLB  0
1A12E:  CALL   4F52
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A132:  MOVLW  8E
1A134:  MOVLB  8
1A136:  MOVWF  xCA
1A138:  CLRF   xCC
1A13A:  MOVLW  0A
1A13C:  MOVWF  xCB
1A13E:  MOVLB  0
1A140:  CALL   4F52
....................    write16(ADDR_M1_POS_DIR,0); 
1A144:  MOVLW  92
1A146:  MOVLB  8
1A148:  MOVWF  xCA
1A14A:  CLRF   xCC
1A14C:  CLRF   xCB
1A14E:  MOVLB  0
1A150:  CALL   4F52
....................    write16(ADDR_M1_PWM_HLD,0); 
1A154:  MOVLW  96
1A156:  MOVLB  8
1A158:  MOVWF  xCA
1A15A:  CLRF   xCC
1A15C:  CLRF   xCB
1A15E:  MOVLB  0
1A160:  CALL   4F52
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A164:  MOVLW  9A
1A166:  MOVLB  8
1A168:  MOVWF  xCA
1A16A:  CLRF   xCC
1A16C:  MOVLW  7F
1A16E:  MOVWF  xCB
1A170:  MOVLB  0
1A172:  CALL   4F52
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A176:  MOVLW  9E
1A178:  MOVLB  8
1A17A:  MOVWF  xCA
1A17C:  MOVLW  17
1A17E:  MOVWF  xCC
1A180:  MOVLW  70
1A182:  MOVWF  xCB
1A184:  MOVLB  0
1A186:  CALL   4F52
....................    write16(ADDR_E1_CPR,16); 
1A18A:  MOVLW  A2
1A18C:  MOVLB  8
1A18E:  MOVWF  xCA
1A190:  CLRF   xCC
1A192:  MOVLW  10
1A194:  MOVWF  xCB
1A196:  MOVLB  0
1A198:  CALL   4F52
....................    write16(ADDR_E1_PPR,16); 
1A19C:  MOVLW  A6
1A19E:  MOVLB  8
1A1A0:  MOVWF  xCA
1A1A2:  CLRF   xCC
1A1A4:  MOVLW  10
1A1A6:  MOVWF  xCB
1A1A8:  MOVLB  0
1A1AA:  CALL   4F52
....................    write16(ADDR_E1_MODE,2); 
1A1AE:  MOVLW  82
1A1B0:  MOVLB  8
1A1B2:  MOVWF  xCA
1A1B4:  CLRF   xCC
1A1B6:  MOVLW  02
1A1B8:  MOVWF  xCB
1A1BA:  MOVLB  0
1A1BC:  CALL   4F52
....................    write16(ADDR_E1_POS,0); 
1A1C0:  MOVLW  7E
1A1C2:  MOVLB  8
1A1C4:  MOVWF  xCA
1A1C6:  CLRF   xCC
1A1C8:  CLRF   xCB
1A1CA:  MOVLB  0
1A1CC:  CALL   4F52
....................    write16(ADDR_E1_PORT,0); 
1A1D0:  MOVLW  AA
1A1D2:  MOVLB  8
1A1D4:  MOVWF  xCA
1A1D6:  CLRF   xCC
1A1D8:  CLRF   xCB
1A1DA:  MOVLB  0
1A1DC:  CALL   4F52
....................    write16(ADDR_E1_TYPE,2); 
1A1E0:  MOVLW  7A
1A1E2:  MOVLB  8
1A1E4:  MOVWF  xCA
1A1E6:  CLRF   xCC
1A1E8:  MOVLW  02
1A1EA:  MOVWF  xCB
1A1EC:  MOVLB  0
1A1EE:  CALL   4F52
....................    write16(ADDR_M1_RUN,270); 
1A1F2:  MOVLW  76
1A1F4:  MOVLB  8
1A1F6:  MOVWF  xCA
1A1F8:  MOVLW  01
1A1FA:  MOVWF  xCC
1A1FC:  MOVLW  0E
1A1FE:  MOVWF  xCB
1A200:  MOVLB  0
1A202:  CALL   4F52
....................    write16(ADDR_M1_BKLSH,0); 
1A206:  MOVLW  72
1A208:  MOVLB  8
1A20A:  MOVWF  xCA
1A20C:  CLRF   xCC
1A20E:  CLRF   xCB
1A210:  MOVLB  0
1A212:  CALL   4F52
....................    write16(ADDR_M1_ERROR,0);   
1A216:  MOVLW  6E
1A218:  MOVLB  8
1A21A:  MOVWF  xCA
1A21C:  CLRF   xCC
1A21E:  CLRF   xCB
1A220:  MOVLB  0
1A222:  CALL   4F52
....................    write16(ADDR_M1_SPR,38400); 
1A226:  MOVLW  AE
1A228:  MOVLB  8
1A22A:  MOVWF  xCA
1A22C:  MOVLW  96
1A22E:  MOVWF  xCC
1A230:  CLRF   xCB
1A232:  MOVLB  0
1A234:  CALL   4F52
....................    write16(ADDR_M1_COMP,0); 
1A238:  MOVLW  B2
1A23A:  MOVLB  8
1A23C:  MOVWF  xCA
1A23E:  CLRF   xCC
1A240:  CLRF   xCB
1A242:  MOVLB  0
1A244:  CALL   4F52
....................    write16(ADDR_M1_LIN_POS,0); 
1A248:  MOVLW  B6
1A24A:  MOVLB  8
1A24C:  MOVWF  xCA
1A24E:  CLRF   xCC
1A250:  CLRF   xCB
1A252:  MOVLB  0
1A254:  CALL   4F52
....................    write16(ADDR_E1_INDEX,1); 
1A258:  MOVLW  BA
1A25A:  MOVLB  8
1A25C:  MOVWF  xCA
1A25E:  CLRF   xCC
1A260:  MOVLW  01
1A262:  MOVWF  xCB
1A264:  MOVLB  0
1A266:  CALL   4F52
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A26A:  MOVLW  88
1A26C:  MOVLB  8
1A26E:  MOVWF  xCA
1A270:  CLRF   xCC
1A272:  MOVLW  01
1A274:  MOVWF  xCB
1A276:  MOVLB  0
1A278:  CALL   4F52
....................    write16(ADDR_M2_MODE,HALF); 
1A27C:  MOVLW  8C
1A27E:  MOVLB  8
1A280:  MOVWF  xCA
1A282:  CLRF   xCC
1A284:  MOVLW  01
1A286:  MOVWF  xCB
1A288:  MOVLB  0
1A28A:  CALL   4F52
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A28E:  MOVLW  90
1A290:  MOVLB  8
1A292:  MOVWF  xCA
1A294:  CLRF   xCC
1A296:  MOVLW  64
1A298:  MOVWF  xCB
1A29A:  MOVLB  0
1A29C:  CALL   4F52
....................    write16(ADDR_M2_POS_DIR,0); 
1A2A0:  MOVLW  94
1A2A2:  MOVLB  8
1A2A4:  MOVWF  xCA
1A2A6:  CLRF   xCC
1A2A8:  CLRF   xCB
1A2AA:  MOVLB  0
1A2AC:  CALL   4F52
....................    write16(ADDR_M2_PWM_HLD,0); 
1A2B0:  MOVLW  98
1A2B2:  MOVLB  8
1A2B4:  MOVWF  xCA
1A2B6:  CLRF   xCC
1A2B8:  CLRF   xCB
1A2BA:  MOVLB  0
1A2BC:  CALL   4F52
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A2C0:  MOVLW  9C
1A2C2:  MOVLB  8
1A2C4:  MOVWF  xCA
1A2C6:  CLRF   xCC
1A2C8:  MOVLW  7F
1A2CA:  MOVWF  xCB
1A2CC:  MOVLB  0
1A2CE:  CALL   4F52
....................    write16(ADDR_M2_GB_ERR,0); 
1A2D2:  MOVLW  A0
1A2D4:  MOVLB  8
1A2D6:  MOVWF  xCA
1A2D8:  CLRF   xCC
1A2DA:  CLRF   xCB
1A2DC:  MOVLB  0
1A2DE:  CALL   4F52
....................    write16(ADDR_E2_CPR,0); 
1A2E2:  MOVLW  A4
1A2E4:  MOVLB  8
1A2E6:  MOVWF  xCA
1A2E8:  CLRF   xCC
1A2EA:  CLRF   xCB
1A2EC:  MOVLB  0
1A2EE:  CALL   4F52
....................    write16(ADDR_E2_PPR,0);   
1A2F2:  MOVLW  A8
1A2F4:  MOVLB  8
1A2F6:  MOVWF  xCA
1A2F8:  CLRF   xCC
1A2FA:  CLRF   xCB
1A2FC:  MOVLB  0
1A2FE:  CALL   4F52
....................    write16(ADDR_E2_MODE,0); 
1A302:  MOVLW  84
1A304:  MOVLB  8
1A306:  MOVWF  xCA
1A308:  CLRF   xCC
1A30A:  CLRF   xCB
1A30C:  MOVLB  0
1A30E:  CALL   4F52
....................    write16(ADDR_E2_POS,0); 
1A312:  MOVLW  80
1A314:  MOVLB  8
1A316:  MOVWF  xCA
1A318:  CLRF   xCC
1A31A:  CLRF   xCB
1A31C:  MOVLB  0
1A31E:  CALL   4F52
....................    write16(ADDR_E2_PORT,0); 
1A322:  MOVLW  AC
1A324:  MOVLB  8
1A326:  MOVWF  xCA
1A328:  CLRF   xCC
1A32A:  CLRF   xCB
1A32C:  MOVLB  0
1A32E:  CALL   4F52
....................    write16(ADDR_E2_TYPE,0); 
1A332:  MOVLW  7C
1A334:  MOVLB  8
1A336:  MOVWF  xCA
1A338:  CLRF   xCC
1A33A:  CLRF   xCB
1A33C:  MOVLB  0
1A33E:  CALL   4F52
....................    write16(ADDR_M2_RUN,0); 
1A342:  MOVLW  78
1A344:  MOVLB  8
1A346:  MOVWF  xCA
1A348:  CLRF   xCC
1A34A:  CLRF   xCB
1A34C:  MOVLB  0
1A34E:  CALL   4F52
....................    write16(ADDR_M2_BKLSH,0); 
1A352:  MOVLW  74
1A354:  MOVLB  8
1A356:  MOVWF  xCA
1A358:  CLRF   xCC
1A35A:  CLRF   xCB
1A35C:  MOVLB  0
1A35E:  CALL   4F52
....................    write16(ADDR_M2_ERROR,0);   
1A362:  MOVLW  70
1A364:  MOVLB  8
1A366:  MOVWF  xCA
1A368:  CLRF   xCC
1A36A:  CLRF   xCB
1A36C:  MOVLB  0
1A36E:  CALL   4F52
....................    write16(ADDR_M2_SPR,0); 
1A372:  MOVLW  B0
1A374:  MOVLB  8
1A376:  MOVWF  xCA
1A378:  CLRF   xCC
1A37A:  CLRF   xCB
1A37C:  MOVLB  0
1A37E:  CALL   4F52
....................    write16(ADDR_M2_COMP,0); 
1A382:  MOVLW  B4
1A384:  MOVLB  8
1A386:  MOVWF  xCA
1A388:  CLRF   xCC
1A38A:  CLRF   xCB
1A38C:  MOVLB  0
1A38E:  CALL   4F52
....................    write16(ADDR_M2_LIN_POS,0);    
1A392:  MOVLW  B8
1A394:  MOVLB  8
1A396:  MOVWF  xCA
1A398:  CLRF   xCC
1A39A:  CLRF   xCB
1A39C:  MOVLB  0
1A39E:  CALL   4F52
....................     
....................    get_step_vars(); 
1A3A2:  CALL   2C98
1A3A6:  GOTO   1A6AA (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A3AA:  MOVLW  86
1A3AC:  MOVLB  8
1A3AE:  MOVWF  xCA
1A3B0:  CLRF   xCC
1A3B2:  MOVLW  01
1A3B4:  MOVWF  xCB
1A3B6:  MOVLB  0
1A3B8:  CALL   4F52
....................    write16(ADDR_M1_MODE,FULL); 
1A3BC:  MOVLW  8A
1A3BE:  MOVLB  8
1A3C0:  MOVWF  xCA
1A3C2:  CLRF   xCC
1A3C4:  CLRF   xCB
1A3C6:  MOVLB  0
1A3C8:  CALL   4F52
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1A3CC:  MOVLW  8E
1A3CE:  MOVLB  8
1A3D0:  MOVWF  xCA
1A3D2:  CLRF   xCC
1A3D4:  MOVLW  28
1A3D6:  MOVWF  xCB
1A3D8:  MOVLB  0
1A3DA:  CALL   4F52
....................    write16(ADDR_M1_POS_DIR,1); 
1A3DE:  MOVLW  92
1A3E0:  MOVLB  8
1A3E2:  MOVWF  xCA
1A3E4:  CLRF   xCC
1A3E6:  MOVLW  01
1A3E8:  MOVWF  xCB
1A3EA:  MOVLB  0
1A3EC:  CALL   4F52
....................    write16(ADDR_M1_PWM_HLD,0); 
1A3F0:  MOVLW  96
1A3F2:  MOVLB  8
1A3F4:  MOVWF  xCA
1A3F6:  CLRF   xCC
1A3F8:  CLRF   xCB
1A3FA:  MOVLB  0
1A3FC:  CALL   4F52
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A400:  MOVLW  9A
1A402:  MOVLB  8
1A404:  MOVWF  xCA
1A406:  CLRF   xCC
1A408:  MOVLW  7F
1A40A:  MOVWF  xCB
1A40C:  MOVLB  0
1A40E:  CALL   4F52
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1A412:  MOVLW  9E
1A414:  MOVLB  8
1A416:  MOVWF  xCA
1A418:  MOVLW  02
1A41A:  MOVWF  xCC
1A41C:  MOVLW  9E
1A41E:  MOVWF  xCB
1A420:  MOVLB  0
1A422:  CALL   4F52
....................    write16(ADDR_E1_CPR,500); 
1A426:  MOVLW  A2
1A428:  MOVLB  8
1A42A:  MOVWF  xCA
1A42C:  MOVLW  01
1A42E:  MOVWF  xCC
1A430:  MOVLW  F4
1A432:  MOVWF  xCB
1A434:  MOVLB  0
1A436:  CALL   4F52
....................    write16(ADDR_E1_PPR,50); 
1A43A:  MOVLW  A6
1A43C:  MOVLB  8
1A43E:  MOVWF  xCA
1A440:  CLRF   xCC
1A442:  MOVLW  32
1A444:  MOVWF  xCB
1A446:  MOVLB  0
1A448:  CALL   4F52
....................    write16(ADDR_E1_MODE,2); 
1A44C:  MOVLW  82
1A44E:  MOVLB  8
1A450:  MOVWF  xCA
1A452:  CLRF   xCC
1A454:  MOVLW  02
1A456:  MOVWF  xCB
1A458:  MOVLB  0
1A45A:  CALL   4F52
....................    write16(ADDR_E1_POS,0); 
1A45E:  MOVLW  7E
1A460:  MOVLB  8
1A462:  MOVWF  xCA
1A464:  CLRF   xCC
1A466:  CLRF   xCB
1A468:  MOVLB  0
1A46A:  CALL   4F52
....................    write16(ADDR_E1_PORT,0); 
1A46E:  MOVLW  AA
1A470:  MOVLB  8
1A472:  MOVWF  xCA
1A474:  CLRF   xCC
1A476:  CLRF   xCB
1A478:  MOVLB  0
1A47A:  CALL   4F52
....................    write16(ADDR_E1_TYPE,1); 
1A47E:  MOVLW  7A
1A480:  MOVLB  8
1A482:  MOVWF  xCA
1A484:  CLRF   xCC
1A486:  MOVLW  01
1A488:  MOVWF  xCB
1A48A:  MOVLB  0
1A48C:  CALL   4F52
....................    write16(ADDR_M1_RUN,0); 
1A490:  MOVLW  76
1A492:  MOVLB  8
1A494:  MOVWF  xCA
1A496:  CLRF   xCC
1A498:  CLRF   xCB
1A49A:  MOVLB  0
1A49C:  CALL   4F52
....................    write16(ADDR_M1_BKLSH,1300); 
1A4A0:  MOVLW  72
1A4A2:  MOVLB  8
1A4A4:  MOVWF  xCA
1A4A6:  MOVLW  05
1A4A8:  MOVWF  xCC
1A4AA:  MOVLW  14
1A4AC:  MOVWF  xCB
1A4AE:  MOVLB  0
1A4B0:  CALL   4F52
....................    write16(ADDR_M1_ERROR,0);   
1A4B4:  MOVLW  6E
1A4B6:  MOVLB  8
1A4B8:  MOVWF  xCA
1A4BA:  CLRF   xCC
1A4BC:  CLRF   xCB
1A4BE:  MOVLB  0
1A4C0:  CALL   4F52
....................    write16(ADDR_M1_SPR,20000); 
1A4C4:  MOVLW  AE
1A4C6:  MOVLB  8
1A4C8:  MOVWF  xCA
1A4CA:  MOVLW  4E
1A4CC:  MOVWF  xCC
1A4CE:  MOVLW  20
1A4D0:  MOVWF  xCB
1A4D2:  MOVLB  0
1A4D4:  CALL   4F52
....................    write16(ADDR_M1_COMP,0); 
1A4D8:  MOVLW  B2
1A4DA:  MOVLB  8
1A4DC:  MOVWF  xCA
1A4DE:  CLRF   xCC
1A4E0:  CLRF   xCB
1A4E2:  MOVLB  0
1A4E4:  CALL   4F52
....................    write16(ADDR_M1_LIN_POS,0); 
1A4E8:  MOVLW  B6
1A4EA:  MOVLB  8
1A4EC:  MOVWF  xCA
1A4EE:  CLRF   xCC
1A4F0:  CLRF   xCB
1A4F2:  MOVLB  0
1A4F4:  CALL   4F52
....................    write16(ADDR_E1_INDEX,0); 
1A4F8:  MOVLW  BA
1A4FA:  MOVLB  8
1A4FC:  MOVWF  xCA
1A4FE:  CLRF   xCC
1A500:  CLRF   xCB
1A502:  MOVLB  0
1A504:  CALL   4F52
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A508:  MOVLW  88
1A50A:  MOVLB  8
1A50C:  MOVWF  xCA
1A50E:  CLRF   xCC
1A510:  MOVLW  01
1A512:  MOVWF  xCB
1A514:  MOVLB  0
1A516:  CALL   4F52
....................    write16(ADDR_M2_MODE,HALF); 
1A51A:  MOVLW  8C
1A51C:  MOVLB  8
1A51E:  MOVWF  xCA
1A520:  CLRF   xCC
1A522:  MOVLW  01
1A524:  MOVWF  xCB
1A526:  MOVLB  0
1A528:  CALL   4F52
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A52C:  MOVLW  90
1A52E:  MOVLB  8
1A530:  MOVWF  xCA
1A532:  CLRF   xCC
1A534:  MOVLW  28
1A536:  MOVWF  xCB
1A538:  MOVLB  0
1A53A:  CALL   4F52
....................    write16(ADDR_M2_POS_DIR,1); 
1A53E:  MOVLW  94
1A540:  MOVLB  8
1A542:  MOVWF  xCA
1A544:  CLRF   xCC
1A546:  MOVLW  01
1A548:  MOVWF  xCB
1A54A:  MOVLB  0
1A54C:  CALL   4F52
....................    write16(ADDR_M2_PWM_HLD,0); 
1A550:  MOVLW  98
1A552:  MOVLB  8
1A554:  MOVWF  xCA
1A556:  CLRF   xCC
1A558:  CLRF   xCB
1A55A:  MOVLB  0
1A55C:  CALL   4F52
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A560:  MOVLW  9C
1A562:  MOVLB  8
1A564:  MOVWF  xCA
1A566:  CLRF   xCC
1A568:  MOVLW  7F
1A56A:  MOVWF  xCB
1A56C:  MOVLB  0
1A56E:  CALL   4F52
....................    write16(ADDR_M2_GB_ERR,0); 
1A572:  MOVLW  A0
1A574:  MOVLB  8
1A576:  MOVWF  xCA
1A578:  CLRF   xCC
1A57A:  CLRF   xCB
1A57C:  MOVLB  0
1A57E:  CALL   4F52
....................    write16(ADDR_E2_CPR,0); 
1A582:  MOVLW  A4
1A584:  MOVLB  8
1A586:  MOVWF  xCA
1A588:  CLRF   xCC
1A58A:  CLRF   xCB
1A58C:  MOVLB  0
1A58E:  CALL   4F52
....................    write16(ADDR_E2_PPR,0);   
1A592:  MOVLW  A8
1A594:  MOVLB  8
1A596:  MOVWF  xCA
1A598:  CLRF   xCC
1A59A:  CLRF   xCB
1A59C:  MOVLB  0
1A59E:  CALL   4F52
....................    write16(ADDR_E2_MODE,0); 
1A5A2:  MOVLW  84
1A5A4:  MOVLB  8
1A5A6:  MOVWF  xCA
1A5A8:  CLRF   xCC
1A5AA:  CLRF   xCB
1A5AC:  MOVLB  0
1A5AE:  CALL   4F52
....................    write16(ADDR_E2_POS,0); 
1A5B2:  MOVLW  80
1A5B4:  MOVLB  8
1A5B6:  MOVWF  xCA
1A5B8:  CLRF   xCC
1A5BA:  CLRF   xCB
1A5BC:  MOVLB  0
1A5BE:  CALL   4F52
....................    write16(ADDR_E2_PORT,0); 
1A5C2:  MOVLW  AC
1A5C4:  MOVLB  8
1A5C6:  MOVWF  xCA
1A5C8:  CLRF   xCC
1A5CA:  CLRF   xCB
1A5CC:  MOVLB  0
1A5CE:  CALL   4F52
....................    write16(ADDR_E2_TYPE,0); 
1A5D2:  MOVLW  7C
1A5D4:  MOVLB  8
1A5D6:  MOVWF  xCA
1A5D8:  CLRF   xCC
1A5DA:  CLRF   xCB
1A5DC:  MOVLB  0
1A5DE:  CALL   4F52
....................    write16(ADDR_M2_RUN,0); 
1A5E2:  MOVLW  78
1A5E4:  MOVLB  8
1A5E6:  MOVWF  xCA
1A5E8:  CLRF   xCC
1A5EA:  CLRF   xCB
1A5EC:  MOVLB  0
1A5EE:  CALL   4F52
....................    write16(ADDR_M2_BKLSH,0); 
1A5F2:  MOVLW  74
1A5F4:  MOVLB  8
1A5F6:  MOVWF  xCA
1A5F8:  CLRF   xCC
1A5FA:  CLRF   xCB
1A5FC:  MOVLB  0
1A5FE:  CALL   4F52
....................    write16(ADDR_M2_ERROR,0);   
1A602:  MOVLW  70
1A604:  MOVLB  8
1A606:  MOVWF  xCA
1A608:  CLRF   xCC
1A60A:  CLRF   xCB
1A60C:  MOVLB  0
1A60E:  CALL   4F52
....................    write16(ADDR_M2_SPR,0); 
1A612:  MOVLW  B0
1A614:  MOVLB  8
1A616:  MOVWF  xCA
1A618:  CLRF   xCC
1A61A:  CLRF   xCB
1A61C:  MOVLB  0
1A61E:  CALL   4F52
....................    write16(ADDR_M2_COMP,0); 
1A622:  MOVLW  B4
1A624:  MOVLB  8
1A626:  MOVWF  xCA
1A628:  CLRF   xCC
1A62A:  CLRF   xCB
1A62C:  MOVLB  0
1A62E:  CALL   4F52
....................    write16(ADDR_M2_LIN_POS,0);    
1A632:  MOVLW  B8
1A634:  MOVLB  8
1A636:  MOVWF  xCA
1A638:  CLRF   xCC
1A63A:  CLRF   xCB
1A63C:  MOVLB  0
1A63E:  CALL   4F52
....................    write16(ADDR_E2_INDEX,0); 
1A642:  MOVLW  BC
1A644:  MOVLB  8
1A646:  MOVWF  xCA
1A648:  CLRF   xCC
1A64A:  CLRF   xCB
1A64C:  MOVLB  0
1A64E:  CALL   4F52
....................     
....................    get_step_vars(); 
1A652:  CALL   2C98
1A656:  GOTO   1A6AA (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
02916:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
02918:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
0291A:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
0291C:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
0291E:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
02920:  BCF    F90.5
....................    set_pwm1_duty(0);    
02922:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
02924:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
02926:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
02928:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
0292A:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
0292C:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
0292E:  BCF    F8D.5
....................    set_pwm2_duty(0);  
02930:  MOVLB  F
02932:  CLRF   x4F
....................  
....................    output_low(VENC1); 
02934:  BCF    F8E.6
....................    output_low(VENC2);         
02936:  BCF    F8E.7
....................    output_low(VHBRDG); 
02938:  BCF    F8E.2
0293A:  MOVLB  0
0293C:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
0123C:  BCF    FD8.0
0123E:  MOVLB  7
01240:  RLCF   x3C,W
01242:  CLRF   03
01244:  ADDLW  4A
01246:  MOVWF  FE9
01248:  MOVLW  07
0124A:  ADDWFC 03,W
0124C:  MOVWF  FEA
0124E:  MOVFF  FEC,A10
01252:  MOVF   FED,F
01254:  MOVFF  FEF,A0F
01258:  MOVLB  A
0125A:  MOVF   x0F,F
0125C:  BTFSS  FD8.2
0125E:  BRA    13E6
01260:  MOVF   x10,F
01262:  BTFSS  FD8.2
01264:  BRA    13E6
....................       if(m_way[motor]==POS) { 
01266:  BCF    FD8.0
01268:  MOVLB  7
0126A:  RLCF   x3C,W
0126C:  CLRF   03
0126E:  ADDLW  82
01270:  MOVWF  FE9
01272:  MOVLW  07
01274:  ADDWFC 03,W
01276:  MOVWF  FEA
01278:  MOVFF  FEC,A10
0127C:  MOVF   FED,F
0127E:  MOVFF  FEF,A0F
01282:  MOVLB  A
01284:  MOVF   x0F,F
01286:  BNZ   1320
01288:  MOVF   x10,F
0128A:  BNZ   1320
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
0128C:  BCF    FD8.0
0128E:  MOVLB  7
01290:  RLCF   x3C,W
01292:  CLRF   03
01294:  ADDLW  BB
01296:  MOVWF  FE9
01298:  MOVLW  07
0129A:  ADDWFC 03,W
0129C:  MOVWF  FEA
0129E:  MOVFF  FEC,A10
012A2:  MOVF   FED,F
012A4:  MOVFF  FEF,A0F
012A8:  BCF    FD8.0
012AA:  RLCF   x3C,W
012AC:  CLRF   03
012AE:  ADDLW  5A
012B0:  MOVWF  FE9
012B2:  MOVLW  07
012B4:  ADDWFC 03,W
012B6:  MOVWF  FEA
012B8:  MOVFF  FEC,03
012BC:  MOVF   FED,F
012BE:  MOVFF  FEF,01
012C2:  MOVF   03,W
012C4:  MOVLB  A
012C6:  SUBWF  x10,W
012C8:  BNC   12EC
012CA:  BNZ   12D2
012CC:  MOVF   01,W
012CE:  SUBWF  x0F,W
012D0:  BNC   12EC
012D2:  BCF    FD8.0
012D4:  MOVLB  7
012D6:  RLCF   x3C,W
012D8:  CLRF   03
012DA:  ADDLW  BB
012DC:  MOVWF  FE9
012DE:  MOVLW  07
012E0:  ADDWFC 03,W
012E2:  MOVWF  FEA
012E4:  CLRF   FEC
012E6:  MOVF   FED,F
012E8:  CLRF   FEF
012EA:  MOVLB  A
....................          e_pos[motor]++; 
012EC:  BCF    FD8.0
012EE:  MOVLB  7
012F0:  RLCF   x3C,W
012F2:  CLRF   03
012F4:  ADDLW  BB
012F6:  MOVWF  FE9
012F8:  MOVLW  07
012FA:  ADDWFC 03,W
012FC:  MOVWF  FEA
012FE:  MOVLW  01
01300:  ADDWF  FEE,F
01302:  BNC   1306
01304:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
01306:  BCF    FD8.0
01308:  RLCF   x3C,W
0130A:  CLRF   03
0130C:  ADDLW  96
0130E:  MOVWF  FE9
01310:  MOVLW  07
01312:  ADDWFC 03,W
01314:  MOVWF  FEA
01316:  CLRF   FEC
01318:  MOVF   FED,F
0131A:  CLRF   FEF
....................       } 
0131C:  BRA    13E4
0131E:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
01320:  BCF    FD8.0
01322:  MOVLB  7
01324:  RLCF   x3C,W
01326:  CLRF   03
01328:  ADDLW  82
0132A:  MOVWF  FE9
0132C:  MOVLW  07
0132E:  ADDWFC 03,W
01330:  MOVWF  FEA
01332:  MOVFF  FEC,A10
01336:  MOVF   FED,F
01338:  MOVFF  FEF,A0F
0133C:  MOVLB  A
0133E:  DECFSZ x0F,W
01340:  BRA    13E6
01342:  MOVF   x10,F
01344:  BNZ   13E6
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01346:  BCF    FD8.0
01348:  MOVLB  7
0134A:  RLCF   x3C,W
0134C:  CLRF   03
0134E:  ADDLW  BB
01350:  MOVWF  FE9
01352:  MOVLW  07
01354:  ADDWFC 03,W
01356:  MOVWF  FEA
01358:  MOVFF  FEC,A10
0135C:  MOVF   FED,F
0135E:  MOVFF  FEF,A0F
01362:  MOVLB  A
01364:  MOVF   x0F,F
01366:  BNZ   13B2
01368:  MOVF   x10,F
0136A:  BNZ   13B2
0136C:  BCF    FD8.0
0136E:  MOVLB  7
01370:  RLCF   x3C,W
01372:  CLRF   03
01374:  ADDLW  BB
01376:  MOVWF  01
01378:  MOVLW  07
0137A:  ADDWFC 03,F
0137C:  MOVLB  A
0137E:  MOVFF  03,A10
01382:  BCF    FD8.0
01384:  MOVLB  7
01386:  RLCF   x3C,W
01388:  CLRF   03
0138A:  ADDLW  5A
0138C:  MOVWF  FE9
0138E:  MOVLW  07
01390:  ADDWFC 03,W
01392:  MOVWF  FEA
01394:  MOVFF  FEC,03
01398:  MOVF   FED,F
0139A:  MOVFF  FEF,A11
0139E:  MOVLB  A
013A0:  MOVFF  A10,FEA
013A4:  MOVFF  01,FE9
013A8:  MOVFF  03,FEC
013AC:  MOVF   FED,F
013AE:  MOVFF  A11,FEF
....................          e_pos[motor]--; 
013B2:  BCF    FD8.0
013B4:  MOVLB  7
013B6:  RLCF   x3C,W
013B8:  CLRF   03
013BA:  ADDLW  BB
013BC:  MOVWF  FE9
013BE:  MOVLW  07
013C0:  ADDWFC 03,W
013C2:  MOVWF  FEA
013C4:  MOVLW  FF
013C6:  ADDWF  FEF,F
013C8:  BC    13CE
013CA:  MOVF   FEE,F
013CC:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
013CE:  BCF    FD8.0
013D0:  RLCF   x3C,W
013D2:  CLRF   03
013D4:  ADDLW  96
013D6:  MOVWF  FE9
013D8:  MOVLW  07
013DA:  ADDWFC 03,W
013DC:  MOVWF  FEA
013DE:  CLRF   FEC
013E0:  MOVF   FED,F
013E2:  CLRF   FEF
013E4:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
013E6:  BCF    FD8.0
013E8:  MOVLB  7
013EA:  RLCF   x3C,W
013EC:  CLRF   03
013EE:  ADDLW  4A
013F0:  MOVWF  FE9
013F2:  MOVLW  07
013F4:  ADDWFC 03,W
013F6:  MOVWF  FEA
013F8:  MOVFF  FEC,A10
013FC:  MOVF   FED,F
013FE:  MOVFF  FEF,A0F
01402:  MOVLB  A
01404:  DECFSZ x0F,W
01406:  BRA    158E
01408:  MOVF   x10,F
0140A:  BTFSS  FD8.2
0140C:  BRA    158E
....................       if(m_way[motor]==NEG) { 
0140E:  BCF    FD8.0
01410:  MOVLB  7
01412:  RLCF   x3C,W
01414:  CLRF   03
01416:  ADDLW  82
01418:  MOVWF  FE9
0141A:  MOVLW  07
0141C:  ADDWFC 03,W
0141E:  MOVWF  FEA
01420:  MOVFF  FEC,A10
01424:  MOVF   FED,F
01426:  MOVFF  FEF,A0F
0142A:  MOVLB  A
0142C:  DECFSZ x0F,W
0142E:  BRA    14C8
01430:  MOVF   x10,F
01432:  BNZ   14C8
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
01434:  BCF    FD8.0
01436:  MOVLB  7
01438:  RLCF   x3C,W
0143A:  CLRF   03
0143C:  ADDLW  BB
0143E:  MOVWF  FE9
01440:  MOVLW  07
01442:  ADDWFC 03,W
01444:  MOVWF  FEA
01446:  MOVFF  FEC,A10
0144A:  MOVF   FED,F
0144C:  MOVFF  FEF,A0F
01450:  BCF    FD8.0
01452:  RLCF   x3C,W
01454:  CLRF   03
01456:  ADDLW  5A
01458:  MOVWF  FE9
0145A:  MOVLW  07
0145C:  ADDWFC 03,W
0145E:  MOVWF  FEA
01460:  MOVFF  FEC,03
01464:  MOVF   FED,F
01466:  MOVFF  FEF,01
0146A:  MOVF   03,W
0146C:  MOVLB  A
0146E:  SUBWF  x10,W
01470:  BNC   1494
01472:  BNZ   147A
01474:  MOVF   01,W
01476:  SUBWF  x0F,W
01478:  BNC   1494
0147A:  BCF    FD8.0
0147C:  MOVLB  7
0147E:  RLCF   x3C,W
01480:  CLRF   03
01482:  ADDLW  BB
01484:  MOVWF  FE9
01486:  MOVLW  07
01488:  ADDWFC 03,W
0148A:  MOVWF  FEA
0148C:  CLRF   FEC
0148E:  MOVF   FED,F
01490:  CLRF   FEF
01492:  MOVLB  A
....................          e_pos[motor]++; 
01494:  BCF    FD8.0
01496:  MOVLB  7
01498:  RLCF   x3C,W
0149A:  CLRF   03
0149C:  ADDLW  BB
0149E:  MOVWF  FE9
014A0:  MOVLW  07
014A2:  ADDWFC 03,W
014A4:  MOVWF  FEA
014A6:  MOVLW  01
014A8:  ADDWF  FEE,F
014AA:  BNC   14AE
014AC:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014AE:  BCF    FD8.0
014B0:  RLCF   x3C,W
014B2:  CLRF   03
014B4:  ADDLW  96
014B6:  MOVWF  FE9
014B8:  MOVLW  07
014BA:  ADDWFC 03,W
014BC:  MOVWF  FEA
014BE:  CLRF   FEC
014C0:  MOVF   FED,F
014C2:  CLRF   FEF
....................       } 
014C4:  BRA    158C
014C6:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
014C8:  BCF    FD8.0
014CA:  MOVLB  7
014CC:  RLCF   x3C,W
014CE:  CLRF   03
014D0:  ADDLW  82
014D2:  MOVWF  FE9
014D4:  MOVLW  07
014D6:  ADDWFC 03,W
014D8:  MOVWF  FEA
014DA:  MOVFF  FEC,A10
014DE:  MOVF   FED,F
014E0:  MOVFF  FEF,A0F
014E4:  MOVLB  A
014E6:  MOVF   x0F,F
014E8:  BNZ   158E
014EA:  MOVF   x10,F
014EC:  BNZ   158E
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
014EE:  BCF    FD8.0
014F0:  MOVLB  7
014F2:  RLCF   x3C,W
014F4:  CLRF   03
014F6:  ADDLW  BB
014F8:  MOVWF  FE9
014FA:  MOVLW  07
014FC:  ADDWFC 03,W
014FE:  MOVWF  FEA
01500:  MOVFF  FEC,A10
01504:  MOVF   FED,F
01506:  MOVFF  FEF,A0F
0150A:  MOVLB  A
0150C:  MOVF   x0F,F
0150E:  BNZ   155A
01510:  MOVF   x10,F
01512:  BNZ   155A
01514:  BCF    FD8.0
01516:  MOVLB  7
01518:  RLCF   x3C,W
0151A:  CLRF   03
0151C:  ADDLW  BB
0151E:  MOVWF  01
01520:  MOVLW  07
01522:  ADDWFC 03,F
01524:  MOVLB  A
01526:  MOVFF  03,A10
0152A:  BCF    FD8.0
0152C:  MOVLB  7
0152E:  RLCF   x3C,W
01530:  CLRF   03
01532:  ADDLW  5A
01534:  MOVWF  FE9
01536:  MOVLW  07
01538:  ADDWFC 03,W
0153A:  MOVWF  FEA
0153C:  MOVFF  FEC,03
01540:  MOVF   FED,F
01542:  MOVFF  FEF,A11
01546:  MOVLB  A
01548:  MOVFF  A10,FEA
0154C:  MOVFF  01,FE9
01550:  MOVFF  03,FEC
01554:  MOVF   FED,F
01556:  MOVFF  A11,FEF
....................          e_pos[motor]--; 
0155A:  BCF    FD8.0
0155C:  MOVLB  7
0155E:  RLCF   x3C,W
01560:  CLRF   03
01562:  ADDLW  BB
01564:  MOVWF  FE9
01566:  MOVLW  07
01568:  ADDWFC 03,W
0156A:  MOVWF  FEA
0156C:  MOVLW  FF
0156E:  ADDWF  FEF,F
01570:  BC    1576
01572:  MOVF   FEE,F
01574:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
01576:  BCF    FD8.0
01578:  RLCF   x3C,W
0157A:  CLRF   03
0157C:  ADDLW  96
0157E:  MOVWF  FE9
01580:  MOVLW  07
01582:  ADDWFC 03,W
01584:  MOVWF  FEA
01586:  CLRF   FEC
01588:  MOVF   FED,F
0158A:  CLRF   FEF
0158C:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
0158E:  MOVF   1F,W
01590:  SUBLW  04
01592:  BTFSS  FD8.2
01594:  BRA    16C8
01596:  MOVF   20,F
01598:  BTFSS  FD8.2
0159A:  BRA    16C8
0159C:  BCF    FD8.0
0159E:  MOVLB  7
015A0:  RLCF   x3C,W
015A2:  CLRF   03
015A4:  ADDLW  66
015A6:  MOVWF  FE9
015A8:  MOVLW  07
015AA:  ADDWFC 03,W
015AC:  MOVWF  FEA
015AE:  MOVFF  FEC,A10
015B2:  MOVF   FED,F
015B4:  MOVFF  FEF,A0F
015B8:  MOVLB  A
015BA:  MOVF   x0F,W
015BC:  SUBLW  02
015BE:  BTFSS  FD8.2
015C0:  BRA    16C8
015C2:  MOVF   x10,F
015C4:  BTFSS  FD8.2
015C6:  BRA    16C8
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
015C8:  MOVLW  01
015CA:  MOVLB  7
015CC:  ADDWF  x3C,W
015CE:  MOVLB  A
015D0:  MOVWF  x0F
015D2:  MOVLB  7
015D4:  MOVF   x3C,W
015D6:  MULLW  04
015D8:  MOVF   FF3,W
015DA:  CLRF   03
015DC:  ADDLW  9E
015DE:  MOVWF  FE9
015E0:  MOVLW  07
015E2:  ADDWFC 03,W
015E4:  MOVWF  FEA
015E6:  MOVFF  FEF,A10
015EA:  MOVFF  FEC,A11
015EE:  MOVFF  FEC,A12
015F2:  MOVFF  FEC,A13
015F6:  BCF    FD8.0
015F8:  RLCF   x3C,W
015FA:  CLRF   03
015FC:  ADDLW  B7
015FE:  MOVWF  FE9
01600:  MOVLW  07
01602:  ADDWFC 03,W
01604:  MOVWF  FEA
01606:  MOVFF  FEC,A15
0160A:  MOVF   FED,F
0160C:  MOVFF  FEF,A14
01610:  BCF    FD8.0
01612:  RLCF   x3C,W
01614:  CLRF   03
01616:  ADDLW  BB
01618:  MOVWF  FE9
0161A:  MOVLW  07
0161C:  ADDWFC 03,W
0161E:  MOVWF  FEA
01620:  MOVFF  FEC,A17
01624:  MOVF   FED,F
01626:  MOVFF  FEF,A16
0162A:  MOVLW  6D
0162C:  BTFSS  F9E.4
0162E:  BRA    162C
01630:  MOVWF  FAD
01632:  MOVLW  3A
01634:  BTFSS  F9E.4
01636:  BRA    1634
01638:  MOVWF  FAD
0163A:  MOVFF  A0F,A18
0163E:  MOVLW  1B
01640:  MOVLB  A
01642:  MOVWF  x19
01644:  MOVLB  0
01646:  RCALL  0F88
01648:  MOVLW  2C
0164A:  BTFSS  F9E.4
0164C:  BRA    164A
0164E:  MOVWF  FAD
01650:  MOVFF  7A6,A18
01654:  MOVLW  1B
01656:  MOVLB  A
01658:  MOVWF  x19
0165A:  MOVLB  0
0165C:  RCALL  0F88
0165E:  MOVLW  4B
01660:  MOVWF  FF6
01662:  MOVLW  0F
01664:  MOVWF  FF7
01666:  MOVLW  00
01668:  MOVWF  FF8
0166A:  MOVLW  03
0166C:  MOVLB  A
0166E:  MOVWF  x18
01670:  MOVLB  0
01672:  RCALL  1006
01674:  MOVLW  41
01676:  MOVWF  FE9
01678:  MOVFF  A13,A1B
0167C:  MOVFF  A12,A1A
01680:  MOVFF  A11,A19
01684:  MOVFF  A10,A18
01688:  RCALL  10CC
0168A:  MOVLW  2C
0168C:  BTFSS  F9E.4
0168E:  BRA    168C
01690:  MOVWF  FAD
01692:  MOVLW  10
01694:  MOVWF  FE9
01696:  MOVFF  A15,A19
0169A:  MOVFF  A14,A18
0169E:  RCALL  1188
016A0:  MOVLW  2C
016A2:  BTFSS  F9E.4
016A4:  BRA    16A2
016A6:  MOVWF  FAD
016A8:  MOVLW  10
016AA:  MOVWF  FE9
016AC:  MOVFF  A17,A19
016B0:  MOVFF  A16,A18
016B4:  RCALL  1188
016B6:  MOVLW  0D
016B8:  BTFSS  F9E.4
016BA:  BRA    16B8
016BC:  MOVWF  FAD
016BE:  MOVLW  0A
016C0:  BTFSS  F9E.4
016C2:  BRA    16C0
016C4:  MOVWF  FAD
016C6:  MOVLB  A
....................    }    
016C8:  MOVLB  0
016CA:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A6CC:  MOVLB  7
0A6CE:  MOVF   x3C,W
0A6D0:  XORLW  00
0A6D2:  MOVLB  0
0A6D4:  BZ    A6DC
0A6D6:  XORLW  01
0A6D8:  BZ    A76C
0A6DA:  BRA    A7FA
....................       case 0 : if (e_type[motor]==1) { 
0A6DC:  BCF    FD8.0
0A6DE:  MOVLB  7
0A6E0:  RLCF   x3C,W
0A6E2:  CLRF   03
0A6E4:  ADDLW  66
0A6E6:  MOVWF  FE9
0A6E8:  MOVLW  07
0A6EA:  ADDWFC 03,W
0A6EC:  MOVWF  FEA
0A6EE:  MOVFF  FEC,8A4
0A6F2:  MOVF   FED,F
0A6F4:  MOVFF  FEF,8A3
0A6F8:  MOVLB  8
0A6FA:  DECFSZ xA3,W
0A6FC:  BRA    A71C
0A6FE:  MOVF   xA4,F
0A700:  BNZ   A71C
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A702:  CLRF   03
0A704:  MOVLB  7
0A706:  MOVF   x3C,W
0A708:  ADDLW  C7
0A70A:  MOVWF  FE9
0A70C:  MOVLW  07
0A70E:  ADDWFC 03,W
0A710:  MOVWF  FEA
0A712:  MOVLW  00
0A714:  BTFSC  F81.4
0A716:  MOVLW  01
0A718:  MOVWF  FEF
0A71A:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A71C:  BCF    FD8.0
0A71E:  MOVLB  7
0A720:  RLCF   x3C,W
0A722:  CLRF   03
0A724:  ADDLW  66
0A726:  MOVWF  FE9
0A728:  MOVLW  07
0A72A:  ADDWFC 03,W
0A72C:  MOVWF  FEA
0A72E:  MOVFF  FEC,8A4
0A732:  MOVF   FED,F
0A734:  MOVFF  FEF,8A3
0A738:  MOVLB  8
0A73A:  MOVF   xA3,W
0A73C:  SUBLW  02
0A73E:  BNZ   A768
0A740:  MOVF   xA4,F
0A742:  BNZ   A768
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A744:  CLRF   03
0A746:  MOVLB  7
0A748:  MOVF   x3C,W
0A74A:  ADDLW  C7
0A74C:  MOVWF  FE9
0A74E:  MOVLW  07
0A750:  ADDWFC 03,W
0A752:  MOVWF  FEA
0A754:  MOVLW  00
0A756:  BTFSC  F81.4
0A758:  MOVLW  01
0A75A:  MOVLB  8
0A75C:  MOVWF  xA5
0A75E:  MOVLW  00
0A760:  BTFSC  F81.1
0A762:  MOVLW  01
0A764:  ANDWF  xA5,W
0A766:  MOVWF  FEF
....................                } 
....................          break; 
0A768:  MOVLB  0
0A76A:  BRA    A7FA
....................       case 1 : if (e_type[motor]==1) { 
0A76C:  BCF    FD8.0
0A76E:  MOVLB  7
0A770:  RLCF   x3C,W
0A772:  CLRF   03
0A774:  ADDLW  66
0A776:  MOVWF  FE9
0A778:  MOVLW  07
0A77A:  ADDWFC 03,W
0A77C:  MOVWF  FEA
0A77E:  MOVFF  FEC,8A4
0A782:  MOVF   FED,F
0A784:  MOVFF  FEF,8A3
0A788:  MOVLB  8
0A78A:  DECFSZ xA3,W
0A78C:  BRA    A7AC
0A78E:  MOVF   xA4,F
0A790:  BNZ   A7AC
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A792:  CLRF   03
0A794:  MOVLB  7
0A796:  MOVF   x3C,W
0A798:  ADDLW  C7
0A79A:  MOVWF  FE9
0A79C:  MOVLW  07
0A79E:  ADDWFC 03,W
0A7A0:  MOVWF  FEA
0A7A2:  MOVLW  00
0A7A4:  BTFSC  F81.5
0A7A6:  MOVLW  01
0A7A8:  MOVWF  FEF
0A7AA:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A7AC:  BCF    FD8.0
0A7AE:  MOVLB  7
0A7B0:  RLCF   x3C,W
0A7B2:  CLRF   03
0A7B4:  ADDLW  66
0A7B6:  MOVWF  FE9
0A7B8:  MOVLW  07
0A7BA:  ADDWFC 03,W
0A7BC:  MOVWF  FEA
0A7BE:  MOVFF  FEC,8A4
0A7C2:  MOVF   FED,F
0A7C4:  MOVFF  FEF,8A3
0A7C8:  MOVLB  8
0A7CA:  MOVF   xA3,W
0A7CC:  SUBLW  02
0A7CE:  BNZ   A7F8
0A7D0:  MOVF   xA4,F
0A7D2:  BNZ   A7F8
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A7D4:  CLRF   03
0A7D6:  MOVLB  7
0A7D8:  MOVF   x3C,W
0A7DA:  ADDLW  C7
0A7DC:  MOVWF  FE9
0A7DE:  MOVLW  07
0A7E0:  ADDWFC 03,W
0A7E2:  MOVWF  FEA
0A7E4:  MOVLW  00
0A7E6:  BTFSC  F81.5
0A7E8:  MOVLW  01
0A7EA:  MOVLB  8
0A7EC:  MOVWF  xA5
0A7EE:  MOVLW  00
0A7F0:  BTFSC  F81.2
0A7F2:  MOVLW  01
0A7F4:  ANDWF  xA5,W
0A7F6:  MOVWF  FEF
....................                } 
....................          break; 
0A7F8:  MOVLB  0
....................    } 
0A7FA:  GOTO   A8B4 (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017B8:  MOVLB  7
017BA:  MOVF   x3C,W
017BC:  XORLW  00
017BE:  MOVLB  0
017C0:  BZ    17C8
017C2:  XORLW  01
017C4:  BZ    1858
017C6:  BRA    18E6
....................       case 0 : if (e_type[motor]==1) { 
017C8:  BCF    FD8.0
017CA:  MOVLB  7
017CC:  RLCF   x3C,W
017CE:  CLRF   03
017D0:  ADDLW  66
017D2:  MOVWF  FE9
017D4:  MOVLW  07
017D6:  ADDWFC 03,W
017D8:  MOVWF  FEA
017DA:  MOVFF  FEC,A10
017DE:  MOVF   FED,F
017E0:  MOVFF  FEF,A0F
017E4:  MOVLB  A
017E6:  DECFSZ x0F,W
017E8:  BRA    1808
017EA:  MOVF   x10,F
017EC:  BNZ   1808
....................                   e_ch_n[motor]=input(ENC1_IND); 
017EE:  CLRF   03
017F0:  MOVLB  7
017F2:  MOVF   x3C,W
017F4:  ADDLW  C7
017F6:  MOVWF  FE9
017F8:  MOVLW  07
017FA:  ADDWFC 03,W
017FC:  MOVWF  FEA
017FE:  MOVLW  00
01800:  BTFSC  F81.4
01802:  MOVLW  01
01804:  MOVWF  FEF
01806:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01808:  BCF    FD8.0
0180A:  MOVLB  7
0180C:  RLCF   x3C,W
0180E:  CLRF   03
01810:  ADDLW  66
01812:  MOVWF  FE9
01814:  MOVLW  07
01816:  ADDWFC 03,W
01818:  MOVWF  FEA
0181A:  MOVFF  FEC,A10
0181E:  MOVF   FED,F
01820:  MOVFF  FEF,A0F
01824:  MOVLB  A
01826:  MOVF   x0F,W
01828:  SUBLW  02
0182A:  BNZ   1854
0182C:  MOVF   x10,F
0182E:  BNZ   1854
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
01830:  CLRF   03
01832:  MOVLB  7
01834:  MOVF   x3C,W
01836:  ADDLW  C7
01838:  MOVWF  FE9
0183A:  MOVLW  07
0183C:  ADDWFC 03,W
0183E:  MOVWF  FEA
01840:  MOVLW  00
01842:  BTFSC  F81.4
01844:  MOVLW  01
01846:  MOVLB  A
01848:  MOVWF  x11
0184A:  MOVLW  00
0184C:  BTFSC  F81.1
0184E:  MOVLW  01
01850:  ANDWF  x11,W
01852:  MOVWF  FEF
....................                } 
....................          break; 
01854:  MOVLB  0
01856:  BRA    18E6
....................       case 1 : if (e_type[motor]==1) { 
01858:  BCF    FD8.0
0185A:  MOVLB  7
0185C:  RLCF   x3C,W
0185E:  CLRF   03
01860:  ADDLW  66
01862:  MOVWF  FE9
01864:  MOVLW  07
01866:  ADDWFC 03,W
01868:  MOVWF  FEA
0186A:  MOVFF  FEC,A10
0186E:  MOVF   FED,F
01870:  MOVFF  FEF,A0F
01874:  MOVLB  A
01876:  DECFSZ x0F,W
01878:  BRA    1898
0187A:  MOVF   x10,F
0187C:  BNZ   1898
....................                   e_ch_n[motor]=input(ENC2_IND); 
0187E:  CLRF   03
01880:  MOVLB  7
01882:  MOVF   x3C,W
01884:  ADDLW  C7
01886:  MOVWF  FE9
01888:  MOVLW  07
0188A:  ADDWFC 03,W
0188C:  MOVWF  FEA
0188E:  MOVLW  00
01890:  BTFSC  F81.5
01892:  MOVLW  01
01894:  MOVWF  FEF
01896:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01898:  BCF    FD8.0
0189A:  MOVLB  7
0189C:  RLCF   x3C,W
0189E:  CLRF   03
018A0:  ADDLW  66
018A2:  MOVWF  FE9
018A4:  MOVLW  07
018A6:  ADDWFC 03,W
018A8:  MOVWF  FEA
018AA:  MOVFF  FEC,A10
018AE:  MOVF   FED,F
018B0:  MOVFF  FEF,A0F
018B4:  MOVLB  A
018B6:  MOVF   x0F,W
018B8:  SUBLW  02
018BA:  BNZ   18E4
018BC:  MOVF   x10,F
018BE:  BNZ   18E4
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018C0:  CLRF   03
018C2:  MOVLB  7
018C4:  MOVF   x3C,W
018C6:  ADDLW  C7
018C8:  MOVWF  FE9
018CA:  MOVLW  07
018CC:  ADDWFC 03,W
018CE:  MOVWF  FEA
018D0:  MOVLW  00
018D2:  BTFSC  F81.5
018D4:  MOVLW  01
018D6:  MOVLB  A
018D8:  MOVWF  x11
018DA:  MOVLW  00
018DC:  BTFSC  F81.2
018DE:  MOVLW  01
018E0:  ANDWF  x11,W
018E2:  MOVWF  FEF
....................                } 
....................          break; 
018E4:  MOVLB  0
....................    } 
018E6:  GOTO   1A34 (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
016CC:  BCF    FD8.0
016CE:  MOVLB  7
016D0:  RLCF   x3C,W
016D2:  CLRF   03
016D4:  ADDLW  B7
016D6:  MOVWF  FE9
016D8:  MOVLW  07
016DA:  ADDWFC 03,W
016DC:  MOVWF  FEA
016DE:  MOVLW  01
016E0:  ADDWF  FEE,F
016E2:  BNC   16E6
016E4:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
016E6:  MOVF   xA6,W
016E8:  XORLW  00
016EA:  MOVLB  0
016EC:  BZ    16F8
016EE:  XORLW  01
016F0:  BZ    16FE
016F2:  XORLW  03
016F4:  BZ    1710
016F6:  BRA    173A
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
016F8:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
016FA:  BCF    FF0.0
....................          break; 
016FC:  BRA    173A
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
016FE:  MOVLW  02
01700:  MOVLB  7
01702:  MOVWF  xA6
....................                disable_interrupts(INT_EXT1_L2H); 
01704:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
01706:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01708:  BSF    FF0.3
0170A:  BCF    FF1.5
....................          break; 
0170C:  MOVLB  0
0170E:  BRA    173A
....................       case 2 : edge_mode=1; 
01710:  MOVLW  01
01712:  MOVLB  7
01714:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01716:  BCF    FD8.0
01718:  RLCF   x3C,W
0171A:  CLRF   03
0171C:  ADDLW  B7
0171E:  MOVWF  FE9
01720:  MOVLW  07
01722:  ADDWFC 03,W
01724:  MOVWF  FEA
01726:  MOVLW  FF
01728:  ADDWF  FEF,F
0172A:  BC    1730
0172C:  MOVF   FEE,F
0172E:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
01730:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
01732:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
01734:  BSF    FF0.3
01736:  BSF    FF1.5
....................          break; 
01738:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
0173A:  RCALL  123C
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
0173C:  BCF    FF0.0
0173E:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
01742:  BCF    FD8.0
01744:  MOVLB  7
01746:  RLCF   x3C,W
01748:  CLRF   03
0174A:  ADDLW  B7
0174C:  MOVWF  FE9
0174E:  MOVLW  07
01750:  ADDWFC 03,W
01752:  MOVWF  FEA
01754:  MOVLW  01
01756:  ADDWF  FEE,F
01758:  BNC   175C
0175A:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
0175C:  MOVF   xA6,W
0175E:  XORLW  00
01760:  MOVLB  0
01762:  BZ    176E
01764:  XORLW  01
01766:  BZ    1774
01768:  XORLW  03
0176A:  BZ    1786
0176C:  BRA    17B0
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
0176E:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
01770:  BCF    FF0.1
....................          break; 
01772:  BRA    17B0
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01774:  MOVLW  02
01776:  MOVLB  7
01778:  MOVWF  xA6
....................                disable_interrupts(INT_EXT2_L2H); 
0177A:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
0177C:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
0177E:  BSF    FF0.4
01780:  BCF    FF1.4
....................          break; 
01782:  MOVLB  0
01784:  BRA    17B0
....................       case 2 : edge_mode=1; 
01786:  MOVLW  01
01788:  MOVLB  7
0178A:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
0178C:  BCF    FD8.0
0178E:  RLCF   x3C,W
01790:  CLRF   03
01792:  ADDLW  B7
01794:  MOVWF  FE9
01796:  MOVLW  07
01798:  ADDWFC 03,W
0179A:  MOVWF  FEA
0179C:  MOVLW  FF
0179E:  ADDWF  FEF,F
017A0:  BC    17A6
017A2:  MOVF   FEE,F
017A4:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017A6:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017A8:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017AA:  BSF    FF0.4
017AC:  BSF    FF1.4
....................          break; 
017AE:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017B0:  RCALL  123C
.................... } 
....................  
.................... // motor step timer interrupt 
017B2:  BCF    FF0.1
017B4:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
018EA:  MOVLW  F9
018EC:  MOVWF  FB3
018EE:  MOVLW  C0
018F0:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
018F2:  BCF    FD8.0
018F4:  MOVLB  7
018F6:  RLCF   x3C,W
018F8:  CLRF   03
018FA:  ADDLW  8A
018FC:  MOVWF  FE9
018FE:  MOVLW  07
01900:  ADDWFC 03,W
01902:  MOVWF  FEA
01904:  MOVLW  01
01906:  ADDWF  FEE,F
01908:  BNC   190C
0190A:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
0190C:  BCF    FD8.0
0190E:  RLCF   x3C,W
01910:  CLRF   03
01912:  ADDLW  8A
01914:  MOVWF  FE9
01916:  MOVLW  07
01918:  ADDWFC 03,W
0191A:  MOVWF  FEA
0191C:  MOVFF  FEC,A10
01920:  MOVF   FED,F
01922:  MOVFF  FEF,A0F
01926:  BCF    FD8.0
01928:  RLCF   x3C,W
0192A:  CLRF   03
0192C:  ADDLW  46
0192E:  MOVWF  FE9
01930:  MOVLW  07
01932:  ADDWFC 03,W
01934:  MOVWF  FEA
01936:  MOVFF  FEC,03
0193A:  MOVF   FED,F
0193C:  MOVFF  FEF,01
01940:  MOVF   03,W
01942:  MOVLB  A
01944:  SUBWF  x10,W
01946:  BTFSS  FD8.0
01948:  BRA    1A36
0194A:  BNZ   1954
0194C:  MOVF   01,W
0194E:  SUBWF  x0F,W
01950:  BTFSS  FD8.0
01952:  BRA    1A36
....................    { 
....................       m_step_cnt[motor]++; 
01954:  MOVLB  7
01956:  MOVF   x3C,W
01958:  MULLW  04
0195A:  MOVF   FF3,W
0195C:  CLRF   03
0195E:  ADDLW  9E
01960:  MOVWF  FE9
01962:  MOVLW  07
01964:  ADDWFC 03,W
01966:  MOVWF  FEA
01968:  MOVLW  01
0196A:  ADDWF  FEE,F
0196C:  MOVLW  00
0196E:  ADDWFC FEE,F
01970:  ADDWFC FEE,F
01972:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
01974:  BCF    FD8.0
01976:  RLCF   x3C,W
01978:  CLRF   03
0197A:  ADDLW  96
0197C:  MOVWF  FE9
0197E:  MOVLW  07
01980:  ADDWFC 03,W
01982:  MOVWF  FEA
01984:  MOVLW  01
01986:  ADDWF  FEE,F
01988:  BNC   198C
0198A:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
0198C:  BCF    FD8.0
0198E:  RLCF   x3C,W
01990:  CLRF   03
01992:  ADDLW  8A
01994:  MOVWF  FE9
01996:  MOVLW  07
01998:  ADDWFC 03,W
0199A:  MOVWF  FEA
0199C:  CLRF   FEC
0199E:  MOVF   FED,F
019A0:  CLRF   FEF
....................  
....................       if (motor==0) 
019A2:  MOVF   x3C,F
019A4:  BNZ   19AA
....................       { 
....................          output_toggle(M1_CLOCK); 
019A6:  BTG    F90.4
....................       } 
019A8:  BRA    1A0A
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019AA:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019AC:  BCF    FD8.0
019AE:  RLCF   x3C,W
019B0:  CLRF   03
019B2:  ADDLW  82
019B4:  MOVWF  FE9
019B6:  MOVLW  07
019B8:  ADDWFC 03,W
019BA:  MOVWF  FEA
019BC:  MOVFF  FEC,A10
019C0:  MOVF   FED,F
019C2:  MOVFF  FEF,A0F
019C6:  MOVLB  A
019C8:  MOVF   x0F,F
019CA:  BNZ   19F0
019CC:  MOVF   x10,F
019CE:  BNZ   19F0
019D0:  BCF    FD8.0
019D2:  MOVLB  7
019D4:  RLCF   x3C,W
019D6:  CLRF   03
019D8:  ADDLW  AF
019DA:  MOVWF  FE9
019DC:  MOVLW  07
019DE:  ADDWFC 03,W
019E0:  MOVWF  FEA
019E2:  MOVLW  FF
019E4:  ADDWF  FEF,F
019E6:  BC    19EC
019E8:  MOVF   FEE,F
019EA:  DECF   FED,F
019EC:  BRA    1A0A
019EE:  MOVLB  A
....................          else m_lin_pos[motor]++;          
019F0:  BCF    FD8.0
019F2:  MOVLB  7
019F4:  RLCF   x3C,W
019F6:  CLRF   03
019F8:  ADDLW  AF
019FA:  MOVWF  FE9
019FC:  MOVLW  07
019FE:  ADDWFC 03,W
01A00:  MOVWF  FEA
01A02:  MOVLW  01
01A04:  ADDWF  FEE,F
01A06:  BNC   1A0A
01A08:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A0A:  BCF    FD8.0
01A0C:  RLCF   x3C,W
01A0E:  CLRF   03
01A10:  ADDLW  62
01A12:  MOVWF  FE9
01A14:  MOVLW  07
01A16:  ADDWFC 03,W
01A18:  MOVWF  FEA
01A1A:  MOVFF  FEC,A10
01A1E:  MOVF   FED,F
01A20:  MOVFF  FEF,A0F
01A24:  MOVLB  A
01A26:  MOVF   x0F,W
01A28:  SUBLW  03
01A2A:  BNZ   1A36
01A2C:  MOVF   x10,F
01A2E:  BNZ   1A36
01A30:  MOVLB  0
01A32:  BRA    17B8
01A34:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A36:  BCF    FA1.1
01A38:  BCF    FA1.1
01A3A:  MOVLB  0
01A3C:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
0892E:  BCF    FD8.0
08930:  MOVLB  7
08932:  RLCF   x3C,W
08934:  CLRF   03
08936:  ADDLW  4A
08938:  MOVWF  FE9
0893A:  MOVLW  07
0893C:  ADDWFC 03,W
0893E:  MOVWF  FEA
08940:  MOVFF  FEC,8B5
08944:  MOVF   FED,F
08946:  MOVFF  FEF,8B4
0894A:  MOVLB  8
0894C:  DECFSZ xB4,W
0894E:  BRA    899E
08950:  MOVF   xB5,F
08952:  BNZ   899E
08954:  BCF    FD8.0
08956:  MOVLB  7
08958:  RLCF   x3C,W
0895A:  CLRF   03
0895C:  ADDLW  82
0895E:  MOVWF  01
08960:  MOVLW  07
08962:  ADDWFC 03,F
08964:  MOVFF  01,8B4
08968:  MOVLB  8
0896A:  MOVFF  03,8B5
0896E:  BCF    FD8.0
08970:  MOVLB  7
08972:  RLCF   x3C,W
08974:  CLRF   03
08976:  ADDLW  82
08978:  MOVWF  FE9
0897A:  MOVLW  07
0897C:  ADDWFC 03,W
0897E:  MOVWF  FEA
08980:  MOVF   FEF,F
08982:  BNZ   8988
08984:  MOVF   FEC,F
08986:  BZ    898C
08988:  MOVLW  00
0898A:  BRA    898E
0898C:  MOVLW  01
0898E:  MOVLB  8
08990:  MOVFF  8B5,FEA
08994:  MOVFF  8B4,FE9
08998:  CLRF   FEC
0899A:  MOVF   FED,F
0899C:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
0899E:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
089A0:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
089A2:  BCF    FD8.0
089A4:  MOVLB  7
089A6:  RLCF   x3C,W
089A8:  CLRF   03
089AA:  ADDLW  3E
089AC:  MOVWF  FE9
089AE:  MOVLW  07
089B0:  ADDWFC 03,W
089B2:  MOVWF  FEA
089B4:  MOVF   FEF,F
089B6:  BNZ   89C0
089B8:  MOVF   FEC,F
089BA:  BNZ   89C0
089BC:  BCF    F90.2
089BE:  BRA    89C2
089C0:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
089C2:  BCF    FD8.0
089C4:  RLCF   x3C,W
089C6:  CLRF   03
089C8:  ADDLW  42
089CA:  MOVWF  FE9
089CC:  MOVLW  07
089CE:  ADDWFC 03,W
089D0:  MOVWF  FEA
089D2:  MOVF   FEF,F
089D4:  BNZ   89DE
089D6:  MOVF   FEC,F
089D8:  BNZ   89DE
089DA:  BCF    F90.3
089DC:  BRA    89E0
089DE:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
089E0:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
089E2:  BCF    FD8.0
089E4:  RLCF   x3C,W
089E6:  CLRF   03
089E8:  ADDLW  82
089EA:  MOVWF  FE9
089EC:  MOVLW  07
089EE:  ADDWFC 03,W
089F0:  MOVWF  FEA
089F2:  MOVF   FEF,F
089F4:  BNZ   89FE
089F6:  MOVF   FEC,F
089F8:  BNZ   89FE
089FA:  BCF    F90.5
089FC:  BRA    8A00
089FE:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08A00:  BCF    FD8.0
08A02:  RLCF   x3C,W
08A04:  CLRF   03
08A06:  ADDLW  52
08A08:  MOVWF  FE9
08A0A:  MOVLW  07
08A0C:  ADDWFC 03,W
08A0E:  MOVWF  FEA
08A10:  MOVFF  FEC,8B5
08A14:  MOVF   FED,F
08A16:  MOVFF  FEF,8B4
08A1A:  MOVLB  8
08A1C:  RRCF   xB5,F
08A1E:  RRCF   xB4,F
08A20:  RRCF   xB5,F
08A22:  RRCF   xB4,F
08A24:  RRCF   xB5,F
08A26:  MOVFF  8B4,FBC
08A2A:  RRCF   xB5,F
08A2C:  RRCF   xB5,W
08A2E:  ANDLW  30
08A30:  MOVWF  00
08A32:  MOVF   FBB,W
08A34:  ANDLW  CF
08A36:  IORWF  00,W
08A38:  MOVWF  FBB
08A3A:  MOVLB  0
08A3C:  GOTO   8BC6 (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08A40:  BCF    FD8.0
08A42:  MOVLB  7
08A44:  RLCF   x3C,W
08A46:  CLRF   03
08A48:  ADDLW  4A
08A4A:  MOVWF  FE9
08A4C:  MOVLW  07
08A4E:  ADDWFC 03,W
08A50:  MOVWF  FEA
08A52:  MOVFF  FEC,8B5
08A56:  MOVF   FED,F
08A58:  MOVFF  FEF,8B4
08A5C:  MOVLB  8
08A5E:  DECFSZ xB4,W
08A60:  BRA    8AB0
08A62:  MOVF   xB5,F
08A64:  BNZ   8AB0
08A66:  BCF    FD8.0
08A68:  MOVLB  7
08A6A:  RLCF   x3C,W
08A6C:  CLRF   03
08A6E:  ADDLW  82
08A70:  MOVWF  01
08A72:  MOVLW  07
08A74:  ADDWFC 03,F
08A76:  MOVFF  01,8B4
08A7A:  MOVLB  8
08A7C:  MOVFF  03,8B5
08A80:  BCF    FD8.0
08A82:  MOVLB  7
08A84:  RLCF   x3C,W
08A86:  CLRF   03
08A88:  ADDLW  82
08A8A:  MOVWF  FE9
08A8C:  MOVLW  07
08A8E:  ADDWFC 03,W
08A90:  MOVWF  FEA
08A92:  MOVF   FEF,F
08A94:  BNZ   8A9A
08A96:  MOVF   FEC,F
08A98:  BZ    8A9E
08A9A:  MOVLW  00
08A9C:  BRA    8AA0
08A9E:  MOVLW  01
08AA0:  MOVLB  8
08AA2:  MOVFF  8B5,FEA
08AA6:  MOVFF  8B4,FE9
08AAA:  CLRF   FEC
08AAC:  MOVF   FED,F
08AAE:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08AB0:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08AB2:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08AB4:  BCF    FD8.0
08AB6:  MOVLB  7
08AB8:  RLCF   x3C,W
08ABA:  CLRF   03
08ABC:  ADDLW  3E
08ABE:  MOVWF  FE9
08AC0:  MOVLW  07
08AC2:  ADDWFC 03,W
08AC4:  MOVWF  FEA
08AC6:  MOVF   FEF,F
08AC8:  BNZ   8AD2
08ACA:  MOVF   FEC,F
08ACC:  BNZ   8AD2
08ACE:  BCF    F8D.2
08AD0:  BRA    8AD4
08AD2:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08AD4:  BCF    FD8.0
08AD6:  RLCF   x3C,W
08AD8:  CLRF   03
08ADA:  ADDLW  42
08ADC:  MOVWF  FE9
08ADE:  MOVLW  07
08AE0:  ADDWFC 03,W
08AE2:  MOVWF  FEA
08AE4:  MOVF   FEF,F
08AE6:  BNZ   8AF0
08AE8:  MOVF   FEC,F
08AEA:  BNZ   8AF0
08AEC:  BCF    F8D.3
08AEE:  BRA    8AF2
08AF0:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08AF2:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08AF4:  BCF    FD8.0
08AF6:  RLCF   x3C,W
08AF8:  CLRF   03
08AFA:  ADDLW  82
08AFC:  MOVWF  FE9
08AFE:  MOVLW  07
08B00:  ADDWFC 03,W
08B02:  MOVWF  FEA
08B04:  MOVF   FEF,F
08B06:  BNZ   8B10
08B08:  MOVF   FEC,F
08B0A:  BNZ   8B10
08B0C:  BCF    F8D.5
08B0E:  BRA    8B12
08B10:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08B12:  BCF    FD8.0
08B14:  RLCF   x3C,W
08B16:  CLRF   03
08B18:  ADDLW  52
08B1A:  MOVWF  FE9
08B1C:  MOVLW  07
08B1E:  ADDWFC 03,W
08B20:  MOVWF  FEA
08B22:  MOVFF  FEC,8B5
08B26:  MOVF   FED,F
08B28:  MOVFF  FEF,8B4
08B2C:  MOVLB  8
08B2E:  RRCF   xB5,F
08B30:  RRCF   xB4,F
08B32:  RRCF   xB5,F
08B34:  RRCF   xB4,F
08B36:  RRCF   xB5,F
08B38:  MOVFF  8B4,F4F
08B3C:  RRCF   xB5,F
08B3E:  RRCF   xB5,W
08B40:  ANDLW  30
08B42:  MOVWF  00
08B44:  MOVLB  F
08B46:  MOVF   x4E,W
08B48:  ANDLW  CF
08B4A:  IORWF  00,W
08B4C:  MOVWF  x4E
08B4E:  MOVLB  0
08B50:  GOTO   8BC6 (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
0891A:  MOVLB  8
0891C:  MOVF   xC8,F
0891E:  BZ    8926
....................       output_bit(VENC1,ON); 
08920:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
08922:  BSF    F8E.7
....................    } 
08924:  BRA    892A
....................    else {       
....................       output_bit(VENC1,OFF); 
08926:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
08928:  BCF    F8E.7
....................    } 
0892A:  MOVLB  0
0892C:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08CB4:  MOVLB  8
08CB6:  MOVF   xC9,F
08CB8:  BNZ   8CE0
08CBA:  MOVF   xCA,F
08CBC:  BNZ   8CE0
....................       edge_mode=0; 
08CBE:  MOVLB  7
08CC0:  CLRF   xA6
....................       switch (motor){ 
08CC2:  MOVF   x3C,W
08CC4:  XORLW  00
08CC6:  MOVLB  0
08CC8:  BZ    8CD0
08CCA:  XORLW  01
08CCC:  BZ    8CD8
08CCE:  BRA    8CDE
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08CD0:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08CD2:  BSF    FF0.3
08CD4:  BCF    FF1.5
....................             break; 
08CD6:  BRA    8CDE
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08CD8:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08CDA:  BSF    FF0.4
08CDC:  BCF    FF1.4
....................             break; 
08CDE:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08CE0:  DECFSZ xC9,W
08CE2:  BRA    8D0A
08CE4:  MOVF   xCA,F
08CE6:  BNZ   8D0A
....................       edge_mode=0; 
08CE8:  MOVLB  7
08CEA:  CLRF   xA6
....................       switch (motor){ 
08CEC:  MOVF   x3C,W
08CEE:  XORLW  00
08CF0:  MOVLB  0
08CF2:  BZ    8CFA
08CF4:  XORLW  01
08CF6:  BZ    8D02
08CF8:  BRA    8D08
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08CFA:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08CFC:  BSF    FF0.3
08CFE:  BSF    FF1.5
....................             break; 
08D00:  BRA    8D08
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08D02:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08D04:  BSF    FF0.4
08D06:  BSF    FF1.4
....................             break; 
08D08:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08D0A:  MOVF   xC9,W
08D0C:  SUBLW  02
08D0E:  BNZ   8D60
08D10:  MOVF   xCA,F
08D12:  BNZ   8D60
08D14:  BCF    FD8.0
08D16:  MOVLB  7
08D18:  RLCF   x3C,W
08D1A:  CLRF   03
08D1C:  ADDLW  66
08D1E:  MOVWF  FE9
08D20:  MOVLW  07
08D22:  ADDWFC 03,W
08D24:  MOVWF  FEA
08D26:  MOVFF  FEC,8CC
08D2A:  MOVF   FED,F
08D2C:  MOVFF  FEF,8CB
08D30:  MOVLB  8
08D32:  MOVF   xCB,W
08D34:  SUBLW  02
08D36:  BNZ   8D60
08D38:  MOVF   xCC,F
08D3A:  BNZ   8D60
....................       edge_mode=1; 
08D3C:  MOVLW  01
08D3E:  MOVLB  7
08D40:  MOVWF  xA6
....................       switch (motor){ 
08D42:  MOVF   x3C,W
08D44:  XORLW  00
08D46:  MOVLB  0
08D48:  BZ    8D50
08D4A:  XORLW  01
08D4C:  BZ    8D58
08D4E:  BRA    8D5E
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08D50:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08D52:  BSF    FF0.3
08D54:  BSF    FF1.5
....................             break; 
08D56:  BRA    8D5E
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08D58:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08D5A:  BSF    FF0.4
08D5C:  BSF    FF1.4
....................             break; 
08D5E:  MOVLB  8
....................       }  
....................    }     
08D60:  MOVLB  0
08D62:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08ECA:  MOVLB  7
08ECC:  MOVF   x3C,W
08ECE:  XORLW  00
08ED0:  MOVLB  0
08ED2:  BZ    8EDA
08ED4:  XORLW  01
08ED6:  BZ    8F04
08ED8:  BRA    8F2C
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08EDA:  BCF    FD8.0
08EDC:  MOVLB  7
08EDE:  RLCF   x3C,W
08EE0:  CLRF   03
08EE2:  ADDLW  92
08EE4:  MOVWF  FE9
08EE6:  MOVLW  07
08EE8:  ADDWFC 03,W
08EEA:  MOVWF  FEA
08EEC:  MOVFF  FEC,8CC
08EF0:  MOVF   FED,F
08EF2:  MOVFF  FEF,8CB
08EF6:  MOVLW  6E
08EF8:  MOVLB  8
08EFA:  MOVWF  xCA
08EFC:  MOVLB  0
08EFE:  CALL   4F52
....................          break; 
08F02:  BRA    8F2C
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08F04:  BCF    FD8.0
08F06:  MOVLB  7
08F08:  RLCF   x3C,W
08F0A:  CLRF   03
08F0C:  ADDLW  92
08F0E:  MOVWF  FE9
08F10:  MOVLW  07
08F12:  ADDWFC 03,W
08F14:  MOVWF  FEA
08F16:  MOVFF  FEC,8CC
08F1A:  MOVF   FED,F
08F1C:  MOVFF  FEF,8CB
08F20:  MOVLW  70
08F22:  MOVLB  8
08F24:  MOVWF  xCA
08F26:  MOVLB  0
08F28:  CALL   4F52
....................          break;          
....................    } 
08F2C:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08D64:  MOVLB  8
08D66:  MOVF   xC8,F
08D68:  BNZ   8D86
....................    { 
....................       switch (motor) 
08D6A:  MOVLB  7
08D6C:  MOVF   x3C,W
08D6E:  XORLW  00
08D70:  MOVLB  0
08D72:  BZ    8D7A
08D74:  XORLW  01
08D76:  BZ    8D80
08D78:  BRA    8D84
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08D7A:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08D7C:  BCF    FF0.3
....................             break; 
08D7E:  BRA    8D84
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08D80:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08D82:  BCF    FF0.4
....................             break; 
08D84:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08D86:  DECFSZ xC8,W
08D88:  BRA    8DEE
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08D8A:  BCF    FD8.0
08D8C:  MOVLB  7
08D8E:  RLCF   x3C,W
08D90:  CLRF   03
08D92:  ADDLW  66
08D94:  MOVWF  FE9
08D96:  MOVLW  07
08D98:  ADDWFC 03,W
08D9A:  MOVWF  FEA
08D9C:  MOVFF  FEC,8CA
08DA0:  MOVF   FED,F
08DA2:  MOVFF  FEF,8C9
08DA6:  MOVLB  8
08DA8:  DECFSZ xC9,W
08DAA:  BRA    8DBA
08DAC:  MOVF   xCA,F
08DAE:  BNZ   8DBA
08DB0:  CLRF   xCA
08DB2:  CLRF   xC9
08DB4:  MOVLB  0
08DB6:  RCALL  8CB4
08DB8:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08DBA:  BCF    FD8.0
08DBC:  MOVLB  7
08DBE:  RLCF   x3C,W
08DC0:  CLRF   03
08DC2:  ADDLW  66
08DC4:  MOVWF  FE9
08DC6:  MOVLW  07
08DC8:  ADDWFC 03,W
08DCA:  MOVWF  FEA
08DCC:  MOVFF  FEC,8CA
08DD0:  MOVF   FED,F
08DD2:  MOVFF  FEF,8C9
08DD6:  MOVLB  8
08DD8:  MOVF   xC9,W
08DDA:  SUBLW  02
08DDC:  BNZ   8DEE
08DDE:  MOVF   xCA,F
08DE0:  BNZ   8DEE
08DE2:  CLRF   xCA
08DE4:  MOVLW  01
08DE6:  MOVWF  xC9
08DE8:  MOVLB  0
08DEA:  RCALL  8CB4
08DEC:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08DEE:  MOVF   xC8,W
08DF0:  SUBLW  02
08DF2:  BNZ   8E28
08DF4:  BCF    FD8.0
08DF6:  MOVLB  7
08DF8:  RLCF   x3C,W
08DFA:  CLRF   03
08DFC:  ADDLW  66
08DFE:  MOVWF  FE9
08E00:  MOVLW  07
08E02:  ADDWFC 03,W
08E04:  MOVWF  FEA
08E06:  MOVFF  FEC,8CA
08E0A:  MOVF   FED,F
08E0C:  MOVFF  FEF,8C9
08E10:  MOVLB  8
08E12:  MOVF   xC9,W
08E14:  SUBLW  02
08E16:  BNZ   8E28
08E18:  MOVF   xCA,F
08E1A:  BNZ   8E28
....................    { 
....................       enable_enc_isr(2);   
08E1C:  CLRF   xCA
08E1E:  MOVLW  02
08E20:  MOVWF  xC9
08E22:  MOVLB  0
08E24:  RCALL  8CB4
08E26:  MOVLB  8
....................    } 
08E28:  MOVLB  0
08E2A:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08B54:  BCF    FD8.0
08B56:  MOVLB  7
08B58:  RLCF   x3C,W
08B5A:  CLRF   03
08B5C:  ADDLW  8A
08B5E:  MOVWF  FE9
08B60:  MOVLW  07
08B62:  ADDWFC 03,W
08B64:  MOVWF  FEA
08B66:  CLRF   FEC
08B68:  MOVF   FED,F
08B6A:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08B6C:  BCF    FD8.0
08B6E:  RLCF   x3C,W
08B70:  CLRF   03
08B72:  ADDLW  B7
08B74:  MOVWF  FE9
08B76:  MOVLW  07
08B78:  ADDWFC 03,W
08B7A:  MOVWF  FEA
08B7C:  CLRF   FEC
08B7E:  MOVF   FED,F
08B80:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08B82:  BCF    FD8.0
08B84:  RLCF   x3C,W
08B86:  CLRF   03
08B88:  ADDLW  96
08B8A:  MOVWF  FE9
08B8C:  MOVLW  07
08B8E:  ADDWFC 03,W
08B90:  MOVWF  FEA
08B92:  CLRF   FEC
08B94:  MOVF   FED,F
08B96:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08B98:  BSF    F8E.1
....................    enc_pwr(ON); 
08B9A:  MOVLW  01
08B9C:  MOVLB  8
08B9E:  MOVWF  xC8
08BA0:  MOVLB  0
08BA2:  RCALL  891A
....................    delay_ms(100); 
08BA4:  MOVLW  64
08BA6:  MOVLB  9
08BA8:  MOVWF  xC8
08BAA:  MOVLB  0
08BAC:  CALL   288E
....................     
....................    switch (motor){ 
08BB0:  MOVLB  7
08BB2:  MOVF   x3C,W
08BB4:  XORLW  00
08BB6:  MOVLB  0
08BB8:  BZ    8BC0
08BBA:  XORLW  01
08BBC:  BZ    8BC4
08BBE:  BRA    8BC6
....................       case 0 : motor_setup1(); 
08BC0:  BRA    892E
....................          break; 
08BC2:  BRA    8BC6
....................       case 1 : motor_setup2(); 
08BC4:  BRA    8A40
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08BC6:  BCF    FD8.0
08BC8:  MOVLB  7
08BCA:  RLCF   x3C,W
08BCC:  CLRF   03
08BCE:  ADDLW  86
08BD0:  MOVWF  FE9
08BD2:  MOVLW  07
08BD4:  ADDWFC 03,W
08BD6:  MOVWF  FEA
08BD8:  MOVFF  FEC,8B5
08BDC:  MOVF   FED,F
08BDE:  MOVFF  FEF,8B4
08BE2:  BCF    FD8.0
08BE4:  RLCF   x3C,W
08BE6:  CLRF   03
08BE8:  ADDLW  82
08BEA:  MOVWF  FE9
08BEC:  MOVLW  07
08BEE:  ADDWFC 03,W
08BF0:  MOVWF  FEA
08BF2:  MOVFF  FEC,03
08BF6:  MOVF   FED,F
08BF8:  MOVF   FEF,W
08BFA:  MOVLB  8
08BFC:  SUBWF  xB4,W
08BFE:  BNZ   8C06
08C00:  MOVF   03,W
08C02:  SUBWF  xB5,W
08C04:  BZ    8CAE
....................       m_way_rst[motor]=m_way[motor]; 
08C06:  BCF    FD8.0
08C08:  MOVLB  7
08C0A:  RLCF   x3C,W
08C0C:  CLRF   03
08C0E:  ADDLW  86
08C10:  MOVWF  01
08C12:  MOVLW  07
08C14:  ADDWFC 03,F
08C16:  MOVLB  8
08C18:  MOVFF  03,8B5
08C1C:  BCF    FD8.0
08C1E:  MOVLB  7
08C20:  RLCF   x3C,W
08C22:  CLRF   03
08C24:  ADDLW  82
08C26:  MOVWF  FE9
08C28:  MOVLW  07
08C2A:  ADDWFC 03,W
08C2C:  MOVWF  FEA
08C2E:  MOVFF  FEC,03
08C32:  MOVF   FED,F
08C34:  MOVFF  FEF,8B6
08C38:  MOVLB  8
08C3A:  MOVFF  8B5,FEA
08C3E:  MOVFF  01,FE9
08C42:  MOVFF  03,FEC
08C46:  MOVF   FED,F
08C48:  MOVFF  8B6,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08C4C:  BCF    FD8.0
08C4E:  MOVLB  7
08C50:  RLCF   x3C,W
08C52:  CLRF   03
08C54:  ADDLW  9A
08C56:  MOVWF  01
08C58:  MOVLW  07
08C5A:  ADDWFC 03,F
08C5C:  MOVLB  8
08C5E:  MOVFF  03,8B5
08C62:  BCF    FD8.0
08C64:  MOVLB  7
08C66:  RLCF   x3C,W
08C68:  CLRF   03
08C6A:  ADDLW  62
08C6C:  MOVWF  FE9
08C6E:  MOVLW  07
08C70:  ADDWFC 03,W
08C72:  MOVWF  FEA
08C74:  MOVFF  FEC,03
08C78:  MOVF   FED,F
08C7A:  MOVFF  FEF,8B6
08C7E:  MOVLB  8
08C80:  MOVFF  8B5,FEA
08C84:  MOVFF  01,FE9
08C88:  MOVFF  03,FEC
08C8C:  MOVF   FED,F
08C8E:  MOVFF  8B6,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08C92:  BCF    FD8.0
08C94:  MOVLB  7
08C96:  RLCF   x3C,W
08C98:  CLRF   03
08C9A:  ADDLW  62
08C9C:  MOVWF  FE9
08C9E:  MOVLW  07
08CA0:  ADDWFC 03,W
08CA2:  MOVWF  FEA
08CA4:  CLRF   FEC
08CA6:  MOVF   FED,F
08CA8:  MOVLW  05
08CAA:  MOVWF  FEF
08CAC:  MOVLB  8
....................    } 
08CAE:  MOVLB  0
08CB0:  GOTO   8E2E (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08E2C:  BRA    8B54
....................     
....................    m_comp[motor]=FALSE; 
08E2E:  BCF    FD8.0
08E30:  MOVLB  7
08E32:  RLCF   x3C,W
08E34:  CLRF   03
08E36:  ADDLW  AB
08E38:  MOVWF  FE9
08E3A:  MOVLW  07
08E3C:  ADDWFC 03,W
08E3E:  MOVWF  FEA
08E40:  CLRF   FEC
08E42:  MOVF   FED,F
08E44:  CLRF   FEF
....................     
....................    switch (motor){ 
08E46:  MOVF   x3C,W
08E48:  XORLW  00
08E4A:  MOVLB  0
08E4C:  BZ    8E54
08E4E:  XORLW  01
08E50:  BZ    8E66
08E52:  BRA    8E76
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08E54:  MOVLW  B2
08E56:  MOVLB  8
08E58:  MOVWF  xCA
08E5A:  CLRF   xCC
08E5C:  CLRF   xCB
08E5E:  MOVLB  0
08E60:  CALL   4F52
....................          break; 
08E64:  BRA    8E76
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08E66:  MOVLW  B4
08E68:  MOVLB  8
08E6A:  MOVWF  xCA
08E6C:  CLRF   xCC
08E6E:  CLRF   xCB
08E70:  MOVLB  0
08E72:  CALL   4F52
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08E76:  MOVLB  7
08E78:  MOVF   x3C,W
08E7A:  XORLW  00
08E7C:  MOVLB  0
08E7E:  BZ    8E86
08E80:  XORLW  01
08E82:  BZ    8E8A
08E84:  BRA    8E8C
....................       case 0 : output_bit(M1_ENABLE, ON); 
08E86:  BSF    F90.1
....................          break; 
08E88:  BRA    8E8C
....................       case 1 : output_bit(M2_ENABLE, ON); 
08E8A:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08E8C:  MOVLW  32
08E8E:  MOVLB  9
08E90:  MOVWF  xC8
08E92:  MOVLB  0
08E94:  CALL   288E
....................     
....................    set_timer3(STEP_INTERVAL); 
08E98:  MOVLW  F9
08E9A:  MOVWF  FB3
08E9C:  MOVLW  C0
08E9E:  MOVWF  FB2
....................    enc_isr(int_mode); 
08EA0:  MOVFF  8B3,8C8
08EA4:  RCALL  8D64
....................    clear_interrupt(INT_TIMER3); 
08EA6:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08EA8:  BCF    FD8.0
08EAA:  MOVLB  7
08EAC:  RLCF   x3C,W
08EAE:  CLRF   03
08EB0:  ADDLW  8E
08EB2:  MOVWF  FE9
08EB4:  MOVLW  07
08EB6:  ADDWFC 03,W
08EB8:  MOVWF  FEA
08EBA:  CLRF   FEC
08EBC:  MOVF   FED,F
08EBE:  MOVLW  01
08EC0:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08EC2:  BSF    FA0.1
08EC4:  MOVLB  0
08EC6:  GOTO   A13E (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
08550:  MOVFF  8B6,8BE
08554:  MOVFF  8B5,8BD
08558:  MOVFF  8B4,8BC
0855C:  MOVFF  8B3,8BB
....................    enc_res    = e_cpr[motor]; 
08560:  BCF    FD8.0
08562:  MOVLB  7
08564:  RLCF   x3C,W
08566:  CLRF   03
08568:  ADDLW  5A
0856A:  MOVWF  FE9
0856C:  MOVLW  07
0856E:  ADDWFC 03,W
08570:  MOVWF  FEA
08572:  MOVLB  8
08574:  CLRF   xC2
08576:  CLRF   xC1
08578:  MOVFF  FEC,8C0
0857C:  MOVF   FED,F
0857E:  MOVFF  FEF,8BF
....................    ports      = e_ppr[motor]; 
08582:  BCF    FD8.0
08584:  MOVLB  7
08586:  RLCF   x3C,W
08588:  CLRF   03
0858A:  ADDLW  5E
0858C:  MOVWF  FE9
0858E:  MOVLW  07
08590:  ADDWFC 03,W
08592:  MOVWF  FEA
08594:  MOVLB  8
08596:  CLRF   xCA
08598:  CLRF   xC9
0859A:  MOVFF  FEC,8C8
0859E:  MOVF   FED,F
085A0:  MOVFF  FEF,8C7
....................     
....................    enc_res = enc_res * 1000; 
085A4:  MOVFF  8C2,9D5
085A8:  MOVFF  8C1,9D4
085AC:  MOVFF  8C0,9D3
085B0:  MOVFF  8BF,9D2
085B4:  MOVLB  9
085B6:  CLRF   xD9
085B8:  CLRF   xD8
085BA:  MOVLW  03
085BC:  MOVWF  xD7
085BE:  MOVLW  E8
085C0:  MOVWF  xD6
085C2:  MOVLB  0
085C4:  CALL   4778
085C8:  MOVFF  03,8C2
085CC:  MOVFF  02,8C1
085D0:  MOVFF  01,8C0
085D4:  MOVFF  00,8BF
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
085D8:  BCF    FD8.1
085DA:  CLRF   1B
085DC:  BTFSC  FF2.7
085DE:  BSF    1B.7
085E0:  BCF    FF2.7
085E2:  MOVFF  8C2,A27
085E6:  MOVFF  8C1,A26
085EA:  MOVFF  8C0,A25
085EE:  MOVFF  8BF,A24
085F2:  MOVFF  8CA,A2B
085F6:  MOVFF  8C9,A2A
085FA:  MOVFF  8C8,A29
085FE:  MOVFF  8C7,A28
08602:  CALL   1038
08606:  BTFSC  1B.7
08608:  BSF    FF2.7
0860A:  MOVFF  03,8BA
0860E:  MOVFF  02,8B9
08612:  MOVFF  01,8B8
08616:  MOVFF  00,8B7
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
0861A:  MOVFF  8B6,9D5
0861E:  MOVFF  8B5,9D4
08622:  MOVFF  8B4,9D3
08626:  MOVFF  8B3,9D2
0862A:  MOVFF  8BA,9D9
0862E:  MOVFF  8B9,9D8
08632:  MOVFF  8B8,9D7
08636:  MOVFF  8B7,9D6
0863A:  CALL   4778
0863E:  MOVLB  8
08640:  MOVF   xB7,W
08642:  SUBWF  00,W
08644:  MOVWF  xBB
08646:  MOVF   xB8,W
08648:  SUBWFB 01,W
0864A:  MOVWF  xBC
0864C:  MOVF   xB9,W
0864E:  SUBWFB 02,W
08650:  MOVWF  xBD
08652:  MOVF   xBA,W
08654:  SUBWFB 03,W
08656:  MOVWF  xBE
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
08658:  BCF    FD8.1
0865A:  CLRF   1B
0865C:  BTFSC  FF2.7
0865E:  BSF    1B.7
08660:  BCF    FF2.7
08662:  MOVFF  8BE,A27
08666:  MOVFF  8BD,A26
0866A:  MOVFF  8BC,A25
0866E:  MOVFF  8BB,A24
08672:  MOVLB  A
08674:  CLRF   x2B
08676:  CLRF   x2A
08678:  MOVLW  03
0867A:  MOVWF  x29
0867C:  MOVLW  E8
0867E:  MOVWF  x28
08680:  MOVLB  0
08682:  CALL   1038
08686:  BTFSC  1B.7
08688:  BSF    FF2.7
0868A:  MOVFF  03,8C6
0868E:  MOVFF  02,8C5
08692:  MOVFF  01,8C4
08696:  MOVFF  00,8C3
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
0869A:  MOVFF  8C6,9D5
0869E:  MOVFF  8C5,9D4
086A2:  MOVFF  8C4,9D3
086A6:  MOVFF  8C3,9D2
086AA:  MOVLB  9
086AC:  CLRF   xD9
086AE:  CLRF   xD8
086B0:  MOVLW  03
086B2:  MOVWF  xD7
086B4:  MOVLW  E8
086B6:  MOVWF  xD6
086B8:  MOVLB  0
086BA:  CALL   4778
086BE:  MOVFF  03,8C6
086C2:  MOVFF  02,8C5
086C6:  MOVFF  01,8C4
086CA:  MOVFF  00,8C3
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
086CE:  MOVLB  8
086D0:  MOVF   xC3,W
086D2:  SUBWF  xBB,F
086D4:  MOVF   xC4,W
086D6:  SUBWFB xBC,F
086D8:  MOVF   xC5,W
086DA:  SUBWFB xBD,F
086DC:  MOVF   xC6,W
086DE:  SUBWFB xBE,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
086E0:  BCF    FD8.1
086E2:  CLRF   1B
086E4:  BTFSC  FF2.7
086E6:  BSF    1B.7
086E8:  BCF    FF2.7
086EA:  MOVFF  8C6,A27
086EE:  MOVFF  8C5,A26
086F2:  MOVFF  8C4,A25
086F6:  MOVFF  8C3,A24
086FA:  MOVLB  A
086FC:  CLRF   x2B
086FE:  CLRF   x2A
08700:  MOVLW  03
08702:  MOVWF  x29
08704:  MOVLW  E8
08706:  MOVWF  x28
08708:  MOVLB  0
0870A:  CALL   1038
0870E:  BTFSC  1B.7
08710:  BSF    FF2.7
08712:  MOVFF  03,8C6
08716:  MOVFF  02,8C5
0871A:  MOVFF  01,8C4
0871E:  MOVFF  00,8C3
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
08722:  MOVLB  8
08724:  MOVF   xBE,F
08726:  BNZ   873C
08728:  MOVF   xBD,F
0872A:  BNZ   873C
0872C:  MOVF   xBC,W
0872E:  SUBLW  00
08730:  BC    874C
08732:  XORLW  FF
08734:  BNZ   873C
08736:  MOVF   xBB,W
08738:  SUBLW  F3
0873A:  BC    874C
0873C:  MOVLW  01
0873E:  ADDWF  xC3,F
08740:  BTFSC  FD8.0
08742:  INCF   xC4,F
08744:  BTFSC  FD8.2
08746:  INCF   xC5,F
08748:  BTFSC  FD8.2
0874A:  INCF   xC6,F
....................    return(enc_pos); 
0874C:  MOVFF  8C3,00
08750:  MOVFF  8C4,01
08754:  MOVFF  8C5,02
08758:  MOVFF  8C6,03
0875C:  MOVLB  0
0875E:  GOTO   A0C6 (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
08762:  BCF    FD8.0
08764:  MOVLB  7
08766:  RLCF   x3C,W
08768:  CLRF   03
0876A:  ADDLW  BB
0876C:  MOVWF  FE9
0876E:  MOVLW  07
08770:  ADDWFC 03,W
08772:  MOVWF  FEA
08774:  MOVFF  FEC,03
08778:  MOVF   FED,F
0877A:  MOVFF  FEF,01
0877E:  MOVF   03,W
08780:  MOVLB  8
08782:  SUBWF  xB6,W
08784:  BNC   884C
08786:  BNZ   878E
08788:  MOVF   xB5,W
0878A:  SUBWF  01,W
0878C:  BC    884C
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
0878E:  BCF    FD8.0
08790:  MOVLB  7
08792:  RLCF   x3C,W
08794:  CLRF   03
08796:  ADDLW  BB
08798:  MOVWF  FE9
0879A:  MOVLW  07
0879C:  ADDWFC 03,W
0879E:  MOVWF  FEA
087A0:  MOVFF  FEC,03
087A4:  MOVF   FED,F
087A6:  MOVF   FEF,W
087A8:  MOVLB  8
087AA:  SUBWF  xB5,W
087AC:  MOVWF  xB7
087AE:  MOVF   03,W
087B0:  SUBWFB xB6,W
087B2:  MOVWF  xB8
....................       if (e_pos_r > (e_cpr[motor]/2)) 
087B4:  BCF    FD8.0
087B6:  MOVLB  7
087B8:  RLCF   x3C,W
087BA:  CLRF   03
087BC:  ADDLW  5A
087BE:  MOVWF  FE9
087C0:  MOVLW  07
087C2:  ADDWFC 03,W
087C4:  MOVWF  FEA
087C6:  MOVFF  FEC,8BA
087CA:  MOVF   FED,F
087CC:  MOVFF  FEF,8B9
087D0:  BCF    FD8.0
087D2:  MOVLB  8
087D4:  RRCF   xBA,W
087D6:  MOVWF  03
087D8:  RRCF   xB9,W
087DA:  MOVWF  02
087DC:  MOVWF  01
087DE:  MOVF   03,W
087E0:  SUBWF  xB8,W
087E2:  BNC   8830
087E4:  BNZ   87EC
087E6:  MOVF   xB7,W
087E8:  SUBWF  01,W
087EA:  BC    8830
....................       { 
....................          m_way[motor] = NEG; 
087EC:  BCF    FD8.0
087EE:  MOVLB  7
087F0:  RLCF   x3C,W
087F2:  CLRF   03
087F4:  ADDLW  82
087F6:  MOVWF  FE9
087F8:  MOVLW  07
087FA:  ADDWFC 03,W
087FC:  MOVWF  FEA
087FE:  CLRF   FEC
08800:  MOVF   FED,F
08802:  MOVLW  01
08804:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
08806:  BCF    FD8.0
08808:  RLCF   x3C,W
0880A:  CLRF   03
0880C:  ADDLW  5A
0880E:  MOVWF  FE9
08810:  MOVLW  07
08812:  ADDWFC 03,W
08814:  MOVWF  FEA
08816:  MOVFF  FEC,8BA
0881A:  MOVF   FED,F
0881C:  MOVFF  FEF,8B9
08820:  MOVLB  8
08822:  MOVF   xB7,W
08824:  SUBWF  xB9,W
08826:  MOVWF  xB7
08828:  MOVF   xB8,W
0882A:  SUBWFB xBA,W
0882C:  MOVWF  xB8
....................       } 
0882E:  BRA    884A
....................       else 
....................       { 
....................          m_way[motor] = POS; 
08830:  BCF    FD8.0
08832:  MOVLB  7
08834:  RLCF   x3C,W
08836:  CLRF   03
08838:  ADDLW  82
0883A:  MOVWF  FE9
0883C:  MOVLW  07
0883E:  ADDWFC 03,W
08840:  MOVWF  FEA
08842:  CLRF   FEC
08844:  MOVF   FED,F
08846:  CLRF   FEF
08848:  MOVLB  8
....................       } 
....................    } 
0884A:  BRA    890C
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
0884C:  BCF    FD8.0
0884E:  MOVLB  7
08850:  RLCF   x3C,W
08852:  CLRF   03
08854:  ADDLW  BB
08856:  MOVWF  FE9
08858:  MOVLW  07
0885A:  ADDWFC 03,W
0885C:  MOVWF  FEA
0885E:  MOVFF  FEC,8BA
08862:  MOVF   FED,F
08864:  MOVFF  FEF,8B9
08868:  MOVLB  8
0886A:  MOVF   xB5,W
0886C:  SUBWF  xB9,W
0886E:  MOVWF  xB7
08870:  MOVF   xB6,W
08872:  SUBWFB xBA,W
08874:  MOVWF  xB8
....................       if (e_pos_r > (e_cpr[motor]/2)) 
08876:  BCF    FD8.0
08878:  MOVLB  7
0887A:  RLCF   x3C,W
0887C:  CLRF   03
0887E:  ADDLW  5A
08880:  MOVWF  FE9
08882:  MOVLW  07
08884:  ADDWFC 03,W
08886:  MOVWF  FEA
08888:  MOVFF  FEC,8BA
0888C:  MOVF   FED,F
0888E:  MOVFF  FEF,8B9
08892:  BCF    FD8.0
08894:  MOVLB  8
08896:  RRCF   xBA,W
08898:  MOVWF  03
0889A:  RRCF   xB9,W
0889C:  MOVWF  02
0889E:  MOVWF  01
088A0:  MOVF   03,W
088A2:  SUBWF  xB8,W
088A4:  BNC   88F0
088A6:  BNZ   88AE
088A8:  MOVF   xB7,W
088AA:  SUBWF  01,W
088AC:  BC    88F0
....................       { 
....................          m_way[motor] = POS; 
088AE:  BCF    FD8.0
088B0:  MOVLB  7
088B2:  RLCF   x3C,W
088B4:  CLRF   03
088B6:  ADDLW  82
088B8:  MOVWF  FE9
088BA:  MOVLW  07
088BC:  ADDWFC 03,W
088BE:  MOVWF  FEA
088C0:  CLRF   FEC
088C2:  MOVF   FED,F
088C4:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088C6:  BCF    FD8.0
088C8:  RLCF   x3C,W
088CA:  CLRF   03
088CC:  ADDLW  5A
088CE:  MOVWF  FE9
088D0:  MOVLW  07
088D2:  ADDWFC 03,W
088D4:  MOVWF  FEA
088D6:  MOVFF  FEC,8BA
088DA:  MOVF   FED,F
088DC:  MOVFF  FEF,8B9
088E0:  MOVLB  8
088E2:  MOVF   xB7,W
088E4:  SUBWF  xB9,W
088E6:  MOVWF  xB7
088E8:  MOVF   xB8,W
088EA:  SUBWFB xBA,W
088EC:  MOVWF  xB8
....................       } 
088EE:  BRA    890C
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
088F0:  BCF    FD8.0
088F2:  MOVLB  7
088F4:  RLCF   x3C,W
088F6:  CLRF   03
088F8:  ADDLW  82
088FA:  MOVWF  FE9
088FC:  MOVLW  07
088FE:  ADDWFC 03,W
08900:  MOVWF  FEA
08902:  CLRF   FEC
08904:  MOVF   FED,F
08906:  MOVLW  01
08908:  MOVWF  FEF
0890A:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
0890C:  MOVFF  8B7,01
08910:  MOVFF  8B8,02
08914:  MOVLB  0
08916:  GOTO   A0F2 (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
0901A:  BCF    FD8.0
0901C:  MOVLB  7
0901E:  RLCF   x3C,W
09020:  CLRF   03
09022:  ADDLW  8E
09024:  MOVWF  FE9
09026:  MOVLW  07
09028:  ADDWFC 03,W
0902A:  MOVWF  FEA
0902C:  CLRF   FEC
0902E:  MOVF   FED,F
09030:  CLRF   FEF
....................           
....................    switch (motor){ 
09032:  MOVF   x3C,W
09034:  XORLW  00
09036:  MOVLB  0
09038:  BZ    9040
0903A:  XORLW  01
0903C:  BZ    90AA
0903E:  BRA    9118
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
09040:  BCF    FD8.0
09042:  MOVLB  7
09044:  RLCF   x3C,W
09046:  CLRF   03
09048:  ADDLW  4E
0904A:  MOVWF  FE9
0904C:  MOVLW  07
0904E:  ADDWFC 03,W
09050:  MOVWF  FEA
09052:  MOVFF  FEC,8C9
09056:  MOVF   FED,F
09058:  MOVFF  FEF,8C8
0905C:  MOVLB  8
0905E:  MOVF   xC8,F
09060:  BNZ   9066
09062:  MOVF   xC9,F
09064:  BZ    90A4
09066:  BCF    FD8.0
09068:  MOVLB  7
0906A:  RLCF   x3C,W
0906C:  CLRF   03
0906E:  ADDLW  4E
09070:  MOVWF  FE9
09072:  MOVLW  07
09074:  ADDWFC 03,W
09076:  MOVWF  FEA
09078:  MOVFF  FEC,8C9
0907C:  MOVF   FED,F
0907E:  MOVFF  FEF,8C8
09082:  MOVLB  8
09084:  RRCF   xC9,F
09086:  RRCF   xC8,F
09088:  RRCF   xC9,F
0908A:  RRCF   xC8,F
0908C:  RRCF   xC9,F
0908E:  MOVFF  8C8,FBC
09092:  RRCF   xC9,F
09094:  RRCF   xC9,W
09096:  ANDLW  30
09098:  MOVWF  00
0909A:  MOVF   FBB,W
0909C:  ANDLW  CF
0909E:  IORWF  00,W
090A0:  MOVWF  FBB
090A2:  BRA    90A6
....................                else output_bit(M1_ENABLE, OFF); 
090A4:  BCF    F90.1
....................          break;   
090A6:  MOVLB  0
090A8:  BRA    9118
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
090AA:  BCF    FD8.0
090AC:  MOVLB  7
090AE:  RLCF   x3C,W
090B0:  CLRF   03
090B2:  ADDLW  4E
090B4:  MOVWF  FE9
090B6:  MOVLW  07
090B8:  ADDWFC 03,W
090BA:  MOVWF  FEA
090BC:  MOVFF  FEC,8C9
090C0:  MOVF   FED,F
090C2:  MOVFF  FEF,8C8
090C6:  MOVLB  8
090C8:  MOVF   xC8,F
090CA:  BNZ   90D0
090CC:  MOVF   xC9,F
090CE:  BZ    9112
090D0:  BCF    FD8.0
090D2:  MOVLB  7
090D4:  RLCF   x3C,W
090D6:  CLRF   03
090D8:  ADDLW  4E
090DA:  MOVWF  FE9
090DC:  MOVLW  07
090DE:  ADDWFC 03,W
090E0:  MOVWF  FEA
090E2:  MOVFF  FEC,8C9
090E6:  MOVF   FED,F
090E8:  MOVFF  FEF,8C8
090EC:  MOVLB  8
090EE:  RRCF   xC9,F
090F0:  RRCF   xC8,F
090F2:  RRCF   xC9,F
090F4:  RRCF   xC8,F
090F6:  RRCF   xC9,F
090F8:  MOVFF  8C8,F4F
090FC:  RRCF   xC9,F
090FE:  RRCF   xC9,W
09100:  ANDLW  30
09102:  MOVWF  00
09104:  MOVLB  F
09106:  MOVF   x4E,W
09108:  ANDLW  CF
0910A:  IORWF  00,W
0910C:  MOVWF  x4E
0910E:  BRA    9116
09110:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
09112:  BCF    F8D.1
09114:  MOVLB  F
....................          break; 
09116:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
09118:  BCF    FA0.1
....................    enc_isr(OFF); 
0911A:  MOVLB  8
0911C:  CLRF   xC8
0911E:  MOVLB  0
09120:  RCALL  8D64
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
09122:  MOVLB  7
09124:  MOVF   x4E,F
09126:  BNZ   9136
09128:  MOVF   x4F,F
0912A:  BNZ   9136
0912C:  MOVF   x50,F
0912E:  BNZ   9136
09130:  MOVF   x51,F
09132:  BNZ   9136
....................    { 
....................       output_bit(VMOT,OFF); 
09134:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
09136:  MOVLB  8
09138:  CLRF   xC8
0913A:  MOVLB  0
0913C:  CALL   891A
....................  
....................    if(success==TRUE) 
09140:  MOVLB  8
09142:  DECFSZ xC7,W
09144:  BRA    92E0
....................    { 
....................       m_error[motor]=FALSE; 
09146:  BCF    FD8.0
09148:  MOVLB  7
0914A:  RLCF   x3C,W
0914C:  CLRF   03
0914E:  ADDLW  92
09150:  MOVWF  FE9
09152:  MOVLW  07
09154:  ADDWFC 03,W
09156:  MOVWF  FEA
09158:  CLRF   FEC
0915A:  MOVF   FED,F
0915C:  CLRF   FEF
....................       wrt_m_error(); 
0915E:  MOVLB  0
09160:  RCALL  8ECA
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
09162:  BCF    FD8.0
09164:  MOVLB  7
09166:  RLCF   x3C,W
09168:  CLRF   03
0916A:  ADDLW  62
0916C:  MOVWF  FE9
0916E:  MOVLW  07
09170:  ADDWFC 03,W
09172:  MOVWF  FEA
09174:  MOVFF  FEC,8C9
09178:  MOVF   FED,F
0917A:  MOVFF  FEF,8C8
0917E:  MOVLB  8
09180:  MOVF   xC8,W
09182:  SUBLW  03
09184:  BNZ   91BC
09186:  MOVF   xC9,F
09188:  BNZ   91BC
....................       { 
....................          e_pos[motor] = 0; 
0918A:  BCF    FD8.0
0918C:  MOVLB  7
0918E:  RLCF   x3C,W
09190:  CLRF   03
09192:  ADDLW  BB
09194:  MOVWF  FE9
09196:  MOVLW  07
09198:  ADDWFC 03,W
0919A:  MOVWF  FEA
0919C:  CLRF   FEC
0919E:  MOVF   FED,F
091A0:  CLRF   FEF
....................          e_port[motor] = 1; 
091A2:  BCF    FD8.0
091A4:  RLCF   x3C,W
091A6:  CLRF   03
091A8:  ADDLW  BF
091AA:  MOVWF  FE9
091AC:  MOVLW  07
091AE:  ADDWFC 03,W
091B0:  MOVWF  FEA
091B2:  CLRF   FEC
091B4:  MOVF   FED,F
091B6:  MOVLW  01
091B8:  MOVWF  FEF
091BA:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
091BC:  BCF    FD8.0
091BE:  MOVLB  7
091C0:  RLCF   x3C,W
091C2:  CLRF   03
091C4:  ADDLW  62
091C6:  MOVWF  FE9
091C8:  MOVLW  07
091CA:  ADDWFC 03,W
091CC:  MOVWF  FEA
091CE:  MOVFF  FEC,8C9
091D2:  MOVF   FED,F
091D4:  MOVFF  FEF,8C8
091D8:  MOVLB  8
091DA:  MOVF   xC8,W
091DC:  SUBLW  02
091DE:  BNZ   922A
091E0:  MOVF   xC9,F
091E2:  BNZ   922A
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
091E4:  BCF    FD8.0
091E6:  MOVLB  7
091E8:  RLCF   x3C,W
091EA:  CLRF   03
091EC:  ADDLW  BF
091EE:  MOVWF  01
091F0:  MOVLW  07
091F2:  ADDWFC 03,F
091F4:  MOVLB  8
091F6:  MOVFF  03,8C9
091FA:  BCF    FD8.0
091FC:  MOVLB  7
091FE:  RLCF   x3C,W
09200:  CLRF   03
09202:  ADDLW  C3
09204:  MOVWF  FE9
09206:  MOVLW  07
09208:  ADDWFC 03,W
0920A:  MOVWF  FEA
0920C:  MOVFF  FEC,03
09210:  MOVF   FED,F
09212:  MOVFF  FEF,8CA
09216:  MOVLB  8
09218:  MOVFF  8C9,FEA
0921C:  MOVFF  01,FE9
09220:  MOVFF  03,FEC
09224:  MOVF   FED,F
09226:  MOVFF  8CA,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
0922A:  BCF    FD8.0
0922C:  MOVLB  7
0922E:  RLCF   x3C,W
09230:  CLRF   03
09232:  ADDLW  62
09234:  MOVWF  FE9
09236:  MOVLW  07
09238:  ADDWFC 03,W
0923A:  MOVWF  FEA
0923C:  MOVFF  FEC,8C9
09240:  MOVF   FED,F
09242:  MOVFF  FEF,8C8
09246:  MOVLB  8
09248:  MOVF   xC8,W
0924A:  SUBLW  02
0924C:  BNZ   9252
0924E:  MOVF   xC9,F
09250:  BZ    927A
09252:  BCF    FD8.0
09254:  MOVLB  7
09256:  RLCF   x3C,W
09258:  CLRF   03
0925A:  ADDLW  62
0925C:  MOVWF  FE9
0925E:  MOVLW  07
09260:  ADDWFC 03,W
09262:  MOVWF  FEA
09264:  MOVFF  FEC,8C9
09268:  MOVF   FED,F
0926A:  MOVFF  FEF,8C8
0926E:  MOVLB  8
09270:  MOVF   xC8,W
09272:  SUBLW  03
09274:  BNZ   92DE
09276:  MOVF   xC9,F
09278:  BNZ   92DE
....................       { 
....................          switch(motor) 
0927A:  MOVLB  7
0927C:  MOVF   x3C,W
0927E:  XORLW  00
09280:  MOVLB  0
09282:  BZ    928A
09284:  XORLW  01
09286:  BZ    92B4
09288:  BRA    92DC
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
0928A:  MOVLW  7E
0928C:  MOVLB  8
0928E:  MOVWF  xCA
09290:  MOVFF  7BC,8CC
09294:  MOVFF  7BB,8CB
09298:  MOVLB  0
0929A:  CALL   4F52
....................                      write16(ADDR_E1_PORT,e_port[0]); 
0929E:  MOVLW  AA
092A0:  MOVLB  8
092A2:  MOVWF  xCA
092A4:  MOVFF  7C0,8CC
092A8:  MOVFF  7BF,8CB
092AC:  MOVLB  0
092AE:  CALL   4F52
....................                break; 
092B2:  BRA    92DC
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
092B4:  MOVLW  80
092B6:  MOVLB  8
092B8:  MOVWF  xCA
092BA:  MOVFF  7BE,8CC
092BE:  MOVFF  7BD,8CB
092C2:  MOVLB  0
092C4:  CALL   4F52
....................                      write16(ADDR_E2_PORT,e_port[1]); 
092C8:  MOVLW  AC
092CA:  MOVLB  8
092CC:  MOVWF  xCA
092CE:  MOVFF  7C2,8CC
092D2:  MOVFF  7C1,8CB
092D6:  MOVLB  0
092D8:  CALL   4F52
....................                break;             
092DC:  MOVLB  8
....................          } 
....................       } 
....................    } 
092DE:  BRA    9388
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
092E0:  BCF    FD8.0
092E2:  MOVLB  7
092E4:  RLCF   x3C,W
092E6:  CLRF   03
092E8:  ADDLW  92
092EA:  MOVWF  FE9
092EC:  MOVLW  07
092EE:  ADDWFC 03,W
092F0:  MOVWF  FEA
092F2:  CLRF   FEC
092F4:  MOVF   FED,F
092F6:  MOVLW  01
092F8:  MOVWF  FEF
....................       e_pos[motor] = 0; 
092FA:  BCF    FD8.0
092FC:  RLCF   x3C,W
092FE:  CLRF   03
09300:  ADDLW  BB
09302:  MOVWF  FE9
09304:  MOVLW  07
09306:  ADDWFC 03,W
09308:  MOVWF  FEA
0930A:  CLRF   FEC
0930C:  MOVF   FED,F
0930E:  CLRF   FEF
....................       e_port[motor] = 0; 
09310:  BCF    FD8.0
09312:  RLCF   x3C,W
09314:  CLRF   03
09316:  ADDLW  BF
09318:  MOVWF  FE9
0931A:  MOVLW  07
0931C:  ADDWFC 03,W
0931E:  MOVWF  FEA
09320:  CLRF   FEC
09322:  MOVF   FED,F
09324:  CLRF   FEF
....................       switch(motor) 
09326:  MOVF   x3C,W
09328:  XORLW  00
0932A:  MOVLB  0
0932C:  BZ    9334
0932E:  XORLW  01
09330:  BZ    935E
09332:  BRA    9386
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09334:  MOVLW  7E
09336:  MOVLB  8
09338:  MOVWF  xCA
0933A:  MOVFF  7BC,8CC
0933E:  MOVFF  7BB,8CB
09342:  MOVLB  0
09344:  CALL   4F52
....................                   write16(ADDR_E1_PORT,e_port[0]); 
09348:  MOVLW  AA
0934A:  MOVLB  8
0934C:  MOVWF  xCA
0934E:  MOVFF  7C0,8CC
09352:  MOVFF  7BF,8CB
09356:  MOVLB  0
09358:  CALL   4F52
....................             break; 
0935C:  BRA    9386
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
0935E:  MOVLW  80
09360:  MOVLB  8
09362:  MOVWF  xCA
09364:  MOVFF  7BE,8CC
09368:  MOVFF  7BD,8CB
0936C:  MOVLB  0
0936E:  CALL   4F52
....................                   write16(ADDR_E2_PORT,e_port[1]); 
09372:  MOVLW  AC
09374:  MOVLB  8
09376:  MOVWF  xCA
09378:  MOVFF  7C2,8CC
0937C:  MOVFF  7C1,8CB
09380:  MOVLB  0
09382:  CALL   4F52
....................             break;             
09386:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
09388:  BCF    FD8.0
0938A:  MOVLB  7
0938C:  RLCF   x3C,W
0938E:  CLRF   03
09390:  ADDLW  AB
09392:  MOVWF  FE9
09394:  MOVLW  07
09396:  ADDWFC 03,W
09398:  MOVWF  FEA
0939A:  CLRF   FEC
0939C:  MOVF   FED,F
0939E:  MOVLW  01
093A0:  MOVWF  FEF
....................     
....................    switch (motor) 
093A2:  MOVF   x3C,W
093A4:  XORLW  00
093A6:  MOVLB  0
093A8:  BZ    93B0
093AA:  XORLW  01
093AC:  BZ    93D8
093AE:  BRA    93FE
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
093B0:  MOVLW  B2
093B2:  MOVLB  8
093B4:  MOVWF  xCA
093B6:  CLRF   xCC
093B8:  MOVLW  01
093BA:  MOVWF  xCB
093BC:  MOVLB  0
093BE:  CALL   4F52
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
093C2:  MOVLW  B6
093C4:  MOVLB  8
093C6:  MOVWF  xCA
093C8:  MOVFF  7B0,8CC
093CC:  MOVFF  7AF,8CB
093D0:  MOVLB  0
093D2:  CALL   4F52
....................          break; 
093D6:  BRA    93FE
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
093D8:  MOVLW  B4
093DA:  MOVLB  8
093DC:  MOVWF  xCA
093DE:  CLRF   xCC
093E0:  MOVLW  01
093E2:  MOVWF  xCB
093E4:  MOVLB  0
093E6:  CALL   4F52
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
093EA:  MOVLW  B8
093EC:  MOVLB  8
093EE:  MOVWF  xCA
093F0:  MOVFF  7B2,8CC
093F4:  MOVFF  7B1,8CB
093F8:  MOVLB  0
093FA:  CALL   4F52
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
093FE:  MOVF   1F,W
09400:  SUBLW  04
09402:  BNZ   94A8
09404:  MOVF   20,F
09406:  BNZ   94A8
....................    { 
....................       if(motor==1) 
09408:  MOVLB  7
0940A:  DECFSZ x3C,W
0940C:  BRA    94AA
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
0940E:  BCF    FD8.0
09410:  RLCF   x3C,W
09412:  CLRF   03
09414:  ADDLW  AB
09416:  MOVWF  FE9
09418:  MOVLW  07
0941A:  ADDWFC 03,W
0941C:  MOVWF  FEA
0941E:  MOVFF  FEC,8C9
09422:  MOVF   FED,F
09424:  MOVFF  FEF,8C8
09428:  BCF    FD8.0
0942A:  RLCF   x3C,W
0942C:  CLRF   03
0942E:  ADDLW  AF
09430:  MOVWF  FE9
09432:  MOVLW  07
09434:  ADDWFC 03,W
09436:  MOVWF  FEA
09438:  MOVFF  FEC,8CB
0943C:  MOVF   FED,F
0943E:  MOVFF  FEF,8CA
09442:  MOVLW  40
09444:  MOVWF  FF6
09446:  MOVLW  1A
09448:  MOVWF  FF7
0944A:  MOVLW  00
0944C:  MOVWF  FF8
0944E:  CLRF   1B
09450:  BTFSC  FF2.7
09452:  BSF    1B.7
09454:  BCF    FF2.7
09456:  MOVLW  05
09458:  MOVLB  A
0945A:  MOVWF  x18
0945C:  MOVLB  0
0945E:  CALL   1006
09462:  BTFSC  1B.7
09464:  BSF    FF2.7
09466:  MOVLW  10
09468:  MOVWF  FE9
0946A:  CLRF   1B
0946C:  BTFSC  FF2.7
0946E:  BSF    1B.7
09470:  BCF    FF2.7
09472:  MOVFF  8C9,A19
09476:  MOVFF  8C8,A18
0947A:  CALL   1188
0947E:  BTFSC  1B.7
09480:  BSF    FF2.7
09482:  MOVLW  2C
09484:  BTFSS  F9E.4
09486:  BRA    9484
09488:  MOVWF  FAD
0948A:  MOVLW  10
0948C:  MOVWF  FE9
0948E:  MOVFF  8CB,8CD
09492:  MOVFF  8CA,8CC
09496:  RCALL  8F2E
09498:  MOVLW  0D
0949A:  BTFSS  F9E.4
0949C:  BRA    949A
0949E:  MOVWF  FAD
094A0:  MOVLW  0A
094A2:  BTFSS  F9E.4
094A4:  BRA    94A2
094A6:  MOVWF  FAD
094A8:  MOVLB  7
....................       } 
....................    } 
094AA:  MOVLB  0
094AC:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
095DA:  BCF    FD8.0
095DC:  MOVLB  7
095DE:  RLCF   x3C,W
095E0:  CLRF   03
095E2:  ADDLW  66
095E4:  MOVWF  FE9
095E6:  MOVLW  07
095E8:  ADDWFC 03,W
095EA:  MOVWF  FEA
095EC:  MOVFF  FEC,8C8
095F0:  MOVF   FED,F
095F2:  MOVFF  FEF,8C7
095F6:  MOVLB  8
095F8:  DECFSZ xC7,W
095FA:  BRA    960A
095FC:  MOVF   xC8,F
095FE:  BNZ   960A
09600:  MOVLW  01
09602:  MOVWF  xC7
09604:  MOVLB  0
09606:  RCALL  901A
09608:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
0960A:  BCF    FD8.0
0960C:  MOVLB  7
0960E:  RLCF   x3C,W
09610:  CLRF   03
09612:  ADDLW  66
09614:  MOVWF  FE9
09616:  MOVLW  07
09618:  ADDWFC 03,W
0961A:  MOVWF  FEA
0961C:  MOVFF  FEC,8C8
09620:  MOVF   FED,F
09622:  MOVFF  FEF,8C7
09626:  MOVLB  8
09628:  MOVF   xC7,W
0962A:  SUBLW  02
0962C:  BTFSS  FD8.2
0962E:  BRA    9C38
09630:  MOVF   xC8,F
09632:  BTFSS  FD8.2
09634:  BRA    9C38
....................       if (e_mode[motor]==2){ 
09636:  BCF    FD8.0
09638:  MOVLB  7
0963A:  RLCF   x3C,W
0963C:  CLRF   03
0963E:  ADDLW  62
09640:  MOVWF  FE9
09642:  MOVLW  07
09644:  ADDWFC 03,W
09646:  MOVWF  FEA
09648:  MOVFF  FEC,8C8
0964C:  MOVF   FED,F
0964E:  MOVFF  FEF,8C7
09652:  MOVLB  8
09654:  MOVF   xC7,W
09656:  SUBLW  02
09658:  BTFSS  FD8.2
0965A:  BRA    9BB4
0965C:  MOVF   xC8,F
0965E:  BTFSS  FD8.2
09660:  BRA    9BB4
....................          if(nv_product==ECO || nv_product==WMS2){ 
09662:  MOVF   2F,F
09664:  BNZ   966A
09666:  MOVF   30,F
09668:  BZ    9678
0966A:  MOVF   2F,W
0966C:  SUBLW  03
0966E:  BTFSS  FD8.2
09670:  BRA    97BC
09672:  MOVF   30,F
09674:  BTFSS  FD8.2
09676:  BRA    97BC
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
09678:  BCF    FD8.0
0967A:  MOVLB  7
0967C:  RLCF   x3C,W
0967E:  CLRF   03
09680:  ADDLW  A7
09682:  MOVWF  FE9
09684:  MOVLW  07
09686:  ADDWFC 03,W
09688:  MOVWF  FEA
0968A:  MOVFF  FEC,9D3
0968E:  MOVF   FED,F
09690:  MOVFF  FEF,9D2
09694:  MOVFF  FEA,8CA
09698:  MOVFF  FE9,8C9
0969C:  MOVLB  9
0969E:  CLRF   xD5
096A0:  CLRF   xD4
096A2:  MOVFF  8B8,9D9
096A6:  MOVFF  8B7,9D8
096AA:  MOVFF  8B6,9D7
096AE:  MOVFF  8B5,9D6
096B2:  MOVLB  0
096B4:  CALL   4778
096B8:  MOVFF  8CA,FEA
096BC:  MOVFF  8C9,FE9
096C0:  MOVFF  03,8CA
096C4:  MOVFF  02,8C9
096C8:  MOVFF  01,8C8
096CC:  MOVFF  00,8C7
096D0:  BCF    FD8.0
096D2:  MOVLB  7
096D4:  RLCF   x3C,W
096D6:  CLRF   03
096D8:  ADDLW  A7
096DA:  MOVWF  FE9
096DC:  MOVLW  07
096DE:  ADDWFC 03,W
096E0:  MOVWF  FEA
096E2:  MOVFF  FEC,8CC
096E6:  MOVF   FED,F
096E8:  MOVFF  FEF,8CB
096EC:  BCF    FD8.0
096EE:  MOVLB  8
096F0:  RRCF   xCC,W
096F2:  MOVWF  03
096F4:  RRCF   xCB,W
096F6:  MOVWF  02
096F8:  ADDWF  00,W
096FA:  MOVWF  00
096FC:  MOVF   03,W
096FE:  ADDWFC 01,W
09700:  MOVWF  01
09702:  MOVLW  00
09704:  ADDWFC xC9,W
09706:  MOVWF  02
09708:  MOVLW  00
0970A:  ADDWFC xCA,W
0970C:  MOVWF  xC2
0970E:  MOVFF  02,8C1
09712:  MOVFF  01,8C0
09716:  MOVFF  00,8BF
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
0971A:  BCF    FD8.0
0971C:  MOVLB  7
0971E:  RLCF   x3C,W
09720:  CLRF   03
09722:  ADDLW  A7
09724:  MOVWF  FE9
09726:  MOVLW  07
09728:  ADDWFC 03,W
0972A:  MOVWF  FEA
0972C:  MOVFF  FEC,9D3
09730:  MOVF   FED,F
09732:  MOVFF  FEF,9D2
09736:  MOVFF  FEA,8CA
0973A:  MOVFF  FE9,8C9
0973E:  MOVLB  9
09740:  CLRF   xD5
09742:  CLRF   xD4
09744:  MOVFF  8B8,9D9
09748:  MOVFF  8B7,9D8
0974C:  MOVFF  8B6,9D7
09750:  MOVFF  8B5,9D6
09754:  MOVLB  0
09756:  CALL   4778
0975A:  MOVFF  8CA,FEA
0975E:  MOVFF  8C9,FE9
09762:  MOVFF  03,8CA
09766:  MOVFF  02,8C9
0976A:  MOVFF  01,8C8
0976E:  MOVFF  00,8C7
09772:  BCF    FD8.0
09774:  MOVLB  7
09776:  RLCF   x3C,W
09778:  CLRF   03
0977A:  ADDLW  A7
0977C:  MOVWF  FE9
0977E:  MOVLW  07
09780:  ADDWFC 03,W
09782:  MOVWF  FEA
09784:  MOVFF  FEC,8CC
09788:  MOVF   FED,F
0978A:  MOVFF  FEF,8CB
0978E:  BCF    FD8.0
09790:  MOVLB  8
09792:  RRCF   xCC,W
09794:  MOVWF  03
09796:  RRCF   xCB,W
09798:  MOVWF  02
0979A:  SUBWF  00,W
0979C:  MOVWF  00
0979E:  MOVF   03,W
097A0:  SUBWFB 01,W
097A2:  MOVWF  01
097A4:  MOVLW  00
097A6:  SUBWFB xC9,W
097A8:  MOVWF  02
097AA:  MOVLW  00
097AC:  SUBWFB xCA,W
097AE:  MOVWF  xC6
097B0:  MOVFF  02,8C5
097B4:  MOVFF  01,8C4
097B8:  MOVFF  00,8C3
....................          } 
....................          if (nv_product==WMS4){ 
097BC:  DECFSZ 2F,W
097BE:  BRA    99D6
097C0:  MOVF   30,F
097C2:  BTFSS  FD8.2
097C4:  BRA    99D6
....................             if (end_even_port==FALSE){ 
097C6:  MOVLB  2
097C8:  MOVF   xD7,F
097CA:  BNZ   98C0
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
097CC:  BCF    FD8.0
097CE:  MOVLB  7
097D0:  RLCF   x3C,W
097D2:  CLRF   03
097D4:  ADDLW  A7
097D6:  MOVWF  FE9
097D8:  MOVLW  07
097DA:  ADDWFC 03,W
097DC:  MOVWF  FEA
097DE:  MOVFF  FEC,9E9
097E2:  MOVF   FED,F
097E4:  MOVFF  FEF,9E8
097E8:  MOVFF  8BA,9EB
097EC:  MOVFF  8B9,9EA
097F0:  MOVLB  0
097F2:  CALL   5C22
097F6:  MOVFF  02,8C8
097FA:  MOVFF  01,8C7
097FE:  BCF    FD8.0
09800:  MOVLB  7
09802:  RLCF   x3C,W
09804:  CLRF   03
09806:  ADDLW  A7
09808:  MOVWF  FE9
0980A:  MOVLW  07
0980C:  ADDWFC 03,W
0980E:  MOVWF  FEA
09810:  MOVFF  FEC,8CA
09814:  MOVF   FED,F
09816:  MOVFF  FEF,8C9
0981A:  BCF    FD8.0
0981C:  MOVLB  8
0981E:  RRCF   xCA,W
09820:  MOVWF  03
09822:  RRCF   xC9,W
09824:  MOVWF  02
09826:  ADDWF  01,W
09828:  MOVWF  01
0982A:  MOVF   xC8,W
0982C:  ADDWFC 03,F
0982E:  MOVFF  01,8BF
09832:  MOVFF  03,8C0
09836:  CLRF   02
09838:  CLRF   03
0983A:  MOVFF  03,8C2
0983E:  MOVFF  02,8C1
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
09842:  BCF    FD8.0
09844:  MOVLB  7
09846:  RLCF   x3C,W
09848:  CLRF   03
0984A:  ADDLW  A7
0984C:  MOVWF  FE9
0984E:  MOVLW  07
09850:  ADDWFC 03,W
09852:  MOVWF  FEA
09854:  MOVFF  FEC,9E9
09858:  MOVF   FED,F
0985A:  MOVFF  FEF,9E8
0985E:  MOVFF  8BA,9EB
09862:  MOVFF  8B9,9EA
09866:  MOVLB  0
09868:  CALL   5C22
0986C:  MOVFF  02,8C8
09870:  MOVFF  01,8C7
09874:  BCF    FD8.0
09876:  MOVLB  7
09878:  RLCF   x3C,W
0987A:  CLRF   03
0987C:  ADDLW  A7
0987E:  MOVWF  FE9
09880:  MOVLW  07
09882:  ADDWFC 03,W
09884:  MOVWF  FEA
09886:  MOVFF  FEC,8CA
0988A:  MOVF   FED,F
0988C:  MOVFF  FEF,8C9
09890:  BCF    FD8.0
09892:  MOVLB  8
09894:  RRCF   xCA,W
09896:  MOVWF  03
09898:  RRCF   xC9,W
0989A:  MOVWF  02
0989C:  SUBWF  01,W
0989E:  MOVWF  00
098A0:  MOVF   03,W
098A2:  SUBWFB xC8,W
098A4:  MOVWF  03
098A6:  MOVF   00,W
098A8:  MOVFF  03,8C4
098AC:  CLRF   02
098AE:  CLRF   03
098B0:  MOVFF  03,8C6
098B4:  MOVFF  02,8C5
098B8:  MOVFF  00,8C3
....................             } 
098BC:  BRA    99D6
098BE:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
098C0:  DECFSZ xD7,W
098C2:  BRA    99D8
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
098C4:  BCF    FD8.0
098C6:  MOVLB  7
098C8:  RLCF   x3C,W
098CA:  CLRF   03
098CC:  ADDLW  A7
098CE:  MOVWF  FE9
098D0:  MOVLW  07
098D2:  ADDWFC 03,W
098D4:  MOVWF  FEA
098D6:  MOVFF  FEC,9E9
098DA:  MOVF   FED,F
098DC:  MOVFF  FEF,9E8
098E0:  MOVLW  01
098E2:  MOVLB  8
098E4:  SUBWF  xB9,W
098E6:  MOVWF  00
098E8:  MOVLW  00
098EA:  SUBWFB xBA,W
098EC:  MOVWF  03
098EE:  MOVFF  00,8C9
098F2:  MOVWF  xCA
098F4:  MOVFF  FE8,9EB
098F8:  MOVFF  00,9EA
098FC:  MOVLB  0
098FE:  CALL   5C22
09902:  MOVFF  02,8C8
09906:  MOVFF  01,8C7
0990A:  BCF    FD8.0
0990C:  MOVLB  7
0990E:  RLCF   x3C,W
09910:  CLRF   03
09912:  ADDLW  A7
09914:  MOVWF  FE9
09916:  MOVLW  07
09918:  ADDWFC 03,W
0991A:  MOVWF  FEA
0991C:  MOVFF  FEC,8CA
09920:  MOVF   FED,F
09922:  MOVFF  FEF,8C9
09926:  BCF    FD8.0
09928:  MOVLB  8
0992A:  RRCF   xCA,W
0992C:  MOVWF  03
0992E:  RRCF   xC9,W
09930:  MOVWF  02
09932:  ADDWF  01,W
09934:  MOVWF  01
09936:  MOVF   xC8,W
09938:  ADDWFC 03,F
0993A:  MOVFF  01,8BF
0993E:  MOVFF  03,8C0
09942:  CLRF   02
09944:  CLRF   03
09946:  MOVFF  03,8C2
0994A:  MOVFF  02,8C1
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
0994E:  BCF    FD8.0
09950:  MOVLB  7
09952:  RLCF   x3C,W
09954:  CLRF   03
09956:  ADDLW  A7
09958:  MOVWF  FE9
0995A:  MOVLW  07
0995C:  ADDWFC 03,W
0995E:  MOVWF  FEA
09960:  MOVFF  FEC,9E9
09964:  MOVF   FED,F
09966:  MOVFF  FEF,9E8
0996A:  MOVLW  01
0996C:  MOVLB  8
0996E:  SUBWF  xB9,W
09970:  MOVWF  00
09972:  MOVLW  00
09974:  SUBWFB xBA,W
09976:  MOVWF  03
09978:  MOVFF  00,8C9
0997C:  MOVWF  xCA
0997E:  MOVFF  FE8,9EB
09982:  MOVFF  00,9EA
09986:  MOVLB  0
09988:  CALL   5C22
0998C:  MOVFF  02,03
09990:  MOVFF  01,8C3
09994:  MOVFF  02,8C4
09998:  CLRF   02
0999A:  CLRF   03
0999C:  MOVFF  03,8C6
099A0:  MOVFF  02,8C5
....................                m_pll = m_pll -(m_ppp[motor]/2); 
099A4:  BCF    FD8.0
099A6:  MOVLB  7
099A8:  RLCF   x3C,W
099AA:  CLRF   03
099AC:  ADDLW  A7
099AE:  MOVWF  FE9
099B0:  MOVLW  07
099B2:  ADDWFC 03,W
099B4:  MOVWF  FEA
099B6:  MOVFF  FEC,8C8
099BA:  MOVF   FED,F
099BC:  MOVFF  FEF,8C7
099C0:  BCF    FD8.0
099C2:  MOVLB  8
099C4:  RRCF   xC8,W
099C6:  MOVWF  03
099C8:  RRCF   xC7,W
099CA:  SUBWF  xC3,F
099CC:  MOVF   03,W
099CE:  SUBWFB xC4,F
099D0:  MOVLW  00
099D2:  SUBWFB xC5,F
099D4:  SUBWFB xC6,F
099D6:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
099D8:  MOVLB  7
099DA:  MOVF   x3C,W
099DC:  MULLW  04
099DE:  MOVF   FF3,W
099E0:  CLRF   03
099E2:  ADDLW  9E
099E4:  MOVWF  FE9
099E6:  MOVLW  07
099E8:  ADDWFC 03,W
099EA:  MOVWF  FEA
099EC:  MOVFF  FEF,8C7
099F0:  MOVFF  FEC,8C8
099F4:  MOVFF  FEC,8C9
099F8:  MOVFF  FEC,8CA
099FC:  MOVLB  8
099FE:  BTFSC  xC2.7
09A00:  BRA    9A70
09A02:  MOVF   xC2,W
09A04:  SUBWF  xCA,W
09A06:  BNC   9A20
09A08:  BNZ   9A70
09A0A:  MOVF   xC1,W
09A0C:  SUBWF  xC9,W
09A0E:  BNC   9A20
09A10:  BNZ   9A70
09A12:  MOVF   xC0,W
09A14:  SUBWF  xC8,W
09A16:  BNC   9A20
09A18:  BNZ   9A70
09A1A:  MOVF   xC7,W
09A1C:  SUBWF  xBF,W
09A1E:  BNC   9A70
09A20:  MOVLB  7
09A22:  MOVF   x3C,W
09A24:  MULLW  04
09A26:  MOVF   FF3,W
09A28:  CLRF   03
09A2A:  ADDLW  9E
09A2C:  MOVWF  FE9
09A2E:  MOVLW  07
09A30:  ADDWFC 03,W
09A32:  MOVWF  FEA
09A34:  MOVFF  FEF,8C7
09A38:  MOVFF  FEC,8C8
09A3C:  MOVFF  FEC,8C9
09A40:  MOVFF  FEC,8CA
09A44:  MOVLB  8
09A46:  BTFSC  xC6.7
09A48:  BRA    9BB4
09A4A:  MOVF   xCA,W
09A4C:  SUBWF  xC6,W
09A4E:  BTFSS  FD8.0
09A50:  BRA    9BB4
09A52:  BNZ   9A70
09A54:  MOVF   xC9,W
09A56:  SUBWF  xC5,W
09A58:  BTFSS  FD8.0
09A5A:  BRA    9BB4
09A5C:  BNZ   9A70
09A5E:  MOVF   xC8,W
09A60:  SUBWF  xC4,W
09A62:  BTFSS  FD8.0
09A64:  BRA    9BB4
09A66:  BNZ   9A70
09A68:  MOVF   xC3,W
09A6A:  SUBWF  xC7,W
09A6C:  BTFSC  FD8.0
09A6E:  BRA    9BB4
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09A70:  MOVLW  01
09A72:  MOVLB  7
09A74:  ADDWF  x3C,W
09A76:  MOVLB  8
09A78:  MOVWF  xC7
09A7A:  BCF    FD8.0
09A7C:  MOVLB  7
09A7E:  RLCF   x3C,W
09A80:  CLRF   03
09A82:  ADDLW  A7
09A84:  MOVWF  FE9
09A86:  MOVLW  07
09A88:  ADDWFC 03,W
09A8A:  MOVWF  FEA
09A8C:  MOVFF  FEC,8C9
09A90:  MOVF   FED,F
09A92:  MOVFF  FEF,8C8
09A96:  MOVF   x3C,W
09A98:  MULLW  04
09A9A:  MOVF   FF3,W
09A9C:  CLRF   03
09A9E:  ADDLW  9E
09AA0:  MOVWF  FE9
09AA2:  MOVLW  07
09AA4:  ADDWFC 03,W
09AA6:  MOVWF  FEA
09AA8:  MOVFF  FEF,8CA
09AAC:  MOVFF  FEC,8CB
09AB0:  MOVFF  FEC,8CC
09AB4:  MOVFF  FEC,8CD
09AB8:  MOVLW  50
09ABA:  MOVWF  FF6
09ABC:  MOVLW  1A
09ABE:  MOVWF  FF7
09AC0:  MOVLW  00
09AC2:  MOVWF  FF8
09AC4:  CLRF   1B
09AC6:  BTFSC  FF2.7
09AC8:  BSF    1B.7
09ACA:  BCF    FF2.7
09ACC:  MOVLW  05
09ACE:  MOVLB  A
09AD0:  MOVWF  x18
09AD2:  MOVLB  0
09AD4:  CALL   1006
09AD8:  BTFSC  1B.7
09ADA:  BSF    FF2.7
09ADC:  CLRF   1B
09ADE:  BTFSC  FF2.7
09AE0:  BSF    1B.7
09AE2:  BCF    FF2.7
09AE4:  MOVFF  8C7,A18
09AE8:  MOVLW  1B
09AEA:  MOVLB  A
09AEC:  MOVWF  x19
09AEE:  MOVLB  0
09AF0:  CALL   0F88
09AF4:  BTFSC  1B.7
09AF6:  BSF    FF2.7
09AF8:  MOVLW  2C
09AFA:  BTFSS  F9E.4
09AFC:  BRA    9AFA
09AFE:  MOVWF  FAD
09B00:  MOVLW  41
09B02:  MOVWF  FE9
09B04:  MOVFF  8B8,8D1
09B08:  MOVFF  8B7,8D0
09B0C:  MOVFF  8B6,8CF
09B10:  MOVFF  8B5,8CE
09B14:  RCALL  94AE
09B16:  MOVLW  2C
09B18:  BTFSS  F9E.4
09B1A:  BRA    9B18
09B1C:  MOVWF  FAD
09B1E:  MOVLW  10
09B20:  MOVWF  FE9
09B22:  CLRF   1B
09B24:  BTFSC  FF2.7
09B26:  BSF    1B.7
09B28:  BCF    FF2.7
09B2A:  MOVFF  8C9,A19
09B2E:  MOVFF  8C8,A18
09B32:  CALL   1188
09B36:  BTFSC  1B.7
09B38:  BSF    FF2.7
09B3A:  MOVLW  2C
09B3C:  BTFSS  F9E.4
09B3E:  BRA    9B3C
09B40:  MOVWF  FAD
09B42:  MOVLW  41
09B44:  MOVWF  FE9
09B46:  CLRF   1B
09B48:  BTFSC  FF2.7
09B4A:  BSF    1B.7
09B4C:  BCF    FF2.7
09B4E:  MOVFF  8CD,A1B
09B52:  MOVFF  8CC,A1A
09B56:  MOVFF  8CB,A19
09B5A:  MOVFF  8CA,A18
09B5E:  CALL   10CC
09B62:  BTFSC  1B.7
09B64:  BSF    FF2.7
09B66:  MOVLW  2C
09B68:  BTFSS  F9E.4
09B6A:  BRA    9B68
09B6C:  MOVWF  FAD
09B6E:  MOVLW  41
09B70:  MOVWF  FE9
09B72:  MOVFF  8C2,8D1
09B76:  MOVFF  8C1,8D0
09B7A:  MOVFF  8C0,8CF
09B7E:  MOVFF  8BF,8CE
09B82:  RCALL  94AE
09B84:  MOVLW  2C
09B86:  BTFSS  F9E.4
09B88:  BRA    9B86
09B8A:  MOVWF  FAD
09B8C:  MOVLW  41
09B8E:  MOVWF  FE9
09B90:  MOVFF  8C6,8D1
09B94:  MOVFF  8C5,8D0
09B98:  MOVFF  8C4,8CF
09B9C:  MOVFF  8C3,8CE
09BA0:  RCALL  94AE
09BA2:  MOVLW  0D
09BA4:  BTFSS  F9E.4
09BA6:  BRA    9BA4
09BA8:  MOVWF  FAD
09BAA:  MOVLW  0A
09BAC:  BTFSS  F9E.4
09BAE:  BRA    9BAC
09BB0:  MOVWF  FAD
09BB2:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09BB4:  BCF    FD8.0
09BB6:  MOVLB  7
09BB8:  RLCF   x3C,W
09BBA:  CLRF   03
09BBC:  ADDLW  9A
09BBE:  MOVWF  01
09BC0:  MOVLW  07
09BC2:  ADDWFC 03,F
09BC4:  MOVLB  8
09BC6:  MOVFF  03,8C8
09BCA:  BCF    FD8.0
09BCC:  MOVLB  7
09BCE:  RLCF   x3C,W
09BD0:  CLRF   03
09BD2:  ADDLW  62
09BD4:  MOVWF  FE9
09BD6:  MOVLW  07
09BD8:  ADDWFC 03,W
09BDA:  MOVWF  FEA
09BDC:  MOVFF  FEC,03
09BE0:  MOVF   FED,F
09BE2:  MOVFF  FEF,8C9
09BE6:  MOVLB  8
09BE8:  MOVFF  8C8,FEA
09BEC:  MOVFF  01,FE9
09BF0:  MOVFF  03,FEC
09BF4:  MOVF   FED,F
09BF6:  MOVFF  8C9,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09BFA:  BCF    FD8.0
09BFC:  MOVLB  7
09BFE:  RLCF   x3C,W
09C00:  CLRF   03
09C02:  ADDLW  62
09C04:  MOVWF  FE9
09C06:  MOVLW  07
09C08:  ADDWFC 03,W
09C0A:  MOVWF  FEA
09C0C:  CLRF   FEC
09C0E:  MOVF   FED,F
09C10:  MOVLW  04
09C12:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09C14:  MOVF   x3C,W
09C16:  MULLW  04
09C18:  MOVF   FF3,W
09C1A:  CLRF   03
09C1C:  ADDLW  9E
09C1E:  MOVWF  FE9
09C20:  MOVLW  07
09C22:  ADDWFC 03,W
09C24:  MOVWF  FEA
09C26:  MOVFF  FEF,8BB
09C2A:  MOVFF  FEC,8BC
09C2E:  MOVFF  FEC,8BD
09C32:  MOVFF  FEC,8BE
09C36:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09C38:  MOVFF  8BB,00
09C3C:  MOVFF  8BC,01
09C40:  MOVFF  8BD,02
09C44:  MOVFF  8BE,03
09C48:  MOVLB  0
09C4A:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
084A8:  MOVLB  2
084AA:  CLRF   xD7
....................    start_even_port = FALSE; 
084AC:  CLRF   xD6
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
084AE:  BCF    FD8.0
084B0:  MOVLB  7
084B2:  RLCF   x3C,W
084B4:  CLRF   03
084B6:  ADDLW  C3
084B8:  MOVWF  FE9
084BA:  MOVLW  07
084BC:  ADDWFC 03,W
084BE:  MOVWF  FEA
084C0:  MOVFF  FEC,8B5
084C4:  MOVF   FED,F
084C6:  MOVFF  FEF,8B4
084CA:  MOVLW  01
084CC:  MOVLB  8
084CE:  ANDWF  xB4,F
084D0:  CLRF   xB5
084D2:  MOVF   xB4,F
084D4:  BNZ   84E2
084D6:  MOVF   xB5,F
084D8:  BNZ   84E2
....................    { 
....................       end_even_port = TRUE; 
084DA:  MOVLW  01
084DC:  MOVLB  2
084DE:  MOVWF  xD7
084E0:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
084E2:  BCF    FD8.0
084E4:  MOVLB  7
084E6:  RLCF   x3C,W
084E8:  CLRF   03
084EA:  ADDLW  BF
084EC:  MOVWF  FE9
084EE:  MOVLW  07
084F0:  ADDWFC 03,W
084F2:  MOVWF  FEA
084F4:  MOVFF  FEC,8B5
084F8:  MOVF   FED,F
084FA:  MOVFF  FEF,8B4
084FE:  MOVLW  01
08500:  MOVLB  8
08502:  ANDWF  xB4,F
08504:  CLRF   xB5
08506:  MOVF   xB4,F
08508:  BNZ   8516
0850A:  MOVF   xB5,F
0850C:  BNZ   8516
....................    { 
....................       start_even_port = TRUE; 
0850E:  MOVLW  01
08510:  MOVLB  2
08512:  MOVWF  xD6
08514:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
08516:  MOVLB  2
08518:  MOVF   xD6,F
0851A:  BNZ   8530
....................    { 
....................       evenOdd = 0; 
0851C:  MOVLB  8
0851E:  CLRF   xB3
....................       if (TRUE == end_even_port) 
08520:  MOVLB  2
08522:  DECFSZ xD7,W
08524:  BRA    852E
....................       { 
....................          evenOdd = 1; 
08526:  MOVLW  01
08528:  MOVLB  8
0852A:  MOVWF  xB3
0852C:  MOVLB  2
....................       } 
....................    } 
0852E:  BRA    8544
....................    else 
....................    { 
....................       evenOdd = 2; 
08530:  MOVLW  02
08532:  MOVLB  8
08534:  MOVWF  xB3
....................       if (TRUE == end_even_port) 
08536:  MOVLB  2
08538:  DECFSZ xD7,W
0853A:  BRA    8544
....................       { 
....................          evenOdd = 3; 
0853C:  MOVLW  03
0853E:  MOVLB  8
08540:  MOVWF  xB3
08542:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
08544:  MOVLB  8
08546:  MOVFF  8B3,01
0854A:  MOVLB  0
0854C:  GOTO   9F9A (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09CC2:  BCF    FD8.0
09CC4:  MOVLB  7
09CC6:  RLCF   x3C,W
09CC8:  CLRF   03
09CCA:  ADDLW  82
09CCC:  MOVWF  FE9
09CCE:  MOVLW  07
09CD0:  ADDWFC 03,W
09CD2:  MOVWF  FEA
09CD4:  CLRF   FEC
09CD6:  MOVF   FED,F
09CD8:  MOVFF  8A4,FEF
....................    m_step_cnt[motor] = 0; 
09CDC:  MOVF   x3C,W
09CDE:  MULLW  04
09CE0:  MOVF   FF3,W
09CE2:  CLRF   03
09CE4:  ADDLW  9E
09CE6:  MOVWF  FE9
09CE8:  MOVLW  07
09CEA:  ADDWFC 03,W
09CEC:  MOVWF  FEA
09CEE:  MOVF   FEE,F
09CF0:  MOVF   FEE,F
09CF2:  CLRF   FEC
09CF4:  MOVF   FED,F
09CF6:  CLRF   FEF
09CF8:  MOVF   FED,F
09CFA:  CLRF   FEF
09CFC:  MOVF   FED,F
09CFE:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09D00:  BCF    FD8.0
09D02:  RLCF   x3C,W
09D04:  CLRF   03
09D06:  ADDLW  6A
09D08:  MOVWF  FE9
09D0A:  MOVLW  07
09D0C:  ADDWFC 03,W
09D0E:  MOVWF  FEA
09D10:  MOVFF  FEC,8B1
09D14:  MOVF   FED,F
09D16:  MOVFF  FEF,8B0
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09D1A:  BCF    FD8.0
09D1C:  RLCF   x3C,W
09D1E:  CLRF   03
09D20:  ADDLW  72
09D22:  MOVWF  FE9
09D24:  MOVLW  07
09D26:  ADDWFC 03,W
09D28:  MOVWF  FEA
09D2A:  MOVFF  FEC,8B8
09D2E:  MOVF   FED,F
09D30:  MOVFF  FEF,8B7
09D34:  BCF    FD8.0
09D36:  RLCF   x3C,W
09D38:  CLRF   03
09D3A:  ADDLW  5A
09D3C:  MOVWF  FE9
09D3E:  MOVLW  07
09D40:  ADDWFC 03,W
09D42:  MOVWF  FEA
09D44:  MOVFF  FEC,03
09D48:  MOVF   FED,F
09D4A:  MOVFF  FEF,8B9
09D4E:  MOVFF  03,8B6
09D52:  MOVFF  03,8BA
09D56:  MOVLB  0
09D58:  CALL   2C52
09D5C:  MOVFF  02,8AF
09D60:  MOVFF  01,8AE
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09D64:  BCF    FD8.0
09D66:  MOVLB  7
09D68:  RLCF   x3C,W
09D6A:  CLRF   03
09D6C:  ADDLW  62
09D6E:  MOVWF  FE9
09D70:  MOVLW  07
09D72:  ADDWFC 03,W
09D74:  MOVWF  FEA
09D76:  MOVFF  FEC,8B4
09D7A:  MOVF   FED,F
09D7C:  MOVFF  FEF,8B3
09D80:  MOVLB  8
09D82:  MOVF   xB3,W
09D84:  SUBLW  02
09D86:  BNZ   9DB6
09D88:  MOVF   xB4,F
09D8A:  BNZ   9DB6
09D8C:  BCF    FD8.0
09D8E:  MOVLB  7
09D90:  RLCF   x3C,W
09D92:  CLRF   03
09D94:  ADDLW  BF
09D96:  MOVWF  FE9
09D98:  MOVLW  07
09D9A:  ADDWFC 03,W
09D9C:  MOVWF  FEA
09D9E:  MOVFF  FEC,8B4
09DA2:  MOVF   FED,F
09DA4:  MOVFF  FEF,8B3
09DA8:  MOVLB  8
09DAA:  MOVF   xB3,F
09DAC:  BNZ   9DB6
09DAE:  MOVF   xB4,F
09DB0:  BTFSC  FD8.2
09DB2:  GOTO   A654
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09DB6:  BCF    FD8.0
09DB8:  MOVLB  7
09DBA:  RLCF   x3C,W
09DBC:  CLRF   03
09DBE:  ADDLW  62
09DC0:  MOVWF  FE9
09DC2:  MOVLW  07
09DC4:  ADDWFC 03,W
09DC6:  MOVWF  FEA
09DC8:  MOVFF  FEC,8B4
09DCC:  MOVF   FED,F
09DCE:  MOVFF  FEF,8B3
09DD2:  MOVLB  8
09DD4:  MOVF   xB3,W
09DD6:  SUBLW  02
09DD8:  BTFSS  FD8.2
09DDA:  BRA    A134
09DDC:  MOVF   xB4,F
09DDE:  BTFSS  FD8.2
09DE0:  BRA    A134
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09DE2:  BCF    FD8.0
09DE4:  MOVLB  7
09DE6:  RLCF   x3C,W
09DE8:  CLRF   03
09DEA:  ADDLW  C3
09DEC:  MOVWF  FE9
09DEE:  MOVLW  07
09DF0:  ADDWFC 03,W
09DF2:  MOVWF  FEA
09DF4:  MOVFF  8A5,FEF
09DF8:  MOVFF  8A6,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09DFC:  DECFSZ 2F,W
09DFE:  BRA    A0B0
09E00:  MOVF   30,F
09E02:  BTFSS  FD8.2
09E04:  BRA    A0B0
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09E06:  BCF    FD8.0
09E08:  RLCF   x3C,W
09E0A:  CLRF   03
09E0C:  ADDLW  C3
09E0E:  MOVWF  FE9
09E10:  MOVLW  07
09E12:  ADDWFC 03,W
09E14:  MOVWF  FEA
09E16:  MOVFF  FEC,8B4
09E1A:  MOVF   FED,F
09E1C:  MOVFF  FEF,8B3
09E20:  BCF    FD8.0
09E22:  RLCF   x3C,W
09E24:  CLRF   03
09E26:  ADDLW  BF
09E28:  MOVWF  FE9
09E2A:  MOVLW  07
09E2C:  ADDWFC 03,W
09E2E:  MOVWF  FEA
09E30:  MOVFF  FEC,03
09E34:  MOVF   FED,F
09E36:  MOVFF  FEF,01
09E3A:  MOVF   03,W
09E3C:  MOVLB  8
09E3E:  SUBWF  xB4,W
09E40:  BNC   9EDC
09E42:  BNZ   9E4A
09E44:  MOVF   xB3,W
09E46:  SUBWF  01,W
09E48:  BC    9EDC
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09E4A:  BCF    FD8.0
09E4C:  MOVLB  7
09E4E:  RLCF   x3C,W
09E50:  CLRF   03
09E52:  ADDLW  B3
09E54:  MOVWF  01
09E56:  MOVLW  07
09E58:  ADDWFC 03,F
09E5A:  MOVLB  8
09E5C:  MOVFF  03,8B4
09E60:  BCF    FD8.0
09E62:  MOVLB  7
09E64:  RLCF   x3C,W
09E66:  CLRF   03
09E68:  ADDLW  C3
09E6A:  MOVWF  FE9
09E6C:  MOVLW  07
09E6E:  ADDWFC 03,W
09E70:  MOVWF  FEA
09E72:  MOVFF  FEC,8B6
09E76:  MOVF   FED,F
09E78:  MOVFF  FEF,8B5
09E7C:  BCF    FD8.0
09E7E:  RLCF   x3C,W
09E80:  CLRF   03
09E82:  ADDLW  BF
09E84:  MOVWF  FE9
09E86:  MOVLW  07
09E88:  ADDWFC 03,W
09E8A:  MOVWF  FEA
09E8C:  MOVFF  FEC,03
09E90:  MOVF   FED,F
09E92:  MOVF   FEF,W
09E94:  MOVLB  8
09E96:  SUBWF  xB5,W
09E98:  MOVWF  00
09E9A:  MOVF   03,W
09E9C:  SUBWFB xB6,W
09E9E:  MOVFF  8B4,FEA
09EA2:  MOVFF  01,FE9
09EA6:  MOVWF  FEC
09EA8:  MOVF   FED,F
09EAA:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09EAE:  BCF    FD8.0
09EB0:  MOVLB  7
09EB2:  RLCF   x3C,W
09EB4:  CLRF   03
09EB6:  ADDLW  B3
09EB8:  MOVWF  FE9
09EBA:  MOVLW  07
09EBC:  ADDWFC 03,W
09EBE:  MOVWF  FEA
09EC0:  MOVFF  FEC,8B4
09EC4:  MOVF   FED,F
09EC6:  MOVFF  FEF,8B3
09ECA:  BCF    FD8.0
09ECC:  MOVLB  8
09ECE:  CLRF   xA8
09ED0:  CLRF   xA7
09ED2:  RRCF   xB4,W
09ED4:  MOVWF  xA6
09ED6:  RRCF   xB3,W
09ED8:  MOVWF  xA5
....................             } 
09EDA:  BRA    9F94
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09EDC:  BCF    FD8.0
09EDE:  MOVLB  7
09EE0:  RLCF   x3C,W
09EE2:  CLRF   03
09EE4:  ADDLW  B3
09EE6:  MOVWF  01
09EE8:  MOVLW  07
09EEA:  ADDWFC 03,F
09EEC:  MOVFF  01,8B3
09EF0:  MOVLB  8
09EF2:  MOVFF  03,8B4
09EF6:  BCF    FD8.0
09EF8:  MOVLB  7
09EFA:  RLCF   x3C,W
09EFC:  CLRF   03
09EFE:  ADDLW  5E
09F00:  MOVWF  FE9
09F02:  MOVLW  07
09F04:  ADDWFC 03,W
09F06:  MOVWF  FEA
09F08:  MOVFF  FEC,8B6
09F0C:  MOVF   FED,F
09F0E:  MOVFF  FEF,8B5
09F12:  BCF    FD8.0
09F14:  RLCF   x3C,W
09F16:  CLRF   03
09F18:  ADDLW  BF
09F1A:  MOVWF  FE9
09F1C:  MOVLW  07
09F1E:  ADDWFC 03,W
09F20:  MOVWF  FEA
09F22:  MOVFF  FEC,03
09F26:  MOVF   FED,F
09F28:  MOVF   FEF,W
09F2A:  MOVLB  8
09F2C:  SUBWF  xB5,F
09F2E:  MOVF   03,W
09F30:  SUBWFB xB6,F
09F32:  BCF    FD8.0
09F34:  MOVLB  7
09F36:  RLCF   x3C,W
09F38:  CLRF   03
09F3A:  ADDLW  C3
09F3C:  MOVWF  FE9
09F3E:  MOVLW  07
09F40:  ADDWFC 03,W
09F42:  MOVWF  FEA
09F44:  MOVFF  FEC,03
09F48:  MOVF   FED,F
09F4A:  MOVF   FEF,W
09F4C:  MOVLB  8
09F4E:  ADDWF  xB5,W
09F50:  MOVWF  01
09F52:  MOVF   xB6,W
09F54:  ADDWFC 03,F
09F56:  MOVFF  8B4,FEA
09F5A:  MOVFF  8B3,FE9
09F5E:  MOVFF  03,FEC
09F62:  MOVF   FED,F
09F64:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F68:  BCF    FD8.0
09F6A:  MOVLB  7
09F6C:  RLCF   x3C,W
09F6E:  CLRF   03
09F70:  ADDLW  B3
09F72:  MOVWF  FE9
09F74:  MOVLW  07
09F76:  ADDWFC 03,W
09F78:  MOVWF  FEA
09F7A:  MOVFF  FEC,8B4
09F7E:  MOVF   FED,F
09F80:  MOVFF  FEF,8B3
09F84:  BCF    FD8.0
09F86:  MOVLB  8
09F88:  CLRF   xA8
09F8A:  CLRF   xA7
09F8C:  RRCF   xB4,W
09F8E:  MOVWF  xA6
09F90:  RRCF   xB3,W
09F92:  MOVWF  xA5
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
09F94:  MOVLB  0
09F96:  GOTO   84A8
09F9A:  MOVFF  01,8B2
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
09F9E:  BCF    FD8.0
09FA0:  MOVLB  7
09FA2:  RLCF   x3C,W
09FA4:  CLRF   03
09FA6:  ADDLW  C3
09FA8:  MOVWF  FE9
09FAA:  MOVLW  07
09FAC:  ADDWFC 03,W
09FAE:  MOVWF  FEA
09FB0:  MOVFF  FEC,8B4
09FB4:  MOVF   FED,F
09FB6:  MOVFF  FEF,8B3
09FBA:  MOVLB  8
09FBC:  MOVF   xB3,W
09FBE:  SUBLW  02
09FC0:  BNZ   9FF0
09FC2:  MOVF   xB4,F
09FC4:  BNZ   9FF0
09FC6:  BCF    FD8.0
09FC8:  MOVLB  7
09FCA:  RLCF   x3C,W
09FCC:  CLRF   03
09FCE:  ADDLW  BF
09FD0:  MOVWF  FE9
09FD2:  MOVLW  07
09FD4:  ADDWFC 03,W
09FD6:  MOVWF  FEA
09FD8:  MOVFF  FEC,8B4
09FDC:  MOVF   FED,F
09FDE:  MOVFF  FEF,8B3
09FE2:  MOVLB  8
09FE4:  DECFSZ xB3,W
09FE6:  BRA    9FF0
09FE8:  MOVF   xB4,F
09FEA:  BNZ   9FF0
....................             { 
....................                port_port=4; 
09FEC:  MOVLW  04
09FEE:  MOVWF  xB2
....................             } 
....................              
....................             switch(port_port){ 
09FF0:  MOVF   xB2,W
09FF2:  ADDLW  FB
09FF4:  BC    A0AC
09FF6:  ADDLW  05
09FF8:  MOVLB  0
09FFA:  GOTO   A6A2
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
09FFE:  BCF    FD8.0
0A000:  MOVLB  7
0A002:  RLCF   x3C,W
0A004:  CLRF   03
0A006:  ADDLW  6A
0A008:  MOVWF  FE9
0A00A:  MOVLW  07
0A00C:  ADDWFC 03,W
0A00E:  MOVWF  FEA
0A010:  MOVFF  FEC,8B1
0A014:  MOVF   FED,F
0A016:  MOVFF  FEF,8B0
....................                   break; 
0A01A:  MOVLB  8
0A01C:  BRA    A0AC
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A01E:  BCF    FD8.0
0A020:  MOVLB  7
0A022:  RLCF   x3C,W
0A024:  CLRF   03
0A026:  ADDLW  7A
0A028:  MOVWF  FE9
0A02A:  MOVLW  07
0A02C:  ADDWFC 03,W
0A02E:  MOVWF  FEA
0A030:  MOVFF  FEC,03
0A034:  MOVF   FED,F
0A036:  MOVF   FEF,W
0A038:  MOVLB  8
0A03A:  ADDWF  xAE,W
0A03C:  MOVWF  xB0
0A03E:  MOVF   03,W
0A040:  ADDWFC xAF,W
0A042:  MOVWF  xB1
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A044:  BRA    A0AC
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A046:  BCF    FD8.0
0A048:  MOVLB  7
0A04A:  RLCF   x3C,W
0A04C:  CLRF   03
0A04E:  ADDLW  6A
0A050:  MOVWF  FE9
0A052:  MOVLW  07
0A054:  ADDWFC 03,W
0A056:  MOVWF  FEA
0A058:  MOVFF  FEC,8B1
0A05C:  MOVF   FED,F
0A05E:  MOVFF  FEF,8B0
....................                         ++m_steps; 
0A062:  MOVLW  01
0A064:  MOVLB  8
0A066:  ADDWF  xA5,F
0A068:  BTFSC  FD8.0
0A06A:  INCF   xA6,F
0A06C:  BTFSC  FD8.2
0A06E:  INCF   xA7,F
0A070:  BTFSC  FD8.2
0A072:  INCF   xA8,F
....................                   break; 
0A074:  BRA    A0AC
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A076:  BCF    FD8.0
0A078:  MOVLB  7
0A07A:  RLCF   x3C,W
0A07C:  CLRF   03
0A07E:  ADDLW  7A
0A080:  MOVWF  FE9
0A082:  MOVLW  07
0A084:  ADDWFC 03,W
0A086:  MOVWF  FEA
0A088:  MOVFF  FEC,03
0A08C:  MOVF   FED,F
0A08E:  MOVF   FEF,W
0A090:  MOVLB  8
0A092:  ADDWF  xAE,W
0A094:  MOVWF  xB0
0A096:  MOVF   03,W
0A098:  ADDWFC xAF,W
0A09A:  MOVWF  xB1
....................  
....................                   break; 
0A09C:  BRA    A0AC
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A09E:  MOVFF  8AF,8B1
0A0A2:  MOVFF  8AE,8B0
....................                   break;     
0A0A6:  MOVLB  8
0A0A8:  BRA    A0AC
0A0AA:  MOVLB  8
....................             } 
....................          } 
0A0AC:  BRA    A0D8
0A0AE:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A0B0:  MOVFF  8A8,8B6
0A0B4:  MOVFF  8A7,8B5
0A0B8:  MOVFF  8A6,8B4
0A0BC:  MOVFF  8A5,8B3
0A0C0:  MOVLB  0
0A0C2:  GOTO   8550
0A0C6:  MOVFF  03,8A8
0A0CA:  MOVFF  02,8A7
0A0CE:  MOVFF  01,8A6
0A0D2:  MOVFF  00,8A5
0A0D6:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A0D8:  DECFSZ xA3,W
0A0DA:  BRA    A102
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A0DC:  MOVFF  8A6,8B4
0A0E0:  MOVFF  8A5,8B3
0A0E4:  MOVFF  8A6,8B6
0A0E8:  MOVFF  8A5,8B5
0A0EC:  MOVLB  0
0A0EE:  GOTO   8762
0A0F2:  MOVLB  8
0A0F4:  CLRF   xA8
0A0F6:  CLRF   xA7
0A0F8:  MOVFF  02,8A6
0A0FC:  MOVFF  01,8A5
....................          } 
0A100:  BRA    A134
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A102:  MOVF   2F,W
0A104:  SUBLW  03
0A106:  BNZ   A134
0A108:  MOVF   30,F
0A10A:  BNZ   A134
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A10C:  BCF    FD8.0
0A10E:  MOVLB  7
0A110:  RLCF   x3C,W
0A112:  CLRF   03
0A114:  ADDLW  BB
0A116:  MOVWF  FE9
0A118:  MOVLW  07
0A11A:  ADDWFC 03,W
0A11C:  MOVWF  FEA
0A11E:  MOVFF  FEC,03
0A122:  MOVF   FED,F
0A124:  MOVF   FEF,W
0A126:  MOVLB  8
0A128:  SUBWF  xA5,F
0A12A:  MOVF   03,W
0A12C:  SUBWFB xA6,F
0A12E:  MOVLW  00
0A130:  SUBWFB xA7,F
0A132:  SUBWFB xA8,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A134:  MOVFF  8A9,8B3
0A138:  MOVLB  0
0A13A:  GOTO   8E2C
....................  
....................       while (m_running[motor]) 
0A13E:  BCF    FD8.0
0A140:  MOVLB  7
0A142:  RLCF   x3C,W
0A144:  CLRF   03
0A146:  ADDLW  8E
0A148:  MOVWF  FE9
0A14A:  MOVLW  07
0A14C:  ADDWFC 03,W
0A14E:  MOVWF  FEA
0A150:  MOVF   FEF,F
0A152:  BNZ   A15A
0A154:  MOVF   FEC,F
0A156:  BTFSC  FD8.2
0A158:  BRA    A650
....................       { 
....................          switch(e_mode[motor]) 
0A15A:  BCF    FD8.0
0A15C:  RLCF   x3C,W
0A15E:  CLRF   03
0A160:  ADDLW  62
0A162:  MOVWF  FE9
0A164:  MOVLW  07
0A166:  ADDWFC 03,W
0A168:  MOVWF  FEA
0A16A:  MOVF   FEF,W
0A16C:  MOVWF  00
0A16E:  MOVF   FEE,F
0A170:  MOVF   FED,W
0A172:  MOVWF  03
0A174:  MOVF   03,W
0A176:  BNZ   A180
0A178:  MOVF   00,F
0A17A:  MOVLB  0
0A17C:  BZ    A1CE
0A17E:  MOVLB  7
0A180:  MOVF   03,W
0A182:  BNZ   A18E
0A184:  MOVLW  01
0A186:  SUBWF  00,W
0A188:  MOVLB  0
0A18A:  BZ    A224
0A18C:  MOVLB  7
0A18E:  MOVF   03,W
0A190:  BNZ   A19C
0A192:  MOVLW  02
0A194:  SUBWF  00,W
0A196:  MOVLB  0
0A198:  BZ    A224
0A19A:  MOVLB  7
0A19C:  MOVF   03,W
0A19E:  BNZ   A1AC
0A1A0:  MOVLW  03
0A1A2:  SUBWF  00,W
0A1A4:  MOVLB  0
0A1A6:  BTFSC  FD8.2
0A1A8:  BRA    A2F2
0A1AA:  MOVLB  7
0A1AC:  MOVF   03,W
0A1AE:  BNZ   A1BC
0A1B0:  MOVLW  04
0A1B2:  SUBWF  00,W
0A1B4:  MOVLB  0
0A1B6:  BTFSC  FD8.2
0A1B8:  BRA    A442
0A1BA:  MOVLB  7
0A1BC:  MOVF   03,W
0A1BE:  BNZ   A1CC
0A1C0:  MOVLW  05
0A1C2:  SUBWF  00,W
0A1C4:  MOVLB  0
0A1C6:  BTFSC  FD8.2
0A1C8:  BRA    A592
0A1CA:  MOVLB  7
0A1CC:  BRA    A64A
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A1CE:  MOVLB  7
0A1D0:  MOVF   x3C,W
0A1D2:  MULLW  04
0A1D4:  MOVF   FF3,W
0A1D6:  CLRF   03
0A1D8:  ADDLW  9E
0A1DA:  MOVWF  FE9
0A1DC:  MOVLW  07
0A1DE:  ADDWFC 03,W
0A1E0:  MOVWF  FEA
0A1E2:  MOVFF  FEF,8B3
0A1E6:  MOVFF  FEC,8B4
0A1EA:  MOVFF  FEC,8B5
0A1EE:  MOVFF  FEC,8B6
0A1F2:  MOVLB  8
0A1F4:  MOVF   xA8,W
0A1F6:  SUBWF  xB6,W
0A1F8:  BNC   A21E
0A1FA:  BNZ   A212
0A1FC:  MOVF   xA7,W
0A1FE:  SUBWF  xB5,W
0A200:  BNC   A21E
0A202:  BNZ   A212
0A204:  MOVF   xA6,W
0A206:  SUBWF  xB4,W
0A208:  BNC   A21E
0A20A:  BNZ   A212
0A20C:  MOVF   xA5,W
0A20E:  SUBWF  xB3,W
0A210:  BNC   A21E
....................                { 
....................                   terminate(1); 
0A212:  MOVLW  01
0A214:  MOVWF  xC7
0A216:  MOVLB  0
0A218:  CALL   901A
0A21C:  MOVLB  8
....................                } 
....................                break; 
0A21E:  MOVLB  7
0A220:  BRA    A64A
0A222:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A224:  BCF    FD8.0
0A226:  MOVLB  7
0A228:  RLCF   x3C,W
0A22A:  CLRF   03
0A22C:  ADDLW  96
0A22E:  MOVWF  FE9
0A230:  MOVLW  07
0A232:  ADDWFC 03,W
0A234:  MOVWF  FEA
0A236:  MOVFF  FEC,8B4
0A23A:  MOVF   FED,F
0A23C:  MOVFF  FEF,8B3
0A240:  BCF    FD8.0
0A242:  RLCF   x3C,W
0A244:  CLRF   03
0A246:  ADDLW  56
0A248:  MOVWF  FE9
0A24A:  MOVLW  07
0A24C:  ADDWFC 03,W
0A24E:  MOVWF  FEA
0A250:  MOVFF  FEC,03
0A254:  MOVF   FED,F
0A256:  MOVFF  FEF,01
0A25A:  MOVF   03,W
0A25C:  MOVLB  8
0A25E:  SUBWF  xB4,W
0A260:  BNC   A274
0A262:  BNZ   A26A
0A264:  MOVF   01,W
0A266:  SUBWF  xB3,W
0A268:  BNC   A274
....................                { 
....................                   terminate(0); 
0A26A:  CLRF   xC7
0A26C:  MOVLB  0
0A26E:  CALL   901A
0A272:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A274:  BCF    FD8.0
0A276:  MOVLB  7
0A278:  RLCF   x3C,W
0A27A:  CLRF   03
0A27C:  ADDLW  B7
0A27E:  MOVWF  FE9
0A280:  MOVLW  07
0A282:  ADDWFC 03,W
0A284:  MOVWF  FEA
0A286:  MOVFF  FEC,8B4
0A28A:  MOVF   FED,F
0A28C:  MOVFF  FEF,8B3
0A290:  MOVLB  8
0A292:  MOVF   xA8,F
0A294:  BNZ   A2EC
0A296:  MOVF   xA7,F
0A298:  BNZ   A2EC
0A29A:  MOVF   xA6,W
0A29C:  SUBWF  xB4,W
0A29E:  BNC   A2EC
0A2A0:  BNZ   A2A8
0A2A2:  MOVF   xA5,W
0A2A4:  SUBWF  xB3,W
0A2A6:  BNC   A2EC
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A2A8:  BCF    FD8.0
0A2AA:  MOVLB  7
0A2AC:  RLCF   x3C,W
0A2AE:  CLRF   03
0A2B0:  ADDLW  B3
0A2B2:  MOVWF  FE9
0A2B4:  MOVLW  07
0A2B6:  ADDWFC 03,W
0A2B8:  MOVWF  FEA
0A2BA:  MOVFF  FEC,8BA
0A2BE:  MOVF   FED,F
0A2C0:  MOVFF  FEF,8B9
0A2C4:  MOVFF  8A8,8B8
0A2C8:  MOVFF  8A7,8B7
0A2CC:  MOVFF  8A6,8B6
0A2D0:  MOVFF  8A5,8B5
0A2D4:  MOVLB  0
0A2D6:  CALL   95DA
0A2DA:  MOVFF  03,8AD
0A2DE:  MOVFF  02,8AC
0A2E2:  MOVFF  01,8AB
0A2E6:  MOVFF  00,8AA
0A2EA:  MOVLB  8
....................                } 
....................                break; 
0A2EC:  MOVLB  7
0A2EE:  BRA    A64A
0A2F0:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A2F2:  BCF    FD8.0
0A2F4:  MOVLB  7
0A2F6:  RLCF   x3C,W
0A2F8:  CLRF   03
0A2FA:  ADDLW  B7
0A2FC:  MOVWF  FE9
0A2FE:  MOVLW  07
0A300:  ADDWFC 03,W
0A302:  MOVWF  FEA
0A304:  MOVFF  FEC,8B4
0A308:  MOVF   FED,F
0A30A:  MOVFF  FEF,8B3
0A30E:  MOVLB  8
0A310:  MOVF   xA8,F
0A312:  BNZ   A330
0A314:  MOVF   xA7,F
0A316:  BNZ   A330
0A318:  MOVF   xA6,W
0A31A:  SUBWF  xB4,W
0A31C:  BNC   A330
0A31E:  BNZ   A326
0A320:  MOVF   xA5,W
0A322:  SUBWF  xB3,W
0A324:  BNC   A330
....................                { 
....................                   terminate(0); 
0A326:  CLRF   xC7
0A328:  MOVLB  0
0A32A:  CALL   901A
0A32E:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A330:  BCF    FD8.0
0A332:  MOVLB  7
0A334:  RLCF   x3C,W
0A336:  CLRF   03
0A338:  ADDLW  76
0A33A:  MOVWF  FE9
0A33C:  MOVLW  07
0A33E:  ADDWFC 03,W
0A340:  MOVWF  FEA
0A342:  MOVFF  FEC,8B4
0A346:  MOVF   FED,F
0A348:  MOVFF  FEF,8B3
0A34C:  MOVLB  8
0A34E:  MOVF   xB3,F
0A350:  BNZ   A3B6
0A352:  MOVF   xB4,F
0A354:  BNZ   A3B6
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A356:  CLRF   03
0A358:  MOVLB  7
0A35A:  MOVF   x3C,W
0A35C:  ADDLW  C7
0A35E:  MOVWF  FE9
0A360:  MOVLW  07
0A362:  ADDWFC 03,W
0A364:  MOVWF  FEA
0A366:  MOVF   FEF,F
0A368:  BNZ   A3B4
....................                   { 
....................                      wrt_m_error(); 
0A36A:  MOVLB  0
0A36C:  CALL   8ECA
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A370:  BCF    FD8.0
0A372:  MOVLB  7
0A374:  RLCF   x3C,W
0A376:  CLRF   03
0A378:  ADDLW  B3
0A37A:  MOVWF  FE9
0A37C:  MOVLW  07
0A37E:  ADDWFC 03,W
0A380:  MOVWF  FEA
0A382:  MOVFF  FEC,8BA
0A386:  MOVF   FED,F
0A388:  MOVFF  FEF,8B9
0A38C:  MOVFF  8A8,8B8
0A390:  MOVFF  8A7,8B7
0A394:  MOVFF  8A6,8B6
0A398:  MOVFF  8A5,8B5
0A39C:  MOVLB  0
0A39E:  CALL   95DA
0A3A2:  MOVFF  03,8AD
0A3A6:  MOVFF  02,8AC
0A3AA:  MOVFF  01,8AB
0A3AE:  MOVFF  00,8AA
0A3B2:  MOVLB  7
0A3B4:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A3B6:  BCF    FD8.0
0A3B8:  MOVLB  7
0A3BA:  RLCF   x3C,W
0A3BC:  CLRF   03
0A3BE:  ADDLW  76
0A3C0:  MOVWF  FE9
0A3C2:  MOVLW  07
0A3C4:  ADDWFC 03,W
0A3C6:  MOVWF  FEA
0A3C8:  MOVFF  FEC,8B4
0A3CC:  MOVF   FED,F
0A3CE:  MOVFF  FEF,8B3
0A3D2:  MOVLB  8
0A3D4:  DECFSZ xB3,W
0A3D6:  BRA    A43C
0A3D8:  MOVF   xB4,F
0A3DA:  BNZ   A43C
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A3DC:  CLRF   03
0A3DE:  MOVLB  7
0A3E0:  MOVF   x3C,W
0A3E2:  ADDLW  C7
0A3E4:  MOVWF  FE9
0A3E6:  MOVLW  07
0A3E8:  ADDWFC 03,W
0A3EA:  MOVWF  FEA
0A3EC:  DECFSZ FEF,W
0A3EE:  BRA    A43A
....................                   { 
....................                      wrt_m_error(); 
0A3F0:  MOVLB  0
0A3F2:  CALL   8ECA
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A3F6:  BCF    FD8.0
0A3F8:  MOVLB  7
0A3FA:  RLCF   x3C,W
0A3FC:  CLRF   03
0A3FE:  ADDLW  B3
0A400:  MOVWF  FE9
0A402:  MOVLW  07
0A404:  ADDWFC 03,W
0A406:  MOVWF  FEA
0A408:  MOVFF  FEC,8BA
0A40C:  MOVF   FED,F
0A40E:  MOVFF  FEF,8B9
0A412:  MOVFF  8A8,8B8
0A416:  MOVFF  8A7,8B7
0A41A:  MOVFF  8A6,8B6
0A41E:  MOVFF  8A5,8B5
0A422:  MOVLB  0
0A424:  CALL   95DA
0A428:  MOVFF  03,8AD
0A42C:  MOVFF  02,8AC
0A430:  MOVFF  01,8AB
0A434:  MOVFF  00,8AA
0A438:  MOVLB  7
0A43A:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A43C:  MOVLB  7
0A43E:  BRA    A64A
0A440:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A442:  MOVLB  7
0A444:  MOVF   x3C,W
0A446:  MULLW  04
0A448:  MOVF   FF3,W
0A44A:  CLRF   03
0A44C:  ADDLW  9E
0A44E:  MOVWF  FE9
0A450:  MOVLW  07
0A452:  ADDWFC 03,W
0A454:  MOVWF  FEA
0A456:  MOVFF  FEF,8B3
0A45A:  MOVFF  FEC,8B4
0A45E:  MOVFF  FEC,8B5
0A462:  MOVFF  FEC,8B6
0A466:  MOVLB  8
0A468:  MOVF   xAA,W
0A46A:  SUBWF  xB3,F
0A46C:  MOVF   xAB,W
0A46E:  SUBWFB xB4,F
0A470:  MOVF   xAC,W
0A472:  SUBWFB xB5,F
0A474:  MOVF   xAD,W
0A476:  SUBWFB xB6,F
0A478:  BNZ   A490
0A47A:  MOVF   xB5,F
0A47C:  BNZ   A490
0A47E:  MOVF   xB1,W
0A480:  SUBWF  xB4,W
0A482:  BTFSS  FD8.0
0A484:  BRA    A58C
0A486:  BNZ   A490
0A488:  MOVF   xB0,W
0A48A:  SUBWF  xB3,W
0A48C:  BTFSS  FD8.0
0A48E:  BRA    A58C
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A490:  BCF    FD8.0
0A492:  MOVLB  7
0A494:  RLCF   x3C,W
0A496:  CLRF   03
0A498:  ADDLW  62
0A49A:  MOVWF  01
0A49C:  MOVLW  07
0A49E:  ADDWFC 03,F
0A4A0:  MOVLB  8
0A4A2:  MOVFF  03,8B4
0A4A6:  BCF    FD8.0
0A4A8:  MOVLB  7
0A4AA:  RLCF   x3C,W
0A4AC:  CLRF   03
0A4AE:  ADDLW  9A
0A4B0:  MOVWF  FE9
0A4B2:  MOVLW  07
0A4B4:  ADDWFC 03,W
0A4B6:  MOVWF  FEA
0A4B8:  MOVFF  FEC,03
0A4BC:  MOVF   FED,F
0A4BE:  MOVFF  FEF,8B5
0A4C2:  MOVLB  8
0A4C4:  MOVFF  8B4,FEA
0A4C8:  MOVFF  01,FE9
0A4CC:  MOVFF  03,FEC
0A4D0:  MOVF   FED,F
0A4D2:  MOVFF  8B5,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A4D6:  MOVLB  7
0A4D8:  MOVF   x3C,W
0A4DA:  MULLW  04
0A4DC:  MOVF   FF3,W
0A4DE:  CLRF   03
0A4E0:  ADDLW  9E
0A4E2:  MOVWF  FE9
0A4E4:  MOVLW  07
0A4E6:  ADDWFC 03,W
0A4E8:  MOVWF  FEA
0A4EA:  MOVFF  FEF,8B3
0A4EE:  MOVFF  FEC,8B4
0A4F2:  MOVFF  FEC,8B5
0A4F6:  MOVFF  FEC,8B6
0A4FA:  MOVLW  6E
0A4FC:  MOVWF  FF6
0A4FE:  MOVLW  1A
0A500:  MOVWF  FF7
0A502:  MOVLW  00
0A504:  MOVWF  FF8
0A506:  CLRF   1B
0A508:  BTFSC  FF2.7
0A50A:  BSF    1B.7
0A50C:  BCF    FF2.7
0A50E:  MOVLW  0B
0A510:  MOVLB  A
0A512:  MOVWF  x18
0A514:  MOVLB  0
0A516:  CALL   1006
0A51A:  BTFSC  1B.7
0A51C:  BSF    FF2.7
0A51E:  MOVLW  41
0A520:  MOVWF  FE9
0A522:  CLRF   1B
0A524:  BTFSC  FF2.7
0A526:  BSF    1B.7
0A528:  BCF    FF2.7
0A52A:  MOVFF  8B6,A1B
0A52E:  MOVFF  8B5,A1A
0A532:  MOVFF  8B4,A19
0A536:  MOVFF  8B3,A18
0A53A:  CALL   10CC
0A53E:  BTFSC  1B.7
0A540:  BSF    FF2.7
0A542:  MOVLW  2C
0A544:  BTFSS  F9E.4
0A546:  BRA    A544
0A548:  MOVWF  FAD
0A54A:  MOVLW  41
0A54C:  MOVWF  FE9
0A54E:  CLRF   1B
0A550:  BTFSC  FF2.7
0A552:  BSF    1B.7
0A554:  BCF    FF2.7
0A556:  MOVFF  8AD,A1B
0A55A:  MOVFF  8AC,A1A
0A55E:  MOVFF  8AB,A19
0A562:  MOVFF  8AA,A18
0A566:  CALL   10CC
0A56A:  BTFSC  1B.7
0A56C:  BSF    FF2.7
0A56E:  MOVLW  0D
0A570:  BTFSS  F9E.4
0A572:  BRA    A570
0A574:  MOVWF  FAD
0A576:  MOVLW  0A
0A578:  BTFSS  F9E.4
0A57A:  BRA    A578
0A57C:  MOVWF  FAD
....................                   terminate(1); 
0A57E:  MOVLW  01
0A580:  MOVLB  8
0A582:  MOVWF  xC7
0A584:  MOVLB  0
0A586:  CALL   901A
0A58A:  MOVLB  8
....................                } 
....................                break; 
0A58C:  MOVLB  7
0A58E:  BRA    A64A
0A590:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A592:  MOVLB  7
0A594:  MOVF   x3C,W
0A596:  MULLW  04
0A598:  MOVF   FF3,W
0A59A:  CLRF   03
0A59C:  ADDLW  9E
0A59E:  MOVWF  FE9
0A5A0:  MOVLW  07
0A5A2:  ADDWFC 03,W
0A5A4:  MOVWF  FEA
0A5A6:  MOVFF  FEF,8B3
0A5AA:  MOVFF  FEC,8B4
0A5AE:  MOVFF  FEC,8B5
0A5B2:  MOVFF  FEC,8B6
0A5B6:  BCF    FD8.0
0A5B8:  RLCF   x3C,W
0A5BA:  CLRF   03
0A5BC:  ADDLW  6E
0A5BE:  MOVWF  FE9
0A5C0:  MOVLW  07
0A5C2:  ADDWFC 03,W
0A5C4:  MOVWF  FEA
0A5C6:  MOVFF  FEC,03
0A5CA:  MOVF   FED,F
0A5CC:  MOVFF  FEF,01
0A5D0:  MOVLB  8
0A5D2:  MOVF   xB6,F
0A5D4:  BNZ   A5E8
0A5D6:  MOVF   xB5,F
0A5D8:  BNZ   A5E8
0A5DA:  MOVF   03,W
0A5DC:  SUBWF  xB4,W
0A5DE:  BNC   A648
0A5E0:  BNZ   A5E8
0A5E2:  MOVF   01,W
0A5E4:  SUBWF  xB3,W
0A5E6:  BNC   A648
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A5E8:  BCF    FD8.0
0A5EA:  MOVLB  7
0A5EC:  RLCF   x3C,W
0A5EE:  CLRF   03
0A5F0:  ADDLW  62
0A5F2:  MOVWF  01
0A5F4:  MOVLW  07
0A5F6:  ADDWFC 03,F
0A5F8:  MOVLB  8
0A5FA:  MOVFF  03,8B4
0A5FE:  BCF    FD8.0
0A600:  MOVLB  7
0A602:  RLCF   x3C,W
0A604:  CLRF   03
0A606:  ADDLW  9A
0A608:  MOVWF  FE9
0A60A:  MOVLW  07
0A60C:  ADDWFC 03,W
0A60E:  MOVWF  FEA
0A610:  MOVFF  FEC,03
0A614:  MOVF   FED,F
0A616:  MOVFF  FEF,8B5
0A61A:  MOVLB  8
0A61C:  MOVFF  8B4,FEA
0A620:  MOVFF  01,FE9
0A624:  MOVFF  03,FEC
0A628:  MOVF   FED,F
0A62A:  MOVFF  8B5,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A62E:  BCF    FD8.0
0A630:  MOVLB  7
0A632:  RLCF   x3C,W
0A634:  CLRF   03
0A636:  ADDLW  B7
0A638:  MOVWF  FE9
0A63A:  MOVLW  07
0A63C:  ADDWFC 03,W
0A63E:  MOVWF  FEA
0A640:  CLRF   FEC
0A642:  MOVF   FED,F
0A644:  CLRF   FEF
0A646:  MOVLB  8
....................                } 
....................                break; 
0A648:  MOVLB  7
....................             } 
....................          } 
0A64A:  MOVLB  0
0A64C:  BRA    A13E
0A64E:  MOVLB  7
....................       } 
....................    } 
0A650:  BRA    A66E
0A652:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A654:  BCF    FD8.0
0A656:  MOVLB  7
0A658:  RLCF   x3C,W
0A65A:  CLRF   03
0A65C:  ADDLW  92
0A65E:  MOVWF  FE9
0A660:  MOVLW  07
0A662:  ADDWFC 03,W
0A664:  MOVWF  FEA
0A666:  CLRF   FEC
0A668:  MOVF   FED,F
0A66A:  MOVLW  01
0A66C:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A66E:  BCF    FD8.0
0A670:  RLCF   x3C,W
0A672:  CLRF   03
0A674:  ADDLW  92
0A676:  MOVWF  FE9
0A678:  MOVLW  07
0A67A:  ADDWFC 03,W
0A67C:  MOVWF  FEA
0A67E:  MOVFF  FEC,8B4
0A682:  MOVF   FED,F
0A684:  MOVFF  FEF,8B3
0A688:  MOVLB  8
0A68A:  DECFSZ xB3,W
0A68C:  BRA    A69E
0A68E:  MOVF   xB4,F
0A690:  BNZ   A69E
....................       wrt_m_error(); 
0A692:  MOVLB  0
0A694:  CALL   8ECA
....................       msg_mer(); 
0A698:  CALL   9C4C
0A69C:  MOVLB  8
....................    } 
0A69E:  MOVLB  0
0A6A0:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
16B6A:  MOVF   44,F
16B6C:  BNZ   16B7A
16B6E:  MOVF   45,F
16B70:  BNZ   16B7A
16B72:  MOVF   46,F
16B74:  BNZ   16B7A
16B76:  MOVF   47,F
16B78:  BZ    16BA6
16B7A:  MOVF   47,F
16B7C:  BNZ   16BA6
16B7E:  MOVF   46,W
16B80:  SUBLW  00
16B82:  BNC   16BA6
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
16B84:  MOVFF  861,8A3
16B88:  MOVFF  862,8A4
16B8C:  MOVFF  47,8A8
16B90:  MOVFF  46,8A7
16B94:  MOVFF  45,8A6
16B98:  MOVFF  44,8A5
16B9C:  MOVFF  863,8A9
16BA0:  CALL   9CC2
....................    } 
16BA4:  BRA    16C22
....................    else if(arg==0) 
16BA6:  MOVF   44,F
16BA8:  BNZ   16C1E
16BAA:  MOVF   45,F
16BAC:  BNZ   16C1E
16BAE:  MOVF   46,F
16BB0:  BNZ   16C1E
16BB2:  MOVF   47,F
16BB4:  BNZ   16C1E
....................    { 
....................       m_lin_pos[motor]=0; 
16BB6:  BCF    FD8.0
16BB8:  MOVLB  7
16BBA:  RLCF   x3C,W
16BBC:  CLRF   03
16BBE:  ADDLW  AF
16BC0:  MOVWF  FE9
16BC2:  MOVLW  07
16BC4:  ADDWFC 03,W
16BC6:  MOVWF  FEA
16BC8:  CLRF   FEC
16BCA:  MOVF   FED,F
16BCC:  CLRF   FEF
....................       switch (motor){ 
16BCE:  MOVF   x3C,W
16BD0:  XORLW  00
16BD2:  MOVLB  0
16BD4:  BZ    16BDC
16BD6:  XORLW  01
16BD8:  BZ    16BEE
16BDA:  BRA    16BFE
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
16BDC:  MOVLW  B6
16BDE:  MOVLB  8
16BE0:  MOVWF  xCA
16BE2:  CLRF   xCC
16BE4:  CLRF   xCB
16BE6:  MOVLB  0
16BE8:  CALL   4F52
....................             break; 
16BEC:  BRA    16BFE
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
16BEE:  MOVLW  B8
16BF0:  MOVLB  8
16BF2:  MOVWF  xCA
16BF4:  CLRF   xCC
16BF6:  CLRF   xCB
16BF8:  MOVLB  0
16BFA:  CALL   4F52
....................             break; 
....................       }  
....................       m_error[motor]=0; 
16BFE:  BCF    FD8.0
16C00:  MOVLB  7
16C02:  RLCF   x3C,W
16C04:  CLRF   03
16C06:  ADDLW  92
16C08:  MOVWF  FE9
16C0A:  MOVLW  07
16C0C:  ADDWFC 03,W
16C0E:  MOVWF  FEA
16C10:  CLRF   FEC
16C12:  MOVF   FED,F
16C14:  CLRF   FEF
....................       wrt_m_error(); 
16C16:  MOVLB  0
16C18:  CALL   8ECA
....................    } 
16C1C:  BRA    16C22
....................    else cmd_arg(); 
16C1E:  CALL   AF7A
16C22:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
18618:  MOVLW  01
1861A:  MOVLB  8
1861C:  MOVWF  xC8
1861E:  MOVLB  0
18620:  CALL   891A
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18624:  MOVLW  FA
18626:  MOVLB  9
18628:  MOVWF  xC8
1862A:  MOVLB  0
1862C:  CALL   288E
....................       switch(motor) 
18630:  MOVLB  7
18632:  MOVF   x3C,W
18634:  XORLW  00
18636:  MOVLB  0
18638:  BZ    18640
1863A:  XORLW  01
1863C:  BZ    18652
1863E:  BRA    18662
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18640:  MOVLB  8
18642:  CLRF   x61
18644:  BTFSC  F81.4
18646:  INCF   x61,F
....................             chanA = input(ENC1_PHA); 
18648:  CLRF   x62
1864A:  BTFSC  F81.1
1864C:  INCF   x62,F
....................             break; 
1864E:  MOVLB  0
18650:  BRA    18662
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18652:  MOVLB  8
18654:  CLRF   x61
18656:  BTFSC  F81.5
18658:  INCF   x61,F
....................             chanA = input(ENC2_PHA); 
1865A:  CLRF   x62
1865C:  BTFSC  F81.2
1865E:  INCF   x62,F
....................             break; 
18660:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18662:  MOVLW  84
18664:  MOVWF  FF6
18666:  MOVLW  1A
18668:  MOVWF  FF7
1866A:  MOVLW  00
1866C:  MOVWF  FF8
1866E:  CLRF   1B
18670:  BTFSC  FF2.7
18672:  BSF    1B.7
18674:  BCF    FF2.7
18676:  MOVLW  04
18678:  MOVLB  A
1867A:  MOVWF  x18
1867C:  MOVLB  0
1867E:  CALL   1006
18682:  BTFSC  1B.7
18684:  BSF    FF2.7
18686:  CLRF   1B
18688:  BTFSC  FF2.7
1868A:  BSF    1B.7
1868C:  BCF    FF2.7
1868E:  MOVFF  861,A18
18692:  MOVLW  1B
18694:  MOVLB  A
18696:  MOVWF  x19
18698:  MOVLB  0
1869A:  CALL   0F88
1869E:  BTFSC  1B.7
186A0:  BSF    FF2.7
186A2:  MOVLW  8A
186A4:  MOVWF  FF6
186A6:  MOVLW  1A
186A8:  MOVWF  FF7
186AA:  MOVLW  00
186AC:  MOVWF  FF8
186AE:  CLRF   1B
186B0:  BTFSC  FF2.7
186B2:  BSF    1B.7
186B4:  BCF    FF2.7
186B6:  MOVLW  07
186B8:  MOVLB  A
186BA:  MOVWF  x18
186BC:  MOVLB  0
186BE:  CALL   1006
186C2:  BTFSC  1B.7
186C4:  BSF    FF2.7
186C6:  CLRF   1B
186C8:  BTFSC  FF2.7
186CA:  BSF    1B.7
186CC:  BCF    FF2.7
186CE:  MOVFF  862,A18
186D2:  MOVLW  1B
186D4:  MOVLB  A
186D6:  MOVWF  x19
186D8:  MOVLB  0
186DA:  CALL   0F88
186DE:  BTFSC  1B.7
186E0:  BSF    FF2.7
186E2:  MOVLW  0D
186E4:  BTFSS  F9E.4
186E6:  BRA    186E4
186E8:  MOVWF  FAD
186EA:  MOVLW  0A
186EC:  BTFSS  F9E.4
186EE:  BRA    186EC
186F0:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
186F2:  BTFSS  F9E.5
186F4:  BRA    18702
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
186F6:  CALL   0E1A
186FA:  MOVF   01,W
186FC:  SUBLW  1B
186FE:  BNZ   18702
....................          { 
....................             break; 
18700:  BRA    18704
....................          } 
....................       } 
18702:  BRA    18624
....................    } 
....................  
....................    delay_ms(100); 
18704:  MOVLW  64
18706:  MOVLB  9
18708:  MOVWF  xC8
1870A:  MOVLB  0
1870C:  CALL   288E
....................    enc_pwr(OFF); 
18710:  MOVLB  8
18712:  CLRF   xC8
18714:  MOVLB  0
18716:  CALL   891A
1871A:  GOTO   18736 (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A7FE:  BCF    FD8.0
0A800:  MOVLB  7
0A802:  RLCF   x3C,W
0A804:  CLRF   03
0A806:  ADDLW  62
0A808:  MOVWF  FE9
0A80A:  MOVLW  07
0A80C:  ADDWFC 03,W
0A80E:  MOVWF  FEA
0A810:  MOVFF  FEC,8A2
0A814:  MOVF   FED,F
0A816:  MOVFF  FEF,8A1
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A81A:  BCF    FD8.0
0A81C:  RLCF   x3C,W
0A81E:  CLRF   03
0A820:  ADDLW  72
0A822:  MOVWF  FE9
0A824:  MOVLW  07
0A826:  ADDWFC 03,W
0A828:  MOVWF  FEA
0A82A:  MOVFF  FEC,8B8
0A82E:  MOVF   FED,F
0A830:  MOVFF  FEF,8B7
0A834:  BCF    FD8.0
0A836:  RLCF   x3C,W
0A838:  CLRF   03
0A83A:  ADDLW  5E
0A83C:  MOVWF  FE9
0A83E:  MOVLW  07
0A840:  ADDWFC 03,W
0A842:  MOVWF  FEA
0A844:  MOVFF  FEC,03
0A848:  MOVF   FED,F
0A84A:  MOVFF  FEF,8B9
0A84E:  MOVFF  03,8A6
0A852:  MOVFF  03,8BA
0A856:  MOVLB  0
0A858:  CALL   2C52
0A85C:  MOVFF  02,8A0
0A860:  MOVFF  01,89F
....................    e_mode[motor] = 0;                          // motor steps 
0A864:  BCF    FD8.0
0A866:  MOVLB  7
0A868:  RLCF   x3C,W
0A86A:  CLRF   03
0A86C:  ADDLW  62
0A86E:  MOVWF  FE9
0A870:  MOVLW  07
0A872:  ADDWFC 03,W
0A874:  MOVWF  FEA
0A876:  CLRF   FEC
0A878:  MOVF   FED,F
0A87A:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A87C:  MOVLB  8
0A87E:  CLRF   xA3
0A880:  MOVFF  89E,8A4
0A884:  CLRF   xA8
0A886:  CLRF   xA7
0A888:  MOVFF  8A0,8A6
0A88C:  MOVFF  89F,8A5
0A890:  MOVLW  01
0A892:  MOVWF  xA9
0A894:  MOVLB  0
0A896:  CALL   9CC2
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A89A:  MOVLW  01
0A89C:  MOVLB  8
0A89E:  MOVWF  xC8
0A8A0:  MOVLB  0
0A8A2:  CALL   891A
....................    delay_ms(100); 
0A8A6:  MOVLW  64
0A8A8:  MOVLB  9
0A8AA:  MOVWF  xC8
0A8AC:  MOVLB  0
0A8AE:  CALL   288E
....................    poll_index(); 
0A8B2:  BRA    A6CC
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A8B4:  BCF    FD8.0
0A8B6:  MOVLB  7
0A8B8:  RLCF   x3C,W
0A8BA:  CLRF   03
0A8BC:  ADDLW  5A
0A8BE:  MOVWF  FE9
0A8C0:  MOVLW  07
0A8C2:  ADDWFC 03,W
0A8C4:  MOVWF  FEA
0A8C6:  MOVFF  FEC,8A4
0A8CA:  MOVF   FED,F
0A8CC:  MOVFF  FEF,8A3
0A8D0:  MOVLW  02
0A8D2:  MOVLB  8
0A8D4:  ADDWF  xA3,W
0A8D6:  MOVWF  x9F
0A8D8:  MOVLW  00
0A8DA:  ADDWFC xA4,W
0A8DC:  MOVWF  xA0
....................    e_mode[motor] = 3; 
0A8DE:  BCF    FD8.0
0A8E0:  MOVLB  7
0A8E2:  RLCF   x3C,W
0A8E4:  CLRF   03
0A8E6:  ADDLW  62
0A8E8:  MOVWF  FE9
0A8EA:  MOVLW  07
0A8EC:  ADDWFC 03,W
0A8EE:  MOVWF  FEA
0A8F0:  CLRF   FEC
0A8F2:  MOVF   FED,F
0A8F4:  MOVLW  03
0A8F6:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A8F8:  MOVLB  8
0A8FA:  CLRF   xA3
0A8FC:  MOVFF  89E,8A4
0A900:  CLRF   xA8
0A902:  CLRF   xA7
0A904:  MOVFF  8A0,8A6
0A908:  MOVFF  89F,8A5
0A90C:  MOVLW  01
0A90E:  MOVWF  xA9
0A910:  MOVLB  0
0A912:  CALL   9CC2
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A916:  MOVFF  77F,8A0
0A91A:  MOVFF  77E,89F
....................    e_mode[motor] = 0;                          // motor steps 
0A91E:  BCF    FD8.0
0A920:  MOVLB  7
0A922:  RLCF   x3C,W
0A924:  CLRF   03
0A926:  ADDLW  62
0A928:  MOVWF  FE9
0A92A:  MOVLW  07
0A92C:  ADDWFC 03,W
0A92E:  MOVWF  FEA
0A930:  CLRF   FEC
0A932:  MOVF   FED,F
0A934:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0A936:  MOVLB  8
0A938:  CLRF   xA3
0A93A:  MOVFF  89E,8A4
0A93E:  CLRF   xA8
0A940:  CLRF   xA7
0A942:  MOVFF  8A0,8A6
0A946:  MOVFF  89F,8A5
0A94A:  MOVLW  01
0A94C:  MOVWF  xA9
0A94E:  MOVLB  0
0A950:  CALL   9CC2
....................  
....................    e_pos[motor] = 0; 
0A954:  BCF    FD8.0
0A956:  MOVLB  7
0A958:  RLCF   x3C,W
0A95A:  CLRF   03
0A95C:  ADDLW  BB
0A95E:  MOVWF  FE9
0A960:  MOVLW  07
0A962:  ADDWFC 03,W
0A964:  MOVWF  FEA
0A966:  CLRF   FEC
0A968:  MOVF   FED,F
0A96A:  CLRF   FEF
....................    e_port[motor] = 1; 
0A96C:  BCF    FD8.0
0A96E:  RLCF   x3C,W
0A970:  CLRF   03
0A972:  ADDLW  BF
0A974:  MOVWF  FE9
0A976:  MOVLW  07
0A978:  ADDWFC 03,W
0A97A:  MOVWF  FEA
0A97C:  CLRF   FEC
0A97E:  MOVF   FED,F
0A980:  MOVLW  01
0A982:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0A984:  BCF    FD8.0
0A986:  RLCF   x3C,W
0A988:  CLRF   03
0A98A:  ADDLW  62
0A98C:  MOVWF  FE9
0A98E:  MOVLW  07
0A990:  ADDWFC 03,W
0A992:  MOVWF  FEA
0A994:  MOVFF  8A2,FEC
0A998:  MOVF   FED,F
0A99A:  MOVFF  8A1,FEF
0A99E:  MOVLB  0
0A9A0:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0DDB4:  BCF    FD8.0
0DDB6:  MOVLB  7
0DDB8:  RLCF   x3C,W
0DDBA:  CLRF   03
0DDBC:  ADDLW  5A
0DDBE:  MOVWF  FE9
0DDC0:  MOVLW  07
0DDC2:  ADDWFC 03,W
0DDC4:  MOVWF  FEA
0DDC6:  MOVFF  FEC,865
0DDCA:  MOVF   FED,F
0DDCC:  MOVFF  FEF,864
0DDD0:  MOVLW  02
0DDD2:  MOVLB  8
0DDD4:  ADDWF  x64,W
0DDD6:  MOVWF  x62
0DDD8:  MOVLW  00
0DDDA:  ADDWFC x65,W
0DDDC:  MOVWF  x63
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0DDDE:  CLRF   xA3
0DDE0:  MOVFF  861,8A4
0DDE4:  CLRF   xA8
0DDE6:  CLRF   xA7
0DDE8:  MOVFF  863,8A6
0DDEC:  MOVFF  862,8A5
0DDF0:  MOVLW  02
0DDF2:  MOVWF  xA9
0DDF4:  MOVLB  0
0DDF6:  CALL   9CC2
0DDFA:  GOTO   DE7A (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0A9A2:  MOVF   2F,W
0A9A4:  SUBLW  02
0A9A6:  BNZ   A9AC
0A9A8:  MOVF   30,F
0A9AA:  BZ    AA0C
....................    { 
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0A9AC:  MOVLW  96
0A9AE:  MOVWF  FF6
0A9B0:  MOVLW  1A
0A9B2:  MOVWF  FF7
0A9B4:  MOVLW  00
0A9B6:  MOVWF  FF8
0A9B8:  CLRF   1B
0A9BA:  BTFSC  FF2.7
0A9BC:  BSF    1B.7
0A9BE:  BCF    FF2.7
0A9C0:  CALL   0E30
0A9C4:  BTFSC  1B.7
0A9C6:  BSF    FF2.7
....................       motor=0; 
0A9C8:  MOVLB  7
0A9CA:  CLRF   x3C
....................       align(0); 
0A9CC:  MOVLB  8
0A9CE:  CLRF   x9E
0A9D0:  MOVLB  0
0A9D2:  RCALL  A7FE
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0A9D4:  MOVLW  01
0A9D6:  MOVLB  7
0A9D8:  MOVWF  x3C
....................       move_motor(0,0,22000,1); 
0A9DA:  MOVLB  8
0A9DC:  CLRF   xA3
0A9DE:  CLRF   xA4
0A9E0:  CLRF   xA8
0A9E2:  CLRF   xA7
0A9E4:  MOVLW  55
0A9E6:  MOVWF  xA6
0A9E8:  MOVLW  F0
0A9EA:  MOVWF  xA5
0A9EC:  MOVLW  01
0A9EE:  MOVWF  xA9
0A9F0:  MOVLB  0
0A9F2:  CALL   9CC2
....................        
....................       m_lin_pos[1]=0; 
0A9F6:  MOVLB  7
0A9F8:  CLRF   xB2
0A9FA:  CLRF   xB1
....................       write16(ADDR_M2_LIN_POS,0); 
0A9FC:  MOVLW  B8
0A9FE:  MOVLB  8
0AA00:  MOVWF  xCA
0AA02:  CLRF   xCC
0AA04:  CLRF   xCB
0AA06:  MOVLB  0
0AA08:  CALL   4F52
....................    } 
0AA0C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0BE7E:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BE80:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0BE82:  BCF    F8E.3
....................   delay_ms(20); 
0BE84:  MOVLW  14
0BE86:  MOVLB  9
0BE88:  MOVWF  xC8
0BE8A:  MOVLB  0
0BE8C:  CALL   288E
....................   output_bit(VMOT,  OFF); 
0BE90:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0BE92:  BCF    F8E.2
0BE94:  GOTO   BEEA (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BE98:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BE9A:  BSF    F8E.1
....................   delay_ms(50); 
0BE9C:  MOVLW  32
0BE9E:  MOVLB  9
0BEA0:  MOVWF  xC8
0BEA2:  MOVLB  0
0BEA4:  CALL   288E
....................   output_bit(HB_IN1,ON);           
0BEA8:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BEAA:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0BEAC:  BSF    F8E.3
0BEAE:  GOTO   BEEA (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BEB2:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BEB4:  BSF    F8E.1
....................   delay_ms(50); 
0BEB6:  MOVLW  32
0BEB8:  MOVLB  9
0BEBA:  MOVWF  xC8
0BEBC:  MOVLB  0
0BEBE:  CALL   288E
....................   output_bit(HB_IN1,OFF);           
0BEC2:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0BEC4:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0BEC6:  BSF    F8E.3
0BEC8:  GOTO   BEEA (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0BECC:  MOVLB  8
0BECE:  MOVF   x91,W
0BED0:  XORLW  00
0BED2:  MOVLB  0
0BED4:  BZ    BEE0
0BED6:  XORLW  01
0BED8:  BZ    BEE4
0BEDA:  XORLW  03
0BEDC:  BZ    BEE8
0BEDE:  BRA    BEEA
....................       case 0:  HB_all_OFF(); 
0BEE0:  BRA    BE7E
....................          break; 
0BEE2:  BRA    BEEA
....................       case 1:  HB_m1_ON(); 
0BEE4:  BRA    BE98
....................          break; 
0BEE6:  BRA    BEEA
....................       case 2:  HB_m2_ON(); 
0BEE8:  BRA    BEB2
....................          break; 
....................    } 
0BEEA:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... serial_wakeup_reason_t serial_wakeup() 
*
158D6:  MOVLB  8
158D8:  CLRF   x65
158DA:  CLRF   x66
158DC:  CLRF   x67
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
158DE:  MOVLB  0
158E0:  BRA    1586C
158E2:  MOVFF  01,866
....................       if (serChar) 
158E6:  MOVLB  8
158E8:  MOVF   x66,F
158EA:  BZ    158FE
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
158EC:  MOVF   x66,W
158EE:  SUBLW  24
158F0:  BNZ   158FA
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
158F2:  MOVLW  02
158F4:  MOVWF  x67
....................             break; 
158F6:  BRA    1590A
....................          } 
158F8:  BRA    158FE
....................          else 
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
158FA:  MOVLW  01
158FC:  MOVWF  x67
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
158FE:  INCF   x65,F
15900:  MOVF   x65,W
15902:  SUBLW  02
15904:  BC    15908
....................       { 
....................          break; 
15906:  BRA    1590A
....................       } 
15908:  BRA    158DE
....................    } 
....................  
....................    return (wakeUpReason); 
1590A:  MOVFF  867,01
1590E:  MOVLB  0
15910:  GOTO   15924 (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
15804:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
15806:  BSF    49.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
15808:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
1580A:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
1580C:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
1580E:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
15810:  BSF    FF2.6
15812:  GOTO   1581E (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
15816:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
15818:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
1581A:  BCF    49.0
....................    set_usart_int(); 
1581C:  BRA    15804
....................    kill_wd(); 
1581E:  CALL   3074
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
15822:  BSF    FF2.4
....................    sleep();  
15824:  MOVFF  FD3,00
15828:  BCF    FD1.7
1582A:  BCF    FD3.7
1582C:  SLEEP 
1582E:  MOVFF  00,FD3
....................    delay_cycles(1); 
15832:  NOP   
15834:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
15914:  MOVLB  8
15916:  CLRF   x64
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
15918:  MOVLB  0
1591A:  RCALL  15836
....................  
....................    if (TRUE != rtc_alarm) 
1591C:  BTFSC  49.0
1591E:  BRA    159B6
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15920:  RCALL  15836
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15922:  BRA    158D6
15924:  MOVFF  01,864
....................       if (WAKE_UP_GOOD == serWakeupReason) 
15928:  MOVLB  8
1592A:  MOVF   x64,W
1592C:  SUBLW  02
1592E:  BNZ   159AE
....................       { 
....................          sleep_mode = FALSE; 
15930:  BCF    49.1
....................          start_heartbeat(); 
15932:  MOVLB  0
15934:  CALL   287E
....................          init_hardware(); 
15938:  CALL   28B8
....................          init_rtc();                      // This is the FAT RTC 
1593C:  CALL   3486
....................          sd_status = init_sdcard(); 
15940:  CALL   4FB8
15944:  MOVFF  01,2D8
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
15948:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
1594A:  MOVLW  01
1594C:  MOVWF  1E
1594E:  MOVLW  A3
15950:  MOVWF  1D
15952:  MOVLW  CC
15954:  MOVWF  FF6
15956:  MOVLW  1A
15958:  MOVWF  FF7
1595A:  MOVLW  00
1595C:  MOVWF  FF8
1595E:  CALL   503C
....................          record_event(); 
15962:  CALL   8424
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15966:  CLRF   32
15968:  MOVLW  01
1596A:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
1596C:  MOVLW  02
1596E:  MOVLB  8
15970:  MOVWF  x65
15972:  MOVFF  31,866
15976:  MOVLB  0
15978:  CALL   3390
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................          if(sd_status>0) 
1597C:  MOVLB  2
1597E:  MOVF   xD8,F
15980:  BZ    1598A
....................          { 
....................             msg_card_fail(); 
15982:  MOVLB  0
15984:  CALL   4FFE
15988:  MOVLB  2
....................          } 
....................  
....................          fprintf(COM_A, "@RST\r\n"); 
1598A:  MOVLW  EE
1598C:  MOVWF  FF6
1598E:  MOVLW  1A
15990:  MOVWF  FF7
15992:  MOVLW  00
15994:  MOVWF  FF8
15996:  CLRF   1B
15998:  BTFSC  FF2.7
1599A:  BSF    1B.7
1599C:  BCF    FF2.7
1599E:  MOVLB  0
159A0:  CALL   0E30
159A4:  BTFSC  1B.7
159A6:  BSF    FF2.7
....................          reset_cpu(); 
159A8:  RESET
....................       } 
159AA:  BRA    159B6
159AC:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
159AE:  DECFSZ x64,W
159B0:  BRA    159B8
....................          { 
....................             initilizeSleepState(); 
159B2:  MOVLB  0
159B4:  RCALL  15816
159B6:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
159B8:  MOVLW  00
159BA:  BTFSC  49.0
159BC:  MOVLW  01
159BE:  MOVWF  01
159C0:  MOVLB  0
159C2:  GOTO   159CC (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
159C6:  RCALL  1579A
....................    initilizeSleepState(); 
159C8:  RCALL  15816
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
159CA:  BRA    15914
159CC:  DECFSZ 01,W
159CE:  BRA    159D4
....................       { 
....................          rtc_alarm = FALSE; 
159D0:  BCF    49.0
....................          break; 
159D2:  BRA    159DA
....................       } 
....................  
....................       blip(); 
159D4:  RCALL  15836
....................       blip(); 
159D6:  RCALL  15836
159D8:  BRA    159CA
....................    } 
159DA:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0AB08:  MOVF   FD0,W
0AB0A:  ANDLW  0F
0AB0C:  BTFSS  FD0.4
0AB0E:  MOVLW  00
0AB10:  BSF    FD0.0
0AB12:  BSF    FD0.1
0AB14:  BSF    FD0.4
0AB16:  BSF    FD8.3
0AB18:  BSF    FD8.4
0AB1A:  ADDLW  F0
0AB1C:  BTFSC  FD8.0
0AB1E:  BRA    ACEE
0AB20:  ADDLW  10
0AB22:  GOTO   ACF2
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0AB26:  MOVLW  F6
0AB28:  MOVWF  FF6
0AB2A:  MOVLW  1A
0AB2C:  MOVWF  FF7
0AB2E:  MOVLW  00
0AB30:  MOVWF  FF8
0AB32:  CLRF   1B
0AB34:  BTFSC  FF2.7
0AB36:  BSF    1B.7
0AB38:  BCF    FF2.7
0AB3A:  CALL   0E30
0AB3E:  BTFSC  1B.7
0AB40:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AB42:  MOVLW  01
0AB44:  MOVWF  1E
0AB46:  MOVLW  A3
0AB48:  MOVWF  1D
0AB4A:  MOVLW  FE
0AB4C:  MOVWF  FF6
0AB4E:  MOVLW  1A
0AB50:  MOVWF  FF7
0AB52:  MOVLW  00
0AB54:  MOVWF  FF8
0AB56:  CALL   503C
....................          record_event(); 
0AB5A:  CALL   8424
....................          recovery(); 
0AB5E:  RCALL  A9A2
....................          break; 
0AB60:  BRA    ACEE
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AB62:  MOVLW  1C
0AB64:  MOVWF  FF6
0AB66:  MOVLW  1B
0AB68:  MOVWF  FF7
0AB6A:  MOVLW  00
0AB6C:  MOVWF  FF8
0AB6E:  CLRF   1B
0AB70:  BTFSC  FF2.7
0AB72:  BSF    1B.7
0AB74:  BCF    FF2.7
0AB76:  CALL   0E30
0AB7A:  BTFSC  1B.7
0AB7C:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AB7E:  MOVLW  01
0AB80:  MOVWF  1E
0AB82:  MOVLW  A3
0AB84:  MOVWF  1D
0AB86:  MOVLW  24
0AB88:  MOVWF  FF6
0AB8A:  MOVLW  1B
0AB8C:  MOVWF  FF7
0AB8E:  MOVLW  00
0AB90:  MOVWF  FF8
0AB92:  CALL   503C
....................          record_event(); 
0AB96:  CALL   8424
....................          recovery(); 
0AB9A:  RCALL  A9A2
....................          break; 
0AB9C:  BRA    ACEE
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AB9E:  MOVLW  44
0ABA0:  MOVWF  FF6
0ABA2:  MOVLW  1B
0ABA4:  MOVWF  FF7
0ABA6:  MOVLW  00
0ABA8:  MOVWF  FF8
0ABAA:  CLRF   1B
0ABAC:  BTFSC  FF2.7
0ABAE:  BSF    1B.7
0ABB0:  BCF    FF2.7
0ABB2:  CALL   0E30
0ABB6:  BTFSC  1B.7
0ABB8:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0ABBA:  MOVLW  01
0ABBC:  MOVWF  1E
0ABBE:  MOVLW  A3
0ABC0:  MOVWF  1D
0ABC2:  MOVLW  4C
0ABC4:  MOVWF  FF6
0ABC6:  MOVLW  1B
0ABC8:  MOVWF  FF7
0ABCA:  MOVLW  00
0ABCC:  MOVWF  FF8
0ABCE:  MOVLW  05
0ABD0:  MOVLB  8
0ABD2:  MOVWF  xC7
0ABD4:  MOVLB  0
0ABD6:  RCALL  AA0E
0ABD8:  MOVLW  10
0ABDA:  MOVWF  FE9
0ABDC:  MOVFF  26,8D3
0ABE0:  MOVFF  25,8D2
0ABE4:  RCALL  AA40
0ABE6:  MOVLW  54
0ABE8:  MOVWF  FF6
0ABEA:  MOVLW  1B
0ABEC:  MOVWF  FF7
0ABEE:  MOVLW  00
0ABF0:  MOVWF  FF8
0ABF2:  MOVLW  20
0ABF4:  MOVLB  8
0ABF6:  MOVWF  xC7
0ABF8:  MOVLB  0
0ABFA:  RCALL  AA0E
....................          record_event(); 
0ABFC:  CALL   8424
....................          break; 
0AC00:  BRA    ACEE
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0AC02:  MOVLW  76
0AC04:  MOVWF  FF6
0AC06:  MOVLW  1B
0AC08:  MOVWF  FF7
0AC0A:  MOVLW  00
0AC0C:  MOVWF  FF8
0AC0E:  CLRF   1B
0AC10:  BTFSC  FF2.7
0AC12:  BSF    1B.7
0AC14:  BCF    FF2.7
0AC16:  CALL   0E30
0AC1A:  BTFSC  1B.7
0AC1C:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0AC1E:  MOVLW  01
0AC20:  MOVWF  1E
0AC22:  MOVLW  A3
0AC24:  MOVWF  1D
0AC26:  MOVLW  7E
0AC28:  MOVWF  FF6
0AC2A:  MOVLW  1B
0AC2C:  MOVWF  FF7
0AC2E:  MOVLW  00
0AC30:  MOVWF  FF8
0AC32:  CALL   503C
....................          record_event(); 
0AC36:  CALL   8424
....................          break; 
0AC3A:  BRA    ACEE
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0AC3C:  MOVLW  A2
0AC3E:  MOVWF  FF6
0AC40:  MOVLW  1B
0AC42:  MOVWF  FF7
0AC44:  MOVLW  00
0AC46:  MOVWF  FF8
0AC48:  CLRF   1B
0AC4A:  BTFSC  FF2.7
0AC4C:  BSF    1B.7
0AC4E:  BCF    FF2.7
0AC50:  CALL   0E30
0AC54:  BTFSC  1B.7
0AC56:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AC58:  MOVLW  01
0AC5A:  MOVWF  1E
0AC5C:  MOVLW  A3
0AC5E:  MOVWF  1D
0AC60:  MOVLW  AA
0AC62:  MOVWF  FF6
0AC64:  MOVLW  1B
0AC66:  MOVWF  FF7
0AC68:  MOVLW  00
0AC6A:  MOVWF  FF8
0AC6C:  CALL   503C
....................          record_event(); 
0AC70:  CALL   8424
....................          recovery(); 
0AC74:  RCALL  A9A2
....................          break; 
0AC76:  BRA    ACEE
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AC78:  MOVLW  C6
0AC7A:  MOVWF  FF6
0AC7C:  MOVLW  1B
0AC7E:  MOVWF  FF7
0AC80:  MOVLW  00
0AC82:  MOVWF  FF8
0AC84:  CLRF   1B
0AC86:  BTFSC  FF2.7
0AC88:  BSF    1B.7
0AC8A:  BCF    FF2.7
0AC8C:  CALL   0E30
0AC90:  BTFSC  1B.7
0AC92:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AC94:  MOVLW  01
0AC96:  MOVWF  1E
0AC98:  MOVLW  A3
0AC9A:  MOVWF  1D
0AC9C:  MOVLW  CE
0AC9E:  MOVWF  FF6
0ACA0:  MOVLW  1B
0ACA2:  MOVWF  FF7
0ACA4:  MOVLW  00
0ACA6:  MOVWF  FF8
0ACA8:  CALL   503C
....................          record_event(); 
0ACAC:  CALL   8424
....................          recovery(); 
0ACB0:  RCALL  A9A2
....................          break; 
0ACB2:  BRA    ACEE
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0ACB4:  MOVLW  F0
0ACB6:  MOVWF  FF6
0ACB8:  MOVLW  1B
0ACBA:  MOVWF  FF7
0ACBC:  MOVLW  00
0ACBE:  MOVWF  FF8
0ACC0:  CLRF   1B
0ACC2:  BTFSC  FF2.7
0ACC4:  BSF    1B.7
0ACC6:  BCF    FF2.7
0ACC8:  CALL   0E30
0ACCC:  BTFSC  1B.7
0ACCE:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ACD0:  MOVLW  01
0ACD2:  MOVWF  1E
0ACD4:  MOVLW  A3
0ACD6:  MOVWF  1D
0ACD8:  MOVLW  F8
0ACDA:  MOVWF  FF6
0ACDC:  MOVLW  1B
0ACDE:  MOVWF  FF7
0ACE0:  MOVLW  00
0ACE2:  MOVWF  FF8
0ACE4:  CALL   503C
....................          record_event(); 
0ACE8:  CALL   8424
....................          recovery(); 
0ACEC:  RCALL  A9A2
....................          break; 
....................       }         
....................    } 
0ACEE:  GOTO   1B1F2 (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02A36:  MOVLW  1E
02A38:  MOVLB  8
02A3A:  MOVWF  x73
02A3C:  MOVLB  0
02A3E:  RCALL  2948
02A40:  MOVFF  02,30
02A44:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02A48:  MOVLW  1C
02A4A:  MOVLB  8
02A4C:  MOVWF  x73
02A4E:  MOVLB  0
02A50:  RCALL  2948
02A52:  MOVFF  02,20
02A56:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02A5A:  MOVLW  16
02A5C:  MOVLB  8
02A5E:  MOVWF  x73
02A60:  MOVLB  0
02A62:  RCALL  2948
02A64:  MOVFF  02,22
02A68:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02A6C:  MOVLW  14
02A6E:  MOVLB  8
02A70:  MOVWF  x73
02A72:  MOVLB  0
02A74:  RCALL  2948
02A76:  MOVFF  02,24
02A7A:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02A7E:  MOVLB  8
02A80:  CLRF   x73
02A82:  MOVLB  0
02A84:  RCALL  2948
02A86:  MOVFF  02,26
02A8A:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02A8E:  MOVLW  18
02A90:  MOVLB  8
02A92:  MOVWF  x73
02A94:  MOVLB  0
02A96:  RCALL  2948
02A98:  MOVFF  02,28
02A9C:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02AA0:  MOVLW  02
02AA2:  MOVLB  8
02AA4:  MOVWF  x93
02AA6:  MOVLB  0
02AA8:  RCALL  29A2
02AAA:  CLRF   32
02AAC:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02AB0:  MOVLW  28
02AB2:  MOVLB  8
02AB4:  MOVWF  x93
02AB6:  MOVLB  0
02AB8:  RCALL  29A2
02ABA:  CLRF   34
02ABC:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02AC0:  MOVLW  12
02AC2:  MOVLB  8
02AC4:  MOVWF  x73
02AC6:  MOVLB  0
02AC8:  RCALL  2948
02ACA:  MOVFF  02,36
02ACE:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02AD2:  MOVLW  3A
02AD4:  MOVLB  8
02AD6:  MOVWF  x73
02AD8:  MOVLB  0
02ADA:  RCALL  2948
02ADC:  MOVFF  02,38
02AE0:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02AE4:  MOVLW  3C
02AE6:  MOVLB  8
02AE8:  MOVWF  x73
02AEA:  MOVLB  0
02AEC:  RCALL  2948
02AEE:  MOVFF  02,3A
02AF2:  MOVFF  01,39
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02AF6:  MOVLW  3E
02AF8:  MOVLB  8
02AFA:  MOVWF  x73
02AFC:  MOVLB  0
02AFE:  RCALL  2948
02B00:  MOVFF  02,3C
02B04:  MOVFF  01,3B
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02B08:  MOVLW  40
02B0A:  MOVLB  8
02B0C:  MOVWF  x73
02B0E:  MOVLB  0
02B10:  RCALL  2948
02B12:  MOVFF  02,3E
02B16:  MOVFF  01,3D
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02B1A:  MOVLW  42
02B1C:  MOVLB  8
02B1E:  MOVWF  x73
02B20:  MOVLB  0
02B22:  RCALL  2948
02B24:  MOVFF  02,40
02B28:  MOVFF  01,3F
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02B2C:  MOVLW  04
02B2E:  MOVLB  8
02B30:  MOVWF  x93
02B32:  MOVLB  0
02B34:  RCALL  29A2
02B36:  MOVFF  01,729
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02B3A:  MOVLB  8
02B3C:  CLRF   x62
02B3E:  MOVLW  44
02B40:  MOVWF  x61
02B42:  MOVLB  0
02B44:  RCALL  29C8
02B46:  MOVFF  03,3F4
02B4A:  MOVFF  02,3F3
02B4E:  MOVFF  01,3F2
02B52:  MOVFF  00,3F1
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02B56:  MOVLB  8
02B58:  CLRF   x62
02B5A:  MOVLW  48
02B5C:  MOVWF  x61
02B5E:  MOVLB  0
02B60:  RCALL  29C8
02B62:  MOVFF  03,3F8
02B66:  MOVFF  02,3F7
02B6A:  MOVFF  01,3F6
02B6E:  MOVFF  00,3F5
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02B72:  MOVLB  8
02B74:  CLRF   x62
02B76:  MOVLW  4C
02B78:  MOVWF  x61
02B7A:  MOVLB  0
02B7C:  RCALL  29C8
02B7E:  MOVFF  03,3FC
02B82:  MOVFF  02,3FB
02B86:  MOVFF  01,3FA
02B8A:  MOVFF  00,3F9
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02B8E:  MOVLB  8
02B90:  CLRF   x62
02B92:  MOVLW  52
02B94:  MOVWF  x61
02B96:  MOVLB  0
02B98:  RCALL  29C8
02B9A:  MOVFF  03,400
02B9E:  MOVFF  02,3FF
02BA2:  MOVFF  01,3FE
02BA6:  MOVFF  00,3FD
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02BAA:  MOVLB  8
02BAC:  CLRF   x62
02BAE:  MOVLW  56
02BB0:  MOVWF  x61
02BB2:  MOVLB  0
02BB4:  RCALL  29C8
02BB6:  MOVFF  03,404
02BBA:  MOVFF  02,403
02BBE:  MOVFF  01,402
02BC2:  MOVFF  00,401
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02BC6:  MOVLB  8
02BC8:  CLRF   x62
02BCA:  MOVLW  5A
02BCC:  MOVWF  x61
02BCE:  MOVLB  0
02BD0:  RCALL  29C8
02BD2:  MOVFF  03,408
02BD6:  MOVFF  02,407
02BDA:  MOVFF  01,406
02BDE:  MOVFF  00,405
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02BE2:  MOVLB  8
02BE4:  CLRF   x62
02BE6:  MOVLW  5E
02BE8:  MOVWF  x61
02BEA:  MOVLB  0
02BEC:  RCALL  29C8
02BEE:  MOVFF  03,40C
02BF2:  MOVFF  02,40B
02BF6:  MOVFF  01,40A
02BFA:  MOVFF  00,409
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02BFE:  MOVLB  8
02C00:  CLRF   x62
02C02:  MOVLW  62
02C04:  MOVWF  x61
02C06:  MOVLB  0
02C08:  RCALL  29C8
02C0A:  MOVFF  03,410
02C0E:  MOVFF  02,40F
02C12:  MOVFF  01,40E
02C16:  MOVFF  00,40D
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02C1A:  MOVLW  20
02C1C:  MOVLB  8
02C1E:  MOVWF  x73
02C20:  MOVLB  0
02C22:  RCALL  2948
02C24:  MOVFF  02,2A
02C28:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02C2C:  MOVLW  22
02C2E:  MOVLB  8
02C30:  MOVWF  x73
02C32:  MOVLB  0
02C34:  RCALL  2948
02C36:  MOVFF  02,2C
02C3A:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02C3E:  MOVLW  24
02C40:  MOVLB  8
02C42:  MOVWF  x73
02C44:  MOVLB  0
02C46:  RCALL  2948
02C48:  MOVFF  02,2E
02C4C:  MOVFF  01,2D
02C50:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DBAC:  MOVLW  1C
0DBAE:  MOVLB  8
0DBB0:  MOVWF  xCA
0DBB2:  CLRF   xCC
0DBB4:  CLRF   xCB
0DBB6:  MOVLB  0
0DBB8:  CALL   4F52
....................    write16(ADDR_SAMPLE,0); 
0DBBC:  MOVLW  16
0DBBE:  MOVLB  8
0DBC0:  MOVWF  xCA
0DBC2:  CLRF   xCC
0DBC4:  CLRF   xCB
0DBC6:  MOVLB  0
0DBC8:  CALL   4F52
....................    write16(ADDR_INTERVAL,60); 
0DBCC:  MOVLW  14
0DBCE:  MOVLB  8
0DBD0:  MOVWF  xCA
0DBD2:  CLRF   xCC
0DBD4:  MOVLW  3C
0DBD6:  MOVWF  xCB
0DBD8:  MOVLB  0
0DBDA:  CALL   4F52
....................    write16(ADDR_SERIALNO,9999); 
0DBDE:  MOVLB  8
0DBE0:  CLRF   xCA
0DBE2:  MOVLW  27
0DBE4:  MOVWF  xCC
0DBE6:  MOVLW  0F
0DBE8:  MOVWF  xCB
0DBEA:  MOVLB  0
0DBEC:  CALL   4F52
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DBF0:  MOVLW  18
0DBF2:  MOVLB  8
0DBF4:  MOVWF  xCA
0DBF6:  MOVLW  0D
0DBF8:  MOVWF  xCC
0DBFA:  MOVLW  20
0DBFC:  MOVWF  xCB
0DBFE:  MOVLB  0
0DC00:  CALL   4F52
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DC04:  MOVLW  02
0DC06:  MOVLB  8
0DC08:  MOVWF  x65
0DC0A:  MOVLW  01
0DC0C:  MOVWF  x66
0DC0E:  MOVLB  0
0DC10:  CALL   3390
....................    write16(ADDR_MACRO_STEP, 0); 
0DC14:  MOVLW  3A
0DC16:  MOVLB  8
0DC18:  MOVWF  xCA
0DC1A:  CLRF   xCC
0DC1C:  CLRF   xCB
0DC1E:  MOVLB  0
0DC20:  CALL   4F52
....................    write16(ADDR_COM_ERR,3); 
0DC24:  MOVLW  3C
0DC26:  MOVLB  8
0DC28:  MOVWF  xCA
0DC2A:  CLRF   xCC
0DC2C:  MOVLW  03
0DC2E:  MOVWF  xCB
0DC30:  MOVLB  0
0DC32:  CALL   4F52
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DC36:  MOVLW  04
0DC38:  MOVLB  8
0DC3A:  MOVWF  x65
0DC3C:  MOVLW  0A
0DC3E:  MOVWF  x66
0DC40:  MOVLB  0
0DC42:  CALL   3390
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DC46:  MOVLB  8
0DC48:  CLRF   x62
0DC4A:  MOVLW  44
0DC4C:  MOVWF  x61
0DC4E:  CLRF   x66
0DC50:  CLRF   x65
0DC52:  CLRF   x64
0DC54:  MOVLW  7F
0DC56:  MOVWF  x63
0DC58:  MOVLB  0
0DC5A:  CALL   CA52
....................    write_float(ADDR_CAL_C1,0); 
0DC5E:  MOVLB  8
0DC60:  CLRF   x62
0DC62:  MOVLW  48
0DC64:  MOVWF  x61
0DC66:  CLRF   x66
0DC68:  CLRF   x65
0DC6A:  CLRF   x64
0DC6C:  CLRF   x63
0DC6E:  MOVLB  0
0DC70:  CALL   CA52
....................    write_float(ADDR_CAL_M2,1); 
0DC74:  MOVLB  8
0DC76:  CLRF   x62
0DC78:  MOVLW  4C
0DC7A:  MOVWF  x61
0DC7C:  CLRF   x66
0DC7E:  CLRF   x65
0DC80:  CLRF   x64
0DC82:  MOVLW  7F
0DC84:  MOVWF  x63
0DC86:  MOVLB  0
0DC88:  CALL   CA52
....................    write_float(ADDR_CAL_C2,0); 
0DC8C:  MOVLB  8
0DC8E:  CLRF   x62
0DC90:  MOVLW  52
0DC92:  MOVWF  x61
0DC94:  CLRF   x66
0DC96:  CLRF   x65
0DC98:  CLRF   x64
0DC9A:  CLRF   x63
0DC9C:  MOVLB  0
0DC9E:  CALL   CA52
....................    write_float(ADDR_CAL_M3,1); 
0DCA2:  MOVLB  8
0DCA4:  CLRF   x62
0DCA6:  MOVLW  56
0DCA8:  MOVWF  x61
0DCAA:  CLRF   x66
0DCAC:  CLRF   x65
0DCAE:  CLRF   x64
0DCB0:  MOVLW  7F
0DCB2:  MOVWF  x63
0DCB4:  MOVLB  0
0DCB6:  CALL   CA52
....................    write_float(ADDR_CAL_C3,0); 
0DCBA:  MOVLB  8
0DCBC:  CLRF   x62
0DCBE:  MOVLW  5A
0DCC0:  MOVWF  x61
0DCC2:  CLRF   x66
0DCC4:  CLRF   x65
0DCC6:  CLRF   x64
0DCC8:  CLRF   x63
0DCCA:  MOVLB  0
0DCCC:  CALL   CA52
....................    write_float(ADDR_CAL_M4,1); 
0DCD0:  MOVLB  8
0DCD2:  CLRF   x62
0DCD4:  MOVLW  5E
0DCD6:  MOVWF  x61
0DCD8:  CLRF   x66
0DCDA:  CLRF   x65
0DCDC:  CLRF   x64
0DCDE:  MOVLW  7F
0DCE0:  MOVWF  x63
0DCE2:  MOVLB  0
0DCE4:  CALL   CA52
....................    write_float(ADDR_CAL_C4,0);  
0DCE8:  MOVLB  8
0DCEA:  CLRF   x62
0DCEC:  MOVLW  62
0DCEE:  MOVWF  x61
0DCF0:  CLRF   x66
0DCF2:  CLRF   x65
0DCF4:  CLRF   x64
0DCF6:  CLRF   x63
0DCF8:  MOVLB  0
0DCFA:  CALL   CA52
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0DCFE:  MOVLW  40
0DD00:  MOVLB  8
0DD02:  MOVWF  xCA
0DD04:  MOVLW  4E
0DD06:  MOVWF  xCC
0DD08:  MOVLW  20
0DD0A:  MOVWF  xCB
0DD0C:  MOVLB  0
0DD0E:  CALL   4F52
....................    write16(ADDR_D2_TEMP,20000); 
0DD12:  MOVLW  42
0DD14:  MOVLB  8
0DD16:  MOVWF  xCA
0DD18:  MOVLW  4E
0DD1A:  MOVWF  xCC
0DD1C:  MOVLW  20
0DD1E:  MOVWF  xCB
0DD20:  MOVLB  0
0DD22:  CALL   4F52
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0DD26:  MOVLW  20
0DD28:  MOVLB  8
0DD2A:  MOVWF  xCA
0DD2C:  CLRF   xCC
0DD2E:  CLRF   xCB
0DD30:  MOVLB  0
0DD32:  CALL   4F52
....................    write16(ADDR_VOLUME,22500);  
0DD36:  MOVLW  22
0DD38:  MOVLB  8
0DD3A:  MOVWF  xCA
0DD3C:  MOVLW  57
0DD3E:  MOVWF  xCC
0DD40:  MOVLW  E4
0DD42:  MOVWF  xCB
0DD44:  MOVLB  0
0DD46:  CALL   4F52
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0DD4A:  MOVF   2F,W
0DD4C:  SUBLW  02
0DD4E:  BNZ   DD54
0DD50:  MOVF   30,F
0DD52:  BZ    DD68
0DD54:  MOVLW  24
0DD56:  MOVLB  8
0DD58:  MOVWF  xCA
0DD5A:  CLRF   xCC
0DD5C:  MOVLW  02
0DD5E:  MOVWF  xCB
0DD60:  MOVLB  0
0DD62:  CALL   4F52
0DD66:  BRA    DD7A
....................    else write16(ADDR_PORT,1); 
0DD68:  MOVLW  24
0DD6A:  MOVLB  8
0DD6C:  MOVWF  xCA
0DD6E:  CLRF   xCC
0DD70:  MOVLW  01
0DD72:  MOVWF  xCB
0DD74:  MOVLB  0
0DD76:  CALL   4F52
....................     
....................    write16(ADDR_DET_TYPE,1); 
0DD7A:  MOVLW  26
0DD7C:  MOVLB  8
0DD7E:  MOVWF  xCA
0DD80:  CLRF   xCC
0DD82:  MOVLW  01
0DD84:  MOVWF  xCB
0DD86:  MOVLB  0
0DD88:  CALL   4F52
....................     
....................    init_nv_vars(); 
0DD8C:  CALL   2A36
0DD90:  GOTO   DDAA (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
124DA:  MOVLW  02
124DC:  MOVWF  FEA
124DE:  MOVLW  43
124E0:  MOVWF  FE9
124E2:  CLRF   00
124E4:  CLRF   02
124E6:  MOVLW  51
124E8:  MOVWF  01
124EA:  CALL   34A4
124EE:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F60E:  MOVLW  03
0F610:  MOVWF  FEA
0F612:  MOVLW  21
0F614:  MOVWF  FE9
0F616:  CLRF   00
0F618:  CLRF   02
0F61A:  MOVLW  14
0F61C:  MOVWF  01
0F61E:  CALL   34A4
0F622:  GOTO   F642 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
13010:  MOVLB  8
13012:  CLRF   xB0
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
13014:  CLRF   FEA
13016:  MOVLW  4E
13018:  MOVWF  FE9
1301A:  CLRF   00
1301C:  CLRF   02
1301E:  MOVLW  14
13020:  MOVWF  01
13022:  MOVLB  0
13024:  CALL   34A4
....................  
....................    for(n=0; n<20; n++) { 
13028:  MOVLB  8
1302A:  CLRF   xB1
1302C:  MOVF   xB1,W
1302E:  SUBLW  13
13030:  BNC   13076
....................         c = data_buffer[string_pos];  
13032:  CLRF   03
13034:  MOVLB  2
13036:  MOVF   x94,W
13038:  ADDLW  63
1303A:  MOVWF  FE9
1303C:  MOVLW  00
1303E:  ADDWFC 03,W
13040:  MOVWF  FEA
13042:  MOVFF  FEF,8B0
....................         ++string_pos; 
13046:  INCF   x94,F
....................         if (c == '\0') return(1); // found end 
13048:  MOVLB  8
1304A:  MOVF   xB0,F
1304C:  BNZ   13054
1304E:  MOVLW  01
13050:  MOVWF  01
13052:  BRA    1307A
....................         if (c == ',')  return(0); // found seperator  
13054:  MOVF   xB0,W
13056:  SUBLW  2C
13058:  BNZ   13060
1305A:  MOVLW  00
1305C:  MOVWF  01
1305E:  BRA    1307A
....................         sub_string[n] = c; 
13060:  CLRF   03
13062:  MOVF   xB1,W
13064:  ADDLW  4E
13066:  MOVWF  FE9
13068:  MOVLW  00
1306A:  ADDWFC 03,W
1306C:  MOVWF  FEA
1306E:  MOVFF  8B0,FEF
13072:  INCF   xB1,F
13074:  BRA    1302C
....................    } 
....................     
....................    return(2); // failed = bad string 
13076:  MOVLW  02
13078:  MOVWF  01
1307A:  MOVLB  0
1307C:  GOTO   133A6 (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
132BA:  MOVLW  1C
132BC:  MOVWF  FF6
132BE:  MOVLW  1C
132C0:  MOVWF  FF7
132C2:  MOVLW  00
132C4:  MOVWF  FF8
132C6:  MOVLW  03
132C8:  MOVWF  FEA
132CA:  MOVLW  39
132CC:  MOVWF  FE9
132CE:  CALL   FB54
132D2:  MOVF   01,W
132D4:  BZ    132E8
132D6:  XORLW  01
132D8:  BZ    13308
132DA:  XORLW  03
132DC:  BZ    13328
132DE:  XORLW  01
132E0:  BZ    13348
132E2:  XORLW  07
132E4:  BZ    13368
132E6:  BRA    13386
....................       case "NO3" : NO3_array[read_i] = result; 
132E8:  BCF    FD8.0
132EA:  MOVLB  3
132EC:  RLCF   x46,W
132EE:  CLRF   03
132F0:  ADDLW  47
132F2:  MOVWF  FE9
132F4:  MOVLW  03
132F6:  ADDWFC 03,W
132F8:  MOVWF  FEA
132FA:  MOVFF  8B1,FEC
132FE:  MOVF   FED,F
13300:  MOVFF  8B0,FEF
....................          break; 
13304:  MOVLB  0
13306:  BRA    13386
....................       case "NO2" : NO2_array[read_i] = result; 
13308:  BCF    FD8.0
1330A:  MOVLB  3
1330C:  RLCF   x46,W
1330E:  CLRF   03
13310:  ADDLW  59
13312:  MOVWF  FE9
13314:  MOVLW  03
13316:  ADDWFC 03,W
13318:  MOVWF  FEA
1331A:  MOVFF  8B1,FEC
1331E:  MOVF   FED,F
13320:  MOVFF  8B0,FEF
....................          break;    
13324:  MOVLB  0
13326:  BRA    13386
....................       case "PO4" : PO4_array[read_i] = result; 
13328:  BCF    FD8.0
1332A:  MOVLB  3
1332C:  RLCF   x46,W
1332E:  CLRF   03
13330:  ADDLW  6B
13332:  MOVWF  FE9
13334:  MOVLW  03
13336:  ADDWFC 03,W
13338:  MOVWF  FEA
1333A:  MOVFF  8B1,FEC
1333E:  MOVF   FED,F
13340:  MOVFF  8B0,FEF
....................          break; 
13344:  MOVLB  0
13346:  BRA    13386
....................       case "NH4" : NH4_array[read_i] = result; 
13348:  BCF    FD8.0
1334A:  MOVLB  3
1334C:  RLCF   x46,W
1334E:  CLRF   03
13350:  ADDLW  7D
13352:  MOVWF  FE9
13354:  MOVLW  03
13356:  ADDWFC 03,W
13358:  MOVWF  FEA
1335A:  MOVFF  8B1,FEC
1335E:  MOVF   FED,F
13360:  MOVFF  8B0,FEF
....................          break; 
13364:  MOVLB  0
13366:  BRA    13386
....................       case "SiO" : SiO_array[read_i] = result; 
13368:  BCF    FD8.0
1336A:  MOVLB  3
1336C:  RLCF   x46,W
1336E:  CLRF   03
13370:  ADDLW  8F
13372:  MOVWF  FE9
13374:  MOVLW  03
13376:  ADDWFC 03,W
13378:  MOVWF  FEA
1337A:  MOVFF  8B1,FEC
1337E:  MOVF   FED,F
13380:  MOVFF  8B0,FEF
....................          break; 
13384:  MOVLB  0
....................    } 
13386:  GOTO   133FE (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
1338A:  MOVLB  8
1338C:  CLRF   xAB
1338E:  CLRF   xAA
13390:  CLRF   xAD
13392:  CLRF   xAC
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
13394:  MOVLB  2
13396:  CLRF   x94
....................     
....................    for (n=0; n<11; ++n){ 
13398:  MOVLB  8
1339A:  CLRF   xAE
1339C:  MOVF   xAE,W
1339E:  SUBLW  0A
133A0:  BNC   133F2
....................       parsed = parse_string(); 
133A2:  MOVLB  0
133A4:  BRA    13010
133A6:  MOVFF  01,8AF
....................       if (parsed == 2) return(0); 
133AA:  MOVLB  8
133AC:  MOVF   xAF,W
133AE:  SUBLW  02
133B0:  BNZ   133BA
133B2:  MOVLW  00
133B4:  MOVWF  01
133B6:  MOVWF  02
133B8:  BRA    13408
....................       if (n==8) result = atol(sub_string); 
133BA:  MOVF   xAE,W
133BC:  SUBLW  08
133BE:  BNZ   133D4
133C0:  CLRF   xB1
133C2:  MOVLW  4E
133C4:  MOVWF  xB0
133C6:  MOVLB  0
133C8:  RCALL  130D6
133CA:  MOVFF  02,8AB
133CE:  MOVFF  01,8AA
133D2:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
133D4:  MOVF   xAE,W
133D6:  SUBLW  0A
133D8:  BNZ   133EE
133DA:  CLRF   xB1
133DC:  MOVLW  4E
133DE:  MOVWF  xB0
133E0:  MOVLB  0
133E2:  RCALL  130D6
133E4:  MOVFF  02,8AD
133E8:  MOVFF  01,8AC
133EC:  MOVLB  8
133EE:  INCF   xAE,F
133F0:  BRA    1339C
....................    } 
....................    load_parsed_data(result); 
133F2:  MOVFF  8AB,8B1
133F6:  MOVFF  8AA,8B0
133FA:  MOVLB  0
133FC:  BRA    132BA
....................    return (temp); 
133FE:  MOVLB  8
13400:  MOVFF  8AC,01
13404:  MOVFF  8AD,02
13408:  MOVLB  0
1340A:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D22C:  CLRF   FEA
0D22E:  MOVLW  63
0D230:  MOVWF  FE9
0D232:  CLRF   00
0D234:  CLRF   02
0D236:  MOVLW  A0
0D238:  MOVWF  01
0D23A:  CALL   34A4
0D23E:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F626:  MOVLW  03
0F628:  MOVWF  FEA
0F62A:  MOVLW  39
0F62C:  MOVWF  FE9
0F62E:  MOVLW  00
0F630:  CALL   02E4
0F634:  TBLRD*-
0F636:  TBLRD*+
0F638:  MOVF   FF5,W
0F63A:  MOVWF  FEE
0F63C:  IORLW  00
0F63E:  BNZ   F636
....................  
....................    clear_flag_str(); 
0F640:  BRA    F60E
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F642:  MOVLW  08
0F644:  MOVWF  1E
0F646:  MOVLW  C9
0F648:  MOVWF  1D
0F64A:  MOVLW  10
0F64C:  MOVWF  FE9
0F64E:  MOVFF  320,8D3
0F652:  MOVFF  31F,8D2
0F656:  CALL   AA40
....................  
....................    if (macro_flag < 100) { 
0F65A:  MOVLB  3
0F65C:  MOVF   x20,F
0F65E:  BNZ   F678
0F660:  MOVF   x1F,W
0F662:  SUBLW  63
0F664:  BNC   F678
....................       temp_str[3] = '\0'; 
0F666:  MOVLB  8
0F668:  CLRF   xCC
....................       temp_str[2] = temp_str[1]; 
0F66A:  MOVFF  8CA,8CB
....................       temp_str[1] = temp_str[0]; 
0F66E:  MOVFF  8C9,8CA
....................       temp_str[0] = '0'; 
0F672:  MOVLW  30
0F674:  MOVWF  xC9
0F676:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F678:  MOVLB  8
0F67A:  MOVF   xC9,W
0F67C:  XORLW  30
0F67E:  MOVLB  0
0F680:  BZ    F6A4
0F682:  XORLW  01
0F684:  BZ    F6CA
0F686:  XORLW  03
0F688:  BZ    F6F0
0F68A:  XORLW  01
0F68C:  BZ    F716
0F68E:  XORLW  07
0F690:  BZ    F73C
0F692:  XORLW  01
0F694:  BZ    F762
0F696:  XORLW  03
0F698:  BTFSC  FD8.2
0F69A:  BRA    F788
0F69C:  XORLW  01
0F69E:  BTFSC  FD8.2
0F6A0:  BRA    F7AE
0F6A2:  BRA    F7D6
....................       case '0' : strcopy(chem,"NO3"); 
0F6A4:  MOVLW  03
0F6A6:  MOVWF  FEA
0F6A8:  MOVLW  39
0F6AA:  MOVWF  FE9
0F6AC:  MOVLW  00
0F6AE:  CALL   02FC
0F6B2:  TBLRD*-
0F6B4:  TBLRD*+
0F6B6:  MOVF   FF5,W
0F6B8:  MOVWF  FEE
0F6BA:  IORLW  00
0F6BC:  BNZ   F6B4
....................                  wave_l=543; 
0F6BE:  MOVLW  02
0F6C0:  MOVLB  8
0F6C2:  MOVWF  xC8
0F6C4:  MOVLW  1F
0F6C6:  MOVWF  xC7
....................          break; 
0F6C8:  BRA    F7FA
....................       case '1' : strcopy(chem,"PO4"); 
0F6CA:  MOVLW  03
0F6CC:  MOVWF  FEA
0F6CE:  MOVLW  39
0F6D0:  MOVWF  FE9
0F6D2:  MOVLW  00
0F6D4:  CALL   0314
0F6D8:  TBLRD*-
0F6DA:  TBLRD*+
0F6DC:  MOVF   FF5,W
0F6DE:  MOVWF  FEE
0F6E0:  IORLW  00
0F6E2:  BNZ   F6DA
....................                  wave_l=880;       
0F6E4:  MOVLW  03
0F6E6:  MOVLB  8
0F6E8:  MOVWF  xC8
0F6EA:  MOVLW  70
0F6EC:  MOVWF  xC7
....................          break; 
0F6EE:  BRA    F7FA
....................       case '2' : strcopy(chem,"NH4"); 
0F6F0:  MOVLW  03
0F6F2:  MOVWF  FEA
0F6F4:  MOVLW  39
0F6F6:  MOVWF  FE9
0F6F8:  MOVLW  00
0F6FA:  CALL   032C
0F6FE:  TBLRD*-
0F700:  TBLRD*+
0F702:  MOVF   FF5,W
0F704:  MOVWF  FEE
0F706:  IORLW  00
0F708:  BNZ   F700
....................                  wave_l=660;       
0F70A:  MOVLW  02
0F70C:  MOVLB  8
0F70E:  MOVWF  xC8
0F710:  MOVLW  94
0F712:  MOVWF  xC7
....................          break; 
0F714:  BRA    F7FA
....................       case '3' : strcopy(chem,"SiO"); 
0F716:  MOVLW  03
0F718:  MOVWF  FEA
0F71A:  MOVLW  39
0F71C:  MOVWF  FE9
0F71E:  MOVLW  00
0F720:  CALL   0344
0F724:  TBLRD*-
0F726:  TBLRD*+
0F728:  MOVF   FF5,W
0F72A:  MOVWF  FEE
0F72C:  IORLW  00
0F72E:  BNZ   F726
....................                  wave_l=810;       
0F730:  MOVLW  03
0F732:  MOVLB  8
0F734:  MOVWF  xC8
0F736:  MOVLW  2A
0F738:  MOVWF  xC7
....................          break; 
0F73A:  BRA    F7FA
....................       case '4' : strcopy(chem,"Ure"); 
0F73C:  MOVLW  03
0F73E:  MOVWF  FEA
0F740:  MOVLW  39
0F742:  MOVWF  FE9
0F744:  MOVLW  00
0F746:  CALL   035C
0F74A:  TBLRD*-
0F74C:  TBLRD*+
0F74E:  MOVF   FF5,W
0F750:  MOVWF  FEE
0F752:  IORLW  00
0F754:  BNZ   F74C
....................                  wave_l=525;       
0F756:  MOVLW  02
0F758:  MOVLB  8
0F75A:  MOVWF  xC8
0F75C:  MOVLW  0D
0F75E:  MOVWF  xC7
....................          break; 
0F760:  BRA    F7FA
....................       case '5' : strcopy(chem,"NO2"); 
0F762:  MOVLW  03
0F764:  MOVWF  FEA
0F766:  MOVLW  39
0F768:  MOVWF  FE9
0F76A:  MOVLW  00
0F76C:  CALL   0374
0F770:  TBLRD*-
0F772:  TBLRD*+
0F774:  MOVF   FF5,W
0F776:  MOVWF  FEE
0F778:  IORLW  00
0F77A:  BNZ   F772
....................                  wave_l=543;       
0F77C:  MOVLW  02
0F77E:  MOVLB  8
0F780:  MOVWF  xC8
0F782:  MOVLW  1F
0F784:  MOVWF  xC7
....................          break; 
0F786:  BRA    F7FA
....................       case '6' : strcopy(chem,"Fe_"); 
0F788:  MOVLW  03
0F78A:  MOVWF  FEA
0F78C:  MOVLW  39
0F78E:  MOVWF  FE9
0F790:  MOVLW  00
0F792:  CALL   038C
0F796:  TBLRD*-
0F798:  TBLRD*+
0F79A:  MOVF   FF5,W
0F79C:  MOVWF  FEE
0F79E:  IORLW  00
0F7A0:  BNZ   F798
....................                  wave_l=543;       
0F7A2:  MOVLW  02
0F7A4:  MOVLB  8
0F7A6:  MOVWF  xC8
0F7A8:  MOVLW  1F
0F7AA:  MOVWF  xC7
....................          break; 
0F7AC:  BRA    F7FA
....................       case '7' : strcopy(chem,"Cl_"); 
0F7AE:  MOVLW  03
0F7B0:  MOVWF  FEA
0F7B2:  MOVLW  39
0F7B4:  MOVWF  FE9
0F7B6:  MOVLW  00
0F7B8:  CALL   03A4
0F7BC:  TBLRD*-
0F7BE:  TBLRD*+
0F7C0:  MOVF   FF5,W
0F7C2:  MOVWF  FEE
0F7C4:  IORLW  00
0F7C6:  BNZ   F7BE
....................                  wave_l=560;       
0F7C8:  MOVLW  02
0F7CA:  MOVLB  8
0F7CC:  MOVWF  xC8
0F7CE:  MOVLW  30
0F7D0:  MOVWF  xC7
....................          break; 
0F7D2:  BRA    F7FA
0F7D4:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0F7D6:  MOVLW  03
0F7D8:  MOVWF  FEA
0F7DA:  MOVLW  39
0F7DC:  MOVWF  FE9
0F7DE:  MOVLW  00
0F7E0:  CALL   02E4
0F7E4:  TBLRD*-
0F7E6:  TBLRD*+
0F7E8:  MOVF   FF5,W
0F7EA:  MOVWF  FEE
0F7EC:  IORLW  00
0F7EE:  BNZ   F7E6
....................                  wave_l=999;       
0F7F0:  MOVLW  03
0F7F2:  MOVLB  8
0F7F4:  MOVWF  xC8
0F7F6:  MOVLW  E7
0F7F8:  MOVWF  xC7
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0F7FA:  MOVF   xCA,W
0F7FC:  XORLW  31
0F7FE:  MOVLB  0
0F800:  BZ    F820
0F802:  XORLW  03
0F804:  BZ    F83C
0F806:  XORLW  01
0F808:  BZ    F858
0F80A:  XORLW  07
0F80C:  BZ    F874
0F80E:  XORLW  01
0F810:  BZ    F890
0F812:  XORLW  03
0F814:  BZ    F8AC
0F816:  XORLW  01
0F818:  BZ    F8C8
0F81A:  XORLW  0F
0F81C:  BZ    F8E4
0F81E:  BRA    F900
....................       case '1' : strcopy(anal,"Smp"); 
0F820:  MOVLW  03
0F822:  MOVWF  FEA
0F824:  MOVLW  3E
0F826:  MOVWF  FE9
0F828:  MOVLW  00
0F82A:  CALL   03BC
0F82E:  TBLRD*-
0F830:  TBLRD*+
0F832:  MOVF   FF5,W
0F834:  MOVWF  FEE
0F836:  IORLW  00
0F838:  BNZ   F830
....................          break; 
0F83A:  BRA    F91A
....................       case '2' : strcopy(anal,"Std"); 
0F83C:  MOVLW  03
0F83E:  MOVWF  FEA
0F840:  MOVLW  3E
0F842:  MOVWF  FE9
0F844:  MOVLW  00
0F846:  CALL   03D4
0F84A:  TBLRD*-
0F84C:  TBLRD*+
0F84E:  MOVF   FF5,W
0F850:  MOVWF  FEE
0F852:  IORLW  00
0F854:  BNZ   F84C
....................          break; 
0F856:  BRA    F91A
....................       case '3' : strcopy(anal,"Cmb"); 
0F858:  MOVLW  03
0F85A:  MOVWF  FEA
0F85C:  MOVLW  3E
0F85E:  MOVWF  FE9
0F860:  MOVLW  00
0F862:  CALL   03EC
0F866:  TBLRD*-
0F868:  TBLRD*+
0F86A:  MOVF   FF5,W
0F86C:  MOVWF  FEE
0F86E:  IORLW  00
0F870:  BNZ   F868
....................          break; 
0F872:  BRA    F91A
....................       case '4' : strcopy(anal,"Tst"); 
0F874:  MOVLW  03
0F876:  MOVWF  FEA
0F878:  MOVLW  3E
0F87A:  MOVWF  FE9
0F87C:  MOVLW  00
0F87E:  CALL   0404
0F882:  TBLRD*-
0F884:  TBLRD*+
0F886:  MOVF   FF5,W
0F888:  MOVWF  FEE
0F88A:  IORLW  00
0F88C:  BNZ   F884
....................          break; 
0F88E:  BRA    F91A
....................       case '5' : strcopy(anal,"Rbl"); 
0F890:  MOVLW  03
0F892:  MOVWF  FEA
0F894:  MOVLW  3E
0F896:  MOVWF  FE9
0F898:  MOVLW  00
0F89A:  CALL   041C
0F89E:  TBLRD*-
0F8A0:  TBLRD*+
0F8A2:  MOVF   FF5,W
0F8A4:  MOVWF  FEE
0F8A6:  IORLW  00
0F8A8:  BNZ   F8A0
....................          break; 
0F8AA:  BRA    F91A
....................       case '6' : strcopy(anal,"Cal"); 
0F8AC:  MOVLW  03
0F8AE:  MOVWF  FEA
0F8B0:  MOVLW  3E
0F8B2:  MOVWF  FE9
0F8B4:  MOVLW  00
0F8B6:  CALL   0434
0F8BA:  TBLRD*-
0F8BC:  TBLRD*+
0F8BE:  MOVF   FF5,W
0F8C0:  MOVWF  FEE
0F8C2:  IORLW  00
0F8C4:  BNZ   F8BC
....................          break; 
0F8C6:  BRA    F91A
....................       case '7' : strcopy(anal,"Fls"); 
0F8C8:  MOVLW  03
0F8CA:  MOVWF  FEA
0F8CC:  MOVLW  3E
0F8CE:  MOVWF  FE9
0F8D0:  MOVLW  00
0F8D2:  CALL   044C
0F8D6:  TBLRD*-
0F8D8:  TBLRD*+
0F8DA:  MOVF   FF5,W
0F8DC:  MOVWF  FEE
0F8DE:  IORLW  00
0F8E0:  BNZ   F8D8
....................          break; 
0F8E2:  BRA    F91A
....................       case '8' : strcopy(anal,"Utl"); 
0F8E4:  MOVLW  03
0F8E6:  MOVWF  FEA
0F8E8:  MOVLW  3E
0F8EA:  MOVWF  FE9
0F8EC:  MOVLW  00
0F8EE:  CALL   0464
0F8F2:  TBLRD*-
0F8F4:  TBLRD*+
0F8F6:  MOVF   FF5,W
0F8F8:  MOVWF  FEE
0F8FA:  IORLW  00
0F8FC:  BNZ   F8F4
....................          break;     
0F8FE:  BRA    F91A
....................       default  : strcopy(anal,"XXX"); 
0F900:  MOVLW  03
0F902:  MOVWF  FEA
0F904:  MOVLW  3E
0F906:  MOVWF  FE9
0F908:  MOVLW  00
0F90A:  CALL   02E4
0F90E:  TBLRD*-
0F910:  TBLRD*+
0F912:  MOVF   FF5,W
0F914:  MOVWF  FEE
0F916:  IORLW  00
0F918:  BNZ   F910
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0F91A:  MOVLB  8
0F91C:  MOVF   xCB,W
0F91E:  XORLW  31
0F920:  MOVLB  0
0F922:  BZ    F94C
0F924:  XORLW  03
0F926:  BZ    F96C
0F928:  XORLW  01
0F92A:  BZ    F98E
0F92C:  XORLW  07
0F92E:  BZ    F9B0
0F930:  XORLW  01
0F932:  BZ    F9D2
0F934:  XORLW  03
0F936:  BZ    F9F4
0F938:  XORLW  01
0F93A:  BTFSC  FD8.2
0F93C:  BRA    FA16
0F93E:  XORLW  0F
0F940:  BTFSC  FD8.2
0F942:  BRA    FA38
0F944:  XORLW  01
0F946:  BTFSC  FD8.2
0F948:  BRA    FA5A
0F94A:  BRA    FA7E
....................       case '1' : strcopy(read_t,"I0s"); 
0F94C:  MOVLW  03
0F94E:  MOVWF  FEA
0F950:  MOVLW  42
0F952:  MOVWF  FE9
0F954:  MOVLW  00
0F956:  CALL   047C
0F95A:  TBLRD*-
0F95C:  TBLRD*+
0F95E:  MOVF   FF5,W
0F960:  MOVWF  FEE
0F962:  IORLW  00
0F964:  BNZ   F95C
....................                  read_i = 0; 
0F966:  MOVLB  3
0F968:  CLRF   x46
....................          break; 
0F96A:  BRA    FA9C
....................       case '2' : strcopy(read_t,"I1s"); 
0F96C:  MOVLW  03
0F96E:  MOVWF  FEA
0F970:  MOVLW  42
0F972:  MOVWF  FE9
0F974:  MOVLW  00
0F976:  CALL   0494
0F97A:  TBLRD*-
0F97C:  TBLRD*+
0F97E:  MOVF   FF5,W
0F980:  MOVWF  FEE
0F982:  IORLW  00
0F984:  BNZ   F97C
....................                  read_i = 1;       
0F986:  MOVLW  01
0F988:  MOVLB  3
0F98A:  MOVWF  x46
....................          break; 
0F98C:  BRA    FA9C
....................       case '3' : strcopy(read_t,"I0t"); 
0F98E:  MOVLW  03
0F990:  MOVWF  FEA
0F992:  MOVLW  42
0F994:  MOVWF  FE9
0F996:  MOVLW  00
0F998:  CALL   04AC
0F99C:  TBLRD*-
0F99E:  TBLRD*+
0F9A0:  MOVF   FF5,W
0F9A2:  MOVWF  FEE
0F9A4:  IORLW  00
0F9A6:  BNZ   F99E
....................                  read_i = 2;       
0F9A8:  MOVLW  02
0F9AA:  MOVLB  3
0F9AC:  MOVWF  x46
....................          break; 
0F9AE:  BRA    FA9C
....................       case '4' : strcopy(read_t,"I1t"); 
0F9B0:  MOVLW  03
0F9B2:  MOVWF  FEA
0F9B4:  MOVLW  42
0F9B6:  MOVWF  FE9
0F9B8:  MOVLW  00
0F9BA:  CALL   04C4
0F9BE:  TBLRD*-
0F9C0:  TBLRD*+
0F9C2:  MOVF   FF5,W
0F9C4:  MOVWF  FEE
0F9C6:  IORLW  00
0F9C8:  BNZ   F9C0
....................                  read_i = 3;       
0F9CA:  MOVLW  03
0F9CC:  MOVLB  3
0F9CE:  MOVWF  x46
....................          break; 
0F9D0:  BRA    FA9C
....................       case '5' : strcopy(read_t,"I0r"); 
0F9D2:  MOVLW  03
0F9D4:  MOVWF  FEA
0F9D6:  MOVLW  42
0F9D8:  MOVWF  FE9
0F9DA:  MOVLW  00
0F9DC:  CALL   04DC
0F9E0:  TBLRD*-
0F9E2:  TBLRD*+
0F9E4:  MOVF   FF5,W
0F9E6:  MOVWF  FEE
0F9E8:  IORLW  00
0F9EA:  BNZ   F9E2
....................                  read_i = 4;       
0F9EC:  MOVLW  04
0F9EE:  MOVLB  3
0F9F0:  MOVWF  x46
....................          break; 
0F9F2:  BRA    FA9C
....................       case '6' : strcopy(read_t,"I1r"); 
0F9F4:  MOVLW  03
0F9F6:  MOVWF  FEA
0F9F8:  MOVLW  42
0F9FA:  MOVWF  FE9
0F9FC:  MOVLW  00
0F9FE:  CALL   04F4
0FA02:  TBLRD*-
0FA04:  TBLRD*+
0FA06:  MOVF   FF5,W
0FA08:  MOVWF  FEE
0FA0A:  IORLW  00
0FA0C:  BNZ   FA04
....................                  read_i = 5;       
0FA0E:  MOVLW  05
0FA10:  MOVLB  3
0FA12:  MOVWF  x46
....................          break; 
0FA14:  BRA    FA9C
....................       case '7' : strcopy(read_t,"I0u"); 
0FA16:  MOVLW  03
0FA18:  MOVWF  FEA
0FA1A:  MOVLW  42
0FA1C:  MOVWF  FE9
0FA1E:  MOVLW  00
0FA20:  CALL   050C
0FA24:  TBLRD*-
0FA26:  TBLRD*+
0FA28:  MOVF   FF5,W
0FA2A:  MOVWF  FEE
0FA2C:  IORLW  00
0FA2E:  BNZ   FA26
....................                  read_i = 6;       
0FA30:  MOVLW  06
0FA32:  MOVLB  3
0FA34:  MOVWF  x46
....................          break; 
0FA36:  BRA    FA9C
....................       case '8' : strcopy(read_t,"I1u"); 
0FA38:  MOVLW  03
0FA3A:  MOVWF  FEA
0FA3C:  MOVLW  42
0FA3E:  MOVWF  FE9
0FA40:  MOVLW  00
0FA42:  CALL   0524
0FA46:  TBLRD*-
0FA48:  TBLRD*+
0FA4A:  MOVF   FF5,W
0FA4C:  MOVWF  FEE
0FA4E:  IORLW  00
0FA50:  BNZ   FA48
....................                  read_i = 7;       
0FA52:  MOVLW  07
0FA54:  MOVLB  3
0FA56:  MOVWF  x46
....................          break; 
0FA58:  BRA    FA9C
....................       case '9' : strcopy(read_t,"Chk"); 
0FA5A:  MOVLW  03
0FA5C:  MOVWF  FEA
0FA5E:  MOVLW  42
0FA60:  MOVWF  FE9
0FA62:  MOVLW  00
0FA64:  CALL   053C
0FA68:  TBLRD*-
0FA6A:  TBLRD*+
0FA6C:  MOVF   FF5,W
0FA6E:  MOVWF  FEE
0FA70:  IORLW  00
0FA72:  BNZ   FA6A
....................                  read_i = 8;       
0FA74:  MOVLW  08
0FA76:  MOVLB  3
0FA78:  MOVWF  x46
....................          break;        
0FA7A:  BRA    FA9C
0FA7C:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FA7E:  MOVLW  03
0FA80:  MOVWF  FEA
0FA82:  MOVLW  42
0FA84:  MOVWF  FE9
0FA86:  MOVLW  00
0FA88:  CALL   0554
0FA8C:  TBLRD*-
0FA8E:  TBLRD*+
0FA90:  MOVF   FF5,W
0FA92:  MOVWF  FEE
0FA94:  IORLW  00
0FA96:  BNZ   FA8E
....................                  read_i = 0;       
0FA98:  MOVLB  3
0FA9A:  CLRF   x46
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FA9C:  MOVLW  03
0FA9E:  MOVLB  8
0FAA0:  MOVWF  xD5
0FAA2:  MOVLW  21
0FAA4:  MOVWF  xD4
0FAA6:  MOVLW  03
0FAA8:  MOVWF  xD7
0FAAA:  MOVLW  39
0FAAC:  MOVWF  xD6
0FAAE:  MOVLB  0
0FAB0:  CALL   545C
....................    strcat(flag_str, (char *)","); 
0FAB4:  MOVLW  2C
0FAB6:  MOVLB  8
0FAB8:  MOVWF  xD0
0FABA:  CLRF   xD1
0FABC:  MOVLW  03
0FABE:  MOVWF  xD5
0FAC0:  MOVLW  21
0FAC2:  MOVWF  xD4
0FAC4:  MOVLW  08
0FAC6:  MOVWF  xD7
0FAC8:  MOVLW  D0
0FACA:  MOVWF  xD6
0FACC:  MOVLB  0
0FACE:  CALL   545C
....................    strcat(flag_str, anal); 
0FAD2:  MOVLW  03
0FAD4:  MOVLB  8
0FAD6:  MOVWF  xD5
0FAD8:  MOVLW  21
0FADA:  MOVWF  xD4
0FADC:  MOVLW  03
0FADE:  MOVWF  xD7
0FAE0:  MOVLW  3E
0FAE2:  MOVWF  xD6
0FAE4:  MOVLB  0
0FAE6:  CALL   545C
....................    strcat(flag_str, (char *)","); 
0FAEA:  MOVLW  2C
0FAEC:  MOVLB  8
0FAEE:  MOVWF  xD0
0FAF0:  CLRF   xD1
0FAF2:  MOVLW  03
0FAF4:  MOVWF  xD5
0FAF6:  MOVLW  21
0FAF8:  MOVWF  xD4
0FAFA:  MOVLW  08
0FAFC:  MOVWF  xD7
0FAFE:  MOVLW  D0
0FB00:  MOVWF  xD6
0FB02:  MOVLB  0
0FB04:  CALL   545C
....................    strcat(flag_str, read_t);   
0FB08:  MOVLW  03
0FB0A:  MOVLB  8
0FB0C:  MOVWF  xD5
0FB0E:  MOVLW  21
0FB10:  MOVWF  xD4
0FB12:  MOVLW  03
0FB14:  MOVWF  xD7
0FB16:  MOVLW  42
0FB18:  MOVWF  xD6
0FB1A:  MOVLB  0
0FB1C:  CALL   545C
....................     
....................    return wave_l; 
0FB20:  MOVLB  8
0FB22:  MOVFF  8C7,01
0FB26:  MOVFF  8C8,02
0FB2A:  MOVLB  0
0FB2C:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F102:  MOVF   43,W
0F104:  SUBLW  4B
0F106:  BTFSC  FD8.2
0F108:  MOVFF  44,2D2
....................    if (cmd=='L') detector_li = arg; 
0F10C:  MOVF   43,W
0F10E:  SUBLW  4C
0F110:  BNZ   F11A
0F112:  MOVFF  45,2D4
0F116:  MOVFF  44,2D3
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F11A:  MOVF   1F,W
0F11C:  SUBLW  04
0F11E:  BNZ   F1E8
0F120:  MOVF   20,F
0F122:  BNZ   F1E8
0F124:  MOVLW  32
0F126:  MOVWF  FF6
0F128:  MOVLW  1C
0F12A:  MOVWF  FF7
0F12C:  MOVLW  00
0F12E:  MOVWF  FF8
0F130:  CLRF   1B
0F132:  BTFSC  FF2.7
0F134:  BSF    1B.7
0F136:  BCF    FF2.7
0F138:  MOVLW  06
0F13A:  MOVLB  A
0F13C:  MOVWF  x18
0F13E:  MOVLB  0
0F140:  CALL   1006
0F144:  BTFSC  1B.7
0F146:  BSF    FF2.7
0F148:  CLRF   1B
0F14A:  BTFSC  FF2.7
0F14C:  BSF    1B.7
0F14E:  BCF    FF2.7
0F150:  MOVFF  2D1,A18
0F154:  MOVLW  1B
0F156:  MOVLB  A
0F158:  MOVWF  x19
0F15A:  MOVLB  0
0F15C:  CALL   0F88
0F160:  BTFSC  1B.7
0F162:  BSF    FF2.7
0F164:  MOVLW  5D
0F166:  BTFSS  F9E.4
0F168:  BRA    F166
0F16A:  MOVWF  FAD
0F16C:  MOVLW  5B
0F16E:  BTFSS  F9E.4
0F170:  BRA    F16E
0F172:  MOVWF  FAD
0F174:  MOVF   43,W
0F176:  BTFSS  F9E.4
0F178:  BRA    F176
0F17A:  MOVWF  FAD
0F17C:  MOVLW  3E
0F17E:  MOVWF  FF6
0F180:  MOVLW  1C
0F182:  MOVWF  FF7
0F184:  MOVLW  00
0F186:  MOVWF  FF8
0F188:  CLRF   1B
0F18A:  BTFSC  FF2.7
0F18C:  BSF    1B.7
0F18E:  BCF    FF2.7
0F190:  MOVLW  05
0F192:  MOVLB  A
0F194:  MOVWF  x18
0F196:  MOVLB  0
0F198:  CALL   1006
0F19C:  BTFSC  1B.7
0F19E:  BSF    FF2.7
0F1A0:  MOVLW  41
0F1A2:  MOVWF  FE9
0F1A4:  CLRF   1B
0F1A6:  BTFSC  FF2.7
0F1A8:  BSF    1B.7
0F1AA:  BCF    FF2.7
0F1AC:  MOVFF  47,A1B
0F1B0:  MOVFF  46,A1A
0F1B4:  MOVFF  45,A19
0F1B8:  MOVFF  44,A18
0F1BC:  CALL   10CC
0F1C0:  BTFSC  1B.7
0F1C2:  BSF    FF2.7
0F1C4:  MOVLW  46
0F1C6:  MOVWF  FF6
0F1C8:  MOVLW  1C
0F1CA:  MOVWF  FF7
0F1CC:  MOVLW  00
0F1CE:  MOVWF  FF8
0F1D0:  CLRF   1B
0F1D2:  BTFSC  FF2.7
0F1D4:  BSF    1B.7
0F1D6:  BCF    FF2.7
0F1D8:  MOVLW  03
0F1DA:  MOVLB  A
0F1DC:  MOVWF  x18
0F1DE:  MOVLB  0
0F1E0:  CALL   1006
0F1E4:  BTFSC  1B.7
0F1E6:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F1E8:  CALL   D77C
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F1EC:  MOVLW  2F
0F1EE:  BTFSS  FA4.4
0F1F0:  BRA    F1EE
0F1F2:  MOVLB  F
0F1F4:  MOVWF  x1C
0F1F6:  MOVFF  2D1,8CF
0F1FA:  MOVLW  1B
0F1FC:  MOVLB  8
0F1FE:  MOVWF  xD0
0F200:  MOVLB  0
0F202:  CALL   D7C4
0F206:  MOVF   43,W
0F208:  BTFSS  FA4.4
0F20A:  BRA    F208
0F20C:  MOVLB  F
0F20E:  MOVWF  x1C
0F210:  MOVLW  41
0F212:  MOVWF  FE9
0F214:  MOVFF  47,8D2
0F218:  MOVFF  46,8D1
0F21C:  MOVFF  45,8D0
0F220:  MOVFF  44,8CF
0F224:  MOVLB  0
0F226:  BRA    F022
0F228:  MOVLW  0D
0F22A:  BTFSS  FA4.4
0F22C:  BRA    F22A
0F22E:  MOVLB  F
0F230:  MOVWF  x1C
0F232:  MOVLW  0A
0F234:  BTFSS  FA4.4
0F236:  BRA    F234
0F238:  MOVWF  x1C
....................    multidrop_off(); 
0F23A:  MOVLB  0
0F23C:  CALL   D868
0F240:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12B30:  MOVLB  8
12B32:  CLRF   xC8
12B34:  BCF    xC9.0
12B36:  CLRF   xCA
12B38:  CLRF   xCE
12B3A:  CLRF   xCD
12B3C:  CLRF   xCC
12B3E:  CLRF   xCB
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12B40:  MOVLW  02
12B42:  MOVWF  FEA
12B44:  MOVLW  43
12B46:  MOVWF  FE9
12B48:  CLRF   00
12B4A:  CLRF   02
12B4C:  MOVLW  51
12B4E:  MOVWF  01
12B50:  MOVLB  0
12B52:  CALL   34A4
....................  
....................    det_cmd(); 
12B56:  CALL   F102
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12B5A:  CALL   54CE
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12B5E:  MOVLB  8
12B60:  MOVF   xCA,W
12B62:  SUBLW  02
12B64:  BZ    12BF8
12B66:  MOVF   xCA,W
12B68:  SUBLW  03
12B6A:  BZ    12BF8
12B6C:  MOVF   xC8,W
12B6E:  SUBLW  50
12B70:  BNC   12BF8
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12B72:  BTFSS  FA4.5
12B74:  BRA    12BAC
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12B76:  MOVLB  0
12B78:  RCALL  12B16
12B7A:  MOVFF  01,8C7
....................  
....................          if(startCharacterRcvd) 
12B7E:  MOVLB  8
12B80:  BTFSS  xC9.0
12B82:  BRA    12BA4
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12B84:  MOVF   xC8,W
12B86:  INCF   xC8,F
12B88:  CLRF   03
12B8A:  ADDLW  43
12B8C:  MOVWF  FE9
12B8E:  MOVLW  02
12B90:  ADDWFC 03,W
12B92:  MOVWF  FEA
12B94:  MOVFF  8C7,FEF
....................             if (CARRIAGE_RET == c) 
12B98:  MOVF   xC7,W
12B9A:  SUBLW  0D
12B9C:  BNZ   12BA2
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12B9E:  MOVLW  02
12BA0:  MOVWF  xCA
....................             } 
....................          } 
12BA2:  BRA    12BAC
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12BA4:  MOVF   xC7,W
12BA6:  SUBLW  40
12BA8:  BNZ   12BAC
....................             { 
....................                startCharacterRcvd = TRUE; 
12BAA:  BSF    xC9.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12BAC:  MOVLW  35
12BAE:  MOVWF  00
12BB0:  DECFSZ 00,F
12BB2:  BRA    12BB0
....................       if (tenMicroSecDelayCounter++ > 500000) 
12BB4:  MOVFF  8CE,8D2
12BB8:  MOVFF  8CD,8D1
12BBC:  MOVFF  8CC,8D0
12BC0:  MOVFF  8CB,8CF
12BC4:  MOVLW  01
12BC6:  ADDWF  xCB,F
12BC8:  BTFSC  FD8.0
12BCA:  INCF   xCC,F
12BCC:  BTFSC  FD8.2
12BCE:  INCF   xCD,F
12BD0:  BTFSC  FD8.2
12BD2:  INCF   xCE,F
12BD4:  MOVF   xD2,F
12BD6:  BNZ   12BF2
12BD8:  MOVF   xD1,W
12BDA:  SUBLW  06
12BDC:  BC    12BF6
12BDE:  XORLW  FF
12BE0:  BNZ   12BF2
12BE2:  MOVF   xD0,W
12BE4:  SUBLW  A0
12BE6:  BC    12BF6
12BE8:  XORLW  FF
12BEA:  BNZ   12BF2
12BEC:  MOVF   xCF,W
12BEE:  SUBLW  20
12BF0:  BC    12BF6
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12BF2:  MOVLW  03
12BF4:  MOVWF  xCA
....................       } 
12BF6:  BRA    12B60
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12BF8:  MOVF   xC8,W
12BFA:  SUBLW  50
12BFC:  BC    12C0E
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12BFE:  MOVF   xCA,W
12C00:  SUBLW  03
12C02:  BZ    12C0E
12C04:  MOVF   xCA,W
12C06:  SUBLW  02
12C08:  BZ    12C0E
....................       { 
....................          rcvDataType = SOME_DATA; 
12C0A:  MOVLW  01
12C0C:  MOVWF  xCA
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12C0E:  MOVLB  0
12C10:  CALL   54EE
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12C14:  MOVLB  8
12C16:  MOVFF  8CA,01
12C1A:  MOVLB  0
12C1C:  GOTO   12D94 (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
0FC5C:  MOVF   1F,F
0FC5E:  BNZ   FC7E
0FC60:  MOVF   20,F
0FC62:  BNZ   FC7E
0FC64:  MOVLB  8
0FC66:  DECFSZ xC8,W
0FC68:  BRA    FC6C
0FC6A:  BRA    FC70
0FC6C:  MOVLB  0
0FC6E:  BRA    FC7E
0FC70:  CLRF   FEA
0FC72:  MOVLW  63
0FC74:  MOVWF  FE9
0FC76:  MOVLB  0
0FC78:  CALL   78E6
0FC7C:  BRA    FC92
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
0FC7E:  MOVF   20,F
0FC80:  BNZ   FC88
0FC82:  MOVF   1F,W
0FC84:  SUBLW  03
0FC86:  BC    FC92
0FC88:  CLRF   FEA
0FC8A:  MOVLW  63
0FC8C:  MOVWF  FE9
0FC8E:  CALL   78E6
....................  
....................    if (store==TRUE && sd_status==0) { 
0FC92:  MOVLB  8
0FC94:  DECFSZ xC7,W
0FC96:  BRA    FCF6
0FC98:  MOVLB  2
0FC9A:  MOVF   xD8,F
0FC9C:  BTFSC  FD8.2
0FC9E:  BRA    FCA4
0FCA0:  MOVLB  8
0FCA2:  BRA    FCF6
....................        
....................       buffer_select = 0; 
0FCA4:  MOVLB  0
0FCA6:  CLRF   x62
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FCA8:  MOVLB  8
0FCAA:  CLRF   xC9
0FCAC:  MOVLB  0
0FCAE:  CALL   5500
....................          append_data(file_ptr_raw_all); 
0FCB2:  MOVLW  02
0FCB4:  MOVLB  8
0FCB6:  MOVWF  xCA
0FCB8:  MOVLW  D9
0FCBA:  MOVWF  xC9
0FCBC:  MOVLB  0
0FCBE:  CALL   8242
....................       heartbeat(TRUE); 
0FCC2:  MOVLW  01
0FCC4:  MOVLB  8
0FCC6:  MOVWF  xC9
0FCC8:  MOVLB  0
0FCCA:  CALL   5500
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FCCE:  MOVLB  8
0FCD0:  CLRF   xC9
0FCD2:  MOVLB  0
0FCD4:  CALL   5500
....................          append_data(file_ptr_raw_new); 
0FCD8:  MOVLW  02
0FCDA:  MOVLB  8
0FCDC:  MOVWF  xCA
0FCDE:  MOVLW  E7
0FCE0:  MOVWF  xC9
0FCE2:  MOVLB  0
0FCE4:  CALL   8242
....................       heartbeat(TRUE); 
0FCE8:  MOVLW  01
0FCEA:  MOVLB  8
0FCEC:  MOVWF  xC9
0FCEE:  MOVLB  0
0FCF0:  CALL   5500
0FCF4:  MOVLB  8
....................    } 
0FCF6:  MOVLB  0
0FCF8:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12C2C:  CLRF   xC1
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12C20:  MOVLW  0D
12C22:  MOVLB  8
12C24:  MOVWF  xAA
12C26:  MOVLW  0A
12C28:  MOVWF  xAB
12C2A:  CLRF   xAC
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12C2E:  MOVLB  0
12C30:  RCALL  124DA
....................    clear_data_buffer(); 
12C32:  CALL   D22C
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12C36:  MOVLW  08
12C38:  MOVWF  FEA
12C3A:  MOVLW  AD
12C3C:  MOVWF  FE9
12C3E:  CLRF   00
12C40:  CLRF   02
12C42:  MOVLW  14
12C44:  MOVWF  01
12C46:  CALL   34A4
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12C4A:  MOVLW  01
12C4C:  MOVWF  FEA
12C4E:  MOVLW  A3
12C50:  MOVWF  FE9
12C52:  CLRF   00
12C54:  CLRF   02
12C56:  MOVLW  A0
12C58:  MOVWF  01
12C5A:  CALL   34A4
....................  
....................    time_stamp(); 
12C5E:  CALL   5398
....................    strcpy(data_buffer, time_stmp_str); 
12C62:  CLRF   FEA
12C64:  MOVLW  63
12C66:  MOVWF  FE9
12C68:  MOVLW  02
12C6A:  MOVWF  FE2
12C6C:  MOVLW  95
12C6E:  MOVWF  FE1
12C70:  MOVF   FE7,F
12C72:  MOVFF  FE6,FEE
12C76:  BNZ   12C70
....................    strcat(data_buffer, (char *)","); 
12C78:  MOVLW  2C
12C7A:  MOVLB  8
12C7C:  MOVWF  xC5
12C7E:  CLRF   xC6
12C80:  CLRF   xD5
12C82:  MOVLW  63
12C84:  MOVWF  xD4
12C86:  MOVLW  08
12C88:  MOVWF  xD7
12C8A:  MOVLW  C5
12C8C:  MOVWF  xD6
12C8E:  MOVLB  0
12C90:  CALL   545C
....................  
....................    flag_mod=fmod(macro_flag,10); 
12C94:  MOVFF  320,8F4
12C98:  MOVFF  31F,8F3
12C9C:  CALL   C622
12CA0:  MOVFF  03,8CA
12CA4:  MOVFF  02,8C9
12CA8:  MOVFF  01,8C8
12CAC:  MOVFF  00,8C7
12CB0:  MOVFF  03,8CE
12CB4:  MOVFF  02,8CD
12CB8:  MOVFF  01,8CC
12CBC:  MOVFF  00,8CB
12CC0:  MOVLB  8
12CC2:  CLRF   xD2
12CC4:  CLRF   xD1
12CC6:  MOVLW  20
12CC8:  MOVWF  xD0
12CCA:  MOVLW  82
12CCC:  MOVWF  xCF
12CCE:  MOVLB  0
12CD0:  BRA    128D6
12CD2:  MOVFF  03,8F2
12CD6:  MOVFF  02,8F1
12CDA:  MOVFF  01,8F0
12CDE:  MOVFF  00,8EF
12CE2:  RCALL  124F0
12CE4:  MOVFF  01,8C4
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
12CE8:  MOVLB  8
12CEA:  DECFSZ xC4,W
12CEC:  BRA    12CF0
12CEE:  BRA    12CF6
12CF0:  MOVF   xC4,W
12CF2:  SUBLW  03
12CF4:  BNZ   12D14
....................    { 
....................       clear_proc_time_stmp_str(); 
12CF6:  MOVLB  0
12CF8:  BRA    12A3E
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
12CFA:  MOVLW  02
12CFC:  MOVWF  FEA
12CFE:  MOVLW  B3
12D00:  MOVWF  FE9
12D02:  MOVLW  02
12D04:  MOVWF  FE2
12D06:  MOVLW  95
12D08:  MOVWF  FE1
12D0A:  MOVF   FE7,F
12D0C:  MOVFF  FE6,FEE
12D10:  BNZ   12D0A
12D12:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
12D14:  MOVLB  0
12D16:  CALL   F626
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12D1A:  MOVLB  8
12D1C:  CLRF   xC8
12D1E:  MOVLW  63
12D20:  MOVWF  xC7
12D22:  MOVLB  0
12D24:  RCALL  12A56
12D26:  MOVFF  02,03
12D2A:  MOVF   01,W
12D2C:  XORLW  FF
12D2E:  ADDLW  A1
12D30:  MOVLB  8
12D32:  MOVWF  xC7
12D34:  MOVLW  00
12D36:  SUBFWB 02,W
12D38:  MOVWF  xC8
12D3A:  MOVLW  01
12D3C:  SUBWF  xC7,F
12D3E:  MOVLW  00
12D40:  SUBWFB xC8,F
12D42:  CLRF   xCA
12D44:  MOVLW  63
12D46:  MOVWF  xC9
12D48:  MOVLW  03
12D4A:  MOVWF  xCC
12D4C:  MOVLW  21
12D4E:  MOVWF  xCB
12D50:  MOVFF  8C8,8CE
12D54:  MOVFF  8C7,8CD
12D58:  MOVLB  0
12D5A:  RCALL  12A92
....................    strcat(data_buffer, (char *)","); 
12D5C:  MOVLW  2C
12D5E:  MOVLB  8
12D60:  MOVWF  xC5
12D62:  CLRF   xC6
12D64:  CLRF   xD5
12D66:  MOVLW  63
12D68:  MOVWF  xD4
12D6A:  MOVLW  08
12D6C:  MOVWF  xD7
12D6E:  MOVLW  C5
12D70:  MOVWF  xD6
12D72:  MOVLB  0
12D74:  CALL   545C
....................     
....................    cmd = 'S'; 
12D78:  MOVLW  53
12D7A:  MOVWF  43
....................    arg = 1; 
12D7C:  CLRF   47
12D7E:  CLRF   46
12D80:  CLRF   45
12D82:  MOVLW  01
12D84:  MOVWF  44
....................  
....................    for(i = 0; i < 6; i++) 
12D86:  MOVLB  8
12D88:  CLRF   xC2
12D8A:  MOVF   xC2,W
12D8C:  SUBLW  05
12D8E:  BNC   12DA6
....................    { 
....................       rcvdData = get_slave_data(); 
12D90:  MOVLB  0
12D92:  BRA    12B30
12D94:  MOVFF  01,8C1
....................       if (DATA_COMPLETE == rcvdData) 
12D98:  MOVLB  8
12D9A:  MOVF   xC1,W
12D9C:  SUBLW  02
12D9E:  BNZ   12DA2
....................       { 
....................          break; 
12DA0:  BRA    12DA6
....................       } 
12DA2:  INCF   xC2,F
12DA4:  BRA    12D8A
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12DA6:  CLRF   xC8
12DA8:  MOVLW  63
12DAA:  MOVWF  xC7
12DAC:  MOVLB  0
12DAE:  RCALL  12A56
12DB0:  MOVFF  02,03
12DB4:  MOVF   01,W
12DB6:  XORLW  FF
12DB8:  ADDLW  A1
12DBA:  MOVLB  8
12DBC:  MOVWF  xC7
12DBE:  MOVLW  00
12DC0:  SUBFWB 02,W
12DC2:  MOVWF  xC8
12DC4:  MOVLW  01
12DC6:  SUBWF  xC7,F
12DC8:  MOVLW  00
12DCA:  SUBWFB xC8,F
12DCC:  CLRF   xCA
12DCE:  MOVLW  63
12DD0:  MOVWF  xC9
12DD2:  MOVLW  02
12DD4:  MOVWF  xCC
12DD6:  MOVLW  43
12DD8:  MOVWF  xCB
12DDA:  MOVFF  8C8,8CE
12DDE:  MOVFF  8C7,8CD
12DE2:  MOVLB  0
12DE4:  RCALL  12A92
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
12DE6:  MOVLW  02
12DE8:  MOVLB  8
12DEA:  MOVWF  xC8
12DEC:  MOVLW  43
12DEE:  MOVWF  xC7
12DF0:  MOVLB  0
12DF2:  RCALL  12A56
12DF4:  MOVFF  01,8C3
....................    if (rec_len > 0 && rec_len < 12) 
12DF8:  MOVLB  8
12DFA:  MOVF   xC3,F
12DFC:  BZ    12E0A
12DFE:  MOVF   xC3,W
12E00:  SUBLW  0B
12E02:  BNC   12E0A
....................    { 
....................       rcvdData = SHORT_DATA; 
12E04:  MOVLW  04
12E06:  MOVWF  xC1
....................    } 
12E08:  BRA    12E14
....................    else 
....................    { 
....................       if (rec_len > 30) 
12E0A:  MOVF   xC3,W
12E0C:  SUBLW  1E
12E0E:  BC    12E14
....................       { 
....................          rcvdData = LONG_DATA; 
12E10:  MOVLW  05
12E12:  MOVWF  xC1
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
12E14:  MOVLW  02
12E16:  SUBWF  xC1,W
12E18:  ADDLW  FC
12E1A:  BC    12E86
12E1C:  ADDLW  04
12E1E:  MOVLB  0
12E20:  GOTO   12FE8
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
12E24:  MOVLB  8
12E26:  BRA    12E86
12E28:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
12E2A:  MOVLW  08
12E2C:  MOVWF  1E
12E2E:  MOVLW  AD
12E30:  MOVWF  1D
12E32:  MOVLW  4A
12E34:  MOVWF  FF6
12E36:  MOVLW  1C
12E38:  MOVWF  FF7
12E3A:  MOVLW  00
12E3C:  MOVWF  FF8
12E3E:  CALL   503C
....................          break; 
12E42:  MOVLB  8
12E44:  BRA    12E86
12E46:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
12E48:  MOVLW  08
12E4A:  MOVWF  1E
12E4C:  MOVLW  AD
12E4E:  MOVWF  1D
12E50:  MOVLW  54
12E52:  MOVWF  FF6
12E54:  MOVLW  1C
12E56:  MOVWF  FF7
12E58:  MOVLW  00
12E5A:  MOVWF  FF8
12E5C:  CALL   503C
....................          break; 
12E60:  MOVLB  8
12E62:  BRA    12E86
12E64:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
12E66:  MOVLW  08
12E68:  MOVWF  1E
12E6A:  MOVLW  AD
12E6C:  MOVWF  1D
12E6E:  MOVLW  64
12E70:  MOVWF  FF6
12E72:  MOVLW  1C
12E74:  MOVWF  FF7
12E76:  MOVLW  00
12E78:  MOVWF  FF8
12E7A:  CALL   503C
....................          break; 
12E7E:  MOVLB  8
12E80:  BRA    12E86
12E82:  MOVLB  0
12E84:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12E86:  CLRF   xC8
12E88:  MOVLW  63
12E8A:  MOVWF  xC7
12E8C:  MOVLB  0
12E8E:  RCALL  12A56
12E90:  MOVFF  02,03
12E94:  MOVF   01,W
12E96:  XORLW  FF
12E98:  ADDLW  A1
12E9A:  MOVLB  8
12E9C:  MOVWF  xC7
12E9E:  MOVLW  00
12EA0:  SUBFWB 02,W
12EA2:  MOVWF  xC8
12EA4:  MOVLW  01
12EA6:  SUBWF  xC7,F
12EA8:  MOVLW  00
12EAA:  SUBWFB xC8,F
12EAC:  CLRF   xCA
12EAE:  MOVLW  63
12EB0:  MOVWF  xC9
12EB2:  MOVLW  08
12EB4:  MOVWF  xCC
12EB6:  MOVLW  AD
12EB8:  MOVWF  xCB
12EBA:  MOVFF  8C8,8CE
12EBE:  MOVFF  8C7,8CD
12EC2:  MOVLB  0
12EC4:  RCALL  12A92
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12EC6:  MOVLB  8
12EC8:  CLRF   xC8
12ECA:  MOVLW  63
12ECC:  MOVWF  xC7
12ECE:  MOVLB  0
12ED0:  RCALL  12A56
12ED2:  MOVFF  02,03
12ED6:  MOVF   01,W
12ED8:  XORLW  FF
12EDA:  ADDLW  A1
12EDC:  MOVLB  8
12EDE:  MOVWF  xC7
12EE0:  MOVLW  00
12EE2:  SUBFWB 02,W
12EE4:  MOVWF  xC8
12EE6:  MOVLW  01
12EE8:  SUBWF  xC7,F
12EEA:  MOVLW  00
12EEC:  SUBWFB xC8,F
12EEE:  CLRF   xCA
12EF0:  MOVLW  63
12EF2:  MOVWF  xC9
12EF4:  MOVLW  08
12EF6:  MOVWF  xCC
12EF8:  MOVLW  AA
12EFA:  MOVWF  xCB
12EFC:  MOVFF  8C8,8CE
12F00:  MOVFF  8C7,8CD
12F04:  MOVLB  0
12F06:  RCALL  12A92
....................  
....................    if(DATA_COMPLETE != rcvdData) 
12F08:  MOVLB  8
12F0A:  MOVF   xC1,W
12F0C:  SUBLW  02
12F0E:  BZ    12FCA
....................    {    //housekeeping 
....................       time_stamp(); 
12F10:  MOVLB  0
12F12:  CALL   5398
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
12F16:  MOVLW  01
12F18:  MOVWF  1E
12F1A:  MOVLW  A3
12F1C:  MOVWF  1D
12F1E:  MOVLW  74
12F20:  MOVWF  FF6
12F22:  MOVLW  1C
12F24:  MOVWF  FF7
12F26:  MOVLW  00
12F28:  MOVWF  FF8
12F2A:  MOVLW  0A
12F2C:  MOVLB  8
12F2E:  MOVWF  xC7
12F30:  MOVLB  0
12F32:  CALL   AA0E
12F36:  MOVFF  1E,FEA
12F3A:  MOVFF  1D,FE9
12F3E:  CLRF   FEF
12F40:  MOVLW  08
12F42:  MOVWF  FEA
12F44:  MOVLW  AD
12F46:  MOVWF  FE9
12F48:  CALL   FB2E
12F4C:  MOVLW  80
12F4E:  MOVWF  FF6
12F50:  MOVLW  1C
12F52:  MOVWF  FF7
12F54:  MOVLW  00
12F56:  MOVWF  FF8
12F58:  MOVLW  06
12F5A:  MOVLB  8
12F5C:  MOVWF  xC7
12F5E:  MOVLB  0
12F60:  CALL   AA0E
12F64:  MOVFF  8C3,8C9
12F68:  MOVLW  1B
12F6A:  MOVLB  8
12F6C:  MOVWF  xCA
12F6E:  MOVLB  0
12F70:  CALL   51FE
12F74:  MOVLW  5D
12F76:  MOVLB  8
12F78:  MOVWF  xDB
12F7A:  MOVLB  0
12F7C:  CALL   501C
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
12F80:  MOVLW  01
12F82:  MOVLB  8
12F84:  MOVWF  xC8
12F86:  MOVLW  A3
12F88:  MOVWF  xC7
12F8A:  MOVLB  0
12F8C:  RCALL  12A56
12F8E:  MOVFF  02,03
12F92:  MOVF   01,W
12F94:  XORLW  FF
12F96:  ADDLW  A1
12F98:  MOVLB  8
12F9A:  MOVWF  xC7
12F9C:  MOVLW  00
12F9E:  SUBFWB 02,W
12FA0:  MOVWF  xC8
12FA2:  MOVLW  01
12FA4:  SUBWF  xC7,F
12FA6:  MOVLW  00
12FA8:  SUBWFB xC8,F
12FAA:  MOVLW  01
12FAC:  MOVWF  xCA
12FAE:  MOVLW  A3
12FB0:  MOVWF  xC9
12FB2:  CLRF   xCC
12FB4:  MOVLW  63
12FB6:  MOVWF  xCB
12FB8:  MOVFF  8C8,8CE
12FBC:  MOVFF  8C7,8CD
12FC0:  MOVLB  0
12FC2:  RCALL  12A92
....................       record_event(); 
12FC4:  CALL   8424
12FC8:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
12FCA:  MOVFF  8A8,8C7
12FCE:  MOVFF  8A9,8C8
12FD2:  MOVLB  0
12FD4:  CALL   FC5C
....................  
....................    return (rcvdData); 
12FD8:  CLRF   03
12FDA:  MOVLB  8
12FDC:  MOVFF  8C1,01
12FE0:  MOVFF  03,02
12FE4:  MOVLB  0
12FE6:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
1340C:  MOVLB  8
1340E:  CLRF   xA0
13410:  MOVF   xA0,W
13412:  SUBLW  02
13414:  BTFSS  FD8.0
13416:  BRA    1352C
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
13418:  MOVFF  89E,8A8
1341C:  MOVFF  89F,8A9
13420:  MOVLB  0
13422:  CALL   12C20
13426:  MOVFF  02,03
1342A:  MOVF   01,W
1342C:  SUBLW  02
1342E:  BNZ   1343C
13430:  MOVF   03,F
13432:  BNZ   1343C
....................       { 
....................          break; 
13434:  MOVLB  8
13436:  BRA    1352C
....................       } 
13438:  BRA    13528
1343A:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
1343C:  MOVLW  01
1343E:  MOVLB  8
13440:  ADDWF  xA0,W
13442:  MOVWF  xA1
13444:  MOVLW  8A
13446:  MOVWF  FF6
13448:  MOVLW  1C
1344A:  MOVWF  FF7
1344C:  MOVLW  00
1344E:  MOVWF  FF8
13450:  CLRF   1B
13452:  BTFSC  FF2.7
13454:  BSF    1B.7
13456:  BCF    FF2.7
13458:  MOVLW  05
1345A:  MOVLB  A
1345C:  MOVWF  x18
1345E:  MOVLB  0
13460:  CALL   1006
13464:  BTFSC  1B.7
13466:  BSF    FF2.7
13468:  CLRF   1B
1346A:  BTFSC  FF2.7
1346C:  BSF    1B.7
1346E:  BCF    FF2.7
13470:  MOVFF  8A1,A18
13474:  MOVLW  1B
13476:  MOVLB  A
13478:  MOVWF  x19
1347A:  MOVLB  0
1347C:  CALL   0F88
13480:  BTFSC  1B.7
13482:  BSF    FF2.7
13484:  MOVLW  0D
13486:  BTFSS  F9E.4
13488:  BRA    13486
1348A:  MOVWF  FAD
1348C:  MOVLW  0A
1348E:  BTFSS  F9E.4
13490:  BRA    1348E
13492:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
13494:  BCF    F90.7
....................          delay_ms(1000); 
13496:  MOVLW  04
13498:  MOVLB  8
1349A:  MOVWF  xA1
1349C:  MOVLW  FA
1349E:  MOVLB  9
134A0:  MOVWF  xC8
134A2:  MOVLB  0
134A4:  CALL   288E
134A8:  MOVLB  8
134AA:  DECFSZ xA1,F
134AC:  BRA    1349C
....................          output_bit(VDET,ON); 
134AE:  BSF    F90.7
....................          delay_ms(1000); 
134B0:  MOVLW  04
134B2:  MOVWF  xA1
134B4:  MOVLW  FA
134B6:  MOVLB  9
134B8:  MOVWF  xC8
134BA:  MOVLB  0
134BC:  CALL   288E
134C0:  MOVLB  8
134C2:  DECFSZ xA1,F
134C4:  BRA    134B4
....................          if (LightTargetFlag==0) 
134C6:  MOVLB  2
134C8:  MOVF   xD5,F
134CA:  BNZ   13512
....................          { 
....................           cmd='K'; 
134CC:  MOVLW  4B
134CE:  MOVWF  43
....................           arg=detector_ch; 
134D0:  CLRF   47
134D2:  CLRF   46
134D4:  CLRF   45
134D6:  MOVFF  2D2,44
....................           det_cmd(); 
134DA:  MOVLB  0
134DC:  CALL   F102
....................           delay_ms(1000); 
134E0:  MOVLW  04
134E2:  MOVLB  8
134E4:  MOVWF  xA1
134E6:  MOVLW  FA
134E8:  MOVLB  9
134EA:  MOVWF  xC8
134EC:  MOVLB  0
134EE:  CALL   288E
134F2:  MOVLB  8
134F4:  DECFSZ xA1,F
134F6:  BRA    134E6
....................           cmd='L'; 
134F8:  MOVLW  4C
134FA:  MOVWF  43
....................           arg=detector_li; 
134FC:  CLRF   47
134FE:  CLRF   46
13500:  MOVFF  2D4,45
13504:  MOVFF  2D3,44
....................           det_cmd(); 
13508:  MOVLB  0
1350A:  CALL   F102
....................          }  
1350E:  BRA    13526
13510:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
13512:  MOVLW  6C
13514:  MOVWF  43
....................           arg=1; 
13516:  CLRF   47
13518:  CLRF   46
1351A:  CLRF   45
1351C:  MOVLW  01
1351E:  MOVWF  44
....................           det_cmd(); 
13520:  MOVLB  0
13522:  CALL   F102
13526:  MOVLB  8
....................          }  
....................       } 
13528:  INCF   xA0,F
1352A:  BRA    13410
....................    } 
....................  
....................    parse_data(); 
1352C:  MOVLB  0
1352E:  RCALL  1338A
....................    data_available = TRUE; 
13530:  MOVLW  01
13532:  MOVLB  3
13534:  MOVWF  x37
....................    macro_flag = 900; 
13536:  MOVLW  03
13538:  MOVWF  x20
1353A:  MOVLW  84
1353C:  MOVWF  x1F
....................  
....................    return; 
1353E:  MOVLB  0
13540:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
138AC:  MOVLB  8
138AE:  CLRF   xA9
138B0:  CLRF   xA8
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
138B2:  MOVLB  0
138B4:  RCALL  1338A
138B6:  MOVFF  02,8A9
138BA:  MOVFF  01,8A8
....................    return (temp); 
138BE:  MOVLB  8
138C0:  MOVFF  8A8,01
138C4:  MOVFF  8A9,02
138C8:  MOVLB  0
138CA:  GOTO   139DC (RETURN)
.................... } 
....................  
.................... void det_temp() 
138CE:  MOVLB  8
138D0:  CLRF   xA5
138D2:  CLRF   xA4
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
138D4:  MOVLB  2
138D6:  MOVF   xD1,W
138D8:  XORLW  01
138DA:  MOVLB  0
138DC:  BZ    138E4
138DE:  XORLW  03
138E0:  BZ    138EE
138E2:  BRA    138F8
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
138E4:  MOVFF  3E,8A7
138E8:  MOVFF  3D,8A6
....................          break; 
138EC:  BRA    13904
....................       case 2 : target_temp = nv_d2_temp; 
138EE:  MOVFF  40,8A7
138F2:  MOVFF  3F,8A6
....................          break; 
138F6:  BRA    13904
....................       default : target_temp = 20000; 
138F8:  MOVLW  4E
138FA:  MOVLB  8
138FC:  MOVWF  xA7
138FE:  MOVLW  20
13900:  MOVWF  xA6
....................          break; 
13902:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
13904:  MOVLB  8
13906:  CLRF   xA3
13908:  MOVLW  3C
1390A:  MOVWF  xA2
....................    n = 0; 
1390C:  CLRF   xA1
1390E:  CLRF   xA0
....................    store=FALSE; 
13910:  CLRF   x9E
....................    display=FALSE; 
13912:  CLRF   x9F
....................  
....................    time_stamp(); 
13914:  MOVLB  0
13916:  CALL   5398
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
1391A:  MOVLW  01
1391C:  MOVWF  1E
1391E:  MOVLW  A3
13920:  MOVWF  1D
13922:  MOVLW  94
13924:  MOVWF  FF6
13926:  MOVLW  1C
13928:  MOVWF  FF7
1392A:  MOVLW  00
1392C:  MOVWF  FF8
1392E:  MOVLW  16
13930:  MOVLB  8
13932:  MOVWF  xC7
13934:  MOVLB  0
13936:  CALL   AA0E
1393A:  MOVLW  10
1393C:  MOVWF  FE9
1393E:  MOVFF  8A7,8D3
13942:  MOVFF  8A6,8D2
13946:  CALL   AA40
1394A:  MOVLW  AD
1394C:  MOVWF  FF6
1394E:  MOVLW  1C
13950:  MOVWF  FF7
13952:  MOVLW  00
13954:  MOVWF  FF8
13956:  MOVLW  09
13958:  MOVLB  8
1395A:  MOVWF  xC7
1395C:  MOVLB  0
1395E:  CALL   AA0E
13962:  MOVLW  10
13964:  MOVWF  FE9
13966:  MOVFF  8A5,8D3
1396A:  MOVFF  8A4,8D2
1396E:  CALL   AA40
13972:  MOVLW  B9
13974:  MOVWF  FF6
13976:  MOVLW  1C
13978:  MOVWF  FF7
1397A:  MOVLW  00
1397C:  MOVWF  FF8
1397E:  MOVLW  0B
13980:  MOVLB  8
13982:  MOVWF  xC7
13984:  MOVLB  0
13986:  CALL   AA0E
1398A:  MOVLW  10
1398C:  MOVWF  FE9
1398E:  MOVFF  8A1,8D3
13992:  MOVFF  8A0,8D2
13996:  CALL   AA40
1399A:  MOVLW  C7
1399C:  MOVWF  FF6
1399E:  MOVLW  1C
139A0:  MOVWF  FF7
139A2:  MOVLW  00
139A4:  MOVWF  FF8
139A6:  MOVLW  03
139A8:  MOVLB  8
139AA:  MOVWF  xC7
139AC:  MOVLB  0
139AE:  CALL   AA0E
....................    record_event(); 
139B2:  CALL   8424
....................  
....................    for (n=1; n<t; ++n) 
139B6:  MOVLB  8
139B8:  CLRF   xA1
139BA:  MOVLW  01
139BC:  MOVWF  xA0
139BE:  MOVF   xA1,W
139C0:  SUBWF  xA3,W
139C2:  BNC   13A1E
139C4:  BNZ   139CC
139C6:  MOVF   xA2,W
139C8:  SUBWF  xA0,W
139CA:  BC    13A1E
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
139CC:  MOVFF  89E,8A8
139D0:  MOVFF  89F,8A9
139D4:  MOVLB  0
139D6:  CALL   12C20
....................       current_temp=parse_temp(); 
139DA:  BRA    138AC
139DC:  MOVFF  02,8A5
139E0:  MOVFF  01,8A4
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
139E4:  MOVLB  8
139E6:  MOVF   xA7,W
139E8:  SUBWF  xA5,W
139EA:  BNC   139F4
139EC:  BNZ   139FC
139EE:  MOVF   xA6,W
139F0:  SUBWF  xA4,W
139F2:  BC    139FC
139F4:  MOVF   xA4,F
139F6:  BNZ   13A00
139F8:  MOVF   xA5,F
139FA:  BNZ   13A00
139FC:  BRA    13A1E
139FE:  BRA    13A16
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13A00:  MOVLW  0A
13A02:  MOVWF  xA8
13A04:  MOVLW  FA
13A06:  MOVLB  9
13A08:  MOVWF  xC8
13A0A:  MOVLB  0
13A0C:  CALL   288E
13A10:  MOVLB  8
13A12:  DECFSZ xA8,F
13A14:  BRA    13A04
13A16:  INCF   xA0,F
13A18:  BTFSC  FD8.2
13A1A:  INCF   xA1,F
13A1C:  BRA    139BE
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13A1E:  MOVLW  01
13A20:  MOVWF  1E
13A22:  MOVLW  A3
13A24:  MOVWF  1D
13A26:  MOVLW  CC
13A28:  MOVWF  FF6
13A2A:  MOVLW  1C
13A2C:  MOVWF  FF7
13A2E:  MOVLW  00
13A30:  MOVWF  FF8
13A32:  MOVLW  14
13A34:  MOVWF  xC7
13A36:  MOVLB  0
13A38:  CALL   AA0E
13A3C:  MOVLW  10
13A3E:  MOVWF  FE9
13A40:  MOVFF  8A7,8D3
13A44:  MOVFF  8A6,8D2
13A48:  CALL   AA40
13A4C:  MOVLW  E3
13A4E:  MOVWF  FF6
13A50:  MOVLW  1C
13A52:  MOVWF  FF7
13A54:  MOVLW  00
13A56:  MOVWF  FF8
13A58:  MOVLW  09
13A5A:  MOVLB  8
13A5C:  MOVWF  xC7
13A5E:  MOVLB  0
13A60:  CALL   AA0E
13A64:  MOVLW  10
13A66:  MOVWF  FE9
13A68:  MOVFF  8A5,8D3
13A6C:  MOVFF  8A4,8D2
13A70:  CALL   AA40
13A74:  MOVLW  EF
13A76:  MOVWF  FF6
13A78:  MOVLW  1C
13A7A:  MOVWF  FF7
13A7C:  MOVLW  00
13A7E:  MOVWF  FF8
13A80:  MOVLW  0B
13A82:  MOVLB  8
13A84:  MOVWF  xC7
13A86:  MOVLB  0
13A88:  CALL   AA0E
13A8C:  MOVLW  10
13A8E:  MOVWF  FE9
13A90:  MOVFF  8A1,8D3
13A94:  MOVFF  8A0,8D2
13A98:  CALL   AA40
13A9C:  MOVLW  FD
13A9E:  MOVWF  FF6
13AA0:  MOVLW  1C
13AA2:  MOVWF  FF7
13AA4:  MOVLW  00
13AA6:  MOVWF  FF8
13AA8:  MOVLW  03
13AAA:  MOVLB  8
13AAC:  MOVWF  xC7
13AAE:  MOVLB  0
13AB0:  CALL   AA0E
....................    record_event();    
13AB4:  CALL   8424
13AB8:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
13584:  MOVLB  8
13586:  CLRF   xB1
13588:  CLRF   xB0
1358A:  CLRF   xAF
1358C:  CLRF   xAE
....................    set_adc_channel(1,VSS); 
1358E:  MOVLW  04
13590:  MOVWF  01
13592:  MOVF   FC2,W
13594:  ANDLW  83
13596:  IORWF  01,W
13598:  MOVWF  FC2
1359A:  MOVLW  00
1359C:  MOVWF  01
1359E:  MOVF   FC1,W
135A0:  ANDLW  F8
135A2:  IORWF  01,W
135A4:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
135A6:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
135A8:  MOVLW  01
135AA:  MOVWF  xAB
135AC:  MOVF   xAB,W
135AE:  SUBLW  32
135B0:  BNC   135D6
....................       reading=read_adc(); 
135B2:  BSF    FC2.1
135B4:  BTFSC  FC2.1
135B6:  BRA    135B4
135B8:  MOVFF  FC3,8B2
135BC:  MOVFF  FC4,8B3
135C0:  CLRF   xB4
135C2:  CLRF   xB5
....................       delay_ms(5); 
135C4:  MOVLW  05
135C6:  MOVLB  9
135C8:  MOVWF  xC8
135CA:  MOVLB  0
135CC:  CALL   288E
135D0:  MOVLB  8
135D2:  INCF   xAB,F
135D4:  BRA    135AC
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
135D6:  MOVLW  01
135D8:  MOVWF  xAB
135DA:  MOVF   xAB,W
135DC:  SUBLW  64
135DE:  BNC   1368C
....................       reading=read_adc(); 
135E0:  BSF    FC2.1
135E2:  BTFSC  FC2.1
135E4:  BRA    135E2
135E6:  MOVFF  FC3,8B2
135EA:  MOVFF  FC4,8B3
135EE:  CLRF   xB4
135F0:  CLRF   xB5
....................       result=(((result*(i-1))+reading)/i); 
135F2:  MOVLW  01
135F4:  SUBWF  xAB,W
135F6:  MOVWF  xB6
135F8:  MOVFF  8B1,9D5
135FC:  MOVFF  8B0,9D4
13600:  MOVFF  8AF,9D3
13604:  MOVFF  8AE,9D2
13608:  MOVLB  9
1360A:  CLRF   xD9
1360C:  CLRF   xD8
1360E:  CLRF   xD7
13610:  MOVWF  xD6
13612:  MOVLB  0
13614:  CALL   4778
13618:  MOVFF  03,8B9
1361C:  MOVFF  02,8B8
13620:  MOVFF  01,8B7
13624:  MOVFF  00,8B6
13628:  MOVLB  8
1362A:  MOVF   xB2,W
1362C:  ADDWF  xB6,F
1362E:  MOVF   xB3,W
13630:  ADDWFC xB7,F
13632:  MOVF   xB4,W
13634:  ADDWFC xB8,F
13636:  MOVF   xB5,W
13638:  ADDWFC xB9,F
1363A:  BCF    FD8.1
1363C:  CLRF   1B
1363E:  BTFSC  FF2.7
13640:  BSF    1B.7
13642:  BCF    FF2.7
13644:  MOVFF  8B9,A27
13648:  MOVFF  8B8,A26
1364C:  MOVFF  8B7,A25
13650:  MOVFF  8B6,A24
13654:  MOVLB  A
13656:  CLRF   x2B
13658:  CLRF   x2A
1365A:  CLRF   x29
1365C:  MOVFF  8AB,A28
13660:  MOVLB  0
13662:  CALL   1038
13666:  BTFSC  1B.7
13668:  BSF    FF2.7
1366A:  MOVFF  03,8B1
1366E:  MOVFF  02,8B0
13672:  MOVFF  01,8AF
13676:  MOVFF  00,8AE
....................       delay_ms(5); 
1367A:  MOVLW  05
1367C:  MOVLB  9
1367E:  MOVWF  xC8
13680:  MOVLB  0
13682:  CALL   288E
13686:  MOVLB  8
13688:  INCF   xAB,F
1368A:  BRA    135DA
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
1368C:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
1368E:  MOVFF  8B1,9D5
13692:  MOVFF  8B0,9D4
13696:  MOVFF  8AF,9D3
1369A:  MOVFF  8AE,9D2
1369E:  MOVLB  9
136A0:  CLRF   xD9
136A2:  CLRF   xD8
136A4:  MOVLW  10
136A6:  MOVWF  xD7
136A8:  MOVLW  25
136AA:  MOVWF  xD6
136AC:  MOVLB  0
136AE:  CALL   4778
136B2:  MOVFF  03,8B9
136B6:  MOVFF  02,8B8
136BA:  MOVFF  01,8B7
136BE:  MOVFF  00,8B6
136C2:  BCF    FD8.1
136C4:  CLRF   1B
136C6:  BTFSC  FF2.7
136C8:  BSF    1B.7
136CA:  BCF    FF2.7
136CC:  MOVFF  03,A27
136D0:  MOVFF  02,A26
136D4:  MOVFF  01,A25
136D8:  MOVFF  00,A24
136DC:  MOVLB  A
136DE:  CLRF   x2B
136E0:  CLRF   x2A
136E2:  CLRF   x29
136E4:  MOVLW  64
136E6:  MOVWF  x28
136E8:  MOVLB  0
136EA:  CALL   1038
136EE:  BTFSC  1B.7
136F0:  BSF    FF2.7
136F2:  MOVLW  21
136F4:  MOVLB  8
136F6:  SUBWF  00,W
136F8:  MOVWF  xAC
136FA:  MOVLW  50
136FC:  SUBWFB 01,W
136FE:  MOVWF  xAD
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
13700:  MOVFF  8AC,01
13704:  MOVFF  8AD,02
13708:  MOVLB  0
1370A:  GOTO   13770 (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
1371A:  CLRF   xA4
1371C:  CLRF   xA3
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
1370E:  MOVLW  0D
13710:  MOVLB  8
13712:  MOVWF  xA0
13714:  MOVLW  0A
13716:  MOVWF  xA1
13718:  CLRF   xA2
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
1371E:  MOVLB  0
13720:  CALL   124DA
....................    clear_data_buffer(); 
13724:  CALL   D22C
....................  
....................    time_stamp(); 
13728:  CALL   5398
....................    strcpy(data_buffer, time_stmp_str); 
1372C:  CLRF   FEA
1372E:  MOVLW  63
13730:  MOVWF  FE9
13732:  MOVLW  02
13734:  MOVWF  FE2
13736:  MOVLW  95
13738:  MOVWF  FE1
1373A:  MOVF   FE7,F
1373C:  MOVFF  FE6,FEE
13740:  BNZ   1373A
....................    strcat(data_buffer, (char *)",Tmp,"); 
13742:  MOVLW  2C
13744:  MOVLB  8
13746:  MOVWF  xA5
13748:  MOVLW  54
1374A:  MOVWF  xA6
1374C:  MOVLW  6D
1374E:  MOVWF  xA7
13750:  MOVLW  70
13752:  MOVWF  xA8
13754:  MOVLW  2C
13756:  MOVWF  xA9
13758:  CLRF   xAA
1375A:  CLRF   xD5
1375C:  MOVLW  63
1375E:  MOVWF  xD4
13760:  MOVLW  08
13762:  MOVWF  xD7
13764:  MOVLW  A5
13766:  MOVWF  xD6
13768:  MOVLB  0
1376A:  CALL   545C
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
1376E:  BRA    13584
13770:  MOVFF  02,8A4
13774:  MOVFF  01,8A3
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
13778:  MOVLW  02
1377A:  MOVWF  1E
1377C:  MOVLW  43
1377E:  MOVWF  1D
13780:  MOVLW  45
13782:  MOVWF  FE9
13784:  MOVLB  8
13786:  CLRF   xCC
13788:  CLRF   xCB
1378A:  MOVFF  8A4,8CA
1378E:  MOVFF  8A3,8C9
13792:  MOVLW  03
13794:  MOVWF  xCD
13796:  MOVLB  0
13798:  CALL   5298
....................  
....................    strcat(slave_reply, endofline); 
1379C:  MOVLW  02
1379E:  MOVLB  8
137A0:  MOVWF  xD5
137A2:  MOVLW  43
137A4:  MOVWF  xD4
137A6:  MOVLW  08
137A8:  MOVWF  xD7
137AA:  MOVLW  A0
137AC:  MOVWF  xD6
137AE:  MOVLB  0
137B0:  CALL   545C
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
137B4:  MOVLB  8
137B6:  CLRF   xC8
137B8:  MOVLW  63
137BA:  MOVWF  xC7
137BC:  MOVLB  0
137BE:  CALL   12A56
137C2:  MOVFF  02,03
137C6:  MOVF   01,W
137C8:  XORLW  FF
137CA:  ADDLW  A1
137CC:  MOVLB  8
137CE:  MOVWF  xAB
137D0:  MOVLW  00
137D2:  SUBFWB 02,W
137D4:  MOVWF  xAC
137D6:  MOVLW  01
137D8:  SUBWF  xAB,F
137DA:  MOVLW  00
137DC:  SUBWFB xAC,F
137DE:  CLRF   xCA
137E0:  MOVLW  63
137E2:  MOVWF  xC9
137E4:  MOVLW  02
137E6:  MOVWF  xCC
137E8:  MOVLW  43
137EA:  MOVWF  xCB
137EC:  MOVFF  8AC,8CE
137F0:  MOVFF  8AB,8CD
137F4:  MOVLB  0
137F6:  CALL   12A92
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
137FA:  MOVF   1F,F
137FC:  BNZ   1381C
137FE:  MOVF   20,F
13800:  BNZ   1381C
13802:  MOVLB  8
13804:  DECFSZ x9F,W
13806:  BRA    1380A
13808:  BRA    1380E
1380A:  MOVLB  0
1380C:  BRA    1381C
1380E:  CLRF   FEA
13810:  MOVLW  63
13812:  MOVWF  FE9
13814:  MOVLB  0
13816:  CALL   78E6
1381A:  BRA    13830
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
1381C:  MOVF   20,F
1381E:  BNZ   13826
13820:  MOVF   1F,W
13822:  SUBLW  03
13824:  BC    13830
13826:  CLRF   FEA
13828:  MOVLW  63
1382A:  MOVWF  FE9
1382C:  CALL   78E6
....................  
....................    if (store == TRUE && sd_status==0) { 
13830:  MOVLB  8
13832:  DECFSZ x9E,W
13834:  BRA    13894
13836:  MOVLB  2
13838:  MOVF   xD8,F
1383A:  BTFSC  FD8.2
1383C:  BRA    13842
1383E:  MOVLB  8
13840:  BRA    13894
....................       buffer_select = 0; 
13842:  MOVLB  0
13844:  CLRF   x62
....................       
....................       heartbeat(FALSE); 
13846:  MOVLB  8
13848:  CLRF   xC9
1384A:  MOVLB  0
1384C:  CALL   5500
....................          append_data(file_ptr_raw_all); 
13850:  MOVLW  02
13852:  MOVLB  8
13854:  MOVWF  xCA
13856:  MOVLW  D9
13858:  MOVWF  xC9
1385A:  MOVLB  0
1385C:  CALL   8242
....................       heartbeat(TRUE); 
13860:  MOVLW  01
13862:  MOVLB  8
13864:  MOVWF  xC9
13866:  MOVLB  0
13868:  CALL   5500
....................        
....................       heartbeat(FALSE); 
1386C:  MOVLB  8
1386E:  CLRF   xC9
13870:  MOVLB  0
13872:  CALL   5500
....................          append_data(file_ptr_raw_new); 
13876:  MOVLW  02
13878:  MOVLB  8
1387A:  MOVWF  xCA
1387C:  MOVLW  E7
1387E:  MOVWF  xC9
13880:  MOVLB  0
13882:  CALL   8242
....................       heartbeat(TRUE); 
13886:  MOVLW  01
13888:  MOVLB  8
1388A:  MOVWF  xC9
1388C:  MOVLB  0
1388E:  CALL   5500
13892:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13894:  MOVLW  03
13896:  MOVLB  3
13898:  MOVWF  x20
1389A:  MOVLW  84
1389C:  MOVWF  x1F
....................     
....................    return (temp); 
1389E:  MOVLB  8
138A0:  MOVFF  8A3,01
138A4:  MOVFF  8A4,02
138A8:  MOVLB  0
138AA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
123EC:  MOVLB  8
123EE:  MOVF   xA1,W
123F0:  ADDLW  FC
123F2:  BC    12430
123F4:  ADDLW  04
123F6:  MOVLB  0
123F8:  GOTO   12438
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
123FC:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
123FE:  BCF    F8C.1
....................          break; 
12400:  MOVLB  8
12402:  BRA    12430
....................       case 1 :  
....................             output_bit(HSW1, ON); 
12404:  BSF    F8C.0
....................          break; 
12406:  MOVLB  8
12408:  BRA    12430
....................       case 2 :  
....................             output_bit(HSW2, ON); 
1240A:  BSF    F8C.1
....................          break;  
1240C:  MOVLB  8
1240E:  BRA    12430
....................       case 3 :  
....................             output_bit(HSW1, ON); 
12410:  BSF    F8C.0
....................             delay_ms(500); 
12412:  MOVLW  02
12414:  MOVLB  8
12416:  MOVWF  xA2
12418:  MOVLW  FA
1241A:  MOVLB  9
1241C:  MOVWF  xC8
1241E:  MOVLB  0
12420:  CALL   288E
12424:  MOVLB  8
12426:  DECFSZ xA2,F
12428:  BRA    12418
....................             output_bit(HSW2, ON); 
1242A:  BSF    F8C.1
....................          break;             
1242C:  BRA    12430
1242E:  MOVLB  8
....................    } 
....................    heater_stat=set; 
12430:  MOVFF  8A1,4B1
12434:  MOVLB  0
12436:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F51C:  MOVLW  08
0F51E:  MOVLB  8
0F520:  MOVWF  xA8
0F522:  CLRF   xA7
....................    LED_level_change=2048; 
0F524:  MOVWF  xAA
0F526:  CLRF   xA9
....................     
....................    for (i=0; i<12; i++){ 
0F528:  CLRF   xA6
0F52A:  MOVF   xA6,W
0F52C:  SUBLW  0B
0F52E:  BNC   F5A6
....................       DAC_set(1,LED_level); 
0F530:  MOVLW  01
0F532:  MOVWF  xAF
0F534:  MOVFF  8A8,8B1
0F538:  MOVFF  8A7,8B0
0F53C:  MOVLB  0
0F53E:  RCALL  F278
....................       LED_level_change = LED_level_change/2; 
0F540:  BCF    FD8.0
0F542:  MOVLB  8
0F544:  RRCF   xAA,F
0F546:  RRCF   xA9,F
....................       ADC_average(200); 
0F548:  CLRF   xB0
0F54A:  MOVLW  C8
0F54C:  MOVWF  xAF
0F54E:  MOVLB  0
0F550:  RCALL  F320
....................       output = ADC_val[2]; 
0F552:  MOVFF  4A6,8AC
0F556:  MOVFF  4A5,8AB
....................       temp = ADC_val[3]; 
0F55A:  MOVFF  4A8,8AE
0F55E:  MOVFF  4A7,8AD
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F562:  MOVLB  8
0F564:  MOVF   xA5,W
0F566:  SUBWF  xAC,W
0F568:  BNC   F57C
0F56A:  BNZ   F572
0F56C:  MOVF   xAB,W
0F56E:  SUBWF  xA4,W
0F570:  BC    F57C
....................          LED_level=LED_level-LED_level_change; 
0F572:  MOVF   xA9,W
0F574:  SUBWF  xA7,F
0F576:  MOVF   xAA,W
0F578:  SUBWFB xA8,F
....................       } 
0F57A:  BRA    F5A2
....................       else if(output<intensity){ 
0F57C:  MOVF   xAC,W
0F57E:  SUBWF  xA5,W
0F580:  BNC   F594
0F582:  BNZ   F58A
0F584:  MOVF   xA4,W
0F586:  SUBWF  xAB,W
0F588:  BC    F594
....................          LED_level=LED_level+LED_level_change; 
0F58A:  MOVF   xA9,W
0F58C:  ADDWF  xA7,F
0F58E:  MOVF   xAA,W
0F590:  ADDWFC xA8,F
....................       } 
0F592:  BRA    F5A2
....................       else if(output==intensity) break; 
0F594:  MOVF   xA4,W
0F596:  SUBWF  xAB,W
0F598:  BNZ   F5A2
0F59A:  MOVF   xA5,W
0F59C:  SUBWF  xAC,W
0F59E:  BTFSC  FD8.2
0F5A0:  BRA    F5A6
0F5A2:  INCF   xA6,F
0F5A4:  BRA    F52A
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F5A6:  MOVLW  01
0F5A8:  MOVWF  xAF
0F5AA:  MOVFF  8A8,8B1
0F5AE:  MOVFF  8A7,8B0
0F5B2:  MOVLB  0
0F5B4:  RCALL  F278
0F5B6:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F5B8:  MOVLW  01
0F5BA:  MOVLB  8
0F5BC:  MOVWF  xA3
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F5BE:  MOVF   xA1,F
0F5C0:  BNZ   F5C6
0F5C2:  MOVF   xA2,F
0F5C4:  BZ    F5DA
0F5C6:  MOVF   xA2,W
0F5C8:  SUBLW  0F
0F5CA:  BNC   F5DA
0F5CC:  MOVFF  8A2,8A5
0F5D0:  MOVFF  8A1,8A4
0F5D4:  MOVLB  0
0F5D6:  RCALL  F51C
0F5D8:  MOVLB  8
....................   if(intensity == 0) { 
0F5DA:  MOVF   xA1,F
0F5DC:  BNZ   F600
0F5DE:  MOVF   xA2,F
0F5E0:  BNZ   F600
....................       DAC_set(1, 0); 
0F5E2:  MOVLW  01
0F5E4:  MOVWF  xAF
0F5E6:  CLRF   xB1
0F5E8:  CLRF   xB0
0F5EA:  MOVLB  0
0F5EC:  RCALL  F278
....................       DAC_set(2, 0); 
0F5EE:  MOVLW  02
0F5F0:  MOVLB  8
0F5F2:  MOVWF  xAF
0F5F4:  CLRF   xB1
0F5F6:  CLRF   xB0
0F5F8:  MOVLB  0
0F5FA:  RCALL  F278
....................    } 
0F5FC:  BRA    F604
0F5FE:  MOVLB  8
....................    else valid=FALSE; 
0F600:  CLRF   xA3
0F602:  MOVLB  0
....................    return(valid); 
0F604:  MOVLB  8
0F606:  MOVFF  8A3,01
0F60A:  MOVLB  0
0F60C:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FB8E:  MOVLW  02
0FB90:  MOVWF  FF6
0FB92:  MOVLW  1D
0FB94:  MOVWF  FF7
0FB96:  MOVLW  00
0FB98:  MOVWF  FF8
0FB9A:  MOVLW  03
0FB9C:  MOVWF  FEA
0FB9E:  MOVLW  39
0FBA0:  MOVWF  FE9
0FBA2:  RCALL  FB54
0FBA4:  MOVF   01,W
0FBA6:  BZ    FBBA
0FBA8:  XORLW  01
0FBAA:  BZ    FBDA
0FBAC:  XORLW  03
0FBAE:  BZ    FBFA
0FBB0:  XORLW  01
0FBB2:  BZ    FC1A
0FBB4:  XORLW  07
0FBB6:  BZ    FC3A
0FBB8:  BRA    FC58
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FBBA:  BCF    FD8.0
0FBBC:  MOVLB  3
0FBBE:  RLCF   x46,W
0FBC0:  CLRF   03
0FBC2:  ADDLW  47
0FBC4:  MOVWF  FE9
0FBC6:  MOVLW  03
0FBC8:  ADDWFC 03,W
0FBCA:  MOVWF  FEA
0FBCC:  MOVFF  4A4,FEC
0FBD0:  MOVF   FED,F
0FBD2:  MOVFF  4A3,FEF
....................          break; 
0FBD6:  MOVLB  0
0FBD8:  BRA    FC58
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FBDA:  BCF    FD8.0
0FBDC:  MOVLB  3
0FBDE:  RLCF   x46,W
0FBE0:  CLRF   03
0FBE2:  ADDLW  59
0FBE4:  MOVWF  FE9
0FBE6:  MOVLW  03
0FBE8:  ADDWFC 03,W
0FBEA:  MOVWF  FEA
0FBEC:  MOVFF  4A4,FEC
0FBF0:  MOVF   FED,F
0FBF2:  MOVFF  4A3,FEF
....................          break;    
0FBF6:  MOVLB  0
0FBF8:  BRA    FC58
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FBFA:  BCF    FD8.0
0FBFC:  MOVLB  3
0FBFE:  RLCF   x46,W
0FC00:  CLRF   03
0FC02:  ADDLW  6B
0FC04:  MOVWF  FE9
0FC06:  MOVLW  03
0FC08:  ADDWFC 03,W
0FC0A:  MOVWF  FEA
0FC0C:  MOVFF  4A4,FEC
0FC10:  MOVF   FED,F
0FC12:  MOVFF  4A3,FEF
....................          break; 
0FC16:  MOVLB  0
0FC18:  BRA    FC58
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FC1A:  BCF    FD8.0
0FC1C:  MOVLB  3
0FC1E:  RLCF   x46,W
0FC20:  CLRF   03
0FC22:  ADDLW  7D
0FC24:  MOVWF  FE9
0FC26:  MOVLW  03
0FC28:  ADDWFC 03,W
0FC2A:  MOVWF  FEA
0FC2C:  MOVFF  4A4,FEC
0FC30:  MOVF   FED,F
0FC32:  MOVFF  4A3,FEF
....................          break; 
0FC36:  MOVLB  0
0FC38:  BRA    FC58
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FC3A:  BCF    FD8.0
0FC3C:  MOVLB  3
0FC3E:  RLCF   x46,W
0FC40:  CLRF   03
0FC42:  ADDLW  8F
0FC44:  MOVWF  FE9
0FC46:  MOVLW  03
0FC48:  ADDWFC 03,W
0FC4A:  MOVWF  FEA
0FC4C:  MOVFF  4A4,FEC
0FC50:  MOVF   FED,F
0FC52:  MOVFF  4A3,FEF
....................          break; 
0FC56:  MOVLB  0
....................    } 
0FC58:  GOTO   FF3C (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
0FCFA:  MOVFF  89F,8B0
0FCFE:  MOVFF  89E,8AF
0FD02:  CALL   F320
....................     
....................    v_supply = read_supply(); 
0FD06:  CALL   507A
0FD0A:  MOVFF  02,8A4
0FD0E:  MOVFF  01,8A3
....................        
....................    RTC_reset_HT(); 
0FD12:  CALL   3430
....................    RTC_read(); 
0FD16:  CALL   32C2
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
0FD1A:  RCALL  F626
0FD1C:  MOVFF  02,8A6
0FD20:  MOVFF  01,8A5
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
0FD24:  MOVLB  8
0FD26:  DECFSZ xA2,W
0FD28:  BRA    FD52
0FD2A:  MOVLW  10
0FD2C:  MOVWF  FE9
0FD2E:  CLRF   1B
0FD30:  BTFSC  FF2.7
0FD32:  BSF    1B.7
0FD34:  BCF    FF2.7
0FD36:  MOVFF  4A6,A19
0FD3A:  MOVFF  4A5,A18
0FD3E:  MOVLB  0
0FD40:  CALL   1188
0FD44:  BTFSC  1B.7
0FD46:  BSF    FF2.7
0FD48:  MOVLW  2C
0FD4A:  BTFSS  F9E.4
0FD4C:  BRA    FD4A
0FD4E:  MOVWF  FAD
0FD50:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
0FD52:  CLRF   1E
0FD54:  MOVLW  63
0FD56:  MOVWF  1D
0FD58:  MOVFF  726,8C9
0FD5C:  MOVLW  01
0FD5E:  MOVWF  xCA
0FD60:  MOVLB  0
0FD62:  CALL   51FE
0FD66:  MOVLW  2F
0FD68:  MOVLB  8
0FD6A:  MOVWF  xDB
0FD6C:  MOVLB  0
0FD6E:  CALL   501C
0FD72:  MOVFF  725,8C9
0FD76:  MOVLW  01
0FD78:  MOVLB  8
0FD7A:  MOVWF  xCA
0FD7C:  MOVLB  0
0FD7E:  CALL   51FE
0FD82:  MOVLW  2F
0FD84:  MOVLB  8
0FD86:  MOVWF  xDB
0FD88:  MOVLB  0
0FD8A:  CALL   501C
0FD8E:  MOVFF  727,8C9
0FD92:  MOVLW  01
0FD94:  MOVLB  8
0FD96:  MOVWF  xCA
0FD98:  MOVLB  0
0FD9A:  CALL   51FE
0FD9E:  MOVLW  20
0FDA0:  MOVLB  8
0FDA2:  MOVWF  xDB
0FDA4:  MOVLB  0
0FDA6:  CALL   501C
0FDAA:  MOVFF  723,8C9
0FDAE:  MOVLW  01
0FDB0:  MOVLB  8
0FDB2:  MOVWF  xCA
0FDB4:  MOVLB  0
0FDB6:  CALL   51FE
0FDBA:  MOVLW  3A
0FDBC:  MOVLB  8
0FDBE:  MOVWF  xDB
0FDC0:  MOVLB  0
0FDC2:  CALL   501C
0FDC6:  MOVFF  722,8C9
0FDCA:  MOVLW  01
0FDCC:  MOVLB  8
0FDCE:  MOVWF  xCA
0FDD0:  MOVLB  0
0FDD2:  CALL   51FE
0FDD6:  MOVLW  3A
0FDD8:  MOVLB  8
0FDDA:  MOVWF  xDB
0FDDC:  MOVLB  0
0FDDE:  CALL   501C
0FDE2:  MOVFF  721,8C9
0FDE6:  MOVLW  01
0FDE8:  MOVLB  8
0FDEA:  MOVWF  xCA
0FDEC:  MOVLB  0
0FDEE:  CALL   51FE
0FDF2:  MOVLW  2C
0FDF4:  MOVLB  8
0FDF6:  MOVWF  xDB
0FDF8:  MOVLB  0
0FDFA:  CALL   501C
0FDFE:  MOVLW  04
0FE00:  MOVWF  FE9
0FE02:  MOVLB  8
0FE04:  CLRF   xCC
0FE06:  CLRF   xCB
0FE08:  MOVFF  8A4,8CA
0FE0C:  MOVFF  8A3,8C9
0FE10:  MOVLW  02
0FE12:  MOVWF  xCD
0FE14:  MOVLB  0
0FE16:  CALL   5298
0FE1A:  MOVLW  2C
0FE1C:  MOVLB  8
0FE1E:  MOVWF  xDB
0FE20:  MOVLB  0
0FE22:  CALL   501C
0FE26:  MOVFF  1E,FEA
0FE2A:  MOVFF  1D,FE9
0FE2E:  CLRF   FEF
0FE30:  MOVLW  03
0FE32:  MOVWF  FEA
0FE34:  MOVLW  39
0FE36:  MOVWF  FE9
0FE38:  RCALL  FB2E
0FE3A:  MOVLW  2C
0FE3C:  MOVLB  8
0FE3E:  MOVWF  xDB
0FE40:  MOVLB  0
0FE42:  CALL   501C
0FE46:  MOVFF  1E,FEA
0FE4A:  MOVFF  1D,FE9
0FE4E:  CLRF   FEF
0FE50:  MOVLW  03
0FE52:  MOVWF  FEA
0FE54:  MOVLW  3E
0FE56:  MOVWF  FE9
0FE58:  RCALL  FB2E
0FE5A:  MOVLW  2C
0FE5C:  MOVLB  8
0FE5E:  MOVWF  xDB
0FE60:  MOVLB  0
0FE62:  CALL   501C
0FE66:  MOVFF  1E,FEA
0FE6A:  MOVFF  1D,FE9
0FE6E:  CLRF   FEF
0FE70:  MOVLW  03
0FE72:  MOVWF  FEA
0FE74:  MOVLW  42
0FE76:  MOVWF  FE9
0FE78:  RCALL  FB2E
0FE7A:  MOVLW  2C
0FE7C:  MOVLB  8
0FE7E:  MOVWF  xDB
0FE80:  MOVLB  0
0FE82:  CALL   501C
0FE86:  MOVLW  10
0FE88:  MOVWF  FE9
0FE8A:  MOVFF  26,8D3
0FE8E:  MOVFF  25,8D2
0FE92:  CALL   AA40
0FE96:  MOVLW  2C
0FE98:  MOVLB  8
0FE9A:  MOVWF  xDB
0FE9C:  MOVLB  0
0FE9E:  CALL   501C
0FEA2:  MOVLW  10
0FEA4:  MOVWF  FE9
0FEA6:  MOVFF  8A6,8D3
0FEAA:  MOVFF  8A5,8D2
0FEAE:  CALL   AA40
0FEB2:  MOVLW  2C
0FEB4:  MOVLB  8
0FEB6:  MOVWF  xDB
0FEB8:  MOVLB  0
0FEBA:  CALL   501C
0FEBE:  MOVFF  4B1,8C9
0FEC2:  MOVLW  1B
0FEC4:  MOVLB  8
0FEC6:  MOVWF  xCA
0FEC8:  MOVLB  0
0FECA:  CALL   51FE
0FECE:  MOVLW  2C
0FED0:  MOVLB  8
0FED2:  MOVWF  xDB
0FED4:  MOVLB  0
0FED6:  CALL   501C
0FEDA:  MOVLW  10
0FEDC:  MOVWF  FE9
0FEDE:  MOVFF  4A4,8D3
0FEE2:  MOVFF  4A3,8D2
0FEE6:  CALL   AA40
0FEEA:  MOVLW  2C
0FEEC:  MOVLB  8
0FEEE:  MOVWF  xDB
0FEF0:  MOVLB  0
0FEF2:  CALL   501C
0FEF6:  MOVLW  10
0FEF8:  MOVWF  FE9
0FEFA:  MOVFF  4AA,8D3
0FEFE:  MOVFF  4A9,8D2
0FF02:  CALL   AA40
0FF06:  MOVLW  2C
0FF08:  MOVLB  8
0FF0A:  MOVWF  xDB
0FF0C:  MOVLB  0
0FF0E:  CALL   501C
0FF12:  MOVLW  10
0FF14:  MOVWF  FE9
0FF16:  MOVFF  4A8,8D3
0FF1A:  MOVFF  4A7,8D2
0FF1E:  CALL   AA40
0FF22:  MOVLW  0D
0FF24:  MOVLB  8
0FF26:  MOVWF  xDB
0FF28:  MOVLB  0
0FF2A:  CALL   501C
0FF2E:  MOVLW  0A
0FF30:  MOVLB  8
0FF32:  MOVWF  xDB
0FF34:  MOVLB  0
0FF36:  CALL   501C
....................  
....................    load_scanned_data();  
0FF3A:  BRA    FB8E
....................  
....................    display_rec(store, display); 
0FF3C:  MOVFF  8A0,8C7
0FF40:  MOVFF  8A1,8C8
0FF44:  RCALL  FC5C
....................     
....................    data_available = TRUE; 
0FF46:  MOVLW  01
0FF48:  MOVLB  3
0FF4A:  MOVWF  x37
....................    macro_flag = 900; 
0FF4C:  MOVLW  03
0FF4E:  MOVWF  x20
0FF50:  MOVLW  84
0FF52:  MOVWF  x1F
0FF54:  MOVLB  0
0FF56:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
*
10000:  MOVLB  8
10002:  CLRF   x67
10004:  CLRF   x66
....................    channel=channel-20000; 
10006:  MOVLW  20
10008:  SUBWF  x63,F
1000A:  MOVLW  4E
1000C:  SUBWFB x64,F
....................     
....................    for (i=0; i<9; i++){ 
1000E:  CLRF   x65
10010:  MOVF   x65,W
10012:  SUBLW  08
10014:  BTFSS  FD8.0
10016:  GOTO   100C2
....................       DAC_set(channel, setting); 
1001A:  MOVFF  863,8AF
1001E:  MOVFF  867,8B1
10022:  MOVFF  866,8B0
10026:  MOVLB  0
10028:  CALL   F278
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
1002C:  MOVLW  18
1002E:  MOVWF  FF6
10030:  MOVLW  1D
10032:  MOVWF  FF7
10034:  MOVLW  00
10036:  MOVWF  FF8
10038:  CLRF   1B
1003A:  BTFSC  FF2.7
1003C:  BSF    1B.7
1003E:  BCF    FF2.7
10040:  MOVLW  05
10042:  MOVLB  A
10044:  MOVWF  x18
10046:  MOVLB  0
10048:  CALL   1006
1004C:  BTFSC  1B.7
1004E:  BSF    FF2.7
10050:  MOVLW  10
10052:  MOVWF  FE9
10054:  CLRF   1B
10056:  BTFSC  FF2.7
10058:  BSF    1B.7
1005A:  BCF    FF2.7
1005C:  MOVFF  864,A19
10060:  MOVFF  863,A18
10064:  CALL   1188
10068:  BTFSC  1B.7
1006A:  BSF    FF2.7
1006C:  MOVLW  2C
1006E:  BTFSS  F9E.4
10070:  GOTO   1006E
10074:  MOVWF  FAD
10076:  MOVLW  10
10078:  MOVWF  FE9
1007A:  CLRF   1B
1007C:  BTFSC  FF2.7
1007E:  BSF    1B.7
10080:  BCF    FF2.7
10082:  MOVFF  867,A19
10086:  MOVFF  866,A18
1008A:  CALL   1188
1008E:  BTFSC  1B.7
10090:  BSF    FF2.7
10092:  MOVLW  2C
10094:  BTFSS  F9E.4
10096:  GOTO   10094
1009A:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1009C:  MOVLB  8
1009E:  CLRF   x9F
100A0:  MOVLW  C8
100A2:  MOVWF  x9E
100A4:  CLRF   xA0
100A6:  MOVLW  01
100A8:  MOVWF  xA1
100AA:  MOVWF  xA2
100AC:  MOVLB  0
100AE:  CALL   FCFA
....................       setting = setting+500; 
100B2:  MOVLW  F4
100B4:  MOVLB  8
100B6:  ADDWF  x66,F
100B8:  MOVLW  01
100BA:  ADDWFC x67,F
100BC:  INCF   x65,F
100BE:  GOTO   10010
....................    } 
100C2:  MOVLB  0
100C4:  GOTO   10194 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
*
0FF58:  MOVLB  8
0FF5A:  CLRF   x63
0FF5C:  CLRF   x62
....................     
....................    for (i=0; i<9; i++){ 
0FF5E:  CLRF   x61
0FF60:  MOVF   x61,W
0FF62:  SUBLW  08
0FF64:  BNC   FFDE
....................       LED_SAR(intensity); 
0FF66:  MOVFF  863,8A5
0FF6A:  MOVFF  862,8A4
0FF6E:  MOVLB  0
0FF70:  CALL   F51C
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
0FF74:  MOVLW  26
0FF76:  MOVWF  FF6
0FF78:  MOVLW  1D
0FF7A:  MOVWF  FF7
0FF7C:  MOVLW  00
0FF7E:  MOVWF  FF8
0FF80:  CLRF   1B
0FF82:  BTFSC  FF2.7
0FF84:  BSF    1B.7
0FF86:  BCF    FF2.7
0FF88:  MOVLW  07
0FF8A:  MOVLB  A
0FF8C:  MOVWF  x18
0FF8E:  MOVLB  0
0FF90:  CALL   1006
0FF94:  BTFSC  1B.7
0FF96:  BSF    FF2.7
0FF98:  MOVLW  10
0FF9A:  MOVWF  FE9
0FF9C:  CLRF   1B
0FF9E:  BTFSC  FF2.7
0FFA0:  BSF    1B.7
0FFA2:  BCF    FF2.7
0FFA4:  MOVFF  863,A19
0FFA8:  MOVFF  862,A18
0FFAC:  CALL   1188
0FFB0:  BTFSC  1B.7
0FFB2:  BSF    FF2.7
0FFB4:  MOVLW  2C
0FFB6:  BTFSS  F9E.4
0FFB8:  BRA    FFB6
0FFBA:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
0FFBC:  MOVLB  8
0FFBE:  CLRF   x9F
0FFC0:  MOVLW  C8
0FFC2:  MOVWF  x9E
0FFC4:  CLRF   xA0
0FFC6:  MOVLW  01
0FFC8:  MOVWF  xA1
0FFCA:  MOVWF  xA2
0FFCC:  MOVLB  0
0FFCE:  RCALL  FCFA
....................       intensity = intensity+500; 
0FFD0:  MOVLW  F4
0FFD2:  MOVLB  8
0FFD4:  ADDWF  x62,F
0FFD6:  MOVLW  01
0FFD8:  ADDWFC x63,F
0FFDA:  INCF   x61,F
0FFDC:  BRA    FF60
....................    } 
0FFDE:  MOVLB  0
0FFE0:  GOTO   10194 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
03038:  MOVLB  8
0303A:  CLRF   x92
0303C:  MOVF   x92,W
0303E:  SUBLW  20
03040:  BNC   3056
03042:  CLRF   03
03044:  MOVF   x92,W
03046:  ADDLW  B3
03048:  MOVWF  FE9
0304A:  MOVLW  04
0304C:  ADDWFC 03,W
0304E:  MOVWF  FEA
03050:  CLRF   FEF
03052:  INCF   x92,F
03054:  BRA    303C
03056:  MOVLB  0
03058:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
0305A:  MOVF   2F,W
0305C:  SUBLW  02
0305E:  BNZ   3068
03060:  MOVF   30,F
03062:  BNZ   3068
03064:  MOVLW  00
03066:  MOVWF  F99
....................    init_valve_status(); 
03068:  RCALL  3038
....................    bus_pwr_status=0; 
0306A:  MOVLB  4
0306C:  CLRF   xB2
0306E:  MOVLB  0
03070:  GOTO   1B14E (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0EA66:  MOVLW  32
0EA68:  MOVWF  FF6
0EA6A:  MOVLW  1D
0EA6C:  MOVWF  FF7
0EA6E:  MOVLW  00
0EA70:  MOVWF  FF8
0EA72:  CLRF   1B
0EA74:  BTFSC  FF2.7
0EA76:  BSF    1B.7
0EA78:  BCF    FF2.7
0EA7A:  CALL   0E30
0EA7E:  BTFSC  1B.7
0EA80:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EA82:  MOVLW  01
0EA84:  MOVLB  8
0EA86:  MOVWF  x92
0EA88:  MOVF   x92,W
0EA8A:  SUBLW  08
0EA8C:  BNC   EAF6
0EA8E:  CLRF   03
0EA90:  MOVF   x92,W
0EA92:  ADDLW  B3
0EA94:  MOVWF  FE9
0EA96:  MOVLW  04
0EA98:  ADDWFC 03,W
0EA9A:  MOVWF  FEA
0EA9C:  MOVFF  FEF,893
0EAA0:  CLRF   1B
0EAA2:  BTFSC  FF2.7
0EAA4:  BSF    1B.7
0EAA6:  BCF    FF2.7
0EAA8:  MOVFF  892,A18
0EAAC:  MOVLW  01
0EAAE:  MOVLB  A
0EAB0:  MOVWF  x19
0EAB2:  MOVLB  0
0EAB4:  CALL   0F88
0EAB8:  BTFSC  1B.7
0EABA:  BSF    FF2.7
0EABC:  MOVLW  5B
0EABE:  BTFSS  F9E.4
0EAC0:  BRA    EABE
0EAC2:  MOVWF  FAD
0EAC4:  CLRF   1B
0EAC6:  BTFSC  FF2.7
0EAC8:  BSF    1B.7
0EACA:  BCF    FF2.7
0EACC:  MOVFF  893,A18
0EAD0:  MOVLW  1B
0EAD2:  MOVLB  A
0EAD4:  MOVWF  x19
0EAD6:  MOVLB  0
0EAD8:  CALL   0F88
0EADC:  BTFSC  1B.7
0EADE:  BSF    FF2.7
0EAE0:  MOVLW  5D
0EAE2:  BTFSS  F9E.4
0EAE4:  BRA    EAE2
0EAE6:  MOVWF  FAD
0EAE8:  MOVLW  20
0EAEA:  BTFSS  F9E.4
0EAEC:  BRA    EAEA
0EAEE:  MOVWF  FAD
0EAF0:  MOVLB  8
0EAF2:  INCF   x92,F
0EAF4:  BRA    EA88
....................    fprintf(COM_A, "\r\n"); 
0EAF6:  MOVLW  0D
0EAF8:  BTFSS  F9E.4
0EAFA:  BRA    EAF8
0EAFC:  MOVWF  FAD
0EAFE:  MOVLW  0A
0EB00:  BTFSS  F9E.4
0EB02:  BRA    EB00
0EB04:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EB06:  MOVLW  38
0EB08:  MOVWF  FF6
0EB0A:  MOVLW  1D
0EB0C:  MOVWF  FF7
0EB0E:  MOVLW  00
0EB10:  MOVWF  FF8
0EB12:  CLRF   1B
0EB14:  BTFSC  FF2.7
0EB16:  BSF    1B.7
0EB18:  BCF    FF2.7
0EB1A:  MOVLB  0
0EB1C:  CALL   0E30
0EB20:  BTFSC  1B.7
0EB22:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EB24:  MOVLW  09
0EB26:  MOVLB  8
0EB28:  MOVWF  x92
0EB2A:  MOVF   x92,W
0EB2C:  SUBLW  10
0EB2E:  BNC   EB98
0EB30:  CLRF   03
0EB32:  MOVF   x92,W
0EB34:  ADDLW  B3
0EB36:  MOVWF  FE9
0EB38:  MOVLW  04
0EB3A:  ADDWFC 03,W
0EB3C:  MOVWF  FEA
0EB3E:  MOVFF  FEF,893
0EB42:  CLRF   1B
0EB44:  BTFSC  FF2.7
0EB46:  BSF    1B.7
0EB48:  BCF    FF2.7
0EB4A:  MOVFF  892,A18
0EB4E:  MOVLW  01
0EB50:  MOVLB  A
0EB52:  MOVWF  x19
0EB54:  MOVLB  0
0EB56:  CALL   0F88
0EB5A:  BTFSC  1B.7
0EB5C:  BSF    FF2.7
0EB5E:  MOVLW  5B
0EB60:  BTFSS  F9E.4
0EB62:  BRA    EB60
0EB64:  MOVWF  FAD
0EB66:  CLRF   1B
0EB68:  BTFSC  FF2.7
0EB6A:  BSF    1B.7
0EB6C:  BCF    FF2.7
0EB6E:  MOVFF  893,A18
0EB72:  MOVLW  1B
0EB74:  MOVLB  A
0EB76:  MOVWF  x19
0EB78:  MOVLB  0
0EB7A:  CALL   0F88
0EB7E:  BTFSC  1B.7
0EB80:  BSF    FF2.7
0EB82:  MOVLW  5D
0EB84:  BTFSS  F9E.4
0EB86:  BRA    EB84
0EB88:  MOVWF  FAD
0EB8A:  MOVLW  20
0EB8C:  BTFSS  F9E.4
0EB8E:  BRA    EB8C
0EB90:  MOVWF  FAD
0EB92:  MOVLB  8
0EB94:  INCF   x92,F
0EB96:  BRA    EB2A
....................    fprintf(COM_A, "\r\n"); 
0EB98:  MOVLW  0D
0EB9A:  BTFSS  F9E.4
0EB9C:  BRA    EB9A
0EB9E:  MOVWF  FAD
0EBA0:  MOVLW  0A
0EBA2:  BTFSS  F9E.4
0EBA4:  BRA    EBA2
0EBA6:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EBA8:  MOVLW  3E
0EBAA:  MOVWF  FF6
0EBAC:  MOVLW  1D
0EBAE:  MOVWF  FF7
0EBB0:  MOVLW  00
0EBB2:  MOVWF  FF8
0EBB4:  CLRF   1B
0EBB6:  BTFSC  FF2.7
0EBB8:  BSF    1B.7
0EBBA:  BCF    FF2.7
0EBBC:  MOVLB  0
0EBBE:  CALL   0E30
0EBC2:  BTFSC  1B.7
0EBC4:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EBC6:  MOVLW  11
0EBC8:  MOVLB  8
0EBCA:  MOVWF  x92
0EBCC:  MOVF   x92,W
0EBCE:  SUBLW  18
0EBD0:  BNC   EC3A
0EBD2:  CLRF   03
0EBD4:  MOVF   x92,W
0EBD6:  ADDLW  B3
0EBD8:  MOVWF  FE9
0EBDA:  MOVLW  04
0EBDC:  ADDWFC 03,W
0EBDE:  MOVWF  FEA
0EBE0:  MOVFF  FEF,893
0EBE4:  CLRF   1B
0EBE6:  BTFSC  FF2.7
0EBE8:  BSF    1B.7
0EBEA:  BCF    FF2.7
0EBEC:  MOVFF  892,A18
0EBF0:  MOVLW  01
0EBF2:  MOVLB  A
0EBF4:  MOVWF  x19
0EBF6:  MOVLB  0
0EBF8:  CALL   0F88
0EBFC:  BTFSC  1B.7
0EBFE:  BSF    FF2.7
0EC00:  MOVLW  5B
0EC02:  BTFSS  F9E.4
0EC04:  BRA    EC02
0EC06:  MOVWF  FAD
0EC08:  CLRF   1B
0EC0A:  BTFSC  FF2.7
0EC0C:  BSF    1B.7
0EC0E:  BCF    FF2.7
0EC10:  MOVFF  893,A18
0EC14:  MOVLW  1B
0EC16:  MOVLB  A
0EC18:  MOVWF  x19
0EC1A:  MOVLB  0
0EC1C:  CALL   0F88
0EC20:  BTFSC  1B.7
0EC22:  BSF    FF2.7
0EC24:  MOVLW  5D
0EC26:  BTFSS  F9E.4
0EC28:  BRA    EC26
0EC2A:  MOVWF  FAD
0EC2C:  MOVLW  20
0EC2E:  BTFSS  F9E.4
0EC30:  BRA    EC2E
0EC32:  MOVWF  FAD
0EC34:  MOVLB  8
0EC36:  INCF   x92,F
0EC38:  BRA    EBCC
....................    fprintf(COM_A, "\r\n"); 
0EC3A:  MOVLW  0D
0EC3C:  BTFSS  F9E.4
0EC3E:  BRA    EC3C
0EC40:  MOVWF  FAD
0EC42:  MOVLW  0A
0EC44:  BTFSS  F9E.4
0EC46:  BRA    EC44
0EC48:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EC4A:  MOVLW  44
0EC4C:  MOVWF  FF6
0EC4E:  MOVLW  1D
0EC50:  MOVWF  FF7
0EC52:  MOVLW  00
0EC54:  MOVWF  FF8
0EC56:  CLRF   1B
0EC58:  BTFSC  FF2.7
0EC5A:  BSF    1B.7
0EC5C:  BCF    FF2.7
0EC5E:  MOVLB  0
0EC60:  CALL   0E30
0EC64:  BTFSC  1B.7
0EC66:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EC68:  MOVLW  19
0EC6A:  MOVLB  8
0EC6C:  MOVWF  x92
0EC6E:  MOVF   x92,W
0EC70:  SUBLW  20
0EC72:  BNC   ECDC
0EC74:  CLRF   03
0EC76:  MOVF   x92,W
0EC78:  ADDLW  B3
0EC7A:  MOVWF  FE9
0EC7C:  MOVLW  04
0EC7E:  ADDWFC 03,W
0EC80:  MOVWF  FEA
0EC82:  MOVFF  FEF,893
0EC86:  CLRF   1B
0EC88:  BTFSC  FF2.7
0EC8A:  BSF    1B.7
0EC8C:  BCF    FF2.7
0EC8E:  MOVFF  892,A18
0EC92:  MOVLW  01
0EC94:  MOVLB  A
0EC96:  MOVWF  x19
0EC98:  MOVLB  0
0EC9A:  CALL   0F88
0EC9E:  BTFSC  1B.7
0ECA0:  BSF    FF2.7
0ECA2:  MOVLW  5B
0ECA4:  BTFSS  F9E.4
0ECA6:  BRA    ECA4
0ECA8:  MOVWF  FAD
0ECAA:  CLRF   1B
0ECAC:  BTFSC  FF2.7
0ECAE:  BSF    1B.7
0ECB0:  BCF    FF2.7
0ECB2:  MOVFF  893,A18
0ECB6:  MOVLW  1B
0ECB8:  MOVLB  A
0ECBA:  MOVWF  x19
0ECBC:  MOVLB  0
0ECBE:  CALL   0F88
0ECC2:  BTFSC  1B.7
0ECC4:  BSF    FF2.7
0ECC6:  MOVLW  5D
0ECC8:  BTFSS  F9E.4
0ECCA:  BRA    ECC8
0ECCC:  MOVWF  FAD
0ECCE:  MOVLW  20
0ECD0:  BTFSS  F9E.4
0ECD2:  BRA    ECD0
0ECD4:  MOVWF  FAD
0ECD6:  MOVLB  8
0ECD8:  INCF   x92,F
0ECDA:  BRA    EC6E
....................    fprintf(COM_A, "\r\n");    
0ECDC:  MOVLW  0D
0ECDE:  BTFSS  F9E.4
0ECE0:  BRA    ECDE
0ECE2:  MOVWF  FAD
0ECE4:  MOVLW  0A
0ECE6:  BTFSS  F9E.4
0ECE8:  BRA    ECE6
0ECEA:  MOVWF  FAD
0ECEC:  MOVLB  0
0ECEE:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
14014:  MOVF   1F,W
14016:  SUBLW  04
14018:  BNZ   14082
1401A:  MOVF   20,F
1401C:  BNZ   14082
1401E:  MOVLW  4A
14020:  MOVWF  FF6
14022:  MOVLW  1D
14024:  MOVWF  FF7
14026:  MOVLW  00
14028:  MOVWF  FF8
1402A:  CLRF   1B
1402C:  BTFSC  FF2.7
1402E:  BSF    1B.7
14030:  BCF    FF2.7
14032:  MOVLW  0C
14034:  MOVLB  A
14036:  MOVWF  x18
14038:  MOVLB  0
1403A:  CALL   1006
1403E:  BTFSC  1B.7
14040:  BSF    FF2.7
14042:  MOVLW  10
14044:  MOVWF  FE9
14046:  CLRF   1B
14048:  BTFSC  FF2.7
1404A:  BSF    1B.7
1404C:  BCF    FF2.7
1404E:  MOVFF  893,A19
14052:  MOVFF  892,A18
14056:  CALL   1188
1405A:  BTFSC  1B.7
1405C:  BSF    FF2.7
1405E:  MOVLW  59
14060:  MOVWF  FF6
14062:  MOVLW  1D
14064:  MOVWF  FF7
14066:  MOVLW  00
14068:  MOVWF  FF8
1406A:  CLRF   1B
1406C:  BTFSC  FF2.7
1406E:  BSF    1B.7
14070:  BCF    FF2.7
14072:  MOVLW  03
14074:  MOVLB  A
14076:  MOVWF  x18
14078:  MOVLB  0
1407A:  CALL   1006
1407E:  BTFSC  1B.7
14080:  BSF    FF2.7
....................  
....................    multidrop_on(); 
14082:  CALL   D77C
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
14086:  MOVLW  5E
14088:  MOVWF  FF6
1408A:  MOVLW  1D
1408C:  MOVWF  FF7
1408E:  MOVLW  00
14090:  MOVWF  FF8
14092:  MOVLW  03
14094:  MOVLB  8
14096:  MOVWF  x94
14098:  MOVLB  0
1409A:  CALL   D790
1409E:  MOVLW  10
140A0:  MOVWF  FE9
140A2:  MOVFF  893,895
140A6:  MOVFF  892,894
140AA:  BRA    13F5A
140AC:  MOVLW  0D
140AE:  BTFSS  FA4.4
140B0:  BRA    140AE
140B2:  MOVLB  F
140B4:  MOVWF  x1C
....................    multidrop_off(); 
140B6:  MOVLB  0
140B8:  CALL   D868
....................  
....................    delay_ms(100); 
140BC:  MOVLW  64
140BE:  MOVLB  9
140C0:  MOVWF  xC8
140C2:  MOVLB  0
140C4:  CALL   288E
140C8:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0D8BA:  MOVF   1F,W
0D8BC:  SUBLW  04
0D8BE:  BNZ   D928
0D8C0:  MOVF   20,F
0D8C2:  BNZ   D928
0D8C4:  MOVLW  66
0D8C6:  MOVWF  FF6
0D8C8:  MOVLW  1D
0D8CA:  MOVWF  FF7
0D8CC:  MOVLW  00
0D8CE:  MOVWF  FF8
0D8D0:  CLRF   1B
0D8D2:  BTFSC  FF2.7
0D8D4:  BSF    1B.7
0D8D6:  BCF    FF2.7
0D8D8:  MOVLW  0C
0D8DA:  MOVLB  A
0D8DC:  MOVWF  x18
0D8DE:  MOVLB  0
0D8E0:  CALL   1006
0D8E4:  BTFSC  1B.7
0D8E6:  BSF    FF2.7
0D8E8:  CLRF   1B
0D8EA:  BTFSC  FF2.7
0D8EC:  BSF    1B.7
0D8EE:  BCF    FF2.7
0D8F0:  MOVFF  892,A18
0D8F4:  MOVLW  1B
0D8F6:  MOVLB  A
0D8F8:  MOVWF  x19
0D8FA:  MOVLB  0
0D8FC:  CALL   0F88
0D900:  BTFSC  1B.7
0D902:  BSF    FF2.7
0D904:  MOVLW  74
0D906:  MOVWF  FF6
0D908:  MOVLW  1D
0D90A:  MOVWF  FF7
0D90C:  MOVLW  00
0D90E:  MOVWF  FF8
0D910:  CLRF   1B
0D912:  BTFSC  FF2.7
0D914:  BSF    1B.7
0D916:  BCF    FF2.7
0D918:  MOVLW  03
0D91A:  MOVLB  A
0D91C:  MOVWF  x18
0D91E:  MOVLB  0
0D920:  CALL   1006
0D924:  BTFSC  1B.7
0D926:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0D928:  RCALL  D77C
....................       fprintf(COM_B, "/1c%u\r",chip); 
0D92A:  MOVLW  78
0D92C:  MOVWF  FF6
0D92E:  MOVLW  1D
0D930:  MOVWF  FF7
0D932:  MOVLW  00
0D934:  MOVWF  FF8
0D936:  MOVLW  03
0D938:  MOVLB  8
0D93A:  MOVWF  x94
0D93C:  MOVLB  0
0D93E:  RCALL  D790
0D940:  MOVFF  892,8CF
0D944:  MOVLW  1B
0D946:  MOVLB  8
0D948:  MOVWF  xD0
0D94A:  MOVLB  0
0D94C:  RCALL  D7C4
0D94E:  MOVLW  0D
0D950:  BTFSS  FA4.4
0D952:  BRA    D950
0D954:  MOVLB  F
0D956:  MOVWF  x1C
....................    multidrop_off(); 
0D958:  MOVLB  0
0D95A:  RCALL  D868
....................    delay_ms(100); 
0D95C:  MOVLW  64
0D95E:  MOVLB  9
0D960:  MOVWF  xC8
0D962:  MOVLB  0
0D964:  CALL   288E
....................  
....................    multidrop_on(); 
0D968:  RCALL  D77C
....................      fprintf(COM_B, "/1s256\r"); 
0D96A:  MOVLW  80
0D96C:  MOVWF  FF6
0D96E:  MOVLW  1D
0D970:  MOVWF  FF7
0D972:  MOVLW  00
0D974:  MOVWF  FF8
0D976:  BRA    D88A
....................    multidrop_off();  
0D978:  RCALL  D868
....................    delay_ms(100); 
0D97A:  MOVLW  64
0D97C:  MOVLB  9
0D97E:  MOVWF  xC8
0D980:  MOVLB  0
0D982:  CALL   288E
0D986:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
140CA:  MOVLB  8
140CC:  MOVF   x91,W
140CE:  ADDLW  DF
140D0:  BTFSC  FD8.0
140D2:  BRA    144BE
140D4:  ADDLW  21
140D6:  MOVLB  0
140D8:  GOTO   144F0
....................       case 0 : sol_chip_cmd(1); 
140DC:  MOVLW  01
140DE:  MOVLB  8
140E0:  MOVWF  x92
140E2:  MOVLB  0
140E4:  CALL   D8BA
....................                sol_switch_cmd(0); 
140E8:  MOVLB  8
140EA:  CLRF   x93
140EC:  CLRF   x92
140EE:  MOVLB  0
140F0:  RCALL  14014
....................                sol_chip_cmd(2); 
140F2:  MOVLW  02
140F4:  MOVLB  8
140F6:  MOVWF  x92
140F8:  MOVLB  0
140FA:  CALL   D8BA
....................                sol_switch_cmd(0); 
140FE:  MOVLB  8
14100:  CLRF   x93
14102:  CLRF   x92
14104:  MOVLB  0
14106:  RCALL  14014
....................                sol_chip_cmd(3); 
14108:  MOVLW  03
1410A:  MOVLB  8
1410C:  MOVWF  x92
1410E:  MOVLB  0
14110:  CALL   D8BA
....................                sol_switch_cmd(0); 
14114:  MOVLB  8
14116:  CLRF   x93
14118:  CLRF   x92
1411A:  MOVLB  0
1411C:  RCALL  14014
....................                sol_chip_cmd(4); 
1411E:  MOVLW  04
14120:  MOVLB  8
14122:  MOVWF  x92
14124:  MOVLB  0
14126:  CALL   D8BA
....................                sol_switch_cmd(0); 
1412A:  MOVLB  8
1412C:  CLRF   x93
1412E:  CLRF   x92
14130:  MOVLB  0
14132:  RCALL  14014
....................                init_valve_status(); 
14134:  CALL   3038
....................          break; 
14138:  MOVLB  8
1413A:  BRA    144BE
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
1413C:  MOVLW  01
1413E:  MOVLB  8
14140:  MOVWF  x92
14142:  MOVLB  0
14144:  CALL   D8BA
....................                sol_switch_cmd(1); 
14148:  MOVLB  8
1414A:  CLRF   x93
1414C:  MOVLW  01
1414E:  MOVWF  x92
14150:  MOVLB  0
14152:  RCALL  14014
....................          break;     
14154:  MOVLB  8
14156:  BRA    144BE
....................       case 2 : sol_chip_cmd(1); 
14158:  MOVLW  01
1415A:  MOVLB  8
1415C:  MOVWF  x92
1415E:  MOVLB  0
14160:  CALL   D8BA
....................                sol_switch_cmd(2); 
14164:  MOVLB  8
14166:  CLRF   x93
14168:  MOVLW  02
1416A:  MOVWF  x92
1416C:  MOVLB  0
1416E:  RCALL  14014
....................          break;           
14170:  MOVLB  8
14172:  BRA    144BE
....................       case 3 : sol_chip_cmd(1); 
14174:  MOVLW  01
14176:  MOVLB  8
14178:  MOVWF  x92
1417A:  MOVLB  0
1417C:  CALL   D8BA
....................                sol_switch_cmd(4); 
14180:  MOVLB  8
14182:  CLRF   x93
14184:  MOVLW  04
14186:  MOVWF  x92
14188:  MOVLB  0
1418A:  RCALL  14014
....................          break;  
1418C:  MOVLB  8
1418E:  BRA    144BE
....................       case 4 : sol_chip_cmd(1); 
14190:  MOVLW  01
14192:  MOVLB  8
14194:  MOVWF  x92
14196:  MOVLB  0
14198:  CALL   D8BA
....................                sol_switch_cmd(8); 
1419C:  MOVLB  8
1419E:  CLRF   x93
141A0:  MOVLW  08
141A2:  MOVWF  x92
141A4:  MOVLB  0
141A6:  RCALL  14014
....................          break;  
141A8:  MOVLB  8
141AA:  BRA    144BE
....................       case 5 : sol_chip_cmd(1); 
141AC:  MOVLW  01
141AE:  MOVLB  8
141B0:  MOVWF  x92
141B2:  MOVLB  0
141B4:  CALL   D8BA
....................                sol_switch_cmd(16); 
141B8:  MOVLB  8
141BA:  CLRF   x93
141BC:  MOVLW  10
141BE:  MOVWF  x92
141C0:  MOVLB  0
141C2:  RCALL  14014
....................          break;  
141C4:  MOVLB  8
141C6:  BRA    144BE
....................       case 6 : sol_chip_cmd(1); 
141C8:  MOVLW  01
141CA:  MOVLB  8
141CC:  MOVWF  x92
141CE:  MOVLB  0
141D0:  CALL   D8BA
....................                sol_switch_cmd(32); 
141D4:  MOVLB  8
141D6:  CLRF   x93
141D8:  MOVLW  20
141DA:  MOVWF  x92
141DC:  MOVLB  0
141DE:  RCALL  14014
....................          break;  
141E0:  MOVLB  8
141E2:  BRA    144BE
....................       case 7 : sol_chip_cmd(1); 
141E4:  MOVLW  01
141E6:  MOVLB  8
141E8:  MOVWF  x92
141EA:  MOVLB  0
141EC:  CALL   D8BA
....................                sol_switch_cmd(64); 
141F0:  MOVLB  8
141F2:  CLRF   x93
141F4:  MOVLW  40
141F6:  MOVWF  x92
141F8:  MOVLB  0
141FA:  RCALL  14014
....................          break;  
141FC:  MOVLB  8
141FE:  BRA    144BE
....................       case 8 : sol_chip_cmd(1); 
14200:  MOVLW  01
14202:  MOVLB  8
14204:  MOVWF  x92
14206:  MOVLB  0
14208:  CALL   D8BA
....................                sol_switch_cmd(128); 
1420C:  MOVLB  8
1420E:  CLRF   x93
14210:  MOVLW  80
14212:  MOVWF  x92
14214:  MOVLB  0
14216:  RCALL  14014
....................          break;   
14218:  MOVLB  8
1421A:  BRA    144BE
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
1421C:  MOVLW  02
1421E:  MOVLB  8
14220:  MOVWF  x92
14222:  MOVLB  0
14224:  CALL   D8BA
....................                sol_switch_cmd(1); 
14228:  MOVLB  8
1422A:  CLRF   x93
1422C:  MOVLW  01
1422E:  MOVWF  x92
14230:  MOVLB  0
14232:  RCALL  14014
....................          break;     
14234:  MOVLB  8
14236:  BRA    144BE
....................       case 10 : sol_chip_cmd(2); 
14238:  MOVLW  02
1423A:  MOVLB  8
1423C:  MOVWF  x92
1423E:  MOVLB  0
14240:  CALL   D8BA
....................                sol_switch_cmd(2); 
14244:  MOVLB  8
14246:  CLRF   x93
14248:  MOVLW  02
1424A:  MOVWF  x92
1424C:  MOVLB  0
1424E:  RCALL  14014
....................          break;           
14250:  MOVLB  8
14252:  BRA    144BE
....................       case 11 : sol_chip_cmd(2); 
14254:  MOVLW  02
14256:  MOVLB  8
14258:  MOVWF  x92
1425A:  MOVLB  0
1425C:  CALL   D8BA
....................                sol_switch_cmd(4); 
14260:  MOVLB  8
14262:  CLRF   x93
14264:  MOVLW  04
14266:  MOVWF  x92
14268:  MOVLB  0
1426A:  RCALL  14014
....................          break;  
1426C:  MOVLB  8
1426E:  BRA    144BE
....................       case 12 : sol_chip_cmd(2); 
14270:  MOVLW  02
14272:  MOVLB  8
14274:  MOVWF  x92
14276:  MOVLB  0
14278:  CALL   D8BA
....................                sol_switch_cmd(8); 
1427C:  MOVLB  8
1427E:  CLRF   x93
14280:  MOVLW  08
14282:  MOVWF  x92
14284:  MOVLB  0
14286:  RCALL  14014
....................          break;  
14288:  MOVLB  8
1428A:  BRA    144BE
....................       case 13 : sol_chip_cmd(2); 
1428C:  MOVLW  02
1428E:  MOVLB  8
14290:  MOVWF  x92
14292:  MOVLB  0
14294:  CALL   D8BA
....................                sol_switch_cmd(16); 
14298:  MOVLB  8
1429A:  CLRF   x93
1429C:  MOVLW  10
1429E:  MOVWF  x92
142A0:  MOVLB  0
142A2:  RCALL  14014
....................          break;  
142A4:  MOVLB  8
142A6:  BRA    144BE
....................       case 14 : sol_chip_cmd(2); 
142A8:  MOVLW  02
142AA:  MOVLB  8
142AC:  MOVWF  x92
142AE:  MOVLB  0
142B0:  CALL   D8BA
....................                sol_switch_cmd(32); 
142B4:  MOVLB  8
142B6:  CLRF   x93
142B8:  MOVLW  20
142BA:  MOVWF  x92
142BC:  MOVLB  0
142BE:  RCALL  14014
....................          break;  
142C0:  MOVLB  8
142C2:  BRA    144BE
....................       case 15 : sol_chip_cmd(2); 
142C4:  MOVLW  02
142C6:  MOVLB  8
142C8:  MOVWF  x92
142CA:  MOVLB  0
142CC:  CALL   D8BA
....................                sol_switch_cmd(64); 
142D0:  MOVLB  8
142D2:  CLRF   x93
142D4:  MOVLW  40
142D6:  MOVWF  x92
142D8:  MOVLB  0
142DA:  RCALL  14014
....................          break;  
142DC:  MOVLB  8
142DE:  BRA    144BE
....................       case 16 : sol_chip_cmd(2); 
142E0:  MOVLW  02
142E2:  MOVLB  8
142E4:  MOVWF  x92
142E6:  MOVLB  0
142E8:  CALL   D8BA
....................                sol_switch_cmd(128); 
142EC:  MOVLB  8
142EE:  CLRF   x93
142F0:  MOVLW  80
142F2:  MOVWF  x92
142F4:  MOVLB  0
142F6:  RCALL  14014
....................          break;   
142F8:  MOVLB  8
142FA:  BRA    144BE
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
142FC:  MOVLW  03
142FE:  MOVLB  8
14300:  MOVWF  x92
14302:  MOVLB  0
14304:  CALL   D8BA
....................                sol_switch_cmd(1); 
14308:  MOVLB  8
1430A:  CLRF   x93
1430C:  MOVLW  01
1430E:  MOVWF  x92
14310:  MOVLB  0
14312:  RCALL  14014
....................          break;     
14314:  MOVLB  8
14316:  BRA    144BE
....................       case 18 : sol_chip_cmd(3); 
14318:  MOVLW  03
1431A:  MOVLB  8
1431C:  MOVWF  x92
1431E:  MOVLB  0
14320:  CALL   D8BA
....................                sol_switch_cmd(2); 
14324:  MOVLB  8
14326:  CLRF   x93
14328:  MOVLW  02
1432A:  MOVWF  x92
1432C:  MOVLB  0
1432E:  RCALL  14014
....................          break;           
14330:  MOVLB  8
14332:  BRA    144BE
....................       case 19 : sol_chip_cmd(3); 
14334:  MOVLW  03
14336:  MOVLB  8
14338:  MOVWF  x92
1433A:  MOVLB  0
1433C:  CALL   D8BA
....................                sol_switch_cmd(4); 
14340:  MOVLB  8
14342:  CLRF   x93
14344:  MOVLW  04
14346:  MOVWF  x92
14348:  MOVLB  0
1434A:  RCALL  14014
....................          break;  
1434C:  MOVLB  8
1434E:  BRA    144BE
....................       case 20 : sol_chip_cmd(3); 
14350:  MOVLW  03
14352:  MOVLB  8
14354:  MOVWF  x92
14356:  MOVLB  0
14358:  CALL   D8BA
....................                sol_switch_cmd(8); 
1435C:  MOVLB  8
1435E:  CLRF   x93
14360:  MOVLW  08
14362:  MOVWF  x92
14364:  MOVLB  0
14366:  RCALL  14014
....................          break;  
14368:  MOVLB  8
1436A:  BRA    144BE
....................       case 21 : sol_chip_cmd(3); 
1436C:  MOVLW  03
1436E:  MOVLB  8
14370:  MOVWF  x92
14372:  MOVLB  0
14374:  CALL   D8BA
....................                sol_switch_cmd(16); 
14378:  MOVLB  8
1437A:  CLRF   x93
1437C:  MOVLW  10
1437E:  MOVWF  x92
14380:  MOVLB  0
14382:  RCALL  14014
....................          break;  
14384:  MOVLB  8
14386:  BRA    144BE
....................       case 22 : sol_chip_cmd(3); 
14388:  MOVLW  03
1438A:  MOVLB  8
1438C:  MOVWF  x92
1438E:  MOVLB  0
14390:  CALL   D8BA
....................                sol_switch_cmd(32); 
14394:  MOVLB  8
14396:  CLRF   x93
14398:  MOVLW  20
1439A:  MOVWF  x92
1439C:  MOVLB  0
1439E:  RCALL  14014
....................          break;  
143A0:  MOVLB  8
143A2:  BRA    144BE
....................       case 23 : sol_chip_cmd(3); 
143A4:  MOVLW  03
143A6:  MOVLB  8
143A8:  MOVWF  x92
143AA:  MOVLB  0
143AC:  CALL   D8BA
....................                sol_switch_cmd(64); 
143B0:  MOVLB  8
143B2:  CLRF   x93
143B4:  MOVLW  40
143B6:  MOVWF  x92
143B8:  MOVLB  0
143BA:  RCALL  14014
....................          break;  
143BC:  MOVLB  8
143BE:  BRA    144BE
....................       case 24 : sol_chip_cmd(3); 
143C0:  MOVLW  03
143C2:  MOVLB  8
143C4:  MOVWF  x92
143C6:  MOVLB  0
143C8:  CALL   D8BA
....................                sol_switch_cmd(128); 
143CC:  MOVLB  8
143CE:  CLRF   x93
143D0:  MOVLW  80
143D2:  MOVWF  x92
143D4:  MOVLB  0
143D6:  RCALL  14014
....................          break;      
143D8:  MOVLB  8
143DA:  BRA    144BE
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
143DC:  MOVLW  04
143DE:  MOVLB  8
143E0:  MOVWF  x92
143E2:  MOVLB  0
143E4:  CALL   D8BA
....................                sol_switch_cmd(1); 
143E8:  MOVLB  8
143EA:  CLRF   x93
143EC:  MOVLW  01
143EE:  MOVWF  x92
143F0:  MOVLB  0
143F2:  RCALL  14014
....................          break;     
143F4:  MOVLB  8
143F6:  BRA    144BE
....................       case 26 : sol_chip_cmd(4); 
143F8:  MOVLW  04
143FA:  MOVLB  8
143FC:  MOVWF  x92
143FE:  MOVLB  0
14400:  CALL   D8BA
....................                sol_switch_cmd(2); 
14404:  MOVLB  8
14406:  CLRF   x93
14408:  MOVLW  02
1440A:  MOVWF  x92
1440C:  MOVLB  0
1440E:  RCALL  14014
....................          break;           
14410:  MOVLB  8
14412:  BRA    144BE
....................       case 27 : sol_chip_cmd(4); 
14414:  MOVLW  04
14416:  MOVLB  8
14418:  MOVWF  x92
1441A:  MOVLB  0
1441C:  CALL   D8BA
....................                sol_switch_cmd(4); 
14420:  MOVLB  8
14422:  CLRF   x93
14424:  MOVLW  04
14426:  MOVWF  x92
14428:  MOVLB  0
1442A:  RCALL  14014
....................          break;  
1442C:  MOVLB  8
1442E:  BRA    144BE
....................       case 28 : sol_chip_cmd(4); 
14430:  MOVLW  04
14432:  MOVLB  8
14434:  MOVWF  x92
14436:  MOVLB  0
14438:  CALL   D8BA
....................                sol_switch_cmd(8); 
1443C:  MOVLB  8
1443E:  CLRF   x93
14440:  MOVLW  08
14442:  MOVWF  x92
14444:  MOVLB  0
14446:  RCALL  14014
....................          break;  
14448:  MOVLB  8
1444A:  BRA    144BE
....................       case 29 : sol_chip_cmd(4); 
1444C:  MOVLW  04
1444E:  MOVLB  8
14450:  MOVWF  x92
14452:  MOVLB  0
14454:  CALL   D8BA
....................                sol_switch_cmd(16); 
14458:  MOVLB  8
1445A:  CLRF   x93
1445C:  MOVLW  10
1445E:  MOVWF  x92
14460:  MOVLB  0
14462:  RCALL  14014
....................          break;  
14464:  MOVLB  8
14466:  BRA    144BE
....................       case 30 : sol_chip_cmd(4); 
14468:  MOVLW  04
1446A:  MOVLB  8
1446C:  MOVWF  x92
1446E:  MOVLB  0
14470:  CALL   D8BA
....................                sol_switch_cmd(32); 
14474:  MOVLB  8
14476:  CLRF   x93
14478:  MOVLW  20
1447A:  MOVWF  x92
1447C:  MOVLB  0
1447E:  RCALL  14014
....................          break;  
14480:  MOVLB  8
14482:  BRA    144BE
....................       case 31 : sol_chip_cmd(4); 
14484:  MOVLW  04
14486:  MOVLB  8
14488:  MOVWF  x92
1448A:  MOVLB  0
1448C:  CALL   D8BA
....................                sol_switch_cmd(64); 
14490:  MOVLB  8
14492:  CLRF   x93
14494:  MOVLW  40
14496:  MOVWF  x92
14498:  MOVLB  0
1449A:  RCALL  14014
....................          break;  
1449C:  MOVLB  8
1449E:  BRA    144BE
....................       case 32 : sol_chip_cmd(4); 
144A0:  MOVLW  04
144A2:  MOVLB  8
144A4:  MOVWF  x92
144A6:  MOVLB  0
144A8:  CALL   D8BA
....................                sol_switch_cmd(128); 
144AC:  MOVLB  8
144AE:  CLRF   x93
144B0:  MOVLW  80
144B2:  MOVWF  x92
144B4:  MOVLB  0
144B6:  RCALL  14014
....................          break; 
144B8:  MOVLB  8
144BA:  BRA    144BE
144BC:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
144BE:  MOVF   x91,F
144C0:  BZ    144DA
144C2:  MOVF   x91,W
144C4:  SUBLW  20
144C6:  BNC   144DA
144C8:  CLRF   03
144CA:  MOVF   x91,W
144CC:  ADDLW  B3
144CE:  MOVWF  FE9
144D0:  MOVLW  04
144D2:  ADDWFC 03,W
144D4:  MOVWF  FEA
144D6:  MOVLW  01
144D8:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
144DA:  MOVF   1F,W
144DC:  SUBLW  04
144DE:  BNZ   144EC
144E0:  MOVF   20,F
144E2:  BNZ   144EC
144E4:  MOVLB  0
144E6:  CALL   EA66
144EA:  MOVLB  8
144EC:  MOVLB  0
144EE:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
10202:  MOVLB  8
10204:  CLRF   x79
10206:  MOVF   x79,W
10208:  SUBLW  07
1020A:  BNC   10226
1020C:  BCF    FD8.0
1020E:  RLCF   x79,W
10210:  CLRF   03
10212:  ADDLW  47
10214:  MOVWF  FE9
10216:  MOVLW  03
10218:  ADDWFC 03,W
1021A:  MOVWF  FEA
1021C:  CLRF   FEC
1021E:  MOVF   FED,F
10220:  CLRF   FEF
10222:  INCF   x79,F
10224:  BRA    10206
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
10226:  CLRF   x79
10228:  MOVF   x79,W
1022A:  SUBLW  07
1022C:  BNC   10248
1022E:  BCF    FD8.0
10230:  RLCF   x79,W
10232:  CLRF   03
10234:  ADDLW  59
10236:  MOVWF  FE9
10238:  MOVLW  03
1023A:  ADDWFC 03,W
1023C:  MOVWF  FEA
1023E:  CLRF   FEC
10240:  MOVF   FED,F
10242:  CLRF   FEF
10244:  INCF   x79,F
10246:  BRA    10228
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
10248:  CLRF   x79
1024A:  MOVF   x79,W
1024C:  SUBLW  07
1024E:  BNC   1026A
10250:  BCF    FD8.0
10252:  RLCF   x79,W
10254:  CLRF   03
10256:  ADDLW  6B
10258:  MOVWF  FE9
1025A:  MOVLW  03
1025C:  ADDWFC 03,W
1025E:  MOVWF  FEA
10260:  CLRF   FEC
10262:  MOVF   FED,F
10264:  CLRF   FEF
10266:  INCF   x79,F
10268:  BRA    1024A
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
1026A:  CLRF   x79
1026C:  MOVF   x79,W
1026E:  SUBLW  07
10270:  BNC   1028C
10272:  BCF    FD8.0
10274:  RLCF   x79,W
10276:  CLRF   03
10278:  ADDLW  7D
1027A:  MOVWF  FE9
1027C:  MOVLW  03
1027E:  ADDWFC 03,W
10280:  MOVWF  FEA
10282:  CLRF   FEC
10284:  MOVF   FED,F
10286:  CLRF   FEF
10288:  INCF   x79,F
1028A:  BRA    1026C
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
1028C:  CLRF   x79
1028E:  MOVF   x79,W
10290:  SUBLW  07
10292:  BNC   102AE
10294:  BCF    FD8.0
10296:  RLCF   x79,W
10298:  CLRF   03
1029A:  ADDLW  8F
1029C:  MOVWF  FE9
1029E:  MOVLW  03
102A0:  ADDWFC 03,W
102A2:  MOVWF  FEA
102A4:  CLRF   FEC
102A6:  MOVF   FED,F
102A8:  CLRF   FEF
102AA:  INCF   x79,F
102AC:  BRA    1028E
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
102AE:  MOVLW  04
102B0:  MOVWF  FEA
102B2:  MOVLW  21
102B4:  MOVWF  FE9
102B6:  CLRF   00
102B8:  CLRF   02
102BA:  MOVLW  44
102BC:  MOVWF  01
102BE:  MOVLB  0
102C0:  CALL   34A4
102C4:  GOTO   14F10 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10B38:  MOVLB  8
10B3A:  CLRF   x9E
10B3C:  MOVF   x9E,W
10B3E:  SUBLW  03
10B40:  BNC   10B60
10B42:  MOVF   x9E,W
10B44:  MULLW  04
10B46:  MOVF   FF3,W
10B48:  CLRF   03
10B4A:  ADDLW  A1
10B4C:  MOVWF  FE9
10B4E:  MOVLW  03
10B50:  ADDWFC 03,W
10B52:  MOVWF  FEA
10B54:  CLRF   FEF
10B56:  CLRF   FEC
10B58:  CLRF   FEC
10B5A:  CLRF   FEC
10B5C:  INCF   x9E,F
10B5E:  BRA    10B3C
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10B60:  MOVLB  3
10B62:  MOVF   x47,F
10B64:  BTFSS  FD8.2
10B66:  BRA    10B6C
10B68:  MOVF   x48,F
10B6A:  BZ    10C06
10B6C:  MOVF   x49,F
10B6E:  BNZ   10B74
10B70:  MOVF   x4A,F
10B72:  BZ    10C06
....................       blank = NO3_array[0]; 
10B74:  MOVFF  348,8F4
10B78:  MOVFF  347,8F3
10B7C:  MOVLB  0
10B7E:  CALL   C622
10B82:  MOVFF  03,8A2
10B86:  MOVFF  02,8A1
10B8A:  MOVFF  01,8A0
10B8E:  MOVFF  00,89F
....................       react = NO3_array[1]; 
10B92:  MOVFF  34A,8F4
10B96:  MOVFF  349,8F3
10B9A:  CALL   C622
10B9E:  MOVFF  03,8A6
10BA2:  MOVFF  02,8A5
10BA6:  MOVFF  01,8A4
10BAA:  MOVFF  00,8A3
....................       ratio = blank / react; 
10BAE:  MOVFF  8A2,8DA
10BB2:  MOVFF  8A1,8D9
10BB6:  MOVFF  8A0,8D8
10BBA:  MOVFF  89F,8D7
10BBE:  MOVFF  8A6,8DE
10BC2:  MOVFF  8A5,8DD
10BC6:  MOVFF  8A4,8DC
10BCA:  MOVFF  8A3,8DB
10BCE:  CALL   C658
10BD2:  MOVFF  03,8AA
10BD6:  MOVFF  02,8A9
10BDA:  MOVFF  01,8A8
10BDE:  MOVFF  00,8A7
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10BE2:  MOVFF  8AA,8AE
10BE6:  MOVFF  8A9,8AD
10BEA:  MOVFF  8A8,8AC
10BEE:  MOVFF  8A7,8AB
10BF2:  RCALL  108BA
10BF4:  MOVFF  03,3A4
10BF8:  MOVFF  02,3A3
10BFC:  MOVFF  01,3A2
10C00:  MOVFF  00,3A1
10C04:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10C06:  MOVF   x4B,F
10C08:  BNZ   10C0E
10C0A:  MOVF   x4C,F
10C0C:  BZ    10CA8
10C0E:  MOVF   x4D,F
10C10:  BNZ   10C16
10C12:  MOVF   x4E,F
10C14:  BZ    10CA8
....................       blank = NO3_array[2]; 
10C16:  MOVFF  34C,8F4
10C1A:  MOVFF  34B,8F3
10C1E:  MOVLB  0
10C20:  CALL   C622
10C24:  MOVFF  03,8A2
10C28:  MOVFF  02,8A1
10C2C:  MOVFF  01,8A0
10C30:  MOVFF  00,89F
....................       react = NO3_array[3]; 
10C34:  MOVFF  34E,8F4
10C38:  MOVFF  34D,8F3
10C3C:  CALL   C622
10C40:  MOVFF  03,8A6
10C44:  MOVFF  02,8A5
10C48:  MOVFF  01,8A4
10C4C:  MOVFF  00,8A3
....................       ratio = blank / react;    
10C50:  MOVFF  8A2,8DA
10C54:  MOVFF  8A1,8D9
10C58:  MOVFF  8A0,8D8
10C5C:  MOVFF  89F,8D7
10C60:  MOVFF  8A6,8DE
10C64:  MOVFF  8A5,8DD
10C68:  MOVFF  8A4,8DC
10C6C:  MOVFF  8A3,8DB
10C70:  CALL   C658
10C74:  MOVFF  03,8AA
10C78:  MOVFF  02,8A9
10C7C:  MOVFF  01,8A8
10C80:  MOVFF  00,8A7
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10C84:  MOVFF  8AA,8AE
10C88:  MOVFF  8A9,8AD
10C8C:  MOVFF  8A8,8AC
10C90:  MOVFF  8A7,8AB
10C94:  RCALL  108BA
10C96:  MOVFF  03,3A8
10C9A:  MOVFF  02,3A7
10C9E:  MOVFF  01,3A6
10CA2:  MOVFF  00,3A5
10CA6:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10CA8:  MOVF   x4F,F
10CAA:  BNZ   10CB0
10CAC:  MOVF   x50,F
10CAE:  BZ    10D4A
10CB0:  MOVF   x51,F
10CB2:  BNZ   10CB8
10CB4:  MOVF   x52,F
10CB6:  BZ    10D4A
....................       blank = NO3_array[4]; 
10CB8:  MOVFF  350,8F4
10CBC:  MOVFF  34F,8F3
10CC0:  MOVLB  0
10CC2:  CALL   C622
10CC6:  MOVFF  03,8A2
10CCA:  MOVFF  02,8A1
10CCE:  MOVFF  01,8A0
10CD2:  MOVFF  00,89F
....................       react = NO3_array[5]; 
10CD6:  MOVFF  352,8F4
10CDA:  MOVFF  351,8F3
10CDE:  CALL   C622
10CE2:  MOVFF  03,8A6
10CE6:  MOVFF  02,8A5
10CEA:  MOVFF  01,8A4
10CEE:  MOVFF  00,8A3
....................       ratio = blank / react; 
10CF2:  MOVFF  8A2,8DA
10CF6:  MOVFF  8A1,8D9
10CFA:  MOVFF  8A0,8D8
10CFE:  MOVFF  89F,8D7
10D02:  MOVFF  8A6,8DE
10D06:  MOVFF  8A5,8DD
10D0A:  MOVFF  8A4,8DC
10D0E:  MOVFF  8A3,8DB
10D12:  CALL   C658
10D16:  MOVFF  03,8AA
10D1A:  MOVFF  02,8A9
10D1E:  MOVFF  01,8A8
10D22:  MOVFF  00,8A7
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
10D26:  MOVFF  8AA,8AE
10D2A:  MOVFF  8A9,8AD
10D2E:  MOVFF  8A8,8AC
10D32:  MOVFF  8A7,8AB
10D36:  RCALL  108BA
10D38:  MOVFF  03,3AC
10D3C:  MOVFF  02,3AB
10D40:  MOVFF  01,3AA
10D44:  MOVFF  00,3A9
10D48:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
10D4A:  MOVF   x53,F
10D4C:  BNZ   10D52
10D4E:  MOVF   x54,F
10D50:  BZ    10DEC
10D52:  MOVF   x55,F
10D54:  BNZ   10D5A
10D56:  MOVF   x56,F
10D58:  BZ    10DEC
....................       blank = NO3_array[6]; 
10D5A:  MOVFF  354,8F4
10D5E:  MOVFF  353,8F3
10D62:  MOVLB  0
10D64:  CALL   C622
10D68:  MOVFF  03,8A2
10D6C:  MOVFF  02,8A1
10D70:  MOVFF  01,8A0
10D74:  MOVFF  00,89F
....................       react = NO3_array[7]; 
10D78:  MOVFF  356,8F4
10D7C:  MOVFF  355,8F3
10D80:  CALL   C622
10D84:  MOVFF  03,8A6
10D88:  MOVFF  02,8A5
10D8C:  MOVFF  01,8A4
10D90:  MOVFF  00,8A3
....................       ratio = blank / react; 
10D94:  MOVFF  8A2,8DA
10D98:  MOVFF  8A1,8D9
10D9C:  MOVFF  8A0,8D8
10DA0:  MOVFF  89F,8D7
10DA4:  MOVFF  8A6,8DE
10DA8:  MOVFF  8A5,8DD
10DAC:  MOVFF  8A4,8DC
10DB0:  MOVFF  8A3,8DB
10DB4:  CALL   C658
10DB8:  MOVFF  03,8AA
10DBC:  MOVFF  02,8A9
10DC0:  MOVFF  01,8A8
10DC4:  MOVFF  00,8A7
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
10DC8:  MOVFF  8AA,8AE
10DCC:  MOVFF  8A9,8AD
10DD0:  MOVFF  8A8,8AC
10DD4:  MOVFF  8A7,8AB
10DD8:  RCALL  108BA
10DDA:  MOVFF  03,3B0
10DDE:  MOVFF  02,3AF
10DE2:  MOVFF  01,3AE
10DE6:  MOVFF  00,3AD
10DEA:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
10DEC:  MOVLW  04
10DEE:  MOVWF  1E
10DF0:  MOVLW  21
10DF2:  MOVWF  1D
10DF4:  MOVLW  88
10DF6:  MOVWF  FF6
10DF8:  MOVLW  1D
10DFA:  MOVWF  FF7
10DFC:  MOVLW  00
10DFE:  MOVWF  FF8
10E00:  MOVLW  06
10E02:  MOVLB  8
10E04:  MOVWF  xC7
10E06:  MOVLB  0
10E08:  CALL   AA0E
10E0C:  MOVLW  10
10E0E:  MOVWF  FE9
10E10:  MOVFF  348,8D3
10E14:  MOVFF  347,8D2
10E18:  CALL   AA40
10E1C:  MOVLW  91
10E1E:  MOVWF  FF6
10E20:  MOVLW  1D
10E22:  MOVWF  FF7
10E24:  MOVLW  00
10E26:  MOVWF  FF8
10E28:  MOVLW  07
10E2A:  MOVLB  8
10E2C:  MOVWF  xC7
10E2E:  MOVLB  0
10E30:  CALL   AA0E
10E34:  MOVLW  10
10E36:  MOVWF  FE9
10E38:  MOVFF  34A,8D3
10E3C:  MOVFF  349,8D2
10E40:  CALL   AA40
10E44:  MOVLW  9B
10E46:  MOVWF  FF6
10E48:  MOVLW  1D
10E4A:  MOVWF  FF7
10E4C:  MOVLW  00
10E4E:  MOVWF  FF8
10E50:  MOVLW  09
10E52:  MOVLB  8
10E54:  MOVWF  xC7
10E56:  MOVLB  0
10E58:  CALL   AA0E
10E5C:  MOVLW  89
10E5E:  MOVWF  FE9
10E60:  MOVFF  3A4,8AE
10E64:  MOVFF  3A3,8AD
10E68:  MOVFF  3A2,8AC
10E6C:  MOVFF  3A1,8AB
10E70:  MOVLW  04
10E72:  MOVLB  8
10E74:  MOVWF  xAF
10E76:  MOVLB  0
10E78:  RCALL  10926
10E7A:  MOVLW  A9
10E7C:  MOVWF  FF6
10E7E:  MOVLW  1D
10E80:  MOVWF  FF7
10E82:  MOVLW  00
10E84:  MOVWF  FF8
10E86:  MOVLW  07
10E88:  MOVLB  8
10E8A:  MOVWF  xC7
10E8C:  MOVLB  0
10E8E:  CALL   AA0E
10E92:  MOVLW  10
10E94:  MOVWF  FE9
10E96:  MOVFF  34C,8D3
10E9A:  MOVFF  34B,8D2
10E9E:  CALL   AA40
10EA2:  MOVLW  B3
10EA4:  MOVWF  FF6
10EA6:  MOVLW  1D
10EA8:  MOVWF  FF7
10EAA:  MOVLW  00
10EAC:  MOVWF  FF8
10EAE:  MOVLW  07
10EB0:  MOVLB  8
10EB2:  MOVWF  xC7
10EB4:  MOVLB  0
10EB6:  CALL   AA0E
10EBA:  MOVLW  10
10EBC:  MOVWF  FE9
10EBE:  MOVFF  34E,8D3
10EC2:  MOVFF  34D,8D2
10EC6:  CALL   AA40
10ECA:  MOVLW  BD
10ECC:  MOVWF  FF6
10ECE:  MOVLW  1D
10ED0:  MOVWF  FF7
10ED2:  MOVLW  00
10ED4:  MOVWF  FF8
10ED6:  MOVLW  09
10ED8:  MOVLB  8
10EDA:  MOVWF  xC7
10EDC:  MOVLB  0
10EDE:  CALL   AA0E
10EE2:  MOVLW  89
10EE4:  MOVWF  FE9
10EE6:  MOVFF  3A8,8AE
10EEA:  MOVFF  3A7,8AD
10EEE:  MOVFF  3A6,8AC
10EF2:  MOVFF  3A5,8AB
10EF6:  MOVLW  04
10EF8:  MOVLB  8
10EFA:  MOVWF  xAF
10EFC:  MOVLB  0
10EFE:  RCALL  10926
10F00:  MOVLW  CB
10F02:  MOVWF  FF6
10F04:  MOVLW  1D
10F06:  MOVWF  FF7
10F08:  MOVLW  00
10F0A:  MOVWF  FF8
10F0C:  MOVLW  07
10F0E:  MOVLB  8
10F10:  MOVWF  xC7
10F12:  MOVLB  0
10F14:  CALL   AA0E
10F18:  MOVLW  10
10F1A:  MOVWF  FE9
10F1C:  MOVFF  350,8D3
10F20:  MOVFF  34F,8D2
10F24:  CALL   AA40
10F28:  MOVLW  D5
10F2A:  MOVWF  FF6
10F2C:  MOVLW  1D
10F2E:  MOVWF  FF7
10F30:  MOVLW  00
10F32:  MOVWF  FF8
10F34:  MOVLW  07
10F36:  MOVLB  8
10F38:  MOVWF  xC7
10F3A:  MOVLB  0
10F3C:  CALL   AA0E
10F40:  MOVLW  10
10F42:  MOVWF  FE9
10F44:  MOVFF  352,8D3
10F48:  MOVFF  351,8D2
10F4C:  CALL   AA40
10F50:  MOVLW  DF
10F52:  MOVWF  FF6
10F54:  MOVLW  1D
10F56:  MOVWF  FF7
10F58:  MOVLW  00
10F5A:  MOVWF  FF8
10F5C:  MOVLW  09
10F5E:  MOVLB  8
10F60:  MOVWF  xC7
10F62:  MOVLB  0
10F64:  CALL   AA0E
10F68:  MOVLW  89
10F6A:  MOVWF  FE9
10F6C:  MOVFF  3AC,8AE
10F70:  MOVFF  3AB,8AD
10F74:  MOVFF  3AA,8AC
10F78:  MOVFF  3A9,8AB
10F7C:  MOVLW  04
10F7E:  MOVLB  8
10F80:  MOVWF  xAF
10F82:  MOVLB  0
10F84:  RCALL  10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
10F86:  MOVF   1F,W
10F88:  SUBLW  02
10F8A:  BNZ   10F90
10F8C:  MOVF   20,F
10F8E:  BZ    10FD0
10F90:  MOVLW  EE
10F92:  MOVWF  FF6
10F94:  MOVLW  1D
10F96:  MOVWF  FF7
10F98:  MOVLW  00
10F9A:  MOVWF  FF8
10F9C:  CLRF   1B
10F9E:  BTFSC  FF2.7
10FA0:  BSF    1B.7
10FA2:  BCF    FF2.7
10FA4:  MOVLW  09
10FA6:  MOVLB  A
10FA8:  MOVWF  x18
10FAA:  MOVLB  0
10FAC:  CALL   1006
10FB0:  BTFSC  1B.7
10FB2:  BSF    FF2.7
10FB4:  MOVLW  04
10FB6:  MOVWF  FEA
10FB8:  MOVLW  21
10FBA:  MOVWF  FE9
10FBC:  CALL   78E6
10FC0:  MOVLW  0D
10FC2:  BTFSS  F9E.4
10FC4:  BRA    10FC2
10FC6:  MOVWF  FAD
10FC8:  MOVLW  0A
10FCA:  BTFSS  F9E.4
10FCC:  BRA    10FCA
10FCE:  MOVWF  FAD
10FD0:  GOTO   122DC (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
10FD4:  MOVLB  8
10FD6:  CLRF   x9E
10FD8:  MOVF   x9E,W
10FDA:  SUBLW  03
10FDC:  BNC   10FFC
10FDE:  MOVF   x9E,W
10FE0:  MULLW  04
10FE2:  MOVF   FF3,W
10FE4:  CLRF   03
10FE6:  ADDLW  B1
10FE8:  MOVWF  FE9
10FEA:  MOVLW  03
10FEC:  ADDWFC 03,W
10FEE:  MOVWF  FEA
10FF0:  CLRF   FEF
10FF2:  CLRF   FEC
10FF4:  CLRF   FEC
10FF6:  CLRF   FEC
10FF8:  INCF   x9E,F
10FFA:  BRA    10FD8
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
10FFC:  MOVLB  3
10FFE:  MOVF   x59,F
11000:  BTFSS  FD8.2
11002:  BRA    11008
11004:  MOVF   x5A,F
11006:  BZ    110A2
11008:  MOVF   x5B,F
1100A:  BNZ   11010
1100C:  MOVF   x5C,F
1100E:  BZ    110A2
....................       blank = NO2_array[0]; 
11010:  MOVFF  35A,8F4
11014:  MOVFF  359,8F3
11018:  MOVLB  0
1101A:  CALL   C622
1101E:  MOVFF  03,8A2
11022:  MOVFF  02,8A1
11026:  MOVFF  01,8A0
1102A:  MOVFF  00,89F
....................       react = NO2_array[1]; 
1102E:  MOVFF  35C,8F4
11032:  MOVFF  35B,8F3
11036:  CALL   C622
1103A:  MOVFF  03,8A6
1103E:  MOVFF  02,8A5
11042:  MOVFF  01,8A4
11046:  MOVFF  00,8A3
....................       ratio = blank / react; 
1104A:  MOVFF  8A2,8DA
1104E:  MOVFF  8A1,8D9
11052:  MOVFF  8A0,8D8
11056:  MOVFF  89F,8D7
1105A:  MOVFF  8A6,8DE
1105E:  MOVFF  8A5,8DD
11062:  MOVFF  8A4,8DC
11066:  MOVFF  8A3,8DB
1106A:  CALL   C658
1106E:  MOVFF  03,8AA
11072:  MOVFF  02,8A9
11076:  MOVFF  01,8A8
1107A:  MOVFF  00,8A7
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
1107E:  MOVFF  8AA,8AE
11082:  MOVFF  8A9,8AD
11086:  MOVFF  8A8,8AC
1108A:  MOVFF  8A7,8AB
1108E:  RCALL  108BA
11090:  MOVFF  03,3B4
11094:  MOVFF  02,3B3
11098:  MOVFF  01,3B2
1109C:  MOVFF  00,3B1
110A0:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
110A2:  MOVF   x5D,F
110A4:  BNZ   110AA
110A6:  MOVF   x5E,F
110A8:  BZ    11146
110AA:  MOVF   x5F,F
110AC:  BNZ   110B2
110AE:  MOVF   x60,F
110B0:  BZ    11146
....................       blank = NO2_array[2]; 
110B2:  MOVFF  35E,8F4
110B6:  MOVFF  35D,8F3
110BA:  MOVLB  0
110BC:  CALL   C622
110C0:  MOVFF  03,8A2
110C4:  MOVFF  02,8A1
110C8:  MOVFF  01,8A0
110CC:  MOVFF  00,89F
....................       react = NO2_array[3]; 
110D0:  MOVFF  360,8F4
110D4:  MOVFF  35F,8F3
110D8:  CALL   C622
110DC:  MOVFF  03,8A6
110E0:  MOVFF  02,8A5
110E4:  MOVFF  01,8A4
110E8:  MOVFF  00,8A3
....................       ratio = blank / react;    
110EC:  MOVFF  8A2,8DA
110F0:  MOVFF  8A1,8D9
110F4:  MOVFF  8A0,8D8
110F8:  MOVFF  89F,8D7
110FC:  MOVFF  8A6,8DE
11100:  MOVFF  8A5,8DD
11104:  MOVFF  8A4,8DC
11108:  MOVFF  8A3,8DB
1110C:  CALL   C658
11110:  MOVFF  03,8AA
11114:  MOVFF  02,8A9
11118:  MOVFF  01,8A8
1111C:  MOVFF  00,8A7
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
11120:  MOVFF  8AA,8AE
11124:  MOVFF  8A9,8AD
11128:  MOVFF  8A8,8AC
1112C:  MOVFF  8A7,8AB
11130:  CALL   108BA
11134:  MOVFF  03,3B8
11138:  MOVFF  02,3B7
1113C:  MOVFF  01,3B6
11140:  MOVFF  00,3B5
11144:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
11146:  MOVF   x61,F
11148:  BNZ   1114E
1114A:  MOVF   x62,F
1114C:  BZ    111EA
1114E:  MOVF   x63,F
11150:  BNZ   11156
11152:  MOVF   x64,F
11154:  BZ    111EA
....................       blank = NO2_array[4]; 
11156:  MOVFF  362,8F4
1115A:  MOVFF  361,8F3
1115E:  MOVLB  0
11160:  CALL   C622
11164:  MOVFF  03,8A2
11168:  MOVFF  02,8A1
1116C:  MOVFF  01,8A0
11170:  MOVFF  00,89F
....................       react = NO2_array[5]; 
11174:  MOVFF  364,8F4
11178:  MOVFF  363,8F3
1117C:  CALL   C622
11180:  MOVFF  03,8A6
11184:  MOVFF  02,8A5
11188:  MOVFF  01,8A4
1118C:  MOVFF  00,8A3
....................       ratio = blank / react; 
11190:  MOVFF  8A2,8DA
11194:  MOVFF  8A1,8D9
11198:  MOVFF  8A0,8D8
1119C:  MOVFF  89F,8D7
111A0:  MOVFF  8A6,8DE
111A4:  MOVFF  8A5,8DD
111A8:  MOVFF  8A4,8DC
111AC:  MOVFF  8A3,8DB
111B0:  CALL   C658
111B4:  MOVFF  03,8AA
111B8:  MOVFF  02,8A9
111BC:  MOVFF  01,8A8
111C0:  MOVFF  00,8A7
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
111C4:  MOVFF  8AA,8AE
111C8:  MOVFF  8A9,8AD
111CC:  MOVFF  8A8,8AC
111D0:  MOVFF  8A7,8AB
111D4:  CALL   108BA
111D8:  MOVFF  03,3BC
111DC:  MOVFF  02,3BB
111E0:  MOVFF  01,3BA
111E4:  MOVFF  00,3B9
111E8:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
111EA:  MOVF   x65,F
111EC:  BNZ   111F2
111EE:  MOVF   x66,F
111F0:  BZ    1128E
111F2:  MOVF   x67,F
111F4:  BNZ   111FA
111F6:  MOVF   x68,F
111F8:  BZ    1128E
....................       blank = NO2_array[6]; 
111FA:  MOVFF  366,8F4
111FE:  MOVFF  365,8F3
11202:  MOVLB  0
11204:  CALL   C622
11208:  MOVFF  03,8A2
1120C:  MOVFF  02,8A1
11210:  MOVFF  01,8A0
11214:  MOVFF  00,89F
....................       react = NO2_array[7]; 
11218:  MOVFF  368,8F4
1121C:  MOVFF  367,8F3
11220:  CALL   C622
11224:  MOVFF  03,8A6
11228:  MOVFF  02,8A5
1122C:  MOVFF  01,8A4
11230:  MOVFF  00,8A3
....................       ratio = blank / react; 
11234:  MOVFF  8A2,8DA
11238:  MOVFF  8A1,8D9
1123C:  MOVFF  8A0,8D8
11240:  MOVFF  89F,8D7
11244:  MOVFF  8A6,8DE
11248:  MOVFF  8A5,8DD
1124C:  MOVFF  8A4,8DC
11250:  MOVFF  8A3,8DB
11254:  CALL   C658
11258:  MOVFF  03,8AA
1125C:  MOVFF  02,8A9
11260:  MOVFF  01,8A8
11264:  MOVFF  00,8A7
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
11268:  MOVFF  8AA,8AE
1126C:  MOVFF  8A9,8AD
11270:  MOVFF  8A8,8AC
11274:  MOVFF  8A7,8AB
11278:  CALL   108BA
1127C:  MOVFF  03,3C0
11280:  MOVFF  02,3BF
11284:  MOVFF  01,3BE
11288:  MOVFF  00,3BD
1128C:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
1128E:  MOVLW  04
11290:  MOVWF  1E
11292:  MOVLW  21
11294:  MOVWF  1D
11296:  MOVLW  FC
11298:  MOVWF  FF6
1129A:  MOVLW  1D
1129C:  MOVWF  FF7
1129E:  MOVLW  00
112A0:  MOVWF  FF8
112A2:  MOVLW  06
112A4:  MOVLB  8
112A6:  MOVWF  xC7
112A8:  MOVLB  0
112AA:  CALL   AA0E
112AE:  MOVLW  10
112B0:  MOVWF  FE9
112B2:  MOVFF  35A,8D3
112B6:  MOVFF  359,8D2
112BA:  CALL   AA40
112BE:  MOVLW  05
112C0:  MOVWF  FF6
112C2:  MOVLW  1E
112C4:  MOVWF  FF7
112C6:  MOVLW  00
112C8:  MOVWF  FF8
112CA:  MOVLW  07
112CC:  MOVLB  8
112CE:  MOVWF  xC7
112D0:  MOVLB  0
112D2:  CALL   AA0E
112D6:  MOVLW  10
112D8:  MOVWF  FE9
112DA:  MOVFF  35C,8D3
112DE:  MOVFF  35B,8D2
112E2:  CALL   AA40
112E6:  MOVLW  0F
112E8:  MOVWF  FF6
112EA:  MOVLW  1E
112EC:  MOVWF  FF7
112EE:  MOVLW  00
112F0:  MOVWF  FF8
112F2:  MOVLW  09
112F4:  MOVLB  8
112F6:  MOVWF  xC7
112F8:  MOVLB  0
112FA:  CALL   AA0E
112FE:  MOVLW  89
11300:  MOVWF  FE9
11302:  MOVFF  3B4,8AE
11306:  MOVFF  3B3,8AD
1130A:  MOVFF  3B2,8AC
1130E:  MOVFF  3B1,8AB
11312:  MOVLW  04
11314:  MOVLB  8
11316:  MOVWF  xAF
11318:  MOVLB  0
1131A:  CALL   10926
1131E:  MOVLW  1D
11320:  MOVWF  FF6
11322:  MOVLW  1E
11324:  MOVWF  FF7
11326:  MOVLW  00
11328:  MOVWF  FF8
1132A:  MOVLW  07
1132C:  MOVLB  8
1132E:  MOVWF  xC7
11330:  MOVLB  0
11332:  CALL   AA0E
11336:  MOVLW  10
11338:  MOVWF  FE9
1133A:  MOVFF  35E,8D3
1133E:  MOVFF  35D,8D2
11342:  CALL   AA40
11346:  MOVLW  27
11348:  MOVWF  FF6
1134A:  MOVLW  1E
1134C:  MOVWF  FF7
1134E:  MOVLW  00
11350:  MOVWF  FF8
11352:  MOVLW  07
11354:  MOVLB  8
11356:  MOVWF  xC7
11358:  MOVLB  0
1135A:  CALL   AA0E
1135E:  MOVLW  10
11360:  MOVWF  FE9
11362:  MOVFF  360,8D3
11366:  MOVFF  35F,8D2
1136A:  CALL   AA40
1136E:  MOVLW  31
11370:  MOVWF  FF6
11372:  MOVLW  1E
11374:  MOVWF  FF7
11376:  MOVLW  00
11378:  MOVWF  FF8
1137A:  MOVLW  09
1137C:  MOVLB  8
1137E:  MOVWF  xC7
11380:  MOVLB  0
11382:  CALL   AA0E
11386:  MOVLW  89
11388:  MOVWF  FE9
1138A:  MOVFF  3B8,8AE
1138E:  MOVFF  3B7,8AD
11392:  MOVFF  3B6,8AC
11396:  MOVFF  3B5,8AB
1139A:  MOVLW  04
1139C:  MOVLB  8
1139E:  MOVWF  xAF
113A0:  MOVLB  0
113A2:  CALL   10926
113A6:  MOVLW  3F
113A8:  MOVWF  FF6
113AA:  MOVLW  1E
113AC:  MOVWF  FF7
113AE:  MOVLW  00
113B0:  MOVWF  FF8
113B2:  MOVLW  07
113B4:  MOVLB  8
113B6:  MOVWF  xC7
113B8:  MOVLB  0
113BA:  CALL   AA0E
113BE:  MOVLW  10
113C0:  MOVWF  FE9
113C2:  MOVFF  362,8D3
113C6:  MOVFF  361,8D2
113CA:  CALL   AA40
113CE:  MOVLW  49
113D0:  MOVWF  FF6
113D2:  MOVLW  1E
113D4:  MOVWF  FF7
113D6:  MOVLW  00
113D8:  MOVWF  FF8
113DA:  MOVLW  07
113DC:  MOVLB  8
113DE:  MOVWF  xC7
113E0:  MOVLB  0
113E2:  CALL   AA0E
113E6:  MOVLW  10
113E8:  MOVWF  FE9
113EA:  MOVFF  364,8D3
113EE:  MOVFF  363,8D2
113F2:  CALL   AA40
113F6:  MOVLW  53
113F8:  MOVWF  FF6
113FA:  MOVLW  1E
113FC:  MOVWF  FF7
113FE:  MOVLW  00
11400:  MOVWF  FF8
11402:  MOVLW  09
11404:  MOVLB  8
11406:  MOVWF  xC7
11408:  MOVLB  0
1140A:  CALL   AA0E
1140E:  MOVLW  89
11410:  MOVWF  FE9
11412:  MOVFF  3BC,8AE
11416:  MOVFF  3BB,8AD
1141A:  MOVFF  3BA,8AC
1141E:  MOVFF  3B9,8AB
11422:  MOVLW  04
11424:  MOVLB  8
11426:  MOVWF  xAF
11428:  MOVLB  0
1142A:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
1142E:  MOVF   1F,W
11430:  SUBLW  02
11432:  BNZ   11438
11434:  MOVF   20,F
11436:  BZ    11478
11438:  MOVLW  62
1143A:  MOVWF  FF6
1143C:  MOVLW  1E
1143E:  MOVWF  FF7
11440:  MOVLW  00
11442:  MOVWF  FF8
11444:  CLRF   1B
11446:  BTFSC  FF2.7
11448:  BSF    1B.7
1144A:  BCF    FF2.7
1144C:  MOVLW  09
1144E:  MOVLB  A
11450:  MOVWF  x18
11452:  MOVLB  0
11454:  CALL   1006
11458:  BTFSC  1B.7
1145A:  BSF    FF2.7
1145C:  MOVLW  04
1145E:  MOVWF  FEA
11460:  MOVLW  21
11462:  MOVWF  FE9
11464:  CALL   78E6
11468:  MOVLW  0D
1146A:  BTFSS  F9E.4
1146C:  BRA    1146A
1146E:  MOVWF  FAD
11470:  MOVLW  0A
11472:  BTFSS  F9E.4
11474:  BRA    11472
11476:  MOVWF  FAD
11478:  GOTO   122DC (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
1147C:  MOVLB  8
1147E:  CLRF   x9E
11480:  MOVF   x9E,W
11482:  SUBLW  03
11484:  BNC   114A4
11486:  MOVF   x9E,W
11488:  MULLW  04
1148A:  MOVF   FF3,W
1148C:  CLRF   03
1148E:  ADDLW  C1
11490:  MOVWF  FE9
11492:  MOVLW  03
11494:  ADDWFC 03,W
11496:  MOVWF  FEA
11498:  CLRF   FEF
1149A:  CLRF   FEC
1149C:  CLRF   FEC
1149E:  CLRF   FEC
114A0:  INCF   x9E,F
114A2:  BRA    11480
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
114A4:  MOVLB  3
114A6:  MOVF   x6B,F
114A8:  BTFSS  FD8.2
114AA:  BRA    114B0
114AC:  MOVF   x6C,F
114AE:  BZ    1154C
114B0:  MOVF   x6D,F
114B2:  BNZ   114B8
114B4:  MOVF   x6E,F
114B6:  BZ    1154C
....................       blank = PO4_array[0]; 
114B8:  MOVFF  36C,8F4
114BC:  MOVFF  36B,8F3
114C0:  MOVLB  0
114C2:  CALL   C622
114C6:  MOVFF  03,8A2
114CA:  MOVFF  02,8A1
114CE:  MOVFF  01,8A0
114D2:  MOVFF  00,89F
....................       react = PO4_array[1]; 
114D6:  MOVFF  36E,8F4
114DA:  MOVFF  36D,8F3
114DE:  CALL   C622
114E2:  MOVFF  03,8A6
114E6:  MOVFF  02,8A5
114EA:  MOVFF  01,8A4
114EE:  MOVFF  00,8A3
....................       ratio = blank / react; 
114F2:  MOVFF  8A2,8DA
114F6:  MOVFF  8A1,8D9
114FA:  MOVFF  8A0,8D8
114FE:  MOVFF  89F,8D7
11502:  MOVFF  8A6,8DE
11506:  MOVFF  8A5,8DD
1150A:  MOVFF  8A4,8DC
1150E:  MOVFF  8A3,8DB
11512:  CALL   C658
11516:  MOVFF  03,8AA
1151A:  MOVFF  02,8A9
1151E:  MOVFF  01,8A8
11522:  MOVFF  00,8A7
....................       PO4_abs_array[0] = log10(ratio); 
11526:  MOVFF  8AA,8AE
1152A:  MOVFF  8A9,8AD
1152E:  MOVFF  8A8,8AC
11532:  MOVFF  8A7,8AB
11536:  CALL   108BA
1153A:  MOVFF  03,3C4
1153E:  MOVFF  02,3C3
11542:  MOVFF  01,3C2
11546:  MOVFF  00,3C1
1154A:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
1154C:  MOVF   x6F,F
1154E:  BNZ   11554
11550:  MOVF   x70,F
11552:  BZ    115F0
11554:  MOVF   x71,F
11556:  BNZ   1155C
11558:  MOVF   x72,F
1155A:  BZ    115F0
....................       blank = PO4_array[2]; 
1155C:  MOVFF  370,8F4
11560:  MOVFF  36F,8F3
11564:  MOVLB  0
11566:  CALL   C622
1156A:  MOVFF  03,8A2
1156E:  MOVFF  02,8A1
11572:  MOVFF  01,8A0
11576:  MOVFF  00,89F
....................       react = PO4_array[3]; 
1157A:  MOVFF  372,8F4
1157E:  MOVFF  371,8F3
11582:  CALL   C622
11586:  MOVFF  03,8A6
1158A:  MOVFF  02,8A5
1158E:  MOVFF  01,8A4
11592:  MOVFF  00,8A3
....................       ratio = blank / react;    
11596:  MOVFF  8A2,8DA
1159A:  MOVFF  8A1,8D9
1159E:  MOVFF  8A0,8D8
115A2:  MOVFF  89F,8D7
115A6:  MOVFF  8A6,8DE
115AA:  MOVFF  8A5,8DD
115AE:  MOVFF  8A4,8DC
115B2:  MOVFF  8A3,8DB
115B6:  CALL   C658
115BA:  MOVFF  03,8AA
115BE:  MOVFF  02,8A9
115C2:  MOVFF  01,8A8
115C6:  MOVFF  00,8A7
....................       PO4_abs_array[1] = log10(ratio); 
115CA:  MOVFF  8AA,8AE
115CE:  MOVFF  8A9,8AD
115D2:  MOVFF  8A8,8AC
115D6:  MOVFF  8A7,8AB
115DA:  CALL   108BA
115DE:  MOVFF  03,3C8
115E2:  MOVFF  02,3C7
115E6:  MOVFF  01,3C6
115EA:  MOVFF  00,3C5
115EE:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
115F0:  MOVF   x73,F
115F2:  BNZ   115F8
115F4:  MOVF   x74,F
115F6:  BZ    11694
115F8:  MOVF   x75,F
115FA:  BNZ   11600
115FC:  MOVF   x76,F
115FE:  BZ    11694
....................       blank = PO4_array[4]; 
11600:  MOVFF  374,8F4
11604:  MOVFF  373,8F3
11608:  MOVLB  0
1160A:  CALL   C622
1160E:  MOVFF  03,8A2
11612:  MOVFF  02,8A1
11616:  MOVFF  01,8A0
1161A:  MOVFF  00,89F
....................       react = PO4_array[5]; 
1161E:  MOVFF  376,8F4
11622:  MOVFF  375,8F3
11626:  CALL   C622
1162A:  MOVFF  03,8A6
1162E:  MOVFF  02,8A5
11632:  MOVFF  01,8A4
11636:  MOVFF  00,8A3
....................       ratio = blank / react; 
1163A:  MOVFF  8A2,8DA
1163E:  MOVFF  8A1,8D9
11642:  MOVFF  8A0,8D8
11646:  MOVFF  89F,8D7
1164A:  MOVFF  8A6,8DE
1164E:  MOVFF  8A5,8DD
11652:  MOVFF  8A4,8DC
11656:  MOVFF  8A3,8DB
1165A:  CALL   C658
1165E:  MOVFF  03,8AA
11662:  MOVFF  02,8A9
11666:  MOVFF  01,8A8
1166A:  MOVFF  00,8A7
....................       PO4_abs_array[2] = log10(ratio); 
1166E:  MOVFF  8AA,8AE
11672:  MOVFF  8A9,8AD
11676:  MOVFF  8A8,8AC
1167A:  MOVFF  8A7,8AB
1167E:  CALL   108BA
11682:  MOVFF  03,3CC
11686:  MOVFF  02,3CB
1168A:  MOVFF  01,3CA
1168E:  MOVFF  00,3C9
11692:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
11694:  MOVF   x77,F
11696:  BNZ   1169C
11698:  MOVF   x78,F
1169A:  BZ    11738
1169C:  MOVF   x79,F
1169E:  BNZ   116A4
116A0:  MOVF   x7A,F
116A2:  BZ    11738
....................       blank = PO4_array[6]; 
116A4:  MOVFF  378,8F4
116A8:  MOVFF  377,8F3
116AC:  MOVLB  0
116AE:  CALL   C622
116B2:  MOVFF  03,8A2
116B6:  MOVFF  02,8A1
116BA:  MOVFF  01,8A0
116BE:  MOVFF  00,89F
....................       react = PO4_array[7]; 
116C2:  MOVFF  37A,8F4
116C6:  MOVFF  379,8F3
116CA:  CALL   C622
116CE:  MOVFF  03,8A6
116D2:  MOVFF  02,8A5
116D6:  MOVFF  01,8A4
116DA:  MOVFF  00,8A3
....................       ratio = blank / react; 
116DE:  MOVFF  8A2,8DA
116E2:  MOVFF  8A1,8D9
116E6:  MOVFF  8A0,8D8
116EA:  MOVFF  89F,8D7
116EE:  MOVFF  8A6,8DE
116F2:  MOVFF  8A5,8DD
116F6:  MOVFF  8A4,8DC
116FA:  MOVFF  8A3,8DB
116FE:  CALL   C658
11702:  MOVFF  03,8AA
11706:  MOVFF  02,8A9
1170A:  MOVFF  01,8A8
1170E:  MOVFF  00,8A7
....................       PO4_abs_array[3] = log10(ratio); 
11712:  MOVFF  8AA,8AE
11716:  MOVFF  8A9,8AD
1171A:  MOVFF  8A8,8AC
1171E:  MOVFF  8A7,8AB
11722:  CALL   108BA
11726:  MOVFF  03,3D0
1172A:  MOVFF  02,3CF
1172E:  MOVFF  01,3CE
11732:  MOVFF  00,3CD
11736:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
11738:  MOVLW  04
1173A:  MOVWF  1E
1173C:  MOVLW  21
1173E:  MOVWF  1D
11740:  MOVLW  70
11742:  MOVWF  FF6
11744:  MOVLW  1E
11746:  MOVWF  FF7
11748:  MOVLW  00
1174A:  MOVWF  FF8
1174C:  MOVLW  06
1174E:  MOVLB  8
11750:  MOVWF  xC7
11752:  MOVLB  0
11754:  CALL   AA0E
11758:  MOVLW  10
1175A:  MOVWF  FE9
1175C:  MOVFF  36C,8D3
11760:  MOVFF  36B,8D2
11764:  CALL   AA40
11768:  MOVLW  79
1176A:  MOVWF  FF6
1176C:  MOVLW  1E
1176E:  MOVWF  FF7
11770:  MOVLW  00
11772:  MOVWF  FF8
11774:  MOVLW  07
11776:  MOVLB  8
11778:  MOVWF  xC7
1177A:  MOVLB  0
1177C:  CALL   AA0E
11780:  MOVLW  10
11782:  MOVWF  FE9
11784:  MOVFF  36E,8D3
11788:  MOVFF  36D,8D2
1178C:  CALL   AA40
11790:  MOVLW  83
11792:  MOVWF  FF6
11794:  MOVLW  1E
11796:  MOVWF  FF7
11798:  MOVLW  00
1179A:  MOVWF  FF8
1179C:  MOVLW  09
1179E:  MOVLB  8
117A0:  MOVWF  xC7
117A2:  MOVLB  0
117A4:  CALL   AA0E
117A8:  MOVLW  89
117AA:  MOVWF  FE9
117AC:  MOVFF  3C4,8AE
117B0:  MOVFF  3C3,8AD
117B4:  MOVFF  3C2,8AC
117B8:  MOVFF  3C1,8AB
117BC:  MOVLW  04
117BE:  MOVLB  8
117C0:  MOVWF  xAF
117C2:  MOVLB  0
117C4:  CALL   10926
117C8:  MOVLW  91
117CA:  MOVWF  FF6
117CC:  MOVLW  1E
117CE:  MOVWF  FF7
117D0:  MOVLW  00
117D2:  MOVWF  FF8
117D4:  MOVLW  07
117D6:  MOVLB  8
117D8:  MOVWF  xC7
117DA:  MOVLB  0
117DC:  CALL   AA0E
117E0:  MOVLW  10
117E2:  MOVWF  FE9
117E4:  MOVFF  370,8D3
117E8:  MOVFF  36F,8D2
117EC:  CALL   AA40
117F0:  MOVLW  9B
117F2:  MOVWF  FF6
117F4:  MOVLW  1E
117F6:  MOVWF  FF7
117F8:  MOVLW  00
117FA:  MOVWF  FF8
117FC:  MOVLW  07
117FE:  MOVLB  8
11800:  MOVWF  xC7
11802:  MOVLB  0
11804:  CALL   AA0E
11808:  MOVLW  10
1180A:  MOVWF  FE9
1180C:  MOVFF  372,8D3
11810:  MOVFF  371,8D2
11814:  CALL   AA40
11818:  MOVLW  A5
1181A:  MOVWF  FF6
1181C:  MOVLW  1E
1181E:  MOVWF  FF7
11820:  MOVLW  00
11822:  MOVWF  FF8
11824:  MOVLW  09
11826:  MOVLB  8
11828:  MOVWF  xC7
1182A:  MOVLB  0
1182C:  CALL   AA0E
11830:  MOVLW  89
11832:  MOVWF  FE9
11834:  MOVFF  3C8,8AE
11838:  MOVFF  3C7,8AD
1183C:  MOVFF  3C6,8AC
11840:  MOVFF  3C5,8AB
11844:  MOVLW  04
11846:  MOVLB  8
11848:  MOVWF  xAF
1184A:  MOVLB  0
1184C:  CALL   10926
11850:  MOVLW  B3
11852:  MOVWF  FF6
11854:  MOVLW  1E
11856:  MOVWF  FF7
11858:  MOVLW  00
1185A:  MOVWF  FF8
1185C:  MOVLW  07
1185E:  MOVLB  8
11860:  MOVWF  xC7
11862:  MOVLB  0
11864:  CALL   AA0E
11868:  MOVLW  10
1186A:  MOVWF  FE9
1186C:  MOVFF  374,8D3
11870:  MOVFF  373,8D2
11874:  CALL   AA40
11878:  MOVLW  BD
1187A:  MOVWF  FF6
1187C:  MOVLW  1E
1187E:  MOVWF  FF7
11880:  MOVLW  00
11882:  MOVWF  FF8
11884:  MOVLW  07
11886:  MOVLB  8
11888:  MOVWF  xC7
1188A:  MOVLB  0
1188C:  CALL   AA0E
11890:  MOVLW  10
11892:  MOVWF  FE9
11894:  MOVFF  376,8D3
11898:  MOVFF  375,8D2
1189C:  CALL   AA40
118A0:  MOVLW  C7
118A2:  MOVWF  FF6
118A4:  MOVLW  1E
118A6:  MOVWF  FF7
118A8:  MOVLW  00
118AA:  MOVWF  FF8
118AC:  MOVLW  09
118AE:  MOVLB  8
118B0:  MOVWF  xC7
118B2:  MOVLB  0
118B4:  CALL   AA0E
118B8:  MOVLW  89
118BA:  MOVWF  FE9
118BC:  MOVFF  3CC,8AE
118C0:  MOVFF  3CB,8AD
118C4:  MOVFF  3CA,8AC
118C8:  MOVFF  3C9,8AB
118CC:  MOVLW  04
118CE:  MOVLB  8
118D0:  MOVWF  xAF
118D2:  MOVLB  0
118D4:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
118D8:  MOVF   1F,W
118DA:  SUBLW  02
118DC:  BNZ   118E2
118DE:  MOVF   20,F
118E0:  BZ    11922
118E2:  MOVLW  D6
118E4:  MOVWF  FF6
118E6:  MOVLW  1E
118E8:  MOVWF  FF7
118EA:  MOVLW  00
118EC:  MOVWF  FF8
118EE:  CLRF   1B
118F0:  BTFSC  FF2.7
118F2:  BSF    1B.7
118F4:  BCF    FF2.7
118F6:  MOVLW  09
118F8:  MOVLB  A
118FA:  MOVWF  x18
118FC:  MOVLB  0
118FE:  CALL   1006
11902:  BTFSC  1B.7
11904:  BSF    FF2.7
11906:  MOVLW  04
11908:  MOVWF  FEA
1190A:  MOVLW  21
1190C:  MOVWF  FE9
1190E:  CALL   78E6
11912:  MOVLW  0D
11914:  BTFSS  F9E.4
11916:  BRA    11914
11918:  MOVWF  FAD
1191A:  MOVLW  0A
1191C:  BTFSS  F9E.4
1191E:  BRA    1191C
11920:  MOVWF  FAD
11922:  GOTO   122DC (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
11926:  MOVLB  8
11928:  CLRF   x9E
1192A:  MOVF   x9E,W
1192C:  SUBLW  03
1192E:  BNC   1194E
11930:  MOVF   x9E,W
11932:  MULLW  04
11934:  MOVF   FF3,W
11936:  CLRF   03
11938:  ADDLW  D1
1193A:  MOVWF  FE9
1193C:  MOVLW  03
1193E:  ADDWFC 03,W
11940:  MOVWF  FEA
11942:  CLRF   FEF
11944:  CLRF   FEC
11946:  CLRF   FEC
11948:  CLRF   FEC
1194A:  INCF   x9E,F
1194C:  BRA    1192A
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
1194E:  MOVLB  3
11950:  MOVF   x7D,F
11952:  BTFSS  FD8.2
11954:  BRA    1195A
11956:  MOVF   x7E,F
11958:  BZ    119F6
1195A:  MOVF   x7F,F
1195C:  BNZ   11962
1195E:  MOVF   x80,F
11960:  BZ    119F6
....................       blank = NH4_array[0]; 
11962:  MOVFF  37E,8F4
11966:  MOVFF  37D,8F3
1196A:  MOVLB  0
1196C:  CALL   C622
11970:  MOVFF  03,8A2
11974:  MOVFF  02,8A1
11978:  MOVFF  01,8A0
1197C:  MOVFF  00,89F
....................       react = NH4_array[1]; 
11980:  MOVFF  380,8F4
11984:  MOVFF  37F,8F3
11988:  CALL   C622
1198C:  MOVFF  03,8A6
11990:  MOVFF  02,8A5
11994:  MOVFF  01,8A4
11998:  MOVFF  00,8A3
....................       ratio = blank / react; 
1199C:  MOVFF  8A2,8DA
119A0:  MOVFF  8A1,8D9
119A4:  MOVFF  8A0,8D8
119A8:  MOVFF  89F,8D7
119AC:  MOVFF  8A6,8DE
119B0:  MOVFF  8A5,8DD
119B4:  MOVFF  8A4,8DC
119B8:  MOVFF  8A3,8DB
119BC:  CALL   C658
119C0:  MOVFF  03,8AA
119C4:  MOVFF  02,8A9
119C8:  MOVFF  01,8A8
119CC:  MOVFF  00,8A7
....................       NH4_abs_array[0] = log10(ratio); 
119D0:  MOVFF  8AA,8AE
119D4:  MOVFF  8A9,8AD
119D8:  MOVFF  8A8,8AC
119DC:  MOVFF  8A7,8AB
119E0:  CALL   108BA
119E4:  MOVFF  03,3D4
119E8:  MOVFF  02,3D3
119EC:  MOVFF  01,3D2
119F0:  MOVFF  00,3D1
119F4:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
119F6:  MOVF   x81,F
119F8:  BNZ   119FE
119FA:  MOVF   x82,F
119FC:  BZ    11A9A
119FE:  MOVF   x83,F
11A00:  BNZ   11A06
11A02:  MOVF   x84,F
11A04:  BZ    11A9A
....................       blank = NH4_array[2]; 
11A06:  MOVFF  382,8F4
11A0A:  MOVFF  381,8F3
11A0E:  MOVLB  0
11A10:  CALL   C622
11A14:  MOVFF  03,8A2
11A18:  MOVFF  02,8A1
11A1C:  MOVFF  01,8A0
11A20:  MOVFF  00,89F
....................       react = NH4_array[3]; 
11A24:  MOVFF  384,8F4
11A28:  MOVFF  383,8F3
11A2C:  CALL   C622
11A30:  MOVFF  03,8A6
11A34:  MOVFF  02,8A5
11A38:  MOVFF  01,8A4
11A3C:  MOVFF  00,8A3
....................       ratio = blank / react;    
11A40:  MOVFF  8A2,8DA
11A44:  MOVFF  8A1,8D9
11A48:  MOVFF  8A0,8D8
11A4C:  MOVFF  89F,8D7
11A50:  MOVFF  8A6,8DE
11A54:  MOVFF  8A5,8DD
11A58:  MOVFF  8A4,8DC
11A5C:  MOVFF  8A3,8DB
11A60:  CALL   C658
11A64:  MOVFF  03,8AA
11A68:  MOVFF  02,8A9
11A6C:  MOVFF  01,8A8
11A70:  MOVFF  00,8A7
....................       NH4_abs_array[1] = log10(ratio); 
11A74:  MOVFF  8AA,8AE
11A78:  MOVFF  8A9,8AD
11A7C:  MOVFF  8A8,8AC
11A80:  MOVFF  8A7,8AB
11A84:  CALL   108BA
11A88:  MOVFF  03,3D8
11A8C:  MOVFF  02,3D7
11A90:  MOVFF  01,3D6
11A94:  MOVFF  00,3D5
11A98:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11A9A:  MOVF   x85,F
11A9C:  BNZ   11AA2
11A9E:  MOVF   x86,F
11AA0:  BZ    11B3E
11AA2:  MOVF   x87,F
11AA4:  BNZ   11AAA
11AA6:  MOVF   x88,F
11AA8:  BZ    11B3E
....................       blank = NH4_array[4]; 
11AAA:  MOVFF  386,8F4
11AAE:  MOVFF  385,8F3
11AB2:  MOVLB  0
11AB4:  CALL   C622
11AB8:  MOVFF  03,8A2
11ABC:  MOVFF  02,8A1
11AC0:  MOVFF  01,8A0
11AC4:  MOVFF  00,89F
....................       react = NH4_array[5]; 
11AC8:  MOVFF  388,8F4
11ACC:  MOVFF  387,8F3
11AD0:  CALL   C622
11AD4:  MOVFF  03,8A6
11AD8:  MOVFF  02,8A5
11ADC:  MOVFF  01,8A4
11AE0:  MOVFF  00,8A3
....................       ratio = blank / react; 
11AE4:  MOVFF  8A2,8DA
11AE8:  MOVFF  8A1,8D9
11AEC:  MOVFF  8A0,8D8
11AF0:  MOVFF  89F,8D7
11AF4:  MOVFF  8A6,8DE
11AF8:  MOVFF  8A5,8DD
11AFC:  MOVFF  8A4,8DC
11B00:  MOVFF  8A3,8DB
11B04:  CALL   C658
11B08:  MOVFF  03,8AA
11B0C:  MOVFF  02,8A9
11B10:  MOVFF  01,8A8
11B14:  MOVFF  00,8A7
....................       NH4_abs_array[2] = log10(ratio); 
11B18:  MOVFF  8AA,8AE
11B1C:  MOVFF  8A9,8AD
11B20:  MOVFF  8A8,8AC
11B24:  MOVFF  8A7,8AB
11B28:  CALL   108BA
11B2C:  MOVFF  03,3DC
11B30:  MOVFF  02,3DB
11B34:  MOVFF  01,3DA
11B38:  MOVFF  00,3D9
11B3C:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11B3E:  MOVF   x89,F
11B40:  BNZ   11B46
11B42:  MOVF   x8A,F
11B44:  BZ    11BE2
11B46:  MOVF   x8B,F
11B48:  BNZ   11B4E
11B4A:  MOVF   x8C,F
11B4C:  BZ    11BE2
....................       blank = NH4_array[6]; 
11B4E:  MOVFF  38A,8F4
11B52:  MOVFF  389,8F3
11B56:  MOVLB  0
11B58:  CALL   C622
11B5C:  MOVFF  03,8A2
11B60:  MOVFF  02,8A1
11B64:  MOVFF  01,8A0
11B68:  MOVFF  00,89F
....................       react = NH4_array[7]; 
11B6C:  MOVFF  38C,8F4
11B70:  MOVFF  38B,8F3
11B74:  CALL   C622
11B78:  MOVFF  03,8A6
11B7C:  MOVFF  02,8A5
11B80:  MOVFF  01,8A4
11B84:  MOVFF  00,8A3
....................       ratio = blank / react; 
11B88:  MOVFF  8A2,8DA
11B8C:  MOVFF  8A1,8D9
11B90:  MOVFF  8A0,8D8
11B94:  MOVFF  89F,8D7
11B98:  MOVFF  8A6,8DE
11B9C:  MOVFF  8A5,8DD
11BA0:  MOVFF  8A4,8DC
11BA4:  MOVFF  8A3,8DB
11BA8:  CALL   C658
11BAC:  MOVFF  03,8AA
11BB0:  MOVFF  02,8A9
11BB4:  MOVFF  01,8A8
11BB8:  MOVFF  00,8A7
....................       NH4_abs_array[3] = log10(ratio); 
11BBC:  MOVFF  8AA,8AE
11BC0:  MOVFF  8A9,8AD
11BC4:  MOVFF  8A8,8AC
11BC8:  MOVFF  8A7,8AB
11BCC:  CALL   108BA
11BD0:  MOVFF  03,3E0
11BD4:  MOVFF  02,3DF
11BD8:  MOVFF  01,3DE
11BDC:  MOVFF  00,3DD
11BE0:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11BE2:  MOVLW  04
11BE4:  MOVWF  1E
11BE6:  MOVLW  21
11BE8:  MOVWF  1D
11BEA:  MOVLW  E4
11BEC:  MOVWF  FF6
11BEE:  MOVLW  1E
11BF0:  MOVWF  FF7
11BF2:  MOVLW  00
11BF4:  MOVWF  FF8
11BF6:  MOVLW  06
11BF8:  MOVLB  8
11BFA:  MOVWF  xC7
11BFC:  MOVLB  0
11BFE:  CALL   AA0E
11C02:  MOVLW  10
11C04:  MOVWF  FE9
11C06:  MOVFF  37E,8D3
11C0A:  MOVFF  37D,8D2
11C0E:  CALL   AA40
11C12:  MOVLW  ED
11C14:  MOVWF  FF6
11C16:  MOVLW  1E
11C18:  MOVWF  FF7
11C1A:  MOVLW  00
11C1C:  MOVWF  FF8
11C1E:  MOVLW  07
11C20:  MOVLB  8
11C22:  MOVWF  xC7
11C24:  MOVLB  0
11C26:  CALL   AA0E
11C2A:  MOVLW  10
11C2C:  MOVWF  FE9
11C2E:  MOVFF  380,8D3
11C32:  MOVFF  37F,8D2
11C36:  CALL   AA40
11C3A:  MOVLW  F7
11C3C:  MOVWF  FF6
11C3E:  MOVLW  1E
11C40:  MOVWF  FF7
11C42:  MOVLW  00
11C44:  MOVWF  FF8
11C46:  MOVLW  09
11C48:  MOVLB  8
11C4A:  MOVWF  xC7
11C4C:  MOVLB  0
11C4E:  CALL   AA0E
11C52:  MOVLW  89
11C54:  MOVWF  FE9
11C56:  MOVFF  3D4,8AE
11C5A:  MOVFF  3D3,8AD
11C5E:  MOVFF  3D2,8AC
11C62:  MOVFF  3D1,8AB
11C66:  MOVLW  04
11C68:  MOVLB  8
11C6A:  MOVWF  xAF
11C6C:  MOVLB  0
11C6E:  CALL   10926
11C72:  MOVLW  05
11C74:  MOVWF  FF6
11C76:  MOVLW  1F
11C78:  MOVWF  FF7
11C7A:  MOVLW  00
11C7C:  MOVWF  FF8
11C7E:  MOVLW  07
11C80:  MOVLB  8
11C82:  MOVWF  xC7
11C84:  MOVLB  0
11C86:  CALL   AA0E
11C8A:  MOVLW  10
11C8C:  MOVWF  FE9
11C8E:  MOVFF  382,8D3
11C92:  MOVFF  381,8D2
11C96:  CALL   AA40
11C9A:  MOVLW  0F
11C9C:  MOVWF  FF6
11C9E:  MOVLW  1F
11CA0:  MOVWF  FF7
11CA2:  MOVLW  00
11CA4:  MOVWF  FF8
11CA6:  MOVLW  07
11CA8:  MOVLB  8
11CAA:  MOVWF  xC7
11CAC:  MOVLB  0
11CAE:  CALL   AA0E
11CB2:  MOVLW  10
11CB4:  MOVWF  FE9
11CB6:  MOVFF  384,8D3
11CBA:  MOVFF  383,8D2
11CBE:  CALL   AA40
11CC2:  MOVLW  19
11CC4:  MOVWF  FF6
11CC6:  MOVLW  1F
11CC8:  MOVWF  FF7
11CCA:  MOVLW  00
11CCC:  MOVWF  FF8
11CCE:  MOVLW  09
11CD0:  MOVLB  8
11CD2:  MOVWF  xC7
11CD4:  MOVLB  0
11CD6:  CALL   AA0E
11CDA:  MOVLW  89
11CDC:  MOVWF  FE9
11CDE:  MOVFF  3D8,8AE
11CE2:  MOVFF  3D7,8AD
11CE6:  MOVFF  3D6,8AC
11CEA:  MOVFF  3D5,8AB
11CEE:  MOVLW  04
11CF0:  MOVLB  8
11CF2:  MOVWF  xAF
11CF4:  MOVLB  0
11CF6:  CALL   10926
11CFA:  MOVLW  27
11CFC:  MOVWF  FF6
11CFE:  MOVLW  1F
11D00:  MOVWF  FF7
11D02:  MOVLW  00
11D04:  MOVWF  FF8
11D06:  MOVLW  07
11D08:  MOVLB  8
11D0A:  MOVWF  xC7
11D0C:  MOVLB  0
11D0E:  CALL   AA0E
11D12:  MOVLW  10
11D14:  MOVWF  FE9
11D16:  MOVFF  386,8D3
11D1A:  MOVFF  385,8D2
11D1E:  CALL   AA40
11D22:  MOVLW  31
11D24:  MOVWF  FF6
11D26:  MOVLW  1F
11D28:  MOVWF  FF7
11D2A:  MOVLW  00
11D2C:  MOVWF  FF8
11D2E:  MOVLW  07
11D30:  MOVLB  8
11D32:  MOVWF  xC7
11D34:  MOVLB  0
11D36:  CALL   AA0E
11D3A:  MOVLW  10
11D3C:  MOVWF  FE9
11D3E:  MOVFF  388,8D3
11D42:  MOVFF  387,8D2
11D46:  CALL   AA40
11D4A:  MOVLW  3B
11D4C:  MOVWF  FF6
11D4E:  MOVLW  1F
11D50:  MOVWF  FF7
11D52:  MOVLW  00
11D54:  MOVWF  FF8
11D56:  MOVLW  09
11D58:  MOVLB  8
11D5A:  MOVWF  xC7
11D5C:  MOVLB  0
11D5E:  CALL   AA0E
11D62:  MOVLW  89
11D64:  MOVWF  FE9
11D66:  MOVFF  3DC,8AE
11D6A:  MOVFF  3DB,8AD
11D6E:  MOVFF  3DA,8AC
11D72:  MOVFF  3D9,8AB
11D76:  MOVLW  04
11D78:  MOVLB  8
11D7A:  MOVWF  xAF
11D7C:  MOVLB  0
11D7E:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
11D82:  MOVF   1F,W
11D84:  SUBLW  02
11D86:  BNZ   11D8C
11D88:  MOVF   20,F
11D8A:  BZ    11DCC
11D8C:  MOVLW  4A
11D8E:  MOVWF  FF6
11D90:  MOVLW  1F
11D92:  MOVWF  FF7
11D94:  MOVLW  00
11D96:  MOVWF  FF8
11D98:  CLRF   1B
11D9A:  BTFSC  FF2.7
11D9C:  BSF    1B.7
11D9E:  BCF    FF2.7
11DA0:  MOVLW  09
11DA2:  MOVLB  A
11DA4:  MOVWF  x18
11DA6:  MOVLB  0
11DA8:  CALL   1006
11DAC:  BTFSC  1B.7
11DAE:  BSF    FF2.7
11DB0:  MOVLW  04
11DB2:  MOVWF  FEA
11DB4:  MOVLW  21
11DB6:  MOVWF  FE9
11DB8:  CALL   78E6
11DBC:  MOVLW  0D
11DBE:  BTFSS  F9E.4
11DC0:  BRA    11DBE
11DC2:  MOVWF  FAD
11DC4:  MOVLW  0A
11DC6:  BTFSS  F9E.4
11DC8:  BRA    11DC6
11DCA:  MOVWF  FAD
11DCC:  GOTO   122DC (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
11DD0:  MOVLB  8
11DD2:  CLRF   x9E
11DD4:  MOVF   x9E,W
11DD6:  SUBLW  03
11DD8:  BNC   11DF8
11DDA:  MOVF   x9E,W
11DDC:  MULLW  04
11DDE:  MOVF   FF3,W
11DE0:  CLRF   03
11DE2:  ADDLW  E1
11DE4:  MOVWF  FE9
11DE6:  MOVLW  03
11DE8:  ADDWFC 03,W
11DEA:  MOVWF  FEA
11DEC:  CLRF   FEF
11DEE:  CLRF   FEC
11DF0:  CLRF   FEC
11DF2:  CLRF   FEC
11DF4:  INCF   x9E,F
11DF6:  BRA    11DD4
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
11DF8:  MOVLB  3
11DFA:  MOVF   x8F,F
11DFC:  BTFSS  FD8.2
11DFE:  BRA    11E04
11E00:  MOVF   x90,F
11E02:  BZ    11EA0
11E04:  MOVF   x91,F
11E06:  BNZ   11E0C
11E08:  MOVF   x92,F
11E0A:  BZ    11EA0
....................       blank = SiO_array[0]; 
11E0C:  MOVFF  390,8F4
11E10:  MOVFF  38F,8F3
11E14:  MOVLB  0
11E16:  CALL   C622
11E1A:  MOVFF  03,8A2
11E1E:  MOVFF  02,8A1
11E22:  MOVFF  01,8A0
11E26:  MOVFF  00,89F
....................       react = SiO_array[1]; 
11E2A:  MOVFF  392,8F4
11E2E:  MOVFF  391,8F3
11E32:  CALL   C622
11E36:  MOVFF  03,8A6
11E3A:  MOVFF  02,8A5
11E3E:  MOVFF  01,8A4
11E42:  MOVFF  00,8A3
....................       ratio = blank / react; 
11E46:  MOVFF  8A2,8DA
11E4A:  MOVFF  8A1,8D9
11E4E:  MOVFF  8A0,8D8
11E52:  MOVFF  89F,8D7
11E56:  MOVFF  8A6,8DE
11E5A:  MOVFF  8A5,8DD
11E5E:  MOVFF  8A4,8DC
11E62:  MOVFF  8A3,8DB
11E66:  CALL   C658
11E6A:  MOVFF  03,8AA
11E6E:  MOVFF  02,8A9
11E72:  MOVFF  01,8A8
11E76:  MOVFF  00,8A7
....................       SiO_abs_array[0] = log10(ratio); 
11E7A:  MOVFF  8AA,8AE
11E7E:  MOVFF  8A9,8AD
11E82:  MOVFF  8A8,8AC
11E86:  MOVFF  8A7,8AB
11E8A:  CALL   108BA
11E8E:  MOVFF  03,3E4
11E92:  MOVFF  02,3E3
11E96:  MOVFF  01,3E2
11E9A:  MOVFF  00,3E1
11E9E:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
11EA0:  MOVF   x93,F
11EA2:  BNZ   11EA8
11EA4:  MOVF   x94,F
11EA6:  BZ    11F44
11EA8:  MOVF   x95,F
11EAA:  BNZ   11EB0
11EAC:  MOVF   x96,F
11EAE:  BZ    11F44
....................       blank = SiO_array[2]; 
11EB0:  MOVFF  394,8F4
11EB4:  MOVFF  393,8F3
11EB8:  MOVLB  0
11EBA:  CALL   C622
11EBE:  MOVFF  03,8A2
11EC2:  MOVFF  02,8A1
11EC6:  MOVFF  01,8A0
11ECA:  MOVFF  00,89F
....................       react = SiO_array[3]; 
11ECE:  MOVFF  396,8F4
11ED2:  MOVFF  395,8F3
11ED6:  CALL   C622
11EDA:  MOVFF  03,8A6
11EDE:  MOVFF  02,8A5
11EE2:  MOVFF  01,8A4
11EE6:  MOVFF  00,8A3
....................       ratio = blank / react;    
11EEA:  MOVFF  8A2,8DA
11EEE:  MOVFF  8A1,8D9
11EF2:  MOVFF  8A0,8D8
11EF6:  MOVFF  89F,8D7
11EFA:  MOVFF  8A6,8DE
11EFE:  MOVFF  8A5,8DD
11F02:  MOVFF  8A4,8DC
11F06:  MOVFF  8A3,8DB
11F0A:  CALL   C658
11F0E:  MOVFF  03,8AA
11F12:  MOVFF  02,8A9
11F16:  MOVFF  01,8A8
11F1A:  MOVFF  00,8A7
....................       SiO_abs_array[1] = log10(ratio); 
11F1E:  MOVFF  8AA,8AE
11F22:  MOVFF  8A9,8AD
11F26:  MOVFF  8A8,8AC
11F2A:  MOVFF  8A7,8AB
11F2E:  CALL   108BA
11F32:  MOVFF  03,3E8
11F36:  MOVFF  02,3E7
11F3A:  MOVFF  01,3E6
11F3E:  MOVFF  00,3E5
11F42:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
11F44:  MOVF   x97,F
11F46:  BNZ   11F4C
11F48:  MOVF   x98,F
11F4A:  BZ    11FE8
11F4C:  MOVF   x99,F
11F4E:  BNZ   11F54
11F50:  MOVF   x9A,F
11F52:  BZ    11FE8
....................       blank = SiO_array[4]; 
11F54:  MOVFF  398,8F4
11F58:  MOVFF  397,8F3
11F5C:  MOVLB  0
11F5E:  CALL   C622
11F62:  MOVFF  03,8A2
11F66:  MOVFF  02,8A1
11F6A:  MOVFF  01,8A0
11F6E:  MOVFF  00,89F
....................       react = SiO_array[5]; 
11F72:  MOVFF  39A,8F4
11F76:  MOVFF  399,8F3
11F7A:  CALL   C622
11F7E:  MOVFF  03,8A6
11F82:  MOVFF  02,8A5
11F86:  MOVFF  01,8A4
11F8A:  MOVFF  00,8A3
....................       ratio = blank / react; 
11F8E:  MOVFF  8A2,8DA
11F92:  MOVFF  8A1,8D9
11F96:  MOVFF  8A0,8D8
11F9A:  MOVFF  89F,8D7
11F9E:  MOVFF  8A6,8DE
11FA2:  MOVFF  8A5,8DD
11FA6:  MOVFF  8A4,8DC
11FAA:  MOVFF  8A3,8DB
11FAE:  CALL   C658
11FB2:  MOVFF  03,8AA
11FB6:  MOVFF  02,8A9
11FBA:  MOVFF  01,8A8
11FBE:  MOVFF  00,8A7
....................       SiO_abs_array[2] = log10(ratio); 
11FC2:  MOVFF  8AA,8AE
11FC6:  MOVFF  8A9,8AD
11FCA:  MOVFF  8A8,8AC
11FCE:  MOVFF  8A7,8AB
11FD2:  CALL   108BA
11FD6:  MOVFF  03,3EC
11FDA:  MOVFF  02,3EB
11FDE:  MOVFF  01,3EA
11FE2:  MOVFF  00,3E9
11FE6:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
11FE8:  MOVF   x9B,F
11FEA:  BNZ   11FF0
11FEC:  MOVF   x9C,F
11FEE:  BZ    1208C
11FF0:  MOVF   x9D,F
11FF2:  BNZ   11FF8
11FF4:  MOVF   x9E,F
11FF6:  BZ    1208C
....................       blank = SiO_array[6]; 
11FF8:  MOVFF  39C,8F4
11FFC:  MOVFF  39B,8F3
12000:  MOVLB  0
12002:  CALL   C622
12006:  MOVFF  03,8A2
1200A:  MOVFF  02,8A1
1200E:  MOVFF  01,8A0
12012:  MOVFF  00,89F
....................       react = SiO_array[7]; 
12016:  MOVFF  39E,8F4
1201A:  MOVFF  39D,8F3
1201E:  CALL   C622
12022:  MOVFF  03,8A6
12026:  MOVFF  02,8A5
1202A:  MOVFF  01,8A4
1202E:  MOVFF  00,8A3
....................       ratio = blank / react; 
12032:  MOVFF  8A2,8DA
12036:  MOVFF  8A1,8D9
1203A:  MOVFF  8A0,8D8
1203E:  MOVFF  89F,8D7
12042:  MOVFF  8A6,8DE
12046:  MOVFF  8A5,8DD
1204A:  MOVFF  8A4,8DC
1204E:  MOVFF  8A3,8DB
12052:  CALL   C658
12056:  MOVFF  03,8AA
1205A:  MOVFF  02,8A9
1205E:  MOVFF  01,8A8
12062:  MOVFF  00,8A7
....................       SiO_abs_array[3] = log10(ratio); 
12066:  MOVFF  8AA,8AE
1206A:  MOVFF  8A9,8AD
1206E:  MOVFF  8A8,8AC
12072:  MOVFF  8A7,8AB
12076:  CALL   108BA
1207A:  MOVFF  03,3F0
1207E:  MOVFF  02,3EF
12082:  MOVFF  01,3EE
12086:  MOVFF  00,3ED
1208A:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
1208C:  MOVLW  04
1208E:  MOVWF  1E
12090:  MOVLW  21
12092:  MOVWF  1D
12094:  MOVLW  58
12096:  MOVWF  FF6
12098:  MOVLW  1F
1209A:  MOVWF  FF7
1209C:  MOVLW  00
1209E:  MOVWF  FF8
120A0:  MOVLW  06
120A2:  MOVLB  8
120A4:  MOVWF  xC7
120A6:  MOVLB  0
120A8:  CALL   AA0E
120AC:  MOVLW  10
120AE:  MOVWF  FE9
120B0:  MOVFF  390,8D3
120B4:  MOVFF  38F,8D2
120B8:  CALL   AA40
120BC:  MOVLW  61
120BE:  MOVWF  FF6
120C0:  MOVLW  1F
120C2:  MOVWF  FF7
120C4:  MOVLW  00
120C6:  MOVWF  FF8
120C8:  MOVLW  07
120CA:  MOVLB  8
120CC:  MOVWF  xC7
120CE:  MOVLB  0
120D0:  CALL   AA0E
120D4:  MOVLW  10
120D6:  MOVWF  FE9
120D8:  MOVFF  392,8D3
120DC:  MOVFF  391,8D2
120E0:  CALL   AA40
120E4:  MOVLW  6B
120E6:  MOVWF  FF6
120E8:  MOVLW  1F
120EA:  MOVWF  FF7
120EC:  MOVLW  00
120EE:  MOVWF  FF8
120F0:  MOVLW  09
120F2:  MOVLB  8
120F4:  MOVWF  xC7
120F6:  MOVLB  0
120F8:  CALL   AA0E
120FC:  MOVLW  89
120FE:  MOVWF  FE9
12100:  MOVFF  3E4,8AE
12104:  MOVFF  3E3,8AD
12108:  MOVFF  3E2,8AC
1210C:  MOVFF  3E1,8AB
12110:  MOVLW  04
12112:  MOVLB  8
12114:  MOVWF  xAF
12116:  MOVLB  0
12118:  CALL   10926
1211C:  MOVLW  79
1211E:  MOVWF  FF6
12120:  MOVLW  1F
12122:  MOVWF  FF7
12124:  MOVLW  00
12126:  MOVWF  FF8
12128:  MOVLW  07
1212A:  MOVLB  8
1212C:  MOVWF  xC7
1212E:  MOVLB  0
12130:  CALL   AA0E
12134:  MOVLW  10
12136:  MOVWF  FE9
12138:  MOVFF  394,8D3
1213C:  MOVFF  393,8D2
12140:  CALL   AA40
12144:  MOVLW  83
12146:  MOVWF  FF6
12148:  MOVLW  1F
1214A:  MOVWF  FF7
1214C:  MOVLW  00
1214E:  MOVWF  FF8
12150:  MOVLW  07
12152:  MOVLB  8
12154:  MOVWF  xC7
12156:  MOVLB  0
12158:  CALL   AA0E
1215C:  MOVLW  10
1215E:  MOVWF  FE9
12160:  MOVFF  396,8D3
12164:  MOVFF  395,8D2
12168:  CALL   AA40
1216C:  MOVLW  8D
1216E:  MOVWF  FF6
12170:  MOVLW  1F
12172:  MOVWF  FF7
12174:  MOVLW  00
12176:  MOVWF  FF8
12178:  MOVLW  09
1217A:  MOVLB  8
1217C:  MOVWF  xC7
1217E:  MOVLB  0
12180:  CALL   AA0E
12184:  MOVLW  89
12186:  MOVWF  FE9
12188:  MOVFF  3E8,8AE
1218C:  MOVFF  3E7,8AD
12190:  MOVFF  3E6,8AC
12194:  MOVFF  3E5,8AB
12198:  MOVLW  04
1219A:  MOVLB  8
1219C:  MOVWF  xAF
1219E:  MOVLB  0
121A0:  CALL   10926
121A4:  MOVLW  9B
121A6:  MOVWF  FF6
121A8:  MOVLW  1F
121AA:  MOVWF  FF7
121AC:  MOVLW  00
121AE:  MOVWF  FF8
121B0:  MOVLW  07
121B2:  MOVLB  8
121B4:  MOVWF  xC7
121B6:  MOVLB  0
121B8:  CALL   AA0E
121BC:  MOVLW  10
121BE:  MOVWF  FE9
121C0:  MOVFF  398,8D3
121C4:  MOVFF  397,8D2
121C8:  CALL   AA40
121CC:  MOVLW  A5
121CE:  MOVWF  FF6
121D0:  MOVLW  1F
121D2:  MOVWF  FF7
121D4:  MOVLW  00
121D6:  MOVWF  FF8
121D8:  MOVLW  07
121DA:  MOVLB  8
121DC:  MOVWF  xC7
121DE:  MOVLB  0
121E0:  CALL   AA0E
121E4:  MOVLW  10
121E6:  MOVWF  FE9
121E8:  MOVFF  39A,8D3
121EC:  MOVFF  399,8D2
121F0:  CALL   AA40
121F4:  MOVLW  AF
121F6:  MOVWF  FF6
121F8:  MOVLW  1F
121FA:  MOVWF  FF7
121FC:  MOVLW  00
121FE:  MOVWF  FF8
12200:  MOVLW  09
12202:  MOVLB  8
12204:  MOVWF  xC7
12206:  MOVLB  0
12208:  CALL   AA0E
1220C:  MOVLW  89
1220E:  MOVWF  FE9
12210:  MOVFF  3EC,8AE
12214:  MOVFF  3EB,8AD
12218:  MOVFF  3EA,8AC
1221C:  MOVFF  3E9,8AB
12220:  MOVLW  04
12222:  MOVLB  8
12224:  MOVWF  xAF
12226:  MOVLB  0
12228:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
1222C:  MOVF   1F,W
1222E:  SUBLW  02
12230:  BNZ   12236
12232:  MOVF   20,F
12234:  BZ    12276
12236:  MOVLW  BE
12238:  MOVWF  FF6
1223A:  MOVLW  1F
1223C:  MOVWF  FF7
1223E:  MOVLW  00
12240:  MOVWF  FF8
12242:  CLRF   1B
12244:  BTFSC  FF2.7
12246:  BSF    1B.7
12248:  BCF    FF2.7
1224A:  MOVLW  09
1224C:  MOVLB  A
1224E:  MOVWF  x18
12250:  MOVLB  0
12252:  CALL   1006
12256:  BTFSC  1B.7
12258:  BSF    FF2.7
1225A:  MOVLW  04
1225C:  MOVWF  FEA
1225E:  MOVLW  21
12260:  MOVWF  FE9
12262:  CALL   78E6
12266:  MOVLW  0D
12268:  BTFSS  F9E.4
1226A:  BRA    12268
1226C:  MOVWF  FAD
1226E:  MOVLW  0A
12270:  BTFSS  F9E.4
12272:  BRA    12270
12274:  MOVWF  FAD
12276:  GOTO   122DC (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
1227A:  MOVLW  04
1227C:  MOVWF  FEA
1227E:  MOVLW  21
12280:  MOVWF  FE9
12282:  MOVLW  00
12284:  CALL   056C
12288:  TBLRD*-
1228A:  TBLRD*+
1228C:  MOVF   FF5,W
1228E:  MOVWF  FEE
12290:  IORLW  00
12292:  BNZ   1228A
....................     
....................    switch (chem){ 
12294:  MOVLW  CC
12296:  MOVWF  FF6
12298:  MOVLW  1F
1229A:  MOVWF  FF7
1229C:  MOVLW  00
1229E:  MOVWF  FF8
122A0:  MOVLW  03
122A2:  MOVWF  FEA
122A4:  MOVLW  39
122A6:  MOVWF  FE9
122A8:  CALL   FB54
122AC:  MOVF   01,W
122AE:  BZ    122C2
122B0:  XORLW  01
122B2:  BZ    122C8
122B4:  XORLW  03
122B6:  BZ    122CE
122B8:  XORLW  01
122BA:  BZ    122D4
122BC:  XORLW  07
122BE:  BZ    122DA
122C0:  BRA    122DC
....................       case "NO3" : calc_abs_NO3(); 
122C2:  GOTO   10B38
....................          break; 
122C6:  BRA    122DC
....................       case "NO2" : calc_abs_NO2 (); 
122C8:  GOTO   10FD4
....................          break;    
122CC:  BRA    122DC
....................       case "PO4" : calc_abs_PO4(); 
122CE:  GOTO   1147C
....................          break; 
122D2:  BRA    122DC
....................       case "NH4" : calc_abs_NH4(); 
122D4:  GOTO   11926
....................          break; 
122D8:  BRA    122DC
....................       case "SiO" : calc_abs_SiO(); 
122DA:  BRA    11DD0
....................          break; 
....................    } 
122DC:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
122DE:  CALL   D22C
....................     
....................    if (data_available == TRUE) { 
122E2:  MOVLB  3
122E4:  DECFSZ x37,W
122E6:  BRA    123E8
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
122E8:  MOVLB  8
122EA:  CLRF   xD5
122EC:  MOVLW  63
122EE:  MOVWF  xD4
122F0:  MOVLW  02
122F2:  MOVWF  xD7
122F4:  MOVLW  B3
122F6:  MOVWF  xD6
122F8:  MOVLB  0
122FA:  CALL   545C
....................       strcat(data_buffer, comma); 
122FE:  MOVLB  8
12300:  CLRF   xD5
12302:  MOVLW  63
12304:  MOVWF  xD4
12306:  MOVLW  03
12308:  MOVWF  xD7
1230A:  MOVLW  35
1230C:  MOVWF  xD6
1230E:  MOVLB  0
12310:  CALL   545C
....................       strcat(data_buffer, chem); 
12314:  MOVLB  8
12316:  CLRF   xD5
12318:  MOVLW  63
1231A:  MOVWF  xD4
1231C:  MOVLW  03
1231E:  MOVWF  xD7
12320:  MOVLW  39
12322:  MOVWF  xD6
12324:  MOVLB  0
12326:  CALL   545C
....................       strcat(data_buffer, comma); 
1232A:  MOVLB  8
1232C:  CLRF   xD5
1232E:  MOVLW  63
12330:  MOVWF  xD4
12332:  MOVLW  03
12334:  MOVWF  xD7
12336:  MOVLW  35
12338:  MOVWF  xD6
1233A:  MOVLB  0
1233C:  CALL   545C
....................       strcat(data_buffer, abs_str); 
12340:  MOVLB  8
12342:  CLRF   xD5
12344:  MOVLW  63
12346:  MOVWF  xD4
12348:  MOVLW  04
1234A:  MOVWF  xD7
1234C:  MOVLW  21
1234E:  MOVWF  xD6
12350:  MOVLB  0
12352:  CALL   545C
....................       strcat(data_buffer, endofline); 
12356:  MOVLB  8
12358:  CLRF   xD5
1235A:  MOVLW  63
1235C:  MOVWF  xD4
1235E:  MOVLW  07
12360:  MOVWF  xD7
12362:  MOVLW  C9
12364:  MOVWF  xD6
12366:  MOVLB  0
12368:  CALL   545C
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
1236C:  MOVF   1F,W
1236E:  SUBLW  04
12370:  BNZ   12390
12372:  MOVF   20,F
12374:  BNZ   12390
12376:  CLRF   FEA
12378:  MOVLW  63
1237A:  MOVWF  FE9
1237C:  CALL   78E6
12380:  MOVLW  0D
12382:  BTFSS  F9E.4
12384:  BRA    12382
12386:  MOVWF  FAD
12388:  MOVLW  0A
1238A:  BTFSS  F9E.4
1238C:  BRA    1238A
1238E:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
12390:  MOVLB  2
12392:  MOVF   xD8,F
12394:  BNZ   123E6
....................        
....................          buffer_select = 0; 
12396:  MOVLB  0
12398:  CLRF   x62
....................           
....................          heartbeat(FALSE); 
1239A:  MOVLB  8
1239C:  CLRF   xC9
1239E:  MOVLB  0
123A0:  CALL   5500
....................             append_data(file_ptr_rel_all); 
123A4:  MOVLW  02
123A6:  MOVLB  8
123A8:  MOVWF  xCA
123AA:  MOVLW  F5
123AC:  MOVWF  xC9
123AE:  MOVLB  0
123B0:  CALL   8242
....................          heartbeat(TRUE);          
123B4:  MOVLW  01
123B6:  MOVLB  8
123B8:  MOVWF  xC9
123BA:  MOVLB  0
123BC:  CALL   5500
....................           
....................          heartbeat(FALSE); 
123C0:  MOVLB  8
123C2:  CLRF   xC9
123C4:  MOVLB  0
123C6:  CALL   5500
....................             append_data(file_ptr_rel_new);    
123CA:  MOVLW  03
123CC:  MOVLB  8
123CE:  MOVWF  xCA
123D0:  MOVWF  xC9
123D2:  MOVLB  0
123D4:  CALL   8242
....................          heartbeat(TRUE); 
123D8:  MOVLW  01
123DA:  MOVLB  8
123DC:  MOVWF  xC9
123DE:  MOVLB  0
123E0:  CALL   5500
123E4:  MOVLB  2
123E6:  MOVLB  3
....................       } 
....................    } 
123E8:  MOVLB  0
123EA:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D342:  MOVLW  2C
0D344:  MOVLB  8
0D346:  MOVWF  x7A
0D348:  CLRF   x7B
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D34A:  MOVLW  0D
0D34C:  MOVWF  x7C
0D34E:  MOVLW  0A
0D350:  MOVWF  x7D
0D352:  CLRF   x7E
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D354:  MOVLB  0
0D356:  RCALL  D22C
....................    time_stamp(); 
0D358:  CALL   5398
....................    strcat(data_buffer, time_stmp_str); 
0D35C:  MOVLB  8
0D35E:  CLRF   xD5
0D360:  MOVLW  63
0D362:  MOVWF  xD4
0D364:  MOVLW  02
0D366:  MOVWF  xD7
0D368:  MOVLW  95
0D36A:  MOVWF  xD6
0D36C:  MOVLB  0
0D36E:  CALL   545C
....................    strcat(data_buffer, comma); 
0D372:  MOVLB  8
0D374:  CLRF   xD5
0D376:  MOVLW  63
0D378:  MOVWF  xD4
0D37A:  MOVLW  08
0D37C:  MOVWF  xD7
0D37E:  MOVLW  7A
0D380:  MOVWF  xD6
0D382:  MOVLB  0
0D384:  CALL   545C
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D388:  MOVLW  08
0D38A:  MOVWF  1E
0D38C:  MOVLW  7F
0D38E:  MOVWF  1D
0D390:  MOVFF  879,8C9
0D394:  MOVLW  1B
0D396:  MOVLB  8
0D398:  MOVWF  xCA
0D39A:  MOVLB  0
0D39C:  CALL   51FE
0D3A0:  MOVLW  2C
0D3A2:  MOVLB  8
0D3A4:  MOVWF  xDB
0D3A6:  MOVLB  0
0D3A8:  CALL   501C
0D3AC:  MOVLW  10
0D3AE:  MOVWF  FE9
0D3B0:  MOVFF  2A,8D3
0D3B4:  MOVFF  29,8D2
0D3B8:  CALL   AA40
0D3BC:  MOVLW  2C
0D3BE:  MOVLB  8
0D3C0:  MOVWF  xDB
0D3C2:  MOVLB  0
0D3C4:  CALL   501C
0D3C8:  MOVLW  10
0D3CA:  MOVWF  FE9
0D3CC:  MOVFF  24,8D3
0D3D0:  MOVFF  23,8D2
0D3D4:  CALL   AA40
0D3D8:  MOVLW  2C
0D3DA:  MOVLB  8
0D3DC:  MOVWF  xDB
0D3DE:  MOVLB  0
0D3E0:  CALL   501C
0D3E4:  MOVLW  10
0D3E6:  MOVWF  FE9
0D3E8:  MOVFF  2C,8D3
0D3EC:  MOVFF  2B,8D2
0D3F0:  CALL   AA40
0D3F4:  MOVLW  2C
0D3F6:  MOVLB  8
0D3F8:  MOVWF  xDB
0D3FA:  MOVLB  0
0D3FC:  CALL   501C
0D400:  MOVLW  10
0D402:  MOVWF  FE9
0D404:  MOVFF  2E,8D3
0D408:  MOVFF  2D,8D2
0D40C:  CALL   AA40
0D410:  MOVLW  2C
0D412:  MOVLB  8
0D414:  MOVWF  xDB
0D416:  MOVLB  0
0D418:  CALL   501C
0D41C:  MOVLW  10
0D41E:  MOVWF  FE9
0D420:  MOVFF  22,8D3
0D424:  MOVFF  21,8D2
0D428:  CALL   AA40
0D42C:  MOVLW  2C
0D42E:  MOVLB  8
0D430:  MOVWF  xDB
0D432:  MOVLB  0
0D434:  CALL   501C
0D438:  MOVLW  10
0D43A:  MOVWF  FE9
0D43C:  MOVFF  7C4,8D3
0D440:  MOVFF  7C3,8D2
0D444:  CALL   AA40
0D448:  MOVLW  2C
0D44A:  MOVLB  8
0D44C:  MOVWF  xDB
0D44E:  MOVLB  0
0D450:  CALL   501C
0D454:  MOVLW  10
0D456:  MOVWF  FE9
0D458:  MOVFF  7B2,89E
0D45C:  MOVFF  7B1,89D
0D460:  BRA    D240
....................    strcat(data_buffer, config_str); 
0D462:  MOVLB  8
0D464:  CLRF   xD5
0D466:  MOVLW  63
0D468:  MOVWF  xD4
0D46A:  MOVLW  08
0D46C:  MOVWF  xD7
0D46E:  MOVLW  7F
0D470:  MOVWF  xD6
0D472:  MOVLB  0
0D474:  CALL   545C
....................    strcat(data_buffer, endofline); 
0D478:  MOVLB  8
0D47A:  CLRF   xD5
0D47C:  MOVLW  63
0D47E:  MOVWF  xD4
0D480:  MOVLW  08
0D482:  MOVWF  xD7
0D484:  MOVLW  7C
0D486:  MOVWF  xD6
0D488:  MOVLB  0
0D48A:  CALL   545C
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D48E:  CLRF   FEA
0D490:  MOVLW  63
0D492:  MOVWF  FE9
0D494:  CALL   78E6
0D498:  MOVLW  0D
0D49A:  BTFSS  F9E.4
0D49C:  BRA    D49A
0D49E:  MOVWF  FAD
0D4A0:  MOVLW  0A
0D4A2:  BTFSS  F9E.4
0D4A4:  BRA    D4A2
0D4A6:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D4A8:  MOVLB  2
0D4AA:  MOVF   xD8,F
0D4AC:  BNZ   D500
....................     
....................       buffer_select = 0; 
0D4AE:  MOVLB  0
0D4B0:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
0D4B2:  MOVLB  8
0D4B4:  CLRF   xC9
0D4B6:  MOVLB  0
0D4B8:  CALL   5500
....................          append_data(file_ptr_raw_all); 
0D4BC:  MOVLW  02
0D4BE:  MOVLB  8
0D4C0:  MOVWF  xCA
0D4C2:  MOVLW  D9
0D4C4:  MOVWF  xC9
0D4C6:  MOVLB  0
0D4C8:  CALL   8242
....................       heartbeat(TRUE);          
0D4CC:  MOVLW  01
0D4CE:  MOVLB  8
0D4D0:  MOVWF  xC9
0D4D2:  MOVLB  0
0D4D4:  CALL   5500
....................        
....................       heartbeat(FALSE); 
0D4D8:  MOVLB  8
0D4DA:  CLRF   xC9
0D4DC:  MOVLB  0
0D4DE:  CALL   5500
....................          append_data(file_ptr_raw_new);    
0D4E2:  MOVLW  02
0D4E4:  MOVLB  8
0D4E6:  MOVWF  xCA
0D4E8:  MOVLW  E7
0D4EA:  MOVWF  xC9
0D4EC:  MOVLB  0
0D4EE:  CALL   8242
....................       heartbeat(TRUE); 
0D4F2:  MOVLW  01
0D4F4:  MOVLB  8
0D4F6:  MOVWF  xC9
0D4F8:  MOVLB  0
0D4FA:  CALL   5500
0D4FE:  MOVLB  2
....................    } 
0D500:  MOVLB  0
0D502:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
14DD6:  MOVLW  2C
14DD8:  MOVLB  8
14DDA:  MOVWF  x7C
14DDC:  CLRF   x7D
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
14DDE:  MOVLW  0D
14DE0:  MOVWF  x7E
14DE2:  MOVLW  0A
14DE4:  MOVWF  x7F
14DE6:  CLRF   x80
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
14DE8:  MOVLB  0
14DEA:  CALL   D22C
....................    time_stamp(); 
14DEE:  CALL   5398
....................    strcat(data_buffer, time_stmp_str); 
14DF2:  MOVLB  8
14DF4:  CLRF   xD5
14DF6:  MOVLW  63
14DF8:  MOVWF  xD4
14DFA:  MOVLW  02
14DFC:  MOVWF  xD7
14DFE:  MOVLW  95
14E00:  MOVWF  xD6
14E02:  MOVLB  0
14E04:  CALL   545C
....................    strcat(data_buffer, comma); 
14E08:  MOVLB  8
14E0A:  CLRF   xD5
14E0C:  MOVLW  63
14E0E:  MOVWF  xD4
14E10:  MOVLW  08
14E12:  MOVWF  xD7
14E14:  MOVLW  7C
14E16:  MOVWF  xD6
14E18:  MOVLB  0
14E1A:  CALL   545C
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
14E1E:  MOVLW  08
14E20:  MOVWF  1E
14E22:  MOVLW  81
14E24:  MOVWF  1D
14E26:  MOVFF  879,8C9
14E2A:  MOVLW  1B
14E2C:  MOVLB  8
14E2E:  MOVWF  xCA
14E30:  MOVLB  0
14E32:  CALL   51FE
14E36:  MOVLW  2C
14E38:  MOVLB  8
14E3A:  MOVWF  xDB
14E3C:  MOVLB  0
14E3E:  CALL   501C
14E42:  MOVLW  10
14E44:  MOVWF  FE9
14E46:  MOVFF  87B,8D3
14E4A:  MOVFF  87A,8D2
14E4E:  CALL   AA40
....................    strcat(data_buffer, config_str); 
14E52:  MOVLB  8
14E54:  CLRF   xD5
14E56:  MOVLW  63
14E58:  MOVWF  xD4
14E5A:  MOVLW  08
14E5C:  MOVWF  xD7
14E5E:  MOVLW  81
14E60:  MOVWF  xD6
14E62:  MOVLB  0
14E64:  CALL   545C
....................    strcat(data_buffer, endofline); 
14E68:  MOVLB  8
14E6A:  CLRF   xD5
14E6C:  MOVLW  63
14E6E:  MOVWF  xD4
14E70:  MOVLW  08
14E72:  MOVWF  xD7
14E74:  MOVLW  7E
14E76:  MOVWF  xD6
14E78:  MOVLB  0
14E7A:  CALL   545C
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
14E7E:  MOVF   1F,W
14E80:  SUBLW  04
14E82:  BNZ   14EA2
14E84:  MOVF   20,F
14E86:  BNZ   14EA2
14E88:  CLRF   FEA
14E8A:  MOVLW  63
14E8C:  MOVWF  FE9
14E8E:  CALL   78E6
14E92:  MOVLW  0D
14E94:  BTFSS  F9E.4
14E96:  BRA    14E94
14E98:  MOVWF  FAD
14E9A:  MOVLW  0A
14E9C:  BTFSS  F9E.4
14E9E:  BRA    14E9C
14EA0:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
14EA2:  MOVLB  2
14EA4:  MOVF   xD8,F
14EA6:  BNZ   14EFA
....................     
....................       buffer_select = 0; 
14EA8:  MOVLB  0
14EAA:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
14EAC:  MOVLB  8
14EAE:  CLRF   xC9
14EB0:  MOVLB  0
14EB2:  CALL   5500
....................          append_data(file_ptr_raw_all); 
14EB6:  MOVLW  02
14EB8:  MOVLB  8
14EBA:  MOVWF  xCA
14EBC:  MOVLW  D9
14EBE:  MOVWF  xC9
14EC0:  MOVLB  0
14EC2:  CALL   8242
....................       heartbeat(TRUE);          
14EC6:  MOVLW  01
14EC8:  MOVLB  8
14ECA:  MOVWF  xC9
14ECC:  MOVLB  0
14ECE:  CALL   5500
....................        
....................       heartbeat(FALSE); 
14ED2:  MOVLB  8
14ED4:  CLRF   xC9
14ED6:  MOVLB  0
14ED8:  CALL   5500
....................          append_data(file_ptr_raw_new);    
14EDC:  MOVLW  02
14EDE:  MOVLB  8
14EE0:  MOVWF  xCA
14EE2:  MOVLW  E7
14EE4:  MOVWF  xC9
14EE6:  MOVLB  0
14EE8:  CALL   8242
....................       heartbeat(TRUE); 
14EEC:  MOVLW  01
14EEE:  MOVLB  8
14EF0:  MOVWF  xC9
14EF2:  MOVLB  0
14EF4:  CALL   5500
14EF8:  MOVLB  2
....................    } 
14EFA:  MOVLB  0
14EFC:  GOTO   15098 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D074:  BSF    F90.7
....................    delay_ms(500); 
0D076:  MOVLW  02
0D078:  MOVLB  8
0D07A:  MOVWF  x9E
0D07C:  MOVLW  FA
0D07E:  MOVLB  9
0D080:  MOVWF  xC8
0D082:  MOVLB  0
0D084:  CALL   288E
0D088:  MOVLB  8
0D08A:  DECFSZ x9E,F
0D08C:  BRA    D07C
....................    bus_pwr_status=1; 
0D08E:  MOVLW  01
0D090:  MOVLB  4
0D092:  MOVWF  xB2
0D094:  MOVLB  0
0D096:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D098:  BCF    F90.7
....................    delay_ms(100); 
0D09A:  MOVLW  64
0D09C:  MOVLB  9
0D09E:  MOVWF  xC8
0D0A0:  MOVLB  0
0D0A2:  CALL   288E
....................    bus_pwr_status=0; 
0D0A6:  MOVLB  4
0D0A8:  CLRF   xB2
0D0AA:  MOVLB  0
0D0AC:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
17A6A:  MOVLB  8
17A6C:  CLRF   x73
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
17A6E:  CLRF   x73
17A70:  MOVF   x73,W
17A72:  SUBLW  31
17A74:  BNC   17A8A
....................       string_arg[i] = 0; 
17A76:  CLRF   03
17A78:  MOVF   x73,W
17A7A:  ADDLW  20
17A7C:  MOVWF  FE9
17A7E:  MOVLW  08
17A80:  ADDWFC 03,W
17A82:  MOVWF  FEA
17A84:  CLRF   FEF
17A86:  INCF   x73,F
17A88:  BRA    17A70
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
17A8A:  CLRF   x73
17A8C:  MOVF   x73,W
17A8E:  SUBLW  31
17A90:  BNC   17B0A
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
17A92:  CLRF   03
17A94:  MOVF   x73,W
17A96:  ADDLW  20
17A98:  MOVWF  FE9
17A9A:  MOVLW  08
17A9C:  ADDWFC 03,W
17A9E:  MOVWF  FEA
17AA0:  MOVFF  FEA,877
17AA4:  MOVFF  FE9,876
17AA8:  MOVLB  0
17AAA:  CALL   0E1A
17AAE:  MOVFF  877,FEA
17AB2:  MOVFF  876,FE9
17AB6:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
17ABA:  DECFSZ 48,W
17ABC:  BRA    17ADA
....................       { 
....................          fputc(string_arg[i],COM_A); 
17ABE:  CLRF   03
17AC0:  MOVLB  8
17AC2:  MOVF   x73,W
17AC4:  ADDLW  20
17AC6:  MOVWF  FE9
17AC8:  MOVLW  08
17ACA:  ADDWFC 03,W
17ACC:  MOVWF  FEA
17ACE:  MOVFF  FEF,874
17AD2:  MOVF   x74,W
17AD4:  MOVLB  0
17AD6:  CALL   ADBE
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
17ADA:  CLRF   03
17ADC:  MOVLB  8
17ADE:  MOVF   x73,W
17AE0:  ADDLW  20
17AE2:  MOVWF  FE9
17AE4:  MOVLW  08
17AE6:  ADDWFC 03,W
17AE8:  MOVWF  FEA
17AEA:  MOVF   FEF,W
17AEC:  SUBLW  0D
17AEE:  BZ    17B04
17AF0:  CLRF   03
17AF2:  MOVF   x73,W
17AF4:  ADDLW  20
17AF6:  MOVWF  FE9
17AF8:  MOVLW  08
17AFA:  ADDWFC 03,W
17AFC:  MOVWF  FEA
17AFE:  MOVF   FEF,W
17B00:  SUBLW  0A
17B02:  BNZ   17B06
....................       { 
....................          break; 
17B04:  BRA    17B0A
....................       } 
17B06:  INCF   x73,F
17B08:  BRA    17A8C
....................    } 
17B0A:  MOVLB  0
17B0C:  GOTO   17E34 (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
17CB2:  MOVLB  8
17CB4:  CLRF   x73
....................    macro_arg = 0; 
17CB6:  CLRF   x75
17CB8:  CLRF   x74
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
17CBA:  MOVF   x73,W
17CBC:  SUBLW  0D
17CBE:  BZ    17D4A
....................       number = fgetc(COM_A); 
17CC0:  MOVLB  0
17CC2:  CALL   0E1A
17CC6:  MOVFF  01,873
....................       if (com_echo == TRUE) 
17CCA:  DECFSZ 48,W
17CCC:  BRA    17CDE
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
17CCE:  MOVLB  8
17CD0:  MOVF   x73,W
17CD2:  SUBLW  0D
17CD4:  BZ    17CE0
17CD6:  MOVF   x73,W
17CD8:  MOVLB  0
17CDA:  CALL   ADBE
17CDE:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
17CE0:  MOVF   x73,W
17CE2:  SUBLW  2F
17CE4:  BC    17D1A
17CE6:  MOVF   x73,W
17CE8:  SUBLW  39
17CEA:  BNC   17D1A
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
17CEC:  MOVLW  30
17CEE:  SUBWF  x73,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
17CF0:  MOVFF  875,9E9
17CF4:  MOVFF  874,9E8
17CF8:  MOVLB  9
17CFA:  CLRF   xEB
17CFC:  MOVLW  0A
17CFE:  MOVWF  xEA
17D00:  MOVLB  0
17D02:  CALL   5C22
17D06:  MOVFF  02,875
17D0A:  MOVFF  01,874
....................          macro_arg = macro_arg + number;                // for each number 
17D0E:  MOVLB  8
17D10:  MOVF   x73,W
17D12:  ADDWF  x74,F
17D14:  MOVLW  00
17D16:  ADDWFC x75,F
....................       } 
17D18:  BRA    17D48
....................       else if (number == CARRIAGE_RET) 
17D1A:  MOVF   x73,W
17D1C:  SUBLW  0D
17D1E:  BNZ   17D40
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
17D20:  INCFSZ x74,W
17D22:  BRA    17D2A
17D24:  INCFSZ x75,W
17D26:  BRA    17D2A
17D28:  BRA    17D36
17D2A:  MOVFF  874,01
17D2E:  MOVFF  875,02
17D32:  BRA    17D4A
17D34:  BRA    17D3E
....................          else return(65535); 
17D36:  MOVLW  FF
17D38:  MOVWF  01
17D3A:  MOVWF  02
17D3C:  BRA    17D4A
....................       } 
17D3E:  BRA    17D48
....................       else 
....................       { 
....................          return(65535); 
17D40:  MOVLW  FF
17D42:  MOVWF  01
17D44:  MOVWF  02
17D46:  BRA    17D4A
....................       } 
17D48:  BRA    17CBA
....................    } 
17D4A:  MOVLB  0
17D4C:  GOTO   17E5E (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
177FA:  MOVF   2F,W
177FC:  MOVWF  00
177FE:  MOVF   30,W
17800:  MOVWF  03
17802:  BNZ   17808
17804:  MOVF   00,F
17806:  BZ    1782E
17808:  MOVF   03,W
1780A:  BNZ   17814
1780C:  MOVLW  03
1780E:  SUBWF  00,W
17810:  BTFSC  FD8.2
17812:  BRA    178EC
17814:  MOVF   03,W
17816:  BNZ   17820
17818:  MOVLW  01
1781A:  SUBWF  00,W
1781C:  BTFSC  FD8.2
1781E:  BRA    178EC
17820:  MOVF   03,W
17822:  BNZ   1782C
17824:  MOVLW  02
17826:  SUBWF  00,W
17828:  BTFSC  FD8.2
1782A:  BRA    17962
1782C:  BRA    179D0
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
1782E:  MOVLB  8
17830:  MOVF   x77,F
17832:  BNZ   17862
17834:  MOVF   x76,W
17836:  SUBLW  23
17838:  BZ    1785C
1783A:  MOVF   x76,W
1783C:  SUBLW  25
1783E:  BZ    1785C
17840:  MOVF   x76,W
17842:  SUBLW  3B
17844:  BZ    1785C
17846:  MOVF   x76,W
17848:  SUBLW  4D
1784A:  BZ    1785C
1784C:  MOVF   x76,W
1784E:  SUBLW  5A
17850:  BZ    1785C
17852:  MOVF   x76,W
17854:  SUBLW  72
17856:  BZ    1785C
17858:  MOVLW  00
1785A:  BRA    1785E
1785C:  MOVLW  01
1785E:  MOVWF  x78
17860:  BRA    178E8
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
17862:  MOVF   x76,W
17864:  SUBLW  23
17866:  BZ    178E4
17868:  MOVF   x76,W
1786A:  SUBLW  25
1786C:  BZ    178E4
1786E:  MOVF   x76,W
17870:  SUBLW  2B
17872:  BZ    178E4
17874:  MOVF   x76,W
17876:  SUBLW  2D
17878:  BZ    178E4
1787A:  MOVF   x76,W
1787C:  SUBLW  2F
1787E:  BZ    178E4
17880:  MOVF   x76,W
17882:  SUBLW  3B
17884:  BZ    178E4
17886:  MOVF   x76,W
17888:  SUBLW  41
1788A:  BZ    178E4
1788C:  MOVF   x76,W
1788E:  SUBLW  42
17890:  BC    17898
17892:  MOVF   x76,W
17894:  SUBLW  44
17896:  BC    178E4
17898:  MOVF   x76,W
1789A:  SUBLW  45
1789C:  BC    178A4
1789E:  MOVF   x76,W
178A0:  SUBLW  48
178A2:  BC    178E4
178A4:  MOVF   x76,W
178A6:  SUBLW  4A
178A8:  BC    178B0
178AA:  MOVF   x76,W
178AC:  SUBLW  4C
178AE:  BC    178E4
178B0:  MOVF   x76,W
178B2:  SUBLW  4F
178B4:  BC    178BC
178B6:  MOVF   x76,W
178B8:  SUBLW  55
178BA:  BC    178E4
178BC:  MOVF   x76,W
178BE:  SUBLW  59
178C0:  BZ    178E4
178C2:  MOVF   x76,W
178C4:  SUBLW  64
178C6:  BZ    178E4
178C8:  MOVF   x76,W
178CA:  SUBLW  69
178CC:  BZ    178E4
178CE:  MOVF   x76,W
178D0:  SUBLW  6C
178D2:  BZ    178E4
178D4:  MOVF   x76,W
178D6:  SUBLW  70
178D8:  BZ    178E4
178DA:  MOVF   x76,W
178DC:  SUBLW  72
178DE:  BZ    178E4
178E0:  MOVLW  00
178E2:  BRA    178E6
178E4:  MOVLW  01
178E6:  MOVWF  x78
....................          break; 
178E8:  MOVLB  0
178EA:  BRA    179D0
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
178EC:  MOVLB  8
178EE:  MOVF   x77,F
178F0:  BNZ   1791A
178F2:  MOVF   x76,W
178F4:  SUBLW  23
178F6:  BZ    17914
178F8:  MOVF   x76,W
178FA:  SUBLW  3B
178FC:  BZ    17914
178FE:  MOVF   x76,W
17900:  SUBLW  4A
17902:  BZ    17914
17904:  MOVF   x76,W
17906:  SUBLW  4D
17908:  BZ    17914
1790A:  MOVF   x76,W
1790C:  SUBLW  50
1790E:  BZ    17914
17910:  MOVLW  00
17912:  BRA    17916
17914:  MOVLW  01
17916:  MOVWF  x78
17918:  BRA    1795E
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
1791A:  MOVF   x76,W
1791C:  SUBLW  23
1791E:  BZ    1795A
17920:  MOVF   x76,W
17922:  SUBLW  2B
17924:  BZ    1795A
17926:  MOVF   x76,W
17928:  SUBLW  2D
1792A:  BZ    1795A
1792C:  MOVF   x76,W
1792E:  SUBLW  3B
17930:  BZ    1795A
17932:  MOVF   x76,W
17934:  SUBLW  42
17936:  BZ    1795A
17938:  MOVF   x76,W
1793A:  SUBLW  47
1793C:  BZ    1795A
1793E:  MOVF   x76,W
17940:  SUBLW  4F
17942:  BC    1794A
17944:  MOVF   x76,W
17946:  SUBLW  52
17948:  BC    1795A
1794A:  MOVF   x76,W
1794C:  SUBLW  54
1794E:  BZ    1795A
17950:  MOVF   x76,W
17952:  SUBLW  59
17954:  BZ    1795A
17956:  MOVLW  00
17958:  BRA    1795C
1795A:  MOVLW  01
1795C:  MOVWF  x78
....................          break;   
1795E:  MOVLB  0
17960:  BRA    179D0
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17962:  MOVLB  8
17964:  MOVF   x77,F
17966:  BNZ   1798A
17968:  MOVF   x76,W
1796A:  SUBLW  23
1796C:  BZ    17984
1796E:  MOVF   x76,W
17970:  SUBLW  3B
17972:  BZ    17984
17974:  MOVF   x76,W
17976:  SUBLW  4D
17978:  BZ    17984
1797A:  MOVF   x76,W
1797C:  SUBLW  50
1797E:  BZ    17984
17980:  MOVLW  00
17982:  BRA    17986
17984:  MOVLW  01
17986:  MOVWF  x78
17988:  BRA    179CE
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
1798A:  MOVF   x76,W
1798C:  SUBLW  23
1798E:  BZ    179CA
17990:  MOVF   x76,W
17992:  SUBLW  2B
17994:  BZ    179CA
17996:  MOVF   x76,W
17998:  SUBLW  2D
1799A:  BZ    179CA
1799C:  MOVF   x76,W
1799E:  SUBLW  3B
179A0:  BZ    179CA
179A2:  MOVF   x76,W
179A4:  SUBLW  42
179A6:  BC    179AE
179A8:  MOVF   x76,W
179AA:  SUBLW  44
179AC:  BC    179CA
179AE:  MOVF   x76,W
179B0:  SUBLW  4F
179B2:  BC    179BA
179B4:  MOVF   x76,W
179B6:  SUBLW  51
179B8:  BC    179CA
179BA:  MOVF   x76,W
179BC:  SUBLW  53
179BE:  BZ    179CA
179C0:  MOVF   x76,W
179C2:  SUBLW  59
179C4:  BZ    179CA
179C6:  MOVLW  00
179C8:  BRA    179CC
179CA:  MOVLW  01
179CC:  MOVWF  x78
....................          break;   
179CE:  MOVLB  0
....................    } 
....................    return(valid_macro); 
179D0:  MOVLB  8
179D2:  MOVFF  878,01
179D6:  MOVLB  0
179D8:  GOTO   17A04 (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
179DC:  MOVLW  01
179DE:  MOVLB  8
179E0:  MOVWF  x75
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
179E2:  MOVLB  0
179E4:  CALL   0E1A
179E8:  MOVFF  01,874
....................       if (com_echo == TRUE) fputc(e,COM_A); 
179EC:  DECFSZ 48,W
179EE:  BRA    179FA
179F0:  MOVLB  8
179F2:  MOVF   x74,W
179F4:  MOVLB  0
179F6:  CALL   ADBE
....................          valid_macro = check_macro(e, macro); 
179FA:  MOVFF  874,876
179FE:  MOVFF  873,877
17A02:  BRA    177FA
17A04:  MOVFF  01,875
....................       if (valid_macro == TRUE) { 
17A08:  MOVLB  8
17A0A:  DECFSZ x75,W
17A0C:  BRA    17A16
....................          return(e); 
17A0E:  MOVFF  874,01
17A12:  BRA    17A22
....................       } 
17A14:  BRA    17A1C
....................       else return(0); 
17A16:  MOVLW  00
17A18:  MOVWF  01
17A1A:  BRA    17A22
....................    } while (valid_macro == TRUE); 
17A1C:  DECFSZ x75,W
17A1E:  BRA    17A22
17A20:  BRA    179E2
17A22:  MOVLB  0
17A24:  GOTO   17E16 (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
17D9C:  BCF    FD8.0
17D9E:  MOVLB  8
17DA0:  RLCF   x76,W
17DA2:  CLRF   03
17DA4:  ADDLW  CC
17DA6:  MOVWF  FE9
17DA8:  MOVLW  07
17DAA:  ADDWFC 03,W
17DAC:  MOVWF  FEA
17DAE:  MOVFF  FEC,87C
17DB2:  MOVF   FED,F
17DB4:  MOVFF  FEF,87B
17DB8:  MOVFF  878,9E9
17DBC:  MOVFF  877,9E8
17DC0:  MOVLB  9
17DC2:  CLRF   xEB
17DC4:  MOVLW  03
17DC6:  MOVWF  xEA
17DC8:  MOVLB  0
17DCA:  CALL   5C22
17DCE:  MOVF   01,W
17DD0:  MOVLB  8
17DD2:  ADDWF  x7B,W
17DD4:  MOVWF  x79
17DD6:  MOVF   02,W
17DD8:  ADDWFC x7C,W
17DDA:  MOVWF  x7A
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
17DDC:  MOVFF  87A,884
17DE0:  MOVFF  879,883
17DE4:  MOVFF  873,885
17DE8:  MOVLB  0
17DEA:  RCALL  17B10
....................     
....................    ++addr; 
17DEC:  MOVLB  8
17DEE:  INCF   x79,F
17DF0:  BTFSC  FD8.2
17DF2:  INCF   x7A,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
17DF4:  MOVFF  87A,87C
17DF8:  MOVFF  879,87B
17DFC:  MOVFF  875,87E
17E00:  MOVFF  874,87D
17E04:  MOVLB  0
17E06:  BRA    17D50
17E08:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
17B70:  BCF    FD8.0
17B72:  MOVLB  8
17B74:  RLCF   x74,W
17B76:  CLRF   03
17B78:  ADDLW  CC
17B7A:  MOVWF  FE9
17B7C:  MOVLW  07
17B7E:  ADDWFC 03,W
17B80:  MOVWF  FEA
17B82:  MOVFF  FEC,87D
17B86:  MOVF   FED,F
17B88:  MOVFF  FEF,87C
17B8C:  MOVFF  876,9E9
17B90:  MOVFF  875,9E8
17B94:  MOVLB  9
17B96:  CLRF   xEB
17B98:  MOVLW  03
17B9A:  MOVWF  xEA
17B9C:  MOVLB  0
17B9E:  CALL   5C22
17BA2:  MOVF   01,W
17BA4:  MOVLB  8
17BA6:  ADDWF  x7C,W
17BA8:  MOVWF  x79
17BAA:  MOVF   02,W
17BAC:  ADDWFC x7D,W
17BAE:  MOVWF  x7A
....................    write_ext_eeprom(addr, macro_cmd); 
17BB0:  MOVFF  87A,884
17BB4:  MOVFF  879,883
17BB8:  MOVFF  873,885
17BBC:  MOVLB  0
17BBE:  RCALL  17B10
....................     
....................    int i = 0; 
17BC0:  MOVLB  8
17BC2:  CLRF   x7B
....................    addr = string_address[macro] + (count*50); 
17BC4:  BCF    FD8.0
17BC6:  RLCF   x74,W
17BC8:  CLRF   03
17BCA:  ADDLW  F6
17BCC:  MOVWF  FE9
17BCE:  MOVLW  07
17BD0:  ADDWFC 03,W
17BD2:  MOVWF  FEA
17BD4:  MOVFF  FEC,87D
17BD8:  MOVF   FED,F
17BDA:  MOVFF  FEF,87C
17BDE:  MOVFF  878,9E9
17BE2:  MOVFF  877,9E8
17BE6:  MOVLB  9
17BE8:  CLRF   xEB
17BEA:  MOVLW  32
17BEC:  MOVWF  xEA
17BEE:  MOVLB  0
17BF0:  CALL   5C22
17BF4:  MOVF   01,W
17BF6:  MOVLB  8
17BF8:  ADDWF  x7C,W
17BFA:  MOVWF  x79
17BFC:  MOVF   02,W
17BFE:  ADDWFC x7D,W
17C00:  MOVWF  x7A
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
17C02:  MOVF   x78,F
17C04:  BNZ   17C5A
17C06:  MOVF   x77,W
17C08:  SUBLW  14
17C0A:  BNC   17C5A
....................       for(i = 0; i<50; i++) { 
17C0C:  CLRF   x7B
17C0E:  MOVF   x7B,W
17C10:  SUBLW  31
17C12:  BNC   17C58
....................          write_ext_eeprom(addr + i, string_arg[i]); 
17C14:  MOVF   x7B,W
17C16:  ADDWF  x79,W
17C18:  MOVWF  x7C
17C1A:  MOVLW  00
17C1C:  ADDWFC x7A,W
17C1E:  MOVWF  x7D
17C20:  CLRF   03
17C22:  MOVF   x7B,W
17C24:  ADDLW  20
17C26:  MOVWF  FE9
17C28:  MOVLW  08
17C2A:  ADDWFC 03,W
17C2C:  MOVWF  FEA
17C2E:  MOVFF  FEF,885
17C32:  MOVFF  87D,884
17C36:  MOVFF  87C,883
17C3A:  MOVLB  0
17C3C:  RCALL  17B10
....................          if(string_arg[i] == 0){ 
17C3E:  CLRF   03
17C40:  MOVLB  8
17C42:  MOVF   x7B,W
17C44:  ADDLW  20
17C46:  MOVWF  FE9
17C48:  MOVLW  08
17C4A:  ADDWFC 03,W
17C4C:  MOVWF  FEA
17C4E:  MOVF   FEF,F
17C50:  BNZ   17C54
....................             break; 
17C52:  BRA    17C58
....................          } 
17C54:  INCF   x7B,F
17C56:  BRA    17C0E
....................       
....................       } 
....................    }else{ 
17C58:  BRA    17CAC
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
17C5A:  MOVLW  B4
17C5C:  MOVWF  FF6
17C5E:  MOVLW  20
17C60:  MOVWF  FF7
17C62:  MOVLW  00
17C64:  MOVWF  FF8
17C66:  CLRF   1B
17C68:  BTFSC  FF2.7
17C6A:  BSF    1B.7
17C6C:  BCF    FF2.7
17C6E:  MOVLW  1E
17C70:  MOVLB  A
17C72:  MOVWF  x18
17C74:  MOVLB  0
17C76:  CALL   1006
17C7A:  BTFSC  1B.7
17C7C:  BSF    FF2.7
17C7E:  MOVLW  10
17C80:  MOVWF  FE9
17C82:  CLRF   1B
17C84:  BTFSC  FF2.7
17C86:  BSF    1B.7
17C88:  BCF    FF2.7
17C8A:  MOVFF  876,A19
17C8E:  MOVFF  875,A18
17C92:  CALL   1188
17C96:  BTFSC  1B.7
17C98:  BSF    FF2.7
17C9A:  MOVLW  0A
17C9C:  BTFSS  F9E.4
17C9E:  BRA    17C9C
17CA0:  MOVWF  FAD
17CA2:  MOVLW  0D
17CA4:  BTFSS  F9E.4
17CA6:  BRA    17CA4
17CA8:  MOVWF  FAD
17CAA:  MOVLB  8
....................    } 
17CAC:  MOVLB  0
17CAE:  GOTO   17E4E (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
17FF2:  CALL   FFE4
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
17FF6:  MOVLW  3B
17FF8:  MOVLB  8
17FFA:  MOVWF  x73
17FFC:  CLRF   x75
17FFE:  CLRF   x74
18000:  CLRF   x76
18002:  CLRF   x78
18004:  CLRF   x77
18006:  MOVLB  0
18008:  RCALL  17D9C
....................     
....................    write_macro_line(59, 0, 1, 0); 
1800A:  MOVLW  3B
1800C:  MOVLB  8
1800E:  MOVWF  x73
18010:  CLRF   x75
18012:  CLRF   x74
18014:  MOVLW  01
18016:  MOVWF  x76
18018:  CLRF   x78
1801A:  CLRF   x77
1801C:  MOVLB  0
1801E:  RCALL  17D9C
....................    write_macro_line(59, 0, 2, 0); 
18020:  MOVLW  3B
18022:  MOVLB  8
18024:  MOVWF  x73
18026:  CLRF   x75
18028:  CLRF   x74
1802A:  MOVLW  02
1802C:  MOVWF  x76
1802E:  CLRF   x78
18030:  CLRF   x77
18032:  MOVLB  0
18034:  RCALL  17D9C
....................    write_macro_line(59, 0, 3, 0); 
18036:  MOVLW  3B
18038:  MOVLB  8
1803A:  MOVWF  x73
1803C:  CLRF   x75
1803E:  CLRF   x74
18040:  MOVLW  03
18042:  MOVWF  x76
18044:  CLRF   x78
18046:  CLRF   x77
18048:  MOVLB  0
1804A:  RCALL  17D9C
....................    write_macro_line(59, 0, 4, 0); 
1804C:  MOVLW  3B
1804E:  MOVLB  8
18050:  MOVWF  x73
18052:  CLRF   x75
18054:  CLRF   x74
18056:  MOVLW  04
18058:  MOVWF  x76
1805A:  CLRF   x78
1805C:  CLRF   x77
1805E:  MOVLB  0
18060:  RCALL  17D9C
....................    write_macro_line(59, 0, 5, 0); 
18062:  MOVLW  3B
18064:  MOVLB  8
18066:  MOVWF  x73
18068:  CLRF   x75
1806A:  CLRF   x74
1806C:  MOVLW  05
1806E:  MOVWF  x76
18070:  CLRF   x78
18072:  CLRF   x77
18074:  MOVLB  0
18076:  RCALL  17D9C
....................    write_macro_line(59, 0, 6, 0); 
18078:  MOVLW  3B
1807A:  MOVLB  8
1807C:  MOVWF  x73
1807E:  CLRF   x75
18080:  CLRF   x74
18082:  MOVLW  06
18084:  MOVWF  x76
18086:  CLRF   x78
18088:  CLRF   x77
1808A:  MOVLB  0
1808C:  RCALL  17D9C
....................    write_macro_line(59, 0, 7, 0); 
1808E:  MOVLW  3B
18090:  MOVLB  8
18092:  MOVWF  x73
18094:  CLRF   x75
18096:  CLRF   x74
18098:  MOVLW  07
1809A:  MOVWF  x76
1809C:  CLRF   x78
1809E:  CLRF   x77
180A0:  MOVLB  0
180A2:  RCALL  17D9C
....................    write_macro_line(59, 0, 8, 0); 
180A4:  MOVLW  3B
180A6:  MOVLB  8
180A8:  MOVWF  x73
180AA:  CLRF   x75
180AC:  CLRF   x74
180AE:  MOVLW  08
180B0:  MOVWF  x76
180B2:  CLRF   x78
180B4:  CLRF   x77
180B6:  MOVLB  0
180B8:  RCALL  17D9C
....................     
....................    write_macro_line(59, 0, 9, 0); 
180BA:  MOVLW  3B
180BC:  MOVLB  8
180BE:  MOVWF  x73
180C0:  CLRF   x75
180C2:  CLRF   x74
180C4:  MOVLW  09
180C6:  MOVWF  x76
180C8:  CLRF   x78
180CA:  CLRF   x77
180CC:  MOVLB  0
180CE:  RCALL  17D9C
....................    write_macro_line(59, 0, 10, 0); 
180D0:  MOVLW  3B
180D2:  MOVLB  8
180D4:  MOVWF  x73
180D6:  CLRF   x75
180D8:  CLRF   x74
180DA:  MOVLW  0A
180DC:  MOVWF  x76
180DE:  CLRF   x78
180E0:  CLRF   x77
180E2:  MOVLB  0
180E4:  RCALL  17D9C
....................    write_macro_line(59, 0, 11, 0); 
180E6:  MOVLW  3B
180E8:  MOVLB  8
180EA:  MOVWF  x73
180EC:  CLRF   x75
180EE:  CLRF   x74
180F0:  MOVLW  0B
180F2:  MOVWF  x76
180F4:  CLRF   x78
180F6:  CLRF   x77
180F8:  MOVLB  0
180FA:  RCALL  17D9C
....................    write_macro_line(59, 0, 12, 0); 
180FC:  MOVLW  3B
180FE:  MOVLB  8
18100:  MOVWF  x73
18102:  CLRF   x75
18104:  CLRF   x74
18106:  MOVLW  0C
18108:  MOVWF  x76
1810A:  CLRF   x78
1810C:  CLRF   x77
1810E:  MOVLB  0
18110:  RCALL  17D9C
....................    write_macro_line(59, 0, 13, 0); 
18112:  MOVLW  3B
18114:  MOVLB  8
18116:  MOVWF  x73
18118:  CLRF   x75
1811A:  CLRF   x74
1811C:  MOVLW  0D
1811E:  MOVWF  x76
18120:  CLRF   x78
18122:  CLRF   x77
18124:  MOVLB  0
18126:  RCALL  17D9C
....................    write_macro_line(59, 0, 14, 0); 
18128:  MOVLW  3B
1812A:  MOVLB  8
1812C:  MOVWF  x73
1812E:  CLRF   x75
18130:  CLRF   x74
18132:  MOVLW  0E
18134:  MOVWF  x76
18136:  CLRF   x78
18138:  CLRF   x77
1813A:  MOVLB  0
1813C:  RCALL  17D9C
....................    write_macro_line(59, 0, 15, 0); 
1813E:  MOVLW  3B
18140:  MOVLB  8
18142:  MOVWF  x73
18144:  CLRF   x75
18146:  CLRF   x74
18148:  MOVLW  0F
1814A:  MOVWF  x76
1814C:  CLRF   x78
1814E:  CLRF   x77
18150:  MOVLB  0
18152:  RCALL  17D9C
....................    write_macro_line(59, 0, 16, 0); 
18154:  MOVLW  3B
18156:  MOVLB  8
18158:  MOVWF  x73
1815A:  CLRF   x75
1815C:  CLRF   x74
1815E:  MOVLW  10
18160:  MOVWF  x76
18162:  CLRF   x78
18164:  CLRF   x77
18166:  MOVLB  0
18168:  RCALL  17D9C
1816A:  GOTO   181A2 (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
17A28:  MOVLB  8
17A2A:  CLRF   x73
....................     
....................    heartbeat(FALSE); 
17A2C:  CLRF   xC9
17A2E:  MOVLB  0
17A30:  CALL   5500
....................     
....................    while(mcc != CARRIAGE_RET){ 
17A34:  MOVLB  8
17A36:  MOVF   x73,W
17A38:  SUBLW  0D
17A3A:  BZ    17A5C
....................       if (kbhit(COM_A)) { 
17A3C:  BTFSS  F9E.5
17A3E:  BRA    17A5A
....................          mcc=fgetc(COM_A); 
17A40:  MOVLB  0
17A42:  CALL   0E1A
17A46:  MOVFF  01,873
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
17A4A:  DECFSZ 48,W
17A4C:  BRA    17A58
17A4E:  MOVLB  8
17A50:  MOVF   x73,W
17A52:  MOVLB  0
17A54:  CALL   ADBE
17A58:  MOVLB  8
....................       } 
17A5A:  BRA    17A36
....................    } 
....................     
....................    heartbeat(TRUE); 
17A5C:  MOVLW  01
17A5E:  MOVWF  xC9
17A60:  MOVLB  0
17A62:  CALL   5500
17A66:  GOTO   17E26 (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
17E0A:  MOVLB  8
17E0C:  CLRF   x72
....................     
....................    macro_cmd = get_cmd(macro); 
17E0E:  MOVFF  86A,873
17E12:  MOVLB  0
17E14:  BRA    179DC
17E16:  MOVFF  01,86F
....................    if (macro_cmd == 35){  
17E1A:  MOVLB  8
17E1C:  MOVF   x6F,W
17E1E:  SUBLW  23
17E20:  BNZ   17E2A
....................       macro_comment();        // # = 35 
17E22:  MOVLB  0
17E24:  BRA    17A28
....................    }else if(macro_cmd == 112){// 112 is p 
17E26:  BRA    17EAC
17E28:  MOVLB  8
17E2A:  MOVF   x6F,W
17E2C:  SUBLW  70
17E2E:  BNZ   17E56
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
17E30:  MOVLB  0
17E32:  BRA    17A6A
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
17E34:  MOVFF  86F,873
17E38:  MOVFF  86A,874
17E3C:  MOVFF  86C,876
17E40:  MOVFF  86B,875
17E44:  MOVFF  86E,878
17E48:  MOVFF  86D,877
17E4C:  BRA    17B70
....................       valid_macro = TRUE; 
17E4E:  MOVLW  01
17E50:  MOVLB  8
17E52:  MOVWF  x72
....................    }else{ 
17E54:  BRA    17EAA
....................       if (macro_cmd != 0) { 
17E56:  MOVF   x6F,F
17E58:  BZ    17E80
....................          macro_arg = get_arg(); 
17E5A:  MOVLB  0
17E5C:  BRA    17CB2
17E5E:  MOVFF  02,871
17E62:  MOVFF  01,870
....................          if (macro_arg != 65535) valid_macro = TRUE; 
17E66:  MOVLB  8
17E68:  INCFSZ x70,W
17E6A:  BRA    17E72
17E6C:  INCFSZ x71,W
17E6E:  BRA    17E72
17E70:  BRA    17E78
17E72:  MOVLW  01
17E74:  MOVWF  x72
17E76:  BRA    17E7E
....................          else return(macro_cmd); 
17E78:  MOVFF  86F,01
17E7C:  BRA    17EB2
....................       }else return(macro_cmd); 
17E7E:  BRA    17E86
17E80:  MOVFF  86F,01
17E84:  BRA    17EB2
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
17E86:  MOVFF  86F,873
17E8A:  MOVFF  871,875
17E8E:  MOVFF  870,874
17E92:  MOVFF  86A,876
17E96:  MOVFF  86C,878
17E9A:  MOVFF  86B,877
17E9E:  MOVLB  0
17EA0:  RCALL  17D9C
....................       return(macro_cmd); 
17EA2:  MOVLB  8
17EA4:  MOVFF  86F,01
17EA8:  BRA    17EB2
17EAA:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
17EAC:  MOVLB  8
17EAE:  MOVFF  86F,01
17EB2:  MOVLB  0
17EB4:  GOTO   17EFE (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
17EB8:  MOVLB  8
17EBA:  CLRF   x69
17EBC:  CLRF   x68
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
17EBE:  CLRF   x64
17EC0:  CLRF   x63
....................    valid_macro = TRUE; 
17EC2:  MOVLW  01
17EC4:  MOVWF  x65
....................    macro_cmd = 1; 
17EC6:  MOVWF  x66
....................    //macro_cmd2 holds value so macro_cmd doesn't get overwritten 
....................    macro_cmd2 = macro_cmd; 
17EC8:  MOVFF  866,867
....................     
....................    init_ext_eeprom(); 
17ECC:  MOVLB  0
17ECE:  CALL   FFE4
....................     
....................    fprintf(COM_A, ":"); 
17ED2:  MOVLW  3A
17ED4:  BTFSS  F9E.4
17ED6:  BRA    17ED4
17ED8:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd2 != 59 && macro_cmd2 != 0) {// changed -Fraser 6/23/17 
17EDA:  MOVLB  8
17EDC:  MOVF   x67,W
17EDE:  SUBLW  3B
17EE0:  BZ    17F44
17EE2:  MOVF   x67,F
17EE4:  BZ    17F44
....................     
....................       macro_cmd2 = get_macro_line(macro, line,count); 
17EE6:  MOVFF  862,86A
17EEA:  MOVFF  864,86C
17EEE:  MOVFF  863,86B
17EF2:  MOVFF  869,86E
17EF6:  MOVFF  868,86D
17EFA:  MOVLB  0
17EFC:  BRA    17E0A
17EFE:  MOVFF  01,867
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd2 == 'p'){ 
17F02:  MOVLB  8
17F04:  MOVF   x67,W
17F06:  SUBLW  70
17F08:  BNZ   17F10
....................          count++; 
17F0A:  INCF   x68,F
17F0C:  BTFSC  FD8.2
17F0E:  INCF   x69,F
....................       } 
....................       if (macro_cmd2 != 35) ++line; 
17F10:  MOVF   x67,W
17F12:  SUBLW  23
17F14:  BZ    17F1C
17F16:  INCF   x63,F
17F18:  BTFSC  FD8.2
17F1A:  INCF   x64,F
....................       if (macro_cmd2 != 59) printf("\r\n:"); 
17F1C:  MOVF   x67,W
17F1E:  SUBLW  3B
17F20:  BZ    17F42
17F22:  MOVLW  D8
17F24:  MOVWF  FF6
17F26:  MOVLW  20
17F28:  MOVWF  FF7
17F2A:  MOVLW  00
17F2C:  MOVWF  FF8
17F2E:  CLRF   1B
17F30:  BTFSC  FF2.7
17F32:  BSF    1B.7
17F34:  BCF    FF2.7
17F36:  MOVLB  0
17F38:  CALL   0E30
17F3C:  BTFSC  1B.7
17F3E:  BSF    FF2.7
17F40:  MOVLB  8
17F42:  BRA    17EDC
....................    }       
....................    if (macro_cmd2 == 0){ 
17F44:  MOVF   x67,F
17F46:  BNZ   17FDC
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
17F48:  MOVLW  DC
17F4A:  MOVWF  FF6
17F4C:  MOVLW  20
17F4E:  MOVWF  FF7
17F50:  MOVLW  00
17F52:  MOVWF  FF8
17F54:  CLRF   1B
17F56:  BTFSC  FF2.7
17F58:  BSF    1B.7
17F5A:  BCF    FF2.7
17F5C:  MOVLB  0
17F5E:  CALL   0E30
17F62:  BTFSC  1B.7
17F64:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
17F66:  MOVLW  04
17F68:  MOVWF  FF6
17F6A:  MOVLW  21
17F6C:  MOVWF  FF7
17F6E:  MOVLW  00
17F70:  MOVWF  FF8
17F72:  CLRF   1B
17F74:  BTFSC  FF2.7
17F76:  BSF    1B.7
17F78:  BCF    FF2.7
17F7A:  MOVLW  15
17F7C:  MOVLB  A
17F7E:  MOVWF  x18
17F80:  MOVLB  0
17F82:  CALL   1006
17F86:  BTFSC  1B.7
17F88:  BSF    FF2.7
17F8A:  MOVLW  10
17F8C:  MOVWF  FE9
17F8E:  MOVFF  864,8CD
17F92:  MOVFF  863,8CC
17F96:  CALL   8F2E
17F9A:  MOVLW  1C
17F9C:  MOVWF  FF6
17F9E:  MOVLW  21
17FA0:  MOVWF  FF7
17FA2:  MOVLW  00
17FA4:  MOVWF  FF8
17FA6:  CLRF   1B
17FA8:  BTFSC  FF2.7
17FAA:  BSF    1B.7
17FAC:  BCF    FF2.7
17FAE:  MOVLW  03
17FB0:  MOVLB  A
17FB2:  MOVWF  x18
17FB4:  MOVLB  0
17FB6:  CALL   1006
17FBA:  BTFSC  1B.7
17FBC:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
17FBE:  MOVLW  20
17FC0:  MOVWF  FF6
17FC2:  MOVLW  21
17FC4:  MOVWF  FF7
17FC6:  MOVLW  00
17FC8:  MOVWF  FF8
17FCA:  CLRF   1B
17FCC:  BTFSC  FF2.7
17FCE:  BSF    1B.7
17FD0:  BCF    FF2.7
17FD2:  CALL   0E30
17FD6:  BTFSC  1B.7
17FD8:  BSF    FF2.7
17FDA:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
17FDC:  MOVLW  0D
17FDE:  BTFSS  F9E.4
17FE0:  BRA    17FDE
17FE2:  MOVWF  FAD
17FE4:  MOVLW  0A
17FE6:  BTFSS  F9E.4
17FE8:  BRA    17FE6
17FEA:  MOVWF  FAD
17FEC:  MOVLB  0
17FEE:  GOTO   1818A (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
181AC:  BCF    FD8.0
181AE:  MOVLB  8
181B0:  RLCF   x67,W
181B2:  CLRF   03
181B4:  ADDLW  CC
181B6:  MOVWF  FE9
181B8:  MOVLW  07
181BA:  ADDWFC 03,W
181BC:  MOVWF  FEA
181BE:  MOVFF  FEC,870
181C2:  MOVF   FED,F
181C4:  MOVFF  FEF,86F
181C8:  MOVFF  869,9E9
181CC:  MOVFF  868,9E8
181D0:  MOVLB  9
181D2:  CLRF   xEB
181D4:  MOVLW  03
181D6:  MOVWF  xEA
181D8:  MOVLB  0
181DA:  CALL   5C22
181DE:  MOVF   01,W
181E0:  MOVLB  8
181E2:  ADDWF  x6F,W
181E4:  MOVWF  x6A
181E6:  MOVF   02,W
181E8:  ADDWFC x70,W
181EA:  MOVWF  x6B
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
181EC:  MOVFF  86B,8A8
181F0:  MOVFF  86A,8A7
181F4:  MOVLB  0
181F6:  CALL   102F0
181FA:  MOVFF  01,86C
....................    ++addr; 
181FE:  MOVLB  8
18200:  INCF   x6A,F
18202:  BTFSC  FD8.2
18204:  INCF   x6B,F
....................    macro_arg = read16_ext_eeprom(addr); 
18206:  MOVFF  86B,89F
1820A:  MOVFF  86A,89E
1820E:  MOVLB  0
18210:  CALL   10404
18214:  MOVFF  02,86E
18218:  MOVFF  01,86D
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
1821C:  MOVLB  8
1821E:  MOVF   x6C,W
18220:  BTFSS  F9E.4
18222:  BRA    18220
18224:  MOVWF  FAD
18226:  MOVLW  10
18228:  MOVWF  FE9
1822A:  CLRF   1B
1822C:  BTFSC  FF2.7
1822E:  BSF    1B.7
18230:  BCF    FF2.7
18232:  MOVFF  86E,A19
18236:  MOVFF  86D,A18
1823A:  MOVLB  0
1823C:  CALL   1188
18240:  BTFSC  1B.7
18242:  BSF    FF2.7
18244:  MOVLW  0D
18246:  BTFSS  F9E.4
18248:  BRA    18246
1824A:  MOVWF  FAD
1824C:  MOVLW  0A
1824E:  BTFSS  F9E.4
18250:  BRA    1824E
18252:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
18254:  MOVLB  8
18256:  MOVFF  86C,01
1825A:  MOVLB  0
1825C:  GOTO   18290 (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
13EA6:  BCF    FD8.0
13EA8:  MOVLB  8
13EAA:  RLCF   x93,W
13EAC:  CLRF   03
13EAE:  ADDLW  CC
13EB0:  MOVWF  FE9
13EB2:  MOVLW  07
13EB4:  ADDWFC 03,W
13EB6:  MOVWF  FEA
13EB8:  MOVFF  FEC,89C
13EBC:  MOVF   FED,F
13EBE:  MOVFF  FEF,89B
13EC2:  MOVFF  895,9E9
13EC6:  MOVFF  894,9E8
13ECA:  MOVLB  9
13ECC:  CLRF   xEB
13ECE:  MOVLW  03
13ED0:  MOVWF  xEA
13ED2:  MOVLB  0
13ED4:  CALL   5C22
13ED8:  MOVF   01,W
13EDA:  MOVLB  8
13EDC:  ADDWF  x9B,W
13EDE:  MOVWF  x96
13EE0:  MOVF   02,W
13EE2:  ADDWFC x9C,W
13EE4:  MOVWF  x97
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
13EE6:  MOVFF  897,8A8
13EEA:  MOVFF  896,8A7
13EEE:  MOVLB  0
13EF0:  CALL   102F0
13EF4:  MOVFF  01,898
....................    ++addr; 
13EF8:  MOVLB  8
13EFA:  INCF   x96,F
13EFC:  BTFSC  FD8.2
13EFE:  INCF   x97,F
....................    macro_arg = read16_ext_eeprom(addr); 
13F00:  MOVFF  897,89F
13F04:  MOVFF  896,89E
13F08:  MOVLB  0
13F0A:  CALL   10404
13F0E:  MOVFF  02,89A
13F12:  MOVFF  01,899
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
13F16:  MOVLB  8
13F18:  MOVF   x98,W
13F1A:  BTFSS  F9E.4
13F1C:  BRA    13F1A
13F1E:  MOVWF  FAD
13F20:  MOVLW  10
13F22:  MOVWF  FE9
13F24:  CLRF   1B
13F26:  BTFSC  FF2.7
13F28:  BSF    1B.7
13F2A:  BCF    FF2.7
13F2C:  MOVFF  89A,A19
13F30:  MOVFF  899,A18
13F34:  MOVLB  0
13F36:  CALL   1188
13F3A:  BTFSC  1B.7
13F3C:  BSF    FF2.7
13F3E:  MOVLW  0D
13F40:  BTFSS  F9E.4
13F42:  BRA    13F40
13F44:  MOVWF  FAD
13F46:  MOVLW  0A
13F48:  BTFSS  F9E.4
13F4A:  BRA    13F48
13F4C:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
13F4E:  MOVLB  8
13F50:  MOVFF  898,01
13F54:  MOVLB  0
13F56:  GOTO   1472E (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
1034A:  BCF    FD8.0
1034C:  MOVLB  8
1034E:  RLCF   x91,W
10350:  CLRF   03
10352:  ADDLW  F6
10354:  MOVWF  FE9
10356:  MOVLW  07
10358:  ADDWFC 03,W
1035A:  MOVWF  FEA
1035C:  MOVFF  FEC,89A
10360:  MOVF   FED,F
10362:  MOVFF  FEF,899
10366:  MOVFF  895,9E9
1036A:  MOVFF  894,9E8
1036E:  MOVLB  9
10370:  CLRF   xEB
10372:  MOVLW  32
10374:  MOVWF  xEA
10376:  MOVLB  0
10378:  CALL   5C22
1037C:  MOVF   01,W
1037E:  MOVLB  8
10380:  ADDWF  x99,W
10382:  MOVWF  x96
10384:  MOVF   02,W
10386:  ADDWFC x9A,W
10388:  MOVWF  x97
....................     
....................    int i = 0; 
1038A:  CLRF   x98
....................    for(i = 0; i < 50; i++){ 
1038C:  CLRF   x98
1038E:  MOVF   x98,W
10390:  SUBLW  31
10392:  BNC   103A8
....................       string_arg[i] = 0; 
10394:  CLRF   03
10396:  MOVF   x98,W
10398:  ADDLW  20
1039A:  MOVWF  FE9
1039C:  MOVLW  08
1039E:  ADDWFC 03,W
103A0:  MOVWF  FEA
103A2:  CLRF   FEF
103A4:  INCF   x98,F
103A6:  BRA    1038E
....................    }  
....................    for(i = 0; i < 50; i++){ 
103A8:  CLRF   x98
103AA:  MOVF   x98,W
103AC:  SUBLW  31
103AE:  BNC   10400
....................       string_arg[i] = read_ext_eeprom(addr + i); 
103B0:  CLRF   03
103B2:  MOVF   x98,W
103B4:  ADDLW  20
103B6:  MOVWF  01
103B8:  MOVLW  08
103BA:  ADDWFC 03,F
103BC:  MOVFF  01,899
103C0:  MOVFF  03,89A
103C4:  MOVF   x98,W
103C6:  ADDWF  x96,W
103C8:  MOVWF  x9B
103CA:  MOVLW  00
103CC:  ADDWFC x97,W
103CE:  MOVWF  x9C
103D0:  MOVWF  xA8
103D2:  MOVFF  89B,8A7
103D6:  MOVLB  0
103D8:  RCALL  102F0
103DA:  MOVFF  89A,FEA
103DE:  MOVFF  899,FE9
103E2:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
103E6:  CLRF   03
103E8:  MOVLB  8
103EA:  MOVF   x98,W
103EC:  ADDLW  20
103EE:  MOVWF  FE9
103F0:  MOVLW  08
103F2:  ADDWFC 03,W
103F4:  MOVWF  FEA
103F6:  MOVF   FEF,F
103F8:  BNZ   103FC
....................          break; 
103FA:  BRA    10400
....................       } 
103FC:  INCF   x98,F
103FE:  BRA    103AA
....................    }   
10400:  MOVLB  0
10402:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
18260:  MOVLB  8
18262:  CLRF   x66
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
18264:  CLRF   x64
18266:  CLRF   x63
....................    macro_cmd = 1; 
18268:  MOVLW  01
1826A:  MOVWF  x65
....................     
....................    init_ext_eeprom(); 
1826C:  MOVLB  0
1826E:  CALL   FFE4
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
18272:  MOVLB  8
18274:  MOVF   x64,W
18276:  SUBLW  03
18278:  BNC   182C0
1827A:  MOVF   x65,W
1827C:  SUBLW  3B
1827E:  BZ    182C0
....................       macro_cmd = read_macro_line(macro, line); 
18280:  MOVFF  862,867
18284:  MOVFF  864,869
18288:  MOVFF  863,868
1828C:  MOVLB  0
1828E:  BRA    181AC
18290:  MOVFF  01,865
....................       if(macro_cmd == 'p'){ 
18294:  MOVLB  8
18296:  MOVF   x65,W
18298:  SUBLW  70
1829A:  BNZ   182B8
....................          read_macro_line_string(macro,line,count); 
1829C:  MOVFF  862,891
182A0:  MOVFF  864,893
182A4:  MOVFF  863,892
182A8:  CLRF   x95
182AA:  MOVFF  866,894
182AE:  MOVLB  0
182B0:  CALL   1034A
....................          count++; 
182B4:  MOVLB  8
182B6:  INCF   x66,F
....................       } 
....................       ++line; 
182B8:  INCF   x63,F
182BA:  BTFSC  FD8.2
182BC:  INCF   x64,F
182BE:  BRA    18274
....................    } 
182C0:  MOVLB  0
182C2:  GOTO   182E2 (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D03E:  MOVLB  8
0D040:  CLRF   xA1
0D042:  CLRF   xA0
0D044:  MOVF   xA1,W
0D046:  SUBWF  x9F,W
0D048:  BNC   D070
0D04A:  BNZ   D052
0D04C:  MOVF   x9E,W
0D04E:  SUBWF  xA0,W
0D050:  BC    D070
....................       delay_ms(1000); 
0D052:  MOVLW  04
0D054:  MOVWF  xA2
0D056:  MOVLW  FA
0D058:  MOVLB  9
0D05A:  MOVWF  xC8
0D05C:  MOVLB  0
0D05E:  CALL   288E
0D062:  MOVLB  8
0D064:  DECFSZ xA2,F
0D066:  BRA    D056
0D068:  INCF   xA0,F
0D06A:  BTFSC  FD8.2
0D06C:  INCF   xA1,F
0D06E:  BRA    D044
....................    }  
0D070:  MOVLB  0
0D072:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0D006:  BCF    FD8.0
0D008:  MOVLB  7
0D00A:  RLCF   x3C,W
0D00C:  CLRF   03
0D00E:  ADDLW  92
0D010:  MOVWF  FE9
0D012:  MOVLW  07
0D014:  ADDWFC 03,W
0D016:  MOVWF  FEA
0D018:  MOVFF  FEC,8A0
0D01C:  MOVF   FED,F
0D01E:  MOVFF  FEF,89F
0D022:  MOVLB  8
0D024:  DECFSZ x9F,W
0D026:  BRA    D032
0D028:  MOVF   xA0,F
0D02A:  BNZ   D032
....................    { 
....................       macro_status = 'e'; 
0D02C:  MOVLW  65
0D02E:  MOVWF  x9E
....................    } 
0D030:  BRA    D036
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D032:  MOVLW  61
0D034:  MOVWF  x9E
....................    } 
....................    return(macro_status); 
0D036:  MOVFF  89E,01
0D03A:  MOVLB  0
0D03C:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
13542:  DECFSZ 41,W
13544:  BRA    13558
13546:  MOVF   42,F
13548:  BNZ   13558
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
1354A:  MOVLW  01
1354C:  MOVLB  8
1354E:  MOVWF  x9E
13550:  MOVWF  x9F
13552:  MOVLB  0
13554:  RCALL  1340C
....................    } 
13556:  BRA    13582
....................    else if(nv_det_type==2 || nv_det_type==3) 
13558:  MOVF   41,W
1355A:  SUBLW  02
1355C:  BNZ   13562
1355E:  MOVF   42,F
13560:  BZ    1356C
13562:  MOVF   41,W
13564:  SUBLW  03
13566:  BNZ   13582
13568:  MOVF   42,F
1356A:  BNZ   13582
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
1356C:  MOVLB  8
1356E:  CLRF   x9F
13570:  MOVLW  C8
13572:  MOVWF  x9E
13574:  MOVLW  01
13576:  MOVWF  xA0
13578:  MOVWF  xA1
1357A:  CLRF   xA2
1357C:  MOVLB  0
1357E:  CALL   FCFA
....................    } 
13582:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
12460:  DECFSZ 41,W
12462:  BRA    1247E
12464:  MOVF   42,F
12466:  BNZ   1247E
....................       cmd = macro_cmd; 
12468:  MOVFF  89E,43
....................       arg = macro_arg; 
1246C:  CLRF   47
1246E:  CLRF   46
12470:  MOVFF  8A0,45
12474:  MOVFF  89F,44
....................       det_cmd(); 
12478:  CALL   F102
....................    } 
1247C:  BRA    12498
....................    else if(nv_det_type==2 || nv_det_type==3) { 
1247E:  MOVF   41,W
12480:  SUBLW  02
12482:  BNZ   12488
12484:  MOVF   42,F
12486:  BZ    12492
12488:  MOVF   41,W
1248A:  SUBLW  03
1248C:  BNZ   12498
1248E:  MOVF   42,F
12490:  BNZ   12498
....................       set_heaters(macro_arg); 
12492:  MOVFF  89F,8A1
12496:  RCALL  123EC
....................    } 
12498:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
1249A:  DECFSZ 41,W
1249C:  BRA    124B8
1249E:  MOVF   42,F
124A0:  BNZ   124B8
....................       cmd = macro_cmd; 
124A2:  MOVFF  89E,43
....................       arg = macro_arg; 
124A6:  CLRF   47
124A8:  CLRF   46
124AA:  MOVFF  8A0,45
124AE:  MOVFF  89F,44
....................       det_cmd(); 
124B2:  CALL   F102
....................    } 
124B6:  BRA    124D8
....................    else if(nv_det_type==2 || nv_det_type==3) { 
124B8:  MOVF   41,W
124BA:  SUBLW  02
124BC:  BNZ   124C2
124BE:  MOVF   42,F
124C0:  BZ    124CC
124C2:  MOVF   41,W
124C4:  SUBLW  03
124C6:  BNZ   124D8
124C8:  MOVF   42,F
124CA:  BNZ   124D8
....................       set_LED(macro_arg); 
124CC:  MOVFF  8A0,8A2
124D0:  MOVFF  89F,8A1
124D4:  CALL   F5B8
....................    } 
124D8:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13ABA:  MOVLW  65
13ABC:  MOVLB  8
13ABE:  MOVWF  x9D
....................     
....................    addr = macro_address[macro] + (line*3); 
13AC0:  BCF    FD8.0
13AC2:  RLCF   x93,W
13AC4:  CLRF   03
13AC6:  ADDLW  CC
13AC8:  MOVWF  FE9
13ACA:  MOVLW  07
13ACC:  ADDWFC 03,W
13ACE:  MOVWF  FEA
13AD0:  MOVFF  FEC,89F
13AD4:  MOVF   FED,F
13AD6:  MOVFF  FEF,89E
13ADA:  MOVFF  895,9E9
13ADE:  MOVFF  894,9E8
13AE2:  MOVLB  9
13AE4:  CLRF   xEB
13AE6:  MOVLW  03
13AE8:  MOVWF  xEA
13AEA:  MOVLB  0
13AEC:  CALL   5C22
13AF0:  MOVF   01,W
13AF2:  MOVLB  8
13AF4:  ADDWF  x9E,W
13AF6:  MOVWF  x98
13AF8:  MOVF   02,W
13AFA:  ADDWFC x9F,W
13AFC:  MOVWF  x99
....................  
....................    init_ext_eeprom(); 
13AFE:  MOVLB  0
13B00:  CALL   FFE4
....................    macro_cmd = read_ext_eeprom(addr); 
13B04:  MOVFF  899,8A8
13B08:  MOVFF  898,8A7
13B0C:  CALL   102F0
13B10:  MOVFF  01,89A
....................    ++addr; 
13B14:  MOVLB  8
13B16:  INCF   x98,F
13B18:  BTFSC  FD8.2
13B1A:  INCF   x99,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13B1C:  MOVFF  899,89F
13B20:  MOVFF  898,89E
13B24:  MOVLB  0
13B26:  CALL   10404
13B2A:  MOVFF  02,89C
13B2E:  MOVFF  01,89B
....................    //} 
....................    heartbeat(TRUE); 
13B32:  MOVLW  01
13B34:  MOVLB  8
13B36:  MOVWF  xC9
13B38:  MOVLB  0
13B3A:  CALL   5500
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13B3E:  MOVF   2F,F
13B40:  BTFSS  FD8.2
13B42:  BRA    13DEE
13B44:  MOVF   30,F
13B46:  BTFSS  FD8.2
13B48:  BRA    13DEE
....................       switch(macro_cmd) 
13B4A:  MOVLW  2B
13B4C:  MOVLB  8
13B4E:  SUBWF  x9A,W
13B50:  ADDLW  BA
13B52:  BTFSC  FD8.0
13B54:  BRA    13DF0
13B56:  ADDLW  46
13B58:  MOVLB  0
13B5A:  GOTO   13DFA
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13B5E:  CALL   1227A
....................             store_rel_data(); 
13B62:  CALL   122DE
....................             macro_status = 'a'; 
13B66:  MOVLW  61
13B68:  MOVLB  8
13B6A:  MOVWF  x9D
....................             break; 
13B6C:  BRA    13DF0
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
13B6E:  MOVLW  08
13B70:  MOVWF  FEA
13B72:  MOVLW  20
13B74:  MOVWF  FE9
13B76:  CALL   78E6
13B7A:  MOVLW  0D
13B7C:  BTFSS  F9E.4
13B7E:  BRA    13B7C
13B80:  MOVWF  FAD
13B82:  MOVLW  0A
13B84:  BTFSS  F9E.4
13B86:  BRA    13B84
13B88:  MOVWF  FAD
....................             macro_status = 'a'; 
13B8A:  MOVLW  61
13B8C:  MOVLB  8
13B8E:  MOVWF  x9D
....................             break; 
13B90:  BRA    13DF0
....................          case 'C' : 
....................             calc_abs_data(); 
13B92:  CALL   1227A
....................             break; 
13B96:  MOVLB  8
13B98:  BRA    13DF0
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
13B9A:  MOVFF  89C,89F
13B9E:  MOVFF  89B,89E
13BA2:  CALL   D03E
....................             macro_status = 'a'; 
13BA6:  MOVLW  61
13BA8:  MOVLB  8
13BAA:  MOVWF  x9D
....................             break; 
13BAC:  BRA    13DF0
....................          case 'F' : macro_flag = macro_arg; 
13BAE:  MOVFF  89C,320
13BB2:  MOVFF  89B,31F
....................                     macro_status = 'a'; 
13BB6:  MOVLW  61
13BB8:  MOVLB  8
13BBA:  MOVWF  x9D
....................             break ; 
13BBC:  BRA    13DF0
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
13BBE:  MOVFF  89B,2D1
....................                     macro_status = 'a'; 
13BC2:  MOVLW  61
13BC4:  MOVLB  8
13BC6:  MOVWF  x9D
....................             break ; 
13BC8:  BRA    13DF0
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
13BCA:  MOVFF  89A,89E
13BCE:  MOVFF  89C,8A0
13BD2:  MOVFF  89B,89F
13BD6:  CALL   12460
....................                     macro_status = 'a'; 
13BDA:  MOVLW  61
13BDC:  MOVLB  8
13BDE:  MOVWF  x9D
....................             break; 
13BE0:  BRA    13DF0
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
13BE2:  MOVFF  89A,89E
13BE6:  MOVFF  89C,8A0
13BEA:  MOVFF  89B,89F
13BEE:  CALL   12460
....................                     macro_status = 'a'; 
13BF2:  MOVLW  61
13BF4:  MOVLB  8
13BF6:  MOVWF  x9D
....................             break; 
13BF8:  BRA    13DF0
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
13BFA:  MOVFF  89C,8B8
13BFE:  MOVFF  89B,8B7
13C02:  MOVLB  8
13C04:  CLRF   xBA
13C06:  MOVLW  64
13C08:  MOVWF  xB9
13C0A:  MOVLB  0
13C0C:  CALL   2C52
13C10:  MOVFF  02,749
13C14:  MOVFF  01,748
....................                     macro_status = 'a'; 
13C18:  MOVLW  61
13C1A:  MOVLB  8
13C1C:  MOVWF  x9D
....................             break;    
13C1E:  BRA    13DF0
....................          case 'l' : LightTargetFlag = 1; 
13C20:  MOVLW  01
13C22:  MOVLB  2
13C24:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
13C26:  MOVFF  89A,89E
13C2A:  MOVFF  89C,8A0
13C2E:  MOVFF  89B,89F
13C32:  MOVLB  0
13C34:  CALL   1249A
....................                     delay_ms(10000); 
13C38:  MOVLW  28
13C3A:  MOVLB  8
13C3C:  MOVWF  x9E
13C3E:  MOVLW  FA
13C40:  MOVLB  9
13C42:  MOVWF  xC8
13C44:  MOVLB  0
13C46:  CALL   288E
13C4A:  MOVLB  8
13C4C:  DECFSZ x9E,F
13C4E:  BRA    13C3E
....................                     macro_status = 'a'; 
13C50:  MOVLW  61
13C52:  MOVWF  x9D
....................             break;        
13C54:  BRA    13DF0
....................          case 'L' : LightTargetFlag = 0; 
13C56:  MOVLB  2
13C58:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
13C5A:  MOVFF  89A,89E
13C5E:  MOVFF  89C,8A0
13C62:  MOVFF  89B,89F
13C66:  MOVLB  0
13C68:  CALL   1249A
....................                     macro_status = 'a'; 
13C6C:  MOVLW  61
13C6E:  MOVLB  8
13C70:  MOVWF  x9D
....................             break; 
13C72:  BRA    13DF0
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
13C74:  MOVFF  89A,43
....................                     arg = macro_arg; 
13C78:  CLRF   47
13C7A:  CLRF   46
13C7C:  MOVFF  89C,45
13C80:  MOVFF  89B,44
....................                     det_cmd(); 
13C84:  CALL   F102
....................                     macro_status = 'a'; 
13C88:  MOVLW  61
13C8A:  MOVLB  8
13C8C:  MOVWF  x9D
....................             break ; 
13C8E:  BRA    13DF0
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
13C90:  MOVLB  8
13C92:  DECFSZ x9B,W
13C94:  BRA    13CA0
13C96:  MOVF   x9C,F
13C98:  BNZ   13CA0
13C9A:  MOVLB  0
13C9C:  RCALL  13542
13C9E:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
13CA0:  MOVF   x9B,W
13CA2:  SUBLW  02
13CA4:  BNZ   13CB6
13CA6:  MOVF   x9C,F
13CA8:  BNZ   13CB6
13CAA:  MOVLW  01
13CAC:  MOVWF  x9E
13CAE:  MOVWF  x9F
13CB0:  MOVLB  0
13CB2:  RCALL  1370E
13CB4:  MOVLB  8
....................                     macro_status = 'a'; 
13CB6:  MOVLW  61
13CB8:  MOVWF  x9D
....................             break ;  
13CBA:  BRA    13DF0
....................          case 'T' : det_temp(); 
13CBC:  RCALL  138CE
....................                     macro_status = 'a'; 
13CBE:  MOVLW  61
13CC0:  MOVLB  8
13CC2:  MOVWF  x9D
....................             break; 
13CC4:  BRA    13DF0
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
13CC6:  MOVLW  01
13CC8:  MOVLB  7
13CCA:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
13CCC:  MOVLB  8
13CCE:  CLRF   xA3
13CD0:  CLRF   xA4
13CD2:  CLRF   xA8
13CD4:  CLRF   xA7
13CD6:  MOVFF  89C,8A6
13CDA:  MOVFF  89B,8A5
13CDE:  MOVWF  xA9
13CE0:  MOVLB  0
13CE2:  CALL   9CC2
....................                     macro_status=step_err_status(); 
13CE6:  CALL   D006
13CEA:  MOVFF  01,89D
....................             break; 
13CEE:  MOVLB  8
13CF0:  BRA    13DF0
....................          case '-' : motor=1; 
13CF2:  MOVLW  01
13CF4:  MOVLB  7
13CF6:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
13CF8:  MOVLB  8
13CFA:  CLRF   xA3
13CFC:  MOVWF  xA4
13CFE:  CLRF   xA8
13D00:  CLRF   xA7
13D02:  MOVFF  89C,8A6
13D06:  MOVFF  89B,8A5
13D0A:  MOVWF  xA9
13D0C:  MOVLB  0
13D0E:  CALL   9CC2
....................                     macro_status=step_err_status(); 
13D12:  CALL   D006
13D16:  MOVFF  01,89D
....................             break; 
13D1A:  MOVLB  8
13D1C:  BRA    13DF0
....................          case 'G' : motor=0; 
13D1E:  MOVLB  7
13D20:  CLRF   x3C
....................                     align(0); 
13D22:  MOVLB  8
13D24:  CLRF   x9E
13D26:  MOVLB  0
13D28:  CALL   A7FE
....................                     macro_status=step_err_status(); 
13D2C:  CALL   D006
13D30:  MOVFF  01,89D
....................             break ;           
13D34:  MOVLB  8
13D36:  BRA    13DF0
....................          case 'P' : motor=0; 
13D38:  MOVLB  7
13D3A:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
13D3C:  MOVLW  01
13D3E:  MOVLB  8
13D40:  MOVWF  xA3
13D42:  CLRF   xA4
13D44:  CLRF   xA8
13D46:  CLRF   xA7
13D48:  MOVFF  89C,8A6
13D4C:  MOVFF  89B,8A5
13D50:  MOVWF  xA9
13D52:  MOVLB  0
13D54:  CALL   9CC2
....................                     macro_status=step_err_status(); 
13D58:  CALL   D006
13D5C:  MOVFF  01,89D
....................             break; 
13D60:  MOVLB  8
13D62:  BRA    13DF0
....................          case 'Q' : motor=0; 
13D64:  MOVLB  7
13D66:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
13D68:  MOVLB  8
13D6A:  CLRF   xA3
13D6C:  CLRF   xA4
13D6E:  CLRF   xA8
13D70:  CLRF   xA7
13D72:  MOVFF  89C,8A6
13D76:  MOVFF  89B,8A5
13D7A:  MOVLW  01
13D7C:  MOVWF  xA9
13D7E:  MOVLB  0
13D80:  CALL   9CC2
....................                     macro_status=step_err_status(); 
13D84:  CALL   D006
13D88:  MOVFF  01,89D
....................             break; 
13D8C:  MOVLB  8
13D8E:  BRA    13DF0
....................          case 'R' : motor=0; 
13D90:  MOVLB  7
13D92:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
13D94:  MOVLB  8
13D96:  CLRF   xA3
13D98:  MOVLW  01
13D9A:  MOVWF  xA4
13D9C:  CLRF   xA8
13D9E:  CLRF   xA7
13DA0:  MOVFF  89C,8A6
13DA4:  MOVFF  89B,8A5
13DA8:  MOVWF  xA9
13DAA:  MOVLB  0
13DAC:  CALL   9CC2
....................                     macro_status=step_err_status(); 
13DB0:  CALL   D006
13DB4:  MOVFF  01,89D
....................             break; 
13DB8:  MOVLB  8
13DBA:  BRA    13DF0
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
13DBC:  MOVLB  8
13DBE:  DECFSZ x9B,W
13DC0:  BRA    13DD0
13DC2:  MOVF   x9C,F
13DC4:  BNZ   13DD0
13DC6:  MOVLB  0
13DC8:  CALL   D074
13DCC:  BRA    13DDE
13DCE:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
13DD0:  MOVF   x9B,F
13DD2:  BNZ   13DE0
13DD4:  MOVF   x9C,F
13DD6:  BNZ   13DE0
13DD8:  MOVLB  0
13DDA:  CALL   D098
13DDE:  MOVLB  8
....................                     macro_status = 'a'; 
13DE0:  MOVLW  61
13DE2:  MOVWF  x9D
....................             break; 
13DE4:  BRA    13DF0
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
13DE6:  MOVLW  66
13DE8:  MOVLB  8
13DEA:  MOVWF  x9D
....................             break ; 
13DEC:  BRA    13DF0
13DEE:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
13DF0:  MOVFF  89D,01
13DF4:  MOVLB  0
13DF6:  GOTO   146F6 (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
14552:  MOVLW  65
14554:  MOVLB  8
14556:  MOVWF  x83
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
14558:  BCF    FD8.0
1455A:  RLCF   x79,W
1455C:  CLRF   03
1455E:  ADDLW  CC
14560:  MOVWF  FE9
14562:  MOVLW  07
14564:  ADDWFC 03,W
14566:  MOVWF  FEA
14568:  MOVFF  FEC,892
1456C:  MOVF   FED,F
1456E:  MOVFF  FEF,891
14572:  MOVFF  87B,03
14576:  MOVFF  87A,FE9
1457A:  MOVFF  87B,FEA
1457E:  MOVFF  FEC,9E9
14582:  MOVF   FED,F
14584:  MOVFF  FEF,9E8
14588:  MOVLB  9
1458A:  CLRF   xEB
1458C:  MOVLW  03
1458E:  MOVWF  xEA
14590:  MOVLB  0
14592:  CALL   5C22
14596:  MOVF   01,W
14598:  MOVLB  8
1459A:  ADDWF  x91,W
1459C:  MOVWF  x7E
1459E:  MOVF   02,W
145A0:  ADDWFC x92,W
145A2:  MOVWF  x7F
....................  
....................    init_ext_eeprom(); 
145A4:  MOVLB  0
145A6:  CALL   FFE4
....................    macro_cmd = read_ext_eeprom(addr); 
145AA:  MOVFF  87F,8A8
145AE:  MOVFF  87E,8A7
145B2:  CALL   102F0
145B6:  MOVFF  01,880
....................    ++addr; 
145BA:  MOVLB  8
145BC:  INCF   x7E,F
145BE:  BTFSC  FD8.2
145C0:  INCF   x7F,F
....................    if(macro_cmd == 'p'){ 
145C2:  MOVF   x80,W
145C4:  SUBLW  70
145C6:  BNZ   145EC
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
145C8:  MOVFF  879,891
145CC:  MOVFF  87B,893
145D0:  MOVFF  87A,892
145D4:  MOVFF  853,895
145D8:  MOVFF  852,894
145DC:  MOVLB  0
145DE:  CALL   1034A
....................       count1++; 
145E2:  MOVLB  8
145E4:  INCF   x52,F
145E6:  BTFSC  FD8.2
145E8:  INCF   x53,F
....................    }else{ 
145EA:  BRA    14604
....................    macro_arg = read16_ext_eeprom(addr); 
145EC:  MOVFF  87F,89F
145F0:  MOVFF  87E,89E
145F4:  MOVLB  0
145F6:  CALL   10404
145FA:  MOVFF  02,882
145FE:  MOVFF  01,881
14602:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
14604:  MOVLW  01
14606:  MOVWF  xC9
14608:  MOVLB  0
1460A:  CALL   5500
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
1460E:  MOVF   2F,F
14610:  BTFSS  FD8.2
14612:  BRA    14A60
14614:  MOVF   30,F
14616:  BTFSS  FD8.2
14618:  BRA    14A60
....................       switch(macro_cmd){ 
1461A:  MOVLW  2B
1461C:  MOVLB  8
1461E:  SUBWF  x80,W
14620:  ADDLW  B8
14622:  BTFSC  FD8.0
14624:  BRA    14A5C
14626:  ADDLW  48
14628:  MOVLB  0
1462A:  GOTO   14D26
....................          case 'A' : 
....................             calc_abs_data(); 
1462E:  CALL   1227A
....................             store_rel_data(); 
14632:  CALL   122DE
....................             macro_status = 'a'; 
14636:  MOVLW  61
14638:  MOVLB  8
1463A:  MOVWF  x83
....................             break; 
1463C:  BRA    14A5C
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
1463E:  MOVLW  08
14640:  MOVWF  FEA
14642:  MOVLW  20
14644:  MOVWF  FE9
14646:  CALL   78E6
1464A:  MOVLW  0D
1464C:  BTFSS  F9E.4
1464E:  BRA    1464C
14650:  MOVWF  FAD
14652:  MOVLW  0A
14654:  BTFSS  F9E.4
14656:  BRA    14654
14658:  MOVWF  FAD
....................             macro_status = 'a'; 
1465A:  MOVLW  61
1465C:  MOVLB  8
1465E:  MOVWF  x83
....................             break; 
14660:  BRA    14A5C
....................          case 'C' : 
....................             calc_abs_data(); 
14662:  CALL   1227A
....................             break; 
14666:  MOVLB  8
14668:  BRA    14A5C
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
1466A:  MOVLB  8
1466C:  CLRF   x87
1466E:  CLRF   x86
14670:  CLRF   x85
14672:  CLRF   x84
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14674:  MOVFF  87B,03
14678:  MOVFF  87A,FE9
1467C:  MOVFF  87B,FEA
14680:  MOVLW  01
14682:  ADDWF  FEE,F
14684:  BNC   14688
14686:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
14688:  MOVFF  87A,FE9
1468C:  MOVFF  87B,FEA
14690:  CLRF   x8B
14692:  CLRF   x8A
14694:  MOVFF  FEC,889
14698:  MOVF   FED,F
1469A:  MOVFF  FEF,888
1469E:  CLRF   x8F
146A0:  CLRF   x8E
146A2:  CLRF   x8D
146A4:  CLRF   x8C
....................                    
....................                   while(count < macro_arg){ 
146A6:  MOVF   x87,F
146A8:  BTFSS  FD8.2
146AA:  BRA    147E6
146AC:  MOVF   x86,F
146AE:  BTFSS  FD8.2
146B0:  BRA    147E6
146B2:  MOVF   x85,W
146B4:  SUBWF  x82,W
146B6:  BTFSS  FD8.0
146B8:  BRA    147E6
146BA:  BNZ   146C4
146BC:  MOVF   x81,W
146BE:  SUBWF  x84,W
146C0:  BTFSC  FD8.0
146C2:  BRA    147E6
....................                      char curr = 'A'; 
146C4:  MOVLW  41
146C6:  MOVWF  x90
....................                      while(curr != '%'){ 
146C8:  MOVF   x90,W
146CA:  SUBLW  25
146CC:  BZ    14738
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
146CE:  MOVFF  87B,03
146D2:  MOVFF  87A,FE9
146D6:  MOVFF  87B,FEA
146DA:  MOVFF  FEC,895
146DE:  MOVF   FED,F
146E0:  MOVFF  FEF,894
146E4:  MOVFF  879,893
146E8:  MOVFF  87D,897
146EC:  MOVFF  87C,896
146F0:  MOVLB  0
146F2:  GOTO   13ABA
....................                         (*line)++; 
146F6:  MOVFF  87B,03
146FA:  MOVLB  8
146FC:  MOVF   x7A,W
146FE:  MOVWF  FE9
14700:  MOVFF  03,FEA
14704:  MOVLW  01
14706:  ADDWF  FEE,F
14708:  BNC   1470C
1470A:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
1470C:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
1470E:  MOVFF  87B,03
14712:  MOVFF  87A,FE9
14716:  MOVFF  87B,FEA
1471A:  MOVFF  FEC,895
1471E:  MOVF   FED,F
14720:  MOVFF  FEF,894
14724:  MOVFF  879,893
14728:  MOVLB  0
1472A:  GOTO   13EA6
1472E:  MOVFF  01,890
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14732:  BSF    F91.5
14734:  MOVLB  8
14736:  BRA    146C8
....................                      } 
....................                      end_line = (*line); 
14738:  MOVFF  87A,FE9
1473C:  MOVFF  87B,FEA
14740:  CLRF   x8F
14742:  CLRF   x8E
14744:  MOVFF  FEC,88D
14748:  MOVF   FED,F
1474A:  MOVFF  FEF,88C
....................                      count++; 
1474E:  MOVLW  01
14750:  ADDWF  x84,F
14752:  BTFSC  FD8.0
14754:  INCF   x85,F
14756:  BTFSC  FD8.2
14758:  INCF   x86,F
1475A:  BTFSC  FD8.2
1475C:  INCF   x87,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
1475E:  MOVF   x84,W
14760:  SUBWF  x81,W
14762:  MOVWF  x91
14764:  MOVF   x85,W
14766:  SUBWFB x82,W
14768:  MOVWF  x92
1476A:  MOVLW  00
1476C:  SUBFWB x86,W
1476E:  MOVWF  x93
14770:  MOVLW  00
14772:  SUBFWB x87,W
14774:  MOVWF  x94
14776:  MOVLW  38
14778:  MOVWF  FF6
1477A:  MOVLW  21
1477C:  MOVWF  FF7
1477E:  MOVLW  00
14780:  MOVWF  FF8
14782:  CLRF   1B
14784:  BTFSC  FF2.7
14786:  BSF    1B.7
14788:  BCF    FF2.7
1478A:  MOVLW  11
1478C:  MOVLB  A
1478E:  MOVWF  x18
14790:  MOVLB  0
14792:  CALL   1006
14796:  BTFSC  1B.7
14798:  BSF    FF2.7
1479A:  MOVLW  41
1479C:  MOVWF  FE9
1479E:  CLRF   1B
147A0:  BTFSC  FF2.7
147A2:  BSF    1B.7
147A4:  BCF    FF2.7
147A6:  MOVFF  894,A1B
147AA:  MOVFF  893,A1A
147AE:  MOVFF  892,A19
147B2:  MOVFF  891,A18
147B6:  CALL   10CC
147BA:  BTFSC  1B.7
147BC:  BSF    FF2.7
147BE:  MOVLW  0D
147C0:  BTFSS  F9E.4
147C2:  BRA    147C0
147C4:  MOVWF  FAD
147C6:  MOVLW  0A
147C8:  BTFSS  F9E.4
147CA:  BRA    147C8
147CC:  MOVWF  FAD
....................                      (*line) = start_line; 
147CE:  MOVFF  87B,03
147D2:  MOVLB  8
147D4:  MOVFF  87A,FE9
147D8:  MOVFF  87B,FEA
147DC:  MOVFF  888,FEF
147E0:  MOVFF  889,FEC
147E4:  BRA    146A6
....................                   } 
....................                   (*line) = end_line + 1; 
147E6:  MOVFF  87A,FE9
147EA:  MOVFF  87B,FEA
147EE:  MOVLW  01
147F0:  ADDWF  x8C,W
147F2:  MOVWF  FEF
147F4:  MOVLW  00
147F6:  ADDWFC x8D,W
147F8:  MOVWF  FEC
....................                   macro_status = 'a'; 
147FA:  MOVLW  61
147FC:  MOVWF  x83
....................             break; 
147FE:  BRA    14A5C
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
14800:  MOVFF  882,89F
14804:  MOVFF  881,89E
14808:  CALL   D03E
....................                     macro_status = 'a'; 
1480C:  MOVLW  61
1480E:  MOVLB  8
14810:  MOVWF  x83
....................             break; 
14812:  BRA    14A5C
....................          case 'F' : macro_flag = macro_arg; 
14814:  MOVFF  882,320
14818:  MOVFF  881,31F
....................                     macro_status = 'a'; 
1481C:  MOVLW  61
1481E:  MOVLB  8
14820:  MOVWF  x83
....................             break ; 
14822:  BRA    14A5C
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14824:  MOVFF  881,2D1
....................                     macro_status = 'a'; 
14828:  MOVLW  61
1482A:  MOVLB  8
1482C:  MOVWF  x83
....................             break ; 
1482E:  BRA    14A5C
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14830:  MOVFF  880,89E
14834:  MOVFF  882,8A0
14838:  MOVFF  881,89F
1483C:  CALL   12460
....................                     macro_status = 'a'; 
14840:  MOVLW  61
14842:  MOVLB  8
14844:  MOVWF  x83
....................             break; 
14846:  BRA    14A5C
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14848:  MOVFF  880,89E
1484C:  MOVFF  882,8A0
14850:  MOVFF  881,89F
14854:  CALL   12460
....................                     macro_status = 'a'; 
14858:  MOVLW  61
1485A:  MOVLB  8
1485C:  MOVWF  x83
....................             break; 
1485E:  BRA    14A5C
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14860:  MOVFF  882,8B8
14864:  MOVFF  881,8B7
14868:  MOVLB  8
1486A:  CLRF   xBA
1486C:  MOVLW  64
1486E:  MOVWF  xB9
14870:  MOVLB  0
14872:  CALL   2C52
14876:  MOVFF  02,749
1487A:  MOVFF  01,748
....................                     macro_status = 'a'; 
1487E:  MOVLW  61
14880:  MOVLB  8
14882:  MOVWF  x83
....................             break;    
14884:  BRA    14A5C
....................          case 'l' : LightTargetFlag = 1; 
14886:  MOVLW  01
14888:  MOVLB  2
1488A:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
1488C:  MOVFF  880,89E
14890:  MOVFF  882,8A0
14894:  MOVFF  881,89F
14898:  MOVLB  0
1489A:  CALL   1249A
....................                     delay_ms(10000); 
1489E:  MOVLW  28
148A0:  MOVLB  8
148A2:  MOVWF  x91
148A4:  MOVLW  FA
148A6:  MOVLB  9
148A8:  MOVWF  xC8
148AA:  MOVLB  0
148AC:  CALL   288E
148B0:  MOVLB  8
148B2:  DECFSZ x91,F
148B4:  BRA    148A4
....................                     macro_status = 'a'; 
148B6:  MOVLW  61
148B8:  MOVWF  x83
....................             break;        
148BA:  BRA    14A5C
....................          case 'L' : LightTargetFlag = 0; 
148BC:  MOVLB  2
148BE:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
148C0:  MOVFF  880,89E
148C4:  MOVFF  882,8A0
148C8:  MOVFF  881,89F
148CC:  MOVLB  0
148CE:  CALL   1249A
....................                     macro_status = 'a'; 
148D2:  MOVLW  61
148D4:  MOVLB  8
148D6:  MOVWF  x83
....................             break; 
148D8:  BRA    14A5C
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
148DA:  MOVFF  880,43
....................                     arg = macro_arg; 
148DE:  CLRF   47
148E0:  CLRF   46
148E2:  MOVFF  882,45
148E6:  MOVFF  881,44
....................                     det_cmd(); 
148EA:  CALL   F102
....................                     macro_status = 'a'; 
148EE:  MOVLW  61
148F0:  MOVLB  8
148F2:  MOVWF  x83
....................             break ; 
148F4:  BRA    14A5C
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
148F6:  MOVLB  8
148F8:  DECFSZ x81,W
148FA:  BRA    14908
148FC:  MOVF   x82,F
148FE:  BNZ   14908
14900:  MOVLB  0
14902:  CALL   13542
14906:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14908:  MOVF   x81,W
1490A:  SUBLW  02
1490C:  BNZ   14920
1490E:  MOVF   x82,F
14910:  BNZ   14920
14912:  MOVLW  01
14914:  MOVWF  x9E
14916:  MOVWF  x9F
14918:  MOVLB  0
1491A:  CALL   1370E
1491E:  MOVLB  8
....................                     macro_status = 'a'; 
14920:  MOVLW  61
14922:  MOVWF  x83
....................             break ;  
14924:  BRA    14A5C
....................          case 'T' : det_temp(); 
14926:  CALL   138CE
....................                     macro_status = 'a'; 
1492A:  MOVLW  61
1492C:  MOVLB  8
1492E:  MOVWF  x83
....................             break; 
14930:  BRA    14A5C
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14932:  MOVLW  01
14934:  MOVLB  7
14936:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14938:  MOVLB  8
1493A:  CLRF   xA3
1493C:  CLRF   xA4
1493E:  CLRF   xA8
14940:  CLRF   xA7
14942:  MOVFF  882,8A6
14946:  MOVFF  881,8A5
1494A:  MOVWF  xA9
1494C:  MOVLB  0
1494E:  CALL   9CC2
....................                     macro_status=step_err_status(); 
14952:  CALL   D006
14956:  MOVFF  01,883
....................             break; 
1495A:  MOVLB  8
1495C:  BRA    14A5C
....................          case '-' : motor=1; 
1495E:  MOVLW  01
14960:  MOVLB  7
14962:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14964:  MOVLB  8
14966:  CLRF   xA3
14968:  MOVWF  xA4
1496A:  CLRF   xA8
1496C:  CLRF   xA7
1496E:  MOVFF  882,8A6
14972:  MOVFF  881,8A5
14976:  MOVWF  xA9
14978:  MOVLB  0
1497A:  CALL   9CC2
....................                     macro_status=step_err_status(); 
1497E:  CALL   D006
14982:  MOVFF  01,883
....................             break; 
14986:  MOVLB  8
14988:  BRA    14A5C
....................          case 'G' : motor=0; 
1498A:  MOVLB  7
1498C:  CLRF   x3C
....................                     align(0); 
1498E:  MOVLB  8
14990:  CLRF   x9E
14992:  MOVLB  0
14994:  CALL   A7FE
....................                     macro_status=step_err_status(); 
14998:  CALL   D006
1499C:  MOVFF  01,883
....................             break ;           
149A0:  MOVLB  8
149A2:  BRA    14A5C
....................          case 'P' : motor=0; 
149A4:  MOVLB  7
149A6:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
149A8:  MOVLW  01
149AA:  MOVLB  8
149AC:  MOVWF  xA3
149AE:  CLRF   xA4
149B0:  CLRF   xA8
149B2:  CLRF   xA7
149B4:  MOVFF  882,8A6
149B8:  MOVFF  881,8A5
149BC:  MOVWF  xA9
149BE:  MOVLB  0
149C0:  CALL   9CC2
....................                     macro_status=step_err_status(); 
149C4:  CALL   D006
149C8:  MOVFF  01,883
....................             break; 
149CC:  MOVLB  8
149CE:  BRA    14A5C
....................          case 'Q' : motor=0; 
149D0:  MOVLB  7
149D2:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
149D4:  MOVLB  8
149D6:  CLRF   xA3
149D8:  CLRF   xA4
149DA:  CLRF   xA8
149DC:  CLRF   xA7
149DE:  MOVFF  882,8A6
149E2:  MOVFF  881,8A5
149E6:  MOVLW  01
149E8:  MOVWF  xA9
149EA:  MOVLB  0
149EC:  CALL   9CC2
....................                     macro_status=step_err_status(); 
149F0:  CALL   D006
149F4:  MOVFF  01,883
....................             break; 
149F8:  MOVLB  8
149FA:  BRA    14A5C
....................          case 'R' : motor=0; 
149FC:  MOVLB  7
149FE:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
14A00:  MOVLB  8
14A02:  CLRF   xA3
14A04:  MOVLW  01
14A06:  MOVWF  xA4
14A08:  CLRF   xA8
14A0A:  CLRF   xA7
14A0C:  MOVFF  882,8A6
14A10:  MOVFF  881,8A5
14A14:  MOVWF  xA9
14A16:  MOVLB  0
14A18:  CALL   9CC2
....................                     macro_status=step_err_status(); 
14A1C:  CALL   D006
14A20:  MOVFF  01,883
....................             break; 
14A24:  MOVLB  8
14A26:  BRA    14A5C
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14A28:  MOVLB  8
14A2A:  DECFSZ x81,W
14A2C:  BRA    14A3C
14A2E:  MOVF   x82,F
14A30:  BNZ   14A3C
14A32:  MOVLB  0
14A34:  CALL   D074
14A38:  BRA    14A4A
14A3A:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14A3C:  MOVF   x81,F
14A3E:  BNZ   14A4C
14A40:  MOVF   x82,F
14A42:  BNZ   14A4C
14A44:  MOVLB  0
14A46:  CALL   D098
14A4A:  MOVLB  8
....................                     macro_status = 'a'; 
14A4C:  MOVLW  61
14A4E:  MOVWF  x83
....................             break; 
14A50:  BRA    14A5C
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14A52:  MOVLW  66
14A54:  MOVLB  8
14A56:  MOVWF  x83
....................             break ; 
14A58:  BRA    14A5C
14A5A:  MOVLB  8
....................       } 
....................    } 
14A5C:  BRA    14D1C
14A5E:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14A60:  DECFSZ 2F,W
14A62:  BRA    14A68
14A64:  MOVF   30,F
14A66:  BZ    14A76
14A68:  MOVF   2F,W
14A6A:  SUBLW  03
14A6C:  BTFSS  FD8.2
14A6E:  BRA    14BF4
14A70:  MOVF   30,F
14A72:  BTFSS  FD8.2
14A74:  BRA    14BF4
....................       switch(macro_cmd){ 
14A76:  MOVLB  8
14A78:  MOVF   x80,W
14A7A:  XORLW  2B
14A7C:  MOVLB  0
14A7E:  BZ    14AAC
14A80:  XORLW  06
14A82:  BZ    14AD6
14A84:  XORLW  6F
14A86:  BZ    14B00
14A88:  XORLW  05
14A8A:  BZ    14B12
14A8C:  XORLW  17
14A8E:  BZ    14B2A
14A90:  XORLW  01
14A92:  BZ    14B54
14A94:  XORLW  03
14A96:  BZ    14B7E
14A98:  XORLW  06
14A9A:  BTFSC  FD8.2
14A9C:  BRA    14BA8
14A9E:  XORLW  0D
14AA0:  BTFSC  FD8.2
14AA2:  BRA    14BBE
14AA4:  XORLW  62
14AA6:  BTFSC  FD8.2
14AA8:  BRA    14BEA
14AAA:  BRA    14BF2
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14AAC:  MOVLW  01
14AAE:  MOVLB  7
14AB0:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14AB2:  MOVLB  8
14AB4:  CLRF   xA3
14AB6:  CLRF   xA4
14AB8:  CLRF   xA8
14ABA:  CLRF   xA7
14ABC:  MOVFF  882,8A6
14AC0:  MOVFF  881,8A5
14AC4:  MOVWF  xA9
14AC6:  MOVLB  0
14AC8:  CALL   9CC2
....................                     macro_status=step_err_status(); 
14ACC:  CALL   D006
14AD0:  MOVFF  01,883
....................             break; 
14AD4:  BRA    14BF2
....................          case '-' : motor=1; 
14AD6:  MOVLW  01
14AD8:  MOVLB  7
14ADA:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14ADC:  MOVLB  8
14ADE:  CLRF   xA3
14AE0:  MOVWF  xA4
14AE2:  CLRF   xA8
14AE4:  CLRF   xA7
14AE6:  MOVFF  882,8A6
14AEA:  MOVFF  881,8A5
14AEE:  MOVWF  xA9
14AF0:  MOVLB  0
14AF2:  CALL   9CC2
....................                     macro_status=step_err_status(); 
14AF6:  CALL   D006
14AFA:  MOVFF  01,883
....................             break; 
14AFE:  BRA    14BF2
....................          case 'B' : h_bridge(macro_arg); 
14B00:  MOVFF  881,891
14B04:  CALL   BECC
....................                     macro_status = 'a'; 
14B08:  MOVLW  61
14B0A:  MOVLB  8
14B0C:  MOVWF  x83
....................             break;             
14B0E:  MOVLB  0
14B10:  BRA    14BF2
....................          case 'G' : motor=0; 
14B12:  MOVLB  7
14B14:  CLRF   x3C
....................                     align(0); 
14B16:  MOVLB  8
14B18:  CLRF   x9E
14B1A:  MOVLB  0
14B1C:  CALL   A7FE
....................                     macro_status=step_err_status(); 
14B20:  CALL   D006
14B24:  MOVFF  01,883
....................             break ;           
14B28:  BRA    14BF2
....................          case 'P' : motor=0; 
14B2A:  MOVLB  7
14B2C:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1);   
14B2E:  MOVLB  8
14B30:  CLRF   xA3
14B32:  CLRF   xA4
14B34:  CLRF   xA8
14B36:  CLRF   xA7
14B38:  MOVFF  87D,8A6
14B3C:  MOVFF  87C,8A5
14B40:  MOVLW  01
14B42:  MOVWF  xA9
14B44:  MOVLB  0
14B46:  CALL   9CC2
....................                     macro_status=step_err_status(); 
14B4A:  CALL   D006
14B4E:  MOVFF  01,883
....................             break; 
14B52:  BRA    14BF2
....................          case 'Q' : motor=0; 
14B54:  MOVLB  7
14B56:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1); 
14B58:  MOVLB  8
14B5A:  CLRF   xA3
14B5C:  CLRF   xA4
14B5E:  CLRF   xA8
14B60:  CLRF   xA7
14B62:  MOVFF  87D,8A6
14B66:  MOVFF  87C,8A5
14B6A:  MOVLW  01
14B6C:  MOVWF  xA9
14B6E:  MOVLB  0
14B70:  CALL   9CC2
....................                     macro_status=step_err_status(); 
14B74:  CALL   D006
14B78:  MOVFF  01,883
....................             break; 
14B7C:  BRA    14BF2
....................          case 'R' : motor=0; 
14B7E:  MOVLB  7
14B80:  CLRF   x3C
....................                     move_motor(0,1,mmacro_var,1); 
14B82:  MOVLB  8
14B84:  CLRF   xA3
14B86:  MOVLW  01
14B88:  MOVWF  xA4
14B8A:  CLRF   xA8
14B8C:  CLRF   xA7
14B8E:  MOVFF  87D,8A6
14B92:  MOVFF  87C,8A5
14B96:  MOVWF  xA9
14B98:  MOVLB  0
14B9A:  CALL   9CC2
....................                     macro_status=step_err_status(); 
14B9E:  CALL   D006
14BA2:  MOVFF  01,883
....................             break; 
14BA6:  BRA    14BF2
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
14BA8:  MOVFF  882,89F
14BAC:  MOVFF  881,89E
14BB0:  CALL   D03E
....................                     macro_status = 'a'; 
14BB4:  MOVLW  61
14BB6:  MOVLB  8
14BB8:  MOVWF  x83
....................             break; 
14BBA:  MOVLB  0
14BBC:  BRA    14BF2
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
14BBE:  MOVLB  8
14BC0:  DECFSZ x81,W
14BC2:  BRA    14BD2
14BC4:  MOVF   x82,F
14BC6:  BNZ   14BD2
14BC8:  MOVLB  0
14BCA:  CALL   D074
14BCE:  BRA    14BE0
14BD0:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14BD2:  MOVF   x81,F
14BD4:  BNZ   14BE2
14BD6:  MOVF   x82,F
14BD8:  BNZ   14BE2
14BDA:  MOVLB  0
14BDC:  CALL   D098
14BE0:  MOVLB  8
....................                     macro_status = 'a'; 
14BE2:  MOVLW  61
14BE4:  MOVWF  x83
....................             break; 
14BE6:  MOVLB  0
14BE8:  BRA    14BF2
....................          case ';' : macro_status = 'f'; 
14BEA:  MOVLW  66
14BEC:  MOVLB  8
14BEE:  MOVWF  x83
....................             break;            
14BF0:  MOVLB  0
....................       } 
....................    } 
14BF2:  BRA    14D1A
....................    else if (nv_product==AWS){ 
14BF4:  MOVF   2F,W
14BF6:  SUBLW  02
14BF8:  BTFSS  FD8.2
14BFA:  BRA    14D1A
14BFC:  MOVF   30,F
14BFE:  BTFSS  FD8.2
14C00:  BRA    14D1A
....................       switch(macro_cmd){ 
14C02:  MOVLB  8
14C04:  MOVF   x80,W
14C06:  XORLW  2B
14C08:  MOVLB  0
14C0A:  BZ    14C30
14C0C:  XORLW  06
14C0E:  BZ    14C5A
14C10:  XORLW  6E
14C12:  BZ    14C84
14C14:  XORLW  07
14C16:  BZ    14C96
14C18:  XORLW  14
14C1A:  BZ    14CAC
14C1C:  XORLW  01
14C1E:  BZ    14CBE
14C20:  XORLW  02
14C22:  BZ    14CD0
14C24:  XORLW  0A
14C26:  BZ    14CE6
14C28:  XORLW  62
14C2A:  BTFSC  FD8.2
14C2C:  BRA    14D12
14C2E:  BRA    14D1A
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14C30:  MOVLW  01
14C32:  MOVLB  7
14C34:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14C36:  MOVLB  8
14C38:  CLRF   xA3
14C3A:  CLRF   xA4
14C3C:  CLRF   xA8
14C3E:  CLRF   xA7
14C40:  MOVFF  882,8A6
14C44:  MOVFF  881,8A5
14C48:  MOVWF  xA9
14C4A:  MOVLB  0
14C4C:  CALL   9CC2
....................                     macro_status=step_err_status(); 
14C50:  CALL   D006
14C54:  MOVFF  01,883
....................             break; 
14C58:  BRA    14D1A
....................          case '-' : motor=1; 
14C5A:  MOVLW  01
14C5C:  MOVLB  7
14C5E:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14C60:  MOVLB  8
14C62:  CLRF   xA3
14C64:  MOVWF  xA4
14C66:  CLRF   xA8
14C68:  CLRF   xA7
14C6A:  MOVFF  882,8A6
14C6E:  MOVFF  881,8A5
14C72:  MOVWF  xA9
14C74:  MOVLB  0
14C76:  CALL   9CC2
....................                     macro_status=step_err_status(); 
14C7A:  CALL   D006
14C7E:  MOVFF  01,883
....................             break; 
14C82:  BRA    14D1A
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
14C84:  MOVFF  881,892
14C88:  CALL   D8BA
....................                     macro_status = 'a';  
14C8C:  MOVLW  61
14C8E:  MOVLB  8
14C90:  MOVWF  x83
....................             break;          
14C92:  MOVLB  0
14C94:  BRA    14D1A
....................          case 'D' : delay_sec(macro_arg); 
14C96:  MOVFF  882,89F
14C9A:  MOVFF  881,89E
14C9E:  CALL   D03E
....................                     macro_status = 'a'; 
14CA2:  MOVLW  61
14CA4:  MOVLB  8
14CA6:  MOVWF  x83
....................             break; 
14CA8:  MOVLB  0
14CAA:  BRA    14D1A
....................          case 'P' : sol_switch(mmacro_var); 
14CAC:  MOVFF  87C,891
14CB0:  CALL   140CA
....................                     macro_status = 'a'; 
14CB4:  MOVLW  61
14CB6:  MOVLB  8
14CB8:  MOVWF  x83
....................             break;              
14CBA:  MOVLB  0
14CBC:  BRA    14D1A
....................          case 'Q' : sol_switch(macro_arg); 
14CBE:  MOVFF  881,891
14CC2:  CALL   140CA
....................                     macro_status = 'a'; 
14CC6:  MOVLW  61
14CC8:  MOVLB  8
14CCA:  MOVWF  x83
....................             break;             
14CCC:  MOVLB  0
14CCE:  BRA    14D1A
....................          case 'S' : sol_switch_cmd(macro_arg); 
14CD0:  MOVFF  882,893
14CD4:  MOVFF  881,892
14CD8:  CALL   14014
....................                     macro_status = 'a'; 
14CDC:  MOVLW  61
14CDE:  MOVLB  8
14CE0:  MOVWF  x83
....................             break; 
14CE2:  MOVLB  0
14CE4:  BRA    14D1A
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14CE6:  MOVLB  8
14CE8:  DECFSZ x81,W
14CEA:  BRA    14CFA
14CEC:  MOVF   x82,F
14CEE:  BNZ   14CFA
14CF0:  MOVLB  0
14CF2:  CALL   D074
14CF6:  BRA    14D08
14CF8:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14CFA:  MOVF   x81,F
14CFC:  BNZ   14D0A
14CFE:  MOVF   x82,F
14D00:  BNZ   14D0A
14D02:  MOVLB  0
14D04:  CALL   D098
14D08:  MOVLB  8
....................                     macro_status = 'a'; 
14D0A:  MOVLW  61
14D0C:  MOVWF  x83
....................             break;               
14D0E:  MOVLB  0
14D10:  BRA    14D1A
....................          case ';' : macro_status = 'f'; 
14D12:  MOVLW  66
14D14:  MOVLB  8
14D16:  MOVWF  x83
....................             break;            
14D18:  MOVLB  0
14D1A:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
14D1C:  MOVFF  883,01
14D20:  MOVLB  0
14D22:  GOTO   15032 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
14F00:  MOVLB  8
14F02:  CLRF   x53
14F04:  CLRF   x52
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
14F06:  MOVLB  0
14F08:  CALL   5064
....................    clear_data_arrays(); 
14F0C:  GOTO   10202
....................     
....................    line = 0;  
14F10:  MOVLB  8
14F12:  CLRF   x77
14F14:  CLRF   x76
....................    macro_status = 'a'; 
14F16:  MOVLW  61
14F18:  MOVWF  x78
....................    data_available = FALSE; 
14F1A:  MOVLB  3
14F1C:  CLRF   x37
....................    macro_flag = 900; 
14F1E:  MOVLW  03
14F20:  MOVWF  x20
14F22:  MOVLW  84
14F24:  MOVWF  x1F
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
14F26:  MOVLW  01
14F28:  MOVWF  1E
14F2A:  MOVLW  A3
14F2C:  MOVWF  1D
14F2E:  MOVLW  50
14F30:  MOVWF  FF6
14F32:  MOVLW  21
14F34:  MOVWF  FF7
14F36:  MOVLW  00
14F38:  MOVWF  FF8
14F3A:  MOVLW  07
14F3C:  MOVLB  8
14F3E:  MOVWF  xC7
14F40:  MOVLB  0
14F42:  CALL   AA0E
14F46:  MOVFF  873,8C9
14F4A:  MOVLW  1B
14F4C:  MOVLB  8
14F4E:  MOVWF  xCA
14F50:  MOVLB  0
14F52:  CALL   51FE
14F56:  MOVLW  59
14F58:  MOVWF  FF6
14F5A:  MOVLW  21
14F5C:  MOVWF  FF7
14F5E:  MOVLW  00
14F60:  MOVWF  FF8
14F62:  MOVLW  09
14F64:  MOVLB  8
14F66:  MOVWF  xC7
14F68:  MOVLB  0
14F6A:  CALL   AA0E
....................    record_event();    
14F6E:  CALL   8424
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
14F72:  MOVLB  8
14F74:  MOVF   x77,W
14F76:  SUBLW  03
14F78:  BNC   1504A
14F7A:  MOVF   x78,W
14F7C:  SUBLW  61
14F7E:  BNZ   1504A
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
14F80:  MOVF   1F,W
14F82:  SUBLW  04
14F84:  BNZ   15018
14F86:  MOVF   20,F
14F88:  BNZ   15018
....................                                                macro_status, (line + 1)); 
14F8A:  MOVLW  01
14F8C:  ADDWF  x76,W
14F8E:  MOVWF  x79
14F90:  MOVLW  00
14F92:  ADDWFC x77,W
14F94:  MOVWF  x7A
14F96:  MOVLW  64
14F98:  MOVWF  FF6
14F9A:  MOVLW  21
14F9C:  MOVWF  FF7
14F9E:  MOVLW  00
14FA0:  MOVWF  FF8
14FA2:  CLRF   1B
14FA4:  BTFSC  FF2.7
14FA6:  BSF    1B.7
14FA8:  BCF    FF2.7
14FAA:  MOVLW  05
14FAC:  MOVLB  A
14FAE:  MOVWF  x18
14FB0:  MOVLB  0
14FB2:  CALL   1006
14FB6:  BTFSC  1B.7
14FB8:  BSF    FF2.7
14FBA:  MOVLB  8
14FBC:  MOVF   x78,W
14FBE:  BTFSS  F9E.4
14FC0:  BRA    14FBE
14FC2:  MOVWF  FAD
14FC4:  MOVLW  5D
14FC6:  BTFSS  F9E.4
14FC8:  BRA    14FC6
14FCA:  MOVWF  FAD
14FCC:  MOVLW  5B
14FCE:  BTFSS  F9E.4
14FD0:  BRA    14FCE
14FD2:  MOVWF  FAD
14FD4:  MOVLW  10
14FD6:  MOVWF  FE9
14FD8:  CLRF   1B
14FDA:  BTFSC  FF2.7
14FDC:  BSF    1B.7
14FDE:  BCF    FF2.7
14FE0:  MOVFF  87A,A19
14FE4:  MOVFF  879,A18
14FE8:  MOVLB  0
14FEA:  CALL   1188
14FEE:  BTFSC  1B.7
14FF0:  BSF    FF2.7
14FF2:  MOVLW  70
14FF4:  MOVWF  FF6
14FF6:  MOVLW  21
14FF8:  MOVWF  FF7
14FFA:  MOVLW  00
14FFC:  MOVWF  FF8
14FFE:  CLRF   1B
15000:  BTFSC  FF2.7
15002:  BSF    1B.7
15004:  BCF    FF2.7
15006:  MOVLW  03
15008:  MOVLB  A
1500A:  MOVWF  x18
1500C:  MOVLB  0
1500E:  CALL   1006
15012:  BTFSC  1B.7
15014:  BSF    FF2.7
15016:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
15018:  MOVFF  873,879
1501C:  MOVLW  08
1501E:  MOVWF  x7B
15020:  MOVLW  76
15022:  MOVWF  x7A
15024:  MOVFF  875,87D
15028:  MOVFF  874,87C
1502C:  MOVLB  0
1502E:  GOTO   14552
15032:  MOVFF  01,878
....................       ++line; 
15036:  MOVLB  8
15038:  INCF   x76,F
1503A:  BTFSC  FD8.2
1503C:  INCF   x77,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
1503E:  DECFSZ 4C,W
15040:  BRA    15048
....................          macro_status = 'g'; 
15042:  MOVLW  67
15044:  MOVWF  x78
....................          break;    
15046:  BRA    1504A
....................       } 
15048:  BRA    14F74
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
1504A:  MOVF   2F,W
1504C:  MOVWF  00
1504E:  MOVF   30,W
15050:  MOVWF  03
15052:  MOVF   03,W
15054:  BNZ   15060
15056:  MOVLW  01
15058:  SUBWF  00,W
1505A:  MOVLB  0
1505C:  BZ    1507E
1505E:  MOVLB  8
15060:  MOVF   03,W
15062:  BNZ   1506E
15064:  MOVLW  03
15066:  SUBWF  00,W
15068:  MOVLB  0
1506A:  BZ    1507E
1506C:  MOVLB  8
1506E:  MOVF   03,W
15070:  BNZ   1507C
15072:  MOVLW  02
15074:  SUBWF  00,W
15076:  MOVLB  0
15078:  BZ    1508A
1507A:  MOVLB  8
1507C:  BRA    1509A
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
1507E:  MOVFF  873,879
15082:  CALL   D342
....................          break; 
15086:  MOVLB  8
15088:  BRA    1509A
....................       case AWS : store_aws_data(macro,mmacro_var); 
1508A:  MOVFF  873,879
1508E:  MOVFF  875,87B
15092:  MOVFF  874,87A
15096:  BRA    14DD6
....................          break; 
15098:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
1509A:  MOVLW  61
1509C:  SUBWF  x78,W
1509E:  ADDLW  F9
150A0:  BC    1518C
150A2:  ADDLW  07
150A4:  MOVLB  0
150A6:  GOTO   15238
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
150AA:  MOVLW  74
150AC:  MOVWF  FF6
150AE:  MOVLW  21
150B0:  MOVWF  FF7
150B2:  MOVLW  00
150B4:  MOVWF  FF8
150B6:  CLRF   1B
150B8:  BTFSC  FF2.7
150BA:  BSF    1B.7
150BC:  BCF    FF2.7
150BE:  CALL   0E30
150C2:  BTFSC  1B.7
150C4:  BSF    FF2.7
....................          break; 
150C6:  MOVLB  8
150C8:  BRA    1518C
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
150CA:  MOVLW  7C
150CC:  MOVWF  FF6
150CE:  MOVLW  21
150D0:  MOVWF  FF7
150D2:  MOVLW  00
150D4:  MOVWF  FF8
150D6:  CLRF   1B
150D8:  BTFSC  FF2.7
150DA:  BSF    1B.7
150DC:  BCF    FF2.7
150DE:  CALL   0E30
150E2:  BTFSC  1B.7
150E4:  BSF    FF2.7
....................          break; 
150E6:  MOVLB  8
150E8:  BRA    1518C
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
150EA:  MOVLW  84
150EC:  MOVWF  FF6
150EE:  MOVLW  21
150F0:  MOVWF  FF7
150F2:  MOVLW  00
150F4:  MOVWF  FF8
150F6:  CLRF   1B
150F8:  BTFSC  FF2.7
150FA:  BSF    1B.7
150FC:  BCF    FF2.7
150FE:  CALL   0E30
15102:  BTFSC  1B.7
15104:  BSF    FF2.7
....................          break; 
15106:  MOVLB  8
15108:  BRA    1518C
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
1510A:  MOVLW  8C
1510C:  MOVWF  FF6
1510E:  MOVLW  21
15110:  MOVWF  FF7
15112:  MOVLW  00
15114:  MOVWF  FF8
15116:  CLRF   1B
15118:  BTFSC  FF2.7
1511A:  BSF    1B.7
1511C:  BCF    FF2.7
1511E:  CALL   0E30
15122:  BTFSC  1B.7
15124:  BSF    FF2.7
....................          break; 
15126:  MOVLB  8
15128:  BRA    1518C
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
1512A:  MOVLW  94
1512C:  MOVWF  FF6
1512E:  MOVLW  21
15130:  MOVWF  FF7
15132:  MOVLW  00
15134:  MOVWF  FF8
15136:  CLRF   1B
15138:  BTFSC  FF2.7
1513A:  BSF    1B.7
1513C:  BCF    FF2.7
1513E:  CALL   0E30
15142:  BTFSC  1B.7
15144:  BSF    FF2.7
....................          break;    
15146:  MOVLB  8
15148:  BRA    1518C
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
1514A:  MOVLW  9C
1514C:  MOVWF  FF6
1514E:  MOVLW  21
15150:  MOVWF  FF7
15152:  MOVLW  00
15154:  MOVWF  FF8
15156:  CLRF   1B
15158:  BTFSC  FF2.7
1515A:  BSF    1B.7
1515C:  BCF    FF2.7
1515E:  CALL   0E30
15162:  BTFSC  1B.7
15164:  BSF    FF2.7
....................          break;    
15166:  MOVLB  8
15168:  BRA    1518C
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
1516A:  MOVLW  A4
1516C:  MOVWF  FF6
1516E:  MOVLW  21
15170:  MOVWF  FF7
15172:  MOVLW  00
15174:  MOVWF  FF8
15176:  CLRF   1B
15178:  BTFSC  FF2.7
1517A:  BSF    1B.7
1517C:  BCF    FF2.7
1517E:  CALL   0E30
15182:  BTFSC  1B.7
15184:  BSF    FF2.7
....................          break;           
15186:  MOVLB  8
15188:  BRA    1518C
1518A:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
1518C:  MOVLW  01
1518E:  MOVWF  1E
15190:  MOVLW  A3
15192:  MOVWF  1D
15194:  MOVLW  AC
15196:  MOVWF  FF6
15198:  MOVLW  21
1519A:  MOVWF  FF7
1519C:  MOVLW  00
1519E:  MOVWF  FF8
151A0:  MOVLW  07
151A2:  MOVWF  xC7
151A4:  MOVLB  0
151A6:  CALL   AA0E
151AA:  MOVFF  873,8C9
151AE:  MOVLW  1B
151B0:  MOVLB  8
151B2:  MOVWF  xCA
151B4:  MOVLB  0
151B6:  CALL   51FE
151BA:  MOVLW  B5
151BC:  MOVWF  FF6
151BE:  MOVLW  21
151C0:  MOVWF  FF7
151C2:  MOVLW  00
151C4:  MOVWF  FF8
151C6:  MOVLW  09
151C8:  MOVLB  8
151CA:  MOVWF  xC7
151CC:  MOVLB  0
151CE:  CALL   AA0E
151D2:  MOVFF  878,8DB
151D6:  CALL   501C
151DA:  MOVLW  C0
151DC:  MOVWF  FF6
151DE:  MOVLW  21
151E0:  MOVWF  FF7
151E2:  MOVLW  00
151E4:  MOVWF  FF8
151E6:  MOVLW  07
151E8:  MOVLB  8
151EA:  MOVWF  xC7
151EC:  MOVLB  0
151EE:  CALL   AA0E
151F2:  MOVLW  10
151F4:  MOVWF  FE9
151F6:  MOVFF  877,8D3
151FA:  MOVFF  876,8D2
151FE:  CALL   AA40
15202:  MOVLW  CA
15204:  MOVWF  FF6
15206:  MOVLW  21
15208:  MOVWF  FF7
1520A:  MOVLW  00
1520C:  MOVWF  FF8
1520E:  MOVLW  03
15210:  MOVLB  8
15212:  MOVWF  xC7
15214:  MOVLB  0
15216:  CALL   AA0E
....................    record_event(); 
1521A:  CALL   8424
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
1521E:  MOVLB  8
15220:  MOVF   x78,W
15222:  SUBLW  66
15224:  BZ    15234
15226:  MOVF   x78,W
15228:  SUBLW  67
1522A:  BZ    15234
1522C:  MOVLB  0
1522E:  CALL   A9A2
15232:  MOVLB  8
15234:  MOVLB  0
15236:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15A8C:  MOVLW  01
15A8E:  MOVLB  8
15A90:  MOVWF  x6B
....................    while (macro_batch == TRUE){ 
15A92:  DECFSZ x6B,W
15A94:  BRA    15D1A
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15A96:  MOVFF  38,9E9
15A9A:  MOVFF  37,9E8
15A9E:  MOVLB  9
15AA0:  CLRF   xEB
15AA2:  MOVLW  03
15AA4:  MOVWF  xEA
15AA6:  MOVLB  0
15AA8:  CALL   5C22
15AAC:  MOVF   01,W
15AAE:  MOVLB  7
15AB0:  ADDWF  xCC,W
15AB2:  MOVLB  8
15AB4:  MOVWF  x66
15AB6:  MOVF   02,W
15AB8:  MOVLB  7
15ABA:  ADDWFC xCD,W
15ABC:  MOVLB  8
15ABE:  MOVWF  x67
....................       init_ext_eeprom(); 
15AC0:  MOVLB  0
15AC2:  CALL   FFE4
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
15AC6:  MOVFF  867,8A8
15ACA:  MOVFF  866,8A7
15ACE:  CALL   102F0
15AD2:  MOVFF  01,868
....................       ++addr; 
15AD6:  MOVLB  8
15AD8:  INCF   x66,F
15ADA:  BTFSC  FD8.2
15ADC:  INCF   x67,F
....................       macro_arg = read16_ext_eeprom(addr); 
15ADE:  MOVFF  867,89F
15AE2:  MOVFF  866,89E
15AE6:  MOVLB  0
15AE8:  CALL   10404
15AEC:  MOVFF  02,86A
15AF0:  MOVFF  01,869
....................       ++addr; 
15AF4:  MOVLB  8
15AF6:  INCF   x66,F
15AF8:  BTFSC  FD8.2
15AFA:  INCF   x67,F
....................       ++addr;      
15AFC:  INCF   x66,F
15AFE:  BTFSC  FD8.2
15B00:  INCF   x67,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
15B02:  MOVF   x68,W
15B04:  SUBLW  4D
15B06:  BTFSS  FD8.2
15B08:  BRA    15C32
15B0A:  MOVF   x69,F
15B0C:  BNZ   15B14
15B0E:  MOVF   x6A,F
15B10:  BTFSC  FD8.2
15B12:  BRA    15C32
....................          { 
....................          RTC_reset_HT(); 
15B14:  MOVLB  0
15B16:  CALL   3430
....................          RTC_read(); 
15B1A:  CALL   32C2
....................          RTC_display(); 
15B1E:  CALL   DF8A
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
15B22:  MOVLW  CE
15B24:  MOVWF  FF6
15B26:  MOVLW  21
15B28:  MOVWF  FF7
15B2A:  MOVLW  00
15B2C:  MOVWF  FF8
15B2E:  CLRF   1B
15B30:  BTFSC  FF2.7
15B32:  BSF    1B.7
15B34:  BCF    FF2.7
15B36:  MOVLW  09
15B38:  MOVLB  A
15B3A:  MOVWF  x18
15B3C:  MOVLB  0
15B3E:  CALL   1006
15B42:  BTFSC  1B.7
15B44:  BSF    FF2.7
15B46:  MOVLB  8
15B48:  MOVF   x68,W
15B4A:  BTFSS  F9E.4
15B4C:  BRA    15B4A
15B4E:  MOVWF  FAD
15B50:  MOVLW  10
15B52:  MOVWF  FE9
15B54:  CLRF   1B
15B56:  BTFSC  FF2.7
15B58:  BSF    1B.7
15B5A:  BCF    FF2.7
15B5C:  MOVFF  86A,A19
15B60:  MOVFF  869,A18
15B64:  MOVLB  0
15B66:  CALL   1188
15B6A:  BTFSC  1B.7
15B6C:  BSF    FF2.7
15B6E:  MOVLW  DC
15B70:  MOVWF  FF6
15B72:  MOVLW  21
15B74:  MOVWF  FF7
15B76:  MOVLW  00
15B78:  MOVWF  FF8
15B7A:  CLRF   1B
15B7C:  BTFSC  FF2.7
15B7E:  BSF    1B.7
15B80:  BCF    FF2.7
15B82:  MOVLW  03
15B84:  MOVLB  A
15B86:  MOVWF  x18
15B88:  MOVLB  0
15B8A:  CALL   1006
15B8E:  BTFSC  1B.7
15B90:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
15B92:  MOVLW  01
15B94:  ADDWF  21,W
15B96:  MOVLB  8
15B98:  MOVWF  x6C
15B9A:  MOVLW  00
15B9C:  ADDWFC 22,W
15B9E:  MOVWF  x6D
15BA0:  MOVLW  E0
15BA2:  MOVWF  FF6
15BA4:  MOVLW  21
15BA6:  MOVWF  FF7
15BA8:  MOVLW  00
15BAA:  MOVWF  FF8
15BAC:  CLRF   1B
15BAE:  BTFSC  FF2.7
15BB0:  BSF    1B.7
15BB2:  BCF    FF2.7
15BB4:  MOVLW  07
15BB6:  MOVLB  A
15BB8:  MOVWF  x18
15BBA:  MOVLB  0
15BBC:  CALL   1006
15BC0:  BTFSC  1B.7
15BC2:  BSF    FF2.7
15BC4:  MOVLW  09
15BC6:  MOVWF  FE9
15BC8:  CLRF   1B
15BCA:  BTFSC  FF2.7
15BCC:  BSF    1B.7
15BCE:  BCF    FF2.7
15BD0:  MOVFF  86D,A19
15BD4:  MOVFF  86C,A18
15BD8:  CALL   1188
15BDC:  BTFSC  1B.7
15BDE:  BSF    FF2.7
15BE0:  MOVLW  EC
15BE2:  MOVWF  FF6
15BE4:  MOVLW  21
15BE6:  MOVWF  FF7
15BE8:  MOVLW  00
15BEA:  MOVWF  FF8
15BEC:  CLRF   1B
15BEE:  BTFSC  FF2.7
15BF0:  BSF    1B.7
15BF2:  BCF    FF2.7
15BF4:  MOVLW  04
15BF6:  MOVLB  A
15BF8:  MOVWF  x18
15BFA:  MOVLB  0
15BFC:  CALL   1006
15C00:  BTFSC  1B.7
15C02:  BSF    FF2.7
15C04:  MOVLW  09
15C06:  MOVWF  FE9
15C08:  CLRF   1B
15C0A:  BTFSC  FF2.7
15C0C:  BSF    1B.7
15C0E:  BCF    FF2.7
15C10:  MOVFF  28,A19
15C14:  MOVFF  27,A18
15C18:  CALL   1188
15C1C:  BTFSC  1B.7
15C1E:  BSF    FF2.7
15C20:  MOVLW  0D
15C22:  BTFSS  F9E.4
15C24:  BRA    15C22
15C26:  MOVWF  FAD
15C28:  MOVLW  0A
15C2A:  BTFSS  F9E.4
15C2C:  BRA    15C2A
15C2E:  MOVWF  FAD
15C30:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
15C32:  MOVF   28,W
15C34:  SUBWF  22,W
15C36:  BNC   15C44
15C38:  BNZ   15C40
15C3A:  MOVF   27,W
15C3C:  SUBWF  21,W
15C3E:  BNC   15C44
....................          {macro_cmd = 'Z';} 
15C40:  MOVLW  5A
15C42:  MOVWF  x68
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
15C44:  MOVF   x68,W
15C46:  XORLW  72
15C48:  MOVLB  0
15C4A:  BZ    15C5E
15C4C:  XORLW  57
15C4E:  BZ    15C80
15C50:  XORLW  68
15C52:  BZ    15CB6
15C54:  XORLW  17
15C56:  BZ    15CEC
15C58:  XORLW  61
15C5A:  BZ    15CF8
15C5C:  BRA    15D02
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
15C5E:  INCF   37,F
15C60:  BTFSC  FD8.2
15C62:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
15C64:  MOVLB  8
15C66:  CLRF   x5B
15C68:  CLRF   x5A
15C6A:  MOVFF  38,859
15C6E:  MOVFF  37,858
....................                master_macro_loop_count = macro_arg; 
15C72:  CLRF   x57
15C74:  CLRF   x56
15C76:  MOVFF  86A,855
15C7A:  MOVFF  869,854
....................             break; 
15C7E:  BRA    15D0E
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
15C80:  MOVLB  8
15C82:  MOVF   x57,F
15C84:  BNZ   15C94
15C86:  MOVF   x56,F
15C88:  BNZ   15C94
15C8A:  MOVF   x55,F
15C8C:  BNZ   15C94
15C8E:  MOVF   x54,W
15C90:  SUBLW  01
15C92:  BC    15CAE
....................                   nv_macro_step = master_macro_loop_start; 
15C94:  MOVFF  859,38
15C98:  MOVFF  858,37
....................                   master_macro_loop_count--; 
15C9C:  MOVLW  FF
15C9E:  ADDWF  x54,F
15CA0:  BTFSS  FD8.0
15CA2:  ADDWF  x55,F
15CA4:  BTFSS  FD8.0
15CA6:  ADDWF  x56,F
15CA8:  BTFSS  FD8.0
15CAA:  ADDWF  x57,F
....................                }else{ 
15CAC:  BRA    15CB4
....................                   nv_macro_step++; 
15CAE:  INCF   37,F
15CB0:  BTFSC  FD8.2
15CB2:  INCF   38,F
....................                } 
....................             break; 
15CB4:  BRA    15D0E
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
15CB6:  MOVLB  8
15CB8:  MOVF   x6A,F
15CBA:  BNZ   15CEA
15CBC:  MOVF   x69,W
15CBE:  SUBLW  14
15CC0:  BNC   15CEA
....................                   play_macro(macro_arg,0);     // casts to int8 
15CC2:  MOVFF  869,873
15CC6:  CLRF   x75
15CC8:  CLRF   x74
15CCA:  MOVLB  0
15CCC:  CALL   14F00
....................                   delay_ms(100); 
15CD0:  MOVLW  64
15CD2:  MOVLB  9
15CD4:  MOVWF  xC8
15CD6:  MOVLB  0
15CD8:  CALL   288E
....................                   ++nv_sample; 
15CDC:  INCF   21,F
15CDE:  BTFSC  FD8.2
15CE0:  INCF   22,F
....................                   ++nv_macro_step; 
15CE2:  INCF   37,F
15CE4:  BTFSC  FD8.2
15CE6:  INCF   38,F
15CE8:  MOVLB  8
....................                } 
....................                break; 
15CEA:  BRA    15D0E
....................             case 'Z' : ++nv_macro_step; 
15CEC:  INCF   37,F
15CEE:  BTFSC  FD8.2
15CF0:  INCF   38,F
....................                        macro_batch = FALSE; 
15CF2:  MOVLB  8
15CF4:  CLRF   x6B
....................                break; 
15CF6:  BRA    15D0E
....................             case ';' : nv_macro_step = 0; 
15CF8:  CLRF   38
15CFA:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
15CFC:  MOVLB  8
15CFE:  BRA    15D0E
15D00:  MOVLB  0
....................             default  : cmd_err(); 
15D02:  CALL   BC3C
....................                        macro_cmd = 'e'; 
15D06:  MOVLW  65
15D08:  MOVLB  8
15D0A:  MOVWF  x68
....................                        macro_batch = FALSE; 
15D0C:  CLRF   x6B
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
15D0E:  DECFSZ 4C,W
15D10:  BRA    15D18
....................             macro_cmd = ';'; 
15D12:  MOVLW  3B
15D14:  MOVWF  x68
....................             break;         // 17 = CTRL-Q (quit) 
15D16:  BRA    15D1A
....................          } 
15D18:  BRA    15A92
....................    } 
....................    return (macro_cmd); 
15D1A:  MOVFF  868,01
15D1E:  MOVLB  0
15D20:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D0AE:  MOVLB  8
0D0B0:  MOVF   x68,W
0D0B2:  XORLW  2B
0D0B4:  MOVLB  0
0D0B6:  BZ    D0E6
0D0B8:  XORLW  06
0D0BA:  BZ    D10E
0D0BC:  XORLW  6F
0D0BE:  BZ    D136
0D0C0:  XORLW  05
0D0C2:  BZ    D148
0D0C4:  XORLW  17
0D0C6:  BZ    D15E
0D0C8:  XORLW  01
0D0CA:  BZ    D18E
0D0CC:  XORLW  03
0D0CE:  BTFSC  FD8.2
0D0D0:  BRA    D1B6
0D0D2:  XORLW  06
0D0D4:  BTFSC  FD8.2
0D0D6:  BRA    D1DE
0D0D8:  XORLW  0D
0D0DA:  BTFSC  FD8.2
0D0DC:  BRA    D1F2
0D0DE:  XORLW  62
0D0E0:  BTFSC  FD8.2
0D0E2:  BRA    D21A
0D0E4:  BRA    D222
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D0E6:  MOVLW  01
0D0E8:  MOVLB  7
0D0EA:  MOVWF  x3C
....................                  move_motor(0,0,macro_arg,1); 
0D0EC:  MOVLB  8
0D0EE:  CLRF   xA3
0D0F0:  CLRF   xA4
0D0F2:  CLRF   xA8
0D0F4:  CLRF   xA7
0D0F6:  MOVFF  86A,8A6
0D0FA:  MOVFF  869,8A5
0D0FE:  MOVWF  xA9
0D100:  MOVLB  0
0D102:  CALL   9CC2
....................                  macro_status=step_err_status(); 
0D106:  RCALL  D006
0D108:  MOVFF  01,86B
....................          break; 
0D10C:  BRA    D222
....................       case '-' : motor=1; 
0D10E:  MOVLW  01
0D110:  MOVLB  7
0D112:  MOVWF  x3C
....................                  move_motor(0,1,macro_arg,1); 
0D114:  MOVLB  8
0D116:  CLRF   xA3
0D118:  MOVWF  xA4
0D11A:  CLRF   xA8
0D11C:  CLRF   xA7
0D11E:  MOVFF  86A,8A6
0D122:  MOVFF  869,8A5
0D126:  MOVWF  xA9
0D128:  MOVLB  0
0D12A:  CALL   9CC2
....................                  macro_status=step_err_status(); 
0D12E:  RCALL  D006
0D130:  MOVFF  01,86B
....................          break; 
0D134:  BRA    D222
....................       case 'B' : h_bridge(macro_arg); 
0D136:  MOVFF  869,891
0D13A:  CALL   BECC
....................                  macro_status = 'a'; 
0D13E:  MOVLW  61
0D140:  MOVLB  8
0D142:  MOVWF  x6B
....................          break; 
0D144:  MOVLB  0
0D146:  BRA    D222
....................       case 'G' : motor=0; 
0D148:  MOVLB  7
0D14A:  CLRF   x3C
....................                  align(0); 
0D14C:  MOVLB  8
0D14E:  CLRF   x9E
0D150:  MOVLB  0
0D152:  CALL   A7FE
....................                  macro_status=step_err_status(); 
0D156:  RCALL  D006
0D158:  MOVFF  01,86B
....................          break ;           
0D15C:  BRA    D222
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D15E:  MOVFF  86A,2E
0D162:  MOVFF  869,2D
....................                  motor=0; 
0D166:  MOVLB  7
0D168:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1);   
0D16A:  MOVLB  8
0D16C:  CLRF   xA3
0D16E:  CLRF   xA4
0D170:  CLRF   xA8
0D172:  CLRF   xA7
0D174:  MOVFF  86A,8A6
0D178:  MOVFF  869,8A5
0D17C:  MOVLW  01
0D17E:  MOVWF  xA9
0D180:  MOVLB  0
0D182:  CALL   9CC2
....................                  macro_status=step_err_status(); 
0D186:  RCALL  D006
0D188:  MOVFF  01,86B
....................          break; 
0D18C:  BRA    D222
....................       case 'Q' : motor=0; 
0D18E:  MOVLB  7
0D190:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1); 
0D192:  MOVLB  8
0D194:  CLRF   xA3
0D196:  CLRF   xA4
0D198:  CLRF   xA8
0D19A:  CLRF   xA7
0D19C:  MOVFF  86A,8A6
0D1A0:  MOVFF  869,8A5
0D1A4:  MOVLW  01
0D1A6:  MOVWF  xA9
0D1A8:  MOVLB  0
0D1AA:  CALL   9CC2
....................                  macro_status=step_err_status(); 
0D1AE:  RCALL  D006
0D1B0:  MOVFF  01,86B
....................          break; 
0D1B4:  BRA    D222
....................       case 'R' : motor=0; 
0D1B6:  MOVLB  7
0D1B8:  CLRF   x3C
....................                  move_motor(0,1,macro_arg,1); 
0D1BA:  MOVLB  8
0D1BC:  CLRF   xA3
0D1BE:  MOVLW  01
0D1C0:  MOVWF  xA4
0D1C2:  CLRF   xA8
0D1C4:  CLRF   xA7
0D1C6:  MOVFF  86A,8A6
0D1CA:  MOVFF  869,8A5
0D1CE:  MOVWF  xA9
0D1D0:  MOVLB  0
0D1D2:  CALL   9CC2
....................                  macro_status=step_err_status(); 
0D1D6:  RCALL  D006
0D1D8:  MOVFF  01,86B
....................          break; 
0D1DC:  BRA    D222
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D1DE:  MOVFF  86A,89F
0D1E2:  MOVFF  869,89E
0D1E6:  RCALL  D03E
....................                  macro_status = 'a'; 
0D1E8:  MOVLW  61
0D1EA:  MOVLB  8
0D1EC:  MOVWF  x6B
....................          break; 
0D1EE:  MOVLB  0
0D1F0:  BRA    D222
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D1F2:  MOVLB  8
0D1F4:  DECFSZ x69,W
0D1F6:  BRA    D204
0D1F8:  MOVF   x6A,F
0D1FA:  BNZ   D204
0D1FC:  MOVLB  0
0D1FE:  RCALL  D074
0D200:  BRA    D210
0D202:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D204:  MOVF   x69,F
0D206:  BNZ   D212
0D208:  MOVF   x6A,F
0D20A:  BNZ   D212
0D20C:  MOVLB  0
0D20E:  RCALL  D098
0D210:  MOVLB  8
....................                  macro_status = 'a'; 
0D212:  MOVLW  61
0D214:  MOVWF  x6B
....................          break;           
0D216:  MOVLB  0
0D218:  BRA    D222
....................       case ';' : macro_status = 'f'; 
0D21A:  MOVLW  66
0D21C:  MOVLB  8
0D21E:  MOVWF  x6B
....................          break;            
0D220:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D222:  MOVLB  8
0D224:  MOVFF  86B,01
0D228:  MOVLB  0
0D22A:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D504:  MOVF   2E,F
0D506:  BNZ   D50E
0D508:  MOVF   2D,W
0D50A:  SUBLW  01
0D50C:  BC    D520
0D50E:  MOVF   2E,F
0D510:  BNZ   D520
0D512:  MOVF   2D,W
0D514:  SUBLW  30
0D516:  BNC   D520
0D518:  DECFSZ 2F,W
0D51A:  BRA    D520
0D51C:  MOVF   30,F
0D51E:  BZ    D53E
0D520:  MOVF   2E,F
0D522:  BNZ   D52A
0D524:  MOVF   2D,W
0D526:  SUBLW  01
0D528:  BC    D548
0D52A:  MOVF   2E,F
0D52C:  BNZ   D548
0D52E:  MOVF   2D,W
0D530:  SUBLW  32
0D532:  BNC   D548
0D534:  MOVF   2F,W
0D536:  SUBLW  03
0D538:  BNZ   D548
0D53A:  MOVF   30,F
0D53C:  BNZ   D548
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D53E:  MOVLW  61
0D540:  MOVLB  8
0D542:  MOVWF  x67
....................    } 
0D544:  BRA    D550
0D546:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D548:  MOVLW  65
0D54A:  MOVLB  8
0D54C:  MOVWF  x67
....................       goto end_macro;       
0D54E:  BRA    D600
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D550:  MOVLW  59
0D552:  MOVWF  x68
0D554:  CLRF   x6A
0D556:  MOVLW  01
0D558:  MOVWF  x69
0D55A:  MOVLB  0
0D55C:  RCALL  D0AE
0D55E:  MOVFF  01,867
....................    if (macro_status != 'a') goto end_macro; 
0D562:  MOVLB  8
0D564:  MOVF   x67,W
0D566:  SUBLW  61
0D568:  BTFSS  FD8.2
0D56A:  BRA    D600
....................    macro_status = play_wms_macro_cmd('G',1); 
0D56C:  MOVLW  47
0D56E:  MOVWF  x68
0D570:  CLRF   x6A
0D572:  MOVLW  01
0D574:  MOVWF  x69
0D576:  MOVLB  0
0D578:  RCALL  D0AE
0D57A:  MOVFF  01,867
....................    if (macro_status != 'a') goto end_macro; 
0D57E:  MOVLB  8
0D580:  MOVF   x67,W
0D582:  SUBLW  61
0D584:  BTFSS  FD8.2
0D586:  BRA    D600
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D588:  MOVLW  2D
0D58A:  MOVWF  x68
0D58C:  MOVFF  2C,86A
0D590:  MOVFF  2B,869
0D594:  MOVLB  0
0D596:  RCALL  D0AE
0D598:  MOVFF  01,867
....................    if (macro_status != 'a') goto end_macro; 
0D59C:  MOVLB  8
0D59E:  MOVF   x67,W
0D5A0:  SUBLW  61
0D5A2:  BTFSS  FD8.2
0D5A4:  BRA    D600
....................    macro_status = play_wms_macro_cmd('P',port); 
0D5A6:  MOVLW  50
0D5A8:  MOVWF  x68
0D5AA:  MOVFF  866,86A
0D5AE:  MOVFF  865,869
0D5B2:  MOVLB  0
0D5B4:  RCALL  D0AE
0D5B6:  MOVFF  01,867
....................    if (macro_status != 'a') goto end_macro;    
0D5BA:  MOVLB  8
0D5BC:  MOVF   x67,W
0D5BE:  SUBLW  61
0D5C0:  BTFSS  FD8.2
0D5C2:  BRA    D600
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D5C4:  MOVLW  2B
0D5C6:  MOVWF  x68
0D5C8:  MOVFF  2C,86A
0D5CC:  MOVFF  2B,869
0D5D0:  MOVLB  0
0D5D2:  RCALL  D0AE
0D5D4:  MOVFF  01,867
....................    if (macro_status != 'a') goto end_macro; 
0D5D8:  MOVLB  8
0D5DA:  MOVF   x67,W
0D5DC:  SUBLW  61
0D5DE:  BTFSS  FD8.2
0D5E0:  BRA    D600
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D5E2:  MOVLW  59
0D5E4:  MOVWF  x68
0D5E6:  CLRF   x6A
0D5E8:  CLRF   x69
0D5EA:  MOVLB  0
0D5EC:  RCALL  D0AE
0D5EE:  MOVFF  01,867
....................    if (macro_status != 'a') goto end_macro; 
0D5F2:  MOVLB  8
0D5F4:  MOVF   x67,W
0D5F6:  SUBLW  61
0D5F8:  BTFSS  FD8.2
0D5FA:  BRA    D600
....................    macro_status='f';  
0D5FC:  MOVLW  66
0D5FE:  MOVWF  x67
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D600:  CLRF   x79
0D602:  MOVLB  0
0D604:  RCALL  D342
....................    
....................    switch(macro_status){ 
0D606:  MOVLW  61
0D608:  MOVLB  8
0D60A:  SUBWF  x67,W
0D60C:  ADDLW  FA
0D60E:  BC    D6E2
0D610:  ADDLW  06
0D612:  MOVLB  0
0D614:  GOTO   D6E6
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D618:  MOVF   1F,F
0D61A:  BNZ   D620
0D61C:  MOVF   20,F
0D61E:  BZ    D63C
0D620:  MOVLW  F8
0D622:  MOVWF  FF6
0D624:  MOVLW  21
0D626:  MOVWF  FF7
0D628:  MOVLW  00
0D62A:  MOVWF  FF8
0D62C:  CLRF   1B
0D62E:  BTFSC  FF2.7
0D630:  BSF    1B.7
0D632:  BCF    FF2.7
0D634:  CALL   0E30
0D638:  BTFSC  1B.7
0D63A:  BSF    FF2.7
....................          break; 
0D63C:  MOVLB  8
0D63E:  BRA    D6E2
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D640:  MOVLW  00
0D642:  MOVWF  FF6
0D644:  MOVLW  22
0D646:  MOVWF  FF7
0D648:  MOVLW  00
0D64A:  MOVWF  FF8
0D64C:  CLRF   1B
0D64E:  BTFSC  FF2.7
0D650:  BSF    1B.7
0D652:  BCF    FF2.7
0D654:  CALL   0E30
0D658:  BTFSC  1B.7
0D65A:  BSF    FF2.7
....................          break; 
0D65C:  MOVLB  8
0D65E:  BRA    D6E2
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D660:  MOVLW  08
0D662:  MOVWF  FF6
0D664:  MOVLW  22
0D666:  MOVWF  FF7
0D668:  MOVLW  00
0D66A:  MOVWF  FF8
0D66C:  CLRF   1B
0D66E:  BTFSC  FF2.7
0D670:  BSF    1B.7
0D672:  BCF    FF2.7
0D674:  CALL   0E30
0D678:  BTFSC  1B.7
0D67A:  BSF    FF2.7
....................          break; 
0D67C:  MOVLB  8
0D67E:  BRA    D6E2
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D680:  MOVLW  10
0D682:  MOVWF  FF6
0D684:  MOVLW  22
0D686:  MOVWF  FF7
0D688:  MOVLW  00
0D68A:  MOVWF  FF8
0D68C:  CLRF   1B
0D68E:  BTFSC  FF2.7
0D690:  BSF    1B.7
0D692:  BCF    FF2.7
0D694:  CALL   0E30
0D698:  BTFSC  1B.7
0D69A:  BSF    FF2.7
....................          break; 
0D69C:  MOVLB  8
0D69E:  BRA    D6E2
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D6A0:  MOVLW  18
0D6A2:  MOVWF  FF6
0D6A4:  MOVLW  22
0D6A6:  MOVWF  FF7
0D6A8:  MOVLW  00
0D6AA:  MOVWF  FF8
0D6AC:  CLRF   1B
0D6AE:  BTFSC  FF2.7
0D6B0:  BSF    1B.7
0D6B2:  BCF    FF2.7
0D6B4:  CALL   0E30
0D6B8:  BTFSC  1B.7
0D6BA:  BSF    FF2.7
....................          break;    
0D6BC:  MOVLB  8
0D6BE:  BRA    D6E2
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D6C0:  MOVLW  20
0D6C2:  MOVWF  FF6
0D6C4:  MOVLW  22
0D6C6:  MOVWF  FF7
0D6C8:  MOVLW  00
0D6CA:  MOVWF  FF8
0D6CC:  CLRF   1B
0D6CE:  BTFSC  FF2.7
0D6D0:  BSF    1B.7
0D6D2:  BCF    FF2.7
0D6D4:  CALL   0E30
0D6D8:  BTFSC  1B.7
0D6DA:  BSF    FF2.7
....................          break;           
0D6DC:  MOVLB  8
0D6DE:  BRA    D6E2
0D6E0:  MOVLB  8
....................    } 
0D6E2:  MOVLB  0
0D6E4:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
15F62:  MOVLB  8
15F64:  MOVF   x64,W
15F66:  BTFSC  FD8.2
15F68:  DECF   x65,F
15F6A:  DECF   x64,F
....................    addr = macro_address[0] + (step*9); 
15F6C:  MOVFF  865,9E9
15F70:  MOVFF  864,9E8
15F74:  MOVLB  9
15F76:  CLRF   xEB
15F78:  MOVLW  09
15F7A:  MOVWF  xEA
15F7C:  MOVLB  0
15F7E:  CALL   5C22
15F82:  MOVF   01,W
15F84:  MOVLB  7
15F86:  ADDWF  xCC,W
15F88:  MOVLB  8
15F8A:  MOVWF  x66
15F8C:  MOVF   02,W
15F8E:  MOVLB  7
15F90:  ADDWFC xCD,W
15F92:  MOVLB  8
15F94:  MOVWF  x67
....................     
....................    init_ext_eeprom(); 
15F96:  MOVLB  0
15F98:  CALL   FFE4
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
15F9C:  MOVFF  867,8A8
15FA0:  MOVFF  866,8A7
15FA4:  CALL   102F0
15FA8:  MOVFF  01,868
....................    ++addr; 
15FAC:  MOVLB  8
15FAE:  INCF   x66,F
15FB0:  BTFSC  FD8.2
15FB2:  INCF   x67,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
15FB4:  MOVFF  867,89F
15FB8:  MOVFF  866,89E
15FBC:  MOVLB  0
15FBE:  CALL   10404
15FC2:  MOVFF  02,86C
15FC6:  MOVFF  01,86B
....................    ++addr; 
15FCA:  MOVLB  8
15FCC:  INCF   x66,F
15FCE:  BTFSC  FD8.2
15FD0:  INCF   x67,F
....................    ++addr; 
15FD2:  INCF   x66,F
15FD4:  BTFSC  FD8.2
15FD6:  INCF   x67,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
15FD8:  MOVFF  867,8A8
15FDC:  MOVFF  866,8A7
15FE0:  MOVLB  0
15FE2:  CALL   102F0
15FE6:  MOVFF  01,869
....................    ++addr; 
15FEA:  MOVLB  8
15FEC:  INCF   x66,F
15FEE:  BTFSC  FD8.2
15FF0:  INCF   x67,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
15FF2:  MOVFF  867,89F
15FF6:  MOVFF  866,89E
15FFA:  MOVLB  0
15FFC:  CALL   10404
16000:  MOVFF  02,86E
16004:  MOVFF  01,86D
....................    ++addr; 
16008:  MOVLB  8
1600A:  INCF   x66,F
1600C:  BTFSC  FD8.2
1600E:  INCF   x67,F
....................    ++addr; 
16010:  INCF   x66,F
16012:  BTFSC  FD8.2
16014:  INCF   x67,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
16016:  MOVFF  867,8A8
1601A:  MOVFF  866,8A7
1601E:  MOVLB  0
16020:  CALL   102F0
16024:  MOVFF  01,86A
....................    ++addr; 
16028:  MOVLB  8
1602A:  INCF   x66,F
1602C:  BTFSC  FD8.2
1602E:  INCF   x67,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
16030:  MOVFF  867,89F
16034:  MOVFF  866,89E
16038:  MOVLB  0
1603A:  CALL   10404
1603E:  MOVFF  02,870
16042:  MOVFF  01,86F
....................    ++addr; 
16046:  MOVLB  8
16048:  INCF   x66,F
1604A:  BTFSC  FD8.2
1604C:  INCF   x67,F
....................    ++addr; 
1604E:  INCF   x66,F
16050:  BTFSC  FD8.2
16052:  INCF   x67,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16054:  MOVFF  867,8A8
16058:  MOVFF  866,8A7
1605C:  MOVLB  0
1605E:  CALL   102F0
16062:  MOVFF  01,871
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
16066:  MOVLB  8
16068:  MOVF   x68,W
1606A:  SUBLW  4A
1606C:  BTFSS  FD8.2
1606E:  BRA    16144
16070:  MOVF   x69,W
16072:  SUBLW  50
16074:  BNZ   16144
16076:  MOVF   x6A,W
16078:  SUBLW  4D
1607A:  BNZ   16144
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
1607C:  MOVF   x68,W
1607E:  BTFSS  F9E.4
16080:  BRA    1607E
16082:  MOVWF  FAD
16084:  MOVLW  10
16086:  MOVWF  FE9
16088:  CLRF   1B
1608A:  BTFSC  FF2.7
1608C:  BSF    1B.7
1608E:  BCF    FF2.7
16090:  MOVFF  86C,A19
16094:  MOVFF  86B,A18
16098:  MOVLB  0
1609A:  CALL   1188
1609E:  BTFSC  1B.7
160A0:  BSF    FF2.7
160A2:  MOVLW  2C
160A4:  BTFSS  F9E.4
160A6:  BRA    160A4
160A8:  MOVWF  FAD
160AA:  MOVLB  8
160AC:  MOVF   x69,W
160AE:  BTFSS  F9E.4
160B0:  BRA    160AE
160B2:  MOVWF  FAD
160B4:  MOVLW  10
160B6:  MOVWF  FE9
160B8:  CLRF   1B
160BA:  BTFSC  FF2.7
160BC:  BSF    1B.7
160BE:  BCF    FF2.7
160C0:  MOVFF  86E,A19
160C4:  MOVFF  86D,A18
160C8:  MOVLB  0
160CA:  CALL   1188
160CE:  BTFSC  1B.7
160D0:  BSF    FF2.7
160D2:  MOVLW  2C
160D4:  BTFSS  F9E.4
160D6:  BRA    160D4
160D8:  MOVWF  FAD
160DA:  MOVLB  8
160DC:  MOVF   x6A,W
160DE:  BTFSS  F9E.4
160E0:  BRA    160DE
160E2:  MOVWF  FAD
160E4:  MOVLW  10
160E6:  MOVWF  FE9
160E8:  CLRF   1B
160EA:  BTFSC  FF2.7
160EC:  BSF    1B.7
160EE:  BCF    FF2.7
160F0:  MOVFF  870,A19
160F4:  MOVFF  86F,A18
160F8:  MOVLB  0
160FA:  CALL   1188
160FE:  BTFSC  1B.7
16100:  BSF    FF2.7
16102:  MOVLW  0D
16104:  BTFSS  F9E.4
16106:  BRA    16104
16108:  MOVWF  FAD
1610A:  MOVLW  0A
1610C:  BTFSS  F9E.4
1610E:  BRA    1610C
16110:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
16112:  MOVFF  86C,24
16116:  MOVFF  86B,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
1611A:  MOVLB  8
1611C:  MOVF   x6F,F
1611E:  BNZ   16124
16120:  MOVF   x70,F
16122:  BZ    16142
16124:  MOVF   x70,F
16126:  BNZ   16142
16128:  MOVF   x6F,W
1612A:  SUBLW  10
1612C:  BNC   16142
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
1612E:  MOVFF  86F,873
16132:  MOVFF  86E,875
16136:  MOVFF  86D,874
1613A:  MOVLB  0
1613C:  CALL   14F00
16140:  MOVLB  8
....................       } 
....................    } 
16142:  BRA    16150
....................    else { 
....................       cmd_err(); 
16144:  MOVLB  0
16146:  CALL   BC3C
....................       macro_end = 59; 
1614A:  MOVLW  3B
1614C:  MOVLB  8
1614E:  MOVWF  x71
....................    } 
....................     
....................    return (macro_end); 
16150:  MOVFF  871,01
16154:  MOVLB  0
16156:  GOTO   16240 (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
16342:  MOVLB  8
16344:  MOVF   x68,W
16346:  BTFSC  FD8.2
16348:  DECF   x69,F
1634A:  DECF   x68,F
....................    addr = macro_address[0] + (step*6); 
1634C:  MOVFF  869,9E9
16350:  MOVFF  868,9E8
16354:  MOVLB  9
16356:  CLRF   xEB
16358:  MOVLW  06
1635A:  MOVWF  xEA
1635C:  MOVLB  0
1635E:  CALL   5C22
16362:  MOVF   01,W
16364:  MOVLB  7
16366:  ADDWF  xCC,W
16368:  MOVLB  8
1636A:  MOVWF  x6A
1636C:  MOVF   02,W
1636E:  MOVLB  7
16370:  ADDWFC xCD,W
16372:  MOVLB  8
16374:  MOVWF  x6B
....................     
....................    init_ext_eeprom(); 
16376:  MOVLB  0
16378:  CALL   FFE4
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
1637C:  MOVFF  86B,8A8
16380:  MOVFF  86A,8A7
16384:  CALL   102F0
16388:  MOVFF  01,86C
....................    ++addr; 
1638C:  MOVLB  8
1638E:  INCF   x6A,F
16390:  BTFSC  FD8.2
16392:  INCF   x6B,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
16394:  MOVFF  86B,89F
16398:  MOVFF  86A,89E
1639C:  MOVLB  0
1639E:  CALL   10404
163A2:  MOVFF  02,86F
163A6:  MOVFF  01,86E
....................    ++addr; 
163AA:  MOVLB  8
163AC:  INCF   x6A,F
163AE:  BTFSC  FD8.2
163B0:  INCF   x6B,F
....................    ++addr; 
163B2:  INCF   x6A,F
163B4:  BTFSC  FD8.2
163B6:  INCF   x6B,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
163B8:  MOVFF  86B,8A8
163BC:  MOVFF  86A,8A7
163C0:  MOVLB  0
163C2:  CALL   102F0
163C6:  MOVFF  01,86D
....................    ++addr; 
163CA:  MOVLB  8
163CC:  INCF   x6A,F
163CE:  BTFSC  FD8.2
163D0:  INCF   x6B,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
163D2:  MOVFF  86B,89F
163D6:  MOVFF  86A,89E
163DA:  MOVLB  0
163DC:  CALL   10404
163E0:  MOVFF  02,871
163E4:  MOVFF  01,870
....................    ++addr; 
163E8:  MOVLB  8
163EA:  INCF   x6A,F
163EC:  BTFSC  FD8.2
163EE:  INCF   x6B,F
....................    ++addr; 
163F0:  INCF   x6A,F
163F2:  BTFSC  FD8.2
163F4:  INCF   x6B,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
163F6:  MOVFF  86B,8A8
163FA:  MOVFF  86A,8A7
163FE:  MOVLB  0
16400:  CALL   102F0
16404:  MOVFF  01,872
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
16408:  MOVLB  8
1640A:  MOVF   x6C,W
1640C:  SUBLW  50
1640E:  BNZ   164B2
16410:  MOVF   x6D,W
16412:  SUBLW  4D
16414:  BNZ   164B2
....................        
....................       RTC_read(); 
16416:  MOVLB  0
16418:  CALL   32C2
....................       RTC_display(); 
1641C:  CALL   DF8A
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
16420:  MOVLB  8
16422:  MOVF   x6C,W
16424:  BTFSS  F9E.4
16426:  BRA    16424
16428:  MOVWF  FAD
1642A:  MOVLW  10
1642C:  MOVWF  FE9
1642E:  CLRF   1B
16430:  BTFSC  FF2.7
16432:  BSF    1B.7
16434:  BCF    FF2.7
16436:  MOVFF  86F,A19
1643A:  MOVFF  86E,A18
1643E:  MOVLB  0
16440:  CALL   1188
16444:  BTFSC  1B.7
16446:  BSF    FF2.7
16448:  MOVLW  2C
1644A:  BTFSS  F9E.4
1644C:  BRA    1644A
1644E:  MOVWF  FAD
16450:  MOVLB  8
16452:  MOVF   x6D,W
16454:  BTFSS  F9E.4
16456:  BRA    16454
16458:  MOVWF  FAD
1645A:  MOVLW  10
1645C:  MOVWF  FE9
1645E:  CLRF   1B
16460:  BTFSC  FF2.7
16462:  BSF    1B.7
16464:  BCF    FF2.7
16466:  MOVFF  871,A19
1646A:  MOVFF  870,A18
1646E:  MOVLB  0
16470:  CALL   1188
16474:  BTFSC  1B.7
16476:  BSF    FF2.7
16478:  MOVLW  0D
1647A:  BTFSS  F9E.4
1647C:  BRA    1647A
1647E:  MOVWF  FAD
16480:  MOVLW  0A
16482:  BTFSS  F9E.4
16484:  BRA    16482
16486:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
16488:  MOVLB  8
1648A:  MOVF   x70,F
1648C:  BNZ   16492
1648E:  MOVF   x71,F
16490:  BZ    164B0
16492:  MOVF   x71,F
16494:  BNZ   164B0
16496:  MOVF   x70,W
16498:  SUBLW  10
1649A:  BNC   164B0
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
1649C:  MOVFF  870,873
164A0:  MOVFF  86F,875
164A4:  MOVFF  86E,874
164A8:  MOVLB  0
164AA:  CALL   14F00
164AE:  MOVLB  8
....................       } 
....................    } 
164B0:  BRA    164BE
....................    else { 
....................       cmd_err(); 
164B2:  MOVLB  0
164B4:  CALL   BC3C
....................       macro_end = 59; 
164B8:  MOVLW  3B
164BA:  MOVLB  8
164BC:  MOVWF  x72
....................    } 
....................     
....................    return (macro_end); 
164BE:  MOVFF  872,01
164C2:  MOVLB  0
164C4:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
15D40:  MOVF   24,W
15D42:  SUBWF  36,W
15D44:  BTFSS  FD8.0
15D46:  BRA    15F4E
15D48:  BNZ   15D52
15D4A:  MOVF   23,W
15D4C:  SUBWF  35,W
15D4E:  BTFSS  FD8.0
15D50:  BRA    15F4E
15D52:  MOVF   33,F
15D54:  BTFSS  FD8.2
15D56:  BRA    15F4E
15D58:  MOVF   34,F
15D5A:  BTFSS  FD8.2
15D5C:  BRA    15F4E
....................       { 
....................          nv_elapsed = 0; 
15D5E:  CLRF   36
15D60:  CLRF   35
....................  
....................          init_hardware(); 
15D62:  CALL   28B8
....................          sd_status = init_sdcard(); 
15D66:  CALL   4FB8
15D6A:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
15D6E:  MOVLB  2
15D70:  MOVF   xD8,F
15D72:  BZ    15D7C
15D74:  MOVLB  0
15D76:  CALL   4FFE
15D7A:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
15D7C:  MOVLW  01
15D7E:  MOVWF  1E
15D80:  MOVLW  A3
15D82:  MOVWF  1D
15D84:  MOVLW  28
15D86:  MOVWF  FF6
15D88:  MOVLW  22
15D8A:  MOVWF  FF7
15D8C:  MOVLW  00
15D8E:  MOVWF  FF8
15D90:  MOVLW  14
15D92:  MOVLB  8
15D94:  MOVWF  xC7
15D96:  MOVLB  0
15D98:  CALL   AA0E
15D9C:  MOVLW  10
15D9E:  MOVWF  FE9
15DA0:  MOVFF  22,8D3
15DA4:  MOVFF  21,8D2
15DA8:  CALL   AA40
15DAC:  MOVLW  3F
15DAE:  MOVWF  FF6
15DB0:  MOVLW  22
15DB2:  MOVWF  FF7
15DB4:  MOVLW  00
15DB6:  MOVWF  FF8
15DB8:  MOVLW  09
15DBA:  MOVLB  8
15DBC:  MOVWF  xC7
15DBE:  MOVLB  0
15DC0:  CALL   AA0E
....................          record_event();          
15DC4:  CALL   8424
....................              
....................          macro_cmd = master_macro_eco(); 
15DC8:  RCALL  15A8C
15DCA:  MOVFF  01,863
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
15DCE:  MOVLW  16
15DD0:  MOVLB  8
15DD2:  MOVWF  xCA
15DD4:  MOVFF  22,8CC
15DD8:  MOVFF  21,8CB
15DDC:  MOVLB  0
15DDE:  CALL   4F52
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
15DE2:  MOVLW  3A
15DE4:  MOVLB  8
15DE6:  MOVWF  xCA
15DE8:  MOVFF  38,8CC
15DEC:  MOVFF  37,8CB
15DF0:  MOVLB  0
15DF2:  CALL   4F52
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
15DF6:  DECFSZ 4C,W
15DF8:  BRA    15E1C
....................          { 
....................             disable_interrupts (INT_EXT); 
15DFA:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
15DFC:  CLRF   32
15DFE:  MOVLW  01
15E00:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15E02:  MOVLW  02
15E04:  MOVLB  8
15E06:  MOVWF  x65
15E08:  MOVFF  31,866
15E0C:  MOVLB  0
15E0E:  CALL   3390
....................             busy_clear(); 
15E12:  CALL   ADB6
....................             return (user_quit); 
15E16:  MOVFF  4C,01
15E1A:  BRA    15F5E
....................          } 
....................  
....................          motor_sleep_rdy(); 
15E1C:  CALL   2916
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
15E20:  MOVLW  01
15E22:  MOVWF  1E
15E24:  MOVLW  A3
15E26:  MOVWF  1D
15E28:  MOVLW  4A
15E2A:  MOVWF  FF6
15E2C:  MOVLW  22
15E2E:  MOVWF  FF7
15E30:  MOVLW  00
15E32:  MOVWF  FF8
15E34:  MOVLW  14
15E36:  MOVLB  8
15E38:  MOVWF  xC7
15E3A:  MOVLB  0
15E3C:  CALL   AA0E
15E40:  MOVLW  10
15E42:  MOVWF  FE9
15E44:  MOVFF  22,8D3
15E48:  MOVFF  21,8D2
15E4C:  CALL   AA40
15E50:  MOVLW  61
15E52:  MOVWF  FF6
15E54:  MOVLW  22
15E56:  MOVWF  FF7
15E58:  MOVLW  00
15E5A:  MOVWF  FF8
15E5C:  MOVLW  0C
15E5E:  MOVLB  8
15E60:  MOVWF  xC7
15E62:  MOVLB  0
15E64:  CALL   AA0E
....................          record_event();  
15E68:  CALL   8424
....................           
....................          if (macro_cmd == 'e') 
15E6C:  MOVLB  8
15E6E:  MOVF   x63,W
15E70:  SUBLW  65
15E72:  BNZ   15EC6
....................          { 
....................             disable_interrupts (INT_EXT); 
15E74:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
15E76:  MOVLW  01
15E78:  MOVWF  1E
15E7A:  MOVLW  A3
15E7C:  MOVWF  1D
15E7E:  MOVLW  6E
15E80:  MOVWF  FF6
15E82:  MOVLW  22
15E84:  MOVWF  FF7
15E86:  MOVLW  00
15E88:  MOVWF  FF8
15E8A:  MOVLW  14
15E8C:  MOVWF  xC7
15E8E:  MOVLB  0
15E90:  CALL   AA0E
15E94:  MOVLW  10
15E96:  MOVWF  FE9
15E98:  MOVFF  22,8D3
15E9C:  MOVFF  21,8D2
15EA0:  CALL   AA40
15EA4:  MOVLW  85
15EA6:  MOVWF  FF6
15EA8:  MOVLW  22
15EAA:  MOVWF  FF7
15EAC:  MOVLW  00
15EAE:  MOVWF  FF8
15EB0:  MOVLW  09
15EB2:  MOVLB  8
15EB4:  MOVWF  xC7
15EB6:  MOVLB  0
15EB8:  CALL   AA0E
....................             record_event();  
15EBC:  CALL   8424
....................             cmd_err(); 
15EC0:  CALL   BC3C
15EC4:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
15EC6:  MOVF   28,W
15EC8:  SUBWF  22,W
15ECA:  BNC   15F50
15ECC:  BNZ   15ED4
15ECE:  MOVF   27,W
15ED0:  SUBWF  21,W
15ED2:  BNC   15F50
....................          { 
....................             disable_interrupts (INT_EXT); 
15ED4:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
15ED6:  MOVLW  01
15ED8:  MOVWF  1E
15EDA:  MOVLW  A3
15EDC:  MOVWF  1D
15EDE:  MOVLW  90
15EE0:  MOVWF  FF6
15EE2:  MOVLW  22
15EE4:  MOVWF  FF7
15EE6:  MOVLW  00
15EE8:  MOVWF  FF8
15EEA:  MOVLW  14
15EEC:  MOVWF  xC7
15EEE:  MOVLB  0
15EF0:  CALL   AA0E
15EF4:  MOVLW  10
15EF6:  MOVWF  FE9
15EF8:  MOVFF  22,8D3
15EFC:  MOVFF  21,8D2
15F00:  CALL   AA40
15F04:  MOVLW  A7
15F06:  MOVWF  FF6
15F08:  MOVLW  22
15F0A:  MOVWF  FF7
15F0C:  MOVLW  00
15F0E:  MOVWF  FF8
15F10:  MOVLW  0F
15F12:  MOVLB  8
15F14:  MOVWF  xC7
15F16:  MOVLB  0
15F18:  CALL   AA0E
....................             record_event();   
15F1C:  CALL   8424
....................             msg_max(); 
15F20:  RCALL  15D22
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
15F22:  CLRF   34
15F24:  MOVLW  01
15F26:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
15F28:  MOVLW  28
15F2A:  MOVLB  8
15F2C:  MOVWF  x65
15F2E:  MOVFF  33,866
15F32:  MOVLB  0
15F34:  CALL   3390
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15F38:  CLRF   32
15F3A:  MOVLW  01
15F3C:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15F3E:  MOVLW  02
15F40:  MOVLB  8
15F42:  MOVWF  x65
15F44:  MOVFF  31,866
15F48:  MOVLB  0
15F4A:  CALL   3390
15F4E:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
15F50:  MOVLB  0
15F52:  RCALL  159C6
15F54:  BRA    15D40
....................    } 
....................     
....................    busy_clear(); 
15F56:  CALL   ADB6
....................    return (user_quit); 
15F5A:  MOVFF  4C,01
15F5E:  GOTO   16882 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
1615A:  MOVF   24,W
1615C:  SUBWF  36,W
1615E:  BTFSS  FD8.0
16160:  BRA    16330
16162:  BNZ   1616C
16164:  MOVF   23,W
16166:  SUBWF  35,W
16168:  BTFSS  FD8.0
1616A:  BRA    16330
....................       { 
....................          nv_elapsed = 0; 
1616C:  CLRF   36
1616E:  CLRF   35
....................  
....................          init_hardware(); 
16170:  CALL   28B8
....................          sd_status = init_sdcard(); 
16174:  CALL   4FB8
16178:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
1617C:  MOVLB  2
1617E:  MOVF   xD8,F
16180:  BZ    1618A
16182:  MOVLB  0
16184:  CALL   4FFE
16188:  MOVLB  2
....................  
....................          ++nv_sample; 
1618A:  INCF   21,F
1618C:  BTFSC  FD8.2
1618E:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
16190:  MOVLW  40
16192:  BTFSS  F9E.4
16194:  BRA    16192
16196:  MOVWF  FAD
16198:  MOVLW  53
1619A:  BTFSS  F9E.4
1619C:  BRA    1619A
1619E:  MOVWF  FAD
161A0:  MOVLW  09
161A2:  MOVWF  FE9
161A4:  CLRF   1B
161A6:  BTFSC  FF2.7
161A8:  BSF    1B.7
161AA:  BCF    FF2.7
161AC:  MOVFF  22,A19
161B0:  MOVFF  21,A18
161B4:  MOVLB  0
161B6:  CALL   1188
161BA:  BTFSC  1B.7
161BC:  BSF    FF2.7
161BE:  MOVLW  0D
161C0:  BTFSS  F9E.4
161C2:  BRA    161C0
161C4:  MOVWF  FAD
161C6:  MOVLW  0A
161C8:  BTFSS  F9E.4
161CA:  BRA    161C8
161CC:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
161CE:  MOVLW  01
161D0:  MOVWF  1E
161D2:  MOVLW  A3
161D4:  MOVWF  1D
161D6:  MOVLW  B8
161D8:  MOVWF  FF6
161DA:  MOVLW  22
161DC:  MOVWF  FF7
161DE:  MOVLW  00
161E0:  MOVWF  FF8
161E2:  MOVLW  14
161E4:  MOVLB  8
161E6:  MOVWF  xC7
161E8:  MOVLB  0
161EA:  CALL   AA0E
161EE:  MOVLW  10
161F0:  MOVWF  FE9
161F2:  MOVFF  22,8D3
161F6:  MOVFF  21,8D2
161FA:  CALL   AA40
161FE:  MOVLW  CF
16200:  MOVWF  FF6
16202:  MOVLW  22
16204:  MOVWF  FF7
16206:  MOVLW  00
16208:  MOVWF  FF8
1620A:  MOVLW  09
1620C:  MOVLB  8
1620E:  MOVWF  xC7
16210:  MOVLB  0
16212:  CALL   AA0E
....................          record_event();   
16216:  CALL   8424
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
1621A:  MOVLW  16
1621C:  MOVLB  8
1621E:  MOVWF  xCA
16220:  MOVFF  22,8CC
16224:  MOVFF  21,8CB
16228:  MOVLB  0
1622A:  CALL   4F52
....................  
....................          if (nv_macro_mode==TRUE) 
1622E:  DECFSZ 29,W
16230:  BRA    16246
16232:  MOVF   2A,F
16234:  BNZ   16246
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
16236:  MOVFF  22,865
1623A:  MOVFF  21,864
1623E:  BRA    15F62
16240:  MOVFF  01,863
....................          } 
16244:  BRA    162AE
....................          else 
....................          { 
....................             time_stamp(); 
16246:  CALL   5398
....................             play_wms_hard_macro(nv_port); 
1624A:  MOVFF  2E,866
1624E:  MOVFF  2D,865
16252:  CALL   D504
....................             ++nv_port; 
16256:  INCF   2D,F
16258:  BTFSC  FD8.2
1625A:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
1625C:  MOVF   2E,F
1625E:  BNZ   16266
16260:  MOVF   2D,W
16262:  SUBLW  01
16264:  BC    16278
16266:  MOVF   2E,F
16268:  BNZ   16278
1626A:  MOVF   2D,W
1626C:  SUBLW  30
1626E:  BNC   16278
16270:  DECFSZ 2F,W
16272:  BRA    16278
16274:  MOVF   30,F
16276:  BZ    16296
16278:  MOVF   2E,F
1627A:  BNZ   16282
1627C:  MOVF   2D,W
1627E:  SUBLW  01
16280:  BC    162AC
16282:  MOVF   2E,F
16284:  BNZ   162AC
16286:  MOVF   2D,W
16288:  SUBLW  32
1628A:  BNC   162AC
1628C:  MOVF   2F,W
1628E:  SUBLW  03
16290:  BNZ   162AC
16292:  MOVF   30,F
16294:  BNZ   162AC
....................             { 
....................                write16(ADDR_PORT, nv_port);             
16296:  MOVLW  24
16298:  MOVLB  8
1629A:  MOVWF  xCA
1629C:  MOVFF  2E,8CC
162A0:  MOVFF  2D,8CB
162A4:  MOVLB  0
162A6:  CALL   4F52
....................             } 
162AA:  BRA    162AE
....................             else disable_interrupts (INT_EXT); 
162AC:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
162AE:  DECFSZ 4C,W
162B0:  BRA    162D4
....................          { 
....................             disable_interrupts (INT_EXT); 
162B2:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
162B4:  CLRF   32
162B6:  MOVLW  01
162B8:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
162BA:  MOVLW  02
162BC:  MOVLB  8
162BE:  MOVWF  x65
162C0:  MOVFF  31,866
162C4:  MOVLB  0
162C6:  CALL   3390
....................             busy_clear(); 
162CA:  CALL   ADB6
....................             return (user_quit); 
162CE:  MOVFF  4C,01
162D2:  BRA    1633E
....................          } 
....................           
....................          motor_sleep_rdy(); 
162D4:  CALL   2916
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
162D8:  MOVLW  01
162DA:  MOVWF  1E
162DC:  MOVLW  A3
162DE:  MOVWF  1D
162E0:  MOVLW  DA
162E2:  MOVWF  FF6
162E4:  MOVLW  22
162E6:  MOVWF  FF7
162E8:  MOVLW  00
162EA:  MOVWF  FF8
162EC:  MOVLW  14
162EE:  MOVLB  8
162F0:  MOVWF  xC7
162F2:  MOVLB  0
162F4:  CALL   AA0E
162F8:  MOVLW  10
162FA:  MOVWF  FE9
162FC:  MOVFF  22,8D3
16300:  MOVFF  21,8D2
16304:  CALL   AA40
16308:  MOVLW  F1
1630A:  MOVWF  FF6
1630C:  MOVLW  22
1630E:  MOVWF  FF7
16310:  MOVLW  00
16312:  MOVWF  FF8
16314:  MOVLW  0C
16316:  MOVLB  8
16318:  MOVWF  xC7
1631A:  MOVLB  0
1631C:  CALL   AA0E
....................          record_event();  
16320:  CALL   8424
....................           
....................          if (macro_end == ';') 
16324:  MOVLB  8
16326:  MOVF   x63,W
16328:  SUBLW  3B
1632A:  BNZ   1632E
....................          { 
....................             disable_interrupts (INT_EXT); 
1632C:  BCF    FF2.4
1632E:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
16330:  CALL   159C6
16334:  BRA    1615A
....................    } 
....................    busy_clear(); 
16336:  CALL   ADB6
....................    return (user_quit); 
1633A:  MOVFF  4C,01
1633E:  GOTO   1688A (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
164C6:  MOVF   24,W
164C8:  SUBWF  36,W
164CA:  BTFSS  FD8.0
164CC:  BRA    16686
164CE:  BNZ   164D8
164D0:  MOVF   23,W
164D2:  SUBWF  35,W
164D4:  BTFSS  FD8.0
164D6:  BRA    16686
....................       { 
....................          nv_elapsed = 0; 
164D8:  CLRF   36
164DA:  CLRF   35
....................  
....................          init_hardware(); 
164DC:  CALL   28B8
....................          sd_status = init_sdcard(); 
164E0:  CALL   4FB8
164E4:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
164E8:  MOVLB  2
164EA:  MOVF   xD8,F
164EC:  BZ    164F6
164EE:  MOVLB  0
164F0:  CALL   4FFE
164F4:  MOVLB  2
....................  
....................          ++nv_sample; 
164F6:  INCF   21,F
164F8:  BTFSC  FD8.2
164FA:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
164FC:  MOVLW  40
164FE:  BTFSS  F9E.4
16500:  BRA    164FE
16502:  MOVWF  FAD
16504:  MOVLW  53
16506:  BTFSS  F9E.4
16508:  BRA    16506
1650A:  MOVWF  FAD
1650C:  MOVLW  09
1650E:  MOVWF  FE9
16510:  CLRF   1B
16512:  BTFSC  FF2.7
16514:  BSF    1B.7
16516:  BCF    FF2.7
16518:  MOVFF  22,A19
1651C:  MOVFF  21,A18
16520:  MOVLB  0
16522:  CALL   1188
16526:  BTFSC  1B.7
16528:  BSF    FF2.7
1652A:  MOVLW  0D
1652C:  BTFSS  F9E.4
1652E:  BRA    1652C
16530:  MOVWF  FAD
16532:  MOVLW  0A
16534:  BTFSS  F9E.4
16536:  BRA    16534
16538:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
1653A:  MOVLW  01
1653C:  MOVWF  1E
1653E:  MOVLW  A3
16540:  MOVWF  1D
16542:  MOVLW  FE
16544:  MOVWF  FF6
16546:  MOVLW  22
16548:  MOVWF  FF7
1654A:  MOVLW  00
1654C:  MOVWF  FF8
1654E:  MOVLW  14
16550:  MOVLB  8
16552:  MOVWF  xC7
16554:  MOVLB  0
16556:  CALL   AA0E
1655A:  MOVLW  10
1655C:  MOVWF  FE9
1655E:  MOVFF  22,8D3
16562:  MOVFF  21,8D2
16566:  CALL   AA40
1656A:  MOVLW  15
1656C:  MOVWF  FF6
1656E:  MOVLW  23
16570:  MOVWF  FF7
16572:  MOVLW  00
16574:  MOVWF  FF8
16576:  MOVLW  09
16578:  MOVLB  8
1657A:  MOVWF  xC7
1657C:  MOVLB  0
1657E:  CALL   AA0E
....................          record_event();   
16582:  CALL   8424
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16586:  MOVLW  16
16588:  MOVLB  8
1658A:  MOVWF  xCA
1658C:  MOVFF  22,8CC
16590:  MOVFF  21,8CB
16594:  MOVLB  0
16596:  CALL   4F52
....................  
....................          macro_end = master_macro_aws(nv_sample); 
1659A:  MOVFF  22,869
1659E:  MOVFF  21,868
165A2:  RCALL  16342
165A4:  MOVFF  01,863
....................           
....................          if (user_quit == TRUE) 
165A8:  DECFSZ 4C,W
165AA:  BRA    165CE
....................          { 
....................             disable_interrupts (INT_EXT); 
165AC:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
165AE:  CLRF   32
165B0:  MOVLW  01
165B2:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
165B4:  MOVLW  02
165B6:  MOVLB  8
165B8:  MOVWF  x65
165BA:  MOVFF  31,866
165BE:  MOVLB  0
165C0:  CALL   3390
....................             busy_clear(); 
165C4:  CALL   ADB6
....................             return (user_quit); 
165C8:  MOVFF  4C,01
165CC:  BRA    16698
....................          } 
....................           
....................          motor_sleep_rdy(); 
165CE:  CALL   2916
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
165D2:  MOVLW  01
165D4:  MOVWF  1E
165D6:  MOVLW  A3
165D8:  MOVWF  1D
165DA:  MOVLW  20
165DC:  MOVWF  FF6
165DE:  MOVLW  23
165E0:  MOVWF  FF7
165E2:  MOVLW  00
165E4:  MOVWF  FF8
165E6:  MOVLW  14
165E8:  MOVLB  8
165EA:  MOVWF  xC7
165EC:  MOVLB  0
165EE:  CALL   AA0E
165F2:  MOVLW  10
165F4:  MOVWF  FE9
165F6:  MOVFF  22,8D3
165FA:  MOVFF  21,8D2
165FE:  CALL   AA40
16602:  MOVLW  37
16604:  MOVWF  FF6
16606:  MOVLW  23
16608:  MOVWF  FF7
1660A:  MOVLW  00
1660C:  MOVWF  FF8
1660E:  MOVLW  0C
16610:  MOVLB  8
16612:  MOVWF  xC7
16614:  MOVLB  0
16616:  CALL   AA0E
....................          record_event();  
1661A:  CALL   8424
....................           
....................          if (macro_end == ';') 
1661E:  MOVLB  8
16620:  MOVF   x63,W
16622:  SUBLW  3B
16624:  BNZ   16628
....................          { 
....................             disable_interrupts (INT_EXT); 
16626:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16628:  MOVF   28,W
1662A:  SUBWF  22,W
1662C:  BNC   16688
1662E:  BNZ   16636
16630:  MOVF   27,W
16632:  SUBWF  21,W
16634:  BNC   16688
....................          { 
....................             disable_interrupts (INT_EXT); 
16636:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16638:  MOVLW  01
1663A:  MOVWF  1E
1663C:  MOVLW  A3
1663E:  MOVWF  1D
16640:  MOVLW  44
16642:  MOVWF  FF6
16644:  MOVLW  23
16646:  MOVWF  FF7
16648:  MOVLW  00
1664A:  MOVWF  FF8
1664C:  MOVLW  14
1664E:  MOVWF  xC7
16650:  MOVLB  0
16652:  CALL   AA0E
16656:  MOVLW  10
16658:  MOVWF  FE9
1665A:  MOVFF  22,8D3
1665E:  MOVFF  21,8D2
16662:  CALL   AA40
16666:  MOVLW  5B
16668:  MOVWF  FF6
1666A:  MOVLW  23
1666C:  MOVWF  FF7
1666E:  MOVLW  00
16670:  MOVWF  FF8
16672:  MOVLW  0F
16674:  MOVLB  8
16676:  MOVWF  xC7
16678:  MOVLB  0
1667A:  CALL   AA0E
....................             record_event();   
1667E:  CALL   8424
....................             msg_max(); 
16682:  CALL   15D22
16686:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
16688:  MOVLB  0
1668A:  CALL   159C6
1668E:  BRA    164C6
....................    } 
....................    busy_clear(); 
16690:  CALL   ADB6
....................    return (user_quit); 
16694:  MOVFF  4C,01
16698:  GOTO   16892 (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
1669C:  CALL   293E
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
166A0:  MOVLW  01
166A2:  MOVWF  1E
166A4:  MOVLW  A3
166A6:  MOVWF  1D
166A8:  MOVLW  6C
166AA:  MOVWF  FF6
166AC:  MOVLW  23
166AE:  MOVWF  FF7
166B0:  MOVLW  00
166B2:  MOVWF  FF8
166B4:  CALL   503C
....................    record_event(); 
166B8:  CALL   8424
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
166BC:  MOVLW  01
166BE:  MOVWF  1E
166C0:  MOVLW  A3
166C2:  MOVWF  1D
166C4:  MOVLW  86
166C6:  MOVWF  FF6
166C8:  MOVLW  23
166CA:  MOVWF  FF7
166CC:  MOVLW  00
166CE:  MOVWF  FF8
166D0:  MOVLW  0C
166D2:  MOVLB  8
166D4:  MOVWF  xC7
166D6:  MOVLB  0
166D8:  CALL   AA0E
166DC:  MOVLW  10
166DE:  MOVWF  FE9
166E0:  MOVFF  26,8D3
166E4:  MOVFF  25,8D2
166E8:  CALL   AA40
166EC:  MOVLW  95
166EE:  MOVWF  FF6
166F0:  MOVLW  23
166F2:  MOVWF  FF7
166F4:  MOVLW  00
166F6:  MOVWF  FF8
166F8:  MOVLW  06
166FA:  MOVLB  8
166FC:  MOVWF  xC7
166FE:  MOVLB  0
16700:  CALL   AA0E
16704:  MOVLW  10
16706:  MOVWF  FE9
16708:  MOVFF  24,8D3
1670C:  MOVFF  23,8D2
16710:  CALL   AA40
16714:  MOVLW  9E
16716:  MOVWF  FF6
16718:  MOVLW  23
1671A:  MOVWF  FF7
1671C:  MOVLW  00
1671E:  MOVWF  FF8
16720:  MOVLW  06
16722:  MOVLB  8
16724:  MOVWF  xC7
16726:  MOVLB  0
16728:  CALL   AA0E
1672C:  MOVLW  10
1672E:  MOVWF  FE9
16730:  MOVFF  28,8D3
16734:  MOVFF  27,8D2
16738:  CALL   AA40
1673C:  MOVLW  A7
1673E:  MOVWF  FF6
16740:  MOVLW  23
16742:  MOVWF  FF7
16744:  MOVLW  00
16746:  MOVWF  FF8
16748:  MOVLW  03
1674A:  MOVLB  8
1674C:  MOVWF  xC7
1674E:  MOVLB  0
16750:  CALL   AA0E
....................    record_event(); 
16754:  CALL   8424
....................     
....................    user_quit = FALSE; 
16758:  CLRF   4C
....................     
....................    nv_cmd_mode = FALSE; 
1675A:  CLRF   32
1675C:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1675E:  MOVLW  02
16760:  MOVLB  8
16762:  MOVWF  x65
16764:  MOVFF  31,866
16768:  MOVLB  0
1676A:  CALL   3390
....................  
....................    RTC_set_AFE(); 
1676E:  GOTO   15266
....................    // check if start is earlier than now 
....................    RTC_late(); 
16772:  CALL   152BE
....................    // show clock 
....................    RTC_display(); 
16776:  CALL   DF8A
....................    // show alarm 
....................    RTC_display_alarm(); 
1677A:  CALL   E1EA
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
1677E:  CALL   15778
....................  
....................    if (alarm_passed == FALSE){ 
16782:  BTFSC  49.3
16784:  BRA    16786
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
16786:  MOVLW  00
16788:  BTFSC  49.3
1678A:  MOVLW  01
1678C:  MOVLB  8
1678E:  MOVWF  x63
16790:  MOVLW  01
16792:  MOVWF  1E
16794:  MOVLW  A3
16796:  MOVWF  1D
16798:  MOVLW  AC
1679A:  MOVWF  FF6
1679C:  MOVLW  23
1679E:  MOVWF  FF7
167A0:  MOVLW  00
167A2:  MOVWF  FF8
167A4:  MOVLW  14
167A6:  MOVWF  xC7
167A8:  MOVLB  0
167AA:  CALL   AA0E
167AE:  MOVLW  10
167B0:  MOVWF  FE9
167B2:  MOVFF  22,8D3
167B6:  MOVFF  21,8D2
167BA:  CALL   AA40
167BE:  MOVLW  C3
167C0:  MOVWF  FF6
167C2:  MOVLW  23
167C4:  MOVWF  FF7
167C6:  MOVLW  00
167C8:  MOVWF  FF8
167CA:  MOVLW  08
167CC:  MOVLB  8
167CE:  MOVWF  xC7
167D0:  MOVLB  0
167D2:  CALL   AA0E
167D6:  MOVFF  863,8C9
167DA:  MOVLW  1B
167DC:  MOVLB  8
167DE:  MOVWF  xCA
167E0:  MOVLB  0
167E2:  CALL   51FE
167E6:  MOVLW  CD
167E8:  MOVWF  FF6
167EA:  MOVLW  23
167EC:  MOVWF  FF7
167EE:  MOVLW  00
167F0:  MOVWF  FF8
167F2:  MOVLW  03
167F4:  MOVLB  8
167F6:  MOVWF  xC7
167F8:  MOVLB  0
167FA:  CALL   AA0E
....................    record_event();  
167FE:  CALL   8424
....................  
....................    while (TRUE == RTC_read_flags_running) 
16802:  BTFSS  49.2
16804:  BRA    16808
....................    { 
....................       ; 
16806:  BRA    16802
....................    } 
....................    RTC_read_flags_running = TRUE; 
16808:  BSF    49.2
1680A:  CLRF   1B
1680C:  BTFSC  FF2.7
1680E:  BSF    1B.7
16810:  BCF    FF2.7
....................    RTC_read_flags(); 
16812:  CALL   0DCC
16816:  BTFSC  1B.7
16818:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
1681A:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
1681C:  CALL   2916
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
16820:  BTFSC  49.3
16822:  BRA    16844
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16824:  MOVLW  01
16826:  MOVWF  1E
16828:  MOVLW  A3
1682A:  MOVWF  1D
1682C:  MOVLW  D2
1682E:  MOVWF  FF6
16830:  MOVLW  23
16832:  MOVWF  FF7
16834:  MOVLW  00
16836:  MOVWF  FF8
16838:  CALL   503C
....................       record_event(); 
1683C:  CALL   8424
....................       go_to_sleep(); 
16840:  CALL   159C6
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16844:  GOTO   159DC
....................    nv_elapsed = nv_interval; 
16848:  MOVFF  24,36
1684C:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
16850:  MOVFF  2F,00
16854:  MOVF   30,W
16856:  MOVWF  03
16858:  BNZ   1685E
1685A:  MOVF   00,F
1685C:  BZ    1687E
1685E:  MOVF   03,W
16860:  BNZ   16868
16862:  MOVLW  01
16864:  SUBWF  00,W
16866:  BZ    16888
16868:  MOVF   03,W
1686A:  BNZ   16872
1686C:  MOVLW  03
1686E:  SUBWF  00,W
16870:  BZ    16888
16872:  MOVF   03,W
16874:  BNZ   1687C
16876:  MOVLW  02
16878:  SUBWF  00,W
1687A:  BZ    16890
1687C:  BRA    16896
....................       case ECO: user_quit = auto_sample_eco(); 
1687E:  GOTO   15D40
16882:  MOVFF  01,4C
....................          break; 
16886:  BRA    16896
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
16888:  BRA    1615A
1688A:  MOVFF  01,4C
....................          break; 
1688E:  BRA    16896
....................       case AWS: user_quit = auto_sample_aws(); 
16890:  BRA    164C6
16892:  MOVFF  01,4C
....................          break;          
....................    } 
....................    return(user_quit); 
16896:  MOVFF  4C,01
1689A:  GOTO   1698E (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BC0C:  MOVF   44,F
0BC0E:  BNZ   BC1C
0BC10:  MOVF   45,F
0BC12:  BNZ   BC1C
0BC14:  MOVF   46,F
0BC16:  BNZ   BC1C
0BC18:  MOVF   47,F
0BC1A:  BZ    BC34
0BC1C:  MOVF   47,F
0BC1E:  BNZ   BC34
0BC20:  MOVF   46,F
0BC22:  BNZ   BC34
0BC24:  MOVF   45,F
0BC26:  BNZ   BC34
0BC28:  MOVF   44,W
0BC2A:  SUBLW  02
0BC2C:  BNC   BC34
....................       detector = arg; 
0BC2E:  MOVFF  44,2D1
....................    } 
0BC32:  BRA    BC38
....................    else cmd_arg(); 
0BC34:  CALL   AF7A
0BC38:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0BC5A:  MOVF   44,F
0BC5C:  BNZ   BC6A
0BC5E:  MOVF   45,F
0BC60:  BNZ   BC6A
0BC62:  MOVF   46,F
0BC64:  BNZ   BC6A
0BC66:  MOVF   47,F
0BC68:  BZ    BCC4
0BC6A:  MOVF   47,F
0BC6C:  BNZ   BCC4
0BC6E:  MOVF   46,W
0BC70:  SUBLW  00
0BC72:  BNC   BCC4
....................       switch (detector){ 
0BC74:  MOVLB  2
0BC76:  MOVF   xD1,W
0BC78:  XORLW  01
0BC7A:  MOVLB  0
0BC7C:  BZ    BC84
0BC7E:  XORLW  03
0BC80:  BZ    BCA2
0BC82:  BRA    BCC0
....................          case 1 : nv_d1_temp = arg; 
0BC84:  MOVFF  45,3E
0BC88:  MOVFF  44,3D
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0BC8C:  MOVLW  40
0BC8E:  MOVLB  8
0BC90:  MOVWF  xCA
0BC92:  MOVFF  3E,8CC
0BC96:  MOVFF  3D,8CB
0BC9A:  MOVLB  0
0BC9C:  CALL   4F52
....................             break; 
0BCA0:  BRA    BCC2
....................          case 2 : nv_d2_temp = arg; 
0BCA2:  MOVFF  45,40
0BCA6:  MOVFF  44,3F
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0BCAA:  MOVLW  42
0BCAC:  MOVLB  8
0BCAE:  MOVWF  xCA
0BCB0:  MOVFF  40,8CC
0BCB4:  MOVFF  3F,8CB
0BCB8:  MOVLB  0
0BCBA:  CALL   4F52
....................             break; 
0BCBE:  BRA    BCC2
....................          default : cmd_err(); 
0BCC0:  RCALL  BC3C
....................             break; 
....................       } 
....................    } 
0BCC2:  BRA    BD6A
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0BCC4:  MOVF   44,F
0BCC6:  BNZ   BD66
0BCC8:  MOVF   45,F
0BCCA:  BNZ   BD66
0BCCC:  MOVF   46,F
0BCCE:  BNZ   BD66
0BCD0:  MOVF   47,F
0BCD2:  BNZ   BD66
0BCD4:  MOVLW  E8
0BCD6:  MOVWF  FF6
0BCD8:  MOVLW  23
0BCDA:  MOVWF  FF7
0BCDC:  MOVLW  00
0BCDE:  MOVWF  FF8
0BCE0:  CLRF   1B
0BCE2:  BTFSC  FF2.7
0BCE4:  BSF    1B.7
0BCE6:  BCF    FF2.7
0BCE8:  MOVLW  03
0BCEA:  MOVLB  A
0BCEC:  MOVWF  x18
0BCEE:  MOVLB  0
0BCF0:  CALL   1006
0BCF4:  BTFSC  1B.7
0BCF6:  BSF    FF2.7
0BCF8:  MOVLW  10
0BCFA:  MOVWF  FE9
0BCFC:  CLRF   1B
0BCFE:  BTFSC  FF2.7
0BD00:  BSF    1B.7
0BD02:  BCF    FF2.7
0BD04:  MOVFF  3E,A19
0BD08:  MOVFF  3D,A18
0BD0C:  CALL   1188
0BD10:  BTFSC  1B.7
0BD12:  BSF    FF2.7
0BD14:  MOVLW  EE
0BD16:  MOVWF  FF6
0BD18:  MOVLW  23
0BD1A:  MOVWF  FF7
0BD1C:  MOVLW  00
0BD1E:  MOVWF  FF8
0BD20:  CLRF   1B
0BD22:  BTFSC  FF2.7
0BD24:  BSF    1B.7
0BD26:  BCF    FF2.7
0BD28:  MOVLW  04
0BD2A:  MOVLB  A
0BD2C:  MOVWF  x18
0BD2E:  MOVLB  0
0BD30:  CALL   1006
0BD34:  BTFSC  1B.7
0BD36:  BSF    FF2.7
0BD38:  MOVLW  10
0BD3A:  MOVWF  FE9
0BD3C:  CLRF   1B
0BD3E:  BTFSC  FF2.7
0BD40:  BSF    1B.7
0BD42:  BCF    FF2.7
0BD44:  MOVFF  40,A19
0BD48:  MOVFF  3F,A18
0BD4C:  CALL   1188
0BD50:  BTFSC  1B.7
0BD52:  BSF    FF2.7
0BD54:  MOVLW  0D
0BD56:  BTFSS  F9E.4
0BD58:  BRA    BD56
0BD5A:  MOVWF  FAD
0BD5C:  MOVLW  0A
0BD5E:  BTFSS  F9E.4
0BD60:  BRA    BD5E
0BD62:  MOVWF  FAD
0BD64:  BRA    BD6A
....................    else cmd_arg(); 
0BD66:  CALL   AF7A
0BD6A:  GOTO   BDD0 (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0BD6E:  MOVF   47,F
0BD70:  BNZ   BD9E
0BD72:  MOVF   46,F
0BD74:  BNZ   BD9E
0BD76:  MOVF   45,F
0BD78:  BNZ   BD9E
0BD7A:  MOVF   44,W
0BD7C:  SUBLW  01
0BD7E:  BNC   BD9E
....................       nv_macro_mode = arg; 
0BD80:  MOVFF  45,2A
0BD84:  MOVFF  44,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0BD88:  MOVLW  20
0BD8A:  MOVLB  8
0BD8C:  MOVWF  xCA
0BD8E:  MOVFF  2A,8CC
0BD92:  MOVFF  29,8CB
0BD96:  MOVLB  0
0BD98:  CALL   4F52
....................    } 
0BD9C:  BRA    BDA2
....................    else cmd_arg(); 
0BD9E:  CALL   AF7A
0BDA2:  GOTO   BDD0 (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0BDA6:  MOVF   2F,W
0BDA8:  MOVWF  00
0BDAA:  MOVF   30,W
0BDAC:  MOVWF  03
0BDAE:  BNZ   BDB4
0BDB0:  MOVF   00,F
0BDB2:  BZ    BDCA
0BDB4:  MOVF   03,W
0BDB6:  BNZ   BDBE
0BDB8:  MOVLW  01
0BDBA:  SUBWF  00,W
0BDBC:  BZ    BDCE
0BDBE:  MOVF   03,W
0BDC0:  BNZ   BDC8
0BDC2:  MOVLW  03
0BDC4:  SUBWF  00,W
0BDC6:  BZ    BDCE
0BDC8:  BRA    BDD0
....................       case ECO : commandAe(); 
0BDCA:  BRA    BC5A
....................          break; 
0BDCC:  BRA    BDD0
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0BDCE:  BRA    BD6E
....................          break; 
....................    } 
0BDD0:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0BDD4:  MOVF   44,F
0BDD6:  BNZ   BDE4
0BDD8:  MOVF   45,F
0BDDA:  BNZ   BDE4
0BDDC:  MOVF   46,F
0BDDE:  BNZ   BDE4
0BDE0:  MOVF   47,F
0BDE2:  BZ    BE14
0BDE4:  MOVF   47,F
0BDE6:  BNZ   BE14
0BDE8:  MOVF   46,F
0BDEA:  BNZ   BE14
0BDEC:  MOVF   45,F
0BDEE:  BNZ   BE14
0BDF0:  MOVF   44,W
0BDF2:  SUBLW  03
0BDF4:  BNC   BE14
....................       nv_det_type = arg; 
0BDF6:  MOVFF  45,42
0BDFA:  MOVFF  44,41
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0BDFE:  MOVLW  26
0BE00:  MOVLB  8
0BE02:  MOVWF  xCA
0BE04:  MOVFF  42,8CC
0BE08:  MOVFF  41,8CB
0BE0C:  MOVLB  0
0BE0E:  CALL   4F52
....................    } 
0BE12:  BRA    BE7A
....................    else if(arg==0) { 
0BE14:  MOVF   44,F
0BE16:  BNZ   BE76
0BE18:  MOVF   45,F
0BE1A:  BNZ   BE76
0BE1C:  MOVF   46,F
0BE1E:  BNZ   BE76
0BE20:  MOVF   47,F
0BE22:  BNZ   BE76
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0BE24:  MOVLW  F8
0BE26:  MOVWF  FF6
0BE28:  MOVLW  23
0BE2A:  MOVWF  FF7
0BE2C:  MOVLW  00
0BE2E:  MOVWF  FF8
0BE30:  CLRF   1B
0BE32:  BTFSC  FF2.7
0BE34:  BSF    1B.7
0BE36:  BCF    FF2.7
0BE38:  MOVLW  05
0BE3A:  MOVLB  A
0BE3C:  MOVWF  x18
0BE3E:  MOVLB  0
0BE40:  CALL   1006
0BE44:  BTFSC  1B.7
0BE46:  BSF    FF2.7
0BE48:  MOVLW  10
0BE4A:  MOVWF  FE9
0BE4C:  CLRF   1B
0BE4E:  BTFSC  FF2.7
0BE50:  BSF    1B.7
0BE52:  BCF    FF2.7
0BE54:  MOVFF  42,A19
0BE58:  MOVFF  41,A18
0BE5C:  CALL   1188
0BE60:  BTFSC  1B.7
0BE62:  BSF    FF2.7
0BE64:  MOVLW  0D
0BE66:  BTFSS  F9E.4
0BE68:  BRA    BE66
0BE6A:  MOVWF  FAD
0BE6C:  MOVLW  0A
0BE6E:  BTFSS  F9E.4
0BE70:  BRA    BE6E
0BE72:  MOVWF  FAD
....................    } 
0BE74:  BRA    BE7A
....................    else cmd_arg(); 
0BE76:  CALL   AF7A
0BE7A:  GOTO   BF3C (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0BEEC:  MOVF   47,F
0BEEE:  BNZ   BF0A
0BEF0:  MOVF   46,F
0BEF2:  BNZ   BF0A
0BEF4:  MOVF   45,F
0BEF6:  BNZ   BF0A
0BEF8:  MOVF   44,W
0BEFA:  SUBLW  03
0BEFC:  BNC   BF0A
....................       hb_cmd=arg; 
0BEFE:  MOVFF  44,861
....................       h_bridge(hb_cmd); 
0BF02:  MOVFF  861,891
0BF06:  RCALL  BECC
....................    } 
0BF08:  BRA    BF0E
....................    else cmd_arg(); 
0BF0A:  CALL   AF7A
0BF0E:  GOTO   BF3C (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0BF12:  MOVF   2F,W
0BF14:  MOVWF  00
0BF16:  MOVF   30,W
0BF18:  MOVWF  03
0BF1A:  BNZ   BF20
0BF1C:  MOVF   00,F
0BF1E:  BZ    BF36
0BF20:  MOVF   03,W
0BF22:  BNZ   BF2A
0BF24:  MOVLW  01
0BF26:  SUBWF  00,W
0BF28:  BZ    BF3A
0BF2A:  MOVF   03,W
0BF2C:  BNZ   BF34
0BF2E:  MOVLW  03
0BF30:  SUBWF  00,W
0BF32:  BZ    BF3A
0BF34:  BRA    BF3C
....................       case ECO : commandBe(); 
0BF36:  BRA    BDD4
....................          break; 
0BF38:  BRA    BF3C
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0BF3A:  BRA    BEEC
....................          break; 
....................    } 
0BF3C:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CAC0:  MOVF   44,W
0CAC2:  MOVWF  00
0CAC4:  MOVF   45,W
0CAC6:  MOVWF  03
0CAC8:  BNZ   CACE
0CACA:  MOVF   00,F
0CACC:  BZ    CB30
0CACE:  MOVF   03,W
0CAD0:  BNZ   CADA
0CAD2:  MOVLW  01
0CAD4:  SUBWF  00,W
0CAD6:  BTFSC  FD8.2
0CAD8:  BRA    CD1E
0CADA:  MOVF   03,W
0CADC:  BNZ   CAE6
0CADE:  MOVLW  02
0CAE0:  SUBWF  00,W
0CAE2:  BTFSC  FD8.2
0CAE4:  BRA    CD7A
0CAE6:  MOVF   03,W
0CAE8:  BNZ   CAF2
0CAEA:  MOVLW  03
0CAEC:  SUBWF  00,W
0CAEE:  BTFSC  FD8.2
0CAF0:  BRA    CDD6
0CAF2:  MOVF   03,W
0CAF4:  BNZ   CAFE
0CAF6:  MOVLW  04
0CAF8:  SUBWF  00,W
0CAFA:  BTFSC  FD8.2
0CAFC:  BRA    CE32
0CAFE:  MOVF   03,W
0CB00:  BNZ   CB0A
0CB02:  MOVLW  05
0CB04:  SUBWF  00,W
0CB06:  BTFSC  FD8.2
0CB08:  BRA    CE8E
0CB0A:  MOVF   03,W
0CB0C:  BNZ   CB16
0CB0E:  MOVLW  06
0CB10:  SUBWF  00,W
0CB12:  BTFSC  FD8.2
0CB14:  BRA    CEEA
0CB16:  MOVF   03,W
0CB18:  BNZ   CB22
0CB1A:  MOVLW  07
0CB1C:  SUBWF  00,W
0CB1E:  BTFSC  FD8.2
0CB20:  BRA    CF46
0CB22:  MOVF   03,W
0CB24:  BNZ   CB2E
0CB26:  MOVLW  08
0CB28:  SUBWF  00,W
0CB2A:  BTFSC  FD8.2
0CB2C:  BRA    CFA2
0CB2E:  BRA    CFFE
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CB30:  MOVLW  04
0CB32:  MOVWF  FF6
0CB34:  MOVLW  24
0CB36:  MOVWF  FF7
0CB38:  MOVLW  00
0CB3A:  MOVWF  FF8
0CB3C:  CLRF   1B
0CB3E:  BTFSC  FF2.7
0CB40:  BSF    1B.7
0CB42:  BCF    FF2.7
0CB44:  MOVLW  04
0CB46:  MOVLB  A
0CB48:  MOVWF  x18
0CB4A:  MOVLB  0
0CB4C:  CALL   1006
0CB50:  BTFSC  1B.7
0CB52:  BSF    FF2.7
0CB54:  MOVLW  89
0CB56:  MOVWF  FE9
0CB58:  MOVFF  3F4,864
0CB5C:  MOVFF  3F3,863
0CB60:  MOVFF  3F2,862
0CB64:  MOVFF  3F1,861
0CB68:  MOVLW  05
0CB6A:  MOVLB  8
0CB6C:  MOVWF  x65
0CB6E:  MOVLB  0
0CB70:  RCALL  C3A4
0CB72:  MOVLW  2C
0CB74:  BTFSS  F9E.4
0CB76:  BRA    CB74
0CB78:  MOVWF  FAD
0CB7A:  MOVLW  89
0CB7C:  MOVWF  FE9
0CB7E:  MOVFF  3F8,864
0CB82:  MOVFF  3F7,863
0CB86:  MOVFF  3F6,862
0CB8A:  MOVFF  3F5,861
0CB8E:  MOVLW  05
0CB90:  MOVLB  8
0CB92:  MOVWF  x65
0CB94:  MOVLB  0
0CB96:  RCALL  C3A4
0CB98:  MOVLW  0D
0CB9A:  BTFSS  F9E.4
0CB9C:  BRA    CB9A
0CB9E:  MOVWF  FAD
0CBA0:  MOVLW  0A
0CBA2:  BTFSS  F9E.4
0CBA4:  BRA    CBA2
0CBA6:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CBA8:  MOVLW  16
0CBAA:  MOVWF  FF6
0CBAC:  MOVLW  24
0CBAE:  MOVWF  FF7
0CBB0:  MOVLW  00
0CBB2:  MOVWF  FF8
0CBB4:  CLRF   1B
0CBB6:  BTFSC  FF2.7
0CBB8:  BSF    1B.7
0CBBA:  BCF    FF2.7
0CBBC:  MOVLW  04
0CBBE:  MOVLB  A
0CBC0:  MOVWF  x18
0CBC2:  MOVLB  0
0CBC4:  CALL   1006
0CBC8:  BTFSC  1B.7
0CBCA:  BSF    FF2.7
0CBCC:  MOVLW  89
0CBCE:  MOVWF  FE9
0CBD0:  MOVFF  3FC,864
0CBD4:  MOVFF  3FB,863
0CBD8:  MOVFF  3FA,862
0CBDC:  MOVFF  3F9,861
0CBE0:  MOVLW  05
0CBE2:  MOVLB  8
0CBE4:  MOVWF  x65
0CBE6:  MOVLB  0
0CBE8:  CALL   C3A4
0CBEC:  MOVLW  2C
0CBEE:  BTFSS  F9E.4
0CBF0:  BRA    CBEE
0CBF2:  MOVWF  FAD
0CBF4:  MOVLW  89
0CBF6:  MOVWF  FE9
0CBF8:  MOVFF  400,864
0CBFC:  MOVFF  3FF,863
0CC00:  MOVFF  3FE,862
0CC04:  MOVFF  3FD,861
0CC08:  MOVLW  05
0CC0A:  MOVLB  8
0CC0C:  MOVWF  x65
0CC0E:  MOVLB  0
0CC10:  CALL   C3A4
0CC14:  MOVLW  0D
0CC16:  BTFSS  F9E.4
0CC18:  BRA    CC16
0CC1A:  MOVWF  FAD
0CC1C:  MOVLW  0A
0CC1E:  BTFSS  F9E.4
0CC20:  BRA    CC1E
0CC22:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CC24:  MOVLW  28
0CC26:  MOVWF  FF6
0CC28:  MOVLW  24
0CC2A:  MOVWF  FF7
0CC2C:  MOVLW  00
0CC2E:  MOVWF  FF8
0CC30:  CLRF   1B
0CC32:  BTFSC  FF2.7
0CC34:  BSF    1B.7
0CC36:  BCF    FF2.7
0CC38:  MOVLW  04
0CC3A:  MOVLB  A
0CC3C:  MOVWF  x18
0CC3E:  MOVLB  0
0CC40:  CALL   1006
0CC44:  BTFSC  1B.7
0CC46:  BSF    FF2.7
0CC48:  MOVLW  89
0CC4A:  MOVWF  FE9
0CC4C:  MOVFF  404,864
0CC50:  MOVFF  403,863
0CC54:  MOVFF  402,862
0CC58:  MOVFF  401,861
0CC5C:  MOVLW  05
0CC5E:  MOVLB  8
0CC60:  MOVWF  x65
0CC62:  MOVLB  0
0CC64:  CALL   C3A4
0CC68:  MOVLW  2C
0CC6A:  BTFSS  F9E.4
0CC6C:  BRA    CC6A
0CC6E:  MOVWF  FAD
0CC70:  MOVLW  89
0CC72:  MOVWF  FE9
0CC74:  MOVFF  408,864
0CC78:  MOVFF  407,863
0CC7C:  MOVFF  406,862
0CC80:  MOVFF  405,861
0CC84:  MOVLW  05
0CC86:  MOVLB  8
0CC88:  MOVWF  x65
0CC8A:  MOVLB  0
0CC8C:  CALL   C3A4
0CC90:  MOVLW  0D
0CC92:  BTFSS  F9E.4
0CC94:  BRA    CC92
0CC96:  MOVWF  FAD
0CC98:  MOVLW  0A
0CC9A:  BTFSS  F9E.4
0CC9C:  BRA    CC9A
0CC9E:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CCA0:  MOVLW  3A
0CCA2:  MOVWF  FF6
0CCA4:  MOVLW  24
0CCA6:  MOVWF  FF7
0CCA8:  MOVLW  00
0CCAA:  MOVWF  FF8
0CCAC:  CLRF   1B
0CCAE:  BTFSC  FF2.7
0CCB0:  BSF    1B.7
0CCB2:  BCF    FF2.7
0CCB4:  MOVLW  05
0CCB6:  MOVLB  A
0CCB8:  MOVWF  x18
0CCBA:  MOVLB  0
0CCBC:  CALL   1006
0CCC0:  BTFSC  1B.7
0CCC2:  BSF    FF2.7
0CCC4:  MOVLW  89
0CCC6:  MOVWF  FE9
0CCC8:  MOVFF  40C,864
0CCCC:  MOVFF  40B,863
0CCD0:  MOVFF  40A,862
0CCD4:  MOVFF  409,861
0CCD8:  MOVLW  05
0CCDA:  MOVLB  8
0CCDC:  MOVWF  x65
0CCDE:  MOVLB  0
0CCE0:  CALL   C3A4
0CCE4:  MOVLW  2C
0CCE6:  BTFSS  F9E.4
0CCE8:  BRA    CCE6
0CCEA:  MOVWF  FAD
0CCEC:  MOVLW  89
0CCEE:  MOVWF  FE9
0CCF0:  MOVFF  410,864
0CCF4:  MOVFF  40F,863
0CCF8:  MOVFF  40E,862
0CCFC:  MOVFF  40D,861
0CD00:  MOVLW  05
0CD02:  MOVLB  8
0CD04:  MOVWF  x65
0CD06:  MOVLB  0
0CD08:  CALL   C3A4
0CD0C:  MOVLW  0D
0CD0E:  BTFSS  F9E.4
0CD10:  BRA    CD0E
0CD12:  MOVWF  FAD
0CD14:  MOVLW  0A
0CD16:  BTFSS  F9E.4
0CD18:  BRA    CD16
0CD1A:  MOVWF  FAD
....................                   break; 
0CD1C:  BRA    D002
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0CD1E:  MOVLW  4E
0CD20:  MOVWF  FF6
0CD22:  MOVLW  24
0CD24:  MOVWF  FF7
0CD26:  MOVLW  00
0CD28:  MOVWF  FF8
0CD2A:  CLRF   1B
0CD2C:  BTFSC  FF2.7
0CD2E:  BSF    1B.7
0CD30:  BCF    FF2.7
0CD32:  CALL   0E30
0CD36:  BTFSC  1B.7
0CD38:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0CD3A:  RCALL  CA0C
0CD3C:  MOVFF  03,3F4
0CD40:  MOVFF  02,3F3
0CD44:  MOVFF  01,3F2
0CD48:  MOVFF  00,3F1
....................                fprintf(COM_A,"\r\n");   
0CD4C:  MOVLW  0D
0CD4E:  BTFSS  F9E.4
0CD50:  BRA    CD4E
0CD52:  MOVWF  FAD
0CD54:  MOVLW  0A
0CD56:  BTFSS  F9E.4
0CD58:  BRA    CD56
0CD5A:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0CD5C:  MOVLB  8
0CD5E:  CLRF   x62
0CD60:  MOVLW  44
0CD62:  MOVWF  x61
0CD64:  MOVFF  3F4,866
0CD68:  MOVFF  3F3,865
0CD6C:  MOVFF  3F2,864
0CD70:  MOVFF  3F1,863
0CD74:  MOVLB  0
0CD76:  RCALL  CA52
....................          break; 
0CD78:  BRA    D002
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0CD7A:  MOVLW  56
0CD7C:  MOVWF  FF6
0CD7E:  MOVLW  24
0CD80:  MOVWF  FF7
0CD82:  MOVLW  00
0CD84:  MOVWF  FF8
0CD86:  CLRF   1B
0CD88:  BTFSC  FF2.7
0CD8A:  BSF    1B.7
0CD8C:  BCF    FF2.7
0CD8E:  CALL   0E30
0CD92:  BTFSC  1B.7
0CD94:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0CD96:  RCALL  CA0C
0CD98:  MOVFF  03,3F8
0CD9C:  MOVFF  02,3F7
0CDA0:  MOVFF  01,3F6
0CDA4:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");  
0CDA8:  MOVLW  0D
0CDAA:  BTFSS  F9E.4
0CDAC:  BRA    CDAA
0CDAE:  MOVWF  FAD
0CDB0:  MOVLW  0A
0CDB2:  BTFSS  F9E.4
0CDB4:  BRA    CDB2
0CDB6:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0CDB8:  MOVLB  8
0CDBA:  CLRF   x62
0CDBC:  MOVLW  48
0CDBE:  MOVWF  x61
0CDC0:  MOVFF  3F8,866
0CDC4:  MOVFF  3F7,865
0CDC8:  MOVFF  3F6,864
0CDCC:  MOVFF  3F5,863
0CDD0:  MOVLB  0
0CDD2:  RCALL  CA52
....................          break; 
0CDD4:  BRA    D002
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0CDD6:  MOVLW  5E
0CDD8:  MOVWF  FF6
0CDDA:  MOVLW  24
0CDDC:  MOVWF  FF7
0CDDE:  MOVLW  00
0CDE0:  MOVWF  FF8
0CDE2:  CLRF   1B
0CDE4:  BTFSC  FF2.7
0CDE6:  BSF    1B.7
0CDE8:  BCF    FF2.7
0CDEA:  CALL   0E30
0CDEE:  BTFSC  1B.7
0CDF0:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0CDF2:  RCALL  CA0C
0CDF4:  MOVFF  03,3FC
0CDF8:  MOVFF  02,3FB
0CDFC:  MOVFF  01,3FA
0CE00:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n"); 
0CE04:  MOVLW  0D
0CE06:  BTFSS  F9E.4
0CE08:  BRA    CE06
0CE0A:  MOVWF  FAD
0CE0C:  MOVLW  0A
0CE0E:  BTFSS  F9E.4
0CE10:  BRA    CE0E
0CE12:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0CE14:  MOVLB  8
0CE16:  CLRF   x62
0CE18:  MOVLW  4C
0CE1A:  MOVWF  x61
0CE1C:  MOVFF  3FC,866
0CE20:  MOVFF  3FB,865
0CE24:  MOVFF  3FA,864
0CE28:  MOVFF  3F9,863
0CE2C:  MOVLB  0
0CE2E:  RCALL  CA52
....................          break; 
0CE30:  BRA    D002
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0CE32:  MOVLW  66
0CE34:  MOVWF  FF6
0CE36:  MOVLW  24
0CE38:  MOVWF  FF7
0CE3A:  MOVLW  00
0CE3C:  MOVWF  FF8
0CE3E:  CLRF   1B
0CE40:  BTFSC  FF2.7
0CE42:  BSF    1B.7
0CE44:  BCF    FF2.7
0CE46:  CALL   0E30
0CE4A:  BTFSC  1B.7
0CE4C:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0CE4E:  RCALL  CA0C
0CE50:  MOVFF  03,400
0CE54:  MOVFF  02,3FF
0CE58:  MOVFF  01,3FE
0CE5C:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n");  
0CE60:  MOVLW  0D
0CE62:  BTFSS  F9E.4
0CE64:  BRA    CE62
0CE66:  MOVWF  FAD
0CE68:  MOVLW  0A
0CE6A:  BTFSS  F9E.4
0CE6C:  BRA    CE6A
0CE6E:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0CE70:  MOVLB  8
0CE72:  CLRF   x62
0CE74:  MOVLW  52
0CE76:  MOVWF  x61
0CE78:  MOVFF  3F8,866
0CE7C:  MOVFF  3F7,865
0CE80:  MOVFF  3F6,864
0CE84:  MOVFF  3F5,863
0CE88:  MOVLB  0
0CE8A:  RCALL  CA52
....................          break; 
0CE8C:  BRA    D002
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0CE8E:  MOVLW  6E
0CE90:  MOVWF  FF6
0CE92:  MOVLW  24
0CE94:  MOVWF  FF7
0CE96:  MOVLW  00
0CE98:  MOVWF  FF8
0CE9A:  CLRF   1B
0CE9C:  BTFSC  FF2.7
0CE9E:  BSF    1B.7
0CEA0:  BCF    FF2.7
0CEA2:  CALL   0E30
0CEA6:  BTFSC  1B.7
0CEA8:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0CEAA:  RCALL  CA0C
0CEAC:  MOVFF  03,404
0CEB0:  MOVFF  02,403
0CEB4:  MOVFF  01,402
0CEB8:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");   
0CEBC:  MOVLW  0D
0CEBE:  BTFSS  F9E.4
0CEC0:  BRA    CEBE
0CEC2:  MOVWF  FAD
0CEC4:  MOVLW  0A
0CEC6:  BTFSS  F9E.4
0CEC8:  BRA    CEC6
0CECA:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0CECC:  MOVLB  8
0CECE:  CLRF   x62
0CED0:  MOVLW  56
0CED2:  MOVWF  x61
0CED4:  MOVFF  404,866
0CED8:  MOVFF  403,865
0CEDC:  MOVFF  402,864
0CEE0:  MOVFF  401,863
0CEE4:  MOVLB  0
0CEE6:  RCALL  CA52
....................          break; 
0CEE8:  BRA    D002
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0CEEA:  MOVLW  76
0CEEC:  MOVWF  FF6
0CEEE:  MOVLW  24
0CEF0:  MOVWF  FF7
0CEF2:  MOVLW  00
0CEF4:  MOVWF  FF8
0CEF6:  CLRF   1B
0CEF8:  BTFSC  FF2.7
0CEFA:  BSF    1B.7
0CEFC:  BCF    FF2.7
0CEFE:  CALL   0E30
0CF02:  BTFSC  1B.7
0CF04:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0CF06:  RCALL  CA0C
0CF08:  MOVFF  03,408
0CF0C:  MOVFF  02,407
0CF10:  MOVFF  01,406
0CF14:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");  
0CF18:  MOVLW  0D
0CF1A:  BTFSS  F9E.4
0CF1C:  BRA    CF1A
0CF1E:  MOVWF  FAD
0CF20:  MOVLW  0A
0CF22:  BTFSS  F9E.4
0CF24:  BRA    CF22
0CF26:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0CF28:  MOVLB  8
0CF2A:  CLRF   x62
0CF2C:  MOVLW  5A
0CF2E:  MOVWF  x61
0CF30:  MOVFF  408,866
0CF34:  MOVFF  407,865
0CF38:  MOVFF  406,864
0CF3C:  MOVFF  405,863
0CF40:  MOVLB  0
0CF42:  RCALL  CA52
....................          break; 
0CF44:  BRA    D002
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0CF46:  MOVLW  7E
0CF48:  MOVWF  FF6
0CF4A:  MOVLW  24
0CF4C:  MOVWF  FF7
0CF4E:  MOVLW  00
0CF50:  MOVWF  FF8
0CF52:  CLRF   1B
0CF54:  BTFSC  FF2.7
0CF56:  BSF    1B.7
0CF58:  BCF    FF2.7
0CF5A:  CALL   0E30
0CF5E:  BTFSC  1B.7
0CF60:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0CF62:  RCALL  CA0C
0CF64:  MOVFF  03,40C
0CF68:  MOVFF  02,40B
0CF6C:  MOVFF  01,40A
0CF70:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");   
0CF74:  MOVLW  0D
0CF76:  BTFSS  F9E.4
0CF78:  BRA    CF76
0CF7A:  MOVWF  FAD
0CF7C:  MOVLW  0A
0CF7E:  BTFSS  F9E.4
0CF80:  BRA    CF7E
0CF82:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0CF84:  MOVLB  8
0CF86:  CLRF   x62
0CF88:  MOVLW  5E
0CF8A:  MOVWF  x61
0CF8C:  MOVFF  40C,866
0CF90:  MOVFF  40B,865
0CF94:  MOVFF  40A,864
0CF98:  MOVFF  409,863
0CF9C:  MOVLB  0
0CF9E:  RCALL  CA52
....................          break; 
0CFA0:  BRA    D002
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0CFA2:  MOVLW  88
0CFA4:  MOVWF  FF6
0CFA6:  MOVLW  24
0CFA8:  MOVWF  FF7
0CFAA:  MOVLW  00
0CFAC:  MOVWF  FF8
0CFAE:  CLRF   1B
0CFB0:  BTFSC  FF2.7
0CFB2:  BSF    1B.7
0CFB4:  BCF    FF2.7
0CFB6:  CALL   0E30
0CFBA:  BTFSC  1B.7
0CFBC:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0CFBE:  RCALL  CA0C
0CFC0:  MOVFF  03,410
0CFC4:  MOVFF  02,40F
0CFC8:  MOVFF  01,40E
0CFCC:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");  
0CFD0:  MOVLW  0D
0CFD2:  BTFSS  F9E.4
0CFD4:  BRA    CFD2
0CFD6:  MOVWF  FAD
0CFD8:  MOVLW  0A
0CFDA:  BTFSS  F9E.4
0CFDC:  BRA    CFDA
0CFDE:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0CFE0:  MOVLB  8
0CFE2:  CLRF   x62
0CFE4:  MOVLW  62
0CFE6:  MOVWF  x61
0CFE8:  MOVFF  410,866
0CFEC:  MOVFF  40F,865
0CFF0:  MOVFF  40E,864
0CFF4:  MOVFF  40D,863
0CFF8:  MOVLB  0
0CFFA:  RCALL  CA52
....................          break;         
0CFFC:  BRA    D002
....................       default: cmd_arg(); 
0CFFE:  CALL   AF7A
....................          break; 
....................    } 
0D002:  GOTO   D9F8 (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0D712:  MOVF   47,F
0D714:  BNZ   D724
0D716:  MOVF   46,F
0D718:  BNZ   D724
0D71A:  MOVF   45,F
0D71C:  BNZ   D724
0D71E:  MOVF   44,W
0D720:  SUBLW  01
0D722:  BC    D774
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0D724:  MOVF   47,F
0D726:  BNZ   D73E
0D728:  MOVF   46,F
0D72A:  BNZ   D73E
0D72C:  MOVF   45,F
0D72E:  BNZ   D73E
0D730:  MOVF   44,W
0D732:  SUBLW  30
0D734:  BNC   D73E
0D736:  DECFSZ 2F,W
0D738:  BRA    D73E
0D73A:  MOVF   30,F
0D73C:  BZ    D75A
0D73E:  MOVF   47,F
0D740:  BNZ   D76E
0D742:  MOVF   46,F
0D744:  BNZ   D76E
0D746:  MOVF   45,F
0D748:  BNZ   D76E
0D74A:  MOVF   44,W
0D74C:  SUBLW  32
0D74E:  BNC   D76E
0D750:  MOVF   2F,W
0D752:  SUBLW  03
0D754:  BNZ   D76E
0D756:  MOVF   30,F
0D758:  BNZ   D76E
....................          port=arg; 
0D75A:  MOVFF  45,862
0D75E:  MOVFF  44,861
....................          play_wms_hard_macro(port);    
0D762:  MOVFF  862,866
0D766:  MOVFF  861,865
0D76A:  RCALL  D504
....................       } 
0D76C:  BRA    D772
....................       else cmd_arg(); 
0D76E:  CALL   AF7A
....................    } 
0D772:  BRA    D778
....................    else cmd_arg(); 
0D774:  CALL   AF7A
0D778:  GOTO   D9F8 (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0D988:  MOVF   44,F
0D98A:  BNZ   D998
0D98C:  MOVF   45,F
0D98E:  BNZ   D998
0D990:  MOVF   46,F
0D992:  BNZ   D998
0D994:  MOVF   47,F
0D996:  BZ    D9B6
0D998:  MOVF   47,F
0D99A:  BNZ   D9B6
0D99C:  MOVF   46,F
0D99E:  BNZ   D9B6
0D9A0:  MOVF   45,F
0D9A2:  BNZ   D9B6
0D9A4:  MOVF   44,W
0D9A6:  SUBLW  04
0D9A8:  BNC   D9B6
....................       chip=arg; 
0D9AA:  MOVFF  44,861
....................       sol_chip_cmd(chip); 
0D9AE:  MOVFF  861,892
0D9B2:  RCALL  D8BA
....................    } 
0D9B4:  BRA    D9BA
....................    else cmd_arg();    
0D9B6:  CALL   AF7A
0D9BA:  GOTO   D9F8 (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0D9BE:  MOVF   2F,W
0D9C0:  MOVWF  00
0D9C2:  MOVF   30,W
0D9C4:  MOVWF  03
0D9C6:  BNZ   D9CC
0D9C8:  MOVF   00,F
0D9CA:  BZ    D9EC
0D9CC:  MOVF   03,W
0D9CE:  BNZ   D9D6
0D9D0:  MOVLW  01
0D9D2:  SUBWF  00,W
0D9D4:  BZ    D9F2
0D9D6:  MOVF   03,W
0D9D8:  BNZ   D9E0
0D9DA:  MOVLW  03
0D9DC:  SUBWF  00,W
0D9DE:  BZ    D9F2
0D9E0:  MOVF   03,W
0D9E2:  BNZ   D9EA
0D9E4:  MOVLW  02
0D9E6:  SUBWF  00,W
0D9E8:  BZ    D9F6
0D9EA:  BRA    D9F8
....................       case ECO : commandCe(); 
0D9EC:  GOTO   CAC0
....................          break; 
0D9F0:  BRA    D9F8
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0D9F2:  BRA    D712
....................          break; 
0D9F4:  BRA    D9F8
....................       case AWS : commandCa(); 
0D9F6:  BRA    D988
....................          break;          
....................    } 
0D9F8:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0D9FC:  MOVF   44,W
0D9FE:  MOVWF  00
0DA00:  MOVF   45,W
0DA02:  MOVWF  03
0DA04:  BNZ   DA0A
0DA06:  MOVF   00,F
0DA08:  BZ    DA2A
0DA0A:  MOVF   03,W
0DA0C:  BNZ   DA14
0DA0E:  MOVLW  01
0DA10:  SUBWF  00,W
0DA12:  BZ    DA3C
0DA14:  MOVF   03,W
0DA16:  BNZ   DA1E
0DA18:  MOVLW  02
0DA1A:  SUBWF  00,W
0DA1C:  BZ    DA5E
0DA1E:  MOVF   03,W
0DA20:  BNZ   DA28
0DA22:  MOVLW  03
0DA24:  SUBWF  00,W
0DA26:  BZ    DA70
0DA28:  BRA    DA8E
....................       case 0 : file_list(file_ptr_raw_all); 
0DA2A:  MOVLW  02
0DA2C:  MOVLB  8
0DA2E:  MOVWF  x62
0DA30:  MOVLW  D9
0DA32:  MOVWF  x61
0DA34:  MOVLB  0
0DA36:  CALL   B7A0
....................          break; 
0DA3A:  BRA    DA92
....................       case 1 : file_list(file_ptr_raw_new); 
0DA3C:  MOVLW  02
0DA3E:  MOVLB  8
0DA40:  MOVWF  x62
0DA42:  MOVLW  E7
0DA44:  MOVWF  x61
0DA46:  MOVLB  0
0DA48:  CALL   B7A0
....................                f_unlink(file_ptr_raw_new); 
0DA4C:  MOVLW  02
0DA4E:  MOVLB  8
0DA50:  MOVWF  x63
0DA52:  MOVLW  E7
0DA54:  MOVWF  x62
0DA56:  MOVLB  0
0DA58:  CALL   B91A
....................          break; 
0DA5C:  BRA    DA92
....................       case 2 : file_list(file_ptr_rel_all); 
0DA5E:  MOVLW  02
0DA60:  MOVLB  8
0DA62:  MOVWF  x62
0DA64:  MOVLW  F5
0DA66:  MOVWF  x61
0DA68:  MOVLB  0
0DA6A:  CALL   B7A0
....................          break; 
0DA6E:  BRA    DA92
....................       case 3 : file_list(file_ptr_rel_new); 
0DA70:  MOVLW  03
0DA72:  MOVLB  8
0DA74:  MOVWF  x62
0DA76:  MOVWF  x61
0DA78:  MOVLB  0
0DA7A:  CALL   B7A0
....................                f_unlink(file_ptr_rel_new); 
0DA7E:  MOVLW  03
0DA80:  MOVLB  8
0DA82:  MOVWF  x63
0DA84:  MOVWF  x62
0DA86:  MOVLB  0
0DA88:  CALL   B91A
....................          break;  
0DA8C:  BRA    DA92
....................       default : cmd_arg(); 
0DA8E:  CALL   AF7A
....................          break; 
....................    } 
0DA92:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DA96:  MOVF   44,W
0DA98:  MOVWF  00
0DA9A:  MOVF   45,W
0DA9C:  MOVWF  03
0DA9E:  BNZ   DAA4
0DAA0:  MOVF   00,F
0DAA2:  BZ    DAB0
0DAA4:  MOVF   03,W
0DAA6:  BNZ   DAAE
0DAA8:  MOVLW  02
0DAAA:  SUBWF  00,W
0DAAC:  BZ    DB2A
0DAAE:  BRA    DBA4
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DAB0:  MOVLW  92
0DAB2:  MOVWF  FF6
0DAB4:  MOVLW  24
0DAB6:  MOVWF  FF7
0DAB8:  MOVLW  00
0DABA:  MOVWF  FF8
0DABC:  CLRF   1B
0DABE:  BTFSC  FF2.7
0DAC0:  BSF    1B.7
0DAC2:  BCF    FF2.7
0DAC4:  CALL   0E30
0DAC8:  BTFSC  1B.7
0DACA:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DACC:  CALL   0E1A
0DAD0:  MOVFF  01,861
....................       if(result == 'Y'){ 
0DAD4:  MOVLB  8
0DAD6:  MOVF   x61,W
0DAD8:  SUBLW  59
0DADA:  BNZ   DB0A
....................       f_unlink(file_ptr_raw_all); 
0DADC:  MOVLW  02
0DADE:  MOVWF  x63
0DAE0:  MOVLW  D9
0DAE2:  MOVWF  x62
0DAE4:  MOVLB  0
0DAE6:  CALL   B91A
....................       printf("File deleted!\n\r"); 
0DAEA:  MOVLW  CE
0DAEC:  MOVWF  FF6
0DAEE:  MOVLW  24
0DAF0:  MOVWF  FF7
0DAF2:  MOVLW  00
0DAF4:  MOVWF  FF8
0DAF6:  CLRF   1B
0DAF8:  BTFSC  FF2.7
0DAFA:  BSF    1B.7
0DAFC:  BCF    FF2.7
0DAFE:  CALL   0E30
0DB02:  BTFSC  1B.7
0DB04:  BSF    FF2.7
....................       }else{ 
0DB06:  BRA    DB28
0DB08:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DB0A:  MOVLW  DE
0DB0C:  MOVWF  FF6
0DB0E:  MOVLW  24
0DB10:  MOVWF  FF7
0DB12:  MOVLW  00
0DB14:  MOVWF  FF8
0DB16:  CLRF   1B
0DB18:  BTFSC  FF2.7
0DB1A:  BSF    1B.7
0DB1C:  BCF    FF2.7
0DB1E:  MOVLB  0
0DB20:  CALL   0E30
0DB24:  BTFSC  1B.7
0DB26:  BSF    FF2.7
....................       } 
....................          break; 
0DB28:  BRA    DBA8
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DB2A:  MOVLW  F4
0DB2C:  MOVWF  FF6
0DB2E:  MOVLW  24
0DB30:  MOVWF  FF7
0DB32:  MOVLW  00
0DB34:  MOVWF  FF8
0DB36:  CLRF   1B
0DB38:  BTFSC  FF2.7
0DB3A:  BSF    1B.7
0DB3C:  BCF    FF2.7
0DB3E:  CALL   0E30
0DB42:  BTFSC  1B.7
0DB44:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DB46:  CALL   0E1A
0DB4A:  MOVFF  01,861
....................          if(result == 'Y'){ 
0DB4E:  MOVLB  8
0DB50:  MOVF   x61,W
0DB52:  SUBLW  59
0DB54:  BNZ   DB84
....................             f_unlink(file_ptr_rel_all); 
0DB56:  MOVLW  02
0DB58:  MOVWF  x63
0DB5A:  MOVLW  F5
0DB5C:  MOVWF  x62
0DB5E:  MOVLB  0
0DB60:  CALL   B91A
....................             printf("File deleted!\n\r"); 
0DB64:  MOVLW  38
0DB66:  MOVWF  FF6
0DB68:  MOVLW  25
0DB6A:  MOVWF  FF7
0DB6C:  MOVLW  00
0DB6E:  MOVWF  FF8
0DB70:  CLRF   1B
0DB72:  BTFSC  FF2.7
0DB74:  BSF    1B.7
0DB76:  BCF    FF2.7
0DB78:  CALL   0E30
0DB7C:  BTFSC  1B.7
0DB7E:  BSF    FF2.7
....................          }else{ 
0DB80:  BRA    DBA2
0DB82:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DB84:  MOVLW  48
0DB86:  MOVWF  FF6
0DB88:  MOVLW  25
0DB8A:  MOVWF  FF7
0DB8C:  MOVLW  00
0DB8E:  MOVWF  FF8
0DB90:  CLRF   1B
0DB92:  BTFSC  FF2.7
0DB94:  BSF    1B.7
0DB96:  BCF    FF2.7
0DB98:  MOVLB  0
0DB9A:  CALL   0E30
0DB9E:  BTFSC  1B.7
0DBA0:  BSF    FF2.7
....................          } 
....................          break; 
0DBA2:  BRA    DBA8
....................       default : cmd_arg(); 
0DBA4:  CALL   AF7A
....................          break;          
....................    } 
0DBA8:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0DD94:  MOVF   44,W
0DD96:  SUBLW  95
0DD98:  BNZ   DDAC
0DD9A:  MOVF   45,W
0DD9C:  SUBLW  15
0DD9E:  BNZ   DDAC
0DDA0:  MOVF   46,F
0DDA2:  BNZ   DDAC
0DDA4:  MOVF   47,F
0DDA6:  BNZ   DDAC
....................       reset_nv_vars(); 
0DDA8:  BRA    DBAC
....................    } 
0DDAA:  BRA    DDB0
....................    else cmd_arg(); 
0DDAC:  CALL   AF7A
0DDB0:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0DDFE:  MOVF   2F,F
0DE00:  BNZ   DE06
0DE02:  MOVF   30,F
0DE04:  BZ    DE18
0DE06:  DECFSZ 2F,W
0DE08:  BRA    DE0E
0DE0A:  MOVF   30,F
0DE0C:  BZ    DE18
0DE0E:  MOVF   2F,W
0DE10:  SUBLW  03
0DE12:  BNZ   DE8A
0DE14:  MOVF   30,F
0DE16:  BNZ   DE8A
....................    { 
....................       busy_set(); 
0DE18:  CALL   293E
....................  
....................       switch(arg) 
0DE1C:  MOVFF  44,00
0DE20:  MOVF   45,W
0DE22:  MOVWF  03
0DE24:  BNZ   DE2C
0DE26:  MOVLW  01
0DE28:  SUBWF  00,W
0DE2A:  BZ    DE42
0DE2C:  MOVF   03,W
0DE2E:  BNZ   DE36
0DE30:  MOVLW  02
0DE32:  SUBWF  00,W
0DE34:  BZ    DE52
0DE36:  MOVF   03,W
0DE38:  BNZ   DE40
0DE3A:  MOVLW  03
0DE3C:  SUBWF  00,W
0DE3E:  BZ    DE7C
0DE40:  BRA    DE82
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0DE42:  MOVLB  7
0DE44:  CLRF   x3C
....................             align(0); 
0DE46:  MOVLB  8
0DE48:  CLRF   x9E
0DE4A:  MOVLB  0
0DE4C:  CALL   A7FE
....................             break; 
0DE50:  BRA    DE86
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0DE52:  MOVF   44,W
0DE54:  SUBLW  02
0DE56:  BNZ   DE7A
0DE58:  MOVF   45,F
0DE5A:  BNZ   DE7A
0DE5C:  MOVF   46,F
0DE5E:  BNZ   DE7A
0DE60:  MOVF   47,F
0DE62:  BNZ   DE7A
0DE64:  MOVF   1F,W
0DE66:  SUBLW  04
0DE68:  BNZ   DE7A
0DE6A:  MOVF   20,F
0DE6C:  BNZ   DE7A
....................             { 
....................                motor=0; 
0DE6E:  MOVLB  7
0DE70:  CLRF   x3C
....................                cal_disk(0); 
0DE72:  MOVLB  8
0DE74:  CLRF   x61
0DE76:  MOVLB  0
0DE78:  BRA    DDB4
....................             } 
....................             break; 
0DE7A:  BRA    DE86
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0DE7C:  CALL   A9A2
....................             break; 
0DE80:  BRA    DE86
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0DE82:  CALL   AF7A
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0DE86:  CALL   ADB6
....................    } 
0DE8A:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E364:  DECFSZ 44,W
0E366:  BRA    E784
0E368:  MOVF   45,F
0E36A:  BTFSS  FD8.2
0E36C:  BRA    E784
0E36E:  MOVF   46,F
0E370:  BTFSS  FD8.2
0E372:  BRA    E784
0E374:  MOVF   47,F
0E376:  BTFSS  FD8.2
0E378:  BRA    E784
....................       v_supply = read_supply(); 
0E37A:  CALL   507A
0E37E:  MOVFF  02,862
0E382:  MOVFF  01,861
....................        
....................       RTC_reset_HT(); 
0E386:  CALL   3430
....................       RTC_read(); 
0E38A:  CALL   32C2
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E38E:  MOVLW  5E
0E390:  MOVWF  FF6
0E392:  MOVLW  25
0E394:  MOVWF  FF7
0E396:  MOVLW  00
0E398:  MOVWF  FF8
0E39A:  CLRF   1B
0E39C:  BTFSC  FF2.7
0E39E:  BSF    1B.7
0E3A0:  BCF    FF2.7
0E3A2:  MOVLW  04
0E3A4:  MOVLB  A
0E3A6:  MOVWF  x18
0E3A8:  MOVLB  0
0E3AA:  CALL   1006
0E3AE:  BTFSC  1B.7
0E3B0:  BSF    FF2.7
0E3B2:  MOVLW  10
0E3B4:  MOVWF  FE9
0E3B6:  CLRF   1B
0E3B8:  BTFSC  FF2.7
0E3BA:  BSF    1B.7
0E3BC:  BCF    FF2.7
0E3BE:  MOVFF  26,A19
0E3C2:  MOVFF  25,A18
0E3C6:  CALL   1188
0E3CA:  BTFSC  1B.7
0E3CC:  BSF    FF2.7
0E3CE:  MOVLW  20
0E3D0:  BTFSS  F9E.4
0E3D2:  BRA    E3D0
0E3D4:  MOVWF  FAD
0E3D6:  MOVLW  49
0E3D8:  BTFSS  F9E.4
0E3DA:  BRA    E3D8
0E3DC:  MOVWF  FAD
0E3DE:  MOVLW  10
0E3E0:  MOVWF  FE9
0E3E2:  CLRF   1B
0E3E4:  BTFSC  FF2.7
0E3E6:  BSF    1B.7
0E3E8:  BCF    FF2.7
0E3EA:  MOVFF  24,A19
0E3EE:  MOVFF  23,A18
0E3F2:  CALL   1188
0E3F6:  BTFSC  1B.7
0E3F8:  BSF    FF2.7
0E3FA:  MOVLW  20
0E3FC:  BTFSS  F9E.4
0E3FE:  BRA    E3FC
0E400:  MOVWF  FAD
0E402:  MOVLW  4E
0E404:  BTFSS  F9E.4
0E406:  BRA    E404
0E408:  MOVWF  FAD
0E40A:  MOVLW  10
0E40C:  MOVWF  FE9
0E40E:  CLRF   1B
0E410:  BTFSC  FF2.7
0E412:  BSF    1B.7
0E414:  BCF    FF2.7
0E416:  MOVFF  22,A19
0E41A:  MOVFF  21,A18
0E41E:  CALL   1188
0E422:  BTFSC  1B.7
0E424:  BSF    FF2.7
0E426:  MOVLW  2F
0E428:  BTFSS  F9E.4
0E42A:  BRA    E428
0E42C:  MOVWF  FAD
0E42E:  MOVLW  10
0E430:  MOVWF  FE9
0E432:  CLRF   1B
0E434:  BTFSC  FF2.7
0E436:  BSF    1B.7
0E438:  BCF    FF2.7
0E43A:  MOVFF  28,A19
0E43E:  MOVFF  27,A18
0E442:  CALL   1188
0E446:  BTFSC  1B.7
0E448:  BSF    FF2.7
0E44A:  MOVLW  20
0E44C:  BTFSS  F9E.4
0E44E:  BRA    E44C
0E450:  MOVWF  FAD
0E452:  MOVLW  58
0E454:  BTFSS  F9E.4
0E456:  BRA    E454
0E458:  MOVWF  FAD
0E45A:  MOVLW  10
0E45C:  MOVWF  FE9
0E45E:  CLRF   1B
0E460:  BTFSC  FF2.7
0E462:  BSF    1B.7
0E464:  BCF    FF2.7
0E466:  MOVFF  20,A19
0E46A:  MOVFF  1F,A18
0E46E:  CALL   1188
0E472:  BTFSC  1B.7
0E474:  BSF    FF2.7
0E476:  MOVLW  20
0E478:  BTFSS  F9E.4
0E47A:  BRA    E478
0E47C:  MOVWF  FAD
0E47E:  MOVLW  55
0E480:  BTFSS  F9E.4
0E482:  BRA    E480
0E484:  MOVWF  FAD
0E486:  CLRF   1B
0E488:  BTFSC  FF2.7
0E48A:  BSF    1B.7
0E48C:  BCF    FF2.7
0E48E:  MOVFF  73C,A18
0E492:  MOVLW  1B
0E494:  MOVLB  A
0E496:  MOVWF  x19
0E498:  MOVLB  0
0E49A:  CALL   0F88
0E49E:  BTFSC  1B.7
0E4A0:  BSF    FF2.7
0E4A2:  MOVLW  20
0E4A4:  BTFSS  F9E.4
0E4A6:  BRA    E4A4
0E4A8:  MOVWF  FAD
0E4AA:  MOVLW  04
0E4AC:  MOVWF  FE9
0E4AE:  MOVLB  8
0E4B0:  CLRF   x66
0E4B2:  CLRF   x65
0E4B4:  MOVFF  862,864
0E4B8:  MOVFF  861,863
0E4BC:  MOVLW  02
0E4BE:  MOVWF  x67
0E4C0:  MOVLB  0
0E4C2:  RCALL  DE8E
0E4C4:  MOVLW  82
0E4C6:  MOVWF  FF6
0E4C8:  MOVLW  25
0E4CA:  MOVWF  FF7
0E4CC:  MOVLW  00
0E4CE:  MOVWF  FF8
0E4D0:  CLRF   1B
0E4D2:  BTFSC  FF2.7
0E4D4:  BSF    1B.7
0E4D6:  BCF    FF2.7
0E4D8:  MOVLW  03
0E4DA:  MOVLB  A
0E4DC:  MOVWF  x18
0E4DE:  MOVLB  0
0E4E0:  CALL   1006
0E4E4:  BTFSC  1B.7
0E4E6:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E4E8:  MOVLW  86
0E4EA:  MOVWF  FF6
0E4EC:  MOVLW  25
0E4EE:  MOVWF  FF7
0E4F0:  MOVLW  00
0E4F2:  MOVWF  FF8
0E4F4:  CLRF   1B
0E4F6:  BTFSC  FF2.7
0E4F8:  BSF    1B.7
0E4FA:  BCF    FF2.7
0E4FC:  MOVLW  09
0E4FE:  MOVLB  A
0E500:  MOVWF  x18
0E502:  MOVLB  0
0E504:  CALL   1006
0E508:  BTFSC  1B.7
0E50A:  BSF    FF2.7
0E50C:  MOVLW  10
0E50E:  MOVWF  FE9
0E510:  CLRF   1B
0E512:  BTFSC  FF2.7
0E514:  BSF    1B.7
0E516:  BCF    FF2.7
0E518:  MOVFF  7C0,A19
0E51C:  MOVFF  7BF,A18
0E520:  CALL   1188
0E524:  BTFSC  1B.7
0E526:  BSF    FF2.7
0E528:  MOVLW  92
0E52A:  MOVWF  FF6
0E52C:  MOVLW  25
0E52E:  MOVWF  FF7
0E530:  MOVLW  00
0E532:  MOVWF  FF8
0E534:  CLRF   1B
0E536:  BTFSC  FF2.7
0E538:  BSF    1B.7
0E53A:  BCF    FF2.7
0E53C:  MOVLW  05
0E53E:  MOVLB  A
0E540:  MOVWF  x18
0E542:  MOVLB  0
0E544:  CALL   1006
0E548:  BTFSC  1B.7
0E54A:  BSF    FF2.7
0E54C:  MOVLW  10
0E54E:  MOVWF  FE9
0E550:  MOVFF  7B2,8CD
0E554:  MOVFF  7B1,8CC
0E558:  CALL   8F2E
0E55C:  MOVLW  0D
0E55E:  BTFSS  F9E.4
0E560:  BRA    E55E
0E562:  MOVWF  FAD
0E564:  MOVLW  0A
0E566:  BTFSS  F9E.4
0E568:  BRA    E566
0E56A:  MOVWF  FAD
....................       RTC_display(); 
0E56C:  RCALL  DF8A
....................       if (RTCfmt == 0) 
0E56E:  MOVF   4B,F
0E570:  BTFSS  FD8.2
0E572:  BRA    E678
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E574:  MOVLW  9E
0E576:  MOVWF  FF6
0E578:  MOVLW  25
0E57A:  MOVWF  FF7
0E57C:  MOVLW  00
0E57E:  MOVWF  FF8
0E580:  CLRF   1B
0E582:  BTFSC  FF2.7
0E584:  BSF    1B.7
0E586:  BCF    FF2.7
0E588:  MOVLW  05
0E58A:  MOVLB  A
0E58C:  MOVWF  x18
0E58E:  MOVLB  0
0E590:  CALL   1006
0E594:  BTFSC  1B.7
0E596:  BSF    FF2.7
0E598:  CLRF   1B
0E59A:  BTFSC  FF2.7
0E59C:  BSF    1B.7
0E59E:  BCF    FF2.7
0E5A0:  MOVFF  736,A18
0E5A4:  MOVLW  01
0E5A6:  MOVLB  A
0E5A8:  MOVWF  x19
0E5AA:  MOVLB  0
0E5AC:  CALL   0F88
0E5B0:  BTFSC  1B.7
0E5B2:  BSF    FF2.7
0E5B4:  MOVLW  2F
0E5B6:  BTFSS  F9E.4
0E5B8:  BRA    E5B6
0E5BA:  MOVWF  FAD
0E5BC:  CLRF   1B
0E5BE:  BTFSC  FF2.7
0E5C0:  BSF    1B.7
0E5C2:  BCF    FF2.7
0E5C4:  MOVFF  737,A18
0E5C8:  MOVLW  01
0E5CA:  MOVLB  A
0E5CC:  MOVWF  x19
0E5CE:  MOVLB  0
0E5D0:  CALL   0F88
0E5D4:  BTFSC  1B.7
0E5D6:  BSF    FF2.7
0E5D8:  MOVLW  2F
0E5DA:  BTFSS  F9E.4
0E5DC:  BRA    E5DA
0E5DE:  MOVWF  FAD
0E5E0:  CLRF   1B
0E5E2:  BTFSC  FF2.7
0E5E4:  BSF    1B.7
0E5E6:  BCF    FF2.7
0E5E8:  MOVFF  738,A18
0E5EC:  MOVLW  01
0E5EE:  MOVLB  A
0E5F0:  MOVWF  x19
0E5F2:  MOVLB  0
0E5F4:  CALL   0F88
0E5F8:  BTFSC  1B.7
0E5FA:  BSF    FF2.7
0E5FC:  MOVLW  20
0E5FE:  BTFSS  F9E.4
0E600:  BRA    E5FE
0E602:  MOVWF  FAD
0E604:  CLRF   1B
0E606:  BTFSC  FF2.7
0E608:  BSF    1B.7
0E60A:  BCF    FF2.7
0E60C:  MOVFF  739,A18
0E610:  MOVLW  01
0E612:  MOVLB  A
0E614:  MOVWF  x19
0E616:  MOVLB  0
0E618:  CALL   0F88
0E61C:  BTFSC  1B.7
0E61E:  BSF    FF2.7
0E620:  MOVLW  3A
0E622:  BTFSS  F9E.4
0E624:  BRA    E622
0E626:  MOVWF  FAD
0E628:  CLRF   1B
0E62A:  BTFSC  FF2.7
0E62C:  BSF    1B.7
0E62E:  BCF    FF2.7
0E630:  MOVFF  73A,A18
0E634:  MOVLW  01
0E636:  MOVLB  A
0E638:  MOVWF  x19
0E63A:  MOVLB  0
0E63C:  CALL   0F88
0E640:  BTFSC  1B.7
0E642:  BSF    FF2.7
0E644:  MOVLW  3A
0E646:  BTFSS  F9E.4
0E648:  BRA    E646
0E64A:  MOVWF  FAD
0E64C:  CLRF   1B
0E64E:  BTFSC  FF2.7
0E650:  BSF    1B.7
0E652:  BCF    FF2.7
0E654:  MOVFF  73B,A18
0E658:  MOVLW  01
0E65A:  MOVLB  A
0E65C:  MOVWF  x19
0E65E:  MOVLB  0
0E660:  CALL   0F88
0E664:  BTFSC  1B.7
0E666:  BSF    FF2.7
0E668:  MOVLW  0D
0E66A:  BTFSS  F9E.4
0E66C:  BRA    E66A
0E66E:  MOVWF  FAD
0E670:  MOVLW  0A
0E672:  BTFSS  F9E.4
0E674:  BRA    E672
0E676:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E678:  DECFSZ 4B,W
0E67A:  BRA    E780
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E67C:  MOVLW  C4
0E67E:  MOVWF  FF6
0E680:  MOVLW  25
0E682:  MOVWF  FF7
0E684:  MOVLW  00
0E686:  MOVWF  FF8
0E688:  CLRF   1B
0E68A:  BTFSC  FF2.7
0E68C:  BSF    1B.7
0E68E:  BCF    FF2.7
0E690:  MOVLW  05
0E692:  MOVLB  A
0E694:  MOVWF  x18
0E696:  MOVLB  0
0E698:  CALL   1006
0E69C:  BTFSC  1B.7
0E69E:  BSF    FF2.7
0E6A0:  CLRF   1B
0E6A2:  BTFSC  FF2.7
0E6A4:  BSF    1B.7
0E6A6:  BCF    FF2.7
0E6A8:  MOVFF  737,A18
0E6AC:  MOVLW  01
0E6AE:  MOVLB  A
0E6B0:  MOVWF  x19
0E6B2:  MOVLB  0
0E6B4:  CALL   0F88
0E6B8:  BTFSC  1B.7
0E6BA:  BSF    FF2.7
0E6BC:  MOVLW  2F
0E6BE:  BTFSS  F9E.4
0E6C0:  BRA    E6BE
0E6C2:  MOVWF  FAD
0E6C4:  CLRF   1B
0E6C6:  BTFSC  FF2.7
0E6C8:  BSF    1B.7
0E6CA:  BCF    FF2.7
0E6CC:  MOVFF  736,A18
0E6D0:  MOVLW  01
0E6D2:  MOVLB  A
0E6D4:  MOVWF  x19
0E6D6:  MOVLB  0
0E6D8:  CALL   0F88
0E6DC:  BTFSC  1B.7
0E6DE:  BSF    FF2.7
0E6E0:  MOVLW  2F
0E6E2:  BTFSS  F9E.4
0E6E4:  BRA    E6E2
0E6E6:  MOVWF  FAD
0E6E8:  CLRF   1B
0E6EA:  BTFSC  FF2.7
0E6EC:  BSF    1B.7
0E6EE:  BCF    FF2.7
0E6F0:  MOVFF  738,A18
0E6F4:  MOVLW  01
0E6F6:  MOVLB  A
0E6F8:  MOVWF  x19
0E6FA:  MOVLB  0
0E6FC:  CALL   0F88
0E700:  BTFSC  1B.7
0E702:  BSF    FF2.7
0E704:  MOVLW  20
0E706:  BTFSS  F9E.4
0E708:  BRA    E706
0E70A:  MOVWF  FAD
0E70C:  CLRF   1B
0E70E:  BTFSC  FF2.7
0E710:  BSF    1B.7
0E712:  BCF    FF2.7
0E714:  MOVFF  739,A18
0E718:  MOVLW  01
0E71A:  MOVLB  A
0E71C:  MOVWF  x19
0E71E:  MOVLB  0
0E720:  CALL   0F88
0E724:  BTFSC  1B.7
0E726:  BSF    FF2.7
0E728:  MOVLW  3A
0E72A:  BTFSS  F9E.4
0E72C:  BRA    E72A
0E72E:  MOVWF  FAD
0E730:  CLRF   1B
0E732:  BTFSC  FF2.7
0E734:  BSF    1B.7
0E736:  BCF    FF2.7
0E738:  MOVFF  73A,A18
0E73C:  MOVLW  01
0E73E:  MOVLB  A
0E740:  MOVWF  x19
0E742:  MOVLB  0
0E744:  CALL   0F88
0E748:  BTFSC  1B.7
0E74A:  BSF    FF2.7
0E74C:  MOVLW  3A
0E74E:  BTFSS  F9E.4
0E750:  BRA    E74E
0E752:  MOVWF  FAD
0E754:  CLRF   1B
0E756:  BTFSC  FF2.7
0E758:  BSF    1B.7
0E75A:  BCF    FF2.7
0E75C:  MOVFF  73B,A18
0E760:  MOVLW  01
0E762:  MOVLB  A
0E764:  MOVWF  x19
0E766:  MOVLB  0
0E768:  CALL   0F88
0E76C:  BTFSC  1B.7
0E76E:  BSF    FF2.7
0E770:  MOVLW  0D
0E772:  BTFSS  F9E.4
0E774:  BRA    E772
0E776:  MOVWF  FAD
0E778:  MOVLW  0A
0E77A:  BTFSS  F9E.4
0E77C:  BRA    E77A
0E77E:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0E780:  RCALL  E114
....................       RTC_display_alarm(); 
0E782:  RCALL  E1EA
....................    } 
0E784:  GOTO   EF98 (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0E788:  DECFSZ 44,W
0E78A:  BRA    EA62
0E78C:  MOVF   45,F
0E78E:  BTFSS  FD8.2
0E790:  BRA    EA62
0E792:  MOVF   46,F
0E794:  BTFSS  FD8.2
0E796:  BRA    EA62
0E798:  MOVF   47,F
0E79A:  BTFSS  FD8.2
0E79C:  BRA    EA62
....................       v_supply = read_supply(); 
0E79E:  CALL   507A
0E7A2:  MOVFF  02,862
0E7A6:  MOVFF  01,861
....................        
....................       RTC_reset_HT(); 
0E7AA:  CALL   3430
....................       RTC_read(); 
0E7AE:  CALL   32C2
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0E7B2:  MOVLW  41
0E7B4:  BTFSS  F9E.4
0E7B6:  BRA    E7B4
0E7B8:  MOVWF  FAD
0E7BA:  MOVLW  10
0E7BC:  MOVWF  FE9
0E7BE:  CLRF   1B
0E7C0:  BTFSC  FF2.7
0E7C2:  BSF    1B.7
0E7C4:  BCF    FF2.7
0E7C6:  MOVFF  2A,A19
0E7CA:  MOVFF  29,A18
0E7CE:  CALL   1188
0E7D2:  BTFSC  1B.7
0E7D4:  BSF    FF2.7
0E7D6:  MOVLW  20
0E7D8:  BTFSS  F9E.4
0E7DA:  BRA    E7D8
0E7DC:  MOVWF  FAD
0E7DE:  MOVLW  49
0E7E0:  BTFSS  F9E.4
0E7E2:  BRA    E7E0
0E7E4:  MOVWF  FAD
0E7E6:  MOVLW  10
0E7E8:  MOVWF  FE9
0E7EA:  CLRF   1B
0E7EC:  BTFSC  FF2.7
0E7EE:  BSF    1B.7
0E7F0:  BCF    FF2.7
0E7F2:  MOVFF  24,A19
0E7F6:  MOVFF  23,A18
0E7FA:  CALL   1188
0E7FE:  BTFSC  1B.7
0E800:  BSF    FF2.7
0E802:  MOVLW  20
0E804:  BTFSS  F9E.4
0E806:  BRA    E804
0E808:  MOVWF  FAD
0E80A:  MOVLW  4C
0E80C:  BTFSS  F9E.4
0E80E:  BRA    E80C
0E810:  MOVWF  FAD
0E812:  MOVLW  10
0E814:  MOVWF  FE9
0E816:  CLRF   1B
0E818:  BTFSC  FF2.7
0E81A:  BSF    1B.7
0E81C:  BCF    FF2.7
0E81E:  MOVFF  2C,A19
0E822:  MOVFF  2B,A18
0E826:  CALL   1188
0E82A:  BTFSC  1B.7
0E82C:  BSF    FF2.7
0E82E:  MOVLW  20
0E830:  BTFSS  F9E.4
0E832:  BRA    E830
0E834:  MOVWF  FAD
0E836:  MOVLW  51
0E838:  BTFSS  F9E.4
0E83A:  BRA    E838
0E83C:  MOVWF  FAD
0E83E:  MOVLW  10
0E840:  MOVWF  FE9
0E842:  CLRF   1B
0E844:  BTFSC  FF2.7
0E846:  BSF    1B.7
0E848:  BCF    FF2.7
0E84A:  MOVFF  2E,A19
0E84E:  MOVFF  2D,A18
0E852:  CALL   1188
0E856:  BTFSC  1B.7
0E858:  BSF    FF2.7
0E85A:  MOVLW  20
0E85C:  BTFSS  F9E.4
0E85E:  BRA    E85C
0E860:  MOVWF  FAD
0E862:  MOVLW  53
0E864:  BTFSS  F9E.4
0E866:  BRA    E864
0E868:  MOVWF  FAD
0E86A:  MOVLW  10
0E86C:  MOVWF  FE9
0E86E:  CLRF   1B
0E870:  BTFSC  FF2.7
0E872:  BSF    1B.7
0E874:  BCF    FF2.7
0E876:  MOVFF  22,A19
0E87A:  MOVFF  21,A18
0E87E:  CALL   1188
0E882:  BTFSC  1B.7
0E884:  BSF    FF2.7
0E886:  MOVLW  20
0E888:  BTFSS  F9E.4
0E88A:  BRA    E888
0E88C:  MOVWF  FAD
0E88E:  MOVLW  04
0E890:  MOVWF  FE9
0E892:  MOVLB  8
0E894:  CLRF   x66
0E896:  CLRF   x65
0E898:  MOVFF  862,864
0E89C:  MOVFF  861,863
0E8A0:  MOVLW  02
0E8A2:  MOVWF  x67
0E8A4:  MOVLB  0
0E8A6:  CALL   DE8E
0E8AA:  MOVLW  08
0E8AC:  MOVWF  FF6
0E8AE:  MOVLW  26
0E8B0:  MOVWF  FF7
0E8B2:  MOVLW  00
0E8B4:  MOVWF  FF8
0E8B6:  CLRF   1B
0E8B8:  BTFSC  FF2.7
0E8BA:  BSF    1B.7
0E8BC:  BCF    FF2.7
0E8BE:  MOVLW  03
0E8C0:  MOVLB  A
0E8C2:  MOVWF  x18
0E8C4:  MOVLB  0
0E8C6:  CALL   1006
0E8CA:  BTFSC  1B.7
0E8CC:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E8CE:  MOVLW  0C
0E8D0:  MOVWF  FF6
0E8D2:  MOVLW  26
0E8D4:  MOVWF  FF7
0E8D6:  MOVLW  00
0E8D8:  MOVWF  FF8
0E8DA:  CLRF   1B
0E8DC:  BTFSC  FF2.7
0E8DE:  BSF    1B.7
0E8E0:  BCF    FF2.7
0E8E2:  MOVLW  09
0E8E4:  MOVLB  A
0E8E6:  MOVWF  x18
0E8E8:  MOVLB  0
0E8EA:  CALL   1006
0E8EE:  BTFSC  1B.7
0E8F0:  BSF    FF2.7
0E8F2:  MOVLW  10
0E8F4:  MOVWF  FE9
0E8F6:  CLRF   1B
0E8F8:  BTFSC  FF2.7
0E8FA:  BSF    1B.7
0E8FC:  BCF    FF2.7
0E8FE:  MOVFF  7C0,A19
0E902:  MOVFF  7BF,A18
0E906:  CALL   1188
0E90A:  BTFSC  1B.7
0E90C:  BSF    FF2.7
0E90E:  MOVLW  18
0E910:  MOVWF  FF6
0E912:  MOVLW  26
0E914:  MOVWF  FF7
0E916:  MOVLW  00
0E918:  MOVWF  FF8
0E91A:  CLRF   1B
0E91C:  BTFSC  FF2.7
0E91E:  BSF    1B.7
0E920:  BCF    FF2.7
0E922:  MOVLW  05
0E924:  MOVLB  A
0E926:  MOVWF  x18
0E928:  MOVLB  0
0E92A:  CALL   1006
0E92E:  BTFSC  1B.7
0E930:  BSF    FF2.7
0E932:  MOVLW  10
0E934:  MOVWF  FE9
0E936:  MOVFF  7B2,8CD
0E93A:  MOVFF  7B1,8CC
0E93E:  CALL   8F2E
0E942:  MOVLW  0D
0E944:  BTFSS  F9E.4
0E946:  BRA    E944
0E948:  MOVWF  FAD
0E94A:  MOVLW  0A
0E94C:  BTFSS  F9E.4
0E94E:  BRA    E94C
0E950:  MOVWF  FAD
....................       RTC_display(); 
0E952:  CALL   DF8A
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E956:  MOVLW  24
0E958:  MOVWF  FF6
0E95A:  MOVLW  26
0E95C:  MOVWF  FF7
0E95E:  MOVLW  00
0E960:  MOVWF  FF8
0E962:  CLRF   1B
0E964:  BTFSC  FF2.7
0E966:  BSF    1B.7
0E968:  BCF    FF2.7
0E96A:  MOVLW  05
0E96C:  MOVLB  A
0E96E:  MOVWF  x18
0E970:  MOVLB  0
0E972:  CALL   1006
0E976:  BTFSC  1B.7
0E978:  BSF    FF2.7
0E97A:  CLRF   1B
0E97C:  BTFSC  FF2.7
0E97E:  BSF    1B.7
0E980:  BCF    FF2.7
0E982:  MOVFF  736,A18
0E986:  MOVLW  01
0E988:  MOVLB  A
0E98A:  MOVWF  x19
0E98C:  MOVLB  0
0E98E:  CALL   0F88
0E992:  BTFSC  1B.7
0E994:  BSF    FF2.7
0E996:  MOVLW  2F
0E998:  BTFSS  F9E.4
0E99A:  BRA    E998
0E99C:  MOVWF  FAD
0E99E:  CLRF   1B
0E9A0:  BTFSC  FF2.7
0E9A2:  BSF    1B.7
0E9A4:  BCF    FF2.7
0E9A6:  MOVFF  737,A18
0E9AA:  MOVLW  01
0E9AC:  MOVLB  A
0E9AE:  MOVWF  x19
0E9B0:  MOVLB  0
0E9B2:  CALL   0F88
0E9B6:  BTFSC  1B.7
0E9B8:  BSF    FF2.7
0E9BA:  MOVLW  2F
0E9BC:  BTFSS  F9E.4
0E9BE:  BRA    E9BC
0E9C0:  MOVWF  FAD
0E9C2:  CLRF   1B
0E9C4:  BTFSC  FF2.7
0E9C6:  BSF    1B.7
0E9C8:  BCF    FF2.7
0E9CA:  MOVFF  738,A18
0E9CE:  MOVLW  01
0E9D0:  MOVLB  A
0E9D2:  MOVWF  x19
0E9D4:  MOVLB  0
0E9D6:  CALL   0F88
0E9DA:  BTFSC  1B.7
0E9DC:  BSF    FF2.7
0E9DE:  MOVLW  20
0E9E0:  BTFSS  F9E.4
0E9E2:  BRA    E9E0
0E9E4:  MOVWF  FAD
0E9E6:  CLRF   1B
0E9E8:  BTFSC  FF2.7
0E9EA:  BSF    1B.7
0E9EC:  BCF    FF2.7
0E9EE:  MOVFF  739,A18
0E9F2:  MOVLW  01
0E9F4:  MOVLB  A
0E9F6:  MOVWF  x19
0E9F8:  MOVLB  0
0E9FA:  CALL   0F88
0E9FE:  BTFSC  1B.7
0EA00:  BSF    FF2.7
0EA02:  MOVLW  3A
0EA04:  BTFSS  F9E.4
0EA06:  BRA    EA04
0EA08:  MOVWF  FAD
0EA0A:  CLRF   1B
0EA0C:  BTFSC  FF2.7
0EA0E:  BSF    1B.7
0EA10:  BCF    FF2.7
0EA12:  MOVFF  73A,A18
0EA16:  MOVLW  01
0EA18:  MOVLB  A
0EA1A:  MOVWF  x19
0EA1C:  MOVLB  0
0EA1E:  CALL   0F88
0EA22:  BTFSC  1B.7
0EA24:  BSF    FF2.7
0EA26:  MOVLW  3A
0EA28:  BTFSS  F9E.4
0EA2A:  BRA    EA28
0EA2C:  MOVWF  FAD
0EA2E:  CLRF   1B
0EA30:  BTFSC  FF2.7
0EA32:  BSF    1B.7
0EA34:  BCF    FF2.7
0EA36:  MOVFF  73B,A18
0EA3A:  MOVLW  01
0EA3C:  MOVLB  A
0EA3E:  MOVWF  x19
0EA40:  MOVLB  0
0EA42:  CALL   0F88
0EA46:  BTFSC  1B.7
0EA48:  BSF    FF2.7
0EA4A:  MOVLW  0D
0EA4C:  BTFSS  F9E.4
0EA4E:  BRA    EA4C
0EA50:  MOVWF  FAD
0EA52:  MOVLW  0A
0EA54:  BTFSS  F9E.4
0EA56:  BRA    EA54
0EA58:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EA5A:  CALL   E114
....................       RTC_display_alarm(); 
0EA5E:  CALL   E1EA
....................    } 
0EA62:  GOTO   EF98 (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0ECF0:  DECFSZ 44,W
0ECF2:  BRA    EF58
0ECF4:  MOVF   45,F
0ECF6:  BTFSS  FD8.2
0ECF8:  BRA    EF58
0ECFA:  MOVF   46,F
0ECFC:  BTFSS  FD8.2
0ECFE:  BRA    EF58
0ED00:  MOVF   47,F
0ED02:  BTFSS  FD8.2
0ED04:  BRA    EF58
....................       v_supply = read_supply(); 
0ED06:  CALL   507A
0ED0A:  MOVFF  02,862
0ED0E:  MOVFF  01,861
....................        
....................       RTC_reset_HT(); 
0ED12:  CALL   3430
....................       RTC_read(); 
0ED16:  CALL   32C2
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0ED1A:  MOVLW  49
0ED1C:  BTFSS  F9E.4
0ED1E:  BRA    ED1C
0ED20:  MOVWF  FAD
0ED22:  MOVLW  10
0ED24:  MOVWF  FE9
0ED26:  CLRF   1B
0ED28:  BTFSC  FF2.7
0ED2A:  BSF    1B.7
0ED2C:  BCF    FF2.7
0ED2E:  MOVFF  24,A19
0ED32:  MOVFF  23,A18
0ED36:  CALL   1188
0ED3A:  BTFSC  1B.7
0ED3C:  BSF    FF2.7
0ED3E:  MOVLW  20
0ED40:  BTFSS  F9E.4
0ED42:  BRA    ED40
0ED44:  MOVWF  FAD
0ED46:  MOVLW  4E
0ED48:  BTFSS  F9E.4
0ED4A:  BRA    ED48
0ED4C:  MOVWF  FAD
0ED4E:  MOVLW  10
0ED50:  MOVWF  FE9
0ED52:  CLRF   1B
0ED54:  BTFSC  FF2.7
0ED56:  BSF    1B.7
0ED58:  BCF    FF2.7
0ED5A:  MOVFF  22,A19
0ED5E:  MOVFF  21,A18
0ED62:  CALL   1188
0ED66:  BTFSC  1B.7
0ED68:  BSF    FF2.7
0ED6A:  MOVLW  2F
0ED6C:  BTFSS  F9E.4
0ED6E:  BRA    ED6C
0ED70:  MOVWF  FAD
0ED72:  MOVLW  10
0ED74:  MOVWF  FE9
0ED76:  CLRF   1B
0ED78:  BTFSC  FF2.7
0ED7A:  BSF    1B.7
0ED7C:  BCF    FF2.7
0ED7E:  MOVFF  28,A19
0ED82:  MOVFF  27,A18
0ED86:  CALL   1188
0ED8A:  BTFSC  1B.7
0ED8C:  BSF    FF2.7
0ED8E:  MOVLW  20
0ED90:  BTFSS  F9E.4
0ED92:  BRA    ED90
0ED94:  MOVWF  FAD
0ED96:  MOVLW  50
0ED98:  BTFSS  F9E.4
0ED9A:  BRA    ED98
0ED9C:  MOVWF  FAD
0ED9E:  MOVLW  10
0EDA0:  MOVWF  FE9
0EDA2:  CLRF   1B
0EDA4:  BTFSC  FF2.7
0EDA6:  BSF    1B.7
0EDA8:  BCF    FF2.7
0EDAA:  MOVFF  2E,A19
0EDAE:  MOVFF  2D,A18
0EDB2:  CALL   1188
0EDB6:  BTFSC  1B.7
0EDB8:  BSF    FF2.7
0EDBA:  MOVLW  20
0EDBC:  BTFSS  F9E.4
0EDBE:  BRA    EDBC
0EDC0:  MOVWF  FAD
0EDC2:  MOVLW  04
0EDC4:  MOVWF  FE9
0EDC6:  MOVLB  8
0EDC8:  CLRF   x66
0EDCA:  CLRF   x65
0EDCC:  MOVFF  862,864
0EDD0:  MOVFF  861,863
0EDD4:  MOVLW  02
0EDD6:  MOVWF  x67
0EDD8:  MOVLB  0
0EDDA:  CALL   DE8E
0EDDE:  MOVLW  62
0EDE0:  MOVWF  FF6
0EDE2:  MOVLW  26
0EDE4:  MOVWF  FF7
0EDE6:  MOVLW  00
0EDE8:  MOVWF  FF8
0EDEA:  CLRF   1B
0EDEC:  BTFSC  FF2.7
0EDEE:  BSF    1B.7
0EDF0:  BCF    FF2.7
0EDF2:  MOVLW  03
0EDF4:  MOVLB  A
0EDF6:  MOVWF  x18
0EDF8:  MOVLB  0
0EDFA:  CALL   1006
0EDFE:  BTFSC  1B.7
0EE00:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0EE02:  MOVLW  66
0EE04:  MOVWF  FF6
0EE06:  MOVLW  26
0EE08:  MOVWF  FF7
0EE0A:  MOVLW  00
0EE0C:  MOVWF  FF8
0EE0E:  CLRF   1B
0EE10:  BTFSC  FF2.7
0EE12:  BSF    1B.7
0EE14:  BCF    FF2.7
0EE16:  MOVLW  09
0EE18:  MOVLB  A
0EE1A:  MOVWF  x18
0EE1C:  MOVLB  0
0EE1E:  CALL   1006
0EE22:  BTFSC  1B.7
0EE24:  BSF    FF2.7
0EE26:  MOVLW  10
0EE28:  MOVWF  FE9
0EE2A:  MOVFF  7B2,8CD
0EE2E:  MOVFF  7B1,8CC
0EE32:  CALL   8F2E
0EE36:  MOVLW  0D
0EE38:  BTFSS  F9E.4
0EE3A:  BRA    EE38
0EE3C:  MOVWF  FAD
0EE3E:  MOVLW  0A
0EE40:  BTFSS  F9E.4
0EE42:  BRA    EE40
0EE44:  MOVWF  FAD
....................       display_valve_status(); 
0EE46:  RCALL  EA66
....................       RTC_display(); 
0EE48:  CALL   DF8A
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EE4C:  MOVLW  76
0EE4E:  MOVWF  FF6
0EE50:  MOVLW  26
0EE52:  MOVWF  FF7
0EE54:  MOVLW  00
0EE56:  MOVWF  FF8
0EE58:  CLRF   1B
0EE5A:  BTFSC  FF2.7
0EE5C:  BSF    1B.7
0EE5E:  BCF    FF2.7
0EE60:  MOVLW  05
0EE62:  MOVLB  A
0EE64:  MOVWF  x18
0EE66:  MOVLB  0
0EE68:  CALL   1006
0EE6C:  BTFSC  1B.7
0EE6E:  BSF    FF2.7
0EE70:  CLRF   1B
0EE72:  BTFSC  FF2.7
0EE74:  BSF    1B.7
0EE76:  BCF    FF2.7
0EE78:  MOVFF  736,A18
0EE7C:  MOVLW  01
0EE7E:  MOVLB  A
0EE80:  MOVWF  x19
0EE82:  MOVLB  0
0EE84:  CALL   0F88
0EE88:  BTFSC  1B.7
0EE8A:  BSF    FF2.7
0EE8C:  MOVLW  2F
0EE8E:  BTFSS  F9E.4
0EE90:  BRA    EE8E
0EE92:  MOVWF  FAD
0EE94:  CLRF   1B
0EE96:  BTFSC  FF2.7
0EE98:  BSF    1B.7
0EE9A:  BCF    FF2.7
0EE9C:  MOVFF  737,A18
0EEA0:  MOVLW  01
0EEA2:  MOVLB  A
0EEA4:  MOVWF  x19
0EEA6:  MOVLB  0
0EEA8:  CALL   0F88
0EEAC:  BTFSC  1B.7
0EEAE:  BSF    FF2.7
0EEB0:  MOVLW  2F
0EEB2:  BTFSS  F9E.4
0EEB4:  BRA    EEB2
0EEB6:  MOVWF  FAD
0EEB8:  CLRF   1B
0EEBA:  BTFSC  FF2.7
0EEBC:  BSF    1B.7
0EEBE:  BCF    FF2.7
0EEC0:  MOVFF  738,A18
0EEC4:  MOVLW  01
0EEC6:  MOVLB  A
0EEC8:  MOVWF  x19
0EECA:  MOVLB  0
0EECC:  CALL   0F88
0EED0:  BTFSC  1B.7
0EED2:  BSF    FF2.7
0EED4:  MOVLW  20
0EED6:  BTFSS  F9E.4
0EED8:  BRA    EED6
0EEDA:  MOVWF  FAD
0EEDC:  CLRF   1B
0EEDE:  BTFSC  FF2.7
0EEE0:  BSF    1B.7
0EEE2:  BCF    FF2.7
0EEE4:  MOVFF  739,A18
0EEE8:  MOVLW  01
0EEEA:  MOVLB  A
0EEEC:  MOVWF  x19
0EEEE:  MOVLB  0
0EEF0:  CALL   0F88
0EEF4:  BTFSC  1B.7
0EEF6:  BSF    FF2.7
0EEF8:  MOVLW  3A
0EEFA:  BTFSS  F9E.4
0EEFC:  BRA    EEFA
0EEFE:  MOVWF  FAD
0EF00:  CLRF   1B
0EF02:  BTFSC  FF2.7
0EF04:  BSF    1B.7
0EF06:  BCF    FF2.7
0EF08:  MOVFF  73A,A18
0EF0C:  MOVLW  01
0EF0E:  MOVLB  A
0EF10:  MOVWF  x19
0EF12:  MOVLB  0
0EF14:  CALL   0F88
0EF18:  BTFSC  1B.7
0EF1A:  BSF    FF2.7
0EF1C:  MOVLW  3A
0EF1E:  BTFSS  F9E.4
0EF20:  BRA    EF1E
0EF22:  MOVWF  FAD
0EF24:  CLRF   1B
0EF26:  BTFSC  FF2.7
0EF28:  BSF    1B.7
0EF2A:  BCF    FF2.7
0EF2C:  MOVFF  73B,A18
0EF30:  MOVLW  01
0EF32:  MOVLB  A
0EF34:  MOVWF  x19
0EF36:  MOVLB  0
0EF38:  CALL   0F88
0EF3C:  BTFSC  1B.7
0EF3E:  BSF    FF2.7
0EF40:  MOVLW  0D
0EF42:  BTFSS  F9E.4
0EF44:  BRA    EF42
0EF46:  MOVWF  FAD
0EF48:  MOVLW  0A
0EF4A:  BTFSS  F9E.4
0EF4C:  BRA    EF4A
0EF4E:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EF50:  CALL   E114
....................       RTC_display_alarm(); 
0EF54:  CALL   E1EA
....................    } 
0EF58:  GOTO   EF98 (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0EF5C:  MOVF   2F,W
0EF5E:  MOVWF  00
0EF60:  MOVF   30,W
0EF62:  MOVWF  03
0EF64:  BNZ   EF6A
0EF66:  MOVF   00,F
0EF68:  BZ    EF8A
0EF6A:  MOVF   03,W
0EF6C:  BNZ   EF74
0EF6E:  MOVLW  01
0EF70:  SUBWF  00,W
0EF72:  BZ    EF90
0EF74:  MOVF   03,W
0EF76:  BNZ   EF7E
0EF78:  MOVLW  03
0EF7A:  SUBWF  00,W
0EF7C:  BZ    EF90
0EF7E:  MOVF   03,W
0EF80:  BNZ   EF88
0EF82:  MOVLW  02
0EF84:  SUBWF  00,W
0EF86:  BZ    EF96
0EF88:  BRA    EF98
....................       case ECO : commandHe(); 
0EF8A:  GOTO   E364
....................          break; 
0EF8E:  BRA    EF98
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0EF90:  GOTO   E788
....................          break; 
0EF94:  BRA    EF98
....................       case AWS : commandHa(); 
0EF96:  BRA    ECF0
....................          break;          
....................    } 
0EF98:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0EF9C:  MOVF   44,F
0EF9E:  BNZ   EFAC
0EFA0:  MOVF   45,F
0EFA2:  BNZ   EFAC
0EFA4:  MOVF   46,F
0EFA6:  BNZ   EFAC
0EFA8:  MOVF   47,F
0EFAA:  BZ    EFE0
0EFAC:  MOVF   47,F
0EFAE:  BNZ   EFE0
0EFB0:  MOVF   46,F
0EFB2:  BNZ   EFE0
0EFB4:  MOVF   45,W
0EFB6:  SUBLW  FD
0EFB8:  BNC   EFE0
0EFBA:  BNZ   EFC2
0EFBC:  MOVF   44,W
0EFBE:  SUBLW  20
0EFC0:  BNC   EFE0
....................       nv_interval = arg; 
0EFC2:  MOVFF  45,24
0EFC6:  MOVFF  44,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0EFCA:  MOVLW  14
0EFCC:  MOVLB  8
0EFCE:  MOVWF  xCA
0EFD0:  MOVFF  24,8CC
0EFD4:  MOVFF  23,8CB
0EFD8:  MOVLB  0
0EFDA:  CALL   4F52
....................    } 
0EFDE:  BRA    EFE4
....................    else cmd_arg(); 
0EFE0:  CALL   AF7A
0EFE4:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0EFE8:  MOVF   47,F
0EFEA:  BNZ   F01A
0EFEC:  MOVF   46,F
0EFEE:  BNZ   F01A
0EFF0:  MOVF   45,W
0EFF2:  SUBLW  27
0EFF4:  BNC   F01A
0EFF6:  BNZ   EFFE
0EFF8:  MOVF   44,W
0EFFA:  SUBLW  0F
0EFFC:  BNC   F01A
....................       nv_serial = arg; 
0EFFE:  MOVFF  45,26
0F002:  MOVFF  44,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0F006:  MOVLB  8
0F008:  CLRF   xCA
0F00A:  MOVFF  26,8CC
0F00E:  MOVFF  25,8CB
0F012:  MOVLB  0
0F014:  CALL   4F52
....................    } 
0F018:  BRA    F01E
....................    else cmd_arg(); 
0F01A:  CALL   AF7A
0F01E:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F242:  MOVF   2F,F
0F244:  BNZ   F274
0F246:  MOVF   30,F
0F248:  BNZ   F274
....................        
....................       if (arg > 0 && arg < 3){ 
0F24A:  MOVF   44,F
0F24C:  BNZ   F25A
0F24E:  MOVF   45,F
0F250:  BNZ   F25A
0F252:  MOVF   46,F
0F254:  BNZ   F25A
0F256:  MOVF   47,F
0F258:  BZ    F270
0F25A:  MOVF   47,F
0F25C:  BNZ   F270
0F25E:  MOVF   46,F
0F260:  BNZ   F270
0F262:  MOVF   45,F
0F264:  BNZ   F270
0F266:  MOVF   44,W
0F268:  SUBLW  02
0F26A:  BNC   F270
....................          det_cmd(); 
0F26C:  RCALL  F102
....................       } 
0F26E:  BRA    F274
....................       else cmd_arg(); 
0F270:  CALL   AF7A
....................        
....................    } 
0F274:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
100C8:  MOVF   47,F
100CA:  BNZ   10136
100CC:  MOVF   46,F
100CE:  BNZ   10136
100D0:  MOVF   45,W
100D2:  SUBLW  0F
100D4:  BNC   10136
....................       switch (nv_det_type){ 
100D6:  MOVFF  41,00
100DA:  MOVF   42,W
100DC:  MOVWF  03
100DE:  BNZ   100E6
100E0:  MOVLW  01
100E2:  SUBWF  00,W
100E4:  BZ    100FC
100E6:  MOVF   03,W
100E8:  BNZ   100F0
100EA:  MOVLW  02
100EC:  SUBWF  00,W
100EE:  BZ    10102
100F0:  MOVF   03,W
100F2:  BNZ   100FA
100F4:  MOVLW  03
100F6:  SUBWF  00,W
100F8:  BZ    10120
100FA:  BRA    10134
....................          case 1 : det_cmd(); 
100FC:  CALL   F102
....................             break; 
10100:  BRA    10134
....................          case 2 : DAC_set(1,arg); 
10102:  MOVFF  45,862
10106:  MOVFF  44,861
1010A:  MOVLW  01
1010C:  MOVLB  8
1010E:  MOVWF  xAF
10110:  MOVFF  862,8B1
10114:  MOVFF  861,8B0
10118:  MOVLB  0
1011A:  CALL   F278
....................             break; 
1011E:  BRA    10134
....................          case 3 : set_LED(arg); 
10120:  MOVFF  45,862
10124:  MOVFF  44,861
10128:  MOVFF  862,8A2
1012C:  MOVFF  861,8A1
10130:  CALL   F5B8
....................             break; 
....................       } 
....................    } 
10134:  BRA    10194
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
10136:  MOVF   47,F
10138:  BNZ   1014E
1013A:  MOVF   46,F
1013C:  BNZ   1014E
1013E:  MOVF   45,W
10140:  SUBLW  4D
10142:  BC    10178
10144:  XORLW  FF
10146:  BNZ   1014E
10148:  MOVF   44,W
1014A:  SUBLW  20
1014C:  BC    10178
1014E:  MOVF   47,F
10150:  BNZ   10178
10152:  MOVF   46,F
10154:  BNZ   10178
10156:  MOVF   45,W
10158:  SUBLW  4E
1015A:  BNC   10178
1015C:  BNZ   10164
1015E:  MOVF   44,W
10160:  SUBLW  22
10162:  BNC   10178
10164:  MOVFF  45,862
10168:  MOVFF  44,861
1016C:  MOVFF  862,864
10170:  MOVFF  861,863
10174:  BRA    10000
10176:  BRA    10194
....................    else if(arg==30001)set_LED_test(); 
10178:  MOVF   44,W
1017A:  SUBLW  31
1017C:  BNZ   10190
1017E:  MOVF   45,W
10180:  SUBLW  75
10182:  BNZ   10190
10184:  MOVF   46,F
10186:  BNZ   10190
10188:  MOVF   47,F
1018A:  BNZ   10190
1018C:  BRA    FF58
1018E:  BRA    10194
....................    else cmd_arg(); 
10190:  CALL   AF7A
10194:  GOTO   101FE (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
10198:  MOVF   47,F
1019A:  BNZ   101CC
1019C:  MOVF   46,F
1019E:  BNZ   101CC
101A0:  MOVF   45,W
101A2:  SUBLW  57
101A4:  BNC   101CC
101A6:  BNZ   101AE
101A8:  MOVF   44,W
101AA:  SUBLW  E4
101AC:  BNC   101CC
....................       nv_volume = arg; 
101AE:  MOVFF  45,2C
101B2:  MOVFF  44,2B
....................       write16(ADDR_VOLUME, nv_volume); 
101B6:  MOVLW  22
101B8:  MOVLB  8
101BA:  MOVWF  xCA
101BC:  MOVFF  2C,8CC
101C0:  MOVFF  2B,8CB
101C4:  MOVLB  0
101C6:  CALL   4F52
....................    } 
101CA:  BRA    101D0
....................    else cmd_arg(); 
101CC:  CALL   AF7A
101D0:  GOTO   101FE (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
101D4:  MOVF   2F,W
101D6:  MOVWF  00
101D8:  MOVF   30,W
101DA:  MOVWF  03
101DC:  BNZ   101E2
101DE:  MOVF   00,F
101E0:  BZ    101F8
101E2:  MOVF   03,W
101E4:  BNZ   101EC
101E6:  MOVLW  01
101E8:  SUBWF  00,W
101EA:  BZ    101FC
101EC:  MOVF   03,W
101EE:  BNZ   101F6
101F0:  MOVLW  03
101F2:  SUBWF  00,W
101F4:  BZ    101FC
101F6:  BRA    101FE
....................       case ECO : commandLe(); 
101F8:  BRA    100C8
....................          break; 
101FA:  BRA    101FE
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
101FC:  BRA    10198
....................          break; 
....................    } 
101FE:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
1689E:  CALL   293E
....................     
....................    user_quit = FALSE; 
168A2:  CLRF   4C
....................     
....................    if(arg > 0 && arg < 21) 
168A4:  MOVF   44,F
168A6:  BNZ   168B4
168A8:  MOVF   45,F
168AA:  BNZ   168B4
168AC:  MOVF   46,F
168AE:  BNZ   168B4
168B0:  MOVF   47,F
168B2:  BZ    16930
168B4:  MOVF   47,F
168B6:  BNZ   16930
168B8:  MOVF   46,F
168BA:  BNZ   16930
168BC:  MOVF   45,F
168BE:  BNZ   16930
168C0:  MOVF   44,W
168C2:  SUBLW  14
168C4:  BNC   16930
....................    { 
....................       macro = arg; 
168C6:  MOVFF  44,862
....................       switch(nv_product){ 
168CA:  MOVFF  2F,00
168CE:  MOVF   30,W
168D0:  MOVWF  03
168D2:  BNZ   168D8
168D4:  MOVF   00,F
168D6:  BZ    168F8
168D8:  MOVF   03,W
168DA:  BNZ   168E2
168DC:  MOVLW  01
168DE:  SUBWF  00,W
168E0:  BZ    168F8
168E2:  MOVF   03,W
168E4:  BNZ   168EC
168E6:  MOVLW  03
168E8:  SUBWF  00,W
168EA:  BZ    168F8
168EC:  MOVF   03,W
168EE:  BNZ   168F6
168F0:  MOVLW  02
168F2:  SUBWF  00,W
168F4:  BZ    1691E
168F6:  BRA    1692E
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
168F8:  MOVLW  01
168FA:  MOVLB  7
168FC:  ADDWF  xBF,W
168FE:  MOVLB  8
16900:  MOVWF  x63
16902:  MOVLW  00
16904:  MOVLB  7
16906:  ADDWFC xC0,W
16908:  MOVLB  8
1690A:  MOVWF  x64
1690C:  MOVFF  862,873
16910:  MOVWF  x75
16912:  MOVFF  863,874
16916:  MOVLB  0
16918:  CALL   14F00
....................             break; 
1691C:  BRA    1692E
....................          case AWS : play_macro(macro,nv_port); 
1691E:  MOVFF  862,873
16922:  MOVFF  2E,875
16926:  MOVFF  2D,874
1692A:  CALL   14F00
....................             break; 
....................       } 
....................    }    
1692E:  BRA    16998
....................    else if (arg == 0) 
16930:  MOVF   44,F
16932:  BNZ   16994
16934:  MOVF   45,F
16936:  BNZ   16994
16938:  MOVF   46,F
1693A:  BNZ   16994
1693C:  MOVF   47,F
1693E:  BNZ   16994
....................    { 
....................       MaxSamples=FALSE; 
16940:  CLRF   34
16942:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
16944:  MOVLW  28
16946:  MOVLB  8
16948:  MOVWF  x65
1694A:  MOVFF  33,866
1694E:  MOVLB  0
16950:  CALL   3390
....................       if (LoggingReentry != TRUE) 
16954:  MOVLB  8
16956:  DECFSZ x61,W
16958:  BRA    1695C
1695A:  BRA    16974
....................       { 
....................          nv_sample = 0; 
1695C:  CLRF   22
1695E:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
16960:  MOVLW  16
16962:  MOVWF  xCA
16964:  MOVFF  22,8CC
16968:  MOVFF  21,8CB
1696C:  MOVLB  0
1696E:  CALL   4F52
16972:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
16974:  CLRF   x61
....................       nv_macro_step = 0; 
16976:  CLRF   38
16978:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
1697A:  MOVLW  3A
1697C:  MOVWF  xCA
1697E:  MOVFF  38,8CC
16982:  MOVFF  37,8CB
16986:  MOVLB  0
16988:  CALL   4F52
....................       user_quit = auto_sample_ready(); 
1698C:  BRA    1669C
1698E:  MOVFF  01,4C
....................    } 
16992:  BRA    16998
....................    else cmd_arg(); 
16994:  CALL   AF7A
....................     
....................    busy_clear(); 
16998:  CALL   ADB6
1699C:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
1699E:  MOVF   44,F
169A0:  BNZ   169AE
169A2:  MOVF   45,F
169A4:  BNZ   169AE
169A6:  MOVF   46,F
169A8:  BNZ   169AE
169AA:  MOVF   47,F
169AC:  BZ    169E2
169AE:  MOVF   47,F
169B0:  BNZ   169E2
169B2:  MOVF   46,F
169B4:  BNZ   169E2
169B6:  MOVF   45,W
169B8:  SUBLW  0D
169BA:  BNC   169E2
169BC:  BNZ   169C4
169BE:  MOVF   44,W
169C0:  SUBLW  AC
169C2:  BNC   169E2
....................       nv_max_samples = arg; 
169C4:  MOVFF  45,28
169C8:  MOVFF  44,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
169CC:  MOVLW  18
169CE:  MOVLB  8
169D0:  MOVWF  xCA
169D2:  MOVFF  28,8CC
169D6:  MOVFF  27,8CB
169DA:  MOVLB  0
169DC:  CALL   4F52
....................    } 
169E0:  BRA    16A28
....................    else if(arg == 0) { 
169E2:  MOVF   44,F
169E4:  BNZ   16A24
169E6:  MOVF   45,F
169E8:  BNZ   16A24
169EA:  MOVF   46,F
169EC:  BNZ   16A24
169EE:  MOVF   47,F
169F0:  BNZ   16A24
....................       nv_sample = 0; 
169F2:  CLRF   22
169F4:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
169F6:  MOVLW  16
169F8:  MOVLB  8
169FA:  MOVWF  xCA
169FC:  MOVFF  22,8CC
16A00:  MOVFF  21,8CB
16A04:  MOVLB  0
16A06:  CALL   4F52
....................       nv_macro_step = 0; 
16A0A:  CLRF   38
16A0C:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16A0E:  MOVLW  3A
16A10:  MOVLB  8
16A12:  MOVWF  xCA
16A14:  MOVFF  38,8CC
16A18:  MOVFF  37,8CB
16A1C:  MOVLB  0
16A1E:  CALL   4F52
....................    } 
16A22:  BRA    16A28
....................    else cmd_arg(); 
16A24:  CALL   AF7A
16A28:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
16B46:  DECFSZ 44,W
16B48:  BRA    16B62
16B4A:  MOVF   45,F
16B4C:  BNZ   16B62
16B4E:  MOVF   46,F
16B50:  BNZ   16B62
16B52:  MOVF   47,F
16B54:  BNZ   16B62
....................    { 
....................       bus_on(); 
16B56:  CALL   D074
....................       open_pipe(); 
16B5A:  BRA    16A3A
....................       bus_off(); 
16B5C:  CALL   D098
....................    } 
16B60:  BRA    16B66
....................    else cmd_arg(); 
16B62:  CALL   AF7A
16B66:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
16C24:  MOVLB  7
16C26:  DECFSZ x3D,W
16C28:  BRA    16C2C
16C2A:  CLRF   x3C
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
16C2C:  MOVF   44,F
16C2E:  BNZ   16C3E
16C30:  MOVF   45,F
16C32:  BNZ   16C3E
16C34:  MOVF   46,F
16C36:  BNZ   16C3E
16C38:  MOVF   47,F
16C3A:  BTFSC  FD8.2
16C3C:  BRA    16D06
16C3E:  BCF    FD8.0
16C40:  RLCF   x3C,W
16C42:  CLRF   03
16C44:  ADDLW  5E
16C46:  MOVWF  FE9
16C48:  MOVLW  07
16C4A:  ADDWFC 03,W
16C4C:  MOVWF  FEA
16C4E:  MOVFF  FEC,03
16C52:  MOVF   FED,F
16C54:  MOVFF  FEF,01
16C58:  MOVF   47,F
16C5A:  BNZ   16D06
16C5C:  MOVF   46,F
16C5E:  BNZ   16D06
16C60:  MOVF   45,W
16C62:  SUBWF  03,W
16C64:  BNC   16D06
16C66:  BNZ   16C6E
16C68:  MOVF   44,W
16C6A:  SUBWF  01,W
16C6C:  BNC   16D06
....................       if(e_mode[motor]==2){     // if port mode then move 
16C6E:  BCF    FD8.0
16C70:  RLCF   x3C,W
16C72:  CLRF   03
16C74:  ADDLW  62
16C76:  MOVWF  FE9
16C78:  MOVLW  07
16C7A:  ADDWFC 03,W
16C7C:  MOVWF  FEA
16C7E:  MOVFF  FEC,862
16C82:  MOVF   FED,F
16C84:  MOVFF  FEF,861
16C88:  MOVLB  8
16C8A:  MOVF   x61,W
16C8C:  SUBLW  02
16C8E:  BNZ   16CFC
16C90:  MOVF   x62,F
16C92:  BNZ   16CFC
....................          switch (nv_product){ 
16C94:  MOVF   2F,W
16C96:  MOVWF  00
16C98:  MOVF   30,W
16C9A:  MOVWF  03
16C9C:  MOVF   03,W
16C9E:  BNZ   16CA8
16CA0:  MOVF   00,F
16CA2:  MOVLB  0
16CA4:  BZ    16CC6
16CA6:  MOVLB  8
16CA8:  MOVF   03,W
16CAA:  BNZ   16CB6
16CAC:  MOVLW  01
16CAE:  SUBWF  00,W
16CB0:  MOVLB  0
16CB2:  BZ    16CD8
16CB4:  MOVLB  8
16CB6:  MOVF   03,W
16CB8:  BNZ   16CC4
16CBA:  MOVLW  03
16CBC:  SUBWF  00,W
16CBE:  MOVLB  0
16CC0:  BZ    16CEA
16CC2:  MOVLB  8
16CC4:  BRA    16CFA
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
16CC6:  MOVLW  01
16CC8:  MOVLB  8
16CCA:  MOVWF  x61
16CCC:  CLRF   x62
16CCE:  MOVWF  x63
16CD0:  MOVLB  0
16CD2:  RCALL  16B6A
....................                break;             
16CD4:  MOVLB  8
16CD6:  BRA    16CFA
....................             case WMS4: command_move(0,0,1); 
16CD8:  MOVLB  8
16CDA:  CLRF   x61
16CDC:  CLRF   x62
16CDE:  MOVLW  01
16CE0:  MOVWF  x63
16CE2:  MOVLB  0
16CE4:  RCALL  16B6A
....................                break; 
16CE6:  MOVLB  8
16CE8:  BRA    16CFA
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
16CEA:  MOVLB  8
16CEC:  CLRF   x61
16CEE:  CLRF   x62
16CF0:  MOVLW  01
16CF2:  MOVWF  x63
16CF4:  MOVLB  0
16CF6:  RCALL  16B6A
....................                break; 
16CF8:  MOVLB  8
....................          } 
....................       } 
16CFA:  BRA    16D04
....................       else cmd_err();                           // else error 
16CFC:  MOVLB  0
16CFE:  CALL   BC3C
16D02:  MOVLB  8
....................    } 
16D04:  BRA    16D0E
....................    else cmd_arg(); 
16D06:  MOVLB  0
16D08:  CALL   AF7A
16D0C:  MOVLB  8
16D0E:  MOVLB  0
16D10:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
16D12:  MOVF   47,F
16D14:  BNZ   16D42
16D16:  MOVF   46,F
16D18:  BNZ   16D42
16D1A:  MOVF   45,F
16D1C:  BNZ   16D42
16D1E:  MOVF   44,W
16D20:  SUBLW  30
16D22:  BNC   16D42
....................       nv_port = arg; 
16D24:  MOVFF  45,2E
16D28:  MOVFF  44,2D
....................       write16(ADDR_PORT, nv_port); 
16D2C:  MOVLW  24
16D2E:  MOVLB  8
16D30:  MOVWF  xCA
16D32:  MOVFF  2E,8CC
16D36:  MOVFF  2D,8CB
16D3A:  MOVLB  0
16D3C:  CALL   4F52
....................    } 
16D40:  BRA    16D46
....................    else cmd_arg(); 
16D42:  CALL   AF7A
16D46:  GOTO   16D82 (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
16D4A:  MOVF   2F,W
16D4C:  MOVWF  00
16D4E:  MOVF   30,W
16D50:  MOVWF  03
16D52:  BNZ   16D58
16D54:  MOVF   00,F
16D56:  BZ    16D78
16D58:  MOVF   03,W
16D5A:  BNZ   16D62
16D5C:  MOVLW  01
16D5E:  SUBWF  00,W
16D60:  BZ    16D7C
16D62:  MOVF   03,W
16D64:  BNZ   16D6C
16D66:  MOVLW  03
16D68:  SUBWF  00,W
16D6A:  BZ    16D7C
16D6C:  MOVF   03,W
16D6E:  BNZ   16D76
16D70:  MOVLW  02
16D72:  SUBWF  00,W
16D74:  BZ    16D80
16D76:  BRA    16D82
....................       case ECO : commandPe(); 
16D78:  RCALL  16C24
....................          break; 
16D7A:  BRA    16D82
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
16D7C:  RCALL  16C24
....................          break; 
16D7E:  BRA    16D82
....................       case AWS : commandPa(); 
16D80:  BRA    16D12
....................          break;          
....................    } 
16D82:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
16DCE:  MOVLB  4
16DD0:  DECFSZ xB2,W
16DD2:  BRA    16DFE
....................     
....................       if(arg<33){ 
16DD4:  MOVF   47,F
16DD6:  BNZ   16DF6
16DD8:  MOVF   46,F
16DDA:  BNZ   16DF6
16DDC:  MOVF   45,F
16DDE:  BNZ   16DF6
16DE0:  MOVF   44,W
16DE2:  SUBLW  20
16DE4:  BNC   16DF6
....................          valve=arg;    
16DE6:  MOVFF  44,861
....................          sol_switch(valve); 
16DEA:  MOVFF  861,891
16DEE:  MOVLB  0
16DF0:  CALL   140CA
....................       }  
16DF4:  BRA    16DFC
....................       else cmd_arg(); 
16DF6:  MOVLB  0
16DF8:  CALL   AF7A
....................    } 
16DFC:  BRA    16E04
....................    else cmd_err(); 
16DFE:  MOVLB  0
16E00:  CALL   BC3C
16E04:  GOTO   16E34 (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
16D86:  MOVF   44,F
16D88:  BNZ   16D96
16D8A:  MOVF   45,F
16D8C:  BNZ   16D96
16D8E:  MOVF   46,F
16D90:  BNZ   16D96
16D92:  MOVF   47,F
16D94:  BZ    16DC6
16D96:  MOVF   47,F
16D98:  BNZ   16DC6
16D9A:  MOVF   46,F
16D9C:  BNZ   16DC6
16D9E:  MOVF   45,F
16DA0:  BNZ   16DC6
16DA2:  MOVF   44,W
16DA4:  SUBLW  32
16DA6:  BNC   16DC6
....................       nv_port = arg; 
16DA8:  MOVFF  45,2E
16DAC:  MOVFF  44,2D
....................       write16(ADDR_SAMPLE, nv_port); 
16DB0:  MOVLW  16
16DB2:  MOVLB  8
16DB4:  MOVWF  xCA
16DB6:  MOVFF  2E,8CC
16DBA:  MOVFF  2D,8CB
16DBE:  MOVLB  0
16DC0:  CALL   4F52
....................    } 
16DC4:  BRA    16DCA
....................    else cmd_arg(); 
16DC6:  CALL   AF7A
16DCA:  GOTO   16E34 (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
16E08:  MOVF   2F,W
16E0A:  MOVWF  00
16E0C:  MOVF   30,W
16E0E:  MOVWF  03
16E10:  BNZ   16E18
16E12:  MOVLW  01
16E14:  SUBWF  00,W
16E16:  BZ    16E2E
16E18:  MOVF   03,W
16E1A:  BNZ   16E22
16E1C:  MOVLW  03
16E1E:  SUBWF  00,W
16E20:  BZ    16E2E
16E22:  MOVF   03,W
16E24:  BNZ   16E2C
16E26:  MOVLW  02
16E28:  SUBWF  00,W
16E2A:  BZ    16E32
16E2C:  BRA    16E34
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
16E2E:  BRA    16D86
....................          break; 
16E30:  BRA    16E34
....................       case AWS : commandQa(); 
16E32:  BRA    16DCE
....................          break;          
....................    } 
16E34:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
16E38:  CALL   293E
....................     
....................    nv_macro_step = 0; 
16E3C:  CLRF   38
16E3E:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
16E40:  MOVLW  3A
16E42:  MOVLB  8
16E44:  MOVWF  xCA
16E46:  MOVFF  38,8CC
16E4A:  MOVFF  37,8CB
16E4E:  MOVLB  0
16E50:  CALL   4F52
....................     
....................    user_quit = FALSE; 
16E54:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 3501){ 
16E56:  MOVF   44,F
16E58:  BNZ   16E66
16E5A:  MOVF   45,F
16E5C:  BNZ   16E66
16E5E:  MOVF   46,F
16E60:  BNZ   16E66
16E62:  MOVF   47,F
16E64:  BZ    16F12
16E66:  MOVF   47,F
16E68:  BNZ   16F12
16E6A:  MOVF   46,F
16E6C:  BNZ   16F12
16E6E:  MOVF   45,W
16E70:  SUBLW  0D
16E72:  BNC   16F12
16E74:  BNZ   16E7C
16E76:  MOVF   44,W
16E78:  SUBLW  AC
16E7A:  BNC   16F12
....................       samples = arg; 
16E7C:  MOVFF  45,863
16E80:  MOVFF  44,862
....................       user_quit = FALSE; 
16E84:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
16E86:  MOVLB  8
16E88:  CLRF   x65
16E8A:  CLRF   x64
16E8C:  MOVF   x65,W
16E8E:  SUBWF  x63,W
16E90:  BNC   16F10
16E92:  BNZ   16E9A
16E94:  MOVF   x62,W
16E96:  SUBWF  x64,W
16E98:  BC    16F10
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
16E9A:  MOVLW  01
16E9C:  ADDWF  x64,W
16E9E:  MOVWF  x66
16EA0:  MOVLW  00
16EA2:  ADDWFC x65,W
16EA4:  MOVWF  x67
16EA6:  MOVLW  9C
16EA8:  MOVWF  FF6
16EAA:  MOVLW  26
16EAC:  MOVWF  FF7
16EAE:  MOVLW  00
16EB0:  MOVWF  FF8
16EB2:  CLRF   1B
16EB4:  BTFSC  FF2.7
16EB6:  BSF    1B.7
16EB8:  BCF    FF2.7
16EBA:  MOVLW  05
16EBC:  MOVLB  A
16EBE:  MOVWF  x18
16EC0:  MOVLB  0
16EC2:  CALL   1006
16EC6:  BTFSC  1B.7
16EC8:  BSF    FF2.7
16ECA:  MOVLW  09
16ECC:  MOVWF  FE9
16ECE:  CLRF   1B
16ED0:  BTFSC  FF2.7
16ED2:  BSF    1B.7
16ED4:  BCF    FF2.7
16ED6:  MOVFF  867,A19
16EDA:  MOVFF  866,A18
16EDE:  CALL   1188
16EE2:  BTFSC  1B.7
16EE4:  BSF    FF2.7
16EE6:  MOVLW  0D
16EE8:  BTFSS  F9E.4
16EEA:  BRA    16EE8
16EEC:  MOVWF  FAD
16EEE:  MOVLW  0A
16EF0:  BTFSS  F9E.4
16EF2:  BRA    16EF0
16EF4:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
16EF6:  CALL   15A8C
16EFA:  MOVFF  01,861
....................          if (macro_cmd == ';') break; 
16EFE:  MOVLB  8
16F00:  MOVF   x61,W
16F02:  SUBLW  3B
16F04:  BTFSC  FD8.2
16F06:  BRA    16F10
16F08:  INCF   x64,F
16F0A:  BTFSC  FD8.2
16F0C:  INCF   x65,F
16F0E:  BRA    16E8C
16F10:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
16F12:  CALL   ADB6
16F16:  GOTO   170D6 (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
16F1A:  MOVF   44,F
16F1C:  BNZ   16F2A
16F1E:  MOVF   45,F
16F20:  BNZ   16F2A
16F22:  MOVF   46,F
16F24:  BNZ   16F2A
16F26:  MOVF   47,F
16F28:  BZ    16F6E
16F2A:  MOVF   47,F
16F2C:  BNZ   16F6E
16F2E:  MOVF   46,F
16F30:  BNZ   16F6E
16F32:  MOVF   45,F
16F34:  BNZ   16F6E
16F36:  MOVF   44,W
16F38:  SUBLW  2F
16F3A:  BNC   16F6E
....................       n=arg; 
16F3C:  MOVFF  44,864
....................       port=2; 
16F40:  MOVLB  8
16F42:  CLRF   x62
16F44:  MOVLW  02
16F46:  MOVWF  x61
....................       for(i=0;i<n;++i){ 
16F48:  CLRF   x63
16F4A:  MOVF   x64,W
16F4C:  SUBWF  x63,W
16F4E:  BC    16F6A
....................          play_wms_hard_macro(port); 
16F50:  MOVFF  862,866
16F54:  MOVFF  861,865
16F58:  MOVLB  0
16F5A:  CALL   D504
....................          ++port; 
16F5E:  MOVLB  8
16F60:  INCF   x61,F
16F62:  BTFSC  FD8.2
16F64:  INCF   x62,F
16F66:  INCF   x63,F
16F68:  BRA    16F4A
....................       } 
....................    } 
16F6A:  BRA    16F74
16F6C:  MOVLB  0
....................    else cmd_arg(); 
16F6E:  CALL   AF7A
16F72:  MOVLB  8
16F74:  MOVLB  0
16F76:  GOTO   170D6 (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
16F7A:  CALL   293E
....................     
....................    nv_macro_step = 0; 
16F7E:  CLRF   38
16F80:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
16F82:  MOVLW  3A
16F84:  MOVLB  8
16F86:  MOVWF  xCA
16F88:  MOVFF  38,8CC
16F8C:  MOVFF  37,8CB
16F90:  MOVLB  0
16F92:  CALL   4F52
....................     
....................    user_quit = FALSE; 
16F96:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 241){ 
16F98:  MOVF   44,F
16F9A:  BNZ   16FAA
16F9C:  MOVF   45,F
16F9E:  BNZ   16FAA
16FA0:  MOVF   46,F
16FA2:  BNZ   16FAA
16FA4:  MOVF   47,F
16FA6:  BTFSC  FD8.2
16FA8:  BRA    17096
16FAA:  MOVF   47,F
16FAC:  BTFSS  FD8.2
16FAE:  BRA    17096
16FB0:  MOVF   46,F
16FB2:  BTFSS  FD8.2
16FB4:  BRA    17096
16FB6:  MOVF   45,F
16FB8:  BTFSS  FD8.2
16FBA:  BRA    17096
16FBC:  MOVF   44,W
16FBE:  SUBLW  F0
16FC0:  BNC   17096
....................       samples = arg; 
16FC2:  MOVFF  45,863
16FC6:  MOVFF  44,862
....................       user_quit = FALSE; 
16FCA:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
16FCC:  MOVLB  8
16FCE:  CLRF   x65
16FD0:  CLRF   x64
16FD2:  MOVF   x65,W
16FD4:  SUBWF  x63,W
16FD6:  BNC   17094
16FD8:  BNZ   16FE0
16FDA:  MOVF   x62,W
16FDC:  SUBWF  x64,W
16FDE:  BC    17094
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
16FE0:  MOVLW  01
16FE2:  ADDWF  x64,W
16FE4:  MOVWF  x66
16FE6:  MOVLW  00
16FE8:  ADDWFC x65,W
16FEA:  MOVWF  x67
16FEC:  MOVLW  AA
16FEE:  MOVWF  FF6
16FF0:  MOVLW  26
16FF2:  MOVWF  FF7
16FF4:  MOVLW  00
16FF6:  MOVWF  FF8
16FF8:  CLRF   1B
16FFA:  BTFSC  FF2.7
16FFC:  BSF    1B.7
16FFE:  BCF    FF2.7
17000:  MOVLW  05
17002:  MOVLB  A
17004:  MOVWF  x18
17006:  MOVLB  0
17008:  CALL   1006
1700C:  BTFSC  1B.7
1700E:  BSF    FF2.7
17010:  MOVLW  09
17012:  MOVWF  FE9
17014:  CLRF   1B
17016:  BTFSC  FF2.7
17018:  BSF    1B.7
1701A:  BCF    FF2.7
1701C:  MOVFF  867,A19
17020:  MOVFF  866,A18
17024:  CALL   1188
17028:  BTFSC  1B.7
1702A:  BSF    FF2.7
1702C:  MOVLW  0D
1702E:  BTFSS  F9E.4
17030:  BRA    1702E
17032:  MOVWF  FAD
17034:  MOVLW  0A
17036:  BTFSS  F9E.4
17038:  BRA    17036
1703A:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
1703C:  MOVLW  01
1703E:  MOVLB  8
17040:  ADDWF  x64,W
17042:  MOVWF  x66
17044:  MOVLW  00
17046:  ADDWFC x65,W
17048:  MOVWF  x67
1704A:  MOVWF  x69
1704C:  MOVFF  866,868
17050:  MOVLB  0
17052:  CALL   16342
17056:  MOVFF  01,861
....................          ++nv_sample;                     // increment sample number 
1705A:  INCF   21,F
1705C:  BTFSC  FD8.2
1705E:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
17060:  MOVLW  16
17062:  MOVLB  8
17064:  MOVWF  xCA
17066:  MOVFF  22,8CC
1706A:  MOVFF  21,8CB
1706E:  MOVLB  0
17070:  CALL   4F52
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
17074:  MOVF   27,W
17076:  SUBWF  21,W
17078:  BNZ   17080
1707A:  MOVF   28,W
1707C:  SUBWF  22,W
1707E:  BZ    17088
17080:  MOVLB  8
17082:  MOVF   x61,W
17084:  SUBLW  3B
17086:  BNZ   1708C
17088:  MOVLB  8
1708A:  BRA    17094
1708C:  INCF   x64,F
1708E:  BTFSC  FD8.2
17090:  INCF   x65,F
17092:  BRA    16FD2
17094:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
17096:  CALL   ADB6
1709A:  GOTO   170D6 (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
1709E:  MOVF   2F,W
170A0:  MOVWF  00
170A2:  MOVF   30,W
170A4:  MOVWF  03
170A6:  BNZ   170AC
170A8:  MOVF   00,F
170AA:  BZ    170CC
170AC:  MOVF   03,W
170AE:  BNZ   170B6
170B0:  MOVLW  01
170B2:  SUBWF  00,W
170B4:  BZ    170D0
170B6:  MOVF   03,W
170B8:  BNZ   170C0
170BA:  MOVLW  03
170BC:  SUBWF  00,W
170BE:  BZ    170D0
170C0:  MOVF   03,W
170C2:  BNZ   170CA
170C4:  MOVLW  02
170C6:  SUBWF  00,W
170C8:  BZ    170D4
170CA:  BRA    170D6
....................       case ECO : commandRe(); 
170CC:  BRA    16E38
....................          break; 
170CE:  BRA    170D6
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
170D0:  BRA    16F1A
....................          break; 
170D2:  BRA    170D6
....................       case AWS : commandRa(); 
170D4:  BRA    16F7A
....................          break;          
....................    } 
170D6:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
170DA:  CALL   293E
....................     
....................    switch(arg){ 
170DE:  MOVFF  44,00
170E2:  MOVF   45,W
170E4:  MOVWF  03
170E6:  BNZ   170EE
170E8:  MOVLW  01
170EA:  SUBWF  00,W
170EC:  BZ    170FA
170EE:  MOVF   03,W
170F0:  BNZ   170F8
170F2:  MOVLW  02
170F4:  SUBWF  00,W
170F6:  BZ    1713E
170F8:  BRA    1714E
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
170FA:  DECFSZ 41,W
170FC:  BRA    17112
170FE:  MOVF   42,F
17100:  BNZ   17112
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
17102:  MOVLB  8
17104:  CLRF   x9E
17106:  MOVLW  01
17108:  MOVWF  x9F
1710A:  MOVLB  0
1710C:  CALL   1340C
....................       } 
17110:  BRA    1713C
....................       else if(nv_det_type==2 || nv_det_type==3) 
17112:  MOVF   41,W
17114:  SUBLW  02
17116:  BNZ   1711C
17118:  MOVF   42,F
1711A:  BZ    17126
1711C:  MOVF   41,W
1711E:  SUBLW  03
17120:  BNZ   1713C
17122:  MOVF   42,F
17124:  BNZ   1713C
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
17126:  MOVLB  8
17128:  CLRF   x9F
1712A:  MOVLW  C8
1712C:  MOVWF  x9E
1712E:  CLRF   xA0
17130:  MOVLW  01
17132:  MOVWF  xA1
17134:  CLRF   xA2
17136:  MOVLB  0
17138:  CALL   FCFA
....................       } 
....................       break;                                                        //200 scans,don't store,display 
1713C:  BRA    17152
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
1713E:  MOVLB  8
17140:  CLRF   x9E
17142:  MOVLW  01
17144:  MOVWF  x9F
17146:  MOVLB  0
17148:  CALL   1370E
....................       break; 
1714C:  BRA    17152
....................    default: cmd_arg(); 
1714E:  CALL   AF7A
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
17152:  CALL   ADB6
17156:  GOTO   17202 (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
1715A:  MOVF   47,F
1715C:  BNZ   1718E
1715E:  MOVF   46,F
17160:  BNZ   1718E
17162:  MOVF   45,W
17164:  SUBLW  04
17166:  BNC   1718E
17168:  BNZ   17170
1716A:  MOVF   44,W
1716C:  SUBLW  00
1716E:  BNC   1718E
....................       nv_sample = arg; 
17170:  MOVFF  45,22
17174:  MOVFF  44,21
....................       write16(ADDR_SAMPLE, nv_sample); 
17178:  MOVLW  16
1717A:  MOVLB  8
1717C:  MOVWF  xCA
1717E:  MOVFF  22,8CC
17182:  MOVFF  21,8CB
17186:  MOVLB  0
17188:  CALL   4F52
....................    } 
1718C:  BRA    17192
....................    else cmd_arg(); 
1718E:  CALL   AF7A
17192:  GOTO   17202 (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
17196:  MOVF   47,F
17198:  BNZ   171C2
1719A:  MOVF   46,F
1719C:  BNZ   171C2
1719E:  MOVF   45,W
171A0:  SUBLW  01
171A2:  BNC   171C2
171A4:  BNZ   171AC
171A6:  MOVF   44,W
171A8:  SUBLW  02
171AA:  BNC   171C2
....................       setting = arg; 
171AC:  MOVFF  45,862
171B0:  MOVFF  44,861
....................       sol_switch_cmd(setting); 
171B4:  MOVFF  862,893
171B8:  MOVFF  861,892
171BC:  CALL   14014
....................    } 
171C0:  BRA    171C6
....................    else cmd_arg(); 
171C2:  CALL   AF7A
171C6:  GOTO   17202 (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
171CA:  MOVF   2F,W
171CC:  MOVWF  00
171CE:  MOVF   30,W
171D0:  MOVWF  03
171D2:  BNZ   171D8
171D4:  MOVF   00,F
171D6:  BZ    171F8
171D8:  MOVF   03,W
171DA:  BNZ   171E2
171DC:  MOVLW  01
171DE:  SUBWF  00,W
171E0:  BZ    171FC
171E2:  MOVF   03,W
171E4:  BNZ   171EC
171E6:  MOVLW  03
171E8:  SUBWF  00,W
171EA:  BZ    171FC
171EC:  MOVF   03,W
171EE:  BNZ   171F6
171F0:  MOVLW  02
171F2:  SUBWF  00,W
171F4:  BZ    17200
171F6:  BRA    17202
....................       case ECO : commandSe(); 
171F8:  BRA    170DA
....................          break; 
171FA:  BRA    17202
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
171FC:  BRA    1715A
....................          break; 
171FE:  BRA    17202
....................       case AWS : commandSa(); 
17200:  BRA    17196
....................          break;          
....................    } 
17202:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
17768:  MOVLW  B8
1776A:  MOVWF  FF6
1776C:  MOVLW  26
1776E:  MOVWF  FF7
17770:  MOVLW  00
17772:  MOVWF  FF8
17774:  CLRF   1B
17776:  BTFSC  FF2.7
17778:  BSF    1B.7
1777A:  BCF    FF2.7
1777C:  CALL   0E30
17780:  BTFSC  1B.7
17782:  BSF    FF2.7
....................    fputc('>',COM_A); 
17784:  MOVLW  3E
17786:  CALL   ADBE
....................    RTCfmt=fgetc(COM_A); 
1778A:  CALL   0E1A
1778E:  MOVFF  01,4B
....................    if (com_echo == TRUE) 
17792:  DECFSZ 48,W
17794:  BRA    1779C
....................       { 
....................       fputc(RTCfmt,COM_A); 
17796:  MOVF   4B,W
17798:  CALL   ADBE
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
1779C:  MOVLW  30
1779E:  SUBWF  4B,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
177A0:  MOVF   4B,W
177A2:  SUBLW  01
177A4:  BNC   177DA
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
177A6:  MOVLW  E4
177A8:  MOVWF  FF6
177AA:  MOVLW  26
177AC:  MOVWF  FF7
177AE:  MOVLW  00
177B0:  MOVWF  FF8
177B2:  CALL   AD8C
177B6:  MOVLW  0D
177B8:  BTFSS  F9E.4
177BA:  BRA    177B8
177BC:  MOVWF  FAD
177BE:  MOVLW  0A
177C0:  BTFSS  F9E.4
177C2:  BRA    177C0
177C4:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
177C6:  MOVLW  1A
177C8:  MOVLB  8
177CA:  MOVWF  xCA
177CC:  CLRF   xCC
177CE:  MOVFF  4B,8CB
177D2:  MOVLB  0
177D4:  CALL   4F52
....................       }  
177D8:  BRA    177DE
....................    else cmd_arg(); 
177DA:  CALL   AF7A
....................     
....................    if(arg == 1) 
177DE:  DECFSZ 44,W
177E0:  BRA    177F2
177E2:  MOVF   45,F
177E4:  BNZ   177F2
177E6:  MOVF   46,F
177E8:  BNZ   177F2
177EA:  MOVF   47,F
177EC:  BNZ   177F2
....................    { 
....................       RTC_Set(); 
177EE:  BRA    1761E
....................    } 
177F0:  BRA    177F6
....................    else cmd_arg(); 
177F2:  CALL   AF7A
177F6:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
1816E:  MOVF   47,F
18170:  BNZ   1818C
18172:  MOVF   46,F
18174:  BNZ   1818C
18176:  MOVF   45,F
18178:  BNZ   1818C
1817A:  MOVF   44,W
1817C:  SUBLW  14
1817E:  BNC   1818C
....................       macro = arg; 
18180:  MOVFF  44,861
....................       upload_macro(macro);    
18184:  MOVFF  861,862
18188:  BRA    17EB8
....................    }    
1818A:  BRA    181A8
....................    else if (arg == 5525){ 
1818C:  MOVF   44,W
1818E:  SUBLW  95
18190:  BNZ   181A4
18192:  MOVF   45,W
18194:  SUBLW  15
18196:  BNZ   181A4
18198:  MOVF   46,F
1819A:  BNZ   181A4
1819C:  MOVF   47,F
1819E:  BNZ   181A4
....................       write_blank_macros(); 
181A0:  BRA    17FF2
....................    } 
181A2:  BRA    181A8
....................    else cmd_arg(); 
181A4:  CALL   AF7A
181A8:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
182C6:  MOVF   47,F
182C8:  BNZ   182E4
182CA:  MOVF   46,F
182CC:  BNZ   182E4
182CE:  MOVF   45,F
182D0:  BNZ   182E4
182D2:  MOVF   44,W
182D4:  SUBLW  14
182D6:  BNC   182E4
....................       macro = arg;  
182D8:  MOVFF  44,861
....................       read_macro(macro); 
182DC:  MOVFF  861,862
182E0:  BRA    18260
....................    }    
182E2:  BRA    182E8
....................    else cmd_arg(); 
182E4:  CALL   AF7A
182E8:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
1843A:  DECFSZ 44,W
1843C:  BRA    18456
1843E:  MOVF   45,F
18440:  BNZ   18456
18442:  MOVF   46,F
18444:  BNZ   18456
18446:  MOVF   47,F
18448:  BNZ   18456
....................       RTC_alarm(); 
1844A:  BRA    182EC
....................       RTC_late(); 
1844C:  CALL   152BE
....................       RTC_alarm_status(); 
18450:  CALL   15778
....................    } 
18454:  BRA    1845A
....................    else cmd_arg(); 
18456:  CALL   AF7A
1845A:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
1845E:  MOVF   44,W
18460:  MOVWF  00
18462:  MOVF   45,W
18464:  MOVWF  03
18466:  BNZ   1846C
18468:  MOVF   00,F
1846A:  BZ    184A0
1846C:  MOVF   03,W
1846E:  BNZ   18476
18470:  MOVLW  02
18472:  SUBWF  00,W
18474:  BZ    184A0
18476:  MOVF   03,W
18478:  BNZ   18480
1847A:  MOVLW  03
1847C:  SUBWF  00,W
1847E:  BZ    184A0
18480:  MOVF   03,W
18482:  BNZ   1848A
18484:  MOVLW  04
18486:  SUBWF  00,W
18488:  BZ    184A0
1848A:  MOVF   03,W
1848C:  BNZ   18494
1848E:  MOVLW  05
18490:  SUBWF  00,W
18492:  BZ    184A0
18494:  MOVF   03,W
18496:  BNZ   1849E
18498:  MOVLW  06
1849A:  SUBWF  00,W
1849C:  BZ    184A0
1849E:  BRA    184BE
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
184A0:  MOVFF  45,20
184A4:  MOVFF  44,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
184A8:  MOVLW  1C
184AA:  MOVLB  8
184AC:  MOVWF  xCA
184AE:  MOVFF  20,8CC
184B2:  MOVFF  1F,8CB
184B6:  MOVLB  0
184B8:  CALL   4F52
....................          break; 
184BC:  BRA    184C2
....................       default: cmd_arg(); 
184BE:  CALL   AF7A
....................          break; 
....................    } 
184C2:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
184C6:  CALL   293E
....................     
....................    switch(arg){ 
184CA:  MOVFF  44,00
184CE:  MOVF   45,W
184D0:  MOVWF  03
184D2:  BNZ   184D8
184D4:  MOVF   00,F
184D6:  BZ    1855C
184D8:  MOVF   03,W
184DA:  BNZ   184E2
184DC:  MOVLW  0A
184DE:  SUBWF  00,W
184E0:  BZ    1855C
184E2:  MOVF   03,W
184E4:  BNZ   184EC
184E6:  MOVLW  01
184E8:  SUBWF  00,W
184EA:  BZ    18564
184EC:  MOVF   03,W
184EE:  BNZ   184F6
184F0:  MOVLW  0B
184F2:  SUBWF  00,W
184F4:  BZ    18564
184F6:  MOVF   03,W
184F8:  BNZ   18500
184FA:  MOVLW  14
184FC:  SUBWF  00,W
184FE:  BZ    1856E
18500:  MOVF   03,W
18502:  BNZ   1850A
18504:  MOVLW  15
18506:  SUBWF  00,W
18508:  BZ    18574
1850A:  MOVF   03,W
1850C:  BNZ   18514
1850E:  MOVLW  1E
18510:  SUBWF  00,W
18512:  BZ    1857A
18514:  MOVF   03,W
18516:  BNZ   1851E
18518:  MOVLW  1F
1851A:  SUBWF  00,W
1851C:  BZ    18580
1851E:  MOVF   03,W
18520:  BNZ   18528
18522:  MOVLW  28
18524:  SUBWF  00,W
18526:  BZ    18586
18528:  MOVF   03,W
1852A:  BNZ   18532
1852C:  MOVLW  29
1852E:  SUBWF  00,W
18530:  BZ    1858C
18532:  MOVF   03,W
18534:  BNZ   1853C
18536:  MOVLW  32
18538:  SUBWF  00,W
1853A:  BZ    18592
1853C:  MOVF   03,W
1853E:  BNZ   18546
18540:  MOVLW  33
18542:  SUBWF  00,W
18544:  BZ    18598
18546:  MOVF   03,W
18548:  BNZ   18550
1854A:  MOVLW  3C
1854C:  SUBWF  00,W
1854E:  BZ    1859E
18550:  MOVF   03,W
18552:  BNZ   1855A
18554:  MOVLW  3D
18556:  SUBWF  00,W
18558:  BZ    185AC
1855A:  BRA    185BE
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
1855C:  BCF    F90.7
....................                bus_pwr_status=0; 
1855E:  MOVLB  4
18560:  CLRF   xB2
....................          break; 
18562:  BRA    185C4
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18564:  BSF    F90.7
....................                bus_pwr_status=1; 
18566:  MOVLW  01
18568:  MOVLB  4
1856A:  MOVWF  xB2
....................          break; 
1856C:  BRA    185C4
....................       case 20: output_bit(VMOT,OFF); 
1856E:  BCF    F8E.1
....................          break; 
18570:  MOVLB  4
18572:  BRA    185C4
....................       case 21: output_bit(VMOT,ON); 
18574:  BSF    F8E.1
....................          break; 
18576:  MOVLB  4
18578:  BRA    185C4
....................       case 30: output_bit(VENC1,OFF); 
1857A:  BCF    F8E.6
....................          break; 
1857C:  MOVLB  4
1857E:  BRA    185C4
....................       case 31: output_bit(VENC1,ON); 
18580:  BSF    F8E.6
....................          break; 
18582:  MOVLB  4
18584:  BRA    185C4
....................       case 40: output_bit(VENC2,OFF); 
18586:  BCF    F8E.7
....................          break; 
18588:  MOVLB  4
1858A:  BRA    185C4
....................       case 41: output_bit(VENC2,ON); 
1858C:  BSF    F8E.7
....................          break; 
1858E:  MOVLB  4
18590:  BRA    185C4
....................       case 50: output_bit(VHBRDG,OFF); 
18592:  BCF    F8E.2
....................          break; 
18594:  MOVLB  4
18596:  BRA    185C4
....................       case 51: output_bit(VHBRDG,ON); 
18598:  BSF    F8E.2
....................          break;          
1859A:  MOVLB  4
1859C:  BRA    185C4
....................       case 60: set_heaters(0); 
1859E:  MOVLB  8
185A0:  CLRF   xA1
185A2:  MOVLB  0
185A4:  CALL   123EC
....................          break; 
185A8:  MOVLB  4
185AA:  BRA    185C4
....................       case 61: set_heaters(3); 
185AC:  MOVLW  03
185AE:  MOVLB  8
185B0:  MOVWF  xA1
185B2:  MOVLB  0
185B4:  CALL   123EC
....................          break; 
185B8:  MOVLB  4
185BA:  BRA    185C4
185BC:  MOVLB  0
....................       default : cmd_arg(); 
185BE:  CALL   AF7A
....................          break;          
185C2:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
185C4:  MOVLB  0
185C6:  CALL   ADB6
185CA:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
185CE:  MOVF   44,F
185D0:  BNZ   185EC
185D2:  MOVF   45,F
185D4:  BNZ   185EC
185D6:  MOVF   46,F
185D8:  BNZ   185EC
185DA:  MOVF   47,F
185DC:  BNZ   185EC
....................       motor_sleep_rdy(); 
185DE:  CALL   2916
....................       shutdown(); 
185E2:  CALL   1579A
....................       go_to_sleep(); 
185E6:  CALL   159C6
....................    } 
185EA:  BRA    185F0
....................    else cmd_arg(); 
185EC:  CALL   AF7A
185F0:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
1871E:  DECFSZ 44,W
18720:  BRA    18732
18722:  MOVF   45,F
18724:  BNZ   18732
18726:  MOVF   46,F
18728:  BNZ   18732
1872A:  MOVF   47,F
1872C:  BNZ   18732
1872E:  BRA    18618
18730:  BRA    18736
....................    else cmd_arg(); 
18732:  CALL   AF7A
18736:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
1873A:  MOVF   47,F
1873C:  BNZ   187CC
1873E:  MOVF   46,F
18740:  BNZ   187CC
18742:  MOVF   45,W
18744:  SUBLW  27
18746:  BNC   187CC
18748:  BNZ   18750
1874A:  MOVF   44,W
1874C:  SUBLW  10
1874E:  BNC   187CC
....................       m_bklsh[motor] = arg; 
18750:  BCF    FD8.0
18752:  MOVLB  7
18754:  RLCF   x3C,W
18756:  CLRF   03
18758:  ADDLW  6E
1875A:  MOVWF  FE9
1875C:  MOVLW  07
1875E:  ADDWFC 03,W
18760:  MOVWF  FEA
18762:  MOVFF  44,FEF
18766:  MOVFF  45,FEC
....................       switch(motor){ 
1876A:  MOVF   x3C,W
1876C:  XORLW  00
1876E:  MOVLB  0
18770:  BZ    18778
18772:  XORLW  01
18774:  BZ    187A2
18776:  BRA    187CA
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
18778:  BCF    FD8.0
1877A:  MOVLB  7
1877C:  RLCF   x3C,W
1877E:  CLRF   03
18780:  ADDLW  6E
18782:  MOVWF  FE9
18784:  MOVLW  07
18786:  ADDWFC 03,W
18788:  MOVWF  FEA
1878A:  MOVFF  FEC,8CC
1878E:  MOVF   FED,F
18790:  MOVFF  FEF,8CB
18794:  MOVLW  72
18796:  MOVLB  8
18798:  MOVWF  xCA
1879A:  MOVLB  0
1879C:  CALL   4F52
....................             break; 
187A0:  BRA    187CA
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
187A2:  BCF    FD8.0
187A4:  MOVLB  7
187A6:  RLCF   x3C,W
187A8:  CLRF   03
187AA:  ADDLW  6E
187AC:  MOVWF  FE9
187AE:  MOVLW  07
187B0:  ADDWFC 03,W
187B2:  MOVWF  FEA
187B4:  MOVFF  FEC,8CC
187B8:  MOVF   FED,F
187BA:  MOVFF  FEF,8CB
187BE:  MOVLW  74
187C0:  MOVLB  8
187C2:  MOVWF  xCA
187C4:  MOVLB  0
187C6:  CALL   4F52
....................             break;             
....................       } 
....................    } 
187CA:  BRA    187D0
....................    else cmd_arg();    
187CC:  CALL   AF7A
187D0:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
187D4:  MOVF   47,F
187D6:  BNZ   18862
187D8:  MOVF   46,F
187DA:  BNZ   18862
187DC:  MOVF   45,F
187DE:  BNZ   18862
187E0:  MOVF   44,W
187E2:  SUBLW  01
187E4:  BNC   18862
....................       m_pos_dir[motor] = arg; 
187E6:  BCF    FD8.0
187E8:  MOVLB  7
187EA:  RLCF   x3C,W
187EC:  CLRF   03
187EE:  ADDLW  4A
187F0:  MOVWF  FE9
187F2:  MOVLW  07
187F4:  ADDWFC 03,W
187F6:  MOVWF  FEA
187F8:  MOVFF  44,FEF
187FC:  MOVFF  45,FEC
....................       switch(motor){ 
18800:  MOVF   x3C,W
18802:  XORLW  00
18804:  MOVLB  0
18806:  BZ    1880E
18808:  XORLW  01
1880A:  BZ    18838
1880C:  BRA    18860
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
1880E:  BCF    FD8.0
18810:  MOVLB  7
18812:  RLCF   x3C,W
18814:  CLRF   03
18816:  ADDLW  4A
18818:  MOVWF  FE9
1881A:  MOVLW  07
1881C:  ADDWFC 03,W
1881E:  MOVWF  FEA
18820:  MOVFF  FEC,8CC
18824:  MOVF   FED,F
18826:  MOVFF  FEF,8CB
1882A:  MOVLW  92
1882C:  MOVLB  8
1882E:  MOVWF  xCA
18830:  MOVLB  0
18832:  CALL   4F52
....................             break; 
18836:  BRA    18860
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
18838:  BCF    FD8.0
1883A:  MOVLB  7
1883C:  RLCF   x3C,W
1883E:  CLRF   03
18840:  ADDLW  4A
18842:  MOVWF  FE9
18844:  MOVLW  07
18846:  ADDWFC 03,W
18848:  MOVWF  FEA
1884A:  MOVFF  FEC,8CC
1884E:  MOVF   FED,F
18850:  MOVFF  FEF,8CB
18854:  MOVLW  94
18856:  MOVLB  8
18858:  MOVWF  xCA
1885A:  MOVLB  0
1885C:  CALL   4F52
....................             break;             
....................       } 
....................    } 
18860:  BRA    18866
....................    else cmd_arg();    
18862:  CALL   AF7A
18866:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
1886A:  MOVF   47,F
1886C:  BNZ   188FC
1886E:  MOVF   46,F
18870:  BNZ   188FC
18872:  MOVF   45,W
18874:  SUBLW  27
18876:  BNC   188FC
18878:  BNZ   18880
1887A:  MOVF   44,W
1887C:  SUBLW  10
1887E:  BNC   188FC
....................       e_cpr[motor] = arg; 
18880:  BCF    FD8.0
18882:  MOVLB  7
18884:  RLCF   x3C,W
18886:  CLRF   03
18888:  ADDLW  5A
1888A:  MOVWF  FE9
1888C:  MOVLW  07
1888E:  ADDWFC 03,W
18890:  MOVWF  FEA
18892:  MOVFF  44,FEF
18896:  MOVFF  45,FEC
....................       switch(motor){ 
1889A:  MOVF   x3C,W
1889C:  XORLW  00
1889E:  MOVLB  0
188A0:  BZ    188A8
188A2:  XORLW  01
188A4:  BZ    188D2
188A6:  BRA    188FA
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
188A8:  BCF    FD8.0
188AA:  MOVLB  7
188AC:  RLCF   x3C,W
188AE:  CLRF   03
188B0:  ADDLW  5A
188B2:  MOVWF  FE9
188B4:  MOVLW  07
188B6:  ADDWFC 03,W
188B8:  MOVWF  FEA
188BA:  MOVFF  FEC,8CC
188BE:  MOVF   FED,F
188C0:  MOVFF  FEF,8CB
188C4:  MOVLW  A2
188C6:  MOVLB  8
188C8:  MOVWF  xCA
188CA:  MOVLB  0
188CC:  CALL   4F52
....................             break; 
188D0:  BRA    188FA
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
188D2:  BCF    FD8.0
188D4:  MOVLB  7
188D6:  RLCF   x3C,W
188D8:  CLRF   03
188DA:  ADDLW  5A
188DC:  MOVWF  FE9
188DE:  MOVLW  07
188E0:  ADDWFC 03,W
188E2:  MOVWF  FEA
188E4:  MOVFF  FEC,8CC
188E8:  MOVF   FED,F
188EA:  MOVFF  FEF,8CB
188EE:  MOVLW  A4
188F0:  MOVLB  8
188F2:  MOVWF  xCA
188F4:  MOVLB  0
188F6:  CALL   4F52
....................             break;             
....................       } 
....................    } 
188FA:  BRA    18900
....................    else cmd_arg();    
188FC:  CALL   AF7A
18900:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18904:  MOVF   47,F
18906:  BNZ   1891C
18908:  MOVF   46,F
1890A:  BNZ   1891C
1890C:  MOVF   45,F
1890E:  BNZ   1891C
18910:  MOVF   44,W
18912:  SUBLW  01
18914:  BNC   1891C
18916:  MOVFF  44,73D
1891A:  BRA    18920
....................    else cmd_arg();    
1891C:  CALL   AF7A
18920:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18924:  MOVF   47,F
18926:  BNZ   189B6
18928:  MOVF   46,F
1892A:  BNZ   189B6
1892C:  MOVF   45,W
1892E:  SUBLW  EA
18930:  BNC   189B6
18932:  BNZ   1893A
18934:  MOVF   44,W
18936:  SUBLW  60
18938:  BNC   189B6
....................       m_gb_err[motor] = arg; 
1893A:  BCF    FD8.0
1893C:  MOVLB  7
1893E:  RLCF   x3C,W
18940:  CLRF   03
18942:  ADDLW  56
18944:  MOVWF  FE9
18946:  MOVLW  07
18948:  ADDWFC 03,W
1894A:  MOVWF  FEA
1894C:  MOVFF  44,FEF
18950:  MOVFF  45,FEC
....................       switch(motor){ 
18954:  MOVF   x3C,W
18956:  XORLW  00
18958:  MOVLB  0
1895A:  BZ    18962
1895C:  XORLW  01
1895E:  BZ    1898C
18960:  BRA    189B4
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18962:  BCF    FD8.0
18964:  MOVLB  7
18966:  RLCF   x3C,W
18968:  CLRF   03
1896A:  ADDLW  56
1896C:  MOVWF  FE9
1896E:  MOVLW  07
18970:  ADDWFC 03,W
18972:  MOVWF  FEA
18974:  MOVFF  FEC,8CC
18978:  MOVF   FED,F
1897A:  MOVFF  FEF,8CB
1897E:  MOVLW  9E
18980:  MOVLB  8
18982:  MOVWF  xCA
18984:  MOVLB  0
18986:  CALL   4F52
....................             break; 
1898A:  BRA    189B4
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
1898C:  BCF    FD8.0
1898E:  MOVLB  7
18990:  RLCF   x3C,W
18992:  CLRF   03
18994:  ADDLW  56
18996:  MOVWF  FE9
18998:  MOVLW  07
1899A:  ADDWFC 03,W
1899C:  MOVWF  FEA
1899E:  MOVFF  FEC,8CC
189A2:  MOVF   FED,F
189A4:  MOVFF  FEF,8CB
189A8:  MOVLW  A0
189AA:  MOVLB  8
189AC:  MOVWF  xCA
189AE:  MOVLB  0
189B0:  CALL   4F52
....................             break;             
....................       } 
....................    } 
189B4:  BRA    189BA
....................    else cmd_arg();    
189B6:  CALL   AF7A
189BA:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
189BE:  MOVF   47,F
189C0:  BNZ   18A8A
189C2:  MOVF   46,F
189C4:  BNZ   18A8A
189C6:  MOVF   45,F
189C8:  BNZ   18A8A
189CA:  MOVF   44,W
189CC:  SUBLW  64
189CE:  BNC   18A8A
....................       hold_pc=arg; 
189D0:  MOVFF  45,862
189D4:  MOVFF  44,861
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
189D8:  BCF    FD8.0
189DA:  MOVLB  7
189DC:  RLCF   x3C,W
189DE:  CLRF   03
189E0:  ADDLW  4E
189E2:  MOVWF  FE9
189E4:  MOVLW  07
189E6:  ADDWFC 03,W
189E8:  MOVWF  FEA
189EA:  MOVFF  862,9E9
189EE:  MOVFF  861,9E8
189F2:  MOVLW  01
189F4:  MOVLB  9
189F6:  MOVWF  xEB
189F8:  SETF   xEA
189FA:  MOVLB  0
189FC:  CALL   5C22
18A00:  MOVFF  02,866
18A04:  MOVFF  01,865
18A08:  MOVFF  02,8B8
18A0C:  MOVFF  01,8B7
18A10:  MOVLB  8
18A12:  CLRF   xBA
18A14:  MOVLW  64
18A16:  MOVWF  xB9
18A18:  MOVLB  0
18A1A:  CALL   2C52
18A1E:  MOVFF  01,FEF
18A22:  MOVFF  02,FEC
....................       switch(motor){ 
18A26:  MOVLB  7
18A28:  MOVF   x3C,W
18A2A:  XORLW  00
18A2C:  MOVLB  0
18A2E:  BZ    18A36
18A30:  XORLW  01
18A32:  BZ    18A60
18A34:  BRA    18A88
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
18A36:  BCF    FD8.0
18A38:  MOVLB  7
18A3A:  RLCF   x3C,W
18A3C:  CLRF   03
18A3E:  ADDLW  4E
18A40:  MOVWF  FE9
18A42:  MOVLW  07
18A44:  ADDWFC 03,W
18A46:  MOVWF  FEA
18A48:  MOVFF  FEC,8CC
18A4C:  MOVF   FED,F
18A4E:  MOVFF  FEF,8CB
18A52:  MOVLW  96
18A54:  MOVLB  8
18A56:  MOVWF  xCA
18A58:  MOVLB  0
18A5A:  CALL   4F52
....................             break; 
18A5E:  BRA    18A88
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
18A60:  BCF    FD8.0
18A62:  MOVLB  7
18A64:  RLCF   x3C,W
18A66:  CLRF   03
18A68:  ADDLW  4E
18A6A:  MOVWF  FE9
18A6C:  MOVLW  07
18A6E:  ADDWFC 03,W
18A70:  MOVWF  FEA
18A72:  MOVFF  FEC,8CC
18A76:  MOVF   FED,F
18A78:  MOVFF  FEF,8CB
18A7C:  MOVLW  98
18A7E:  MOVLB  8
18A80:  MOVWF  xCA
18A82:  MOVLB  0
18A84:  CALL   4F52
....................             break;             
....................       } 
....................    } 
18A88:  BRA    18A8E
....................    else cmd_arg();    
18A8A:  CALL   AF7A
18A8E:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
18A92:  MOVF   47,F
18A94:  BNZ   18B66
18A96:  MOVF   46,F
18A98:  BNZ   18B66
18A9A:  MOVF   45,W
18A9C:  SUBLW  EA
18A9E:  BNC   18B66
18AA0:  BNZ   18AA8
18AA2:  MOVF   44,W
18AA4:  SUBLW  60
18AA6:  BNC   18B66
....................       m_stp_int[motor] = (arg/100); 
18AA8:  BCF    FD8.0
18AAA:  MOVLB  7
18AAC:  RLCF   x3C,W
18AAE:  CLRF   03
18AB0:  ADDLW  46
18AB2:  MOVWF  FE9
18AB4:  MOVLW  07
18AB6:  ADDWFC 03,W
18AB8:  MOVWF  FEA
18ABA:  MOVFF  FEA,864
18ABE:  MOVFF  FE9,863
18AC2:  BCF    FD8.1
18AC4:  CLRF   1B
18AC6:  BTFSC  FF2.7
18AC8:  BSF    1B.7
18ACA:  BCF    FF2.7
18ACC:  MOVFF  47,A27
18AD0:  MOVFF  46,A26
18AD4:  MOVFF  45,A25
18AD8:  MOVFF  44,A24
18ADC:  MOVLB  A
18ADE:  CLRF   x2B
18AE0:  CLRF   x2A
18AE2:  CLRF   x29
18AE4:  MOVLW  64
18AE6:  MOVWF  x28
18AE8:  MOVLB  0
18AEA:  CALL   1038
18AEE:  BTFSC  1B.7
18AF0:  BSF    FF2.7
18AF2:  MOVFF  864,FEA
18AF6:  MOVFF  863,FE9
18AFA:  MOVFF  00,FEF
18AFE:  MOVFF  01,FEC
....................       switch(motor){ 
18B02:  MOVLB  7
18B04:  MOVF   x3C,W
18B06:  XORLW  00
18B08:  MOVLB  0
18B0A:  BZ    18B12
18B0C:  XORLW  01
18B0E:  BZ    18B3C
18B10:  BRA    18B64
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
18B12:  BCF    FD8.0
18B14:  MOVLB  7
18B16:  RLCF   x3C,W
18B18:  CLRF   03
18B1A:  ADDLW  46
18B1C:  MOVWF  FE9
18B1E:  MOVLW  07
18B20:  ADDWFC 03,W
18B22:  MOVWF  FEA
18B24:  MOVFF  FEC,8CC
18B28:  MOVF   FED,F
18B2A:  MOVFF  FEF,8CB
18B2E:  MOVLW  8E
18B30:  MOVLB  8
18B32:  MOVWF  xCA
18B34:  MOVLB  0
18B36:  CALL   4F52
....................             break; 
18B3A:  BRA    18B64
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
18B3C:  BCF    FD8.0
18B3E:  MOVLB  7
18B40:  RLCF   x3C,W
18B42:  CLRF   03
18B44:  ADDLW  46
18B46:  MOVWF  FE9
18B48:  MOVLW  07
18B4A:  ADDWFC 03,W
18B4C:  MOVWF  FEA
18B4E:  MOVFF  FEC,8CC
18B52:  MOVF   FED,F
18B54:  MOVFF  FEF,8CB
18B58:  MOVLW  90
18B5A:  MOVLB  8
18B5C:  MOVWF  xCA
18B5E:  MOVLB  0
18B60:  CALL   4F52
....................             break;             
....................       } 
....................    } 
18B64:  BRA    18B6A
....................    else cmd_arg();    
18B66:  CALL   AF7A
18B6A:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
18B6E:  MOVF   47,F
18B70:  BNZ   18C00
18B72:  MOVF   46,F
18B74:  BNZ   18C00
18B76:  MOVF   45,W
18B78:  SUBLW  27
18B7A:  BNC   18C00
18B7C:  BNZ   18B84
18B7E:  MOVF   44,W
18B80:  SUBLW  10
18B82:  BNC   18C00
....................       m_run[motor] = arg; 
18B84:  BCF    FD8.0
18B86:  MOVLB  7
18B88:  RLCF   x3C,W
18B8A:  CLRF   03
18B8C:  ADDLW  6A
18B8E:  MOVWF  FE9
18B90:  MOVLW  07
18B92:  ADDWFC 03,W
18B94:  MOVWF  FEA
18B96:  MOVFF  44,FEF
18B9A:  MOVFF  45,FEC
....................       switch(motor){ 
18B9E:  MOVF   x3C,W
18BA0:  XORLW  00
18BA2:  MOVLB  0
18BA4:  BZ    18BAC
18BA6:  XORLW  01
18BA8:  BZ    18BD6
18BAA:  BRA    18BFE
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
18BAC:  BCF    FD8.0
18BAE:  MOVLB  7
18BB0:  RLCF   x3C,W
18BB2:  CLRF   03
18BB4:  ADDLW  6A
18BB6:  MOVWF  FE9
18BB8:  MOVLW  07
18BBA:  ADDWFC 03,W
18BBC:  MOVWF  FEA
18BBE:  MOVFF  FEC,8CC
18BC2:  MOVF   FED,F
18BC4:  MOVFF  FEF,8CB
18BC8:  MOVLW  76
18BCA:  MOVLB  8
18BCC:  MOVWF  xCA
18BCE:  MOVLB  0
18BD0:  CALL   4F52
....................             break; 
18BD4:  BRA    18BFE
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
18BD6:  BCF    FD8.0
18BD8:  MOVLB  7
18BDA:  RLCF   x3C,W
18BDC:  CLRF   03
18BDE:  ADDLW  6A
18BE0:  MOVWF  FE9
18BE2:  MOVLW  07
18BE4:  ADDWFC 03,W
18BE6:  MOVWF  FEA
18BE8:  MOVFF  FEC,8CC
18BEC:  MOVF   FED,F
18BEE:  MOVFF  FEF,8CB
18BF2:  MOVLW  78
18BF4:  MOVLB  8
18BF6:  MOVWF  xCA
18BF8:  MOVLB  0
18BFA:  CALL   4F52
....................             break;             
....................       } 
....................    } 
18BFE:  BRA    18C04
....................    else cmd_arg();    
18C00:  CALL   AF7A
18C04:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
18C08:  MOVF   47,F
18C0A:  BNZ   18C96
18C0C:  MOVF   46,F
18C0E:  BNZ   18C96
18C10:  MOVF   45,F
18C12:  BNZ   18C96
18C14:  MOVF   44,W
18C16:  SUBLW  03
18C18:  BNC   18C96
....................       e_mode[motor] = arg; 
18C1A:  BCF    FD8.0
18C1C:  MOVLB  7
18C1E:  RLCF   x3C,W
18C20:  CLRF   03
18C22:  ADDLW  62
18C24:  MOVWF  FE9
18C26:  MOVLW  07
18C28:  ADDWFC 03,W
18C2A:  MOVWF  FEA
18C2C:  MOVFF  44,FEF
18C30:  MOVFF  45,FEC
....................       switch(motor){ 
18C34:  MOVF   x3C,W
18C36:  XORLW  00
18C38:  MOVLB  0
18C3A:  BZ    18C42
18C3C:  XORLW  01
18C3E:  BZ    18C6C
18C40:  BRA    18C94
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
18C42:  BCF    FD8.0
18C44:  MOVLB  7
18C46:  RLCF   x3C,W
18C48:  CLRF   03
18C4A:  ADDLW  62
18C4C:  MOVWF  FE9
18C4E:  MOVLW  07
18C50:  ADDWFC 03,W
18C52:  MOVWF  FEA
18C54:  MOVFF  FEC,8CC
18C58:  MOVF   FED,F
18C5A:  MOVFF  FEF,8CB
18C5E:  MOVLW  82
18C60:  MOVLB  8
18C62:  MOVWF  xCA
18C64:  MOVLB  0
18C66:  CALL   4F52
....................             break; 
18C6A:  BRA    18C94
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
18C6C:  BCF    FD8.0
18C6E:  MOVLB  7
18C70:  RLCF   x3C,W
18C72:  CLRF   03
18C74:  ADDLW  62
18C76:  MOVWF  FE9
18C78:  MOVLW  07
18C7A:  ADDWFC 03,W
18C7C:  MOVWF  FEA
18C7E:  MOVFF  FEC,8CC
18C82:  MOVF   FED,F
18C84:  MOVFF  FEF,8CB
18C88:  MOVLW  84
18C8A:  MOVLB  8
18C8C:  MOVWF  xCA
18C8E:  MOVLB  0
18C90:  CALL   4F52
....................             break;             
....................       } 
....................    } 
18C94:  BRA    18C9A
....................    else cmd_arg();    
18C96:  CALL   AF7A
18C9A:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
198FE:  MOVF   47,F
19900:  BNZ   1998C
19902:  MOVF   46,F
19904:  BNZ   1998C
19906:  MOVF   45,F
19908:  BNZ   1998C
1990A:  MOVF   44,W
1990C:  SUBLW  01
1990E:  BNC   1998C
....................       m_mode[motor] = arg; 
19910:  BCF    FD8.0
19912:  MOVLB  7
19914:  RLCF   x3C,W
19916:  CLRF   03
19918:  ADDLW  42
1991A:  MOVWF  FE9
1991C:  MOVLW  07
1991E:  ADDWFC 03,W
19920:  MOVWF  FEA
19922:  MOVFF  44,FEF
19926:  MOVFF  45,FEC
....................       switch(motor){ 
1992A:  MOVF   x3C,W
1992C:  XORLW  00
1992E:  MOVLB  0
19930:  BZ    19938
19932:  XORLW  01
19934:  BZ    19962
19936:  BRA    1998A
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19938:  BCF    FD8.0
1993A:  MOVLB  7
1993C:  RLCF   x3C,W
1993E:  CLRF   03
19940:  ADDLW  42
19942:  MOVWF  FE9
19944:  MOVLW  07
19946:  ADDWFC 03,W
19948:  MOVWF  FEA
1994A:  MOVFF  FEC,8CC
1994E:  MOVF   FED,F
19950:  MOVFF  FEF,8CB
19954:  MOVLW  8A
19956:  MOVLB  8
19958:  MOVWF  xCA
1995A:  MOVLB  0
1995C:  CALL   4F52
....................             break; 
19960:  BRA    1998A
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19962:  BCF    FD8.0
19964:  MOVLB  7
19966:  RLCF   x3C,W
19968:  CLRF   03
1996A:  ADDLW  42
1996C:  MOVWF  FE9
1996E:  MOVLW  07
19970:  ADDWFC 03,W
19972:  MOVWF  FEA
19974:  MOVFF  FEC,8CC
19978:  MOVF   FED,F
1997A:  MOVFF  FEF,8CB
1997E:  MOVLW  8C
19980:  MOVLB  8
19982:  MOVWF  xCA
19984:  MOVLB  0
19986:  CALL   4F52
....................             break;             
....................       } 
....................    } 
1998A:  BRA    19990
....................    else cmd_arg();    
1998C:  CALL   AF7A
19990:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19994:  MOVF   47,F
19996:  BNZ   19A22
19998:  MOVF   46,F
1999A:  BNZ   19A22
1999C:  MOVF   45,F
1999E:  BNZ   19A22
199A0:  MOVF   44,W
199A2:  SUBLW  01
199A4:  BNC   19A22
....................       e_index[motor] = arg; 
199A6:  BCF    FD8.0
199A8:  MOVLB  7
199AA:  RLCF   x3C,W
199AC:  CLRF   03
199AE:  ADDLW  76
199B0:  MOVWF  FE9
199B2:  MOVLW  07
199B4:  ADDWFC 03,W
199B6:  MOVWF  FEA
199B8:  MOVFF  44,FEF
199BC:  MOVFF  45,FEC
....................       switch(motor){ 
199C0:  MOVF   x3C,W
199C2:  XORLW  00
199C4:  MOVLB  0
199C6:  BZ    199CE
199C8:  XORLW  01
199CA:  BZ    199F8
199CC:  BRA    19A20
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
199CE:  BCF    FD8.0
199D0:  MOVLB  7
199D2:  RLCF   x3C,W
199D4:  CLRF   03
199D6:  ADDLW  76
199D8:  MOVWF  FE9
199DA:  MOVLW  07
199DC:  ADDWFC 03,W
199DE:  MOVWF  FEA
199E0:  MOVFF  FEC,8CC
199E4:  MOVF   FED,F
199E6:  MOVFF  FEF,8CB
199EA:  MOVLW  BA
199EC:  MOVLB  8
199EE:  MOVWF  xCA
199F0:  MOVLB  0
199F2:  CALL   4F52
....................             break; 
199F6:  BRA    19A20
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
199F8:  BCF    FD8.0
199FA:  MOVLB  7
199FC:  RLCF   x3C,W
199FE:  CLRF   03
19A00:  ADDLW  76
19A02:  MOVWF  FE9
19A04:  MOVLW  07
19A06:  ADDWFC 03,W
19A08:  MOVWF  FEA
19A0A:  MOVFF  FEC,8CC
19A0E:  MOVF   FED,F
19A10:  MOVFF  FEF,8CB
19A14:  MOVLW  BC
19A16:  MOVLB  8
19A18:  MOVWF  xCA
19A1A:  MOVLB  0
19A1C:  CALL   4F52
....................             break;             
....................       } 
....................    } 
19A20:  BRA    19A26
....................    else cmd_arg();    
19A22:  CALL   AF7A
19A26:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
19A2A:  MOVF   47,F
19A2C:  BNZ   19ABC
19A2E:  MOVF   46,F
19A30:  BNZ   19ABC
19A32:  MOVF   45,W
19A34:  SUBLW  01
19A36:  BNC   19ABC
19A38:  BNZ   19A40
19A3A:  MOVF   44,W
19A3C:  SUBLW  0A
19A3E:  BNC   19ABC
....................        evn_so[motor] = arg; 
19A40:  BCF    FD8.0
19A42:  MOVLB  7
19A44:  RLCF   x3C,W
19A46:  CLRF   03
19A48:  ADDLW  7A
19A4A:  MOVWF  FE9
19A4C:  MOVLW  07
19A4E:  ADDWFC 03,W
19A50:  MOVWF  FEA
19A52:  MOVFF  44,FEF
19A56:  MOVFF  45,FEC
....................        switch(motor){ 
19A5A:  MOVF   x3C,W
19A5C:  XORLW  00
19A5E:  MOVLB  0
19A60:  BZ    19A68
19A62:  XORLW  01
19A64:  BZ    19A92
19A66:  BRA    19ABA
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
19A68:  BCF    FD8.0
19A6A:  MOVLB  7
19A6C:  RLCF   x3C,W
19A6E:  CLRF   03
19A70:  ADDLW  7A
19A72:  MOVWF  FE9
19A74:  MOVLW  07
19A76:  ADDWFC 03,W
19A78:  MOVWF  FEA
19A7A:  MOVFF  FEC,8CC
19A7E:  MOVF   FED,F
19A80:  MOVFF  FEF,8CB
19A84:  MOVLW  BE
19A86:  MOVLB  8
19A88:  MOVWF  xCA
19A8A:  MOVLB  0
19A8C:  CALL   4F52
....................             break; 
19A90:  BRA    19ABA
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
19A92:  BCF    FD8.0
19A94:  MOVLB  7
19A96:  RLCF   x3C,W
19A98:  CLRF   03
19A9A:  ADDLW  7A
19A9C:  MOVWF  FE9
19A9E:  MOVLW  07
19AA0:  ADDWFC 03,W
19AA2:  MOVWF  FEA
19AA4:  MOVFF  FEC,8CC
19AA8:  MOVF   FED,F
19AAA:  MOVFF  FEF,8CB
19AAE:  MOVLW  C0
19AB0:  MOVLB  8
19AB2:  MOVWF  xCA
19AB4:  MOVLB  0
19AB6:  CALL   4F52
....................             break;             
....................       } 
....................    } 
19ABA:  BRA    19AC0
....................    else cmd_arg();    
19ABC:  CALL   AF7A
19AC0:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
19AC4:  MOVF   47,F
19AC6:  BNZ   19B56
19AC8:  MOVF   46,F
19ACA:  BNZ   19B56
19ACC:  MOVF   45,W
19ACE:  SUBLW  03
19AD0:  BNC   19B56
19AD2:  BNZ   19ADA
19AD4:  MOVF   44,W
19AD6:  SUBLW  E8
19AD8:  BNC   19B56
....................       e_ppr[motor] = arg; 
19ADA:  BCF    FD8.0
19ADC:  MOVLB  7
19ADE:  RLCF   x3C,W
19AE0:  CLRF   03
19AE2:  ADDLW  5E
19AE4:  MOVWF  FE9
19AE6:  MOVLW  07
19AE8:  ADDWFC 03,W
19AEA:  MOVWF  FEA
19AEC:  MOVFF  44,FEF
19AF0:  MOVFF  45,FEC
....................       switch(motor){ 
19AF4:  MOVF   x3C,W
19AF6:  XORLW  00
19AF8:  MOVLB  0
19AFA:  BZ    19B02
19AFC:  XORLW  01
19AFE:  BZ    19B2C
19B00:  BRA    19B54
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
19B02:  BCF    FD8.0
19B04:  MOVLB  7
19B06:  RLCF   x3C,W
19B08:  CLRF   03
19B0A:  ADDLW  5E
19B0C:  MOVWF  FE9
19B0E:  MOVLW  07
19B10:  ADDWFC 03,W
19B12:  MOVWF  FEA
19B14:  MOVFF  FEC,8CC
19B18:  MOVF   FED,F
19B1A:  MOVFF  FEF,8CB
19B1E:  MOVLW  A6
19B20:  MOVLB  8
19B22:  MOVWF  xCA
19B24:  MOVLB  0
19B26:  CALL   4F52
....................             break; 
19B2A:  BRA    19B54
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
19B2C:  BCF    FD8.0
19B2E:  MOVLB  7
19B30:  RLCF   x3C,W
19B32:  CLRF   03
19B34:  ADDLW  5E
19B36:  MOVWF  FE9
19B38:  MOVLW  07
19B3A:  ADDWFC 03,W
19B3C:  MOVWF  FEA
19B3E:  MOVFF  FEC,8CC
19B42:  MOVF   FED,F
19B44:  MOVFF  FEF,8CB
19B48:  MOVLW  A8
19B4A:  MOVLB  8
19B4C:  MOVWF  xCA
19B4E:  MOVLB  0
19B50:  CALL   4F52
....................             break;             
....................       } 
....................    } 
19B54:  BRA    19B5A
....................    else cmd_arg();    
19B56:  CALL   AF7A
19B5A:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
19B5E:  MOVF   44,F
19B60:  BNZ   19B72
19B62:  MOVF   45,F
19B64:  BNZ   19B72
19B66:  MOVF   46,F
19B68:  BNZ   19B72
19B6A:  MOVF   47,F
19B6C:  BNZ   19B72
19B6E:  BCF    F8E.1
19B70:  BRA    19B76
....................    else cmd_arg();    
19B72:  CALL   AF7A
19B76:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1A65A:  MOVF   44,F
1A65C:  BNZ   1A6AC
1A65E:  MOVF   45,F
1A660:  BNZ   1A6AC
1A662:  MOVF   46,F
1A664:  BNZ   1A6AC
1A666:  MOVF   47,F
1A668:  BNZ   1A6AC
....................       switch (nv_product) { 
1A66A:  MOVFF  2F,00
1A66E:  MOVF   30,W
1A670:  MOVWF  03
1A672:  BNZ   1A678
1A674:  MOVF   00,F
1A676:  BZ    1A698
1A678:  MOVF   03,W
1A67A:  BNZ   1A682
1A67C:  MOVLW  01
1A67E:  SUBWF  00,W
1A680:  BZ    1A69E
1A682:  MOVF   03,W
1A684:  BNZ   1A68C
1A686:  MOVLW  02
1A688:  SUBWF  00,W
1A68A:  BZ    1A6A4
1A68C:  MOVF   03,W
1A68E:  BNZ   1A696
1A690:  MOVLW  03
1A692:  SUBWF  00,W
1A694:  BZ    1A6A8
1A696:  BRA    1A6AA
....................          case ECO : rst_step_vars_eco(); 
1A698:  GOTO   19B7A
....................             break; 
1A69C:  BRA    1A6AA
....................          case WMS4 : rst_step_vars_wms4(); 
1A69E:  GOTO   19E64
....................             break; 
1A6A2:  BRA    1A6AA
....................          case AWS : rst_step_vars_aws(); 
1A6A4:  BRA    1A110
....................             break;             
1A6A6:  BRA    1A6AA
....................          case WMS2 : rst_step_vars_wms2(); 
1A6A8:  BRA    1A3AA
....................             break; 
....................       } 
....................    }  
1A6AA:  BRA    1A6B0
....................    else cmd_arg(); 
1A6AC:  CALL   AF7A
1A6B0:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1A6B4:  MOVF   47,F
1A6B6:  BTFSS  FD8.2
1A6B8:  BRA    1A7BA
1A6BA:  MOVF   46,W
1A6BC:  SUBLW  00
1A6BE:  BTFSS  FD8.0
1A6C0:  BRA    1A7BA
....................       m_spr[motor] = arg; 
1A6C2:  BCF    FD8.0
1A6C4:  MOVLB  7
1A6C6:  RLCF   x3C,W
1A6C8:  CLRF   03
1A6CA:  ADDLW  72
1A6CC:  MOVWF  FE9
1A6CE:  MOVLW  07
1A6D0:  ADDWFC 03,W
1A6D2:  MOVWF  FEA
1A6D4:  MOVFF  44,FEF
1A6D8:  MOVFF  45,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1A6DC:  BCF    FD8.0
1A6DE:  RLCF   x3C,W
1A6E0:  CLRF   03
1A6E2:  ADDLW  A7
1A6E4:  MOVWF  01
1A6E6:  MOVLW  07
1A6E8:  ADDWFC 03,F
1A6EA:  MOVFF  01,861
1A6EE:  MOVLB  8
1A6F0:  MOVFF  03,862
1A6F4:  BCF    FD8.0
1A6F6:  MOVLB  7
1A6F8:  RLCF   x3C,W
1A6FA:  CLRF   03
1A6FC:  ADDLW  72
1A6FE:  MOVWF  FE9
1A700:  MOVLW  07
1A702:  ADDWFC 03,W
1A704:  MOVWF  FEA
1A706:  MOVFF  FEC,8B8
1A70A:  MOVF   FED,F
1A70C:  MOVFF  FEF,8B7
1A710:  BCF    FD8.0
1A712:  RLCF   x3C,W
1A714:  CLRF   03
1A716:  ADDLW  5E
1A718:  MOVWF  FE9
1A71A:  MOVLW  07
1A71C:  ADDWFC 03,W
1A71E:  MOVWF  FEA
1A720:  MOVFF  FEC,03
1A724:  MOVF   FED,F
1A726:  MOVFF  FEF,8B9
1A72A:  MOVFF  03,866
1A72E:  MOVFF  03,8BA
1A732:  MOVLB  0
1A734:  CALL   2C52
1A738:  MOVFF  02,864
1A73C:  BCF    FD8.0
1A73E:  MOVLB  8
1A740:  RLCF   01,W
1A742:  MOVWF  02
1A744:  RLCF   x64,W
1A746:  MOVFF  862,FEA
1A74A:  MOVFF  861,FE9
1A74E:  MOVWF  FEC
1A750:  MOVF   FED,F
1A752:  MOVFF  02,FEF
....................       switch(motor){ 
1A756:  MOVLB  7
1A758:  MOVF   x3C,W
1A75A:  XORLW  00
1A75C:  MOVLB  0
1A75E:  BZ    1A766
1A760:  XORLW  01
1A762:  BZ    1A790
1A764:  BRA    1A7B8
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1A766:  BCF    FD8.0
1A768:  MOVLB  7
1A76A:  RLCF   x3C,W
1A76C:  CLRF   03
1A76E:  ADDLW  72
1A770:  MOVWF  FE9
1A772:  MOVLW  07
1A774:  ADDWFC 03,W
1A776:  MOVWF  FEA
1A778:  MOVFF  FEC,8CC
1A77C:  MOVF   FED,F
1A77E:  MOVFF  FEF,8CB
1A782:  MOVLW  AE
1A784:  MOVLB  8
1A786:  MOVWF  xCA
1A788:  MOVLB  0
1A78A:  CALL   4F52
....................             break; 
1A78E:  BRA    1A7B8
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1A790:  BCF    FD8.0
1A792:  MOVLB  7
1A794:  RLCF   x3C,W
1A796:  CLRF   03
1A798:  ADDLW  72
1A79A:  MOVWF  FE9
1A79C:  MOVLW  07
1A79E:  ADDWFC 03,W
1A7A0:  MOVWF  FEA
1A7A2:  MOVFF  FEC,8CC
1A7A6:  MOVF   FED,F
1A7A8:  MOVFF  FEF,8CB
1A7AC:  MOVLW  B0
1A7AE:  MOVLB  8
1A7B0:  MOVWF  xCA
1A7B2:  MOVLB  0
1A7B4:  CALL   4F52
....................             break;             
....................       } 
....................    } 
1A7B8:  BRA    1A7BE
....................    else cmd_arg();    
1A7BA:  CALL   AF7A
1A7BE:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1A7C2:  MOVF   47,F
1A7C4:  BNZ   1A850
1A7C6:  MOVF   46,F
1A7C8:  BNZ   1A850
1A7CA:  MOVF   45,F
1A7CC:  BNZ   1A850
1A7CE:  MOVF   44,W
1A7D0:  SUBLW  02
1A7D2:  BNC   1A850
....................       e_type[motor] = arg; 
1A7D4:  BCF    FD8.0
1A7D6:  MOVLB  7
1A7D8:  RLCF   x3C,W
1A7DA:  CLRF   03
1A7DC:  ADDLW  66
1A7DE:  MOVWF  FE9
1A7E0:  MOVLW  07
1A7E2:  ADDWFC 03,W
1A7E4:  MOVWF  FEA
1A7E6:  MOVFF  44,FEF
1A7EA:  MOVFF  45,FEC
....................       switch(motor){ 
1A7EE:  MOVF   x3C,W
1A7F0:  XORLW  00
1A7F2:  MOVLB  0
1A7F4:  BZ    1A7FC
1A7F6:  XORLW  01
1A7F8:  BZ    1A826
1A7FA:  BRA    1A84E
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1A7FC:  BCF    FD8.0
1A7FE:  MOVLB  7
1A800:  RLCF   x3C,W
1A802:  CLRF   03
1A804:  ADDLW  66
1A806:  MOVWF  FE9
1A808:  MOVLW  07
1A80A:  ADDWFC 03,W
1A80C:  MOVWF  FEA
1A80E:  MOVFF  FEC,8CC
1A812:  MOVF   FED,F
1A814:  MOVFF  FEF,8CB
1A818:  MOVLW  7A
1A81A:  MOVLB  8
1A81C:  MOVWF  xCA
1A81E:  MOVLB  0
1A820:  CALL   4F52
....................             break; 
1A824:  BRA    1A84E
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1A826:  BCF    FD8.0
1A828:  MOVLB  7
1A82A:  RLCF   x3C,W
1A82C:  CLRF   03
1A82E:  ADDLW  66
1A830:  MOVWF  FE9
1A832:  MOVLW  07
1A834:  ADDWFC 03,W
1A836:  MOVWF  FEA
1A838:  MOVFF  FEC,8CC
1A83C:  MOVF   FED,F
1A83E:  MOVFF  FEF,8CB
1A842:  MOVLW  7C
1A844:  MOVLB  8
1A846:  MOVWF  xCA
1A848:  MOVLB  0
1A84A:  CALL   4F52
....................             break;             
....................       } 
....................    } 
1A84E:  BRA    1A854
....................    else cmd_arg();    
1A850:  CALL   AF7A
1A854:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1A890:  MOVF   47,F
1A892:  BNZ   1A95C
1A894:  MOVF   46,F
1A896:  BNZ   1A95C
1A898:  MOVF   45,F
1A89A:  BNZ   1A95C
1A89C:  MOVF   44,W
1A89E:  SUBLW  64
1A8A0:  BNC   1A95C
....................       drive_pc=arg; 
1A8A2:  MOVFF  45,862
1A8A6:  MOVFF  44,861
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1A8AA:  BCF    FD8.0
1A8AC:  MOVLB  7
1A8AE:  RLCF   x3C,W
1A8B0:  CLRF   03
1A8B2:  ADDLW  52
1A8B4:  MOVWF  FE9
1A8B6:  MOVLW  07
1A8B8:  ADDWFC 03,W
1A8BA:  MOVWF  FEA
1A8BC:  MOVFF  862,9E9
1A8C0:  MOVFF  861,9E8
1A8C4:  MOVLW  01
1A8C6:  MOVLB  9
1A8C8:  MOVWF  xEB
1A8CA:  SETF   xEA
1A8CC:  MOVLB  0
1A8CE:  CALL   5C22
1A8D2:  MOVFF  02,866
1A8D6:  MOVFF  01,865
1A8DA:  MOVFF  02,8B8
1A8DE:  MOVFF  01,8B7
1A8E2:  MOVLB  8
1A8E4:  CLRF   xBA
1A8E6:  MOVLW  64
1A8E8:  MOVWF  xB9
1A8EA:  MOVLB  0
1A8EC:  CALL   2C52
1A8F0:  MOVFF  01,FEF
1A8F4:  MOVFF  02,FEC
....................       switch(motor){ 
1A8F8:  MOVLB  7
1A8FA:  MOVF   x3C,W
1A8FC:  XORLW  00
1A8FE:  MOVLB  0
1A900:  BZ    1A908
1A902:  XORLW  01
1A904:  BZ    1A932
1A906:  BRA    1A95A
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1A908:  BCF    FD8.0
1A90A:  MOVLB  7
1A90C:  RLCF   x3C,W
1A90E:  CLRF   03
1A910:  ADDLW  52
1A912:  MOVWF  FE9
1A914:  MOVLW  07
1A916:  ADDWFC 03,W
1A918:  MOVWF  FEA
1A91A:  MOVFF  FEC,8CC
1A91E:  MOVF   FED,F
1A920:  MOVFF  FEF,8CB
1A924:  MOVLW  9A
1A926:  MOVLB  8
1A928:  MOVWF  xCA
1A92A:  MOVLB  0
1A92C:  CALL   4F52
....................             break; 
1A930:  BRA    1A95A
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1A932:  BCF    FD8.0
1A934:  MOVLB  7
1A936:  RLCF   x3C,W
1A938:  CLRF   03
1A93A:  ADDLW  52
1A93C:  MOVWF  FE9
1A93E:  MOVLW  07
1A940:  ADDWFC 03,W
1A942:  MOVWF  FEA
1A944:  MOVFF  FEC,8CC
1A948:  MOVF   FED,F
1A94A:  MOVFF  FEF,8CB
1A94E:  MOVLW  9C
1A950:  MOVLB  8
1A952:  MOVWF  xCA
1A954:  MOVLB  0
1A956:  CALL   4F52
....................             break;             
....................       } 
....................    } 
1A95A:  BRA    1A960
....................    else cmd_arg();    
1A95C:  CALL   AF7A
1A960:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1A964:  MOVF   47,F
1A966:  BNZ   1A9F6
1A968:  MOVF   46,F
1A96A:  BNZ   1A9F6
1A96C:  MOVF   45,W
1A96E:  SUBLW  27
1A970:  BNC   1A9F6
1A972:  BNZ   1A97A
1A974:  MOVF   44,W
1A976:  SUBLW  0F
1A978:  BNC   1A9F6
....................        align_os[motor] = arg; 
1A97A:  BCF    FD8.0
1A97C:  MOVLB  7
1A97E:  RLCF   x3C,W
1A980:  CLRF   03
1A982:  ADDLW  7E
1A984:  MOVWF  FE9
1A986:  MOVLW  07
1A988:  ADDWFC 03,W
1A98A:  MOVWF  FEA
1A98C:  MOVFF  44,FEF
1A990:  MOVFF  45,FEC
....................        switch(motor){ 
1A994:  MOVF   x3C,W
1A996:  XORLW  00
1A998:  MOVLB  0
1A99A:  BZ    1A9A2
1A99C:  XORLW  01
1A99E:  BZ    1A9CC
1A9A0:  BRA    1A9F4
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1A9A2:  BCF    FD8.0
1A9A4:  MOVLB  7
1A9A6:  RLCF   x3C,W
1A9A8:  CLRF   03
1A9AA:  ADDLW  7E
1A9AC:  MOVWF  FE9
1A9AE:  MOVLW  07
1A9B0:  ADDWFC 03,W
1A9B2:  MOVWF  FEA
1A9B4:  MOVFF  FEC,8CC
1A9B8:  MOVF   FED,F
1A9BA:  MOVFF  FEF,8CB
1A9BE:  MOVLW  C2
1A9C0:  MOVLB  8
1A9C2:  MOVWF  xCA
1A9C4:  MOVLB  0
1A9C6:  CALL   4F52
....................             break; 
1A9CA:  BRA    1A9F4
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1A9CC:  BCF    FD8.0
1A9CE:  MOVLB  7
1A9D0:  RLCF   x3C,W
1A9D2:  CLRF   03
1A9D4:  ADDLW  7E
1A9D6:  MOVWF  FE9
1A9D8:  MOVLW  07
1A9DA:  ADDWFC 03,W
1A9DC:  MOVWF  FEA
1A9DE:  MOVFF  FEC,8CC
1A9E2:  MOVF   FED,F
1A9E4:  MOVFF  FEF,8CB
1A9E8:  MOVLW  C4
1A9EA:  MOVLB  8
1A9EC:  MOVWF  xCA
1A9EE:  MOVLB  0
1A9F0:  CALL   4F52
....................             break;             
....................       } 
....................    } 
1A9F4:  BRA    1A9FA
....................    else cmd_arg();    
1A9F6:  CALL   AF7A
1A9FA:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1A9FE:  MOVF   47,F
1AA00:  BNZ   1AA8C
1AA02:  MOVF   46,F
1AA04:  BNZ   1AA8C
1AA06:  MOVF   45,F
1AA08:  BNZ   1AA8C
1AA0A:  MOVF   44,W
1AA0C:  SUBLW  01
1AA0E:  BNC   1AA8C
....................       m_ctrl[motor] = arg; 
1AA10:  BCF    FD8.0
1AA12:  MOVLB  7
1AA14:  RLCF   x3C,W
1AA16:  CLRF   03
1AA18:  ADDLW  3E
1AA1A:  MOVWF  FE9
1AA1C:  MOVLW  07
1AA1E:  ADDWFC 03,W
1AA20:  MOVWF  FEA
1AA22:  MOVFF  44,FEF
1AA26:  MOVFF  45,FEC
....................       switch(motor){ 
1AA2A:  MOVF   x3C,W
1AA2C:  XORLW  00
1AA2E:  MOVLB  0
1AA30:  BZ    1AA38
1AA32:  XORLW  01
1AA34:  BZ    1AA62
1AA36:  BRA    1AA8A
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1AA38:  BCF    FD8.0
1AA3A:  MOVLB  7
1AA3C:  RLCF   x3C,W
1AA3E:  CLRF   03
1AA40:  ADDLW  3E
1AA42:  MOVWF  FE9
1AA44:  MOVLW  07
1AA46:  ADDWFC 03,W
1AA48:  MOVWF  FEA
1AA4A:  MOVFF  FEC,8CC
1AA4E:  MOVF   FED,F
1AA50:  MOVFF  FEF,8CB
1AA54:  MOVLW  86
1AA56:  MOVLB  8
1AA58:  MOVWF  xCA
1AA5A:  MOVLB  0
1AA5C:  CALL   4F52
....................             break; 
1AA60:  BRA    1AA8A
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1AA62:  BCF    FD8.0
1AA64:  MOVLB  7
1AA66:  RLCF   x3C,W
1AA68:  CLRF   03
1AA6A:  ADDLW  3E
1AA6C:  MOVWF  FE9
1AA6E:  MOVLW  07
1AA70:  ADDWFC 03,W
1AA72:  MOVWF  FEA
1AA74:  MOVFF  FEC,8CC
1AA78:  MOVF   FED,F
1AA7A:  MOVFF  FEF,8CB
1AA7E:  MOVLW  88
1AA80:  MOVLB  8
1AA82:  MOVWF  xCA
1AA84:  MOVLB  0
1AA86:  CALL   4F52
....................             break;             
....................       } 
....................    } 
1AA8A:  BRA    1AA90
....................    else cmd_arg();    
1AA8C:  CALL   AF7A
1AA90:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1A858:  MOVF   44,W
1A85A:  MOVWF  00
1A85C:  MOVF   45,W
1A85E:  MOVWF  03
1A860:  BNZ   1A868
1A862:  MOVLW  01
1A864:  SUBWF  00,W
1A866:  BZ    1A874
1A868:  MOVF   03,W
1A86A:  BNZ   1A872
1A86C:  MOVLW  02
1A86E:  SUBWF  00,W
1A870:  BZ    1A87A
1A872:  BRA    1A884
....................       case 1: motor = 0; 
1A874:  MOVLB  7
1A876:  CLRF   x3C
....................          break; 
1A878:  BRA    1A88A
....................       case 2: motor = 1; 
1A87A:  MOVLW  01
1A87C:  MOVLB  7
1A87E:  MOVWF  x3C
....................          break; 
1A880:  BRA    1A88A
1A882:  MOVLB  0
....................       default : cmd_arg(); 
1A884:  CALL   AF7A
....................          break; 
1A888:  MOVLB  7
....................    } 
1A88A:  MOVLB  0
1A88C:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1AA94:  MOVF   44,F
1AA96:  BNZ   1AAA4
1AA98:  MOVF   45,F
1AA9A:  BNZ   1AAA4
1AA9C:  MOVF   46,F
1AA9E:  BNZ   1AAA4
1AAA0:  MOVF   47,F
1AAA2:  BZ    1AB02
1AAA4:  MOVF   47,F
1AAA6:  BNZ   1AB02
1AAA8:  MOVF   46,F
1AAAA:  BNZ   1AB02
1AAAC:  MOVF   45,F
1AAAE:  BNZ   1AB02
1AAB0:  MOVF   44,W
1AAB2:  SUBLW  02
1AAB4:  BNC   1AB02
....................       switch(arg){ 
1AAB6:  MOVFF  44,00
1AABA:  MOVF   45,W
1AABC:  MOVWF  03
1AABE:  BNZ   1AAC6
1AAC0:  MOVLW  01
1AAC2:  SUBWF  00,W
1AAC4:  BZ    1AAD2
1AAC6:  MOVF   03,W
1AAC8:  BNZ   1AAD0
1AACA:  MOVLW  02
1AACC:  SUBWF  00,W
1AACE:  BZ    1AAEA
1AAD0:  BRA    1AB00
....................          case 1 : e_pos[0] = 0; 
1AAD2:  MOVLB  7
1AAD4:  CLRF   xBC
1AAD6:  CLRF   xBB
....................                   write16(ADDR_E1_POS, 0); 
1AAD8:  MOVLW  7E
1AADA:  MOVLB  8
1AADC:  MOVWF  xCA
1AADE:  CLRF   xCC
1AAE0:  CLRF   xCB
1AAE2:  MOVLB  0
1AAE4:  CALL   4F52
....................             break; 
1AAE8:  BRA    1AB00
....................          case 2 : e_pos[1] = 0; 
1AAEA:  MOVLB  7
1AAEC:  CLRF   xBE
1AAEE:  CLRF   xBD
....................                   write16(ADDR_E2_POS, 0); 
1AAF0:  MOVLW  80
1AAF2:  MOVLB  8
1AAF4:  MOVWF  xCA
1AAF6:  CLRF   xCC
1AAF8:  CLRF   xCB
1AAFA:  MOVLB  0
1AAFC:  CALL   4F52
....................             break;             
....................       } 
....................    } 
1AB00:  BRA    1AB06
....................    else cmd_arg();  
1AB02:  CALL   AF7A
1AB06:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
18C9E:  DECFSZ 44,W
18CA0:  GOTO   198F6
18CA4:  MOVF   45,F
18CA6:  BTFSS  FD8.2
18CA8:  GOTO   198F6
18CAC:  MOVF   46,F
18CAE:  BTFSS  FD8.2
18CB0:  GOTO   198F6
18CB4:  MOVF   47,F
18CB6:  BTFSS  FD8.2
18CB8:  GOTO   198F6
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18CBC:  MOVFF  74F,9E9
18CC0:  MOVFF  74E,9E8
18CC4:  MOVLB  9
18CC6:  CLRF   xEB
18CC8:  MOVLW  64
18CCA:  MOVWF  xEA
18CCC:  MOVLB  0
18CCE:  CALL   5C22
18CD2:  MOVFF  02,868
18CD6:  MOVFF  01,867
18CDA:  MOVFF  02,8B8
18CDE:  MOVFF  01,8B7
18CE2:  MOVLW  01
18CE4:  MOVLB  8
18CE6:  MOVWF  xBA
18CE8:  SETF   xB9
18CEA:  MOVLB  0
18CEC:  CALL   2C52
18CF0:  MOVFF  02,862
18CF4:  MOVFF  01,861
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18CF8:  MOVFF  753,9E9
18CFC:  MOVFF  752,9E8
18D00:  MOVLB  9
18D02:  CLRF   xEB
18D04:  MOVLW  64
18D06:  MOVWF  xEA
18D08:  MOVLB  0
18D0A:  CALL   5C22
18D0E:  MOVFF  02,868
18D12:  MOVFF  01,867
18D16:  MOVFF  02,8B8
18D1A:  MOVFF  01,8B7
18D1E:  MOVLW  01
18D20:  MOVLB  8
18D22:  MOVWF  xBA
18D24:  SETF   xB9
18D26:  MOVLB  0
18D28:  CALL   2C52
18D2C:  MOVFF  02,864
18D30:  MOVFF  01,863
....................       step_us  =   m_stp_int[0]*100; 
18D34:  MOVFF  747,9E9
18D38:  MOVFF  746,9E8
18D3C:  MOVLB  9
18D3E:  CLRF   xEB
18D40:  MOVLW  64
18D42:  MOVWF  xEA
18D44:  MOVLB  0
18D46:  CALL   5C22
18D4A:  MOVFF  02,866
18D4E:  MOVFF  01,865
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
18D52:  MOVLW  FC
18D54:  MOVWF  FF6
18D56:  MOVLW  26
18D58:  MOVWF  FF7
18D5A:  MOVLW  00
18D5C:  MOVWF  FF8
18D5E:  CLRF   1B
18D60:  BTFSC  FF2.7
18D62:  BSF    1B.7
18D64:  BCF    FF2.7
18D66:  CALL   0E30
18D6A:  BTFSC  1B.7
18D6C:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
18D6E:  MOVLW  62
18D70:  BTFSS  F9E.4
18D72:  BRA    18D70
18D74:  MOVWF  FAD
18D76:  MOVLW  3A
18D78:  BTFSS  F9E.4
18D7A:  BRA    18D78
18D7C:  MOVWF  FAD
18D7E:  MOVLW  10
18D80:  MOVWF  FE9
18D82:  CLRF   1B
18D84:  BTFSC  FF2.7
18D86:  BSF    1B.7
18D88:  BCF    FF2.7
18D8A:  MOVFF  76F,A19
18D8E:  MOVFF  76E,A18
18D92:  CALL   1188
18D96:  BTFSC  1B.7
18D98:  BSF    FF2.7
18D9A:  MOVLW  0D
18D9C:  BTFSS  F9E.4
18D9E:  BRA    18D9C
18DA0:  MOVWF  FAD
18DA2:  MOVLW  0A
18DA4:  BTFSS  F9E.4
18DA6:  BRA    18DA4
18DA8:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
18DAA:  MOVLW  63
18DAC:  BTFSS  F9E.4
18DAE:  BRA    18DAC
18DB0:  MOVWF  FAD
18DB2:  MOVLW  3A
18DB4:  BTFSS  F9E.4
18DB6:  BRA    18DB4
18DB8:  MOVWF  FAD
18DBA:  MOVLW  41
18DBC:  MOVWF  FE9
18DBE:  CLRF   1B
18DC0:  BTFSC  FF2.7
18DC2:  BSF    1B.7
18DC4:  BCF    FF2.7
18DC6:  MOVFF  7A1,A1B
18DCA:  MOVFF  7A0,A1A
18DCE:  MOVFF  79F,A19
18DD2:  MOVFF  79E,A18
18DD6:  CALL   10CC
18DDA:  BTFSC  1B.7
18DDC:  BSF    FF2.7
18DDE:  MOVLW  2F
18DE0:  BTFSS  F9E.4
18DE2:  BRA    18DE0
18DE4:  MOVWF  FAD
18DE6:  MOVLW  10
18DE8:  MOVWF  FE9
18DEA:  CLRF   1B
18DEC:  BTFSC  FF2.7
18DEE:  BSF    1B.7
18DF0:  BCF    FF2.7
18DF2:  MOVFF  7B8,A19
18DF6:  MOVFF  7B7,A18
18DFA:  CALL   1188
18DFE:  BTFSC  1B.7
18E00:  BSF    FF2.7
18E02:  MOVLW  2F
18E04:  BTFSS  F9E.4
18E06:  BRA    18E04
18E08:  MOVWF  FAD
18E0A:  MOVLW  10
18E0C:  MOVWF  FE9
18E0E:  CLRF   1B
18E10:  BTFSC  FF2.7
18E12:  BSF    1B.7
18E14:  BCF    FF2.7
18E16:  MOVFF  7BC,A19
18E1A:  MOVFF  7BB,A18
18E1E:  CALL   1188
18E22:  BTFSC  1B.7
18E24:  BSF    FF2.7
18E26:  MOVLW  0D
18E28:  BTFSS  F9E.4
18E2A:  BRA    18E28
18E2C:  MOVWF  FAD
18E2E:  MOVLW  0A
18E30:  BTFSS  F9E.4
18E32:  BRA    18E30
18E34:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
18E36:  MOVLW  64
18E38:  BTFSS  F9E.4
18E3A:  BRA    18E38
18E3C:  MOVWF  FAD
18E3E:  MOVLW  3A
18E40:  BTFSS  F9E.4
18E42:  BRA    18E40
18E44:  MOVWF  FAD
18E46:  MOVLW  10
18E48:  MOVWF  FE9
18E4A:  CLRF   1B
18E4C:  BTFSC  FF2.7
18E4E:  BSF    1B.7
18E50:  BCF    FF2.7
18E52:  MOVFF  74B,A19
18E56:  MOVFF  74A,A18
18E5A:  CALL   1188
18E5E:  BTFSC  1B.7
18E60:  BSF    FF2.7
18E62:  MOVLW  0D
18E64:  BTFSS  F9E.4
18E66:  BRA    18E64
18E68:  MOVWF  FAD
18E6A:  MOVLW  0A
18E6C:  BTFSS  F9E.4
18E6E:  BRA    18E6C
18E70:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
18E72:  MOVLW  65
18E74:  BTFSS  F9E.4
18E76:  BRA    18E74
18E78:  MOVWF  FAD
18E7A:  MOVLW  3A
18E7C:  BTFSS  F9E.4
18E7E:  BRA    18E7C
18E80:  MOVWF  FAD
18E82:  MOVLW  10
18E84:  MOVWF  FE9
18E86:  CLRF   1B
18E88:  BTFSC  FF2.7
18E8A:  BSF    1B.7
18E8C:  BCF    FF2.7
18E8E:  MOVFF  75B,A19
18E92:  MOVFF  75A,A18
18E96:  CALL   1188
18E9A:  BTFSC  1B.7
18E9C:  BSF    FF2.7
18E9E:  MOVLW  0D
18EA0:  BTFSS  F9E.4
18EA2:  BRA    18EA0
18EA4:  MOVWF  FAD
18EA6:  MOVLW  0A
18EA8:  BTFSS  F9E.4
18EAA:  BRA    18EA8
18EAC:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
18EAE:  MOVLW  66
18EB0:  BTFSS  F9E.4
18EB2:  BRA    18EB0
18EB4:  MOVWF  FAD
18EB6:  MOVLW  3A
18EB8:  BTFSS  F9E.4
18EBA:  BRA    18EB8
18EBC:  MOVWF  FAD
18EBE:  CLRF   1B
18EC0:  BTFSC  FF2.7
18EC2:  BSF    1B.7
18EC4:  BCF    FF2.7
18EC6:  MOVFF  73D,A18
18ECA:  MOVLW  1B
18ECC:  MOVLB  A
18ECE:  MOVWF  x19
18ED0:  MOVLB  0
18ED2:  CALL   0F88
18ED6:  BTFSC  1B.7
18ED8:  BSF    FF2.7
18EDA:  MOVLW  0D
18EDC:  BTFSS  F9E.4
18EDE:  BRA    18EDC
18EE0:  MOVWF  FAD
18EE2:  MOVLW  0A
18EE4:  BTFSS  F9E.4
18EE6:  BRA    18EE4
18EE8:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
18EEA:  MOVLW  67
18EEC:  BTFSS  F9E.4
18EEE:  BRA    18EEC
18EF0:  MOVWF  FAD
18EF2:  MOVLW  3A
18EF4:  BTFSS  F9E.4
18EF6:  BRA    18EF4
18EF8:  MOVWF  FAD
18EFA:  MOVLW  10
18EFC:  MOVWF  FE9
18EFE:  CLRF   1B
18F00:  BTFSC  FF2.7
18F02:  BSF    1B.7
18F04:  BCF    FF2.7
18F06:  MOVFF  757,A19
18F0A:  MOVFF  756,A18
18F0E:  CALL   1188
18F12:  BTFSC  1B.7
18F14:  BSF    FF2.7
18F16:  MOVLW  0D
18F18:  BTFSS  F9E.4
18F1A:  BRA    18F18
18F1C:  MOVWF  FAD
18F1E:  MOVLW  0A
18F20:  BTFSS  F9E.4
18F22:  BRA    18F20
18F24:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
18F26:  MOVLW  68
18F28:  BTFSS  F9E.4
18F2A:  BRA    18F28
18F2C:  MOVWF  FAD
18F2E:  MOVLW  3A
18F30:  BTFSS  F9E.4
18F32:  BRA    18F30
18F34:  MOVWF  FAD
18F36:  MOVLW  10
18F38:  MOVWF  FE9
18F3A:  CLRF   1B
18F3C:  BTFSC  FF2.7
18F3E:  BSF    1B.7
18F40:  BCF    FF2.7
18F42:  MOVFF  862,A19
18F46:  MOVFF  861,A18
18F4A:  CALL   1188
18F4E:  BTFSC  1B.7
18F50:  BSF    FF2.7
18F52:  MOVLW  0D
18F54:  BTFSS  F9E.4
18F56:  BRA    18F54
18F58:  MOVWF  FAD
18F5A:  MOVLW  0A
18F5C:  BTFSS  F9E.4
18F5E:  BRA    18F5C
18F60:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
18F62:  MOVLW  69
18F64:  BTFSS  F9E.4
18F66:  BRA    18F64
18F68:  MOVWF  FAD
18F6A:  MOVLW  3A
18F6C:  BTFSS  F9E.4
18F6E:  BRA    18F6C
18F70:  MOVWF  FAD
18F72:  MOVLW  10
18F74:  MOVWF  FE9
18F76:  CLRF   1B
18F78:  BTFSC  FF2.7
18F7A:  BSF    1B.7
18F7C:  BCF    FF2.7
18F7E:  MOVFF  866,A19
18F82:  MOVFF  865,A18
18F86:  CALL   1188
18F8A:  BTFSC  1B.7
18F8C:  BSF    FF2.7
18F8E:  MOVLW  0D
18F90:  BTFSS  F9E.4
18F92:  BRA    18F90
18F94:  MOVWF  FAD
18F96:  MOVLW  0A
18F98:  BTFSS  F9E.4
18F9A:  BRA    18F98
18F9C:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
18F9E:  MOVLW  6A
18FA0:  BTFSS  F9E.4
18FA2:  BRA    18FA0
18FA4:  MOVWF  FAD
18FA6:  MOVLW  3A
18FA8:  BTFSS  F9E.4
18FAA:  BRA    18FA8
18FAC:  MOVWF  FAD
18FAE:  MOVLW  10
18FB0:  MOVWF  FE9
18FB2:  CLRF   1B
18FB4:  BTFSC  FF2.7
18FB6:  BSF    1B.7
18FB8:  BCF    FF2.7
18FBA:  MOVFF  76B,A19
18FBE:  MOVFF  76A,A18
18FC2:  CALL   1188
18FC6:  BTFSC  1B.7
18FC8:  BSF    FF2.7
18FCA:  MOVLW  0D
18FCC:  BTFSS  F9E.4
18FCE:  BRA    18FCC
18FD0:  MOVWF  FAD
18FD2:  MOVLW  0A
18FD4:  BTFSS  F9E.4
18FD6:  BRA    18FD4
18FD8:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
18FDA:  MOVLW  6B
18FDC:  BTFSS  F9E.4
18FDE:  BRA    18FDC
18FE0:  MOVWF  FAD
18FE2:  MOVLW  3A
18FE4:  BTFSS  F9E.4
18FE6:  BRA    18FE4
18FE8:  MOVWF  FAD
18FEA:  MOVLW  10
18FEC:  MOVWF  FE9
18FEE:  CLRF   1B
18FF0:  BTFSC  FF2.7
18FF2:  BSF    1B.7
18FF4:  BCF    FF2.7
18FF6:  MOVFF  763,A19
18FFA:  MOVFF  762,A18
18FFE:  CALL   1188
19002:  BTFSC  1B.7
19004:  BSF    FF2.7
19006:  MOVLW  0D
19008:  BTFSS  F9E.4
1900A:  BRA    19008
1900C:  MOVWF  FAD
1900E:  MOVLW  0A
19010:  BTFSS  F9E.4
19012:  BRA    19010
19014:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
19016:  MOVLW  6D
19018:  BTFSS  F9E.4
1901A:  BRA    19018
1901C:  MOVWF  FAD
1901E:  MOVLW  3A
19020:  BTFSS  F9E.4
19022:  BRA    19020
19024:  MOVWF  FAD
19026:  MOVLW  10
19028:  MOVWF  FE9
1902A:  CLRF   1B
1902C:  BTFSC  FF2.7
1902E:  BSF    1B.7
19030:  BCF    FF2.7
19032:  MOVFF  743,A19
19036:  MOVFF  742,A18
1903A:  CALL   1188
1903E:  BTFSC  1B.7
19040:  BSF    FF2.7
19042:  MOVLW  0D
19044:  BTFSS  F9E.4
19046:  BRA    19044
19048:  MOVWF  FAD
1904A:  MOVLW  0A
1904C:  BTFSS  F9E.4
1904E:  BRA    1904C
19050:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
19052:  MOVLW  6E
19054:  BTFSS  F9E.4
19056:  BRA    19054
19058:  MOVWF  FAD
1905A:  MOVLW  3A
1905C:  BTFSS  F9E.4
1905E:  BRA    1905C
19060:  MOVWF  FAD
19062:  MOVLW  10
19064:  MOVWF  FE9
19066:  CLRF   1B
19068:  BTFSC  FF2.7
1906A:  BSF    1B.7
1906C:  BCF    FF2.7
1906E:  MOVFF  777,A19
19072:  MOVFF  776,A18
19076:  CALL   1188
1907A:  BTFSC  1B.7
1907C:  BSF    FF2.7
1907E:  MOVLW  0D
19080:  BTFSS  F9E.4
19082:  BRA    19080
19084:  MOVWF  FAD
19086:  MOVLW  0A
19088:  BTFSS  F9E.4
1908A:  BRA    19088
1908C:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
1908E:  MOVLW  6F
19090:  BTFSS  F9E.4
19092:  BRA    19090
19094:  MOVWF  FAD
19096:  MOVLW  3A
19098:  BTFSS  F9E.4
1909A:  BRA    19098
1909C:  MOVWF  FAD
1909E:  MOVLW  10
190A0:  MOVWF  FE9
190A2:  CLRF   1B
190A4:  BTFSC  FF2.7
190A6:  BSF    1B.7
190A8:  BCF    FF2.7
190AA:  MOVFF  77B,A19
190AE:  MOVFF  77A,A18
190B2:  CALL   1188
190B6:  BTFSC  1B.7
190B8:  BSF    FF2.7
190BA:  MOVLW  0D
190BC:  BTFSS  F9E.4
190BE:  BRA    190BC
190C0:  MOVWF  FAD
190C2:  MOVLW  0A
190C4:  BTFSS  F9E.4
190C6:  BRA    190C4
190C8:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
190CA:  MOVLW  70
190CC:  BTFSS  F9E.4
190CE:  BRA    190CC
190D0:  MOVWF  FAD
190D2:  MOVLW  3A
190D4:  BTFSS  F9E.4
190D6:  BRA    190D4
190D8:  MOVWF  FAD
190DA:  MOVLW  10
190DC:  MOVWF  FE9
190DE:  CLRF   1B
190E0:  BTFSC  FF2.7
190E2:  BSF    1B.7
190E4:  BCF    FF2.7
190E6:  MOVFF  7C0,A19
190EA:  MOVFF  7BF,A18
190EE:  CALL   1188
190F2:  BTFSC  1B.7
190F4:  BSF    FF2.7
190F6:  MOVLW  2F
190F8:  BTFSS  F9E.4
190FA:  BRA    190F8
190FC:  MOVWF  FAD
190FE:  MOVLW  10
19100:  MOVWF  FE9
19102:  CLRF   1B
19104:  BTFSC  FF2.7
19106:  BSF    1B.7
19108:  BCF    FF2.7
1910A:  MOVFF  75F,A19
1910E:  MOVFF  75E,A18
19112:  CALL   1188
19116:  BTFSC  1B.7
19118:  BSF    FF2.7
1911A:  MOVLW  0D
1911C:  BTFSS  F9E.4
1911E:  BRA    1911C
19120:  MOVWF  FAD
19122:  MOVLW  0A
19124:  BTFSS  F9E.4
19126:  BRA    19124
19128:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
1912A:  MOVLW  71
1912C:  BTFSS  F9E.4
1912E:  BRA    1912C
19130:  MOVWF  FAD
19132:  MOVLW  3A
19134:  BTFSS  F9E.4
19136:  BRA    19134
19138:  MOVWF  FAD
1913A:  MOVLW  10
1913C:  MOVWF  FE9
1913E:  CLRF   1B
19140:  BTFSC  FF2.7
19142:  BSF    1B.7
19144:  BCF    FF2.7
19146:  MOVFF  793,A19
1914A:  MOVFF  792,A18
1914E:  CALL   1188
19152:  BTFSC  1B.7
19154:  BSF    FF2.7
19156:  MOVLW  0D
19158:  BTFSS  F9E.4
1915A:  BRA    19158
1915C:  MOVWF  FAD
1915E:  MOVLW  0A
19160:  BTFSS  F9E.4
19162:  BRA    19160
19164:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
19166:  MOVLW  73
19168:  BTFSS  F9E.4
1916A:  BRA    19168
1916C:  MOVWF  FAD
1916E:  MOVLW  3A
19170:  BTFSS  F9E.4
19172:  BRA    19170
19174:  MOVWF  FAD
19176:  MOVLW  10
19178:  MOVWF  FE9
1917A:  CLRF   1B
1917C:  BTFSC  FF2.7
1917E:  BSF    1B.7
19180:  BCF    FF2.7
19182:  MOVFF  773,A19
19186:  MOVFF  772,A18
1918A:  CALL   1188
1918E:  BTFSC  1B.7
19190:  BSF    FF2.7
19192:  MOVLW  0D
19194:  BTFSS  F9E.4
19196:  BRA    19194
19198:  MOVWF  FAD
1919A:  MOVLW  0A
1919C:  BTFSS  F9E.4
1919E:  BRA    1919C
191A0:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
191A2:  MOVLW  74
191A4:  BTFSS  F9E.4
191A6:  BRA    191A4
191A8:  MOVWF  FAD
191AA:  MOVLW  3A
191AC:  BTFSS  F9E.4
191AE:  BRA    191AC
191B0:  MOVWF  FAD
191B2:  MOVLW  10
191B4:  MOVWF  FE9
191B6:  CLRF   1B
191B8:  BTFSC  FF2.7
191BA:  BSF    1B.7
191BC:  BCF    FF2.7
191BE:  MOVFF  767,A19
191C2:  MOVFF  766,A18
191C6:  CALL   1188
191CA:  BTFSC  1B.7
191CC:  BSF    FF2.7
191CE:  MOVLW  0D
191D0:  BTFSS  F9E.4
191D2:  BRA    191D0
191D4:  MOVWF  FAD
191D6:  MOVLW  0A
191D8:  BTFSS  F9E.4
191DA:  BRA    191D8
191DC:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
191DE:  MOVLW  01
191E0:  MOVLB  7
191E2:  ADDWF  x3C,W
191E4:  MOVLB  8
191E6:  MOVWF  x67
191E8:  MOVLW  75
191EA:  BTFSS  F9E.4
191EC:  BRA    191EA
191EE:  MOVWF  FAD
191F0:  MOVLW  3A
191F2:  BTFSS  F9E.4
191F4:  BRA    191F2
191F6:  MOVWF  FAD
191F8:  CLRF   1B
191FA:  BTFSC  FF2.7
191FC:  BSF    1B.7
191FE:  BCF    FF2.7
19200:  MOVFF  867,A18
19204:  MOVLW  1B
19206:  MOVLB  A
19208:  MOVWF  x19
1920A:  MOVLB  0
1920C:  CALL   0F88
19210:  BTFSC  1B.7
19212:  BSF    FF2.7
19214:  MOVLW  0D
19216:  BTFSS  F9E.4
19218:  BRA    19216
1921A:  MOVWF  FAD
1921C:  MOVLW  0A
1921E:  BTFSS  F9E.4
19220:  BRA    1921E
19222:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19224:  MOVLW  77
19226:  BTFSS  F9E.4
19228:  BRA    19226
1922A:  MOVWF  FAD
1922C:  MOVLW  3A
1922E:  BTFSS  F9E.4
19230:  BRA    1922E
19232:  MOVWF  FAD
19234:  MOVLW  10
19236:  MOVWF  FE9
19238:  CLRF   1B
1923A:  BTFSC  FF2.7
1923C:  BSF    1B.7
1923E:  BCF    FF2.7
19240:  MOVFF  864,A19
19244:  MOVFF  863,A18
19248:  CALL   1188
1924C:  BTFSC  1B.7
1924E:  BSF    FF2.7
19250:  MOVLW  0D
19252:  BTFSS  F9E.4
19254:  BRA    19252
19256:  MOVWF  FAD
19258:  MOVLW  0A
1925A:  BTFSS  F9E.4
1925C:  BRA    1925A
1925E:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
19260:  MOVLW  78
19262:  BTFSS  F9E.4
19264:  BRA    19262
19266:  MOVWF  FAD
19268:  MOVLW  3A
1926A:  BTFSS  F9E.4
1926C:  BRA    1926A
1926E:  MOVWF  FAD
19270:  MOVLW  10
19272:  MOVWF  FE9
19274:  CLRF   1B
19276:  BTFSC  FF2.7
19278:  BSF    1B.7
1927A:  BCF    FF2.7
1927C:  MOVFF  77F,A19
19280:  MOVFF  77E,A18
19284:  CALL   1188
19288:  BTFSC  1B.7
1928A:  BSF    FF2.7
1928C:  MOVLW  0D
1928E:  BTFSS  F9E.4
19290:  BRA    1928E
19292:  MOVWF  FAD
19294:  MOVLW  0A
19296:  BTFSS  F9E.4
19298:  BRA    19296
1929A:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
1929C:  MOVLW  79
1929E:  BTFSS  F9E.4
192A0:  BRA    1929E
192A2:  MOVWF  FAD
192A4:  MOVLW  3A
192A6:  BTFSS  F9E.4
192A8:  BRA    192A6
192AA:  MOVWF  FAD
192AC:  MOVLW  10
192AE:  MOVWF  FE9
192B0:  CLRF   1B
192B2:  BTFSC  FF2.7
192B4:  BSF    1B.7
192B6:  BCF    FF2.7
192B8:  MOVFF  73F,A19
192BC:  MOVFF  73E,A18
192C0:  CALL   1188
192C4:  BTFSC  1B.7
192C6:  BSF    FF2.7
192C8:  MOVLW  0D
192CA:  BTFSS  F9E.4
192CC:  BRA    192CA
192CE:  MOVWF  FAD
192D0:  MOVLW  0A
192D2:  BTFSS  F9E.4
192D4:  BRA    192D2
192D6:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
192D8:  MOVFF  751,9E9
192DC:  MOVFF  750,9E8
192E0:  MOVLB  9
192E2:  CLRF   xEB
192E4:  MOVLW  64
192E6:  MOVWF  xEA
192E8:  MOVLB  0
192EA:  CALL   5C22
192EE:  MOVFF  02,868
192F2:  MOVFF  01,867
192F6:  MOVFF  02,8B8
192FA:  MOVFF  01,8B7
192FE:  MOVLW  01
19300:  MOVLB  8
19302:  MOVWF  xBA
19304:  SETF   xB9
19306:  MOVLB  0
19308:  CALL   2C52
1930C:  MOVFF  02,862
19310:  MOVFF  01,861
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19314:  MOVFF  755,9E9
19318:  MOVFF  754,9E8
1931C:  MOVLB  9
1931E:  CLRF   xEB
19320:  MOVLW  64
19322:  MOVWF  xEA
19324:  MOVLB  0
19326:  CALL   5C22
1932A:  MOVFF  02,868
1932E:  MOVFF  01,867
19332:  MOVFF  02,8B8
19336:  MOVFF  01,8B7
1933A:  MOVLW  01
1933C:  MOVLB  8
1933E:  MOVWF  xBA
19340:  SETF   xB9
19342:  MOVLB  0
19344:  CALL   2C52
19348:  MOVFF  02,864
1934C:  MOVFF  01,863
....................       step_us  =   m_stp_int[1]*100; 
19350:  MOVFF  749,9E9
19354:  MOVFF  748,9E8
19358:  MOVLB  9
1935A:  CLRF   xEB
1935C:  MOVLW  64
1935E:  MOVWF  xEA
19360:  MOVLB  0
19362:  CALL   5C22
19366:  MOVFF  02,866
1936A:  MOVFF  01,865
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
1936E:  MOVLW  08
19370:  MOVWF  FF6
19372:  MOVLW  27
19374:  MOVWF  FF7
19376:  MOVLW  00
19378:  MOVWF  FF8
1937A:  CLRF   1B
1937C:  BTFSC  FF2.7
1937E:  BSF    1B.7
19380:  BCF    FF2.7
19382:  CALL   0E30
19386:  BTFSC  1B.7
19388:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
1938A:  MOVLW  62
1938C:  BTFSS  F9E.4
1938E:  BRA    1938C
19390:  MOVWF  FAD
19392:  MOVLW  3A
19394:  BTFSS  F9E.4
19396:  BRA    19394
19398:  MOVWF  FAD
1939A:  MOVLW  10
1939C:  MOVWF  FE9
1939E:  CLRF   1B
193A0:  BTFSC  FF2.7
193A2:  BSF    1B.7
193A4:  BCF    FF2.7
193A6:  MOVFF  771,A19
193AA:  MOVFF  770,A18
193AE:  CALL   1188
193B2:  BTFSC  1B.7
193B4:  BSF    FF2.7
193B6:  MOVLW  0D
193B8:  BTFSS  F9E.4
193BA:  BRA    193B8
193BC:  MOVWF  FAD
193BE:  MOVLW  0A
193C0:  BTFSS  F9E.4
193C2:  BRA    193C0
193C4:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
193C6:  MOVLW  63
193C8:  BTFSS  F9E.4
193CA:  BRA    193C8
193CC:  MOVWF  FAD
193CE:  MOVLW  3A
193D0:  BTFSS  F9E.4
193D2:  BRA    193D0
193D4:  MOVWF  FAD
193D6:  MOVLW  41
193D8:  MOVWF  FE9
193DA:  CLRF   1B
193DC:  BTFSC  FF2.7
193DE:  BSF    1B.7
193E0:  BCF    FF2.7
193E2:  MOVFF  7A5,A1B
193E6:  MOVFF  7A4,A1A
193EA:  MOVFF  7A3,A19
193EE:  MOVFF  7A2,A18
193F2:  CALL   10CC
193F6:  BTFSC  1B.7
193F8:  BSF    FF2.7
193FA:  MOVLW  2F
193FC:  BTFSS  F9E.4
193FE:  BRA    193FC
19400:  MOVWF  FAD
19402:  MOVLW  10
19404:  MOVWF  FE9
19406:  CLRF   1B
19408:  BTFSC  FF2.7
1940A:  BSF    1B.7
1940C:  BCF    FF2.7
1940E:  MOVFF  7BA,A19
19412:  MOVFF  7B9,A18
19416:  CALL   1188
1941A:  BTFSC  1B.7
1941C:  BSF    FF2.7
1941E:  MOVLW  2F
19420:  BTFSS  F9E.4
19422:  BRA    19420
19424:  MOVWF  FAD
19426:  MOVLW  10
19428:  MOVWF  FE9
1942A:  CLRF   1B
1942C:  BTFSC  FF2.7
1942E:  BSF    1B.7
19430:  BCF    FF2.7
19432:  MOVFF  7BE,A19
19436:  MOVFF  7BD,A18
1943A:  CALL   1188
1943E:  BTFSC  1B.7
19440:  BSF    FF2.7
19442:  MOVLW  0D
19444:  BTFSS  F9E.4
19446:  BRA    19444
19448:  MOVWF  FAD
1944A:  MOVLW  0A
1944C:  BTFSS  F9E.4
1944E:  BRA    1944C
19450:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
19452:  MOVLW  64
19454:  BTFSS  F9E.4
19456:  BRA    19454
19458:  MOVWF  FAD
1945A:  MOVLW  3A
1945C:  BTFSS  F9E.4
1945E:  BRA    1945C
19460:  MOVWF  FAD
19462:  MOVLW  10
19464:  MOVWF  FE9
19466:  CLRF   1B
19468:  BTFSC  FF2.7
1946A:  BSF    1B.7
1946C:  BCF    FF2.7
1946E:  MOVFF  74D,A19
19472:  MOVFF  74C,A18
19476:  CALL   1188
1947A:  BTFSC  1B.7
1947C:  BSF    FF2.7
1947E:  MOVLW  0D
19480:  BTFSS  F9E.4
19482:  BRA    19480
19484:  MOVWF  FAD
19486:  MOVLW  0A
19488:  BTFSS  F9E.4
1948A:  BRA    19488
1948C:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
1948E:  MOVLW  65
19490:  BTFSS  F9E.4
19492:  BRA    19490
19494:  MOVWF  FAD
19496:  MOVLW  3A
19498:  BTFSS  F9E.4
1949A:  BRA    19498
1949C:  MOVWF  FAD
1949E:  MOVLW  10
194A0:  MOVWF  FE9
194A2:  CLRF   1B
194A4:  BTFSC  FF2.7
194A6:  BSF    1B.7
194A8:  BCF    FF2.7
194AA:  MOVFF  75D,A19
194AE:  MOVFF  75C,A18
194B2:  CALL   1188
194B6:  BTFSC  1B.7
194B8:  BSF    FF2.7
194BA:  MOVLW  0D
194BC:  BTFSS  F9E.4
194BE:  BRA    194BC
194C0:  MOVWF  FAD
194C2:  MOVLW  0A
194C4:  BTFSS  F9E.4
194C6:  BRA    194C4
194C8:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
194CA:  MOVLW  66
194CC:  BTFSS  F9E.4
194CE:  BRA    194CC
194D0:  MOVWF  FAD
194D2:  MOVLW  3A
194D4:  BTFSS  F9E.4
194D6:  BRA    194D4
194D8:  MOVWF  FAD
194DA:  CLRF   1B
194DC:  BTFSC  FF2.7
194DE:  BSF    1B.7
194E0:  BCF    FF2.7
194E2:  MOVFF  73D,A18
194E6:  MOVLW  1B
194E8:  MOVLB  A
194EA:  MOVWF  x19
194EC:  MOVLB  0
194EE:  CALL   0F88
194F2:  BTFSC  1B.7
194F4:  BSF    FF2.7
194F6:  MOVLW  0D
194F8:  BTFSS  F9E.4
194FA:  BRA    194F8
194FC:  MOVWF  FAD
194FE:  MOVLW  0A
19500:  BTFSS  F9E.4
19502:  BRA    19500
19504:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
19506:  MOVLW  67
19508:  BTFSS  F9E.4
1950A:  BRA    19508
1950C:  MOVWF  FAD
1950E:  MOVLW  3A
19510:  BTFSS  F9E.4
19512:  BRA    19510
19514:  MOVWF  FAD
19516:  MOVLW  10
19518:  MOVWF  FE9
1951A:  CLRF   1B
1951C:  BTFSC  FF2.7
1951E:  BSF    1B.7
19520:  BCF    FF2.7
19522:  MOVFF  759,A19
19526:  MOVFF  758,A18
1952A:  CALL   1188
1952E:  BTFSC  1B.7
19530:  BSF    FF2.7
19532:  MOVLW  0D
19534:  BTFSS  F9E.4
19536:  BRA    19534
19538:  MOVWF  FAD
1953A:  MOVLW  0A
1953C:  BTFSS  F9E.4
1953E:  BRA    1953C
19540:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19542:  MOVLW  68
19544:  BTFSS  F9E.4
19546:  BRA    19544
19548:  MOVWF  FAD
1954A:  MOVLW  3A
1954C:  BTFSS  F9E.4
1954E:  BRA    1954C
19550:  MOVWF  FAD
19552:  MOVLW  10
19554:  MOVWF  FE9
19556:  CLRF   1B
19558:  BTFSC  FF2.7
1955A:  BSF    1B.7
1955C:  BCF    FF2.7
1955E:  MOVFF  862,A19
19562:  MOVFF  861,A18
19566:  CALL   1188
1956A:  BTFSC  1B.7
1956C:  BSF    FF2.7
1956E:  MOVLW  0D
19570:  BTFSS  F9E.4
19572:  BRA    19570
19574:  MOVWF  FAD
19576:  MOVLW  0A
19578:  BTFSS  F9E.4
1957A:  BRA    19578
1957C:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
1957E:  MOVLW  69
19580:  BTFSS  F9E.4
19582:  BRA    19580
19584:  MOVWF  FAD
19586:  MOVLW  3A
19588:  BTFSS  F9E.4
1958A:  BRA    19588
1958C:  MOVWF  FAD
1958E:  MOVLW  10
19590:  MOVWF  FE9
19592:  CLRF   1B
19594:  BTFSC  FF2.7
19596:  BSF    1B.7
19598:  BCF    FF2.7
1959A:  MOVFF  866,A19
1959E:  MOVFF  865,A18
195A2:  CALL   1188
195A6:  BTFSC  1B.7
195A8:  BSF    FF2.7
195AA:  MOVLW  0D
195AC:  BTFSS  F9E.4
195AE:  BRA    195AC
195B0:  MOVWF  FAD
195B2:  MOVLW  0A
195B4:  BTFSS  F9E.4
195B6:  BRA    195B4
195B8:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
195BA:  MOVLW  6A
195BC:  BTFSS  F9E.4
195BE:  BRA    195BC
195C0:  MOVWF  FAD
195C2:  MOVLW  3A
195C4:  BTFSS  F9E.4
195C6:  BRA    195C4
195C8:  MOVWF  FAD
195CA:  MOVLW  10
195CC:  MOVWF  FE9
195CE:  CLRF   1B
195D0:  BTFSC  FF2.7
195D2:  BSF    1B.7
195D4:  BCF    FF2.7
195D6:  MOVFF  76D,A19
195DA:  MOVFF  76C,A18
195DE:  CALL   1188
195E2:  BTFSC  1B.7
195E4:  BSF    FF2.7
195E6:  MOVLW  0D
195E8:  BTFSS  F9E.4
195EA:  BRA    195E8
195EC:  MOVWF  FAD
195EE:  MOVLW  0A
195F0:  BTFSS  F9E.4
195F2:  BRA    195F0
195F4:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
195F6:  MOVLW  6B
195F8:  BTFSS  F9E.4
195FA:  BRA    195F8
195FC:  MOVWF  FAD
195FE:  MOVLW  3A
19600:  BTFSS  F9E.4
19602:  BRA    19600
19604:  MOVWF  FAD
19606:  MOVLW  10
19608:  MOVWF  FE9
1960A:  CLRF   1B
1960C:  BTFSC  FF2.7
1960E:  BSF    1B.7
19610:  BCF    FF2.7
19612:  MOVFF  765,A19
19616:  MOVFF  764,A18
1961A:  CALL   1188
1961E:  BTFSC  1B.7
19620:  BSF    FF2.7
19622:  MOVLW  0D
19624:  BTFSS  F9E.4
19626:  BRA    19624
19628:  MOVWF  FAD
1962A:  MOVLW  0A
1962C:  BTFSS  F9E.4
1962E:  BRA    1962C
19630:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
19632:  MOVLW  6D
19634:  BTFSS  F9E.4
19636:  BRA    19634
19638:  MOVWF  FAD
1963A:  MOVLW  3A
1963C:  BTFSS  F9E.4
1963E:  BRA    1963C
19640:  MOVWF  FAD
19642:  MOVLW  10
19644:  MOVWF  FE9
19646:  CLRF   1B
19648:  BTFSC  FF2.7
1964A:  BSF    1B.7
1964C:  BCF    FF2.7
1964E:  MOVFF  745,A19
19652:  MOVFF  744,A18
19656:  CALL   1188
1965A:  BTFSC  1B.7
1965C:  BSF    FF2.7
1965E:  MOVLW  0D
19660:  BTFSS  F9E.4
19662:  BRA    19660
19664:  MOVWF  FAD
19666:  MOVLW  0A
19668:  BTFSS  F9E.4
1966A:  BRA    19668
1966C:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
1966E:  MOVLW  6E
19670:  BTFSS  F9E.4
19672:  BRA    19670
19674:  MOVWF  FAD
19676:  MOVLW  3A
19678:  BTFSS  F9E.4
1967A:  BRA    19678
1967C:  MOVWF  FAD
1967E:  MOVLW  10
19680:  MOVWF  FE9
19682:  CLRF   1B
19684:  BTFSC  FF2.7
19686:  BSF    1B.7
19688:  BCF    FF2.7
1968A:  MOVFF  779,A19
1968E:  MOVFF  778,A18
19692:  CALL   1188
19696:  BTFSC  1B.7
19698:  BSF    FF2.7
1969A:  MOVLW  0D
1969C:  BTFSS  F9E.4
1969E:  BRA    1969C
196A0:  MOVWF  FAD
196A2:  MOVLW  0A
196A4:  BTFSS  F9E.4
196A6:  BRA    196A4
196A8:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
196AA:  MOVLW  6F
196AC:  BTFSS  F9E.4
196AE:  BRA    196AC
196B0:  MOVWF  FAD
196B2:  MOVLW  3A
196B4:  BTFSS  F9E.4
196B6:  BRA    196B4
196B8:  MOVWF  FAD
196BA:  MOVLW  10
196BC:  MOVWF  FE9
196BE:  CLRF   1B
196C0:  BTFSC  FF2.7
196C2:  BSF    1B.7
196C4:  BCF    FF2.7
196C6:  MOVFF  77D,A19
196CA:  MOVFF  77C,A18
196CE:  CALL   1188
196D2:  BTFSC  1B.7
196D4:  BSF    FF2.7
196D6:  MOVLW  0D
196D8:  BTFSS  F9E.4
196DA:  BRA    196D8
196DC:  MOVWF  FAD
196DE:  MOVLW  0A
196E0:  BTFSS  F9E.4
196E2:  BRA    196E0
196E4:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
196E6:  MOVLW  70
196E8:  BTFSS  F9E.4
196EA:  BRA    196E8
196EC:  MOVWF  FAD
196EE:  MOVLW  3A
196F0:  BTFSS  F9E.4
196F2:  BRA    196F0
196F4:  MOVWF  FAD
196F6:  MOVLW  10
196F8:  MOVWF  FE9
196FA:  CLRF   1B
196FC:  BTFSC  FF2.7
196FE:  BSF    1B.7
19700:  BCF    FF2.7
19702:  MOVFF  7C2,A19
19706:  MOVFF  7C1,A18
1970A:  CALL   1188
1970E:  BTFSC  1B.7
19710:  BSF    FF2.7
19712:  MOVLW  2F
19714:  BTFSS  F9E.4
19716:  BRA    19714
19718:  MOVWF  FAD
1971A:  MOVLW  10
1971C:  MOVWF  FE9
1971E:  CLRF   1B
19720:  BTFSC  FF2.7
19722:  BSF    1B.7
19724:  BCF    FF2.7
19726:  MOVFF  761,A19
1972A:  MOVFF  760,A18
1972E:  CALL   1188
19732:  BTFSC  1B.7
19734:  BSF    FF2.7
19736:  MOVLW  0D
19738:  BTFSS  F9E.4
1973A:  BRA    19738
1973C:  MOVWF  FAD
1973E:  MOVLW  0A
19740:  BTFSS  F9E.4
19742:  BRA    19740
19744:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
19746:  MOVLW  71
19748:  BTFSS  F9E.4
1974A:  BRA    19748
1974C:  MOVWF  FAD
1974E:  MOVLW  3A
19750:  BTFSS  F9E.4
19752:  BRA    19750
19754:  MOVWF  FAD
19756:  MOVLW  10
19758:  MOVWF  FE9
1975A:  CLRF   1B
1975C:  BTFSC  FF2.7
1975E:  BSF    1B.7
19760:  BCF    FF2.7
19762:  MOVFF  795,A19
19766:  MOVFF  794,A18
1976A:  CALL   1188
1976E:  BTFSC  1B.7
19770:  BSF    FF2.7
19772:  MOVLW  0D
19774:  BTFSS  F9E.4
19776:  BRA    19774
19778:  MOVWF  FAD
1977A:  MOVLW  0A
1977C:  BTFSS  F9E.4
1977E:  BRA    1977C
19780:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
19782:  MOVLW  73
19784:  BTFSS  F9E.4
19786:  BRA    19784
19788:  MOVWF  FAD
1978A:  MOVLW  3A
1978C:  BTFSS  F9E.4
1978E:  BRA    1978C
19790:  MOVWF  FAD
19792:  MOVLW  10
19794:  MOVWF  FE9
19796:  CLRF   1B
19798:  BTFSC  FF2.7
1979A:  BSF    1B.7
1979C:  BCF    FF2.7
1979E:  MOVFF  775,A19
197A2:  MOVFF  774,A18
197A6:  CALL   1188
197AA:  BTFSC  1B.7
197AC:  BSF    FF2.7
197AE:  MOVLW  0D
197B0:  BTFSS  F9E.4
197B2:  BRA    197B0
197B4:  MOVWF  FAD
197B6:  MOVLW  0A
197B8:  BTFSS  F9E.4
197BA:  BRA    197B8
197BC:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
197BE:  MOVLW  74
197C0:  BTFSS  F9E.4
197C2:  BRA    197C0
197C4:  MOVWF  FAD
197C6:  MOVLW  3A
197C8:  BTFSS  F9E.4
197CA:  BRA    197C8
197CC:  MOVWF  FAD
197CE:  MOVLW  10
197D0:  MOVWF  FE9
197D2:  CLRF   1B
197D4:  BTFSC  FF2.7
197D6:  BSF    1B.7
197D8:  BCF    FF2.7
197DA:  MOVFF  769,A19
197DE:  MOVFF  768,A18
197E2:  CALL   1188
197E6:  BTFSC  1B.7
197E8:  BSF    FF2.7
197EA:  MOVLW  0D
197EC:  BTFSS  F9E.4
197EE:  BRA    197EC
197F0:  MOVWF  FAD
197F2:  MOVLW  0A
197F4:  BTFSS  F9E.4
197F6:  BRA    197F4
197F8:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
197FA:  MOVLW  01
197FC:  MOVLB  7
197FE:  ADDWF  x3C,W
19800:  MOVLB  8
19802:  MOVWF  x67
19804:  MOVLW  75
19806:  BTFSS  F9E.4
19808:  BRA    19806
1980A:  MOVWF  FAD
1980C:  MOVLW  3A
1980E:  BTFSS  F9E.4
19810:  BRA    1980E
19812:  MOVWF  FAD
19814:  CLRF   1B
19816:  BTFSC  FF2.7
19818:  BSF    1B.7
1981A:  BCF    FF2.7
1981C:  MOVFF  867,A18
19820:  MOVLW  1B
19822:  MOVLB  A
19824:  MOVWF  x19
19826:  MOVLB  0
19828:  CALL   0F88
1982C:  BTFSC  1B.7
1982E:  BSF    FF2.7
19830:  MOVLW  0D
19832:  BTFSS  F9E.4
19834:  BRA    19832
19836:  MOVWF  FAD
19838:  MOVLW  0A
1983A:  BTFSS  F9E.4
1983C:  BRA    1983A
1983E:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19840:  MOVLW  77
19842:  BTFSS  F9E.4
19844:  BRA    19842
19846:  MOVWF  FAD
19848:  MOVLW  3A
1984A:  BTFSS  F9E.4
1984C:  BRA    1984A
1984E:  MOVWF  FAD
19850:  MOVLW  10
19852:  MOVWF  FE9
19854:  CLRF   1B
19856:  BTFSC  FF2.7
19858:  BSF    1B.7
1985A:  BCF    FF2.7
1985C:  MOVFF  864,A19
19860:  MOVFF  863,A18
19864:  CALL   1188
19868:  BTFSC  1B.7
1986A:  BSF    FF2.7
1986C:  MOVLW  0D
1986E:  BTFSS  F9E.4
19870:  BRA    1986E
19872:  MOVWF  FAD
19874:  MOVLW  0A
19876:  BTFSS  F9E.4
19878:  BRA    19876
1987A:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
1987C:  MOVLW  78
1987E:  BTFSS  F9E.4
19880:  BRA    1987E
19882:  MOVWF  FAD
19884:  MOVLW  3A
19886:  BTFSS  F9E.4
19888:  BRA    19886
1988A:  MOVWF  FAD
1988C:  MOVLW  10
1988E:  MOVWF  FE9
19890:  CLRF   1B
19892:  BTFSC  FF2.7
19894:  BSF    1B.7
19896:  BCF    FF2.7
19898:  MOVFF  781,A19
1989C:  MOVFF  780,A18
198A0:  CALL   1188
198A4:  BTFSC  1B.7
198A6:  BSF    FF2.7
198A8:  MOVLW  0D
198AA:  BTFSS  F9E.4
198AC:  BRA    198AA
198AE:  MOVWF  FAD
198B0:  MOVLW  0A
198B2:  BTFSS  F9E.4
198B4:  BRA    198B2
198B6:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
198B8:  MOVLW  79
198BA:  BTFSS  F9E.4
198BC:  BRA    198BA
198BE:  MOVWF  FAD
198C0:  MOVLW  3A
198C2:  BTFSS  F9E.4
198C4:  BRA    198C2
198C6:  MOVWF  FAD
198C8:  MOVLW  10
198CA:  MOVWF  FE9
198CC:  CLRF   1B
198CE:  BTFSC  FF2.7
198D0:  BSF    1B.7
198D2:  BCF    FF2.7
198D4:  MOVFF  741,A19
198D8:  MOVFF  740,A18
198DC:  CALL   1188
198E0:  BTFSC  1B.7
198E2:  BSF    FF2.7
198E4:  MOVLW  0D
198E6:  BTFSS  F9E.4
198E8:  BRA    198E6
198EA:  MOVWF  FAD
198EC:  MOVLW  0A
198EE:  BTFSS  F9E.4
198F0:  BRA    198EE
198F2:  MOVWF  FAD
....................    } 
198F4:  BRA    198FA
....................    else cmd_arg(); 
198F6:  CALL   AF7A
198FA:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BBC2:  MOVF   44,W
0BBC4:  SUBLW  0D
0BBC6:  BNZ   BBE6
0BBC8:  MOVF   45,W
0BBCA:  SUBLW  07
0BBCC:  BNZ   BBE6
0BBCE:  MOVF   46,F
0BBD0:  BNZ   BBE6
0BBD2:  MOVF   47,F
0BBD4:  BNZ   BBE6
0BBD6:  MOVLW  03
0BBD8:  MOVLB  8
0BBDA:  MOVWF  x62
0BBDC:  MOVLW  11
0BBDE:  MOVWF  x61
0BBE0:  MOVLB  0
0BBE2:  RCALL  B7A0
0BBE4:  BRA    BC08
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BBE6:  MOVF   44,W
0BBE8:  SUBLW  98
0BBEA:  BNZ   BC08
0BBEC:  MOVF   45,W
0BBEE:  SUBLW  07
0BBF0:  BNZ   BC08
0BBF2:  MOVF   46,F
0BBF4:  BNZ   BC08
0BBF6:  MOVF   47,F
0BBF8:  BNZ   BC08
0BBFA:  MOVLW  03
0BBFC:  MOVLB  8
0BBFE:  MOVWF  x63
0BC00:  MOVLW  11
0BC02:  MOVWF  x62
0BC04:  MOVLB  0
0BC06:  RCALL  B91A
0BC08:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0AFD4:  MOVF   44,W
0AFD6:  MOVWF  00
0AFD8:  MOVFF  45,03
0AFDC:  MOVLW  15
0AFDE:  SUBWF  45,W
0AFE0:  BNZ   AFE8
0AFE2:  MOVLW  95
0AFE4:  SUBWF  00,W
0AFE6:  BZ    B00E
0AFE8:  MOVLW  15
0AFEA:  SUBWF  03,W
0AFEC:  BNZ   AFF4
0AFEE:  MOVLW  96
0AFF0:  SUBWF  00,W
0AFF2:  BZ    B040
0AFF4:  MOVLW  15
0AFF6:  SUBWF  03,W
0AFF8:  BNZ   B000
0AFFA:  MOVLW  97
0AFFC:  SUBWF  00,W
0AFFE:  BZ    B076
0B000:  MOVLW  15
0B002:  SUBWF  03,W
0B004:  BNZ   B00C
0B006:  MOVLW  98
0B008:  SUBWF  00,W
0B00A:  BZ    B0AC
0B00C:  BRA    B0E0
....................       case 5525 : nv_product = ECO; 
0B00E:  CLRF   30
0B010:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B012:  MOVLW  1E
0B014:  MOVLB  8
0B016:  MOVWF  xCA
0B018:  CLRF   xCC
0B01A:  CLRF   xCB
0B01C:  MOVLB  0
0B01E:  CALL   4F52
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B022:  MOVLW  01
0B024:  MOVWF  1E
0B026:  MOVLW  A3
0B028:  MOVWF  1D
0B02A:  MOVLW  14
0B02C:  MOVWF  FF6
0B02E:  MOVLW  27
0B030:  MOVWF  FF7
0B032:  MOVLW  00
0B034:  MOVWF  FF8
0B036:  CALL   503C
....................                   record_event(); 
0B03A:  CALL   8424
....................          break; 
0B03E:  BRA    B0E0
....................       case 5526 : nv_product = WMS4; 
0B040:  CLRF   30
0B042:  MOVLW  01
0B044:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B046:  MOVLW  1E
0B048:  MOVLB  8
0B04A:  MOVWF  xCA
0B04C:  CLRF   xCC
0B04E:  MOVLW  01
0B050:  MOVWF  xCB
0B052:  MOVLB  0
0B054:  CALL   4F52
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B058:  MOVLW  01
0B05A:  MOVWF  1E
0B05C:  MOVLW  A3
0B05E:  MOVWF  1D
0B060:  MOVLW  24
0B062:  MOVWF  FF6
0B064:  MOVLW  27
0B066:  MOVWF  FF7
0B068:  MOVLW  00
0B06A:  MOVWF  FF8
0B06C:  CALL   503C
....................                   record_event();                   
0B070:  CALL   8424
....................          break;    
0B074:  BRA    B0E0
....................       case 5527 : nv_product = AWS; 
0B076:  CLRF   30
0B078:  MOVLW  02
0B07A:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B07C:  MOVLW  1E
0B07E:  MOVLB  8
0B080:  MOVWF  xCA
0B082:  CLRF   xCC
0B084:  MOVLW  02
0B086:  MOVWF  xCB
0B088:  MOVLB  0
0B08A:  CALL   4F52
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B08E:  MOVLW  01
0B090:  MOVWF  1E
0B092:  MOVLW  A3
0B094:  MOVWF  1D
0B096:  MOVLW  3A
0B098:  MOVWF  FF6
0B09A:  MOVLW  27
0B09C:  MOVWF  FF7
0B09E:  MOVLW  00
0B0A0:  MOVWF  FF8
0B0A2:  CALL   503C
....................                   record_event();                   
0B0A6:  CALL   8424
....................          break;   
0B0AA:  BRA    B0E0
....................       case 5528 : nv_product = WMS2; 
0B0AC:  CLRF   30
0B0AE:  MOVLW  03
0B0B0:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B0B2:  MOVLW  1E
0B0B4:  MOVLB  8
0B0B6:  MOVWF  xCA
0B0B8:  CLRF   xCC
0B0BA:  MOVLW  03
0B0BC:  MOVWF  xCB
0B0BE:  MOVLB  0
0B0C0:  CALL   4F52
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B0C4:  MOVLW  01
0B0C6:  MOVWF  1E
0B0C8:  MOVLW  A3
0B0CA:  MOVWF  1D
0B0CC:  MOVLW  4A
0B0CE:  MOVWF  FF6
0B0D0:  MOVLW  27
0B0D2:  MOVWF  FF7
0B0D4:  MOVLW  00
0B0D6:  MOVWF  FF8
0B0D8:  CALL   503C
....................                   record_event();                   
0B0DC:  CALL   8424
....................          break;            
....................    } 
0B0E0:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0AF98:  MOVF   44,W
0AF9A:  MOVWF  00
0AF9C:  MOVF   45,W
0AF9E:  MOVWF  03
0AFA0:  BNZ   AFA6
0AFA2:  MOVF   00,F
0AFA4:  BZ    AFBC
0AFA6:  MOVF   03,W
0AFA8:  BNZ   AFB0
0AFAA:  MOVLW  01
0AFAC:  SUBWF  00,W
0AFAE:  BZ    AFC2
0AFB0:  MOVF   03,W
0AFB2:  BNZ   AFBA
0AFB4:  MOVLW  02
0AFB6:  SUBWF  00,W
0AFB8:  BZ    AFC8
0AFBA:  BRA    AFCE
....................       case 0 : kill_wd(); 
0AFBC:  CALL   3074
....................          break; 
0AFC0:  BRA    AFD0
....................       case 1 : start_heartbeat(); 
0AFC2:  CALL   287E
....................          break; 
0AFC6:  BRA    AFD0
....................       case 2 : suspend_heartbeat(); 
0AFC8:  CALL   54CE
....................          break; 
0AFCC:  BRA    AFD0
....................       default : cmd_arg(); 
0AFCE:  RCALL  AF7A
....................          break; 
....................    } 
0AFD0:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0AED8:  MOVF   44,W
0AEDA:  MOVWF  00
0AEDC:  MOVF   45,W
0AEDE:  MOVWF  03
0AEE0:  BNZ   AEE6
0AEE2:  MOVF   00,F
0AEE4:  BZ    AEF4
0AEE6:  MOVLW  15
0AEE8:  SUBWF  03,W
0AEEA:  BNZ   AEF2
0AEEC:  MOVLW  95
0AEEE:  SUBWF  00,W
0AEF0:  BZ    AF52
0AEF2:  BRA    AF76
....................       case 0:     signon(); 
0AEF4:  CALL   30C6
....................                   fprintf(COM_A, __DATE__); 
0AEF8:  MOVLW  60
0AEFA:  MOVWF  FF6
0AEFC:  MOVLW  27
0AEFE:  MOVWF  FF7
0AF00:  MOVLW  00
0AF02:  MOVWF  FF8
0AF04:  CLRF   1B
0AF06:  BTFSC  FF2.7
0AF08:  BSF    1B.7
0AF0A:  BCF    FF2.7
0AF0C:  CALL   0E30
0AF10:  BTFSC  1B.7
0AF12:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0AF14:  MOVLW  0D
0AF16:  BTFSS  F9E.4
0AF18:  BRA    AF16
0AF1A:  MOVWF  FAD
0AF1C:  MOVLW  0A
0AF1E:  BTFSS  F9E.4
0AF20:  BRA    AF1E
0AF22:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0AF24:  MOVLW  6A
0AF26:  MOVWF  FF6
0AF28:  MOVLW  27
0AF2A:  MOVWF  FF7
0AF2C:  MOVLW  00
0AF2E:  MOVWF  FF8
0AF30:  CLRF   1B
0AF32:  BTFSC  FF2.7
0AF34:  BSF    1B.7
0AF36:  BCF    FF2.7
0AF38:  CALL   0E30
0AF3C:  BTFSC  1B.7
0AF3E:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0AF40:  MOVLW  0D
0AF42:  BTFSS  F9E.4
0AF44:  BRA    AF42
0AF46:  MOVWF  FAD
0AF48:  MOVLW  0A
0AF4A:  BTFSS  F9E.4
0AF4C:  BRA    AF4A
0AF4E:  MOVWF  FAD
....................          break; 
0AF50:  BRA    AF76
....................       case 5525 : kill_wd(); 
0AF52:  CALL   3074
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0AF56:  MOVLW  74
0AF58:  MOVWF  FF6
0AF5A:  MOVLW  27
0AF5C:  MOVWF  FF7
0AF5E:  MOVLW  00
0AF60:  MOVWF  FF8
0AF62:  CLRF   1B
0AF64:  BTFSC  FF2.7
0AF66:  BSF    1B.7
0AF68:  BCF    FF2.7
0AF6A:  CALL   0E30
0AF6E:  BTFSC  1B.7
0AF70:  BSF    FF2.7
....................                   load_program(); 
0AF72:  CALL   1F800
....................          break; 
....................    } 
0AF76:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
185F2:  MOVF   44,W
185F4:  MOVWF  00
185F6:  MOVF   45,W
185F8:  MOVWF  03
185FA:  BNZ   18600
185FC:  MOVF   00,F
185FE:  BZ    1860C
18600:  MOVF   03,W
18602:  BNZ   1860A
18604:  MOVLW  01
18606:  SUBWF  00,W
18608:  BZ    18610
1860A:  BRA    18614
....................       case 0 : cmd_set=0;  // user 
1860C:  CLRF   4D
....................          break; 
1860E:  BRA    18614
....................       case 1 : cmd_set=1;  // full 
18610:  MOVLW  01
18612:  MOVWF  4D
....................          break; 
....................    } 
18614:  GOTO   1AC9A (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1AB0A:  CALL   ADB6
....................     
....................    switch (cmd) 
1AB0E:  MOVLW  23
1AB10:  SUBWF  43,W
1AB12:  ADDLW  A8
1AB14:  BTFSC  FD8.0
1AB16:  BRA    1AC9A
1AB18:  ADDLW  58
1AB1A:  GOTO   1AC9E
....................    { 
....................       case '&': commandFW(); 
1AB1E:  GOTO   AED8
....................          break; 
1AB22:  BRA    1AC9A
....................       case '#': command_hash(); 
1AB24:  GOTO   AF98
....................          break;          
1AB28:  BRA    1AC9A
....................       case '%': command_prod(); 
1AB2A:  GOTO   AFD4
....................          break; 
1AB2E:  BRA    1AC9A
....................       case '*': command_star(); 
1AB30:  GOTO   BBC2
....................          break;       
1AB34:  BRA    1AC9A
....................       // standard commands 
....................       case '/': command_addr(); 
1AB36:  GOTO   BC0C
....................          break; 
1AB3A:  BRA    1AC9A
....................       case 'A': commandA(); 
1AB3C:  GOTO   BDA6
....................          break; 
1AB40:  BRA    1AC9A
....................       case 'B': commandB(); 
1AB42:  GOTO   BF12
....................          break; 
1AB46:  BRA    1AC9A
....................       case 'C': commandC(); 
1AB48:  GOTO   D9BE
....................          break; 
1AB4C:  BRA    1AC9A
....................       case 'D': commandD(); 
1AB4E:  GOTO   D9FC
....................          break; 
1AB52:  BRA    1AC9A
....................       case 'E': commandE(); 
1AB54:  GOTO   DA96
....................          break;          
1AB58:  BRA    1AC9A
....................       case 'F': commandF(); 
1AB5A:  GOTO   DD94
....................          break;          
1AB5E:  BRA    1AC9A
....................       case 'G': commandG(); 
1AB60:  GOTO   DDFE
....................          break; 
1AB64:  BRA    1AC9A
....................       case 'H': commandH(); 
1AB66:  GOTO   EF5C
....................          break; 
1AB6A:  BRA    1AC9A
....................       case 'I': commandI(); 
1AB6C:  GOTO   EF9C
....................          break;    
1AB70:  BRA    1AC9A
....................       case 'J': commandJ(); 
1AB72:  GOTO   EFE8
....................          break;      
1AB76:  BRA    1AC9A
....................       case 'K': commandK(); 
1AB78:  GOTO   F242
....................          break;    
1AB7C:  BRA    1AC9A
....................       case 'L': commandL(); 
1AB7E:  GOTO   101D4
....................          break;             
1AB82:  BRA    1AC9A
....................       case 'M': commandM(FALSE); 
1AB84:  MOVLB  8
1AB86:  CLRF   x61
1AB88:  MOVLB  0
1AB8A:  CALL   1689E
....................          break;   
1AB8E:  BRA    1AC9A
....................       case 'N': commandN(); 
1AB90:  GOTO   1699E
....................          break;          
1AB94:  BRA    1AC9A
....................       case 'O': commandO(); 
1AB96:  GOTO   16B46
....................          break;    
1AB9A:  BRA    1AC9A
....................       case 'P': commandP(); 
1AB9C:  GOTO   16D4A
....................          break;  
1ABA0:  BRA    1AC9A
....................       case 'Q': commandQ(); 
1ABA2:  GOTO   16E08
....................          break;              
1ABA6:  BRA    1AC9A
....................       case 'R': commandR(); 
1ABA8:  GOTO   1709E
....................          break;    
1ABAC:  BRA    1AC9A
....................       case 'S': commandS(); 
1ABAE:  GOTO   171CA
....................          break;  
1ABB2:  BRA    1AC9A
....................       case 'T': commandT(); 
1ABB4:  GOTO   17768
....................          break;            
1ABB8:  BRA    1AC9A
....................       case 'U': commandU(); 
1ABBA:  GOTO   1816E
....................          break;           
1ABBE:  BRA    1AC9A
....................       case 'V': commandV(); 
1ABC0:  GOTO   182C6
....................          break; 
1ABC4:  BRA    1AC9A
....................       case 'W': commandW(); 
1ABC6:  GOTO   1843A
....................          break; 
1ABCA:  BRA    1AC9A
....................       case 'X': commandX(); 
1ABCC:  GOTO   1845E
....................          break; 
1ABD0:  BRA    1AC9A
....................       case 'Y': commandY(); 
1ABD2:  GOTO   184C6
....................          break;  
1ABD6:  BRA    1AC9A
....................       case 'Z': commandZ(); 
1ABD8:  CALL   185CE
....................          break;    
1ABDC:  BRA    1AC9A
....................       // stepper 
....................       case '^': command_set(); 
1ABDE:  GOTO   185F2
....................          break;       
1ABE2:  BRA    1AC9A
....................       case '+': if(m_fixed==1) motor=1; 
1ABE4:  MOVLB  7
1ABE6:  DECFSZ x3D,W
1ABE8:  BRA    1ABEE
1ABEA:  MOVLW  01
1ABEC:  MOVWF  x3C
....................                 command_move(0,0,1); 
1ABEE:  MOVLB  8
1ABF0:  CLRF   x61
1ABF2:  CLRF   x62
1ABF4:  MOVLW  01
1ABF6:  MOVWF  x63
1ABF8:  MOVLB  0
1ABFA:  CALL   16B6A
....................          break; 
1ABFE:  BRA    1AC9A
....................       case '-': if(m_fixed==1) motor=1; 
1AC00:  MOVLB  7
1AC02:  DECFSZ x3D,W
1AC04:  BRA    1AC0A
1AC06:  MOVLW  01
1AC08:  MOVWF  x3C
....................                 command_move(0,1,1); 
1AC0A:  MOVLB  8
1AC0C:  CLRF   x61
1AC0E:  MOVLW  01
1AC10:  MOVWF  x62
1AC12:  MOVWF  x63
1AC14:  MOVLB  0
1AC16:  CALL   16B6A
....................          break; 
1AC1A:  BRA    1AC9A
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1AC1C:  GOTO   1871E
....................          break;     
1AC20:  BRA    1AC9A
....................       case 'b': command_b(); 
1AC22:  GOTO   1873A
....................          break;           
1AC26:  BRA    1AC9A
....................       case 'd': command_d(); 
1AC28:  GOTO   187D4
....................          break;          
1AC2C:  BRA    1AC9A
....................       case 'e': command_e(); 
1AC2E:  GOTO   1886A
....................          break;       
1AC32:  BRA    1AC9A
....................       case 'f': command_f(); 
1AC34:  GOTO   18904
....................          break; 
1AC38:  BRA    1AC9A
....................       case 'g': command_g(); 
1AC3A:  GOTO   18924
....................          break;          
1AC3E:  BRA    1AC9A
....................       case 'h': command_h(); 
1AC40:  GOTO   189BE
....................          break; 
1AC44:  BRA    1AC9A
....................       case 'i': command_i(); 
1AC46:  GOTO   18A92
....................          break;   
1AC4A:  BRA    1AC9A
....................       case 'j': command_j(); 
1AC4C:  GOTO   18B6E
....................          break;           
1AC50:  BRA    1AC9A
....................       case 'k': command_k(); 
1AC52:  GOTO   18C08
....................          break;          
1AC56:  BRA    1AC9A
....................       case 'l': step_var_list(); 
1AC58:  GOTO   18C9E
....................          break;          
1AC5C:  BRA    1AC9A
....................       case 'm': command_m(); 
1AC5E:  GOTO   198FE
....................          break;    
1AC62:  BRA    1AC9A
....................       case 'n': command_n(); 
1AC64:  GOTO   19994
....................          break; 
1AC68:  BRA    1AC9A
....................       case 'o': command_o(); 
1AC6A:  GOTO   19A2A
....................          break;    
1AC6E:  BRA    1AC9A
....................       case 'p': command_p(); 
1AC70:  GOTO   19AC4
....................          break;   
1AC74:  BRA    1AC9A
....................       case 'q': command_q(); 
1AC76:  GOTO   19B5E
....................          break; 
1AC7A:  BRA    1AC9A
....................       case 'r': command_r(); 
1AC7C:  BRA    1A65A
....................          break;    
1AC7E:  BRA    1AC9A
....................       case 's': command_s(); 
1AC80:  BRA    1A6B4
....................          break;           
1AC82:  BRA    1AC9A
....................       case 't': command_t(); 
1AC84:  BRA    1A7C2
....................          break;          
1AC86:  BRA    1AC9A
....................       case 'u': command_u(); 
1AC88:  BRA    1A858
....................          break;           
1AC8A:  BRA    1AC9A
....................       case 'w': command_w(); 
1AC8C:  BRA    1A890
....................          break; 
1AC8E:  BRA    1AC9A
....................       case 'x': command_x(); 
1AC90:  BRA    1A964
....................          break;    
1AC92:  BRA    1AC9A
....................       case 'y': command_y(); 
1AC94:  BRA    1A9FE
....................          break;  
1AC96:  BRA    1AC9A
....................       case 'z': command_z(); 
1AC98:  BRA    1AA94
....................          break;           
....................    } 
1AC9A:  GOTO   1AE22 (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................  
....................   number = 0; 
*
1AD6E:  MOVLB  8
1AD70:  CLRF   x5F
....................   arg = 0; 
1AD72:  CLRF   47
1AD74:  CLRF   46
1AD76:  CLRF   45
1AD78:  CLRF   44
....................   good_arg = FALSE; 
1AD7A:  CLRF   x60
....................    
....................   while (number != CARRIAGE_RET) 
1AD7C:  MOVF   x5F,W
1AD7E:  SUBLW  0D
1AD80:  BZ    1AE54
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
1AD82:  MOVLB  0
1AD84:  CALL   0E1A
1AD88:  MOVFF  01,85F
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
1AD8C:  MOVLB  8
1AD8E:  MOVF   x5F,W
1AD90:  SUBLW  0D
1AD92:  BZ    1AD9E
1AD94:  MOVF   x5F,W
1AD96:  MOVLB  0
1AD98:  CALL   ADBE
1AD9C:  MOVLB  8
....................      if (number > 47 && number < 58) 
1AD9E:  MOVF   x5F,W
1ADA0:  SUBLW  2F
1ADA2:  BC    1ADF4
1ADA4:  MOVF   x5F,W
1ADA6:  SUBLW  39
1ADA8:  BNC   1ADF4
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
1ADAA:  MOVLW  30
1ADAC:  SUBWF  x5F,F
....................         arg = arg * 10;                    // increase significance 
1ADAE:  MOVFF  47,9D5
1ADB2:  MOVFF  46,9D4
1ADB6:  MOVFF  45,9D3
1ADBA:  MOVFF  44,9D2
1ADBE:  MOVLB  9
1ADC0:  CLRF   xD9
1ADC2:  CLRF   xD8
1ADC4:  CLRF   xD7
1ADC6:  MOVLW  0A
1ADC8:  MOVWF  xD6
1ADCA:  MOVLB  0
1ADCC:  CALL   4778
1ADD0:  MOVFF  03,47
1ADD4:  MOVFF  02,46
1ADD8:  MOVFF  01,45
1ADDC:  MOVFF  00,44
....................         arg = arg + number;                // for each number 
1ADE0:  MOVLB  8
1ADE2:  MOVF   x5F,W
1ADE4:  ADDWF  44,F
1ADE6:  MOVLW  00
1ADE8:  ADDWFC 45,F
1ADEA:  ADDWFC 46,F
1ADEC:  ADDWFC 47,F
....................         good_arg = TRUE; 
1ADEE:  MOVLW  01
1ADF0:  MOVWF  x60
....................      } 
1ADF2:  BRA    1AE4C
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
1ADF4:  MOVF   x5F,W
1ADF6:  SUBLW  0D
1ADF8:  BNZ   1AE26
1ADFA:  DECFSZ x60,W
1ADFC:  BRA    1AE26
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
1ADFE:  MOVLW  9A
1AE00:  MOVWF  FF6
1AE02:  MOVLW  27
1AE04:  MOVWF  FF7
1AE06:  MOVLW  00
1AE08:  MOVWF  FF8
1AE0A:  MOVLB  0
1AE0C:  CALL   AD8C
1AE10:  MOVLW  0D
1AE12:  BTFSS  F9E.4
1AE14:  BRA    1AE12
1AE16:  MOVWF  FAD
1AE18:  MOVLW  0A
1AE1A:  BTFSS  F9E.4
1AE1C:  BRA    1AE1A
1AE1E:  MOVWF  FAD
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
1AE20:  BRA    1AB0A
....................      } 
1AE22:  BRA    1AE4A
1AE24:  MOVLB  8
....................      else 
....................      { 
....................         good_arg = FALSE; 
1AE26:  CLRF   x60
....................         fputs("@ARG ", COM_A);             // bad input 
1AE28:  MOVLW  A0
1AE2A:  MOVWF  FF6
1AE2C:  MOVLW  27
1AE2E:  MOVWF  FF7
1AE30:  MOVLW  00
1AE32:  MOVWF  FF8
1AE34:  MOVLB  0
1AE36:  CALL   AD8C
1AE3A:  MOVLW  0D
1AE3C:  BTFSS  F9E.4
1AE3E:  BRA    1AE3C
1AE40:  MOVWF  FAD
1AE42:  MOVLW  0A
1AE44:  BTFSS  F9E.4
1AE46:  BRA    1AE44
1AE48:  MOVWF  FAD
1AE4A:  MOVLB  8
....................      } 
....................      if (good_arg == FALSE) break; 
1AE4C:  MOVF   x60,F
1AE4E:  BTFSC  FD8.2
1AE50:  BRA    1AE54
1AE52:  BRA    1AD7C
....................   } 
1AE54:  MOVLB  0
1AE56:  GOTO   1AE8A (RETURN)
.................... } 
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0AE08:  MOVF   4D,F
0AE0A:  BNZ   AE5C
0AE0C:  MOVLB  8
0AE0E:  MOVF   x5F,W
0AE10:  SUBLW  24
0AE12:  BC    AE1A
0AE14:  MOVF   x5F,W
0AE16:  SUBLW  26
0AE18:  BC    AE54
0AE1A:  MOVF   x5F,W
0AE1C:  SUBLW  29
0AE1E:  BC    AE26
0AE20:  MOVF   x5F,W
0AE22:  SUBLW  2B
0AE24:  BC    AE54
0AE26:  MOVF   x5F,W
0AE28:  SUBLW  2D
0AE2A:  BZ    AE54
0AE2C:  MOVF   x5F,W
0AE2E:  SUBLW  2F
0AE30:  BZ    AE54
0AE32:  MOVF   x5F,W
0AE34:  SUBLW  40
0AE36:  BC    AE3E
0AE38:  MOVF   x5F,W
0AE3A:  SUBLW  42
0AE3C:  BC    AE54
0AE3E:  MOVF   x5F,W
0AE40:  SUBLW  43
0AE42:  BC    AE4A
0AE44:  MOVF   x5F,W
0AE46:  SUBLW  5A
0AE48:  BC    AE54
0AE4A:  MOVF   x5F,W
0AE4C:  SUBLW  5E
0AE4E:  BZ    AE54
0AE50:  MOVLW  00
0AE52:  BRA    AE56
0AE54:  MOVLW  01
0AE56:  MOVWF  x60
0AE58:  BRA    AECA
0AE5A:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0AE5C:  DECFSZ 4D,W
0AE5E:  BRA    AECC
0AE60:  MOVLB  8
0AE62:  MOVF   x5F,W
0AE64:  SUBLW  23
0AE66:  BZ    AEC6
0AE68:  MOVF   x5F,W
0AE6A:  SUBLW  24
0AE6C:  BC    AE74
0AE6E:  MOVF   x5F,W
0AE70:  SUBLW  26
0AE72:  BC    AEC6
0AE74:  MOVF   x5F,W
0AE76:  SUBLW  29
0AE78:  BC    AE80
0AE7A:  MOVF   x5F,W
0AE7C:  SUBLW  2B
0AE7E:  BC    AEC6
0AE80:  MOVF   x5F,W
0AE82:  SUBLW  2D
0AE84:  BZ    AEC6
0AE86:  MOVF   x5F,W
0AE88:  SUBLW  2F
0AE8A:  BZ    AEC6
0AE8C:  MOVF   x5F,W
0AE8E:  SUBLW  40
0AE90:  BC    AE98
0AE92:  MOVF   x5F,W
0AE94:  SUBLW  42
0AE96:  BC    AEC6
0AE98:  MOVF   x5F,W
0AE9A:  SUBLW  43
0AE9C:  BC    AEA4
0AE9E:  MOVF   x5F,W
0AEA0:  SUBLW  5A
0AEA2:  BC    AEC6
0AEA4:  MOVF   x5F,W
0AEA6:  SUBLW  5E
0AEA8:  BZ    AEC6
0AEAA:  MOVF   x5F,W
0AEAC:  SUBLW  60
0AEAE:  BC    AEB6
0AEB0:  MOVF   x5F,W
0AEB2:  SUBLW  75
0AEB4:  BC    AEC6
0AEB6:  MOVF   x5F,W
0AEB8:  SUBLW  76
0AEBA:  BC    AEC2
0AEBC:  MOVF   x5F,W
0AEBE:  SUBLW  7A
0AEC0:  BC    AEC6
0AEC2:  MOVLW  00
0AEC4:  BRA    AEC8
0AEC6:  MOVLW  01
0AEC8:  MOVWF  x60
0AECA:  MOVLB  0
....................    return(valid); 
0AECC:  MOVLB  8
0AECE:  MOVFF  860,01
0AED2:  MOVLB  0
0AED4:  GOTO   1AE62 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
*
1AE5A:  MOVFF  43,85F
1AE5E:  GOTO   AE08
1AE62:  MOVF   01,F
1AE64:  BZ    1AE6A
1AE66:  BRA    1AD6E
1AE68:  BRA    1AE8A
....................    else fputs("@INV", COM_A); 
1AE6A:  MOVLW  A6
1AE6C:  MOVWF  FF6
1AE6E:  MOVLW  27
1AE70:  MOVWF  FF7
1AE72:  MOVLW  00
1AE74:  MOVWF  FF8
1AE76:  CALL   AD8C
1AE7A:  MOVLW  0D
1AE7C:  BTFSS  F9E.4
1AE7E:  BRA    1AE7C
1AE80:  MOVWF  FAD
1AE82:  MOVLW  0A
1AE84:  BTFSS  F9E.4
1AE86:  BRA    1AE84
1AE88:  MOVWF  FAD
1AE8A:  GOTO   1AF0E (RETURN)
.................... } 
....................  
.................... void command_prompt() 
.................... { 
....................    disable_interrupts(INT_EXT); 
1AE8E:  BCF    FF2.4
....................     
....................    nv_cmd_mode = TRUE; 
1AE90:  CLRF   32
1AE92:  MOVLW  01
1AE94:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1AE96:  MOVLW  02
1AE98:  MOVLB  8
1AE9A:  MOVWF  x65
1AE9C:  MOVFF  31,866
1AEA0:  MOVLB  0
1AEA2:  CALL   3390
....................     
....................    fputs("@CMD", COM_A); 
1AEA6:  MOVLW  AC
1AEA8:  MOVWF  FF6
1AEAA:  MOVLW  27
1AEAC:  MOVWF  FF7
1AEAE:  MOVLW  00
1AEB0:  MOVWF  FF8
1AEB2:  CALL   AD8C
1AEB6:  MOVLW  0D
1AEB8:  BTFSS  F9E.4
1AEBA:  BRA    1AEB8
1AEBC:  MOVWF  FAD
1AEBE:  MOVLW  0A
1AEC0:  BTFSS  F9E.4
1AEC2:  BRA    1AEC0
1AEC4:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1AEC6:  MOVLW  01
1AEC8:  MOVWF  1E
1AECA:  MOVLW  A3
1AECC:  MOVWF  1D
1AECE:  MOVLW  B2
1AED0:  MOVWF  FF6
1AED2:  MOVLW  27
1AED4:  MOVWF  FF7
1AED6:  MOVLW  00
1AED8:  MOVWF  FF8
1AEDA:  CALL   503C
....................    record_event(); 
1AEDE:  CALL   8424
....................     
....................    busy_clear(); 
1AEE2:  CALL   ADB6
....................     
....................    cmd_set=0; // user 
1AEE6:  CLRF   4D
....................     
....................    do { 
....................       fputc('>',COM_A); 
1AEE8:  MOVLW  3E
1AEEA:  CALL   ADBE
....................       cmd=fgetc(COM_A); 
1AEEE:  CALL   0E1A
1AEF2:  MOVFF  01,43
....................       if (com_echo == TRUE) 
1AEF6:  DECFSZ 48,W
1AEF8:  BRA    1AF00
....................       { 
....................          fputc(cmd,COM_A); 
1AEFA:  MOVF   43,W
1AEFC:  CALL   ADBE
....................       } 
....................       if (cmd == '?') msg_busy(); 
1AF00:  MOVF   43,W
1AF02:  SUBLW  3F
1AF04:  BNZ   1AF0C
1AF06:  GOTO   ADC6
1AF0A:  BRA    1AF0E
....................       else proc_cmd(); 
1AF0C:  BRA    1AE5A
....................    } while(nv_cmd_mode == TRUE); 
1AF0E:  DECFSZ 31,W
1AF10:  BRA    1AF16
1AF12:  MOVF   32,F
1AF14:  BZ    1AEE8
1AF16:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
1AF18:  CLRF   FF8
1AF1A:  BCF    FD0.7
1AF1C:  BSF    07.7
1AF1E:  MOVLW  70
1AF20:  MOVWF  FD3
1AF22:  MOVLW  40
1AF24:  MOVWF  F9B
1AF26:  CLRF   F64
1AF28:  CLRF   1C
1AF2A:  BSF    F65.3
1AF2C:  MOVWF  FAF
1AF2E:  MOVLW  03
1AF30:  MOVWF  FD4
1AF32:  MOVLW  A6
1AF34:  MOVWF  FAC
1AF36:  MOVLW  90
1AF38:  MOVWF  FAB
1AF3A:  MOVLB  F
1AF3C:  BSF    x20.3
1AF3E:  MOVLW  82
1AF40:  MOVWF  x1E
1AF42:  MOVLW  06
1AF44:  MOVWF  x1F
1AF46:  MOVLW  A6
1AF48:  MOVWF  x21
1AF4A:  MOVLW  90
1AF4C:  MOVWF  x22
1AF4E:  BSF    F65.3
1AF50:  MOVLW  40
1AF52:  MOVWF  FAF
1AF54:  MOVLW  03
1AF56:  MOVWF  FD4
1AF58:  MOVLW  A6
1AF5A:  MOVWF  FAC
1AF5C:  MOVLW  90
1AF5E:  MOVWF  FAB
1AF60:  CLRF   1E
1AF62:  CLRF   1D
1AF64:  CLRF   42
1AF66:  MOVLW  01
1AF68:  MOVWF  41
1AF6A:  MOVWF  48
1AF6C:  BCF    49.0
1AF6E:  BCF    49.1
1AF70:  BCF    49.2
1AF72:  MOVLB  0
1AF74:  CLRF   x62
1AF76:  MOVLB  2
1AF78:  MOVWF  xD5
1AF7A:  MOVLB  3
1AF7C:  CLRF   x37
1AF7E:  MOVLB  4
1AF80:  CLRF   xE3
1AF82:  MOVWF  xE9
1AF84:  MOVLW  04
1AF86:  MOVLB  7
1AF88:  MOVWF  x0F
1AF8A:  MOVLW  EA
1AF8C:  MOVWF  x0E
1AF8E:  MOVLB  8
1AF90:  CLRF   x53
1AF92:  CLRF   x52
1AF94:  CLRF   x57
1AF96:  CLRF   x56
1AF98:  CLRF   x55
1AF9A:  CLRF   x54
1AF9C:  CLRF   x5B
1AF9E:  CLRF   x5A
1AFA0:  CLRF   x59
1AFA2:  CLRF   x58
1AFA4:  MOVLW  00
1AFA6:  MOVLB  F
1AFA8:  MOVWF  x23
1AFAA:  MOVWF  x24
1AFAC:  MOVWF  x25
1AFAE:  BCF    FC1.3
1AFB0:  BCF    FC1.4
1AFB2:  BCF    FC1.5
1AFB4:  CLRF   x2E
1AFB6:  CLRF   x2F
1AFB8:  CLRF   x54
1AFBA:  BRA    1B07C
1AFBC:  DATA 44,02
1AFBE:  DATA D9,20
1AFC0:  DATA 64,72
1AFC2:  DATA 61,77
1AFC4:  DATA 5F,61
1AFC6:  DATA 6C,6C
1AFC8:  DATA 2E,63
1AFCA:  DATA 73,76
1AFCC:  DATA 00,20
1AFCE:  DATA 64,72
1AFD0:  DATA 61,77
1AFD2:  DATA 5F,6E
1AFD4:  DATA 65,77
1AFD6:  DATA 2E,63
1AFD8:  DATA 73,76
1AFDA:  DATA 00,20
1AFDC:  DATA 64,72
1AFDE:  DATA 65,6C
1AFE0:  DATA 5F,61
1AFE2:  DATA 6C,6C
1AFE4:  DATA 2E,63
1AFE6:  DATA 73,76
1AFE8:  DATA 00,20
1AFEA:  DATA 64,72
1AFEC:  DATA 65,6C
1AFEE:  DATA 5F,6E
1AFF0:  DATA 65,77
1AFF2:  DATA 2E,63
1AFF4:  DATA 73,76
1AFF6:  DATA 00,20
1AFF8:  DATA 65,76
1AFFA:  DATA 65,6E
1AFFC:  DATA 74,73
1AFFE:  DATA 2E,74
1B000:  DATA 78,74
1B002:  DATA 00,02
1B004:  DATA 03,35
1B006:  DATA 2C,00
1B008:  DATA 02,04
1B00A:  DATA D4,00
1B00C:  DATA 00,10
1B00E:  DATA 07,10
1B010:  DATA 46,41
1B012:  DATA 54,31
1B014:  DATA 32,46
1B016:  DATA 41,54
1B018:  DATA 31,36
1B01A:  DATA 46,41
1B01C:  DATA 54,33
1B01E:  DATA 32,00
1B020:  DATA 57,07
1B022:  DATA C9,0D
1B024:  DATA 0A,00
1B026:  DATA 00,03
1B028:  DATA 00,0F
1B02A:  DATA 00,1B
1B02C:  DATA 00,27
1B02E:  DATA 00,33
1B030:  DATA 00,3F
1B032:  DATA 00,4B
1B034:  DATA 00,57
1B036:  DATA 00,63
1B038:  DATA 00,6F
1B03A:  DATA 00,7B
1B03C:  DATA 00,87
1B03E:  DATA 00,93
1B040:  DATA 00,9F
1B042:  DATA 00,AB
1B044:  DATA 00,B7
1B046:  DATA 00,C3
1B048:  DATA 48,B1
1B04A:  DATA 70,D4
1B04C:  DATA 98,F7
1B04E:  DATA C0,1A
1B050:  DATA 00,CF
1B052:  DATA 28,F2
1B054:  DATA 50,15
1B056:  DATA 78,38
1B058:  DATA A0,5B
1B05A:  DATA C8,7E
1B05C:  DATA F0,A1
1B05E:  DATA 18,C5
1B060:  DATA 40,E8
1B062:  DATA 68,0B
1B064:  DATA 90,2E
1B066:  DATA B8,51
1B068:  DATA E0,74
1B06A:  DATA 08,98
1B06C:  DATA 30,BB
1B06E:  DATA 58,DE
1B070:  DATA 80,01
1B072:  DATA A8,24
1B074:  DATA D0,47
1B076:  DATA F8,6A
1B078:  DATA 20,8E
1B07A:  DATA 00,00
1B07C:  MOVLW  01
1B07E:  MOVWF  FF8
1B080:  MOVLW  AF
1B082:  MOVWF  FF7
1B084:  MOVLW  BC
1B086:  MOVWF  FF6
1B088:  TBLRD*+
1B08A:  MOVF   FF5,W
1B08C:  MOVWF  00
1B08E:  XORLW  00
1B090:  BZ    1B0B8
1B092:  TBLRD*+
1B094:  MOVF   FF5,W
1B096:  MOVWF  01
1B098:  BTFSC  FE8.7
1B09A:  BRA    1B0A6
1B09C:  ANDLW  0F
1B09E:  MOVWF  FEA
1B0A0:  TBLRD*+
1B0A2:  MOVFF  FF5,FE9
1B0A6:  BTFSC  01.6
1B0A8:  TBLRD*+
1B0AA:  BTFSS  01.6
1B0AC:  TBLRD*+
1B0AE:  MOVFF  FF5,FEE
1B0B2:  DCFSNZ 00,F
1B0B4:  BRA    1B088
1B0B6:  BRA    1B0AA
1B0B8:  CLRF   FF8
1B0BA:  MOVLB  8
1B0BC:  CLRF   x5C
1B0BE:  CLRF   x5E
1B0C0:  CLRF   x5D
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B0C2:  BCF    FF2.6
1B0C4:  BCF    FF2.7
1B0C6:  BTFSC  FF2.7
1B0C8:  BRA    1B0C4
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B0CA:  BCF    FC6.5
1B0CC:  MOVLW  21
1B0CE:  MOVWF  FC6
1B0D0:  MOVLW  40
1B0D2:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B0D4:  BCF    F67.5
1B0D6:  MOVLW  21
1B0D8:  MOVWF  F67
1B0DA:  MOVLW  40
1B0DC:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B0DE:  MOVLW  00
1B0E0:  MOVLB  F
1B0E2:  MOVWF  x23
1B0E4:  MOVWF  x24
1B0E6:  MOVLW  1F
1B0E8:  MOVWF  x25
1B0EA:  BCF    FC1.3
1B0EC:  BSF    FC1.4
1B0EE:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B0F0:  MOVF   FC0,W
1B0F2:  ANDLW  C0
1B0F4:  IORLW  07
1B0F6:  MOVWF  FC0
1B0F8:  BSF    FC0.7
1B0FA:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B0FC:  MOVLW  87
1B0FE:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B100:  MOVLW  37
1B102:  MOVWF  FCD
1B104:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B106:  MOVLB  0
1B108:  GOTO   2842
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B10C:  CLRF   FB0
1B10E:  MOVLW  07
1B110:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B112:  MOVLW  04
1B114:  MOVLB  F
1B116:  MOVWF  x2E
1B118:  MOVWF  x2F
1B11A:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B11C:  MOVLW  70
1B11E:  MOVWF  FD3
1B120:  MOVLW  40
1B122:  MOVWF  F9B
1B124:  CLRF   F64
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B126:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B128:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B12A:  MOVLB  0
1B12C:  CALL   287E
....................  
....................    enable_interrupts(GLOBAL); 
1B130:  MOVLW  C0
1B132:  IORWF  FF2,F
....................  
....................    init_hardware(); 
1B134:  CALL   28B8
....................    motor_sleep_rdy(); 
1B138:  CALL   2916
....................  
....................    sleep_mode = FALSE;    
1B13C:  BCF    49.1
....................    busy_set(); 
1B13E:  CALL   293E
....................     
....................    init_nv_vars(); 
1B142:  CALL   2A36
....................    get_step_vars(); 
1B146:  CALL   2C98
....................    init_aws(); 
1B14A:  GOTO   305A
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B14E:  CALL   3074
....................    blink(); 
1B152:  GOTO   307A
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B156:  CALL   30C6
....................     
....................    RTC_read(); 
1B15A:  CALL   32C2
....................    RTC_last_power(); 
1B15E:  GOTO   33C0
....................    RTC_reset_HT();   
1B162:  CALL   3430
....................    RTC_read(); 
1B166:  CALL   32C2
1B16A:  CLRF   1B
1B16C:  BTFSC  FF2.7
1B16E:  BSF    1B.7
1B170:  BCF    FF2.7
....................    RTC_read_flags(); 
1B172:  CALL   0DCC
1B176:  BTFSC  1B.7
1B178:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B17A:  MOVF   3B,F
1B17C:  BNZ   1B182
1B17E:  MOVF   3C,F
1B180:  BZ    1B1D2
1B182:  MOVLW  C4
1B184:  MOVWF  FF6
1B186:  MOVLW  27
1B188:  MOVWF  FF7
1B18A:  MOVLW  00
1B18C:  MOVWF  FF8
1B18E:  CLRF   1B
1B190:  BTFSC  FF2.7
1B192:  BSF    1B.7
1B194:  BCF    FF2.7
1B196:  MOVLW  04
1B198:  MOVLB  A
1B19A:  MOVWF  x18
1B19C:  MOVLB  0
1B19E:  CALL   1006
1B1A2:  BTFSC  1B.7
1B1A4:  BSF    FF2.7
1B1A6:  MOVLW  10
1B1A8:  MOVWF  FE9
1B1AA:  CLRF   1B
1B1AC:  BTFSC  FF2.7
1B1AE:  BSF    1B.7
1B1B0:  BCF    FF2.7
1B1B2:  MOVFF  3C,A19
1B1B6:  MOVFF  3B,A18
1B1BA:  CALL   1188
1B1BE:  BTFSC  1B.7
1B1C0:  BSF    FF2.7
1B1C2:  MOVLW  0D
1B1C4:  BTFSS  F9E.4
1B1C6:  BRA    1B1C4
1B1C8:  MOVWF  FAD
1B1CA:  MOVLW  0A
1B1CC:  BTFSS  F9E.4
1B1CE:  BRA    1B1CC
1B1D0:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B1D2:  CALL   3486
....................    sd_status = init_sdcard(); 
1B1D6:  CALL   4FB8
1B1DA:  MOVFF  01,2D8
....................    if(sd_status>0) msg_card_fail(); 
1B1DE:  MOVLB  2
1B1E0:  MOVF   xD8,F
1B1E2:  BZ    1B1EC
1B1E4:  MOVLB  0
1B1E6:  CALL   4FFE
1B1EA:  MOVLB  2
....................     
....................    reset_event(); 
1B1EC:  MOVLB  0
1B1EE:  GOTO   AB08
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B1F2:  MOVLB  7
1B1F4:  MOVF   x92,F
1B1F6:  BNZ   1B204
1B1F8:  MOVF   x93,F
1B1FA:  BNZ   1B204
1B1FC:  MOVF   x94,F
1B1FE:  BNZ   1B204
1B200:  MOVF   x95,F
1B202:  BZ    1B20C
1B204:  MOVLB  0
1B206:  CALL   9C4C
1B20A:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B20C:  MOVF   xAB,F
1B20E:  BNZ   1B292
1B210:  MOVF   xAC,F
1B212:  BNZ   1B292
....................       e_port[0]=0; 
1B214:  CLRF   xC0
1B216:  CLRF   xBF
....................       write16(ADDR_E1_PORT,0); 
1B218:  MOVLW  AA
1B21A:  MOVLB  8
1B21C:  MOVWF  xCA
1B21E:  CLRF   xCC
1B220:  CLRF   xCB
1B222:  MOVLB  0
1B224:  CALL   4F52
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B228:  MOVLW  CE
1B22A:  MOVWF  FF6
1B22C:  MOVLW  27
1B22E:  MOVWF  FF7
1B230:  MOVLW  00
1B232:  MOVWF  FF8
1B234:  CLRF   1B
1B236:  BTFSC  FF2.7
1B238:  BSF    1B.7
1B23A:  BCF    FF2.7
1B23C:  MOVLW  05
1B23E:  MOVLB  A
1B240:  MOVWF  x18
1B242:  MOVLB  0
1B244:  CALL   1006
1B248:  BTFSC  1B.7
1B24A:  BSF    FF2.7
1B24C:  MOVLW  10
1B24E:  MOVWF  FE9
1B250:  CLRF   1B
1B252:  BTFSC  FF2.7
1B254:  BSF    1B.7
1B256:  BCF    FF2.7
1B258:  MOVFF  7AC,A19
1B25C:  MOVFF  7AB,A18
1B260:  CALL   1188
1B264:  BTFSC  1B.7
1B266:  BSF    FF2.7
1B268:  MOVLW  2C
1B26A:  BTFSS  F9E.4
1B26C:  BRA    1B26A
1B26E:  MOVWF  FAD
1B270:  MOVLW  10
1B272:  MOVWF  FE9
1B274:  MOVFF  7C0,8CD
1B278:  MOVFF  7BF,8CC
1B27C:  CALL   8F2E
1B280:  MOVLW  0D
1B282:  BTFSS  F9E.4
1B284:  BRA    1B282
1B286:  MOVWF  FAD
1B288:  MOVLW  0A
1B28A:  BTFSS  F9E.4
1B28C:  BRA    1B28A
1B28E:  MOVWF  FAD
1B290:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B292:  MOVF   xAD,F
1B294:  BNZ   1B318
1B296:  MOVF   xAE,F
1B298:  BNZ   1B318
....................       m_lin_pos[1]=-1; 
1B29A:  SETF   xB2
1B29C:  SETF   xB1
....................       write16(ADDR_M2_LIN_POS, -1); 
1B29E:  MOVLW  B8
1B2A0:  MOVLB  8
1B2A2:  MOVWF  xCA
1B2A4:  SETF   xCC
1B2A6:  SETF   xCB
1B2A8:  MOVLB  0
1B2AA:  CALL   4F52
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B2AE:  MOVLW  DE
1B2B0:  MOVWF  FF6
1B2B2:  MOVLW  27
1B2B4:  MOVWF  FF7
1B2B6:  MOVLW  00
1B2B8:  MOVWF  FF8
1B2BA:  CLRF   1B
1B2BC:  BTFSC  FF2.7
1B2BE:  BSF    1B.7
1B2C0:  BCF    FF2.7
1B2C2:  MOVLW  05
1B2C4:  MOVLB  A
1B2C6:  MOVWF  x18
1B2C8:  MOVLB  0
1B2CA:  CALL   1006
1B2CE:  BTFSC  1B.7
1B2D0:  BSF    FF2.7
1B2D2:  MOVLW  10
1B2D4:  MOVWF  FE9
1B2D6:  CLRF   1B
1B2D8:  BTFSC  FF2.7
1B2DA:  BSF    1B.7
1B2DC:  BCF    FF2.7
1B2DE:  MOVFF  7AE,A19
1B2E2:  MOVFF  7AD,A18
1B2E6:  CALL   1188
1B2EA:  BTFSC  1B.7
1B2EC:  BSF    FF2.7
1B2EE:  MOVLW  2C
1B2F0:  BTFSS  F9E.4
1B2F2:  BRA    1B2F0
1B2F4:  MOVWF  FAD
1B2F6:  MOVLW  10
1B2F8:  MOVWF  FE9
1B2FA:  MOVFF  7B2,8CD
1B2FE:  MOVFF  7B1,8CC
1B302:  CALL   8F2E
1B306:  MOVLW  0D
1B308:  BTFSS  F9E.4
1B30A:  BRA    1B308
1B30C:  MOVWF  FAD
1B30E:  MOVLW  0A
1B310:  BTFSS  F9E.4
1B312:  BRA    1B310
1B314:  MOVWF  FAD
1B316:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1B318:  MOVF   31,F
1B31A:  BNZ   1B3BE
1B31C:  MOVF   32,F
1B31E:  BNZ   1B3BE
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1B320:  MOVLW  EE
1B322:  MOVWF  FF6
1B324:  MOVLW  27
1B326:  MOVWF  FF7
1B328:  MOVLW  00
1B32A:  MOVWF  FF8
1B32C:  CLRF   1B
1B32E:  BTFSC  FF2.7
1B330:  BSF    1B.7
1B332:  BCF    FF2.7
1B334:  MOVLB  0
1B336:  CALL   0E30
1B33A:  BTFSC  1B.7
1B33C:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1B33E:  MOVLB  8
1B340:  MOVF   x5E,F
1B342:  BNZ   1B370
1B344:  MOVF   x5D,W
1B346:  SUBLW  63
1B348:  BNC   1B370
1B34A:  MOVF   x5C,W
1B34C:  SUBLW  1B
1B34E:  BZ    1B370
....................       { 
....................          EscNum=TestForEsc(); 
1B350:  MOVLB  0
1B352:  GOTO   AD32
1B356:  MOVFF  01,85C
....................          if(EscNum == ESCAPE) command_prompt(); 
1B35A:  MOVLB  8
1B35C:  MOVF   x5C,W
1B35E:  SUBLW  1B
1B360:  BNZ   1B368
1B362:  MOVLB  0
1B364:  RCALL  1AE8E
1B366:  MOVLB  8
....................          EscCount++; 
1B368:  INCF   x5D,F
1B36A:  BTFSC  FD8.2
1B36C:  INCF   x5E,F
1B36E:  BRA    1B340
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1B370:  DECFSZ 33,W
1B372:  BRA    1B388
1B374:  MOVF   34,F
1B376:  BNZ   1B388
....................       { 
....................          arg=0; 
1B378:  CLRF   47
1B37A:  CLRF   46
1B37C:  CLRF   45
1B37E:  CLRF   44
....................          commandZ(); 
1B380:  MOVLB  0
1B382:  CALL   185CE
1B386:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1B388:  MOVLW  26
1B38A:  MOVWF  FF6
1B38C:  MOVLW  28
1B38E:  MOVWF  FF7
1B390:  MOVLW  00
1B392:  MOVWF  FF8
1B394:  CLRF   1B
1B396:  BTFSC  FF2.7
1B398:  BSF    1B.7
1B39A:  BCF    FF2.7
1B39C:  MOVLB  0
1B39E:  CALL   0E30
1B3A2:  BTFSC  1B.7
1B3A4:  BSF    FF2.7
....................       arg = 0; 
1B3A6:  CLRF   47
1B3A8:  CLRF   46
1B3AA:  CLRF   45
1B3AC:  CLRF   44
....................       commandM(TRUE); 
1B3AE:  MOVLW  01
1B3B0:  MOVLB  8
1B3B2:  MOVWF  x61
1B3B4:  MOVLB  0
1B3B6:  CALL   1689E
....................    } 
1B3BA:  BRA    1B3C2
1B3BC:  MOVLB  7
....................    else 
....................    { 
....................       command_prompt(); 
1B3BE:  MOVLB  0
1B3C0:  RCALL  1AE8E
....................    } 
....................  
....................    reset_cpu(); 
1B3C2:  RESET
.................... } 
....................  
1B3C4:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 2A78   PUT NOBROWNOUT BORV18 ZPBORM WDT_SW WDT1024
   Word  3: 0BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 NOMCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
