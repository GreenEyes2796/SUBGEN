CCS PCH C Compiler, Version 5.071d, 1               07-Jul-17 12:14
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   114878 bytes (88%)
                           Largest free fragment is 15830
               RAM used:   2148 (56%) at main() level
                           2649 (69%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1B572
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0EE0
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0F0A
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   1900
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E0C
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   16E2
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   1758
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E70
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 0D,0A
00668:  DATA 3F,40
0066A:  DATA 42,53
0066C:  DATA 59,0D
0066E:  DATA 0A,00
00670:  DATA 0D,0A
00672:  DATA 40,52
00674:  DATA 44,59
00676:  DATA 0D,0A
00678:  DATA 00,00
0067A:  DATA 40,46
0067C:  DATA 53,3A
0067E:  DATA 44,69
00680:  DATA 73,63
00682:  DATA 6F,76
00684:  DATA 65,72
00686:  DATA 79,0D
00688:  DATA 0A,00
0068A:  DATA 40,46
0068C:  DATA 53,3A
0068E:  DATA 55,6E
00690:  DATA 61,62
00692:  DATA 6C,65
00694:  DATA 20,74
00696:  DATA 6F,20
00698:  DATA 70,75
0069A:  DATA 74,20
0069C:  DATA 63,61
0069E:  DATA 72,64
006A0:  DATA 20,69
006A2:  DATA 6E,20
006A4:  DATA 69,64
006A6:  DATA 6C,65
006A8:  DATA 20,73
006AA:  DATA 74,61
006AC:  DATA 74,65
006AE:  DATA 2C,20
006B0:  DATA 72,65
006B2:  DATA 73,70
006B4:  DATA 6F,6E
006B6:  DATA 73,65
006B8:  DATA 20,3D
006BA:  DATA 20,25
006BC:  DATA 30,32
006BE:  DATA 78,0D
006C0:  DATA 0A,00
006C2:  DATA 40,46
006C4:  DATA 53,3A
006C6:  DATA 43,61
006C8:  DATA 72,64
006CA:  DATA 20,69
006CC:  DATA 64,6C
006CE:  DATA 65,2C
006D0:  DATA 20,72
006D2:  DATA 65,73
006D4:  DATA 70,6F
006D6:  DATA 6E,73
006D8:  DATA 65,20
006DA:  DATA 3D,20
006DC:  DATA 25,30
006DE:  DATA 32,78
006E0:  DATA 0D,0A
006E2:  DATA 00,00
006E4:  DATA 40,46
006E6:  DATA 53,3A
006E8:  DATA 52,65
006EA:  DATA 73,70
006EC:  DATA 6F,6E
006EE:  DATA 73,65
006F0:  DATA 20,74
006F2:  DATA 6F,20
006F4:  DATA 53,44
006F6:  DATA 20,76
006F8:  DATA 65,72
006FA:  DATA 20,32
006FC:  DATA 20,74
006FE:  DATA 65,73
00700:  DATA 74,20
00702:  DATA 43,4D
00704:  DATA 44,38
00706:  DATA 20,3D
00708:  DATA 20,25
0070A:  DATA 78,0D
0070C:  DATA 0A,00
0070E:  DATA 40,46
00710:  DATA 53,3A
00712:  DATA 50,6F
00714:  DATA 73,73
00716:  DATA 69,62
00718:  DATA 6C,65
0071A:  DATA 20,53
0071C:  DATA 44,76
0071E:  DATA 32,20
00720:  DATA 63,61
00722:  DATA 72,64
00724:  DATA 20,64
00726:  DATA 65,74
00728:  DATA 65,63
0072A:  DATA 74,65
0072C:  DATA 64,0D
0072E:  DATA 0A,00
00730:  DATA 40,46
00732:  DATA 53,3A
00734:  DATA 56,6F
00736:  DATA 6C,74
00738:  DATA 61,67
0073A:  DATA 65,20
0073C:  DATA 72,61
0073E:  DATA 6E,67
00740:  DATA 65,20
00742:  DATA 63,68
00744:  DATA 65,63
00746:  DATA 6B,2C
00748:  DATA 20,6F
0074A:  DATA 63,72
0074C:  DATA 20,3D
0074E:  DATA 20,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,25
0075C:  DATA 30,32
0075E:  DATA 78,0D
00760:  DATA 0A,00
00762:  DATA 40,46
00764:  DATA 53,3A
00766:  DATA 43,61
00768:  DATA 72,64
0076A:  DATA 20,56
0076C:  DATA 64,64
0076E:  DATA 20,72
00770:  DATA 61,6E
00772:  DATA 67,65
00774:  DATA 20,3D
00776:  DATA 20,32
00778:  DATA 2E,37
0077A:  DATA 2D,33
0077C:  DATA 2E,36
0077E:  DATA 20,76
00780:  DATA 6F,6C
00782:  DATA 74,73
00784:  DATA 0D,0A
00786:  DATA 00,00
00788:  DATA 40,46
0078A:  DATA 53,3A
0078C:  DATA 53,65
0078E:  DATA 6E,64
00790:  DATA 69,6E
00792:  DATA 67,20
00794:  DATA 41,43
00796:  DATA 4D,44
00798:  DATA 34,31
0079A:  DATA 20,63
0079C:  DATA 6F,6D
0079E:  DATA 6D,61
007A0:  DATA 6E,64
007A2:  DATA 20,74
007A4:  DATA 6F,20
007A6:  DATA 53,44
007A8:  DATA 20,76
007AA:  DATA 65,72
007AC:  DATA 20,32
007AE:  DATA 20,63
007B0:  DATA 61,72
007B2:  DATA 64,0D
007B4:  DATA 0A,00
007B6:  DATA 40,46
007B8:  DATA 53,3A
007BA:  DATA 52,65
007BC:  DATA 73,70
007BE:  DATA 6F,6E
007C0:  DATA 73,65
007C2:  DATA 20,66
007C4:  DATA 72,6F
007C6:  DATA 6D,20
007C8:  DATA 73,65
007CA:  DATA 6E,64
007CC:  DATA 69,6E
007CE:  DATA 67,20
007D0:  DATA 41,43
007D2:  DATA 4D,44
007D4:  DATA 34,31
007D6:  DATA 20,3D
007D8:  DATA 20,25
007DA:  DATA 30,32
007DC:  DATA 78,2C
007DE:  DATA 20,54
007E0:  DATA 69,6D
007E2:  DATA 65,72
007E4:  DATA 20,3D
007E6:  DATA 20,25
007E8:  DATA 6C,75
007EA:  DATA 0D,0A
007EC:  DATA 00,00
007EE:  DATA 40,46
007F0:  DATA 53,3A
007F2:  DATA 52,65
007F4:  DATA 73,70
007F6:  DATA 6F,6E
007F8:  DATA 73,65
007FA:  DATA 20,74
007FC:  DATA 6F,20
007FE:  DATA 43,4D
00800:  DATA 44,35
00802:  DATA 38,20
00804:  DATA 3D,20
00806:  DATA 25,78
00808:  DATA 0D,0A
0080A:  DATA 00,00
0080C:  DATA 40,46
0080E:  DATA 53,3A
00810:  DATA 53,65
00812:  DATA 6E,74
00814:  DATA 20,43
00816:  DATA 4D,44
00818:  DATA 20,35
0081A:  DATA 38,2C
0081C:  DATA 20,54
0081E:  DATA 69,6D
00820:  DATA 65,72
00822:  DATA 20,76
00824:  DATA 61,6C
00826:  DATA 75,65
00828:  DATA 20,3D
0082A:  DATA 20,25
0082C:  DATA 6C,75
0082E:  DATA 2C,20
00830:  DATA 6F,63
00832:  DATA 72,20
00834:  DATA 3D,20
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 25,30
00844:  DATA 32,78
00846:  DATA 0D,0A
00848:  DATA 00,00
0084A:  DATA 40,46
0084C:  DATA 53,3A
0084E:  DATA 43,61
00850:  DATA 72,64
00852:  DATA 20,43
00854:  DATA 41,4E
00856:  DATA 4E,4F
00858:  DATA 54,20
0085A:  DATA 77,6F
0085C:  DATA 72,6B
0085E:  DATA 20,56
00860:  DATA 64,64
00862:  DATA 20,72
00864:  DATA 61,6E
00866:  DATA 67,65
00868:  DATA 20,6F
0086A:  DATA 66,20
0086C:  DATA 32,2E
0086E:  DATA 37,2D
00870:  DATA 33,2E
00872:  DATA 36,20
00874:  DATA 76,6F
00876:  DATA 6C,74
00878:  DATA 73,0D
0087A:  DATA 0A,00
0087C:  DATA 40,46
0087E:  DATA 53,3A
00880:  DATA 4E,6F
00882:  DATA 74,20
00884:  DATA 61,6E
00886:  DATA 20,53
00888:  DATA 44,53
0088A:  DATA 43,20
0088C:  DATA 6F,72
0088E:  DATA 20,53
00890:  DATA 44,48
00892:  DATA 43,20
00894:  DATA 63,61
00896:  DATA 72,64
00898:  DATA 2C,20
0089A:  DATA 54,65
0089C:  DATA 73,74
0089E:  DATA 69,6E
008A0:  DATA 67,20
008A2:  DATA 66,6F
008A4:  DATA 72,20
008A6:  DATA 53,44
008A8:  DATA 20,56
008AA:  DATA 65,72
008AC:  DATA 31,20
008AE:  DATA 6F,72
008B0:  DATA 20,4D
008B2:  DATA 4D,43
008B4:  DATA 20,43
008B6:  DATA 61,72
008B8:  DATA 64,0D
008BA:  DATA 0A,00
008BC:  DATA 40,46
008BE:  DATA 53,3A
008C0:  DATA 52,65
008C2:  DATA 73,70
008C4:  DATA 6F,6E
008C6:  DATA 73,65
008C8:  DATA 20,66
008CA:  DATA 72,6F
008CC:  DATA 6D,20
008CE:  DATA 47,4F
008D0:  DATA 5F,49
008D2:  DATA 44,4C
008D4:  DATA 45,20
008D6:  DATA 3D,20
008D8:  DATA 25,30
008DA:  DATA 32,78
008DC:  DATA 0D,0A
008DE:  DATA 00,00
008E0:  DATA 40,46
008E2:  DATA 53,3A
008E4:  DATA 52,65
008E6:  DATA 73,70
008E8:  DATA 6F,6E
008EA:  DATA 73,65
008EC:  DATA 20,66
008EE:  DATA 72,6F
008F0:  DATA 6D,20
008F2:  DATA 53,44
008F4:  DATA 5F,43
008F6:  DATA 4D,44
008F8:  DATA 5F,53
008FA:  DATA 45,4E
008FC:  DATA 44,5F
008FE:  DATA 4F,50
00900:  DATA 5F,43
00902:  DATA 4F,4E
00904:  DATA 44,20
00906:  DATA 3D,20
00908:  DATA 25,30
0090A:  DATA 32,78
0090C:  DATA 2C,20
0090E:  DATA 54,69
00910:  DATA 6D,65
00912:  DATA 72,20
00914:  DATA 3D,20
00916:  DATA 25,6C
00918:  DATA 75,0D
0091A:  DATA 0A,00
0091C:  DATA 40,46
0091E:  DATA 53,3A
00920:  DATA 41,74
00922:  DATA 74,65
00924:  DATA 6D,70
00926:  DATA 74,69
00928:  DATA 6E,67
0092A:  DATA 20,53
0092C:  DATA 44,76
0092E:  DATA 31,20
00930:  DATA 76,65
00932:  DATA 72,73
00934:  DATA 75,73
00936:  DATA 20,4D
00938:  DATA 4D,43
0093A:  DATA 20,49
0093C:  DATA 44,2C
0093E:  DATA 20,52
00940:  DATA 65,73
00942:  DATA 70,6F
00944:  DATA 6E,73
00946:  DATA 65,20
00948:  DATA 66,72
0094A:  DATA 6F,6D
0094C:  DATA 20,53
0094E:  DATA 44,5F
00950:  DATA 43,4D
00952:  DATA 44,5F
00954:  DATA 41,50
00956:  DATA 50,4C
00958:  DATA 5F,43
0095A:  DATA 4D,44
0095C:  DATA 20,3D
0095E:  DATA 20,25
00960:  DATA 30,32
00962:  DATA 78,0D
00964:  DATA 0A,00
00966:  DATA 40,46
00968:  DATA 53,3A
0096A:  DATA 49,6E
0096C:  DATA 76,61
0096E:  DATA 6C,69
00970:  DATA 64,20
00972:  DATA 72,65
00974:  DATA 73,70
00976:  DATA 6F,6E
00978:  DATA 73,65
0097A:  DATA 20,74
0097C:  DATA 6F,20
0097E:  DATA 53,44
00980:  DATA 5F,41
00982:  DATA 43,4D
00984:  DATA 44,34
00986:  DATA 31,2C
00988:  DATA 20,72
0098A:  DATA 65,73
0098C:  DATA 70,6F
0098E:  DATA 6E,73
00990:  DATA 65,20
00992:  DATA 3D,20
00994:  DATA 25,30
00996:  DATA 32,58
00998:  DATA 2C,20
0099A:  DATA 72,65
0099C:  DATA 69,6E
0099E:  DATA 69,74
009A0:  DATA 69,61
009A2:  DATA 6C,69
009A4:  DATA 7A,69
009A6:  DATA 6E,67
009A8:  DATA 20,61
009AA:  DATA 73,20
009AC:  DATA 4D,4D
009AE:  DATA 43,0D
009B0:  DATA 0A,00
009B2:  DATA 40,46
009B4:  DATA 53,3A
009B6:  DATA 46,61
009B8:  DATA 69,6C
009BA:  DATA 65,64
009BC:  DATA 20,74
009BE:  DATA 6F,20
009C0:  DATA 69,6E
009C2:  DATA 69,74
009C4:  DATA 69,61
009C6:  DATA 6C,69
009C8:  DATA 7A,65
009CA:  DATA 20,61
009CC:  DATA 73,20
009CE:  DATA 4D,4D
009D0:  DATA 43,2C
009D2:  DATA 20,72
009D4:  DATA 65,73
009D6:  DATA 70,6F
009D8:  DATA 6E,73
009DA:  DATA 65,20
009DC:  DATA 3D,20
009DE:  DATA 25,30
009E0:  DATA 32,58
009E2:  DATA 2C,20
009E4:  DATA 65,78
009E6:  DATA 69,74
009E8:  DATA 69,6E
009EA:  DATA 67,0D
009EC:  DATA 0A,00
009EE:  DATA 40,46
009F0:  DATA 53,3A
009F2:  DATA 43,61
009F4:  DATA 72,64
009F6:  DATA 20,66
009F8:  DATA 61,69
009FA:  DATA 6C,65
009FC:  DATA 64,20
009FE:  DATA 74,6F
00A00:  DATA 20,72
00A02:  DATA 65,73
00A04:  DATA 70,6F
00A06:  DATA 6E,64
00A08:  DATA 20,63
00A0A:  DATA 6F,72
00A0C:  DATA 72,65
00A0E:  DATA 63,6C
00A10:  DATA 79,20
00A12:  DATA 61,66
00A14:  DATA 74,65
00A16:  DATA 72,20
00A18:  DATA 53,44
00A1A:  DATA 5F,43
00A1C:  DATA 4D,44
00A1E:  DATA 5F,53
00A20:  DATA 45,4E
00A22:  DATA 44,5F
00A24:  DATA 4F,50
00A26:  DATA 5F,43
00A28:  DATA 4F,4E
00A2A:  DATA 44,2C
00A2C:  DATA 20,72
00A2E:  DATA 65,73
00A30:  DATA 70,6F
00A32:  DATA 6E,73
00A34:  DATA 65,20
00A36:  DATA 3D,20
00A38:  DATA 25,30
00A3A:  DATA 32,58
00A3C:  DATA 2C,20
00A3E:  DATA 54,69
00A40:  DATA 6D,65
00A42:  DATA 72,20
00A44:  DATA 3D,20
00A46:  DATA 25,6C
00A48:  DATA 75,0D
00A4A:  DATA 0A,00
00A4C:  DATA 40,46
00A4E:  DATA 53,3A
00A50:  DATA 53,65
00A52:  DATA 74,74
00A54:  DATA 69,6E
00A56:  DATA 67,20
00A58:  DATA 62,6C
00A5A:  DATA 6F,63
00A5C:  DATA 6B,20
00A5E:  DATA 6C,65
00A60:  DATA 6E,67
00A62:  DATA 74,68
00A64:  DATA 0D,0A
00A66:  DATA 00,00
00A68:  DATA 40,46
00A6A:  DATA 53,3A
00A6C:  DATA 45,72
00A6E:  DATA 72,6F
00A70:  DATA 72,20
00A72:  DATA 73,65
00A74:  DATA 74,74
00A76:  DATA 69,6E
00A78:  DATA 67,20
00A7A:  DATA 62,6C
00A7C:  DATA 6F,63
00A7E:  DATA 6B,20
00A80:  DATA 6C,65
00A82:  DATA 6E,67
00A84:  DATA 74,68
00A86:  DATA 2C,20
00A88:  DATA 72,65
00A8A:  DATA 73,70
00A8C:  DATA 6F,6E
00A8E:  DATA 73,65
00A90:  DATA 20,3D
00A92:  DATA 20,25
00A94:  DATA 30,32
00A96:  DATA 78,2C
00A98:  DATA 20,74
00A9A:  DATA 69,6D
00A9C:  DATA 65,72
00A9E:  DATA 20,3D
00AA0:  DATA 20,25
00AA2:  DATA 6C,75
00AA4:  DATA 0D,0A
00AA6:  DATA 00,00
00AA8:  DATA 40,46
00AAA:  DATA 53,3A
00AAC:  DATA 43,61
00AAE:  DATA 72,64
00AB0:  DATA 20,54
00AB2:  DATA 79,70
00AB4:  DATA 65,20
00AB6:  DATA 44,69
00AB8:  DATA 73,63
00ABA:  DATA 6F,76
00ABC:  DATA 65,72
00ABE:  DATA 79,20
00AC0:  DATA 45,72
00AC2:  DATA 72,6F
00AC4:  DATA 72,0D
00AC6:  DATA 0A,00
00AC8:  DATA 40,46
00ACA:  DATA 53,3A
00ACC:  DATA 4D,4D
00ACE:  DATA 43,20
00AD0:  DATA 43,61
00AD2:  DATA 72,64
00AD4:  DATA 20,66
00AD6:  DATA 6F,75
00AD8:  DATA 6E,64
00ADA:  DATA 0D,0A
00ADC:  DATA 00,00
00ADE:  DATA 40,46
00AE0:  DATA 53,3A
00AE2:  DATA 53,44
00AE4:  DATA 76,31
00AE6:  DATA 20,43
00AE8:  DATA 61,72
00AEA:  DATA 64,20
00AEC:  DATA 66,6F
00AEE:  DATA 75,6E
00AF0:  DATA 64,0D
00AF2:  DATA 0A,00
00AF4:  DATA 40,46
00AF6:  DATA 53,3A
00AF8:  DATA 53,44
00AFA:  DATA 53,43
00AFC:  DATA 20,43
00AFE:  DATA 61,72
00B00:  DATA 64,20
00B02:  DATA 66,6F
00B04:  DATA 75,6E
00B06:  DATA 64,0D
00B08:  DATA 0A,00
00B0A:  DATA 40,46
00B0C:  DATA 53,3A
00B0E:  DATA 53,44
00B10:  DATA 48,43
00B12:  DATA 20,43
00B14:  DATA 61,72
00B16:  DATA 64,20
00B18:  DATA 66,6F
00B1A:  DATA 75,6E
00B1C:  DATA 64,0D
00B1E:  DATA 0A,00
00B20:  DATA 40,46
00B22:  DATA 53,3A
00B24:  DATA 43,61
00B26:  DATA 72,64
00B28:  DATA 20,54
00B2A:  DATA 79,70
00B2C:  DATA 65,20
00B2E:  DATA 44,69
00B30:  DATA 73,63
00B32:  DATA 6F,76
00B34:  DATA 65,72
00B36:  DATA 79,20
00B38:  DATA 45,72
00B3A:  DATA 72,6F
00B3C:  DATA 72,2C
00B3E:  DATA 20,43
00B40:  DATA 61,72
00B42:  DATA 64,20
00B44:  DATA 3D,20
00B46:  DATA 25,30
00B48:  DATA 32,58
00B4A:  DATA 0D,0A
00B4C:  DATA 00,00
00B4E:  DATA 40,46
00B50:  DATA 53,3A
00B52:  DATA 43,61
00B54:  DATA 72,64
00B56:  DATA 20,72
00B58:  DATA 65,73
00B5A:  DATA 65,74
00B5C:  DATA 20,73
00B5E:  DATA 75,63
00B60:  DATA 63,65
00B62:  DATA 73,73
00B64:  DATA 20,2D
00B66:  DATA 20,43
00B68:  DATA 6D,64
00B6A:  DATA 20,74
00B6C:  DATA 6F,20
00B6E:  DATA 52,65
00B70:  DATA 61,64
00B72:  DATA 79,20
00B74:  DATA 63,6F
00B76:  DATA 75,6E
00B78:  DATA 74,20
00B7A:  DATA 3D,20
00B7C:  DATA 25,6C
00B7E:  DATA 75,0D
00B80:  DATA 0A,00
00B82:  DATA 40,46
00B84:  DATA 53,3A
00B86:  DATA 53,50
00B88:  DATA 49,20
00B8A:  DATA 62,75
00B8C:  DATA 73,20
00B8E:  DATA 73,70
00B90:  DATA 65,65
00B92:  DATA 64,20
00B94:  DATA 73,65
00B96:  DATA 74,20
00B98:  DATA 74,6F
00B9A:  DATA 20,68
00B9C:  DATA 69,67
00B9E:  DATA 68,0D
00BA0:  DATA 0A,00
00BA2:  DATA 40,46
00BA4:  DATA 53,3A
00BA6:  DATA 43,61
00BA8:  DATA 72,64
00BAA:  DATA 20,61
00BAC:  DATA 63,74
00BAE:  DATA 69,76
00BB0:  DATA 61,74
00BB2:  DATA 65,20
00BB4:  DATA 66,61
00BB6:  DATA 69,6C
00BB8:  DATA 75,72
00BBA:  DATA 65,2C
00BBC:  DATA 20,72
00BBE:  DATA 65,73
00BC0:  DATA 70,6F
00BC2:  DATA 6E,73
00BC4:  DATA 65,20
00BC6:  DATA 3D,20
00BC8:  DATA 25,30
00BCA:  DATA 32,58
00BCC:  DATA 2C,20
00BCE:  DATA 54,69
00BD0:  DATA 6D,65
00BD2:  DATA 72,20
00BD4:  DATA 3D,20
00BD6:  DATA 25,6C
00BD8:  DATA 75,0D
00BDA:  DATA 0A,00
00BDC:  DATA 40,46
00BDE:  DATA 53,3A
00BE0:  DATA 43,61
00BE2:  DATA 72,64
00BE4:  DATA 20,61
00BE6:  DATA 63,74
00BE8:  DATA 69,76
00BEA:  DATA 61,74
00BEC:  DATA 65,20
00BEE:  DATA 73,75
00BF0:  DATA 63,63
00BF2:  DATA 65,73
00BF4:  DATA 73,20
00BF6:  DATA 6F,6E
00BF8:  DATA 20,61
00BFA:  DATA 74,74
00BFC:  DATA 65,6D
00BFE:  DATA 70,74
00C00:  DATA 20,25
00C02:  DATA 6C,75
00C04:  DATA 0D,0A
00C06:  DATA 00,00
00C08:  DATA 46,41
00C0A:  DATA 54,20
00C0C:  DATA 61,74
00C0E:  DATA 20,73
00C10:  DATA 65,63
00C12:  DATA 74,6F
00C14:  DATA 72,20
00C16:  DATA 30,0D
00C18:  DATA 0A,00
00C1A:  DATA 54,59
00C1C:  DATA 50,45
00C1E:  DATA 20,63
00C20:  DATA 6F,6D
00C22:  DATA 6D,61
00C24:  DATA 6E,64
00C26:  DATA 20,45
00C28:  DATA 52,52
00C2A:  DATA 4F,52
00C2C:  DATA 0D,0A
00C2E:  DATA 00,00
00C30:  DATA 40,46
00C32:  DATA 53,3A
00C34:  DATA 20,25
00C36:  DATA 73,0D
00C38:  DATA 0A,00
00C3A:  DATA 40,46
00C3C:  DATA 53,3A
00C3E:  DATA 20,25
00C40:  DATA 73,0D
00C42:  DATA 0A,00
00C44:  DATA 2A,2A
00C46:  DATA 20,40
00C48:  DATA 46,53
00C4A:  DATA 3A,20
00C4C:  DATA 45,52
00C4E:  DATA 52,4F
00C50:  DATA 52,0D
00C52:  DATA 0A,00
00C54:  DATA 20,20
00C56:  DATA 20,4E
00C58:  DATA 6F,45
00C5A:  DATA 72,72
00C5C:  DATA 6F,72
00C5E:  DATA 0D,0A
00C60:  DATA 00,00
00C62:  DATA 20,20
00C64:  DATA 20,4D
00C66:  DATA 65,64
00C68:  DATA 69,61
00C6A:  DATA 20,4E
00C6C:  DATA 6F,74
00C6E:  DATA 20,52
00C70:  DATA 65,61
00C72:  DATA 64,79
00C74:  DATA 0D,0A
00C76:  DATA 00,00
00C78:  DATA 20,20
00C7A:  DATA 20,46
00C7C:  DATA 69,6C
00C7E:  DATA 65,20
00C80:  DATA 4E,6F
00C82:  DATA 74,20
00C84:  DATA 46,6F
00C86:  DATA 75,6E
00C88:  DATA 64,0D
00C8A:  DATA 0A,00
00C8C:  DATA 20,20
00C8E:  DATA 20,49
00C90:  DATA 6E,76
00C92:  DATA 61,6C
00C94:  DATA 69,64
00C96:  DATA 20,50
00C98:  DATA 61,74
00C9A:  DATA 68,0D
00C9C:  DATA 0A,00
00C9E:  DATA 20,20
00CA0:  DATA 20,49
00CA2:  DATA 6E,76
00CA4:  DATA 61,6C
00CA6:  DATA 69,64
00CA8:  DATA 20,4E
00CAA:  DATA 61,6D
00CAC:  DATA 65,0D
00CAE:  DATA 0A,00
00CB0:  DATA 20,20
00CB2:  DATA 20,41
00CB4:  DATA 63,63
00CB6:  DATA 65,73
00CB8:  DATA 73,20
00CBA:  DATA 44,65
00CBC:  DATA 6E,69
00CBE:  DATA 65,64
00CC0:  DATA 0D,0A
00CC2:  DATA 00,00
00CC4:  DATA 20,20
00CC6:  DATA 20,44
00CC8:  DATA 69,73
00CCA:  DATA 6B,20
00CCC:  DATA 46,75
00CCE:  DATA 6C,6C
00CD0:  DATA 0D,0A
00CD2:  DATA 00,00
00CD4:  DATA 20,20
00CD6:  DATA 20,52
00CD8:  DATA 65,61
00CDA:  DATA 64,2F
00CDC:  DATA 57,72
00CDE:  DATA 69,74
00CE0:  DATA 65,20
00CE2:  DATA 45,72
00CE4:  DATA 72,6F
00CE6:  DATA 72,0D
00CE8:  DATA 0A,00
00CEA:  DATA 20,20
00CEC:  DATA 20,49
00CEE:  DATA 6E,63
00CF0:  DATA 6F,72
00CF2:  DATA 72,65
00CF4:  DATA 63,74
00CF6:  DATA 20,4D
00CF8:  DATA 65,64
00CFA:  DATA 69,61
00CFC:  DATA 20,43
00CFE:  DATA 68,61
00D00:  DATA 6E,67
00D02:  DATA 65,0D
00D04:  DATA 0A,00
00D06:  DATA 20,20
00D08:  DATA 20,57
00D0A:  DATA 72,69
00D0C:  DATA 74,65
00D0E:  DATA 20,50
00D10:  DATA 72,6F
00D12:  DATA 74,65
00D14:  DATA 63,74
00D16:  DATA 65,64
00D18:  DATA 0D,0A
00D1A:  DATA 00,00
00D1C:  DATA 20,20
00D1E:  DATA 20,4E
00D20:  DATA 6F,74
00D22:  DATA 20,45
00D24:  DATA 6E,61
00D26:  DATA 62,6C
00D28:  DATA 65,64
00D2A:  DATA 0D,0A
00D2C:  DATA 00,00
00D2E:  DATA 20,20
00D30:  DATA 20,4E
00D32:  DATA 6F,20
00D34:  DATA 46,69
00D36:  DATA 6C,65
00D38:  DATA 20,53
00D3A:  DATA 79,73
00D3C:  DATA 74,65
00D3E:  DATA 6D,0D
00D40:  DATA 0A,00
00D42:  DATA 61,70
00D44:  DATA 70,65
00D46:  DATA 6E,64
00D48:  DATA 3A,20
00D4A:  DATA 46,53
00D4C:  DATA 20,45
00D4E:  DATA 52,52
00D50:  DATA 4F,52
00D52:  DATA 20,6F
00D54:  DATA 6E,20
00D56:  DATA 66,69
00D58:  DATA 6C,65
00D5A:  DATA 5F,6F
00D5C:  DATA 70,65
00D5E:  DATA 6E,0D
00D60:  DATA 0A,00
00D62:  DATA 40,46
00D64:  DATA 53,3A
00D66:  DATA 57,72
00D68:  DATA 69,74
00D6A:  DATA 69,6E
00D6C:  DATA 67,0D
00D6E:  DATA 0A,5B
00D70:  DATA 25,73
00D72:  DATA 5D,0D
00D74:  DATA 0A,00
00D76:  DATA 40,46
00D78:  DATA 53,3A
00D7A:  DATA 45,52
00D7C:  DATA 52,4F
00D7E:  DATA 52,5B
00D80:  DATA 61,70
00D82:  DATA 70,65
00D84:  DATA 6E,64
00D86:  DATA 5D,0D
00D88:  DATA 0A,00
00D8A:  DATA 40,46
00D8C:  DATA 53,3A
00D8E:  DATA 43,6C
00D90:  DATA 6F,73
00D92:  DATA 69,6E
00D94:  DATA 67,0D
00D96:  DATA 0A,00
00D98:  DATA 40,52
00D9A:  DATA 54,43
00D9C:  DATA 3A,25
00D9E:  DATA 30,32
00DA0:  DATA 75,2F
00DA2:  DATA 00,00
00DA4:  DATA 40,52
00DA6:  DATA 54,43
00DA8:  DATA 3A,25
00DAA:  DATA 30,32
00DAC:  DATA 75,2F
00DAE:  DATA 00,00
00DB0:  DATA 40,41
00DB2:  DATA 4C,4D
00DB4:  DATA 3A,25
00DB6:  DATA 30,32
00DB8:  DATA 75,2F
00DBA:  DATA 00,00
00DBC:  DATA 40,41
00DBE:  DATA 4C,4D
00DC0:  DATA 3A,25
00DC2:  DATA 30,32
00DC4:  DATA 75,2F
00DC6:  DATA 00,00
00DC8:  DATA 40,41
00DCA:  DATA 4C,4D
00DCC:  DATA 0D,0A
00DCE:  DATA 00,00
*
00E46:  TBLRD*+
00E48:  MOVF   FF5,F
00E4A:  BZ    0E6E
00E4C:  MOVFF  FF6,A38
00E50:  MOVFF  FF7,A39
00E54:  MOVFF  FF8,A3A
00E58:  MOVF   FF5,W
00E5A:  BTFSS  F9E.4
00E5C:  BRA    0E5A
00E5E:  MOVWF  FAD
00E60:  MOVFF  A38,FF6
00E64:  MOVFF  A39,FF7
00E68:  MOVFF  A3A,FF8
00E6C:  BRA    0E46
00E6E:  RETURN 0
*
00ED0:  DATA 3F,40
00ED2:  DATA 42,53
00ED4:  DATA 59,0D
00ED6:  DATA 0A,00
00ED8:  DATA 40,52
00EDA:  DATA 44,59
00EDC:  DATA 0D,0A
00EDE:  DATA 00,00
*
00F20:  DATA 40,5B
00F22:  DATA 4F,5D
00F24:  DATA 0D,0A
00F26:  DATA 00,00
00F28:  DATA 40,43
00F2A:  DATA 4D,44
00F2C:  DATA 20,74
00F2E:  DATA 6F,6F
00F30:  DATA 20,6C
00F32:  DATA 6F,6E
00F34:  DATA 67,0D
00F36:  DATA 0A,00
00F38:  DATA 40,5B
00F3A:  DATA 43,5D
00F3C:  DATA 0D,0A
00F3E:  DATA 00,00
00F40:  DATA 40,53
00F42:  DATA 4C,45
00F44:  DATA 45,50
00F46:  DATA 0D,0A
00F48:  DATA 00,00
00F4A:  DATA 40,4D
00F4C:  DATA 45,52
00F4E:  DATA 2C,25
00F50:  DATA 4C,75
00F52:  DATA 2C,25
00F54:  DATA 4C,75
00F56:  DATA 0D,0A
00F58:  DATA 00,00
00F5A:  DATA 6D,3A
00F5C:  DATA 25,75
00F5E:  DATA 2C,25
00F60:  DATA 75,20
00F62:  DATA 63,3A
00F64:  DATA 25,4C
00F66:  DATA 75,2C
00F68:  DATA 25,4C
00F6A:  DATA 75,2C
00F6C:  DATA 25,4C
00F6E:  DATA 75,0D
00F70:  DATA 0A,00
00F72:  MOVLB  A
00F74:  MOVF   x43,W
00F76:  CLRF   01
00F78:  SUBWF  x42,W
00F7A:  BC    0F82
00F7C:  MOVFF  A42,00
00F80:  BRA    0F9A
00F82:  CLRF   00
00F84:  MOVLW  08
00F86:  MOVWF  x44
00F88:  RLCF   x42,F
00F8A:  RLCF   00,F
00F8C:  MOVF   x43,W
00F8E:  SUBWF  00,W
00F90:  BTFSC  FD8.0
00F92:  MOVWF  00
00F94:  RLCF   01,F
00F96:  DECFSZ x44,F
00F98:  BRA    0F88
00F9A:  MOVLB  0
00F9C:  RETURN 0
00F9E:  MOVF   01,W
00FA0:  MOVFF  A40,A42
00FA4:  MOVLW  64
00FA6:  MOVLB  A
00FA8:  MOVWF  x43
00FAA:  MOVLB  0
00FAC:  RCALL  0F72
00FAE:  MOVFF  00,A40
00FB2:  MOVF   01,W
00FB4:  MOVLW  30
00FB6:  BNZ   0FC8
00FB8:  MOVLB  A
00FBA:  BTFSS  x41.1
00FBC:  BRA    0FDA
00FBE:  BTFSC  x41.3
00FC0:  BRA    0FDA
00FC2:  BTFSC  x41.4
00FC4:  MOVLW  20
00FC6:  BRA    0FD0
00FC8:  MOVLB  A
00FCA:  BCF    x41.3
00FCC:  BCF    x41.4
00FCE:  BSF    x41.0
00FD0:  ADDWF  01,F
00FD2:  MOVF   01,W
00FD4:  BTFSS  F9E.4
00FD6:  BRA    0FD4
00FD8:  MOVWF  FAD
00FDA:  MOVFF  A40,A42
00FDE:  MOVLW  0A
00FE0:  MOVWF  x43
00FE2:  MOVLB  0
00FE4:  RCALL  0F72
00FE6:  MOVFF  00,A40
00FEA:  MOVF   01,W
00FEC:  MOVLW  30
00FEE:  BNZ   1000
00FF0:  MOVLB  A
00FF2:  BTFSC  x41.3
00FF4:  BRA    100C
00FF6:  BTFSS  x41.0
00FF8:  BRA    100C
00FFA:  BTFSC  x41.4
00FFC:  MOVLW  20
00FFE:  MOVLB  0
01000:  ADDWF  01,F
01002:  MOVF   01,W
01004:  BTFSS  F9E.4
01006:  BRA    1004
01008:  MOVWF  FAD
0100A:  MOVLB  A
0100C:  MOVLW  30
0100E:  ADDWF  x40,F
01010:  MOVF   x40,W
01012:  BTFSS  F9E.4
01014:  BRA    1012
01016:  MOVWF  FAD
01018:  MOVLB  0
0101A:  RETURN 0
0101C:  TBLRD*+
0101E:  MOVFF  FF6,A41
01022:  MOVFF  FF7,A42
01026:  MOVFF  FF8,A43
0102A:  MOVF   FF5,W
0102C:  BTFSS  F9E.4
0102E:  BRA    102C
01030:  MOVWF  FAD
01032:  MOVFF  A41,FF6
01036:  MOVFF  A42,FF7
0103A:  MOVFF  A43,FF8
0103E:  MOVLB  A
01040:  DECFSZ x40,F
01042:  BRA    1046
01044:  BRA    104A
01046:  MOVLB  0
01048:  BRA    101C
0104A:  MOVLB  0
0104C:  RETURN 0
0104E:  BTFSC  FD8.1
01050:  BRA    105A
01052:  MOVLW  0A
01054:  MOVWF  FEA
01056:  MOVLW  54
01058:  MOVWF  FE9
0105A:  CLRF   00
0105C:  CLRF   01
0105E:  CLRF   02
01060:  CLRF   03
01062:  MOVLB  A
01064:  CLRF   x54
01066:  CLRF   x55
01068:  CLRF   x56
0106A:  CLRF   x57
0106C:  MOVF   x53,W
0106E:  IORWF  x52,W
01070:  IORWF  x51,W
01072:  IORWF  x50,W
01074:  BZ    10CE
01076:  MOVLW  20
01078:  MOVWF  x58
0107A:  BCF    FD8.0
0107C:  RLCF   x4C,F
0107E:  RLCF   x4D,F
01080:  RLCF   x4E,F
01082:  RLCF   x4F,F
01084:  RLCF   x54,F
01086:  RLCF   x55,F
01088:  RLCF   x56,F
0108A:  RLCF   x57,F
0108C:  MOVF   x53,W
0108E:  SUBWF  x57,W
01090:  BNZ   10A2
01092:  MOVF   x52,W
01094:  SUBWF  x56,W
01096:  BNZ   10A2
01098:  MOVF   x51,W
0109A:  SUBWF  x55,W
0109C:  BNZ   10A2
0109E:  MOVF   x50,W
010A0:  SUBWF  x54,W
010A2:  BNC   10C2
010A4:  MOVF   x50,W
010A6:  SUBWF  x54,F
010A8:  MOVF   x51,W
010AA:  BTFSS  FD8.0
010AC:  INCFSZ x51,W
010AE:  SUBWF  x55,F
010B0:  MOVF   x52,W
010B2:  BTFSS  FD8.0
010B4:  INCFSZ x52,W
010B6:  SUBWF  x56,F
010B8:  MOVF   x53,W
010BA:  BTFSS  FD8.0
010BC:  INCFSZ x53,W
010BE:  SUBWF  x57,F
010C0:  BSF    FD8.0
010C2:  RLCF   00,F
010C4:  RLCF   01,F
010C6:  RLCF   02,F
010C8:  RLCF   03,F
010CA:  DECFSZ x58,F
010CC:  BRA    107A
010CE:  MOVFF  A54,FEF
010D2:  MOVFF  A55,FEC
010D6:  MOVFF  A56,FEC
010DA:  MOVFF  A57,FEC
010DE:  MOVLB  0
010E0:  RETURN 0
010E2:  MOVF   FE9,W
010E4:  MOVLB  A
010E6:  MOVWF  x44
010E8:  MOVLW  3B
010EA:  MOVWF  x4B
010EC:  MOVLW  9A
010EE:  MOVWF  x4A
010F0:  MOVLW  CA
010F2:  MOVWF  x49
010F4:  CLRF   x48
010F6:  MOVLW  0A
010F8:  MOVWF  x46
010FA:  BSF    FD8.1
010FC:  MOVLW  0A
010FE:  MOVWF  FEA
01100:  MOVLW  40
01102:  MOVWF  FE9
01104:  MOVFF  A43,A4F
01108:  MOVFF  A42,A4E
0110C:  MOVFF  A41,A4D
01110:  MOVFF  A40,A4C
01114:  MOVFF  A4B,A53
01118:  MOVFF  A4A,A52
0111C:  MOVFF  A49,A51
01120:  MOVFF  A48,A50
01124:  MOVLB  0
01126:  RCALL  104E
01128:  MOVF   01,W
0112A:  MOVF   00,F
0112C:  BNZ   1154
0112E:  MOVLB  A
01130:  MOVF   x46,W
01132:  XORLW  01
01134:  BTFSS  FD8.2
01136:  BRA    113C
01138:  MOVLB  0
0113A:  BRA    1154
0113C:  MOVF   x44,W
0113E:  BZ    1158
01140:  ANDLW  0F
01142:  SUBWF  x46,W
01144:  BZ    1148
01146:  BC    1164
01148:  BTFSC  x44.7
0114A:  BRA    1164
0114C:  BTFSC  x44.6
0114E:  BRA    1158
01150:  MOVLW  20
01152:  BRA    115A
01154:  MOVLB  A
01156:  CLRF   x44
01158:  MOVLW  30
0115A:  ADDWF  00,F
0115C:  MOVF   00,W
0115E:  BTFSS  F9E.4
01160:  BRA    115E
01162:  MOVWF  FAD
01164:  BCF    FD8.1
01166:  MOVFF  A4B,A4F
0116A:  MOVFF  A4A,A4E
0116E:  MOVFF  A49,A4D
01172:  MOVFF  A48,A4C
01176:  CLRF   x53
01178:  CLRF   x52
0117A:  CLRF   x51
0117C:  MOVLW  0A
0117E:  MOVWF  x50
01180:  MOVLB  0
01182:  RCALL  104E
01184:  MOVFF  03,A4B
01188:  MOVFF  02,A4A
0118C:  MOVFF  01,A49
01190:  MOVFF  00,A48
01194:  MOVLB  A
01196:  DECFSZ x46,F
01198:  BRA    10FA
0119A:  MOVLB  0
0119C:  RETURN 0
0119E:  MOVFF  FEA,A48
011A2:  MOVFF  FE9,A47
011A6:  MOVLB  A
011A8:  SWAPF  x41,W
011AA:  IORLW  F0
011AC:  MOVWF  x43
011AE:  ADDWF  x43,F
011B0:  ADDLW  E2
011B2:  MOVWF  x44
011B4:  ADDLW  32
011B6:  MOVWF  x46
011B8:  MOVF   x41,W
011BA:  ANDLW  0F
011BC:  ADDWF  x44,F
011BE:  ADDWF  x44,F
011C0:  ADDWF  x46,F
011C2:  ADDLW  E9
011C4:  MOVWF  x45
011C6:  ADDWF  x45,F
011C8:  ADDWF  x45,F
011CA:  SWAPF  x40,W
011CC:  ANDLW  0F
011CE:  ADDWF  x45,F
011D0:  ADDWF  x46,F
011D2:  RLCF   x45,F
011D4:  RLCF   x46,F
011D6:  COMF   x46,F
011D8:  RLCF   x46,F
011DA:  MOVF   x40,W
011DC:  ANDLW  0F
011DE:  ADDWF  x46,F
011E0:  RLCF   x43,F
011E2:  MOVLW  07
011E4:  MOVWF  x42
011E6:  MOVLW  0A
011E8:  DECF   x45,F
011EA:  ADDWF  x46,F
011EC:  BNC   11E8
011EE:  DECF   x44,F
011F0:  ADDWF  x45,F
011F2:  BNC   11EE
011F4:  DECF   x43,F
011F6:  ADDWF  x44,F
011F8:  BNC   11F4
011FA:  DECF   x42,F
011FC:  ADDWF  x43,F
011FE:  BNC   11FA
01200:  MOVLW  0A
01202:  MOVWF  FEA
01204:  MOVLW  42
01206:  MOVWF  FE9
01208:  MOVLW  07
0120A:  ANDWF  x47,W
0120C:  BCF    x47.6
0120E:  ADDWF  FE9,F
01210:  MOVLW  00
01212:  ADDWFC FEA,F
01214:  MOVF   FE9,W
01216:  SUBLW  46
01218:  BNZ   1222
0121A:  MOVF   FEA,W
0121C:  SUBLW  0A
0121E:  BNZ   1222
01220:  BSF    x47.6
01222:  MOVF   FEF,W
01224:  MOVWF  00
01226:  BNZ   1238
01228:  BTFSC  x47.6
0122A:  BRA    1238
0122C:  BTFSC  x47.4
0122E:  BRA    1248
01230:  BTFSC  x47.3
01232:  BRA    1238
01234:  MOVLW  20
01236:  BRA    123E
01238:  BSF    x47.3
0123A:  BCF    x47.4
0123C:  MOVLW  30
0123E:  ADDWF  00,F
01240:  MOVF   00,W
01242:  BTFSS  F9E.4
01244:  BRA    1242
01246:  MOVWF  FAD
01248:  MOVF   FEE,W
0124A:  BTFSS  x47.6
0124C:  BRA    1214
0124E:  MOVLB  0
01250:  RETURN 0
*
01A56:  DATA 40,4C
01A58:  DATA 50,43
01A5A:  DATA 2C,25
01A5C:  DATA 4C,75
01A5E:  DATA 2C,25
01A60:  DATA 4C,64
01A62:  DATA 0D,0A
01A64:  DATA 00,00
01A66:  DATA 40,4D
01A68:  DATA 4D,45
01A6A:  DATA 2C,25
01A6C:  DATA 75,2C
01A6E:  DATA 25,4C
01A70:  DATA 64,2C
01A72:  DATA 25,4C
01A74:  DATA 75,2C
01A76:  DATA 25,4C
01A78:  DATA 75,2C
01A7A:  DATA 25,4C
01A7C:  DATA 64,2C
01A7E:  DATA 25,4C
01A80:  DATA 64,0D
01A82:  DATA 0A,00
01A84:  DATA 56,41
01A86:  DATA 4C,56
01A88:  DATA 45,20
01A8A:  DATA 53,54
01A8C:  DATA 4F,50
01A8E:  DATA 20,25
01A90:  DATA 4C,75
01A92:  DATA 2C,25
01A94:  DATA 4C,75
01A96:  DATA 0D,0A
01A98:  DATA 00,00
01A9A:  DATA 69,6E
01A9C:  DATA 64,3A
01A9E:  DATA 25,75
01AA0:  DATA 20,2F
01AA2:  DATA 20,70
01AA4:  DATA 68,61
01AA6:  DATA 3A,25
01AA8:  DATA 75,0D
01AAA:  DATA 0A,00
01AAC:  DATA 40,52
01AAE:  DATA 45,43
01AB0:  DATA 20,2D
01AB2:  DATA 20,68
01AB4:  DATA 6F,6D
01AB6:  DATA 69,6E
01AB8:  DATA 67,20
01ABA:  DATA 73,79
01ABC:  DATA 72,69
01ABE:  DATA 6E,67
01AC0:  DATA 65,20
01AC2:  DATA 61,6E
01AC4:  DATA 64,20
01AC6:  DATA 61,6C
01AC8:  DATA 69,67
01ACA:  DATA 6E,69
01ACC:  DATA 6E,67
01ACE:  DATA 20,76
01AD0:  DATA 61,6C
01AD2:  DATA 76,65
01AD4:  DATA 20,74
01AD6:  DATA 6F,20
01AD8:  DATA 70,6F
01ADA:  DATA 72,74
01ADC:  DATA 20,31
01ADE:  DATA 0D,0A
01AE0:  DATA 00,00
01AE2:  DATA 2C,73
01AE4:  DATA 65,72
01AE6:  DATA 69,61
01AE8:  DATA 6C,20
01AEA:  DATA 77,61
01AEC:  DATA 6B,65
01AEE:  DATA 2D,75
01AF0:  DATA 70,2C
01AF2:  DATA 53,44
01AF4:  DATA 20,69
01AF6:  DATA 6E,69
01AF8:  DATA 74,69
01AFA:  DATA 61,6C
01AFC:  DATA 69,7A
01AFE:  DATA 65,64
01B00:  DATA 0D,0A
01B02:  DATA 00,00
01B04:  DATA 40,52
01B06:  DATA 53,54
01B08:  DATA 0D,0A
01B0A:  DATA 00,00
01B0C:  DATA 40,57
01B0E:  DATA 44,54
01B10:  DATA 0D,0A
01B12:  DATA 00,00
01B14:  DATA 2C,72
01B16:  DATA 65,73
01B18:  DATA 74,61
01B1A:  DATA 72,74
01B1C:  DATA 20,63
01B1E:  DATA 61,75
01B20:  DATA 73,65
01B22:  DATA 2C,57
01B24:  DATA 44,20
01B26:  DATA 74,69
01B28:  DATA 6D,65
01B2A:  DATA 2D,6F
01B2C:  DATA 75,74
01B2E:  DATA 0D,0A
01B30:  DATA 00,00
01B32:  DATA 40,57
01B34:  DATA 44,53
01B36:  DATA 0D,0A
01B38:  DATA 00,00
01B3A:  DATA 2C,72
01B3C:  DATA 65,73
01B3E:  DATA 74,61
01B40:  DATA 72,74
01B42:  DATA 20,63
01B44:  DATA 61,75
01B46:  DATA 73,65
01B48:  DATA 2C,57
01B4A:  DATA 44,20
01B4C:  DATA 66,72
01B4E:  DATA 6F,6D
01B50:  DATA 20,73
01B52:  DATA 6C,65
01B54:  DATA 65,70
01B56:  DATA 0D,0A
01B58:  DATA 00,00
01B5A:  DATA 40,4E
01B5C:  DATA 50,55
01B5E:  DATA 0D,0A
01B60:  DATA 00,00
01B62:  DATA 2C,69
01B64:  DATA 64,23
01B66:  DATA 5B,25
01B68:  DATA 4C,75
01B6A:  DATA 5D,2C
01B6C:  DATA 70,6F
01B6E:  DATA 77,65
01B70:  DATA 72,20
01B72:  DATA 61,70
01B74:  DATA 70,6C
01B76:  DATA 69,65
01B78:  DATA 64,2C
01B7A:  DATA 53,44
01B7C:  DATA 20,69
01B7E:  DATA 6E,69
01B80:  DATA 74,69
01B82:  DATA 61,6C
01B84:  DATA 69,7A
01B86:  DATA 65,64
01B88:  DATA 0D,0A
01B8A:  DATA 00,00
01B8C:  DATA 40,52
01B8E:  DATA 53,54
01B90:  DATA 0D,0A
01B92:  DATA 00,00
01B94:  DATA 2C,72
01B96:  DATA 65,73
01B98:  DATA 74,61
01B9A:  DATA 72,74
01B9C:  DATA 20,63
01B9E:  DATA 61,75
01BA0:  DATA 73,65
01BA2:  DATA 2C,72
01BA4:  DATA 65,73
01BA6:  DATA 65,74
01BA8:  DATA 20,69
01BAA:  DATA 6E,73
01BAC:  DATA 74,72
01BAE:  DATA 75,63
01BB0:  DATA 74,69
01BB2:  DATA 6F,6E
01BB4:  DATA 0D,0A
01BB6:  DATA 00,00
01BB8:  DATA 40,42
01BBA:  DATA 4F,52
01BBC:  DATA 0D,0A
01BBE:  DATA 00,00
01BC0:  DATA 2C,72
01BC2:  DATA 65,73
01BC4:  DATA 74,61
01BC6:  DATA 72,74
01BC8:  DATA 20,63
01BCA:  DATA 61,75
01BCC:  DATA 73,65
01BCE:  DATA 2C,62
01BD0:  DATA 72,6F
01BD2:  DATA 77,6E
01BD4:  DATA 2D,6F
01BD6:  DATA 75,74
01BD8:  DATA 0D,0A
01BDA:  DATA 00,00
01BDC:  DATA 40,4D
01BDE:  DATA 52,53
01BE0:  DATA 0D,0A
01BE2:  DATA 00,00
01BE4:  DATA 2C,72
01BE6:  DATA 65,73
01BE8:  DATA 74,61
01BEA:  DATA 72,74
01BEC:  DATA 20,63
01BEE:  DATA 61,75
01BF0:  DATA 73,65
01BF2:  DATA 2C,4D
01BF4:  DATA 43,4C
01BF6:  DATA 52,20
01BF8:  DATA 66,72
01BFA:  DATA 6F,6D
01BFC:  DATA 20,73
01BFE:  DATA 6C,65
01C00:  DATA 65,70
01C02:  DATA 0D,0A
01C04:  DATA 00,00
01C06:  DATA 40,4D
01C08:  DATA 52,52
01C0A:  DATA 0D,0A
01C0C:  DATA 00,00
01C0E:  DATA 2C,72
01C10:  DATA 65,73
01C12:  DATA 74,61
01C14:  DATA 72,74
01C16:  DATA 20,63
01C18:  DATA 61,75
01C1A:  DATA 73,65
01C1C:  DATA 2C,4D
01C1E:  DATA 43,4C
01C20:  DATA 52,20
01C22:  DATA 77,68
01C24:  DATA 65,6E
01C26:  DATA 20,72
01C28:  DATA 75,6E
01C2A:  DATA 6E,69
01C2C:  DATA 6E,67
01C2E:  DATA 0D,0A
01C30:  DATA 00,00
01C32:  DATA 4E,4F
01C34:  DATA 33,00
01C36:  DATA 4E,4F
01C38:  DATA 32,00
01C3A:  DATA 50,4F
01C3C:  DATA 34,00
01C3E:  DATA 4E,48
01C40:  DATA 34,00
01C42:  DATA 53,69
01C44:  DATA 4F,00
01C46:  DATA 00,00
01C48:  DATA 40,44
01C4A:  DATA 45,54
01C4C:  DATA 5B,2F
01C4E:  DATA 25,75
01C50:  DATA 5D,5B
01C52:  DATA 25,63
01C54:  DATA 5D,41
01C56:  DATA 52,47
01C58:  DATA 5B,25
01C5A:  DATA 4C,75
01C5C:  DATA 5D,0D
01C5E:  DATA 0A,00
01C60:  DATA 20,74
01C62:  DATA 69,6D
01C64:  DATA 65,2D
01C66:  DATA 6F,75
01C68:  DATA 74,00
01C6A:  DATA 20,64
01C6C:  DATA 61,74
01C6E:  DATA 61,20
01C70:  DATA 74,6F
01C72:  DATA 6F,20
01C74:  DATA 73,68
01C76:  DATA 6F,72
01C78:  DATA 74,00
01C7A:  DATA 20,64
01C7C:  DATA 61,74
01C7E:  DATA 61,20
01C80:  DATA 74,6F
01C82:  DATA 6F,20
01C84:  DATA 6C,6F
01C86:  DATA 6E,67
01C88:  DATA 00,00
01C8A:  DATA 2C,64
01C8C:  DATA 65,74
01C8E:  DATA 65,63
01C90:  DATA 74,6F
01C92:  DATA 72,5B
01C94:  DATA 25,73
01C96:  DATA 5D,2C
01C98:  DATA 6C,65
01C9A:  DATA 6E,5B
01C9C:  DATA 25,75
01C9E:  DATA 5D,00
01CA0:  DATA 40,52
01CA2:  DATA 54,59
01CA4:  DATA 2C,25
01CA6:  DATA 75,0D
01CA8:  DATA 0A,00
01CAA:  DATA 2C,73
01CAC:  DATA 74,61
01CAE:  DATA 72,74
01CB0:  DATA 20,68
01CB2:  DATA 65,61
01CB4:  DATA 74,69
01CB6:  DATA 6E,67
01CB8:  DATA 2C,74
01CBA:  DATA 61,72
01CBC:  DATA 67,65
01CBE:  DATA 74,5B
01CC0:  DATA 25,4C
01CC2:  DATA 75,5D
01CC4:  DATA 2C,61
01CC6:  DATA 63,74
01CC8:  DATA 75,61
01CCA:  DATA 6C,5B
01CCC:  DATA 25,4C
01CCE:  DATA 75,5D
01CD0:  DATA 2C,72
01CD2:  DATA 65,61
01CD4:  DATA 64,69
01CD6:  DATA 6E,67
01CD8:  DATA 73,5B
01CDA:  DATA 25,4C
01CDC:  DATA 75,5D
01CDE:  DATA 0D,0A
01CE0:  DATA 00,00
01CE2:  DATA 2C,65
01CE4:  DATA 6E,64
01CE6:  DATA 20,68
01CE8:  DATA 65,61
01CEA:  DATA 74,69
01CEC:  DATA 6E,67
01CEE:  DATA 2C,74
01CF0:  DATA 61,72
01CF2:  DATA 67,65
01CF4:  DATA 74,5B
01CF6:  DATA 25,4C
01CF8:  DATA 75,5D
01CFA:  DATA 2C,61
01CFC:  DATA 63,74
01CFE:  DATA 75,61
01D00:  DATA 6C,5B
01D02:  DATA 25,4C
01D04:  DATA 75,5D
01D06:  DATA 2C,72
01D08:  DATA 65,61
01D0A:  DATA 64,69
01D0C:  DATA 6E,67
01D0E:  DATA 73,5B
01D10:  DATA 25,4C
01D12:  DATA 75,5D
01D14:  DATA 0D,0A
01D16:  DATA 00,00
01D18:  DATA 4E,4F
01D1A:  DATA 33,00
01D1C:  DATA 4E,4F
01D1E:  DATA 32,00
01D20:  DATA 50,4F
01D22:  DATA 34,00
01D24:  DATA 4E,48
01D26:  DATA 34,00
01D28:  DATA 53,69
01D2A:  DATA 4F,00
01D2C:  DATA 00,00
01D2E:  DATA 40,44
01D30:  DATA 41,43
01D32:  DATA 2C,25
01D34:  DATA 4C,75
01D36:  DATA 2C,25
01D38:  DATA 4C,75
01D3A:  DATA 2C,00
01D3C:  DATA 40,53
01D3E:  DATA 41,52
01D40:  DATA 2C,31
01D42:  DATA 2C,25
01D44:  DATA 4C,75
01D46:  DATA 2C,00
01D48:  DATA 40,56
01D4A:  DATA 41,4C
01D4C:  DATA 20,00
01D4E:  DATA 40,56
01D50:  DATA 41,4C
01D52:  DATA 20,00
01D54:  DATA 40,56
01D56:  DATA 41,4C
01D58:  DATA 20,00
01D5A:  DATA 40,56
01D5C:  DATA 41,4C
01D5E:  DATA 20,00
01D60:  DATA 40,53
01D62:  DATA 4F,4C
01D64:  DATA 5B,2F
01D66:  DATA 31,5D
01D68:  DATA 5B,73
01D6A:  DATA 5D,5B
01D6C:  DATA 25,4C
01D6E:  DATA 75,5D
01D70:  DATA 0D,0A
01D72:  DATA 00,00
01D74:  DATA 2F,31
01D76:  DATA 73,25
01D78:  DATA 4C,75
01D7A:  DATA 0D,00
01D7C:  DATA 40,53
01D7E:  DATA 4F,4C
01D80:  DATA 5B,2F
01D82:  DATA 31,5D
01D84:  DATA 5B,63
01D86:  DATA 5D,5B
01D88:  DATA 25,75
01D8A:  DATA 5D,0D
01D8C:  DATA 0A,00
01D8E:  DATA 2F,31
01D90:  DATA 63,25
01D92:  DATA 75,0D
01D94:  DATA 00,00
01D96:  DATA 2F,31
01D98:  DATA 73,32
01D9A:  DATA 35,36
01D9C:  DATA 0D,00
01D9E:  DATA 28,49
01DA0:  DATA 30,73
01DA2:  DATA 29,2C
01DA4:  DATA 25,4C
01DA6:  DATA 75,2C
01DA8:  DATA 28,49
01DAA:  DATA 31,73
01DAC:  DATA 29,2C
01DAE:  DATA 25,4C
01DB0:  DATA 75,2C
01DB2:  DATA 28,41
01DB4:  DATA 62,73
01DB6:  DATA 2D,73
01DB8:  DATA 29,2C
01DBA:  DATA 25,31
01DBC:  DATA 2E,34
01DBE:  DATA 67,2C
01DC0:  DATA 28,49
01DC2:  DATA 30,74
01DC4:  DATA 29,2C
01DC6:  DATA 25,4C
01DC8:  DATA 75,2C
01DCA:  DATA 28,49
01DCC:  DATA 31,74
01DCE:  DATA 29,2C
01DD0:  DATA 25,4C
01DD2:  DATA 75,2C
01DD4:  DATA 28,41
01DD6:  DATA 62,73
01DD8:  DATA 2D,74
01DDA:  DATA 29,2C
01DDC:  DATA 25,31
01DDE:  DATA 2E,34
01DE0:  DATA 67,2C
01DE2:  DATA 28,49
01DE4:  DATA 30,72
01DE6:  DATA 29,2C
01DE8:  DATA 25,4C
01DEA:  DATA 75,2C
01DEC:  DATA 28,49
01DEE:  DATA 31,72
01DF0:  DATA 29,2C
01DF2:  DATA 25,4C
01DF4:  DATA 75,2C
01DF6:  DATA 28,41
01DF8:  DATA 62,73
01DFA:  DATA 2D,72
01DFC:  DATA 29,2C
01DFE:  DATA 25,31
01E00:  DATA 2E,34
01E02:  DATA 67,00
01E04:  DATA 40,41
01E06:  DATA 62,73
01E08:  DATA 2C,4E
01E0A:  DATA 4F,33
01E0C:  DATA 2C,25
01E0E:  DATA 73,0D
01E10:  DATA 0A,00
01E12:  DATA 28,49
01E14:  DATA 30,73
01E16:  DATA 29,2C
01E18:  DATA 25,4C
01E1A:  DATA 75,2C
01E1C:  DATA 28,49
01E1E:  DATA 31,73
01E20:  DATA 29,2C
01E22:  DATA 25,4C
01E24:  DATA 75,2C
01E26:  DATA 28,41
01E28:  DATA 62,73
01E2A:  DATA 2D,73
01E2C:  DATA 29,2C
01E2E:  DATA 25,31
01E30:  DATA 2E,34
01E32:  DATA 67,2C
01E34:  DATA 28,49
01E36:  DATA 30,74
01E38:  DATA 29,2C
01E3A:  DATA 25,4C
01E3C:  DATA 75,2C
01E3E:  DATA 28,49
01E40:  DATA 31,74
01E42:  DATA 29,2C
01E44:  DATA 25,4C
01E46:  DATA 75,2C
01E48:  DATA 28,41
01E4A:  DATA 62,73
01E4C:  DATA 2D,74
01E4E:  DATA 29,2C
01E50:  DATA 25,31
01E52:  DATA 2E,34
01E54:  DATA 67,2C
01E56:  DATA 28,49
01E58:  DATA 30,72
01E5A:  DATA 29,2C
01E5C:  DATA 25,4C
01E5E:  DATA 75,2C
01E60:  DATA 28,49
01E62:  DATA 31,72
01E64:  DATA 29,2C
01E66:  DATA 25,4C
01E68:  DATA 75,2C
01E6A:  DATA 28,41
01E6C:  DATA 62,73
01E6E:  DATA 2D,72
01E70:  DATA 29,2C
01E72:  DATA 25,31
01E74:  DATA 2E,34
01E76:  DATA 67,00
01E78:  DATA 40,41
01E7A:  DATA 62,73
01E7C:  DATA 2C,4E
01E7E:  DATA 4F,32
01E80:  DATA 2C,25
01E82:  DATA 73,0D
01E84:  DATA 0A,00
01E86:  DATA 28,49
01E88:  DATA 30,73
01E8A:  DATA 29,2C
01E8C:  DATA 25,4C
01E8E:  DATA 75,2C
01E90:  DATA 28,49
01E92:  DATA 31,73
01E94:  DATA 29,2C
01E96:  DATA 25,4C
01E98:  DATA 75,2C
01E9A:  DATA 28,41
01E9C:  DATA 62,73
01E9E:  DATA 2D,73
01EA0:  DATA 29,2C
01EA2:  DATA 25,31
01EA4:  DATA 2E,34
01EA6:  DATA 67,2C
01EA8:  DATA 28,49
01EAA:  DATA 30,74
01EAC:  DATA 29,2C
01EAE:  DATA 25,4C
01EB0:  DATA 75,2C
01EB2:  DATA 28,49
01EB4:  DATA 31,74
01EB6:  DATA 29,2C
01EB8:  DATA 25,4C
01EBA:  DATA 75,2C
01EBC:  DATA 28,41
01EBE:  DATA 62,73
01EC0:  DATA 2D,74
01EC2:  DATA 29,2C
01EC4:  DATA 25,31
01EC6:  DATA 2E,34
01EC8:  DATA 67,2C
01ECA:  DATA 28,49
01ECC:  DATA 30,72
01ECE:  DATA 29,2C
01ED0:  DATA 25,4C
01ED2:  DATA 75,2C
01ED4:  DATA 28,49
01ED6:  DATA 31,72
01ED8:  DATA 29,2C
01EDA:  DATA 25,4C
01EDC:  DATA 75,2C
01EDE:  DATA 28,41
01EE0:  DATA 62,73
01EE2:  DATA 2D,72
01EE4:  DATA 29,2C
01EE6:  DATA 25,31
01EE8:  DATA 2E,34
01EEA:  DATA 67,00
01EEC:  DATA 40,41
01EEE:  DATA 62,73
01EF0:  DATA 2C,50
01EF2:  DATA 4F,34
01EF4:  DATA 2C,25
01EF6:  DATA 73,0D
01EF8:  DATA 0A,00
01EFA:  DATA 28,49
01EFC:  DATA 30,73
01EFE:  DATA 29,2C
01F00:  DATA 25,4C
01F02:  DATA 75,2C
01F04:  DATA 28,49
01F06:  DATA 31,73
01F08:  DATA 29,2C
01F0A:  DATA 25,4C
01F0C:  DATA 75,2C
01F0E:  DATA 28,41
01F10:  DATA 62,73
01F12:  DATA 2D,73
01F14:  DATA 29,2C
01F16:  DATA 25,31
01F18:  DATA 2E,34
01F1A:  DATA 67,2C
01F1C:  DATA 28,49
01F1E:  DATA 30,74
01F20:  DATA 29,2C
01F22:  DATA 25,4C
01F24:  DATA 75,2C
01F26:  DATA 28,49
01F28:  DATA 31,74
01F2A:  DATA 29,2C
01F2C:  DATA 25,4C
01F2E:  DATA 75,2C
01F30:  DATA 28,41
01F32:  DATA 62,73
01F34:  DATA 2D,74
01F36:  DATA 29,2C
01F38:  DATA 25,31
01F3A:  DATA 2E,34
01F3C:  DATA 67,2C
01F3E:  DATA 28,49
01F40:  DATA 30,72
01F42:  DATA 29,2C
01F44:  DATA 25,4C
01F46:  DATA 75,2C
01F48:  DATA 28,49
01F4A:  DATA 31,72
01F4C:  DATA 29,2C
01F4E:  DATA 25,4C
01F50:  DATA 75,2C
01F52:  DATA 28,41
01F54:  DATA 62,73
01F56:  DATA 2D,72
01F58:  DATA 29,2C
01F5A:  DATA 25,31
01F5C:  DATA 2E,34
01F5E:  DATA 67,00
01F60:  DATA 40,41
01F62:  DATA 62,73
01F64:  DATA 2C,4E
01F66:  DATA 48,34
01F68:  DATA 2C,25
01F6A:  DATA 73,0D
01F6C:  DATA 0A,00
01F6E:  DATA 28,49
01F70:  DATA 30,73
01F72:  DATA 29,2C
01F74:  DATA 25,4C
01F76:  DATA 75,2C
01F78:  DATA 28,49
01F7A:  DATA 31,73
01F7C:  DATA 29,2C
01F7E:  DATA 25,4C
01F80:  DATA 75,2C
01F82:  DATA 28,41
01F84:  DATA 62,73
01F86:  DATA 2D,73
01F88:  DATA 29,2C
01F8A:  DATA 25,31
01F8C:  DATA 2E,34
01F8E:  DATA 67,2C
01F90:  DATA 28,49
01F92:  DATA 30,74
01F94:  DATA 29,2C
01F96:  DATA 25,4C
01F98:  DATA 75,2C
01F9A:  DATA 28,49
01F9C:  DATA 31,74
01F9E:  DATA 29,2C
01FA0:  DATA 25,4C
01FA2:  DATA 75,2C
01FA4:  DATA 28,41
01FA6:  DATA 62,73
01FA8:  DATA 2D,74
01FAA:  DATA 29,2C
01FAC:  DATA 25,31
01FAE:  DATA 2E,34
01FB0:  DATA 67,2C
01FB2:  DATA 28,49
01FB4:  DATA 30,72
01FB6:  DATA 29,2C
01FB8:  DATA 25,4C
01FBA:  DATA 75,2C
01FBC:  DATA 28,49
01FBE:  DATA 31,72
01FC0:  DATA 29,2C
01FC2:  DATA 25,4C
01FC4:  DATA 75,2C
01FC6:  DATA 28,41
01FC8:  DATA 62,73
01FCA:  DATA 2D,72
01FCC:  DATA 29,2C
01FCE:  DATA 25,31
01FD0:  DATA 2E,34
01FD2:  DATA 67,00
01FD4:  DATA 40,41
01FD6:  DATA 42,53
01FD8:  DATA 2C,53
01FDA:  DATA 69,4F
01FDC:  DATA 2C,25
01FDE:  DATA 73,0D
01FE0:  DATA 0A,00
01FE2:  DATA 4E,4F
01FE4:  DATA 33,00
01FE6:  DATA 4E,4F
01FE8:  DATA 32,00
01FEA:  DATA 50,4F
01FEC:  DATA 34,00
01FEE:  DATA 4E,48
01FF0:  DATA 34,00
01FF2:  DATA 53,69
01FF4:  DATA 4F,00
01FF6:  DATA 00,00
01FF8:  DATA 28,6D
01FFA:  DATA 29,2C
01FFC:  DATA 25,33
01FFE:  DATA 2E,33
02000:  DATA 67,2C
02002:  DATA 28,63
02004:  DATA 29,2C
02006:  DATA 25,33
02008:  DATA 2E,33
0200A:  DATA 67,00
0200C:  DATA 28,43
0200E:  DATA 73,29
02010:  DATA 2C,25
02012:  DATA 33,2E
02014:  DATA 33,67
02016:  DATA 0D,0A
02018:  DATA 00,00
0201A:  DATA 40,43
0201C:  DATA 4F,4E
0201E:  DATA 2C,4E
02020:  DATA 4F,33
02022:  DATA 2C,25
02024:  DATA 73,0D
02026:  DATA 0A,00
02028:  DATA 28,6D
0202A:  DATA 29,2C
0202C:  DATA 25,33
0202E:  DATA 2E,33
02030:  DATA 67,2C
02032:  DATA 28,63
02034:  DATA 29,2C
02036:  DATA 25,33
02038:  DATA 2E,33
0203A:  DATA 67,00
0203C:  DATA 28,43
0203E:  DATA 73,29
02040:  DATA 2C,25
02042:  DATA 33,2E
02044:  DATA 33,67
02046:  DATA 0D,0A
02048:  DATA 00,00
0204A:  DATA 40,43
0204C:  DATA 4F,4E
0204E:  DATA 2C,50
02050:  DATA 4F,34
02052:  DATA 2C,25
02054:  DATA 73,0D
02056:  DATA 0A,00
02058:  DATA 28,6D
0205A:  DATA 29,2C
0205C:  DATA 25,33
0205E:  DATA 2E,33
02060:  DATA 67,2C
02062:  DATA 28,63
02064:  DATA 29,2C
02066:  DATA 25,33
02068:  DATA 2E,33
0206A:  DATA 67,00
0206C:  DATA 28,43
0206E:  DATA 73,29
02070:  DATA 2C,25
02072:  DATA 33,2E
02074:  DATA 33,67
02076:  DATA 0D,0A
02078:  DATA 00,00
0207A:  DATA 40,43
0207C:  DATA 4F,4E
0207E:  DATA 2C,4E
02080:  DATA 48,34
02082:  DATA 2C,25
02084:  DATA 73,0D
02086:  DATA 0A,00
02088:  DATA 28,6D
0208A:  DATA 29,2C
0208C:  DATA 25,33
0208E:  DATA 2E,33
02090:  DATA 67,2C
02092:  DATA 28,63
02094:  DATA 29,2C
02096:  DATA 25,33
02098:  DATA 2E,33
0209A:  DATA 67,00
0209C:  DATA 28,43
0209E:  DATA 73,29
020A0:  DATA 2C,25
020A2:  DATA 33,2E
020A4:  DATA 33,67
020A6:  DATA 0D,0A
020A8:  DATA 00,00
020AA:  DATA 40,43
020AC:  DATA 4F,4E
020AE:  DATA 2C,53
020B0:  DATA 69,4F
020B2:  DATA 2C,25
020B4:  DATA 73,0D
020B6:  DATA 0A,00
020B8:  DATA 4E,4F
020BA:  DATA 33,00
020BC:  DATA 50,4F
020BE:  DATA 34,00
020C0:  DATA 4E,48
020C2:  DATA 34,00
020C4:  DATA 53,69
020C6:  DATA 4F,00
020C8:  DATA 00,00
020CA:  DATA 4D,45
020CC:  DATA 4D,4F
020CE:  DATA 52,59
020D0:  DATA 20,4F
020D2:  DATA 56,45
020D4:  DATA 52,46
020D6:  DATA 4C,4F
020D8:  DATA 57,20
020DA:  DATA 45,52
020DC:  DATA 52,4F
020DE:  DATA 52,20
020E0:  DATA 40,20
020E2:  DATA 4C,69
020E4:  DATA 6E,65
020E6:  DATA 20,3A
020E8:  DATA 25,4C
020EA:  DATA 75,0A
020EC:  DATA 0D,00
020EE:  DATA 0D,0A
020F0:  DATA 3A,00
020F2:  DATA 0D,0A
020F4:  DATA 57,41
020F6:  DATA 52,4E
020F8:  DATA 49,4E
020FA:  DATA 47,3A
020FC:  DATA 20,49
020FE:  DATA 4E,56
02100:  DATA 41,4C
02102:  DATA 49,44
02104:  DATA 20,43
02106:  DATA 4F,4D
02108:  DATA 4D,41
0210A:  DATA 4E,44
0210C:  DATA 20,49
0210E:  DATA 4E,20
02110:  DATA 4D,41
02112:  DATA 43,52
02114:  DATA 4F,21
02116:  DATA 0D,0A
02118:  DATA 00,00
0211A:  DATA 42,61
0211C:  DATA 64,20
0211E:  DATA 63,6F
02120:  DATA 6D,6D
02122:  DATA 61,6E
02124:  DATA 64,20
02126:  DATA 61,74
02128:  DATA 20,6C
0212A:  DATA 69,6E
0212C:  DATA 65,3A
0212E:  DATA 20,25
02130:  DATA 4C,64
02132:  DATA 20,0D
02134:  DATA 0A,00
02136:  DATA 50,6C
02138:  DATA 65,61
0213A:  DATA 73,65
0213C:  DATA 20,72
0213E:  DATA 65,2D
02140:  DATA 75,70
02142:  DATA 6C,6F
02144:  DATA 61,64
02146:  DATA 20,6D
02148:  DATA 61,63
0214A:  DATA 72,6F
0214C:  DATA 00,00
0214E:  DATA 49,74
02150:  DATA 65,72
02152:  DATA 61,74
02154:  DATA 69,6F
02156:  DATA 6E,73
02158:  DATA 20,6C
0215A:  DATA 65,66
0215C:  DATA 74,3A
0215E:  DATA 20,25
02160:  DATA 4C,75
02162:  DATA 0D,0A
02164:  DATA 00,00
02166:  DATA 2C,6D
02168:  DATA 61,63
0216A:  DATA 72,6F
0216C:  DATA 5B,25
0216E:  DATA 75,5D
02170:  DATA 2C,73
02172:  DATA 74,61
02174:  DATA 72,74
02176:  DATA 0D,0A
02178:  DATA 00,00
0217A:  DATA 40,4D
0217C:  DATA 43,4C
0217E:  DATA 5B,25
02180:  DATA 63,5D
02182:  DATA 5B,25
02184:  DATA 4C,75
02186:  DATA 5D,0D
02188:  DATA 0A,00
0218A:  DATA 40,4C
0218C:  DATA 4E,45
0218E:  DATA 0D,0A
02190:  DATA 00,00
02192:  DATA 40,52
02194:  DATA 55,4E
02196:  DATA 0D,0A
02198:  DATA 00,00
0219A:  DATA 40,42
0219C:  DATA 41,44
0219E:  DATA 0D,0A
021A0:  DATA 00,00
021A2:  DATA 40,54
021A4:  DATA 2F,4F
021A6:  DATA 0D,0A
021A8:  DATA 00,00
021AA:  DATA 40,45
021AC:  DATA 52,52
021AE:  DATA 0D,0A
021B0:  DATA 00,00
021B2:  DATA 40,45
021B4:  DATA 4E,44
021B6:  DATA 0D,0A
021B8:  DATA 00,00
021BA:  DATA 40,48
021BC:  DATA 4C,54
021BE:  DATA 0D,0A
021C0:  DATA 00,00
021C2:  DATA 2C,6D
021C4:  DATA 61,63
021C6:  DATA 72,6F
021C8:  DATA 5B,25
021CA:  DATA 75,5D
021CC:  DATA 2C,73
021CE:  DATA 74,61
021D0:  DATA 74,75
021D2:  DATA 73,5B
021D4:  DATA 25,63
021D6:  DATA 5D,2C
021D8:  DATA 6C,69
021DA:  DATA 6E,65
021DC:  DATA 5B,25
021DE:  DATA 4C,75
021E0:  DATA 5D,0D
021E2:  DATA 0A,00
021E4:  DATA 40,52
021E6:  DATA 75,6E
021E8:  DATA 6E,69
021EA:  DATA 6E,67
021EC:  DATA 20,25
021EE:  DATA 63,25
021F0:  DATA 4C,75
021F2:  DATA 20,0D
021F4:  DATA 0A,00
021F6:  DATA 40,4D
021F8:  DATA 61,63
021FA:  DATA 72,6F
021FC:  DATA 20,25
021FE:  DATA 30,34
02200:  DATA 4C,75
02202:  DATA 20,6F
02204:  DATA 66,20
02206:  DATA 25,30
02208:  DATA 34,4C
0220A:  DATA 75,0D
0220C:  DATA 0A,00
0220E:  DATA 40,4C
02210:  DATA 4E,45
02212:  DATA 0D,0A
02214:  DATA 00,00
02216:  DATA 40,52
02218:  DATA 55,4E
0221A:  DATA 0D,0A
0221C:  DATA 00,00
0221E:  DATA 40,42
02220:  DATA 41,44
02222:  DATA 0D,0A
02224:  DATA 00,00
02226:  DATA 40,54
02228:  DATA 2F,4F
0222A:  DATA 0D,0A
0222C:  DATA 00,00
0222E:  DATA 40,45
02230:  DATA 52,52
02232:  DATA 0D,0A
02234:  DATA 00,00
02236:  DATA 40,45
02238:  DATA 4E,44
0223A:  DATA 0D,0A
0223C:  DATA 00,00
0223E:  DATA 2C,61
02240:  DATA 75,74
02242:  DATA 6F,2D
02244:  DATA 73,61
02246:  DATA 6D,70
02248:  DATA 6C,65
0224A:  DATA 2C,73
0224C:  DATA 61,6D
0224E:  DATA 70,6C
02250:  DATA 65,5B
02252:  DATA 25,4C
02254:  DATA 75,5D
02256:  DATA 2C,73
02258:  DATA 74,61
0225A:  DATA 72,74
0225C:  DATA 0D,0A
0225E:  DATA 00,00
02260:  DATA 2C,61
02262:  DATA 75,74
02264:  DATA 6F,2D
02266:  DATA 73,61
02268:  DATA 6D,70
0226A:  DATA 6C,65
0226C:  DATA 2C,73
0226E:  DATA 61,6D
02270:  DATA 70,6C
02272:  DATA 65,5B
02274:  DATA 25,4C
02276:  DATA 75,5D
02278:  DATA 2C,63
0227A:  DATA 6F,6D
0227C:  DATA 70,6C
0227E:  DATA 65,74
02280:  DATA 65,0D
02282:  DATA 0A,00
02284:  DATA 2C,61
02286:  DATA 75,74
02288:  DATA 6F,2D
0228A:  DATA 73,61
0228C:  DATA 6D,70
0228E:  DATA 6C,65
02290:  DATA 2C,73
02292:  DATA 61,6D
02294:  DATA 70,6C
02296:  DATA 65,5B
02298:  DATA 25,4C
0229A:  DATA 75,5D
0229C:  DATA 2C,65
0229E:  DATA 72,72
022A0:  DATA 6F,72
022A2:  DATA 0D,0A
022A4:  DATA 00,00
022A6:  DATA 2C,61
022A8:  DATA 75,74
022AA:  DATA 6F,2D
022AC:  DATA 73,61
022AE:  DATA 6D,70
022B0:  DATA 6C,65
022B2:  DATA 2C,73
022B4:  DATA 61,6D
022B6:  DATA 70,6C
022B8:  DATA 65,5B
022BA:  DATA 25,4C
022BC:  DATA 75,5D
022BE:  DATA 2C,6D
022C0:  DATA 61,78
022C2:  DATA 20,73
022C4:  DATA 61,6D
022C6:  DATA 70,6C
022C8:  DATA 65,73
022CA:  DATA 0D,0A
022CC:  DATA 00,00
022CE:  DATA 2C,61
022D0:  DATA 75,74
022D2:  DATA 6F,2D
022D4:  DATA 73,61
022D6:  DATA 6D,70
022D8:  DATA 6C,65
022DA:  DATA 2C,73
022DC:  DATA 61,6D
022DE:  DATA 70,6C
022E0:  DATA 65,5B
022E2:  DATA 25,4C
022E4:  DATA 75,5D
022E6:  DATA 2C,73
022E8:  DATA 74,61
022EA:  DATA 72,74
022EC:  DATA 0D,0A
022EE:  DATA 00,00
022F0:  DATA 2C,61
022F2:  DATA 75,74
022F4:  DATA 6F,2D
022F6:  DATA 73,61
022F8:  DATA 6D,70
022FA:  DATA 6C,65
022FC:  DATA 2C,73
022FE:  DATA 61,6D
02300:  DATA 70,6C
02302:  DATA 65,5B
02304:  DATA 25,4C
02306:  DATA 75,5D
02308:  DATA 2C,63
0230A:  DATA 6F,6D
0230C:  DATA 70,6C
0230E:  DATA 65,74
02310:  DATA 65,0D
02312:  DATA 0A,00
02314:  DATA 2C,61
02316:  DATA 75,74
02318:  DATA 6F,2D
0231A:  DATA 73,61
0231C:  DATA 6D,70
0231E:  DATA 6C,65
02320:  DATA 2C,73
02322:  DATA 61,6D
02324:  DATA 70,6C
02326:  DATA 65,5B
02328:  DATA 25,4C
0232A:  DATA 75,5D
0232C:  DATA 2C,73
0232E:  DATA 74,61
02330:  DATA 72,74
02332:  DATA 0D,0A
02334:  DATA 00,00
02336:  DATA 2C,61
02338:  DATA 75,74
0233A:  DATA 6F,2D
0233C:  DATA 73,61
0233E:  DATA 6D,70
02340:  DATA 6C,65
02342:  DATA 2C,73
02344:  DATA 61,6D
02346:  DATA 70,6C
02348:  DATA 65,5B
0234A:  DATA 25,4C
0234C:  DATA 75,5D
0234E:  DATA 2C,63
02350:  DATA 6F,6D
02352:  DATA 70,6C
02354:  DATA 65,74
02356:  DATA 65,0D
02358:  DATA 0A,00
0235A:  DATA 2C,61
0235C:  DATA 75,74
0235E:  DATA 6F,2D
02360:  DATA 73,61
02362:  DATA 6D,70
02364:  DATA 6C,65
02366:  DATA 2C,73
02368:  DATA 61,6D
0236A:  DATA 70,6C
0236C:  DATA 65,5B
0236E:  DATA 25,4C
02370:  DATA 75,5D
02372:  DATA 2C,6D
02374:  DATA 61,78
02376:  DATA 20,73
02378:  DATA 61,6D
0237A:  DATA 70,6C
0237C:  DATA 65,73
0237E:  DATA 0D,0A
02380:  DATA 00,00
02382:  DATA 2C,61
02384:  DATA 75,74
02386:  DATA 6F,2D
02388:  DATA 73,61
0238A:  DATA 6D,70
0238C:  DATA 6C,65
0238E:  DATA 2C,69
02390:  DATA 6E,69
02392:  DATA 74,69
02394:  DATA 61,6C
02396:  DATA 69,7A
02398:  DATA 65,0D
0239A:  DATA 0A,00
0239C:  DATA 2C,68
0239E:  DATA 65,61
023A0:  DATA 64,65
023A2:  DATA 72,2C
023A4:  DATA 69,64
023A6:  DATA 23,5B
023A8:  DATA 25,4C
023AA:  DATA 75,5D
023AC:  DATA 2C,69
023AE:  DATA 6E,74
023B0:  DATA 5B,25
023B2:  DATA 4C,75
023B4:  DATA 5D,2C
023B6:  DATA 6D,61
023B8:  DATA 78,5B
023BA:  DATA 25,4C
023BC:  DATA 75,5D
023BE:  DATA 0D,0A
023C0:  DATA 00,00
023C2:  DATA 2C,61
023C4:  DATA 75,74
023C6:  DATA 6F,2D
023C8:  DATA 73,61
023CA:  DATA 6D,70
023CC:  DATA 6C,65
023CE:  DATA 2C,73
023D0:  DATA 61,6D
023D2:  DATA 70,6C
023D4:  DATA 65,5B
023D6:  DATA 25,4C
023D8:  DATA 75,5D
023DA:  DATA 2C,61
023DC:  DATA 6C,61
023DE:  DATA 72,6D
023E0:  DATA 5B,25
023E2:  DATA 75,5D
023E4:  DATA 0D,0A
023E6:  DATA 00,00
023E8:  DATA 2C,61
023EA:  DATA 75,74
023EC:  DATA 6F,2D
023EE:  DATA 73,61
023F0:  DATA 6D,70
023F2:  DATA 6C,65
023F4:  DATA 2C,73
023F6:  DATA 6C,65
023F8:  DATA 65,70
023FA:  DATA 0D,0A
023FC:  DATA 00,00
023FE:  DATA 74,31
02400:  DATA 3A,25
02402:  DATA 4C,75
02404:  DATA 20,74
02406:  DATA 32,3A
02408:  DATA 25,4C
0240A:  DATA 75,0D
0240C:  DATA 0A,00
0240E:  DATA 40,44
02410:  DATA 45,54
02412:  DATA 2C,25
02414:  DATA 4C,75
02416:  DATA 0D,0A
02418:  DATA 00,00
0241A:  DATA 4E,4F
0241C:  DATA 33,2C
0241E:  DATA 25,31
02420:  DATA 2E,35
02422:  DATA 67,2C
02424:  DATA 25,31
02426:  DATA 2E,35
02428:  DATA 67,0D
0242A:  DATA 0A,00
0242C:  DATA 50,4F
0242E:  DATA 34,2C
02430:  DATA 25,31
02432:  DATA 2E,35
02434:  DATA 67,2C
02436:  DATA 25,31
02438:  DATA 2E,35
0243A:  DATA 67,0D
0243C:  DATA 0A,00
0243E:  DATA 4E,48
02440:  DATA 34,2C
02442:  DATA 25,31
02444:  DATA 2E,35
02446:  DATA 67,2C
02448:  DATA 25,31
0244A:  DATA 2E,35
0244C:  DATA 67,0D
0244E:  DATA 0A,00
02450:  DATA 53,69
02452:  DATA 4F,34
02454:  DATA 2C,25
02456:  DATA 31,2E
02458:  DATA 35,67
0245A:  DATA 2C,25
0245C:  DATA 31,2E
0245E:  DATA 35,67
02460:  DATA 0D,0A
02462:  DATA 00,00
02464:  DATA 4E,4F
02466:  DATA 33,28
02468:  DATA 6D,29
0246A:  DATA 3A,00
0246C:  DATA 4E,4F
0246E:  DATA 33,28
02470:  DATA 63,29
02472:  DATA 3A,00
02474:  DATA 50,4F
02476:  DATA 34,28
02478:  DATA 6D,29
0247A:  DATA 3A,00
0247C:  DATA 50,4F
0247E:  DATA 34,28
02480:  DATA 63,29
02482:  DATA 3A,00
02484:  DATA 4E,48
02486:  DATA 34,28
02488:  DATA 6D,29
0248A:  DATA 3A,00
0248C:  DATA 4E,48
0248E:  DATA 34,28
02490:  DATA 63,29
02492:  DATA 3A,00
02494:  DATA 53,69
02496:  DATA 4F,34
02498:  DATA 28,6D
0249A:  DATA 29,3A
0249C:  DATA 00,00
0249E:  DATA 53,69
024A0:  DATA 4F,34
024A2:  DATA 28,63
024A4:  DATA 29,3A
024A6:  DATA 00,00
024A8:  DATA 41,72
024AA:  DATA 65,20
024AC:  DATA 79,6F
024AE:  DATA 75,20
024B0:  DATA 73,75
024B2:  DATA 72,65
024B4:  DATA 20,79
024B6:  DATA 6F,75
024B8:  DATA 20,77
024BA:  DATA 61,6E
024BC:  DATA 74,20
024BE:  DATA 74,6F
024C0:  DATA 20,65
024C2:  DATA 72,61
024C4:  DATA 73,65
024C6:  DATA 20,74
024C8:  DATA 68,65
024CA:  DATA 20,72
024CC:  DATA 61,77
024CE:  DATA 20,64
024D0:  DATA 61,74
024D2:  DATA 61,20
024D4:  DATA 66,69
024D6:  DATA 6C,65
024D8:  DATA 3F,20
024DA:  DATA 59,20
024DC:  DATA 6F,72
024DE:  DATA 20,4E
024E0:  DATA 21,0D
024E2:  DATA 0A,00
024E4:  DATA 46,69
024E6:  DATA 6C,65
024E8:  DATA 20,64
024EA:  DATA 65,6C
024EC:  DATA 65,74
024EE:  DATA 65,64
024F0:  DATA 21,0A
024F2:  DATA 0D,00
024F4:  DATA 4F,70
024F6:  DATA 65,72
024F8:  DATA 61,74
024FA:  DATA 69,6F
024FC:  DATA 6E,20
024FE:  DATA 63,61
02500:  DATA 6E,63
02502:  DATA 65,6C
02504:  DATA 65,64
02506:  DATA 21,0D
02508:  DATA 0A,00
0250A:  DATA 41,72
0250C:  DATA 65,20
0250E:  DATA 79,6F
02510:  DATA 75,20
02512:  DATA 73,75
02514:  DATA 72,65
02516:  DATA 20,79
02518:  DATA 6F,75
0251A:  DATA 20,77
0251C:  DATA 61,6E
0251E:  DATA 74,20
02520:  DATA 74,6F
02522:  DATA 20,65
02524:  DATA 72,61
02526:  DATA 73,65
02528:  DATA 20,74
0252A:  DATA 68,65
0252C:  DATA 20,63
0252E:  DATA 61,6C
02530:  DATA 63,75
02532:  DATA 6C,61
02534:  DATA 74,65
02536:  DATA 64,20
02538:  DATA 64,61
0253A:  DATA 74,61
0253C:  DATA 20,66
0253E:  DATA 69,6C
02540:  DATA 65,3F
02542:  DATA 20,59
02544:  DATA 20,6F
02546:  DATA 72,20
02548:  DATA 4E,21
0254A:  DATA 0D,0A
0254C:  DATA 00,00
0254E:  DATA 46,69
02550:  DATA 6C,65
02552:  DATA 20,64
02554:  DATA 65,6C
02556:  DATA 65,74
02558:  DATA 65,64
0255A:  DATA 21,0A
0255C:  DATA 0D,00
0255E:  DATA 4F,70
02560:  DATA 65,72
02562:  DATA 61,74
02564:  DATA 69,6F
02566:  DATA 6E,20
02568:  DATA 63,61
0256A:  DATA 6E,63
0256C:  DATA 65,6C
0256E:  DATA 65,64
02570:  DATA 21,0D
02572:  DATA 0A,00
02574:  DATA 40,49
02576:  DATA 44,23
02578:  DATA 25,4C
0257A:  DATA 75,20
0257C:  DATA 49,25
0257E:  DATA 4C,75
02580:  DATA 20,4E
02582:  DATA 25,4C
02584:  DATA 75,2F
02586:  DATA 25,4C
02588:  DATA 75,20
0258A:  DATA 58,25
0258C:  DATA 4C,75
0258E:  DATA 20,55
02590:  DATA 25,75
02592:  DATA 20,25
02594:  DATA 34,2E
02596:  DATA 32,77
02598:  DATA 56,0D
0259A:  DATA 0A,00
0259C:  DATA 40,4D
0259E:  DATA 4F,54
025A0:  DATA 3A,56
025A2:  DATA 41,4C
025A4:  DATA 3D,25
025A6:  DATA 4C,75
025A8:  DATA 20,53
025AA:  DATA 59,52
025AC:  DATA 3D,25
025AE:  DATA 4C,64
025B0:  DATA 0D,0A
025B2:  DATA 00,00
025B4:  DATA 40,50
025B6:  DATA 57,52
025B8:  DATA 3A,25
025BA:  DATA 30,32
025BC:  DATA 75,2F
025BE:  DATA 25,30
025C0:  DATA 32,75
025C2:  DATA 2F,25
025C4:  DATA 30,32
025C6:  DATA 75,20
025C8:  DATA 25,30
025CA:  DATA 32,75
025CC:  DATA 3A,25
025CE:  DATA 30,32
025D0:  DATA 75,3A
025D2:  DATA 25,30
025D4:  DATA 32,75
025D6:  DATA 0D,0A
025D8:  DATA 00,00
025DA:  DATA 40,50
025DC:  DATA 57,52
025DE:  DATA 3A,25
025E0:  DATA 30,32
025E2:  DATA 75,2F
025E4:  DATA 25,30
025E6:  DATA 32,75
025E8:  DATA 2F,25
025EA:  DATA 30,32
025EC:  DATA 75,20
025EE:  DATA 25,30
025F0:  DATA 32,75
025F2:  DATA 3A,25
025F4:  DATA 30,32
025F6:  DATA 75,3A
025F8:  DATA 25,30
025FA:  DATA 32,75
025FC:  DATA 0D,0A
025FE:  DATA 00,00
02600:  DATA 41,25
02602:  DATA 4C,75
02604:  DATA 20,49
02606:  DATA 25,4C
02608:  DATA 75,20
0260A:  DATA 4C,25
0260C:  DATA 4C,75
0260E:  DATA 20,51
02610:  DATA 25,4C
02612:  DATA 75,20
02614:  DATA 53,25
02616:  DATA 4C,75
02618:  DATA 20,25
0261A:  DATA 34,2E
0261C:  DATA 32,77
0261E:  DATA 56,0D
02620:  DATA 0A,00
02622:  DATA 40,4D
02624:  DATA 4F,54
02626:  DATA 3A,56
02628:  DATA 41,4C
0262A:  DATA 3D,25
0262C:  DATA 4C,75
0262E:  DATA 20,53
02630:  DATA 59,52
02632:  DATA 3D,25
02634:  DATA 4C,64
02636:  DATA 0D,0A
02638:  DATA 00,00
0263A:  DATA 40,50
0263C:  DATA 57,52
0263E:  DATA 3A,25
02640:  DATA 30,32
02642:  DATA 75,2F
02644:  DATA 25,30
02646:  DATA 32,75
02648:  DATA 2F,25
0264A:  DATA 30,32
0264C:  DATA 75,20
0264E:  DATA 25,30
02650:  DATA 32,75
02652:  DATA 3A,25
02654:  DATA 30,32
02656:  DATA 75,3A
02658:  DATA 25,30
0265A:  DATA 32,75
0265C:  DATA 0D,0A
0265E:  DATA 00,00
02660:  DATA 49,25
02662:  DATA 4C,75
02664:  DATA 20,4E
02666:  DATA 25,4C
02668:  DATA 75,2F
0266A:  DATA 25,4C
0266C:  DATA 75,20
0266E:  DATA 50,25
02670:  DATA 4C,75
02672:  DATA 20,25
02674:  DATA 34,2E
02676:  DATA 32,77
02678:  DATA 56,0D
0267A:  DATA 0A,00
0267C:  DATA 40,4D
0267E:  DATA 4F,54
02680:  DATA 3A,53
02682:  DATA 59,52
02684:  DATA 3D,25
02686:  DATA 4C,64
02688:  DATA 0D,0A
0268A:  DATA 00,00
0268C:  DATA 40,50
0268E:  DATA 57,52
02690:  DATA 3A,25
02692:  DATA 30,32
02694:  DATA 75,2F
02696:  DATA 25,30
02698:  DATA 32,75
0269A:  DATA 2F,25
0269C:  DATA 30,32
0269E:  DATA 75,20
026A0:  DATA 25,30
026A2:  DATA 32,75
026A4:  DATA 3A,25
026A6:  DATA 30,32
026A8:  DATA 75,3A
026AA:  DATA 25,30
026AC:  DATA 32,75
026AE:  DATA 0D,0A
026B0:  DATA 00,00
026B2:  DATA 40,53
026B4:  DATA 4D,50
026B6:  DATA 20,25
026B8:  DATA 30,34
026BA:  DATA 4C,75
026BC:  DATA 0D,0A
026BE:  DATA 00,00
026C0:  DATA 40,53
026C2:  DATA 4D,50
026C4:  DATA 20,25
026C6:  DATA 30,34
026C8:  DATA 4C,75
026CA:  DATA 0D,0A
026CC:  DATA 00,00
026CE:  DATA 45,6E
026D0:  DATA 74,65
026D2:  DATA 72,20
026D4:  DATA 64,61
026D6:  DATA 74,65
026D8:  DATA 20,66
026DA:  DATA 6F,72
026DC:  DATA 6D,61
026DE:  DATA 74,20
026E0:  DATA 30,3D
026E2:  DATA 4D,4D
026E4:  DATA 2F,44
026E6:  DATA 44,2F
026E8:  DATA 59,59
026EA:  DATA 20,20
026EC:  DATA 31,3D
026EE:  DATA 44,44
026F0:  DATA 2F,4D
026F2:  DATA 4D,2F
026F4:  DATA 59,59
026F6:  DATA 0D,0A
026F8:  DATA 00,00
026FA:  DATA 40,4F
026FC:  DATA 4B,21
026FE:  DATA 0D,0A
02700:  DATA 20,00
02702:  DATA 40,45
02704:  DATA 52,52
02706:  DATA 0D,0A
02708:  DATA 00,00
0270A:  DATA 40,52
0270C:  DATA 55,4E
0270E:  DATA 0D,0A
02710:  DATA 00,00
02712:  DATA 5B,6D
02714:  DATA 6F,74
02716:  DATA 6F,72
02718:  DATA 3A,31
0271A:  DATA 5D,0D
0271C:  DATA 0A,00
0271E:  DATA 5B,6D
02720:  DATA 6F,74
02722:  DATA 6F,72
02724:  DATA 3A,32
02726:  DATA 5D,0D
02728:  DATA 0A,00
0272A:  DATA 2C,45
0272C:  DATA 43,4F
0272E:  DATA 20,6D
02730:  DATA 6F,64
02732:  DATA 65,20
02734:  DATA 73,65
02736:  DATA 74,0D
02738:  DATA 0A,00
0273A:  DATA 2C,57
0273C:  DATA 4D,53
0273E:  DATA 2D,34
02740:  DATA 2D,53
02742:  DATA 44,20
02744:  DATA 6D,6F
02746:  DATA 64,65
02748:  DATA 20,73
0274A:  DATA 65,74
0274C:  DATA 0D,0A
0274E:  DATA 00,00
02750:  DATA 2C,41
02752:  DATA 57,53
02754:  DATA 20,6D
02756:  DATA 6F,64
02758:  DATA 65,20
0275A:  DATA 73,65
0275C:  DATA 74,0D
0275E:  DATA 0A,00
02760:  DATA 2C,57
02762:  DATA 4D,53
02764:  DATA 2D,34
02766:  DATA 2D,51
02768:  DATA 45,20
0276A:  DATA 6D,6F
0276C:  DATA 64,65
0276E:  DATA 20,73
02770:  DATA 65,74
02772:  DATA 0D,0A
02774:  DATA 00,00
02776:  DATA 30,37
02778:  DATA 2D,4A
0277A:  DATA 75,6C
0277C:  DATA 2D,31
0277E:  DATA 37,00
02780:  DATA 31,32
02782:  DATA 3A,31
02784:  DATA 34,3A
02786:  DATA 34,38
02788:  DATA 00,00
0278A:  DATA 53,45
0278C:  DATA 4E,44
0278E:  DATA 20,48
02790:  DATA 45,58
02792:  DATA 20,46
02794:  DATA 49,4C
02796:  DATA 45,20
02798:  DATA 28,31
0279A:  DATA 39,32
0279C:  DATA 30,30
0279E:  DATA 2C,4E
027A0:  DATA 38,31
027A2:  DATA 2C,58
027A4:  DATA 4F,4E
027A6:  DATA 2D,58
027A8:  DATA 4F,46
027AA:  DATA 46,29
027AC:  DATA 0D,0A
027AE:  DATA 00,00
027B0:  DATA 40,4F
027B2:  DATA 4B,21
027B4:  DATA 20,00
027B6:  DATA 40,41
027B8:  DATA 52,47
027BA:  DATA 20,00
027BC:  DATA 40,4F
027BE:  DATA 4B,21
027C0:  DATA 20,00
027C2:  DATA 40,41
027C4:  DATA 52,47
027C6:  DATA 20,00
027C8:  DATA 0D,0A
027CA:  DATA 40,49
027CC:  DATA 4E,56
027CE:  DATA 00,00
027D0:  DATA 0D,0A
027D2:  DATA 40,4F
027D4:  DATA 4B,21
027D6:  DATA 20,00
027D8:  DATA 40,49
027DA:  DATA 4E,56
027DC:  DATA 00,00
027DE:  DATA 40,43
027E0:  DATA 4D,44
027E2:  DATA 00,00
027E4:  DATA 2C,63
027E6:  DATA 6F,6D
027E8:  DATA 6D,61
027EA:  DATA 6E,64
027EC:  DATA 20,70
027EE:  DATA 72,6F
027F0:  DATA 6D,70
027F2:  DATA 74,0D
027F4:  DATA 0A,00
027F6:  DATA 20,20
027F8:  DATA 20,20
027FA:  DATA 20,20
027FC:  DATA 20,20
027FE:  DATA 20,20
02800:  DATA 20,20
02802:  DATA 20,20
02804:  DATA 20,20
02806:  DATA 20,20
02808:  DATA 20,20
0280A:  DATA 20,20
0280C:  DATA 20,20
0280E:  DATA 20,20
02810:  DATA 20,20
02812:  DATA 20,20
02814:  DATA 20,20
02816:  DATA 20,20
02818:  DATA 20,20
0281A:  DATA 20,20
0281C:  DATA 20,00
0281E:  DATA 0D,0A
02820:  DATA 40,41
02822:  DATA 52,47
02824:  DATA 20,00
02826:  DATA 0D,0A
02828:  DATA 40,41
0282A:  DATA 52,47
0282C:  DATA 20,00
0282E:  DATA 40,43
02830:  DATA 4D,44
02832:  DATA 00,00
02834:  DATA 2C,63
02836:  DATA 6F,6D
02838:  DATA 6D,61
0283A:  DATA 6E,64
0283C:  DATA 20,70
0283E:  DATA 72,6F
02840:  DATA 6D,70
02842:  DATA 74,0D
02844:  DATA 0A,00
02846:  DATA 40,53
02848:  DATA 44,3D
0284A:  DATA 25,4C
0284C:  DATA 75,0D
0284E:  DATA 0A,00
02850:  DATA 40,4D
02852:  DATA 43,31
02854:  DATA 2C,25
02856:  DATA 4C,75
02858:  DATA 2C,25
0285A:  DATA 4C,64
0285C:  DATA 0D,0A
0285E:  DATA 00,00
02860:  DATA 40,4D
02862:  DATA 43,32
02864:  DATA 2C,25
02866:  DATA 4C,75
02868:  DATA 2C,25
0286A:  DATA 4C,64
0286C:  DATA 0D,0A
0286E:  DATA 00,00
02870:  DATA 50,72
02872:  DATA 65,73
02874:  DATA 73,20
02876:  DATA 61,6E
02878:  DATA 64,20
0287A:  DATA 68,6F
0287C:  DATA 6C,64
0287E:  DATA 20,74
02880:  DATA 68,65
02882:  DATA 20,45
02884:  DATA 73,63
02886:  DATA 20,6B
02888:  DATA 65,79
0288A:  DATA 20,74
0288C:  DATA 6F,20
0288E:  DATA 72,65
02890:  DATA 74,75
02892:  DATA 72,6E
02894:  DATA 20,74
02896:  DATA 6F,20
02898:  DATA 43,6F
0289A:  DATA 6D,6D
0289C:  DATA 61,6E
0289E:  DATA 64,20
028A0:  DATA 4D,6F
028A2:  DATA 64,65
028A4:  DATA 0D,0A
028A6:  DATA 00,00
028A8:  DATA 52,65
028AA:  DATA 74,75
028AC:  DATA 72,6E
028AE:  DATA 69,6E
028B0:  DATA 67,20
028B2:  DATA 74,6F
028B4:  DATA 20,4C
028B6:  DATA 6F,67
028B8:  DATA 67,69
028BA:  DATA 6E,67
028BC:  DATA 20,4D
028BE:  DATA 6F,64
028C0:  DATA 65,0D
028C2:  DATA 0A,00
*
02CD4:  CLRF   01
02CD6:  CLRF   02
02CD8:  CLRF   00
02CDA:  CLRF   03
02CDC:  MOVLB  8
02CDE:  MOVF   xDE,W
02CE0:  BNZ   2CE6
02CE2:  MOVF   xDD,W
02CE4:  BZ    2D16
02CE6:  MOVLW  10
02CE8:  MOVWF  xDF
02CEA:  BCF    FD8.0
02CEC:  RLCF   xDB,F
02CEE:  RLCF   xDC,F
02CF0:  RLCF   00,F
02CF2:  RLCF   03,F
02CF4:  MOVF   xDE,W
02CF6:  SUBWF  03,W
02CF8:  BNZ   2CFE
02CFA:  MOVF   xDD,W
02CFC:  SUBWF  00,W
02CFE:  BNC   2D0E
02D00:  MOVF   xDD,W
02D02:  SUBWF  00,F
02D04:  BTFSS  FD8.0
02D06:  DECF   03,F
02D08:  MOVF   xDE,W
02D0A:  SUBWF  03,F
02D0C:  BSF    FD8.0
02D0E:  RLCF   01,F
02D10:  RLCF   02,F
02D12:  DECFSZ xDF,F
02D14:  BRA    2CEA
02D16:  MOVLB  0
02D18:  RETURN 0
*
03526:  TSTFSZ 01
03528:  BRA    3530
0352A:  TSTFSZ 02
0352C:  BRA    3532
0352E:  BRA    353E
03530:  INCF   02,F
03532:  MOVFF  00,FEE
03536:  DECFSZ 01,F
03538:  BRA    3532
0353A:  DECFSZ 02,F
0353C:  BRA    3532
0353E:  RETURN 0
*
03610:  MOVLB  9
03612:  BTFSC  xED.7
03614:  BRA    3636
03616:  MOVLW  0F
03618:  MOVWF  00
0361A:  SWAPF  xEC,W
0361C:  ANDWF  00,F
0361E:  MOVLW  0A
03620:  SUBWF  00,W
03622:  BC    362A
03624:  MOVLW  30
03626:  ADDWF  00,F
03628:  BRA    362E
0362A:  MOVF   xED,W
0362C:  ADDWF  00,F
0362E:  MOVF   00,W
03630:  BTFSS  F9E.4
03632:  BRA    3630
03634:  MOVWF  FAD
03636:  MOVLW  0F
03638:  ANDWF  xEC,F
0363A:  MOVLW  0A
0363C:  SUBWF  xEC,W
0363E:  BC    3644
03640:  MOVLW  30
03642:  BRA    3648
03644:  BCF    xED.7
03646:  MOVF   xED,W
03648:  ADDWF  xEC,F
0364A:  MOVF   xEC,W
0364C:  BTFSS  F9E.4
0364E:  BRA    364C
03650:  MOVWF  FAD
03652:  MOVLB  0
03654:  RETURN 0
*
047F0:  MOVLB  9
047F2:  CLRF   xFE
047F4:  CLRF   xFF
047F6:  MOVLW  01
047F8:  MOVLB  A
047FA:  MOVWF  x00
047FC:  CLRF   FDA
047FE:  CLRF   FD9
04800:  MOVLW  09
04802:  MOVWF  x03
04804:  MOVLW  F6
04806:  MOVWF  x02
04808:  MOVLW  09
0480A:  MOVWF  FEA
0480C:  MOVLW  FA
0480E:  MOVWF  FE9
04810:  MOVFF  A03,FE2
04814:  MOVFF  A02,FE1
04818:  MOVFF  A00,A01
0481C:  BCF    FD8.0
0481E:  MOVF   FE5,W
04820:  MULWF  FEE
04822:  MOVF   FF3,W
04824:  MOVLB  9
04826:  ADDWFC xFE,F
04828:  MOVF   FF4,W
0482A:  ADDWFC xFF,F
0482C:  MOVLB  A
0482E:  DECFSZ x01,F
04830:  BRA    481C
04832:  MOVFF  9FE,FDE
04836:  MOVFF  9FF,9FE
0483A:  MOVLB  9
0483C:  CLRF   xFF
0483E:  BTFSC  FD8.0
04840:  INCF   xFF,F
04842:  MOVLB  A
04844:  INCF   x02,F
04846:  BTFSC  FD8.2
04848:  INCF   x03,F
0484A:  INCF   x00,F
0484C:  MOVF   x00,W
0484E:  SUBLW  05
04850:  BNZ   4808
04852:  MOVLB  0
04854:  RETURN 0
*
0509E:  MOVFF  1E,FEA
050A2:  MOVFF  1D,FE9
050A6:  MOVLB  8
050A8:  MOVFF  8FF,FEF
050AC:  INCF   FE9,F
050AE:  BTFSC  FD8.2
050B0:  INCF   FEA,F
050B2:  CLRF   FEF
050B4:  INCF   1D,F
050B6:  BTFSC  FD8.2
050B8:  INCF   1E,F
050BA:  MOVLB  0
050BC:  RETURN 0
050BE:  TBLRD*+
050C0:  MOVF   FF5,F
050C2:  BZ    50E4
050C4:  MOVFF  FF6,8EB
050C8:  MOVFF  FF7,8EC
050CC:  MOVFF  FF8,8ED
050D0:  MOVFF  FF5,8FF
050D4:  RCALL  509E
050D6:  MOVFF  8EB,FF6
050DA:  MOVFF  8EC,FF7
050DE:  MOVFF  8ED,FF8
050E2:  BRA    50BE
050E4:  RETURN 0
*
05280:  MOVF   01,W
05282:  CLRF   1B
05284:  BTFSC  FF2.7
05286:  BSF    1B.7
05288:  BCF    FF2.7
0528A:  MOVFF  8ED,A42
0528E:  MOVLW  64
05290:  MOVLB  A
05292:  MOVWF  x43
05294:  MOVLB  0
05296:  CALL   0F72
0529A:  BTFSC  1B.7
0529C:  BSF    FF2.7
0529E:  MOVFF  00,8ED
052A2:  MOVF   01,W
052A4:  MOVLW  30
052A6:  BNZ   52B8
052A8:  MOVLB  8
052AA:  BTFSS  xEE.1
052AC:  BRA    52CC
052AE:  BTFSC  xEE.3
052B0:  BRA    52CC
052B2:  BTFSC  xEE.4
052B4:  MOVLW  20
052B6:  BRA    52C0
052B8:  MOVLB  8
052BA:  BCF    xEE.3
052BC:  BCF    xEE.4
052BE:  BSF    xEE.0
052C0:  ADDWF  01,F
052C2:  MOVFF  01,8FF
052C6:  MOVLB  0
052C8:  RCALL  509E
052CA:  MOVLB  8
052CC:  CLRF   1B
052CE:  BTFSC  FF2.7
052D0:  BSF    1B.7
052D2:  BCF    FF2.7
052D4:  MOVFF  8ED,A42
052D8:  MOVLW  0A
052DA:  MOVLB  A
052DC:  MOVWF  x43
052DE:  MOVLB  0
052E0:  CALL   0F72
052E4:  BTFSC  1B.7
052E6:  BSF    FF2.7
052E8:  MOVFF  00,8ED
052EC:  MOVF   01,W
052EE:  MOVLW  30
052F0:  BNZ   5302
052F2:  MOVLB  8
052F4:  BTFSC  xEE.3
052F6:  BRA    530C
052F8:  BTFSS  xEE.0
052FA:  BRA    530C
052FC:  BTFSC  xEE.4
052FE:  MOVLW  20
05300:  MOVLB  0
05302:  ADDWF  01,F
05304:  MOVFF  01,8FF
05308:  RCALL  509E
0530A:  MOVLB  8
0530C:  MOVLW  30
0530E:  ADDWF  xED,F
05310:  MOVFF  8ED,8FF
05314:  MOVLB  0
05316:  RCALL  509E
05318:  RETURN 0
0531A:  MOVF   FE9,W
0531C:  MOVLB  8
0531E:  MOVWF  xF2
05320:  MOVLW  3B
05322:  MOVWF  xF9
05324:  MOVLW  9A
05326:  MOVWF  xF8
05328:  MOVLW  CA
0532A:  MOVWF  xF7
0532C:  CLRF   xF6
0532E:  MOVLW  0A
05330:  MOVWF  xF4
05332:  MOVF   xF1,W
05334:  BTFSS  FD8.2
05336:  DECF   xF2,F
05338:  BSF    FD8.1
0533A:  MOVLW  08
0533C:  MOVWF  FEA
0533E:  MOVLW  ED
05340:  MOVWF  FE9
05342:  CLRF   1B
05344:  BTFSC  FF2.7
05346:  BSF    1B.7
05348:  BCF    FF2.7
0534A:  MOVFF  8F0,A4F
0534E:  MOVFF  8EF,A4E
05352:  MOVFF  8EE,A4D
05356:  MOVFF  8ED,A4C
0535A:  MOVFF  8F9,A53
0535E:  MOVFF  8F8,A52
05362:  MOVFF  8F7,A51
05366:  MOVFF  8F6,A50
0536A:  MOVLB  0
0536C:  CALL   104E
05370:  BTFSC  1B.7
05372:  BSF    FF2.7
05374:  MOVF   01,W
05376:  MOVF   00,F
05378:  BNZ   53A0
0537A:  MOVLB  8
0537C:  INCF   xF1,W
0537E:  SUBWF  xF4,W
05380:  BTFSS  FD8.2
05382:  BRA    5388
05384:  MOVLB  0
05386:  BRA    53A0
05388:  MOVF   xF2,W
0538A:  BZ    53A4
0538C:  ANDLW  0F
0538E:  SUBWF  xF4,W
05390:  BZ    5394
05392:  BC    53D0
05394:  BTFSC  xF2.7
05396:  BRA    53D0
05398:  BTFSC  xF2.6
0539A:  BRA    53A4
0539C:  MOVLW  20
0539E:  BRA    53C4
053A0:  MOVLB  8
053A2:  CLRF   xF2
053A4:  MOVF   xF1,W
053A6:  SUBWF  xF4,W
053A8:  BNZ   53C2
053AA:  MOVFF  00,8F2
053AE:  MOVLW  2E
053B0:  MOVWF  xFF
053B2:  MOVLB  0
053B4:  RCALL  509E
053B6:  MOVLB  8
053B8:  MOVFF  8F2,00
053BC:  MOVLW  20
053BE:  ANDWF  xF2,F
053C0:  MOVLW  00
053C2:  MOVLW  30
053C4:  ADDWF  00,F
053C6:  MOVFF  00,8FF
053CA:  MOVLB  0
053CC:  RCALL  509E
053CE:  MOVLB  8
053D0:  BCF    FD8.1
053D2:  CLRF   1B
053D4:  BTFSC  FF2.7
053D6:  BSF    1B.7
053D8:  BCF    FF2.7
053DA:  MOVFF  8F9,A4F
053DE:  MOVFF  8F8,A4E
053E2:  MOVFF  8F7,A4D
053E6:  MOVFF  8F6,A4C
053EA:  MOVLB  A
053EC:  CLRF   x53
053EE:  CLRF   x52
053F0:  CLRF   x51
053F2:  MOVLW  0A
053F4:  MOVWF  x50
053F6:  MOVLB  0
053F8:  CALL   104E
053FC:  BTFSC  1B.7
053FE:  BSF    FF2.7
05400:  MOVFF  03,8F9
05404:  MOVFF  02,8F8
05408:  MOVFF  01,8F7
0540C:  MOVFF  00,8F6
05410:  MOVLB  8
05412:  DECFSZ xF4,F
05414:  BRA    5338
05416:  MOVLB  0
05418:  RETURN 0
*
05C98:  MOVLB  A
05C9A:  MOVF   x10,W
05C9C:  MULWF  x12
05C9E:  MOVFF  FF3,01
05CA2:  MOVFF  FF4,00
05CA6:  MULWF  x13
05CA8:  MOVF   FF3,W
05CAA:  ADDWF  00,F
05CAC:  MOVF   x11,W
05CAE:  MULWF  x12
05CB0:  MOVF   FF3,W
05CB2:  ADDWFC 00,W
05CB4:  MOVWF  02
05CB6:  MOVLB  0
05CB8:  RETURN 0
*
07996:  MOVF   FEF,F
07998:  BZ    79BA
0799A:  MOVFF  FEA,9B1
0799E:  MOVFF  FE9,9B0
079A2:  MOVF   FEF,W
079A4:  BTFSS  F9E.4
079A6:  BRA    79A4
079A8:  MOVWF  FAD
079AA:  MOVFF  9B1,FEA
079AE:  MOVFF  9B0,FE9
079B2:  INCF   FE9,F
079B4:  BTFSC  FD8.2
079B6:  INCF   FEA,F
079B8:  BRA    7996
079BA:  RETURN 0
*
08FE4:  MOVFF  FEA,8F8
08FE8:  MOVFF  FE9,8F7
08FEC:  MOVLB  8
08FEE:  BTFSS  xF1.7
08FF0:  BRA    9002
08FF2:  BSF    xF7.7
08FF4:  BTFSS  xF7.4
08FF6:  INCF   xF7,F
08FF8:  COMF   xF0,F
08FFA:  COMF   xF1,F
08FFC:  INCF   xF0,F
08FFE:  BTFSC  FD8.2
09000:  INCF   xF1,F
09002:  SWAPF  xF1,W
09004:  IORLW  F0
09006:  MOVWF  xF3
09008:  ADDWF  xF3,F
0900A:  ADDLW  E2
0900C:  MOVWF  xF4
0900E:  ADDLW  32
09010:  MOVWF  xF6
09012:  MOVF   xF1,W
09014:  ANDLW  0F
09016:  ADDWF  xF4,F
09018:  ADDWF  xF4,F
0901A:  ADDWF  xF6,F
0901C:  ADDLW  E9
0901E:  MOVWF  xF5
09020:  ADDWF  xF5,F
09022:  ADDWF  xF5,F
09024:  SWAPF  xF0,W
09026:  ANDLW  0F
09028:  ADDWF  xF5,F
0902A:  ADDWF  xF6,F
0902C:  RLCF   xF5,F
0902E:  RLCF   xF6,F
09030:  COMF   xF6,F
09032:  RLCF   xF6,F
09034:  MOVF   xF0,W
09036:  ANDLW  0F
09038:  ADDWF  xF6,F
0903A:  RLCF   xF3,F
0903C:  MOVLW  07
0903E:  MOVWF  xF2
09040:  MOVLW  0A
09042:  DECF   xF5,F
09044:  ADDWF  xF6,F
09046:  BNC   9042
09048:  DECF   xF4,F
0904A:  ADDWF  xF5,F
0904C:  BNC   9048
0904E:  DECF   xF3,F
09050:  ADDWF  xF4,F
09052:  BNC   904E
09054:  DECF   xF2,F
09056:  ADDWF  xF3,F
09058:  BNC   9054
0905A:  MOVLW  08
0905C:  MOVWF  FEA
0905E:  MOVLW  F2
09060:  MOVWF  FE9
09062:  MOVLW  07
09064:  ANDWF  xF7,W
09066:  BCF    xF7.6
09068:  MOVF   FED,F
0906A:  ANDWF  xF7,W
0906C:  BNZ   907C
0906E:  BTFSC  xF7.4
09070:  MOVF   FEE,F
09072:  BTFSC  xF7.4
09074:  BRA    907C
09076:  MOVLW  20
09078:  MOVWF  00
0907A:  BRA    90BE
0907C:  ADDWF  FE9,F
0907E:  MOVLW  00
09080:  ADDWFC FEA,F
09082:  MOVF   FE9,W
09084:  SUBLW  F6
09086:  BNZ   9090
09088:  MOVF   FEA,W
0908A:  SUBLW  08
0908C:  BNZ   9090
0908E:  BSF    xF7.6
09090:  MOVF   FEF,W
09092:  MOVWF  00
09094:  BNZ   90A6
09096:  BTFSC  xF7.6
09098:  BRA    90A6
0909A:  BTFSC  xF7.4
0909C:  BRA    90C6
0909E:  BTFSC  xF7.3
090A0:  BRA    90A6
090A2:  MOVLW  20
090A4:  BRA    90BC
090A6:  BTFSS  xF7.7
090A8:  BRA    90B6
090AA:  MOVLW  2D
090AC:  MOVWF  00
090AE:  MOVF   FED,W
090B0:  BCF    xF7.6
090B2:  BCF    xF7.7
090B4:  BRA    90BE
090B6:  BSF    xF7.3
090B8:  BCF    xF7.4
090BA:  MOVLW  30
090BC:  ADDWF  00,F
090BE:  MOVF   00,W
090C0:  BTFSS  F9E.4
090C2:  BRA    90C0
090C4:  MOVWF  FAD
090C6:  MOVF   FEE,W
090C8:  BTFSS  xF7.6
090CA:  BRA    9082
090CC:  MOVLB  0
090CE:  RETURN 0
*
09564:  MOVF   FE9,W
09566:  MOVLB  8
09568:  MOVWF  xF6
0956A:  BTFSS  xF5.7
0956C:  BRA    9588
0956E:  DECF   xF6,F
09570:  BSF    xF6.5
09572:  COMF   xF2,F
09574:  COMF   xF3,F
09576:  COMF   xF4,F
09578:  COMF   xF5,F
0957A:  INCF   xF2,F
0957C:  BTFSC  FD8.2
0957E:  INCF   xF3,F
09580:  BTFSC  FD8.2
09582:  INCF   xF4,F
09584:  BTFSC  FD8.2
09586:  INCF   xF5,F
09588:  MOVLW  3B
0958A:  MOVWF  xFD
0958C:  MOVLW  9A
0958E:  MOVWF  xFC
09590:  MOVLW  CA
09592:  MOVWF  xFB
09594:  CLRF   xFA
09596:  MOVLW  0A
09598:  MOVWF  xF8
0959A:  BSF    FD8.1
0959C:  MOVLW  08
0959E:  MOVWF  FEA
095A0:  MOVLW  F2
095A2:  MOVWF  FE9
095A4:  CLRF   1B
095A6:  BTFSC  FF2.7
095A8:  BSF    1B.7
095AA:  BCF    FF2.7
095AC:  MOVFF  8F5,A4F
095B0:  MOVFF  8F4,A4E
095B4:  MOVFF  8F3,A4D
095B8:  MOVFF  8F2,A4C
095BC:  MOVFF  8FD,A53
095C0:  MOVFF  8FC,A52
095C4:  MOVFF  8FB,A51
095C8:  MOVFF  8FA,A50
095CC:  MOVLB  0
095CE:  CALL   104E
095D2:  BTFSC  1B.7
095D4:  BSF    FF2.7
095D6:  MOVF   01,W
095D8:  MOVF   00,F
095DA:  BNZ   9602
095DC:  MOVLB  8
095DE:  MOVF   xF8,W
095E0:  XORLW  01
095E2:  BTFSS  FD8.2
095E4:  BRA    95EA
095E6:  MOVLB  0
095E8:  BRA    9602
095EA:  MOVF   xF6,W
095EC:  BZ    9608
095EE:  ANDLW  0F
095F0:  SUBWF  xF8,W
095F2:  BZ    95F6
095F4:  BC    9646
095F6:  BTFSC  xF6.7
095F8:  BRA    9646
095FA:  BTFSC  xF6.6
095FC:  BRA    9608
095FE:  MOVLW  20
09600:  BRA    963C
09602:  MOVLW  20
09604:  MOVLB  8
09606:  ANDWF  xF6,F
09608:  BTFSS  xF6.5
0960A:  BRA    9620
0960C:  BCF    xF6.5
0960E:  MOVFF  00,8F6
09612:  MOVLW  2D
09614:  BTFSS  F9E.4
09616:  BRA    9614
09618:  MOVWF  FAD
0961A:  MOVFF  8F6,00
0961E:  CLRF   xF6
09620:  MOVLW  30
09622:  BTFSS  xF6.5
09624:  BRA    963C
09626:  BCF    xF6.5
09628:  MOVFF  00,8F6
0962C:  MOVLW  2D
0962E:  BTFSS  F9E.4
09630:  BRA    962E
09632:  MOVWF  FAD
09634:  MOVFF  8F6,00
09638:  CLRF   xF6
0963A:  MOVLW  30
0963C:  ADDWF  00,F
0963E:  MOVF   00,W
09640:  BTFSS  F9E.4
09642:  BRA    9640
09644:  MOVWF  FAD
09646:  BCF    FD8.1
09648:  CLRF   1B
0964A:  BTFSC  FF2.7
0964C:  BSF    1B.7
0964E:  BCF    FF2.7
09650:  MOVFF  8FD,A4F
09654:  MOVFF  8FC,A4E
09658:  MOVFF  8FB,A4D
0965C:  MOVFF  8FA,A4C
09660:  MOVLB  A
09662:  CLRF   x53
09664:  CLRF   x52
09666:  CLRF   x51
09668:  MOVLW  0A
0966A:  MOVWF  x50
0966C:  MOVLB  0
0966E:  CALL   104E
09672:  BTFSC  1B.7
09674:  BSF    FF2.7
09676:  MOVFF  03,8FD
0967A:  MOVFF  02,8FC
0967E:  MOVFF  01,8FB
09682:  MOVFF  00,8FA
09686:  MOVLB  8
09688:  DECFSZ xF8,F
0968A:  BRA    959A
0968C:  MOVLB  0
0968E:  RETURN 0
*
0A758:  ADDWF  FE8,W
0A75A:  CLRF   FF7
0A75C:  RLCF   FF7,F
0A75E:  ADDLW  79
0A760:  MOVWF  FF6
0A762:  MOVLW  A7
0A764:  ADDWFC FF7,F
0A766:  MOVLW  00
0A768:  MOVWF  FF8
0A76A:  MOVWF  FFB
0A76C:  TBLRD*-
0A76E:  MOVF   FF5,W
0A770:  MOVWF  FFA
0A772:  TBLRD*
0A774:  MOVF   FF5,W
0A776:  MOVWF  FF9
0A778:  DATA B4,A0
0A77A:  DATA D4,A0
0A77C:  DATA FC,A0
0A77E:  DATA 2C,A1
0A780:  DATA 54,A1
*
0AACC:  TBLRD*+
0AACE:  MOVFF  FF6,8EC
0AAD2:  MOVFF  FF7,8ED
0AAD6:  MOVFF  FF8,8EE
0AADA:  MOVFF  FF5,8FF
0AADE:  CALL   509E
0AAE2:  MOVFF  8EC,FF6
0AAE6:  MOVFF  8ED,FF7
0AAEA:  MOVFF  8EE,FF8
0AAEE:  MOVLB  8
0AAF0:  DECFSZ xEB,F
0AAF2:  BRA    AAF6
0AAF4:  BRA    AAFA
0AAF6:  MOVLB  0
0AAF8:  BRA    AACC
0AAFA:  MOVLB  0
0AAFC:  RETURN 0
0AAFE:  MOVFF  FEA,8FE
0AB02:  MOVFF  FE9,8FD
0AB06:  MOVLB  8
0AB08:  SWAPF  xF7,W
0AB0A:  IORLW  F0
0AB0C:  MOVWF  xF9
0AB0E:  ADDWF  xF9,F
0AB10:  ADDLW  E2
0AB12:  MOVWF  xFA
0AB14:  ADDLW  32
0AB16:  MOVWF  xFC
0AB18:  MOVF   xF7,W
0AB1A:  ANDLW  0F
0AB1C:  ADDWF  xFA,F
0AB1E:  ADDWF  xFA,F
0AB20:  ADDWF  xFC,F
0AB22:  ADDLW  E9
0AB24:  MOVWF  xFB
0AB26:  ADDWF  xFB,F
0AB28:  ADDWF  xFB,F
0AB2A:  SWAPF  xF6,W
0AB2C:  ANDLW  0F
0AB2E:  ADDWF  xFB,F
0AB30:  ADDWF  xFC,F
0AB32:  RLCF   xFB,F
0AB34:  RLCF   xFC,F
0AB36:  COMF   xFC,F
0AB38:  RLCF   xFC,F
0AB3A:  MOVF   xF6,W
0AB3C:  ANDLW  0F
0AB3E:  ADDWF  xFC,F
0AB40:  RLCF   xF9,F
0AB42:  MOVLW  07
0AB44:  MOVWF  xF8
0AB46:  MOVLW  0A
0AB48:  DECF   xFB,F
0AB4A:  ADDWF  xFC,F
0AB4C:  BNC   AB48
0AB4E:  DECF   xFA,F
0AB50:  ADDWF  xFB,F
0AB52:  BNC   AB4E
0AB54:  DECF   xF9,F
0AB56:  ADDWF  xFA,F
0AB58:  BNC   AB54
0AB5A:  DECF   xF8,F
0AB5C:  ADDWF  xF9,F
0AB5E:  BNC   AB5A
0AB60:  MOVLW  08
0AB62:  MOVWF  FEA
0AB64:  MOVLW  F8
0AB66:  MOVWF  FE9
0AB68:  MOVLW  07
0AB6A:  ANDWF  xFD,W
0AB6C:  BCF    xFD.6
0AB6E:  ADDWF  FE9,F
0AB70:  MOVLW  00
0AB72:  ADDWFC FEA,F
0AB74:  MOVF   FE9,W
0AB76:  SUBLW  FC
0AB78:  BNZ   AB82
0AB7A:  MOVF   FEA,W
0AB7C:  SUBLW  08
0AB7E:  BNZ   AB82
0AB80:  BSF    xFD.6
0AB82:  MOVF   FEF,W
0AB84:  MOVWF  00
0AB86:  BNZ   AB98
0AB88:  BTFSC  xFD.6
0AB8A:  BRA    AB98
0AB8C:  BTFSC  xFD.4
0AB8E:  BRA    ABBC
0AB90:  BTFSC  xFD.3
0AB92:  BRA    AB98
0AB94:  MOVLW  20
0AB96:  BRA    AB9E
0AB98:  BSF    xFD.3
0AB9A:  BCF    xFD.4
0AB9C:  MOVLW  30
0AB9E:  ADDWF  00,F
0ABA0:  MOVFF  FEA,8F7
0ABA4:  MOVFF  FE9,8F6
0ABA8:  MOVFF  00,8FF
0ABAC:  MOVLB  0
0ABAE:  CALL   509E
0ABB2:  MOVFF  8F7,FEA
0ABB6:  MOVFF  8F6,FE9
0ABBA:  MOVLB  8
0ABBC:  MOVF   FEE,W
0ABBE:  BTFSS  xFD.6
0ABC0:  BRA    AB74
0ABC2:  MOVLB  0
0ABC4:  RETURN 0
*
0ADEC:  ADDWF  FE8,W
0ADEE:  CLRF   FF7
0ADF0:  RLCF   FF7,F
0ADF2:  ADDLW  0D
0ADF4:  MOVWF  FF6
0ADF6:  MOVLW  AE
0ADF8:  ADDWFC FF7,F
0ADFA:  MOVLW  00
0ADFC:  MOVWF  FF8
0ADFE:  MOVWF  FFB
0AE00:  TBLRD*-
0AE02:  MOVF   FF5,W
0AE04:  MOVWF  FFA
0AE06:  TBLRD*
0AE08:  MOVF   FF5,W
0AE0A:  MOVWF  FF9
0AE0C:  DATA C0,AC
0AE0E:  DATA E8,AD
0AE10:  DATA E8,AD
0AE12:  DATA 20,AC
0AE14:  DATA E8,AD
0AE16:  DATA E8,AD
0AE18:  DATA E8,AD
0AE1A:  DATA E4,AB
0AE1C:  DATA E8,AD
0AE1E:  DATA E8,AD
0AE20:  DATA E8,AD
0AE22:  DATA 36,AD
0AE24:  DATA 5C,AC
0AE26:  DATA E8,AD
0AE28:  DATA FA,AC
0AE2A:  DATA 90,AD
*
0AE86:  TBLRD*+
0AE88:  MOVF   FF5,F
0AE8A:  BZ    AEAE
0AE8C:  MOVFF  FF6,885
0AE90:  MOVFF  FF7,886
0AE94:  MOVFF  FF8,887
0AE98:  MOVF   FF5,W
0AE9A:  BTFSS  F9E.4
0AE9C:  BRA    AE9A
0AE9E:  MOVWF  FAD
0AEA0:  MOVFF  885,FF6
0AEA4:  MOVFF  886,FF7
0AEA8:  MOVFF  887,FF8
0AEAC:  BRA    AE86
0AEAE:  RETURN 0
*
0C2C4:  MOVLB  9
0C2C6:  MOVF   x13,W
0C2C8:  BTFSC  FD8.2
0C2CA:  BRA    C3AE
0C2CC:  MOVWF  00
0C2CE:  MOVF   x17,W
0C2D0:  BTFSC  FD8.2
0C2D2:  BRA    C3AE
0C2D4:  ADDWF  00,F
0C2D6:  BNC   C2E0
0C2D8:  MOVLW  81
0C2DA:  ADDWF  00,F
0C2DC:  BC    C3AE
0C2DE:  BRA    C2E8
0C2E0:  MOVLW  7F
0C2E2:  SUBWF  00,F
0C2E4:  BNC   C3AE
0C2E6:  BZ    C3AE
0C2E8:  MOVFF  914,91B
0C2EC:  MOVF   x18,W
0C2EE:  XORWF  x1B,F
0C2F0:  BSF    x14.7
0C2F2:  BSF    x18.7
0C2F4:  MOVF   x16,W
0C2F6:  MULWF  x1A
0C2F8:  MOVFF  FF4,91D
0C2FC:  MOVF   x15,W
0C2FE:  MULWF  x19
0C300:  MOVFF  FF4,03
0C304:  MOVFF  FF3,91C
0C308:  MULWF  x1A
0C30A:  MOVF   FF3,W
0C30C:  ADDWF  x1D,F
0C30E:  MOVF   FF4,W
0C310:  ADDWFC x1C,F
0C312:  MOVLW  00
0C314:  ADDWFC 03,F
0C316:  MOVF   x16,W
0C318:  MULWF  x19
0C31A:  MOVF   FF3,W
0C31C:  ADDWF  x1D,F
0C31E:  MOVF   FF4,W
0C320:  ADDWFC x1C,F
0C322:  MOVLW  00
0C324:  CLRF   02
0C326:  ADDWFC 03,F
0C328:  ADDWFC 02,F
0C32A:  MOVF   x14,W
0C32C:  MULWF  x1A
0C32E:  MOVF   FF3,W
0C330:  ADDWF  x1C,F
0C332:  MOVF   FF4,W
0C334:  ADDWFC 03,F
0C336:  MOVLW  00
0C338:  ADDWFC 02,F
0C33A:  MOVF   x14,W
0C33C:  MULWF  x19
0C33E:  MOVF   FF3,W
0C340:  ADDWF  03,F
0C342:  MOVF   FF4,W
0C344:  ADDWFC 02,F
0C346:  MOVLW  00
0C348:  CLRF   01
0C34A:  ADDWFC 01,F
0C34C:  MOVF   x16,W
0C34E:  MULWF  x18
0C350:  MOVF   FF3,W
0C352:  ADDWF  x1C,F
0C354:  MOVF   FF4,W
0C356:  ADDWFC 03,F
0C358:  MOVLW  00
0C35A:  ADDWFC 02,F
0C35C:  ADDWFC 01,F
0C35E:  MOVF   x15,W
0C360:  MULWF  x18
0C362:  MOVF   FF3,W
0C364:  ADDWF  03,F
0C366:  MOVF   FF4,W
0C368:  ADDWFC 02,F
0C36A:  MOVLW  00
0C36C:  ADDWFC 01,F
0C36E:  MOVF   x14,W
0C370:  MULWF  x18
0C372:  MOVF   FF3,W
0C374:  ADDWF  02,F
0C376:  MOVF   FF4,W
0C378:  ADDWFC 01,F
0C37A:  INCF   00,F
0C37C:  BTFSC  01.7
0C37E:  BRA    C38A
0C380:  RLCF   x1C,F
0C382:  RLCF   03,F
0C384:  RLCF   02,F
0C386:  RLCF   01,F
0C388:  DECF   00,F
0C38A:  MOVLW  00
0C38C:  BTFSS  x1C.7
0C38E:  BRA    C3A4
0C390:  INCF   03,F
0C392:  ADDWFC 02,F
0C394:  ADDWFC 01,F
0C396:  MOVF   01,W
0C398:  BNZ   C3A4
0C39A:  MOVF   02,W
0C39C:  BNZ   C3A4
0C39E:  MOVF   03,W
0C3A0:  BNZ   C3A4
0C3A2:  INCF   00,F
0C3A4:  BTFSC  x1B.7
0C3A6:  BSF    01.7
0C3A8:  BTFSS  x1B.7
0C3AA:  BCF    01.7
0C3AC:  BRA    C3B6
0C3AE:  CLRF   00
0C3B0:  CLRF   01
0C3B2:  CLRF   02
0C3B4:  CLRF   03
0C3B6:  MOVLB  0
0C3B8:  RETURN 0
0C3BA:  MOVLW  80
0C3BC:  BTFSS  FD8.1
0C3BE:  BRA    C3C4
0C3C0:  MOVLB  9
0C3C2:  XORWF  x1C,F
0C3C4:  MOVLB  9
0C3C6:  CLRF   x21
0C3C8:  CLRF   x22
0C3CA:  MOVFF  918,920
0C3CE:  MOVF   x1C,W
0C3D0:  XORWF  x20,F
0C3D2:  MOVF   x17,W
0C3D4:  BTFSC  FD8.2
0C3D6:  BRA    C596
0C3D8:  MOVWF  x1F
0C3DA:  MOVWF  00
0C3DC:  MOVF   x1B,W
0C3DE:  BTFSC  FD8.2
0C3E0:  BRA    C5A8
0C3E2:  SUBWF  x1F,F
0C3E4:  BTFSC  FD8.2
0C3E6:  BRA    C4EE
0C3E8:  BNC   C466
0C3EA:  MOVFF  91C,925
0C3EE:  BSF    x25.7
0C3F0:  MOVFF  91D,924
0C3F4:  MOVFF  91E,923
0C3F8:  CLRF   x22
0C3FA:  BCF    FD8.0
0C3FC:  RRCF   x25,F
0C3FE:  RRCF   x24,F
0C400:  RRCF   x23,F
0C402:  RRCF   x22,F
0C404:  DECFSZ x1F,F
0C406:  BRA    C3F8
0C408:  BTFSS  x20.7
0C40A:  BRA    C412
0C40C:  BSF    x21.0
0C40E:  BRA    C5D0
0C410:  BCF    x21.0
0C412:  BCF    x1F.0
0C414:  BSF    x21.4
0C416:  MOVLW  09
0C418:  MOVWF  FEA
0C41A:  MOVLW  1A
0C41C:  MOVWF  FE9
0C41E:  BRA    C5F6
0C420:  BCF    x21.4
0C422:  BTFSC  x20.7
0C424:  BRA    C43A
0C426:  BTFSS  x1F.0
0C428:  BRA    C450
0C42A:  RRCF   x25,F
0C42C:  RRCF   x24,F
0C42E:  RRCF   x23,F
0C430:  RRCF   x22,F
0C432:  INCF   00,F
0C434:  BTFSC  FD8.2
0C436:  BRA    C5C6
0C438:  BRA    C450
0C43A:  BTFSC  x25.7
0C43C:  BRA    C456
0C43E:  BCF    FD8.0
0C440:  RLCF   x22,F
0C442:  RLCF   x23,F
0C444:  RLCF   x24,F
0C446:  RLCF   x25,F
0C448:  DECF   00,F
0C44A:  BTFSC  FD8.2
0C44C:  BRA    C5C6
0C44E:  BRA    C43A
0C450:  BSF    x21.6
0C452:  BRA    C52E
0C454:  BCF    x21.6
0C456:  MOVFF  918,920
0C45A:  BTFSS  x18.7
0C45C:  BRA    C462
0C45E:  BSF    x25.7
0C460:  BRA    C5B8
0C462:  BCF    x25.7
0C464:  BRA    C5B8
0C466:  MOVFF  91B,91F
0C46A:  MOVFF  91B,00
0C46E:  MOVF   x17,W
0C470:  SUBWF  x1F,F
0C472:  MOVFF  918,925
0C476:  BSF    x25.7
0C478:  MOVFF  919,924
0C47C:  MOVFF  91A,923
0C480:  CLRF   x22
0C482:  BCF    FD8.0
0C484:  RRCF   x25,F
0C486:  RRCF   x24,F
0C488:  RRCF   x23,F
0C48A:  RRCF   x22,F
0C48C:  DECFSZ x1F,F
0C48E:  BRA    C480
0C490:  BTFSS  x20.7
0C492:  BRA    C49A
0C494:  BSF    x21.1
0C496:  BRA    C5D0
0C498:  BCF    x21.1
0C49A:  BCF    x1F.0
0C49C:  BSF    x21.5
0C49E:  MOVLW  09
0C4A0:  MOVWF  FEA
0C4A2:  MOVLW  1E
0C4A4:  MOVWF  FE9
0C4A6:  BRA    C5F6
0C4A8:  BCF    x21.5
0C4AA:  BTFSC  x20.7
0C4AC:  BRA    C4C2
0C4AE:  BTFSS  x1F.0
0C4B0:  BRA    C4D8
0C4B2:  RRCF   x25,F
0C4B4:  RRCF   x24,F
0C4B6:  RRCF   x23,F
0C4B8:  RRCF   x22,F
0C4BA:  INCF   00,F
0C4BC:  BTFSC  FD8.2
0C4BE:  BRA    C5C6
0C4C0:  BRA    C4D8
0C4C2:  BTFSC  x25.7
0C4C4:  BRA    C4DE
0C4C6:  BCF    FD8.0
0C4C8:  RLCF   x22,F
0C4CA:  RLCF   x23,F
0C4CC:  RLCF   x24,F
0C4CE:  RLCF   x25,F
0C4D0:  DECF   00,F
0C4D2:  BTFSC  FD8.2
0C4D4:  BRA    C5C6
0C4D6:  BRA    C4C2
0C4D8:  BSF    x21.7
0C4DA:  BRA    C52E
0C4DC:  BCF    x21.7
0C4DE:  MOVFF  91C,920
0C4E2:  BTFSS  x1C.7
0C4E4:  BRA    C4EA
0C4E6:  BSF    x25.7
0C4E8:  BRA    C5B8
0C4EA:  BCF    x25.7
0C4EC:  BRA    C5B8
0C4EE:  MOVFF  91C,925
0C4F2:  BSF    x25.7
0C4F4:  MOVFF  91D,924
0C4F8:  MOVFF  91E,923
0C4FC:  BTFSS  x20.7
0C4FE:  BRA    C508
0C500:  BCF    x25.7
0C502:  BSF    x21.2
0C504:  BRA    C5D0
0C506:  BCF    x21.2
0C508:  CLRF   x22
0C50A:  BCF    x1F.0
0C50C:  MOVLW  09
0C50E:  MOVWF  FEA
0C510:  MOVLW  1A
0C512:  MOVWF  FE9
0C514:  BRA    C5F6
0C516:  BTFSC  x20.7
0C518:  BRA    C552
0C51A:  MOVFF  918,920
0C51E:  BTFSS  x1F.0
0C520:  BRA    C52E
0C522:  RRCF   x25,F
0C524:  RRCF   x24,F
0C526:  RRCF   x23,F
0C528:  RRCF   x22,F
0C52A:  INCF   00,F
0C52C:  BZ    C5C6
0C52E:  BTFSS  x22.7
0C530:  BRA    C548
0C532:  INCF   x23,F
0C534:  BNZ   C548
0C536:  INCF   x24,F
0C538:  BNZ   C548
0C53A:  INCF   x25,F
0C53C:  BNZ   C548
0C53E:  RRCF   x25,F
0C540:  RRCF   x24,F
0C542:  RRCF   x23,F
0C544:  INCF   00,F
0C546:  BZ    C5C6
0C548:  BTFSC  x21.6
0C54A:  BRA    C454
0C54C:  BTFSC  x21.7
0C54E:  BRA    C4DC
0C550:  BRA    C58A
0C552:  MOVLW  80
0C554:  XORWF  x25,F
0C556:  BTFSS  x25.7
0C558:  BRA    C562
0C55A:  BRA    C5D0
0C55C:  MOVFF  91C,920
0C560:  BRA    C576
0C562:  MOVFF  918,920
0C566:  MOVF   x25,F
0C568:  BNZ   C576
0C56A:  MOVF   x24,F
0C56C:  BNZ   C576
0C56E:  MOVF   x23,F
0C570:  BNZ   C576
0C572:  CLRF   00
0C574:  BRA    C5B8
0C576:  BTFSC  x25.7
0C578:  BRA    C58A
0C57A:  BCF    FD8.0
0C57C:  RLCF   x22,F
0C57E:  RLCF   x23,F
0C580:  RLCF   x24,F
0C582:  RLCF   x25,F
0C584:  DECFSZ 00,F
0C586:  BRA    C576
0C588:  BRA    C5C6
0C58A:  BTFSS  x20.7
0C58C:  BRA    C592
0C58E:  BSF    x25.7
0C590:  BRA    C5B8
0C592:  BCF    x25.7
0C594:  BRA    C5B8
0C596:  MOVFF  91B,00
0C59A:  MOVFF  91C,925
0C59E:  MOVFF  91D,924
0C5A2:  MOVFF  91E,923
0C5A6:  BRA    C5B8
0C5A8:  MOVFF  917,00
0C5AC:  MOVFF  918,925
0C5B0:  MOVFF  919,924
0C5B4:  MOVFF  91A,923
0C5B8:  MOVFF  925,01
0C5BC:  MOVFF  924,02
0C5C0:  MOVFF  923,03
0C5C4:  BRA    C62E
0C5C6:  CLRF   00
0C5C8:  CLRF   01
0C5CA:  CLRF   02
0C5CC:  CLRF   03
0C5CE:  BRA    C62E
0C5D0:  CLRF   x22
0C5D2:  COMF   x23,F
0C5D4:  COMF   x24,F
0C5D6:  COMF   x25,F
0C5D8:  COMF   x22,F
0C5DA:  INCF   x22,F
0C5DC:  BNZ   C5E8
0C5DE:  INCF   x23,F
0C5E0:  BNZ   C5E8
0C5E2:  INCF   x24,F
0C5E4:  BNZ   C5E8
0C5E6:  INCF   x25,F
0C5E8:  BTFSC  x21.0
0C5EA:  BRA    C410
0C5EC:  BTFSC  x21.1
0C5EE:  BRA    C498
0C5F0:  BTFSC  x21.2
0C5F2:  BRA    C506
0C5F4:  BRA    C55C
0C5F6:  MOVF   FEF,W
0C5F8:  ADDWF  x23,F
0C5FA:  BNC   C606
0C5FC:  INCF   x24,F
0C5FE:  BNZ   C606
0C600:  INCF   x25,F
0C602:  BTFSC  FD8.2
0C604:  BSF    x1F.0
0C606:  MOVF   FED,F
0C608:  MOVF   FEF,W
0C60A:  ADDWF  x24,F
0C60C:  BNC   C614
0C60E:  INCF   x25,F
0C610:  BTFSC  FD8.2
0C612:  BSF    x1F.0
0C614:  MOVF   FED,F
0C616:  MOVF   FEF,W
0C618:  BTFSC  FEF.7
0C61A:  BRA    C61E
0C61C:  XORLW  80
0C61E:  ADDWF  x25,F
0C620:  BTFSC  FD8.0
0C622:  BSF    x1F.0
0C624:  BTFSC  x21.4
0C626:  BRA    C420
0C628:  BTFSC  x21.5
0C62A:  BRA    C4A8
0C62C:  BRA    C516
0C62E:  MOVLB  0
0C630:  RETURN 0
0C632:  MOVLB  8
0C634:  MOVF   xDC,W
0C636:  SUBLW  B6
0C638:  MOVWF  xDC
0C63A:  CLRF   03
0C63C:  MOVFF  8DD,8E0
0C640:  BSF    xDD.7
0C642:  BCF    FD8.0
0C644:  RRCF   xDD,F
0C646:  RRCF   xDE,F
0C648:  RRCF   xDF,F
0C64A:  RRCF   03,F
0C64C:  RRCF   02,F
0C64E:  RRCF   01,F
0C650:  RRCF   00,F
0C652:  DECFSZ xDC,F
0C654:  BRA    C642
0C656:  BTFSS  xE0.7
0C658:  BRA    C670
0C65A:  COMF   00,F
0C65C:  COMF   01,F
0C65E:  COMF   02,F
0C660:  COMF   03,F
0C662:  INCF   00,F
0C664:  BTFSC  FD8.2
0C666:  INCF   01,F
0C668:  BTFSC  FD8.2
0C66A:  INCF   02,F
0C66C:  BTFSC  FD8.2
0C66E:  INCF   03,F
0C670:  MOVLB  0
0C672:  RETURN 0
0C674:  MOVF   FE9,W
0C676:  MOVLB  8
0C678:  MOVWF  x8A
0C67A:  MOVF   x89,W
0C67C:  MOVWF  x8C
0C67E:  BZ    C6B8
0C680:  MOVFF  888,916
0C684:  MOVFF  887,915
0C688:  MOVFF  886,914
0C68C:  MOVFF  885,913
0C690:  MOVLB  9
0C692:  CLRF   x1A
0C694:  CLRF   x19
0C696:  MOVLW  20
0C698:  MOVWF  x18
0C69A:  MOVLW  82
0C69C:  MOVWF  x17
0C69E:  MOVLB  0
0C6A0:  RCALL  C2C4
0C6A2:  MOVFF  03,888
0C6A6:  MOVFF  02,887
0C6AA:  MOVFF  01,886
0C6AE:  MOVFF  00,885
0C6B2:  MOVLB  8
0C6B4:  DECFSZ x8C,F
0C6B6:  BRA    C680
0C6B8:  MOVLW  7E
0C6BA:  MOVWF  00
0C6BC:  CLRF   01
0C6BE:  BTFSC  x86.7
0C6C0:  BSF    01.7
0C6C2:  CLRF   02
0C6C4:  CLRF   03
0C6C6:  BCF    FD8.1
0C6C8:  MOVFF  888,91A
0C6CC:  MOVFF  887,919
0C6D0:  MOVFF  886,918
0C6D4:  MOVFF  885,917
0C6D8:  MOVFF  03,91E
0C6DC:  MOVFF  02,91D
0C6E0:  MOVFF  01,91C
0C6E4:  MOVFF  FE8,91B
0C6E8:  MOVLB  0
0C6EA:  RCALL  C3BA
0C6EC:  MOVFF  03,888
0C6F0:  MOVFF  02,887
0C6F4:  MOVFF  01,886
0C6F8:  MOVFF  00,885
0C6FC:  MOVFF  888,8DF
0C700:  MOVFF  887,8DE
0C704:  MOVFF  886,8DD
0C708:  MOVFF  885,8DC
0C70C:  RCALL  C632
0C70E:  MOVFF  03,888
0C712:  MOVFF  02,887
0C716:  MOVFF  01,886
0C71A:  MOVFF  00,885
0C71E:  MOVLB  8
0C720:  BTFSS  x88.7
0C722:  BRA    C73E
0C724:  DECF   x8A,F
0C726:  BSF    x8A.5
0C728:  COMF   x85,F
0C72A:  COMF   x86,F
0C72C:  COMF   x87,F
0C72E:  COMF   x88,F
0C730:  INCF   x85,F
0C732:  BTFSC  FD8.2
0C734:  INCF   x86,F
0C736:  BTFSC  FD8.2
0C738:  INCF   x87,F
0C73A:  BTFSC  FD8.2
0C73C:  INCF   x88,F
0C73E:  MOVLW  3B
0C740:  MOVWF  x91
0C742:  MOVLW  9A
0C744:  MOVWF  x90
0C746:  MOVLW  CA
0C748:  MOVWF  x8F
0C74A:  CLRF   x8E
0C74C:  MOVLW  0A
0C74E:  MOVWF  x8C
0C750:  MOVF   x89,W
0C752:  BTFSC  FD8.2
0C754:  INCF   x8A,F
0C756:  BSF    FD8.1
0C758:  MOVLW  08
0C75A:  MOVWF  FEA
0C75C:  MOVLW  85
0C75E:  MOVWF  FE9
0C760:  CLRF   1B
0C762:  BTFSC  FF2.7
0C764:  BSF    1B.7
0C766:  BCF    FF2.7
0C768:  MOVFF  888,A4F
0C76C:  MOVFF  887,A4E
0C770:  MOVFF  886,A4D
0C774:  MOVFF  885,A4C
0C778:  MOVFF  891,A53
0C77C:  MOVFF  890,A52
0C780:  MOVFF  88F,A51
0C784:  MOVFF  88E,A50
0C788:  MOVLB  0
0C78A:  CALL   104E
0C78E:  BTFSC  1B.7
0C790:  BSF    FF2.7
0C792:  MOVF   01,W
0C794:  MOVF   00,F
0C796:  BNZ   C7BE
0C798:  MOVLB  8
0C79A:  INCF   x89,W
0C79C:  SUBWF  x8C,W
0C79E:  BTFSS  FD8.2
0C7A0:  BRA    C7A6
0C7A2:  MOVLB  0
0C7A4:  BRA    C7BE
0C7A6:  MOVF   x8A,W
0C7A8:  BZ    C7C4
0C7AA:  ANDLW  0F
0C7AC:  SUBWF  x8C,W
0C7AE:  BZ    C7B2
0C7B0:  BC    C82A
0C7B2:  BTFSC  x8A.7
0C7B4:  BRA    C82A
0C7B6:  BTFSC  x8A.6
0C7B8:  BRA    C7C4
0C7BA:  MOVLW  20
0C7BC:  BRA    C820
0C7BE:  MOVLW  20
0C7C0:  MOVLB  8
0C7C2:  ANDWF  x8A,F
0C7C4:  BTFSS  x8A.5
0C7C6:  BRA    C7E2
0C7C8:  BCF    x8A.5
0C7CA:  MOVF   x89,W
0C7CC:  BTFSS  FD8.2
0C7CE:  DECF   x8A,F
0C7D0:  MOVF   00,W
0C7D2:  MOVWF  x8A
0C7D4:  MOVLW  2D
0C7D6:  BTFSS  F9E.4
0C7D8:  BRA    C7D6
0C7DA:  MOVWF  FAD
0C7DC:  MOVF   x8A,W
0C7DE:  MOVWF  00
0C7E0:  CLRF   x8A
0C7E2:  MOVF   x89,W
0C7E4:  SUBWF  x8C,W
0C7E6:  BNZ   C7FE
0C7E8:  MOVF   00,W
0C7EA:  MOVWF  x8A
0C7EC:  MOVLW  2E
0C7EE:  BTFSS  F9E.4
0C7F0:  BRA    C7EE
0C7F2:  MOVWF  FAD
0C7F4:  MOVF   x8A,W
0C7F6:  MOVWF  00
0C7F8:  MOVLW  20
0C7FA:  ANDWF  x8A,F
0C7FC:  MOVLW  00
0C7FE:  MOVLW  30
0C800:  BTFSS  x8A.5
0C802:  BRA    C820
0C804:  BCF    x8A.5
0C806:  MOVF   x89,W
0C808:  BTFSS  FD8.2
0C80A:  DECF   x8A,F
0C80C:  MOVF   00,W
0C80E:  MOVWF  x8A
0C810:  MOVLW  2D
0C812:  BTFSS  F9E.4
0C814:  BRA    C812
0C816:  MOVWF  FAD
0C818:  MOVF   x8A,W
0C81A:  MOVWF  00
0C81C:  CLRF   x8A
0C81E:  MOVLW  30
0C820:  ADDWF  00,F
0C822:  MOVF   00,W
0C824:  BTFSS  F9E.4
0C826:  BRA    C824
0C828:  MOVWF  FAD
0C82A:  BCF    FD8.1
0C82C:  CLRF   1B
0C82E:  BTFSC  FF2.7
0C830:  BSF    1B.7
0C832:  BCF    FF2.7
0C834:  MOVFF  891,A4F
0C838:  MOVFF  890,A4E
0C83C:  MOVFF  88F,A4D
0C840:  MOVFF  88E,A4C
0C844:  MOVLB  A
0C846:  CLRF   x53
0C848:  CLRF   x52
0C84A:  CLRF   x51
0C84C:  MOVLW  0A
0C84E:  MOVWF  x50
0C850:  MOVLB  0
0C852:  CALL   104E
0C856:  BTFSC  1B.7
0C858:  BSF    FF2.7
0C85A:  MOVFF  03,891
0C85E:  MOVFF  02,890
0C862:  MOVFF  01,88F
0C866:  MOVFF  00,88E
0C86A:  MOVLB  8
0C86C:  DECFSZ x8C,F
0C86E:  BRA    C756
0C870:  MOVLB  0
0C872:  RETURN 0
*
0C8F6:  MOVLW  8E
0C8F8:  MOVWF  00
0C8FA:  MOVFF  918,01
0C8FE:  MOVFF  917,02
0C902:  CLRF   03
0C904:  MOVF   01,F
0C906:  BNZ   C91A
0C908:  MOVFF  02,01
0C90C:  CLRF   02
0C90E:  MOVLW  08
0C910:  SUBWF  00,F
0C912:  MOVF   01,F
0C914:  BNZ   C91A
0C916:  CLRF   00
0C918:  BRA    C92A
0C91A:  BCF    FD8.0
0C91C:  BTFSC  01.7
0C91E:  BRA    C928
0C920:  RLCF   02,F
0C922:  RLCF   01,F
0C924:  DECF   00,F
0C926:  BRA    C91A
0C928:  BCF    01.7
0C92A:  RETURN 0
0C92C:  MOVLB  8
0C92E:  MOVF   xFB,W
0C930:  BTFSC  FD8.2
0C932:  BRA    CA9C
0C934:  MOVLB  9
0C936:  MOVWF  x07
0C938:  MOVLB  8
0C93A:  MOVF   xFF,W
0C93C:  BTFSC  FD8.2
0C93E:  BRA    CA9C
0C940:  MOVLB  9
0C942:  SUBWF  x07,F
0C944:  BNC   C954
0C946:  MOVLW  7F
0C948:  ADDWF  x07,F
0C94A:  BTFSS  FD8.0
0C94C:  BRA    C952
0C94E:  MOVLB  8
0C950:  BRA    CA9C
0C952:  BRA    C968
0C954:  MOVLW  81
0C956:  SUBWF  x07,F
0C958:  BTFSC  FD8.0
0C95A:  BRA    C960
0C95C:  MOVLB  8
0C95E:  BRA    CA9C
0C960:  BTFSS  FD8.2
0C962:  BRA    C968
0C964:  MOVLB  8
0C966:  BRA    CA9C
0C968:  MOVFF  907,00
0C96C:  CLRF   01
0C96E:  CLRF   02
0C970:  CLRF   03
0C972:  CLRF   x06
0C974:  MOVFF  8FC,905
0C978:  BSF    x05.7
0C97A:  MOVFF  8FD,904
0C97E:  MOVFF  8FE,903
0C982:  MOVLW  19
0C984:  MOVWF  x07
0C986:  MOVF   x02,W
0C988:  SUBWF  x03,F
0C98A:  BC    C9A6
0C98C:  MOVLW  01
0C98E:  SUBWF  x04,F
0C990:  BC    C9A6
0C992:  SUBWF  x05,F
0C994:  BC    C9A6
0C996:  SUBWF  x06,F
0C998:  BC    C9A6
0C99A:  INCF   x06,F
0C99C:  INCF   x05,F
0C99E:  INCF   x04,F
0C9A0:  MOVF   x02,W
0C9A2:  ADDWF  x03,F
0C9A4:  BRA    C9F6
0C9A6:  MOVF   x01,W
0C9A8:  SUBWF  x04,F
0C9AA:  BC    C9D0
0C9AC:  MOVLW  01
0C9AE:  SUBWF  x05,F
0C9B0:  BC    C9D0
0C9B2:  SUBWF  x06,F
0C9B4:  BC    C9D0
0C9B6:  INCF   x06,F
0C9B8:  INCF   x05,F
0C9BA:  MOVF   x01,W
0C9BC:  ADDWF  x04,F
0C9BE:  MOVF   x02,W
0C9C0:  ADDWF  x03,F
0C9C2:  BNC   C9F6
0C9C4:  INCF   x04,F
0C9C6:  BNZ   C9F6
0C9C8:  INCF   x05,F
0C9CA:  BNZ   C9F6
0C9CC:  INCF   x06,F
0C9CE:  BRA    C9F6
0C9D0:  MOVF   x00,W
0C9D2:  IORLW  80
0C9D4:  SUBWF  x05,F
0C9D6:  BC    C9F4
0C9D8:  MOVLW  01
0C9DA:  SUBWF  x06,F
0C9DC:  BC    C9F4
0C9DE:  INCF   x06,F
0C9E0:  MOVF   x00,W
0C9E2:  IORLW  80
0C9E4:  ADDWF  x05,F
0C9E6:  MOVF   x01,W
0C9E8:  ADDWF  x04,F
0C9EA:  BNC   C9BE
0C9EC:  INCF   x05,F
0C9EE:  BNZ   C9BE
0C9F0:  INCF   x06,F
0C9F2:  BRA    C9BE
0C9F4:  BSF    03.0
0C9F6:  DECFSZ x07,F
0C9F8:  BRA    C9FC
0C9FA:  BRA    CA12
0C9FC:  BCF    FD8.0
0C9FE:  RLCF   x03,F
0CA00:  RLCF   x04,F
0CA02:  RLCF   x05,F
0CA04:  RLCF   x06,F
0CA06:  BCF    FD8.0
0CA08:  RLCF   03,F
0CA0A:  RLCF   02,F
0CA0C:  RLCF   01,F
0CA0E:  RLCF   x08,F
0CA10:  BRA    C986
0CA12:  BTFSS  x08.0
0CA14:  BRA    CA22
0CA16:  BCF    FD8.0
0CA18:  RRCF   01,F
0CA1A:  RRCF   02,F
0CA1C:  RRCF   03,F
0CA1E:  RRCF   x08,F
0CA20:  BRA    CA2A
0CA22:  DECFSZ 00,F
0CA24:  BRA    CA2A
0CA26:  MOVLB  8
0CA28:  BRA    CA9C
0CA2A:  BTFSC  x08.7
0CA2C:  BRA    CA6A
0CA2E:  BCF    FD8.0
0CA30:  RLCF   x03,F
0CA32:  RLCF   x04,F
0CA34:  RLCF   x05,F
0CA36:  RLCF   x06,F
0CA38:  MOVF   x02,W
0CA3A:  SUBWF  x03,F
0CA3C:  BC    CA4C
0CA3E:  MOVLW  01
0CA40:  SUBWF  x04,F
0CA42:  BC    CA4C
0CA44:  SUBWF  x05,F
0CA46:  BC    CA4C
0CA48:  SUBWF  x06,F
0CA4A:  BNC   CA86
0CA4C:  MOVF   x01,W
0CA4E:  SUBWF  x04,F
0CA50:  BC    CA5C
0CA52:  MOVLW  01
0CA54:  SUBWF  x05,F
0CA56:  BC    CA5C
0CA58:  SUBWF  x06,F
0CA5A:  BNC   CA86
0CA5C:  MOVF   x00,W
0CA5E:  IORLW  80
0CA60:  SUBWF  x05,F
0CA62:  BC    CA6A
0CA64:  MOVLW  01
0CA66:  SUBWF  x06,F
0CA68:  BNC   CA86
0CA6A:  INCF   03,F
0CA6C:  BNZ   CA86
0CA6E:  INCF   02,F
0CA70:  BNZ   CA86
0CA72:  INCF   01,F
0CA74:  BNZ   CA86
0CA76:  INCF   00,F
0CA78:  BTFSS  FD8.2
0CA7A:  BRA    CA80
0CA7C:  MOVLB  8
0CA7E:  BRA    CA9C
0CA80:  RRCF   01,F
0CA82:  RRCF   02,F
0CA84:  RRCF   03,F
0CA86:  MOVFF  8FC,907
0CA8A:  MOVF   x00,W
0CA8C:  XORWF  x07,F
0CA8E:  BTFSS  x07.7
0CA90:  BRA    CA96
0CA92:  BSF    01.7
0CA94:  BRA    CAA6
0CA96:  BCF    01.7
0CA98:  BRA    CAA6
0CA9A:  MOVLB  8
0CA9C:  CLRF   00
0CA9E:  CLRF   01
0CAA0:  CLRF   02
0CAA2:  CLRF   03
0CAA4:  MOVLB  9
0CAA6:  MOVLB  0
0CAA8:  RETURN 0
*
0D53C:  MOVFF  FEA,8C9
0D540:  MOVFF  FE9,8C8
0D544:  MOVLB  8
0D546:  BTFSS  xC2.7
0D548:  BRA    D55A
0D54A:  BSF    xC8.7
0D54C:  BTFSS  xC8.4
0D54E:  INCF   xC8,F
0D550:  COMF   xC1,F
0D552:  COMF   xC2,F
0D554:  INCF   xC1,F
0D556:  BTFSC  FD8.2
0D558:  INCF   xC2,F
0D55A:  SWAPF  xC2,W
0D55C:  IORLW  F0
0D55E:  MOVWF  xC4
0D560:  ADDWF  xC4,F
0D562:  ADDLW  E2
0D564:  MOVWF  xC5
0D566:  ADDLW  32
0D568:  MOVWF  xC7
0D56A:  MOVF   xC2,W
0D56C:  ANDLW  0F
0D56E:  ADDWF  xC5,F
0D570:  ADDWF  xC5,F
0D572:  ADDWF  xC7,F
0D574:  ADDLW  E9
0D576:  MOVWF  xC6
0D578:  ADDWF  xC6,F
0D57A:  ADDWF  xC6,F
0D57C:  SWAPF  xC1,W
0D57E:  ANDLW  0F
0D580:  ADDWF  xC6,F
0D582:  ADDWF  xC7,F
0D584:  RLCF   xC6,F
0D586:  RLCF   xC7,F
0D588:  COMF   xC7,F
0D58A:  RLCF   xC7,F
0D58C:  MOVF   xC1,W
0D58E:  ANDLW  0F
0D590:  ADDWF  xC7,F
0D592:  RLCF   xC4,F
0D594:  MOVLW  07
0D596:  MOVWF  xC3
0D598:  MOVLW  0A
0D59A:  DECF   xC6,F
0D59C:  ADDWF  xC7,F
0D59E:  BNC   D59A
0D5A0:  DECF   xC5,F
0D5A2:  ADDWF  xC6,F
0D5A4:  BNC   D5A0
0D5A6:  DECF   xC4,F
0D5A8:  ADDWF  xC5,F
0D5AA:  BNC   D5A6
0D5AC:  DECF   xC3,F
0D5AE:  ADDWF  xC4,F
0D5B0:  BNC   D5AC
0D5B2:  MOVLW  08
0D5B4:  MOVWF  FEA
0D5B6:  MOVLW  C3
0D5B8:  MOVWF  FE9
0D5BA:  MOVLW  07
0D5BC:  ANDWF  xC8,W
0D5BE:  BCF    xC8.6
0D5C0:  MOVF   FED,F
0D5C2:  ANDWF  xC8,W
0D5C4:  BNZ   D5D4
0D5C6:  BTFSC  xC8.4
0D5C8:  MOVF   FEE,F
0D5CA:  BTFSC  xC8.4
0D5CC:  BRA    D5D4
0D5CE:  MOVLW  20
0D5D0:  MOVWF  00
0D5D2:  BRA    D616
0D5D4:  ADDWF  FE9,F
0D5D6:  MOVLW  00
0D5D8:  ADDWFC FEA,F
0D5DA:  MOVF   FE9,W
0D5DC:  SUBLW  C7
0D5DE:  BNZ   D5E8
0D5E0:  MOVF   FEA,W
0D5E2:  SUBLW  08
0D5E4:  BNZ   D5E8
0D5E6:  BSF    xC8.6
0D5E8:  MOVF   FEF,W
0D5EA:  MOVWF  00
0D5EC:  BNZ   D5FE
0D5EE:  BTFSC  xC8.6
0D5F0:  BRA    D5FE
0D5F2:  BTFSC  xC8.4
0D5F4:  BRA    D632
0D5F6:  BTFSC  xC8.3
0D5F8:  BRA    D5FE
0D5FA:  MOVLW  20
0D5FC:  BRA    D614
0D5FE:  BTFSS  xC8.7
0D600:  BRA    D60E
0D602:  MOVLW  2D
0D604:  MOVWF  00
0D606:  MOVF   FED,W
0D608:  BCF    xC8.6
0D60A:  BCF    xC8.7
0D60C:  BRA    D616
0D60E:  BSF    xC8.3
0D610:  BCF    xC8.4
0D612:  MOVLW  30
0D614:  ADDWF  00,F
0D616:  MOVFF  FEA,8C2
0D61A:  MOVFF  FE9,8C1
0D61E:  MOVFF  00,8FF
0D622:  MOVLB  0
0D624:  CALL   509E
0D628:  MOVFF  8C2,FEA
0D62C:  MOVFF  8C1,FE9
0D630:  MOVLB  8
0D632:  MOVF   FEE,W
0D634:  BTFSS  xC8.6
0D636:  BRA    D5DA
0D638:  MOVLB  0
0D63A:  GOTO   D75E (RETURN)
*
0D9E2:  ADDWF  FE8,W
0D9E4:  CLRF   FF7
0D9E6:  RLCF   FF7,F
0D9E8:  ADDLW  03
0D9EA:  MOVWF  FF6
0D9EC:  MOVLW  DA
0D9EE:  ADDWFC FF7,F
0D9F0:  MOVLW  00
0D9F2:  MOVWF  FF8
0D9F4:  MOVWF  FFB
0D9F6:  TBLRD*-
0D9F8:  MOVF   FF5,W
0D9FA:  MOVWF  FFA
0D9FC:  TBLRD*
0D9FE:  MOVF   FF5,W
0DA00:  MOVWF  FF9
0DA02:  DATA 14,D9
0DA04:  DATA 3C,D9
0DA06:  DATA 5C,D9
0DA08:  DATA 7C,D9
0DA0A:  DATA 9C,D9
0DA0C:  DATA BC,D9
*
0DA8C:  TBLRD*+
0DA8E:  MOVFF  FF6,8B9
0DA92:  MOVFF  FF7,8BA
0DA96:  MOVFF  FF8,8BB
0DA9A:  MOVF   FF5,W
0DA9C:  BTFSS  FA4.4
0DA9E:  BRA    DA9C
0DAA0:  MOVLB  F
0DAA2:  MOVWF  x1C
0DAA4:  MOVFF  8B9,FF6
0DAA8:  MOVFF  8BA,FF7
0DAAC:  MOVFF  8BB,FF8
0DAB0:  MOVLB  8
0DAB2:  DECFSZ xB8,F
0DAB4:  BRA    DAB8
0DAB6:  BRA    DABC
0DAB8:  MOVLB  0
0DABA:  BRA    DA8C
0DABC:  MOVLB  0
0DABE:  RETURN 0
0DAC0:  MOVF   01,W
0DAC2:  CLRF   1B
0DAC4:  BTFSC  FF2.7
0DAC6:  BSF    1B.7
0DAC8:  BCF    FF2.7
0DACA:  MOVFF  8F3,A42
0DACE:  MOVLW  64
0DAD0:  MOVLB  A
0DAD2:  MOVWF  x43
0DAD4:  MOVLB  0
0DAD6:  CALL   0F72
0DADA:  BTFSC  1B.7
0DADC:  BSF    FF2.7
0DADE:  MOVFF  00,8F3
0DAE2:  MOVF   01,W
0DAE4:  MOVLW  30
0DAE6:  BNZ   DAF8
0DAE8:  MOVLB  8
0DAEA:  BTFSS  xF4.1
0DAEC:  BRA    DB0E
0DAEE:  BTFSC  xF4.3
0DAF0:  BRA    DB0E
0DAF2:  BTFSC  xF4.4
0DAF4:  MOVLW  20
0DAF6:  BRA    DB00
0DAF8:  MOVLB  8
0DAFA:  BCF    xF4.3
0DAFC:  BCF    xF4.4
0DAFE:  BSF    xF4.0
0DB00:  ADDWF  01,F
0DB02:  MOVF   01,W
0DB04:  BTFSS  FA4.4
0DB06:  BRA    DB04
0DB08:  MOVLB  F
0DB0A:  MOVWF  x1C
0DB0C:  MOVLB  8
0DB0E:  CLRF   1B
0DB10:  BTFSC  FF2.7
0DB12:  BSF    1B.7
0DB14:  BCF    FF2.7
0DB16:  MOVFF  8F3,A42
0DB1A:  MOVLW  0A
0DB1C:  MOVLB  A
0DB1E:  MOVWF  x43
0DB20:  MOVLB  0
0DB22:  CALL   0F72
0DB26:  BTFSC  1B.7
0DB28:  BSF    FF2.7
0DB2A:  MOVFF  00,8F3
0DB2E:  MOVF   01,W
0DB30:  MOVLW  30
0DB32:  BNZ   DB44
0DB34:  MOVLB  8
0DB36:  BTFSC  xF4.3
0DB38:  BRA    DB52
0DB3A:  BTFSS  xF4.0
0DB3C:  BRA    DB52
0DB3E:  BTFSC  xF4.4
0DB40:  MOVLW  20
0DB42:  MOVLB  0
0DB44:  ADDWF  01,F
0DB46:  MOVF   01,W
0DB48:  BTFSS  FA4.4
0DB4A:  BRA    DB48
0DB4C:  MOVLB  F
0DB4E:  MOVWF  x1C
0DB50:  MOVLB  8
0DB52:  MOVLW  30
0DB54:  ADDWF  xF3,F
0DB56:  MOVF   xF3,W
0DB58:  BTFSS  FA4.4
0DB5A:  BRA    DB58
0DB5C:  MOVLB  F
0DB5E:  MOVWF  x1C
0DB60:  MOVLB  0
0DB62:  RETURN 0
*
0DB86:  TBLRD*+
0DB88:  MOVF   FF5,F
0DB8A:  BZ    DBB2
0DB8C:  MOVFF  FF6,8B7
0DB90:  MOVFF  FF7,8B8
0DB94:  MOVFF  FF8,8B9
0DB98:  MOVF   FF5,W
0DB9A:  BTFSS  FA4.4
0DB9C:  BRA    DB9A
0DB9E:  MOVLB  F
0DBA0:  MOVWF  x1C
0DBA2:  MOVFF  8B7,FF6
0DBA6:  MOVFF  8B8,FF7
0DBAA:  MOVFF  8B9,FF8
0DBAE:  MOVLB  0
0DBB0:  BRA    DB86
0DBB2:  GOTO   DC74 (RETURN)
*
0E18E:  MOVF   FE9,W
0E190:  MOVLB  8
0E192:  MOVWF  x8C
0E194:  MOVLW  3B
0E196:  MOVWF  x93
0E198:  MOVLW  9A
0E19A:  MOVWF  x92
0E19C:  MOVLW  CA
0E19E:  MOVWF  x91
0E1A0:  CLRF   x90
0E1A2:  MOVLW  0A
0E1A4:  MOVWF  x8E
0E1A6:  MOVF   x8B,W
0E1A8:  BTFSS  FD8.2
0E1AA:  DECF   x8C,F
0E1AC:  BSF    FD8.1
0E1AE:  MOVLW  08
0E1B0:  MOVWF  FEA
0E1B2:  MOVLW  87
0E1B4:  MOVWF  FE9
0E1B6:  CLRF   1B
0E1B8:  BTFSC  FF2.7
0E1BA:  BSF    1B.7
0E1BC:  BCF    FF2.7
0E1BE:  MOVFF  88A,A4F
0E1C2:  MOVFF  889,A4E
0E1C6:  MOVFF  888,A4D
0E1CA:  MOVFF  887,A4C
0E1CE:  MOVFF  893,A53
0E1D2:  MOVFF  892,A52
0E1D6:  MOVFF  891,A51
0E1DA:  MOVFF  890,A50
0E1DE:  MOVLB  0
0E1E0:  CALL   104E
0E1E4:  BTFSC  1B.7
0E1E6:  BSF    FF2.7
0E1E8:  MOVF   01,W
0E1EA:  MOVF   00,F
0E1EC:  BNZ   E214
0E1EE:  MOVLB  8
0E1F0:  INCF   x8B,W
0E1F2:  SUBWF  x8E,W
0E1F4:  BTFSS  FD8.2
0E1F6:  BRA    E1FC
0E1F8:  MOVLB  0
0E1FA:  BRA    E214
0E1FC:  MOVF   x8C,W
0E1FE:  BZ    E218
0E200:  ANDLW  0F
0E202:  SUBWF  x8E,W
0E204:  BZ    E208
0E206:  BC    E240
0E208:  BTFSC  x8C.7
0E20A:  BRA    E240
0E20C:  BTFSC  x8C.6
0E20E:  BRA    E218
0E210:  MOVLW  20
0E212:  BRA    E236
0E214:  MOVLB  8
0E216:  CLRF   x8C
0E218:  MOVF   x8B,W
0E21A:  SUBWF  x8E,W
0E21C:  BNZ   E234
0E21E:  MOVFF  00,88C
0E222:  MOVLW  2E
0E224:  BTFSS  F9E.4
0E226:  BRA    E224
0E228:  MOVWF  FAD
0E22A:  MOVFF  88C,00
0E22E:  MOVLW  20
0E230:  ANDWF  x8C,F
0E232:  MOVLW  00
0E234:  MOVLW  30
0E236:  ADDWF  00,F
0E238:  MOVF   00,W
0E23A:  BTFSS  F9E.4
0E23C:  BRA    E23A
0E23E:  MOVWF  FAD
0E240:  BCF    FD8.1
0E242:  CLRF   1B
0E244:  BTFSC  FF2.7
0E246:  BSF    1B.7
0E248:  BCF    FF2.7
0E24A:  MOVFF  893,A4F
0E24E:  MOVFF  892,A4E
0E252:  MOVFF  891,A4D
0E256:  MOVFF  890,A4C
0E25A:  MOVLB  A
0E25C:  CLRF   x53
0E25E:  CLRF   x52
0E260:  CLRF   x51
0E262:  MOVLW  0A
0E264:  MOVWF  x50
0E266:  MOVLB  0
0E268:  CALL   104E
0E26C:  BTFSC  1B.7
0E26E:  BSF    FF2.7
0E270:  MOVFF  03,893
0E274:  MOVFF  02,892
0E278:  MOVFF  01,891
0E27C:  MOVFF  00,890
0E280:  MOVLB  8
0E282:  DECFSZ x8E,F
0E284:  BRA    E1AC
0E286:  MOVLB  0
0E288:  RETURN 0
*
0F322:  MOVF   FE9,W
0F324:  MOVLB  8
0F326:  MOVWF  xF7
0F328:  MOVLW  3B
0F32A:  MOVWF  xFE
0F32C:  MOVLW  9A
0F32E:  MOVWF  xFD
0F330:  MOVLW  CA
0F332:  MOVWF  xFC
0F334:  CLRF   xFB
0F336:  MOVLW  0A
0F338:  MOVWF  xF9
0F33A:  BSF    FD8.1
0F33C:  MOVLW  08
0F33E:  MOVWF  FEA
0F340:  MOVLW  F3
0F342:  MOVWF  FE9
0F344:  CLRF   1B
0F346:  BTFSC  FF2.7
0F348:  BSF    1B.7
0F34A:  BCF    FF2.7
0F34C:  MOVFF  8F6,A4F
0F350:  MOVFF  8F5,A4E
0F354:  MOVFF  8F4,A4D
0F358:  MOVFF  8F3,A4C
0F35C:  MOVFF  8FE,A53
0F360:  MOVFF  8FD,A52
0F364:  MOVFF  8FC,A51
0F368:  MOVFF  8FB,A50
0F36C:  MOVLB  0
0F36E:  CALL   104E
0F372:  BTFSC  1B.7
0F374:  BSF    FF2.7
0F376:  MOVF   01,W
0F378:  MOVF   00,F
0F37A:  BNZ   F3A2
0F37C:  MOVLB  8
0F37E:  MOVF   xF9,W
0F380:  XORLW  01
0F382:  BTFSS  FD8.2
0F384:  BRA    F38A
0F386:  MOVLB  0
0F388:  BRA    F3A2
0F38A:  MOVF   xF7,W
0F38C:  BZ    F3A6
0F38E:  ANDLW  0F
0F390:  SUBWF  xF9,W
0F392:  BZ    F396
0F394:  BC    F3B6
0F396:  BTFSC  xF7.7
0F398:  BRA    F3B6
0F39A:  BTFSC  xF7.6
0F39C:  BRA    F3A6
0F39E:  MOVLW  20
0F3A0:  BRA    F3A8
0F3A2:  MOVLB  8
0F3A4:  CLRF   xF7
0F3A6:  MOVLW  30
0F3A8:  ADDWF  00,F
0F3AA:  MOVF   00,W
0F3AC:  BTFSS  FA4.4
0F3AE:  BRA    F3AC
0F3B0:  MOVLB  F
0F3B2:  MOVWF  x1C
0F3B4:  MOVLB  8
0F3B6:  BCF    FD8.1
0F3B8:  CLRF   1B
0F3BA:  BTFSC  FF2.7
0F3BC:  BSF    1B.7
0F3BE:  BCF    FF2.7
0F3C0:  MOVFF  8FE,A4F
0F3C4:  MOVFF  8FD,A4E
0F3C8:  MOVFF  8FC,A4D
0F3CC:  MOVFF  8FB,A4C
0F3D0:  MOVLB  A
0F3D2:  CLRF   x53
0F3D4:  CLRF   x52
0F3D6:  CLRF   x51
0F3D8:  MOVLW  0A
0F3DA:  MOVWF  x50
0F3DC:  MOVLB  0
0F3DE:  CALL   104E
0F3E2:  BTFSC  1B.7
0F3E4:  BSF    FF2.7
0F3E6:  MOVFF  03,8FE
0F3EA:  MOVFF  02,8FD
0F3EE:  MOVFF  01,8FC
0F3F2:  MOVFF  00,8FB
0F3F6:  MOVLB  8
0F3F8:  DECFSZ xF9,F
0F3FA:  BRA    F33A
0F3FC:  MOVLB  0
0F3FE:  GOTO   F528 (RETURN)
*
0F5F8:  ADDWF  FE8,W
0F5FA:  CLRF   FF7
0F5FC:  RLCF   FF7,F
0F5FE:  ADDLW  19
0F600:  MOVWF  FF6
0F602:  MOVLW  F6
0F604:  ADDWFC FF7,F
0F606:  MOVLW  00
0F608:  MOVWF  FF8
0F60A:  MOVWF  FFB
0F60C:  TBLRD*-
0F60E:  MOVF   FF5,W
0F610:  MOVWF  FFA
0F612:  TBLRD*
0F614:  MOVF   FF5,W
0F616:  MOVWF  FF9
0F618:  DATA B8,F5
0F61A:  DATA C0,F5
0F61C:  DATA C8,F5
0F61E:  DATA D0,F5
*
0FE3C:  MOVF   FEF,F
0FE3E:  BZ    FE60
0FE40:  MOVFF  FEA,8EC
0FE44:  MOVFF  FE9,8EB
0FE48:  MOVFF  FEF,8FF
0FE4C:  CALL   509E
0FE50:  MOVFF  8EC,FEA
0FE54:  MOVFF  8EB,FE9
0FE58:  INCF   FE9,F
0FE5A:  BTFSC  FD8.2
0FE5C:  INCF   FEA,F
0FE5E:  BRA    FE3C
0FE60:  RETURN 0
0FE62:  MOVFF  FEA,FE2
0FE66:  MOVFF  FE9,FE1
0FE6A:  CLRF   01
0FE6C:  BSF    00.0
0FE6E:  TBLRD*+
0FE70:  MOVF   FF5,W
0FE72:  BTFSS  00.0
0FE74:  BRA    FE80
0FE76:  SUBWF  FEE,W
0FE78:  BNZ   FE80
0FE7A:  MOVF   FF5,F
0FE7C:  BNZ   FE6E
0FE7E:  BRA    FE9A
0FE80:  BCF    00.0
0FE82:  MOVF   FF5,F
0FE84:  BNZ   FE6E
0FE86:  INCF   01,F
0FE88:  BSF    00.0
0FE8A:  MOVFF  FE2,FEA
0FE8E:  MOVFF  FE1,FE9
0FE92:  TBLRD*
0FE94:  MOVF   FF5,F
0FE96:  BNZ   FE6E
0FE98:  SETF   01
0FE9A:  RETURN 0
*
10778:  MOVFF  914,91B
1077C:  MOVLB  9
1077E:  MOVF   x18,W
10780:  XORWF  x1B,F
10782:  BTFSS  x1B.7
10784:  BRA    10790
10786:  BCF    FD8.2
10788:  BCF    FD8.0
1078A:  BTFSC  x14.7
1078C:  BSF    FD8.0
1078E:  BRA    107EE
10790:  MOVFF  914,91B
10794:  MOVFF  917,91C
10798:  MOVF   x13,W
1079A:  SUBWF  x1C,F
1079C:  BZ    107AA
1079E:  BTFSS  x1B.7
107A0:  BRA    107EE
107A2:  MOVF   FD8,W
107A4:  XORLW  01
107A6:  MOVWF  FD8
107A8:  BRA    107EE
107AA:  MOVFF  918,91C
107AE:  MOVF   x14,W
107B0:  SUBWF  x1C,F
107B2:  BZ    107C0
107B4:  BTFSS  x1B.7
107B6:  BRA    107EE
107B8:  MOVF   FD8,W
107BA:  XORLW  01
107BC:  MOVWF  FD8
107BE:  BRA    107EE
107C0:  MOVFF  919,91C
107C4:  MOVF   x15,W
107C6:  SUBWF  x1C,F
107C8:  BZ    107D6
107CA:  BTFSS  x1B.7
107CC:  BRA    107EE
107CE:  MOVF   FD8,W
107D0:  XORLW  01
107D2:  MOVWF  FD8
107D4:  BRA    107EE
107D6:  MOVFF  91A,91C
107DA:  MOVF   x16,W
107DC:  SUBWF  x1C,F
107DE:  BZ    107EC
107E0:  BTFSS  x1B.7
107E2:  BRA    107EE
107E4:  MOVF   FD8,W
107E6:  XORLW  01
107E8:  MOVWF  FD8
107EA:  BRA    107EE
107EC:  BCF    FD8.0
107EE:  MOVLB  0
107F0:  RETURN 0
107F2:  MOVLW  8E
107F4:  MOVWF  00
107F6:  MOVFF  8ED,01
107FA:  MOVFF  8EC,02
107FE:  CLRF   03
10800:  BTFSS  01.7
10802:  BRA    1080E
10804:  COMF   01,F
10806:  COMF   02,F
10808:  INCF   02,F
1080A:  BNZ   1080E
1080C:  INCF   01,F
1080E:  MOVF   01,F
10810:  BNZ   10824
10812:  MOVFF  02,01
10816:  CLRF   02
10818:  MOVLW  08
1081A:  SUBWF  00,F
1081C:  MOVF   01,F
1081E:  BNZ   10824
10820:  CLRF   00
10822:  BRA    10840
10824:  BCF    FD8.0
10826:  BTFSC  01.7
10828:  BRA    10832
1082A:  RLCF   02,F
1082C:  RLCF   01,F
1082E:  DECF   00,F
10830:  BRA    10824
10832:  MOVLB  8
10834:  BTFSS  xED.7
10836:  BRA    1083C
10838:  MOVLB  0
1083A:  BRA    10840
1083C:  BCF    01.7
1083E:  MOVLB  0
10840:  RETURN 0
*
10C42:  MOVF   FE9,W
10C44:  MOVLB  8
10C46:  MOVWF  xD4
10C48:  MOVF   xD3,W
10C4A:  MOVWF  xD6
10C4C:  BZ    10C88
10C4E:  MOVFF  8D2,916
10C52:  MOVFF  8D1,915
10C56:  MOVFF  8D0,914
10C5A:  MOVFF  8CF,913
10C5E:  MOVLB  9
10C60:  CLRF   x1A
10C62:  CLRF   x19
10C64:  MOVLW  20
10C66:  MOVWF  x18
10C68:  MOVLW  82
10C6A:  MOVWF  x17
10C6C:  MOVLB  0
10C6E:  CALL   C2C4
10C72:  MOVFF  03,8D2
10C76:  MOVFF  02,8D1
10C7A:  MOVFF  01,8D0
10C7E:  MOVFF  00,8CF
10C82:  MOVLB  8
10C84:  DECFSZ xD6,F
10C86:  BRA    10C4E
10C88:  MOVLW  7E
10C8A:  MOVWF  00
10C8C:  CLRF   01
10C8E:  BTFSC  xD0.7
10C90:  BSF    01.7
10C92:  CLRF   02
10C94:  CLRF   03
10C96:  BCF    FD8.1
10C98:  MOVFF  8D2,91A
10C9C:  MOVFF  8D1,919
10CA0:  MOVFF  8D0,918
10CA4:  MOVFF  8CF,917
10CA8:  MOVFF  03,91E
10CAC:  MOVFF  02,91D
10CB0:  MOVFF  01,91C
10CB4:  MOVFF  FE8,91B
10CB8:  MOVLB  0
10CBA:  CALL   C3BA
10CBE:  MOVFF  03,8D2
10CC2:  MOVFF  02,8D1
10CC6:  MOVFF  01,8D0
10CCA:  MOVFF  00,8CF
10CCE:  MOVFF  8D2,8DF
10CD2:  MOVFF  8D1,8DE
10CD6:  MOVFF  8D0,8DD
10CDA:  MOVFF  8CF,8DC
10CDE:  CALL   C632
10CE2:  MOVFF  03,8D2
10CE6:  MOVFF  02,8D1
10CEA:  MOVFF  01,8D0
10CEE:  MOVFF  00,8CF
10CF2:  MOVLB  8
10CF4:  BTFSS  xD2.7
10CF6:  BRA    10D12
10CF8:  DECF   xD4,F
10CFA:  BSF    xD4.5
10CFC:  COMF   xCF,F
10CFE:  COMF   xD0,F
10D00:  COMF   xD1,F
10D02:  COMF   xD2,F
10D04:  INCF   xCF,F
10D06:  BTFSC  FD8.2
10D08:  INCF   xD0,F
10D0A:  BTFSC  FD8.2
10D0C:  INCF   xD1,F
10D0E:  BTFSC  FD8.2
10D10:  INCF   xD2,F
10D12:  MOVLW  3B
10D14:  MOVWF  xDB
10D16:  MOVLW  9A
10D18:  MOVWF  xDA
10D1A:  MOVLW  CA
10D1C:  MOVWF  xD9
10D1E:  CLRF   xD8
10D20:  MOVLW  0A
10D22:  MOVWF  xD6
10D24:  MOVF   xD3,W
10D26:  BTFSC  FD8.2
10D28:  INCF   xD4,F
10D2A:  BSF    FD8.1
10D2C:  MOVLW  08
10D2E:  MOVWF  FEA
10D30:  MOVLW  CF
10D32:  MOVWF  FE9
10D34:  CLRF   1B
10D36:  BTFSC  FF2.7
10D38:  BSF    1B.7
10D3A:  BCF    FF2.7
10D3C:  MOVFF  8D2,A4F
10D40:  MOVFF  8D1,A4E
10D44:  MOVFF  8D0,A4D
10D48:  MOVFF  8CF,A4C
10D4C:  MOVFF  8DB,A53
10D50:  MOVFF  8DA,A52
10D54:  MOVFF  8D9,A51
10D58:  MOVFF  8D8,A50
10D5C:  MOVLB  0
10D5E:  CALL   104E
10D62:  BTFSC  1B.7
10D64:  BSF    FF2.7
10D66:  MOVF   01,W
10D68:  MOVF   00,F
10D6A:  BNZ   10D92
10D6C:  MOVLB  8
10D6E:  INCF   xD3,W
10D70:  SUBWF  xD6,W
10D72:  BTFSS  FD8.2
10D74:  BRA    10D7A
10D76:  MOVLB  0
10D78:  BRA    10D92
10D7A:  MOVF   xD4,W
10D7C:  BZ    10D98
10D7E:  ANDLW  0F
10D80:  SUBWF  xD6,W
10D82:  BZ    10D86
10D84:  BC    10E0E
10D86:  BTFSC  xD4.7
10D88:  BRA    10E0E
10D8A:  BTFSC  xD4.6
10D8C:  BRA    10D98
10D8E:  MOVLW  20
10D90:  BRA    10E00
10D92:  MOVLW  20
10D94:  MOVLB  8
10D96:  ANDWF  xD4,F
10D98:  BTFSS  xD4.5
10D9A:  BRA    10DBA
10D9C:  BCF    xD4.5
10D9E:  MOVF   xD3,W
10DA0:  BTFSS  FD8.2
10DA2:  DECF   xD4,F
10DA4:  MOVF   00,W
10DA6:  MOVWF  xD4
10DA8:  MOVLW  2D
10DAA:  MOVWF  xFF
10DAC:  MOVLB  0
10DAE:  CALL   509E
10DB2:  MOVLB  8
10DB4:  MOVF   xD4,W
10DB6:  MOVWF  00
10DB8:  CLRF   xD4
10DBA:  MOVF   xD3,W
10DBC:  SUBWF  xD6,W
10DBE:  BNZ   10DDA
10DC0:  MOVF   00,W
10DC2:  MOVWF  xD4
10DC4:  MOVLW  2E
10DC6:  MOVWF  xFF
10DC8:  MOVLB  0
10DCA:  CALL   509E
10DCE:  MOVLB  8
10DD0:  MOVF   xD4,W
10DD2:  MOVWF  00
10DD4:  MOVLW  20
10DD6:  ANDWF  xD4,F
10DD8:  MOVLW  00
10DDA:  MOVLW  30
10DDC:  BTFSS  xD4.5
10DDE:  BRA    10E00
10DE0:  BCF    xD4.5
10DE2:  MOVF   xD3,W
10DE4:  BTFSS  FD8.2
10DE6:  DECF   xD4,F
10DE8:  MOVF   00,W
10DEA:  MOVWF  xD4
10DEC:  MOVLW  2D
10DEE:  MOVWF  xFF
10DF0:  MOVLB  0
10DF2:  CALL   509E
10DF6:  MOVLB  8
10DF8:  MOVF   xD4,W
10DFA:  MOVWF  00
10DFC:  CLRF   xD4
10DFE:  MOVLW  30
10E00:  ADDWF  00,F
10E02:  MOVFF  00,8FF
10E06:  MOVLB  0
10E08:  CALL   509E
10E0C:  MOVLB  8
10E0E:  BCF    FD8.1
10E10:  CLRF   1B
10E12:  BTFSC  FF2.7
10E14:  BSF    1B.7
10E16:  BCF    FF2.7
10E18:  MOVFF  8DB,A4F
10E1C:  MOVFF  8DA,A4E
10E20:  MOVFF  8D9,A4D
10E24:  MOVFF  8D8,A4C
10E28:  MOVLB  A
10E2A:  CLRF   x53
10E2C:  CLRF   x52
10E2E:  CLRF   x51
10E30:  MOVLW  0A
10E32:  MOVWF  x50
10E34:  MOVLB  0
10E36:  CALL   104E
10E3A:  BTFSC  1B.7
10E3C:  BSF    FF2.7
10E3E:  MOVFF  03,8DB
10E42:  MOVFF  02,8DA
10E46:  MOVFF  01,8D9
10E4A:  MOVFF  00,8D8
10E4E:  MOVLB  8
10E50:  DECFSZ xD6,F
10E52:  BRA    10D2A
10E54:  MOVLB  0
10E56:  RETURN 0
*
1275A:  ADDWF  FE8,W
1275C:  CLRF   FF7
1275E:  RLCF   FF7,F
12760:  ADDLW  7B
12762:  MOVWF  FF6
12764:  MOVLW  27
12766:  ADDWFC FF7,F
12768:  MOVLW  01
1276A:  MOVWF  FF8
1276C:  MOVWF  FFB
1276E:  TBLRD*-
12770:  MOVF   FF5,W
12772:  MOVWF  FFA
12774:  TBLRD*
12776:  MOVF   FF5,W
12778:  MOVWF  FF9
1277A:  DATA 1E,27
1277C:  DATA 26,27
1277E:  DATA 2C,27
12780:  DATA 32,27
*
12812:  MOVLW  8E
12814:  MOVWF  00
12816:  MOVLB  9
12818:  MOVF   x13,W
1281A:  SUBWF  00,F
1281C:  MOVFF  914,02
12820:  MOVFF  915,01
12824:  BSF    02.7
12826:  MOVF   00,F
12828:  BZ    1283C
1282A:  BCF    FD8.0
1282C:  MOVF   02,F
1282E:  BNZ   12834
12830:  MOVF   01,F
12832:  BZ    1283C
12834:  RRCF   02,F
12836:  RRCF   01,F
12838:  DECFSZ 00,F
1283A:  BRA    1282A
1283C:  BTFSS  x14.7
1283E:  BRA    1284A
12840:  COMF   01,F
12842:  COMF   02,F
12844:  INCF   01,F
12846:  BTFSC  FD8.2
12848:  INCF   02,F
1284A:  MOVLB  0
1284C:  RETURN 0
*
1330A:  ADDWF  FE8,W
1330C:  CLRF   FF7
1330E:  RLCF   FF7,F
13310:  ADDLW  2B
13312:  MOVWF  FF6
13314:  MOVLW  33
13316:  ADDWFC FF7,F
13318:  MOVLW  01
1331A:  MOVWF  FF8
1331C:  MOVWF  FFB
1331E:  TBLRD*-
13320:  MOVF   FF5,W
13322:  MOVWF  FFA
13324:  TBLRD*
13326:  MOVF   FF5,W
13328:  MOVWF  FF9
1332A:  DATA 46,31
1332C:  DATA 4C,31
1332E:  DATA 6A,31
13330:  DATA 88,31
*
133A2:  MOVLB  8
133A4:  MOVF   xDD,W
133A6:  XORWF  xDF,W
133A8:  ANDLW  80
133AA:  MOVWF  xE1
133AC:  BTFSS  xDD.7
133AE:  BRA    133BA
133B0:  COMF   xDC,F
133B2:  COMF   xDD,F
133B4:  INCF   xDC,F
133B6:  BTFSC  FD8.2
133B8:  INCF   xDD,F
133BA:  BTFSS  xDF.7
133BC:  BRA    133C8
133BE:  COMF   xDE,F
133C0:  COMF   xDF,F
133C2:  INCF   xDE,F
133C4:  BTFSC  FD8.2
133C6:  INCF   xDF,F
133C8:  MOVF   xDC,W
133CA:  MULWF  xDE
133CC:  MOVFF  FF3,01
133D0:  MOVFF  FF4,00
133D4:  MULWF  xDF
133D6:  MOVF   FF3,W
133D8:  ADDWF  00,F
133DA:  MOVF   xDD,W
133DC:  MULWF  xDE
133DE:  MOVF   FF3,W
133E0:  ADDWFC 00,W
133E2:  MOVWF  02
133E4:  BTFSS  xE1.7
133E6:  BRA    133F2
133E8:  COMF   01,F
133EA:  COMF   02,F
133EC:  INCF   01,F
133EE:  BTFSC  FD8.2
133F0:  INCF   02,F
133F2:  MOVLB  0
133F4:  GOTO   134D2 (RETURN)
*
14290:  ADDWF  FE8,W
14292:  CLRF   FF7
14294:  RLCF   FF7,F
14296:  ADDLW  B1
14298:  MOVWF  FF6
1429A:  MOVLW  42
1429C:  ADDWFC FF7,F
1429E:  MOVLW  01
142A0:  MOVWF  FF8
142A2:  MOVWF  FFB
142A4:  TBLRD*-
142A6:  MOVF   FF5,W
142A8:  MOVWF  FFA
142AA:  TBLRD*
142AC:  MOVF   FF5,W
142AE:  MOVWF  FF9
142B0:  DATA 46,41
142B2:  DATA 84,42
142B4:  DATA 72,41
142B6:  DATA 84,42
142B8:  DATA 3C,40
142BA:  DATA 84,42
142BC:  DATA 84,42
142BE:  DATA 84,42
142C0:  DATA 84,42
142C2:  DATA 84,42
142C4:  DATA 84,42
142C6:  DATA 84,42
142C8:  DATA 84,42
142CA:  DATA 84,42
142CC:  DATA 84,42
142CE:  DATA 84,42
142D0:  DATA 7C,42
142D2:  DATA 84,42
142D4:  DATA 84,42
142D6:  DATA 84,42
142D8:  DATA 84,42
142DA:  DATA 84,42
142DC:  DATA DC,3F
142DE:  DATA 84,42
142E0:  DATA 10,40
142E2:  DATA 18,40
142E4:  DATA 84,42
142E6:  DATA 2C,40
142E8:  DATA 9E,41
142EA:  DATA 60,40
142EC:  DATA 84,42
142EE:  DATA 84,42
142F0:  DATA F2,40
142F2:  DATA D4,40
142F4:  DATA 84,42
142F6:  DATA 84,42
142F8:  DATA 84,42
142FA:  DATA B8,41
142FC:  DATA E4,41
142FE:  DATA 10,42
14300:  DATA 0E,41
14302:  DATA 3C,41
14304:  DATA 84,42
14306:  DATA 84,42
14308:  DATA 84,42
1430A:  DATA 84,42
1430C:  DATA 3C,42
1430E:  DATA 84,42
14310:  DATA 84,42
14312:  DATA 84,42
14314:  DATA 84,42
14316:  DATA 84,42
14318:  DATA 84,42
1431A:  DATA 84,42
1431C:  DATA 84,42
1431E:  DATA 84,42
14320:  DATA 84,42
14322:  DATA 48,40
14324:  DATA 84,42
14326:  DATA 84,42
14328:  DATA 84,42
1432A:  DATA 84,42
1432C:  DATA 78,40
1432E:  DATA 84,42
14330:  DATA 84,42
14332:  DATA 9E,40
14334:  DATA 84,42
14336:  DATA 84,42
14338:  DATA 84,42
1433A:  DATA EC,3F
1433C:  DATA 84,42
1433E:  DATA 84,42
14340:  DATA 84,42
14342:  DATA 84,42
14344:  DATA 84,42
14346:  DATA 66,42
*
143FC:  MOVFF  FEA,8C0
14400:  MOVFF  FE9,8BF
14404:  MOVLB  8
14406:  SWAPF  xB9,W
14408:  IORLW  F0
1440A:  MOVWF  xBB
1440C:  ADDWF  xBB,F
1440E:  ADDLW  E2
14410:  MOVWF  xBC
14412:  ADDLW  32
14414:  MOVWF  xBE
14416:  MOVF   xB9,W
14418:  ANDLW  0F
1441A:  ADDWF  xBC,F
1441C:  ADDWF  xBC,F
1441E:  ADDWF  xBE,F
14420:  ADDLW  E9
14422:  MOVWF  xBD
14424:  ADDWF  xBD,F
14426:  ADDWF  xBD,F
14428:  SWAPF  xB8,W
1442A:  ANDLW  0F
1442C:  ADDWF  xBD,F
1442E:  ADDWF  xBE,F
14430:  RLCF   xBD,F
14432:  RLCF   xBE,F
14434:  COMF   xBE,F
14436:  RLCF   xBE,F
14438:  MOVF   xB8,W
1443A:  ANDLW  0F
1443C:  ADDWF  xBE,F
1443E:  RLCF   xBB,F
14440:  MOVLW  07
14442:  MOVWF  xBA
14444:  MOVLW  0A
14446:  DECF   xBD,F
14448:  ADDWF  xBE,F
1444A:  BNC   14446
1444C:  DECF   xBC,F
1444E:  ADDWF  xBD,F
14450:  BNC   1444C
14452:  DECF   xBB,F
14454:  ADDWF  xBC,F
14456:  BNC   14452
14458:  DECF   xBA,F
1445A:  ADDWF  xBB,F
1445C:  BNC   14458
1445E:  MOVLW  08
14460:  MOVWF  FEA
14462:  MOVLW  BA
14464:  MOVWF  FE9
14466:  MOVLW  07
14468:  ANDWF  xBF,W
1446A:  BCF    xBF.6
1446C:  ADDWF  FE9,F
1446E:  MOVLW  00
14470:  ADDWFC FEA,F
14472:  MOVF   FE9,W
14474:  SUBLW  BE
14476:  BNZ   14480
14478:  MOVF   FEA,W
1447A:  SUBLW  08
1447C:  BNZ   14480
1447E:  BSF    xBF.6
14480:  MOVF   FEF,W
14482:  MOVWF  00
14484:  BNZ   14496
14486:  BTFSC  xBF.6
14488:  BRA    14496
1448A:  BTFSC  xBF.4
1448C:  BRA    144AA
1448E:  BTFSC  xBF.3
14490:  BRA    14496
14492:  MOVLW  20
14494:  BRA    1449C
14496:  BSF    xBF.3
14498:  BCF    xBF.4
1449A:  MOVLW  30
1449C:  ADDWF  00,F
1449E:  MOVF   00,W
144A0:  BTFSS  FA4.4
144A2:  BRA    144A0
144A4:  MOVLB  F
144A6:  MOVWF  x1C
144A8:  MOVLB  8
144AA:  MOVF   FEE,W
144AC:  BTFSS  xBF.6
144AE:  BRA    14472
144B0:  MOVLB  0
144B2:  GOTO   1454E (RETURN)
*
14992:  ADDWF  FE8,W
14994:  CLRF   FF7
14996:  RLCF   FF7,F
14998:  ADDLW  B3
1499A:  MOVWF  FF6
1499C:  MOVLW  49
1499E:  ADDWFC FF7,F
149A0:  MOVLW  01
149A2:  MOVWF  FF8
149A4:  MOVWF  FFB
149A6:  TBLRD*-
149A8:  MOVF   FF5,W
149AA:  MOVWF  FFA
149AC:  TBLRD*
149AE:  MOVF   FF5,W
149B0:  MOVWF  FF9
149B2:  DATA 7E,45
149B4:  DATA DE,45
149B6:  DATA FA,45
149B8:  DATA 16,46
149BA:  DATA 32,46
149BC:  DATA 4E,46
149BE:  DATA 6A,46
149C0:  DATA 86,46
149C2:  DATA A2,46
149C4:  DATA BE,46
149C6:  DATA DA,46
149C8:  DATA F6,46
149CA:  DATA 12,47
149CC:  DATA 2E,47
149CE:  DATA 4A,47
149D0:  DATA 66,47
149D2:  DATA 82,47
149D4:  DATA 9E,47
149D6:  DATA BA,47
149D8:  DATA D6,47
149DA:  DATA F2,47
149DC:  DATA 0E,48
149DE:  DATA 2A,48
149E0:  DATA 46,48
149E2:  DATA 62,48
149E4:  DATA 7E,48
149E6:  DATA 9A,48
149E8:  DATA B6,48
149EA:  DATA D2,48
149EC:  DATA EE,48
149EE:  DATA 0A,49
149F0:  DATA 26,49
149F2:  DATA 42,49
*
151E0:  ADDWF  FE8,W
151E2:  CLRF   FF7
151E4:  RLCF   FF7,F
151E6:  ADDLW  01
151E8:  MOVWF  FF6
151EA:  MOVLW  52
151EC:  ADDWFC FF7,F
151EE:  MOVLW  01
151F0:  MOVWF  FF8
151F2:  MOVWF  FFB
151F4:  TBLRD*-
151F6:  MOVF   FF5,W
151F8:  MOVWF  FFA
151FA:  TBLRD*
151FC:  MOVF   FF5,W
151FE:  MOVWF  FF9
15200:  DATA D4,4D
15202:  DATA 14,4F
15204:  DATA 00,4E
15206:  DATA 14,4F
15208:  DATA C6,4C
1520A:  DATA 14,4F
1520C:  DATA 14,4F
1520E:  DATA 14,4F
15210:  DATA 14,4F
15212:  DATA 14,4F
15214:  DATA 14,4F
15216:  DATA 14,4F
15218:  DATA 14,4F
1521A:  DATA 14,4F
1521C:  DATA 14,4F
1521E:  DATA 14,4F
15220:  DATA 0C,4F
15222:  DATA 14,4F
15224:  DATA 14,4F
15226:  DATA 14,4F
15228:  DATA 14,4F
1522A:  DATA 14,4F
1522C:  DATA D0,4A
1522E:  DATA 14,4F
15230:  DATA 04,4B
15232:  DATA A2,4C
15234:  DATA 14,4F
15236:  DATA B6,4C
15238:  DATA 2C,4E
1523A:  DATA EA,4C
1523C:  DATA 14,4F
1523E:  DATA 14,4F
15240:  DATA 7C,4D
15242:  DATA 5E,4D
15244:  DATA 14,4F
15246:  DATA 14,4F
15248:  DATA 14,4F
1524A:  DATA 46,4E
1524C:  DATA 72,4E
1524E:  DATA 9E,4E
15250:  DATA 98,4D
15252:  DATA C8,4D
15254:  DATA 14,4F
15256:  DATA 14,4F
15258:  DATA 14,4F
1525A:  DATA 14,4F
1525C:  DATA CA,4E
1525E:  DATA 14,4F
15260:  DATA 14,4F
15262:  DATA 14,4F
15264:  DATA 14,4F
15266:  DATA 14,4F
15268:  DATA 14,4F
1526A:  DATA 14,4F
1526C:  DATA 14,4F
1526E:  DATA 14,4F
15270:  DATA 14,4F
15272:  DATA D2,4C
15274:  DATA 14,4F
15276:  DATA 14,4F
15278:  DATA 14,4F
1527A:  DATA 14,4F
1527C:  DATA 02,4D
1527E:  DATA 14,4F
15280:  DATA 14,4F
15282:  DATA 28,4D
15284:  DATA 14,4F
15286:  DATA 14,4F
15288:  DATA 14,4F
1528A:  DATA E0,4A
1528C:  DATA 14,4F
1528E:  DATA 0C,4B
15290:  DATA 14,4F
15292:  DATA 14,4F
15294:  DATA 14,4F
15296:  DATA F4,4E
*
156FA:  ADDWF  FE8,W
156FC:  CLRF   FF7
156FE:  RLCF   FF7,F
15700:  ADDLW  1B
15702:  MOVWF  FF6
15704:  MOVLW  57
15706:  ADDWFC FF7,F
15708:  MOVLW  01
1570A:  MOVWF  FF8
1570C:  MOVWF  FFB
1570E:  TBLRD*-
15710:  MOVF   FF5,W
15712:  MOVWF  FFA
15714:  TBLRD*
15716:  MOVF   FF5,W
15718:  MOVWF  FF9
1571A:  DATA 6C,55
1571C:  DATA 8C,55
1571E:  DATA AC,55
15720:  DATA CC,55
15722:  DATA EC,55
15724:  DATA 0C,56
15726:  DATA 2C,56
*
1B22E:  ADDWF  FE8,W
1B230:  CLRF   FF7
1B232:  RLCF   FF7,F
1B234:  ADDLW  4F
1B236:  MOVWF  FF6
1B238:  MOVLW  B2
1B23A:  ADDWFC FF7,F
1B23C:  MOVLW  01
1B23E:  MOVWF  FF8
1B240:  MOVWF  FFB
1B242:  TBLRD*-
1B244:  MOVF   FF5,W
1B246:  MOVWF  FFA
1B248:  TBLRD*
1B24A:  MOVF   FF5,W
1B24C:  MOVWF  FF9
1B24E:  DATA A8,B0
1B250:  DATA 2A,B2
1B252:  DATA AE,B0
1B254:  DATA A2,B0
1B256:  DATA 2A,B2
1B258:  DATA 2A,B2
1B25A:  DATA 2A,B2
1B25C:  DATA B4,B0
1B25E:  DATA 68,B1
1B260:  DATA 2A,B2
1B262:  DATA 84,B1
1B264:  DATA 2A,B2
1B266:  DATA BA,B0
1B268:  DATA 2A,B2
1B26A:  DATA 2A,B2
1B26C:  DATA 2A,B2
1B26E:  DATA 2A,B2
1B270:  DATA 2A,B2
1B272:  DATA 2A,B2
1B274:  DATA 2A,B2
1B276:  DATA 2A,B2
1B278:  DATA 2A,B2
1B27A:  DATA 2A,B2
1B27C:  DATA 2A,B2
1B27E:  DATA 2A,B2
1B280:  DATA 2A,B2
1B282:  DATA 2A,B2
1B284:  DATA 2A,B2
1B286:  DATA 2A,B2
1B288:  DATA 2A,B2
1B28A:  DATA C0,B0
1B28C:  DATA C6,B0
1B28E:  DATA CC,B0
1B290:  DATA D2,B0
1B292:  DATA D8,B0
1B294:  DATA DE,B0
1B296:  DATA E4,B0
1B298:  DATA EA,B0
1B29A:  DATA F0,B0
1B29C:  DATA F6,B0
1B29E:  DATA FC,B0
1B2A0:  DATA 02,B1
1B2A2:  DATA 08,B1
1B2A4:  DATA 14,B1
1B2A6:  DATA 1A,B1
1B2A8:  DATA 20,B1
1B2AA:  DATA 26,B1
1B2AC:  DATA 2C,B1
1B2AE:  DATA 32,B1
1B2B0:  DATA 38,B1
1B2B2:  DATA 3E,B1
1B2B4:  DATA 44,B1
1B2B6:  DATA 4A,B1
1B2B8:  DATA 50,B1
1B2BA:  DATA 56,B1
1B2BC:  DATA 5C,B1
1B2BE:  DATA 2A,B2
1B2C0:  DATA 2A,B2
1B2C2:  DATA 2A,B2
1B2C4:  DATA 62,B1
1B2C6:  DATA 2A,B2
1B2C8:  DATA 2A,B2
1B2CA:  DATA A0,B1
1B2CC:  DATA A6,B1
1B2CE:  DATA AC,B1
1B2D0:  DATA B2,B1
1B2D2:  DATA B8,B1
1B2D4:  DATA BE,B1
1B2D6:  DATA C4,B1
1B2D8:  DATA CA,B1
1B2DA:  DATA D0,B1
1B2DC:  DATA D6,B1
1B2DE:  DATA DC,B1
1B2E0:  DATA E2,B1
1B2E2:  DATA E8,B1
1B2E4:  DATA EE,B1
1B2E6:  DATA F4,B1
1B2E8:  DATA FA,B1
1B2EA:  DATA 00,B2
1B2EC:  DATA 06,B2
1B2EE:  DATA 0A,B2
1B2F0:  DATA 0E,B2
1B2F2:  DATA 12,B2
1B2F4:  DATA 16,B2
1B2F6:  DATA 1C,B2
1B2F8:  DATA 20,B2
1B2FA:  DATA 24,B2
1B2FC:  DATA 28,B2
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8F4
1F8BA:  MOVFF  FF7,8F5
1F8BE:  MOVFF  FF8,8F6
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8F4,FF6
1F8CE:  MOVFF  8F5,FF7
1F8D2:  MOVFF  8F6,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8F5
1F8E0:  MOVFF  FF7,8F6
1F8E4:  MOVFF  FF8,8F7
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8F5,FF6
1F8F4:  MOVFF  8F6,FF7
1F8F8:  MOVFF  8F7,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xF4,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xF5.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xF4,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xF5,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xF4,F
1F936:  MOVLW  0A
1F938:  SUBWF  xF4,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xF5.7
1F942:  MOVF   xF5,W
1F944:  ADDWF  xF4,F
1F946:  MOVF   xF4,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xF7,W
1F956:  CLRF   01
1F958:  SUBWF  xF6,W
1F95A:  BC    1F962
1F95C:  MOVFF  8F6,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xF8
1F968:  RLCF   xF6,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xF7,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xF8,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8F4,8F6
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xF7
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8F4
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xF5.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xF5.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xF5.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xF5.3
1F9AC:  BCF    xF5.4
1F9AE:  BSF    xF5.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8F4,8F6
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xF7
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8F4
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xF5.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xF5.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xF5.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xF4,F
1F9F0:  MOVF   xF4,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8F4,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8F5,01
1FA60:  MOVFF  8F4,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... #FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... #FUSES WDT_SW   
.................... //#use delay(clock=2000000) 
....................  
.................... #FUSES NOWDT 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
02910:  MOVLW  09
02912:  MOVWF  FEA
02914:  MOVLW  EC
02916:  MOVWF  FE9
02918:  MOVF   FEF,W
0291A:  BZ    2938
0291C:  MOVLW  14
0291E:  MOVWF  01
02920:  CLRF   00
02922:  DECFSZ 00,F
02924:  BRA    2922
02926:  DECFSZ 01,F
02928:  BRA    2920
0292A:  MOVLW  BF
0292C:  MOVWF  00
0292E:  DECFSZ 00,F
02930:  BRA    292E
02932:  BRA    2934
02934:  DECFSZ FEF,F
02936:  BRA    291C
02938:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E30:  BTFSS  F9E.5
00E32:  BRA    0E30
00E34:  MOVFF  FAB,1C
00E38:  MOVFF  FAE,01
00E3C:  BTFSS  1C.1
00E3E:  BRA    0E44
00E40:  BCF    FAB.4
00E42:  BSF    FAB.4
00E44:  RETURN 0
*
0AEB8:  BTFSS  F9E.4
0AEBA:  BRA    AEB8
0AEBC:  MOVWF  FAD
0AEBE:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12E38:  BTFSS  FA4.5
12E3A:  BRA    12E38
12E3C:  MOVLB  F
12E3E:  MOVFF  F22,1C
12E42:  MOVFF  F1D,01
12E46:  BTFSS  1C.1
12E48:  BRA    12E4E
12E4A:  BCF    x22.4
12E4C:  BSF    x22.4
12E4E:  MOVLB  0
12E50:  RETURN 0
*
16F66:  BTFSS  FA4.4
16F68:  BRA    16F66
16F6A:  MOVLB  F
16F6C:  MOVWF  x1C
16F6E:  MOVLB  0
16F70:  GOTO   1700A (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xFA
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xFB
1F850:  MOVF   xFB,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8F9,03
1F85A:  MOVFF  8F8,FE9
1F85E:  MOVFF  8F9,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xFA,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8FC
1F870:  MOVFF  8F8,FE9
1F874:  MOVFF  8F9,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xFC,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xFA
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xFA,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8FC
1F88C:  MOVFF  8F8,FE9
1F890:  MOVFF  8F9,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xFC,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xFA
....................       }  
1F89C:  MOVF   xFB,W
1F89E:  INCF   xFB,F
1F8A0:  INCF   xF8,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xF9,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8FA,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xF8,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8F5,03
1FA84:  MOVFF  8F4,FE9
1FA88:  MOVFF  8F5,FEA
1FA8C:  MOVFF  FEF,8F9
1FA90:  MOVFF  8F7,03
1FA94:  MOVFF  8F6,FE9
1FA98:  MOVFF  8F7,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xF9,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8F5,03
1FAA6:  MOVFF  8F4,FE9
1FAAA:  MOVFF  8F5,FEA
1FAAE:  MOVFF  FEF,8F9
1FAB2:  MOVFF  8F7,03
1FAB6:  MOVFF  8F6,FE9
1FABA:  MOVFF  8F7,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xF9,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8F5,03
1FAD4:  MOVFF  8F4,FE9
1FAD8:  MOVFF  8F5,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8F5,03
1FAEA:  MOVF   xF4,W
1FAEC:  INCF   xF4,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xF5,F
1FAF2:  MOVFF  8F7,03
1FAF6:  MOVF   xF6,W
1FAF8:  INCF   xF6,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xF7,F
1FAFE:  DECF   xF8,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x85.1
1FB0E:  CLRF   x8F
1FB10:  CLRF   x8E
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xEC
1FB2A:  MOVLB  0
1FB2C:  CALL   2910
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x85.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x8B
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x8B,W
1FB3C:  ADDLW  B4
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x8B,W
1FB50:  INCF   x8B,F
1FB52:  CLRF   03
1FB54:  ADDLW  B4
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x8B,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x85.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   xB4,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xF9
1FB80:  MOVLW  B5
1FB82:  MOVWF  xF8
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,88A
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xF9
1FB92:  MOVLW  B7
1FB94:  MOVWF  xF8
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8F4
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xF9
1FBA4:  MOVLW  B9
1FBA6:  MOVWF  xF8
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8F4,88D
1FBB0:  MOVFF  01,88C
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xF9
1FBBA:  MOVLW  BB
1FBBC:  MOVWF  xF8
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,887
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  88E,892
1FBCA:  MOVFF  88F,893
1FBCE:  MOVFF  88C,890
1FBD2:  MOVFF  88D,891
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x87,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x85.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x85.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x93,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x92,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x91,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x93,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x92,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x93,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x92,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x86
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x89
1FC26:  MOVLW  03
1FC28:  SUBWF  x8B,W
1FC2A:  SUBWF  x89,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x89,W
1FC32:  ADDLW  B4
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8F4
1FC3E:  MOVFF  03,8F5
1FC42:  MOVFF  03,8F9
1FC46:  MOVFF  01,8F8
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x86,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x89,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x86,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x86
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x8B,W
1FC68:  CLRF   03
1FC6A:  ADDLW  B4
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8F4
1FC76:  MOVFF  03,8F5
1FC7A:  MOVFF  03,8F9
1FC7E:  MOVFF  01,8F8
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x86,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x85.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x87,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x89
1FCAE:  CLRF   x88
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x8B,W
1FCB4:  SUBWF  x89,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x88,W
1FCBA:  INCF   x88,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  94
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8F4
1FCCA:  MOVFF  03,8F5
1FCCE:  CLRF   03
1FCD0:  MOVF   x89,W
1FCD2:  ADDLW  B4
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8F6
1FCDE:  MOVFF  03,8F7
1FCE2:  MOVFF  03,8F9
1FCE6:  MOVFF  01,8F8
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8F5,FEA
1FCF2:  MOVFF  8F4,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x89,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xF4
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  893,8F4
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xF5
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  892,8F4
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xF5
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  891,8F4
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xF5
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  890,8F4
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xF5
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  88A,8F4
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xF5
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  892,FF8
1FD80:  MOVFF  891,FF7
1FD84:  MOVFF  890,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  94
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  88A,8F4
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  892,FF8
1FD9A:  MOVFF  891,FF7
1FD9E:  MOVFF  890,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  B4
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xF5
1FDAE:  MOVFF  88A,8F4
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xF5
1FDBC:  MOVLW  94
1FDBE:  MOVWF  xF4
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xF7
1FDC4:  MOVLW  B4
1FDC6:  MOVWF  xF6
1FDC8:  MOVFF  88A,8F8
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x85.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x87,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xF9
1FE02:  MOVLW  BD
1FE04:  MOVWF  xF8
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8F4
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xF9
1FE14:  MOVLW  BF
1FE16:  MOVWF  xF8
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8F4,88F
1FE20:  MOVFF  01,88E
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xF4
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  88E,8F4
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xF5
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x85.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x85.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xF4
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xEC
1FE8E:  MOVLB  0
1FE90:  CALL   2910
1FE94:  MOVLB  8
1FE96:  DECFSZ xF4,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... int16 valve_align_timeout = -1; 
.................... int16 valve_align_counter = -1; 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
05554:  BCF    FF2.5
....................    restart_wdt(); 
05556:  CLRWDT
05558:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
0555A:  CLRF   FCF
0555C:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
0555E:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
05560:  MOVF   2F,W
05562:  SUBLW  02
05564:  BNZ   556C
05566:  MOVF   30,F
05568:  BNZ   556C
0556A:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
0556C:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
0556E:  BSF    F9D.0
05570:  GOTO   5584 (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
05574:  MOVLW  0B
05576:  MOVWF  FD7
05578:  MOVLW  DC
0557A:  MOVWF  FD6
....................    restart_wdt(); 
0557C:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
0557E:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
05580:  BSF    FF2.5
....................    setup_led_pulse(); 
05582:  BRA    555A
05584:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
05586:  MOVLB  8
05588:  MOVF   xED,W
0558A:  XORLW  00
0558C:  MOVLB  0
0558E:  BZ    5596
05590:  XORLW  01
05592:  BZ    559A
05594:  BRA    559C
....................       case 0 : suspend_heartbeat(); 
05596:  RCALL  5554
....................          break; 
05598:  BRA    559C
....................       case 1 : restart_heartbeat(); 
0559A:  RCALL  5574
....................          break; 
....................    } 
0559C:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
030F6:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
030F8:  BCF    FD1.0
030FA:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
02900:  MOVLW  0B
02902:  MOVWF  FD7
02904:  MOVLW  DC
02906:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
02908:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
0290A:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
0290C:  BSF    FD1.0
0290E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
07908:  MOVFF  9B1,9B7
0790C:  MOVFF  9B0,9B6
07910:  MOVLB  9
07912:  MOVF   xB4,F
07914:  BNZ   791A
07916:  MOVF   xB5,F
07918:  BZ    7964
0791A:  MOVFF  9B3,03
0791E:  MOVFF  9B2,FE9
07922:  MOVFF  9B3,FEA
07926:  MOVF   FEF,F
07928:  BZ    7964
....................      *s++ = *s2++; 
0792A:  MOVFF  9B7,9B9
0792E:  MOVF   xB6,W
07930:  INCF   xB6,F
07932:  BTFSC  FD8.2
07934:  INCF   xB7,F
07936:  MOVWF  xB8
07938:  MOVFF  9B3,03
0793C:  MOVF   xB2,W
0793E:  INCF   xB2,F
07940:  BTFSC  FD8.2
07942:  INCF   xB3,F
07944:  MOVWF  FE9
07946:  MOVFF  03,FEA
0794A:  MOVFF  FEF,9BA
0794E:  MOVFF  9B9,FEA
07952:  MOVFF  9B8,FE9
07956:  MOVFF  9BA,FEF
0795A:  MOVF   xB4,W
0795C:  BTFSC  FD8.2
0795E:  DECF   xB5,F
07960:  DECF   xB4,F
07962:  BRA    7912
....................   for (; n > 0; n--) 
07964:  MOVF   xB4,F
07966:  BNZ   796C
07968:  MOVF   xB5,F
0796A:  BZ    798A
....................      *s++ = '\0'; 
0796C:  MOVFF  9B7,03
07970:  MOVF   xB6,W
07972:  INCF   xB6,F
07974:  BTFSC  FD8.2
07976:  INCF   xB7,F
07978:  MOVWF  FE9
0797A:  MOVFF  03,FEA
0797E:  CLRF   FEF
07980:  MOVF   xB4,W
07982:  BTFSC  FD8.2
07984:  DECF   xB5,F
07986:  DECF   xB4,F
07988:  BRA    7964
....................  
....................   return(s1); 
0798A:  MOVFF  9B0,01
0798E:  MOVFF  9B1,02
07992:  MOVLB  0
07994:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
054DE:  MOVFF  8F9,8FD
054E2:  MOVFF  8F8,8FC
054E6:  MOVFF  8FD,03
054EA:  MOVLB  8
054EC:  MOVFF  8FC,FE9
054F0:  MOVFF  8FD,FEA
054F4:  MOVF   FEF,F
054F6:  BZ    5504
054F8:  INCF   xFC,F
054FA:  BTFSC  FD8.2
054FC:  INCF   xFD,F
054FE:  MOVLB  0
05500:  BRA    54E6
05502:  MOVLB  8
....................    while(*s2 != '\0') 
05504:  MOVFF  8FB,03
05508:  MOVFF  8FA,FE9
0550C:  MOVFF  8FB,FEA
05510:  MOVF   FEF,F
05512:  BZ    553E
....................    { 
....................       *s = *s2; 
05514:  MOVFF  8FA,FE9
05518:  MOVFF  8FB,FEA
0551C:  MOVFF  FEF,900
05520:  MOVLB  9
05522:  MOVFF  8FD,FEA
05526:  MOVFF  8FC,FE9
0552A:  MOVFF  900,FEF
....................       ++s; 
0552E:  MOVLB  8
05530:  INCF   xFC,F
05532:  BTFSC  FD8.2
05534:  INCF   xFD,F
....................       ++s2; 
05536:  INCF   xFA,F
05538:  BTFSC  FD8.2
0553A:  INCF   xFB,F
0553C:  BRA    5504
....................    } 
....................  
....................    *s = '\0'; 
0553E:  MOVFF  8FC,FE9
05542:  MOVFF  8FD,FEA
05546:  CLRF   FEF
....................    return(s1); 
05548:  MOVFF  8F8,01
0554C:  MOVFF  8F9,02
05550:  MOVLB  0
05552:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12DB4:  MOVFF  8EE,8F4
12DB8:  MOVFF  8ED,8F3
12DBC:  MOVFF  8F4,03
12DC0:  MOVLB  8
12DC2:  MOVFF  8F3,FE9
12DC6:  MOVFF  8F4,FEA
12DCA:  MOVF   FEF,F
12DCC:  BZ    12DDA
12DCE:  INCF   xF3,F
12DD0:  BTFSC  FD8.2
12DD2:  INCF   xF4,F
12DD4:  MOVLB  0
12DD6:  BRA    12DBC
12DD8:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12DDA:  MOVFF  8F0,03
12DDE:  MOVFF  8EF,FE9
12DE2:  MOVFF  8F0,FEA
12DE6:  MOVF   FEF,F
12DE8:  BZ    12E22
12DEA:  MOVF   xF2,F
12DEC:  BNZ   12DF4
12DEE:  MOVF   xF1,W
12DF0:  SUBLW  00
12DF2:  BC    12E22
....................    { 
....................       *s = *s2; 
12DF4:  MOVFF  8EF,FE9
12DF8:  MOVFF  8F0,FEA
12DFC:  MOVFF  FEF,8F7
12E00:  MOVFF  8F4,FEA
12E04:  MOVFF  8F3,FE9
12E08:  MOVFF  8F7,FEF
....................       ++s; 
12E0C:  INCF   xF3,F
12E0E:  BTFSC  FD8.2
12E10:  INCF   xF4,F
....................       ++s2; 
12E12:  INCF   xEF,F
12E14:  BTFSC  FD8.2
12E16:  INCF   xF0,F
....................       --n; 
12E18:  MOVF   xF1,W
12E1A:  BTFSC  FD8.2
12E1C:  DECF   xF2,F
12E1E:  DECF   xF1,F
12E20:  BRA    12DDA
....................    } 
....................  
....................    *s = '\0'; 
12E22:  MOVFF  8F3,FE9
12E26:  MOVFF  8F4,FEA
12E2A:  CLRF   FEF
....................    return(s1); 
12E2C:  MOVFF  8ED,01
12E30:  MOVFF  8EE,02
12E34:  MOVLB  0
12E36:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
0460C:  MOVFF  9EA,9F0
04610:  MOVFF  9E9,9EF
04614:  MOVFF  9EC,9F2
04618:  MOVFF  9EB,9F1
0461C:  MOVLB  9
0461E:  MOVF   xEE,F
04620:  BNZ   4628
04622:  MOVF   xED,W
04624:  SUBLW  00
04626:  BC    4688
.................... { 
....................    if(*su1!=*su2) 
04628:  MOVFF  9EF,FE9
0462C:  MOVFF  9F0,FEA
04630:  MOVFF  FEF,9F3
04634:  MOVFF  9F2,03
04638:  MOVFF  9F1,FE9
0463C:  MOVFF  9F2,FEA
04640:  MOVF   FEF,W
04642:  SUBWF  xF3,W
04644:  BZ    4672
....................       return ((*su1<*su2)?-1:1); 
04646:  MOVFF  9F0,03
0464A:  MOVFF  9EF,FE9
0464E:  MOVFF  03,FEA
04652:  MOVFF  FEF,9F3
04656:  MOVFF  9F2,03
0465A:  MOVFF  9F1,FE9
0465E:  MOVFF  9F2,FEA
04662:  MOVF   FEF,W
04664:  SUBWF  xF3,W
04666:  BC    466C
04668:  MOVLW  FF
0466A:  BRA    466E
0466C:  MOVLW  01
0466E:  MOVWF  01
04670:  BRA    468C
04672:  INCF   xEF,F
04674:  BTFSC  FD8.2
04676:  INCF   xF0,F
04678:  INCF   xF1,F
0467A:  BTFSC  FD8.2
0467C:  INCF   xF2,F
0467E:  MOVF   xED,W
04680:  BTFSC  FD8.2
04682:  DECF   xEE,F
04684:  DECF   xED,F
04686:  BRA    461E
.................... } 
.................... return 0; 
04688:  MOVLW  00
0468A:  MOVWF  01
0468C:  MOVLB  0
0468E:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12D78:  MOVFF  8EC,8EE
12D7C:  MOVFF  8EB,8ED
12D80:  MOVFF  8EE,03
12D84:  MOVLB  8
12D86:  MOVFF  8ED,FE9
12D8A:  MOVFF  8EE,FEA
12D8E:  MOVF   FEF,F
12D90:  BZ    12D9E
12D92:  INCF   xED,F
12D94:  BTFSC  FD8.2
12D96:  INCF   xEE,F
12D98:  MOVLB  0
12D9A:  BRA    12D80
12D9C:  MOVLB  8
....................    return(sc - s); 
12D9E:  MOVF   xEB,W
12DA0:  SUBWF  xED,W
12DA2:  MOVWF  00
12DA4:  MOVF   xEC,W
12DA6:  SUBWFB xEE,W
12DA8:  MOVWF  03
12DAA:  MOVFF  00,01
12DAE:  MOVWF  02
12DB0:  MOVLB  0
12DB2:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
133F8:  MOVLB  8
133FA:  CLRF   xDA
....................    sign = 0; 
133FC:  CLRF   xD8
....................    base = 10; 
133FE:  MOVLW  0A
13400:  MOVWF  xD9
....................    result = 0; 
13402:  CLRF   xD7
13404:  CLRF   xD6
....................  
....................    if (!s) 
13406:  MOVF   xD4,W
13408:  IORWF  xD5,W
1340A:  BNZ   13414
....................       return 0; 
1340C:  MOVLW  00
1340E:  MOVWF  01
13410:  MOVWF  02
13412:  BRA    135D8
....................    c = s[index++]; 
13414:  MOVF   xDA,W
13416:  INCF   xDA,F
13418:  ADDWF  xD4,W
1341A:  MOVWF  FE9
1341C:  MOVLW  00
1341E:  ADDWFC xD5,W
13420:  MOVWF  FEA
13422:  MOVFF  FEF,8DB
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
13426:  MOVF   xDB,W
13428:  SUBLW  2D
1342A:  BNZ   13444
....................    { 
....................       sign = 1;         // Set the sign to negative 
1342C:  MOVLW  01
1342E:  MOVWF  xD8
....................       c = s[index++]; 
13430:  MOVF   xDA,W
13432:  INCF   xDA,F
13434:  ADDWF  xD4,W
13436:  MOVWF  FE9
13438:  MOVLW  00
1343A:  ADDWFC xD5,W
1343C:  MOVWF  FEA
1343E:  MOVFF  FEF,8DB
....................    } 
13442:  BRA    1345C
....................    else if (c == '+') 
13444:  MOVF   xDB,W
13446:  SUBLW  2B
13448:  BNZ   1345C
....................    { 
....................       c = s[index++]; 
1344A:  MOVF   xDA,W
1344C:  INCF   xDA,F
1344E:  ADDWF  xD4,W
13450:  MOVWF  FE9
13452:  MOVLW  00
13454:  ADDWFC xD5,W
13456:  MOVWF  FEA
13458:  MOVFF  FEF,8DB
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1345C:  MOVF   xDB,W
1345E:  SUBLW  2F
13460:  BTFSC  FD8.0
13462:  BRA    135BC
13464:  MOVF   xDB,W
13466:  SUBLW  39
13468:  BTFSS  FD8.0
1346A:  BRA    135BC
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1346C:  MOVF   xDB,W
1346E:  SUBLW  30
13470:  BNZ   134AE
13472:  MOVF   xDA,W
13474:  ADDWF  xD4,W
13476:  MOVWF  FE9
13478:  MOVLW  00
1347A:  ADDWFC xD5,W
1347C:  MOVWF  FEA
1347E:  MOVF   FEF,W
13480:  SUBLW  78
13482:  BZ    13496
13484:  MOVF   xDA,W
13486:  ADDWF  xD4,W
13488:  MOVWF  FE9
1348A:  MOVLW  00
1348C:  ADDWFC xD5,W
1348E:  MOVWF  FEA
13490:  MOVF   FEF,W
13492:  SUBLW  58
13494:  BNZ   134AE
....................       { 
....................          base = 16; 
13496:  MOVLW  10
13498:  MOVWF  xD9
....................          index++; 
1349A:  INCF   xDA,F
....................          c = s[index++]; 
1349C:  MOVF   xDA,W
1349E:  INCF   xDA,F
134A0:  ADDWF  xD4,W
134A2:  MOVWF  FE9
134A4:  MOVLW  00
134A6:  ADDWFC xD5,W
134A8:  MOVWF  FEA
134AA:  MOVFF  FEF,8DB
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
134AE:  MOVF   xD9,W
134B0:  SUBLW  0A
134B2:  BNZ   134F8
....................       { 
....................          while (c >= '0' && c <= '9') 
134B4:  MOVF   xDB,W
134B6:  SUBLW  2F
134B8:  BC    134F6
134BA:  MOVF   xDB,W
134BC:  SUBLW  39
134BE:  BNC   134F6
....................          { 
....................             result = 10*result + (c - '0'); 
134C0:  CLRF   xDD
134C2:  MOVLW  0A
134C4:  MOVWF  xDC
134C6:  MOVFF  8D7,8DF
134CA:  MOVFF  8D6,8DE
134CE:  MOVLB  0
134D0:  BRA    133A2
134D2:  MOVLW  30
134D4:  MOVLB  8
134D6:  SUBWF  xDB,W
134D8:  ADDWF  01,W
134DA:  MOVWF  xD6
134DC:  MOVLW  00
134DE:  ADDWFC 02,W
134E0:  MOVWF  xD7
....................             c = s[index++]; 
134E2:  MOVF   xDA,W
134E4:  INCF   xDA,F
134E6:  ADDWF  xD4,W
134E8:  MOVWF  FE9
134EA:  MOVLW  00
134EC:  ADDWFC xD5,W
134EE:  MOVWF  FEA
134F0:  MOVFF  FEF,8DB
134F4:  BRA    134B4
....................          } 
....................       } 
134F6:  BRA    135BC
....................       else if (base == 16)    // The number is a hexa number 
134F8:  MOVF   xD9,W
134FA:  SUBLW  10
134FC:  BNZ   135BC
....................       { 
....................          c = toupper(c); 
134FE:  MOVF   xDB,W
13500:  SUBLW  60
13502:  BC    13510
13504:  MOVF   xDB,W
13506:  SUBLW  7A
13508:  BNC   13510
1350A:  MOVF   xDB,W
1350C:  ANDLW  DF
1350E:  BRA    13512
13510:  MOVF   xDB,W
13512:  MOVWF  xDB
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
13514:  MOVF   xDB,W
13516:  SUBLW  2F
13518:  BC    13520
1351A:  MOVF   xDB,W
1351C:  SUBLW  39
1351E:  BC    1352C
13520:  MOVF   xDB,W
13522:  SUBLW  40
13524:  BC    135BC
13526:  MOVF   xDB,W
13528:  SUBLW  46
1352A:  BNC   135BC
....................          { 
....................             if (c >= '0' && c <= '9') 
1352C:  MOVF   xDB,W
1352E:  SUBLW  2F
13530:  BC    13566
13532:  MOVF   xDB,W
13534:  SUBLW  39
13536:  BNC   13566
....................                result = (result << 4) + (c - '0'); 
13538:  RLCF   xD6,W
1353A:  MOVWF  xDC
1353C:  RLCF   xD7,W
1353E:  MOVWF  xDD
13540:  RLCF   xDC,F
13542:  RLCF   xDD,F
13544:  RLCF   xDC,F
13546:  RLCF   xDD,F
13548:  RLCF   xDC,F
1354A:  RLCF   xDD,F
1354C:  MOVLW  F0
1354E:  ANDWF  xDC,F
13550:  MOVLW  30
13552:  SUBWF  xDB,W
13554:  ADDWF  xDC,W
13556:  MOVWF  01
13558:  MOVLW  00
1355A:  ADDWFC xDD,W
1355C:  MOVWF  03
1355E:  MOVFF  01,8D6
13562:  MOVWF  xD7
13564:  BRA    13592
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
13566:  RLCF   xD6,W
13568:  MOVWF  xDC
1356A:  RLCF   xD7,W
1356C:  MOVWF  xDD
1356E:  RLCF   xDC,F
13570:  RLCF   xDD,F
13572:  RLCF   xDC,F
13574:  RLCF   xDD,F
13576:  RLCF   xDC,F
13578:  RLCF   xDD,F
1357A:  MOVLW  F0
1357C:  ANDWF  xDC,F
1357E:  MOVLW  41
13580:  SUBWF  xDB,W
13582:  ADDLW  0A
13584:  ADDWF  xDC,W
13586:  MOVWF  01
13588:  MOVLW  00
1358A:  ADDWFC xDD,W
1358C:  MOVFF  01,8D6
13590:  MOVWF  xD7
....................  
....................             c = s[index++];c = toupper(c); 
13592:  MOVF   xDA,W
13594:  INCF   xDA,F
13596:  ADDWF  xD4,W
13598:  MOVWF  FE9
1359A:  MOVLW  00
1359C:  ADDWFC xD5,W
1359E:  MOVWF  FEA
135A0:  MOVFF  FEF,8DB
135A4:  MOVF   xDB,W
135A6:  SUBLW  60
135A8:  BC    135B6
135AA:  MOVF   xDB,W
135AC:  SUBLW  7A
135AE:  BNC   135B6
135B0:  MOVF   xDB,W
135B2:  ANDLW  DF
135B4:  BRA    135B8
135B6:  MOVF   xDB,W
135B8:  MOVWF  xDB
135BA:  BRA    13514
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
135BC:  MOVF   xD9,W
135BE:  SUBLW  0A
135C0:  BNZ   135D0
135C2:  DECFSZ xD8,W
135C4:  BRA    135D0
....................       result = -result; 
135C6:  COMF   xD6,F
135C8:  COMF   xD7,F
135CA:  INCF   xD6,F
135CC:  BTFSC  FD8.2
135CE:  INCF   xD7,F
....................  
....................    return(result); 
135D0:  MOVFF  8D6,01
135D4:  MOVFF  8D7,02
135D8:  MOVLB  0
135DA:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0AF02:  MOVLB  8
0AF04:  CLRF   x8D
....................    sign = 0; 
0AF06:  CLRF   x8B
....................    base = 10; 
0AF08:  MOVLW  0A
0AF0A:  MOVWF  x8C
....................    result = 0; 
0AF0C:  CLRF   x8A
0AF0E:  CLRF   x89
0AF10:  CLRF   x88
0AF12:  CLRF   x87
....................  
....................    if (!s) 
0AF14:  MOVF   x85,W
0AF16:  IORWF  x86,W
0AF18:  BNZ   AF24
....................       return 0; 
0AF1A:  CLRF   00
0AF1C:  CLRF   01
0AF1E:  CLRF   02
0AF20:  CLRF   03
0AF22:  BRA    B192
....................    c = s[index++]; 
0AF24:  MOVF   x8D,W
0AF26:  INCF   x8D,F
0AF28:  ADDWF  x85,W
0AF2A:  MOVWF  FE9
0AF2C:  MOVLW  00
0AF2E:  ADDWFC x86,W
0AF30:  MOVWF  FEA
0AF32:  MOVFF  FEF,88E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0AF36:  MOVF   x8E,W
0AF38:  SUBLW  2D
0AF3A:  BNZ   AF54
....................    { 
....................       sign = 1;         // Set the sign to negative 
0AF3C:  MOVLW  01
0AF3E:  MOVWF  x8B
....................       c = s[index++]; 
0AF40:  MOVF   x8D,W
0AF42:  INCF   x8D,F
0AF44:  ADDWF  x85,W
0AF46:  MOVWF  FE9
0AF48:  MOVLW  00
0AF4A:  ADDWFC x86,W
0AF4C:  MOVWF  FEA
0AF4E:  MOVFF  FEF,88E
....................    } 
0AF52:  BRA    AF6C
....................    else if (c == '+') 
0AF54:  MOVF   x8E,W
0AF56:  SUBLW  2B
0AF58:  BNZ   AF6C
....................    { 
....................       c = s[index++]; 
0AF5A:  MOVF   x8D,W
0AF5C:  INCF   x8D,F
0AF5E:  ADDWF  x85,W
0AF60:  MOVWF  FE9
0AF62:  MOVLW  00
0AF64:  ADDWFC x86,W
0AF66:  MOVWF  FEA
0AF68:  MOVFF  FEF,88E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0AF6C:  MOVF   x8E,W
0AF6E:  SUBLW  2F
0AF70:  BTFSC  FD8.0
0AF72:  BRA    B162
0AF74:  MOVF   x8E,W
0AF76:  SUBLW  39
0AF78:  BTFSS  FD8.0
0AF7A:  BRA    B162
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0AF7C:  MOVF   x8E,W
0AF7E:  SUBLW  30
0AF80:  BNZ   AFBE
0AF82:  MOVF   x8D,W
0AF84:  ADDWF  x85,W
0AF86:  MOVWF  FE9
0AF88:  MOVLW  00
0AF8A:  ADDWFC x86,W
0AF8C:  MOVWF  FEA
0AF8E:  MOVF   FEF,W
0AF90:  SUBLW  78
0AF92:  BZ    AFA6
0AF94:  MOVF   x8D,W
0AF96:  ADDWF  x85,W
0AF98:  MOVWF  FE9
0AF9A:  MOVLW  00
0AF9C:  ADDWFC x86,W
0AF9E:  MOVWF  FEA
0AFA0:  MOVF   FEF,W
0AFA2:  SUBLW  58
0AFA4:  BNZ   AFBE
....................       { 
....................          base = 16; 
0AFA6:  MOVLW  10
0AFA8:  MOVWF  x8C
....................          index++; 
0AFAA:  INCF   x8D,F
....................          c = s[index++]; 
0AFAC:  MOVF   x8D,W
0AFAE:  INCF   x8D,F
0AFB0:  ADDWF  x85,W
0AFB2:  MOVWF  FE9
0AFB4:  MOVLW  00
0AFB6:  ADDWFC x86,W
0AFB8:  MOVWF  FEA
0AFBA:  MOVFF  FEF,88E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0AFBE:  MOVF   x8C,W
0AFC0:  SUBLW  0A
0AFC2:  BNZ   B04A
....................       { 
....................          while (c >= '0' && c <= '9') { 
0AFC4:  MOVF   x8E,W
0AFC6:  SUBLW  2F
0AFC8:  BC    B048
0AFCA:  MOVF   x8E,W
0AFCC:  SUBLW  39
0AFCE:  BNC   B048
....................             result = (result << 1) + (result << 3);  // result *= 10; 
0AFD0:  BCF    FD8.0
0AFD2:  RLCF   x87,W
0AFD4:  MOVWF  x90
0AFD6:  RLCF   x88,W
0AFD8:  MOVWF  x91
0AFDA:  RLCF   x89,W
0AFDC:  MOVWF  x92
0AFDE:  RLCF   x8A,W
0AFE0:  MOVWF  x93
0AFE2:  RLCF   x87,W
0AFE4:  MOVWF  00
0AFE6:  RLCF   x88,W
0AFE8:  MOVWF  01
0AFEA:  RLCF   x89,W
0AFEC:  MOVWF  02
0AFEE:  RLCF   x8A,W
0AFF0:  MOVWF  03
0AFF2:  RLCF   00,F
0AFF4:  RLCF   01,F
0AFF6:  RLCF   02,F
0AFF8:  RLCF   03,F
0AFFA:  RLCF   00,F
0AFFC:  RLCF   01,F
0AFFE:  RLCF   02,F
0B000:  RLCF   03,F
0B002:  MOVLW  F8
0B004:  ANDWF  00,F
0B006:  MOVF   x90,W
0B008:  ADDWF  00,F
0B00A:  MOVF   x91,W
0B00C:  ADDWFC 01,F
0B00E:  MOVF   x92,W
0B010:  ADDWFC 02,F
0B012:  MOVF   x93,W
0B014:  ADDWFC 03,F
0B016:  MOVFF  03,88A
0B01A:  MOVFF  02,889
0B01E:  MOVFF  01,888
0B022:  MOVFF  00,887
....................             result += (c - '0'); 
0B026:  MOVLW  30
0B028:  SUBWF  x8E,W
0B02A:  ADDWF  x87,F
0B02C:  MOVLW  00
0B02E:  ADDWFC x88,F
0B030:  ADDWFC x89,F
0B032:  ADDWFC x8A,F
....................             c = s[index++]; 
0B034:  MOVF   x8D,W
0B036:  INCF   x8D,F
0B038:  ADDWF  x85,W
0B03A:  MOVWF  FE9
0B03C:  MOVLW  00
0B03E:  ADDWFC x86,W
0B040:  MOVWF  FEA
0B042:  MOVFF  FEF,88E
0B046:  BRA    AFC4
....................          } 
....................       } 
0B048:  BRA    B162
....................       else if (base == 16)    // The number is a hexa number 
0B04A:  MOVF   x8C,W
0B04C:  SUBLW  10
0B04E:  BTFSS  FD8.2
0B050:  BRA    B162
....................       { 
....................          c = toupper(c); 
0B052:  MOVF   x8E,W
0B054:  SUBLW  60
0B056:  BC    B064
0B058:  MOVF   x8E,W
0B05A:  SUBLW  7A
0B05C:  BNC   B064
0B05E:  MOVF   x8E,W
0B060:  ANDLW  DF
0B062:  BRA    B066
0B064:  MOVF   x8E,W
0B066:  MOVWF  x8E
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0B068:  MOVF   x8E,W
0B06A:  SUBLW  2F
0B06C:  BC    B074
0B06E:  MOVF   x8E,W
0B070:  SUBLW  39
0B072:  BC    B082
0B074:  MOVF   x8E,W
0B076:  SUBLW  40
0B078:  BTFSC  FD8.0
0B07A:  BRA    B162
0B07C:  MOVF   x8E,W
0B07E:  SUBLW  46
0B080:  BNC   B162
....................          { 
....................             if (c >= '0' && c <= '9') 
0B082:  MOVF   x8E,W
0B084:  SUBLW  2F
0B086:  BC    B0E4
0B088:  MOVF   x8E,W
0B08A:  SUBLW  39
0B08C:  BNC   B0E4
....................                result = (result << 4) + (c - '0'); 
0B08E:  RLCF   x87,W
0B090:  MOVWF  x90
0B092:  RLCF   x88,W
0B094:  MOVWF  x91
0B096:  RLCF   x89,W
0B098:  MOVWF  x92
0B09A:  RLCF   x8A,W
0B09C:  MOVWF  x93
0B09E:  RLCF   x90,F
0B0A0:  RLCF   x91,F
0B0A2:  RLCF   x92,F
0B0A4:  RLCF   x93,F
0B0A6:  RLCF   x90,F
0B0A8:  RLCF   x91,F
0B0AA:  RLCF   x92,F
0B0AC:  RLCF   x93,F
0B0AE:  RLCF   x90,F
0B0B0:  RLCF   x91,F
0B0B2:  RLCF   x92,F
0B0B4:  RLCF   x93,F
0B0B6:  MOVLW  F0
0B0B8:  ANDWF  x90,F
0B0BA:  MOVLW  30
0B0BC:  SUBWF  x8E,W
0B0BE:  ADDWF  x90,W
0B0C0:  MOVWF  00
0B0C2:  MOVLW  00
0B0C4:  ADDWFC x91,W
0B0C6:  MOVWF  01
0B0C8:  MOVLW  00
0B0CA:  ADDWFC x92,W
0B0CC:  MOVWF  02
0B0CE:  MOVLW  00
0B0D0:  ADDWFC x93,W
0B0D2:  MOVWF  03
0B0D4:  MOVWF  x8A
0B0D6:  MOVFF  02,889
0B0DA:  MOVFF  01,888
0B0DE:  MOVFF  00,887
0B0E2:  BRA    B138
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B0E4:  RLCF   x87,W
0B0E6:  MOVWF  x90
0B0E8:  RLCF   x88,W
0B0EA:  MOVWF  x91
0B0EC:  RLCF   x89,W
0B0EE:  MOVWF  x92
0B0F0:  RLCF   x8A,W
0B0F2:  MOVWF  x93
0B0F4:  RLCF   x90,F
0B0F6:  RLCF   x91,F
0B0F8:  RLCF   x92,F
0B0FA:  RLCF   x93,F
0B0FC:  RLCF   x90,F
0B0FE:  RLCF   x91,F
0B100:  RLCF   x92,F
0B102:  RLCF   x93,F
0B104:  RLCF   x90,F
0B106:  RLCF   x91,F
0B108:  RLCF   x92,F
0B10A:  RLCF   x93,F
0B10C:  MOVLW  F0
0B10E:  ANDWF  x90,F
0B110:  MOVLW  41
0B112:  SUBWF  x8E,W
0B114:  ADDLW  0A
0B116:  ADDWF  x90,W
0B118:  MOVWF  00
0B11A:  MOVLW  00
0B11C:  ADDWFC x91,W
0B11E:  MOVWF  01
0B120:  MOVLW  00
0B122:  ADDWFC x92,W
0B124:  MOVWF  02
0B126:  MOVLW  00
0B128:  ADDWFC x93,W
0B12A:  MOVWF  x8A
0B12C:  MOVFF  02,889
0B130:  MOVFF  01,888
0B134:  MOVFF  00,887
....................  
....................             c = s[index++];c = toupper(c); 
0B138:  MOVF   x8D,W
0B13A:  INCF   x8D,F
0B13C:  ADDWF  x85,W
0B13E:  MOVWF  FE9
0B140:  MOVLW  00
0B142:  ADDWFC x86,W
0B144:  MOVWF  FEA
0B146:  MOVFF  FEF,88E
0B14A:  MOVF   x8E,W
0B14C:  SUBLW  60
0B14E:  BC    B15C
0B150:  MOVF   x8E,W
0B152:  SUBLW  7A
0B154:  BNC   B15C
0B156:  MOVF   x8E,W
0B158:  ANDLW  DF
0B15A:  BRA    B15E
0B15C:  MOVF   x8E,W
0B15E:  MOVWF  x8E
0B160:  BRA    B068
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0B162:  MOVF   x8C,W
0B164:  SUBLW  0A
0B166:  BNZ   B182
0B168:  DECFSZ x8B,W
0B16A:  BRA    B182
....................       result = -result; 
0B16C:  COMF   x87,F
0B16E:  COMF   x88,F
0B170:  COMF   x89,F
0B172:  COMF   x8A,F
0B174:  INCF   x87,F
0B176:  BTFSC  FD8.2
0B178:  INCF   x88,F
0B17A:  BTFSC  FD8.2
0B17C:  INCF   x89,F
0B17E:  BTFSC  FD8.2
0B180:  INCF   x8A,F
....................  
....................    return(result); 
0B182:  MOVFF  887,00
0B186:  MOVFF  888,01
0B18A:  MOVFF  889,02
0B18E:  MOVFF  88A,03
0B192:  MOVLB  0
0B194:  GOTO   1B550 (RETURN)
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0CAAA:  MOVLB  8
0CAAC:  CLRF   xA4
0CAAE:  CLRF   xA3
0CAB0:  CLRF   xA2
0CAB2:  MOVLW  7F
0CAB4:  MOVWF  xA1
0CAB6:  CLRF   xA8
0CAB8:  CLRF   xA7
0CABA:  CLRF   xA6
0CABC:  CLRF   xA5
0CABE:  BSF    xA9.0
0CAC0:  BCF    xA9.1
0CAC2:  BCF    xA9.2
0CAC4:  CLRF   xAB
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0CAC6:  MOVF   x9D,W
0CAC8:  IORWF  x9E,W
0CACA:  BNZ   CAD6
....................       return 0; 
0CACC:  CLRF   00
0CACE:  CLRF   01
0CAD0:  CLRF   02
0CAD2:  CLRF   03
0CAD4:  BRA    CD00
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0CAD6:  MOVF   xAB,W
0CAD8:  INCF   xAB,F
0CADA:  ADDWF  x9D,W
0CADC:  MOVWF  FE9
0CADE:  MOVLW  00
0CAE0:  ADDWFC x9E,W
0CAE2:  MOVWF  FEA
0CAE4:  MOVFF  FEF,8AA
0CAE8:  MOVF   xAA,F
0CAEA:  BTFSC  FD8.2
0CAEC:  BRA    CC82
....................    { 
....................       if (skip && !isspace(c)) 
0CAEE:  BTFSS  xA9.0
0CAF0:  BRA    CB10
0CAF2:  MOVF   xAA,W
0CAF4:  SUBLW  20
0CAF6:  BZ    CB10
....................       { 
....................          skip = 0; 
0CAF8:  BCF    xA9.0
....................          if (c == '+') 
0CAFA:  MOVF   xAA,W
0CAFC:  SUBLW  2B
0CAFE:  BNZ   CB06
....................          { 
....................             sign = 0; 
0CB00:  BCF    xA9.1
....................             continue; 
0CB02:  BRA    CC6A
....................          }             
0CB04:  BRA    CB10
....................          else if (c == '-') 
0CB06:  MOVF   xAA,W
0CB08:  SUBLW  2D
0CB0A:  BNZ   CB10
....................          { 
....................             sign = 1; 
0CB0C:  BSF    xA9.1
....................             continue; 
0CB0E:  BRA    CC6A
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0CB10:  BTFSC  xA9.0
0CB12:  BRA    CB22
0CB14:  MOVF   xAA,W
0CB16:  SUBLW  2E
0CB18:  BNZ   CB22
0CB1A:  BTFSC  xA9.2
0CB1C:  BRA    CB22
....................          point = 1; 
0CB1E:  BSF    xA9.2
0CB20:  BRA    CC6A
....................       else if (!skip && isdigit(c)) 
0CB22:  BTFSC  xA9.0
0CB24:  BRA    CC64
0CB26:  MOVF   xAA,W
0CB28:  SUBLW  2F
0CB2A:  BTFSC  FD8.0
0CB2C:  BRA    CC64
0CB2E:  MOVF   xAA,W
0CB30:  SUBLW  39
0CB32:  BTFSS  FD8.0
0CB34:  BRA    CC64
....................       { 
....................          c -= '0'; 
0CB36:  MOVLW  30
0CB38:  SUBWF  xAA,F
....................          if (point) 
0CB3A:  BTFSS  xA9.2
0CB3C:  BRA    CBEA
....................          { 
....................             pow10 = pow10 * 10.0; 
0CB3E:  MOVFF  8A4,916
0CB42:  MOVFF  8A3,915
0CB46:  MOVFF  8A2,914
0CB4A:  MOVFF  8A1,913
0CB4E:  MOVLB  9
0CB50:  CLRF   x1A
0CB52:  CLRF   x19
0CB54:  MOVLW  20
0CB56:  MOVWF  x18
0CB58:  MOVLW  82
0CB5A:  MOVWF  x17
0CB5C:  MOVLB  0
0CB5E:  CALL   C2C4
0CB62:  MOVFF  03,8A4
0CB66:  MOVFF  02,8A3
0CB6A:  MOVFF  01,8A2
0CB6E:  MOVFF  00,8A1
....................             result += (float)c / pow10;    
0CB72:  MOVLB  9
0CB74:  CLRF   x18
0CB76:  MOVFF  8AA,917
0CB7A:  MOVLB  0
0CB7C:  RCALL  C8F6
0CB7E:  MOVFF  03,8AF
0CB82:  MOVFF  02,8AE
0CB86:  MOVFF  01,8AD
0CB8A:  MOVFF  00,8AC
0CB8E:  MOVFF  03,8FE
0CB92:  MOVFF  02,8FD
0CB96:  MOVFF  01,8FC
0CB9A:  MOVFF  00,8FB
0CB9E:  MOVFF  8A4,902
0CBA2:  MOVFF  8A3,901
0CBA6:  MOVFF  8A2,900
0CBAA:  MOVFF  8A1,8FF
0CBAE:  RCALL  C92C
0CBB0:  BCF    FD8.1
0CBB2:  MOVFF  8A8,91A
0CBB6:  MOVFF  8A7,919
0CBBA:  MOVFF  8A6,918
0CBBE:  MOVFF  8A5,917
0CBC2:  MOVFF  03,91E
0CBC6:  MOVFF  02,91D
0CBCA:  MOVFF  01,91C
0CBCE:  MOVFF  00,91B
0CBD2:  CALL   C3BA
0CBD6:  MOVFF  03,8A8
0CBDA:  MOVFF  02,8A7
0CBDE:  MOVFF  01,8A6
0CBE2:  MOVFF  00,8A5
....................          } 
0CBE6:  BRA    CC60
0CBE8:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0CBEA:  MOVLB  9
0CBEC:  CLRF   x16
0CBEE:  CLRF   x15
0CBF0:  MOVLW  20
0CBF2:  MOVWF  x14
0CBF4:  MOVLW  82
0CBF6:  MOVWF  x13
0CBF8:  MOVFF  8A8,91A
0CBFC:  MOVFF  8A7,919
0CC00:  MOVFF  8A6,918
0CC04:  MOVFF  8A5,917
0CC08:  MOVLB  0
0CC0A:  CALL   C2C4
0CC0E:  MOVFF  03,8AF
0CC12:  MOVFF  02,8AE
0CC16:  MOVFF  01,8AD
0CC1A:  MOVFF  00,8AC
0CC1E:  MOVLB  9
0CC20:  CLRF   x18
0CC22:  MOVFF  8AA,917
0CC26:  MOVLB  0
0CC28:  RCALL  C8F6
0CC2A:  BCF    FD8.1
0CC2C:  MOVFF  8AF,91A
0CC30:  MOVFF  8AE,919
0CC34:  MOVFF  8AD,918
0CC38:  MOVFF  8AC,917
0CC3C:  MOVFF  03,91E
0CC40:  MOVFF  02,91D
0CC44:  MOVFF  01,91C
0CC48:  MOVFF  00,91B
0CC4C:  CALL   C3BA
0CC50:  MOVFF  03,8A8
0CC54:  MOVFF  02,8A7
0CC58:  MOVFF  01,8A6
0CC5C:  MOVFF  00,8A5
....................          } 
....................       } 
0CC60:  BRA    CC6C
0CC62:  MOVLB  8
....................       else if (!skip) 
0CC64:  BTFSC  xA9.0
0CC66:  BRA    CC6A
....................          break; 
0CC68:  BRA    CC82
0CC6A:  MOVLB  0
0CC6C:  MOVLB  8
0CC6E:  MOVF   xAB,W
0CC70:  INCF   xAB,F
0CC72:  ADDWF  x9D,W
0CC74:  MOVWF  FE9
0CC76:  MOVLW  00
0CC78:  ADDWFC x9E,W
0CC7A:  MOVWF  FEA
0CC7C:  MOVFF  FEF,8AA
0CC80:  BRA    CAE8
....................    } 
....................  
....................    if (sign) 
0CC82:  BTFSS  xA9.1
0CC84:  BRA    CCBC
....................       result = -1*result; 
0CC86:  MOVLB  9
0CC88:  CLRF   x16
0CC8A:  CLRF   x15
0CC8C:  MOVLW  80
0CC8E:  MOVWF  x14
0CC90:  MOVLW  7F
0CC92:  MOVWF  x13
0CC94:  MOVFF  8A8,91A
0CC98:  MOVFF  8A7,919
0CC9C:  MOVFF  8A6,918
0CCA0:  MOVFF  8A5,917
0CCA4:  MOVLB  0
0CCA6:  CALL   C2C4
0CCAA:  MOVFF  03,8A8
0CCAE:  MOVFF  02,8A7
0CCB2:  MOVFF  01,8A6
0CCB6:  MOVFF  00,8A5
0CCBA:  MOVLB  8
....................        
....................    if(endptr) 
0CCBC:  MOVF   x9F,W
0CCBE:  IORWF  xA0,W
0CCC0:  BZ    CCF0
....................    { 
....................       if (ptr) { 
0CCC2:  MOVF   xAB,F
0CCC4:  BZ    CCDE
....................          ptr--; 
0CCC6:  DECF   xAB,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0CCC8:  MOVFF  89F,FE9
0CCCC:  MOVFF  8A0,FEA
0CCD0:  MOVF   xAB,W
0CCD2:  ADDWF  x9D,W
0CCD4:  MOVWF  FEF
0CCD6:  MOVLW  00
0CCD8:  ADDWFC x9E,W
0CCDA:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0CCDC:  BRA    CCF0
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0CCDE:  MOVFF  89F,FE9
0CCE2:  MOVFF  8A0,FEA
0CCE6:  MOVFF  89E,FEC
0CCEA:  MOVF   FED,F
0CCEC:  MOVFF  89D,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0CCF0:  MOVFF  8A5,00
0CCF4:  MOVFF  8A6,01
0CCF8:  MOVFF  8A7,02
0CCFC:  MOVFF  8A8,03
0CD00:  MOVLB  0
0CD02:  GOTO   CD2A (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
1284E:  MOVLB  9
12850:  BCF    x12.0
....................    y = x; 
12852:  MOVFF  906,90B
12856:  MOVFF  905,90A
1285A:  MOVFF  904,909
1285E:  MOVFF  903,908
....................  
....................    if (x < 0) 
12862:  MOVFF  906,916
12866:  MOVFF  905,915
1286A:  MOVFF  904,914
1286E:  MOVFF  903,913
12872:  CLRF   x1A
12874:  CLRF   x19
12876:  CLRF   x18
12878:  CLRF   x17
1287A:  MOVLB  0
1287C:  CALL   10778
12880:  BNC   1288E
....................    { 
....................       s = 1; 
12882:  MOVLB  9
12884:  BSF    x12.0
....................       y = -y; 
12886:  MOVF   x09,W
12888:  XORLW  80
1288A:  MOVWF  x09
1288C:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
1288E:  MOVFF  90B,916
12892:  MOVFF  90A,915
12896:  MOVFF  909,914
1289A:  MOVFF  908,913
1289E:  MOVLB  9
128A0:  CLRF   x1A
128A2:  CLRF   x19
128A4:  CLRF   x18
128A6:  MOVLW  8E
128A8:  MOVWF  x17
128AA:  MOVLB  0
128AC:  CALL   10778
128B0:  BC    128B4
128B2:  BNZ   128E4
....................       res = (float32)(unsigned int16)y; 
128B4:  MOVFF  90B,916
128B8:  MOVFF  90A,915
128BC:  MOVFF  909,914
128C0:  MOVFF  908,913
128C4:  RCALL  12812
128C6:  MOVFF  02,918
128CA:  MOVFF  01,917
128CE:  CALL   C8F6
128D2:  MOVFF  03,90F
128D6:  MOVFF  02,90E
128DA:  MOVFF  01,90D
128DE:  MOVFF  00,90C
128E2:  BRA    12A86
....................  
....................  else if (y < 10000000.0) 
128E4:  MOVFF  90B,916
128E8:  MOVFF  90A,915
128EC:  MOVFF  909,914
128F0:  MOVFF  908,913
128F4:  MOVLW  80
128F6:  MOVLB  9
128F8:  MOVWF  x1A
128FA:  MOVLW  96
128FC:  MOVWF  x19
128FE:  MOVLW  18
12900:  MOVWF  x18
12902:  MOVLW  96
12904:  MOVWF  x17
12906:  MOVLB  0
12908:  CALL   10778
1290C:  BTFSS  FD8.0
1290E:  BRA    12A76
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
12910:  MOVFF  90B,916
12914:  MOVFF  90A,915
12918:  MOVFF  909,914
1291C:  MOVFF  908,913
12920:  MOVLB  9
12922:  CLRF   x1A
12924:  CLRF   x19
12926:  CLRF   x18
12928:  MOVLW  70
1292A:  MOVWF  x17
1292C:  MOVLB  0
1292E:  CALL   C2C4
12932:  MOVFF  03,916
12936:  MOVFF  02,915
1293A:  MOVFF  01,914
1293E:  MOVFF  00,913
12942:  RCALL  12812
12944:  MOVFF  02,911
12948:  MOVFF  01,910
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
1294C:  MOVFF  90B,916
12950:  MOVFF  90A,915
12954:  MOVFF  909,914
12958:  MOVFF  908,913
1295C:  MOVLB  9
1295E:  CLRF   x1A
12960:  CLRF   x19
12962:  CLRF   x18
12964:  MOVLW  70
12966:  MOVWF  x17
12968:  MOVLB  0
1296A:  CALL   C2C4
1296E:  MOVFF  03,916
12972:  MOVFF  02,915
12976:  MOVFF  01,914
1297A:  MOVFF  00,913
1297E:  MOVFF  911,918
12982:  MOVFF  910,917
12986:  CALL   C8F6
1298A:  BSF    FD8.1
1298C:  MOVFF  916,91A
12990:  MOVFF  915,919
12994:  MOVFF  914,918
12998:  MOVFF  913,917
1299C:  MOVFF  03,91E
129A0:  MOVFF  02,91D
129A4:  MOVFF  01,91C
129A8:  MOVFF  00,91B
129AC:  CALL   C3BA
129B0:  MOVLB  9
129B2:  CLRF   x16
129B4:  CLRF   x15
129B6:  CLRF   x14
129B8:  MOVLW  8E
129BA:  MOVWF  x13
129BC:  MOVFF  03,91A
129C0:  MOVFF  02,919
129C4:  MOVFF  01,918
129C8:  MOVFF  00,917
129CC:  MOVLB  0
129CE:  CALL   C2C4
129D2:  MOVFF  03,90B
129D6:  MOVFF  02,90A
129DA:  MOVFF  01,909
129DE:  MOVFF  00,908
....................       res = 32768.0*(float32)l; 
129E2:  MOVFF  911,918
129E6:  MOVFF  910,917
129EA:  CALL   C8F6
129EE:  MOVLB  9
129F0:  CLRF   x16
129F2:  CLRF   x15
129F4:  CLRF   x14
129F6:  MOVLW  8E
129F8:  MOVWF  x13
129FA:  MOVFF  03,91A
129FE:  MOVFF  02,919
12A02:  MOVFF  01,918
12A06:  MOVFF  00,917
12A0A:  MOVLB  0
12A0C:  CALL   C2C4
12A10:  MOVFF  03,90F
12A14:  MOVFF  02,90E
12A18:  MOVFF  01,90D
12A1C:  MOVFF  00,90C
....................       res += (float32)(unsigned int16)y; 
12A20:  MOVFF  90B,916
12A24:  MOVFF  90A,915
12A28:  MOVFF  909,914
12A2C:  MOVFF  908,913
12A30:  RCALL  12812
12A32:  MOVFF  02,918
12A36:  MOVFF  01,917
12A3A:  CALL   C8F6
12A3E:  BCF    FD8.1
12A40:  MOVFF  90F,91A
12A44:  MOVFF  90E,919
12A48:  MOVFF  90D,918
12A4C:  MOVFF  90C,917
12A50:  MOVFF  03,91E
12A54:  MOVFF  02,91D
12A58:  MOVFF  01,91C
12A5C:  MOVFF  00,91B
12A60:  CALL   C3BA
12A64:  MOVFF  03,90F
12A68:  MOVFF  02,90E
12A6C:  MOVFF  01,90D
12A70:  MOVFF  00,90C
....................    } 
12A74:  BRA    12A86
....................  
....................  else 
....................   res = y; 
12A76:  MOVFF  90B,90F
12A7A:  MOVFF  90A,90E
12A7E:  MOVFF  909,90D
12A82:  MOVFF  908,90C
....................  
....................  y = y - (float32)(unsigned int16)y; 
12A86:  MOVFF  90B,916
12A8A:  MOVFF  90A,915
12A8E:  MOVFF  909,914
12A92:  MOVFF  908,913
12A96:  RCALL  12812
12A98:  MOVFF  02,918
12A9C:  MOVFF  01,917
12AA0:  CALL   C8F6
12AA4:  BSF    FD8.1
12AA6:  MOVFF  90B,91A
12AAA:  MOVFF  90A,919
12AAE:  MOVFF  909,918
12AB2:  MOVFF  908,917
12AB6:  MOVFF  03,91E
12ABA:  MOVFF  02,91D
12ABE:  MOVFF  01,91C
12AC2:  MOVFF  00,91B
12AC6:  CALL   C3BA
12ACA:  MOVFF  03,90B
12ACE:  MOVFF  02,90A
12AD2:  MOVFF  01,909
12AD6:  MOVFF  00,908
....................  
....................  if (s) 
12ADA:  MOVLB  9
12ADC:  BTFSS  x12.0
12ADE:  BRA    12AE6
....................   res = -res; 
12AE0:  MOVF   x0D,W
12AE2:  XORLW  80
12AE4:  MOVWF  x0D
....................  
....................  if (y != 0) 
12AE6:  MOVFF  90B,916
12AEA:  MOVFF  90A,915
12AEE:  MOVFF  909,914
12AF2:  MOVFF  908,913
12AF6:  CLRF   x1A
12AF8:  CLRF   x19
12AFA:  CLRF   x18
12AFC:  CLRF   x17
12AFE:  MOVLB  0
12B00:  CALL   10778
12B04:  BZ    12B7E
....................  { 
....................   if (s == 1 && n == 0) 
12B06:  MOVLB  9
12B08:  BTFSS  x12.0
12B0A:  BRA    12B44
12B0C:  MOVF   x07,F
12B0E:  BNZ   12B44
....................    res -= 1.0; 
12B10:  BSF    FD8.1
12B12:  MOVFF  90F,91A
12B16:  MOVFF  90E,919
12B1A:  MOVFF  90D,918
12B1E:  MOVFF  90C,917
12B22:  CLRF   x1E
12B24:  CLRF   x1D
12B26:  CLRF   x1C
12B28:  MOVLW  7F
12B2A:  MOVWF  x1B
12B2C:  MOVLB  0
12B2E:  CALL   C3BA
12B32:  MOVFF  03,90F
12B36:  MOVFF  02,90E
12B3A:  MOVFF  01,90D
12B3E:  MOVFF  00,90C
12B42:  MOVLB  9
....................  
....................   if (s == 0 && n == 1) 
12B44:  BTFSC  x12.0
12B46:  BRA    12B80
12B48:  DECFSZ x07,W
12B4A:  BRA    12B80
....................    res += 1.0; 
12B4C:  BCF    FD8.1
12B4E:  MOVFF  90F,91A
12B52:  MOVFF  90E,919
12B56:  MOVFF  90D,918
12B5A:  MOVFF  90C,917
12B5E:  CLRF   x1E
12B60:  CLRF   x1D
12B62:  CLRF   x1C
12B64:  MOVLW  7F
12B66:  MOVWF  x1B
12B68:  MOVLB  0
12B6A:  CALL   C3BA
12B6E:  MOVFF  03,90F
12B72:  MOVFF  02,90E
12B76:  MOVFF  01,90D
12B7A:  MOVFF  00,90C
12B7E:  MOVLB  9
....................  } 
....................  if (x == 0) 
12B80:  MOVFF  906,916
12B84:  MOVFF  905,915
12B88:  MOVFF  904,914
12B8C:  MOVFF  903,913
12B90:  CLRF   x1A
12B92:  CLRF   x19
12B94:  CLRF   x18
12B96:  CLRF   x17
12B98:  MOVLB  0
12B9A:  CALL   10778
12B9E:  BNZ   12BAC
....................     res = 0; 
12BA0:  MOVLB  9
12BA2:  CLRF   x0F
12BA4:  CLRF   x0E
12BA6:  CLRF   x0D
12BA8:  CLRF   x0C
12BAA:  MOVLB  0
....................  
....................  return (res); 
12BAC:  MOVFF  90C,00
12BB0:  MOVFF  90D,01
12BB4:  MOVFF  90E,02
12BB8:  MOVFF  90F,03
12BBC:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
12BDC:  MOVFF  902,906
12BE0:  MOVFF  901,905
12BE4:  MOVFF  900,904
12BE8:  MOVFF  8FF,903
12BEC:  MOVLB  9
12BEE:  CLRF   x07
12BF0:  MOVLB  0
12BF2:  RCALL  1284E
12BF4:  GOTO   12D00 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
12BBE:  MOVFF  902,906
12BC2:  MOVFF  901,905
12BC6:  MOVFF  900,904
12BCA:  MOVFF  8FF,903
12BCE:  MOVLW  01
12BD0:  MOVLB  9
12BD2:  MOVWF  x07
12BD4:  MOVLB  0
12BD6:  RCALL  1284E
12BD8:  GOTO   12CB8 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
12BF8:  MOVFF  8F6,916
12BFC:  MOVFF  8F5,915
12C00:  MOVFF  8F4,914
12C04:  MOVFF  8F3,913
12C08:  MOVLB  9
12C0A:  CLRF   x1A
12C0C:  CLRF   x19
12C0E:  CLRF   x18
12C10:  CLRF   x17
12C12:  MOVLB  0
12C14:  CALL   10778
12C18:  BTFSC  FD8.2
12C1A:  BRA    12D5C
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
12C1C:  MOVFF  8F2,8FE
12C20:  MOVFF  8F1,8FD
12C24:  MOVFF  8F0,8FC
12C28:  MOVFF  8EF,8FB
12C2C:  MOVFF  8F6,902
12C30:  MOVFF  8F5,901
12C34:  MOVFF  8F4,900
12C38:  MOVFF  8F3,8FF
12C3C:  CALL   C92C
12C40:  MOVFF  03,8FE
12C44:  MOVFF  02,8FD
12C48:  MOVFF  01,8FC
12C4C:  MOVFF  00,8FB
12C50:  MOVFF  03,916
12C54:  MOVFF  02,915
12C58:  MOVFF  01,914
12C5C:  MOVFF  00,913
12C60:  MOVLB  9
12C62:  CLRF   x1A
12C64:  CLRF   x19
12C66:  CLRF   x18
12C68:  CLRF   x17
12C6A:  MOVLB  0
12C6C:  CALL   10778
12C70:  BNC   12CBA
12C72:  MOVFF  8F2,8FE
12C76:  MOVFF  8F1,8FD
12C7A:  MOVFF  8F0,8FC
12C7E:  MOVFF  8EF,8FB
12C82:  MOVFF  8F6,902
12C86:  MOVFF  8F5,901
12C8A:  MOVFF  8F4,900
12C8E:  MOVFF  8F3,8FF
12C92:  CALL   C92C
12C96:  MOVFF  03,8FE
12C9A:  MOVFF  02,8FD
12C9E:  MOVFF  01,8FC
12CA2:  MOVFF  00,8FB
12CA6:  MOVFF  03,902
12CAA:  MOVFF  02,901
12CAE:  MOVFF  01,900
12CB2:  MOVFF  00,8FF
12CB6:  BRA    12BBE
12CB8:  BRA    12D00
12CBA:  MOVFF  8F2,8FE
12CBE:  MOVFF  8F1,8FD
12CC2:  MOVFF  8F0,8FC
12CC6:  MOVFF  8EF,8FB
12CCA:  MOVFF  8F6,902
12CCE:  MOVFF  8F5,901
12CD2:  MOVFF  8F4,900
12CD6:  MOVFF  8F3,8FF
12CDA:  CALL   C92C
12CDE:  MOVFF  03,8FE
12CE2:  MOVFF  02,8FD
12CE6:  MOVFF  01,8FC
12CEA:  MOVFF  00,8FB
12CEE:  MOVFF  03,902
12CF2:  MOVFF  02,901
12CF6:  MOVFF  01,900
12CFA:  MOVFF  00,8FF
12CFE:  BRA    12BDC
12D00:  MOVFF  03,8FA
12D04:  MOVFF  02,8F9
12D08:  MOVFF  01,8F8
12D0C:  MOVFF  00,8F7
....................       return(x-(i*y)); 
12D10:  MOVFF  8FA,916
12D14:  MOVFF  8F9,915
12D18:  MOVFF  8F8,914
12D1C:  MOVFF  8F7,913
12D20:  MOVFF  8F6,91A
12D24:  MOVFF  8F5,919
12D28:  MOVFF  8F4,918
12D2C:  MOVFF  8F3,917
12D30:  CALL   C2C4
12D34:  BSF    FD8.1
12D36:  MOVFF  8F2,91A
12D3A:  MOVFF  8F1,919
12D3E:  MOVFF  8F0,918
12D42:  MOVFF  8EF,917
12D46:  MOVFF  03,91E
12D4A:  MOVFF  02,91D
12D4E:  MOVFF  01,91C
12D52:  MOVFF  00,91B
12D56:  CALL   C3BA
12D5A:  BRA    12D5C
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12D5C:  GOTO   12FF4 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
10842:  MOVFF  8DA,8DE
10846:  MOVFF  8D9,8DD
1084A:  MOVFF  8D8,8DC
1084E:  MOVFF  8D7,8DB
....................  
....................    if (y != 1.0) 
10852:  MOVFF  8DE,916
10856:  MOVFF  8DD,915
1085A:  MOVFF  8DC,914
1085E:  MOVFF  8DB,913
10862:  MOVLB  9
10864:  CLRF   x1A
10866:  CLRF   x19
10868:  CLRF   x18
1086A:  MOVLW  7F
1086C:  MOVWF  x17
1086E:  MOVLB  0
10870:  RCALL  10778
10872:  BTFSC  FD8.2
10874:  BRA    10BB6
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
10876:  MOVLW  08
10878:  MOVLB  8
1087A:  MOVWF  xED
1087C:  MOVLW  DB
1087E:  MOVWF  FE9
10880:  MOVFF  8ED,FEA
10884:  MOVLW  7E
10886:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
10888:  BSF    FD8.1
1088A:  MOVFF  8DE,91A
1088E:  MOVFF  8DD,919
10892:  MOVFF  8DC,918
10896:  MOVFF  8DB,917
1089A:  MOVLB  9
1089C:  CLRF   x1E
1089E:  CLRF   x1D
108A0:  CLRF   x1C
108A2:  MOVLW  7F
108A4:  MOVWF  x1B
108A6:  MOVLB  0
108A8:  CALL   C3BA
108AC:  MOVFF  03,8EF
108B0:  MOVFF  02,8EE
108B4:  MOVFF  01,8ED
108B8:  MOVFF  00,8EC
108BC:  BCF    FD8.1
108BE:  MOVFF  8DE,91A
108C2:  MOVFF  8DD,919
108C6:  MOVFF  8DC,918
108CA:  MOVFF  8DB,917
108CE:  MOVLB  9
108D0:  CLRF   x1E
108D2:  CLRF   x1D
108D4:  CLRF   x1C
108D6:  MOVLW  7F
108D8:  MOVWF  x1B
108DA:  MOVLB  0
108DC:  CALL   C3BA
108E0:  MOVFF  8EF,8FE
108E4:  MOVFF  8EE,8FD
108E8:  MOVFF  8ED,8FC
108EC:  MOVFF  8EC,8FB
108F0:  MOVFF  03,902
108F4:  MOVFF  02,901
108F8:  MOVFF  01,900
108FC:  MOVFF  00,8FF
10900:  CALL   C92C
10904:  MOVFF  03,8DE
10908:  MOVFF  02,8DD
1090C:  MOVFF  01,8DC
10910:  MOVFF  00,8DB
....................  
....................       y2=y*y; 
10914:  MOVFF  8DE,916
10918:  MOVFF  8DD,915
1091C:  MOVFF  8DC,914
10920:  MOVFF  8DB,913
10924:  MOVFF  8DE,91A
10928:  MOVFF  8DD,919
1092C:  MOVFF  8DC,918
10930:  MOVFF  8DB,917
10934:  CALL   C2C4
10938:  MOVFF  03,8EA
1093C:  MOVFF  02,8E9
10940:  MOVFF  01,8E8
10944:  MOVFF  00,8E7
....................  
....................       res = pl[0]*y2 + pl[1]; 
10948:  MOVLW  99
1094A:  MOVLB  9
1094C:  MOVWF  x16
1094E:  MOVLW  47
10950:  MOVWF  x15
10952:  MOVLW  8A
10954:  MOVWF  x14
10956:  MOVLW  7F
10958:  MOVWF  x13
1095A:  MOVFF  8EA,91A
1095E:  MOVFF  8E9,919
10962:  MOVFF  8E8,918
10966:  MOVFF  8E7,917
1096A:  MOVLB  0
1096C:  CALL   C2C4
10970:  MOVFF  03,8EF
10974:  MOVFF  02,8EE
10978:  MOVFF  01,8ED
1097C:  MOVFF  00,8EC
10980:  BCF    FD8.1
10982:  MOVFF  03,91A
10986:  MOVFF  02,919
1098A:  MOVFF  01,918
1098E:  MOVFF  00,917
10992:  MOVLB  9
10994:  CLRF   x1E
10996:  CLRF   x1D
10998:  CLRF   x1C
1099A:  MOVLW  80
1099C:  MOVWF  x1B
1099E:  MOVLB  0
109A0:  CALL   C3BA
109A4:  MOVFF  03,8E2
109A8:  MOVFF  02,8E1
109AC:  MOVFF  01,8E0
109B0:  MOVFF  00,8DF
....................  
....................       r = ql[0]*y2 + ql[1]; 
109B4:  MOVLW  4C
109B6:  MOVLB  9
109B8:  MOVWF  x16
109BA:  MOVLW  F3
109BC:  MOVWF  x15
109BE:  MOVLW  3A
109C0:  MOVWF  x14
109C2:  MOVLW  7B
109C4:  MOVWF  x13
109C6:  MOVFF  8EA,91A
109CA:  MOVFF  8E9,919
109CE:  MOVFF  8E8,918
109D2:  MOVFF  8E7,917
109D6:  MOVLB  0
109D8:  CALL   C2C4
109DC:  MOVFF  03,8EF
109E0:  MOVFF  02,8EE
109E4:  MOVFF  01,8ED
109E8:  MOVFF  00,8EC
109EC:  BCF    FD8.1
109EE:  MOVFF  03,91A
109F2:  MOVFF  02,919
109F6:  MOVFF  01,918
109FA:  MOVFF  00,917
109FE:  MOVLW  2B
10A00:  MOVLB  9
10A02:  MOVWF  x1E
10A04:  MOVLW  9D
10A06:  MOVWF  x1D
10A08:  MOVLW  DF
10A0A:  MOVWF  x1C
10A0C:  MOVLW  7E
10A0E:  MOVWF  x1B
10A10:  MOVLB  0
10A12:  CALL   C3BA
10A16:  MOVFF  03,8E6
10A1A:  MOVFF  02,8E5
10A1E:  MOVFF  01,8E4
10A22:  MOVFF  00,8E3
....................       r = r*y2 + 1.0; 
10A26:  MOVFF  8E6,916
10A2A:  MOVFF  8E5,915
10A2E:  MOVFF  8E4,914
10A32:  MOVFF  8E3,913
10A36:  MOVFF  8EA,91A
10A3A:  MOVFF  8E9,919
10A3E:  MOVFF  8E8,918
10A42:  MOVFF  8E7,917
10A46:  CALL   C2C4
10A4A:  MOVFF  03,8EF
10A4E:  MOVFF  02,8EE
10A52:  MOVFF  01,8ED
10A56:  MOVFF  00,8EC
10A5A:  BCF    FD8.1
10A5C:  MOVFF  03,91A
10A60:  MOVFF  02,919
10A64:  MOVFF  01,918
10A68:  MOVFF  00,917
10A6C:  MOVLB  9
10A6E:  CLRF   x1E
10A70:  CLRF   x1D
10A72:  CLRF   x1C
10A74:  MOVLW  7F
10A76:  MOVWF  x1B
10A78:  MOVLB  0
10A7A:  CALL   C3BA
10A7E:  MOVFF  03,8E6
10A82:  MOVFF  02,8E5
10A86:  MOVFF  01,8E4
10A8A:  MOVFF  00,8E3
....................  
....................       res = y*res/r; 
10A8E:  MOVFF  8DE,916
10A92:  MOVFF  8DD,915
10A96:  MOVFF  8DC,914
10A9A:  MOVFF  8DB,913
10A9E:  MOVFF  8E2,91A
10AA2:  MOVFF  8E1,919
10AA6:  MOVFF  8E0,918
10AAA:  MOVFF  8DF,917
10AAE:  CALL   C2C4
10AB2:  MOVFF  03,8EF
10AB6:  MOVFF  02,8EE
10ABA:  MOVFF  01,8ED
10ABE:  MOVFF  00,8EC
10AC2:  MOVFF  03,8FE
10AC6:  MOVFF  02,8FD
10ACA:  MOVFF  01,8FC
10ACE:  MOVFF  00,8FB
10AD2:  MOVFF  8E6,902
10AD6:  MOVFF  8E5,901
10ADA:  MOVFF  8E4,900
10ADE:  MOVFF  8E3,8FF
10AE2:  CALL   C92C
10AE6:  MOVFF  03,8E2
10AEA:  MOVFF  02,8E1
10AEE:  MOVFF  01,8E0
10AF2:  MOVFF  00,8DF
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
10AF6:  MOVLW  08
10AF8:  MOVLB  8
10AFA:  MOVWF  xED
10AFC:  MOVLW  D7
10AFE:  MOVWF  FE9
10B00:  MOVFF  8ED,FEA
10B04:  MOVLW  7E
10B06:  SUBWF  FEF,W
10B08:  MOVWF  xEB
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
10B0A:  BTFSS  xEB.7
10B0C:  BRA    10B36
....................          r = -(float32)-n; 
10B0E:  MOVLW  00
10B10:  BSF    FD8.0
10B12:  SUBFWB xEB,W
10B14:  CLRF   xED
10B16:  MOVWF  xEC
10B18:  BTFSC  xEC.7
10B1A:  DECF   xED,F
10B1C:  MOVLB  0
10B1E:  RCALL  107F2
10B20:  MOVFF  00,8E3
10B24:  MOVF   01,W
10B26:  XORLW  80
10B28:  MOVLB  8
10B2A:  MOVWF  xE4
10B2C:  MOVFF  02,8E5
10B30:  MOVFF  03,8E6
10B34:  BRA    10B56
....................       else 
....................          r = (float32)n; 
10B36:  CLRF   xED
10B38:  MOVFF  8EB,8EC
10B3C:  BTFSC  xEC.7
10B3E:  DECF   xED,F
10B40:  MOVLB  0
10B42:  RCALL  107F2
10B44:  MOVFF  03,8E6
10B48:  MOVFF  02,8E5
10B4C:  MOVFF  01,8E4
10B50:  MOVFF  00,8E3
10B54:  MOVLB  8
....................  
....................       res += r*LN2; 
10B56:  MOVFF  8E6,916
10B5A:  MOVFF  8E5,915
10B5E:  MOVFF  8E4,914
10B62:  MOVFF  8E3,913
10B66:  MOVLW  18
10B68:  MOVLB  9
10B6A:  MOVWF  x1A
10B6C:  MOVLW  72
10B6E:  MOVWF  x19
10B70:  MOVLW  31
10B72:  MOVWF  x18
10B74:  MOVLW  7E
10B76:  MOVWF  x17
10B78:  MOVLB  0
10B7A:  CALL   C2C4
10B7E:  BCF    FD8.1
10B80:  MOVFF  8E2,91A
10B84:  MOVFF  8E1,919
10B88:  MOVFF  8E0,918
10B8C:  MOVFF  8DF,917
10B90:  MOVFF  03,91E
10B94:  MOVFF  02,91D
10B98:  MOVFF  01,91C
10B9C:  MOVFF  00,91B
10BA0:  CALL   C3BA
10BA4:  MOVFF  03,8E2
10BA8:  MOVFF  02,8E1
10BAC:  MOVFF  01,8E0
10BB0:  MOVFF  00,8DF
....................    } 
10BB4:  BRA    10BC2
....................  
....................    else 
....................       res = 0.0; 
10BB6:  MOVLB  8
10BB8:  CLRF   xE2
10BBA:  CLRF   xE1
10BBC:  CLRF   xE0
10BBE:  CLRF   xDF
10BC0:  MOVLB  0
....................  
....................    return(res); 
10BC2:  MOVFF  8DF,00
10BC6:  MOVFF  8E0,01
10BCA:  MOVFF  8E1,02
10BCE:  MOVFF  8E2,03
10BD2:  GOTO   10BE8 (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
10BD6:  MOVFF  8D2,8DA
10BDA:  MOVFF  8D1,8D9
10BDE:  MOVFF  8D0,8D8
10BE2:  MOVFF  8CF,8D7
10BE6:  BRA    10842
10BE8:  MOVFF  03,8D6
10BEC:  MOVFF  02,8D5
10BF0:  MOVFF  01,8D4
10BF4:  MOVFF  00,8D3
....................    r = r*LN10_INV; 
10BF8:  MOVFF  8D6,916
10BFC:  MOVFF  8D5,915
10C00:  MOVFF  8D4,914
10C04:  MOVFF  8D3,913
10C08:  MOVLW  D9
10C0A:  MOVLB  9
10C0C:  MOVWF  x1A
10C0E:  MOVLW  5B
10C10:  MOVWF  x19
10C12:  MOVLW  5E
10C14:  MOVWF  x18
10C16:  MOVLW  7D
10C18:  MOVWF  x17
10C1A:  MOVLB  0
10C1C:  CALL   C2C4
10C20:  MOVFF  03,8D6
10C24:  MOVFF  02,8D5
10C28:  MOVFF  01,8D4
10C2C:  MOVFF  00,8D3
....................    return(r); 
10C30:  MOVFF  8D3,00
10C34:  MOVFF  8D4,01
10C38:  MOVFF  8D5,02
10C3C:  MOVFF  8D6,03
10C40:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
105D0:  BCF    FC6.5
105D2:  MOVLW  21
105D4:  MOVWF  FC6
105D6:  MOVLW  40
105D8:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
105DA:  BSF    F91.2
....................    output_high(EEP_WP); 
105DC:  BSF    F91.3
105DE:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
105E0:  BCF    F91.2
....................    spi_write(0x05);  
105E2:  MOVF   FC9,W
105E4:  MOVLW  05
105E6:  MOVWF  FC9
105E8:  RRCF   FC7,W
105EA:  BNC   105E8
....................    data = spi_read(0);  
105EC:  MOVF   FC9,W
105EE:  CLRF   FC9
105F0:  RRCF   FC7,W
105F2:  BNC   105F0
105F4:  MOVFF  FC9,8CE
....................    output_high(EEP_CS);  
105F8:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
105FA:  MOVLW  00
105FC:  MOVLB  8
105FE:  BTFSS  xCE.0
10600:  MOVLW  01
10602:  MOVWF  01
10604:  MOVLB  0
10606:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
18050:  MOVLB  8
18052:  CLRF   xED
18054:  MOVLB  0
18056:  CALL   5586
....................       while(!ext_eeprom_ready()); 
1805A:  CALL   105E0
1805E:  MOVF   01,F
18060:  BZ    1805A
....................     
....................       output_low(EEP_CS);  
18062:  BCF    F91.2
....................       spi_write(0x06);  
18064:  MOVF   FC9,W
18066:  MOVLW  06
18068:  MOVWF  FC9
1806A:  RRCF   FC7,W
1806C:  BNC   1806A
....................       output_high(EEP_CS);  
1806E:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
18070:  BCF    F91.2
....................       spi_write(0x02);  
18072:  MOVF   FC9,W
18074:  MOVLW  02
18076:  MOVWF  FC9
18078:  RRCF   FC7,W
1807A:  BNC   18078
....................       spi_write(address >> 8);  
1807C:  MOVFF  8A8,8AA
18080:  MOVLB  8
18082:  CLRF   xAB
18084:  MOVF   FC9,W
18086:  MOVFF  8A8,FC9
1808A:  RRCF   FC7,W
1808C:  BNC   1808A
....................       spi_write(address);  
1808E:  MOVF   FC9,W
18090:  MOVFF  8A7,FC9
18094:  RRCF   FC7,W
18096:  BNC   18094
....................       spi_write(data);  
18098:  MOVF   FC9,W
1809A:  MOVFF  8A9,FC9
1809E:  RRCF   FC7,W
180A0:  BNC   1809E
....................       output_high(EEP_CS);  
180A2:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
180A4:  MOVLW  01
180A6:  MOVWF  xED
180A8:  MOVLB  0
180AA:  CALL   5586
180AE:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
10608:  MOVLB  8
1060A:  CLRF   xED
1060C:  MOVLB  0
1060E:  CALL   5586
....................     
....................       while(!ext_eeprom_ready()); 
10612:  RCALL  105E0
10614:  MOVF   01,F
10616:  BZ    10612
....................        
....................       output_low(EEP_CS);  
10618:  BCF    F91.2
....................       spi_write(0x03);  
1061A:  MOVF   FC9,W
1061C:  MOVLW  03
1061E:  MOVWF  FC9
10620:  RRCF   FC7,W
10622:  BNC   10620
....................       spi_write(address >> 8);  
10624:  MOVFF  8CC,8CE
10628:  MOVLB  8
1062A:  CLRF   xCF
1062C:  MOVF   FC9,W
1062E:  MOVFF  8CC,FC9
10632:  RRCF   FC7,W
10634:  BNC   10632
....................       spi_write(address);  
10636:  MOVF   FC9,W
10638:  MOVFF  8CB,FC9
1063C:  RRCF   FC7,W
1063E:  BNC   1063C
....................        
....................       data = spi_read(0);  
10640:  MOVF   FC9,W
10642:  CLRF   FC9
10644:  RRCF   FC7,W
10646:  BNC   10644
10648:  MOVFF  FC9,8CD
....................       output_high(EEP_CS);  
1064C:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
1064E:  MOVLW  01
10650:  MOVWF  xED
10652:  MOVLB  0
10654:  CALL   5586
....................     
....................    return(data);  
10658:  MOVLB  8
1065A:  MOVFF  8CD,01
1065E:  MOVLB  0
10660:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
03412:  MOVF   FF2,W
03414:  MOVWF  00
03416:  BCF    FF2.7
03418:  CLRF   F63
0341A:  MOVFF  889,F62
0341E:  MOVFF  88A,F61
03422:  BCF    F7F.6
03424:  BCF    F7F.7
03426:  BSF    F7F.2
03428:  MOVLB  F
0342A:  MOVLW  55
0342C:  MOVWF  F7E
0342E:  MOVLW  AA
03430:  MOVWF  F7E
03432:  BSF    F7F.1
03434:  BTFSC  F7F.1
03436:  BRA    3434
03438:  BCF    F7F.2
0343A:  MOVF   00,W
0343C:  IORWF  FF2,F
0343E:  MOVLB  0
03440:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
02A24:  MOVLB  8
02A26:  CLRF   xB8
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
02A28:  MOVFF  FF2,8B9
02A2C:  BCF    FF2.7
02A2E:  CLRF   F63
02A30:  MOVFF  8B7,F62
02A34:  BCF    F7F.6
02A36:  BCF    F7F.7
02A38:  BSF    F7F.0
02A3A:  MOVF   F61,W
02A3C:  BTFSC  xB9.7
02A3E:  BSF    FF2.7
02A40:  MOVWF  xB8
....................    return(data); 
02A42:  MOVFF  8B8,01
02A46:  MOVLB  0
02A48:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04FD4:  MOVLB  8
04FD6:  CLRF   xF1
04FD8:  MOVF   xF1,W
04FDA:  SUBLW  01
04FDC:  BNC   5036
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
04FDE:  MOVF   xEE,W
04FE0:  ADDWF  xF1,W
04FE2:  MOVWF  xF2
04FE4:  MOVLW  08
04FE6:  MOVWF  xF4
04FE8:  MOVLW  EF
04FEA:  MOVWF  xF3
04FEC:  MOVF   xF1,W
04FEE:  ADDWF  xF3,W
04FF0:  MOVWF  01
04FF2:  MOVLW  00
04FF4:  ADDWFC xF4,W
04FF6:  MOVWF  03
04FF8:  MOVF   01,W
04FFA:  MOVWF  FE9
04FFC:  MOVFF  03,FEA
05000:  MOVFF  FEF,8F3
05004:  MOVF   FF2,W
05006:  MOVWF  00
05008:  BCF    FF2.7
0500A:  CLRF   F63
0500C:  MOVFF  8F2,F62
05010:  MOVFF  8F3,F61
05014:  BCF    F7F.6
05016:  BCF    F7F.7
05018:  BSF    F7F.2
0501A:  MOVLB  F
0501C:  MOVLW  55
0501E:  MOVWF  F7E
05020:  MOVLW  AA
05022:  MOVWF  F7E
05024:  BSF    F7F.1
05026:  BTFSC  F7F.1
05028:  BRA    5026
0502A:  BCF    F7F.2
0502C:  MOVF   00,W
0502E:  IORWF  FF2,F
05030:  MOVLB  8
05032:  INCF   xF1,F
05034:  BRA    4FD8
....................     }  
05036:  MOVLB  0
05038:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
029CA:  MOVLB  8
029CC:  CLRF   x9A
029CE:  CLRF   x99
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
029D0:  CLRF   x98
029D2:  MOVF   x98,W
029D4:  SUBLW  01
029D6:  BNC   2A18
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
029D8:  MOVLW  08
029DA:  MOVWF  x9C
029DC:  MOVLW  99
029DE:  MOVWF  x9B
029E0:  MOVF   x98,W
029E2:  ADDWF  x9B,W
029E4:  MOVWF  01
029E6:  MOVLW  00
029E8:  ADDWFC x9C,W
029EA:  MOVWF  03
029EC:  MOVF   01,W
029EE:  MOVWF  FE9
029F0:  MOVFF  03,FEA
029F4:  MOVF   x97,W
029F6:  ADDWF  x98,W
029F8:  MOVWF  x9D
029FA:  MOVFF  FF2,89E
029FE:  BCF    FF2.7
02A00:  CLRF   F63
02A02:  MOVFF  89D,F62
02A06:  BCF    F7F.6
02A08:  BCF    F7F.7
02A0A:  BSF    F7F.0
02A0C:  MOVF   F61,W
02A0E:  BTFSC  x9E.7
02A10:  BSF    FF2.7
02A12:  MOVWF  FEF
02A14:  INCF   x98,F
02A16:  BRA    29D2
....................    } 
....................  
....................    return(data);  
02A18:  MOVFF  899,01
02A1C:  MOVFF  89A,02
02A20:  MOVLB  0
02A22:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CD4C:  MOVLB  8
0CD4E:  CLRF   x8B
0CD50:  MOVF   x8B,W
0CD52:  SUBLW  03
0CD54:  BNC   CDB6
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CD56:  MOVF   x8B,W
0CD58:  ADDWF  x85,W
0CD5A:  MOVWF  x8C
0CD5C:  MOVLW  00
0CD5E:  ADDWFC x86,W
0CD60:  MOVWF  x8D
0CD62:  MOVLW  08
0CD64:  MOVWF  x8F
0CD66:  MOVLW  87
0CD68:  MOVWF  x8E
0CD6A:  MOVF   x8B,W
0CD6C:  ADDWF  x8E,W
0CD6E:  MOVWF  01
0CD70:  MOVLW  00
0CD72:  ADDWFC x8F,W
0CD74:  MOVWF  03
0CD76:  MOVF   01,W
0CD78:  MOVWF  FE9
0CD7A:  MOVFF  03,FEA
0CD7E:  MOVFF  FEF,88E
0CD82:  MOVF   FF2,W
0CD84:  MOVWF  00
0CD86:  BCF    FF2.7
0CD88:  MOVFF  88D,F63
0CD8C:  MOVFF  88C,F62
0CD90:  MOVFF  88E,F61
0CD94:  BCF    F7F.6
0CD96:  BCF    F7F.7
0CD98:  BSF    F7F.2
0CD9A:  MOVLB  F
0CD9C:  MOVLW  55
0CD9E:  MOVWF  F7E
0CDA0:  MOVLW  AA
0CDA2:  MOVWF  F7E
0CDA4:  BSF    F7F.1
0CDA6:  BTFSC  F7F.1
0CDA8:  BRA    CDA6
0CDAA:  BCF    F7F.2
0CDAC:  MOVF   00,W
0CDAE:  IORWF  FF2,F
0CDB0:  MOVLB  8
0CDB2:  INCF   x8B,F
0CDB4:  BRA    CD50
....................    } 
0CDB6:  MOVLB  0
0CDB8:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
02A4A:  MOVLB  8
02A4C:  CLRF   x8B
02A4E:  CLRF   x8A
02A50:  CLRF   x89
02A52:  CLRF   x88
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
02A54:  CLRF   x87
02A56:  MOVF   x87,W
02A58:  SUBLW  03
02A5A:  BNC   2AA4
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A5C:  MOVLW  08
02A5E:  MOVWF  x8D
02A60:  MOVLW  88
02A62:  MOVWF  x8C
02A64:  MOVF   x87,W
02A66:  ADDWF  x8C,W
02A68:  MOVWF  01
02A6A:  MOVLW  00
02A6C:  ADDWFC x8D,W
02A6E:  MOVWF  03
02A70:  MOVF   01,W
02A72:  MOVWF  FE9
02A74:  MOVFF  03,FEA
02A78:  MOVF   x87,W
02A7A:  ADDWF  x85,W
02A7C:  MOVWF  x8E
02A7E:  MOVLW  00
02A80:  ADDWFC x86,W
02A82:  MOVWF  x8F
02A84:  MOVFF  FF2,890
02A88:  BCF    FF2.7
02A8A:  MOVFF  88F,F63
02A8E:  MOVFF  88E,F62
02A92:  BCF    F7F.6
02A94:  BCF    F7F.7
02A96:  BSF    F7F.0
02A98:  MOVF   F61,W
02A9A:  BTFSC  x90.7
02A9C:  BSF    FF2.7
02A9E:  MOVWF  FEF
02AA0:  INCF   x87,F
02AA2:  BRA    2A56
....................    } 
....................  
....................    return(data);  
02AA4:  MOVFF  888,00
02AA8:  MOVFF  889,01
02AAC:  MOVFF  88A,02
02AB0:  MOVFF  88B,03
02AB4:  MOVLB  0
02AB6:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
18290:  MOVLB  8
18292:  CLRF   xA3
18294:  MOVF   xA3,W
18296:  SUBLW  01
18298:  BNC   182D6
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
1829A:  MOVF   xA3,W
1829C:  ADDWF  x9F,W
1829E:  MOVWF  xA4
182A0:  MOVLW  00
182A2:  ADDWFC xA0,W
182A4:  MOVWF  xA5
182A6:  MOVLW  08
182A8:  MOVWF  xA7
182AA:  MOVLW  A1
182AC:  MOVWF  xA6
182AE:  MOVF   xA3,W
182B0:  ADDWF  xA6,W
182B2:  MOVWF  01
182B4:  MOVLW  00
182B6:  ADDWFC xA7,W
182B8:  MOVWF  03
182BA:  MOVFF  01,FE9
182BE:  MOVWF  FEA
182C0:  MOVFF  FEF,8A9
182C4:  MOVFF  8A5,8A8
182C8:  MOVFF  8A4,8A7
182CC:  MOVLB  0
182CE:  RCALL  18050
182D0:  MOVLB  8
182D2:  INCF   xA3,F
182D4:  BRA    18294
....................     }  
182D6:  MOVLB  0
182D8:  GOTO   18348 (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
1071C:  MOVLB  8
1071E:  CLRF   xC6
10720:  CLRF   xC5
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
10722:  CLRF   xC4
10724:  MOVF   xC4,W
10726:  SUBLW  01
10728:  BNC   1076C
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
1072A:  MOVLW  08
1072C:  MOVWF  xC8
1072E:  MOVLW  C5
10730:  MOVWF  xC7
10732:  MOVF   xC4,W
10734:  ADDWF  xC7,W
10736:  MOVWF  01
10738:  MOVLW  00
1073A:  ADDWFC xC8,W
1073C:  MOVWF  03
1073E:  MOVFF  01,8C7
10742:  MOVWF  xC8
10744:  MOVF   xC4,W
10746:  ADDWF  xC2,W
10748:  MOVWF  xC9
1074A:  MOVLW  00
1074C:  ADDWFC xC3,W
1074E:  MOVWF  xCA
10750:  MOVWF  xCC
10752:  MOVFF  8C9,8CB
10756:  MOVLB  0
10758:  RCALL  10608
1075A:  MOVFF  8C8,FEA
1075E:  MOVFF  8C7,FE9
10762:  MOVFF  01,FEF
10766:  MOVLB  8
10768:  INCF   xC4,F
1076A:  BRA    10724
....................    } 
....................    return(data);  
1076C:  MOVFF  8C5,01
10770:  MOVFF  8C6,02
10774:  MOVLB  0
10776:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
15D04:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
15D06:  MOVF   2F,W
15D08:  SUBLW  02
15D0A:  BNZ   15D12
15D0C:  MOVF   30,F
15D0E:  BNZ   15D12
15D10:  BSF    F90.6
....................    delay_ms(32); 
15D12:  MOVLW  20
15D14:  MOVLB  9
15D16:  MOVWF  xEC
15D18:  MOVLB  0
15D1A:  CALL   2910
....................    output_bit(BOARD_LED, OFF); 
15D1E:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15D20:  MOVF   2F,W
15D22:  SUBLW  02
15D24:  BNZ   15D2C
15D26:  MOVF   30,F
15D28:  BNZ   15D2C
15D2A:  BCF    F90.6
....................    delay_ms(32); 
15D2C:  MOVLW  20
15D2E:  MOVLB  9
15D30:  MOVWF  xEC
15D32:  MOVLB  0
15D34:  CALL   2910
15D38:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
03148:  MOVF   2F,W
0314A:  MOVWF  00
0314C:  MOVF   30,W
0314E:  MOVWF  03
03150:  BNZ   3156
03152:  MOVF   00,F
03154:  BZ    3178
03156:  MOVF   03,W
03158:  BNZ   3160
0315A:  MOVLW  01
0315C:  SUBWF  00,W
0315E:  BZ    31CA
03160:  MOVF   03,W
03162:  BNZ   316A
03164:  MOVLW  02
03166:  SUBWF  00,W
03168:  BZ    321C
0316A:  MOVF   03,W
0316C:  BNZ   3176
0316E:  MOVLW  03
03170:  SUBWF  00,W
03172:  BTFSC  FD8.2
03174:  BRA    326E
03176:  BRA    32C0
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
03178:  MOVLW  BE
0317A:  MOVWF  FF6
0317C:  MOVLW  05
0317E:  MOVWF  FF7
03180:  MOVLW  00
03182:  MOVWF  FF8
03184:  CLRF   1B
03186:  BTFSC  FF2.7
03188:  BSF    1B.7
0318A:  BCF    FF2.7
0318C:  MOVLW  06
0318E:  MOVLB  A
03190:  MOVWF  x40
03192:  MOVLB  0
03194:  CALL   101C
03198:  BTFSC  1B.7
0319A:  BSF    FF2.7
0319C:  MOVLW  CA
0319E:  MOVWF  FF6
031A0:  MOVLW  05
031A2:  MOVWF  FF7
031A4:  MOVLW  00
031A6:  MOVWF  FF8
031A8:  CLRF   1B
031AA:  BTFSC  FF2.7
031AC:  BSF    1B.7
031AE:  BCF    FF2.7
031B0:  CALL   0E46
031B4:  BTFSC  1B.7
031B6:  BSF    FF2.7
031B8:  MOVLW  0D
031BA:  BTFSS  F9E.4
031BC:  BRA    31BA
031BE:  MOVWF  FAD
031C0:  MOVLW  0A
031C2:  BTFSS  F9E.4
031C4:  BRA    31C2
031C6:  MOVWF  FAD
....................          break; 
031C8:  BRA    3310
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
031CA:  MOVLW  D2
031CC:  MOVWF  FF6
031CE:  MOVLW  05
031D0:  MOVWF  FF7
031D2:  MOVLW  00
031D4:  MOVWF  FF8
031D6:  CLRF   1B
031D8:  BTFSC  FF2.7
031DA:  BSF    1B.7
031DC:  BCF    FF2.7
031DE:  MOVLW  09
031E0:  MOVLB  A
031E2:  MOVWF  x40
031E4:  MOVLB  0
031E6:  CALL   101C
031EA:  BTFSC  1B.7
031EC:  BSF    FF2.7
031EE:  MOVLW  E0
031F0:  MOVWF  FF6
031F2:  MOVLW  05
031F4:  MOVWF  FF7
031F6:  MOVLW  00
031F8:  MOVWF  FF8
031FA:  CLRF   1B
031FC:  BTFSC  FF2.7
031FE:  BSF    1B.7
03200:  BCF    FF2.7
03202:  CALL   0E46
03206:  BTFSC  1B.7
03208:  BSF    FF2.7
0320A:  MOVLW  0D
0320C:  BTFSS  F9E.4
0320E:  BRA    320C
03210:  MOVWF  FAD
03212:  MOVLW  0A
03214:  BTFSS  F9E.4
03216:  BRA    3214
03218:  MOVWF  FAD
....................          break;  
0321A:  BRA    3310
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
0321C:  MOVLW  E8
0321E:  MOVWF  FF6
03220:  MOVLW  05
03222:  MOVWF  FF7
03224:  MOVLW  00
03226:  MOVWF  FF8
03228:  CLRF   1B
0322A:  BTFSC  FF2.7
0322C:  BSF    1B.7
0322E:  BCF    FF2.7
03230:  MOVLW  06
03232:  MOVLB  A
03234:  MOVWF  x40
03236:  MOVLB  0
03238:  CALL   101C
0323C:  BTFSC  1B.7
0323E:  BSF    FF2.7
03240:  MOVLW  F4
03242:  MOVWF  FF6
03244:  MOVLW  05
03246:  MOVWF  FF7
03248:  MOVLW  00
0324A:  MOVWF  FF8
0324C:  CLRF   1B
0324E:  BTFSC  FF2.7
03250:  BSF    1B.7
03252:  BCF    FF2.7
03254:  CALL   0E46
03258:  BTFSC  1B.7
0325A:  BSF    FF2.7
0325C:  MOVLW  0D
0325E:  BTFSS  F9E.4
03260:  BRA    325E
03262:  MOVWF  FAD
03264:  MOVLW  0A
03266:  BTFSS  F9E.4
03268:  BRA    3266
0326A:  MOVWF  FAD
....................          break; 
0326C:  BRA    3310
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
0326E:  MOVLW  FC
03270:  MOVWF  FF6
03272:  MOVLW  05
03274:  MOVWF  FF7
03276:  MOVLW  00
03278:  MOVWF  FF8
0327A:  CLRF   1B
0327C:  BTFSC  FF2.7
0327E:  BSF    1B.7
03280:  BCF    FF2.7
03282:  MOVLW  09
03284:  MOVLB  A
03286:  MOVWF  x40
03288:  MOVLB  0
0328A:  CALL   101C
0328E:  BTFSC  1B.7
03290:  BSF    FF2.7
03292:  MOVLW  0A
03294:  MOVWF  FF6
03296:  MOVLW  06
03298:  MOVWF  FF7
0329A:  MOVLW  00
0329C:  MOVWF  FF8
0329E:  CLRF   1B
032A0:  BTFSC  FF2.7
032A2:  BSF    1B.7
032A4:  BCF    FF2.7
032A6:  CALL   0E46
032AA:  BTFSC  1B.7
032AC:  BSF    FF2.7
032AE:  MOVLW  0D
032B0:  BTFSS  F9E.4
032B2:  BRA    32B0
032B4:  MOVWF  FAD
032B6:  MOVLW  0A
032B8:  BTFSS  F9E.4
032BA:  BRA    32B8
032BC:  MOVWF  FAD
....................          break;           
032BE:  BRA    3310
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
032C0:  MOVLW  12
032C2:  MOVWF  FF6
032C4:  MOVLW  06
032C6:  MOVWF  FF7
032C8:  MOVLW  00
032CA:  MOVWF  FF8
032CC:  CLRF   1B
032CE:  BTFSC  FF2.7
032D0:  BSF    1B.7
032D2:  BCF    FF2.7
032D4:  MOVLW  06
032D6:  MOVLB  A
032D8:  MOVWF  x40
032DA:  MOVLB  0
032DC:  CALL   101C
032E0:  BTFSC  1B.7
032E2:  BSF    FF2.7
032E4:  MOVLW  1E
032E6:  MOVWF  FF6
032E8:  MOVLW  06
032EA:  MOVWF  FF7
032EC:  MOVLW  00
032EE:  MOVWF  FF8
032F0:  CLRF   1B
032F2:  BTFSC  FF2.7
032F4:  BSF    1B.7
032F6:  BCF    FF2.7
032F8:  CALL   0E46
032FC:  BTFSC  1B.7
032FE:  BSF    FF2.7
03300:  MOVLW  0D
03302:  BTFSS  F9E.4
03304:  BRA    3302
03306:  MOVWF  FAD
03308:  MOVLW  0A
0330A:  BTFSS  F9E.4
0330C:  BRA    330A
0330E:  MOVWF  FAD
....................          break; 
....................    } 
03310:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
17740:  MOVLW  26
17742:  MOVWF  FF6
17744:  MOVLW  06
17746:  MOVWF  FF7
17748:  MOVLW  00
1774A:  MOVWF  FF8
1774C:  CLRF   1B
1774E:  BTFSC  FF2.7
17750:  BSF    1B.7
17752:  BCF    FF2.7
17754:  CALL   0E46
17758:  BTFSC  1B.7
1775A:  BSF    FF2.7
1775C:  GOTO   17B06 (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0B2FE:  MOVLW  2E
0B300:  MOVWF  FF6
0B302:  MOVLW  06
0B304:  MOVWF  FF7
0B306:  MOVLW  00
0B308:  MOVWF  FF8
0B30A:  CLRF   1B
0B30C:  BTFSC  FF2.7
0B30E:  BSF    1B.7
0B310:  BCF    FF2.7
0B312:  CALL   0E46
0B316:  BTFSC  1B.7
0B318:  BSF    FF2.7
0B31A:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BFC0:  MOVLW  36
0BFC2:  MOVWF  FF6
0BFC4:  MOVLW  06
0BFC6:  MOVWF  FF7
0BFC8:  MOVLW  00
0BFCA:  MOVWF  FF8
0BFCC:  CLRF   1B
0BFCE:  BTFSC  FF2.7
0BFD0:  BSF    1B.7
0BFD2:  BCF    FF2.7
0BFD4:  CALL   0E46
0BFD8:  BTFSC  1B.7
0BFDA:  BSF    FF2.7
0BFDC:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
03656:  MOVLW  4E
03658:  MOVWF  FF6
0365A:  MOVLW  06
0365C:  MOVWF  FF7
0365E:  MOVLW  00
03660:  MOVWF  FF8
03662:  CLRF   1B
03664:  BTFSC  FF2.7
03666:  BSF    1B.7
03668:  BCF    FF2.7
0366A:  CALL   0E46
0366E:  BTFSC  1B.7
03670:  BSF    FF2.7
03672:  GOTO   43C8 (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
05080:  MOVLW  56
05082:  MOVWF  FF6
05084:  MOVLW  06
05086:  MOVWF  FF7
05088:  MOVLW  00
0508A:  MOVWF  FF8
0508C:  CLRF   1B
0508E:  BTFSC  FF2.7
05090:  BSF    1B.7
05092:  BCF    FF2.7
05094:  CALL   0E46
05098:  BTFSC  1B.7
0509A:  BSF    FF2.7
0509C:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
1623E:  MOVLW  5E
16240:  MOVWF  FF6
16242:  MOVLW  06
16244:  MOVWF  FF7
16246:  MOVLW  00
16248:  MOVWF  FF8
1624A:  CLRF   1B
1624C:  BTFSC  FF2.7
1624E:  BSF    1B.7
16250:  BCF    FF2.7
16252:  CALL   0E46
16256:  BTFSC  1B.7
16258:  BSF    FF2.7
1625A:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "\r\n?@BSY\r\n"); 
*
0AEC0:  DECFSZ 4E,W
0AEC2:  BRA    AEE2
0AEC4:  MOVLW  66
0AEC6:  MOVWF  FF6
0AEC8:  MOVLW  06
0AECA:  MOVWF  FF7
0AECC:  MOVLW  00
0AECE:  MOVWF  FF8
0AED0:  CLRF   1B
0AED2:  BTFSC  FF2.7
0AED4:  BSF    1B.7
0AED6:  BCF    FF2.7
0AED8:  CALL   0E46
0AEDC:  BTFSC  1B.7
0AEDE:  BSF    FF2.7
0AEE0:  BRA    AEFE
....................    else fprintf(COM_A, "\r\n@RDY\r\n"); 
0AEE2:  MOVLW  70
0AEE4:  MOVWF  FF6
0AEE6:  MOVLW  06
0AEE8:  MOVWF  FF7
0AEEA:  MOVLW  00
0AEEC:  MOVWF  FF8
0AEEE:  CLRF   1B
0AEF0:  BTFSC  FF2.7
0AEF2:  BSF    1B.7
0AEF4:  BCF    FF2.7
0AEF6:  CALL   0E46
0AEFA:  BTFSC  1B.7
0AEFC:  BSF    FF2.7
0AEFE:  GOTO   1B4A6 (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
03540:  MOVLW  0A
03542:  MOVLB  A
03544:  MOVWF  x35
03546:  MOVLW  2C
03548:  MOVFF  A35,A33
0354C:  MOVWF  x32
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
0354E:  MOVF   FC9,W
03550:  SETF   FC9
03552:  RRCF   FC7,W
03554:  BNC   3552
....................    SD_spi_read(sdcmd); 
03556:  MOVF   FC9,W
03558:  MOVFF  A2B,FC9
0355C:  RRCF   FC7,W
0355E:  BNC   355C
....................    SD_spi_read(value[3]); 
03560:  MOVLW  03
03562:  ADDWF  x32,W
03564:  MOVWF  FE9
03566:  MOVLW  00
03568:  ADDWFC x33,W
0356A:  MOVWF  FEA
0356C:  MOVFF  FEF,A34
03570:  MOVF   FC9,W
03572:  MOVFF  A34,FC9
03576:  RRCF   FC7,W
03578:  BNC   3576
....................    SD_spi_read(value[2]); 
0357A:  MOVLW  02
0357C:  ADDWF  x32,W
0357E:  MOVWF  FE9
03580:  MOVLW  00
03582:  ADDWFC x33,W
03584:  MOVWF  FEA
03586:  MOVFF  FEF,A34
0358A:  MOVF   FC9,W
0358C:  MOVFF  A34,FC9
03590:  RRCF   FC7,W
03592:  BNC   3590
....................    SD_spi_read(value[1]); 
03594:  MOVLW  01
03596:  ADDWF  x32,W
03598:  MOVWF  FE9
0359A:  MOVLW  00
0359C:  ADDWFC x33,W
0359E:  MOVWF  FEA
035A0:  MOVFF  FEF,A34
035A4:  MOVF   FC9,W
035A6:  MOVFF  A34,FC9
035AA:  RRCF   FC7,W
035AC:  BNC   35AA
....................    SD_spi_read(value[0]); 
035AE:  MOVFF  A32,FE9
035B2:  MOVFF  A33,FEA
035B6:  MOVFF  FEF,A34
035BA:  MOVF   FC9,W
035BC:  MOVFF  A34,FC9
035C0:  RRCF   FC7,W
035C2:  BNC   35C0
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
035C4:  MOVF   x2B,W
035C6:  SUBLW  48
035C8:  BNZ   35D6
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
035CA:  MOVF   FC9,W
035CC:  MOVLW  87
035CE:  MOVWF  FC9
035D0:  RRCF   FC7,W
035D2:  BNC   35D0
035D4:  BRA    35E0
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
035D6:  MOVF   FC9,W
035D8:  MOVLW  95
035DA:  MOVWF  FC9
035DC:  RRCF   FC7,W
035DE:  BNC   35DC
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
035E0:  CLRF   x30
....................    response = SD_spi_read(0xFF); 
035E2:  MOVF   FC9,W
035E4:  SETF   FC9
035E6:  RRCF   FC7,W
035E8:  BNC   35E6
035EA:  MOVFF  FC9,A31
....................    while ((response == 0xFF) && (i < 100)) 
035EE:  INCFSZ x31,W
035F0:  BRA    3608
035F2:  MOVF   x30,W
035F4:  SUBLW  63
035F6:  BNC   3608
....................       { 
....................       i++; 
035F8:  INCF   x30,F
....................       response = SD_spi_read(0xFF); 
035FA:  MOVF   FC9,W
035FC:  SETF   FC9
035FE:  RRCF   FC7,W
03600:  BNC   35FE
03602:  MOVFF  FC9,A31
03606:  BRA    35EE
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
03608:  MOVFF  A31,01
0360C:  MOVLB  0
0360E:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
043D4:  MOVLW  50
043D6:  MOVLB  A
043D8:  MOVWF  x2B
043DA:  MOVFF  A2A,A2F
043DE:  MOVFF  A29,A2E
043E2:  MOVFF  A28,A2D
043E6:  MOVFF  A27,A2C
043EA:  MOVLB  0
043EC:  CALL   3540
043F0:  MOVF   01,W
043F2:  BZ    43FA
043F4:  XORLW  40
043F6:  BZ    4410
043F8:  BRA    4416
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
043FA:  MOVFF  A2A,4EC
043FE:  MOVFF  A29,4EB
04402:  MOVFF  A28,4EA
04406:  MOVFF  A27,4E9
....................          return(TRUE); 
0440A:  MOVLW  01
0440C:  MOVWF  01
0440E:  BRA    441A
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
04410:  MOVLW  00
04412:  MOVWF  01
04414:  BRA    441A
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
04416:  MOVLW  00
04418:  MOVWF  01
....................       } 
0441A:  GOTO   44FE (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
0441E:  MOVF   FC9,W
04420:  SETF   FC9
04422:  RRCF   FC7,W
04424:  BNC   4422
04426:  MOVFF  FC9,A2F
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
0442A:  MOVLB  A
0442C:  CLRF   x2E
0442E:  CLRF   x2D
04430:  MOVF   x2E,W
04432:  SUBLW  27
04434:  BNC   445E
04436:  BNZ   443E
04438:  MOVF   x2D,W
0443A:  SUBLW  0F
0443C:  BNC   445E
0443E:  INCFSZ x2F,W
04440:  BRA    445E
....................       { 
....................       delay_us(10); 
04442:  MOVLW  35
04444:  MOVWF  00
04446:  DECFSZ 00,F
04448:  BRA    4446
....................       response = SD_spi_read(0xFF);  
0444A:  MOVF   FC9,W
0444C:  SETF   FC9
0444E:  RRCF   FC7,W
04450:  BNC   444E
04452:  MOVFF  FC9,A2F
04456:  INCF   x2D,F
04458:  BTFSC  FD8.2
0445A:  INCF   x2E,F
0445C:  BRA    4430
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
0445E:  MOVF   x2F,W
04460:  SUBLW  FE
04462:  BZ    4472
....................       { 
....................       if (!response) 
04464:  MOVF   x2F,F
04466:  BNZ   446C
....................          response = 0xFE; 
04468:  MOVLW  FE
0446A:  MOVWF  x2F
....................       return(response); 
0446C:  MOVFF  A2F,01
04470:  BRA    44C8
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
04472:  CLRF   x2E
04474:  CLRF   x2D
04476:  MOVF   x2C,F
04478:  BNZ   448C
0447A:  MOVF   x2B,F
0447C:  BNZ   448C
0447E:  MOVF   x2E,W
04480:  SUBWF  x2A,W
04482:  BNC   44AC
04484:  BNZ   448C
04486:  MOVF   x29,W
04488:  SUBWF  x2D,W
0448A:  BC    44AC
....................       ptr[i]=SD_spi_read(0xFF); 
0448C:  MOVF   x27,W
0448E:  ADDWF  x2D,W
04490:  MOVWF  FE9
04492:  MOVF   x28,W
04494:  ADDWFC x2E,W
04496:  MOVWF  FEA
04498:  MOVF   FC9,W
0449A:  SETF   FC9
0449C:  RRCF   FC7,W
0449E:  BNC   449C
044A0:  MOVFF  FC9,FEF
044A4:  INCF   x2D,F
044A6:  BTFSC  FD8.2
044A8:  INCF   x2E,F
044AA:  BRA    4476
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
044AC:  MOVF   FC9,W
044AE:  SETF   FC9
044B0:  RRCF   FC7,W
044B2:  BNC   44B0
....................    SD_spi_read(0xFF); 
044B4:  MOVF   FC9,W
044B6:  SETF   FC9
044B8:  RRCF   FC7,W
044BA:  BNC   44B8
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
044BC:  MOVF   FC9,W
044BE:  SETF   FC9
044C0:  RRCF   FC7,W
044C2:  BNC   44C0
....................    return(0); 
044C4:  MOVLW  00
044C6:  MOVWF  01
044C8:  MOVLB  0
044CA:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
05846:  MOVLW  C3
05848:  MOVLB  A
0584A:  MOVWF  x2F
0584C:  MOVLW  50
0584E:  MOVWF  x2E
....................    SD_spi_read(0xFF); 
05850:  MOVF   FC9,W
05852:  SETF   FC9
05854:  RRCF   FC7,W
05856:  BNC   5854
....................    do 
....................       { 
....................       delay_us(10); 
05858:  MOVLW  35
0585A:  MOVWF  00
0585C:  DECFSZ 00,F
0585E:  BRA    585C
....................       response = SD_spi_read(0xFF); 
05860:  MOVF   FC9,W
05862:  SETF   FC9
05864:  RRCF   FC7,W
05866:  BNC   5864
05868:  MOVFF  FC9,A2D
....................       Timer--; 
0586C:  MOVF   x2E,W
0586E:  BTFSC  FD8.2
05870:  DECF   x2F,F
05872:  DECF   x2E,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
05874:  INCFSZ x2D,W
05876:  BRA    587A
05878:  BRA    5880
0587A:  MOVF   x2E,W
0587C:  IORWF  x2F,W
0587E:  BNZ   5858
....................       ; 
....................  
....................    return (response); 
05880:  MOVFF  A2D,01
05884:  MOVLB  0
05886:  GOTO   5896 (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
0588A:  MOVLW  02
0588C:  MOVLB  A
0588E:  MOVWF  x2C
05890:  CLRF   x2B
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
05892:  MOVLB  0
05894:  BRA    5846
05896:  INCFSZ 01,W
05898:  BRA    589C
0589A:  BRA    58A2
....................       return (FALSE); 
0589C:  MOVLW  00
0589E:  MOVWF  01
058A0:  BRA    593C
....................  
....................    SD_spi_write(token);               // transmit data token 
058A2:  MOVF   FC9,W
058A4:  MOVFF  A29,FC9
058A8:  RRCF   FC7,W
058AA:  BNC   58A8
....................    if (token != 0xFD) 
058AC:  MOVLB  A
058AE:  MOVF   x29,W
058B0:  SUBLW  FD
058B2:  BZ    5936
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
058B4:  MOVFF  A2C,03
058B8:  MOVF   x2B,W
058BA:  BTFSC  FD8.2
058BC:  DECF   x2C,F
058BE:  DECF   x2B,F
058C0:  IORWF  03,W
058C2:  BZ    58E6
....................          SD_spi_write(*ptr++); 
058C4:  MOVFF  A28,03
058C8:  MOVF   x27,W
058CA:  INCF   x27,F
058CC:  BTFSC  FD8.2
058CE:  INCF   x28,F
058D0:  MOVWF  FE9
058D2:  MOVFF  03,FEA
058D6:  MOVFF  FEF,A2D
058DA:  MOVF   FC9,W
058DC:  MOVFF  A2D,FC9
058E0:  RRCF   FC7,W
058E2:  BNC   58E0
058E4:  BRA    58B4
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
058E6:  MOVF   FC9,W
058E8:  SETF   FC9
058EA:  RRCF   FC7,W
058EC:  BNC   58EA
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
058EE:  MOVF   FC9,W
058F0:  SETF   FC9
058F2:  RRCF   FC7,W
058F4:  BNC   58F2
....................       response = SD_spi_read(0xFF);      // Receive data response 
058F6:  MOVF   FC9,W
058F8:  SETF   FC9
058FA:  RRCF   FC7,W
058FC:  BNC   58FA
058FE:  MOVFF  FC9,A2A
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
05902:  CLRF   x2C
05904:  CLRF   x2B
05906:  MOVF   x2C,W
05908:  SUBLW  C3
0590A:  BNC   5936
0590C:  BNZ   5914
0590E:  MOVF   x2B,W
05910:  SUBLW  4F
05912:  BNC   5936
....................          { 
....................          delay_us(10); 
05914:  MOVLW  35
05916:  MOVWF  00
05918:  DECFSZ 00,F
0591A:  BRA    5918
....................          response = SD_spi_read(0xFF);   // digest prior operation 
0591C:  MOVF   FC9,W
0591E:  SETF   FC9
05920:  RRCF   FC7,W
05922:  BNC   5920
05924:  MOVFF  FC9,A2A
....................          if (response != 0x00) 
05928:  MOVF   x2A,F
0592A:  BZ    592E
....................             break; 
0592C:  BRA    5936
0592E:  INCF   x2B,F
05930:  BTFSC  FD8.2
05932:  INCF   x2C,F
05934:  BRA    5906
....................          } 
....................  
....................       } 
....................    return(TRUE); 
05936:  MOVLW  01
05938:  MOVWF  01
0593A:  MOVLB  0
0593C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
0593E:  MOVLB  4
05940:  BTFSS  xED.0
05942:  BRA    594A
....................       return (RES_NOTRDY); 
05944:  MOVLW  03
05946:  MOVWF  01
05948:  BRA    5A7E
....................  
....................    if (Media_Status & STA_PROTECT) 
0594A:  BTFSS  xED.2
0594C:  BRA    5954
....................       return (RES_WRPRT); 
0594E:  MOVLW  02
05950:  MOVWF  01
05952:  BRA    5A7E
....................  
....................    if (!SectorCount) 
05954:  MOVLB  A
05956:  MOVF   x26,F
05958:  BNZ   5964
....................       return (RES_PARERR); 
0595A:  MOVLW  04
0595C:  MOVWF  01
0595E:  MOVLB  4
05960:  BRA    5A7E
05962:  MOVLB  A
....................  
....................    SelectSD; 
05964:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
05966:  MOVLB  4
05968:  MOVF   xE7,W
0596A:  SUBLW  05
0596C:  BZ    5988
....................       SectorNumber *= 512; 
0596E:  BCF    FD8.0
05970:  MOVFF  A24,A25
05974:  MOVFF  A23,A24
05978:  MOVFF  A22,A23
0597C:  MOVLB  A
0597E:  CLRF   x22
05980:  RLCF   x23,F
05982:  RLCF   x24,F
05984:  RLCF   x25,F
05986:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
05988:  MOVLB  A
0598A:  DECFSZ x26,W
0598C:  BRA    59CC
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
0598E:  MOVLW  58
05990:  MOVWF  x2B
05992:  MOVFF  A25,A2F
05996:  MOVFF  A24,A2E
0599A:  MOVFF  A23,A2D
0599E:  MOVFF  A22,A2C
059A2:  MOVLB  0
059A4:  CALL   3540
059A8:  MOVF   01,F
059AA:  BNZ   59C8
....................          if (SD_write_data(Buffer, 0xFE)) 
059AC:  MOVFF  A21,A28
059B0:  MOVFF  A20,A27
059B4:  MOVLW  FE
059B6:  MOVLB  A
059B8:  MOVWF  x29
059BA:  MOVLB  0
059BC:  RCALL  588A
059BE:  MOVF   01,F
059C0:  BZ    59C8
....................             SectorCount = 0; 
059C2:  MOVLB  A
059C4:  CLRF   x26
059C6:  MOVLB  0
....................       } 
059C8:  BRA    5A64
059CA:  MOVLB  A
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
059CC:  MOVLB  4
059CE:  MOVF   xE7,W
059D0:  ANDLW  03
059D2:  BZ    5A00
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
059D4:  MOVLW  77
059D6:  MOVLB  A
059D8:  MOVWF  x2B
059DA:  CLRF   x2F
059DC:  CLRF   x2E
059DE:  CLRF   x2D
059E0:  CLRF   x2C
059E2:  MOVLB  0
059E4:  CALL   3540
....................          SD_cmd(SD_ACMD23, SectorCount); 
059E8:  MOVLW  57
059EA:  MOVLB  A
059EC:  MOVWF  x2B
059EE:  CLRF   x2F
059F0:  CLRF   x2E
059F2:  CLRF   x2D
059F4:  MOVFF  A26,A2C
059F8:  MOVLB  0
059FA:  CALL   3540
059FE:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05A00:  MOVLW  59
05A02:  MOVLB  A
05A04:  MOVWF  x2B
05A06:  MOVFF  A25,A2F
05A0A:  MOVFF  A24,A2E
05A0E:  MOVFF  A23,A2D
05A12:  MOVFF  A22,A2C
05A16:  MOVLB  0
05A18:  CALL   3540
05A1C:  MOVF   01,F
05A1E:  BNZ   5A64
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
05A20:  MOVFF  A21,A28
05A24:  MOVFF  A20,A27
05A28:  MOVLW  FC
05A2A:  MOVLB  A
05A2C:  MOVWF  x29
05A2E:  MOVLB  0
05A30:  RCALL  588A
05A32:  MOVF   01,F
05A34:  BNZ   5A38
....................                break; 
05A36:  BRA    5A4A
....................             Buffer += 512; 
05A38:  MOVLW  02
05A3A:  MOVLB  A
05A3C:  ADDWF  x21,F
....................             } while (--SectorCount); 
05A3E:  DECF   x26,F
05A40:  BTFSC  FD8.2
05A42:  BRA    5A48
05A44:  MOVLB  0
05A46:  BRA    5A20
05A48:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
05A4A:  MOVLB  A
05A4C:  CLRF   x28
05A4E:  CLRF   x27
05A50:  MOVLW  FD
05A52:  MOVWF  x29
05A54:  MOVLB  0
05A56:  RCALL  588A
05A58:  MOVF   01,F
05A5A:  BNZ   5A64
....................             SectorCount = 1; 
05A5C:  MOVLW  01
05A5E:  MOVLB  A
05A60:  MOVWF  x26
05A62:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
05A64:  BSF    F91.1
....................    SD_spi_read(0xFF); 
05A66:  MOVF   FC9,W
05A68:  SETF   FC9
05A6A:  RRCF   FC7,W
05A6C:  BNC   5A6A
....................    return SectorCount ? RES_ERROR : RES_OK; 
05A6E:  MOVLB  A
05A70:  MOVF   x26,F
05A72:  BZ    5A78
05A74:  MOVLW  01
05A76:  BRA    5A7A
05A78:  MOVLW  00
05A7A:  MOVWF  01
05A7C:  MOVLB  4
05A7E:  MOVLB  0
05A80:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
044CC:  MOVLB  4
044CE:  BTFSS  xED.0
044D0:  BRA    44D8
....................       return (RES_NOTRDY); 
044D2:  MOVLW  03
044D4:  MOVWF  01
044D6:  BRA    4608
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
044D8:  MOVLB  A
044DA:  MOVF   x26,W
044DC:  SUBLW  01
044DE:  BNC   44E4
044E0:  MOVF   x26,F
044E2:  BNZ   44EE
....................       return(RES_PARERR); 
044E4:  MOVLW  04
044E6:  MOVWF  01
044E8:  MOVLB  4
044EA:  BRA    4608
044EC:  MOVLB  A
....................  
....................    SelectSD; 
044EE:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
044F0:  CLRF   x2A
044F2:  CLRF   x29
044F4:  MOVLW  02
044F6:  MOVWF  x28
044F8:  CLRF   x27
044FA:  MOVLB  0
044FC:  BRA    43D4
044FE:  MOVF   01,F
04500:  BNZ   450E
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
04502:  BSF    F91.1
....................       return(RES_ERROR); 
04504:  MOVLW  01
04506:  MOVWF  01
04508:  MOVLB  4
0450A:  BRA    4608
0450C:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
0450E:  MOVLB  4
04510:  MOVF   xE7,W
04512:  SUBLW  05
04514:  BZ    4530
....................       SectorNumber *= 512; 
04516:  BCF    FD8.0
04518:  MOVFF  A24,A25
0451C:  MOVFF  A23,A24
04520:  MOVFF  A22,A23
04524:  MOVLB  A
04526:  CLRF   x22
04528:  RLCF   x23,F
0452A:  RLCF   x24,F
0452C:  RLCF   x25,F
0452E:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
04530:  MOVLB  A
04532:  DECFSZ x26,W
04534:  BRA    458C
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
04536:  MOVLW  51
04538:  MOVWF  x2B
0453A:  MOVFF  A25,A2F
0453E:  MOVFF  A24,A2E
04542:  MOVFF  A23,A2D
04546:  MOVFF  A22,A2C
0454A:  MOVLB  0
0454C:  CALL   3540
04550:  MOVF   01,F
04552:  BZ    4560
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
04554:  BSF    F91.1
....................          return(RES_PARERR); 
04556:  MOVLW  04
04558:  MOVWF  01
0455A:  MOVLB  4
0455C:  BRA    4608
0455E:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
04560:  MOVFF  A21,A28
04564:  MOVFF  A20,A27
04568:  MOVLB  A
0456A:  CLRF   x2C
0456C:  CLRF   x2B
0456E:  MOVLW  02
04570:  MOVWF  x2A
04572:  CLRF   x29
04574:  MOVLB  0
04576:  RCALL  441E
04578:  MOVF   01,F
0457A:  BZ    4588
....................          { 
....................          DeselectSD; 
0457C:  BSF    F91.1
....................          return(RES_ERROR); 
0457E:  MOVLW  01
04580:  MOVWF  01
04582:  MOVLB  4
04584:  BRA    4608
04586:  MOVLB  0
....................          } 
....................       } 
04588:  BRA    4600
0458A:  MOVLB  A
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
0458C:  MOVLW  52
0458E:  MOVWF  x2B
04590:  MOVFF  A25,A2F
04594:  MOVFF  A24,A2E
04598:  MOVFF  A23,A2D
0459C:  MOVFF  A22,A2C
045A0:  MOVLB  0
045A2:  CALL   3540
045A6:  MOVF   01,F
045A8:  BZ    45B6
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
045AA:  BSF    F91.1
....................          return(RES_PARERR); 
045AC:  MOVLW  04
045AE:  MOVWF  01
045B0:  MOVLB  4
045B2:  BRA    4608
045B4:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
045B6:  MOVFF  A21,A28
045BA:  MOVFF  A20,A27
045BE:  MOVLB  A
045C0:  CLRF   x2C
045C2:  CLRF   x2B
045C4:  MOVLW  02
045C6:  MOVWF  x2A
045C8:  CLRF   x29
045CA:  MOVLB  0
045CC:  RCALL  441E
045CE:  MOVF   01,F
045D0:  BZ    45DE
....................             { 
....................             DeselectSD; 
045D2:  BSF    F91.1
....................             return(RES_ERROR); 
045D4:  MOVLW  01
045D6:  MOVWF  01
045D8:  MOVLB  4
045DA:  BRA    4608
045DC:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
045DE:  MOVLW  02
045E0:  MOVLB  A
045E2:  ADDWF  x21,F
....................          } while (--SectorCount); 
045E4:  DECF   x26,F
045E6:  BTFSC  FD8.2
045E8:  BRA    45EE
045EA:  MOVLB  0
045EC:  BRA    45B6
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
045EE:  MOVLW  4C
045F0:  MOVWF  x2B
045F2:  CLRF   x2F
045F4:  CLRF   x2E
045F6:  CLRF   x2D
045F8:  CLRF   x2C
045FA:  MOVLB  0
045FC:  CALL   3540
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
04600:  BSF    F91.1
....................    return(RES_OK); 
04602:  MOVLW  00
04604:  MOVWF  01
04606:  MOVLB  4
04608:  MOVLB  0
0460A:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
0559E:  MOVLB  4
055A0:  BCF    xED.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
055A2:  BCF    xED.2
....................  
....................    return(Media_Status); 
055A4:  MOVFF  4ED,01
055A8:  MOVLB  0
055AA:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
03676:  MOVLB  9
03678:  CLRF   xEB
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
0367A:  MOVLB  4
0367C:  CLRF   xE7
....................  
....................    DeselectSD; 
0367E:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
03680:  MOVLW  0A
03682:  MOVLB  9
03684:  MOVWF  xEC
03686:  MOVLB  0
03688:  CALL   2910
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
0368C:  BCF    FC6.5
0368E:  MOVLW  22
03690:  MOVWF  FC6
03692:  MOVLW  40
03694:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
03696:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
03698:  MOVLB  9
0369A:  CLRF   xE3
0369C:  MOVF   xE3,W
0369E:  SUBLW  09
036A0:  BNC   36AE
....................       SD_spi_read(0xFF); 
036A2:  MOVF   FC9,W
036A4:  SETF   FC9
036A6:  RRCF   FC7,W
036A8:  BNC   36A6
036AA:  INCF   xE3,F
036AC:  BRA    369C
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
036AE:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
036B0:  MOVF   1F,W
036B2:  SUBLW  04
036B4:  BNZ   36DA
036B6:  MOVF   20,F
036B8:  BNZ   36DA
036BA:  MOVLW  7A
036BC:  MOVWF  FF6
036BE:  MOVLW  06
036C0:  MOVWF  FF7
036C2:  MOVLW  00
036C4:  MOVWF  FF8
036C6:  CLRF   1B
036C8:  BTFSC  FF2.7
036CA:  BSF    1B.7
036CC:  BCF    FF2.7
036CE:  MOVLB  0
036D0:  CALL   0E46
036D4:  BTFSC  1B.7
036D6:  BSF    FF2.7
036D8:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
036DA:  MOVLW  40
036DC:  MOVLB  A
036DE:  MOVWF  x2B
036E0:  CLRF   x2F
036E2:  CLRF   x2E
036E4:  CLRF   x2D
036E6:  CLRF   x2C
036E8:  MOVLB  0
036EA:  RCALL  3540
036EC:  MOVFF  01,9E4
....................    if (response > 1 ) 
036F0:  MOVLB  9
036F2:  MOVF   xE4,W
036F4:  SUBLW  01
036F6:  BC    374C
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
036F8:  MOVF   1F,W
036FA:  SUBLW  04
036FC:  BNZ   3746
036FE:  MOVF   20,F
03700:  BNZ   3746
03702:  MOVLW  8A
03704:  MOVWF  FF6
03706:  MOVLW  06
03708:  MOVWF  FF7
0370A:  MOVLW  00
0370C:  MOVWF  FF8
0370E:  CLRF   1B
03710:  BTFSC  FF2.7
03712:  BSF    1B.7
03714:  BCF    FF2.7
03716:  MOVLW  31
03718:  MOVLB  A
0371A:  MOVWF  x40
0371C:  MOVLB  0
0371E:  CALL   101C
03722:  BTFSC  1B.7
03724:  BSF    FF2.7
03726:  MOVFF  9E4,9EC
0372A:  MOVLW  57
0372C:  MOVLB  9
0372E:  MOVWF  xED
03730:  MOVLB  0
03732:  RCALL  3610
03734:  MOVLW  0D
03736:  BTFSS  F9E.4
03738:  BRA    3736
0373A:  MOVWF  FAD
0373C:  MOVLW  0A
0373E:  BTFSS  F9E.4
03740:  BRA    373E
03742:  MOVWF  FAD
03744:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
03746:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
03748:  GOTO   43CA
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
0374C:  MOVF   1F,W
0374E:  SUBLW  04
03750:  BNZ   379A
03752:  MOVF   20,F
03754:  BNZ   379A
03756:  MOVLW  C2
03758:  MOVWF  FF6
0375A:  MOVLW  06
0375C:  MOVWF  FF7
0375E:  MOVLW  00
03760:  MOVWF  FF8
03762:  CLRF   1B
03764:  BTFSC  FF2.7
03766:  BSF    1B.7
03768:  BCF    FF2.7
0376A:  MOVLW  1A
0376C:  MOVLB  A
0376E:  MOVWF  x40
03770:  MOVLB  0
03772:  CALL   101C
03776:  BTFSC  1B.7
03778:  BSF    FF2.7
0377A:  MOVFF  9E4,9EC
0377E:  MOVLW  57
03780:  MOVLB  9
03782:  MOVWF  xED
03784:  MOVLB  0
03786:  RCALL  3610
03788:  MOVLW  0D
0378A:  BTFSS  F9E.4
0378C:  BRA    378A
0378E:  MOVWF  FAD
03790:  MOVLW  0A
03792:  BTFSS  F9E.4
03794:  BRA    3792
03796:  MOVWF  FAD
03798:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
0379A:  MOVLW  48
0379C:  MOVLB  A
0379E:  MOVWF  x2B
037A0:  CLRF   x2F
037A2:  CLRF   x2E
037A4:  MOVLW  01
037A6:  MOVWF  x2D
037A8:  MOVLW  AA
037AA:  MOVWF  x2C
037AC:  MOVLB  0
037AE:  RCALL  3540
037B0:  MOVFF  01,9E4
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
037B4:  MOVF   1F,W
037B6:  SUBLW  04
037B8:  BNZ   3800
037BA:  MOVF   20,F
037BC:  BNZ   3800
037BE:  MOVLW  E4
037C0:  MOVWF  FF6
037C2:  MOVLW  06
037C4:  MOVWF  FF7
037C6:  MOVLW  00
037C8:  MOVWF  FF8
037CA:  CLRF   1B
037CC:  BTFSC  FF2.7
037CE:  BSF    1B.7
037D0:  BCF    FF2.7
037D2:  MOVLW  25
037D4:  MOVLB  A
037D6:  MOVWF  x40
037D8:  MOVLB  0
037DA:  CALL   101C
037DE:  BTFSC  1B.7
037E0:  BSF    FF2.7
037E2:  MOVFF  9E4,9EC
037E6:  MOVLW  57
037E8:  MOVLB  9
037EA:  MOVWF  xED
037EC:  MOVLB  0
037EE:  RCALL  3610
037F0:  MOVLW  0D
037F2:  BTFSS  F9E.4
037F4:  BRA    37F2
037F6:  MOVWF  FAD
037F8:  MOVLW  0A
037FA:  BTFSS  F9E.4
037FC:  BRA    37FA
037FE:  MOVWF  FAD
....................    if (response == 1)  
03800:  MOVLB  9
03802:  DECFSZ xE4,W
03804:  BRA    3BD6
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
03806:  MOVF   1F,W
03808:  SUBLW  04
0380A:  BNZ   3830
0380C:  MOVF   20,F
0380E:  BNZ   3830
03810:  MOVLW  0E
03812:  MOVWF  FF6
03814:  MOVLW  07
03816:  MOVWF  FF7
03818:  MOVLW  00
0381A:  MOVWF  FF8
0381C:  CLRF   1B
0381E:  BTFSC  FF2.7
03820:  BSF    1B.7
03822:  BCF    FF2.7
03824:  MOVLB  0
03826:  CALL   0E46
0382A:  BTFSC  1B.7
0382C:  BSF    FF2.7
0382E:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
03830:  CLRF   xE3
03832:  MOVF   xE3,W
03834:  SUBLW  03
03836:  BNC   3856
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
03838:  CLRF   03
0383A:  MOVF   xE3,W
0383C:  ADDLW  E5
0383E:  MOVWF  FE9
03840:  MOVLW  09
03842:  ADDWFC 03,W
03844:  MOVWF  FEA
03846:  MOVF   FC9,W
03848:  SETF   FC9
0384A:  RRCF   FC7,W
0384C:  BNC   384A
0384E:  MOVFF  FC9,FEF
03852:  INCF   xE3,F
03854:  BRA    3832
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
03856:  MOVF   1F,W
03858:  SUBLW  04
0385A:  BNZ   38CE
0385C:  MOVF   20,F
0385E:  BNZ   38CE
03860:  MOVLW  30
03862:  MOVWF  FF6
03864:  MOVLW  07
03866:  MOVWF  FF7
03868:  MOVLW  00
0386A:  MOVWF  FF8
0386C:  CLRF   1B
0386E:  BTFSC  FF2.7
03870:  BSF    1B.7
03872:  BCF    FF2.7
03874:  MOVLW  1F
03876:  MOVLB  A
03878:  MOVWF  x40
0387A:  MOVLB  0
0387C:  CALL   101C
03880:  BTFSC  1B.7
03882:  BSF    FF2.7
03884:  MOVFF  9E5,9EC
03888:  MOVLW  57
0388A:  MOVLB  9
0388C:  MOVWF  xED
0388E:  MOVLB  0
03890:  RCALL  3610
03892:  MOVFF  9E6,9EC
03896:  MOVLW  57
03898:  MOVLB  9
0389A:  MOVWF  xED
0389C:  MOVLB  0
0389E:  RCALL  3610
038A0:  MOVFF  9E7,9EC
038A4:  MOVLW  57
038A6:  MOVLB  9
038A8:  MOVWF  xED
038AA:  MOVLB  0
038AC:  RCALL  3610
038AE:  MOVFF  9E8,9EC
038B2:  MOVLW  57
038B4:  MOVLB  9
038B6:  MOVWF  xED
038B8:  MOVLB  0
038BA:  RCALL  3610
038BC:  MOVLW  0D
038BE:  BTFSS  F9E.4
038C0:  BRA    38BE
038C2:  MOVWF  FAD
038C4:  MOVLW  0A
038C6:  BTFSS  F9E.4
038C8:  BRA    38C6
038CA:  MOVWF  FAD
038CC:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
038CE:  DECFSZ xE7,W
038D0:  BRA    3BAC
038D2:  MOVF   xE8,W
038D4:  SUBLW  AA
038D6:  BTFSS  FD8.2
038D8:  BRA    3BAC
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
038DA:  MOVF   1F,W
038DC:  SUBLW  04
038DE:  BNZ   3904
038E0:  MOVF   20,F
038E2:  BNZ   3904
038E4:  MOVLW  62
038E6:  MOVWF  FF6
038E8:  MOVLW  07
038EA:  MOVWF  FF7
038EC:  MOVLW  00
038EE:  MOVWF  FF8
038F0:  CLRF   1B
038F2:  BTFSC  FF2.7
038F4:  BSF    1B.7
038F6:  BCF    FF2.7
038F8:  MOVLB  0
038FA:  CALL   0E46
038FE:  BTFSC  1B.7
03900:  BSF    FF2.7
03902:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
03904:  MOVF   1F,W
03906:  SUBLW  04
03908:  BNZ   392E
0390A:  MOVF   20,F
0390C:  BNZ   392E
0390E:  MOVLW  88
03910:  MOVWF  FF6
03912:  MOVLW  07
03914:  MOVWF  FF7
03916:  MOVLW  00
03918:  MOVWF  FF8
0391A:  CLRF   1B
0391C:  BTFSC  FF2.7
0391E:  BSF    1B.7
03920:  BCF    FF2.7
03922:  MOVLB  0
03924:  CALL   0E46
03928:  BTFSC  1B.7
0392A:  BSF    FF2.7
0392C:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
0392E:  CLRF   xEA
03930:  CLRF   xE9
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
03932:  MOVLW  77
03934:  MOVLB  A
03936:  MOVWF  x2B
03938:  CLRF   x2F
0393A:  CLRF   x2E
0393C:  CLRF   x2D
0393E:  CLRF   x2C
03940:  MOVLB  0
03942:  RCALL  3540
03944:  MOVFF  01,9E4
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
03948:  MOVLW  69
0394A:  MOVLB  A
0394C:  MOVWF  x2B
0394E:  MOVLW  40
03950:  MOVWF  x2F
03952:  CLRF   x2E
03954:  CLRF   x2D
03956:  CLRF   x2C
03958:  MOVLB  0
0395A:  RCALL  3540
0395C:  MOVFF  01,9E4
....................          while (response && (Timer < 50000)) 
03960:  MOVLB  9
03962:  MOVF   xE4,F
03964:  BZ    39B6
03966:  MOVF   xEA,W
03968:  SUBLW  C3
0396A:  BNC   39B6
0396C:  BNZ   3974
0396E:  MOVF   xE9,W
03970:  SUBLW  4F
03972:  BNC   39B6
....................          { 
....................             delay_us(20); 
03974:  MOVLW  6A
03976:  MOVWF  00
03978:  DECFSZ 00,F
0397A:  BRA    3978
0397C:  NOP   
....................             Timer++; 
0397E:  INCF   xE9,F
03980:  BTFSC  FD8.2
03982:  INCF   xEA,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
03984:  MOVLW  77
03986:  MOVLB  A
03988:  MOVWF  x2B
0398A:  CLRF   x2F
0398C:  CLRF   x2E
0398E:  CLRF   x2D
03990:  CLRF   x2C
03992:  MOVLB  0
03994:  RCALL  3540
03996:  MOVFF  01,9E4
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
0399A:  MOVLW  69
0399C:  MOVLB  A
0399E:  MOVWF  x2B
039A0:  MOVLW  40
039A2:  MOVWF  x2F
039A4:  CLRF   x2E
039A6:  CLRF   x2D
039A8:  CLRF   x2C
039AA:  MOVLB  0
039AC:  RCALL  3540
039AE:  MOVFF  01,9E4
039B2:  BRA    3960
039B4:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
039B6:  MOVF   1F,W
039B8:  SUBLW  04
039BA:  BNZ   3A44
039BC:  MOVF   20,F
039BE:  BNZ   3A44
039C0:  MOVLW  B6
039C2:  MOVWF  FF6
039C4:  MOVLW  07
039C6:  MOVWF  FF7
039C8:  MOVLW  00
039CA:  MOVWF  FF8
039CC:  CLRF   1B
039CE:  BTFSC  FF2.7
039D0:  BSF    1B.7
039D2:  BCF    FF2.7
039D4:  MOVLW  23
039D6:  MOVLB  A
039D8:  MOVWF  x40
039DA:  MOVLB  0
039DC:  CALL   101C
039E0:  BTFSC  1B.7
039E2:  BSF    FF2.7
039E4:  MOVFF  9E4,9EC
039E8:  MOVLW  57
039EA:  MOVLB  9
039EC:  MOVWF  xED
039EE:  MOVLB  0
039F0:  RCALL  3610
039F2:  MOVLW  DD
039F4:  MOVWF  FF6
039F6:  MOVLW  07
039F8:  MOVWF  FF7
039FA:  MOVLW  00
039FC:  MOVWF  FF8
039FE:  CLRF   1B
03A00:  BTFSC  FF2.7
03A02:  BSF    1B.7
03A04:  BCF    FF2.7
03A06:  MOVLW  0A
03A08:  MOVLB  A
03A0A:  MOVWF  x40
03A0C:  MOVLB  0
03A0E:  CALL   101C
03A12:  BTFSC  1B.7
03A14:  BSF    FF2.7
03A16:  MOVLW  10
03A18:  MOVWF  FE9
03A1A:  CLRF   1B
03A1C:  BTFSC  FF2.7
03A1E:  BSF    1B.7
03A20:  BCF    FF2.7
03A22:  MOVFF  9EA,A41
03A26:  MOVFF  9E9,A40
03A2A:  CALL   119E
03A2E:  BTFSC  1B.7
03A30:  BSF    FF2.7
03A32:  MOVLW  0D
03A34:  BTFSS  F9E.4
03A36:  BRA    3A34
03A38:  MOVWF  FAD
03A3A:  MOVLW  0A
03A3C:  BTFSS  F9E.4
03A3E:  BRA    3A3C
03A40:  MOVWF  FAD
03A42:  MOVLB  9
....................          if (!response) 
03A44:  MOVF   xE4,F
03A46:  BTFSS  FD8.2
03A48:  BRA    3BAA
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
03A4A:  MOVLW  7A
03A4C:  MOVLB  A
03A4E:  MOVWF  x2B
03A50:  MOVLW  40
03A52:  MOVWF  x2F
03A54:  CLRF   x2E
03A56:  CLRF   x2D
03A58:  CLRF   x2C
03A5A:  MOVLB  0
03A5C:  RCALL  3540
03A5E:  MOVFF  01,9E4
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
03A62:  MOVF   1F,W
03A64:  SUBLW  04
03A66:  BNZ   3AAE
03A68:  MOVF   20,F
03A6A:  BNZ   3AAE
03A6C:  MOVLW  EE
03A6E:  MOVWF  FF6
03A70:  MOVLW  07
03A72:  MOVWF  FF7
03A74:  MOVLW  00
03A76:  MOVWF  FF8
03A78:  CLRF   1B
03A7A:  BTFSC  FF2.7
03A7C:  BSF    1B.7
03A7E:  BCF    FF2.7
03A80:  MOVLW  18
03A82:  MOVLB  A
03A84:  MOVWF  x40
03A86:  MOVLB  0
03A88:  CALL   101C
03A8C:  BTFSC  1B.7
03A8E:  BSF    FF2.7
03A90:  MOVFF  9E4,9EC
03A94:  MOVLW  57
03A96:  MOVLB  9
03A98:  MOVWF  xED
03A9A:  MOVLB  0
03A9C:  RCALL  3610
03A9E:  MOVLW  0D
03AA0:  BTFSS  F9E.4
03AA2:  BRA    3AA0
03AA4:  MOVWF  FAD
03AA6:  MOVLW  0A
03AA8:  BTFSS  F9E.4
03AAA:  BRA    3AA8
03AAC:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03AAE:  MOVLB  9
03AB0:  MOVF   xE4,F
03AB2:  BTFSS  FD8.2
03AB4:  BRA    3BAA
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03AB6:  CLRF   xE3
03AB8:  MOVF   xE3,W
03ABA:  SUBLW  03
03ABC:  BNC   3ADC
....................                   ocr[i] = SD_spi_read(0xFF); 
03ABE:  CLRF   03
03AC0:  MOVF   xE3,W
03AC2:  ADDLW  E5
03AC4:  MOVWF  FE9
03AC6:  MOVLW  09
03AC8:  ADDWFC 03,W
03ACA:  MOVWF  FEA
03ACC:  MOVF   FC9,W
03ACE:  SETF   FC9
03AD0:  RRCF   FC7,W
03AD2:  BNC   3AD0
03AD4:  MOVFF  FC9,FEF
03AD8:  INCF   xE3,F
03ADA:  BRA    3AB8
....................                if (ocr[0] & 0x40) 
03ADC:  BTFSS  xE5.6
03ADE:  BRA    3AEA
....................                   Card = SDHC; 
03AE0:  MOVLW  05
03AE2:  MOVLB  4
03AE4:  MOVWF  xE7
03AE6:  BRA    3AF0
03AE8:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03AEA:  MOVLW  04
03AEC:  MOVLB  4
03AEE:  MOVWF  xE7
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03AF0:  MOVF   1F,W
03AF2:  SUBLW  04
03AF4:  BNZ   3BA8
03AF6:  MOVF   20,F
03AF8:  BNZ   3BA8
03AFA:  MOVLW  0C
03AFC:  MOVWF  FF6
03AFE:  MOVLW  08
03B00:  MOVWF  FF7
03B02:  MOVLW  00
03B04:  MOVWF  FF8
03B06:  CLRF   1B
03B08:  BTFSC  FF2.7
03B0A:  BSF    1B.7
03B0C:  BCF    FF2.7
03B0E:  MOVLW  1F
03B10:  MOVLB  A
03B12:  MOVWF  x40
03B14:  MOVLB  0
03B16:  CALL   101C
03B1A:  BTFSC  1B.7
03B1C:  BSF    FF2.7
03B1E:  MOVLW  10
03B20:  MOVWF  FE9
03B22:  CLRF   1B
03B24:  BTFSC  FF2.7
03B26:  BSF    1B.7
03B28:  BCF    FF2.7
03B2A:  MOVFF  9EA,A41
03B2E:  MOVFF  9E9,A40
03B32:  CALL   119E
03B36:  BTFSC  1B.7
03B38:  BSF    FF2.7
03B3A:  MOVLW  2E
03B3C:  MOVWF  FF6
03B3E:  MOVLW  08
03B40:  MOVWF  FF7
03B42:  MOVLW  00
03B44:  MOVWF  FF8
03B46:  CLRF   1B
03B48:  BTFSC  FF2.7
03B4A:  BSF    1B.7
03B4C:  BCF    FF2.7
03B4E:  MOVLW  08
03B50:  MOVLB  A
03B52:  MOVWF  x40
03B54:  MOVLB  0
03B56:  CALL   101C
03B5A:  BTFSC  1B.7
03B5C:  BSF    FF2.7
03B5E:  MOVFF  9E5,9EC
03B62:  MOVLW  57
03B64:  MOVLB  9
03B66:  MOVWF  xED
03B68:  MOVLB  0
03B6A:  RCALL  3610
03B6C:  MOVFF  9E6,9EC
03B70:  MOVLW  57
03B72:  MOVLB  9
03B74:  MOVWF  xED
03B76:  MOVLB  0
03B78:  RCALL  3610
03B7A:  MOVFF  9E7,9EC
03B7E:  MOVLW  57
03B80:  MOVLB  9
03B82:  MOVWF  xED
03B84:  MOVLB  0
03B86:  RCALL  3610
03B88:  MOVFF  9E8,9EC
03B8C:  MOVLW  57
03B8E:  MOVLB  9
03B90:  MOVWF  xED
03B92:  MOVLB  0
03B94:  RCALL  3610
03B96:  MOVLW  0D
03B98:  BTFSS  F9E.4
03B9A:  BRA    3B98
03B9C:  MOVWF  FAD
03B9E:  MOVLW  0A
03BA0:  BTFSS  F9E.4
03BA2:  BRA    3BA0
03BA4:  MOVWF  FAD
03BA6:  MOVLB  4
03BA8:  MOVLB  9
....................             } 
....................          } 
....................       } 
03BAA:  BRA    3BD6
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03BAC:  MOVF   1F,W
03BAE:  SUBLW  04
03BB0:  BNZ   3BD6
03BB2:  MOVF   20,F
03BB4:  BNZ   3BD6
03BB6:  MOVLW  4A
03BB8:  MOVWF  FF6
03BBA:  MOVLW  08
03BBC:  MOVWF  FF7
03BBE:  MOVLW  00
03BC0:  MOVWF  FF8
03BC2:  CLRF   1B
03BC4:  BTFSC  FF2.7
03BC6:  BSF    1B.7
03BC8:  BCF    FF2.7
03BCA:  MOVLB  0
03BCC:  CALL   0E46
03BD0:  BTFSC  1B.7
03BD2:  BSF    FF2.7
03BD4:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03BD6:  MOVLB  4
03BD8:  MOVF   xE7,F
03BDA:  BTFSS  FD8.2
03BDC:  BRA    40AC
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03BDE:  MOVF   1F,W
03BE0:  SUBLW  04
03BE2:  BNZ   3C08
03BE4:  MOVF   20,F
03BE6:  BNZ   3C08
03BE8:  MOVLW  7C
03BEA:  MOVWF  FF6
03BEC:  MOVLW  08
03BEE:  MOVWF  FF7
03BF0:  MOVLW  00
03BF2:  MOVWF  FF8
03BF4:  CLRF   1B
03BF6:  BTFSC  FF2.7
03BF8:  BSF    1B.7
03BFA:  BCF    FF2.7
03BFC:  MOVLB  0
03BFE:  CALL   0E46
03C02:  BTFSC  1B.7
03C04:  BSF    FF2.7
03C06:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03C08:  MOVLW  40
03C0A:  MOVLB  A
03C0C:  MOVWF  x2B
03C0E:  CLRF   x2F
03C10:  CLRF   x2E
03C12:  CLRF   x2D
03C14:  CLRF   x2C
03C16:  MOVLB  0
03C18:  RCALL  3540
03C1A:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03C1E:  MOVF   1F,W
03C20:  SUBLW  04
03C22:  BNZ   3C6A
03C24:  MOVF   20,F
03C26:  BNZ   3C6A
03C28:  MOVLW  BC
03C2A:  MOVWF  FF6
03C2C:  MOVLW  08
03C2E:  MOVWF  FF7
03C30:  MOVLW  00
03C32:  MOVWF  FF8
03C34:  CLRF   1B
03C36:  BTFSC  FF2.7
03C38:  BSF    1B.7
03C3A:  BCF    FF2.7
03C3C:  MOVLW  1C
03C3E:  MOVLB  A
03C40:  MOVWF  x40
03C42:  MOVLB  0
03C44:  CALL   101C
03C48:  BTFSC  1B.7
03C4A:  BSF    FF2.7
03C4C:  MOVFF  9E4,9EC
03C50:  MOVLW  57
03C52:  MOVLB  9
03C54:  MOVWF  xED
03C56:  MOVLB  0
03C58:  RCALL  3610
03C5A:  MOVLW  0D
03C5C:  BTFSS  F9E.4
03C5E:  BRA    3C5C
03C60:  MOVWF  FAD
03C62:  MOVLW  0A
03C64:  BTFSS  F9E.4
03C66:  BRA    3C64
03C68:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03C6A:  MOVLB  9
03C6C:  DECFSZ xE4,W
03C6E:  BRA    3C72
03C70:  BRA    3C7C
03C72:  MOVF   xE4,F
03C74:  BZ    3C7C
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03C76:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03C78:  GOTO   43CA
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03C7C:  CLRF   xEA
03C7E:  CLRF   xE9
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03C80:  MOVLW  41
03C82:  MOVLB  A
03C84:  MOVWF  x2B
03C86:  CLRF   x2F
03C88:  CLRF   x2E
03C8A:  CLRF   x2D
03C8C:  CLRF   x2C
03C8E:  MOVLB  0
03C90:  RCALL  3540
03C92:  MOVFF  01,9E4
....................          if (response != 0x00 ) 
03C96:  MOVLB  9
03C98:  MOVF   xE4,F
03C9A:  BZ    3CA4
....................             delay_us(10); 
03C9C:  MOVLW  35
03C9E:  MOVWF  00
03CA0:  DECFSZ 00,F
03CA2:  BRA    3CA0
....................          Timer++; 
03CA4:  INCF   xE9,F
03CA6:  BTFSC  FD8.2
03CA8:  INCF   xEA,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03CAA:  MOVF   xE4,F
03CAC:  BZ    3CBC
03CAE:  MOVF   xEA,W
03CB0:  SUBLW  C3
03CB2:  BNC   3CBC
03CB4:  BNZ   3C80
03CB6:  MOVF   xE9,W
03CB8:  SUBLW  4F
03CBA:  BC    3C80
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03CBC:  MOVF   1F,W
03CBE:  SUBLW  04
03CC0:  BNZ   3D4A
03CC2:  MOVF   20,F
03CC4:  BNZ   3D4A
03CC6:  MOVLW  E0
03CC8:  MOVWF  FF6
03CCA:  MOVLW  08
03CCC:  MOVWF  FF7
03CCE:  MOVLW  00
03CD0:  MOVWF  FF8
03CD2:  CLRF   1B
03CD4:  BTFSC  FF2.7
03CD6:  BSF    1B.7
03CD8:  BCF    FF2.7
03CDA:  MOVLW  28
03CDC:  MOVLB  A
03CDE:  MOVWF  x40
03CE0:  MOVLB  0
03CE2:  CALL   101C
03CE6:  BTFSC  1B.7
03CE8:  BSF    FF2.7
03CEA:  MOVFF  9E4,9EC
03CEE:  MOVLW  57
03CF0:  MOVLB  9
03CF2:  MOVWF  xED
03CF4:  MOVLB  0
03CF6:  RCALL  3610
03CF8:  MOVLW  0C
03CFA:  MOVWF  FF6
03CFC:  MOVLW  09
03CFE:  MOVWF  FF7
03D00:  MOVLW  00
03D02:  MOVWF  FF8
03D04:  CLRF   1B
03D06:  BTFSC  FF2.7
03D08:  BSF    1B.7
03D0A:  BCF    FF2.7
03D0C:  MOVLW  0A
03D0E:  MOVLB  A
03D10:  MOVWF  x40
03D12:  MOVLB  0
03D14:  CALL   101C
03D18:  BTFSC  1B.7
03D1A:  BSF    FF2.7
03D1C:  MOVLW  10
03D1E:  MOVWF  FE9
03D20:  CLRF   1B
03D22:  BTFSC  FF2.7
03D24:  BSF    1B.7
03D26:  BCF    FF2.7
03D28:  MOVFF  9EA,A41
03D2C:  MOVFF  9E9,A40
03D30:  CALL   119E
03D34:  BTFSC  1B.7
03D36:  BSF    FF2.7
03D38:  MOVLW  0D
03D3A:  BTFSS  F9E.4
03D3C:  BRA    3D3A
03D3E:  MOVWF  FAD
03D40:  MOVLW  0A
03D42:  BTFSS  F9E.4
03D44:  BRA    3D42
03D46:  MOVWF  FAD
03D48:  MOVLB  9
....................       if(response) 
03D4A:  MOVF   xE4,F
03D4C:  BZ    3D52
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03D4E:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03D50:  BRA    43CA
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03D52:  MOVLW  77
03D54:  MOVLB  A
03D56:  MOVWF  x2B
03D58:  CLRF   x2F
03D5A:  CLRF   x2E
03D5C:  CLRF   x2D
03D5E:  CLRF   x2C
03D60:  MOVLB  0
03D62:  CALL   3540
03D66:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03D6A:  MOVF   1F,W
03D6C:  SUBLW  04
03D6E:  BNZ   3DB6
03D70:  MOVF   20,F
03D72:  BNZ   3DB6
03D74:  MOVLW  1C
03D76:  MOVWF  FF6
03D78:  MOVLW  09
03D7A:  MOVWF  FF7
03D7C:  MOVLW  00
03D7E:  MOVWF  FF8
03D80:  CLRF   1B
03D82:  BTFSC  FF2.7
03D84:  BSF    1B.7
03D86:  BCF    FF2.7
03D88:  MOVLW  43
03D8A:  MOVLB  A
03D8C:  MOVWF  x40
03D8E:  MOVLB  0
03D90:  CALL   101C
03D94:  BTFSC  1B.7
03D96:  BSF    FF2.7
03D98:  MOVFF  9E4,9EC
03D9C:  MOVLW  57
03D9E:  MOVLB  9
03DA0:  MOVWF  xED
03DA2:  MOVLB  0
03DA4:  RCALL  3610
03DA6:  MOVLW  0D
03DA8:  BTFSS  F9E.4
03DAA:  BRA    3DA8
03DAC:  MOVWF  FAD
03DAE:  MOVLW  0A
03DB0:  BTFSS  F9E.4
03DB2:  BRA    3DB0
03DB4:  MOVWF  FAD
....................       if (response) 
03DB6:  MOVLB  9
03DB8:  MOVF   xE4,F
03DBA:  BZ    3DC6
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03DBC:  MOVLW  02
03DBE:  MOVLB  4
03DC0:  MOVWF  xE7
....................          } 
03DC2:  BRA    3FC0
03DC4:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03DC6:  MOVLW  69
03DC8:  MOVLB  A
03DCA:  MOVWF  x2B
03DCC:  CLRF   x2F
03DCE:  CLRF   x2E
03DD0:  CLRF   x2D
03DD2:  CLRF   x2C
03DD4:  MOVLB  0
03DD6:  CALL   3540
03DDA:  MOVFF  01,9E4
....................          if (response <= 1 ) 
03DDE:  MOVLB  9
03DE0:  MOVF   xE4,W
03DE2:  SUBLW  01
03DE4:  BNC   3DF0
....................             Card = SDv1; 
03DE6:  MOVLW  03
03DE8:  MOVLB  4
03DEA:  MOVWF  xE7
03DEC:  BRA    3FC0
03DEE:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03DF0:  MOVF   1F,W
03DF2:  SUBLW  04
03DF4:  BNZ   3E54
03DF6:  MOVF   20,F
03DF8:  BNZ   3E54
03DFA:  MOVLW  66
03DFC:  MOVWF  FF6
03DFE:  MOVLW  09
03E00:  MOVWF  FF7
03E02:  MOVLW  00
03E04:  MOVWF  FF8
03E06:  CLRF   1B
03E08:  BTFSC  FF2.7
03E0A:  BSF    1B.7
03E0C:  BCF    FF2.7
03E0E:  MOVLW  2E
03E10:  MOVLB  A
03E12:  MOVWF  x40
03E14:  MOVLB  0
03E16:  CALL   101C
03E1A:  BTFSC  1B.7
03E1C:  BSF    FF2.7
03E1E:  MOVFF  9E4,9EC
03E22:  MOVLW  37
03E24:  MOVLB  9
03E26:  MOVWF  xED
03E28:  MOVLB  0
03E2A:  CALL   3610
03E2E:  MOVLW  98
03E30:  MOVWF  FF6
03E32:  MOVLW  09
03E34:  MOVWF  FF7
03E36:  MOVLW  00
03E38:  MOVWF  FF8
03E3A:  CLRF   1B
03E3C:  BTFSC  FF2.7
03E3E:  BSF    1B.7
03E40:  BCF    FF2.7
03E42:  MOVLW  19
03E44:  MOVLB  A
03E46:  MOVWF  x40
03E48:  MOVLB  0
03E4A:  CALL   101C
03E4E:  BTFSC  1B.7
03E50:  BSF    FF2.7
03E52:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03E54:  MOVLW  40
03E56:  MOVLB  A
03E58:  MOVWF  x2B
03E5A:  CLRF   x2F
03E5C:  CLRF   x2E
03E5E:  CLRF   x2D
03E60:  CLRF   x2C
03E62:  MOVLB  0
03E64:  CALL   3540
03E68:  MOVFF  01,9E4
....................             if ((response !=0x01) && (response != 0)) 
03E6C:  MOVLB  9
03E6E:  DECFSZ xE4,W
03E70:  BRA    3E74
03E72:  BRA    3EE0
03E74:  MOVF   xE4,F
03E76:  BZ    3EE0
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03E78:  MOVF   1F,W
03E7A:  SUBLW  04
03E7C:  BNZ   3EDC
03E7E:  MOVF   20,F
03E80:  BNZ   3EDC
03E82:  MOVLW  B2
03E84:  MOVWF  FF6
03E86:  MOVLW  09
03E88:  MOVWF  FF7
03E8A:  MOVLW  00
03E8C:  MOVWF  FF8
03E8E:  CLRF   1B
03E90:  BTFSC  FF2.7
03E92:  BSF    1B.7
03E94:  BCF    FF2.7
03E96:  MOVLW  2C
03E98:  MOVLB  A
03E9A:  MOVWF  x40
03E9C:  MOVLB  0
03E9E:  CALL   101C
03EA2:  BTFSC  1B.7
03EA4:  BSF    FF2.7
03EA6:  MOVFF  9E4,9EC
03EAA:  MOVLW  37
03EAC:  MOVLB  9
03EAE:  MOVWF  xED
03EB0:  MOVLB  0
03EB2:  CALL   3610
03EB6:  MOVLW  E2
03EB8:  MOVWF  FF6
03EBA:  MOVLW  09
03EBC:  MOVWF  FF7
03EBE:  MOVLW  00
03EC0:  MOVWF  FF8
03EC2:  CLRF   1B
03EC4:  BTFSC  FF2.7
03EC6:  BSF    1B.7
03EC8:  BCF    FF2.7
03ECA:  MOVLW  0B
03ECC:  MOVLB  A
03ECE:  MOVWF  x40
03ED0:  MOVLB  0
03ED2:  CALL   101C
03ED6:  BTFSC  1B.7
03ED8:  BSF    FF2.7
03EDA:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03EDC:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03EDE:  BRA    43CA
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03EE0:  CLRF   xEA
03EE2:  CLRF   xE9
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03EE4:  MOVLW  41
03EE6:  MOVLB  A
03EE8:  MOVWF  x2B
03EEA:  CLRF   x2F
03EEC:  CLRF   x2E
03EEE:  CLRF   x2D
03EF0:  CLRF   x2C
03EF2:  MOVLB  0
03EF4:  CALL   3540
03EF8:  MOVFF  01,9E4
....................                if (response != 0x00 ) 
03EFC:  MOVLB  9
03EFE:  MOVF   xE4,F
03F00:  BZ    3F0A
....................                   delay_us(10); 
03F02:  MOVLW  35
03F04:  MOVWF  00
03F06:  DECFSZ 00,F
03F08:  BRA    3F06
....................                Timer++; 
03F0A:  INCF   xE9,F
03F0C:  BTFSC  FD8.2
03F0E:  INCF   xEA,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03F10:  MOVF   xE4,F
03F12:  BZ    3F22
03F14:  MOVF   xEA,W
03F16:  SUBLW  C3
03F18:  BNC   3F22
03F1A:  BNZ   3EE4
03F1C:  MOVF   xE9,W
03F1E:  SUBLW  4F
03F20:  BC    3EE4
....................     
....................             if(response) 
03F22:  MOVF   xE4,F
03F24:  BZ    3FBA
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03F26:  MOVF   1F,W
03F28:  SUBLW  04
03F2A:  BNZ   3FB6
03F2C:  MOVF   20,F
03F2E:  BNZ   3FB6
03F30:  MOVLW  EE
03F32:  MOVWF  FF6
03F34:  MOVLW  09
03F36:  MOVWF  FF7
03F38:  MOVLW  00
03F3A:  MOVWF  FF8
03F3C:  CLRF   1B
03F3E:  BTFSC  FF2.7
03F40:  BSF    1B.7
03F42:  BCF    FF2.7
03F44:  MOVLW  4A
03F46:  MOVLB  A
03F48:  MOVWF  x40
03F4A:  MOVLB  0
03F4C:  CALL   101C
03F50:  BTFSC  1B.7
03F52:  BSF    FF2.7
03F54:  MOVFF  9E4,9EC
03F58:  MOVLW  37
03F5A:  MOVLB  9
03F5C:  MOVWF  xED
03F5E:  MOVLB  0
03F60:  CALL   3610
03F64:  MOVLW  3C
03F66:  MOVWF  FF6
03F68:  MOVLW  0A
03F6A:  MOVWF  FF7
03F6C:  MOVLW  00
03F6E:  MOVWF  FF8
03F70:  CLRF   1B
03F72:  BTFSC  FF2.7
03F74:  BSF    1B.7
03F76:  BCF    FF2.7
03F78:  MOVLW  0A
03F7A:  MOVLB  A
03F7C:  MOVWF  x40
03F7E:  MOVLB  0
03F80:  CALL   101C
03F84:  BTFSC  1B.7
03F86:  BSF    FF2.7
03F88:  MOVLW  10
03F8A:  MOVWF  FE9
03F8C:  CLRF   1B
03F8E:  BTFSC  FF2.7
03F90:  BSF    1B.7
03F92:  BCF    FF2.7
03F94:  MOVFF  9EA,A41
03F98:  MOVFF  9E9,A40
03F9C:  CALL   119E
03FA0:  BTFSC  1B.7
03FA2:  BSF    FF2.7
03FA4:  MOVLW  0D
03FA6:  BTFSS  F9E.4
03FA8:  BRA    3FA6
03FAA:  MOVWF  FAD
03FAC:  MOVLW  0A
03FAE:  BTFSS  F9E.4
03FB0:  BRA    3FAE
03FB2:  MOVWF  FAD
03FB4:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03FB6:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03FB8:  BRA    43CA
....................                } 
....................  
....................             Card = MMC; 
03FBA:  MOVLW  02
03FBC:  MOVLB  4
03FBE:  MOVWF  xE7
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03FC0:  MOVF   1F,W
03FC2:  SUBLW  04
03FC4:  BNZ   3FEA
03FC6:  MOVF   20,F
03FC8:  BNZ   3FEA
03FCA:  MOVLW  4C
03FCC:  MOVWF  FF6
03FCE:  MOVLW  0A
03FD0:  MOVWF  FF7
03FD2:  MOVLW  00
03FD4:  MOVWF  FF8
03FD6:  CLRF   1B
03FD8:  BTFSC  FF2.7
03FDA:  BSF    1B.7
03FDC:  BCF    FF2.7
03FDE:  MOVLB  0
03FE0:  CALL   0E46
03FE4:  BTFSC  1B.7
03FE6:  BSF    FF2.7
03FE8:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
03FEA:  MOVLW  50
03FEC:  MOVLB  A
03FEE:  MOVWF  x2B
03FF0:  CLRF   x2F
03FF2:  CLRF   x2E
03FF4:  MOVLW  02
03FF6:  MOVWF  x2D
03FF8:  CLRF   x2C
03FFA:  MOVLB  0
03FFC:  CALL   3540
04000:  MOVFF  01,9E4
....................       if ((Timer == 50000) || (response > 1))    
04004:  MOVLB  9
04006:  MOVF   xE9,W
04008:  SUBLW  50
0400A:  BNZ   4012
0400C:  MOVF   xEA,W
0400E:  SUBLW  C3
04010:  BZ    4018
04012:  MOVF   xE4,W
04014:  SUBLW  01
04016:  BC    40AE
....................       { 
....................          Card = None; 
04018:  MOVLB  4
0401A:  CLRF   xE7
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
0401C:  MOVF   1F,W
0401E:  SUBLW  04
04020:  BNZ   40AC
04022:  MOVF   20,F
04024:  BNZ   40AC
04026:  MOVLW  68
04028:  MOVWF  FF6
0402A:  MOVLW  0A
0402C:  MOVWF  FF7
0402E:  MOVLW  00
04030:  MOVWF  FF8
04032:  CLRF   1B
04034:  BTFSC  FF2.7
04036:  BSF    1B.7
04038:  BCF    FF2.7
0403A:  MOVLW  2B
0403C:  MOVLB  A
0403E:  MOVWF  x40
04040:  MOVLB  0
04042:  CALL   101C
04046:  BTFSC  1B.7
04048:  BSF    FF2.7
0404A:  MOVFF  9E4,9EC
0404E:  MOVLW  57
04050:  MOVLB  9
04052:  MOVWF  xED
04054:  MOVLB  0
04056:  CALL   3610
0405A:  MOVLW  97
0405C:  MOVWF  FF6
0405E:  MOVLW  0A
04060:  MOVWF  FF7
04062:  MOVLW  00
04064:  MOVWF  FF8
04066:  CLRF   1B
04068:  BTFSC  FF2.7
0406A:  BSF    1B.7
0406C:  BCF    FF2.7
0406E:  MOVLW  0A
04070:  MOVLB  A
04072:  MOVWF  x40
04074:  MOVLB  0
04076:  CALL   101C
0407A:  BTFSC  1B.7
0407C:  BSF    FF2.7
0407E:  MOVLW  10
04080:  MOVWF  FE9
04082:  CLRF   1B
04084:  BTFSC  FF2.7
04086:  BSF    1B.7
04088:  BCF    FF2.7
0408A:  MOVFF  9EA,A41
0408E:  MOVFF  9E9,A40
04092:  CALL   119E
04096:  BTFSC  1B.7
04098:  BSF    FF2.7
0409A:  MOVLW  0D
0409C:  BTFSS  F9E.4
0409E:  BRA    409C
040A0:  MOVWF  FAD
040A2:  MOVLW  0A
040A4:  BTFSS  F9E.4
040A6:  BRA    40A4
040A8:  MOVWF  FAD
040AA:  MOVLB  4
040AC:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
040AE:  MOVLB  4
040B0:  MOVF   xE7,F
040B2:  BNZ   40E6
....................    { 
....................       if (nv_report_mode == 4) 
040B4:  MOVF   1F,W
040B6:  SUBLW  04
040B8:  BNZ   40DE
040BA:  MOVF   20,F
040BC:  BNZ   40DE
....................          printf("@FS:Card Type Discovery Error\r\n"); 
040BE:  MOVLW  A8
040C0:  MOVWF  FF6
040C2:  MOVLW  0A
040C4:  MOVWF  FF7
040C6:  MOVLW  00
040C8:  MOVWF  FF8
040CA:  CLRF   1B
040CC:  BTFSC  FF2.7
040CE:  BSF    1B.7
040D0:  BCF    FF2.7
040D2:  MOVLB  0
040D4:  CALL   0E46
040D8:  BTFSC  1B.7
040DA:  BSF    FF2.7
040DC:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
040DE:  MOVLB  9
040E0:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
040E2:  BRA    43CA
040E4:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
040E6:  MOVF   xE7,W
040E8:  XORLW  02
040EA:  MOVLB  0
040EC:  BZ    40FC
040EE:  XORLW  01
040F0:  BZ    4124
040F2:  XORLW  07
040F4:  BZ    414C
040F6:  XORLW  01
040F8:  BZ    4174
040FA:  BRA    419C
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
040FC:  MOVF   1F,W
040FE:  SUBLW  04
04100:  BNZ   4122
04102:  MOVF   20,F
04104:  BNZ   4122
04106:  MOVLW  C8
04108:  MOVWF  FF6
0410A:  MOVLW  0A
0410C:  MOVWF  FF7
0410E:  MOVLW  00
04110:  MOVWF  FF8
04112:  CLRF   1B
04114:  BTFSC  FF2.7
04116:  BSF    1B.7
04118:  BCF    FF2.7
0411A:  CALL   0E46
0411E:  BTFSC  1B.7
04120:  BSF    FF2.7
....................          break; 
04122:  BRA    41F2
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
04124:  MOVF   1F,W
04126:  SUBLW  04
04128:  BNZ   414A
0412A:  MOVF   20,F
0412C:  BNZ   414A
0412E:  MOVLW  DE
04130:  MOVWF  FF6
04132:  MOVLW  0A
04134:  MOVWF  FF7
04136:  MOVLW  00
04138:  MOVWF  FF8
0413A:  CLRF   1B
0413C:  BTFSC  FF2.7
0413E:  BSF    1B.7
04140:  BCF    FF2.7
04142:  CALL   0E46
04146:  BTFSC  1B.7
04148:  BSF    FF2.7
....................          break; 
0414A:  BRA    41F2
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
0414C:  MOVF   1F,W
0414E:  SUBLW  04
04150:  BNZ   4172
04152:  MOVF   20,F
04154:  BNZ   4172
04156:  MOVLW  F4
04158:  MOVWF  FF6
0415A:  MOVLW  0A
0415C:  MOVWF  FF7
0415E:  MOVLW  00
04160:  MOVWF  FF8
04162:  CLRF   1B
04164:  BTFSC  FF2.7
04166:  BSF    1B.7
04168:  BCF    FF2.7
0416A:  CALL   0E46
0416E:  BTFSC  1B.7
04170:  BSF    FF2.7
....................          break; 
04172:  BRA    41F2
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
04174:  MOVF   1F,W
04176:  SUBLW  04
04178:  BNZ   419A
0417A:  MOVF   20,F
0417C:  BNZ   419A
0417E:  MOVLW  0A
04180:  MOVWF  FF6
04182:  MOVLW  0B
04184:  MOVWF  FF7
04186:  MOVLW  00
04188:  MOVWF  FF8
0418A:  CLRF   1B
0418C:  BTFSC  FF2.7
0418E:  BSF    1B.7
04190:  BCF    FF2.7
04192:  CALL   0E46
04196:  BTFSC  1B.7
04198:  BSF    FF2.7
....................          break; 
0419A:  BRA    41F2
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
0419C:  MOVF   1F,W
0419E:  SUBLW  04
041A0:  BNZ   41EA
041A2:  MOVF   20,F
041A4:  BNZ   41EA
041A6:  MOVLW  20
041A8:  MOVWF  FF6
041AA:  MOVLW  0B
041AC:  MOVWF  FF7
041AE:  MOVLW  00
041B0:  MOVWF  FF8
041B2:  CLRF   1B
041B4:  BTFSC  FF2.7
041B6:  BSF    1B.7
041B8:  BCF    FF2.7
041BA:  MOVLW  26
041BC:  MOVLB  A
041BE:  MOVWF  x40
041C0:  MOVLB  0
041C2:  CALL   101C
041C6:  BTFSC  1B.7
041C8:  BSF    FF2.7
041CA:  MOVFF  4E7,9EC
041CE:  MOVLW  37
041D0:  MOVLB  9
041D2:  MOVWF  xED
041D4:  MOVLB  0
041D6:  CALL   3610
041DA:  MOVLW  0D
041DC:  BTFSS  F9E.4
041DE:  BRA    41DC
041E0:  MOVWF  FAD
041E2:  MOVLW  0A
041E4:  BTFSS  F9E.4
041E6:  BRA    41E4
041E8:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
041EA:  MOVLB  9
041EC:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
041EE:  BRA    43CA
041F0:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
041F2:  MOVLB  9
041F4:  BCF    xEB.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
041F6:  MOVF   1F,W
041F8:  SUBLW  04
041FA:  BNZ   4252
041FC:  MOVF   20,F
041FE:  BNZ   4252
04200:  MOVLW  4E
04202:  MOVWF  FF6
04204:  MOVLW  0B
04206:  MOVWF  FF7
04208:  MOVLW  00
0420A:  MOVWF  FF8
0420C:  CLRF   1B
0420E:  BTFSC  FF2.7
04210:  BSF    1B.7
04212:  BCF    FF2.7
04214:  MOVLW  2E
04216:  MOVLB  A
04218:  MOVWF  x40
0421A:  MOVLB  0
0421C:  CALL   101C
04220:  BTFSC  1B.7
04222:  BSF    FF2.7
04224:  MOVLW  10
04226:  MOVWF  FE9
04228:  CLRF   1B
0422A:  BTFSC  FF2.7
0422C:  BSF    1B.7
0422E:  BCF    FF2.7
04230:  MOVFF  9EA,A41
04234:  MOVFF  9E9,A40
04238:  CALL   119E
0423C:  BTFSC  1B.7
0423E:  BSF    FF2.7
04240:  MOVLW  0D
04242:  BTFSS  F9E.4
04244:  BRA    4242
04246:  MOVWF  FAD
04248:  MOVLW  0A
0424A:  BTFSS  F9E.4
0424C:  BRA    424A
0424E:  MOVWF  FAD
04250:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
04252:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
04254:  BCF    FC6.5
04256:  MOVLW  20
04258:  MOVWF  FC6
0425A:  MOVLW  40
0425C:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
0425E:  BCF    F9E.3
....................    SelectSD; 
04260:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
04262:  MOVF   1F,W
04264:  SUBLW  04
04266:  BNZ   428C
04268:  MOVF   20,F
0426A:  BNZ   428C
0426C:  MOVLW  82
0426E:  MOVWF  FF6
04270:  MOVLW  0B
04272:  MOVWF  FF7
04274:  MOVLW  00
04276:  MOVWF  FF8
04278:  CLRF   1B
0427A:  BTFSC  FF2.7
0427C:  BSF    1B.7
0427E:  BCF    FF2.7
04280:  MOVLB  0
04282:  CALL   0E46
04286:  BTFSC  1B.7
04288:  BSF    FF2.7
0428A:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
0428C:  CLRF   xEA
0428E:  CLRF   xE9
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
04290:  MOVLW  41
04292:  MOVLB  A
04294:  MOVWF  x2B
04296:  CLRF   x2F
04298:  CLRF   x2E
0429A:  CLRF   x2D
0429C:  CLRF   x2C
0429E:  MOVLB  0
042A0:  CALL   3540
042A4:  MOVFF  01,9E4
....................       if (response != 0x00 ) 
042A8:  MOVLB  9
042AA:  MOVF   xE4,F
042AC:  BZ    42B6
....................          delay_us(10); 
042AE:  MOVLW  35
042B0:  MOVWF  00
042B2:  DECFSZ 00,F
042B4:  BRA    42B2
....................  
....................       Timer++; 
042B6:  INCF   xE9,F
042B8:  BTFSC  FD8.2
042BA:  INCF   xEA,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
042BC:  MOVF   xE4,F
042BE:  BZ    42CE
042C0:  MOVF   xEA,W
042C2:  SUBLW  C3
042C4:  BNC   42CE
042C6:  BNZ   4290
042C8:  MOVF   xE9,W
042CA:  SUBLW  4F
042CC:  BC    4290
....................  
....................    if (response != 0x00) 
042CE:  MOVF   xE4,F
042D0:  BZ    4366
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
042D2:  MOVF   1F,W
042D4:  SUBLW  04
042D6:  BNZ   4362
042D8:  MOVF   20,F
042DA:  BNZ   4362
042DC:  MOVLW  A2
042DE:  MOVWF  FF6
042E0:  MOVLW  0B
042E2:  MOVWF  FF7
042E4:  MOVLW  00
042E6:  MOVWF  FF8
042E8:  CLRF   1B
042EA:  BTFSC  FF2.7
042EC:  BSF    1B.7
042EE:  BCF    FF2.7
042F0:  MOVLW  26
042F2:  MOVLB  A
042F4:  MOVWF  x40
042F6:  MOVLB  0
042F8:  CALL   101C
042FC:  BTFSC  1B.7
042FE:  BSF    FF2.7
04300:  MOVFF  9E4,9EC
04304:  MOVLW  37
04306:  MOVLB  9
04308:  MOVWF  xED
0430A:  MOVLB  0
0430C:  CALL   3610
04310:  MOVLW  CC
04312:  MOVWF  FF6
04314:  MOVLW  0B
04316:  MOVWF  FF7
04318:  MOVLW  00
0431A:  MOVWF  FF8
0431C:  CLRF   1B
0431E:  BTFSC  FF2.7
04320:  BSF    1B.7
04322:  BCF    FF2.7
04324:  MOVLW  0A
04326:  MOVLB  A
04328:  MOVWF  x40
0432A:  MOVLB  0
0432C:  CALL   101C
04330:  BTFSC  1B.7
04332:  BSF    FF2.7
04334:  MOVLW  10
04336:  MOVWF  FE9
04338:  CLRF   1B
0433A:  BTFSC  FF2.7
0433C:  BSF    1B.7
0433E:  BCF    FF2.7
04340:  MOVFF  9EA,A41
04344:  MOVFF  9E9,A40
04348:  CALL   119E
0434C:  BTFSC  1B.7
0434E:  BSF    FF2.7
04350:  MOVLW  0D
04352:  BTFSS  F9E.4
04354:  BRA    4352
04356:  MOVWF  FAD
04358:  MOVLW  0A
0435A:  BTFSS  F9E.4
0435C:  BRA    435A
0435E:  MOVWF  FAD
04360:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
04362:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
04364:  BRA    43CA
....................    } 
....................  
....................    if (nv_report_mode == 4) 
04366:  MOVF   1F,W
04368:  SUBLW  04
0436A:  BNZ   43C2
0436C:  MOVF   20,F
0436E:  BNZ   43C2
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
04370:  MOVLW  DC
04372:  MOVWF  FF6
04374:  MOVLW  0B
04376:  MOVWF  FF7
04378:  MOVLW  00
0437A:  MOVWF  FF8
0437C:  CLRF   1B
0437E:  BTFSC  FF2.7
04380:  BSF    1B.7
04382:  BCF    FF2.7
04384:  MOVLW  25
04386:  MOVLB  A
04388:  MOVWF  x40
0438A:  MOVLB  0
0438C:  CALL   101C
04390:  BTFSC  1B.7
04392:  BSF    FF2.7
04394:  MOVLW  10
04396:  MOVWF  FE9
04398:  CLRF   1B
0439A:  BTFSC  FF2.7
0439C:  BSF    1B.7
0439E:  BCF    FF2.7
043A0:  MOVFF  9EA,A41
043A4:  MOVFF  9E9,A40
043A8:  CALL   119E
043AC:  BTFSC  1B.7
043AE:  BSF    FF2.7
043B0:  MOVLW  0D
043B2:  BTFSS  F9E.4
043B4:  BRA    43B2
043B6:  MOVWF  FAD
043B8:  MOVLW  0A
043BA:  BTFSS  F9E.4
043BC:  BRA    43BA
043BE:  MOVWF  FAD
043C0:  MOVLB  9
....................  
....................    msg_card_ok(); 
043C2:  MOVLB  0
043C4:  GOTO   3656
043C8:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
043CA:  BSF    F91.1
....................    return(SDCardStatus); 
043CC:  MOVFF  9EB,01
043D0:  MOVLB  0
043D2:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05A82:  MOVLW  20
05A84:  MOVLB  7
05A86:  ADDWF  x12,W
05A88:  MOVWF  FE9
05A8A:  MOVLW  00
05A8C:  ADDWFC x13,W
05A8E:  MOVWF  FEA
05A90:  MOVFF  FEF,A18
05A94:  MOVFF  FEC,A19
05A98:  MOVFF  FEC,A1A
05A9C:  MOVFF  FEC,A1B
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05AA0:  MOVLB  A
05AA2:  MOVF   x14,W
05AA4:  SUBWF  x18,W
05AA6:  BNZ   5ABC
05AA8:  MOVF   x15,W
05AAA:  SUBWF  x19,W
05AAC:  BNZ   5ABC
05AAE:  MOVF   x16,W
05AB0:  SUBWF  x1A,W
05AB2:  BNZ   5ABC
05AB4:  MOVF   x17,W
05AB6:  SUBWF  x1B,W
05AB8:  BTFSC  FD8.2
05ABA:  BRA    5C90
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05ABC:  MOVLW  06
05ABE:  MOVLB  7
05AC0:  ADDWF  x12,W
05AC2:  MOVWF  FE9
05AC4:  MOVLW  00
05AC6:  ADDWFC x13,W
05AC8:  MOVWF  FEA
05ACA:  MOVF   FEF,F
05ACC:  BTFSC  FD8.2
05ACE:  BRA    5C1A
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05AD0:  MOVLW  24
05AD2:  ADDWF  x12,W
05AD4:  MOVWF  01
05AD6:  MOVLW  00
05AD8:  ADDWFC x13,W
05ADA:  MOVWF  03
05ADC:  MOVFF  01,A1E
05AE0:  MOVLB  A
05AE2:  MOVWF  x1F
05AE4:  MOVWF  x21
05AE6:  MOVFF  01,A20
05AEA:  MOVFF  A1B,A25
05AEE:  MOVFF  A1A,A24
05AF2:  MOVFF  A19,A23
05AF6:  MOVFF  A18,A22
05AFA:  MOVLW  01
05AFC:  MOVWF  x26
05AFE:  MOVLB  0
05B00:  RCALL  593E
05B02:  MOVFF  01,A1C
....................             if (response != RES_OK) 
05B06:  MOVLB  A
05B08:  MOVF   x1C,F
05B0A:  BZ    5B12
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05B0C:  MOVLW  00
05B0E:  MOVWF  01
05B10:  BRA    5C94
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05B12:  MOVLW  06
05B14:  MOVLB  7
05B16:  ADDWF  x12,W
05B18:  MOVWF  FE9
05B1A:  MOVLW  00
05B1C:  ADDWFC x13,W
05B1E:  MOVWF  FEA
05B20:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05B22:  MOVLW  10
05B24:  ADDWF  x12,W
05B26:  MOVWF  FE9
05B28:  MOVLW  00
05B2A:  ADDWFC x13,W
05B2C:  MOVWF  FEA
05B2E:  MOVFF  FEF,A1E
05B32:  MOVFF  FEC,A1F
05B36:  MOVFF  FEC,A20
05B3A:  MOVFF  FEC,A21
05B3E:  MOVLW  08
05B40:  ADDWF  x12,W
05B42:  MOVWF  FE9
05B44:  MOVLW  00
05B46:  ADDWFC x13,W
05B48:  MOVWF  FEA
05B4A:  MOVFF  FEF,00
05B4E:  MOVFF  FEC,01
05B52:  MOVFF  FEC,02
05B56:  MOVFF  FEC,03
05B5A:  MOVLB  A
05B5C:  MOVF   x1E,W
05B5E:  ADDWF  00,F
05B60:  MOVF   x1F,W
05B62:  ADDWFC 01,F
05B64:  MOVF   x20,W
05B66:  ADDWFC 02,F
05B68:  MOVF   x21,W
05B6A:  ADDWFC 03,F
05B6C:  MOVF   x1B,W
05B6E:  SUBWF  03,W
05B70:  BNC   5C18
05B72:  BNZ   5B8A
05B74:  MOVF   x1A,W
05B76:  SUBWF  02,W
05B78:  BNC   5C18
05B7A:  BNZ   5B8A
05B7C:  MOVF   x19,W
05B7E:  SUBWF  01,W
05B80:  BNC   5C18
05B82:  BNZ   5B8A
05B84:  MOVF   00,W
05B86:  SUBWF  x18,W
05B88:  BC    5C18
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05B8A:  MOVLW  03
05B8C:  MOVLB  7
05B8E:  ADDWF  x12,W
05B90:  MOVWF  FE9
05B92:  MOVLW  00
05B94:  ADDWFC x13,W
05B96:  MOVWF  FEA
05B98:  MOVFF  FEF,A1D
05B9C:  MOVLB  A
05B9E:  MOVF   x1D,W
05BA0:  SUBLW  01
05BA2:  BC    5C18
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05BA4:  MOVLW  08
05BA6:  MOVLB  7
05BA8:  ADDWF  x12,W
05BAA:  MOVWF  FE9
05BAC:  MOVLW  00
05BAE:  ADDWFC x13,W
05BB0:  MOVWF  FEA
05BB2:  MOVFF  FEF,00
05BB6:  MOVFF  FEC,01
05BBA:  MOVFF  FEC,02
05BBE:  MOVFF  FEC,03
05BC2:  MOVF   00,W
05BC4:  MOVLB  A
05BC6:  ADDWF  x18,F
05BC8:  MOVF   01,W
05BCA:  ADDWFC x19,F
05BCC:  MOVF   02,W
05BCE:  ADDWFC x1A,F
05BD0:  MOVF   03,W
05BD2:  ADDWFC x1B,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05BD4:  MOVLW  24
05BD6:  MOVLB  7
05BD8:  ADDWF  x12,W
05BDA:  MOVWF  01
05BDC:  MOVLW  00
05BDE:  ADDWFC x13,W
05BE0:  MOVWF  03
05BE2:  MOVFF  01,A1E
05BE6:  MOVLB  A
05BE8:  MOVWF  x1F
05BEA:  MOVWF  x21
05BEC:  MOVFF  01,A20
05BF0:  MOVFF  A1B,A25
05BF4:  MOVFF  A1A,A24
05BF8:  MOVFF  A19,A23
05BFC:  MOVFF  A18,A22
05C00:  MOVLW  01
05C02:  MOVWF  x26
05C04:  MOVLB  0
05C06:  RCALL  593E
05C08:  MOVF   01,F
05C0A:  BZ    5C12
....................                      break; 
05C0C:  MOVLB  A
05C0E:  BRA    5C18
05C10:  MOVLB  0
05C12:  MOVLB  A
05C14:  DECF   x1D,F
05C16:  BRA    5B9E
05C18:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05C1A:  MOVLB  A
05C1C:  MOVF   x14,F
05C1E:  BNZ   5C2C
05C20:  MOVF   x15,F
05C22:  BNZ   5C2C
05C24:  MOVF   x16,F
05C26:  BNZ   5C2C
05C28:  MOVF   x17,F
05C2A:  BZ    5C90
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05C2C:  MOVLW  24
05C2E:  MOVLB  7
05C30:  ADDWF  x12,W
05C32:  MOVWF  01
05C34:  MOVLW  00
05C36:  ADDWFC x13,W
05C38:  MOVWF  03
05C3A:  MOVFF  01,A1E
05C3E:  MOVLB  A
05C40:  MOVWF  x1F
05C42:  MOVWF  x21
05C44:  MOVFF  01,A20
05C48:  MOVFF  A17,A25
05C4C:  MOVFF  A16,A24
05C50:  MOVFF  A15,A23
05C54:  MOVFF  A14,A22
05C58:  MOVLW  01
05C5A:  MOVWF  x26
05C5C:  MOVLB  0
05C5E:  CALL   44CC
05C62:  MOVF   01,F
05C64:  BZ    5C70
....................             return FALSE; 
05C66:  MOVLW  00
05C68:  MOVWF  01
05C6A:  MOVLB  A
05C6C:  BRA    5C94
05C6E:  MOVLB  0
....................          fs->winsect = sector; 
05C70:  MOVLW  20
05C72:  MOVLB  7
05C74:  ADDWF  x12,W
05C76:  MOVWF  FE9
05C78:  MOVLW  00
05C7A:  ADDWFC x13,W
05C7C:  MOVWF  FEA
05C7E:  MOVFF  A14,FEF
05C82:  MOVFF  A15,FEC
05C86:  MOVFF  A16,FEC
05C8A:  MOVFF  A17,FEC
05C8E:  MOVLB  A
....................          } 
....................       } 
....................    return (TRUE); 
05C90:  MOVLW  01
05C92:  MOVWF  01
05C94:  MOVLB  0
05C96:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05CBA:  MOVLB  9
05CBC:  MOVF   xFF,F
05CBE:  BNZ   5CD0
05CC0:  MOVF   xFE,F
05CC2:  BNZ   5CD0
05CC4:  MOVF   xFD,F
05CC6:  BNZ   5CD0
05CC8:  MOVF   xFC,W
05CCA:  SUBLW  01
05CCC:  BTFSC  FD8.0
05CCE:  BRA    5FF8
05CD0:  MOVLW  0C
05CD2:  MOVLB  7
05CD4:  ADDWF  x12,W
05CD6:  MOVWF  FE9
05CD8:  MOVLW  00
05CDA:  ADDWFC x13,W
05CDC:  MOVWF  FEA
05CDE:  MOVFF  FEF,00
05CE2:  MOVFF  FEC,01
05CE6:  MOVFF  FEC,02
05CEA:  MOVFF  FEC,03
05CEE:  MOVLB  9
05CF0:  MOVF   xFF,W
05CF2:  SUBWF  03,W
05CF4:  BTFSS  FD8.0
05CF6:  BRA    5FF8
05CF8:  BNZ   5D16
05CFA:  MOVF   xFE,W
05CFC:  SUBWF  02,W
05CFE:  BTFSS  FD8.0
05D00:  BRA    5FF8
05D02:  BNZ   5D16
05D04:  MOVF   xFD,W
05D06:  SUBWF  01,W
05D08:  BTFSS  FD8.0
05D0A:  BRA    5FF8
05D0C:  BNZ   5D16
05D0E:  MOVF   00,W
05D10:  SUBWF  xFC,W
05D12:  BTFSC  FD8.0
05D14:  BRA    5FF8
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05D16:  MOVLW  10
05D18:  MOVLB  7
05D1A:  ADDWF  x12,W
05D1C:  MOVWF  FE9
05D1E:  MOVLW  00
05D20:  ADDWFC x13,W
05D22:  MOVWF  FEA
05D24:  MOVFF  FEF,A04
05D28:  MOVFF  FEC,A05
05D2C:  MOVFF  FEC,A06
05D30:  MOVFF  FEC,A07
....................       switch (fs->fs_type)  
05D34:  MOVF   x12,W
05D36:  MOVWF  FE9
05D38:  MOVF   x13,W
05D3A:  MOVWF  FEA
05D3C:  MOVF   FEF,W
05D3E:  XORLW  01
05D40:  MOVLB  0
05D42:  BZ    5D52
05D44:  XORLW  03
05D46:  BTFSC  FD8.2
05D48:  BRA    5E9E
05D4A:  XORLW  01
05D4C:  BTFSC  FD8.2
05D4E:  BRA    5F26
05D50:  BRA    5FF6
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05D52:  MOVFF  9FD,A11
05D56:  MOVFF  9FC,A10
05D5A:  MOVLB  A
05D5C:  CLRF   x13
05D5E:  MOVLW  03
05D60:  MOVWF  x12
05D62:  MOVLB  0
05D64:  RCALL  5C98
05D66:  BCF    FD8.0
05D68:  MOVLB  A
05D6A:  RRCF   02,W
05D6C:  MOVWF  x03
05D6E:  RRCF   01,W
05D70:  MOVWF  x02
....................             if (!move_window(fatsect + bc / 512))  
05D72:  BCF    FD8.0
05D74:  CLRF   03
05D76:  RRCF   x03,W
05D78:  MOVWF  02
05D7A:  ADDWF  x04,W
05D7C:  MOVWF  x08
05D7E:  MOVF   03,W
05D80:  ADDWFC x05,W
05D82:  MOVWF  x09
05D84:  MOVLW  00
05D86:  ADDWFC x06,W
05D88:  MOVWF  x0A
05D8A:  MOVLW  00
05D8C:  ADDWFC x07,W
05D8E:  MOVWF  x0B
05D90:  MOVWF  x17
05D92:  MOVFF  A0A,A16
05D96:  MOVFF  A09,A15
05D9A:  MOVFF  A08,A14
05D9E:  MOVLB  0
05DA0:  RCALL  5A82
05DA2:  MOVF   01,F
05DA4:  BNZ   5DA8
....................                break; 
05DA6:  BRA    5FF6
....................             wc = fs->win[bc % 512]; 
05DA8:  MOVLB  A
05DAA:  MOVF   x03,W
05DAC:  ANDLW  01
05DAE:  MOVWF  x09
05DB0:  MOVLW  24
05DB2:  ADDWF  x02,W
05DB4:  MOVWF  01
05DB6:  MOVLW  00
05DB8:  ADDWFC x09,W
05DBA:  MOVWF  03
05DBC:  MOVF   01,W
05DBE:  MOVLB  7
05DC0:  ADDWF  x12,W
05DC2:  MOVWF  FE9
05DC4:  MOVF   x13,W
05DC6:  ADDWFC 03,W
05DC8:  MOVWF  FEA
05DCA:  MOVLB  A
05DCC:  CLRF   x01
05DCE:  MOVFF  FEF,A00
....................             bc++; 
05DD2:  INCF   x02,F
05DD4:  BTFSC  FD8.2
05DD6:  INCF   x03,F
....................             if (!move_window(fatsect + bc / 512))  
05DD8:  BCF    FD8.0
05DDA:  CLRF   03
05DDC:  RRCF   x03,W
05DDE:  MOVWF  02
05DE0:  ADDWF  x04,W
05DE2:  MOVWF  x08
05DE4:  MOVF   03,W
05DE6:  ADDWFC x05,W
05DE8:  MOVWF  x09
05DEA:  MOVLW  00
05DEC:  ADDWFC x06,W
05DEE:  MOVWF  x0A
05DF0:  MOVLW  00
05DF2:  ADDWFC x07,W
05DF4:  MOVWF  x0B
05DF6:  MOVWF  x17
05DF8:  MOVFF  A0A,A16
05DFC:  MOVFF  A09,A15
05E00:  MOVFF  A08,A14
05E04:  MOVLB  0
05E06:  RCALL  5A82
05E08:  MOVF   01,F
05E0A:  BNZ   5E0E
....................                break; 
05E0C:  BRA    5FF6
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05E0E:  MOVLB  A
05E10:  MOVF   x03,W
05E12:  ANDLW  01
05E14:  MOVWF  x09
05E16:  MOVLW  24
05E18:  ADDWF  x02,W
05E1A:  MOVWF  01
05E1C:  MOVLW  00
05E1E:  ADDWFC x09,W
05E20:  MOVWF  03
05E22:  MOVF   01,W
05E24:  MOVLB  7
05E26:  ADDWF  x12,W
05E28:  MOVWF  FE9
05E2A:  MOVF   x13,W
05E2C:  ADDWFC 03,W
05E2E:  MOVWF  FEA
05E30:  MOVF   FEF,W
05E32:  MOVLB  A
05E34:  MOVWF  x0A
05E36:  MOVLW  00
05E38:  IORWF  x00,F
05E3A:  MOVF   x0A,W
05E3C:  IORWF  x01,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05E3E:  MOVLB  9
05E40:  MOVF   xFC,W
05E42:  ANDLW  01
05E44:  MOVWF  00
05E46:  CLRF   01
05E48:  CLRF   02
05E4A:  CLRF   03
05E4C:  MOVF   00,F
05E4E:  BNZ   5E5C
05E50:  MOVF   01,F
05E52:  BNZ   5E5C
05E54:  MOVF   02,F
05E56:  BNZ   5E5C
05E58:  MOVF   03,F
05E5A:  BZ    5E84
05E5C:  MOVLB  A
05E5E:  RRCF   x01,W
05E60:  MOVWF  03
05E62:  RRCF   x00,W
05E64:  MOVWF  02
05E66:  RRCF   03,F
05E68:  RRCF   02,F
05E6A:  RRCF   03,F
05E6C:  RRCF   02,F
05E6E:  RRCF   03,F
05E70:  RRCF   02,F
05E72:  MOVLW  0F
05E74:  ANDWF  03,F
05E76:  MOVFF  02,00
05E7A:  MOVFF  03,01
05E7E:  CLRF   02
05E80:  CLRF   03
05E82:  BRA    5E9A
05E84:  MOVLB  A
05E86:  MOVFF  A00,00
05E8A:  MOVF   x01,W
05E8C:  ANDLW  0F
05E8E:  MOVWF  03
05E90:  MOVF   x00,W
05E92:  MOVFF  03,01
05E96:  CLRF   02
05E98:  CLRF   03
05E9A:  BRA    6004
05E9C:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05E9E:  MOVFF  9FD,00
05EA2:  MOVFF  9FE,01
05EA6:  MOVFF  9FF,02
05EAA:  CLRF   03
05EAC:  MOVF   00,W
05EAE:  MOVLB  A
05EB0:  ADDWF  x04,W
05EB2:  MOVWF  x08
05EB4:  MOVF   01,W
05EB6:  ADDWFC x05,W
05EB8:  MOVWF  x09
05EBA:  MOVF   02,W
05EBC:  ADDWFC x06,W
05EBE:  MOVWF  x0A
05EC0:  MOVF   03,W
05EC2:  ADDWFC x07,W
05EC4:  MOVWF  x0B
05EC6:  MOVWF  x17
05EC8:  MOVFF  A0A,A16
05ECC:  MOVFF  A09,A15
05ED0:  MOVFF  A08,A14
05ED4:  MOVLB  0
05ED6:  RCALL  5A82
05ED8:  MOVF   01,F
05EDA:  BNZ   5EDE
....................                break; 
05EDC:  BRA    5FF6
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05EDE:  BCF    FD8.0
05EE0:  MOVLB  9
05EE2:  RLCF   xFC,W
05EE4:  MOVLB  A
05EE6:  MOVWF  x08
05EE8:  MOVLB  9
05EEA:  RLCF   xFD,W
05EEC:  MOVLB  A
05EEE:  MOVWF  x09
05EF0:  MOVLW  01
05EF2:  ANDWF  x09,F
05EF4:  MOVLW  24
05EF6:  ADDWF  x08,W
05EF8:  MOVWF  01
05EFA:  MOVLW  00
05EFC:  ADDWFC x09,W
05EFE:  MOVWF  03
05F00:  MOVF   01,W
05F02:  MOVLB  7
05F04:  ADDWF  x12,W
05F06:  MOVWF  01
05F08:  MOVF   x13,W
05F0A:  ADDWFC 03,F
05F0C:  MOVFF  01,FE9
05F10:  MOVFF  03,FEA
05F14:  MOVFF  FEF,00
05F18:  MOVFF  FEC,01
05F1C:  CLRF   02
05F1E:  CLRF   03
05F20:  MOVLB  A
05F22:  BRA    6004
05F24:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05F26:  MOVLB  9
05F28:  RRCF   xFF,W
05F2A:  MOVWF  03
05F2C:  RRCF   xFE,W
05F2E:  MOVWF  02
05F30:  RRCF   xFD,W
05F32:  MOVWF  01
05F34:  RRCF   xFC,W
05F36:  MOVWF  00
05F38:  RRCF   03,F
05F3A:  RRCF   02,F
05F3C:  RRCF   01,F
05F3E:  RRCF   00,F
05F40:  RRCF   03,F
05F42:  RRCF   02,F
05F44:  RRCF   01,F
05F46:  RRCF   00,F
05F48:  RRCF   03,F
05F4A:  RRCF   02,F
05F4C:  RRCF   01,F
05F4E:  RRCF   00,F
05F50:  RRCF   03,F
05F52:  RRCF   02,F
05F54:  RRCF   01,F
05F56:  RRCF   00,F
05F58:  RRCF   03,F
05F5A:  RRCF   02,F
05F5C:  RRCF   01,F
05F5E:  RRCF   00,F
05F60:  RRCF   03,F
05F62:  RRCF   02,F
05F64:  RRCF   01,F
05F66:  RRCF   00,F
05F68:  MOVLW  01
05F6A:  ANDWF  03,F
05F6C:  MOVF   00,W
05F6E:  MOVLB  A
05F70:  ADDWF  x04,W
05F72:  MOVWF  x08
05F74:  MOVF   01,W
05F76:  ADDWFC x05,W
05F78:  MOVWF  x09
05F7A:  MOVF   02,W
05F7C:  ADDWFC x06,W
05F7E:  MOVWF  x0A
05F80:  MOVF   03,W
05F82:  ADDWFC x07,W
05F84:  MOVWF  x0B
05F86:  MOVWF  x17
05F88:  MOVFF  A0A,A16
05F8C:  MOVFF  A09,A15
05F90:  MOVFF  A08,A14
05F94:  MOVLB  0
05F96:  RCALL  5A82
05F98:  MOVF   01,F
05F9A:  BNZ   5F9E
....................                break; 
05F9C:  BRA    5FF6
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05F9E:  MOVLB  9
05FA0:  RLCF   xFC,W
05FA2:  MOVLB  A
05FA4:  MOVWF  x08
05FA6:  MOVLB  9
05FA8:  RLCF   xFD,W
05FAA:  MOVLB  A
05FAC:  MOVWF  x09
05FAE:  RLCF   x08,F
05FB0:  RLCF   x09,F
05FB2:  MOVLW  FC
05FB4:  ANDWF  x08,F
05FB6:  MOVLW  01
05FB8:  ANDWF  x09,F
05FBA:  MOVLW  24
05FBC:  ADDWF  x08,W
05FBE:  MOVWF  01
05FC0:  MOVLW  00
05FC2:  ADDWFC x09,W
05FC4:  MOVWF  03
05FC6:  MOVF   01,W
05FC8:  MOVLB  7
05FCA:  ADDWF  x12,W
05FCC:  MOVWF  01
05FCE:  MOVF   x13,W
05FD0:  ADDWFC 03,F
05FD2:  MOVFF  01,FE9
05FD6:  MOVFF  03,FEA
05FDA:  MOVFF  FEF,00
05FDE:  MOVFF  FEC,01
05FE2:  MOVFF  FEC,02
05FE6:  MOVFF  FEC,A0D
05FEA:  MOVLB  A
05FEC:  MOVF   x0D,W
05FEE:  ANDLW  0F
05FF0:  MOVWF  03
05FF2:  BRA    6004
05FF4:  MOVLB  0
05FF6:  MOVLB  9
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
05FF8:  MOVLW  01
05FFA:  MOVWF  00
05FFC:  CLRF   01
05FFE:  CLRF   02
06000:  CLRF   03
06002:  MOVLB  A
06004:  MOVLB  0
06006:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
065CA:  MOVLW  10
065CC:  MOVLB  7
065CE:  ADDWF  x12,W
065D0:  MOVWF  FE9
065D2:  MOVLW  00
065D4:  ADDWFC x13,W
065D6:  MOVWF  FEA
065D8:  MOVFF  FEF,A08
065DC:  MOVFF  FEC,A09
065E0:  MOVFF  FEC,A0A
065E4:  MOVFF  FEC,A0B
....................    switch (fs->fs_type)  
065E8:  MOVF   x12,W
065EA:  MOVWF  FE9
065EC:  MOVF   x13,W
065EE:  MOVWF  FEA
065F0:  MOVF   FEF,W
065F2:  XORLW  01
065F4:  MOVLB  0
065F6:  BZ    6606
065F8:  XORLW  03
065FA:  BTFSC  FD8.2
065FC:  BRA    67EA
065FE:  XORLW  01
06600:  BTFSC  FD8.2
06602:  BRA    6874
06604:  BRA    6944
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
06606:  MOVFF  9FD,A11
0660A:  MOVFF  9FC,A10
0660E:  MOVLB  A
06610:  CLRF   x13
06612:  MOVLW  03
06614:  MOVWF  x12
06616:  MOVLB  0
06618:  CALL   5C98
0661C:  BCF    FD8.0
0661E:  MOVLB  A
06620:  RRCF   02,W
06622:  MOVWF  x05
06624:  RRCF   01,W
06626:  MOVWF  x04
....................          if (!move_window(fatsect + bc / 512)) 
06628:  BCF    FD8.0
0662A:  CLRF   03
0662C:  RRCF   x05,W
0662E:  MOVWF  02
06630:  ADDWF  x08,W
06632:  MOVWF  x0C
06634:  MOVF   03,W
06636:  ADDWFC x09,W
06638:  MOVWF  x0D
0663A:  MOVLW  00
0663C:  ADDWFC x0A,W
0663E:  MOVWF  x0E
06640:  MOVLW  00
06642:  ADDWFC x0B,W
06644:  MOVWF  x0F
06646:  MOVWF  x17
06648:  MOVFF  A0E,A16
0664C:  MOVFF  A0D,A15
06650:  MOVFF  A0C,A14
06654:  MOVLB  0
06656:  CALL   5A82
0665A:  MOVF   01,F
0665C:  BNZ   6664
....................             return (FALSE); 
0665E:  MOVLW  00
06660:  MOVWF  01
06662:  BRA    6962
....................          p = &fs->win[bc % 512]; 
06664:  MOVLB  A
06666:  MOVF   x05,W
06668:  ANDLW  01
0666A:  MOVWF  x0D
0666C:  MOVLW  24
0666E:  ADDWF  x04,W
06670:  MOVWF  01
06672:  MOVLW  00
06674:  ADDWFC x0D,W
06676:  MOVWF  03
06678:  MOVF   01,W
0667A:  MOVLB  7
0667C:  ADDWF  x12,W
0667E:  MOVWF  01
06680:  MOVF   x13,W
06682:  ADDWFC 03,F
06684:  MOVFF  01,A06
06688:  MOVLB  A
0668A:  MOVFF  03,A07
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
0668E:  MOVFF  A06,A0C
06692:  MOVFF  A07,A0D
06696:  MOVLB  9
06698:  MOVF   xFC,W
0669A:  ANDLW  01
0669C:  MOVWF  00
0669E:  CLRF   01
066A0:  CLRF   02
066A2:  CLRF   03
066A4:  MOVF   00,F
066A6:  BNZ   66B4
066A8:  MOVF   01,F
066AA:  BNZ   66B4
066AC:  MOVF   02,F
066AE:  BNZ   66B4
066B0:  MOVF   03,F
066B2:  BZ    66D6
066B4:  MOVFF  A07,03
066B8:  MOVLB  A
066BA:  MOVFF  A06,FE9
066BE:  MOVFF  A07,FEA
066C2:  MOVF   FEF,W
066C4:  ANDLW  0F
066C6:  MOVWF  x0E
066C8:  SWAPF  x00,W
066CA:  MOVWF  00
066CC:  MOVLW  F0
066CE:  ANDWF  00,F
066D0:  MOVF   00,W
066D2:  IORWF  x0E,W
066D4:  BRA    66DA
066D6:  MOVLB  A
066D8:  MOVF   x00,W
066DA:  MOVFF  A0D,FEA
066DE:  MOVFF  A0C,FE9
066E2:  MOVWF  FEF
....................          fs->winflag = 1; 
066E4:  MOVLW  06
066E6:  MOVLB  7
066E8:  ADDWF  x12,W
066EA:  MOVWF  FE9
066EC:  MOVLW  00
066EE:  ADDWFC x13,W
066F0:  MOVWF  FEA
066F2:  MOVLW  01
066F4:  MOVWF  FEF
....................          bc++; 
066F6:  MOVLB  A
066F8:  INCF   x04,F
066FA:  BTFSC  FD8.2
066FC:  INCF   x05,F
....................          if (!move_window(fatsect + bc / 512)) 
066FE:  BCF    FD8.0
06700:  CLRF   03
06702:  RRCF   x05,W
06704:  MOVWF  02
06706:  ADDWF  x08,W
06708:  MOVWF  x0C
0670A:  MOVF   03,W
0670C:  ADDWFC x09,W
0670E:  MOVWF  x0D
06710:  MOVLW  00
06712:  ADDWFC x0A,W
06714:  MOVWF  x0E
06716:  MOVLW  00
06718:  ADDWFC x0B,W
0671A:  MOVWF  x0F
0671C:  MOVWF  x17
0671E:  MOVFF  A0E,A16
06722:  MOVFF  A0D,A15
06726:  MOVFF  A0C,A14
0672A:  MOVLB  0
0672C:  CALL   5A82
06730:  MOVF   01,F
06732:  BNZ   673A
....................             return (FALSE); 
06734:  MOVLW  00
06736:  MOVWF  01
06738:  BRA    6962
....................          p = &fs->win[bc % 512]; 
0673A:  MOVLB  A
0673C:  MOVF   x05,W
0673E:  ANDLW  01
06740:  MOVWF  x0D
06742:  MOVLW  24
06744:  ADDWF  x04,W
06746:  MOVWF  01
06748:  MOVLW  00
0674A:  ADDWFC x0D,W
0674C:  MOVWF  03
0674E:  MOVF   01,W
06750:  MOVLB  7
06752:  ADDWF  x12,W
06754:  MOVWF  01
06756:  MOVF   x13,W
06758:  ADDWFC 03,F
0675A:  MOVFF  01,A06
0675E:  MOVLB  A
06760:  MOVFF  03,A07
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
06764:  MOVFF  A06,A0C
06768:  MOVFF  A07,A0D
0676C:  MOVLB  9
0676E:  MOVF   xFC,W
06770:  ANDLW  01
06772:  MOVWF  00
06774:  CLRF   01
06776:  CLRF   02
06778:  CLRF   03
0677A:  MOVF   00,F
0677C:  BNZ   678A
0677E:  MOVF   01,F
06780:  BNZ   678A
06782:  MOVF   02,F
06784:  BNZ   678A
06786:  MOVF   03,F
06788:  BZ    67BC
0678A:  MOVLB  A
0678C:  RRCF   x03,W
0678E:  MOVWF  03
06790:  RRCF   x02,W
06792:  MOVWF  02
06794:  RRCF   x01,W
06796:  MOVWF  01
06798:  RRCF   x00,W
0679A:  MOVWF  00
0679C:  RRCF   03,F
0679E:  RRCF   02,F
067A0:  RRCF   01,F
067A2:  RRCF   00,F
067A4:  RRCF   03,F
067A6:  RRCF   02,F
067A8:  RRCF   01,F
067AA:  RRCF   00,F
067AC:  RRCF   03,F
067AE:  RRCF   02,F
067B0:  RRCF   01,F
067B2:  RRCF   00,F
067B4:  MOVLW  0F
067B6:  ANDWF  03,F
067B8:  MOVF   00,W
067BA:  BRA    67DE
067BC:  MOVLB  A
067BE:  MOVFF  A06,FE9
067C2:  MOVFF  A07,FEA
067C6:  MOVF   FEF,W
067C8:  ANDLW  F0
067CA:  MOVWF  x0F
067CC:  MOVFF  A01,00
067D0:  MOVFF  A02,01
067D4:  MOVFF  A03,02
067D8:  MOVF   x01,W
067DA:  ANDLW  0F
067DC:  IORWF  x0F,W
067DE:  MOVFF  A0D,FEA
067E2:  MOVFF  A0C,FE9
067E6:  MOVWF  FEF
....................          break; 
067E8:  BRA    694C
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
067EA:  MOVFF  9FD,00
067EE:  MOVFF  9FE,01
067F2:  MOVFF  9FF,02
067F6:  CLRF   03
067F8:  MOVF   00,W
067FA:  MOVLB  A
067FC:  ADDWF  x08,W
067FE:  MOVWF  x0C
06800:  MOVF   01,W
06802:  ADDWFC x09,W
06804:  MOVWF  x0D
06806:  MOVF   02,W
06808:  ADDWFC x0A,W
0680A:  MOVWF  x0E
0680C:  MOVF   03,W
0680E:  ADDWFC x0B,W
06810:  MOVWF  x0F
06812:  MOVWF  x17
06814:  MOVFF  A0E,A16
06818:  MOVFF  A0D,A15
0681C:  MOVFF  A0C,A14
06820:  MOVLB  0
06822:  CALL   5A82
06826:  MOVF   01,F
06828:  BNZ   6830
....................             return (FALSE); 
0682A:  MOVLW  00
0682C:  MOVWF  01
0682E:  BRA    6962
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
06830:  BCF    FD8.0
06832:  MOVLB  9
06834:  RLCF   xFC,W
06836:  MOVLB  A
06838:  MOVWF  x0C
0683A:  MOVLB  9
0683C:  RLCF   xFD,W
0683E:  MOVLB  A
06840:  MOVWF  x0D
06842:  MOVLW  01
06844:  ANDWF  x0D,F
06846:  MOVLW  24
06848:  ADDWF  x0C,W
0684A:  MOVWF  01
0684C:  MOVLW  00
0684E:  ADDWFC x0D,W
06850:  MOVWF  03
06852:  MOVF   01,W
06854:  MOVLB  7
06856:  ADDWF  x12,W
06858:  MOVWF  01
0685A:  MOVF   x13,W
0685C:  ADDWFC 03,F
0685E:  MOVFF  01,FE9
06862:  MOVFF  03,FEA
06866:  MOVFF  A01,FEC
0686A:  MOVF   FED,F
0686C:  MOVFF  A00,FEF
....................          break; 
06870:  MOVLB  A
06872:  BRA    694C
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
06874:  MOVLB  9
06876:  RRCF   xFF,W
06878:  MOVWF  03
0687A:  RRCF   xFE,W
0687C:  MOVWF  02
0687E:  RRCF   xFD,W
06880:  MOVWF  01
06882:  RRCF   xFC,W
06884:  MOVWF  00
06886:  RRCF   03,F
06888:  RRCF   02,F
0688A:  RRCF   01,F
0688C:  RRCF   00,F
0688E:  RRCF   03,F
06890:  RRCF   02,F
06892:  RRCF   01,F
06894:  RRCF   00,F
06896:  RRCF   03,F
06898:  RRCF   02,F
0689A:  RRCF   01,F
0689C:  RRCF   00,F
0689E:  RRCF   03,F
068A0:  RRCF   02,F
068A2:  RRCF   01,F
068A4:  RRCF   00,F
068A6:  RRCF   03,F
068A8:  RRCF   02,F
068AA:  RRCF   01,F
068AC:  RRCF   00,F
068AE:  RRCF   03,F
068B0:  RRCF   02,F
068B2:  RRCF   01,F
068B4:  RRCF   00,F
068B6:  MOVLW  01
068B8:  ANDWF  03,F
068BA:  MOVF   00,W
068BC:  MOVLB  A
068BE:  ADDWF  x08,W
068C0:  MOVWF  x0C
068C2:  MOVF   01,W
068C4:  ADDWFC x09,W
068C6:  MOVWF  x0D
068C8:  MOVF   02,W
068CA:  ADDWFC x0A,W
068CC:  MOVWF  x0E
068CE:  MOVF   03,W
068D0:  ADDWFC x0B,W
068D2:  MOVWF  x0F
068D4:  MOVWF  x17
068D6:  MOVFF  A0E,A16
068DA:  MOVFF  A0D,A15
068DE:  MOVFF  A0C,A14
068E2:  MOVLB  0
068E4:  CALL   5A82
068E8:  MOVF   01,F
068EA:  BNZ   68F2
....................             return (FALSE); 
068EC:  MOVLW  00
068EE:  MOVWF  01
068F0:  BRA    6962
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
068F2:  MOVLB  9
068F4:  RLCF   xFC,W
068F6:  MOVLB  A
068F8:  MOVWF  x0C
068FA:  MOVLB  9
068FC:  RLCF   xFD,W
068FE:  MOVLB  A
06900:  MOVWF  x0D
06902:  RLCF   x0C,F
06904:  RLCF   x0D,F
06906:  MOVLW  FC
06908:  ANDWF  x0C,F
0690A:  MOVLW  01
0690C:  ANDWF  x0D,F
0690E:  MOVLW  24
06910:  ADDWF  x0C,W
06912:  MOVWF  01
06914:  MOVLW  00
06916:  ADDWFC x0D,W
06918:  MOVWF  03
0691A:  MOVF   01,W
0691C:  MOVLB  7
0691E:  ADDWF  x12,W
06920:  MOVWF  01
06922:  MOVF   x13,W
06924:  ADDWFC 03,F
06926:  MOVFF  01,FE9
0692A:  MOVFF  03,FEA
0692E:  MOVFF  A00,FEF
06932:  MOVFF  A01,FEC
06936:  MOVFF  A02,FEC
0693A:  MOVFF  A03,FEC
....................          break; 
0693E:  MOVLB  A
06940:  BRA    694C
06942:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
06944:  MOVLW  00
06946:  MOVWF  01
06948:  BRA    6962
0694A:  MOVLB  A
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
0694C:  MOVLW  06
0694E:  MOVLB  7
06950:  ADDWF  x12,W
06952:  MOVWF  FE9
06954:  MOVLW  00
06956:  ADDWFC x13,W
06958:  MOVWF  FEA
0695A:  MOVLW  01
0695C:  MOVWF  FEF
....................    return (TRUE); 
0695E:  MOVWF  01
06960:  MOVLB  0
06962:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06F46:  MOVFF  9DE,9FF
06F4A:  MOVFF  9DD,9FE
06F4E:  MOVFF  9DC,9FD
06F52:  MOVFF  9DB,9FC
06F56:  CALL   5CBA
06F5A:  MOVFF  03,9E2
06F5E:  MOVFF  02,9E1
06F62:  MOVFF  01,9E0
06F66:  MOVFF  00,9DF
06F6A:  MOVLB  9
06F6C:  MOVF   xE2,F
06F6E:  BNZ   6F7E
06F70:  MOVF   xE1,F
06F72:  BNZ   6F7E
06F74:  MOVF   xE0,F
06F76:  BNZ   6F7E
06F78:  MOVF   xDF,W
06F7A:  SUBLW  01
06F7C:  BC    6FE0
....................       { 
....................       if (!put_cluster(clust, 0)) 
06F7E:  MOVFF  9DE,9FF
06F82:  MOVFF  9DD,9FE
06F86:  MOVFF  9DC,9FD
06F8A:  MOVFF  9DB,9FC
06F8E:  MOVLB  A
06F90:  CLRF   x03
06F92:  CLRF   x02
06F94:  CLRF   x01
06F96:  CLRF   x00
06F98:  MOVLB  0
06F9A:  CALL   65CA
06F9E:  MOVF   01,F
06FA0:  BNZ   6FA8
....................          return FALSE; 
06FA2:  MOVLW  00
06FA4:  MOVWF  01
06FA6:  BRA    6FE6
....................       clust = nxt; 
06FA8:  MOVFF  9E2,9DE
06FAC:  MOVFF  9E1,9DD
06FB0:  MOVFF  9E0,9DC
06FB4:  MOVFF  9DF,9DB
06FB8:  MOVFF  9DE,9FF
06FBC:  MOVFF  9DD,9FE
06FC0:  MOVFF  9DC,9FD
06FC4:  MOVFF  9DB,9FC
06FC8:  CALL   5CBA
06FCC:  MOVFF  03,9E2
06FD0:  MOVFF  02,9E1
06FD4:  MOVFF  01,9E0
06FD8:  MOVFF  00,9DF
06FDC:  BRA    6F6A
06FDE:  MOVLB  9
....................       } 
....................    return TRUE; 
06FE0:  MOVLW  01
06FE2:  MOVWF  01
06FE4:  MOVLB  0
06FE6:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
06964:  MOVLW  0C
06966:  MOVLB  7
06968:  ADDWF  x12,W
0696A:  MOVWF  FE9
0696C:  MOVLW  00
0696E:  ADDWFC x13,W
06970:  MOVWF  FEA
06972:  MOVFF  FEF,9F8
06976:  MOVFF  FEC,9F9
0697A:  MOVFF  FEC,9FA
0697E:  MOVFF  FEC,9FB
....................    if (clust == 0)  
06982:  MOVLB  9
06984:  MOVF   xE8,F
06986:  BNZ   69F0
06988:  MOVF   xE9,F
0698A:  BNZ   69F0
0698C:  MOVF   xEA,F
0698E:  BNZ   69F0
06990:  MOVF   xEB,F
06992:  BNZ   69F0
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
06994:  MOVLW  1C
06996:  MOVLB  7
06998:  ADDWF  x12,W
0699A:  MOVWF  FE9
0699C:  MOVLW  00
0699E:  ADDWFC x13,W
069A0:  MOVWF  FEA
069A2:  MOVFF  FEF,9F4
069A6:  MOVFF  FEC,9F5
069AA:  MOVFF  FEC,9F6
069AE:  MOVFF  FEC,9F7
....................       if (scl < 2 || scl >= mcl) scl = 1; 
069B2:  MOVLB  9
069B4:  MOVF   xF7,F
069B6:  BNZ   69C6
069B8:  MOVF   xF6,F
069BA:  BNZ   69C6
069BC:  MOVF   xF5,F
069BE:  BNZ   69C6
069C0:  MOVF   xF4,W
069C2:  SUBLW  01
069C4:  BC    69E4
069C6:  MOVF   xFB,W
069C8:  SUBWF  xF7,W
069CA:  BNC   69EE
069CC:  BNZ   69E4
069CE:  MOVF   xFA,W
069D0:  SUBWF  xF6,W
069D2:  BNC   69EE
069D4:  BNZ   69E4
069D6:  MOVF   xF9,W
069D8:  SUBWF  xF5,W
069DA:  BNC   69EE
069DC:  BNZ   69E4
069DE:  MOVF   xF8,W
069E0:  SUBWF  xF4,W
069E2:  BNC   69EE
069E4:  CLRF   xF7
069E6:  CLRF   xF6
069E8:  CLRF   xF5
069EA:  MOVLW  01
069EC:  MOVWF  xF4
....................       } 
069EE:  BRA    6A74
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
069F0:  MOVFF  9EB,9FF
069F4:  MOVFF  9EA,9FE
069F8:  MOVFF  9E9,9FD
069FC:  MOVFF  9E8,9FC
06A00:  MOVLB  0
06A02:  CALL   5CBA
06A06:  MOVFF  03,9EF
06A0A:  MOVFF  02,9EE
06A0E:  MOVFF  01,9ED
06A12:  MOVFF  00,9EC
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06A16:  MOVLB  9
06A18:  MOVF   xEF,F
06A1A:  BNZ   6A34
06A1C:  MOVF   xEE,F
06A1E:  BNZ   6A34
06A20:  MOVF   xED,F
06A22:  BNZ   6A34
06A24:  MOVF   xEC,W
06A26:  SUBLW  01
06A28:  BNC   6A34
06A2A:  CLRF   00
06A2C:  CLRF   01
06A2E:  CLRF   02
06A30:  CLRF   03
06A32:  BRA    6BF8
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
06A34:  MOVF   xEF,W
06A36:  SUBWF  xFB,W
06A38:  BNC   6A64
06A3A:  BNZ   6A52
06A3C:  MOVF   xEE,W
06A3E:  SUBWF  xFA,W
06A40:  BNC   6A64
06A42:  BNZ   6A52
06A44:  MOVF   xED,W
06A46:  SUBWF  xF9,W
06A48:  BNC   6A64
06A4A:  BNZ   6A52
06A4C:  MOVF   xF8,W
06A4E:  SUBWF  xEC,W
06A50:  BC    6A64
06A52:  MOVFF  9EC,00
06A56:  MOVFF  9ED,01
06A5A:  MOVFF  9EE,02
06A5E:  MOVFF  9EF,03
06A62:  BRA    6BF8
....................       scl = clust; 
06A64:  MOVFF  9EB,9F7
06A68:  MOVFF  9EA,9F6
06A6C:  MOVFF  9E9,9F5
06A70:  MOVFF  9E8,9F4
....................       } 
....................       ncl = scl;                  // Scan start cluster 
06A74:  MOVFF  9F7,9F3
06A78:  MOVFF  9F6,9F2
06A7C:  MOVFF  9F5,9F1
06A80:  MOVFF  9F4,9F0
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
06A84:  MOVLW  01
06A86:  ADDWF  xF0,F
06A88:  BTFSC  FD8.0
06A8A:  INCF   xF1,F
06A8C:  BTFSC  FD8.2
06A8E:  INCF   xF2,F
06A90:  BTFSC  FD8.2
06A92:  INCF   xF3,F
....................       if (ncl >= mcl)  
06A94:  MOVF   xFB,W
06A96:  SUBWF  xF3,W
06A98:  BNC   6AD6
06A9A:  BNZ   6AB2
06A9C:  MOVF   xFA,W
06A9E:  SUBWF  xF2,W
06AA0:  BNC   6AD6
06AA2:  BNZ   6AB2
06AA4:  MOVF   xF9,W
06AA6:  SUBWF  xF1,W
06AA8:  BNC   6AD6
06AAA:  BNZ   6AB2
06AAC:  MOVF   xF8,W
06AAE:  SUBWF  xF0,W
06AB0:  BNC   6AD6
....................          {         // Wrap around 
....................          ncl = 2; 
06AB2:  CLRF   xF3
06AB4:  CLRF   xF2
06AB6:  CLRF   xF1
06AB8:  MOVLW  02
06ABA:  MOVWF  xF0
....................          if (scl == 1) return 0;      // No free custer was found 
06ABC:  DECFSZ xF4,W
06ABE:  BRA    6AD6
06AC0:  MOVF   xF5,F
06AC2:  BNZ   6AD6
06AC4:  MOVF   xF6,F
06AC6:  BNZ   6AD6
06AC8:  MOVF   xF7,F
06ACA:  BNZ   6AD6
06ACC:  CLRF   00
06ACE:  CLRF   01
06AD0:  CLRF   02
06AD2:  CLRF   03
06AD4:  BRA    6BF8
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06AD6:  MOVF   xF4,W
06AD8:  SUBWF  xF0,W
06ADA:  BNZ   6AF8
06ADC:  MOVF   xF5,W
06ADE:  SUBWF  xF1,W
06AE0:  BNZ   6AF8
06AE2:  MOVF   xF6,W
06AE4:  SUBWF  xF2,W
06AE6:  BNZ   6AF8
06AE8:  MOVF   xF7,W
06AEA:  SUBWF  xF3,W
06AEC:  BNZ   6AF8
06AEE:  CLRF   00
06AF0:  CLRF   01
06AF2:  CLRF   02
06AF4:  CLRF   03
06AF6:  BRA    6BF8
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06AF8:  MOVFF  9F3,9FF
06AFC:  MOVFF  9F2,9FE
06B00:  MOVFF  9F1,9FD
06B04:  MOVFF  9F0,9FC
06B08:  MOVLB  0
06B0A:  CALL   5CBA
06B0E:  MOVFF  03,9EF
06B12:  MOVFF  02,9EE
06B16:  MOVFF  01,9ED
06B1A:  MOVFF  00,9EC
....................       if (cstat == 1) return 0;      // Any error occured 
06B1E:  MOVLB  9
06B20:  DECFSZ xEC,W
06B22:  BRA    6B3A
06B24:  MOVF   xED,F
06B26:  BNZ   6B3A
06B28:  MOVF   xEE,F
06B2A:  BNZ   6B3A
06B2C:  MOVF   xEF,F
06B2E:  BNZ   6B3A
06B30:  CLRF   00
06B32:  CLRF   01
06B34:  CLRF   02
06B36:  CLRF   03
06B38:  BRA    6BF8
....................       } while (cstat);            // Repeat until find a free cluster 
06B3A:  MOVF   xEC,F
06B3C:  BNZ   6A84
06B3E:  MOVF   xED,F
06B40:  BNZ   6A84
06B42:  MOVF   xEE,F
06B44:  BNZ   6A84
06B46:  MOVF   xEF,F
06B48:  BNZ   6A84
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06B4A:  MOVFF  9F3,9FF
06B4E:  MOVFF  9F2,9FE
06B52:  MOVFF  9F1,9FD
06B56:  MOVFF  9F0,9FC
06B5A:  MOVLW  0F
06B5C:  MOVLB  A
06B5E:  MOVWF  x03
06B60:  SETF   x02
06B62:  SETF   x01
06B64:  SETF   x00
06B66:  MOVLB  0
06B68:  RCALL  65CA
06B6A:  MOVF   01,F
06B6C:  BNZ   6B7C
06B6E:  CLRF   00
06B70:  CLRF   01
06B72:  CLRF   02
06B74:  CLRF   03
06B76:  MOVLB  9
06B78:  BRA    6BF8
06B7A:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06B7C:  MOVLB  9
06B7E:  MOVF   xE8,F
06B80:  BNZ   6B8E
06B82:  MOVF   xE9,F
06B84:  BNZ   6B8E
06B86:  MOVF   xEA,F
06B88:  BNZ   6B8E
06B8A:  MOVF   xEB,F
06B8C:  BZ    6BC8
06B8E:  MOVFF  9EB,9FF
06B92:  MOVFF  9EA,9FE
06B96:  MOVFF  9E9,9FD
06B9A:  MOVFF  9E8,9FC
06B9E:  MOVFF  9F3,A03
06BA2:  MOVFF  9F2,A02
06BA6:  MOVFF  9F1,A01
06BAA:  MOVFF  9F0,A00
06BAE:  MOVLB  0
06BB0:  RCALL  65CA
06BB2:  MOVF   01,F
06BB4:  BTFSC  FD8.2
06BB6:  BRA    6BBC
06BB8:  MOVLB  9
06BBA:  BRA    6BC8
06BBC:  CLRF   00
06BBE:  CLRF   01
06BC0:  CLRF   02
06BC2:  CLRF   03
06BC4:  MOVLB  9
06BC6:  BRA    6BF8
....................    fs->last_clust = ncl; 
06BC8:  MOVLW  1C
06BCA:  MOVLB  7
06BCC:  ADDWF  x12,W
06BCE:  MOVWF  FE9
06BD0:  MOVLW  00
06BD2:  ADDWFC x13,W
06BD4:  MOVWF  FEA
06BD6:  MOVFF  9F0,FEF
06BDA:  MOVFF  9F1,FEC
06BDE:  MOVFF  9F2,FEC
06BE2:  MOVFF  9F3,FEC
....................  
....................    return ncl;      // Return new cluster number 
06BE6:  MOVFF  9F0,00
06BEA:  MOVFF  9F1,01
06BEE:  MOVFF  9F2,02
06BF2:  MOVFF  9F3,03
06BF6:  MOVLB  9
06BF8:  MOVLB  0
06BFA:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
0560E:  MOVLW  02
05610:  MOVLB  9
05612:  SUBWF  xEF,F
05614:  MOVLW  00
05616:  SUBWFB xF0,F
05618:  SUBWFB xF1,F
0561A:  SUBWFB xF2,F
....................    if (clust >= fs->max_clust)  
0561C:  MOVLW  0C
0561E:  MOVLB  7
05620:  ADDWF  x12,W
05622:  MOVWF  FE9
05624:  MOVLW  00
05626:  ADDWFC x13,W
05628:  MOVWF  FEA
0562A:  MOVFF  FEF,00
0562E:  MOVFF  FEC,01
05632:  MOVFF  FEC,02
05636:  MOVFF  FEC,03
0563A:  MOVF   03,W
0563C:  MOVLB  9
0563E:  SUBWF  xF2,W
05640:  BNC   5664
05642:  BNZ   565A
05644:  MOVF   02,W
05646:  SUBWF  xF1,W
05648:  BNC   5664
0564A:  BNZ   565A
0564C:  MOVF   01,W
0564E:  SUBWF  xF0,W
05650:  BNC   5664
05652:  BNZ   565A
05654:  MOVF   00,W
05656:  SUBWF  xEF,W
05658:  BNC   5664
....................       return 0;      // Invalid cluster#  
0565A:  CLRF   00
0565C:  CLRF   01
0565E:  CLRF   02
05660:  CLRF   03
05662:  BRA    56E4
....................    return (clust * fs->sects_clust + fs->database); 
05664:  MOVLW  02
05666:  MOVLB  7
05668:  ADDWF  x12,W
0566A:  MOVWF  FE9
0566C:  MOVLW  00
0566E:  ADDWFC x13,W
05670:  MOVWF  FEA
05672:  MOVFF  FEF,9FA
05676:  MOVLB  9
05678:  MOVFF  FEA,9F5
0567C:  MOVFF  FE9,9F4
05680:  MOVFF  9F2,9F9
05684:  MOVFF  9F1,9F8
05688:  MOVFF  9F0,9F7
0568C:  MOVFF  9EF,9F6
05690:  CLRF   xFD
05692:  CLRF   xFC
05694:  CLRF   xFB
05696:  MOVLB  0
05698:  CALL   47F0
0569C:  MOVFF  9F5,FEA
056A0:  MOVFF  9F4,FE9
056A4:  MOVFF  03,9F6
056A8:  MOVFF  02,9F5
056AC:  MOVFF  01,9F4
056B0:  MOVFF  00,9F3
056B4:  MOVLW  18
056B6:  MOVLB  7
056B8:  ADDWF  x12,W
056BA:  MOVWF  FE9
056BC:  MOVLW  00
056BE:  ADDWFC x13,W
056C0:  MOVWF  FEA
056C2:  MOVFF  FEF,00
056C6:  MOVFF  FEC,01
056CA:  MOVFF  FEC,02
056CE:  MOVFF  FEC,03
056D2:  MOVLB  9
056D4:  MOVF   xF3,W
056D6:  ADDWF  00,F
056D8:  MOVF   xF4,W
056DA:  ADDWFC 01,F
056DC:  MOVF   xF5,W
056DE:  ADDWFC 02,F
056E0:  MOVF   xF6,W
056E2:  ADDWFC 03,F
056E4:  MOVLB  0
056E6:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
04690:  MOVLW  24
04692:  MOVLB  7
04694:  ADDWF  x12,W
04696:  MOVWF  01
04698:  MOVLW  00
0469A:  ADDWFC x13,W
0469C:  MOVWF  03
0469E:  MOVFF  01,9E7
046A2:  MOVLB  9
046A4:  MOVWF  xE8
046A6:  MOVWF  FEA
046A8:  MOVFF  01,FE9
046AC:  CLRF   00
046AE:  MOVLW  02
046B0:  MOVWF  02
046B2:  CLRF   01
046B4:  MOVLB  0
046B6:  CALL   3526
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
046BA:  MOVLW  24
046BC:  MOVLB  7
046BE:  ADDWF  x12,W
046C0:  MOVWF  01
046C2:  MOVLW  00
046C4:  ADDWFC x13,W
046C6:  MOVWF  03
046C8:  MOVFF  01,9E7
046CC:  MOVLB  9
046CE:  MOVWF  xE8
046D0:  MOVFF  FE8,A21
046D4:  MOVFF  01,A20
046D8:  MOVFF  9E6,A25
046DC:  MOVFF  9E5,A24
046E0:  MOVFF  9E4,A23
046E4:  MOVFF  9E3,A22
046E8:  MOVLW  01
046EA:  MOVLB  A
046EC:  MOVWF  x26
046EE:  MOVLB  0
046F0:  RCALL  44CC
046F2:  MOVF   01,F
046F4:  BTFSS  FD8.2
046F6:  BRA    47E6
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
046F8:  MOVLW  22
046FA:  MOVLB  7
046FC:  ADDWF  x12,W
046FE:  MOVWF  01
04700:  MOVLW  02
04702:  ADDWFC x13,W
04704:  MOVWF  03
04706:  MOVFF  01,FE9
0470A:  MOVWF  FEA
0470C:  MOVFF  FEC,9E8
04710:  MOVF   FED,F
04712:  MOVFF  FEF,9E7
04716:  MOVLB  9
04718:  MOVF   xE7,W
0471A:  SUBLW  55
0471C:  BNZ   47E8
0471E:  MOVF   xE8,W
04720:  SUBLW  AA
04722:  BNZ   47E8
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
04724:  MOVLW  5A
04726:  MOVLB  7
04728:  ADDWF  x12,W
0472A:  MOVWF  01
0472C:  MOVLW  00
0472E:  ADDWFC x13,W
04730:  MOVWF  03
04732:  MOVFF  01,9E7
04736:  MOVLB  9
04738:  MOVWF  xE8
0473A:  MOVWF  xEA
0473C:  MOVFF  01,9E9
04740:  MOVLW  07
04742:  MOVWF  xEC
04744:  MOVLW  14
04746:  MOVWF  xEB
04748:  CLRF   xEE
0474A:  MOVLW  05
0474C:  MOVWF  xED
0474E:  MOVLB  0
04750:  RCALL  460C
04752:  MOVF   01,F
04754:  BNZ   475C
....................             return (FS_FAT12); 
04756:  MOVLW  01
04758:  MOVWF  01
0475A:  BRA    47EE
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
0475C:  MOVLW  5A
0475E:  MOVLB  7
04760:  ADDWF  x12,W
04762:  MOVWF  01
04764:  MOVLW  00
04766:  ADDWFC x13,W
04768:  MOVWF  03
0476A:  MOVFF  01,9E7
0476E:  MOVLB  9
04770:  MOVWF  xE8
04772:  MOVWF  xEA
04774:  MOVFF  01,9E9
04778:  MOVLW  07
0477A:  MOVWF  xEC
0477C:  MOVLW  19
0477E:  MOVWF  xEB
04780:  CLRF   xEE
04782:  MOVLW  05
04784:  MOVWF  xED
04786:  MOVLB  0
04788:  RCALL  460C
0478A:  MOVF   01,F
0478C:  BNZ   4794
....................             return (FS_FAT16); 
0478E:  MOVLW  02
04790:  MOVWF  01
04792:  BRA    47EE
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
04794:  MOVLW  76
04796:  MOVLB  7
04798:  ADDWF  x12,W
0479A:  MOVWF  01
0479C:  MOVLW  00
0479E:  ADDWFC x13,W
047A0:  MOVWF  03
047A2:  MOVFF  01,9E7
047A6:  MOVLB  9
047A8:  MOVWF  xE8
047AA:  MOVWF  xEA
047AC:  MOVFF  01,9E9
047B0:  MOVLW  07
047B2:  MOVWF  xEC
047B4:  MOVLW  1E
047B6:  MOVWF  xEB
047B8:  CLRF   xEE
047BA:  MOVLW  05
047BC:  MOVWF  xED
047BE:  MOVLB  0
047C0:  RCALL  460C
047C2:  MOVF   01,F
047C4:  BNZ   47E6
047C6:  MOVLW  4C
047C8:  MOVLB  7
047CA:  ADDWF  x12,W
047CC:  MOVWF  FE9
047CE:  MOVLW  00
047D0:  ADDWFC x13,W
047D2:  MOVWF  FEA
047D4:  MOVF   FEF,F
047D6:  BTFSC  FD8.2
047D8:  BRA    47DE
047DA:  MOVLB  0
047DC:  BRA    47E6
....................             return (FS_FAT32); 
047DE:  MOVLW  03
047E0:  MOVWF  01
047E2:  MOVLB  0
047E4:  BRA    47EE
047E6:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
047E8:  MOVLW  00
047EA:  MOVWF  01
047EC:  MOVLB  0
047EE:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
06008:  MOVLW  0C
0600A:  MOVLB  9
0600C:  ADDWF  xE5,W
0600E:  MOVWF  FE9
06010:  MOVLW  00
06012:  ADDWFC xE6,W
06014:  MOVWF  FEA
06016:  MOVFF  FEC,9EE
0601A:  MOVF   FED,F
0601C:  MOVFF  FEF,9ED
06020:  MOVLW  01
06022:  ADDWF  xED,W
06024:  MOVWF  xEB
06026:  MOVLW  00
06028:  ADDWFC xEE,W
0602A:  MOVWF  xEC
....................    if ((idx & 15) == 0)  
0602C:  MOVF   xEB,W
0602E:  ANDLW  0F
06030:  MOVWF  xED
06032:  CLRF   xEE
06034:  MOVF   xED,F
06036:  BTFSS  FD8.2
06038:  BRA    61C4
0603A:  MOVF   xEE,F
0603C:  BTFSS  FD8.2
0603E:  BRA    61C4
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
06040:  MOVLW  08
06042:  ADDWF  xE5,W
06044:  MOVWF  FE9
06046:  MOVLW  00
06048:  ADDWFC xE6,W
0604A:  MOVWF  FEA
0604C:  MOVLW  01
0604E:  ADDWF  FEE,F
06050:  MOVLW  00
06052:  ADDWFC FEE,F
06054:  ADDWFC FEE,F
06056:  ADDWFC FED,F
....................       if (!scan->clust)  
06058:  MOVLW  04
0605A:  ADDWF  xE5,W
0605C:  MOVWF  FE9
0605E:  MOVLW  00
06060:  ADDWFC xE6,W
06062:  MOVWF  FEA
06064:  MOVF   FEF,F
06066:  BNZ   60A4
06068:  MOVF   FEC,F
0606A:  BNZ   60A4
0606C:  MOVF   FEC,F
0606E:  BNZ   60A4
06070:  MOVF   FEC,F
06072:  BNZ   60A4
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
06074:  MOVLW  04
06076:  MOVLB  7
06078:  ADDWF  x12,W
0607A:  MOVWF  FE9
0607C:  MOVLW  00
0607E:  ADDWFC x13,W
06080:  MOVWF  FEA
06082:  MOVFF  FEC,03
06086:  MOVF   FED,F
06088:  MOVFF  FEF,01
0608C:  MOVF   03,W
0608E:  MOVLB  9
06090:  SUBWF  xEC,W
06092:  BNC   60A2
06094:  BNZ   609C
06096:  MOVF   01,W
06098:  SUBWF  xEB,W
0609A:  BNC   60A2
....................             return (FALSE);   // Reached to end of table  
0609C:  MOVLW  00
0609E:  MOVWF  01
060A0:  BRA    61DE
....................          }  
060A2:  BRA    61C4
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
060A4:  RRCF   xEC,W
060A6:  MOVWF  xEE
060A8:  RRCF   xEB,W
060AA:  MOVWF  xED
060AC:  RRCF   xEE,F
060AE:  RRCF   xED,F
060B0:  RRCF   xEE,F
060B2:  RRCF   xED,F
060B4:  RRCF   xEE,F
060B6:  RRCF   xED,F
060B8:  MOVLW  0F
060BA:  ANDWF  xEE,F
060BC:  MOVLW  02
060BE:  MOVLB  7
060C0:  ADDWF  x12,W
060C2:  MOVWF  FE9
060C4:  MOVLW  00
060C6:  ADDWFC x13,W
060C8:  MOVWF  FEA
060CA:  MOVLW  01
060CC:  SUBWF  FEF,W
060CE:  MOVLB  9
060D0:  ANDWF  xED,F
060D2:  CLRF   xEE
060D4:  MOVF   xED,F
060D6:  BTFSS  FD8.2
060D8:  BRA    61C4
060DA:  MOVF   xEE,F
060DC:  BTFSS  FD8.2
060DE:  BRA    61C4
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
060E0:  MOVLW  04
060E2:  ADDWF  xE5,W
060E4:  MOVWF  FE9
060E6:  MOVLW  00
060E8:  ADDWFC xE6,W
060EA:  MOVWF  FEA
060EC:  MOVFF  FEF,9FC
060F0:  MOVFF  FEC,9FD
060F4:  MOVFF  FEC,9FE
060F8:  MOVFF  FEC,9FF
060FC:  MOVLB  0
060FE:  RCALL  5CBA
06100:  MOVFF  03,9EA
06104:  MOVFF  02,9E9
06108:  MOVFF  01,9E8
0610C:  MOVFF  00,9E7
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06110:  MOVLW  0C
06112:  MOVLB  7
06114:  ADDWF  x12,W
06116:  MOVWF  FE9
06118:  MOVLW  00
0611A:  ADDWFC x13,W
0611C:  MOVWF  FEA
0611E:  MOVFF  FEF,00
06122:  MOVFF  FEC,01
06126:  MOVFF  FEC,02
0612A:  MOVFF  FEC,03
0612E:  MOVF   03,W
06130:  MOVLB  9
06132:  SUBWF  xEA,W
06134:  BNC   614E
06136:  BNZ   6160
06138:  MOVF   02,W
0613A:  SUBWF  xE9,W
0613C:  BNC   614E
0613E:  BNZ   6160
06140:  MOVF   01,W
06142:  SUBWF  xE8,W
06144:  BNC   614E
06146:  BNZ   6160
06148:  MOVF   00,W
0614A:  SUBWF  xE7,W
0614C:  BC    6160
0614E:  MOVF   xEA,F
06150:  BNZ   6166
06152:  MOVF   xE9,F
06154:  BNZ   6166
06156:  MOVF   xE8,F
06158:  BNZ   6166
0615A:  MOVF   xE7,W
0615C:  SUBLW  01
0615E:  BNC   6166
....................                return (FALSE); 
06160:  MOVLW  00
06162:  MOVWF  01
06164:  BRA    61DE
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
06166:  MOVLW  04
06168:  ADDWF  xE5,W
0616A:  MOVWF  FE9
0616C:  MOVLW  00
0616E:  ADDWFC xE6,W
06170:  MOVWF  FEA
06172:  MOVFF  9E7,FEF
06176:  MOVFF  9E8,FEC
0617A:  MOVFF  9E9,FEC
0617E:  MOVFF  9EA,FEC
....................             scan->sect = clust2sect(clust); 
06182:  MOVLW  08
06184:  ADDWF  xE5,W
06186:  MOVWF  01
06188:  MOVLW  00
0618A:  ADDWFC xE6,W
0618C:  MOVWF  03
0618E:  MOVFF  01,9ED
06192:  MOVWF  xEE
06194:  MOVFF  9EA,9F2
06198:  MOVFF  9E9,9F1
0619C:  MOVFF  9E8,9F0
061A0:  MOVFF  9E7,9EF
061A4:  MOVLB  0
061A6:  CALL   560E
061AA:  MOVFF  9EE,FEA
061AE:  MOVFF  9ED,FE9
061B2:  MOVFF  00,FEF
061B6:  MOVFF  01,FEC
061BA:  MOVFF  02,FEC
061BE:  MOVFF  03,FEC
061C2:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
061C4:  MOVLW  0C
061C6:  ADDWF  xE5,W
061C8:  MOVWF  FE9
061CA:  MOVLW  00
061CC:  ADDWFC xE6,W
061CE:  MOVWF  FEA
061D0:  MOVFF  9EC,FEC
061D4:  MOVF   FED,F
061D6:  MOVFF  9EB,FEF
....................    return (TRUE); 
061DA:  MOVLW  01
061DC:  MOVWF  01
061DE:  MOVLB  0
061E0:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
056E8:  MOVFF  9E8,FEA
056EC:  MOVFF  9E7,FE9
056F0:  MOVLW  20
056F2:  MOVWF  00
056F4:  CLRF   02
056F6:  MOVLW  0B
056F8:  MOVWF  01
056FA:  CALL   3526
....................    a = 0; b = 0x18;            // NT flag 
056FE:  MOVLB  9
05700:  CLRF   xEC
05702:  MOVLW  18
05704:  MOVWF  xED
....................    n = 0; t = 8; 
05706:  CLRF   xE9
05708:  MOVLW  08
0570A:  MOVWF  xEA
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
0570C:  MOVFF  9E5,FE9
05710:  MOVFF  9E6,FEA
05714:  MOVFF  FEC,9EF
05718:  MOVF   FED,F
0571A:  MOVFF  FEF,9EE
....................       c = *ptr; 
0571E:  MOVFF  9EE,FE9
05722:  MOVFF  9EF,FEA
05726:  MOVFF  FEF,9EB
....................       (*path)++; 
0572A:  MOVFF  9E6,03
0572E:  MOVFF  9E5,FE9
05732:  MOVFF  9E6,FEA
05736:  MOVLW  01
05738:  ADDWF  FEE,F
0573A:  BNC   573E
0573C:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
0573E:  MOVF   xEB,W
05740:  SUBLW  20
05742:  BNC   5746
....................          c = 0; 
05744:  CLRF   xEB
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
05746:  MOVF   xEB,F
05748:  BZ    5756
0574A:  MOVF   xEB,W
0574C:  SUBLW  2F
0574E:  BZ    5756
05750:  MOVF   xEB,W
05752:  SUBLW  5C
05754:  BNZ   5774
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
05756:  MOVF   xE9,F
05758:  BNZ   575C
....................             break; 
0575A:  BRA    583C
....................          dirname[11] = a & b;  
0575C:  MOVLW  0B
0575E:  ADDWF  xE7,W
05760:  MOVWF  FE9
05762:  MOVLW  00
05764:  ADDWFC xE8,W
05766:  MOVWF  FEA
05768:  MOVF   xEC,W
0576A:  ANDWF  xED,W
0576C:  MOVWF  FEF
....................             return (c); 
0576E:  MOVFF  9EB,01
05772:  BRA    5840
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
05774:  MOVF   xEB,W
05776:  SUBLW  20
05778:  BC    5780
0577A:  MOVF   xEB,W
0577C:  SUBLW  7F
0577E:  BNZ   5782
....................          break;   // reject invisible characters 
05780:  BRA    583C
....................       if (c == '.')  
05782:  MOVF   xEB,W
05784:  SUBLW  2E
05786:  BNZ   57A4
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
05788:  BTFSC  xEC.0
0578A:  BRA    57A2
0578C:  MOVF   xE9,W
0578E:  SUBLW  00
05790:  BC    57A2
05792:  MOVF   xE9,W
05794:  SUBLW  08
05796:  BNC   57A2
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
05798:  MOVLW  08
0579A:  MOVWF  xE9
0579C:  MOVLW  0B
0579E:  MOVWF  xEA
....................             continue; 
057A0:  BRA    583A
....................             } 
....................          break; 
057A2:  BRA    583C
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
057A4:  MOVF   xEB,W
057A6:  SUBLW  22
057A8:  BNZ   57AC
....................          break;               // Reject "  
057AA:  BRA    583C
....................  
....................       if (c <= ')')  
057AC:  MOVF   xEB,W
057AE:  SUBLW  29
057B0:  BNC   57B4
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
057B2:  BRA    581E
....................  
....................       if (c <= ',') 
057B4:  MOVF   xEB,W
057B6:  SUBLW  2C
057B8:  BNC   57BC
....................          break;               // Reject * + ,  
057BA:  BRA    583C
....................  
....................       if (c <= '9')  
057BC:  MOVF   xEB,W
057BE:  SUBLW  39
057C0:  BNC   57C4
....................          goto md_l1;            // Accept - 0-9  
057C2:  BRA    581E
....................  
....................       if (c <= '?')  
057C4:  MOVF   xEB,W
057C6:  SUBLW  3F
057C8:  BNC   57CC
....................          break;               // Reject : ; < = > ?  
057CA:  BRA    583C
....................  
....................       if (!(a & 1))  
057CC:  BTFSC  xEC.0
057CE:  BRA    581E
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
057D0:  MOVF   xEB,W
057D2:  SUBLW  7C
057D4:  BNZ   57D8
....................             break;            // Reject |  
057D6:  BRA    583C
....................  
....................          if ((c >= '[') && (c <= ']')) 
057D8:  MOVF   xEB,W
057DA:  SUBLW  5A
057DC:  BC    57E6
057DE:  MOVF   xEB,W
057E0:  SUBLW  5D
057E2:  BNC   57E6
....................             break;// Reject [ \ ]  
057E4:  BRA    583C
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
057E6:  MOVF   xEB,W
057E8:  SUBLW  40
057EA:  BC    5800
057EC:  MOVF   xEB,W
057EE:  SUBLW  5A
057F0:  BNC   5800
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
057F2:  MOVF   xEA,W
057F4:  SUBLW  08
057F6:  BNZ   57FE
057F8:  BCF    xED.3
057FA:  MOVF   xED,W
057FC:  BRA    5800
057FE:  BCF    xED.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
05800:  MOVF   xEB,W
05802:  SUBLW  60
05804:  BC    581E
05806:  MOVF   xEB,W
05808:  SUBLW  7A
0580A:  BNC   581E
....................             {      // Convert to upper case  
....................             c -= 0x20; 
0580C:  MOVLW  20
0580E:  SUBWF  xEB,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
05810:  MOVF   xEA,W
05812:  SUBLW  08
05814:  BNZ   581C
05816:  BSF    xEC.3
05818:  MOVF   xEC,W
0581A:  BRA    581E
0581C:  BSF    xEC.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
0581E:  BCF    xEC.0
....................    md_l2: 
....................       if (n >= t)  
05820:  MOVF   xEA,W
05822:  SUBWF  xE9,W
05824:  BNC   5828
....................          break; 
05826:  BRA    583C
....................       dirname[n++] = c; 
05828:  MOVF   xE9,W
0582A:  INCF   xE9,F
0582C:  ADDWF  xE7,W
0582E:  MOVWF  FE9
05830:  MOVLW  00
05832:  ADDWFC xE8,W
05834:  MOVWF  FEA
05836:  MOVFF  9EB,FEF
0583A:  BRA    570C
....................       } 
....................    return 1; 
0583C:  MOVLW  01
0583E:  MOVWF  01
05840:  MOVLB  0
05842:  GOTO   6384 (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
061E2:  MOVLB  9
061E4:  CLRF   xE4
061E6:  CLRF   xE3
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
061E8:  MOVLW  14
061EA:  MOVLB  7
061EC:  ADDWF  x12,W
061EE:  MOVWF  FE9
061F0:  MOVLW  00
061F2:  ADDWFC x13,W
061F4:  MOVWF  FEA
061F6:  MOVFF  FEF,9DE
061FA:  MOVFF  FEC,9DF
061FE:  MOVFF  FEC,9E0
06202:  MOVFF  FEC,9E1
....................    if (fs->fs_type == FS_FAT32)  
06206:  MOVFF  712,FE9
0620A:  MOVFF  713,FEA
0620E:  MOVF   FEF,W
06210:  SUBLW  03
06212:  BNZ   6296
....................       { 
....................       scan->clust = scan->sclust = clust; 
06214:  MOVLW  04
06216:  MOVLB  9
06218:  ADDWF  xD6,W
0621A:  MOVWF  01
0621C:  MOVLW  00
0621E:  ADDWFC xD7,W
06220:  MOVFF  01,9E5
06224:  MOVFF  9D6,FE9
06228:  MOVFF  9D7,FEA
0622C:  MOVFF  9DE,FEF
06230:  MOVFF  9DF,FEC
06234:  MOVFF  9E0,FEC
06238:  MOVFF  9E1,FEC
0623C:  MOVWF  FEA
0623E:  MOVFF  9E5,FE9
06242:  MOVFF  9DE,FEF
06246:  MOVFF  9DF,FEC
0624A:  MOVFF  9E0,FEC
0624E:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
06252:  MOVLW  08
06254:  ADDWF  xD6,W
06256:  MOVWF  01
06258:  MOVLW  00
0625A:  ADDWFC xD7,W
0625C:  MOVWF  03
0625E:  MOVFF  01,9E5
06262:  MOVWF  xE6
06264:  MOVFF  9E1,9F2
06268:  MOVFF  9E0,9F1
0626C:  MOVFF  9DF,9F0
06270:  MOVFF  9DE,9EF
06274:  MOVLB  0
06276:  CALL   560E
0627A:  MOVFF  9E6,FEA
0627E:  MOVFF  9E5,FE9
06282:  MOVFF  00,FEF
06286:  MOVFF  01,FEC
0628A:  MOVFF  02,FEC
0628E:  MOVFF  03,FEC
....................       } 
06292:  BRA    62F6
06294:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
06296:  MOVLW  04
06298:  MOVLB  9
0629A:  ADDWF  xD6,W
0629C:  MOVWF  01
0629E:  MOVLW  00
062A0:  ADDWFC xD7,W
062A2:  MOVWF  03
062A4:  MOVFF  9D6,FE9
062A8:  MOVFF  9D7,FEA
062AC:  MOVF   FEE,F
062AE:  MOVF   FEE,F
062B0:  CLRF   FEC
062B2:  MOVF   FED,F
062B4:  CLRF   FEF
062B6:  MOVF   FED,F
062B8:  CLRF   FEF
062BA:  MOVF   FED,F
062BC:  CLRF   FEF
062BE:  MOVLW  00
062C0:  MOVFF  03,FEA
062C4:  MOVFF  01,FE9
062C8:  MOVFF  00,FEF
062CC:  MOVFF  01,FEC
062D0:  MOVFF  02,FEC
062D4:  MOVFF  03,FEC
....................       scan->sect = clust; 
062D8:  MOVLW  08
062DA:  ADDWF  xD6,W
062DC:  MOVWF  FE9
062DE:  MOVLW  00
062E0:  ADDWFC xD7,W
062E2:  MOVWF  FEA
062E4:  MOVFF  9DE,FEF
062E8:  MOVFF  9DF,FEC
062EC:  MOVFF  9E0,FEC
062F0:  MOVFF  9E1,FEC
062F4:  MOVLB  0
....................       } 
....................    scan->index = 0; 
062F6:  MOVLW  0C
062F8:  MOVLB  9
062FA:  ADDWF  xD6,W
062FC:  MOVWF  FE9
062FE:  MOVLW  00
06300:  ADDWFC xD7,W
06302:  MOVWF  FEA
06304:  CLRF   FEC
06306:  MOVF   FED,F
06308:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
0630A:  MOVFF  9DB,03
0630E:  MOVFF  9DA,FE9
06312:  MOVFF  9DB,FEA
06316:  MOVF   FEF,W
06318:  SUBLW  20
0631A:  BZ    6340
0631C:  MOVFF  9DB,03
06320:  MOVFF  9DA,FE9
06324:  MOVFF  9DB,FEA
06328:  MOVF   FEF,W
0632A:  SUBLW  2F
0632C:  BZ    6340
0632E:  MOVFF  9DB,03
06332:  MOVFF  9DA,FE9
06336:  MOVFF  9DB,FEA
0633A:  MOVF   FEF,W
0633C:  SUBLW  5C
0633E:  BNZ   6348
....................        path++; 
06340:  INCF   xDA,F
06342:  BTFSC  FD8.2
06344:  INCF   xDB,F
06346:  BRA    630A
....................  
....................    if ((BYTE)*path < ' ')  
06348:  MOVFF  9DB,03
0634C:  MOVFF  9DA,FE9
06350:  MOVFF  9DB,FEA
06354:  MOVF   FEF,W
06356:  SUBLW  1F
06358:  BNC   636E
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
0635A:  MOVFF  9DC,FE9
0635E:  MOVFF  9DD,FEA
06362:  CLRF   FEC
06364:  MOVF   FED,F
06366:  CLRF   FEF
....................       return (FR_OK); 
06368:  MOVLW  00
0636A:  MOVWF  01
0636C:  BRA    65C6
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
0636E:  MOVLW  09
06370:  MOVWF  xE6
06372:  MOVLW  DA
06374:  MOVWF  xE5
06376:  MOVFF  9D9,9E8
0637A:  MOVFF  9D8,9E7
0637E:  MOVLB  0
06380:  GOTO   56E8
06384:  MOVFF  01,9E2
....................       if (ds == 1)  
06388:  MOVLB  9
0638A:  DECFSZ xE2,W
0638C:  BRA    6394
....................          return (FR_INVALID_NAME); 
0638E:  MOVLW  04
06390:  MOVWF  01
06392:  BRA    65C6
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
06394:  MOVLW  08
06396:  ADDWF  xD6,W
06398:  MOVWF  FE9
0639A:  MOVLW  00
0639C:  ADDWFC xD7,W
0639E:  MOVWF  FEA
063A0:  MOVFF  FEF,A14
063A4:  MOVFF  FEC,A15
063A8:  MOVFF  FEC,A16
063AC:  MOVFF  FEC,A17
063B0:  MOVLB  0
063B2:  CALL   5A82
063B6:  MOVF   01,F
063B8:  BNZ   63C4
....................             return (FR_RW_ERROR); 
063BA:  MOVLW  07
063BC:  MOVWF  01
063BE:  MOVLB  9
063C0:  BRA    65C6
063C2:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
063C4:  MOVLW  0C
063C6:  MOVLB  9
063C8:  ADDWF  xD6,W
063CA:  MOVWF  FE9
063CC:  MOVLW  00
063CE:  ADDWFC xD7,W
063D0:  MOVWF  FEA
063D2:  MOVFF  FEC,9E6
063D6:  MOVF   FED,F
063D8:  MOVFF  FEF,9E5
063DC:  MOVLW  0F
063DE:  ANDWF  xE5,F
063E0:  CLRF   xE6
063E2:  RLCF   xE5,F
063E4:  RLCF   xE6,F
063E6:  RLCF   xE5,F
063E8:  RLCF   xE6,F
063EA:  RLCF   xE5,F
063EC:  RLCF   xE6,F
063EE:  RLCF   xE5,F
063F0:  RLCF   xE6,F
063F2:  RLCF   xE5,F
063F4:  RLCF   xE6,F
063F6:  MOVLW  E0
063F8:  ANDWF  xE5,F
063FA:  MOVLW  24
063FC:  ADDWF  xE5,W
063FE:  MOVWF  01
06400:  MOVLW  00
06402:  ADDWFC xE6,W
06404:  MOVWF  03
06406:  MOVF   01,W
06408:  MOVLB  7
0640A:  ADDWF  x12,W
0640C:  MOVWF  01
0640E:  MOVF   x13,W
06410:  ADDWFC 03,F
06412:  MOVFF  01,9E3
06416:  MOVLB  9
06418:  MOVFF  03,9E4
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
0641C:  MOVFF  9E4,03
06420:  MOVFF  9E3,FE9
06424:  MOVFF  9E4,FEA
06428:  MOVF   FEF,F
0642A:  BNZ   643A
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
0642C:  MOVF   xE2,F
0642E:  BNZ   6434
06430:  MOVLW  02
06432:  BRA    6436
06434:  MOVLW  03
06436:  MOVWF  01
06438:  BRA    65C6
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
0643A:  MOVFF  9E4,03
0643E:  MOVFF  9E3,FE9
06442:  MOVFF  9E4,FEA
06446:  MOVF   FEF,W
06448:  SUBLW  E5
0644A:  BZ    648C
0644C:  MOVLW  0B
0644E:  ADDWF  xE3,W
06450:  MOVWF  01
06452:  MOVLW  00
06454:  ADDWFC xE4,W
06456:  MOVWF  03
06458:  MOVFF  01,FE9
0645C:  MOVWF  FEA
0645E:  BTFSC  FEF.3
06460:  BRA    648C
06462:  MOVFF  9E4,9EA
06466:  MOVFF  9E3,9E9
0646A:  MOVFF  9D9,9EC
0646E:  MOVFF  9D8,9EB
06472:  CLRF   xEE
06474:  MOVLW  0B
06476:  MOVWF  xED
06478:  MOVLB  0
0647A:  CALL   460C
0647E:  MOVF   01,F
06480:  BTFSC  FD8.2
06482:  BRA    6488
06484:  MOVLB  9
06486:  BRA    648C
....................              break; 
06488:  BRA    64B4
0648A:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
0648C:  MOVFF  9D7,9E6
06490:  MOVFF  9D6,9E5
06494:  MOVLB  0
06496:  RCALL  6008
06498:  MOVF   01,F
0649A:  BNZ   64AE
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
0649C:  MOVLB  9
0649E:  MOVF   xE2,F
064A0:  BNZ   64A6
064A2:  MOVLW  02
064A4:  BRA    64A8
064A6:  MOVLW  03
064A8:  MOVWF  01
064AA:  BRA    65C6
064AC:  MOVLB  0
064AE:  MOVLB  9
064B0:  BRA    6394
064B2:  MOVLB  0
....................          } 
....................       if (!ds)  
064B4:  MOVLB  9
064B6:  MOVF   xE2,F
064B8:  BNZ   64D2
....................          {  
....................          *win_dir = dptr;  
064BA:  MOVFF  9DC,FE9
064BE:  MOVFF  9DD,FEA
064C2:  MOVFF  9E4,FEC
064C6:  MOVF   FED,F
064C8:  MOVFF  9E3,FEF
....................          return (FR_OK); 
064CC:  MOVLW  00
064CE:  MOVWF  01
064D0:  BRA    65C6
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
064D2:  MOVLW  0B
064D4:  ADDWF  xE3,W
064D6:  MOVWF  01
064D8:  MOVLW  00
064DA:  ADDWFC xE4,W
064DC:  MOVWF  03
064DE:  MOVFF  01,FE9
064E2:  MOVWF  FEA
064E4:  BTFSC  FEF.4
064E6:  BRA    64EE
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
064E8:  MOVLW  03
064EA:  MOVWF  01
064EC:  BRA    65C6
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
064EE:  MOVLW  14
064F0:  ADDWF  xE3,W
064F2:  MOVWF  01
064F4:  MOVLW  00
064F6:  ADDWFC xE4,W
064F8:  MOVWF  03
064FA:  MOVFF  01,FE9
064FE:  MOVWF  FEA
06500:  MOVFF  FEC,9E1
06504:  MOVF   FED,F
06506:  MOVFF  FEF,9E5
0650A:  MOVFF  9E5,9E0
0650E:  CLRF   xE5
06510:  CLRF   xE6
06512:  MOVLW  1A
06514:  ADDWF  xE3,W
06516:  MOVWF  01
06518:  MOVLW  00
0651A:  ADDWFC xE4,W
0651C:  MOVFF  01,FE9
06520:  MOVWF  FEA
06522:  MOVFF  FEC,03
06526:  MOVF   FED,F
06528:  MOVF   FEF,W
0652A:  IORWF  xE5,W
0652C:  MOVWF  xDE
0652E:  MOVF   03,W
06530:  IORWF  xE6,W
06532:  MOVWF  xDF
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
06534:  MOVLW  04
06536:  ADDWF  xD6,W
06538:  MOVWF  01
0653A:  MOVLW  00
0653C:  ADDWFC xD7,W
0653E:  MOVFF  01,9E5
06542:  MOVFF  9D6,FE9
06546:  MOVFF  9D7,FEA
0654A:  MOVFF  9DE,FEF
0654E:  MOVFF  9DF,FEC
06552:  MOVFF  9E0,FEC
06556:  MOVFF  9E1,FEC
0655A:  MOVWF  FEA
0655C:  MOVFF  9E5,FE9
06560:  MOVFF  9DE,FEF
06564:  MOVFF  9DF,FEC
06568:  MOVFF  9E0,FEC
0656C:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
06570:  MOVLW  08
06572:  ADDWF  xD6,W
06574:  MOVWF  01
06576:  MOVLW  00
06578:  ADDWFC xD7,W
0657A:  MOVWF  03
0657C:  MOVFF  01,9E5
06580:  MOVWF  xE6
06582:  MOVFF  9E1,9F2
06586:  MOVFF  9E0,9F1
0658A:  MOVFF  9DF,9F0
0658E:  MOVFF  9DE,9EF
06592:  MOVLB  0
06594:  CALL   560E
06598:  MOVFF  9E6,FEA
0659C:  MOVFF  9E5,FE9
065A0:  MOVFF  00,FEF
065A4:  MOVFF  01,FEC
065A8:  MOVFF  02,FEC
065AC:  MOVFF  03,FEC
....................       scan->index = 0; 
065B0:  MOVLW  0C
065B2:  MOVLB  9
065B4:  ADDWF  xD6,W
065B6:  MOVWF  FE9
065B8:  MOVLW  00
065BA:  ADDWFC xD7,W
065BC:  MOVWF  FEA
065BE:  CLRF   FEC
065C0:  MOVF   FED,F
065C2:  CLRF   FEF
065C4:  BRA    636E
....................       } 
065C6:  MOVLB  0
065C8:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06BFC:  MOVLB  9
06BFE:  MOVFF  9D6,FE9
06C02:  MOVFF  9D7,FEA
06C06:  MOVFF  FEF,9D8
06C0A:  MOVFF  FEC,9D9
06C0E:  MOVFF  FEC,9DA
06C12:  MOVFF  FEC,9DB
....................    if (clust) {   // Dyanmic directory table  
06C16:  MOVF   xD8,F
06C18:  BNZ   6C26
06C1A:  MOVF   xD9,F
06C1C:  BNZ   6C26
06C1E:  MOVF   xDA,F
06C20:  BNZ   6C26
06C22:  MOVF   xDB,F
06C24:  BZ    6C86
....................       scan->clust = clust; 
06C26:  MOVLW  04
06C28:  ADDWF  xD6,W
06C2A:  MOVWF  FE9
06C2C:  MOVLW  00
06C2E:  ADDWFC xD7,W
06C30:  MOVWF  FEA
06C32:  MOVFF  9D8,FEF
06C36:  MOVFF  9D9,FEC
06C3A:  MOVFF  9DA,FEC
06C3E:  MOVFF  9DB,FEC
....................       scan->sect = clust2sect(clust); 
06C42:  MOVLW  08
06C44:  ADDWF  xD6,W
06C46:  MOVWF  01
06C48:  MOVLW  00
06C4A:  ADDWFC xD7,W
06C4C:  MOVWF  03
06C4E:  MOVFF  01,9E4
06C52:  MOVWF  xE5
06C54:  MOVFF  9DB,9F2
06C58:  MOVFF  9DA,9F1
06C5C:  MOVFF  9D9,9F0
06C60:  MOVFF  9D8,9EF
06C64:  MOVLB  0
06C66:  CALL   560E
06C6A:  MOVFF  9E5,FEA
06C6E:  MOVFF  9E4,FE9
06C72:  MOVFF  00,FEF
06C76:  MOVFF  01,FEC
06C7A:  MOVFF  02,FEC
06C7E:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06C82:  BRA    6CD0
06C84:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06C86:  MOVLW  08
06C88:  ADDWF  xD6,W
06C8A:  MOVWF  01
06C8C:  MOVLW  00
06C8E:  ADDWFC xD7,W
06C90:  MOVWF  03
06C92:  MOVFF  01,9E4
06C96:  MOVWF  xE5
06C98:  MOVLW  14
06C9A:  MOVLB  7
06C9C:  ADDWF  x12,W
06C9E:  MOVWF  FE9
06CA0:  MOVLW  00
06CA2:  ADDWFC x13,W
06CA4:  MOVWF  FEA
06CA6:  MOVFF  FEF,00
06CAA:  MOVFF  FEC,01
06CAE:  MOVFF  FEC,02
06CB2:  MOVFF  FEC,03
06CB6:  MOVFF  9E5,FEA
06CBA:  MOVFF  9E4,FE9
06CBE:  MOVFF  00,FEF
06CC2:  MOVFF  01,FEC
06CC6:  MOVFF  02,FEC
06CCA:  MOVFF  03,FEC
06CCE:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06CD0:  MOVLW  0C
06CD2:  MOVLB  9
06CD4:  ADDWF  xD6,W
06CD6:  MOVWF  FE9
06CD8:  MOVLW  00
06CDA:  ADDWFC xD7,W
06CDC:  MOVWF  FEA
06CDE:  CLRF   FEC
06CE0:  MOVF   FED,F
06CE2:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06CE4:  MOVLW  08
06CE6:  ADDWF  xD6,W
06CE8:  MOVWF  FE9
06CEA:  MOVLW  00
06CEC:  ADDWFC xD7,W
06CEE:  MOVWF  FEA
06CF0:  MOVFF  FEF,A14
06CF4:  MOVFF  FEC,A15
06CF8:  MOVFF  FEC,A16
06CFC:  MOVFF  FEC,A17
06D00:  MOVLB  0
06D02:  CALL   5A82
06D06:  MOVF   01,F
06D08:  BNZ   6D12
....................          return (NULL); 
06D0A:  MOVLW  00
06D0C:  MOVWF  01
06D0E:  MOVWF  02
06D10:  BRA    6F40
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06D12:  MOVLW  0C
06D14:  MOVLB  9
06D16:  ADDWF  xD6,W
06D18:  MOVWF  FE9
06D1A:  MOVLW  00
06D1C:  ADDWFC xD7,W
06D1E:  MOVWF  FEA
06D20:  MOVFF  FEC,9E5
06D24:  MOVF   FED,F
06D26:  MOVFF  FEF,9E4
06D2A:  MOVLW  0F
06D2C:  ANDWF  xE4,F
06D2E:  CLRF   xE5
06D30:  RLCF   xE4,F
06D32:  RLCF   xE5,F
06D34:  RLCF   xE4,F
06D36:  RLCF   xE5,F
06D38:  RLCF   xE4,F
06D3A:  RLCF   xE5,F
06D3C:  RLCF   xE4,F
06D3E:  RLCF   xE5,F
06D40:  RLCF   xE4,F
06D42:  RLCF   xE5,F
06D44:  MOVLW  E0
06D46:  ANDWF  xE4,F
06D48:  MOVLW  24
06D4A:  ADDWF  xE4,W
06D4C:  MOVWF  01
06D4E:  MOVLW  00
06D50:  ADDWFC xE5,W
06D52:  MOVWF  03
06D54:  MOVF   01,W
06D56:  MOVLB  7
06D58:  ADDWF  x12,W
06D5A:  MOVWF  01
06D5C:  MOVF   x13,W
06D5E:  ADDWFC 03,F
06D60:  MOVFF  01,9E2
06D64:  MOVLB  9
06D66:  MOVFF  03,9E3
....................       c = *dptr; 
06D6A:  MOVFF  9E2,FE9
06D6E:  MOVFF  9E3,FEA
06D72:  MOVFF  FEF,9E0
....................       if ((c == 0) || (c == 0xE5))  
06D76:  MOVF   xE0,F
06D78:  BZ    6D80
06D7A:  MOVF   xE0,W
06D7C:  SUBLW  E5
06D7E:  BNZ   6D8E
....................          return (dptr);      // Found an empty entry!  
06D80:  MOVFF  9E2,01
06D84:  MOVFF  9E3,02
06D88:  MOVLB  0
06D8A:  BRA    6F40
06D8C:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06D8E:  MOVFF  9D7,9E6
06D92:  MOVFF  9D6,9E5
06D96:  MOVLB  0
06D98:  CALL   6008
06D9C:  MOVF   01,F
06D9E:  BTFSC  FD8.2
06DA0:  BRA    6DA6
06DA2:  MOVLB  9
06DA4:  BRA    6CE4
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06DA6:  MOVLB  9
06DA8:  MOVF   xD8,F
06DAA:  BNZ   6DC4
06DAC:  MOVF   xD9,F
06DAE:  BNZ   6DC4
06DB0:  MOVF   xDA,F
06DB2:  BNZ   6DC4
06DB4:  MOVF   xDB,F
06DB6:  BNZ   6DC4
....................        return (NULL); 
06DB8:  MOVLW  00
06DBA:  MOVWF  01
06DBC:  MOVWF  02
06DBE:  MOVLB  0
06DC0:  BRA    6F40
06DC2:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06DC4:  MOVLW  04
06DC6:  ADDWF  xD6,W
06DC8:  MOVWF  FE9
06DCA:  MOVLW  00
06DCC:  ADDWFC xD7,W
06DCE:  MOVWF  FEA
06DD0:  MOVFF  FEF,9E8
06DD4:  MOVFF  FEC,9E9
06DD8:  MOVFF  FEC,9EA
06DDC:  MOVFF  FEC,9EB
06DE0:  MOVLB  0
06DE2:  RCALL  6964
06DE4:  MOVFF  03,9DB
06DE8:  MOVFF  02,9DA
06DEC:  MOVFF  01,9D9
06DF0:  MOVFF  00,9D8
....................    if (!(clust))  
06DF4:  MOVLB  9
06DF6:  MOVF   xD8,F
06DF8:  BNZ   6E12
06DFA:  MOVF   xD9,F
06DFC:  BNZ   6E12
06DFE:  MOVF   xDA,F
06E00:  BNZ   6E12
06E02:  MOVF   xDB,F
06E04:  BNZ   6E12
....................       return (NULL); 
06E06:  MOVLW  00
06E08:  MOVWF  01
06E0A:  MOVWF  02
06E0C:  MOVLB  0
06E0E:  BRA    6F40
06E10:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06E12:  MOVLB  A
06E14:  CLRF   x17
06E16:  CLRF   x16
06E18:  CLRF   x15
06E1A:  CLRF   x14
06E1C:  MOVLB  0
06E1E:  CALL   5A82
06E22:  MOVF   01,F
06E24:  BNZ   6E2E
....................       return (0); 
06E26:  MOVLW  00
06E28:  MOVWF  01
06E2A:  MOVWF  02
06E2C:  BRA    6F40
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06E2E:  MOVLW  20
06E30:  MOVLB  7
06E32:  ADDWF  x12,W
06E34:  MOVWF  01
06E36:  MOVLW  00
06E38:  ADDWFC x13,W
06E3A:  MOVWF  03
06E3C:  MOVFF  01,9E4
06E40:  MOVLB  9
06E42:  MOVWF  xE5
06E44:  MOVFF  9DB,9F2
06E48:  MOVFF  9DA,9F1
06E4C:  MOVFF  9D9,9F0
06E50:  MOVFF  9D8,9EF
06E54:  MOVLB  0
06E56:  CALL   560E
06E5A:  MOVFF  03,9DF
06E5E:  MOVFF  02,9DE
06E62:  MOVFF  01,9DD
06E66:  MOVFF  00,9DC
06E6A:  MOVFF  9E5,FEA
06E6E:  MOVFF  9E4,FE9
06E72:  MOVFF  9DC,FEF
06E76:  MOVFF  9DD,FEC
06E7A:  MOVFF  9DE,FEC
06E7E:  MOVFF  9DF,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06E82:  MOVLW  24
06E84:  MOVLB  7
06E86:  ADDWF  x12,W
06E88:  MOVWF  01
06E8A:  MOVLW  00
06E8C:  ADDWFC x13,W
06E8E:  MOVWF  03
06E90:  MOVFF  01,9E4
06E94:  MOVLB  9
06E96:  MOVWF  xE5
06E98:  MOVWF  FEA
06E9A:  MOVFF  01,FE9
06E9E:  CLRF   00
06EA0:  MOVLW  02
06EA2:  MOVWF  02
06EA4:  CLRF   01
06EA6:  MOVLB  0
06EA8:  CALL   3526
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06EAC:  MOVLW  02
06EAE:  MOVLB  7
06EB0:  ADDWF  x12,W
06EB2:  MOVWF  FE9
06EB4:  MOVLW  00
06EB6:  ADDWFC x13,W
06EB8:  MOVWF  FEA
06EBA:  MOVFF  FEF,9E1
06EBE:  MOVLB  9
06EC0:  MOVF   xE1,F
06EC2:  BZ    6F20
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06EC4:  MOVLW  24
06EC6:  MOVLB  7
06EC8:  ADDWF  x12,W
06ECA:  MOVWF  01
06ECC:  MOVLW  00
06ECE:  ADDWFC x13,W
06ED0:  MOVWF  03
06ED2:  MOVFF  01,9E4
06ED6:  MOVLB  9
06ED8:  MOVWF  xE5
06EDA:  MOVFF  FE8,A21
06EDE:  MOVFF  01,A20
06EE2:  MOVFF  9DF,A25
06EE6:  MOVFF  9DE,A24
06EEA:  MOVFF  9DD,A23
06EEE:  MOVFF  9DC,A22
06EF2:  MOVLW  01
06EF4:  MOVLB  A
06EF6:  MOVWF  x26
06EF8:  MOVLB  0
06EFA:  CALL   593E
06EFE:  MOVF   01,F
06F00:  BZ    6F0A
....................          return (NULL); 
06F02:  MOVLW  00
06F04:  MOVWF  01
06F06:  MOVWF  02
06F08:  BRA    6F40
....................       sector++; 
06F0A:  MOVLW  01
06F0C:  MOVLB  9
06F0E:  ADDWF  xDC,F
06F10:  BTFSC  FD8.0
06F12:  INCF   xDD,F
06F14:  BTFSC  FD8.2
06F16:  INCF   xDE,F
06F18:  BTFSC  FD8.2
06F1A:  INCF   xDF,F
06F1C:  DECF   xE1,F
06F1E:  BRA    6EC0
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06F20:  MOVLW  06
06F22:  MOVLB  7
06F24:  ADDWF  x12,W
06F26:  MOVWF  FE9
06F28:  MOVLW  00
06F2A:  ADDWFC x13,W
06F2C:  MOVWF  FEA
06F2E:  MOVLW  01
06F30:  MOVWF  FEF
....................    return (fs->win); 
06F32:  MOVLW  24
06F34:  ADDWF  x12,W
06F36:  MOVWF  01
06F38:  MOVLW  00
06F3A:  ADDWFC x13,W
06F3C:  MOVWF  03
06F3E:  MOVWF  02
06F40:  MOVLB  0
06F42:  GOTO   71DA (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
055AC:  MOVLB  7
055AE:  MOVF   x12,W
055B0:  IORWF  x13,W
055B2:  BNZ   55BA
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
055B4:  MOVLW  0B
055B6:  MOVWF  01
055B8:  BRA    560A
....................  
....................    if (disk_status() & STA_NOINIT)  
055BA:  MOVLB  0
055BC:  RCALL  559E
055BE:  BTFSS  01.0
055C0:  BRA    55EC
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
055C2:  MOVLW  01
055C4:  MOVLB  7
055C6:  ADDWF  x12,W
055C8:  MOVWF  FE9
055CA:  MOVLW  00
055CC:  ADDWFC x13,W
055CE:  MOVWF  FEA
055D0:  MOVF   FEF,F
055D2:  BZ    55DC
....................          return (FR_INCORRECT_DISK_CHANGE); 
055D4:  MOVLW  09
055D6:  MOVWF  01
055D8:  BRA    560A
055DA:  BRA    55E8
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
055DC:  MOVLB  0
055DE:  CALL   4856
055E2:  MOVF   01,W
055E4:  MOVLB  7
055E6:  BRA    560A
....................       }  
055E8:  BRA    5606
055EA:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
055EC:  MOVLB  7
055EE:  MOVFF  712,FE9
055F2:  MOVFF  713,FEA
055F6:  MOVF   FEF,F
055F8:  BNZ   5606
....................          return (f_mountdrv());      // Initialize file system and return resulut  
055FA:  MOVLB  0
055FC:  CALL   4856
05600:  MOVF   01,W
05602:  MOVLB  7
05604:  BRA    560A
....................       } 
....................    return FR_OK;                  // File system is valid  
05606:  MOVLW  00
05608:  MOVWF  01
0560A:  MOVLB  0
0560C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B976:  MOVLB  8
0B978:  MOVF   xCC,W
0B97A:  XORLW  00
0B97C:  MOVLB  0
0B97E:  BZ    B9B8
0B980:  XORLW  04
0B982:  BZ    B9D4
0B984:  XORLW  05
0B986:  BZ    B9F0
0B988:  XORLW  03
0B98A:  BZ    BA0C
0B98C:  XORLW  01
0B98E:  BZ    BA28
0B990:  XORLW  06
0B992:  BZ    BA44
0B994:  XORLW  03
0B996:  BZ    BA60
0B998:  XORLW  01
0B99A:  BTFSC  FD8.2
0B99C:  BRA    BA7C
0B99E:  XORLW  0E
0B9A0:  BTFSC  FD8.2
0B9A2:  BRA    BA98
0B9A4:  XORLW  03
0B9A6:  BTFSC  FD8.2
0B9A8:  BRA    BAB4
0B9AA:  XORLW  01
0B9AC:  BTFSC  FD8.2
0B9AE:  BRA    BAD0
0B9B0:  XORLW  07
0B9B2:  BTFSC  FD8.2
0B9B4:  BRA    BAEC
0B9B6:  BRA    BB08
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B9B8:  MOVFF  8CE,FEA
0B9BC:  MOVFF  8CD,FE9
0B9C0:  MOVLW  00
0B9C2:  CALL   0106
0B9C6:  TBLRD*-
0B9C8:  TBLRD*+
0B9CA:  MOVF   FF5,W
0B9CC:  MOVWF  FEE
0B9CE:  IORLW  00
0B9D0:  BNZ   B9C8
....................          break; 
0B9D2:  BRA    BB22
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B9D4:  MOVFF  8CE,FEA
0B9D8:  MOVFF  8CD,FE9
0B9DC:  MOVLW  00
0B9DE:  CALL   0124
0B9E2:  TBLRD*-
0B9E4:  TBLRD*+
0B9E6:  MOVF   FF5,W
0B9E8:  MOVWF  FEE
0B9EA:  IORLW  00
0B9EC:  BNZ   B9E4
....................          break; 
0B9EE:  BRA    BB22
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B9F0:  MOVFF  8CE,FEA
0B9F4:  MOVFF  8CD,FE9
0B9F8:  MOVLW  00
0B9FA:  CALL   014A
0B9FE:  TBLRD*-
0BA00:  TBLRD*+
0BA02:  MOVF   FF5,W
0BA04:  MOVWF  FEE
0BA06:  IORLW  00
0BA08:  BNZ   BA00
....................          break; 
0BA0A:  BRA    BB22
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0BA0C:  MOVFF  8CE,FEA
0BA10:  MOVFF  8CD,FE9
0BA14:  MOVLW  00
0BA16:  CALL   016E
0BA1A:  TBLRD*-
0BA1C:  TBLRD*+
0BA1E:  MOVF   FF5,W
0BA20:  MOVWF  FEE
0BA22:  IORLW  00
0BA24:  BNZ   BA1C
....................          break; 
0BA26:  BRA    BB22
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0BA28:  MOVFF  8CE,FEA
0BA2C:  MOVFF  8CD,FE9
0BA30:  MOVLW  00
0BA32:  CALL   0192
0BA36:  TBLRD*-
0BA38:  TBLRD*+
0BA3A:  MOVF   FF5,W
0BA3C:  MOVWF  FEE
0BA3E:  IORLW  00
0BA40:  BNZ   BA38
....................          break; 
0BA42:  BRA    BB22
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0BA44:  MOVFF  8CE,FEA
0BA48:  MOVFF  8CD,FE9
0BA4C:  MOVLW  00
0BA4E:  CALL   01B6
0BA52:  TBLRD*-
0BA54:  TBLRD*+
0BA56:  MOVF   FF5,W
0BA58:  MOVWF  FEE
0BA5A:  IORLW  00
0BA5C:  BNZ   BA54
....................          break; 
0BA5E:  BRA    BB22
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0BA60:  MOVFF  8CE,FEA
0BA64:  MOVFF  8CD,FE9
0BA68:  MOVLW  00
0BA6A:  CALL   01D8
0BA6E:  TBLRD*-
0BA70:  TBLRD*+
0BA72:  MOVF   FF5,W
0BA74:  MOVWF  FEE
0BA76:  IORLW  00
0BA78:  BNZ   BA70
....................          break; 
0BA7A:  BRA    BB22
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0BA7C:  MOVFF  8CE,FEA
0BA80:  MOVFF  8CD,FE9
0BA84:  MOVLW  00
0BA86:  CALL   01F8
0BA8A:  TBLRD*-
0BA8C:  TBLRD*+
0BA8E:  MOVF   FF5,W
0BA90:  MOVWF  FEE
0BA92:  IORLW  00
0BA94:  BNZ   BA8C
....................          break; 
0BA96:  BRA    BB22
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0BA98:  MOVFF  8CE,FEA
0BA9C:  MOVFF  8CD,FE9
0BAA0:  MOVLW  00
0BAA2:  CALL   0216
0BAA6:  TBLRD*-
0BAA8:  TBLRD*+
0BAAA:  MOVF   FF5,W
0BAAC:  MOVWF  FEE
0BAAE:  IORLW  00
0BAB0:  BNZ   BAA8
....................          break; 
0BAB2:  BRA    BB22
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0BAB4:  MOVFF  8CE,FEA
0BAB8:  MOVFF  8CD,FE9
0BABC:  MOVLW  00
0BABE:  CALL   0242
0BAC2:  TBLRD*-
0BAC4:  TBLRD*+
0BAC6:  MOVF   FF5,W
0BAC8:  MOVWF  FEE
0BACA:  IORLW  00
0BACC:  BNZ   BAC4
....................          break; 
0BACE:  BRA    BB22
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0BAD0:  MOVFF  8CE,FEA
0BAD4:  MOVFF  8CD,FE9
0BAD8:  MOVLW  00
0BADA:  CALL   0266
0BADE:  TBLRD*-
0BAE0:  TBLRD*+
0BAE2:  MOVF   FF5,W
0BAE4:  MOVWF  FEE
0BAE6:  IORLW  00
0BAE8:  BNZ   BAE0
....................          break; 
0BAEA:  BRA    BB22
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0BAEC:  MOVFF  8CE,FEA
0BAF0:  MOVFF  8CD,FE9
0BAF4:  MOVLW  00
0BAF6:  CALL   028A
0BAFA:  TBLRD*-
0BAFC:  TBLRD*+
0BAFE:  MOVF   FF5,W
0BB00:  MOVWF  FEE
0BB02:  IORLW  00
0BB04:  BNZ   BAFC
....................          break; 
0BB06:  BRA    BB22
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0BB08:  MOVFF  8CE,FEA
0BB0C:  MOVFF  8CD,FE9
0BB10:  MOVLW  00
0BB12:  CALL   02AC
0BB16:  TBLRD*-
0BB18:  TBLRD*+
0BB1A:  MOVF   FF5,W
0BB1C:  MOVWF  FEE
0BB1E:  IORLW  00
0BB20:  BNZ   BB18
....................       } 
0BB22:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
04856:  MOVLB  7
04858:  MOVF   x12,W
0485A:  IORWF  x13,W
0485C:  BNZ   4864
....................       return (FR_NOT_ENABLED); 
0485E:  MOVLW  0B
04860:  MOVWF  01
04862:  BRA    4DF0
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
04864:  MOVFF  713,FEA
04868:  MOVFF  712,FE9
0486C:  CLRF   00
0486E:  MOVLW  02
04870:  MOVWF  02
04872:  MOVLW  24
04874:  MOVWF  01
04876:  MOVLB  0
04878:  CALL   3526
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
0487C:  CALL   3676
04880:  MOVFF  01,4ED
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
04884:  MOVLB  4
04886:  BTFSS  xED.0
04888:  BRA    4896
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
0488A:  MOVLB  0
0488C:  CALL   3676
04890:  MOVFF  01,4ED
04894:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
04896:  BTFSS  xED.0
04898:  BRA    48A4
0489A:  MOVLW  01
0489C:  MOVWF  01
0489E:  MOVLB  7
048A0:  BRA    4DF0
048A2:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
048A4:  MOVLB  9
048A6:  CLRF   xDA
048A8:  CLRF   xD9
048AA:  CLRF   xD8
048AC:  CLRF   xD7
048AE:  MOVFF  9DA,9E6
048B2:  MOVFF  9D9,9E5
048B6:  MOVFF  9D8,9E4
048BA:  MOVFF  9D7,9E3
048BE:  MOVLB  0
048C0:  RCALL  4690
048C2:  MOVFF  01,9D6
....................    if (!fat)  
048C6:  MOVLB  9
048C8:  MOVF   xD6,F
048CA:  BNZ   493A
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
048CC:  MOVLW  E6
048CE:  MOVLB  7
048D0:  ADDWF  x12,W
048D2:  MOVWF  FE9
048D4:  MOVLW  01
048D6:  ADDWFC x13,W
048D8:  MOVWF  FEA
048DA:  MOVF   FEF,F
048DC:  BZ    491A
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
048DE:  MOVLW  EA
048E0:  ADDWF  x12,W
048E2:  MOVWF  01
048E4:  MOVLW  01
048E6:  ADDWFC x13,W
048E8:  MOVFF  01,FE9
048EC:  MOVWF  FEA
048EE:  MOVFF  FEF,9D7
048F2:  MOVFF  FEC,9D8
048F6:  MOVFF  FEC,9D9
048FA:  MOVFF  FEC,9DA
....................          fat = check_fs(sect);            // Check the partition  
048FE:  MOVFF  9DA,9E6
04902:  MOVFF  9D9,9E5
04906:  MOVFF  9D8,9E4
0490A:  MOVFF  9D7,9E3
0490E:  MOVLB  0
04910:  RCALL  4690
04912:  MOVFF  01,9D6
....................          } 
04916:  BRA    4938
04918:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
0491A:  MOVLW  08
0491C:  MOVWF  FF6
0491E:  MOVLW  0C
04920:  MOVWF  FF7
04922:  MOVLW  00
04924:  MOVWF  FF8
04926:  CLRF   1B
04928:  BTFSC  FF2.7
0492A:  BSF    1B.7
0492C:  BCF    FF2.7
0492E:  MOVLB  0
04930:  CALL   0E46
04934:  BTFSC  1B.7
04936:  BSF    FF2.7
04938:  MOVLB  9
....................       } 
....................    if (!fat)  
0493A:  MOVF   xD6,F
0493C:  BNZ   4948
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
0493E:  MOVLW  0C
04940:  MOVWF  01
04942:  MOVLB  7
04944:  BRA    4DF0
04946:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
04948:  MOVLB  7
0494A:  MOVFF  712,FE9
0494E:  MOVFF  713,FEA
04952:  MOVFF  9D6,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
04956:  MOVLB  9
04958:  MOVF   xD6,W
0495A:  SUBLW  03
0495C:  BNZ   49C2
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
0495E:  MOVLW  08
04960:  MOVLB  7
04962:  ADDWF  x12,W
04964:  MOVWF  01
04966:  MOVLW  00
04968:  ADDWFC x13,W
0496A:  MOVWF  03
0496C:  MOVFF  01,9E3
04970:  MOVLB  9
04972:  MOVWF  xE4
04974:  MOVLW  48
04976:  MOVLB  7
04978:  ADDWF  x12,W
0497A:  MOVWF  01
0497C:  MOVLW  00
0497E:  ADDWFC x13,W
04980:  MOVFF  01,FE9
04984:  MOVWF  FEA
04986:  MOVFF  FEF,00
0498A:  MOVFF  FEC,01
0498E:  MOVFF  FEC,02
04992:  MOVFF  FEC,03
04996:  MOVFF  03,9E8
0499A:  MOVFF  02,9E7
0499E:  MOVFF  01,9E6
049A2:  MOVFF  00,9E5
049A6:  MOVFF  9E4,FEA
049AA:  MOVFF  9E3,FE9
049AE:  MOVFF  00,FEF
049B2:  MOVFF  01,FEC
049B6:  MOVFF  02,FEC
049BA:  MOVFF  03,FEC
049BE:  BRA    4A1A
049C0:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
049C2:  MOVLW  08
049C4:  MOVLB  7
049C6:  ADDWF  x12,W
049C8:  MOVWF  01
049CA:  MOVLW  00
049CC:  ADDWFC x13,W
049CE:  MOVWF  03
049D0:  MOVFF  01,9E3
049D4:  MOVLB  9
049D6:  MOVWF  xE4
049D8:  MOVLW  3A
049DA:  MOVLB  7
049DC:  ADDWF  x12,W
049DE:  MOVWF  01
049E0:  MOVLW  00
049E2:  ADDWFC x13,W
049E4:  MOVFF  01,FE9
049E8:  MOVWF  FEA
049EA:  MOVFF  FEC,03
049EE:  MOVF   FED,F
049F0:  MOVFF  FEF,9E5
049F4:  MOVLB  9
049F6:  MOVFF  03,9E6
049FA:  MOVFF  9E4,FEA
049FE:  MOVFF  9E3,FE9
04A02:  MOVF   FEE,F
04A04:  MOVF   FEE,F
04A06:  CLRF   FEC
04A08:  MOVF   FED,F
04A0A:  CLRF   FEF
04A0C:  MOVF   FED,F
04A0E:  MOVFF  03,FEF
04A12:  MOVF   FED,F
04A14:  MOVFF  9E5,FEF
04A18:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
04A1A:  MOVLW  02
04A1C:  ADDWF  x12,W
04A1E:  MOVWF  01
04A20:  MOVLW  00
04A22:  ADDWFC x13,W
04A24:  MOVWF  03
04A26:  MOVLW  31
04A28:  MOVLB  7
04A2A:  ADDWF  x12,W
04A2C:  MOVWF  FE9
04A2E:  MOVLW  00
04A30:  ADDWFC x13,W
04A32:  MOVWF  FEA
04A34:  MOVFF  FEF,9E5
04A38:  MOVLB  9
04A3A:  MOVFF  03,FEA
04A3E:  MOVFF  01,FE9
04A42:  MOVFF  9E5,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
04A46:  MOVLW  03
04A48:  MOVLB  7
04A4A:  ADDWF  x12,W
04A4C:  MOVWF  01
04A4E:  MOVLW  00
04A50:  ADDWFC x13,W
04A52:  MOVWF  03
04A54:  MOVLW  34
04A56:  MOVLB  7
04A58:  ADDWF  x12,W
04A5A:  MOVWF  FE9
04A5C:  MOVLW  00
04A5E:  ADDWFC x13,W
04A60:  MOVWF  FEA
04A62:  MOVFF  FEF,9E5
04A66:  MOVLB  9
04A68:  MOVFF  03,FEA
04A6C:  MOVFF  01,FE9
04A70:  MOVFF  9E5,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
04A74:  MOVLW  10
04A76:  MOVLB  7
04A78:  ADDWF  x12,W
04A7A:  MOVWF  01
04A7C:  MOVLW  00
04A7E:  ADDWFC x13,W
04A80:  MOVWF  03
04A82:  MOVFF  01,9E3
04A86:  MOVLB  9
04A88:  MOVWF  xE4
04A8A:  MOVLW  32
04A8C:  MOVLB  7
04A8E:  ADDWF  x12,W
04A90:  MOVWF  01
04A92:  MOVLW  00
04A94:  ADDWFC x13,W
04A96:  MOVFF  01,FE9
04A9A:  MOVWF  FEA
04A9C:  MOVFF  FEC,03
04AA0:  MOVF   FED,F
04AA2:  MOVF   FEF,W
04AA4:  MOVLB  9
04AA6:  ADDWF  xD7,W
04AA8:  MOVWF  00
04AAA:  MOVF   03,W
04AAC:  ADDWFC xD8,W
04AAE:  MOVWF  01
04AB0:  MOVLW  00
04AB2:  ADDWFC xD9,W
04AB4:  MOVWF  02
04AB6:  MOVLW  00
04AB8:  ADDWFC xDA,W
04ABA:  MOVFF  9E4,FEA
04ABE:  MOVFF  9E3,FE9
04AC2:  MOVFF  00,FEF
04AC6:  MOVFF  01,FEC
04ACA:  MOVFF  02,FEC
04ACE:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04AD0:  MOVLW  04
04AD2:  MOVLB  7
04AD4:  ADDWF  x12,W
04AD6:  MOVWF  01
04AD8:  MOVLW  00
04ADA:  ADDWFC x13,W
04ADC:  MOVWF  03
04ADE:  MOVFF  01,9E3
04AE2:  MOVLB  9
04AE4:  MOVWF  xE4
04AE6:  MOVLW  35
04AE8:  MOVLB  7
04AEA:  ADDWF  x12,W
04AEC:  MOVWF  01
04AEE:  MOVLW  00
04AF0:  ADDWFC x13,W
04AF2:  MOVFF  01,FE9
04AF6:  MOVWF  FEA
04AF8:  MOVFF  FEC,03
04AFC:  MOVF   FED,F
04AFE:  MOVFF  FEF,9E5
04B02:  MOVLB  9
04B04:  MOVFF  9E4,FEA
04B08:  MOVFF  9E3,FE9
04B0C:  MOVFF  03,FEC
04B10:  MOVF   FED,F
04B12:  MOVFF  9E5,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04B16:  MOVLW  08
04B18:  MOVLB  7
04B1A:  ADDWF  x12,W
04B1C:  MOVWF  FE9
04B1E:  MOVLW  00
04B20:  ADDWFC x13,W
04B22:  MOVWF  FEA
04B24:  MOVFF  FEF,9F6
04B28:  MOVFF  FEC,9F7
04B2C:  MOVFF  FEC,9F8
04B30:  MOVFF  FEC,9F9
04B34:  MOVLW  03
04B36:  ADDWF  x12,W
04B38:  MOVWF  FE9
04B3A:  MOVLW  00
04B3C:  ADDWFC x13,W
04B3E:  MOVWF  FEA
04B40:  MOVFF  FEF,9FA
04B44:  MOVLB  9
04B46:  MOVFF  FEA,9E9
04B4A:  MOVFF  FE9,9E8
04B4E:  CLRF   xFD
04B50:  CLRF   xFC
04B52:  CLRF   xFB
04B54:  MOVLB  0
04B56:  RCALL  47F0
04B58:  MOVFF  9E9,FEA
04B5C:  MOVFF  9E8,FE9
04B60:  MOVFF  03,9E6
04B64:  MOVFF  02,9E5
04B68:  MOVFF  01,9E4
04B6C:  MOVFF  00,9E3
04B70:  MOVLW  10
04B72:  MOVLB  7
04B74:  ADDWF  x12,W
04B76:  MOVWF  FE9
04B78:  MOVLW  00
04B7A:  ADDWFC x13,W
04B7C:  MOVWF  FEA
04B7E:  MOVFF  FEF,00
04B82:  MOVFF  FEC,01
04B86:  MOVFF  FEC,02
04B8A:  MOVFF  FEC,03
04B8E:  MOVF   00,W
04B90:  MOVLB  9
04B92:  ADDWF  xE3,W
04B94:  MOVWF  xDB
04B96:  MOVF   01,W
04B98:  ADDWFC xE4,W
04B9A:  MOVWF  xDC
04B9C:  MOVF   02,W
04B9E:  ADDWFC xE5,W
04BA0:  MOVWF  xDD
04BA2:  MOVF   03,W
04BA4:  ADDWFC xE6,W
04BA6:  MOVWF  xDE
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04BA8:  MOVF   xD6,W
04BAA:  SUBLW  03
04BAC:  BNZ   4C1E
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04BAE:  MOVLW  14
04BB0:  MOVLB  7
04BB2:  ADDWF  x12,W
04BB4:  MOVWF  01
04BB6:  MOVLW  00
04BB8:  ADDWFC x13,W
04BBA:  MOVWF  03
04BBC:  MOVFF  01,9E3
04BC0:  MOVLB  9
04BC2:  MOVWF  xE4
04BC4:  MOVLW  50
04BC6:  MOVLB  7
04BC8:  ADDWF  x12,W
04BCA:  MOVWF  01
04BCC:  MOVLW  00
04BCE:  ADDWFC x13,W
04BD0:  MOVFF  01,FE9
04BD4:  MOVWF  FEA
04BD6:  MOVFF  FEF,00
04BDA:  MOVFF  FEC,01
04BDE:  MOVFF  FEC,02
04BE2:  MOVFF  FEC,03
04BE6:  MOVFF  9E4,FEA
04BEA:  MOVFF  9E3,FE9
04BEE:  MOVFF  00,FEF
04BF2:  MOVFF  01,FEC
04BF6:  MOVFF  02,FEC
04BFA:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04BFE:  MOVLW  18
04C00:  ADDWF  x12,W
04C02:  MOVWF  FE9
04C04:  MOVLW  00
04C06:  ADDWFC x13,W
04C08:  MOVWF  FEA
04C0A:  MOVFF  9DB,FEF
04C0E:  MOVFF  9DC,FEC
04C12:  MOVFF  9DD,FEC
04C16:  MOVFF  9DE,FEC
....................       }  
04C1A:  BRA    4CAA
04C1C:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04C1E:  MOVLW  14
04C20:  MOVLB  7
04C22:  ADDWF  x12,W
04C24:  MOVWF  FE9
04C26:  MOVLW  00
04C28:  ADDWFC x13,W
04C2A:  MOVWF  FEA
04C2C:  MOVFF  9DB,FEF
04C30:  MOVFF  9DC,FEC
04C34:  MOVFF  9DD,FEC
04C38:  MOVFF  9DE,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04C3C:  MOVLW  18
04C3E:  ADDWF  x12,W
04C40:  MOVWF  01
04C42:  MOVLW  00
04C44:  ADDWFC x13,W
04C46:  MOVFF  01,9E3
04C4A:  MOVLB  9
04C4C:  MOVWF  xE4
04C4E:  MOVLW  04
04C50:  MOVLB  7
04C52:  ADDWF  x12,W
04C54:  MOVWF  FE9
04C56:  MOVLW  00
04C58:  ADDWFC x13,W
04C5A:  MOVWF  FEA
04C5C:  MOVFF  FEC,9E6
04C60:  MOVF   FED,F
04C62:  MOVFF  FEF,9E5
04C66:  MOVLB  9
04C68:  RRCF   xE6,F
04C6A:  RRCF   xE5,F
04C6C:  RRCF   xE6,F
04C6E:  RRCF   xE5,F
04C70:  RRCF   xE6,F
04C72:  RRCF   xE5,F
04C74:  RRCF   xE6,F
04C76:  RRCF   xE5,F
04C78:  MOVLW  0F
04C7A:  ANDWF  xE6,F
04C7C:  MOVF   xE5,W
04C7E:  ADDWF  xDB,W
04C80:  MOVWF  00
04C82:  MOVF   xE6,W
04C84:  ADDWFC xDC,W
04C86:  MOVWF  01
04C88:  MOVLW  00
04C8A:  ADDWFC xDD,W
04C8C:  MOVWF  02
04C8E:  MOVLW  00
04C90:  ADDWFC xDE,W
04C92:  MOVFF  9E4,FEA
04C96:  MOVFF  9E3,FE9
04C9A:  MOVFF  00,FEF
04C9E:  MOVFF  01,FEC
04CA2:  MOVFF  02,FEC
04CA6:  MOVWF  FEC
04CA8:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04CAA:  MOVLW  44
04CAC:  ADDWF  x12,W
04CAE:  MOVWF  01
04CB0:  MOVLW  00
04CB2:  ADDWFC x13,W
04CB4:  MOVFF  01,FE9
04CB8:  MOVWF  FEA
04CBA:  MOVFF  FEF,9DF
04CBE:  MOVFF  FEC,9E0
04CC2:  MOVFF  FEC,9E1
04CC6:  MOVFF  FEC,9E2
....................    if (!maxsect)  
04CCA:  MOVLB  9
04CCC:  MOVF   xDF,F
04CCE:  BNZ   4CFE
04CD0:  MOVF   xE0,F
04CD2:  BNZ   4CFE
04CD4:  MOVF   xE1,F
04CD6:  BNZ   4CFE
04CD8:  MOVF   xE2,F
04CDA:  BNZ   4CFE
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04CDC:  MOVLW  37
04CDE:  MOVLB  7
04CE0:  ADDWF  x12,W
04CE2:  MOVWF  01
04CE4:  MOVLW  00
04CE6:  ADDWFC x13,W
04CE8:  MOVFF  01,FE9
04CEC:  MOVWF  FEA
04CEE:  MOVLB  9
04CF0:  CLRF   xE2
04CF2:  CLRF   xE1
04CF4:  MOVFF  FEC,9E0
04CF8:  MOVF   FED,F
04CFA:  MOVFF  FEF,9DF
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04CFE:  MOVLW  0C
04D00:  MOVLB  7
04D02:  ADDWF  x12,W
04D04:  MOVWF  01
04D06:  MOVLW  00
04D08:  ADDWFC x13,W
04D0A:  MOVWF  03
04D0C:  MOVFF  01,9E3
04D10:  MOVLB  9
04D12:  MOVWF  xE4
04D14:  MOVLW  18
04D16:  MOVLB  7
04D18:  ADDWF  x12,W
04D1A:  MOVWF  FE9
04D1C:  MOVLW  00
04D1E:  ADDWFC x13,W
04D20:  MOVWF  FEA
04D22:  MOVFF  FEF,00
04D26:  MOVFF  FEC,01
04D2A:  MOVFF  FEC,02
04D2E:  MOVFF  FEC,03
04D32:  MOVF   00,W
04D34:  MOVLB  9
04D36:  SUBWF  xDF,W
04D38:  MOVWF  xE5
04D3A:  MOVF   01,W
04D3C:  SUBWFB xE0,W
04D3E:  MOVWF  xE6
04D40:  MOVF   02,W
04D42:  SUBWFB xE1,W
04D44:  MOVWF  xE7
04D46:  MOVF   03,W
04D48:  SUBWFB xE2,W
04D4A:  MOVWF  xE8
04D4C:  MOVF   xD7,W
04D4E:  ADDWF  xE5,F
04D50:  MOVF   xD8,W
04D52:  ADDWFC xE6,F
04D54:  MOVF   xD9,W
04D56:  ADDWFC xE7,F
04D58:  MOVF   xDA,W
04D5A:  ADDWFC xE8,F
04D5C:  MOVLW  02
04D5E:  MOVLB  7
04D60:  ADDWF  x12,W
04D62:  MOVWF  FE9
04D64:  MOVLW  00
04D66:  ADDWFC x13,W
04D68:  MOVWF  FEA
04D6A:  MOVFF  FEF,A50
04D6E:  MOVLB  9
04D70:  MOVFF  FEA,9EB
04D74:  MOVFF  FE9,9EA
04D78:  BCF    FD8.1
04D7A:  CLRF   1B
04D7C:  BTFSC  FF2.7
04D7E:  BSF    1B.7
04D80:  BCF    FF2.7
04D82:  MOVFF  9E8,A4F
04D86:  MOVFF  9E7,A4E
04D8A:  MOVFF  9E6,A4D
04D8E:  MOVFF  9E5,A4C
04D92:  MOVLB  A
04D94:  CLRF   x53
04D96:  CLRF   x52
04D98:  CLRF   x51
04D9A:  MOVLB  0
04D9C:  CALL   104E
04DA0:  BTFSC  1B.7
04DA2:  BSF    FF2.7
04DA4:  MOVFF  9EB,FEA
04DA8:  MOVFF  9EA,FE9
04DAC:  MOVFF  03,9E8
04DB0:  MOVFF  02,9E7
04DB4:  MOVFF  01,9E6
04DB8:  MOVFF  00,9E5
04DBC:  MOVLW  02
04DBE:  MOVLB  9
04DC0:  ADDWF  00,W
04DC2:  MOVWF  00
04DC4:  MOVLW  00
04DC6:  ADDWFC 01,W
04DC8:  MOVWF  01
04DCA:  MOVLW  00
04DCC:  ADDWFC 02,W
04DCE:  MOVWF  02
04DD0:  MOVLW  00
04DD2:  ADDWFC 03,W
04DD4:  MOVFF  9E4,FEA
04DD8:  MOVFF  9E3,FE9
04DDC:  MOVFF  00,FEF
04DE0:  MOVFF  01,FEC
04DE4:  MOVFF  02,FEC
04DE8:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04DEA:  MOVLW  00
04DEC:  MOVWF  01
04DEE:  MOVLB  7
04DF0:  MOVLB  0
04DF2:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
07158:  CALL   55AC
0715C:  MOVFF  01,9C3
....................    if (result != FR_OK)  
07160:  MOVLB  9
07162:  MOVF   xC3,F
07164:  BZ    716C
....................       return (result); 
07166:  MOVFF  9C3,01
0716A:  BRA    759C
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
0716C:  MOVF   xB4,W
0716E:  ANDLW  0A
07170:  BZ    7188
07172:  MOVLB  0
07174:  CALL   559E
07178:  BTFSC  01.2
0717A:  BRA    7180
0717C:  MOVLB  9
0717E:  BRA    7188
....................          return (FR_WRITE_PROTECTED); 
07180:  MOVLW  0A
07182:  MOVWF  01
07184:  MOVLB  9
07186:  BRA    759C
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
07188:  MOVLW  09
0718A:  MOVWF  xD7
0718C:  MOVLW  B5
0718E:  MOVWF  xD6
07190:  MOVLW  09
07192:  MOVWF  xD9
07194:  MOVLW  C6
07196:  MOVWF  xD8
07198:  MOVFF  9B3,9DB
0719C:  MOVFF  9B2,9DA
071A0:  MOVLW  09
071A2:  MOVWF  xDD
071A4:  MOVLW  C4
071A6:  MOVWF  xDC
071A8:  MOVLB  0
071AA:  CALL   61E2
071AE:  MOVFF  01,9C3
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
071B2:  MOVLB  9
071B4:  MOVF   xB4,W
071B6:  ANDLW  18
071B8:  BTFSC  FD8.2
071BA:  BRA    73DE
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
071BC:  MOVF   xC3,F
071BE:  BZ    7246
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
071C0:  BSF    xB4.3
....................          if (result != FR_NO_FILE) 
071C2:  MOVF   xC3,W
071C4:  SUBLW  02
071C6:  BZ    71CE
....................             return (result); 
071C8:  MOVFF  9C3,01
071CC:  BRA    759C
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
071CE:  MOVLW  09
071D0:  MOVWF  xD7
071D2:  MOVLW  B5
071D4:  MOVWF  xD6
071D6:  MOVLB  0
071D8:  BRA    6BFC
071DA:  MOVFF  02,9C5
071DE:  MOVFF  01,9C4
....................          if (dir_ptr == NULL) 
071E2:  MOVLB  9
071E4:  MOVF   xC4,F
071E6:  BNZ   71F2
071E8:  MOVF   xC5,F
071EA:  BNZ   71F2
....................             return (FR_DENIED); 
071EC:  MOVLW  05
071EE:  MOVWF  01
071F0:  BRA    759C
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
071F2:  MOVFF  9C5,FEA
071F6:  MOVFF  9C4,FE9
071FA:  MOVLW  09
071FC:  MOVWF  FE2
071FE:  MOVLW  C6
07200:  MOVWF  FE1
07202:  MOVLW  0B
07204:  MOVWF  01
07206:  MOVFF  FE6,FEE
0720A:  DECFSZ 01,F
0720C:  BRA    7206
....................          *(dir_ptr+12) = fn[11]; 
0720E:  MOVLW  0C
07210:  ADDWF  xC4,W
07212:  MOVWF  01
07214:  MOVLW  00
07216:  ADDWFC xC5,W
07218:  MOVFF  01,FE9
0721C:  MOVWF  FEA
0721E:  MOVFF  9D1,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
07222:  MOVLW  0D
07224:  ADDWF  xC4,W
07226:  MOVWF  xD6
07228:  MOVLW  00
0722A:  ADDWFC xC5,W
0722C:  MOVWF  xD7
0722E:  MOVWF  FEA
07230:  MOVFF  9D6,FE9
07234:  CLRF   00
07236:  CLRF   02
07238:  MOVLW  13
0723A:  MOVWF  01
0723C:  MOVLB  0
0723E:  CALL   3526
....................       }  
07242:  BRA    7358
07244:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
07246:  MOVF   xC4,F
07248:  BNZ   724E
0724A:  MOVF   xC5,F
0724C:  BZ    7266
0724E:  MOVLW  0B
07250:  ADDWF  xC4,W
07252:  MOVWF  01
07254:  MOVLW  00
07256:  ADDWFC xC5,W
07258:  MOVWF  03
0725A:  MOVFF  01,FE9
0725E:  MOVWF  FEA
07260:  MOVF   FEF,W
07262:  ANDLW  11
07264:  BZ    726C
....................             return (FR_DENIED); 
07266:  MOVLW  05
07268:  MOVWF  01
0726A:  BRA    759C
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
0726C:  BTFSS  xB4.3
0726E:  BRA    7356
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
07270:  MOVLW  20
07272:  MOVLB  7
07274:  ADDWF  x12,W
07276:  MOVWF  FE9
07278:  MOVLW  00
0727A:  ADDWFC x13,W
0727C:  MOVWF  FEA
0727E:  MOVFF  FEF,9D2
07282:  MOVFF  FEC,9D3
07286:  MOVFF  FEC,9D4
0728A:  MOVFF  FEC,9D5
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
0728E:  MOVLW  14
07290:  MOVLB  9
07292:  ADDWF  xC4,W
07294:  MOVWF  01
07296:  MOVLW  00
07298:  ADDWFC xC5,W
0729A:  MOVWF  03
0729C:  MOVFF  01,FE9
072A0:  MOVWF  FEA
072A2:  MOVFF  FEC,9DE
072A6:  MOVF   FED,F
072A8:  MOVFF  FEF,9D6
072AC:  CLRF   xD8
072AE:  MOVFF  9D6,9DD
072B2:  CLRF   xD6
072B4:  CLRF   xD7
072B6:  MOVLW  1A
072B8:  ADDWF  xC4,W
072BA:  MOVWF  01
072BC:  MOVLW  00
072BE:  ADDWFC xC5,W
072C0:  MOVFF  01,FE9
072C4:  MOVWF  FEA
072C6:  MOVFF  FEC,03
072CA:  MOVF   FED,F
072CC:  MOVF   FEF,W
072CE:  IORWF  xD6,F
072D0:  MOVF   03,W
072D2:  IORWF  xD7,F
072D4:  MOVFF  9D7,9DC
072D8:  MOVFF  9D6,9DB
072DC:  MOVLB  0
072DE:  RCALL  6F46
072E0:  MOVF   01,F
072E2:  BZ    72FC
072E4:  MOVFF  9D5,A17
072E8:  MOVFF  9D4,A16
072EC:  MOVFF  9D3,A15
072F0:  MOVFF  9D2,A14
072F4:  CALL   5A82
072F8:  MOVF   01,F
072FA:  BNZ   7306
....................                return (FR_RW_ERROR); 
072FC:  MOVLW  07
072FE:  MOVWF  01
07300:  MOVLB  9
07302:  BRA    759C
07304:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
07306:  MOVLW  14
07308:  MOVLB  9
0730A:  ADDWF  xC4,W
0730C:  MOVWF  01
0730E:  MOVLW  00
07310:  ADDWFC xC5,W
07312:  MOVFF  01,FE9
07316:  MOVWF  FEA
07318:  CLRF   FEC
0731A:  MOVF   FED,F
0731C:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
0731E:  MOVLW  1A
07320:  ADDWF  xC4,W
07322:  MOVWF  01
07324:  MOVLW  00
07326:  ADDWFC xC5,W
07328:  MOVFF  01,FE9
0732C:  MOVWF  FEA
0732E:  CLRF   FEC
07330:  MOVF   FED,F
07332:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
07334:  MOVLW  1C
07336:  ADDWF  xC4,W
07338:  MOVWF  01
0733A:  MOVLW  00
0733C:  ADDWFC xC5,W
0733E:  MOVFF  01,FE9
07342:  MOVWF  FEA
07344:  MOVF   FEE,F
07346:  MOVF   FEE,F
07348:  CLRF   FEC
0734A:  MOVF   FED,F
0734C:  CLRF   FEF
0734E:  MOVF   FED,F
07350:  CLRF   FEF
07352:  MOVF   FED,F
07354:  CLRF   FEF
07356:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
07358:  MOVLB  9
0735A:  BTFSS  xB4.3
0735C:  BRA    73DC
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
0735E:  MOVLW  0B
07360:  ADDWF  xC4,W
07362:  MOVWF  01
07364:  MOVLW  00
07366:  ADDWFC xC5,W
07368:  MOVFF  01,FE9
0736C:  MOVWF  FEA
0736E:  MOVLW  20
07370:  MOVWF  FEF
....................          dw = get_fattime(); 
07372:  MOVLB  0
07374:  RCALL  6FE8
07376:  MOVFF  03,9D5
0737A:  MOVFF  02,9D4
0737E:  MOVFF  01,9D3
07382:  MOVFF  00,9D2
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
07386:  MOVLW  0E
07388:  MOVLB  9
0738A:  ADDWF  xC4,W
0738C:  MOVWF  01
0738E:  MOVLW  00
07390:  ADDWFC xC5,W
07392:  MOVFF  01,FE9
07396:  MOVWF  FEA
07398:  MOVFF  9D2,FEF
0739C:  MOVFF  9D3,FEC
073A0:  MOVFF  9D4,FEC
073A4:  MOVFF  9D5,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
073A8:  MOVLW  16
073AA:  ADDWF  xC4,W
073AC:  MOVWF  01
073AE:  MOVLW  00
073B0:  ADDWFC xC5,W
073B2:  MOVFF  01,FE9
073B6:  MOVWF  FEA
073B8:  MOVFF  9D2,FEF
073BC:  MOVFF  9D3,FEC
073C0:  MOVFF  9D4,FEC
073C4:  MOVFF  9D5,FEC
....................          fs->winflag = 1; 
073C8:  MOVLW  06
073CA:  MOVLB  7
073CC:  ADDWF  x12,W
073CE:  MOVWF  FE9
073D0:  MOVLW  00
073D2:  ADDWFC x13,W
073D4:  MOVWF  FEA
073D6:  MOVLW  01
073D8:  MOVWF  FEF
073DA:  MOVLB  9
....................       } 
....................    } 
073DC:  BRA    742C
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
073DE:  MOVF   xC3,F
073E0:  BZ    73E8
....................          return (result);      // Trace failed  
073E2:  MOVFF  9C3,01
073E6:  BRA    759C
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
073E8:  MOVF   xC4,F
073EA:  BNZ   73F0
073EC:  MOVF   xC5,F
073EE:  BZ    7406
073F0:  MOVLW  0B
073F2:  ADDWF  xC4,W
073F4:  MOVWF  01
073F6:  MOVLW  00
073F8:  ADDWFC xC5,W
073FA:  MOVWF  03
073FC:  MOVFF  01,FE9
07400:  MOVWF  FEA
07402:  BTFSS  FEF.4
07404:  BRA    740C
....................          return (FR_NO_FILE); 
07406:  MOVLW  02
07408:  MOVWF  01
0740A:  BRA    759C
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
0740C:  BTFSS  xB4.1
0740E:  BRA    742C
07410:  MOVLW  0B
07412:  ADDWF  xC4,W
07414:  MOVWF  01
07416:  MOVLW  00
07418:  ADDWFC xC5,W
0741A:  MOVWF  03
0741C:  MOVFF  01,FE9
07420:  MOVWF  FEA
07422:  BTFSS  FEF.0
07424:  BRA    742C
....................          return (FR_DENIED); 
07426:  MOVLW  05
07428:  MOVWF  01
0742A:  BRA    759C
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
0742C:  MOVLW  1A
0742E:  ADDWF  xB0,W
07430:  MOVWF  FE9
07432:  MOVLW  00
07434:  ADDWFC xB1,W
07436:  MOVWF  FEA
07438:  MOVF   xB4,W
0743A:  ANDLW  03
0743C:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
0743E:  MOVLW  14
07440:  ADDWF  xB0,W
07442:  MOVWF  01
07444:  MOVLW  00
07446:  ADDWFC xB1,W
07448:  MOVWF  03
0744A:  MOVFF  01,9D6
0744E:  MOVWF  xD7
07450:  MOVLW  20
07452:  MOVLB  7
07454:  ADDWF  x12,W
07456:  MOVWF  FE9
07458:  MOVLW  00
0745A:  ADDWFC x13,W
0745C:  MOVWF  FEA
0745E:  MOVFF  FEF,00
07462:  MOVFF  FEC,01
07466:  MOVFF  FEC,02
0746A:  MOVFF  FEC,03
0746E:  MOVFF  9D7,FEA
07472:  MOVFF  9D6,FE9
07476:  MOVFF  00,FEF
0747A:  MOVFF  01,FEC
0747E:  MOVFF  02,FEC
07482:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
07486:  MOVLW  18
07488:  MOVLB  9
0748A:  ADDWF  xB0,W
0748C:  MOVWF  FE9
0748E:  MOVLW  00
07490:  ADDWFC xB1,W
07492:  MOVWF  FEA
07494:  MOVFF  9C5,FEC
07498:  MOVF   FED,F
0749A:  MOVFF  9C4,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
0749E:  MOVLW  08
074A0:  ADDWF  xB0,W
074A2:  MOVWF  01
074A4:  MOVLW  00
074A6:  ADDWFC xB1,W
074A8:  MOVWF  03
074AA:  MOVFF  01,9D6
074AE:  MOVWF  xD7
074B0:  MOVLW  14
074B2:  ADDWF  xC4,W
074B4:  MOVWF  01
074B6:  MOVLW  00
074B8:  ADDWFC xC5,W
074BA:  MOVWF  03
074BC:  MOVFF  01,FE9
074C0:  MOVWF  FEA
074C2:  MOVFF  FEC,9DB
074C6:  MOVF   FED,F
074C8:  MOVFF  FEF,9D8
074CC:  CLRF   xDA
074CE:  MOVFF  9D8,9DA
074D2:  CLRF   xD8
074D4:  CLRF   xD9
074D6:  MOVLW  1A
074D8:  ADDWF  xC4,W
074DA:  MOVWF  01
074DC:  MOVLW  00
074DE:  ADDWFC xC5,W
074E0:  MOVFF  01,FE9
074E4:  MOVWF  FEA
074E6:  MOVFF  FEC,03
074EA:  MOVF   FED,F
074EC:  MOVF   FEF,W
074EE:  IORWF  xD8,W
074F0:  MOVWF  00
074F2:  MOVF   03,W
074F4:  IORWF  xD9,W
074F6:  MOVFF  9DA,02
074FA:  MOVFF  9DB,03
074FE:  MOVFF  9D7,FEA
07502:  MOVFF  9D6,FE9
07506:  MOVFF  00,FEF
0750A:  MOVWF  FEC
0750C:  MOVFF  9DA,FEC
07510:  MOVFF  9DB,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
07514:  MOVLW  04
07516:  ADDWF  xB0,W
07518:  MOVWF  01
0751A:  MOVLW  00
0751C:  ADDWFC xB1,W
0751E:  MOVWF  03
07520:  MOVFF  01,9D6
07524:  MOVWF  xD7
07526:  MOVLW  1C
07528:  ADDWF  xC4,W
0752A:  MOVWF  01
0752C:  MOVLW  00
0752E:  ADDWFC xC5,W
07530:  MOVFF  01,FE9
07534:  MOVWF  FEA
07536:  MOVFF  FEF,00
0753A:  MOVFF  FEC,01
0753E:  MOVFF  FEC,02
07542:  MOVFF  FEC,03
07546:  MOVFF  9D7,FEA
0754A:  MOVFF  9D6,FE9
0754E:  MOVFF  00,FEF
07552:  MOVFF  01,FEC
07556:  MOVFF  02,FEC
0755A:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
0755E:  MOVFF  9B0,FE9
07562:  MOVFF  9B1,FEA
07566:  MOVF   FEE,F
07568:  MOVF   FEE,F
0756A:  CLRF   FEC
0756C:  MOVF   FED,F
0756E:  CLRF   FEF
07570:  MOVF   FED,F
07572:  CLRF   FEF
07574:  MOVF   FED,F
07576:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
07578:  MOVLW  1B
0757A:  ADDWF  xB0,W
0757C:  MOVWF  FE9
0757E:  MOVLW  00
07580:  ADDWFC xB1,W
07582:  MOVWF  FEA
07584:  MOVLW  01
07586:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
07588:  MOVLB  7
0758A:  ADDWF  x12,W
0758C:  MOVWF  FE9
0758E:  MOVLW  00
07590:  ADDWFC x13,W
07592:  MOVWF  FEA
07594:  INCF   FEF,F
....................    return (FR_OK); 
07596:  MOVLW  00
07598:  MOVWF  01
0759A:  MOVLB  9
0759C:  MOVLB  0
0759E:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B468:  MOVFF  8CF,8E4
0B46C:  MOVFF  8CE,8E3
....................       *br = 0; 
0B470:  MOVLB  8
0B472:  MOVFF  8D2,FE9
0B476:  MOVFF  8D3,FEA
0B47A:  CLRF   FEC
0B47C:  MOVF   FED,F
0B47E:  CLRF   FEF
....................       if (!fs)  
0B480:  MOVLB  7
0B482:  MOVF   x12,W
0B484:  IORWF  x13,W
0B486:  BNZ   B48E
....................          return (FR_NOT_ENABLED); 
0B488:  MOVLW  0B
0B48A:  MOVWF  01
0B48C:  BRA    B970
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B48E:  MOVLB  0
0B490:  CALL   559E
0B494:  BTFSC  01.0
0B496:  BRA    B4A8
0B498:  MOVLB  7
0B49A:  MOVFF  712,FE9
0B49E:  MOVFF  713,FEA
0B4A2:  MOVF   FEF,F
0B4A4:  BNZ   B4B0
0B4A6:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B4A8:  MOVLW  01
0B4AA:  MOVWF  01
0B4AC:  MOVLB  7
0B4AE:  BRA    B970
....................     
....................       if (fp->flag & FA__ERROR) 
0B4B0:  MOVLW  1A
0B4B2:  MOVLB  8
0B4B4:  ADDWF  xCC,W
0B4B6:  MOVWF  FE9
0B4B8:  MOVLW  00
0B4BA:  ADDWFC xCD,W
0B4BC:  MOVWF  FEA
0B4BE:  BTFSS  FEF.7
0B4C0:  BRA    B4CC
....................          return (FR_RW_ERROR);   // Check error flag  
0B4C2:  MOVLW  07
0B4C4:  MOVWF  01
0B4C6:  MOVLB  7
0B4C8:  BRA    B970
0B4CA:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B4CC:  MOVLW  1A
0B4CE:  ADDWF  xCC,W
0B4D0:  MOVWF  FE9
0B4D2:  MOVLW  00
0B4D4:  ADDWFC xCD,W
0B4D6:  MOVWF  FEA
0B4D8:  BTFSC  FEF.0
0B4DA:  BRA    B4E6
....................          return (FR_DENIED);      // Check access mode  
0B4DC:  MOVLW  05
0B4DE:  MOVWF  01
0B4E0:  MOVLB  7
0B4E2:  BRA    B970
0B4E4:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B4E6:  MOVLW  04
0B4E8:  ADDWF  xCC,W
0B4EA:  MOVWF  FE9
0B4EC:  MOVLW  00
0B4EE:  ADDWFC xCD,W
0B4F0:  MOVWF  FEA
0B4F2:  MOVFF  FEF,8E5
0B4F6:  MOVFF  FEC,8E6
0B4FA:  MOVFF  FEC,8E7
0B4FE:  MOVFF  FEC,8E8
0B502:  MOVFF  8CC,FE9
0B506:  MOVFF  8CD,FEA
0B50A:  MOVFF  FEF,00
0B50E:  MOVFF  FEC,01
0B512:  MOVFF  FEC,02
0B516:  MOVFF  FEC,03
0B51A:  MOVF   00,W
0B51C:  SUBWF  xE5,W
0B51E:  MOVWF  xDC
0B520:  MOVF   01,W
0B522:  SUBWFB xE6,W
0B524:  MOVWF  xDD
0B526:  MOVF   02,W
0B528:  SUBWFB xE7,W
0B52A:  MOVWF  xDE
0B52C:  MOVF   03,W
0B52E:  SUBWFB xE8,W
0B530:  MOVWF  xDF
....................       if (btr > ln) 
0B532:  MOVF   xDF,F
0B534:  BNZ   B550
0B536:  MOVF   xDE,F
0B538:  BNZ   B550
0B53A:  MOVF   xDD,W
0B53C:  SUBWF  xD1,W
0B53E:  BNC   B550
0B540:  BNZ   B548
0B542:  MOVF   xD0,W
0B544:  SUBWF  xDC,W
0B546:  BC    B550
....................          btr = ln;            // Truncate read count by number of bytes left  
0B548:  MOVFF  8DD,8D1
0B54C:  MOVFF  8DC,8D0
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B550:  MOVF   xD0,W
0B552:  IORWF  xD1,W
0B554:  BTFSC  FD8.2
0B556:  BRA    B94E
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B558:  MOVFF  8CC,FE9
0B55C:  MOVFF  8CD,FEA
0B560:  MOVFF  FEF,8E5
0B564:  MOVFF  FEC,8E6
0B568:  MOVFF  FEC,8E7
0B56C:  MOVFF  FEC,8E8
0B570:  MOVLW  01
0B572:  ANDWF  xE6,F
0B574:  CLRF   xE7
0B576:  CLRF   xE8
0B578:  MOVF   xE5,F
0B57A:  BTFSS  FD8.2
0B57C:  BRA    B7F6
0B57E:  MOVF   xE6,F
0B580:  BTFSS  FD8.2
0B582:  BRA    B7F6
0B584:  MOVF   xE7,F
0B586:  BTFSS  FD8.2
0B588:  BRA    B7F6
0B58A:  MOVF   xE8,F
0B58C:  BTFSS  FD8.2
0B58E:  BRA    B7F6
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B590:  MOVLW  1B
0B592:  ADDWF  xCC,W
0B594:  MOVWF  FE9
0B596:  MOVLW  00
0B598:  ADDWFC xCD,W
0B59A:  MOVWF  FEA
0B59C:  DECF   FEF,F
0B59E:  BZ    B5D6
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B5A0:  MOVLW  10
0B5A2:  ADDWF  xCC,W
0B5A4:  MOVWF  FE9
0B5A6:  MOVLW  00
0B5A8:  ADDWFC xCD,W
0B5AA:  MOVWF  FEA
0B5AC:  MOVFF  FEF,8E5
0B5B0:  MOVFF  FEC,8E6
0B5B4:  MOVFF  FEC,8E7
0B5B8:  MOVFF  FEC,8E8
0B5BC:  MOVLW  01
0B5BE:  ADDWF  xE5,W
0B5C0:  MOVWF  xD8
0B5C2:  MOVLW  00
0B5C4:  ADDWFC xE6,W
0B5C6:  MOVWF  xD9
0B5C8:  MOVLW  00
0B5CA:  ADDWFC xE7,W
0B5CC:  MOVWF  xDA
0B5CE:  MOVLW  00
0B5D0:  ADDWFC xE8,W
0B5D2:  MOVWF  xDB
....................                }  
0B5D4:  BRA    B712
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B5D6:  MOVFF  8CC,FE9
0B5DA:  MOVFF  8CD,FEA
0B5DE:  MOVFF  FEF,8E5
0B5E2:  MOVFF  FEC,8E6
0B5E6:  MOVFF  FEC,8E7
0B5EA:  MOVFF  FEC,8E8
0B5EE:  MOVF   xE5,F
0B5F0:  BNZ   B61C
0B5F2:  MOVF   xE6,F
0B5F4:  BNZ   B61C
0B5F6:  MOVF   xE7,F
0B5F8:  BNZ   B61C
0B5FA:  MOVF   xE8,F
0B5FC:  BNZ   B61C
0B5FE:  MOVLW  08
0B600:  ADDWF  xCC,W
0B602:  MOVWF  FE9
0B604:  MOVLW  00
0B606:  ADDWFC xCD,W
0B608:  MOVWF  FEA
0B60A:  MOVFF  FEF,00
0B60E:  MOVFF  FEC,01
0B612:  MOVFF  FEC,02
0B616:  MOVFF  FEC,03
0B61A:  BRA    B640
0B61C:  MOVLW  0C
0B61E:  ADDWF  xCC,W
0B620:  MOVWF  FE9
0B622:  MOVLW  00
0B624:  ADDWFC xCD,W
0B626:  MOVWF  FEA
0B628:  MOVFF  FEF,9FC
0B62C:  MOVFF  FEC,9FD
0B630:  MOVFF  FEC,9FE
0B634:  MOVFF  FEC,9FF
0B638:  MOVLB  0
0B63A:  CALL   5CBA
0B63E:  MOVLB  8
0B640:  MOVFF  03,8D7
0B644:  MOVFF  02,8D6
0B648:  MOVFF  01,8D5
0B64C:  MOVFF  00,8D4
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B650:  MOVF   xD7,F
0B652:  BNZ   B662
0B654:  MOVF   xD6,F
0B656:  BNZ   B662
0B658:  MOVF   xD5,F
0B65A:  BNZ   B662
0B65C:  MOVF   xD4,W
0B65E:  SUBLW  01
0B660:  BC    B6A0
0B662:  MOVLW  0C
0B664:  MOVLB  7
0B666:  ADDWF  x12,W
0B668:  MOVWF  FE9
0B66A:  MOVLW  00
0B66C:  ADDWFC x13,W
0B66E:  MOVWF  FEA
0B670:  MOVFF  FEF,00
0B674:  MOVFF  FEC,01
0B678:  MOVFF  FEC,02
0B67C:  MOVFF  FEC,03
0B680:  MOVF   03,W
0B682:  MOVLB  8
0B684:  SUBWF  xD7,W
0B686:  BNC   B6A2
0B688:  BNZ   B6A0
0B68A:  MOVF   02,W
0B68C:  SUBWF  xD6,W
0B68E:  BNC   B6A2
0B690:  BNZ   B6A0
0B692:  MOVF   01,W
0B694:  SUBWF  xD5,W
0B696:  BNC   B6A2
0B698:  BNZ   B6A0
0B69A:  MOVF   00,W
0B69C:  SUBWF  xD4,W
0B69E:  BNC   B6A2
....................                   goto fr_error; 
0B6A0:  BRA    B958
....................                fp->curr_clust = clust;            // Current cluster  
0B6A2:  MOVLW  0C
0B6A4:  ADDWF  xCC,W
0B6A6:  MOVWF  FE9
0B6A8:  MOVLW  00
0B6AA:  ADDWFC xCD,W
0B6AC:  MOVWF  FEA
0B6AE:  MOVFF  8D4,FEF
0B6B2:  MOVFF  8D5,FEC
0B6B6:  MOVFF  8D6,FEC
0B6BA:  MOVFF  8D7,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B6BE:  MOVFF  8D7,9F2
0B6C2:  MOVFF  8D6,9F1
0B6C6:  MOVFF  8D5,9F0
0B6CA:  MOVFF  8D4,9EF
0B6CE:  MOVLB  0
0B6D0:  CALL   560E
0B6D4:  MOVFF  03,8DB
0B6D8:  MOVFF  02,8DA
0B6DC:  MOVFF  01,8D9
0B6E0:  MOVFF  00,8D8
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B6E4:  MOVLW  1B
0B6E6:  MOVLB  8
0B6E8:  ADDWF  xCC,W
0B6EA:  MOVWF  01
0B6EC:  MOVLW  00
0B6EE:  ADDWFC xCD,W
0B6F0:  MOVWF  03
0B6F2:  MOVLW  02
0B6F4:  MOVLB  7
0B6F6:  ADDWF  x12,W
0B6F8:  MOVWF  FE9
0B6FA:  MOVLW  00
0B6FC:  ADDWFC x13,W
0B6FE:  MOVWF  FEA
0B700:  MOVFF  FEF,8E7
0B704:  MOVLB  8
0B706:  MOVFF  03,FEA
0B70A:  MOVFF  01,FE9
0B70E:  MOVFF  8E7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B712:  MOVLW  10
0B714:  ADDWF  xCC,W
0B716:  MOVWF  FE9
0B718:  MOVLW  00
0B71A:  ADDWFC xCD,W
0B71C:  MOVWF  FEA
0B71E:  MOVFF  8D8,FEF
0B722:  MOVFF  8D9,FEC
0B726:  MOVFF  8DA,FEC
0B72A:  MOVFF  8DB,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B72E:  BCF    FD8.0
0B730:  RRCF   xD1,W
0B732:  MOVWF  xE2
....................             if (cc)  
0B734:  MOVF   xE2,F
0B736:  BZ    B7F6
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B738:  MOVLW  1B
0B73A:  ADDWF  xCC,W
0B73C:  MOVWF  FE9
0B73E:  MOVLW  00
0B740:  ADDWFC xCD,W
0B742:  MOVWF  FEA
0B744:  MOVF   FEF,W
0B746:  SUBWF  xE2,W
0B748:  BZ    B75C
0B74A:  BNC   B75C
....................                   cc = fp->sect_clust; 
0B74C:  MOVLW  1B
0B74E:  ADDWF  xCC,W
0B750:  MOVWF  FE9
0B752:  MOVLW  00
0B754:  ADDWFC xCD,W
0B756:  MOVWF  FEA
0B758:  MOVFF  FEF,8E2
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B75C:  MOVFF  8E4,A21
0B760:  MOVFF  8E3,A20
0B764:  MOVFF  8DB,A25
0B768:  MOVFF  8DA,A24
0B76C:  MOVFF  8D9,A23
0B770:  MOVFF  8D8,A22
0B774:  MOVFF  8E2,A26
0B778:  MOVLB  0
0B77A:  CALL   44CC
0B77E:  MOVF   01,F
0B780:  BZ    B788
....................                   goto fr_error; 
0B782:  MOVLB  8
0B784:  BRA    B958
0B786:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B788:  MOVLW  1B
0B78A:  MOVLB  8
0B78C:  ADDWF  xCC,W
0B78E:  MOVWF  FE9
0B790:  MOVLW  00
0B792:  ADDWFC xCD,W
0B794:  MOVWF  FEA
0B796:  MOVLW  01
0B798:  SUBWF  xE2,W
0B79A:  SUBWF  FEF,W
0B79C:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B79E:  MOVLW  10
0B7A0:  ADDWF  xCC,W
0B7A2:  MOVWF  FE9
0B7A4:  MOVLW  00
0B7A6:  ADDWFC xCD,W
0B7A8:  MOVWF  FEA
0B7AA:  MOVLW  01
0B7AC:  SUBWF  xE2,W
0B7AE:  ADDWF  FEF,W
0B7B0:  MOVWF  00
0B7B2:  MOVLW  00
0B7B4:  ADDWFC FEC,W
0B7B6:  MOVWF  01
0B7B8:  MOVLW  00
0B7BA:  ADDWFC FEC,W
0B7BC:  MOVWF  02
0B7BE:  MOVLW  00
0B7C0:  ADDWFC FEC,W
0B7C2:  MOVF   FED,F
0B7C4:  MOVF   FED,F
0B7C6:  MOVF   FED,F
0B7C8:  MOVFF  00,FEF
0B7CC:  MOVFF  01,FEC
0B7D0:  MOVFF  02,FEC
0B7D4:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B7D6:  MOVLB  A
0B7D8:  CLRF   x11
0B7DA:  MOVFF  8E2,A10
0B7DE:  MOVLW  02
0B7E0:  MOVWF  x13
0B7E2:  CLRF   x12
0B7E4:  MOVLB  0
0B7E6:  CALL   5C98
0B7EA:  MOVFF  02,8E1
0B7EE:  MOVFF  01,8E0
....................                continue; 
0B7F2:  BRA    B8EA
0B7F4:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B7F6:  MOVLW  10
0B7F8:  ADDWF  xCC,W
0B7FA:  MOVWF  FE9
0B7FC:  MOVLW  00
0B7FE:  ADDWFC xCD,W
0B800:  MOVWF  FEA
0B802:  MOVFF  FEF,A14
0B806:  MOVFF  FEC,A15
0B80A:  MOVFF  FEC,A16
0B80E:  MOVFF  FEC,A17
0B812:  MOVLB  0
0B814:  CALL   5A82
0B818:  MOVF   01,F
0B81A:  BNZ   B822
....................                goto fr_error; 
0B81C:  MOVLB  8
0B81E:  BRA    B958
0B820:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B822:  MOVLB  8
0B824:  MOVFF  8CC,FE9
0B828:  MOVFF  8CD,FEA
0B82C:  MOVFF  FEF,8E5
0B830:  MOVFF  FEC,8E6
0B834:  MOVFF  FEC,8E7
0B838:  MOVFF  FEC,8E8
0B83C:  MOVF   xE6,W
0B83E:  ANDLW  01
0B840:  MOVWF  01
0B842:  MOVLW  00
0B844:  BSF    FD8.0
0B846:  SUBFWB xE5,W
0B848:  MOVWF  xE0
0B84A:  MOVLW  02
0B84C:  SUBFWB 01,W
0B84E:  MOVWF  xE1
....................          if (rcnt > btr) 
0B850:  MOVF   xD1,W
0B852:  SUBWF  xE1,W
0B854:  BNC   B866
0B856:  BNZ   B85E
0B858:  MOVF   xE0,W
0B85A:  SUBWF  xD0,W
0B85C:  BC    B866
....................             rcnt = btr; 
0B85E:  MOVFF  8D1,8E1
0B862:  MOVFF  8D0,8E0
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B866:  MOVFF  8CC,FE9
0B86A:  MOVFF  8CD,FEA
0B86E:  MOVFF  FEF,8E5
0B872:  MOVFF  FEC,8E6
0B876:  MOVFF  FEC,8E7
0B87A:  MOVFF  FEC,8E8
0B87E:  MOVLW  01
0B880:  ANDWF  xE6,F
0B882:  CLRF   xE7
0B884:  CLRF   xE8
0B886:  MOVLW  24
0B888:  ADDWF  xE5,W
0B88A:  MOVWF  00
0B88C:  MOVLW  00
0B88E:  ADDWFC xE6,W
0B890:  MOVWF  01
0B892:  MOVLW  00
0B894:  ADDWFC xE7,W
0B896:  MOVWF  02
0B898:  MOVLW  00
0B89A:  ADDWFC xE8,W
0B89C:  MOVWF  03
0B89E:  MOVFF  01,03
0B8A2:  MOVF   00,W
0B8A4:  MOVLB  7
0B8A6:  ADDWF  x12,W
0B8A8:  MOVWF  01
0B8AA:  MOVF   x13,W
0B8AC:  ADDWFC 03,F
0B8AE:  MOVFF  01,8E9
0B8B2:  MOVLB  8
0B8B4:  MOVFF  03,8EA
0B8B8:  MOVFF  8E4,FEA
0B8BC:  MOVFF  8E3,FE9
0B8C0:  MOVFF  03,FE2
0B8C4:  MOVFF  01,FE1
0B8C8:  MOVFF  8E1,02
0B8CC:  MOVFF  8E0,01
0B8D0:  MOVF   01,F
0B8D2:  BZ    B8D8
0B8D4:  INCF   02,F
0B8D6:  BRA    B8DC
0B8D8:  MOVF   02,F
0B8DA:  BZ    B8E8
0B8DC:  MOVFF  FE6,FEE
0B8E0:  DECFSZ 01,F
0B8E2:  BRA    B8DC
0B8E4:  DECFSZ 02,F
0B8E6:  BRA    B8DC
0B8E8:  MOVLB  0
0B8EA:  MOVLB  8
0B8EC:  MOVF   xE0,W
0B8EE:  ADDWF  xE3,F
0B8F0:  MOVF   xE1,W
0B8F2:  ADDWFC xE4,F
0B8F4:  MOVFF  8CC,FE9
0B8F8:  MOVFF  8CD,FEA
0B8FC:  MOVF   xE0,W
0B8FE:  ADDWF  FEF,W
0B900:  MOVWF  00
0B902:  MOVF   xE1,W
0B904:  ADDWFC FEC,W
0B906:  MOVWF  01
0B908:  MOVLW  00
0B90A:  ADDWFC FEC,W
0B90C:  MOVWF  02
0B90E:  MOVLW  00
0B910:  ADDWFC FEC,W
0B912:  MOVWF  03
0B914:  MOVF   FED,F
0B916:  MOVF   FED,F
0B918:  MOVF   FED,F
0B91A:  MOVFF  00,FEF
0B91E:  MOVFF  01,FEC
0B922:  MOVFF  02,FEC
0B926:  MOVWF  FEC
0B928:  MOVFF  8D2,FE9
0B92C:  MOVFF  8D3,FEA
0B930:  MOVF   xE0,W
0B932:  ADDWF  FEF,W
0B934:  MOVWF  01
0B936:  MOVF   xE1,W
0B938:  ADDWFC FEC,W
0B93A:  MOVWF  03
0B93C:  MOVF   FED,F
0B93E:  MOVFF  01,FEF
0B942:  MOVWF  FEC
0B944:  MOVF   xE0,W
0B946:  SUBWF  xD0,F
0B948:  MOVF   xE1,W
0B94A:  SUBWFB xD1,F
0B94C:  BRA    B550
....................          } 
....................       return (FR_OK); 
0B94E:  MOVLW  00
0B950:  MOVWF  01
0B952:  MOVLB  7
0B954:  BRA    B970
0B956:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B958:  MOVLW  1A
0B95A:  ADDWF  xCC,W
0B95C:  MOVWF  FE9
0B95E:  MOVLW  00
0B960:  ADDWFC xCD,W
0B962:  MOVWF  FEA
0B964:  MOVF   FEF,W
0B966:  IORLW  80
0B968:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B96A:  MOVLW  07
0B96C:  MOVWF  01
0B96E:  MOVLB  7
0B970:  MOVLB  0
0B972:  GOTO   BB6E (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
079FA:  MOVFF  9B3,9C4
079FE:  MOVFF  9B2,9C3
....................       *bw = 0; 
07A02:  MOVLB  9
07A04:  MOVFF  9B6,FE9
07A08:  MOVFF  9B7,FEA
07A0C:  CLRF   FEC
07A0E:  MOVF   FED,F
07A10:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07A12:  CLRF   xC1
07A14:  CLRF   xC0
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07A16:  MOVLB  7
07A18:  MOVF   x12,W
07A1A:  IORWF  x13,W
07A1C:  BNZ   7A24
....................          return (FR_NOT_ENABLED); 
07A1E:  MOVLW  0B
07A20:  MOVWF  01
07A22:  BRA    80C4
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07A24:  MOVLB  0
07A26:  CALL   559E
07A2A:  BTFSC  01.0
07A2C:  BRA    7A3E
07A2E:  MOVLB  7
07A30:  MOVFF  712,FE9
07A34:  MOVFF  713,FEA
07A38:  MOVF   FEF,F
07A3A:  BNZ   7A46
07A3C:  MOVLB  0
....................          return (FR_NOT_READY); 
07A3E:  MOVLW  01
07A40:  MOVWF  01
07A42:  MOVLB  7
07A44:  BRA    80C4
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
07A46:  MOVLW  1A
07A48:  MOVLB  9
07A4A:  ADDWF  xB0,W
07A4C:  MOVWF  FE9
07A4E:  MOVLW  00
07A50:  ADDWFC xB1,W
07A52:  MOVWF  FEA
07A54:  BTFSS  FEF.7
07A56:  BRA    7A62
....................          return (FR_RW_ERROR);         // Check error flag  
07A58:  MOVLW  07
07A5A:  MOVWF  01
07A5C:  MOVLB  7
07A5E:  BRA    80C4
07A60:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
07A62:  MOVLW  1A
07A64:  ADDWF  xB0,W
07A66:  MOVWF  FE9
07A68:  MOVLW  00
07A6A:  ADDWFC xB1,W
07A6C:  MOVWF  FEA
07A6E:  BTFSC  FEF.1
07A70:  BRA    7A7C
....................          return (FR_DENIED);            // Check access mode  
07A72:  MOVLW  05
07A74:  MOVWF  01
07A76:  MOVLB  7
07A78:  BRA    80C4
07A7A:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
07A7C:  MOVLW  04
07A7E:  ADDWF  xB0,W
07A80:  MOVWF  FE9
07A82:  MOVLW  00
07A84:  ADDWFC xB1,W
07A86:  MOVWF  FEA
07A88:  MOVFF  FEF,9C5
07A8C:  MOVFF  FEC,9C6
07A90:  MOVFF  FEC,9C7
07A94:  MOVFF  FEC,9C8
07A98:  MOVF   xB4,W
07A9A:  ADDWF  xC5,F
07A9C:  MOVF   xB5,W
07A9E:  ADDWFC xC6,F
07AA0:  MOVLW  00
07AA2:  ADDWFC xC7,F
07AA4:  ADDWFC xC8,F
07AA6:  MOVLW  04
07AA8:  ADDWF  xB0,W
07AAA:  MOVWF  FE9
07AAC:  MOVLW  00
07AAE:  ADDWFC xB1,W
07AB0:  MOVWF  FEA
07AB2:  MOVFF  FEF,00
07AB6:  MOVFF  FEC,01
07ABA:  MOVFF  FEC,02
07ABE:  MOVFF  FEC,03
07AC2:  MOVF   xC8,W
07AC4:  SUBWF  03,W
07AC6:  BNC   7AE4
07AC8:  BNZ   7AE0
07ACA:  MOVF   xC7,W
07ACC:  SUBWF  02,W
07ACE:  BNC   7AE4
07AD0:  BNZ   7AE0
07AD2:  MOVF   xC6,W
07AD4:  SUBWF  01,W
07AD6:  BNC   7AE4
07AD8:  BNZ   7AE0
07ADA:  MOVF   00,W
07ADC:  SUBWF  xC5,W
07ADE:  BC    7AE4
....................          btw = 0;                  // File size cannot reach 4GB  
07AE0:  CLRF   xB5
07AE2:  CLRF   xB4
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07AE4:  MOVF   xB4,W
07AE6:  IORWF  xB5,W
07AE8:  BTFSC  FD8.2
07AEA:  BRA    7FF8
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07AEC:  MOVFF  9B0,FE9
07AF0:  MOVFF  9B1,FEA
07AF4:  MOVFF  FEF,9C5
07AF8:  MOVFF  FEC,9C6
07AFC:  MOVFF  FEC,9C7
07B00:  MOVFF  FEC,9C8
07B04:  MOVLW  01
07B06:  ANDWF  xC6,F
07B08:  CLRF   xC7
07B0A:  CLRF   xC8
07B0C:  MOVF   xC5,F
07B0E:  BTFSS  FD8.2
07B10:  BRA    7E92
07B12:  MOVF   xC6,F
07B14:  BTFSS  FD8.2
07B16:  BRA    7E92
07B18:  MOVF   xC7,F
07B1A:  BTFSS  FD8.2
07B1C:  BRA    7E92
07B1E:  MOVF   xC8,F
07B20:  BTFSS  FD8.2
07B22:  BRA    7E92
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07B24:  MOVLW  1B
07B26:  ADDWF  xB0,W
07B28:  MOVWF  FE9
07B2A:  MOVLW  00
07B2C:  ADDWFC xB1,W
07B2E:  MOVWF  FEA
07B30:  DECF   FEF,F
07B32:  BZ    7B6A
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07B34:  MOVLW  10
07B36:  ADDWF  xB0,W
07B38:  MOVWF  FE9
07B3A:  MOVLW  00
07B3C:  ADDWFC xB1,W
07B3E:  MOVWF  FEA
07B40:  MOVFF  FEF,9C5
07B44:  MOVFF  FEC,9C6
07B48:  MOVFF  FEC,9C7
07B4C:  MOVFF  FEC,9C8
07B50:  MOVLW  01
07B52:  ADDWF  xC5,W
07B54:  MOVWF  xBC
07B56:  MOVLW  00
07B58:  ADDWFC xC6,W
07B5A:  MOVWF  xBD
07B5C:  MOVLW  00
07B5E:  ADDWFC xC7,W
07B60:  MOVWF  xBE
07B62:  MOVLW  00
07B64:  ADDWFC xC8,W
07B66:  MOVWF  xBF
....................                }  
07B68:  BRA    7D00
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07B6A:  MOVFF  9B0,FE9
07B6E:  MOVFF  9B1,FEA
07B72:  MOVFF  FEF,9C5
07B76:  MOVFF  FEC,9C6
07B7A:  MOVFF  FEC,9C7
07B7E:  MOVFF  FEC,9C8
07B82:  MOVF   xC5,F
07B84:  BNZ   7C0A
07B86:  MOVF   xC6,F
07B88:  BNZ   7C0A
07B8A:  MOVF   xC7,F
07B8C:  BNZ   7C0A
07B8E:  MOVF   xC8,F
07B90:  BNZ   7C0A
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07B92:  MOVLW  08
07B94:  ADDWF  xB0,W
07B96:  MOVWF  FE9
07B98:  MOVLW  00
07B9A:  ADDWFC xB1,W
07B9C:  MOVWF  FEA
07B9E:  MOVFF  FEF,9B8
07BA2:  MOVFF  FEC,9B9
07BA6:  MOVFF  FEC,9BA
07BAA:  MOVFF  FEC,9BB
....................                   if (clust == 0)            // No cluster is created  
07BAE:  MOVF   xB8,F
07BB0:  BNZ   7C08
07BB2:  MOVF   xB9,F
07BB4:  BNZ   7C08
07BB6:  MOVF   xBA,F
07BB8:  BNZ   7C08
07BBA:  MOVF   xBB,F
07BBC:  BNZ   7C08
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07BBE:  MOVLW  08
07BC0:  ADDWF  xB0,W
07BC2:  MOVWF  01
07BC4:  MOVLW  00
07BC6:  ADDWFC xB1,W
07BC8:  MOVWF  03
07BCA:  MOVFF  01,9C5
07BCE:  MOVWF  xC6
07BD0:  CLRF   xEB
07BD2:  CLRF   xEA
07BD4:  CLRF   xE9
07BD6:  CLRF   xE8
07BD8:  MOVLB  0
07BDA:  CALL   6964
07BDE:  MOVFF  03,9BB
07BE2:  MOVFF  02,9BA
07BE6:  MOVFF  01,9B9
07BEA:  MOVFF  00,9B8
07BEE:  MOVFF  9C6,FEA
07BF2:  MOVFF  9C5,FE9
07BF6:  MOVFF  9B8,FEF
07BFA:  MOVFF  9B9,FEC
07BFE:  MOVFF  9BA,FEC
07C02:  MOVFF  9BB,FEC
07C06:  MOVLB  9
....................                   } 
07C08:  BRA    7C3E
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07C0A:  MOVLW  0C
07C0C:  ADDWF  xB0,W
07C0E:  MOVWF  FE9
07C10:  MOVLW  00
07C12:  ADDWFC xB1,W
07C14:  MOVWF  FEA
07C16:  MOVFF  FEF,9E8
07C1A:  MOVFF  FEC,9E9
07C1E:  MOVFF  FEC,9EA
07C22:  MOVFF  FEC,9EB
07C26:  MOVLB  0
07C28:  CALL   6964
07C2C:  MOVFF  03,9BB
07C30:  MOVFF  02,9BA
07C34:  MOVFF  01,9B9
07C38:  MOVFF  00,9B8
07C3C:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07C3E:  MOVF   xBB,F
07C40:  BNZ   7C50
07C42:  MOVF   xBA,F
07C44:  BNZ   7C50
07C46:  MOVF   xB9,F
07C48:  BNZ   7C50
07C4A:  MOVF   xB8,W
07C4C:  SUBLW  01
07C4E:  BC    7C8E
07C50:  MOVLW  0C
07C52:  MOVLB  7
07C54:  ADDWF  x12,W
07C56:  MOVWF  FE9
07C58:  MOVLW  00
07C5A:  ADDWFC x13,W
07C5C:  MOVWF  FEA
07C5E:  MOVFF  FEF,00
07C62:  MOVFF  FEC,01
07C66:  MOVFF  FEC,02
07C6A:  MOVFF  FEC,03
07C6E:  MOVF   03,W
07C70:  MOVLB  9
07C72:  SUBWF  xBB,W
07C74:  BNC   7C90
07C76:  BNZ   7C8E
07C78:  MOVF   02,W
07C7A:  SUBWF  xBA,W
07C7C:  BNC   7C90
07C7E:  BNZ   7C8E
07C80:  MOVF   01,W
07C82:  SUBWF  xB9,W
07C84:  BNC   7C90
07C86:  BNZ   7C8E
07C88:  MOVF   00,W
07C8A:  SUBWF  xB8,W
07C8C:  BNC   7C90
....................                   break; 
07C8E:  BRA    7FF8
....................                fp->curr_clust = clust;            // Current cluster  
07C90:  MOVLW  0C
07C92:  ADDWF  xB0,W
07C94:  MOVWF  FE9
07C96:  MOVLW  00
07C98:  ADDWFC xB1,W
07C9A:  MOVWF  FEA
07C9C:  MOVFF  9B8,FEF
07CA0:  MOVFF  9B9,FEC
07CA4:  MOVFF  9BA,FEC
07CA8:  MOVFF  9BB,FEC
....................                sect = clust2sect(clust);         // Current sector  
07CAC:  MOVFF  9BB,9F2
07CB0:  MOVFF  9BA,9F1
07CB4:  MOVFF  9B9,9F0
07CB8:  MOVFF  9B8,9EF
07CBC:  MOVLB  0
07CBE:  CALL   560E
07CC2:  MOVFF  03,9BF
07CC6:  MOVFF  02,9BE
07CCA:  MOVFF  01,9BD
07CCE:  MOVFF  00,9BC
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07CD2:  MOVLW  1B
07CD4:  MOVLB  9
07CD6:  ADDWF  xB0,W
07CD8:  MOVWF  01
07CDA:  MOVLW  00
07CDC:  ADDWFC xB1,W
07CDE:  MOVWF  03
07CE0:  MOVLW  02
07CE2:  MOVLB  7
07CE4:  ADDWF  x12,W
07CE6:  MOVWF  FE9
07CE8:  MOVLW  00
07CEA:  ADDWFC x13,W
07CEC:  MOVWF  FEA
07CEE:  MOVFF  FEF,9C7
07CF2:  MOVLB  9
07CF4:  MOVFF  03,FEA
07CF8:  MOVFF  01,FE9
07CFC:  MOVFF  9C7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07D00:  MOVLW  10
07D02:  ADDWF  xB0,W
07D04:  MOVWF  FE9
07D06:  MOVLW  00
07D08:  ADDWFC xB1,W
07D0A:  MOVWF  FEA
07D0C:  MOVFF  9BC,FEF
07D10:  MOVFF  9BD,FEC
07D14:  MOVFF  9BE,FEC
07D18:  MOVFF  9BF,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07D1C:  BCF    FD8.0
07D1E:  RRCF   xB5,W
07D20:  MOVWF  xC2
....................             if (cc)  
07D22:  MOVF   xC2,F
07D24:  BZ    7DE0
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07D26:  MOVLW  1B
07D28:  ADDWF  xB0,W
07D2A:  MOVWF  FE9
07D2C:  MOVLW  00
07D2E:  ADDWFC xB1,W
07D30:  MOVWF  FEA
07D32:  MOVF   FEF,W
07D34:  SUBWF  xC2,W
07D36:  BZ    7D4A
07D38:  BNC   7D4A
....................                   cc = fp->sect_clust; 
07D3A:  MOVLW  1B
07D3C:  ADDWF  xB0,W
07D3E:  MOVWF  FE9
07D40:  MOVLW  00
07D42:  ADDWFC xB1,W
07D44:  MOVWF  FEA
07D46:  MOVFF  FEF,9C2
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07D4A:  MOVFF  9C4,A21
07D4E:  MOVFF  9C3,A20
07D52:  MOVFF  9BF,A25
07D56:  MOVFF  9BE,A24
07D5A:  MOVFF  9BD,A23
07D5E:  MOVFF  9BC,A22
07D62:  MOVFF  9C2,A26
07D66:  MOVLB  0
07D68:  CALL   593E
07D6C:  MOVF   01,F
07D6E:  BZ    7D72
....................                   goto fw_error; 
07D70:  BRA    80AA
....................                fp->sect_clust -= cc - 1; 
07D72:  MOVLW  1B
07D74:  MOVLB  9
07D76:  ADDWF  xB0,W
07D78:  MOVWF  FE9
07D7A:  MOVLW  00
07D7C:  ADDWFC xB1,W
07D7E:  MOVWF  FEA
07D80:  MOVLW  01
07D82:  SUBWF  xC2,W
07D84:  SUBWF  FEF,W
07D86:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07D88:  MOVLW  10
07D8A:  ADDWF  xB0,W
07D8C:  MOVWF  FE9
07D8E:  MOVLW  00
07D90:  ADDWFC xB1,W
07D92:  MOVWF  FEA
07D94:  MOVLW  01
07D96:  SUBWF  xC2,W
07D98:  ADDWF  FEF,W
07D9A:  MOVWF  00
07D9C:  MOVLW  00
07D9E:  ADDWFC FEC,W
07DA0:  MOVWF  01
07DA2:  MOVLW  00
07DA4:  ADDWFC FEC,W
07DA6:  MOVWF  02
07DA8:  MOVLW  00
07DAA:  ADDWFC FEC,W
07DAC:  MOVF   FED,F
07DAE:  MOVF   FED,F
07DB0:  MOVF   FED,F
07DB2:  MOVFF  00,FEF
07DB6:  MOVFF  01,FEC
07DBA:  MOVFF  02,FEC
07DBE:  MOVWF  FEC
....................                wcnt = cc * 512; 
07DC0:  MOVLB  A
07DC2:  CLRF   x11
07DC4:  MOVFF  9C2,A10
07DC8:  MOVLW  02
07DCA:  MOVWF  x13
07DCC:  CLRF   x12
07DCE:  MOVLB  0
07DD0:  CALL   5C98
07DD4:  MOVFF  02,9C1
07DD8:  MOVFF  01,9C0
....................                continue; 
07DDC:  BRA    7F94
07DDE:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07DE0:  MOVFF  9B0,FE9
07DE4:  MOVFF  9B1,FEA
07DE8:  MOVFF  FEF,9C5
07DEC:  MOVFF  FEC,9C6
07DF0:  MOVFF  FEC,9C7
07DF4:  MOVFF  FEC,9C8
07DF8:  MOVLW  04
07DFA:  ADDWF  xB0,W
07DFC:  MOVWF  FE9
07DFE:  MOVLW  00
07E00:  ADDWFC xB1,W
07E02:  MOVWF  FEA
07E04:  MOVFF  FEF,00
07E08:  MOVFF  FEC,01
07E0C:  MOVFF  FEC,02
07E10:  MOVFF  FEC,03
07E14:  MOVF   03,W
07E16:  SUBWF  xC8,W
07E18:  BNC   7E92
07E1A:  BNZ   7E32
07E1C:  MOVF   02,W
07E1E:  SUBWF  xC7,W
07E20:  BNC   7E92
07E22:  BNZ   7E32
07E24:  MOVF   01,W
07E26:  SUBWF  xC6,W
07E28:  BNC   7E92
07E2A:  BNZ   7E32
07E2C:  MOVF   00,W
07E2E:  SUBWF  xC5,W
07E30:  BNC   7E92
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07E32:  MOVLB  A
07E34:  CLRF   x17
07E36:  CLRF   x16
07E38:  CLRF   x15
07E3A:  CLRF   x14
07E3C:  MOVLB  0
07E3E:  CALL   5A82
07E42:  MOVF   01,F
07E44:  BNZ   7E48
....................                   goto fw_error; 
07E46:  BRA    80AA
....................                fs->winsect = fp->curr_sect; 
07E48:  MOVLW  20
07E4A:  MOVLB  7
07E4C:  ADDWF  x12,W
07E4E:  MOVWF  01
07E50:  MOVLW  00
07E52:  ADDWFC x13,W
07E54:  MOVWF  03
07E56:  MOVFF  01,9C5
07E5A:  MOVLB  9
07E5C:  MOVWF  xC6
07E5E:  MOVLW  10
07E60:  ADDWF  xB0,W
07E62:  MOVWF  FE9
07E64:  MOVLW  00
07E66:  ADDWFC xB1,W
07E68:  MOVWF  FEA
07E6A:  MOVFF  FEF,00
07E6E:  MOVFF  FEC,01
07E72:  MOVFF  FEC,02
07E76:  MOVFF  FEC,03
07E7A:  MOVFF  9C6,FEA
07E7E:  MOVFF  9C5,FE9
07E82:  MOVFF  00,FEF
07E86:  MOVFF  01,FEC
07E8A:  MOVFF  02,FEC
07E8E:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07E92:  MOVLW  10
07E94:  ADDWF  xB0,W
07E96:  MOVWF  FE9
07E98:  MOVLW  00
07E9A:  ADDWFC xB1,W
07E9C:  MOVWF  FEA
07E9E:  MOVFF  FEF,A14
07EA2:  MOVFF  FEC,A15
07EA6:  MOVFF  FEC,A16
07EAA:  MOVFF  FEC,A17
07EAE:  MOVLB  0
07EB0:  CALL   5A82
07EB4:  MOVF   01,F
07EB6:  BNZ   7EBA
....................             goto fw_error;               // Move sector window 
07EB8:  BRA    80AA
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07EBA:  MOVLB  9
07EBC:  MOVFF  9B0,FE9
07EC0:  MOVFF  9B1,FEA
07EC4:  MOVFF  FEF,9C5
07EC8:  MOVFF  FEC,9C6
07ECC:  MOVFF  FEC,9C7
07ED0:  MOVFF  FEC,9C8
07ED4:  MOVF   xC6,W
07ED6:  ANDLW  01
07ED8:  MOVWF  01
07EDA:  MOVLW  00
07EDC:  BSF    FD8.0
07EDE:  SUBFWB xC5,W
07EE0:  MOVWF  xC0
07EE2:  MOVLW  02
07EE4:  SUBFWB 01,W
07EE6:  MOVWF  xC1
....................          if (wcnt > btw) 
07EE8:  MOVF   xB5,W
07EEA:  SUBWF  xC1,W
07EEC:  BNC   7EFE
07EEE:  BNZ   7EF6
07EF0:  MOVF   xC0,W
07EF2:  SUBWF  xB4,W
07EF4:  BC    7EFE
....................             wcnt = btw; 
07EF6:  MOVFF  9B5,9C1
07EFA:  MOVFF  9B4,9C0
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07EFE:  MOVFF  9B0,FE9
07F02:  MOVFF  9B1,FEA
07F06:  MOVFF  FEF,9C5
07F0A:  MOVFF  FEC,9C6
07F0E:  MOVFF  FEC,9C7
07F12:  MOVFF  FEC,9C8
07F16:  MOVLW  01
07F18:  ANDWF  xC6,F
07F1A:  CLRF   xC7
07F1C:  CLRF   xC8
07F1E:  MOVLW  24
07F20:  ADDWF  xC5,W
07F22:  MOVWF  00
07F24:  MOVLW  00
07F26:  ADDWFC xC6,W
07F28:  MOVWF  01
07F2A:  MOVLW  00
07F2C:  ADDWFC xC7,W
07F2E:  MOVWF  02
07F30:  MOVLW  00
07F32:  ADDWFC xC8,W
07F34:  MOVWF  03
07F36:  MOVFF  01,03
07F3A:  MOVF   00,W
07F3C:  MOVLB  7
07F3E:  ADDWF  x12,W
07F40:  MOVWF  01
07F42:  MOVF   x13,W
07F44:  ADDWFC 03,F
07F46:  MOVFF  01,9C9
07F4A:  MOVLB  9
07F4C:  MOVFF  03,9CA
07F50:  MOVFF  03,FEA
07F54:  MOVFF  01,FE9
07F58:  MOVFF  9C4,FE2
07F5C:  MOVFF  9C3,FE1
07F60:  MOVFF  9C1,02
07F64:  MOVFF  9C0,01
07F68:  MOVF   01,F
07F6A:  BZ    7F70
07F6C:  INCF   02,F
07F6E:  BRA    7F74
07F70:  MOVF   02,F
07F72:  BZ    7F80
07F74:  MOVFF  FE6,FEE
07F78:  DECFSZ 01,F
07F7A:  BRA    7F74
07F7C:  DECFSZ 02,F
07F7E:  BRA    7F74
....................          fs->winflag = 1; 
07F80:  MOVLW  06
07F82:  MOVLB  7
07F84:  ADDWF  x12,W
07F86:  MOVWF  FE9
07F88:  MOVLW  00
07F8A:  ADDWFC x13,W
07F8C:  MOVWF  FEA
07F8E:  MOVLW  01
07F90:  MOVWF  FEF
07F92:  MOVLB  0
07F94:  MOVLB  9
07F96:  MOVF   xC0,W
07F98:  ADDWF  xC3,F
07F9A:  MOVF   xC1,W
07F9C:  ADDWFC xC4,F
07F9E:  MOVFF  9B0,FE9
07FA2:  MOVFF  9B1,FEA
07FA6:  MOVF   xC0,W
07FA8:  ADDWF  FEF,W
07FAA:  MOVWF  00
07FAC:  MOVF   xC1,W
07FAE:  ADDWFC FEC,W
07FB0:  MOVWF  01
07FB2:  MOVLW  00
07FB4:  ADDWFC FEC,W
07FB6:  MOVWF  02
07FB8:  MOVLW  00
07FBA:  ADDWFC FEC,W
07FBC:  MOVWF  03
07FBE:  MOVF   FED,F
07FC0:  MOVF   FED,F
07FC2:  MOVF   FED,F
07FC4:  MOVFF  00,FEF
07FC8:  MOVFF  01,FEC
07FCC:  MOVFF  02,FEC
07FD0:  MOVWF  FEC
07FD2:  MOVFF  9B6,FE9
07FD6:  MOVFF  9B7,FEA
07FDA:  MOVF   xC0,W
07FDC:  ADDWF  FEF,W
07FDE:  MOVWF  01
07FE0:  MOVF   xC1,W
07FE2:  ADDWFC FEC,W
07FE4:  MOVWF  03
07FE6:  MOVF   FED,F
07FE8:  MOVFF  01,FEF
07FEC:  MOVWF  FEC
07FEE:  MOVF   xC0,W
07FF0:  SUBWF  xB4,F
07FF2:  MOVF   xC1,W
07FF4:  SUBWFB xB5,F
07FF6:  BRA    7AE4
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
07FF8:  MOVFF  9B0,FE9
07FFC:  MOVFF  9B1,FEA
08000:  MOVFF  FEF,9C5
08004:  MOVFF  FEC,9C6
08008:  MOVFF  FEC,9C7
0800C:  MOVFF  FEC,9C8
08010:  MOVLW  04
08012:  ADDWF  xB0,W
08014:  MOVWF  FE9
08016:  MOVLW  00
08018:  ADDWFC xB1,W
0801A:  MOVWF  FEA
0801C:  MOVFF  FEF,00
08020:  MOVFF  FEC,01
08024:  MOVFF  FEC,02
08028:  MOVFF  FEC,03
0802C:  MOVF   03,W
0802E:  SUBWF  xC8,W
08030:  BNC   808E
08032:  BNZ   804A
08034:  MOVF   02,W
08036:  SUBWF  xC7,W
08038:  BNC   808E
0803A:  BNZ   804A
0803C:  MOVF   01,W
0803E:  SUBWF  xC6,W
08040:  BNC   808E
08042:  BNZ   804A
08044:  MOVF   xC5,W
08046:  SUBWF  00,W
08048:  BC    808E
....................          fp->fsize = fp->fptr;      // Update file size if needed  
0804A:  MOVLW  04
0804C:  ADDWF  xB0,W
0804E:  MOVWF  01
08050:  MOVLW  00
08052:  ADDWFC xB1,W
08054:  MOVWF  03
08056:  MOVFF  01,9C5
0805A:  MOVFF  03,9C6
0805E:  MOVFF  9B0,FE9
08062:  MOVFF  9B1,FEA
08066:  MOVFF  FEF,00
0806A:  MOVFF  FEC,01
0806E:  MOVFF  FEC,02
08072:  MOVFF  FEC,03
08076:  MOVFF  9C6,FEA
0807A:  MOVFF  9C5,FE9
0807E:  MOVFF  00,FEF
08082:  MOVFF  01,FEC
08086:  MOVFF  02,FEC
0808A:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
0808E:  MOVLW  1A
08090:  ADDWF  xB0,W
08092:  MOVWF  FE9
08094:  MOVLW  00
08096:  ADDWFC xB1,W
08098:  MOVWF  FEA
0809A:  MOVF   FEF,W
0809C:  IORLW  20
0809E:  MOVWF  FEF
....................       return (FR_OK); 
080A0:  MOVLW  00
080A2:  MOVWF  01
080A4:  MOVLB  7
080A6:  BRA    80C4
080A8:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
080AA:  MOVLW  1A
080AC:  MOVLB  9
080AE:  ADDWF  xB0,W
080B0:  MOVWF  FE9
080B2:  MOVLW  00
080B4:  ADDWFC xB1,W
080B6:  MOVWF  FEA
080B8:  MOVF   FEF,W
080BA:  IORLW  80
080BC:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
080BE:  MOVLW  07
080C0:  MOVWF  01
080C2:  MOVLB  7
080C4:  MOVLB  0
080C6:  GOTO   846E (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
075A0:  MOVLB  7
075A2:  MOVF   x12,W
075A4:  IORWF  x13,W
075A6:  BNZ   75AE
....................          return (FR_NOT_ENABLED); 
075A8:  MOVLW  0B
075AA:  MOVWF  01
075AC:  BRA    7902
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
075AE:  MOVLB  0
075B0:  CALL   559E
075B4:  BTFSC  01.0
075B6:  BRA    75C8
075B8:  MOVLB  7
075BA:  MOVFF  712,FE9
075BE:  MOVFF  713,FEA
075C2:  MOVF   FEF,F
075C4:  BNZ   75D0
075C6:  MOVLB  0
....................          return (FR_NOT_READY); 
075C8:  MOVLW  01
075CA:  MOVWF  01
075CC:  MOVLB  7
075CE:  BRA    7902
....................     
....................       if (fp->flag & FA__ERROR) 
075D0:  MOVLW  1A
075D2:  MOVLB  9
075D4:  ADDWF  xB0,W
075D6:  MOVWF  FE9
075D8:  MOVLW  00
075DA:  ADDWFC xB1,W
075DC:  MOVWF  FEA
075DE:  BTFSS  FEF.7
075E0:  BRA    75EC
....................          return (FR_RW_ERROR); 
075E2:  MOVLW  07
075E4:  MOVWF  01
075E6:  MOVLB  7
075E8:  BRA    7902
075EA:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
075EC:  MOVLW  04
075EE:  ADDWF  xB0,W
075F0:  MOVWF  FE9
075F2:  MOVLW  00
075F4:  ADDWFC xB1,W
075F6:  MOVWF  FEA
075F8:  MOVFF  FEF,00
075FC:  MOVFF  FEC,01
07600:  MOVFF  FEC,02
07604:  MOVFF  FEC,03
07608:  MOVF   03,W
0760A:  SUBWF  xB5,W
0760C:  BNC   7642
0760E:  BNZ   7626
07610:  MOVF   02,W
07612:  SUBWF  xB4,W
07614:  BNC   7642
07616:  BNZ   7626
07618:  MOVF   01,W
0761A:  SUBWF  xB3,W
0761C:  BNC   7642
0761E:  BNZ   7626
07620:  MOVF   xB2,W
07622:  SUBWF  00,W
07624:  BC    7642
....................          ofs = fp->fsize;               // Clip offset by file size  
07626:  MOVLW  04
07628:  ADDWF  xB0,W
0762A:  MOVWF  FE9
0762C:  MOVLW  00
0762E:  ADDWFC xB1,W
07630:  MOVWF  FEA
07632:  MOVFF  FEF,9B2
07636:  MOVFF  FEC,9B3
0763A:  MOVFF  FEC,9B4
0763E:  MOVFF  FEC,9B5
....................       fp->fptr = ofs;  
07642:  MOVFF  9B0,FE9
07646:  MOVF   xB1,W
07648:  MOVWF  FEA
0764A:  MOVFF  9B2,FEF
0764E:  MOVFF  9B3,FEC
07652:  MOVFF  9B4,FEC
07656:  MOVFF  9B5,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
0765A:  MOVLW  1B
0765C:  ADDWF  xB0,W
0765E:  MOVWF  FE9
07660:  MOVLW  00
07662:  ADDWFC xB1,W
07664:  MOVWF  FEA
07666:  MOVLW  01
07668:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
0766A:  MOVF   xB2,F
0766C:  BNZ   767C
0766E:  MOVF   xB3,F
07670:  BNZ   767C
07672:  MOVF   xB4,F
07674:  BNZ   767C
07676:  MOVF   xB5,F
07678:  BTFSC  FD8.2
0767A:  BRA    78E0
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
0767C:  MOVLW  01
0767E:  SUBWF  xB2,W
07680:  MOVLW  00
07682:  SUBWFB xB3,W
07684:  MOVWF  xBC
07686:  MOVLW  00
07688:  SUBWFB xB4,W
0768A:  MOVWF  xBD
0768C:  MOVLW  00
0768E:  SUBWFB xB5,W
07690:  MOVWF  xBE
07692:  BCF    FD8.0
07694:  CLRF   xB5
07696:  RRCF   xBE,W
07698:  MOVWF  xB4
0769A:  RRCF   xBD,W
0769C:  MOVWF  xB3
0769E:  RRCF   xBC,W
076A0:  MOVWF  xB2
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
076A2:  MOVLW  02
076A4:  MOVLB  7
076A6:  ADDWF  x12,W
076A8:  MOVWF  FE9
076AA:  MOVLW  00
076AC:  ADDWFC x13,W
076AE:  MOVWF  FEA
076B0:  MOVFF  FEF,9BA
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
076B4:  MOVLW  1B
076B6:  MOVLB  9
076B8:  ADDWF  xB0,W
076BA:  MOVWF  01
076BC:  MOVLW  00
076BE:  ADDWFC xB1,W
076C0:  MOVWF  03
076C2:  MOVFF  01,9BB
076C6:  MOVWF  xBC
076C8:  MOVFF  FEA,9BE
076CC:  MOVFF  FE9,9BD
076D0:  BSF    FD8.1
076D2:  MOVLW  09
076D4:  MOVWF  FEA
076D6:  MOVLW  BF
076D8:  MOVWF  FE9
076DA:  CLRF   1B
076DC:  BTFSC  FF2.7
076DE:  BSF    1B.7
076E0:  BCF    FF2.7
076E2:  MOVFF  9B5,A4F
076E6:  MOVFF  9B4,A4E
076EA:  MOVFF  9B3,A4D
076EE:  MOVFF  9B2,A4C
076F2:  MOVLB  A
076F4:  CLRF   x53
076F6:  CLRF   x52
076F8:  CLRF   x51
076FA:  MOVFF  9BA,A50
076FE:  MOVLB  0
07700:  CALL   104E
07704:  BTFSC  1B.7
07706:  BSF    FF2.7
07708:  MOVFF  9BF,00
0770C:  MOVFF  9C0,01
07710:  MOVFF  9C1,02
07714:  MOVFF  9C2,03
07718:  MOVFF  9BE,FEA
0771C:  MOVFF  9BD,FE9
07720:  MOVF   00,W
07722:  MOVLB  9
07724:  SUBWF  xBA,W
07726:  MOVWF  00
07728:  MOVLW  00
0772A:  SUBFWB 01,F
0772C:  SUBFWB 02,F
0772E:  SUBFWB 03,F
07730:  MOVFF  9BC,FEA
07734:  MOVFF  9BB,FE9
07738:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
0773C:  BCF    FD8.1
0773E:  CLRF   1B
07740:  BTFSC  FF2.7
07742:  BSF    1B.7
07744:  BCF    FF2.7
07746:  MOVFF  9B5,A4F
0774A:  MOVFF  9B4,A4E
0774E:  MOVFF  9B3,A4D
07752:  MOVFF  9B2,A4C
07756:  MOVLB  A
07758:  CLRF   x53
0775A:  CLRF   x52
0775C:  CLRF   x51
0775E:  MOVFF  9BA,A50
07762:  MOVLB  0
07764:  CALL   104E
07768:  BTFSC  1B.7
0776A:  BSF    FF2.7
0776C:  MOVFF  03,9B5
07770:  MOVFF  02,9B4
07774:  MOVFF  01,9B3
07778:  MOVFF  00,9B2
....................          clust = fp->org_clust;            // Seek to current cluster  
0777C:  MOVLW  08
0777E:  MOVLB  9
07780:  ADDWF  xB0,W
07782:  MOVWF  FE9
07784:  MOVLW  00
07786:  ADDWFC xB1,W
07788:  MOVWF  FEA
0778A:  MOVFF  FEF,9B6
0778E:  MOVFF  FEC,9B7
07792:  MOVFF  FEC,9B8
07796:  MOVFF  FEC,9B9
....................     
....................          while (ofs--) 
0779A:  MOVFF  9B5,03
0779E:  MOVFF  9B4,02
077A2:  MOVFF  9B3,01
077A6:  MOVFF  9B2,00
077AA:  MOVLW  FF
077AC:  ADDWF  xB2,F
077AE:  BTFSS  FD8.0
077B0:  ADDWF  xB3,F
077B2:  BTFSS  FD8.0
077B4:  ADDWF  xB4,F
077B6:  BTFSS  FD8.0
077B8:  ADDWF  xB5,F
077BA:  MOVF   00,F
077BC:  BNZ   77CA
077BE:  MOVF   01,F
077C0:  BNZ   77CA
077C2:  MOVF   02,F
077C4:  BNZ   77CA
077C6:  MOVF   03,F
077C8:  BZ    77F4
....................             clust = get_cluster(clust); 
077CA:  MOVFF  9B9,9FF
077CE:  MOVFF  9B8,9FE
077D2:  MOVFF  9B7,9FD
077D6:  MOVFF  9B6,9FC
077DA:  MOVLB  0
077DC:  CALL   5CBA
077E0:  MOVFF  03,9B9
077E4:  MOVFF  02,9B8
077E8:  MOVFF  01,9B7
077EC:  MOVFF  00,9B6
077F0:  MOVLB  9
077F2:  BRA    779A
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
077F4:  MOVF   xB9,F
077F6:  BNZ   7806
077F8:  MOVF   xB8,F
077FA:  BNZ   7806
077FC:  MOVF   xB7,F
077FE:  BNZ   7806
07800:  MOVF   xB6,W
07802:  SUBLW  01
07804:  BC    7844
07806:  MOVLW  0C
07808:  MOVLB  7
0780A:  ADDWF  x12,W
0780C:  MOVWF  FE9
0780E:  MOVLW  00
07810:  ADDWFC x13,W
07812:  MOVWF  FEA
07814:  MOVFF  FEF,00
07818:  MOVFF  FEC,01
0781C:  MOVFF  FEC,02
07820:  MOVFF  FEC,03
07824:  MOVF   03,W
07826:  MOVLB  9
07828:  SUBWF  xB9,W
0782A:  BNC   7846
0782C:  BNZ   7844
0782E:  MOVF   02,W
07830:  SUBWF  xB8,W
07832:  BNC   7846
07834:  BNZ   7844
07836:  MOVF   01,W
07838:  SUBWF  xB7,W
0783A:  BNC   7846
0783C:  BNZ   7844
0783E:  MOVF   00,W
07840:  SUBWF  xB6,W
07842:  BNC   7846
....................             goto fk_error; 
07844:  BRA    78EA
....................     
....................          fp->curr_clust = clust; 
07846:  MOVLW  0C
07848:  ADDWF  xB0,W
0784A:  MOVWF  FE9
0784C:  MOVLW  00
0784E:  ADDWFC xB1,W
07850:  MOVWF  FEA
07852:  MOVFF  9B6,FEF
07856:  MOVFF  9B7,FEC
0785A:  MOVFF  9B8,FEC
0785E:  MOVFF  9B9,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
07862:  MOVLW  10
07864:  ADDWF  xB0,W
07866:  MOVWF  01
07868:  MOVLW  00
0786A:  ADDWFC xB1,W
0786C:  MOVWF  03
0786E:  MOVFF  01,9BB
07872:  MOVWF  xBC
07874:  MOVFF  9B9,9F2
07878:  MOVFF  9B8,9F1
0787C:  MOVFF  9B7,9F0
07880:  MOVFF  9B6,9EF
07884:  MOVLB  0
07886:  CALL   560E
0788A:  MOVFF  03,9C0
0788E:  MOVFF  02,9BF
07892:  MOVFF  01,9BE
07896:  MOVFF  00,9BD
0789A:  MOVLB  9
0789C:  MOVF   xBA,W
0789E:  ADDWF  xBD,F
078A0:  MOVLW  00
078A2:  ADDWFC xBE,F
078A4:  ADDWFC xBF,F
078A6:  ADDWFC xC0,F
078A8:  MOVLW  1B
078AA:  ADDWF  xB0,W
078AC:  MOVWF  FE9
078AE:  MOVLW  00
078B0:  ADDWFC xB1,W
078B2:  MOVWF  FEA
078B4:  MOVF   FEF,W
078B6:  SUBWF  xBD,W
078B8:  MOVWF  00
078BA:  MOVLW  00
078BC:  SUBWFB xBE,W
078BE:  MOVWF  01
078C0:  MOVLW  00
078C2:  SUBWFB xBF,W
078C4:  MOVWF  02
078C6:  MOVLW  00
078C8:  SUBWFB xC0,W
078CA:  MOVFF  9BC,FEA
078CE:  MOVFF  9BB,FE9
078D2:  MOVFF  00,FEF
078D6:  MOVFF  01,FEC
078DA:  MOVFF  02,FEC
078DE:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
078E0:  MOVLW  00
078E2:  MOVWF  01
078E4:  MOVLB  7
078E6:  BRA    7902
078E8:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
078EA:  MOVLW  1A
078EC:  ADDWF  xB0,W
078EE:  MOVWF  FE9
078F0:  MOVLW  00
078F2:  ADDWFC xB1,W
078F4:  MOVWF  FEA
078F6:  MOVF   FEF,W
078F8:  IORLW  80
078FA:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
078FC:  MOVLW  07
078FE:  MOVWF  01
07900:  MOVLB  7
07902:  MOVLB  0
07904:  GOTO   8386 (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
080CA:  MOVLB  7
080CC:  MOVF   x12,W
080CE:  IORWF  x13,W
080D0:  BNZ   80D8
....................       return (FR_NOT_ENABLED); 
080D2:  MOVLW  0B
080D4:  MOVWF  01
080D6:  BRA    82A6
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
080D8:  MOVLB  0
080DA:  CALL   559E
080DE:  BTFSC  01.0
080E0:  BRA    80F2
080E2:  MOVLB  7
080E4:  MOVFF  712,FE9
080E8:  MOVFF  713,FEA
080EC:  MOVF   FEF,F
080EE:  BNZ   80FA
080F0:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
080F2:  MOVLW  09
080F4:  MOVWF  01
080F6:  MOVLB  7
080F8:  BRA    82A6
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
080FA:  MOVLW  1A
080FC:  MOVLB  9
080FE:  ADDWF  xB3,W
08100:  MOVWF  FE9
08102:  MOVLW  00
08104:  ADDWFC xB4,W
08106:  MOVWF  FEA
08108:  BTFSS  FEF.5
0810A:  BRA    8282
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
0810C:  MOVLW  14
0810E:  ADDWF  xB3,W
08110:  MOVWF  FE9
08112:  MOVLW  00
08114:  ADDWFC xB4,W
08116:  MOVWF  FEA
08118:  MOVFF  FEF,A14
0811C:  MOVFF  FEC,A15
08120:  MOVFF  FEC,A16
08124:  MOVFF  FEC,A17
08128:  MOVLB  0
0812A:  CALL   5A82
0812E:  MOVF   01,F
08130:  BNZ   813C
....................          return (FR_RW_ERROR); 
08132:  MOVLW  07
08134:  MOVWF  01
08136:  MOVLB  7
08138:  BRA    82A6
0813A:  MOVLB  0
....................       ptr = fp->dir_ptr; 
0813C:  MOVLW  18
0813E:  MOVLB  9
08140:  ADDWF  xB3,W
08142:  MOVWF  FE9
08144:  MOVLW  00
08146:  ADDWFC xB4,W
08148:  MOVWF  FEA
0814A:  MOVFF  FEC,9B6
0814E:  MOVF   FED,F
08150:  MOVFF  FEF,9B5
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
08154:  MOVLW  0B
08156:  ADDWF  xB5,W
08158:  MOVWF  01
0815A:  MOVLW  00
0815C:  ADDWFC xB6,W
0815E:  MOVFF  01,FE9
08162:  MOVWF  FEA
08164:  MOVF   FEF,W
08166:  IORLW  20
08168:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
0816A:  MOVLW  1C
0816C:  ADDWF  xB5,W
0816E:  MOVWF  01
08170:  MOVLW  00
08172:  ADDWFC xB6,W
08174:  MOVWF  03
08176:  MOVFF  01,9B7
0817A:  MOVWF  xB8
0817C:  MOVLW  04
0817E:  ADDWF  xB3,W
08180:  MOVWF  FE9
08182:  MOVLW  00
08184:  ADDWFC xB4,W
08186:  MOVWF  FEA
08188:  MOVFF  FEF,00
0818C:  MOVFF  FEC,01
08190:  MOVFF  FEC,02
08194:  MOVFF  FEC,03
08198:  MOVFF  9B8,FEA
0819C:  MOVFF  9B7,FE9
081A0:  MOVFF  00,FEF
081A4:  MOVFF  01,FEC
081A8:  MOVFF  02,FEC
081AC:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
081B0:  MOVLW  1A
081B2:  ADDWF  xB5,W
081B4:  MOVWF  01
081B6:  MOVLW  00
081B8:  ADDWFC xB6,W
081BA:  MOVWF  03
081BC:  MOVFF  01,9B7
081C0:  MOVWF  xB8
081C2:  MOVLW  08
081C4:  ADDWF  xB3,W
081C6:  MOVWF  FE9
081C8:  MOVLW  00
081CA:  ADDWFC xB4,W
081CC:  MOVWF  FEA
081CE:  MOVFF  FEF,00
081D2:  MOVFF  FEC,01
081D6:  MOVFF  FEC,02
081DA:  MOVFF  FEC,03
081DE:  MOVFF  9B8,FEA
081E2:  MOVFF  9B7,FE9
081E6:  MOVFF  00,FEF
081EA:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
081EE:  MOVLW  14
081F0:  ADDWF  xB5,W
081F2:  MOVWF  01
081F4:  MOVLW  00
081F6:  ADDWFC xB6,W
081F8:  MOVWF  03
081FA:  MOVFF  01,9B7
081FE:  MOVWF  xB8
08200:  MOVLW  08
08202:  ADDWF  xB3,W
08204:  MOVWF  FE9
08206:  MOVLW  00
08208:  ADDWFC xB4,W
0820A:  MOVWF  FEA
0820C:  MOVFF  FEF,9B9
08210:  MOVFF  FEC,9BA
08214:  MOVFF  FEC,00
08218:  MOVFF  FEC,01
0821C:  MOVFF  9B8,FEA
08220:  MOVFF  9B7,FE9
08224:  MOVFF  00,FEF
08228:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
0822C:  MOVLW  16
0822E:  ADDWF  xB5,W
08230:  MOVWF  01
08232:  MOVLW  00
08234:  ADDWFC xB6,W
08236:  MOVWF  03
08238:  MOVFF  01,9B7
0823C:  MOVWF  xB8
0823E:  MOVLB  0
08240:  CALL   6FE8
08244:  MOVFF  9B8,FEA
08248:  MOVFF  9B7,FE9
0824C:  MOVFF  00,FEF
08250:  MOVFF  01,FEC
08254:  MOVFF  02,FEC
08258:  MOVFF  03,FEC
....................       fs->winflag = 1; 
0825C:  MOVLW  06
0825E:  MOVLB  7
08260:  ADDWF  x12,W
08262:  MOVWF  FE9
08264:  MOVLW  00
08266:  ADDWFC x13,W
08268:  MOVWF  FEA
0826A:  MOVLW  01
0826C:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
0826E:  MOVLW  1A
08270:  MOVLB  9
08272:  ADDWF  xB3,W
08274:  MOVWF  FE9
08276:  MOVLW  00
08278:  ADDWFC xB4,W
0827A:  MOVWF  FEA
0827C:  MOVF   FEF,W
0827E:  ANDLW  DF
08280:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
08282:  MOVLB  A
08284:  CLRF   x17
08286:  CLRF   x16
08288:  CLRF   x15
0828A:  CLRF   x14
0828C:  MOVLB  0
0828E:  CALL   5A82
08292:  MOVF   01,F
08294:  BNZ   82A0
....................       return (FR_RW_ERROR); 
08296:  MOVLW  07
08298:  MOVWF  01
0829A:  MOVLB  7
0829C:  BRA    82A6
0829E:  MOVLB  0
....................  
....................    return (FR_OK); 
082A0:  MOVLW  00
082A2:  MOVWF  01
082A4:  MOVLB  7
082A6:  MOVLB  0
082A8:  GOTO   82B6 (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
082AC:  MOVFF  9B1,9B4
082B0:  MOVFF  9B0,9B3
082B4:  BRA    80CA
082B6:  MOVFF  01,9B2
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
082BA:  MOVLB  9
082BC:  MOVF   xB2,F
082BE:  BNZ   82F0
....................       { 
....................       fp->flag = 0; 
082C0:  MOVLW  1A
082C2:  ADDWF  xB0,W
082C4:  MOVWF  FE9
082C6:  MOVLW  00
082C8:  ADDWFC xB1,W
082CA:  MOVWF  FEA
082CC:  CLRF   FEF
....................       if (fs->files) 
082CE:  MOVLW  01
082D0:  MOVLB  7
082D2:  ADDWF  x12,W
082D4:  MOVWF  FE9
082D6:  MOVLW  00
082D8:  ADDWFC x13,W
082DA:  MOVWF  FEA
082DC:  MOVF   FEF,F
082DE:  BZ    82EE
....................          fs->files--; 
082E0:  MOVLW  01
082E2:  ADDWF  x12,W
082E4:  MOVWF  FE9
082E6:  MOVLW  00
082E8:  ADDWFC x13,W
082EA:  MOVWF  FEA
082EC:  DECF   FEF,F
082EE:  MOVLB  9
....................       } 
....................    return (res); 
082F0:  MOVFF  9B2,01
082F4:  MOVLB  0
082F6:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0BC9E:  CALL   55AC
0BCA2:  MOVFF  01,88B
....................    if (res != FR_OK)  
0BCA6:  MOVLB  8
0BCA8:  MOVF   x8B,F
0BCAA:  BZ    BCB2
....................       return (res); 
0BCAC:  MOVFF  88B,01
0BCB0:  BRA    BF42
....................  
....................    if (disk_status() & STA_PROTECT) 
0BCB2:  MOVLB  0
0BCB4:  CALL   559E
0BCB8:  BTFSS  01.2
0BCBA:  BRA    BCC6
....................       return (FR_WRITE_PROTECTED); 
0BCBC:  MOVLW  0A
0BCBE:  MOVWF  01
0BCC0:  MOVLB  8
0BCC2:  BRA    BF42
0BCC4:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0BCC6:  MOVLW  08
0BCC8:  MOVLB  9
0BCCA:  MOVWF  xD7
0BCCC:  MOVLW  98
0BCCE:  MOVWF  xD6
0BCD0:  MOVLW  08
0BCD2:  MOVWF  xD9
0BCD4:  MOVLW  A6
0BCD6:  MOVWF  xD8
0BCD8:  MOVFF  88A,9DB
0BCDC:  MOVFF  889,9DA
0BCE0:  MOVLW  08
0BCE2:  MOVWF  xDD
0BCE4:  MOVLW  8C
0BCE6:  MOVWF  xDC
0BCE8:  MOVLB  0
0BCEA:  CALL   61E2
0BCEE:  MOVFF  01,88B
....................  
....................    if (res != FR_OK)  
0BCF2:  MOVLB  8
0BCF4:  MOVF   x8B,F
0BCF6:  BZ    BCFE
....................       return (res);            // Trace failed  
0BCF8:  MOVFF  88B,01
0BCFC:  BRA    BF42
....................  
....................    if (dir_ptr == NULL)  
0BCFE:  MOVF   x8C,F
0BD00:  BNZ   BD0C
0BD02:  MOVF   x8D,F
0BD04:  BNZ   BD0C
....................       return (FR_NO_FILE);      // It is a root directory  
0BD06:  MOVLW  02
0BD08:  MOVWF  01
0BD0A:  BRA    BF42
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0BD0C:  MOVLW  0B
0BD0E:  ADDWF  x8C,W
0BD10:  MOVWF  01
0BD12:  MOVLW  00
0BD14:  ADDWFC x8D,W
0BD16:  MOVWF  03
0BD18:  MOVFF  01,FE9
0BD1C:  MOVWF  FEA
0BD1E:  BTFSS  FEF.0
0BD20:  BRA    BD28
....................       return (FR_DENIED);         // It is a R/O item  
0BD22:  MOVLW  05
0BD24:  MOVWF  01
0BD26:  BRA    BF42
....................  
....................    dsect = fs->winsect; 
0BD28:  MOVLW  20
0BD2A:  MOVLB  7
0BD2C:  ADDWF  x12,W
0BD2E:  MOVWF  FE9
0BD30:  MOVLW  00
0BD32:  ADDWFC x13,W
0BD34:  MOVWF  FEA
0BD36:  MOVFF  FEF,894
0BD3A:  MOVFF  FEC,895
0BD3E:  MOVFF  FEC,896
0BD42:  MOVFF  FEC,897
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0BD46:  MOVLW  14
0BD48:  MOVLB  8
0BD4A:  ADDWF  x8C,W
0BD4C:  MOVWF  01
0BD4E:  MOVLW  00
0BD50:  ADDWFC x8D,W
0BD52:  MOVWF  03
0BD54:  MOVFF  01,FE9
0BD58:  MOVWF  FEA
0BD5A:  MOVFF  FEC,893
0BD5E:  MOVF   FED,F
0BD60:  MOVFF  FEF,8B2
0BD64:  MOVFF  8B2,892
0BD68:  CLRF   xB2
0BD6A:  CLRF   xB3
0BD6C:  MOVLW  1A
0BD6E:  ADDWF  x8C,W
0BD70:  MOVWF  01
0BD72:  MOVLW  00
0BD74:  ADDWFC x8D,W
0BD76:  MOVFF  01,FE9
0BD7A:  MOVWF  FEA
0BD7C:  MOVFF  FEC,03
0BD80:  MOVF   FED,F
0BD82:  MOVF   FEF,W
0BD84:  IORWF  xB2,W
0BD86:  MOVWF  x90
0BD88:  MOVF   03,W
0BD8A:  IORWF  xB3,W
0BD8C:  MOVWF  x91
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BD8E:  MOVLW  0B
0BD90:  ADDWF  x8C,W
0BD92:  MOVWF  01
0BD94:  MOVLW  00
0BD96:  ADDWFC x8D,W
0BD98:  MOVWF  03
0BD9A:  MOVFF  01,FE9
0BD9E:  MOVWF  FEA
0BDA0:  BTFSS  FEF.4
0BDA2:  BRA    BEB6
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BDA4:  MOVFF  893,89F
0BDA8:  MOVFF  892,89E
0BDAC:  MOVFF  891,89D
0BDB0:  MOVFF  890,89C
....................       dirscan.sect = clust2sect(dclust); 
0BDB4:  MOVFF  893,9F2
0BDB8:  MOVFF  892,9F1
0BDBC:  MOVFF  891,9F0
0BDC0:  MOVFF  890,9EF
0BDC4:  MOVLB  0
0BDC6:  CALL   560E
0BDCA:  MOVFF  03,8A3
0BDCE:  MOVFF  02,8A2
0BDD2:  MOVFF  01,8A1
0BDD6:  MOVFF  00,8A0
....................       dirscan.index = 0; 
0BDDA:  MOVLB  8
0BDDC:  CLRF   xA5
0BDDE:  CLRF   xA4
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BDE0:  MOVFF  8A3,A17
0BDE4:  MOVFF  8A2,A16
0BDE8:  MOVFF  8A1,A15
0BDEC:  MOVFF  8A0,A14
0BDF0:  MOVLB  0
0BDF2:  CALL   5A82
0BDF6:  MOVF   01,F
0BDF8:  BNZ   BE04
....................             return (FR_RW_ERROR); 
0BDFA:  MOVLW  07
0BDFC:  MOVWF  01
0BDFE:  MOVLB  8
0BE00:  BRA    BF42
0BE02:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BE04:  MOVLB  8
0BE06:  MOVF   xA4,W
0BE08:  ANDLW  0F
0BE0A:  MOVWF  xB2
0BE0C:  CLRF   xB3
0BE0E:  RLCF   xB2,F
0BE10:  RLCF   xB3,F
0BE12:  RLCF   xB2,F
0BE14:  RLCF   xB3,F
0BE16:  RLCF   xB2,F
0BE18:  RLCF   xB3,F
0BE1A:  RLCF   xB2,F
0BE1C:  RLCF   xB3,F
0BE1E:  RLCF   xB2,F
0BE20:  RLCF   xB3,F
0BE22:  MOVLW  E0
0BE24:  ANDWF  xB2,F
0BE26:  MOVLW  24
0BE28:  ADDWF  xB2,W
0BE2A:  MOVWF  01
0BE2C:  MOVLW  00
0BE2E:  ADDWFC xB3,W
0BE30:  MOVWF  03
0BE32:  MOVF   01,W
0BE34:  MOVLB  7
0BE36:  ADDWF  x12,W
0BE38:  MOVWF  01
0BE3A:  MOVF   x13,W
0BE3C:  ADDWFC 03,F
0BE3E:  MOVFF  01,88E
0BE42:  MOVLB  8
0BE44:  MOVFF  03,88F
....................          if (*sdir == 0) 
0BE48:  MOVFF  88F,03
0BE4C:  MOVFF  88E,FE9
0BE50:  MOVFF  88F,FEA
0BE54:  MOVF   FEF,F
0BE56:  BNZ   BE5A
....................             break; 
0BE58:  BRA    BEB6
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BE5A:  MOVFF  88F,03
0BE5E:  MOVFF  88E,FE9
0BE62:  MOVFF  88F,FEA
0BE66:  MOVF   FEF,W
0BE68:  SUBLW  E5
0BE6A:  BZ    BE9A
0BE6C:  MOVFF  88F,03
0BE70:  MOVFF  88E,FE9
0BE74:  MOVFF  88F,FEA
0BE78:  MOVF   FEF,W
0BE7A:  SUBLW  2E
0BE7C:  BZ    BE9A
0BE7E:  MOVLW  0B
0BE80:  ADDWF  x8E,W
0BE82:  MOVWF  01
0BE84:  MOVLW  00
0BE86:  ADDWFC x8F,W
0BE88:  MOVWF  03
0BE8A:  MOVFF  01,FE9
0BE8E:  MOVWF  FEA
0BE90:  BTFSC  FEF.3
0BE92:  BRA    BE9A
....................             return (FR_DENIED);   // The directory is not empty  
0BE94:  MOVLW  05
0BE96:  MOVWF  01
0BE98:  BRA    BF42
....................          } while (next_dir_ptr(&dirscan)); 
0BE9A:  MOVLW  08
0BE9C:  MOVLB  9
0BE9E:  MOVWF  xE6
0BEA0:  MOVLW  98
0BEA2:  MOVWF  xE5
0BEA4:  MOVLB  0
0BEA6:  CALL   6008
0BEAA:  MOVF   01,F
0BEAC:  BTFSC  FD8.2
0BEAE:  BRA    BEB4
0BEB0:  MOVLB  8
0BEB2:  BRA    BDE0
0BEB4:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BEB6:  MOVFF  897,A17
0BEBA:  MOVFF  896,A16
0BEBE:  MOVFF  895,A15
0BEC2:  MOVFF  894,A14
0BEC6:  MOVLB  0
0BEC8:  CALL   5A82
0BECC:  MOVF   01,F
0BECE:  BNZ   BEDA
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BED0:  MOVLW  07
0BED2:  MOVWF  01
0BED4:  MOVLB  8
0BED6:  BRA    BF42
0BED8:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BEDA:  MOVLB  8
0BEDC:  MOVFF  88C,FE9
0BEE0:  MOVFF  88D,FEA
0BEE4:  MOVLW  E5
0BEE6:  MOVWF  FEF
....................    fs->winflag = 1; 
0BEE8:  MOVLW  06
0BEEA:  MOVLB  7
0BEEC:  ADDWF  x12,W
0BEEE:  MOVWF  FE9
0BEF0:  MOVLW  00
0BEF2:  ADDWFC x13,W
0BEF4:  MOVWF  FEA
0BEF6:  MOVLW  01
0BEF8:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BEFA:  MOVFF  893,9DE
0BEFE:  MOVFF  892,9DD
0BF02:  MOVFF  891,9DC
0BF06:  MOVFF  890,9DB
0BF0A:  MOVLB  0
0BF0C:  CALL   6F46
0BF10:  MOVF   01,F
0BF12:  BNZ   BF1E
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BF14:  MOVLW  07
0BF16:  MOVWF  01
0BF18:  MOVLB  8
0BF1A:  BRA    BF42
0BF1C:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BF1E:  MOVLB  A
0BF20:  CLRF   x17
0BF22:  CLRF   x16
0BF24:  CLRF   x15
0BF26:  CLRF   x14
0BF28:  MOVLB  0
0BF2A:  CALL   5A82
0BF2E:  MOVF   01,F
0BF30:  BNZ   BF3C
....................       return (FR_RW_ERROR); 
0BF32:  MOVLW  07
0BF34:  MOVWF  01
0BF36:  MOVLB  8
0BF38:  BRA    BF42
0BF3A:  MOVLB  0
....................  
....................    return (FR_OK); 
0BF3C:  MOVLW  00
0BF3E:  MOVWF  01
0BF40:  MOVLB  8
0BF42:  MOVLB  0
0BF44:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
079BC:  MOVFF  9B1,9B3
079C0:  MOVFF  9B0,9B2
079C4:  MOVFF  9B3,03
079C8:  MOVLB  9
079CA:  MOVFF  9B2,FE9
079CE:  MOVFF  9B3,FEA
079D2:  MOVF   FEF,F
079D4:  BZ    79E2
079D6:  INCF   xB2,F
079D8:  BTFSC  FD8.2
079DA:  INCF   xB3,F
079DC:  MOVLB  0
079DE:  BRA    79C4
079E0:  MOVLB  9
....................    return(sc - s); 
079E2:  MOVF   xB0,W
079E4:  SUBWF  xB2,W
079E6:  MOVWF  00
079E8:  MOVF   xB1,W
079EA:  SUBWFB xB3,W
079EC:  MOVWF  03
079EE:  MOVFF  00,01
079F2:  MOVWF  02
079F4:  MOVLB  0
079F6:  GOTO   843E (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
03508:  MOVLB  4
0350A:  CLRF   xE6
0350C:  MOVLW  01
0350E:  MOVWF  xE5
....................    rtc.year=10; 
03510:  MOVLW  0A
03512:  MOVWF  xE4
....................    rtc.month=1; 
03514:  MOVLW  01
03516:  MOVWF  xE3
....................    rtc.day=1; 
03518:  MOVWF  xE2
....................    rtc.hour=0; 
0351A:  CLRF   xE1
....................    rtc.min=0; 
0351C:  CLRF   xE0
....................    rtc.sec=0; 
0351E:  CLRF   xDF
....................    rtc.ms100=0; 
03520:  CLRF   xDE
03522:  MOVLB  0
03524:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
06FE8:  MOVLB  9
06FEA:  CLRF   xDD
06FEC:  CLRF   xDC
06FEE:  CLRF   xDB
06FF0:  MOVFF  4E4,9DA
06FF4:  MOVLW  14
06FF6:  ADDWF  xDA,F
06FF8:  MOVLW  00
06FFA:  ADDWFC xDB,F
06FFC:  ADDWFC xDC,F
06FFE:  ADDWFC xDD,F
07000:  BCF    FD8.0
07002:  CLRF   xD6
07004:  CLRF   xD7
07006:  CLRF   xD8
07008:  RLCF   xDA,W
0700A:  MOVWF  xD9
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
0700C:  CLRF   xDD
0700E:  CLRF   xDC
07010:  CLRF   xDB
07012:  MOVFF  4E3,9DA
07016:  MOVLW  0F
07018:  ANDWF  xDA,F
0701A:  CLRF   xDB
0701C:  CLRF   xDC
0701E:  CLRF   xDD
07020:  CLRF   00
07022:  CLRF   01
07024:  RLCF   xDA,W
07026:  MOVWF  02
07028:  RLCF   xDB,W
0702A:  MOVWF  03
0702C:  RLCF   02,F
0702E:  RLCF   03,F
07030:  RLCF   02,F
07032:  RLCF   03,F
07034:  RLCF   02,F
07036:  RLCF   03,F
07038:  RLCF   02,F
0703A:  RLCF   03,F
0703C:  MOVLW  E0
0703E:  ANDWF  02,F
07040:  MOVF   00,W
07042:  IORWF  xD6,F
07044:  MOVF   01,W
07046:  IORWF  xD7,F
07048:  MOVF   02,W
0704A:  IORWF  xD8,F
0704C:  MOVF   03,W
0704E:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
07050:  CLRF   xDD
07052:  CLRF   xDC
07054:  CLRF   xDB
07056:  MOVFF  4E2,9DA
0705A:  MOVLW  1F
0705C:  ANDWF  xDA,F
0705E:  CLRF   xDB
07060:  CLRF   xDC
07062:  CLRF   xDD
07064:  CLRF   00
07066:  CLRF   01
07068:  MOVF   00,W
0706A:  IORWF  xD6,F
0706C:  MOVF   01,W
0706E:  IORWF  xD7,F
07070:  MOVF   xDA,W
07072:  IORWF  xD8,F
07074:  MOVF   xDB,W
07076:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
07078:  CLRF   xDD
0707A:  CLRF   xDC
0707C:  CLRF   xDB
0707E:  MOVFF  4E1,9DA
07082:  MOVLW  1F
07084:  ANDWF  xDA,F
07086:  CLRF   xDB
07088:  CLRF   xDC
0708A:  CLRF   xDD
0708C:  CLRF   00
0708E:  RLCF   xDA,W
07090:  MOVWF  01
07092:  RLCF   xDB,W
07094:  MOVWF  02
07096:  RLCF   xDC,W
07098:  MOVWF  03
0709A:  RLCF   01,F
0709C:  RLCF   02,F
0709E:  RLCF   03,F
070A0:  RLCF   01,F
070A2:  RLCF   02,F
070A4:  RLCF   03,F
070A6:  MOVLW  F8
070A8:  ANDWF  01,F
070AA:  MOVF   00,W
070AC:  IORWF  xD6,F
070AE:  MOVF   01,W
070B0:  IORWF  xD7,F
070B2:  MOVF   02,W
070B4:  IORWF  xD8,F
070B6:  MOVF   03,W
070B8:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
070BA:  CLRF   xDD
070BC:  CLRF   xDC
070BE:  CLRF   xDB
070C0:  MOVFF  4E0,9DA
070C4:  MOVLW  3F
070C6:  ANDWF  xDA,F
070C8:  CLRF   xDB
070CA:  CLRF   xDC
070CC:  CLRF   xDD
070CE:  RLCF   xDA,W
070D0:  MOVWF  00
070D2:  RLCF   xDB,W
070D4:  MOVWF  01
070D6:  RLCF   xDC,W
070D8:  MOVWF  02
070DA:  RLCF   xDD,W
070DC:  MOVWF  03
070DE:  RLCF   00,F
070E0:  RLCF   01,F
070E2:  RLCF   02,F
070E4:  RLCF   03,F
070E6:  RLCF   00,F
070E8:  RLCF   01,F
070EA:  RLCF   02,F
070EC:  RLCF   03,F
070EE:  RLCF   00,F
070F0:  RLCF   01,F
070F2:  RLCF   02,F
070F4:  RLCF   03,F
070F6:  RLCF   00,F
070F8:  RLCF   01,F
070FA:  RLCF   02,F
070FC:  RLCF   03,F
070FE:  MOVLW  E0
07100:  ANDWF  00,F
07102:  MOVF   00,W
07104:  IORWF  xD6,F
07106:  MOVF   01,W
07108:  IORWF  xD7,F
0710A:  MOVF   02,W
0710C:  IORWF  xD8,F
0710E:  MOVF   03,W
07110:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
07112:  CLRF   xDD
07114:  CLRF   xDC
07116:  CLRF   xDB
07118:  MOVFF  4DF,9DA
0711C:  MOVLW  3F
0711E:  ANDWF  xDA,F
07120:  CLRF   xDB
07122:  CLRF   xDC
07124:  CLRF   xDD
07126:  BCF    FD8.0
07128:  RRCF   xDD,W
0712A:  MOVWF  03
0712C:  RRCF   xDC,W
0712E:  MOVWF  02
07130:  RRCF   xDB,W
07132:  MOVWF  01
07134:  RRCF   xDA,W
07136:  IORWF  xD6,F
07138:  MOVF   01,W
0713A:  IORWF  xD7,F
0713C:  MOVF   02,W
0713E:  IORWF  xD8,F
07140:  MOVF   03,W
07142:  IORWF  xD9,F
....................    return (work); 
07144:  MOVFF  9D6,00
07148:  MOVFF  9D7,01
0714C:  MOVFF  9D8,02
07150:  MOVFF  9D9,03
07154:  MOVLB  0
07156:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0BB24:  MOVLW  08
0BB26:  MOVLB  9
0BB28:  MOVWF  xB1
0BB2A:  MOVLW  8B
0BB2C:  MOVWF  xB0
0BB2E:  MOVFF  88A,9B3
0BB32:  MOVFF  889,9B2
0BB36:  MOVLW  01
0BB38:  MOVWF  xB4
0BB3A:  MOVLB  0
0BB3C:  CALL   7158
0BB40:  MOVFF  01,8A7
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0BB44:  MOVLB  8
0BB46:  MOVF   xA7,F
0BB48:  BTFSS  FD8.2
0BB4A:  BRA    BC4C
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0BB4C:  MOVLW  08
0BB4E:  MOVWF  xCD
0BB50:  MOVLW  8B
0BB52:  MOVWF  xCC
0BB54:  MOVLW  08
0BB56:  MOVWF  xCF
0BB58:  MOVLW  A8
0BB5A:  MOVWF  xCE
0BB5C:  CLRF   xD1
0BB5E:  MOVLW  20
0BB60:  MOVWF  xD0
0BB62:  MOVLW  08
0BB64:  MOVWF  xD3
0BB66:  MOVLW  CA
0BB68:  MOVWF  xD2
0BB6A:  MOVLB  0
0BB6C:  BRA    B468
0BB6E:  MOVFF  01,8A7
....................          for (i = 0; i < br; i++) 
0BB72:  MOVLB  8
0BB74:  CLRF   xC9
0BB76:  CLRF   xC8
0BB78:  MOVF   xC9,W
0BB7A:  SUBWF  xCB,W
0BB7C:  BNC   BBA8
0BB7E:  BNZ   BB86
0BB80:  MOVF   xCA,W
0BB82:  SUBWF  xC8,W
0BB84:  BC    BBA8
....................          { 
....................             putc(mesg[i]); 
0BB86:  MOVLW  A8
0BB88:  ADDWF  xC8,W
0BB8A:  MOVWF  FE9
0BB8C:  MOVLW  08
0BB8E:  ADDWFC xC9,W
0BB90:  MOVWF  FEA
0BB92:  MOVFF  FEF,8CC
0BB96:  MOVF   xCC,W
0BB98:  MOVLB  0
0BB9A:  CALL   AEB8
0BB9E:  MOVLB  8
0BBA0:  INCF   xC8,F
0BBA2:  BTFSC  FD8.2
0BBA4:  INCF   xC9,F
0BBA6:  BRA    BB78
....................          } 
....................       } while ((result == FR_OK) && br); 
0BBA8:  MOVF   xA7,F
0BBAA:  BNZ   BBB2
0BBAC:  MOVF   xCA,W
0BBAE:  IORWF  xCB,W
0BBB0:  BNZ   BB4C
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0BBB2:  MOVF   xA7,F
0BBB4:  BZ    BC28
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0BBB6:  MOVLW  1A
0BBB8:  MOVWF  FF6
0BBBA:  MOVLW  0C
0BBBC:  MOVWF  FF7
0BBBE:  MOVLW  00
0BBC0:  MOVWF  FF8
0BBC2:  CLRF   1B
0BBC4:  BTFSC  FF2.7
0BBC6:  BSF    1B.7
0BBC8:  BCF    FF2.7
0BBCA:  MOVLB  0
0BBCC:  CALL   0E46
0BBD0:  BTFSC  1B.7
0BBD2:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0BBD4:  MOVFF  8A7,8CC
0BBD8:  MOVLW  08
0BBDA:  MOVLB  8
0BBDC:  MOVWF  xCE
0BBDE:  MOVLW  A8
0BBE0:  MOVWF  xCD
0BBE2:  MOVLB  0
0BBE4:  RCALL  B976
....................          printf("@FS: %s\r\n",mesg); 
0BBE6:  MOVLW  30
0BBE8:  MOVWF  FF6
0BBEA:  MOVLW  0C
0BBEC:  MOVWF  FF7
0BBEE:  MOVLW  00
0BBF0:  MOVWF  FF8
0BBF2:  CLRF   1B
0BBF4:  BTFSC  FF2.7
0BBF6:  BSF    1B.7
0BBF8:  BCF    FF2.7
0BBFA:  MOVLW  05
0BBFC:  MOVLB  A
0BBFE:  MOVWF  x40
0BC00:  MOVLB  0
0BC02:  CALL   101C
0BC06:  BTFSC  1B.7
0BC08:  BSF    FF2.7
0BC0A:  MOVLW  08
0BC0C:  MOVWF  FEA
0BC0E:  MOVLW  A8
0BC10:  MOVWF  FE9
0BC12:  CALL   7996
0BC16:  MOVLW  0D
0BC18:  BTFSS  F9E.4
0BC1A:  BRA    BC18
0BC1C:  MOVWF  FAD
0BC1E:  MOVLW  0A
0BC20:  BTFSS  F9E.4
0BC22:  BRA    BC20
0BC24:  MOVWF  FAD
0BC26:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0BC28:  MOVLW  08
0BC2A:  MOVLB  9
0BC2C:  MOVWF  xB1
0BC2E:  MOVLW  8B
0BC30:  MOVWF  xB0
0BC32:  MOVLB  0
0BC34:  CALL   82AC
....................       printf("\r\n");       
0BC38:  MOVLW  0D
0BC3A:  BTFSS  F9E.4
0BC3C:  BRA    BC3A
0BC3E:  MOVWF  FAD
0BC40:  MOVLW  0A
0BC42:  BTFSS  F9E.4
0BC44:  BRA    BC42
0BC46:  MOVWF  FAD
....................    } 
0BC48:  BRA    BC9C
0BC4A:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0BC4C:  MOVFF  8A7,8CC
0BC50:  MOVLW  08
0BC52:  MOVWF  xCE
0BC54:  MOVLW  A8
0BC56:  MOVWF  xCD
0BC58:  MOVLB  0
0BC5A:  RCALL  B976
....................       printf("@FS: %s\r\n",mesg); 
0BC5C:  MOVLW  3A
0BC5E:  MOVWF  FF6
0BC60:  MOVLW  0C
0BC62:  MOVWF  FF7
0BC64:  MOVLW  00
0BC66:  MOVWF  FF8
0BC68:  CLRF   1B
0BC6A:  BTFSC  FF2.7
0BC6C:  BSF    1B.7
0BC6E:  BCF    FF2.7
0BC70:  MOVLW  05
0BC72:  MOVLB  A
0BC74:  MOVWF  x40
0BC76:  MOVLB  0
0BC78:  CALL   101C
0BC7C:  BTFSC  1B.7
0BC7E:  BSF    FF2.7
0BC80:  MOVLW  08
0BC82:  MOVWF  FEA
0BC84:  MOVLW  A8
0BC86:  MOVWF  FE9
0BC88:  CALL   7996
0BC8C:  MOVLW  0D
0BC8E:  BTFSS  F9E.4
0BC90:  BRA    BC8E
0BC92:  MOVWF  FAD
0BC94:  MOVLW  0A
0BC96:  BTFSS  F9E.4
0BC98:  BRA    BC96
0BC9A:  MOVWF  FAD
....................    } 
0BC9C:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04DF4:  MOVLW  44
04DF6:  MOVWF  FF6
04DF8:  MOVLW  0C
04DFA:  MOVWF  FF7
04DFC:  MOVLW  00
04DFE:  MOVWF  FF8
04E00:  CLRF   1B
04E02:  BTFSC  FF2.7
04E04:  BSF    1B.7
04E06:  BCF    FF2.7
04E08:  CALL   0E46
04E0C:  BTFSC  1B.7
04E0E:  BSF    FF2.7
....................    if (status & FR_OK) 
04E10:  ANDLW  00
04E12:  BZ    4E30
....................       printf("   NoError\r\n"); 
04E14:  MOVLW  54
04E16:  MOVWF  FF6
04E18:  MOVLW  0C
04E1A:  MOVWF  FF7
04E1C:  MOVLW  00
04E1E:  MOVWF  FF8
04E20:  CLRF   1B
04E22:  BTFSC  FF2.7
04E24:  BSF    1B.7
04E26:  BCF    FF2.7
04E28:  CALL   0E46
04E2C:  BTFSC  1B.7
04E2E:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04E30:  MOVLB  8
04E32:  BTFSS  x8A.0
04E34:  BRA    4E56
....................       printf("   Media Not Ready\r\n"); 
04E36:  MOVLW  62
04E38:  MOVWF  FF6
04E3A:  MOVLW  0C
04E3C:  MOVWF  FF7
04E3E:  MOVLW  00
04E40:  MOVWF  FF8
04E42:  CLRF   1B
04E44:  BTFSC  FF2.7
04E46:  BSF    1B.7
04E48:  BCF    FF2.7
04E4A:  MOVLB  0
04E4C:  CALL   0E46
04E50:  BTFSC  1B.7
04E52:  BSF    FF2.7
04E54:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04E56:  BTFSS  x8A.1
04E58:  BRA    4E7A
....................       printf("   File Not Found\r\n"); 
04E5A:  MOVLW  78
04E5C:  MOVWF  FF6
04E5E:  MOVLW  0C
04E60:  MOVWF  FF7
04E62:  MOVLW  00
04E64:  MOVWF  FF8
04E66:  CLRF   1B
04E68:  BTFSC  FF2.7
04E6A:  BSF    1B.7
04E6C:  BCF    FF2.7
04E6E:  MOVLB  0
04E70:  CALL   0E46
04E74:  BTFSC  1B.7
04E76:  BSF    FF2.7
04E78:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04E7A:  MOVF   x8A,W
04E7C:  ANDLW  03
04E7E:  BZ    4EA0
....................       printf("   Invalid Path\r\n"); 
04E80:  MOVLW  8C
04E82:  MOVWF  FF6
04E84:  MOVLW  0C
04E86:  MOVWF  FF7
04E88:  MOVLW  00
04E8A:  MOVWF  FF8
04E8C:  CLRF   1B
04E8E:  BTFSC  FF2.7
04E90:  BSF    1B.7
04E92:  BCF    FF2.7
04E94:  MOVLB  0
04E96:  CALL   0E46
04E9A:  BTFSC  1B.7
04E9C:  BSF    FF2.7
04E9E:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04EA0:  BTFSS  x8A.2
04EA2:  BRA    4EC4
....................       printf("   Invalid Name\r\n"); 
04EA4:  MOVLW  9E
04EA6:  MOVWF  FF6
04EA8:  MOVLW  0C
04EAA:  MOVWF  FF7
04EAC:  MOVLW  00
04EAE:  MOVWF  FF8
04EB0:  CLRF   1B
04EB2:  BTFSC  FF2.7
04EB4:  BSF    1B.7
04EB6:  BCF    FF2.7
04EB8:  MOVLB  0
04EBA:  CALL   0E46
04EBE:  BTFSC  1B.7
04EC0:  BSF    FF2.7
04EC2:  MOVLB  8
....................    if (status & FR_DENIED) 
04EC4:  MOVF   x8A,W
04EC6:  ANDLW  05
04EC8:  BZ    4EEA
....................       printf("   Access Denied\r\n"); 
04ECA:  MOVLW  B0
04ECC:  MOVWF  FF6
04ECE:  MOVLW  0C
04ED0:  MOVWF  FF7
04ED2:  MOVLW  00
04ED4:  MOVWF  FF8
04ED6:  CLRF   1B
04ED8:  BTFSC  FF2.7
04EDA:  BSF    1B.7
04EDC:  BCF    FF2.7
04EDE:  MOVLB  0
04EE0:  CALL   0E46
04EE4:  BTFSC  1B.7
04EE6:  BSF    FF2.7
04EE8:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04EEA:  MOVF   x8A,W
04EEC:  ANDLW  06
04EEE:  BZ    4F10
....................       printf("   Disk Full\r\n"); 
04EF0:  MOVLW  C4
04EF2:  MOVWF  FF6
04EF4:  MOVLW  0C
04EF6:  MOVWF  FF7
04EF8:  MOVLW  00
04EFA:  MOVWF  FF8
04EFC:  CLRF   1B
04EFE:  BTFSC  FF2.7
04F00:  BSF    1B.7
04F02:  BCF    FF2.7
04F04:  MOVLB  0
04F06:  CALL   0E46
04F0A:  BTFSC  1B.7
04F0C:  BSF    FF2.7
04F0E:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04F10:  MOVF   x8A,W
04F12:  ANDLW  07
04F14:  BZ    4F36
....................       printf("   Read/Write Error\r\n"); 
04F16:  MOVLW  D4
04F18:  MOVWF  FF6
04F1A:  MOVLW  0C
04F1C:  MOVWF  FF7
04F1E:  MOVLW  00
04F20:  MOVWF  FF8
04F22:  CLRF   1B
04F24:  BTFSC  FF2.7
04F26:  BSF    1B.7
04F28:  BCF    FF2.7
04F2A:  MOVLB  0
04F2C:  CALL   0E46
04F30:  BTFSC  1B.7
04F32:  BSF    FF2.7
04F34:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04F36:  MOVF   x8A,W
04F38:  ANDLW  09
04F3A:  BZ    4F5C
....................       printf("   Incorrect Media Change\r\n"); 
04F3C:  MOVLW  EA
04F3E:  MOVWF  FF6
04F40:  MOVLW  0C
04F42:  MOVWF  FF7
04F44:  MOVLW  00
04F46:  MOVWF  FF8
04F48:  CLRF   1B
04F4A:  BTFSC  FF2.7
04F4C:  BSF    1B.7
04F4E:  BCF    FF2.7
04F50:  MOVLB  0
04F52:  CALL   0E46
04F56:  BTFSC  1B.7
04F58:  BSF    FF2.7
04F5A:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04F5C:  MOVF   x8A,W
04F5E:  ANDLW  0A
04F60:  BZ    4F82
....................       printf("   Write Protected\r\n"); 
04F62:  MOVLW  06
04F64:  MOVWF  FF6
04F66:  MOVLW  0D
04F68:  MOVWF  FF7
04F6A:  MOVLW  00
04F6C:  MOVWF  FF8
04F6E:  CLRF   1B
04F70:  BTFSC  FF2.7
04F72:  BSF    1B.7
04F74:  BCF    FF2.7
04F76:  MOVLB  0
04F78:  CALL   0E46
04F7C:  BTFSC  1B.7
04F7E:  BSF    FF2.7
04F80:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04F82:  MOVF   x8A,W
04F84:  ANDLW  0B
04F86:  BZ    4FA8
....................       printf("   Not Enabled\r\n"); 
04F88:  MOVLW  1C
04F8A:  MOVWF  FF6
04F8C:  MOVLW  0D
04F8E:  MOVWF  FF7
04F90:  MOVLW  00
04F92:  MOVWF  FF8
04F94:  CLRF   1B
04F96:  BTFSC  FF2.7
04F98:  BSF    1B.7
04F9A:  BCF    FF2.7
04F9C:  MOVLB  0
04F9E:  CALL   0E46
04FA2:  BTFSC  1B.7
04FA4:  BSF    FF2.7
04FA6:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04FA8:  MOVF   x8A,W
04FAA:  ANDLW  0C
04FAC:  BZ    4FCE
....................       printf("   No File System\r\n"); 
04FAE:  MOVLW  2E
04FB0:  MOVWF  FF6
04FB2:  MOVLW  0D
04FB4:  MOVWF  FF7
04FB6:  MOVLW  00
04FB8:  MOVWF  FF8
04FBA:  CLRF   1B
04FBC:  BTFSC  FF2.7
04FBE:  BSF    1B.7
04FC0:  BCF    FF2.7
04FC2:  MOVLB  0
04FC4:  CALL   0E46
04FC8:  BTFSC  1B.7
04FCA:  BSF    FF2.7
04FCC:  MOVLB  8
04FCE:  MOVLB  0
04FD0:  GOTO   505A (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
082F8:  MOVLW  09
082FA:  MOVWF  FEA
082FC:  MOVLW  10
082FE:  MOVWF  FE9
08300:  CLRF   00
08302:  CLRF   02
08304:  MOVLW  A0
08306:  MOVWF  01
08308:  CALL   3526
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
0830C:  MOVLW  08
0830E:  MOVLB  9
08310:  MOVWF  xB1
08312:  MOVLW  EF
08314:  MOVWF  xB0
08316:  MOVFF  8EE,9B3
0831A:  MOVFF  8ED,9B2
0831E:  MOVLW  12
08320:  MOVWF  xB4
08322:  MOVLB  0
08324:  CALL   7158
08328:  MOVFF  01,90B
....................    if (result) 
0832C:  MOVLB  9
0832E:  MOVF   x0B,F
08330:  BZ    8354
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
08332:  MOVLW  42
08334:  MOVWF  FF6
08336:  MOVLW  0D
08338:  MOVWF  FF7
0833A:  MOVLW  00
0833C:  MOVWF  FF8
0833E:  CLRF   1B
08340:  BTFSC  FF2.7
08342:  BSF    1B.7
08344:  BCF    FF2.7
08346:  MOVLB  0
08348:  CALL   0E46
0834C:  BTFSC  1B.7
0834E:  BSF    FF2.7
....................    } 
08350:  BRA    84D0
08352:  MOVLB  9
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
08354:  MOVLB  8
08356:  MOVF   xF3,F
08358:  BNZ   8366
0835A:  MOVF   xF4,F
0835C:  BNZ   8366
0835E:  MOVF   xF5,F
08360:  BNZ   8366
08362:  MOVF   xF6,F
08364:  BZ    838C
....................          result = f_lseek(&fdst, fdst.fsize);  
08366:  MOVLW  08
08368:  MOVLB  9
0836A:  MOVWF  xB1
0836C:  MOVLW  EF
0836E:  MOVWF  xB0
08370:  MOVFF  8F6,9B5
08374:  MOVFF  8F5,9B4
08378:  MOVFF  8F4,9B3
0837C:  MOVFF  8F3,9B2
08380:  MOVLB  0
08382:  GOTO   75A0
08386:  MOVFF  01,90B
0838A:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
0838C:  MOVLB  0
0838E:  MOVF   x66,F
08390:  BNZ   83AE
08392:  MOVLW  09
08394:  MOVLB  9
08396:  MOVWF  xB1
08398:  MOVLW  10
0839A:  MOVWF  xB0
0839C:  CLRF   xB3
0839E:  MOVLW  67
083A0:  MOVWF  xB2
083A2:  CLRF   xB5
083A4:  MOVLW  9F
083A6:  MOVWF  xB4
083A8:  MOVLB  0
083AA:  CALL   7908
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
083AE:  DECFSZ x66,W
083B0:  BRA    83D0
083B2:  MOVLW  09
083B4:  MOVLB  9
083B6:  MOVWF  xB1
083B8:  MOVLW  10
083BA:  MOVWF  xB0
083BC:  MOVLW  01
083BE:  MOVWF  xB3
083C0:  MOVLW  07
083C2:  MOVWF  xB2
083C4:  CLRF   xB5
083C6:  MOVLW  9F
083C8:  MOVWF  xB4
083CA:  MOVLB  0
083CC:  CALL   7908
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
083D0:  MOVF   20,F
083D2:  BNZ   83DA
083D4:  MOVF   1F,W
083D6:  SUBLW  04
083D8:  BC    842E
083DA:  MOVLW  62
083DC:  MOVWF  FF6
083DE:  MOVLW  0D
083E0:  MOVWF  FF7
083E2:  MOVLW  00
083E4:  MOVWF  FF8
083E6:  CLRF   1B
083E8:  BTFSC  FF2.7
083EA:  BSF    1B.7
083EC:  BCF    FF2.7
083EE:  MOVLW  0E
083F0:  MOVLB  A
083F2:  MOVWF  x40
083F4:  MOVLB  0
083F6:  CALL   101C
083FA:  BTFSC  1B.7
083FC:  BSF    FF2.7
083FE:  MOVLW  09
08400:  MOVWF  FEA
08402:  MOVLW  10
08404:  MOVWF  FE9
08406:  CALL   7996
0840A:  MOVLW  72
0840C:  MOVWF  FF6
0840E:  MOVLW  0D
08410:  MOVWF  FF7
08412:  MOVLW  00
08414:  MOVWF  FF8
08416:  CLRF   1B
08418:  BTFSC  FF2.7
0841A:  BSF    1B.7
0841C:  BCF    FF2.7
0841E:  MOVLW  03
08420:  MOVLB  A
08422:  MOVWF  x40
08424:  MOVLB  0
08426:  CALL   101C
0842A:  BTFSC  1B.7
0842C:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
0842E:  MOVLW  09
08430:  MOVLB  9
08432:  MOVWF  xB1
08434:  MOVLW  10
08436:  MOVWF  xB0
08438:  MOVLB  0
0843A:  GOTO   79BC
0843E:  MOVFF  02,90D
08442:  MOVFF  01,90C
....................       result = f_write(&fdst, mesg, btw, &bw); 
08446:  MOVLW  08
08448:  MOVLB  9
0844A:  MOVWF  xB1
0844C:  MOVLW  EF
0844E:  MOVWF  xB0
08450:  MOVLW  09
08452:  MOVWF  xB3
08454:  MOVLW  10
08456:  MOVWF  xB2
08458:  MOVFF  90D,9B5
0845C:  MOVFF  90C,9B4
08460:  MOVLW  09
08462:  MOVWF  xB7
08464:  MOVLW  0E
08466:  MOVWF  xB6
08468:  MOVLB  0
0846A:  GOTO   79FA
0846E:  MOVFF  01,90B
....................       if (result) 
08472:  MOVLB  9
08474:  MOVF   x0B,F
08476:  BZ    849A
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
08478:  MOVLW  76
0847A:  MOVWF  FF6
0847C:  MOVLW  0D
0847E:  MOVWF  FF7
08480:  MOVLW  00
08482:  MOVWF  FF8
08484:  CLRF   1B
08486:  BTFSC  FF2.7
08488:  BSF    1B.7
0848A:  BCF    FF2.7
0848C:  MOVLB  0
0848E:  CALL   0E46
08492:  BTFSC  1B.7
08494:  BSF    FF2.7
....................       } 
08496:  BRA    84C2
08498:  MOVLB  9
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
0849A:  MOVF   20,F
0849C:  BNZ   84A4
0849E:  MOVF   1F,W
084A0:  SUBLW  04
084A2:  BC    84C4
084A4:  MOVLW  8A
084A6:  MOVWF  FF6
084A8:  MOVLW  0D
084AA:  MOVWF  FF7
084AC:  MOVLW  00
084AE:  MOVWF  FF8
084B0:  CLRF   1B
084B2:  BTFSC  FF2.7
084B4:  BSF    1B.7
084B6:  BCF    FF2.7
084B8:  MOVLB  0
084BA:  CALL   0E46
084BE:  BTFSC  1B.7
084C0:  BSF    FF2.7
084C2:  MOVLB  9
....................       } 
....................  
....................       f_close(&fdst); 
084C4:  MOVLW  08
084C6:  MOVWF  xB1
084C8:  MOVLW  EF
084CA:  MOVWF  xB0
084CC:  MOVLB  0
084CE:  RCALL  82AC
....................    } 
....................  
....................    return (result); 
084D0:  MOVLB  9
084D2:  MOVFF  90B,01
084D6:  MOVLB  0
084D8:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
17B1A:  CLRF   1B
17B1C:  BTFSC  FF2.7
17B1E:  BSF    1B.7
17B20:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
17B22:  MOVFF  887,A42
17B26:  MOVLW  0A
17B28:  MOVLB  A
17B2A:  MOVWF  x43
17B2C:  MOVLB  0
17B2E:  CALL   0F72
17B32:  BTFSC  1B.7
17B34:  BSF    FF2.7
17B36:  MOVFF  01,888
....................    nibl=data-(nibh*10); 
17B3A:  MOVLB  8
17B3C:  MOVF   x88,W
17B3E:  MULLW  0A
17B40:  MOVF   FF3,W
17B42:  SUBWF  x87,W
17B44:  MOVWF  x89
....................  
....................    return((nibh<<4)|nibl); 
17B46:  SWAPF  x88,W
17B48:  MOVWF  00
17B4A:  MOVLW  F0
17B4C:  ANDWF  00,F
17B4E:  MOVF   00,W
17B50:  IORWF  x89,W
17B52:  MOVWF  01
17B54:  MOVLB  0
17B56:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
03312:  MOVFF  8EE,8EF
....................    data=(i>>4)*10; 
03316:  MOVLB  8
03318:  SWAPF  xEF,W
0331A:  MOVWF  00
0331C:  MOVLW  0F
0331E:  ANDWF  00,F
03320:  MOVF   00,W
03322:  MULLW  0A
03324:  MOVFF  FF3,8EE
....................    data=data+(i<<4>>4); 
03328:  SWAPF  xEF,W
0332A:  MOVWF  00
0332C:  MOVLW  F0
0332E:  ANDWF  00,F
03330:  MOVF   00,W
03332:  SWAPF  00,F
03334:  MOVLW  0F
03336:  ANDWF  00,F
03338:  MOVF   00,W
0333A:  ADDWF  xEE,F
....................  
....................    return data; 
0333C:  MOVFF  8EE,01
03340:  MOVLB  0
03342:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
034B2:  MOVLB  8
034B4:  CLRF   xCB
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
034B6:  BCF    FC6.5
034B8:  MOVLW  21
034BA:  MOVWF  FC6
034BC:  MOVLW  40
034BE:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
034C0:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
034C2:  MOVF   FC9,W
034C4:  MOVLW  0C
034C6:  MOVWF  FC9
034C8:  RRCF   FC7,W
034CA:  BNC   34C8
034CC:  MOVFF  FC9,8CB
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
034D0:  MOVF   FC9,W
034D2:  MOVFF  8CB,FC9
034D6:  RRCF   FC7,W
034D8:  BNC   34D6
034DA:  MOVFF  FC9,730
....................    output_bit(RTC_CS, DISABLE); 
034DE:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
034E0:  MOVLB  7
034E2:  BCF    x30.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
034E4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
034E6:  MOVF   FC9,W
034E8:  MOVLW  8C
034EA:  MOVWF  FC9
034EC:  RRCF   FC7,W
034EE:  BNC   34EC
034F0:  MOVFF  FC9,8CB
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
034F4:  MOVF   FC9,W
034F6:  MOVFF  730,FC9
034FA:  RRCF   FC7,W
034FC:  BNC   34FA
034FE:  MOVFF  FC9,8CB
....................    output_bit(RTC_CS, DISABLE); 
03502:  BSF    F91.0
03504:  MOVLB  0
03506:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0E28A:  MOVLW  1A
0E28C:  MOVLB  8
0E28E:  MOVWF  x97
0E290:  MOVLB  0
0E292:  CALL   29CA
0E296:  MOVFF  01,4F
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0E29A:  MOVF   4F,F
0E29C:  BNZ   E30A
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0E29E:  MOVLW  98
0E2A0:  MOVWF  FF6
0E2A2:  MOVLW  0D
0E2A4:  MOVWF  FF7
0E2A6:  MOVLW  00
0E2A8:  MOVWF  FF8
0E2AA:  CLRF   1B
0E2AC:  BTFSC  FF2.7
0E2AE:  BSF    1B.7
0E2B0:  BCF    FF2.7
0E2B2:  MOVLW  05
0E2B4:  MOVLB  A
0E2B6:  MOVWF  x40
0E2B8:  MOVLB  0
0E2BA:  CALL   101C
0E2BE:  BTFSC  1B.7
0E2C0:  BSF    FF2.7
0E2C2:  CLRF   1B
0E2C4:  BTFSC  FF2.7
0E2C6:  BSF    1B.7
0E2C8:  BCF    FF2.7
0E2CA:  MOVFF  72A,A40
0E2CE:  MOVLW  01
0E2D0:  MOVLB  A
0E2D2:  MOVWF  x41
0E2D4:  MOVLB  0
0E2D6:  CALL   0F9E
0E2DA:  BTFSC  1B.7
0E2DC:  BSF    FF2.7
0E2DE:  MOVLW  2F
0E2E0:  BTFSS  F9E.4
0E2E2:  BRA    E2E0
0E2E4:  MOVWF  FAD
0E2E6:  CLRF   1B
0E2E8:  BTFSC  FF2.7
0E2EA:  BSF    1B.7
0E2EC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0E2EE:  MOVFF  729,A40
0E2F2:  MOVLW  01
0E2F4:  MOVLB  A
0E2F6:  MOVWF  x41
0E2F8:  MOVLB  0
0E2FA:  CALL   0F9E
0E2FE:  BTFSC  1B.7
0E300:  BSF    FF2.7
0E302:  MOVLW  2F
0E304:  BTFSS  F9E.4
0E306:  BRA    E304
0E308:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E30A:  DECFSZ 4F,W
0E30C:  BRA    E37A
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E30E:  MOVLW  A4
0E310:  MOVWF  FF6
0E312:  MOVLW  0D
0E314:  MOVWF  FF7
0E316:  MOVLW  00
0E318:  MOVWF  FF8
0E31A:  CLRF   1B
0E31C:  BTFSC  FF2.7
0E31E:  BSF    1B.7
0E320:  BCF    FF2.7
0E322:  MOVLW  05
0E324:  MOVLB  A
0E326:  MOVWF  x40
0E328:  MOVLB  0
0E32A:  CALL   101C
0E32E:  BTFSC  1B.7
0E330:  BSF    FF2.7
0E332:  CLRF   1B
0E334:  BTFSC  FF2.7
0E336:  BSF    1B.7
0E338:  BCF    FF2.7
0E33A:  MOVFF  729,A40
0E33E:  MOVLW  01
0E340:  MOVLB  A
0E342:  MOVWF  x41
0E344:  MOVLB  0
0E346:  CALL   0F9E
0E34A:  BTFSC  1B.7
0E34C:  BSF    FF2.7
0E34E:  MOVLW  2F
0E350:  BTFSS  F9E.4
0E352:  BRA    E350
0E354:  MOVWF  FAD
0E356:  CLRF   1B
0E358:  BTFSC  FF2.7
0E35A:  BSF    1B.7
0E35C:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E35E:  MOVFF  72A,A40
0E362:  MOVLW  01
0E364:  MOVLB  A
0E366:  MOVWF  x41
0E368:  MOVLB  0
0E36A:  CALL   0F9E
0E36E:  BTFSC  1B.7
0E370:  BSF    FF2.7
0E372:  MOVLW  2F
0E374:  BTFSS  F9E.4
0E376:  BRA    E374
0E378:  MOVWF  FAD
0E37A:  CLRF   1B
0E37C:  BTFSC  FF2.7
0E37E:  BSF    1B.7
0E380:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E382:  MOVFF  72B,A40
0E386:  MOVLW  01
0E388:  MOVLB  A
0E38A:  MOVWF  x41
0E38C:  MOVLB  0
0E38E:  CALL   0F9E
0E392:  BTFSC  1B.7
0E394:  BSF    FF2.7
0E396:  MOVLW  20
0E398:  BTFSS  F9E.4
0E39A:  BRA    E398
0E39C:  MOVWF  FAD
0E39E:  CLRF   1B
0E3A0:  BTFSC  FF2.7
0E3A2:  BSF    1B.7
0E3A4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E3A6:  MOVFF  727,A40
0E3AA:  MOVLW  01
0E3AC:  MOVLB  A
0E3AE:  MOVWF  x41
0E3B0:  MOVLB  0
0E3B2:  CALL   0F9E
0E3B6:  BTFSC  1B.7
0E3B8:  BSF    FF2.7
0E3BA:  MOVLW  3A
0E3BC:  BTFSS  F9E.4
0E3BE:  BRA    E3BC
0E3C0:  MOVWF  FAD
0E3C2:  CLRF   1B
0E3C4:  BTFSC  FF2.7
0E3C6:  BSF    1B.7
0E3C8:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E3CA:  MOVFF  726,A40
0E3CE:  MOVLW  01
0E3D0:  MOVLB  A
0E3D2:  MOVWF  x41
0E3D4:  MOVLB  0
0E3D6:  CALL   0F9E
0E3DA:  BTFSC  1B.7
0E3DC:  BSF    FF2.7
0E3DE:  MOVLW  3A
0E3E0:  BTFSS  F9E.4
0E3E2:  BRA    E3E0
0E3E4:  MOVWF  FAD
0E3E6:  CLRF   1B
0E3E8:  BTFSC  FF2.7
0E3EA:  BSF    1B.7
0E3EC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E3EE:  MOVFF  725,A40
0E3F2:  MOVLW  01
0E3F4:  MOVLB  A
0E3F6:  MOVWF  x41
0E3F8:  MOVLB  0
0E3FA:  CALL   0F9E
0E3FE:  BTFSC  1B.7
0E400:  BSF    FF2.7
0E402:  MOVLW  0A
0E404:  BTFSS  F9E.4
0E406:  BRA    E404
0E408:  MOVWF  FAD
0E40A:  MOVLW  0D
0E40C:  BTFSS  F9E.4
0E40E:  BRA    E40C
0E410:  MOVWF  FAD
0E412:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03344:  MOVLB  8
03346:  CLRF   xED
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
03348:  BCF    FC6.5
0334A:  MOVLW  21
0334C:  MOVWF  FC6
0334E:  MOVLW  40
03350:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
03352:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
03354:  MOVF   FC9,W
03356:  CLRF   FC9
03358:  RRCF   FC7,W
0335A:  BNC   3358
0335C:  MOVFF  FC9,8ED
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
03360:  MOVF   FC9,W
03362:  MOVFF  8ED,FC9
03366:  RRCF   FC7,W
03368:  BNC   3366
0336A:  MOVFF  FC9,72C
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
0336E:  MOVF   FC9,W
03370:  MOVFF  8ED,FC9
03374:  RRCF   FC7,W
03376:  BNC   3374
03378:  MOVFF  FC9,725
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
0337C:  MOVF   FC9,W
0337E:  MOVFF  8ED,FC9
03382:  RRCF   FC7,W
03384:  BNC   3382
03386:  MOVFF  FC9,726
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
0338A:  MOVF   FC9,W
0338C:  MOVFF  8ED,FC9
03390:  RRCF   FC7,W
03392:  BNC   3390
03394:  MOVFF  FC9,727
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
03398:  MOVF   FC9,W
0339A:  MOVFF  8ED,FC9
0339E:  RRCF   FC7,W
033A0:  BNC   339E
033A2:  MOVFF  FC9,728
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
033A6:  MOVF   FC9,W
033A8:  MOVFF  8ED,FC9
033AC:  RRCF   FC7,W
033AE:  BNC   33AC
033B0:  MOVFF  FC9,729
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
033B4:  MOVF   FC9,W
033B6:  MOVFF  8ED,FC9
033BA:  RRCF   FC7,W
033BC:  BNC   33BA
033BE:  MOVFF  FC9,72A
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
033C2:  MOVF   FC9,W
033C4:  MOVFF  8ED,FC9
033C8:  RRCF   FC7,W
033CA:  BNC   33C8
033CC:  MOVFF  FC9,72B
....................    output_bit(RTC_CS, DISABLE); 
033D0:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
033D2:  MOVFF  725,8EE
033D6:  MOVLB  0
033D8:  RCALL  3312
033DA:  MOVFF  01,725
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
033DE:  MOVFF  726,8EE
033E2:  RCALL  3312
033E4:  MOVFF  01,726
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
033E8:  MOVFF  727,8EE
033EC:  RCALL  3312
033EE:  MOVFF  01,727
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
033F2:  MOVFF  729,8EE
033F6:  RCALL  3312
033F8:  MOVFF  01,729
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
033FC:  MOVFF  72A,8EE
03400:  RCALL  3312
03402:  MOVFF  01,72A
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
03406:  MOVFF  72B,8EE
0340A:  RCALL  3312
0340C:  MOVFF  01,72B
03410:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DD0:  MOVLB  A
00DD2:  CLRF   x37
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DD4:  BCF    FC6.5
00DD6:  MOVLW  21
00DD8:  MOVWF  FC6
00DDA:  MOVLW  40
00DDC:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00DDE:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00DE0:  MOVF   FC9,W
00DE2:  MOVLW  0F
00DE4:  MOVWF  FC9
00DE6:  RRCF   FC7,W
00DE8:  BNC   0DE6
00DEA:  MOVFF  FC9,A37
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00DEE:  MOVF   FC9,W
00DF0:  MOVFF  A37,FC9
00DF4:  RRCF   FC7,W
00DF6:  BNC   0DF4
00DF8:  MOVFF  FC9,733
....................    spi_read(0x00); 
00DFC:  MOVF   FC9,W
00DFE:  CLRF   FC9
00E00:  RRCF   FC7,W
00E02:  BNC   0E00
....................    output_bit(RTC_CS, DISABLE); 
00E04:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00E06:  BCF    4D.2
00E08:  MOVLB  0
00E0A:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E4EA:  MOVF   4F,F
0E4EC:  BNZ   E55A
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E4EE:  MOVLW  B0
0E4F0:  MOVWF  FF6
0E4F2:  MOVLW  0D
0E4F4:  MOVWF  FF7
0E4F6:  MOVLW  00
0E4F8:  MOVWF  FF8
0E4FA:  CLRF   1B
0E4FC:  BTFSC  FF2.7
0E4FE:  BSF    1B.7
0E500:  BCF    FF2.7
0E502:  MOVLW  05
0E504:  MOVLB  A
0E506:  MOVWF  x40
0E508:  MOVLB  0
0E50A:  CALL   101C
0E50E:  BTFSC  1B.7
0E510:  BSF    FF2.7
0E512:  CLRF   1B
0E514:  BTFSC  FF2.7
0E516:  BSF    1B.7
0E518:  BCF    FF2.7
0E51A:  MOVFF  72E,A40
0E51E:  MOVLW  01
0E520:  MOVLB  A
0E522:  MOVWF  x41
0E524:  MOVLB  0
0E526:  CALL   0F9E
0E52A:  BTFSC  1B.7
0E52C:  BSF    FF2.7
0E52E:  MOVLW  2F
0E530:  BTFSS  F9E.4
0E532:  BRA    E530
0E534:  MOVWF  FAD
0E536:  CLRF   1B
0E538:  BTFSC  FF2.7
0E53A:  BSF    1B.7
0E53C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E53E:  MOVFF  72F,A40
0E542:  MOVLW  01
0E544:  MOVLB  A
0E546:  MOVWF  x41
0E548:  MOVLB  0
0E54A:  CALL   0F9E
0E54E:  BTFSC  1B.7
0E550:  BSF    FF2.7
0E552:  MOVLW  2F
0E554:  BTFSS  F9E.4
0E556:  BRA    E554
0E558:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E55A:  DECFSZ 4F,W
0E55C:  BRA    E5CA
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E55E:  MOVLW  BC
0E560:  MOVWF  FF6
0E562:  MOVLW  0D
0E564:  MOVWF  FF7
0E566:  MOVLW  00
0E568:  MOVWF  FF8
0E56A:  CLRF   1B
0E56C:  BTFSC  FF2.7
0E56E:  BSF    1B.7
0E570:  BCF    FF2.7
0E572:  MOVLW  05
0E574:  MOVLB  A
0E576:  MOVWF  x40
0E578:  MOVLB  0
0E57A:  CALL   101C
0E57E:  BTFSC  1B.7
0E580:  BSF    FF2.7
0E582:  CLRF   1B
0E584:  BTFSC  FF2.7
0E586:  BSF    1B.7
0E588:  BCF    FF2.7
0E58A:  MOVFF  72F,A40
0E58E:  MOVLW  01
0E590:  MOVLB  A
0E592:  MOVWF  x41
0E594:  MOVLB  0
0E596:  CALL   0F9E
0E59A:  BTFSC  1B.7
0E59C:  BSF    FF2.7
0E59E:  MOVLW  2F
0E5A0:  BTFSS  F9E.4
0E5A2:  BRA    E5A0
0E5A4:  MOVWF  FAD
0E5A6:  CLRF   1B
0E5A8:  BTFSC  FF2.7
0E5AA:  BSF    1B.7
0E5AC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E5AE:  MOVFF  72E,A40
0E5B2:  MOVLW  01
0E5B4:  MOVLB  A
0E5B6:  MOVWF  x41
0E5B8:  MOVLB  0
0E5BA:  CALL   0F9E
0E5BE:  BTFSC  1B.7
0E5C0:  BSF    FF2.7
0E5C2:  MOVLW  2F
0E5C4:  BTFSS  F9E.4
0E5C6:  BRA    E5C4
0E5C8:  MOVWF  FAD
0E5CA:  CLRF   1B
0E5CC:  BTFSC  FF2.7
0E5CE:  BSF    1B.7
0E5D0:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E5D2:  MOVFF  72D,A40
0E5D6:  MOVLW  01
0E5D8:  MOVLB  A
0E5DA:  MOVWF  x41
0E5DC:  MOVLB  0
0E5DE:  CALL   0F9E
0E5E2:  BTFSC  1B.7
0E5E4:  BSF    FF2.7
0E5E6:  MOVLW  20
0E5E8:  BTFSS  F9E.4
0E5EA:  BRA    E5E8
0E5EC:  MOVWF  FAD
0E5EE:  CLRF   1B
0E5F0:  BTFSC  FF2.7
0E5F2:  BSF    1B.7
0E5F4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E5F6:  MOVFF  730,A40
0E5FA:  MOVLW  01
0E5FC:  MOVLB  A
0E5FE:  MOVWF  x41
0E600:  MOVLB  0
0E602:  CALL   0F9E
0E606:  BTFSC  1B.7
0E608:  BSF    FF2.7
0E60A:  MOVLW  3A
0E60C:  BTFSS  F9E.4
0E60E:  BRA    E60C
0E610:  MOVWF  FAD
0E612:  CLRF   1B
0E614:  BTFSC  FF2.7
0E616:  BSF    1B.7
0E618:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E61A:  MOVFF  731,A40
0E61E:  MOVLW  01
0E620:  MOVLB  A
0E622:  MOVWF  x41
0E624:  MOVLB  0
0E626:  CALL   0F9E
0E62A:  BTFSC  1B.7
0E62C:  BSF    FF2.7
0E62E:  MOVLW  3A
0E630:  BTFSS  F9E.4
0E632:  BRA    E630
0E634:  MOVWF  FAD
0E636:  CLRF   1B
0E638:  BTFSC  FF2.7
0E63A:  BSF    1B.7
0E63C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E63E:  MOVFF  732,A40
0E642:  MOVLW  01
0E644:  MOVLB  A
0E646:  MOVWF  x41
0E648:  MOVLB  0
0E64A:  CALL   0F9E
0E64E:  BTFSC  1B.7
0E650:  BSF    FF2.7
0E652:  MOVLW  0A
0E654:  BTFSS  F9E.4
0E656:  BRA    E654
0E658:  MOVWF  FAD
0E65A:  MOVLW  0D
0E65C:  BTFSS  F9E.4
0E65E:  BRA    E65C
0E660:  MOVWF  FAD
0E662:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E414:  MOVLB  8
0E416:  CLRF   xB7
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E418:  BCF    FC6.5
0E41A:  MOVLW  21
0E41C:  MOVWF  FC6
0E41E:  MOVLW  40
0E420:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E422:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E424:  MOVF   FC9,W
0E426:  MOVLW  0A
0E428:  MOVWF  FC9
0E42A:  RRCF   FC7,W
0E42C:  BNC   E42A
0E42E:  MOVFF  FC9,8B7
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E432:  MOVF   FC9,W
0E434:  MOVFF  8B7,FC9
0E438:  RRCF   FC7,W
0E43A:  BNC   E438
0E43C:  MOVFF  FC9,72E
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E440:  MOVF   FC9,W
0E442:  MOVFF  8B7,FC9
0E446:  RRCF   FC7,W
0E448:  BNC   E446
0E44A:  MOVFF  FC9,72F
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E44E:  MOVF   FC9,W
0E450:  MOVFF  8B7,FC9
0E454:  RRCF   FC7,W
0E456:  BNC   E454
0E458:  MOVFF  FC9,730
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E45C:  MOVF   FC9,W
0E45E:  MOVFF  8B7,FC9
0E462:  RRCF   FC7,W
0E464:  BNC   E462
0E466:  MOVFF  FC9,731
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E46A:  MOVF   FC9,W
0E46C:  MOVFF  8B7,FC9
0E470:  RRCF   FC7,W
0E472:  BNC   E470
0E474:  MOVFF  FC9,732
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E478:  MOVF   FC9,W
0E47A:  MOVFF  8B7,FC9
0E47E:  RRCF   FC7,W
0E480:  BNC   E47E
0E482:  MOVFF  FC9,733
....................    output_bit(RTC_CS, DISABLE); 
0E486:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E488:  MOVLW  1F
0E48A:  MOVLB  7
0E48C:  ANDWF  x2E,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E48E:  MOVFF  72E,8EE
0E492:  MOVLB  0
0E494:  CALL   3312
0E498:  MOVFF  01,72E
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E49C:  MOVLW  3F
0E49E:  MOVLB  7
0E4A0:  ANDWF  x2F,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E4A2:  MOVFF  72F,8EE
0E4A6:  MOVLB  0
0E4A8:  CALL   3312
0E4AC:  MOVFF  01,72F
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E4B0:  MOVLW  3F
0E4B2:  MOVLB  7
0E4B4:  ANDWF  x30,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E4B6:  MOVFF  730,8EE
0E4BA:  MOVLB  0
0E4BC:  CALL   3312
0E4C0:  MOVFF  01,730
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E4C4:  MOVLB  7
0E4C6:  BCF    x31.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E4C8:  MOVFF  731,8EE
0E4CC:  MOVLB  0
0E4CE:  CALL   3312
0E4D2:  MOVFF  01,731
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E4D6:  MOVLB  7
0E4D8:  BCF    x32.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E4DA:  MOVFF  732,8EE
0E4DE:  MOVLB  0
0E4E0:  CALL   3312
0E4E4:  MOVFF  01,732
0E4E8:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
17760:  MOVLW  08
17762:  MOVWF  FEA
17764:  MOVLW  89
17766:  MOVWF  FE9
17768:  CLRF   00
1776A:  CLRF   02
1776C:  MOVLW  0C
1776E:  MOVWF  01
17770:  CALL   3526
....................  
....................    time_error = 0; 
17774:  MOVLB  8
17776:  CLRF   x95
....................     
....................    fputc('[', COM_A); 
17778:  MOVLW  5B
1777A:  MOVLB  0
1777C:  CALL   AEB8
....................     
....................    for (n=0; n<12; ++n){ 
17780:  MOVLB  8
17782:  CLRF   x88
17784:  MOVF   x88,W
17786:  SUBLW  0B
17788:  BNC   177CE
....................       c = fgetc(COM_A); 
1778A:  MOVLB  0
1778C:  CALL   0E30
17790:  MOVFF  01,887
....................       if (com_echo == TRUE) 
17794:  DECFSZ 4C,W
17796:  BRA    177A2
....................       { 
....................          fputc(c, COM_A); 
17798:  MOVLB  8
1779A:  MOVF   x87,W
1779C:  MOVLB  0
1779E:  CALL   AEB8
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
177A2:  MOVLB  8
177A4:  MOVF   x87,W
177A6:  SUBLW  2F
177A8:  BC    177C4
177AA:  MOVF   x87,W
177AC:  SUBLW  39
177AE:  BNC   177C4
177B0:  CLRF   03
177B2:  MOVF   x88,W
177B4:  ADDLW  89
177B6:  MOVWF  FE9
177B8:  MOVLW  08
177BA:  ADDWFC 03,W
177BC:  MOVWF  FEA
177BE:  MOVFF  887,FEF
177C2:  BRA    177CA
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
177C4:  MOVLW  01
177C6:  MOVWF  x95
....................          break; 
177C8:  BRA    177CE
....................       } 
177CA:  INCF   x88,F
177CC:  BRA    17784
....................    } 
....................     
....................    if (time_error == 0){ 
177CE:  MOVF   x95,F
177D0:  BTFSS  FD8.2
177D2:  BRA    17B0A
....................     
....................       fputc(']', COM_A); 
177D4:  MOVLW  5D
177D6:  MOVLB  0
177D8:  CALL   AEB8
....................        
....................       for (n=0; n<12; ++n){ 
177DC:  MOVLB  8
177DE:  CLRF   x88
177E0:  MOVF   x88,W
177E2:  SUBLW  0B
177E4:  BNC   17816
....................          t_entry[n] = (t_entry[n] - 48); 
177E6:  CLRF   03
177E8:  MOVF   x88,W
177EA:  ADDLW  89
177EC:  MOVWF  01
177EE:  MOVLW  08
177F0:  ADDWFC 03,F
177F2:  MOVFF  03,897
177F6:  CLRF   03
177F8:  MOVF   x88,W
177FA:  ADDLW  89
177FC:  MOVWF  FE9
177FE:  MOVLW  08
17800:  ADDWFC 03,W
17802:  MOVWF  FEA
17804:  MOVLW  30
17806:  SUBWF  FEF,W
17808:  MOVFF  897,FEA
1780C:  MOVFF  01,FE9
17810:  MOVWF  FEF
17812:  INCF   x88,F
17814:  BRA    177E0
....................       } 
....................        
....................       if (RTCfmt == 0) 
17816:  MOVF   4F,F
17818:  BNZ   17856
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
1781A:  MOVF   x89,W
1781C:  MULLW  0A
1781E:  MOVF   FF3,W
17820:  ADDWF  x8A,W
17822:  MOVLB  7
17824:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17826:  MOVF   x38,F
17828:  BZ    17830
1782A:  MOVF   x38,W
1782C:  SUBLW  0C
1782E:  BC    17838
17830:  MOVLW  02
17832:  MOVLB  8
17834:  MOVWF  x95
17836:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
17838:  MOVLB  8
1783A:  MOVF   x8B,W
1783C:  MULLW  0A
1783E:  MOVF   FF3,W
17840:  ADDWF  x8C,W
17842:  MOVLB  7
17844:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17846:  MOVF   x37,F
17848:  BZ    17850
1784A:  MOVF   x37,W
1784C:  SUBLW  1F
1784E:  BC    17858
17850:  MOVLW  02
17852:  MOVLB  8
17854:  MOVWF  x95
17856:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17858:  DECFSZ 4F,W
1785A:  BRA    1789C
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
1785C:  MOVLB  8
1785E:  MOVF   x89,W
17860:  MULLW  0A
17862:  MOVF   FF3,W
17864:  ADDWF  x8A,W
17866:  MOVLB  7
17868:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
1786A:  MOVF   x37,F
1786C:  BZ    17874
1786E:  MOVF   x37,W
17870:  SUBLW  1F
17872:  BC    1787C
17874:  MOVLW  02
17876:  MOVLB  8
17878:  MOVWF  x95
1787A:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
1787C:  MOVLB  8
1787E:  MOVF   x8B,W
17880:  MULLW  0A
17882:  MOVF   FF3,W
17884:  ADDWF  x8C,W
17886:  MOVLB  7
17888:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
1788A:  MOVF   x38,F
1788C:  BZ    17894
1788E:  MOVF   x38,W
17890:  SUBLW  0C
17892:  BC    1789C
17894:  MOVLW  02
17896:  MOVLB  8
17898:  MOVWF  x95
1789A:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
1789C:  MOVLB  8
1789E:  MOVF   x8D,W
178A0:  MULLW  0A
178A2:  MOVF   FF3,W
178A4:  ADDWF  x8E,W
178A6:  MOVLB  7
178A8:  MOVWF  x39
....................       if (RTC_Yr_Data > 99) time_error = 2;  
178AA:  MOVF   x39,W
178AC:  SUBLW  63
178AE:  BC    178B8
178B0:  MOVLW  02
178B2:  MOVLB  8
178B4:  MOVWF  x95
178B6:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
178B8:  MOVLB  8
178BA:  MOVF   x8F,W
178BC:  MULLW  0A
178BE:  MOVF   FF3,W
178C0:  ADDWF  x90,W
178C2:  MOVLB  7
178C4:  MOVWF  x36
....................       if (RTC_Hr_Data > 24) time_error = 2;  
178C6:  MOVF   x36,W
178C8:  SUBLW  18
178CA:  BC    178D4
178CC:  MOVLW  02
178CE:  MOVLB  8
178D0:  MOVWF  x95
178D2:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
178D4:  MOVLB  8
178D6:  MOVF   x91,W
178D8:  MULLW  0A
178DA:  MOVF   FF3,W
178DC:  ADDWF  x92,W
178DE:  MOVLB  7
178E0:  MOVWF  x35
....................       if (RTC_Min_Data > 60) time_error = 2;  
178E2:  MOVF   x35,W
178E4:  SUBLW  3C
178E6:  BC    178F0
178E8:  MOVLW  02
178EA:  MOVLB  8
178EC:  MOVWF  x95
178EE:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
178F0:  MOVLB  8
178F2:  MOVF   x93,W
178F4:  MULLW  0A
178F6:  MOVF   FF3,W
178F8:  ADDWF  x94,W
178FA:  MOVLB  7
178FC:  MOVWF  x34
....................       if (RTC_Sec_Data > 60) time_error = 2; 
178FE:  MOVF   x34,W
17900:  SUBLW  3C
17902:  BC    1790C
17904:  MOVLW  02
17906:  MOVLB  8
17908:  MOVWF  x95
1790A:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
1790C:  MOVF   4F,F
1790E:  BTFSS  FD8.2
17910:  BRA    17A04
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
17912:  MOVLW  0A
17914:  BTFSS  F9E.4
17916:  BRA    17914
17918:  MOVWF  FAD
1791A:  MOVLW  0D
1791C:  BTFSS  F9E.4
1791E:  BRA    1791C
17920:  MOVWF  FAD
17922:  CLRF   1B
17924:  BTFSC  FF2.7
17926:  BSF    1B.7
17928:  BCF    FF2.7
1792A:  MOVFF  738,A40
1792E:  MOVLW  01
17930:  MOVLB  A
17932:  MOVWF  x41
17934:  MOVLB  0
17936:  CALL   0F9E
1793A:  BTFSC  1B.7
1793C:  BSF    FF2.7
1793E:  MOVLW  2F
17940:  BTFSS  F9E.4
17942:  BRA    17940
17944:  MOVWF  FAD
17946:  CLRF   1B
17948:  BTFSC  FF2.7
1794A:  BSF    1B.7
1794C:  BCF    FF2.7
1794E:  MOVFF  737,A40
17952:  MOVLW  01
17954:  MOVLB  A
17956:  MOVWF  x41
17958:  MOVLB  0
1795A:  CALL   0F9E
1795E:  BTFSC  1B.7
17960:  BSF    FF2.7
17962:  MOVLW  2F
17964:  BTFSS  F9E.4
17966:  BRA    17964
17968:  MOVWF  FAD
1796A:  CLRF   1B
1796C:  BTFSC  FF2.7
1796E:  BSF    1B.7
17970:  BCF    FF2.7
17972:  MOVFF  739,A40
17976:  MOVLW  01
17978:  MOVLB  A
1797A:  MOVWF  x41
1797C:  MOVLB  0
1797E:  CALL   0F9E
17982:  BTFSC  1B.7
17984:  BSF    FF2.7
17986:  MOVLW  20
17988:  BTFSS  F9E.4
1798A:  BRA    17988
1798C:  MOVWF  FAD
1798E:  CLRF   1B
17990:  BTFSC  FF2.7
17992:  BSF    1B.7
17994:  BCF    FF2.7
17996:  MOVFF  736,A40
1799A:  MOVLW  01
1799C:  MOVLB  A
1799E:  MOVWF  x41
179A0:  MOVLB  0
179A2:  CALL   0F9E
179A6:  BTFSC  1B.7
179A8:  BSF    FF2.7
179AA:  MOVLW  3A
179AC:  BTFSS  F9E.4
179AE:  BRA    179AC
179B0:  MOVWF  FAD
179B2:  CLRF   1B
179B4:  BTFSC  FF2.7
179B6:  BSF    1B.7
179B8:  BCF    FF2.7
179BA:  MOVFF  735,A40
179BE:  MOVLW  01
179C0:  MOVLB  A
179C2:  MOVWF  x41
179C4:  MOVLB  0
179C6:  CALL   0F9E
179CA:  BTFSC  1B.7
179CC:  BSF    FF2.7
179CE:  MOVLW  3A
179D0:  BTFSS  F9E.4
179D2:  BRA    179D0
179D4:  MOVWF  FAD
179D6:  CLRF   1B
179D8:  BTFSC  FF2.7
179DA:  BSF    1B.7
179DC:  BCF    FF2.7
179DE:  MOVFF  734,A40
179E2:  MOVLW  01
179E4:  MOVLB  A
179E6:  MOVWF  x41
179E8:  MOVLB  0
179EA:  CALL   0F9E
179EE:  BTFSC  1B.7
179F0:  BSF    FF2.7
179F2:  MOVLW  0A
179F4:  BTFSS  F9E.4
179F6:  BRA    179F4
179F8:  MOVWF  FAD
179FA:  MOVLW  0D
179FC:  BTFSS  F9E.4
179FE:  BRA    179FC
17A00:  MOVWF  FAD
17A02:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17A04:  DECFSZ 4F,W
17A06:  BRA    17AFA
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
17A08:  MOVLW  0A
17A0A:  BTFSS  F9E.4
17A0C:  BRA    17A0A
17A0E:  MOVWF  FAD
17A10:  MOVLW  0D
17A12:  BTFSS  F9E.4
17A14:  BRA    17A12
17A16:  MOVWF  FAD
17A18:  CLRF   1B
17A1A:  BTFSC  FF2.7
17A1C:  BSF    1B.7
17A1E:  BCF    FF2.7
17A20:  MOVFF  737,A40
17A24:  MOVLW  01
17A26:  MOVLB  A
17A28:  MOVWF  x41
17A2A:  MOVLB  0
17A2C:  CALL   0F9E
17A30:  BTFSC  1B.7
17A32:  BSF    FF2.7
17A34:  MOVLW  2F
17A36:  BTFSS  F9E.4
17A38:  BRA    17A36
17A3A:  MOVWF  FAD
17A3C:  CLRF   1B
17A3E:  BTFSC  FF2.7
17A40:  BSF    1B.7
17A42:  BCF    FF2.7
17A44:  MOVFF  738,A40
17A48:  MOVLW  01
17A4A:  MOVLB  A
17A4C:  MOVWF  x41
17A4E:  MOVLB  0
17A50:  CALL   0F9E
17A54:  BTFSC  1B.7
17A56:  BSF    FF2.7
17A58:  MOVLW  2F
17A5A:  BTFSS  F9E.4
17A5C:  BRA    17A5A
17A5E:  MOVWF  FAD
17A60:  CLRF   1B
17A62:  BTFSC  FF2.7
17A64:  BSF    1B.7
17A66:  BCF    FF2.7
17A68:  MOVFF  739,A40
17A6C:  MOVLW  01
17A6E:  MOVLB  A
17A70:  MOVWF  x41
17A72:  MOVLB  0
17A74:  CALL   0F9E
17A78:  BTFSC  1B.7
17A7A:  BSF    FF2.7
17A7C:  MOVLW  20
17A7E:  BTFSS  F9E.4
17A80:  BRA    17A7E
17A82:  MOVWF  FAD
17A84:  CLRF   1B
17A86:  BTFSC  FF2.7
17A88:  BSF    1B.7
17A8A:  BCF    FF2.7
17A8C:  MOVFF  736,A40
17A90:  MOVLW  01
17A92:  MOVLB  A
17A94:  MOVWF  x41
17A96:  MOVLB  0
17A98:  CALL   0F9E
17A9C:  BTFSC  1B.7
17A9E:  BSF    FF2.7
17AA0:  MOVLW  3A
17AA2:  BTFSS  F9E.4
17AA4:  BRA    17AA2
17AA6:  MOVWF  FAD
17AA8:  CLRF   1B
17AAA:  BTFSC  FF2.7
17AAC:  BSF    1B.7
17AAE:  BCF    FF2.7
17AB0:  MOVFF  735,A40
17AB4:  MOVLW  01
17AB6:  MOVLB  A
17AB8:  MOVWF  x41
17ABA:  MOVLB  0
17ABC:  CALL   0F9E
17AC0:  BTFSC  1B.7
17AC2:  BSF    FF2.7
17AC4:  MOVLW  3A
17AC6:  BTFSS  F9E.4
17AC8:  BRA    17AC6
17ACA:  MOVWF  FAD
17ACC:  CLRF   1B
17ACE:  BTFSC  FF2.7
17AD0:  BSF    1B.7
17AD2:  BCF    FF2.7
17AD4:  MOVFF  734,A40
17AD8:  MOVLW  01
17ADA:  MOVLB  A
17ADC:  MOVWF  x41
17ADE:  MOVLB  0
17AE0:  CALL   0F9E
17AE4:  BTFSC  1B.7
17AE6:  BSF    FF2.7
17AE8:  MOVLW  0A
17AEA:  BTFSS  F9E.4
17AEC:  BRA    17AEA
17AEE:  MOVWF  FAD
17AF0:  MOVLW  0D
17AF2:  BTFSS  F9E.4
17AF4:  BRA    17AF2
17AF6:  MOVWF  FAD
17AF8:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
17AFA:  MOVLB  8
17AFC:  MOVF   x95,W
17AFE:  SUBLW  02
17B00:  BNZ   17B08
17B02:  MOVLB  0
17B04:  BRA    17740
17B06:  MOVLB  8
....................  
....................    } 
17B08:  BRA    17B12
....................    else cmd_arg(); 
17B0A:  MOVLB  0
17B0C:  CALL   B2FE
17B10:  MOVLB  8
....................     
....................    return time_error; 
17B12:  MOVFF  895,01
17B16:  MOVLB  0
17B18:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
17B58:  RCALL  17760
17B5A:  MOVFF  01,885
....................     
....................    if (time_error ==0 ){ 
17B5E:  MOVLB  8
17B60:  MOVF   x85,F
17B62:  BTFSS  FD8.2
17B64:  BRA    17C9C
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
17B66:  BCF    FC6.5
17B68:  MOVLW  21
17B6A:  MOVWF  FC6
17B6C:  MOVLW  40
17B6E:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
17B70:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
17B72:  MOVF   FC9,W
17B74:  MOVLW  86
17B76:  MOVWF  FC9
17B78:  RRCF   FC7,W
17B7A:  BNC   17B78
17B7C:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
17B80:  MOVFF  738,887
17B84:  MOVLB  0
17B86:  RCALL  17B1A
17B88:  MOVFF  01,887
17B8C:  MOVF   FC9,W
17B8E:  MOVFF  01,FC9
17B92:  RRCF   FC7,W
17B94:  BNC   17B92
17B96:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17B9A:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17B9C:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
17B9E:  MOVF   FC9,W
17BA0:  MOVLW  85
17BA2:  MOVWF  FC9
17BA4:  RRCF   FC7,W
17BA6:  BNC   17BA4
17BA8:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
17BAC:  MOVFF  737,887
17BB0:  RCALL  17B1A
17BB2:  MOVFF  01,887
17BB6:  MOVF   FC9,W
17BB8:  MOVFF  01,FC9
17BBC:  RRCF   FC7,W
17BBE:  BNC   17BBC
17BC0:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17BC4:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17BC6:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
17BC8:  MOVF   FC9,W
17BCA:  MOVLW  87
17BCC:  MOVWF  FC9
17BCE:  RRCF   FC7,W
17BD0:  BNC   17BCE
17BD2:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
17BD6:  MOVFF  739,887
17BDA:  RCALL  17B1A
17BDC:  MOVFF  01,887
17BE0:  MOVF   FC9,W
17BE2:  MOVFF  01,FC9
17BE6:  RRCF   FC7,W
17BE8:  BNC   17BE6
17BEA:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17BEE:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17BF0:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
17BF2:  MOVF   FC9,W
17BF4:  MOVLW  83
17BF6:  MOVWF  FC9
17BF8:  RRCF   FC7,W
17BFA:  BNC   17BF8
17BFC:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
17C00:  MOVFF  736,887
17C04:  RCALL  17B1A
17C06:  MOVFF  01,887
17C0A:  MOVF   FC9,W
17C0C:  MOVFF  01,FC9
17C10:  RRCF   FC7,W
17C12:  BNC   17C10
17C14:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C18:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C1A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
17C1C:  MOVF   FC9,W
17C1E:  MOVLW  82
17C20:  MOVWF  FC9
17C22:  RRCF   FC7,W
17C24:  BNC   17C22
17C26:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
17C2A:  MOVFF  735,887
17C2E:  RCALL  17B1A
17C30:  MOVFF  01,887
17C34:  MOVF   FC9,W
17C36:  MOVFF  01,FC9
17C3A:  RRCF   FC7,W
17C3C:  BNC   17C3A
17C3E:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C42:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C44:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
17C46:  MOVF   FC9,W
17C48:  MOVLW  81
17C4A:  MOVWF  FC9
17C4C:  RRCF   FC7,W
17C4E:  BNC   17C4C
17C50:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
17C54:  MOVFF  734,887
17C58:  RCALL  17B1A
17C5A:  MOVFF  01,887
17C5E:  MOVF   FC9,W
17C60:  MOVFF  01,FC9
17C64:  RRCF   FC7,W
17C66:  BNC   17C64
17C68:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C6C:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C6E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
17C70:  MOVF   FC9,W
17C72:  MOVLW  80
17C74:  MOVWF  FC9
17C76:  RRCF   FC7,W
17C78:  BNC   17C76
17C7A:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
17C7E:  MOVLB  8
17C80:  CLRF   x87
17C82:  MOVLB  0
17C84:  RCALL  17B1A
17C86:  MOVFF  01,887
17C8A:  MOVF   FC9,W
17C8C:  MOVFF  01,FC9
17C90:  RRCF   FC7,W
17C92:  BNC   17C90
17C94:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C98:  BSF    F91.0
17C9A:  MOVLB  8
....................    } 
17C9C:  MOVLB  0
17C9E:  GOTO   17D2A (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
18828:  CALL   E414
....................     
....................    time_error = get_time(); 
1882C:  CALL   17760
18830:  MOVFF  01,885
....................     
....................    if (time_error == 0 ){ 
18834:  MOVLB  8
18836:  MOVF   x85,F
18838:  BTFSS  FD8.2
1883A:  BRA    18970
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
1883C:  MOVFF  739,72D
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
18840:  MOVLW  04
18842:  MOVWF  x89
18844:  MOVFF  72D,88A
18848:  MOVLB  0
1884A:  CALL   3412
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
1884E:  MOVFF  738,887
18852:  CALL   17B1A
18856:  MOVFF  01,738
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
1885A:  MOVLB  7
1885C:  BSF    x38.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1885E:  BCF    FC6.5
18860:  MOVLW  21
18862:  MOVWF  FC6
18864:  MOVLW  40
18866:  MOVWF  FC7
....................       delay_us(10); 
18868:  MOVLW  35
1886A:  MOVWF  00
1886C:  DECFSZ 00,F
1886E:  BRA    1886C
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
18870:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
18872:  MOVF   FC9,W
18874:  MOVLW  8E
18876:  MOVWF  FC9
18878:  RRCF   FC7,W
1887A:  BNC   18878
1887C:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
18880:  MOVFF  734,887
18884:  MOVLB  0
18886:  CALL   17B1A
1888A:  MOVFF  01,887
1888E:  MOVF   FC9,W
18890:  MOVFF  01,FC9
18894:  RRCF   FC7,W
18896:  BNC   18894
18898:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
1889C:  BSF    F91.0
....................       delay_us(1); // Delays added 1.020A 
1889E:  MOVLW  05
188A0:  MOVWF  00
188A2:  DECFSZ 00,F
188A4:  BRA    188A2
....................        
....................       output_bit(RTC_CS, ENABLE); 
188A6:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
188A8:  MOVF   FC9,W
188AA:  MOVLW  8D
188AC:  MOVWF  FC9
188AE:  RRCF   FC7,W
188B0:  BNC   188AE
188B2:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
188B6:  MOVFF  735,887
188BA:  CALL   17B1A
188BE:  MOVFF  01,887
188C2:  MOVF   FC9,W
188C4:  MOVFF  01,FC9
188C8:  RRCF   FC7,W
188CA:  BNC   188C8
188CC:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
188D0:  BSF    F91.0
....................       delay_us(1); 
188D2:  MOVLW  05
188D4:  MOVWF  00
188D6:  DECFSZ 00,F
188D8:  BRA    188D6
....................        
....................       output_bit(RTC_CS, ENABLE); 
188DA:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
188DC:  MOVF   FC9,W
188DE:  MOVLW  8C
188E0:  MOVWF  FC9
188E2:  RRCF   FC7,W
188E4:  BNC   188E2
188E6:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
188EA:  MOVFF  736,887
188EE:  CALL   17B1A
188F2:  MOVFF  01,887
188F6:  MOVF   FC9,W
188F8:  MOVFF  01,FC9
188FC:  RRCF   FC7,W
188FE:  BNC   188FC
18900:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18904:  BSF    F91.0
....................       delay_us(1);  
18906:  MOVLW  05
18908:  MOVWF  00
1890A:  DECFSZ 00,F
1890C:  BRA    1890A
....................        
....................       output_bit(RTC_CS, ENABLE); 
1890E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
18910:  MOVF   FC9,W
18912:  MOVLW  8B
18914:  MOVWF  FC9
18916:  RRCF   FC7,W
18918:  BNC   18916
1891A:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
1891E:  MOVFF  737,887
18922:  CALL   17B1A
18926:  MOVFF  01,887
1892A:  MOVF   FC9,W
1892C:  MOVFF  01,FC9
18930:  RRCF   FC7,W
18932:  BNC   18930
18934:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE);  
18938:  BSF    F91.0
....................       delay_us(1); 
1893A:  MOVLW  05
1893C:  MOVWF  00
1893E:  DECFSZ 00,F
18940:  BRA    1893E
....................        
....................       output_bit(RTC_CS, ENABLE); 
18942:  BCF    F91.0
....................       //fprintf(COM_A,"test61\r\n"); 
....................       RTC_buffer = spi_read(0x8A);// address - Month 
18944:  MOVF   FC9,W
18946:  MOVLW  8A
18948:  MOVWF  FC9
1894A:  RRCF   FC7,W
1894C:  BNC   1894A
1894E:  MOVFF  FC9,886
....................       //fprintf(COM_A,"test62\r\n"); 
....................       //fprintf(COM_A,"test6: %d\r\n",RTC_Mon_Data); 
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
18952:  MOVF   FC9,W
18954:  MOVFF  738,FC9
18958:  RRCF   FC7,W
1895A:  BNC   18958
1895C:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18960:  BSF    F91.0
....................       delay_us(1); 
18962:  MOVLW  05
18964:  MOVWF  00
18966:  DECFSZ 00,F
18968:  BRA    18966
....................       //fprintf(COM_A,"test6\r\n"); 
....................     
....................    RTC_read_alarm(); 
1896A:  CALL   E414
1896E:  MOVLB  8
....................    } 
18970:  MOVLB  0
18972:  GOTO   18988 (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15EF8:  BCF    FC6.5
15EFA:  MOVLW  21
15EFC:  MOVWF  FC6
15EFE:  MOVLW  40
15F00:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15F02:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15F04:  MOVF   FC9,W
15F06:  MOVLW  8E
15F08:  MOVWF  FC9
15F0A:  RRCF   FC7,W
15F0C:  BNC   15F0A
15F0E:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b00000000);  // data 
15F12:  MOVF   FC9,W
15F14:  CLRF   FC9
15F16:  RRCF   FC7,W
15F18:  BNC   15F16
15F1A:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F1E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F20:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15F22:  MOVF   FC9,W
15F24:  MOVLW  8D
15F26:  MOVWF  FC9
15F28:  RRCF   FC7,W
15F2A:  BNC   15F28
15F2C:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F30:  MOVF   FC9,W
15F32:  MOVLW  80
15F34:  MOVWF  FC9
15F36:  RRCF   FC7,W
15F38:  BNC   15F36
15F3A:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F3E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F40:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15F42:  MOVF   FC9,W
15F44:  MOVLW  8C
15F46:  MOVWF  FC9
15F48:  RRCF   FC7,W
15F4A:  BNC   15F48
15F4C:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F50:  MOVF   FC9,W
15F52:  MOVLW  80
15F54:  MOVWF  FC9
15F56:  RRCF   FC7,W
15F58:  BNC   15F56
15F5A:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F5E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F60:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15F62:  MOVF   FC9,W
15F64:  MOVLW  8B
15F66:  MOVWF  FC9
15F68:  RRCF   FC7,W
15F6A:  BNC   15F68
15F6C:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b11000000);  // data 
15F70:  MOVF   FC9,W
15F72:  MOVLW  C0
15F74:  MOVWF  FC9
15F76:  RRCF   FC7,W
15F78:  BNC   15F76
15F7A:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE);    
15F7E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F80:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15F82:  MOVF   FC9,W
15F84:  MOVLW  8A
15F86:  MOVWF  FC9
15F88:  RRCF   FC7,W
15F8A:  BNC   15F88
15F8C:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F90:  MOVF   FC9,W
15F92:  MOVLW  80
15F94:  MOVWF  FC9
15F96:  RRCF   FC7,W
15F98:  BNC   15F96
15F9A:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F9E:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15FA0:  CALL   E414
15FA4:  GOTO   16D64 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
15728:  MOVLB  8
1572A:  CLRF   x87
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1572C:  BCF    FC6.5
1572E:  MOVLW  21
15730:  MOVWF  FC6
15732:  MOVLW  40
15734:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15736:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
15738:  MOVF   FC9,W
1573A:  MOVLW  0A
1573C:  MOVWF  FC9
1573E:  RRCF   FC7,W
15740:  BNC   1573E
15742:  MOVFF  FC9,887
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
15746:  MOVF   FC9,W
15748:  MOVFF  887,FC9
1574C:  RRCF   FC7,W
1574E:  BNC   1574C
15750:  MOVFF  FC9,72E
....................    output_bit(RTC_CS, DISABLE); 
15754:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
15756:  MOVLB  7
15758:  BSF    x2E.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
1575A:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
1575C:  MOVF   FC9,W
1575E:  MOVLW  8A
15760:  MOVWF  FC9
15762:  RRCF   FC7,W
15764:  BNC   15762
15766:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
1576A:  MOVF   FC9,W
1576C:  MOVFF  72E,FC9
15770:  RRCF   FC7,W
15772:  BNC   15770
15774:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15778:  BSF    F91.0
1577A:  MOVLB  0
1577C:  GOTO   16C8E (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
03442:  MOVFF  725,73F
....................    rtc_last_min   = RTC_Min_Reg; 
03446:  MOVFF  726,73E
....................    rtc_last_hour  = RTC_Hr_Reg; 
0344A:  MOVFF  727,73D
....................    rtc_last_day   = RTC_DOM_Reg; 
0344E:  MOVFF  729,73B
....................    rtc_last_month = RTC_Mon_Reg; 
03452:  MOVFF  72A,73A
....................    rtc_last_year  = RTC_Yr_Reg; 
03456:  MOVFF  72B,73C
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
0345A:  MOVLW  06
0345C:  MOVLB  8
0345E:  MOVWF  x89
03460:  MOVFF  73A,88A
03464:  MOVLB  0
03466:  RCALL  3412
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
03468:  MOVLW  08
0346A:  MOVLB  8
0346C:  MOVWF  x89
0346E:  MOVFF  73B,88A
03472:  MOVLB  0
03474:  RCALL  3412
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
03476:  MOVLW  0A
03478:  MOVLB  8
0347A:  MOVWF  x89
0347C:  MOVFF  73C,88A
03480:  MOVLB  0
03482:  RCALL  3412
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
03484:  MOVLW  0C
03486:  MOVLB  8
03488:  MOVWF  x89
0348A:  MOVFF  73D,88A
0348E:  MOVLB  0
03490:  RCALL  3412
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
03492:  MOVLW  0E
03494:  MOVLB  8
03496:  MOVWF  x89
03498:  MOVFF  73E,88A
0349C:  MOVLB  0
0349E:  RCALL  3412
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
034A0:  MOVLW  10
034A2:  MOVLB  8
034A4:  MOVWF  x89
034A6:  MOVFF  73F,88A
034AA:  MOVLB  0
034AC:  RCALL  3412
034AE:  GOTO   1B7C6 (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
15780:  MOVLB  8
15782:  CLRF   x8A
15784:  CLRF   x89
15786:  CLRF   x88
15788:  CLRF   x87
1578A:  CLRF   x8E
1578C:  CLRF   x8D
1578E:  CLRF   x8C
15790:  CLRF   x8B
15792:  CLRF   x92
15794:  CLRF   x91
15796:  CLRF   x90
15798:  CLRF   x8F
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
1579A:  CLRF   x9F
1579C:  CLRF   xA0
1579E:  MOVLW  1F
157A0:  MOVWF  xA1
157A2:  CLRF   xA2
157A4:  MOVLW  3B
157A6:  MOVWF  xA3
157A8:  CLRF   xA4
157AA:  MOVLW  5A
157AC:  MOVWF  xA5
157AE:  CLRF   xA6
157B0:  MOVLW  78
157B2:  MOVWF  xA7
157B4:  CLRF   xA8
157B6:  MOVLW  97
157B8:  MOVWF  xA9
157BA:  CLRF   xAA
157BC:  MOVLW  B5
157BE:  MOVWF  xAB
157C0:  CLRF   xAC
157C2:  MOVLW  D4
157C4:  MOVWF  xAD
157C6:  CLRF   xAE
157C8:  MOVLW  F3
157CA:  MOVWF  xAF
157CC:  CLRF   xB0
157CE:  MOVLW  11
157D0:  MOVWF  xB1
157D2:  MOVLW  01
157D4:  MOVWF  xB2
157D6:  MOVLW  30
157D8:  MOVWF  xB3
157DA:  MOVLW  01
157DC:  MOVWF  xB4
157DE:  MOVLW  4E
157E0:  MOVWF  xB5
157E2:  MOVLW  01
157E4:  MOVWF  xB6
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
157E6:  BCF    4D.3
....................     
....................    RTC_read(); 
157E8:  MOVLB  0
157EA:  CALL   3344
....................    RTC_read_alarm(); 
157EE:  CALL   E414
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
157F2:  MOVLW  04
157F4:  MOVLB  8
157F6:  MOVWF  xB7
157F8:  MOVLB  0
157FA:  CALL   2A24
157FE:  MOVFF  01,72D
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
15802:  MOVLB  7
15804:  MOVF   x2B,W
15806:  SUBWF  x2D,W
15808:  BC    1580E
1580A:  BSF    4D.3
1580C:  BRA    15C42
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
1580E:  MOVF   x2D,W
15810:  SUBWF  x2B,W
15812:  BTFSS  FD8.2
15814:  BRA    15C42
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
15816:  MOVLW  01
15818:  SUBWF  x2A,W
1581A:  MOVWF  00
1581C:  BCF    FD8.0
1581E:  RLCF   00,F
15820:  MOVF   00,W
15822:  CLRF   03
15824:  ADDLW  9F
15826:  MOVWF  FE9
15828:  MOVLW  08
1582A:  ADDWFC 03,W
1582C:  MOVWF  FEA
1582E:  MOVFF  FEC,03
15832:  MOVF   FED,F
15834:  MOVFF  FEF,917
15838:  MOVFF  03,918
1583C:  MOVLB  0
1583E:  CALL   C8F6
15842:  MOVFF  03,88A
15846:  MOVFF  02,889
1584A:  MOVFF  01,888
1584E:  MOVFF  00,887
....................          time_now = time_now + RTC_DOM_Reg; 
15852:  MOVLB  9
15854:  CLRF   x18
15856:  MOVFF  729,917
1585A:  MOVLB  0
1585C:  CALL   C8F6
15860:  BCF    FD8.1
15862:  MOVFF  88A,91A
15866:  MOVFF  889,919
1586A:  MOVFF  888,918
1586E:  MOVFF  887,917
15872:  MOVFF  03,91E
15876:  MOVFF  02,91D
1587A:  MOVFF  01,91C
1587E:  MOVFF  00,91B
15882:  CALL   C3BA
15886:  MOVFF  03,88A
1588A:  MOVFF  02,889
1588E:  MOVFF  01,888
15892:  MOVFF  00,887
....................           
....................          hour = RTC_Hr_Reg; 
15896:  MOVLB  9
15898:  CLRF   x18
1589A:  MOVFF  727,917
1589E:  MOVLB  0
158A0:  CALL   C8F6
158A4:  MOVFF  03,896
158A8:  MOVFF  02,895
158AC:  MOVFF  01,894
158B0:  MOVFF  00,893
....................          minute = RTC_Min_Reg; 
158B4:  MOVLB  9
158B6:  CLRF   x18
158B8:  MOVFF  726,917
158BC:  MOVLB  0
158BE:  CALL   C8F6
158C2:  MOVFF  03,89A
158C6:  MOVFF  02,899
158CA:  MOVFF  01,898
158CE:  MOVFF  00,897
....................          second = RTC_Sec_Reg; 
158D2:  MOVLB  9
158D4:  CLRF   x18
158D6:  MOVFF  725,917
158DA:  MOVLB  0
158DC:  CALL   C8F6
158E0:  MOVFF  03,89E
158E4:  MOVFF  02,89D
158E8:  MOVFF  01,89C
158EC:  MOVFF  00,89B
....................           
....................          fraction_of_day = (hour / 24); 
158F0:  MOVFF  896,8FE
158F4:  MOVFF  895,8FD
158F8:  MOVFF  894,8FC
158FC:  MOVFF  893,8FB
15900:  MOVLB  9
15902:  CLRF   x02
15904:  CLRF   x01
15906:  MOVLW  40
15908:  MOVWF  x00
1590A:  MOVLW  83
1590C:  MOVLB  8
1590E:  MOVWF  xFF
15910:  MOVLB  0
15912:  CALL   C92C
15916:  MOVFF  03,892
1591A:  MOVFF  02,891
1591E:  MOVFF  01,890
15922:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15926:  MOVFF  89A,8FE
1592A:  MOVFF  899,8FD
1592E:  MOVFF  898,8FC
15932:  MOVFF  897,8FB
15936:  MOVLB  9
15938:  CLRF   x02
1593A:  CLRF   x01
1593C:  MOVLW  34
1593E:  MOVWF  x00
15940:  MOVLW  89
15942:  MOVLB  8
15944:  MOVWF  xFF
15946:  MOVLB  0
15948:  CALL   C92C
1594C:  BCF    FD8.1
1594E:  MOVFF  892,91A
15952:  MOVFF  891,919
15956:  MOVFF  890,918
1595A:  MOVFF  88F,917
1595E:  MOVFF  03,91E
15962:  MOVFF  02,91D
15966:  MOVFF  01,91C
1596A:  MOVFF  00,91B
1596E:  CALL   C3BA
15972:  MOVFF  03,892
15976:  MOVFF  02,891
1597A:  MOVFF  01,890
1597E:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15982:  MOVFF  89E,8FE
15986:  MOVFF  89D,8FD
1598A:  MOVFF  89C,8FC
1598E:  MOVFF  89B,8FB
15992:  MOVLB  9
15994:  CLRF   x02
15996:  MOVLW  C0
15998:  MOVWF  x01
1599A:  MOVLW  28
1599C:  MOVWF  x00
1599E:  MOVLW  8F
159A0:  MOVLB  8
159A2:  MOVWF  xFF
159A4:  MOVLB  0
159A6:  CALL   C92C
159AA:  BCF    FD8.1
159AC:  MOVFF  892,91A
159B0:  MOVFF  891,919
159B4:  MOVFF  890,918
159B8:  MOVFF  88F,917
159BC:  MOVFF  03,91E
159C0:  MOVFF  02,91D
159C4:  MOVFF  01,91C
159C8:  MOVFF  00,91B
159CC:  CALL   C3BA
159D0:  MOVFF  03,892
159D4:  MOVFF  02,891
159D8:  MOVFF  01,890
159DC:  MOVFF  00,88F
....................           
....................          time_now = time_now + fraction_of_day; 
159E0:  BCF    FD8.1
159E2:  MOVFF  88A,91A
159E6:  MOVFF  889,919
159EA:  MOVFF  888,918
159EE:  MOVFF  887,917
159F2:  MOVFF  892,91E
159F6:  MOVFF  891,91D
159FA:  MOVFF  890,91C
159FE:  MOVFF  88F,91B
15A02:  CALL   C3BA
15A06:  MOVFF  03,88A
15A0A:  MOVFF  02,889
15A0E:  MOVFF  01,888
15A12:  MOVFF  00,887
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
15A16:  MOVLB  9
15A18:  CLRF   x18
15A1A:  MOVFF  730,917
15A1E:  MOVLB  0
15A20:  CALL   C8F6
15A24:  MOVFF  03,896
15A28:  MOVFF  02,895
15A2C:  MOVFF  01,894
15A30:  MOVFF  00,893
....................          minute = RTC_Al_Min_Reg; 
15A34:  MOVLB  9
15A36:  CLRF   x18
15A38:  MOVFF  731,917
15A3C:  MOVLB  0
15A3E:  CALL   C8F6
15A42:  MOVFF  03,89A
15A46:  MOVFF  02,899
15A4A:  MOVFF  01,898
15A4E:  MOVFF  00,897
....................          second = RTC_Al_Sec_Reg; 
15A52:  MOVLB  9
15A54:  CLRF   x18
15A56:  MOVFF  732,917
15A5A:  MOVLB  0
15A5C:  CALL   C8F6
15A60:  MOVFF  03,89E
15A64:  MOVFF  02,89D
15A68:  MOVFF  01,89C
15A6C:  MOVFF  00,89B
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
15A70:  MOVLW  01
15A72:  MOVLB  7
15A74:  SUBWF  x2E,W
15A76:  MOVWF  00
15A78:  BCF    FD8.0
15A7A:  RLCF   00,F
15A7C:  MOVF   00,W
15A7E:  CLRF   03
15A80:  ADDLW  9F
15A82:  MOVWF  FE9
15A84:  MOVLW  08
15A86:  ADDWFC 03,W
15A88:  MOVWF  FEA
15A8A:  MOVFF  FEC,03
15A8E:  MOVF   FED,F
15A90:  MOVFF  FEF,917
15A94:  MOVFF  03,918
15A98:  MOVLB  0
15A9A:  CALL   C8F6
15A9E:  MOVFF  03,88E
15AA2:  MOVFF  02,88D
15AA6:  MOVFF  01,88C
15AAA:  MOVFF  00,88B
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
15AAE:  MOVLB  9
15AB0:  CLRF   x18
15AB2:  MOVFF  72F,917
15AB6:  MOVLB  0
15AB8:  CALL   C8F6
15ABC:  BCF    FD8.1
15ABE:  MOVFF  88E,91A
15AC2:  MOVFF  88D,919
15AC6:  MOVFF  88C,918
15ACA:  MOVFF  88B,917
15ACE:  MOVFF  03,91E
15AD2:  MOVFF  02,91D
15AD6:  MOVFF  01,91C
15ADA:  MOVFF  00,91B
15ADE:  CALL   C3BA
15AE2:  MOVFF  03,88E
15AE6:  MOVFF  02,88D
15AEA:  MOVFF  01,88C
15AEE:  MOVFF  00,88B
....................           
....................          fraction_of_day = (hour / 24); 
15AF2:  MOVFF  896,8FE
15AF6:  MOVFF  895,8FD
15AFA:  MOVFF  894,8FC
15AFE:  MOVFF  893,8FB
15B02:  MOVLB  9
15B04:  CLRF   x02
15B06:  CLRF   x01
15B08:  MOVLW  40
15B0A:  MOVWF  x00
15B0C:  MOVLW  83
15B0E:  MOVLB  8
15B10:  MOVWF  xFF
15B12:  MOVLB  0
15B14:  CALL   C92C
15B18:  MOVFF  03,892
15B1C:  MOVFF  02,891
15B20:  MOVFF  01,890
15B24:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15B28:  MOVFF  89A,8FE
15B2C:  MOVFF  899,8FD
15B30:  MOVFF  898,8FC
15B34:  MOVFF  897,8FB
15B38:  MOVLB  9
15B3A:  CLRF   x02
15B3C:  CLRF   x01
15B3E:  MOVLW  34
15B40:  MOVWF  x00
15B42:  MOVLW  89
15B44:  MOVLB  8
15B46:  MOVWF  xFF
15B48:  MOVLB  0
15B4A:  CALL   C92C
15B4E:  BCF    FD8.1
15B50:  MOVFF  892,91A
15B54:  MOVFF  891,919
15B58:  MOVFF  890,918
15B5C:  MOVFF  88F,917
15B60:  MOVFF  03,91E
15B64:  MOVFF  02,91D
15B68:  MOVFF  01,91C
15B6C:  MOVFF  00,91B
15B70:  CALL   C3BA
15B74:  MOVFF  03,892
15B78:  MOVFF  02,891
15B7C:  MOVFF  01,890
15B80:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15B84:  MOVFF  89E,8FE
15B88:  MOVFF  89D,8FD
15B8C:  MOVFF  89C,8FC
15B90:  MOVFF  89B,8FB
15B94:  MOVLB  9
15B96:  CLRF   x02
15B98:  MOVLW  C0
15B9A:  MOVWF  x01
15B9C:  MOVLW  28
15B9E:  MOVWF  x00
15BA0:  MOVLW  8F
15BA2:  MOVLB  8
15BA4:  MOVWF  xFF
15BA6:  MOVLB  0
15BA8:  CALL   C92C
15BAC:  BCF    FD8.1
15BAE:  MOVFF  892,91A
15BB2:  MOVFF  891,919
15BB6:  MOVFF  890,918
15BBA:  MOVFF  88F,917
15BBE:  MOVFF  03,91E
15BC2:  MOVFF  02,91D
15BC6:  MOVFF  01,91C
15BCA:  MOVFF  00,91B
15BCE:  CALL   C3BA
15BD2:  MOVFF  03,892
15BD6:  MOVFF  02,891
15BDA:  MOVFF  01,890
15BDE:  MOVFF  00,88F
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
15BE2:  BCF    FD8.1
15BE4:  MOVFF  88E,91A
15BE8:  MOVFF  88D,919
15BEC:  MOVFF  88C,918
15BF0:  MOVFF  88B,917
15BF4:  MOVFF  892,91E
15BF8:  MOVFF  891,91D
15BFC:  MOVFF  890,91C
15C00:  MOVFF  88F,91B
15C04:  CALL   C3BA
15C08:  MOVFF  03,88E
15C0C:  MOVFF  02,88D
15C10:  MOVFF  01,88C
15C14:  MOVFF  00,88B
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
15C18:  MOVFF  88E,916
15C1C:  MOVFF  88D,915
15C20:  MOVFF  88C,914
15C24:  MOVFF  88B,913
15C28:  MOVFF  88A,91A
15C2C:  MOVFF  889,919
15C30:  MOVFF  888,918
15C34:  MOVFF  887,917
15C38:  CALL   10778
15C3C:  BNC   15C40
15C3E:  BSF    4D.3
15C40:  MOVLB  7
....................       } 
....................    } 
15C42:  MOVLB  0
15C44:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
15C46:  BTFSS  4D.3
15C48:  BRA    15C66
15C4A:  MOVLW  C8
15C4C:  MOVWF  FF6
15C4E:  MOVLW  0D
15C50:  MOVWF  FF7
15C52:  MOVLW  00
15C54:  MOVWF  FF8
15C56:  CLRF   1B
15C58:  BTFSC  FF2.7
15C5A:  BSF    1B.7
15C5C:  BCF    FF2.7
15C5E:  CALL   0E46
15C62:  BTFSC  1B.7
15C64:  BSF    FF2.7
15C66:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F578:  BCF    F67.5
0F57A:  MOVLW  32
0F57C:  MOVWF  F67
0F57E:  MOVLW  40
0F580:  MOVWF  F68
....................     
....................    data = 0; 
0F582:  MOVLB  8
0F584:  CLRF   xD7
0F586:  CLRF   xD6
....................     
....................    DAC_MS_byte = 0; 
0F588:  CLRF   xD8
....................    DAC_LS_byte = 0; 
0F58A:  CLRF   xD9
....................     
....................    data = setting & 0b0000111100000000; 
0F58C:  CLRF   xD6
0F58E:  MOVF   xD5,W
0F590:  ANDLW  0F
0F592:  MOVWF  xD7
....................    data = data >> 8; 
0F594:  MOVFF  8D7,8D6
0F598:  CLRF   xD7
....................    DAC_MS_byte = data; 
0F59A:  MOVFF  8D6,8D8
....................     
....................    data = setting & 0b0000000011111111; 
0F59E:  MOVFF  8D4,8D6
0F5A2:  CLRF   xD7
....................    DAC_LS_byte = data; 
0F5A4:  MOVFF  8D6,8D9
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F5A8:  MOVLW  01
0F5AA:  SUBWF  xD3,W
0F5AC:  ADDLW  FC
0F5AE:  BC    F5DA
0F5B0:  ADDLW  04
0F5B2:  MOVLB  0
0F5B4:  GOTO   F5F8
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F5B8:  MOVLW  30
0F5BA:  MOVLB  8
0F5BC:  IORWF  xD8,F
....................          break; 
0F5BE:  BRA    F5DA
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F5C0:  MOVLW  70
0F5C2:  MOVLB  8
0F5C4:  IORWF  xD8,F
....................          break; 
0F5C6:  BRA    F5DA
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F5C8:  MOVLW  B0
0F5CA:  MOVLB  8
0F5CC:  IORWF  xD8,F
....................          break; 
0F5CE:  BRA    F5DA
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F5D0:  MOVLW  F0
0F5D2:  MOVLB  8
0F5D4:  IORWF  xD8,F
....................          break; 
0F5D6:  BRA    F5DA
0F5D8:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F5DA:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F5DC:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F5DE:  MOVF   F6A,W
0F5E0:  MOVFF  8D8,F6A
0F5E4:  RRCF   F68,W
0F5E6:  BNC   F5E4
....................    spi_write2(DAC_LS_byte); 
0F5E8:  MOVF   F6A,W
0F5EA:  MOVFF  8D9,F6A
0F5EE:  RRCF   F68,W
0F5F0:  BNC   F5EE
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F5F2:  BSF    F8C.3
0F5F4:  MOVLB  0
0F5F6:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F620:  MOVLB  8
0F622:  CLRF   xD8
0F624:  CLRF   xD9
0F626:  CLRF   xDA
0F628:  CLRF   xDB
0F62A:  CLRF   xDC
0F62C:  CLRF   xDD
0F62E:  CLRF   xDE
0F630:  CLRF   xDF
0F632:  CLRF   xE0
0F634:  CLRF   xE1
0F636:  CLRF   xE2
0F638:  CLRF   xE3
0F63A:  CLRF   xE4
0F63C:  CLRF   xE5
0F63E:  CLRF   xE6
0F640:  CLRF   xE7
0F642:  CLRF   xE8
0F644:  CLRF   xE9
0F646:  CLRF   xEA
0F648:  CLRF   xEB
0F64A:  CLRF   xEC
0F64C:  CLRF   xED
0F64E:  CLRF   xEE
0F650:  CLRF   xEF
0F652:  CLRF   xF0
0F654:  CLRF   xF1
0F656:  CLRF   xF2
0F658:  CLRF   xF3
0F65A:  CLRF   xF4
0F65C:  CLRF   xF5
0F65E:  CLRF   xF6
0F660:  CLRF   xF7
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F662:  CLRF   xF8
0F664:  CLRF   xF9
0F666:  CLRF   xFA
0F668:  CLRF   xFB
0F66A:  CLRF   xFC
0F66C:  CLRF   xFD
0F66E:  CLRF   xFE
0F670:  CLRF   xFF
0F672:  MOVLB  9
0F674:  CLRF   x00
0F676:  CLRF   x01
0F678:  CLRF   x02
0F67A:  CLRF   x03
0F67C:  CLRF   x04
0F67E:  CLRF   x05
0F680:  CLRF   x06
0F682:  CLRF   x07
0F684:  CLRF   x08
0F686:  CLRF   x09
0F688:  CLRF   x0A
0F68A:  CLRF   x0B
0F68C:  CLRF   x0C
0F68E:  CLRF   x0D
0F690:  CLRF   x0E
0F692:  CLRF   x0F
0F694:  CLRF   x10
0F696:  CLRF   x11
0F698:  CLRF   x12
0F69A:  CLRF   x13
0F69C:  CLRF   x14
0F69E:  CLRF   x15
0F6A0:  CLRF   x16
0F6A2:  CLRF   x17
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F6A4:  MOVLB  8
0F6A6:  CLRF   xD7
0F6A8:  MOVLW  01
0F6AA:  MOVWF  xD6
0F6AC:  MOVLW  01
0F6AE:  ADDWF  xD3,W
0F6B0:  MOVWF  01
0F6B2:  MOVLW  00
0F6B4:  ADDWFC xD4,W
0F6B6:  MOVWF  03
0F6B8:  MOVF   xD7,W
0F6BA:  SUBWF  03,W
0F6BC:  BTFSS  FD8.0
0F6BE:  BRA    F7AA
0F6C0:  BNZ   F6C8
0F6C2:  MOVF   01,W
0F6C4:  SUBWF  xD6,W
0F6C6:  BC    F7AA
....................    { 
....................       for (n=1; n<5; ++n) 
0F6C8:  MOVLW  01
0F6CA:  MOVWF  xD5
0F6CC:  MOVF   xD5,W
0F6CE:  SUBLW  04
0F6D0:  BNC   F7A2
....................       { 
....................          set_adc_channel(n,VSS); 
0F6D2:  RLCF   xD5,W
0F6D4:  MOVWF  00
0F6D6:  RLCF   00,F
0F6D8:  MOVLW  FC
0F6DA:  ANDWF  00,F
0F6DC:  MOVF   FC2,W
0F6DE:  ANDLW  83
0F6E0:  IORWF  00,W
0F6E2:  MOVWF  FC2
0F6E4:  MOVLW  00
0F6E6:  MOVWF  01
0F6E8:  MOVF   FC1,W
0F6EA:  ANDLW  F8
0F6EC:  IORWF  01,W
0F6EE:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F6F0:  MOVF   xD5,W
0F6F2:  MULLW  04
0F6F4:  MOVF   FF3,W
0F6F6:  CLRF   03
0F6F8:  ADDLW  F8
0F6FA:  MOVWF  FE9
0F6FC:  MOVLW  08
0F6FE:  ADDWFC 03,W
0F700:  MOVWF  FEA
0F702:  BSF    FC2.1
0F704:  BTFSC  FC2.1
0F706:  BRA    F704
0F708:  MOVFF  FC3,FEF
0F70C:  MOVFF  FC4,FEC
0F710:  CLRF   FEC
0F712:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F714:  MOVF   xD5,W
0F716:  MULLW  04
0F718:  MOVF   FF3,W
0F71A:  CLRF   03
0F71C:  ADDLW  D8
0F71E:  MOVWF  01
0F720:  MOVLW  08
0F722:  ADDWFC 03,F
0F724:  MOVFF  01,918
0F728:  MOVFF  03,919
0F72C:  MOVLB  8
0F72E:  MOVF   xD5,W
0F730:  MULLW  04
0F732:  MOVF   FF3,W
0F734:  CLRF   03
0F736:  ADDLW  D8
0F738:  MOVWF  FE9
0F73A:  MOVLW  08
0F73C:  ADDWFC 03,W
0F73E:  MOVWF  FEA
0F740:  MOVFF  FEF,91A
0F744:  MOVFF  FEC,91B
0F748:  MOVFF  FEC,91C
0F74C:  MOVFF  FEC,91D
0F750:  MOVF   xD5,W
0F752:  MULLW  04
0F754:  MOVF   FF3,W
0F756:  CLRF   03
0F758:  ADDLW  F8
0F75A:  MOVWF  FE9
0F75C:  MOVLW  08
0F75E:  ADDWFC 03,W
0F760:  MOVWF  FEA
0F762:  MOVFF  FEF,00
0F766:  MOVFF  FEC,01
0F76A:  MOVFF  FEC,02
0F76E:  MOVFF  FEC,03
0F772:  MOVLB  9
0F774:  MOVF   x1A,W
0F776:  ADDWF  00,F
0F778:  MOVF   x1B,W
0F77A:  ADDWFC 01,F
0F77C:  MOVF   x1C,W
0F77E:  ADDWFC 02,F
0F780:  MOVF   x1D,W
0F782:  ADDWFC 03,F
0F784:  MOVFF  919,FEA
0F788:  MOVFF  918,FE9
0F78C:  MOVFF  00,FEF
0F790:  MOVFF  01,FEC
0F794:  MOVFF  02,FEC
0F798:  MOVFF  03,FEC
0F79C:  MOVLB  8
0F79E:  INCF   xD5,F
0F7A0:  BRA    F6CC
....................       } 
0F7A2:  INCF   xD6,F
0F7A4:  BTFSC  FD8.2
0F7A6:  INCF   xD7,F
0F7A8:  BRA    F6AC
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F7AA:  MOVLW  01
0F7AC:  MOVWF  xD5
0F7AE:  MOVF   xD5,W
0F7B0:  SUBLW  04
0F7B2:  BNC   F826
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F7B4:  BCF    FD8.0
0F7B6:  RLCF   xD5,W
0F7B8:  CLRF   03
0F7BA:  ADDLW  A5
0F7BC:  MOVWF  01
0F7BE:  MOVLW  04
0F7C0:  ADDWFC 03,F
0F7C2:  MOVFF  01,918
0F7C6:  MOVFF  03,919
0F7CA:  MOVLB  8
0F7CC:  MOVF   xD5,W
0F7CE:  MULLW  04
0F7D0:  MOVF   FF3,W
0F7D2:  CLRF   03
0F7D4:  ADDLW  D8
0F7D6:  MOVWF  FE9
0F7D8:  MOVLW  08
0F7DA:  ADDWFC 03,W
0F7DC:  MOVWF  FEA
0F7DE:  MOVFF  FEF,A4C
0F7E2:  MOVFF  FEC,A4D
0F7E6:  MOVFF  FEC,A4E
0F7EA:  MOVFF  FEC,A4F
0F7EE:  BCF    FD8.1
0F7F0:  CLRF   1B
0F7F2:  BTFSC  FF2.7
0F7F4:  BSF    1B.7
0F7F6:  BCF    FF2.7
0F7F8:  MOVLB  A
0F7FA:  CLRF   x53
0F7FC:  CLRF   x52
0F7FE:  MOVFF  8D4,A51
0F802:  MOVFF  8D3,A50
0F806:  MOVLB  0
0F808:  CALL   104E
0F80C:  BTFSC  1B.7
0F80E:  BSF    FF2.7
0F810:  MOVFF  919,FEA
0F814:  MOVFF  918,FE9
0F818:  MOVFF  00,FEF
0F81C:  MOVFF  01,FEC
0F820:  MOVLB  8
0F822:  INCF   xD5,F
0F824:  BRA    F7AE
....................    } 
0F826:  MOVLB  0
0F828:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    //Handle updating variables for the valve timeout 
....................    /*if(valve_align_timeout != -1){ 
....................       fprintf(COM_A,"align_var: %Ld \r\n",valve_align_timeout); 
....................       if(valve_align_timeout >= 2){ 
....................          valve_align_timeout = -1; 
....................          reset_cpu(); 
....................       } 
....................       valve_align_timeout++; 
....................    }*/ 
....................    //Service watchdog 
....................    output_bit(PIN_J7,(!input(PIN_J7))); 
*
00E0C:  BTFSS  F88.7
00E0E:  BRA    0E14
00E10:  BCF    F91.7
00E12:  BRA    0E16
00E14:  BSF    F91.7
....................     
....................    rtc_alarm = TRUE; 
00E16:  BSF    4D.0
....................    sleep_mode = FALSE; 
00E18:  BCF    4D.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E1A:  BTFSS  4D.2
00E1C:  BRA    0E20
....................    { 
....................       ; 
00E1E:  BRA    0E1A
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E20:  BSF    4D.2
....................    RTC_read_flags(); 
00E22:  RCALL  0DD0
....................    ++nv_elapsed; 
00E24:  INCF   35,F
00E26:  BTFSC  FD8.2
00E28:  INCF   36,F
.................... } 
....................  
00E2A:  BCF    FF2.1
00E2C:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E70:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E72:  BTFSC  4D.1
00E74:  BRA    0EC6
....................    { 
....................       if (kbhit(COM_A)) 
00E76:  BTFSS  F9E.5
00E78:  BRA    0EC4
....................       { 
....................          c = getc(COM_A); 
00E7A:  RCALL  0E30
00E7C:  MOVFF  01,A37
....................          switch (c) 
00E80:  MOVLB  A
00E82:  MOVF   x37,W
00E84:  XORLW  3F
00E86:  MOVLB  0
00E88:  BZ    0E94
00E8A:  XORLW  2E
00E8C:  BZ    0EB8
00E8E:  XORLW  0A
00E90:  BZ    0EBE
00E92:  BRA    0EC4
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00E94:  DECFSZ 4E,W
00E96:  BRA    0EA8
00E98:  MOVLW  D0
00E9A:  MOVWF  FF6
00E9C:  MOVLW  0E
00E9E:  MOVWF  FF7
00EA0:  MOVLW  00
00EA2:  MOVWF  FF8
00EA4:  RCALL  0E46
00EA6:  BRA    0EB6
....................                else fprintf(COM_A, "@RDY\r\n"); 
00EA8:  MOVLW  D8
00EAA:  MOVWF  FF6
00EAC:  MOVLW  0E
00EAE:  MOVWF  FF7
00EB0:  MOVLW  00
00EB2:  MOVWF  FF8
00EB4:  RCALL  0E46
....................                break; 
00EB6:  BRA    0EC4
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EB8:  MOVLW  01
00EBA:  MOVWF  50
....................                break;          
00EBC:  BRA    0EC4
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EBE:  CLRF   32
00EC0:  MOVLW  01
00EC2:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EC4:  BRA    0ECA
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EC6:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00EC8:  BCF    F9E.5
....................    } 
00ECA:  BCF    F9E.5
00ECC:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0AEB0:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0AEB2:  MOVF   FAE,W
....................    busy_status = FALSE; 
0AEB4:  CLRF   4E
0AEB6:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
029C0:  MOVLW  01
029C2:  MOVWF  4E
....................    clear_interrupt(INT_RDA); 
029C4:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
029C6:  BSF    F9D.5
029C8:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00EE0:  MOVLW  0B
00EE2:  MOVWF  FD7
00EE4:  MOVLW  DC
00EE6:  MOVWF  FD6
....................    restart_wdt(); 
00EE8:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00EEA:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00EEC:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00EEE:  CLRF   FCF
00EF0:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00EF2:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00EF4:  MOVF   2F,W
00EF6:  SUBLW  02
00EF8:  BNZ   0F00
00EFA:  MOVF   30,F
00EFC:  BNZ   0F00
00EFE:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00F00:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00F02:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00F04:  BCF    FF2.2
00F06:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00F0A:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F0C:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F0E:  MOVF   2F,W
00F10:  SUBLW  02
00F12:  BNZ   0F1A
00F14:  MOVF   30,F
00F16:  BNZ   0F1A
00F18:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F1A:  BCF    F9E.0
00F1C:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
15D3A:  MOVLB  8
15D3C:  CLRF   x8C
15D3E:  CLRF   x90
15D40:  CLRF   x8F
15D42:  CLRF   x8E
15D44:  CLRF   x8D
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
15D46:  MOVLW  01
15D48:  ADDWF  x8D,F
15D4A:  BTFSC  FD8.0
15D4C:  INCF   x8E,F
15D4E:  BTFSC  FD8.2
15D50:  INCF   x8F,F
15D52:  BTFSC  FD8.2
15D54:  INCF   x90,F
15D56:  MOVF   x90,F
15D58:  BNZ   15D9A
15D5A:  MOVF   x8F,W
15D5C:  SUBLW  04
15D5E:  BNC   15D9A
15D60:  BNZ   15D70
15D62:  MOVF   x8E,W
15D64:  SUBLW  93
15D66:  BNC   15D9A
15D68:  BNZ   15D70
15D6A:  MOVF   x8D,W
15D6C:  SUBLW  DF
15D6E:  BNC   15D9A
....................    { 
....................       if(kbhit(COM_A)) 
15D70:  BTFSS  F9E.5
15D72:  BRA    15D90
....................       { 
....................          c = fgetc(COM_A); 
15D74:  MOVLB  0
15D76:  CALL   0E30
15D7A:  MOVFF  01,88C
....................          if (com_echo == TRUE) 
15D7E:  DECFSZ 4C,W
15D80:  BRA    15D8C
....................          { 
....................             fputc(c, COM_A); 
15D82:  MOVLB  8
15D84:  MOVF   x8C,W
15D86:  MOVLB  0
15D88:  CALL   AEB8
....................          } 
....................          break; 
15D8C:  MOVLB  8
15D8E:  BRA    15D9A
....................       } 
....................  
....................       delay_us(10); 
15D90:  MOVLW  35
15D92:  MOVWF  00
15D94:  DECFSZ 00,F
15D96:  BRA    15D94
15D98:  BRA    15D46
....................    } 
....................  
....................    return(c); 
15D9A:  MOVFF  88C,01
15D9E:  MOVLB  0
15DA0:  GOTO   15DB0 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AE2C:  MOVLW  58
0AE2E:  MOVLB  8
0AE30:  MOVWF  x64
0AE32:  CLRF   x68
0AE34:  CLRF   x67
0AE36:  CLRF   x66
0AE38:  CLRF   x65
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AE3A:  MOVLW  01
0AE3C:  ADDWF  x65,F
0AE3E:  BTFSC  FD8.0
0AE40:  INCF   x66,F
0AE42:  BTFSC  FD8.2
0AE44:  INCF   x67,F
0AE46:  BTFSC  FD8.2
0AE48:  INCF   x68,F
0AE4A:  MOVF   x68,F
0AE4C:  BNZ   AE7C
0AE4E:  MOVF   x67,F
0AE50:  BNZ   AE7C
0AE52:  MOVF   x66,W
0AE54:  SUBLW  C3
0AE56:  BNC   AE7C
0AE58:  BNZ   AE60
0AE5A:  MOVF   x65,W
0AE5C:  SUBLW  4F
0AE5E:  BNC   AE7C
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AE60:  MOVLW  05
0AE62:  MOVWF  00
0AE64:  DECFSZ 00,F
0AE66:  BRA    AE64
....................  
....................       if(kbhit()) 
0AE68:  BTFSS  F9E.5
0AE6A:  BRA    AE7A
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AE6C:  MOVLB  0
0AE6E:  CALL   0E30
0AE72:  MOVFF  01,864
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AE76:  MOVLB  8
0AE78:  BRA    AE7C
....................       } 
0AE7A:  BRA    AE3A
....................    } 
....................  
....................    return(EscChar); 
0AE7C:  MOVFF  864,01
0AE80:  MOVLB  0
0AE82:  GOTO   1B9BA (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0DA78:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0DA7A:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0DA7C:  BSF    F8F.3
....................    delay_ms(10); 
0DA7E:  MOVLW  0A
0DA80:  MOVLB  9
0DA82:  MOVWF  xEC
0DA84:  MOVLB  0
0DA86:  CALL   2910
0DA8A:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0DB64:  MOVLB  8
0DB66:  CLRF   xF4
0DB68:  CLRF   xF3
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0DB6A:  MOVLB  F
0DB6C:  BTFSC  x21.1
0DB6E:  BRA    DB7C
....................       ++c; 
0DB70:  MOVLB  8
0DB72:  INCF   xF3,F
0DB74:  BTFSC  FD8.2
0DB76:  INCF   xF4,F
0DB78:  BRA    DB6A
0DB7A:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0DB7C:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0DB7E:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0DB80:  BCF    F8F.3
0DB82:  MOVLB  0
0DB84:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
0FFF4:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0FFF6:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0FFF8:  BCF    F8F.3
0FFFA:  GOTO   17060 (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
*
16F74:  MOVLB  8
16F76:  CLRF   x85
16F78:  CLRF   x86
16F7A:  CLRF   xD7
16F7C:  CLRF   xD8
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16F7E:  MOVLW  20
16F80:  MOVWF  FF6
16F82:  MOVLW  0F
16F84:  MOVWF  FF7
16F86:  MOVLW  00
16F88:  MOVWF  FF8
16F8A:  CLRF   1B
16F8C:  BTFSC  FF2.7
16F8E:  BSF    1B.7
16F90:  BCF    FF2.7
16F92:  MOVLB  0
16F94:  CALL   0E46
16F98:  BTFSC  1B.7
16F9A:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16F9C:  MOVLB  8
16F9E:  MOVF   x86,W
16FA0:  SUBLW  04
16FA2:  BZ    1705A
....................    { 
....................        if (kbhit(COM_A)) 
16FA4:  BTFSS  F9E.5
16FA6:  BRA    1703E
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16FA8:  MOVLB  0
16FAA:  CALL   0E30
16FAE:  MOVFF  01,885
....................           if (com_echo == TRUE) 
16FB2:  DECFSZ 4C,W
16FB4:  BRA    16FC0
....................           { 
....................              fputc(charFromA, COM_A); 
16FB6:  MOVLB  8
16FB8:  MOVF   x85,W
16FBA:  MOVLB  0
16FBC:  CALL   AEB8
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16FC0:  MOVLB  8
16FC2:  MOVF   xD8,W
16FC4:  SUBLW  4F
16FC6:  BNC   1701C
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16FC8:  MOVF   xD8,W
16FCA:  INCF   xD8,F
16FCC:  CLRF   03
16FCE:  ADDLW  87
16FD0:  MOVWF  FE9
16FD2:  MOVLW  08
16FD4:  ADDWFC 03,W
16FD6:  MOVWF  FEA
16FD8:  MOVFF  885,FEF
....................              if (CARRIAGE_RET == charFromA) 
16FDC:  MOVF   x85,W
16FDE:  SUBLW  0D
16FE0:  BNZ   1701A
....................              { 
....................                 multidrop_on(); 
16FE2:  MOVLB  0
16FE4:  CALL   DA78
....................                 for (index = 0 ; index < charCount; index++) 
16FE8:  MOVLB  8
16FEA:  CLRF   xD7
16FEC:  MOVF   xD8,W
16FEE:  SUBWF  xD7,W
16FF0:  BC    17010
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
16FF2:  CLRF   03
16FF4:  MOVF   xD7,W
16FF6:  ADDLW  87
16FF8:  MOVWF  FE9
16FFA:  MOVLW  08
16FFC:  ADDWFC 03,W
16FFE:  MOVWF  FEA
17000:  MOVFF  FEF,8D9
17004:  MOVF   xD9,W
17006:  MOVLB  0
17008:  BRA    16F66
1700A:  MOVLB  8
1700C:  INCF   xD7,F
1700E:  BRA    16FEC
....................                 } 
....................                 charCount = 0; 
17010:  CLRF   xD8
....................                 multidrop_off(); 
17012:  MOVLB  0
17014:  CALL   DB64
17018:  MOVLB  8
....................              } 
....................           } 
1701A:  BRA    1703E
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
1701C:  MOVLW  28
1701E:  MOVWF  FF6
17020:  MOVLW  0F
17022:  MOVWF  FF7
17024:  MOVLW  00
17026:  MOVWF  FF8
17028:  CLRF   1B
1702A:  BTFSC  FF2.7
1702C:  BSF    1B.7
1702E:  BCF    FF2.7
17030:  MOVLB  0
17032:  CALL   0E46
17036:  BTFSC  1B.7
17038:  BSF    FF2.7
....................              charCount = 0; 
1703A:  MOVLB  8
1703C:  CLRF   xD8
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
1703E:  BTFSS  FA4.5
17040:  BRA    17058
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
17042:  MOVLB  0
17044:  CALL   12E38
17048:  MOVFF  01,886
....................           fputc(charFromB, COM_A);                  // send data via USART 
1704C:  MOVLB  8
1704E:  MOVF   x86,W
17050:  MOVLB  0
17052:  CALL   AEB8
17056:  MOVLB  8
....................        } 
17058:  BRA    16F9E
....................    } 
....................  
....................    multidrop_shdn(); 
1705A:  MOVLB  0
1705C:  GOTO   FFF4
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
17060:  MOVLW  38
17062:  MOVWF  FF6
17064:  MOVLW  0F
17066:  MOVWF  FF7
17068:  MOVLW  00
1706A:  MOVWF  FF8
1706C:  CLRF   1B
1706E:  BTFSC  FF2.7
17070:  BSF    1B.7
17072:  BCF    FF2.7
17074:  CALL   0E46
17078:  BTFSC  1B.7
1707A:  BSF    FF2.7
1707C:  GOTO   17096 (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C874:  MOVLB  8
0C876:  DECF   x9F,F
....................    len=0; 
0C878:  CLRF   xA0
....................    do { 
....................      c=getc(); 
0C87A:  MOVLB  0
0C87C:  CALL   0E30
0C880:  MOVFF  01,8A1
....................      if(c==8) {  // Backspace 
0C884:  MOVLB  8
0C886:  MOVF   xA1,W
0C888:  SUBLW  08
0C88A:  BNZ   C8AE
....................         if(len>0) { 
0C88C:  MOVF   xA0,F
0C88E:  BZ    C8AC
....................           len--; 
0C890:  DECF   xA0,F
....................           putc(c); 
0C892:  MOVF   xA1,W
0C894:  MOVLB  0
0C896:  CALL   AEB8
....................           putc(' '); 
0C89A:  MOVLW  20
0C89C:  CALL   AEB8
....................           putc(c); 
0C8A0:  MOVLB  8
0C8A2:  MOVF   xA1,W
0C8A4:  MOVLB  0
0C8A6:  CALL   AEB8
0C8AA:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C8AC:  BRA    C8DC
0C8AE:  MOVF   xA1,W
0C8B0:  SUBLW  1F
0C8B2:  BC    C8DC
0C8B4:  MOVF   xA1,W
0C8B6:  SUBLW  7E
0C8B8:  BNC   C8DC
....................        if(len<=max) { 
0C8BA:  MOVF   xA0,W
0C8BC:  SUBWF  x9F,W
0C8BE:  BNC   C8DC
....................          s[len++]=c; 
0C8C0:  MOVF   xA0,W
0C8C2:  INCF   xA0,F
0C8C4:  ADDWF  x9D,W
0C8C6:  MOVWF  FE9
0C8C8:  MOVLW  00
0C8CA:  ADDWFC x9E,W
0C8CC:  MOVWF  FEA
0C8CE:  MOVFF  8A1,FEF
....................          putc(c); 
0C8D2:  MOVF   xA1,W
0C8D4:  MOVLB  0
0C8D6:  CALL   AEB8
0C8DA:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C8DC:  MOVF   xA1,W
0C8DE:  SUBLW  0D
0C8E0:  BNZ   C87A
....................    s[len]=0; 
0C8E2:  MOVF   xA0,W
0C8E4:  ADDWF  x9D,W
0C8E6:  MOVWF  FE9
0C8E8:  MOVLW  00
0C8EA:  ADDWFC x9E,W
0C8EC:  MOVWF  FEA
0C8EE:  CLRF   FEF
0C8F0:  MOVLB  0
0C8F2:  GOTO   CD18 (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CD06:  MOVLW  08
0CD08:  MOVLB  8
0CD0A:  MOVWF  x9E
0CD0C:  MOVLW  85
0CD0E:  MOVWF  x9D
0CD10:  MOVLW  14
0CD12:  MOVWF  x9F
0CD14:  MOVLB  0
0CD16:  BRA    C874
....................   f = atof(s); 
0CD18:  MOVLW  08
0CD1A:  MOVLB  8
0CD1C:  MOVWF  x9E
0CD1E:  MOVLW  85
0CD20:  MOVWF  x9D
0CD22:  CLRF   xA0
0CD24:  CLRF   x9F
0CD26:  MOVLB  0
0CD28:  BRA    CAAA
0CD2A:  MOVFF  03,89C
0CD2E:  MOVFF  02,89B
0CD32:  MOVFF  01,89A
0CD36:  MOVFF  00,899
....................   return(f); 
0CD3A:  MOVFF  899,00
0CD3E:  MOVFF  89A,01
0CD42:  MOVFF  89B,02
0CD46:  MOVFF  89C,03
0CD4A:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
0293A:  MOVLW  2F
0293C:  MOVWF  F92
....................    set_tris_b(0b00110111); 
0293E:  MOVLW  37
02940:  MOVWF  F93
....................    set_tris_c(0b10010000); 
02942:  MOVLW  90
02944:  MOVWF  F94
....................    set_tris_d(0b00100000); 
02946:  MOVLW  20
02948:  MOVWF  F95
....................    set_tris_e(0b01000000); 
0294A:  MOVLW  40
0294C:  MOVWF  F96
....................    set_tris_f(0b00000000); 
0294E:  MOVLW  00
02950:  MOVWF  F97
....................    set_tris_g(0b11100100); 
02952:  MOVLW  E4
02954:  MOVWF  F98
....................    set_tris_h(0b01000000); 
02956:  MOVLW  40
02958:  MOVWF  F99
....................    set_tris_j(0b00000000); 
0295A:  MOVLW  00
0295C:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
0295E:  BCF    F8E.3
....................    output_low(HB_IN1); 
02960:  BCF    F8E.4
....................    output_low(HB_IN2); 
02962:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
02964:  BCF    F91.3
....................    output_high(EEP_CS);        
02966:  BSF    F91.2
....................    output_high(RTC_CS); 
02968:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
0296A:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
0296C:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
0296E:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
02970:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
02972:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
02974:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
02976:  BCF    F8F.3
....................    delay_ms(20);   
02978:  MOVLW  14
0297A:  MOVLB  9
0297C:  MOVWF  xEC
0297E:  MOVLB  0
02980:  RCALL  2910
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
02982:  BCF    F8E.1
....................    output_low(VDET);     
02984:  BCF    F90.7
....................    bus_pwr_status=0; 
02986:  MOVLB  4
02988:  CLRF   xB6
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
0298A:  BSF    F8C.2
....................    output_high(DAC_CS); 
0298C:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
0298E:  BCF    F8C.0
....................    output_low(HSW2); 
02990:  BCF    F8C.1
....................    heater_stat=0; 
02992:  CLRF   xB5
02994:  MOVLB  0
02996:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
15C68:  BSF    F91.1
....................    output_low(EEP_WP);        
15C6A:  BCF    F91.3
....................    output_high(EEP_CS);        
15C6C:  BSF    F91.2
....................    output_high(RTC_CS);  
15C6E:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
15C70:  BCF    F8E.3
....................    output_low(HB_IN1);        
15C72:  BCF    F8E.4
....................    output_low(HB_IN2); 
15C74:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
15C76:  BCF    F8C.2
....................    output_low(DAC_CS); 
15C78:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
15C7A:  BCF    F8C.0
....................    output_low(HSW2); 
15C7C:  BCF    F8C.1
....................    heater_stat=0; 
15C7E:  MOVLB  4
15C80:  CLRF   xB5
....................    // Power switches 
....................    output_low(VMOT);         
15C82:  BCF    F8E.1
....................    output_low(VDET);  
15C84:  BCF    F90.7
....................    bus_pwr_status=0; 
15C86:  CLRF   xB6
....................    output_low(VENC1);         
15C88:  BCF    F8E.6
....................    output_low(VENC2);         
15C8A:  BCF    F8E.7
....................    output_low(VHBRDG);  
15C8C:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
15C8E:  MOVLW  40
15C90:  MOVWF  FF6
15C92:  MOVLW  0F
15C94:  MOVWF  FF7
15C96:  MOVLW  00
15C98:  MOVWF  FF8
15C9A:  CLRF   1B
15C9C:  BTFSC  FF2.7
15C9E:  BSF    1B.7
15CA0:  BCF    FF2.7
15CA2:  MOVLB  0
15CA4:  CALL   0E46
15CA8:  BTFSC  1B.7
15CAA:  BSF    FF2.7
....................    delay_ms(50); 
15CAC:  MOVLW  32
15CAE:  MOVLB  9
15CB0:  MOVWF  xEC
15CB2:  MOVLB  0
15CB4:  CALL   2910
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
15CB8:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
15CBA:  BSF    F91.6
....................    output_low(MD1_TXEN); 
15CBC:  BCF    F91.5
....................    output_low(MD2_SHDN);    
15CBE:  BCF    F8F.0
....................    output_low(MD2_REN); 
15CC0:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
15CC2:  BCF    F8F.3
....................  
....................    delay_ms(30); 
15CC4:  MOVLW  1E
15CC6:  MOVLB  9
15CC8:  MOVWF  xEC
15CCA:  MOVLB  0
15CCC:  CALL   2910
15CD0:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
0503A:  MOVLB  8
0503C:  CLRF   x89
0503E:  MOVF   x89,W
05040:  SUBLW  02
05042:  BNC   5068
....................       FS_Status = f_mountdrv(); 
05044:  MOVLB  0
05046:  RCALL  4856
05048:  MOVFF  01,724
....................       if (FS_Status) 
0504C:  MOVLB  7
0504E:  MOVF   x24,F
05050:  BZ    505C
....................          { 
....................          display_file_result(FS_Status); 
05052:  MOVFF  724,88A
05056:  MOVLB  0
05058:  BRA    4DF4
....................          } 
0505A:  BRA    5062
....................       else break; 
0505C:  MOVLB  8
0505E:  BRA    5068
05060:  MOVLB  0
05062:  MOVLB  8
05064:  INCF   x89,F
05066:  BRA    503E
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
05068:  MOVLW  3E
0506A:  MOVWF  xEE
0506C:  CLRF   xF0
0506E:  MOVFF  724,8EF
05072:  MOVLB  0
05074:  RCALL  4FD4
....................     
....................    return(FS_Status); 
05076:  MOVLB  7
05078:  MOVFF  724,01
0507C:  MOVLB  0
0507E:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
030FC:  MOVLW  01
030FE:  MOVLB  8
03100:  MOVWF  x64
03102:  MOVF   x64,W
03104:  SUBLW  03
03106:  BNC   3142
....................    { 
....................       output_bit(BOARD_LED, ON); 
03108:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
0310A:  MOVF   2F,W
0310C:  SUBLW  02
0310E:  BNZ   3116
03110:  MOVF   30,F
03112:  BNZ   3116
03114:  BSF    F90.6
....................       delay_ms(32); 
03116:  MOVLW  20
03118:  MOVLB  9
0311A:  MOVWF  xEC
0311C:  MOVLB  0
0311E:  CALL   2910
....................       output_bit(BOARD_LED, OFF); 
03122:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
03124:  MOVF   2F,W
03126:  SUBLW  02
03128:  BNZ   3130
0312A:  MOVF   30,F
0312C:  BNZ   3130
0312E:  BCF    F90.6
....................       delay_ms(32); 
03130:  MOVLW  20
03132:  MOVLB  9
03134:  MOVWF  xEC
03136:  MOVLB  0
03138:  CALL   2910
0313C:  MOVLB  8
0313E:  INCF   x64,F
03140:  BRA    3102
....................    } 
03142:  MOVLB  0
03144:  GOTO   1B7BA (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
050FC:  MOVLB  8
050FE:  CLRF   xF3
05100:  CLRF   xF2
05102:  CLRF   xF1
05104:  CLRF   xF0
....................    set_adc_channel(0,VSS); 
05106:  MOVLW  00
05108:  MOVWF  01
0510A:  MOVF   FC2,W
0510C:  ANDLW  83
0510E:  IORWF  01,W
05110:  MOVWF  FC2
05112:  MOVLW  00
05114:  MOVWF  01
05116:  MOVF   FC1,W
05118:  ANDLW  F8
0511A:  IORWF  01,W
0511C:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
0511E:  MOVLW  01
05120:  MOVWF  xED
05122:  MOVF   xED,W
05124:  SUBLW  32
05126:  BNC   514C
....................       reading=read_adc(); 
05128:  BSF    FC2.1
0512A:  BTFSC  FC2.1
0512C:  BRA    512A
0512E:  MOVFF  FC3,8F4
05132:  MOVFF  FC4,8F5
05136:  CLRF   xF6
05138:  CLRF   xF7
....................       delay_ms(5); 
0513A:  MOVLW  05
0513C:  MOVLB  9
0513E:  MOVWF  xEC
05140:  MOVLB  0
05142:  CALL   2910
05146:  MOVLB  8
05148:  INCF   xED,F
0514A:  BRA    5122
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
0514C:  MOVLW  01
0514E:  MOVWF  xED
05150:  MOVF   xED,W
05152:  SUBLW  64
05154:  BNC   5202
....................       reading=read_adc(); 
05156:  BSF    FC2.1
05158:  BTFSC  FC2.1
0515A:  BRA    5158
0515C:  MOVFF  FC3,8F4
05160:  MOVFF  FC4,8F5
05164:  CLRF   xF6
05166:  CLRF   xF7
....................       result=(((result*(i-1))+reading)/i); 
05168:  MOVLW  01
0516A:  SUBWF  xED,W
0516C:  MOVWF  xF8
0516E:  MOVFF  8F3,9F9
05172:  MOVFF  8F2,9F8
05176:  MOVFF  8F1,9F7
0517A:  MOVFF  8F0,9F6
0517E:  MOVLB  9
05180:  CLRF   xFD
05182:  CLRF   xFC
05184:  CLRF   xFB
05186:  MOVWF  xFA
05188:  MOVLB  0
0518A:  CALL   47F0
0518E:  MOVFF  03,8FB
05192:  MOVFF  02,8FA
05196:  MOVFF  01,8F9
0519A:  MOVFF  00,8F8
0519E:  MOVLB  8
051A0:  MOVF   xF4,W
051A2:  ADDWF  xF8,F
051A4:  MOVF   xF5,W
051A6:  ADDWFC xF9,F
051A8:  MOVF   xF6,W
051AA:  ADDWFC xFA,F
051AC:  MOVF   xF7,W
051AE:  ADDWFC xFB,F
051B0:  BCF    FD8.1
051B2:  CLRF   1B
051B4:  BTFSC  FF2.7
051B6:  BSF    1B.7
051B8:  BCF    FF2.7
051BA:  MOVFF  8FB,A4F
051BE:  MOVFF  8FA,A4E
051C2:  MOVFF  8F9,A4D
051C6:  MOVFF  8F8,A4C
051CA:  MOVLB  A
051CC:  CLRF   x53
051CE:  CLRF   x52
051D0:  CLRF   x51
051D2:  MOVFF  8ED,A50
051D6:  MOVLB  0
051D8:  CALL   104E
051DC:  BTFSC  1B.7
051DE:  BSF    FF2.7
051E0:  MOVFF  03,8F3
051E4:  MOVFF  02,8F2
051E8:  MOVFF  01,8F1
051EC:  MOVFF  00,8F0
....................       delay_ms(5); 
051F0:  MOVLW  05
051F2:  MOVLB  9
051F4:  MOVWF  xEC
051F6:  MOVLB  0
051F8:  CALL   2910
051FC:  MOVLB  8
051FE:  INCF   xED,F
05200:  BRA    5150
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
05202:  MOVFF  8F3,9F9
05206:  MOVFF  8F2,9F8
0520A:  MOVFF  8F1,9F7
0520E:  MOVFF  8F0,9F6
05212:  MOVLB  9
05214:  CLRF   xFD
05216:  CLRF   xFC
05218:  CLRF   xFB
0521A:  MOVLW  64
0521C:  MOVWF  xFA
0521E:  MOVLB  0
05220:  CALL   47F0
05224:  MOVFF  03,8FB
05228:  MOVFF  02,8FA
0522C:  MOVFF  01,8F9
05230:  MOVFF  00,8F8
05234:  BCF    FD8.1
05236:  CLRF   1B
05238:  BTFSC  FF2.7
0523A:  BSF    1B.7
0523C:  BCF    FF2.7
0523E:  MOVFF  03,A4F
05242:  MOVFF  02,A4E
05246:  MOVFF  01,A4D
0524A:  MOVFF  00,A4C
0524E:  MOVLB  A
05250:  CLRF   x53
05252:  CLRF   x52
05254:  MOVLW  01
05256:  MOVWF  x51
05258:  MOVLW  10
0525A:  MOVWF  x50
0525C:  MOVLB  0
0525E:  CALL   104E
05262:  BTFSC  1B.7
05264:  BSF    FF2.7
05266:  MOVLW  56
05268:  MOVLB  8
0526A:  ADDWF  00,W
0526C:  MOVWF  xEE
0526E:  MOVLW  00
05270:  ADDWFC 01,W
05272:  MOVWF  xEF
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
05274:  MOVFF  8EE,01
05278:  MOVFF  8EF,02
0527C:  MOVLB  0
0527E:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
050E6:  MOVLW  02
050E8:  MOVWF  FEA
050EA:  MOVLW  99
050EC:  MOVWF  FE9
050EE:  CLRF   00
050F0:  CLRF   02
050F2:  MOVLW  1E
050F4:  MOVWF  01
050F6:  CALL   3526
050FA:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12D60:  MOVLW  02
12D62:  MOVWF  FEA
12D64:  MOVLW  B7
12D66:  MOVWF  FE9
12D68:  CLRF   00
12D6A:  CLRF   02
12D6C:  MOVLW  1E
12D6E:  MOVWF  01
12D70:  CALL   3526
12D74:  GOTO   1301C (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
0541A:  RCALL  50E6
....................     
....................    v_supply = read_supply(); 
0541C:  RCALL  50FC
0541E:  MOVFF  02,8EC
05422:  MOVFF  01,8EB
....................    RTC_read(); 
05426:  CALL   3344
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
0542A:  MOVLW  02
0542C:  MOVWF  1E
0542E:  MOVLW  99
05430:  MOVWF  1D
05432:  MOVFF  72A,8ED
05436:  MOVLW  01
05438:  MOVLB  8
0543A:  MOVWF  xEE
0543C:  MOVLB  0
0543E:  RCALL  5280
05440:  MOVLW  2F
05442:  MOVLB  8
05444:  MOVWF  xFF
05446:  MOVLB  0
05448:  RCALL  509E
0544A:  MOVFF  729,8ED
0544E:  MOVLW  01
05450:  MOVLB  8
05452:  MOVWF  xEE
05454:  MOVLB  0
05456:  RCALL  5280
05458:  MOVLW  2F
0545A:  MOVLB  8
0545C:  MOVWF  xFF
0545E:  MOVLB  0
05460:  RCALL  509E
05462:  MOVFF  72B,8ED
05466:  MOVLW  01
05468:  MOVLB  8
0546A:  MOVWF  xEE
0546C:  MOVLB  0
0546E:  RCALL  5280
05470:  MOVLW  20
05472:  MOVLB  8
05474:  MOVWF  xFF
05476:  MOVLB  0
05478:  RCALL  509E
0547A:  MOVFF  727,8ED
0547E:  MOVLW  01
05480:  MOVLB  8
05482:  MOVWF  xEE
05484:  MOVLB  0
05486:  RCALL  5280
05488:  MOVLW  3A
0548A:  MOVLB  8
0548C:  MOVWF  xFF
0548E:  MOVLB  0
05490:  RCALL  509E
05492:  MOVFF  726,8ED
05496:  MOVLW  01
05498:  MOVLB  8
0549A:  MOVWF  xEE
0549C:  MOVLB  0
0549E:  RCALL  5280
054A0:  MOVLW  3A
054A2:  MOVLB  8
054A4:  MOVWF  xFF
054A6:  MOVLB  0
054A8:  RCALL  509E
054AA:  MOVFF  725,8ED
054AE:  MOVLW  01
054B0:  MOVLB  8
054B2:  MOVWF  xEE
054B4:  MOVLB  0
054B6:  RCALL  5280
054B8:  MOVLW  2C
054BA:  MOVLB  8
054BC:  MOVWF  xFF
054BE:  MOVLB  0
054C0:  RCALL  509E
054C2:  MOVLW  44
054C4:  MOVWF  FE9
054C6:  MOVLB  8
054C8:  CLRF   xF0
054CA:  CLRF   xEF
054CC:  MOVFF  8EC,8EE
054D0:  MOVFF  8EB,8ED
054D4:  MOVLW  02
054D6:  MOVWF  xF1
054D8:  MOVLB  0
054DA:  RCALL  531A
054DC:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
084DA:  MOVLB  2
084DC:  MOVF   xDC,F
084DE:  BNZ   855A
....................    { 
....................       strcopy(event_buffer,""); 
084E0:  MOVLW  01
084E2:  MOVWF  FEA
084E4:  MOVLW  07
084E6:  MOVWF  FE9
084E8:  MOVLW  00
084EA:  MOVLB  0
084EC:  CALL   02CE
084F0:  TBLRD*-
084F2:  TBLRD*+
084F4:  MOVF   FF5,W
084F6:  MOVWF  FEE
084F8:  IORLW  00
084FA:  BNZ   84F2
....................       time_stamp(); 
084FC:  CALL   541A
....................       strcat(event_buffer, time_stmp_str); 
08500:  MOVLW  01
08502:  MOVLB  8
08504:  MOVWF  xF9
08506:  MOVLW  07
08508:  MOVWF  xF8
0850A:  MOVLW  02
0850C:  MOVWF  xFB
0850E:  MOVLW  99
08510:  MOVWF  xFA
08512:  MOVLB  0
08514:  CALL   54DE
....................       strcat(event_buffer, event_str); 
08518:  MOVLW  01
0851A:  MOVLB  8
0851C:  MOVWF  xF9
0851E:  MOVLW  07
08520:  MOVWF  xF8
08522:  MOVLW  01
08524:  MOVWF  xFB
08526:  MOVLW  A7
08528:  MOVWF  xFA
0852A:  MOVLB  0
0852C:  CALL   54DE
....................       buffer_select = 1; 
08530:  MOVLW  01
08532:  MOVWF  x66
....................     
....................       heartbeat(FALSE); 
08534:  MOVLB  8
08536:  CLRF   xED
08538:  MOVLB  0
0853A:  CALL   5586
....................          append_data(file_ptr_events); 
0853E:  MOVLW  03
08540:  MOVLB  8
08542:  MOVWF  xEE
08544:  MOVLW  15
08546:  MOVWF  xED
08548:  MOVLB  0
0854A:  RCALL  82F8
....................       heartbeat(TRUE); 
0854C:  MOVLW  01
0854E:  MOVLB  8
08550:  MOVWF  xED
08552:  MOVLB  0
08554:  CALL   5586
08558:  MOVLB  2
....................    } 
0855A:  MOVLB  0
0855C:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
028C4:  BCF    F8B.2
028C6:  MOVLW  0C
028C8:  MOVWF  FBB
028CA:  CLRF   FBE
028CC:  CLRF   FBF
028CE:  MOVLW  01
028D0:  MOVWF  F9C
028D2:  MOVLW  F8
028D4:  MOVLB  F
028D6:  ANDWF  x2D,F
028D8:  MOVLW  00
028DA:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
028DC:  BCF    F8B.1
028DE:  MOVLW  0C
028E0:  MOVWF  x4E
028E2:  CLRF   x51
028E4:  CLRF   x52
028E6:  MOVLW  01
028E8:  MOVWF  x1B
028EA:  MOVLW  C7
028EC:  ANDWF  x2D,F
028EE:  MOVLW  00
028F0:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
028F2:  IORLW  05
028F4:  MOVWF  FCA
028F6:  MOVLW  7F
028F8:  MOVWF  FCB
028FA:  MOVLB  0
028FC:  GOTO   1B770 (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09D02:  MOVLW  4A
09D04:  MOVWF  FF6
09D06:  MOVLW  0F
09D08:  MOVWF  FF7
09D0A:  MOVLW  00
09D0C:  MOVWF  FF8
09D0E:  CLRF   1B
09D10:  BTFSC  FF2.7
09D12:  BSF    1B.7
09D14:  BCF    FF2.7
09D16:  MOVLW  05
09D18:  MOVLB  A
09D1A:  MOVWF  x40
09D1C:  MOVLB  0
09D1E:  CALL   101C
09D22:  BTFSC  1B.7
09D24:  BSF    FF2.7
09D26:  MOVLW  10
09D28:  MOVWF  FE9
09D2A:  CLRF   1B
09D2C:  BTFSC  FF2.7
09D2E:  BSF    1B.7
09D30:  BCF    FF2.7
09D32:  MOVFF  797,A41
09D36:  MOVFF  796,A40
09D3A:  CALL   119E
09D3E:  BTFSC  1B.7
09D40:  BSF    FF2.7
09D42:  MOVLW  2C
09D44:  BTFSS  F9E.4
09D46:  BRA    9D44
09D48:  MOVWF  FAD
09D4A:  MOVLW  10
09D4C:  MOVWF  FE9
09D4E:  CLRF   1B
09D50:  BTFSC  FF2.7
09D52:  BSF    1B.7
09D54:  BCF    FF2.7
09D56:  MOVFF  799,A41
09D5A:  MOVFF  798,A40
09D5E:  CALL   119E
09D62:  BTFSC  1B.7
09D64:  BSF    FF2.7
09D66:  MOVLW  0D
09D68:  BTFSS  F9E.4
09D6A:  BRA    9D68
09D6C:  MOVWF  FAD
09D6E:  MOVLW  0A
09D70:  BTFSS  F9E.4
09D72:  BRA    9D70
09D74:  MOVWF  FAD
09D76:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02D1A:  MOVLW  86
02D1C:  MOVLB  8
02D1E:  MOVWF  x97
02D20:  MOVLB  0
02D22:  RCALL  29CA
02D24:  MOVFF  02,743
02D28:  MOVFF  01,742
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02D2C:  MOVLW  8A
02D2E:  MOVLB  8
02D30:  MOVWF  x97
02D32:  MOVLB  0
02D34:  RCALL  29CA
02D36:  MOVFF  02,747
02D3A:  MOVFF  01,746
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02D3E:  MOVLW  8E
02D40:  MOVLB  8
02D42:  MOVWF  x97
02D44:  MOVLB  0
02D46:  RCALL  29CA
02D48:  MOVFF  02,74B
02D4C:  MOVFF  01,74A
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02D50:  MOVLW  92
02D52:  MOVLB  8
02D54:  MOVWF  x97
02D56:  MOVLB  0
02D58:  RCALL  29CA
02D5A:  MOVFF  02,74F
02D5E:  MOVFF  01,74E
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02D62:  MOVLW  96
02D64:  MOVLB  8
02D66:  MOVWF  x97
02D68:  MOVLB  0
02D6A:  RCALL  29CA
02D6C:  MOVFF  02,753
02D70:  MOVFF  01,752
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02D74:  MOVLW  9A
02D76:  MOVLB  8
02D78:  MOVWF  x97
02D7A:  MOVLB  0
02D7C:  RCALL  29CA
02D7E:  MOVFF  02,757
02D82:  MOVFF  01,756
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02D86:  MOVLW  9E
02D88:  MOVLB  8
02D8A:  MOVWF  x97
02D8C:  MOVLB  0
02D8E:  RCALL  29CA
02D90:  MOVFF  02,75B
02D94:  MOVFF  01,75A
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02D98:  MOVLW  A2
02D9A:  MOVLB  8
02D9C:  MOVWF  x97
02D9E:  MOVLB  0
02DA0:  RCALL  29CA
02DA2:  MOVFF  02,75F
02DA6:  MOVFF  01,75E
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02DAA:  MOVLW  A6
02DAC:  MOVLB  8
02DAE:  MOVWF  x97
02DB0:  MOVLB  0
02DB2:  RCALL  29CA
02DB4:  MOVFF  02,763
02DB8:  MOVFF  01,762
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02DBC:  MOVLW  82
02DBE:  MOVLB  8
02DC0:  MOVWF  x97
02DC2:  MOVLB  0
02DC4:  RCALL  29CA
02DC6:  MOVFF  02,767
02DCA:  MOVFF  01,766
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02DCE:  MOVLW  7E
02DD0:  MOVLB  8
02DD2:  MOVWF  x97
02DD4:  MOVLB  0
02DD6:  RCALL  29CA
02DD8:  MOVFF  02,7C0
02DDC:  MOVFF  01,7BF
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02DE0:  MOVLW  AA
02DE2:  MOVLB  8
02DE4:  MOVWF  x97
02DE6:  MOVLB  0
02DE8:  RCALL  29CA
02DEA:  MOVFF  02,7C4
02DEE:  MOVFF  01,7C3
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02DF2:  MOVLW  7A
02DF4:  MOVLB  8
02DF6:  MOVWF  x97
02DF8:  MOVLB  0
02DFA:  RCALL  29CA
02DFC:  MOVFF  02,76B
02E00:  MOVFF  01,76A
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02E04:  MOVLW  76
02E06:  MOVLB  8
02E08:  MOVWF  x97
02E0A:  MOVLB  0
02E0C:  RCALL  29CA
02E0E:  MOVFF  02,76F
02E12:  MOVFF  01,76E
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02E16:  MOVLW  72
02E18:  MOVLB  8
02E1A:  MOVWF  x97
02E1C:  MOVLB  0
02E1E:  RCALL  29CA
02E20:  MOVFF  02,773
02E24:  MOVFF  01,772
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02E28:  MOVLW  6E
02E2A:  MOVLB  8
02E2C:  MOVWF  x97
02E2E:  MOVLB  0
02E30:  RCALL  29CA
02E32:  MOVFF  02,797
02E36:  MOVFF  01,796
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02E3A:  MOVLW  AE
02E3C:  MOVLB  8
02E3E:  MOVWF  x97
02E40:  MOVLB  0
02E42:  RCALL  29CA
02E44:  MOVFF  02,777
02E48:  MOVFF  01,776
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02E4C:  MOVLW  B2
02E4E:  MOVLB  8
02E50:  MOVWF  x97
02E52:  MOVLB  0
02E54:  RCALL  29CA
02E56:  MOVFF  02,7B0
02E5A:  MOVFF  01,7AF
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02E5E:  MOVLW  B6
02E60:  MOVLB  8
02E62:  MOVWF  x97
02E64:  MOVLB  0
02E66:  RCALL  29CA
02E68:  MOVFF  02,7B4
02E6C:  MOVFF  01,7B3
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02E70:  MOVLW  BA
02E72:  MOVLB  8
02E74:  MOVWF  x97
02E76:  MOVLB  0
02E78:  RCALL  29CA
02E7A:  MOVFF  02,77B
02E7E:  MOVFF  01,77A
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02E82:  MOVLW  BE
02E84:  MOVLB  8
02E86:  MOVWF  x97
02E88:  MOVLB  0
02E8A:  RCALL  29CA
02E8C:  MOVFF  02,77F
02E90:  MOVFF  01,77E
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02E94:  MOVLW  C2
02E96:  MOVLB  8
02E98:  MOVWF  x97
02E9A:  MOVLB  0
02E9C:  RCALL  29CA
02E9E:  MOVFF  02,783
02EA2:  MOVFF  01,782
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02EA6:  MOVLW  88
02EA8:  MOVLB  8
02EAA:  MOVWF  x97
02EAC:  MOVLB  0
02EAE:  RCALL  29CA
02EB0:  MOVFF  02,745
02EB4:  MOVFF  01,744
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02EB8:  MOVLW  8C
02EBA:  MOVLB  8
02EBC:  MOVWF  x97
02EBE:  MOVLB  0
02EC0:  RCALL  29CA
02EC2:  MOVFF  02,749
02EC6:  MOVFF  01,748
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02ECA:  MOVLW  90
02ECC:  MOVLB  8
02ECE:  MOVWF  x97
02ED0:  MOVLB  0
02ED2:  RCALL  29CA
02ED4:  MOVFF  02,74D
02ED8:  MOVFF  01,74C
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02EDC:  MOVLW  94
02EDE:  MOVLB  8
02EE0:  MOVWF  x97
02EE2:  MOVLB  0
02EE4:  RCALL  29CA
02EE6:  MOVFF  02,751
02EEA:  MOVFF  01,750
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02EEE:  MOVLW  98
02EF0:  MOVLB  8
02EF2:  MOVWF  x97
02EF4:  MOVLB  0
02EF6:  RCALL  29CA
02EF8:  MOVFF  02,755
02EFC:  MOVFF  01,754
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02F00:  MOVLW  9C
02F02:  MOVLB  8
02F04:  MOVWF  x97
02F06:  MOVLB  0
02F08:  RCALL  29CA
02F0A:  MOVFF  02,759
02F0E:  MOVFF  01,758
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02F12:  MOVLW  A0
02F14:  MOVLB  8
02F16:  MOVWF  x97
02F18:  MOVLB  0
02F1A:  RCALL  29CA
02F1C:  MOVFF  02,75D
02F20:  MOVFF  01,75C
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02F24:  MOVLW  A4
02F26:  MOVLB  8
02F28:  MOVWF  x97
02F2A:  MOVLB  0
02F2C:  RCALL  29CA
02F2E:  MOVFF  02,761
02F32:  MOVFF  01,760
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02F36:  MOVLW  A8
02F38:  MOVLB  8
02F3A:  MOVWF  x97
02F3C:  MOVLB  0
02F3E:  RCALL  29CA
02F40:  MOVFF  02,765
02F44:  MOVFF  01,764
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02F48:  MOVLW  84
02F4A:  MOVLB  8
02F4C:  MOVWF  x97
02F4E:  MOVLB  0
02F50:  RCALL  29CA
02F52:  MOVFF  02,769
02F56:  MOVFF  01,768
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02F5A:  MOVLW  80
02F5C:  MOVLB  8
02F5E:  MOVWF  x97
02F60:  MOVLB  0
02F62:  RCALL  29CA
02F64:  MOVFF  02,7C2
02F68:  MOVFF  01,7C1
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02F6C:  MOVLW  AC
02F6E:  MOVLB  8
02F70:  MOVWF  x97
02F72:  MOVLB  0
02F74:  RCALL  29CA
02F76:  MOVFF  02,7C6
02F7A:  MOVFF  01,7C5
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02F7E:  MOVLW  7C
02F80:  MOVLB  8
02F82:  MOVWF  x97
02F84:  MOVLB  0
02F86:  RCALL  29CA
02F88:  MOVFF  02,76D
02F8C:  MOVFF  01,76C
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02F90:  MOVLW  78
02F92:  MOVLB  8
02F94:  MOVWF  x97
02F96:  MOVLB  0
02F98:  RCALL  29CA
02F9A:  MOVFF  02,771
02F9E:  MOVFF  01,770
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02FA2:  MOVLW  74
02FA4:  MOVLB  8
02FA6:  MOVWF  x97
02FA8:  MOVLB  0
02FAA:  RCALL  29CA
02FAC:  MOVFF  02,775
02FB0:  MOVFF  01,774
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02FB4:  MOVLW  70
02FB6:  MOVLB  8
02FB8:  MOVWF  x97
02FBA:  MOVLB  0
02FBC:  RCALL  29CA
02FBE:  MOVFF  02,799
02FC2:  MOVFF  01,798
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02FC6:  MOVLW  B0
02FC8:  MOVLB  8
02FCA:  MOVWF  x97
02FCC:  MOVLB  0
02FCE:  RCALL  29CA
02FD0:  MOVFF  02,779
02FD4:  MOVFF  01,778
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
02FD8:  MOVLW  B4
02FDA:  MOVLB  8
02FDC:  MOVWF  x97
02FDE:  MOVLB  0
02FE0:  RCALL  29CA
02FE2:  MOVFF  02,7B2
02FE6:  MOVFF  01,7B1
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
02FEA:  MOVLW  B8
02FEC:  MOVLB  8
02FEE:  MOVWF  x97
02FF0:  MOVLB  0
02FF2:  RCALL  29CA
02FF4:  MOVFF  02,7B6
02FF8:  MOVFF  01,7B5
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
02FFC:  MOVLW  BC
02FFE:  MOVLB  8
03000:  MOVWF  x97
03002:  MOVLB  0
03004:  RCALL  29CA
03006:  MOVFF  02,77D
0300A:  MOVFF  01,77C
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
0300E:  MOVLW  C0
03010:  MOVLB  8
03012:  MOVWF  x97
03014:  MOVLB  0
03016:  RCALL  29CA
03018:  MOVFF  02,781
0301C:  MOVFF  01,780
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
03020:  MOVLW  C4
03022:  MOVLB  8
03024:  MOVWF  x97
03026:  MOVLB  0
03028:  RCALL  29CA
0302A:  MOVFF  02,785
0302E:  MOVFF  01,784
....................     
....................    motor=0; 
03032:  MOVLB  7
03034:  CLRF   x40
....................    m_fixed=1; 
03036:  MOVLW  01
03038:  MOVWF  x41
....................    m_step_cnt[0]=0; 
0303A:  CLRF   xA5
0303C:  CLRF   xA4
0303E:  CLRF   xA3
03040:  CLRF   xA2
....................    m_step_cnt[1]=0; 
03042:  CLRF   xA9
03044:  CLRF   xA8
03046:  CLRF   xA7
03048:  CLRF   xA6
....................    e_cha_cnt[0]=0; 
0304A:  CLRF   xBC
0304C:  CLRF   xBB
....................    e_cha_cnt[1]=0;  
0304E:  CLRF   xBE
03050:  CLRF   xBD
....................    m_gb_cnt[0]=0; 
03052:  CLRF   x9B
03054:  CLRF   x9A
....................    m_gb_cnt[1]=0; 
03056:  CLRF   x9D
03058:  CLRF   x9C
....................    e_mode_rst[0]=0; 
0305A:  CLRF   x9F
0305C:  CLRF   x9E
....................    e_mode_rst[1]=0;    
0305E:  CLRF   xA1
03060:  CLRF   xA0
....................    e_port_dist[0]=0; 
03062:  CLRF   xB8
03064:  CLRF   xB7
....................    e_port_dist[1]=0; 
03066:  CLRF   xBA
03068:  CLRF   xB9
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
0306A:  MOVFF  777,8DC
0306E:  MOVFF  776,8DB
03072:  MOVFF  763,8DE
03076:  MOVFF  762,8DD
0307A:  MOVLB  0
0307C:  RCALL  2CD4
0307E:  BCF    FD8.0
03080:  MOVLB  8
03082:  RLCF   01,W
03084:  MOVLB  7
03086:  MOVWF  xAB
03088:  MOVLB  8
0308A:  RLCF   02,W
0308C:  MOVLB  7
0308E:  MOVWF  xAC
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
03090:  MOVFF  779,8DC
03094:  MOVFF  778,8DB
03098:  MOVFF  765,8DE
0309C:  MOVFF  764,8DD
030A0:  MOVLB  0
030A2:  RCALL  2CD4
030A4:  BCF    FD8.0
030A6:  MOVLB  8
030A8:  RLCF   01,W
030AA:  MOVLB  7
030AC:  MOVWF  xAD
030AE:  MOVLB  8
030B0:  RLCF   02,W
030B2:  MOVLB  7
030B4:  MOVWF  xAE
030B6:  MOVLB  0
030B8:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
1A0FE:  MOVLW  86
1A100:  MOVLB  8
1A102:  MOVWF  xEE
1A104:  CLRF   xF0
1A106:  MOVLW  01
1A108:  MOVWF  xEF
1A10A:  MOVLB  0
1A10C:  CALL   4FD4
....................    write16(ADDR_M1_MODE,FULL); 
1A110:  MOVLW  8A
1A112:  MOVLB  8
1A114:  MOVWF  xEE
1A116:  CLRF   xF0
1A118:  CLRF   xEF
1A11A:  MOVLB  0
1A11C:  CALL   4FD4
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A120:  MOVLW  8E
1A122:  MOVLB  8
1A124:  MOVWF  xEE
1A126:  CLRF   xF0
1A128:  MOVLW  0A
1A12A:  MOVWF  xEF
1A12C:  MOVLB  0
1A12E:  CALL   4FD4
....................    write16(ADDR_M1_POS_DIR,0); 
1A132:  MOVLW  92
1A134:  MOVLB  8
1A136:  MOVWF  xEE
1A138:  CLRF   xF0
1A13A:  CLRF   xEF
1A13C:  MOVLB  0
1A13E:  CALL   4FD4
....................    write16(ADDR_M1_PWM_HLD,0); 
1A142:  MOVLW  96
1A144:  MOVLB  8
1A146:  MOVWF  xEE
1A148:  CLRF   xF0
1A14A:  CLRF   xEF
1A14C:  MOVLB  0
1A14E:  CALL   4FD4
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A152:  MOVLW  9A
1A154:  MOVLB  8
1A156:  MOVWF  xEE
1A158:  CLRF   xF0
1A15A:  MOVLW  7F
1A15C:  MOVWF  xEF
1A15E:  MOVLB  0
1A160:  CALL   4FD4
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A164:  MOVLW  9E
1A166:  MOVLB  8
1A168:  MOVWF  xEE
1A16A:  MOVLW  17
1A16C:  MOVWF  xF0
1A16E:  MOVLW  70
1A170:  MOVWF  xEF
1A172:  MOVLB  0
1A174:  CALL   4FD4
....................    write16(ADDR_E1_CPR,16); 
1A178:  MOVLW  A2
1A17A:  MOVLB  8
1A17C:  MOVWF  xEE
1A17E:  CLRF   xF0
1A180:  MOVLW  10
1A182:  MOVWF  xEF
1A184:  MOVLB  0
1A186:  CALL   4FD4
....................    write16(ADDR_E1_PPR,16); 
1A18A:  MOVLW  A6
1A18C:  MOVLB  8
1A18E:  MOVWF  xEE
1A190:  CLRF   xF0
1A192:  MOVLW  10
1A194:  MOVWF  xEF
1A196:  MOVLB  0
1A198:  CALL   4FD4
....................    write16(ADDR_E1_MODE,2); 
1A19C:  MOVLW  82
1A19E:  MOVLB  8
1A1A0:  MOVWF  xEE
1A1A2:  CLRF   xF0
1A1A4:  MOVLW  02
1A1A6:  MOVWF  xEF
1A1A8:  MOVLB  0
1A1AA:  CALL   4FD4
....................    write16(ADDR_E1_POS,0); 
1A1AE:  MOVLW  7E
1A1B0:  MOVLB  8
1A1B2:  MOVWF  xEE
1A1B4:  CLRF   xF0
1A1B6:  CLRF   xEF
1A1B8:  MOVLB  0
1A1BA:  CALL   4FD4
....................    write16(ADDR_E1_PORT,0); 
1A1BE:  MOVLW  AA
1A1C0:  MOVLB  8
1A1C2:  MOVWF  xEE
1A1C4:  CLRF   xF0
1A1C6:  CLRF   xEF
1A1C8:  MOVLB  0
1A1CA:  CALL   4FD4
....................    write16(ADDR_E1_TYPE,2); 
1A1CE:  MOVLW  7A
1A1D0:  MOVLB  8
1A1D2:  MOVWF  xEE
1A1D4:  CLRF   xF0
1A1D6:  MOVLW  02
1A1D8:  MOVWF  xEF
1A1DA:  MOVLB  0
1A1DC:  CALL   4FD4
....................    write16(ADDR_M1_RUN,270); 
1A1E0:  MOVLW  76
1A1E2:  MOVLB  8
1A1E4:  MOVWF  xEE
1A1E6:  MOVLW  01
1A1E8:  MOVWF  xF0
1A1EA:  MOVLW  0E
1A1EC:  MOVWF  xEF
1A1EE:  MOVLB  0
1A1F0:  CALL   4FD4
....................    write16(ADDR_M1_BKLSH,0); 
1A1F4:  MOVLW  72
1A1F6:  MOVLB  8
1A1F8:  MOVWF  xEE
1A1FA:  CLRF   xF0
1A1FC:  CLRF   xEF
1A1FE:  MOVLB  0
1A200:  CALL   4FD4
....................    write16(ADDR_M1_ERROR,0);   
1A204:  MOVLW  6E
1A206:  MOVLB  8
1A208:  MOVWF  xEE
1A20A:  CLRF   xF0
1A20C:  CLRF   xEF
1A20E:  MOVLB  0
1A210:  CALL   4FD4
....................    write16(ADDR_M1_SPR,38400); 
1A214:  MOVLW  AE
1A216:  MOVLB  8
1A218:  MOVWF  xEE
1A21A:  MOVLW  96
1A21C:  MOVWF  xF0
1A21E:  CLRF   xEF
1A220:  MOVLB  0
1A222:  CALL   4FD4
....................    write16(ADDR_M1_COMP,0); 
1A226:  MOVLW  B2
1A228:  MOVLB  8
1A22A:  MOVWF  xEE
1A22C:  CLRF   xF0
1A22E:  CLRF   xEF
1A230:  MOVLB  0
1A232:  CALL   4FD4
....................    write16(ADDR_M1_LIN_POS,0); 
1A236:  MOVLW  B6
1A238:  MOVLB  8
1A23A:  MOVWF  xEE
1A23C:  CLRF   xF0
1A23E:  CLRF   xEF
1A240:  MOVLB  0
1A242:  CALL   4FD4
....................    write16(ADDR_E1_INDEX,1); 
1A246:  MOVLW  BA
1A248:  MOVLB  8
1A24A:  MOVWF  xEE
1A24C:  CLRF   xF0
1A24E:  MOVLW  01
1A250:  MOVWF  xEF
1A252:  MOVLB  0
1A254:  CALL   4FD4
....................    write16(ADDR_M1_EVN_SO,0); 
1A258:  MOVLW  BE
1A25A:  MOVLB  8
1A25C:  MOVWF  xEE
1A25E:  CLRF   xF0
1A260:  CLRF   xEF
1A262:  MOVLB  0
1A264:  CALL   4FD4
....................    write16(ADDR_M1_ALIGN_OS,0); 
1A268:  MOVLW  C2
1A26A:  MOVLB  8
1A26C:  MOVWF  xEE
1A26E:  CLRF   xF0
1A270:  CLRF   xEF
1A272:  MOVLB  0
1A274:  CALL   4FD4
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A278:  MOVLW  88
1A27A:  MOVLB  8
1A27C:  MOVWF  xEE
1A27E:  CLRF   xF0
1A280:  MOVLW  01
1A282:  MOVWF  xEF
1A284:  MOVLB  0
1A286:  CALL   4FD4
....................    write16(ADDR_M2_MODE,HALF); 
1A28A:  MOVLW  8C
1A28C:  MOVLB  8
1A28E:  MOVWF  xEE
1A290:  CLRF   xF0
1A292:  MOVLW  01
1A294:  MOVWF  xEF
1A296:  MOVLB  0
1A298:  CALL   4FD4
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
1A29C:  MOVLW  90
1A29E:  MOVLB  8
1A2A0:  MOVWF  xEE
1A2A2:  CLRF   xF0
1A2A4:  MOVLW  05
1A2A6:  MOVWF  xEF
1A2A8:  MOVLB  0
1A2AA:  CALL   4FD4
....................    write16(ADDR_M2_POS_DIR,0); 
1A2AE:  MOVLW  94
1A2B0:  MOVLB  8
1A2B2:  MOVWF  xEE
1A2B4:  CLRF   xF0
1A2B6:  CLRF   xEF
1A2B8:  MOVLB  0
1A2BA:  CALL   4FD4
....................    write16(ADDR_M2_PWM_HLD,0); 
1A2BE:  MOVLW  98
1A2C0:  MOVLB  8
1A2C2:  MOVWF  xEE
1A2C4:  CLRF   xF0
1A2C6:  CLRF   xEF
1A2C8:  MOVLB  0
1A2CA:  CALL   4FD4
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A2CE:  MOVLW  9C
1A2D0:  MOVLB  8
1A2D2:  MOVWF  xEE
1A2D4:  CLRF   xF0
1A2D6:  MOVLW  7F
1A2D8:  MOVWF  xEF
1A2DA:  MOVLB  0
1A2DC:  CALL   4FD4
....................    write16(ADDR_M2_GB_ERR,0); 
1A2E0:  MOVLW  A0
1A2E2:  MOVLB  8
1A2E4:  MOVWF  xEE
1A2E6:  CLRF   xF0
1A2E8:  CLRF   xEF
1A2EA:  MOVLB  0
1A2EC:  CALL   4FD4
....................    write16(ADDR_E2_CPR,0); 
1A2F0:  MOVLW  A4
1A2F2:  MOVLB  8
1A2F4:  MOVWF  xEE
1A2F6:  CLRF   xF0
1A2F8:  CLRF   xEF
1A2FA:  MOVLB  0
1A2FC:  CALL   4FD4
....................    write16(ADDR_E2_PPR,0);   
1A300:  MOVLW  A8
1A302:  MOVLB  8
1A304:  MOVWF  xEE
1A306:  CLRF   xF0
1A308:  CLRF   xEF
1A30A:  MOVLB  0
1A30C:  CALL   4FD4
....................    write16(ADDR_E2_MODE,0); 
1A310:  MOVLW  84
1A312:  MOVLB  8
1A314:  MOVWF  xEE
1A316:  CLRF   xF0
1A318:  CLRF   xEF
1A31A:  MOVLB  0
1A31C:  CALL   4FD4
....................    write16(ADDR_E2_POS,0); 
1A320:  MOVLW  80
1A322:  MOVLB  8
1A324:  MOVWF  xEE
1A326:  CLRF   xF0
1A328:  CLRF   xEF
1A32A:  MOVLB  0
1A32C:  CALL   4FD4
....................    write16(ADDR_E2_PORT,0); 
1A330:  MOVLW  AC
1A332:  MOVLB  8
1A334:  MOVWF  xEE
1A336:  CLRF   xF0
1A338:  CLRF   xEF
1A33A:  MOVLB  0
1A33C:  CALL   4FD4
....................    write16(ADDR_E2_TYPE,0); 
1A340:  MOVLW  7C
1A342:  MOVLB  8
1A344:  MOVWF  xEE
1A346:  CLRF   xF0
1A348:  CLRF   xEF
1A34A:  MOVLB  0
1A34C:  CALL   4FD4
....................    write16(ADDR_M2_RUN,0); 
1A350:  MOVLW  78
1A352:  MOVLB  8
1A354:  MOVWF  xEE
1A356:  CLRF   xF0
1A358:  CLRF   xEF
1A35A:  MOVLB  0
1A35C:  CALL   4FD4
....................    write16(ADDR_M2_BKLSH,0); 
1A360:  MOVLW  74
1A362:  MOVLB  8
1A364:  MOVWF  xEE
1A366:  CLRF   xF0
1A368:  CLRF   xEF
1A36A:  MOVLB  0
1A36C:  CALL   4FD4
....................    write16(ADDR_M2_ERROR,0);   
1A370:  MOVLW  70
1A372:  MOVLB  8
1A374:  MOVWF  xEE
1A376:  CLRF   xF0
1A378:  CLRF   xEF
1A37A:  MOVLB  0
1A37C:  CALL   4FD4
....................    write16(ADDR_M2_SPR,0); 
1A380:  MOVLW  B0
1A382:  MOVLB  8
1A384:  MOVWF  xEE
1A386:  CLRF   xF0
1A388:  CLRF   xEF
1A38A:  MOVLB  0
1A38C:  CALL   4FD4
....................    write16(ADDR_M2_COMP,0); 
1A390:  MOVLW  B4
1A392:  MOVLB  8
1A394:  MOVWF  xEE
1A396:  CLRF   xF0
1A398:  CLRF   xEF
1A39A:  MOVLB  0
1A39C:  CALL   4FD4
....................    write16(ADDR_M2_LIN_POS,0);    
1A3A0:  MOVLW  B8
1A3A2:  MOVLB  8
1A3A4:  MOVWF  xEE
1A3A6:  CLRF   xF0
1A3A8:  CLRF   xEF
1A3AA:  MOVLB  0
1A3AC:  CALL   4FD4
....................    write16(ADDR_E2_INDEX,0); 
1A3B0:  MOVLW  BC
1A3B2:  MOVLB  8
1A3B4:  MOVWF  xEE
1A3B6:  CLRF   xF0
1A3B8:  CLRF   xEF
1A3BA:  MOVLB  0
1A3BC:  CALL   4FD4
....................    write16(ADDR_M2_EVN_SO,0); 
1A3C0:  MOVLW  C0
1A3C2:  MOVLB  8
1A3C4:  MOVWF  xEE
1A3C6:  CLRF   xF0
1A3C8:  CLRF   xEF
1A3CA:  MOVLB  0
1A3CC:  CALL   4FD4
....................    write16(ADDR_M2_ALIGN_OS,0); 
1A3D0:  MOVLW  C4
1A3D2:  MOVLB  8
1A3D4:  MOVWF  xEE
1A3D6:  CLRF   xF0
1A3D8:  CLRF   xEF
1A3DA:  MOVLB  0
1A3DC:  CALL   4FD4
....................     
....................    get_step_vars(); 
1A3E0:  CALL   2D1A
1A3E4:  GOTO   1AC2E (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A3E8:  MOVLW  86
1A3EA:  MOVLB  8
1A3EC:  MOVWF  xEE
1A3EE:  CLRF   xF0
1A3F0:  MOVLW  01
1A3F2:  MOVWF  xEF
1A3F4:  MOVLB  0
1A3F6:  CALL   4FD4
....................    write16(ADDR_M1_MODE,FULL); 
1A3FA:  MOVLW  8A
1A3FC:  MOVLB  8
1A3FE:  MOVWF  xEE
1A400:  CLRF   xF0
1A402:  CLRF   xEF
1A404:  MOVLB  0
1A406:  CALL   4FD4
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
1A40A:  MOVLW  8E
1A40C:  MOVLB  8
1A40E:  MOVWF  xEE
1A410:  CLRF   xF0
1A412:  MOVLW  14
1A414:  MOVWF  xEF
1A416:  MOVLB  0
1A418:  CALL   4FD4
....................    write16(ADDR_M1_POS_DIR,1); 
1A41C:  MOVLW  92
1A41E:  MOVLB  8
1A420:  MOVWF  xEE
1A422:  CLRF   xF0
1A424:  MOVLW  01
1A426:  MOVWF  xEF
1A428:  MOVLB  0
1A42A:  CALL   4FD4
....................    write16(ADDR_M1_PWM_HLD,51); 
1A42E:  MOVLW  96
1A430:  MOVLB  8
1A432:  MOVWF  xEE
1A434:  CLRF   xF0
1A436:  MOVLW  33
1A438:  MOVWF  xEF
1A43A:  MOVLB  0
1A43C:  CALL   4FD4
....................    write16(ADDR_M1_PWM_DRV,511); 
1A440:  MOVLW  9A
1A442:  MOVLB  8
1A444:  MOVWF  xEE
1A446:  MOVLW  01
1A448:  MOVWF  xF0
1A44A:  SETF   xEF
1A44C:  MOVLB  0
1A44E:  CALL   4FD4
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
1A452:  MOVLW  9E
1A454:  MOVLB  8
1A456:  MOVWF  xEE
1A458:  MOVLW  02
1A45A:  MOVWF  xF0
1A45C:  MOVLW  9E
1A45E:  MOVWF  xEF
1A460:  MOVLB  0
1A462:  CALL   4FD4
....................    write16(ADDR_E1_CPR,24); 
1A466:  MOVLW  A2
1A468:  MOVLB  8
1A46A:  MOVWF  xEE
1A46C:  CLRF   xF0
1A46E:  MOVLW  18
1A470:  MOVWF  xEF
1A472:  MOVLB  0
1A474:  CALL   4FD4
....................    write16(ADDR_E1_PPR,48); 
1A478:  MOVLW  A6
1A47A:  MOVLB  8
1A47C:  MOVWF  xEE
1A47E:  CLRF   xF0
1A480:  MOVLW  30
1A482:  MOVWF  xEF
1A484:  MOVLB  0
1A486:  CALL   4FD4
....................    write16(ADDR_E1_MODE,2); 
1A48A:  MOVLW  82
1A48C:  MOVLB  8
1A48E:  MOVWF  xEE
1A490:  CLRF   xF0
1A492:  MOVLW  02
1A494:  MOVWF  xEF
1A496:  MOVLB  0
1A498:  CALL   4FD4
....................    write16(ADDR_E1_POS,0); 
1A49C:  MOVLW  7E
1A49E:  MOVLB  8
1A4A0:  MOVWF  xEE
1A4A2:  CLRF   xF0
1A4A4:  CLRF   xEF
1A4A6:  MOVLB  0
1A4A8:  CALL   4FD4
....................    write16(ADDR_E1_PORT,0); 
1A4AC:  MOVLW  AA
1A4AE:  MOVLB  8
1A4B0:  MOVWF  xEE
1A4B2:  CLRF   xF0
1A4B4:  CLRF   xEF
1A4B6:  MOVLB  0
1A4B8:  CALL   4FD4
....................    write16(ADDR_E1_TYPE,2); 
1A4BC:  MOVLW  7A
1A4BE:  MOVLB  8
1A4C0:  MOVWF  xEE
1A4C2:  CLRF   xF0
1A4C4:  MOVLW  02
1A4C6:  MOVWF  xEF
1A4C8:  MOVLB  0
1A4CA:  CALL   4FD4
....................    write16(ADDR_M1_RUN,34); 
1A4CE:  MOVLW  76
1A4D0:  MOVLB  8
1A4D2:  MOVWF  xEE
1A4D4:  CLRF   xF0
1A4D6:  MOVLW  22
1A4D8:  MOVWF  xEF
1A4DA:  MOVLB  0
1A4DC:  CALL   4FD4
....................    write16(ADDR_M1_BKLSH,0); 
1A4E0:  MOVLW  72
1A4E2:  MOVLB  8
1A4E4:  MOVWF  xEE
1A4E6:  CLRF   xF0
1A4E8:  CLRF   xEF
1A4EA:  MOVLB  0
1A4EC:  CALL   4FD4
....................    write16(ADDR_M1_ERROR,0);   
1A4F0:  MOVLW  6E
1A4F2:  MOVLB  8
1A4F4:  MOVWF  xEE
1A4F6:  CLRF   xF0
1A4F8:  CLRF   xEF
1A4FA:  MOVLB  0
1A4FC:  CALL   4FD4
....................    write16(ADDR_M1_SPR,6400); 
1A500:  MOVLW  AE
1A502:  MOVLB  8
1A504:  MOVWF  xEE
1A506:  MOVLW  19
1A508:  MOVWF  xF0
1A50A:  CLRF   xEF
1A50C:  MOVLB  0
1A50E:  CALL   4FD4
....................    write16(ADDR_M1_COMP,0); 
1A512:  MOVLW  B2
1A514:  MOVLB  8
1A516:  MOVWF  xEE
1A518:  CLRF   xF0
1A51A:  CLRF   xEF
1A51C:  MOVLB  0
1A51E:  CALL   4FD4
....................    write16(ADDR_M1_LIN_POS,0); 
1A522:  MOVLW  B6
1A524:  MOVLB  8
1A526:  MOVWF  xEE
1A528:  CLRF   xF0
1A52A:  CLRF   xEF
1A52C:  MOVLB  0
1A52E:  CALL   4FD4
....................    write16(ADDR_E1_INDEX,1);    
1A532:  MOVLW  BA
1A534:  MOVLB  8
1A536:  MOVWF  xEE
1A538:  CLRF   xF0
1A53A:  MOVLW  01
1A53C:  MOVWF  xEF
1A53E:  MOVLB  0
1A540:  CALL   4FD4
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A544:  MOVLW  88
1A546:  MOVLB  8
1A548:  MOVWF  xEE
1A54A:  CLRF   xF0
1A54C:  MOVLW  01
1A54E:  MOVWF  xEF
1A550:  MOVLB  0
1A552:  CALL   4FD4
....................    write16(ADDR_M2_MODE,HALF); 
1A556:  MOVLW  8C
1A558:  MOVLB  8
1A55A:  MOVWF  xEE
1A55C:  CLRF   xF0
1A55E:  MOVLW  01
1A560:  MOVWF  xEF
1A562:  MOVLB  0
1A564:  CALL   4FD4
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A568:  MOVLW  90
1A56A:  MOVLB  8
1A56C:  MOVWF  xEE
1A56E:  CLRF   xF0
1A570:  MOVLW  28
1A572:  MOVWF  xEF
1A574:  MOVLB  0
1A576:  CALL   4FD4
....................    write16(ADDR_M2_POS_DIR,0); 
1A57A:  MOVLW  94
1A57C:  MOVLB  8
1A57E:  MOVWF  xEE
1A580:  CLRF   xF0
1A582:  CLRF   xEF
1A584:  MOVLB  0
1A586:  CALL   4FD4
....................    write16(ADDR_M2_PWM_HLD,0); 
1A58A:  MOVLW  98
1A58C:  MOVLB  8
1A58E:  MOVWF  xEE
1A590:  CLRF   xF0
1A592:  CLRF   xEF
1A594:  MOVLB  0
1A596:  CALL   4FD4
....................    write16(ADDR_M2_PWM_DRV,511); 
1A59A:  MOVLW  9C
1A59C:  MOVLB  8
1A59E:  MOVWF  xEE
1A5A0:  MOVLW  01
1A5A2:  MOVWF  xF0
1A5A4:  SETF   xEF
1A5A6:  MOVLB  0
1A5A8:  CALL   4FD4
....................    write16(ADDR_M2_GB_ERR,0); 
1A5AC:  MOVLW  A0
1A5AE:  MOVLB  8
1A5B0:  MOVWF  xEE
1A5B2:  CLRF   xF0
1A5B4:  CLRF   xEF
1A5B6:  MOVLB  0
1A5B8:  CALL   4FD4
....................    write16(ADDR_E2_CPR,0); 
1A5BC:  MOVLW  A4
1A5BE:  MOVLB  8
1A5C0:  MOVWF  xEE
1A5C2:  CLRF   xF0
1A5C4:  CLRF   xEF
1A5C6:  MOVLB  0
1A5C8:  CALL   4FD4
....................    write16(ADDR_E2_PPR,0);   
1A5CC:  MOVLW  A8
1A5CE:  MOVLB  8
1A5D0:  MOVWF  xEE
1A5D2:  CLRF   xF0
1A5D4:  CLRF   xEF
1A5D6:  MOVLB  0
1A5D8:  CALL   4FD4
....................    write16(ADDR_E2_MODE,0); 
1A5DC:  MOVLW  84
1A5DE:  MOVLB  8
1A5E0:  MOVWF  xEE
1A5E2:  CLRF   xF0
1A5E4:  CLRF   xEF
1A5E6:  MOVLB  0
1A5E8:  CALL   4FD4
....................    write16(ADDR_E2_POS,0); 
1A5EC:  MOVLW  80
1A5EE:  MOVLB  8
1A5F0:  MOVWF  xEE
1A5F2:  CLRF   xF0
1A5F4:  CLRF   xEF
1A5F6:  MOVLB  0
1A5F8:  CALL   4FD4
....................    write16(ADDR_E2_PORT,0); 
1A5FC:  MOVLW  AC
1A5FE:  MOVLB  8
1A600:  MOVWF  xEE
1A602:  CLRF   xF0
1A604:  CLRF   xEF
1A606:  MOVLB  0
1A608:  CALL   4FD4
....................    write16(ADDR_E2_TYPE,0); 
1A60C:  MOVLW  7C
1A60E:  MOVLB  8
1A610:  MOVWF  xEE
1A612:  CLRF   xF0
1A614:  CLRF   xEF
1A616:  MOVLB  0
1A618:  CALL   4FD4
....................    write16(ADDR_M2_RUN,0); 
1A61C:  MOVLW  78
1A61E:  MOVLB  8
1A620:  MOVWF  xEE
1A622:  CLRF   xF0
1A624:  CLRF   xEF
1A626:  MOVLB  0
1A628:  CALL   4FD4
....................    write16(ADDR_M2_BKLSH,0); 
1A62C:  MOVLW  74
1A62E:  MOVLB  8
1A630:  MOVWF  xEE
1A632:  CLRF   xF0
1A634:  CLRF   xEF
1A636:  MOVLB  0
1A638:  CALL   4FD4
....................    write16(ADDR_M2_ERROR,0);   
1A63C:  MOVLW  70
1A63E:  MOVLB  8
1A640:  MOVWF  xEE
1A642:  CLRF   xF0
1A644:  CLRF   xEF
1A646:  MOVLB  0
1A648:  CALL   4FD4
....................    write16(ADDR_M2_SPR,0); 
1A64C:  MOVLW  B0
1A64E:  MOVLB  8
1A650:  MOVWF  xEE
1A652:  CLRF   xF0
1A654:  CLRF   xEF
1A656:  MOVLB  0
1A658:  CALL   4FD4
....................    write16(ADDR_M2_COMP,0); 
1A65C:  MOVLW  B4
1A65E:  MOVLB  8
1A660:  MOVWF  xEE
1A662:  CLRF   xF0
1A664:  CLRF   xEF
1A666:  MOVLB  0
1A668:  CALL   4FD4
....................    write16(ADDR_M2_LIN_POS,0);   
1A66C:  MOVLW  B8
1A66E:  MOVLB  8
1A670:  MOVWF  xEE
1A672:  CLRF   xF0
1A674:  CLRF   xEF
1A676:  MOVLB  0
1A678:  CALL   4FD4
....................    write16(ADDR_E2_INDEX,0);    
1A67C:  MOVLW  BC
1A67E:  MOVLB  8
1A680:  MOVWF  xEE
1A682:  CLRF   xF0
1A684:  CLRF   xEF
1A686:  MOVLB  0
1A688:  CALL   4FD4
....................     
....................    get_step_vars(); 
1A68C:  CALL   2D1A
1A690:  GOTO   1AC2E (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A694:  MOVLW  86
1A696:  MOVLB  8
1A698:  MOVWF  xEE
1A69A:  CLRF   xF0
1A69C:  MOVLW  01
1A69E:  MOVWF  xEF
1A6A0:  MOVLB  0
1A6A2:  CALL   4FD4
....................    write16(ADDR_M1_MODE,FULL); 
1A6A6:  MOVLW  8A
1A6A8:  MOVLB  8
1A6AA:  MOVWF  xEE
1A6AC:  CLRF   xF0
1A6AE:  CLRF   xEF
1A6B0:  MOVLB  0
1A6B2:  CALL   4FD4
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A6B6:  MOVLW  8E
1A6B8:  MOVLB  8
1A6BA:  MOVWF  xEE
1A6BC:  CLRF   xF0
1A6BE:  MOVLW  0A
1A6C0:  MOVWF  xEF
1A6C2:  MOVLB  0
1A6C4:  CALL   4FD4
....................    write16(ADDR_M1_POS_DIR,0); 
1A6C8:  MOVLW  92
1A6CA:  MOVLB  8
1A6CC:  MOVWF  xEE
1A6CE:  CLRF   xF0
1A6D0:  CLRF   xEF
1A6D2:  MOVLB  0
1A6D4:  CALL   4FD4
....................    write16(ADDR_M1_PWM_HLD,0); 
1A6D8:  MOVLW  96
1A6DA:  MOVLB  8
1A6DC:  MOVWF  xEE
1A6DE:  CLRF   xF0
1A6E0:  CLRF   xEF
1A6E2:  MOVLB  0
1A6E4:  CALL   4FD4
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A6E8:  MOVLW  9A
1A6EA:  MOVLB  8
1A6EC:  MOVWF  xEE
1A6EE:  CLRF   xF0
1A6F0:  MOVLW  7F
1A6F2:  MOVWF  xEF
1A6F4:  MOVLB  0
1A6F6:  CALL   4FD4
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A6FA:  MOVLW  9E
1A6FC:  MOVLB  8
1A6FE:  MOVWF  xEE
1A700:  MOVLW  17
1A702:  MOVWF  xF0
1A704:  MOVLW  70
1A706:  MOVWF  xEF
1A708:  MOVLB  0
1A70A:  CALL   4FD4
....................    write16(ADDR_E1_CPR,16); 
1A70E:  MOVLW  A2
1A710:  MOVLB  8
1A712:  MOVWF  xEE
1A714:  CLRF   xF0
1A716:  MOVLW  10
1A718:  MOVWF  xEF
1A71A:  MOVLB  0
1A71C:  CALL   4FD4
....................    write16(ADDR_E1_PPR,16); 
1A720:  MOVLW  A6
1A722:  MOVLB  8
1A724:  MOVWF  xEE
1A726:  CLRF   xF0
1A728:  MOVLW  10
1A72A:  MOVWF  xEF
1A72C:  MOVLB  0
1A72E:  CALL   4FD4
....................    write16(ADDR_E1_MODE,2); 
1A732:  MOVLW  82
1A734:  MOVLB  8
1A736:  MOVWF  xEE
1A738:  CLRF   xF0
1A73A:  MOVLW  02
1A73C:  MOVWF  xEF
1A73E:  MOVLB  0
1A740:  CALL   4FD4
....................    write16(ADDR_E1_POS,0); 
1A744:  MOVLW  7E
1A746:  MOVLB  8
1A748:  MOVWF  xEE
1A74A:  CLRF   xF0
1A74C:  CLRF   xEF
1A74E:  MOVLB  0
1A750:  CALL   4FD4
....................    write16(ADDR_E1_PORT,0); 
1A754:  MOVLW  AA
1A756:  MOVLB  8
1A758:  MOVWF  xEE
1A75A:  CLRF   xF0
1A75C:  CLRF   xEF
1A75E:  MOVLB  0
1A760:  CALL   4FD4
....................    write16(ADDR_E1_TYPE,2); 
1A764:  MOVLW  7A
1A766:  MOVLB  8
1A768:  MOVWF  xEE
1A76A:  CLRF   xF0
1A76C:  MOVLW  02
1A76E:  MOVWF  xEF
1A770:  MOVLB  0
1A772:  CALL   4FD4
....................    write16(ADDR_M1_RUN,270); 
1A776:  MOVLW  76
1A778:  MOVLB  8
1A77A:  MOVWF  xEE
1A77C:  MOVLW  01
1A77E:  MOVWF  xF0
1A780:  MOVLW  0E
1A782:  MOVWF  xEF
1A784:  MOVLB  0
1A786:  CALL   4FD4
....................    write16(ADDR_M1_BKLSH,0); 
1A78A:  MOVLW  72
1A78C:  MOVLB  8
1A78E:  MOVWF  xEE
1A790:  CLRF   xF0
1A792:  CLRF   xEF
1A794:  MOVLB  0
1A796:  CALL   4FD4
....................    write16(ADDR_M1_ERROR,0);   
1A79A:  MOVLW  6E
1A79C:  MOVLB  8
1A79E:  MOVWF  xEE
1A7A0:  CLRF   xF0
1A7A2:  CLRF   xEF
1A7A4:  MOVLB  0
1A7A6:  CALL   4FD4
....................    write16(ADDR_M1_SPR,38400); 
1A7AA:  MOVLW  AE
1A7AC:  MOVLB  8
1A7AE:  MOVWF  xEE
1A7B0:  MOVLW  96
1A7B2:  MOVWF  xF0
1A7B4:  CLRF   xEF
1A7B6:  MOVLB  0
1A7B8:  CALL   4FD4
....................    write16(ADDR_M1_COMP,0); 
1A7BC:  MOVLW  B2
1A7BE:  MOVLB  8
1A7C0:  MOVWF  xEE
1A7C2:  CLRF   xF0
1A7C4:  CLRF   xEF
1A7C6:  MOVLB  0
1A7C8:  CALL   4FD4
....................    write16(ADDR_M1_LIN_POS,0); 
1A7CC:  MOVLW  B6
1A7CE:  MOVLB  8
1A7D0:  MOVWF  xEE
1A7D2:  CLRF   xF0
1A7D4:  CLRF   xEF
1A7D6:  MOVLB  0
1A7D8:  CALL   4FD4
....................    write16(ADDR_E1_INDEX,1); 
1A7DC:  MOVLW  BA
1A7DE:  MOVLB  8
1A7E0:  MOVWF  xEE
1A7E2:  CLRF   xF0
1A7E4:  MOVLW  01
1A7E6:  MOVWF  xEF
1A7E8:  MOVLB  0
1A7EA:  CALL   4FD4
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A7EE:  MOVLW  88
1A7F0:  MOVLB  8
1A7F2:  MOVWF  xEE
1A7F4:  CLRF   xF0
1A7F6:  MOVLW  01
1A7F8:  MOVWF  xEF
1A7FA:  MOVLB  0
1A7FC:  CALL   4FD4
....................    write16(ADDR_M2_MODE,HALF); 
1A800:  MOVLW  8C
1A802:  MOVLB  8
1A804:  MOVWF  xEE
1A806:  CLRF   xF0
1A808:  MOVLW  01
1A80A:  MOVWF  xEF
1A80C:  MOVLB  0
1A80E:  CALL   4FD4
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A812:  MOVLW  90
1A814:  MOVLB  8
1A816:  MOVWF  xEE
1A818:  CLRF   xF0
1A81A:  MOVLW  64
1A81C:  MOVWF  xEF
1A81E:  MOVLB  0
1A820:  CALL   4FD4
....................    write16(ADDR_M2_POS_DIR,0); 
1A824:  MOVLW  94
1A826:  MOVLB  8
1A828:  MOVWF  xEE
1A82A:  CLRF   xF0
1A82C:  CLRF   xEF
1A82E:  MOVLB  0
1A830:  CALL   4FD4
....................    write16(ADDR_M2_PWM_HLD,0); 
1A834:  MOVLW  98
1A836:  MOVLB  8
1A838:  MOVWF  xEE
1A83A:  CLRF   xF0
1A83C:  CLRF   xEF
1A83E:  MOVLB  0
1A840:  CALL   4FD4
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A844:  MOVLW  9C
1A846:  MOVLB  8
1A848:  MOVWF  xEE
1A84A:  CLRF   xF0
1A84C:  MOVLW  7F
1A84E:  MOVWF  xEF
1A850:  MOVLB  0
1A852:  CALL   4FD4
....................    write16(ADDR_M2_GB_ERR,0); 
1A856:  MOVLW  A0
1A858:  MOVLB  8
1A85A:  MOVWF  xEE
1A85C:  CLRF   xF0
1A85E:  CLRF   xEF
1A860:  MOVLB  0
1A862:  CALL   4FD4
....................    write16(ADDR_E2_CPR,0); 
1A866:  MOVLW  A4
1A868:  MOVLB  8
1A86A:  MOVWF  xEE
1A86C:  CLRF   xF0
1A86E:  CLRF   xEF
1A870:  MOVLB  0
1A872:  CALL   4FD4
....................    write16(ADDR_E2_PPR,0);   
1A876:  MOVLW  A8
1A878:  MOVLB  8
1A87A:  MOVWF  xEE
1A87C:  CLRF   xF0
1A87E:  CLRF   xEF
1A880:  MOVLB  0
1A882:  CALL   4FD4
....................    write16(ADDR_E2_MODE,0); 
1A886:  MOVLW  84
1A888:  MOVLB  8
1A88A:  MOVWF  xEE
1A88C:  CLRF   xF0
1A88E:  CLRF   xEF
1A890:  MOVLB  0
1A892:  CALL   4FD4
....................    write16(ADDR_E2_POS,0); 
1A896:  MOVLW  80
1A898:  MOVLB  8
1A89A:  MOVWF  xEE
1A89C:  CLRF   xF0
1A89E:  CLRF   xEF
1A8A0:  MOVLB  0
1A8A2:  CALL   4FD4
....................    write16(ADDR_E2_PORT,0); 
1A8A6:  MOVLW  AC
1A8A8:  MOVLB  8
1A8AA:  MOVWF  xEE
1A8AC:  CLRF   xF0
1A8AE:  CLRF   xEF
1A8B0:  MOVLB  0
1A8B2:  CALL   4FD4
....................    write16(ADDR_E2_TYPE,0); 
1A8B6:  MOVLW  7C
1A8B8:  MOVLB  8
1A8BA:  MOVWF  xEE
1A8BC:  CLRF   xF0
1A8BE:  CLRF   xEF
1A8C0:  MOVLB  0
1A8C2:  CALL   4FD4
....................    write16(ADDR_M2_RUN,0); 
1A8C6:  MOVLW  78
1A8C8:  MOVLB  8
1A8CA:  MOVWF  xEE
1A8CC:  CLRF   xF0
1A8CE:  CLRF   xEF
1A8D0:  MOVLB  0
1A8D2:  CALL   4FD4
....................    write16(ADDR_M2_BKLSH,0); 
1A8D6:  MOVLW  74
1A8D8:  MOVLB  8
1A8DA:  MOVWF  xEE
1A8DC:  CLRF   xF0
1A8DE:  CLRF   xEF
1A8E0:  MOVLB  0
1A8E2:  CALL   4FD4
....................    write16(ADDR_M2_ERROR,0);   
1A8E6:  MOVLW  70
1A8E8:  MOVLB  8
1A8EA:  MOVWF  xEE
1A8EC:  CLRF   xF0
1A8EE:  CLRF   xEF
1A8F0:  MOVLB  0
1A8F2:  CALL   4FD4
....................    write16(ADDR_M2_SPR,0); 
1A8F6:  MOVLW  B0
1A8F8:  MOVLB  8
1A8FA:  MOVWF  xEE
1A8FC:  CLRF   xF0
1A8FE:  CLRF   xEF
1A900:  MOVLB  0
1A902:  CALL   4FD4
....................    write16(ADDR_M2_COMP,0); 
1A906:  MOVLW  B4
1A908:  MOVLB  8
1A90A:  MOVWF  xEE
1A90C:  CLRF   xF0
1A90E:  CLRF   xEF
1A910:  MOVLB  0
1A912:  CALL   4FD4
....................    write16(ADDR_M2_LIN_POS,0);    
1A916:  MOVLW  B8
1A918:  MOVLB  8
1A91A:  MOVWF  xEE
1A91C:  CLRF   xF0
1A91E:  CLRF   xEF
1A920:  MOVLB  0
1A922:  CALL   4FD4
....................     
....................    get_step_vars(); 
1A926:  CALL   2D1A
1A92A:  GOTO   1AC2E (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A92E:  MOVLW  86
1A930:  MOVLB  8
1A932:  MOVWF  xEE
1A934:  CLRF   xF0
1A936:  MOVLW  01
1A938:  MOVWF  xEF
1A93A:  MOVLB  0
1A93C:  CALL   4FD4
....................    write16(ADDR_M1_MODE,FULL); 
1A940:  MOVLW  8A
1A942:  MOVLB  8
1A944:  MOVWF  xEE
1A946:  CLRF   xF0
1A948:  CLRF   xEF
1A94A:  MOVLB  0
1A94C:  CALL   4FD4
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1A950:  MOVLW  8E
1A952:  MOVLB  8
1A954:  MOVWF  xEE
1A956:  CLRF   xF0
1A958:  MOVLW  28
1A95A:  MOVWF  xEF
1A95C:  MOVLB  0
1A95E:  CALL   4FD4
....................    write16(ADDR_M1_POS_DIR,1); 
1A962:  MOVLW  92
1A964:  MOVLB  8
1A966:  MOVWF  xEE
1A968:  CLRF   xF0
1A96A:  MOVLW  01
1A96C:  MOVWF  xEF
1A96E:  MOVLB  0
1A970:  CALL   4FD4
....................    write16(ADDR_M1_PWM_HLD,0); 
1A974:  MOVLW  96
1A976:  MOVLB  8
1A978:  MOVWF  xEE
1A97A:  CLRF   xF0
1A97C:  CLRF   xEF
1A97E:  MOVLB  0
1A980:  CALL   4FD4
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A984:  MOVLW  9A
1A986:  MOVLB  8
1A988:  MOVWF  xEE
1A98A:  CLRF   xF0
1A98C:  MOVLW  7F
1A98E:  MOVWF  xEF
1A990:  MOVLB  0
1A992:  CALL   4FD4
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1A996:  MOVLW  9E
1A998:  MOVLB  8
1A99A:  MOVWF  xEE
1A99C:  MOVLW  02
1A99E:  MOVWF  xF0
1A9A0:  MOVLW  9E
1A9A2:  MOVWF  xEF
1A9A4:  MOVLB  0
1A9A6:  CALL   4FD4
....................    write16(ADDR_E1_CPR,500); 
1A9AA:  MOVLW  A2
1A9AC:  MOVLB  8
1A9AE:  MOVWF  xEE
1A9B0:  MOVLW  01
1A9B2:  MOVWF  xF0
1A9B4:  MOVLW  F4
1A9B6:  MOVWF  xEF
1A9B8:  MOVLB  0
1A9BA:  CALL   4FD4
....................    write16(ADDR_E1_PPR,50); 
1A9BE:  MOVLW  A6
1A9C0:  MOVLB  8
1A9C2:  MOVWF  xEE
1A9C4:  CLRF   xF0
1A9C6:  MOVLW  32
1A9C8:  MOVWF  xEF
1A9CA:  MOVLB  0
1A9CC:  CALL   4FD4
....................    write16(ADDR_E1_MODE,2); 
1A9D0:  MOVLW  82
1A9D2:  MOVLB  8
1A9D4:  MOVWF  xEE
1A9D6:  CLRF   xF0
1A9D8:  MOVLW  02
1A9DA:  MOVWF  xEF
1A9DC:  MOVLB  0
1A9DE:  CALL   4FD4
....................    write16(ADDR_E1_POS,0); 
1A9E2:  MOVLW  7E
1A9E4:  MOVLB  8
1A9E6:  MOVWF  xEE
1A9E8:  CLRF   xF0
1A9EA:  CLRF   xEF
1A9EC:  MOVLB  0
1A9EE:  CALL   4FD4
....................    write16(ADDR_E1_PORT,0); 
1A9F2:  MOVLW  AA
1A9F4:  MOVLB  8
1A9F6:  MOVWF  xEE
1A9F8:  CLRF   xF0
1A9FA:  CLRF   xEF
1A9FC:  MOVLB  0
1A9FE:  CALL   4FD4
....................    write16(ADDR_E1_TYPE,1); 
1AA02:  MOVLW  7A
1AA04:  MOVLB  8
1AA06:  MOVWF  xEE
1AA08:  CLRF   xF0
1AA0A:  MOVLW  01
1AA0C:  MOVWF  xEF
1AA0E:  MOVLB  0
1AA10:  CALL   4FD4
....................    write16(ADDR_M1_RUN,0); 
1AA14:  MOVLW  76
1AA16:  MOVLB  8
1AA18:  MOVWF  xEE
1AA1A:  CLRF   xF0
1AA1C:  CLRF   xEF
1AA1E:  MOVLB  0
1AA20:  CALL   4FD4
....................    write16(ADDR_M1_BKLSH,1300); 
1AA24:  MOVLW  72
1AA26:  MOVLB  8
1AA28:  MOVWF  xEE
1AA2A:  MOVLW  05
1AA2C:  MOVWF  xF0
1AA2E:  MOVLW  14
1AA30:  MOVWF  xEF
1AA32:  MOVLB  0
1AA34:  CALL   4FD4
....................    write16(ADDR_M1_ERROR,0);   
1AA38:  MOVLW  6E
1AA3A:  MOVLB  8
1AA3C:  MOVWF  xEE
1AA3E:  CLRF   xF0
1AA40:  CLRF   xEF
1AA42:  MOVLB  0
1AA44:  CALL   4FD4
....................    write16(ADDR_M1_SPR,20000); 
1AA48:  MOVLW  AE
1AA4A:  MOVLB  8
1AA4C:  MOVWF  xEE
1AA4E:  MOVLW  4E
1AA50:  MOVWF  xF0
1AA52:  MOVLW  20
1AA54:  MOVWF  xEF
1AA56:  MOVLB  0
1AA58:  CALL   4FD4
....................    write16(ADDR_M1_COMP,0); 
1AA5C:  MOVLW  B2
1AA5E:  MOVLB  8
1AA60:  MOVWF  xEE
1AA62:  CLRF   xF0
1AA64:  CLRF   xEF
1AA66:  MOVLB  0
1AA68:  CALL   4FD4
....................    write16(ADDR_M1_LIN_POS,0); 
1AA6C:  MOVLW  B6
1AA6E:  MOVLB  8
1AA70:  MOVWF  xEE
1AA72:  CLRF   xF0
1AA74:  CLRF   xEF
1AA76:  MOVLB  0
1AA78:  CALL   4FD4
....................    write16(ADDR_E1_INDEX,0); 
1AA7C:  MOVLW  BA
1AA7E:  MOVLB  8
1AA80:  MOVWF  xEE
1AA82:  CLRF   xF0
1AA84:  CLRF   xEF
1AA86:  MOVLB  0
1AA88:  CALL   4FD4
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1AA8C:  MOVLW  88
1AA8E:  MOVLB  8
1AA90:  MOVWF  xEE
1AA92:  CLRF   xF0
1AA94:  MOVLW  01
1AA96:  MOVWF  xEF
1AA98:  MOVLB  0
1AA9A:  CALL   4FD4
....................    write16(ADDR_M2_MODE,HALF); 
1AA9E:  MOVLW  8C
1AAA0:  MOVLB  8
1AAA2:  MOVWF  xEE
1AAA4:  CLRF   xF0
1AAA6:  MOVLW  01
1AAA8:  MOVWF  xEF
1AAAA:  MOVLB  0
1AAAC:  CALL   4FD4
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1AAB0:  MOVLW  90
1AAB2:  MOVLB  8
1AAB4:  MOVWF  xEE
1AAB6:  CLRF   xF0
1AAB8:  MOVLW  28
1AABA:  MOVWF  xEF
1AABC:  MOVLB  0
1AABE:  CALL   4FD4
....................    write16(ADDR_M2_POS_DIR,1); 
1AAC2:  MOVLW  94
1AAC4:  MOVLB  8
1AAC6:  MOVWF  xEE
1AAC8:  CLRF   xF0
1AACA:  MOVLW  01
1AACC:  MOVWF  xEF
1AACE:  MOVLB  0
1AAD0:  CALL   4FD4
....................    write16(ADDR_M2_PWM_HLD,0); 
1AAD4:  MOVLW  98
1AAD6:  MOVLB  8
1AAD8:  MOVWF  xEE
1AADA:  CLRF   xF0
1AADC:  CLRF   xEF
1AADE:  MOVLB  0
1AAE0:  CALL   4FD4
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1AAE4:  MOVLW  9C
1AAE6:  MOVLB  8
1AAE8:  MOVWF  xEE
1AAEA:  CLRF   xF0
1AAEC:  MOVLW  7F
1AAEE:  MOVWF  xEF
1AAF0:  MOVLB  0
1AAF2:  CALL   4FD4
....................    write16(ADDR_M2_GB_ERR,0); 
1AAF6:  MOVLW  A0
1AAF8:  MOVLB  8
1AAFA:  MOVWF  xEE
1AAFC:  CLRF   xF0
1AAFE:  CLRF   xEF
1AB00:  MOVLB  0
1AB02:  CALL   4FD4
....................    write16(ADDR_E2_CPR,0); 
1AB06:  MOVLW  A4
1AB08:  MOVLB  8
1AB0A:  MOVWF  xEE
1AB0C:  CLRF   xF0
1AB0E:  CLRF   xEF
1AB10:  MOVLB  0
1AB12:  CALL   4FD4
....................    write16(ADDR_E2_PPR,0);   
1AB16:  MOVLW  A8
1AB18:  MOVLB  8
1AB1A:  MOVWF  xEE
1AB1C:  CLRF   xF0
1AB1E:  CLRF   xEF
1AB20:  MOVLB  0
1AB22:  CALL   4FD4
....................    write16(ADDR_E2_MODE,0); 
1AB26:  MOVLW  84
1AB28:  MOVLB  8
1AB2A:  MOVWF  xEE
1AB2C:  CLRF   xF0
1AB2E:  CLRF   xEF
1AB30:  MOVLB  0
1AB32:  CALL   4FD4
....................    write16(ADDR_E2_POS,0); 
1AB36:  MOVLW  80
1AB38:  MOVLB  8
1AB3A:  MOVWF  xEE
1AB3C:  CLRF   xF0
1AB3E:  CLRF   xEF
1AB40:  MOVLB  0
1AB42:  CALL   4FD4
....................    write16(ADDR_E2_PORT,0); 
1AB46:  MOVLW  AC
1AB48:  MOVLB  8
1AB4A:  MOVWF  xEE
1AB4C:  CLRF   xF0
1AB4E:  CLRF   xEF
1AB50:  MOVLB  0
1AB52:  CALL   4FD4
....................    write16(ADDR_E2_TYPE,0); 
1AB56:  MOVLW  7C
1AB58:  MOVLB  8
1AB5A:  MOVWF  xEE
1AB5C:  CLRF   xF0
1AB5E:  CLRF   xEF
1AB60:  MOVLB  0
1AB62:  CALL   4FD4
....................    write16(ADDR_M2_RUN,0); 
1AB66:  MOVLW  78
1AB68:  MOVLB  8
1AB6A:  MOVWF  xEE
1AB6C:  CLRF   xF0
1AB6E:  CLRF   xEF
1AB70:  MOVLB  0
1AB72:  CALL   4FD4
....................    write16(ADDR_M2_BKLSH,0); 
1AB76:  MOVLW  74
1AB78:  MOVLB  8
1AB7A:  MOVWF  xEE
1AB7C:  CLRF   xF0
1AB7E:  CLRF   xEF
1AB80:  MOVLB  0
1AB82:  CALL   4FD4
....................    write16(ADDR_M2_ERROR,0);   
1AB86:  MOVLW  70
1AB88:  MOVLB  8
1AB8A:  MOVWF  xEE
1AB8C:  CLRF   xF0
1AB8E:  CLRF   xEF
1AB90:  MOVLB  0
1AB92:  CALL   4FD4
....................    write16(ADDR_M2_SPR,0); 
1AB96:  MOVLW  B0
1AB98:  MOVLB  8
1AB9A:  MOVWF  xEE
1AB9C:  CLRF   xF0
1AB9E:  CLRF   xEF
1ABA0:  MOVLB  0
1ABA2:  CALL   4FD4
....................    write16(ADDR_M2_COMP,0); 
1ABA6:  MOVLW  B4
1ABA8:  MOVLB  8
1ABAA:  MOVWF  xEE
1ABAC:  CLRF   xF0
1ABAE:  CLRF   xEF
1ABB0:  MOVLB  0
1ABB2:  CALL   4FD4
....................    write16(ADDR_M2_LIN_POS,0);    
1ABB6:  MOVLW  B8
1ABB8:  MOVLB  8
1ABBA:  MOVWF  xEE
1ABBC:  CLRF   xF0
1ABBE:  CLRF   xEF
1ABC0:  MOVLB  0
1ABC2:  CALL   4FD4
....................    write16(ADDR_E2_INDEX,0); 
1ABC6:  MOVLW  BC
1ABC8:  MOVLB  8
1ABCA:  MOVWF  xEE
1ABCC:  CLRF   xF0
1ABCE:  CLRF   xEF
1ABD0:  MOVLB  0
1ABD2:  CALL   4FD4
....................     
....................    get_step_vars(); 
1ABD6:  CALL   2D1A
1ABDA:  GOTO   1AC2E (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
02998:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
0299A:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
0299C:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
0299E:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
029A0:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
029A2:  BCF    F90.5
....................    set_pwm1_duty(0);    
029A4:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
029A6:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
029A8:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
029AA:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
029AC:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
029AE:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
029B0:  BCF    F8D.5
....................    set_pwm2_duty(0);  
029B2:  MOVLB  F
029B4:  CLRF   x4F
....................  
....................    output_low(VENC1); 
029B6:  BCF    F8E.6
....................    output_low(VENC2);         
029B8:  BCF    F8E.7
....................    output_low(VHBRDG); 
029BA:  BCF    F8E.2
029BC:  MOVLB  0
029BE:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
01252:  BCF    FD8.0
01254:  MOVLB  7
01256:  RLCF   x40,W
01258:  CLRF   03
0125A:  ADDLW  4E
0125C:  MOVWF  FE9
0125E:  MOVLW  07
01260:  ADDWFC 03,W
01262:  MOVWF  FEA
01264:  MOVFF  FEC,A38
01268:  MOVF   FED,F
0126A:  MOVFF  FEF,A37
0126E:  MOVLB  A
01270:  MOVF   x37,F
01272:  BTFSS  FD8.2
01274:  BRA    13FC
01276:  MOVF   x38,F
01278:  BTFSS  FD8.2
0127A:  BRA    13FC
....................       if(m_way[motor]==POS) { 
0127C:  BCF    FD8.0
0127E:  MOVLB  7
01280:  RLCF   x40,W
01282:  CLRF   03
01284:  ADDLW  86
01286:  MOVWF  FE9
01288:  MOVLW  07
0128A:  ADDWFC 03,W
0128C:  MOVWF  FEA
0128E:  MOVFF  FEC,A38
01292:  MOVF   FED,F
01294:  MOVFF  FEF,A37
01298:  MOVLB  A
0129A:  MOVF   x37,F
0129C:  BNZ   1336
0129E:  MOVF   x38,F
012A0:  BNZ   1336
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
012A2:  BCF    FD8.0
012A4:  MOVLB  7
012A6:  RLCF   x40,W
012A8:  CLRF   03
012AA:  ADDLW  BF
012AC:  MOVWF  FE9
012AE:  MOVLW  07
012B0:  ADDWFC 03,W
012B2:  MOVWF  FEA
012B4:  MOVFF  FEC,A38
012B8:  MOVF   FED,F
012BA:  MOVFF  FEF,A37
012BE:  BCF    FD8.0
012C0:  RLCF   x40,W
012C2:  CLRF   03
012C4:  ADDLW  5E
012C6:  MOVWF  FE9
012C8:  MOVLW  07
012CA:  ADDWFC 03,W
012CC:  MOVWF  FEA
012CE:  MOVFF  FEC,03
012D2:  MOVF   FED,F
012D4:  MOVFF  FEF,01
012D8:  MOVF   03,W
012DA:  MOVLB  A
012DC:  SUBWF  x38,W
012DE:  BNC   1302
012E0:  BNZ   12E8
012E2:  MOVF   01,W
012E4:  SUBWF  x37,W
012E6:  BNC   1302
012E8:  BCF    FD8.0
012EA:  MOVLB  7
012EC:  RLCF   x40,W
012EE:  CLRF   03
012F0:  ADDLW  BF
012F2:  MOVWF  FE9
012F4:  MOVLW  07
012F6:  ADDWFC 03,W
012F8:  MOVWF  FEA
012FA:  CLRF   FEC
012FC:  MOVF   FED,F
012FE:  CLRF   FEF
01300:  MOVLB  A
....................          e_pos[motor]++; 
01302:  BCF    FD8.0
01304:  MOVLB  7
01306:  RLCF   x40,W
01308:  CLRF   03
0130A:  ADDLW  BF
0130C:  MOVWF  FE9
0130E:  MOVLW  07
01310:  ADDWFC 03,W
01312:  MOVWF  FEA
01314:  MOVLW  01
01316:  ADDWF  FEE,F
01318:  BNC   131C
0131A:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
0131C:  BCF    FD8.0
0131E:  RLCF   x40,W
01320:  CLRF   03
01322:  ADDLW  9A
01324:  MOVWF  FE9
01326:  MOVLW  07
01328:  ADDWFC 03,W
0132A:  MOVWF  FEA
0132C:  CLRF   FEC
0132E:  MOVF   FED,F
01330:  CLRF   FEF
....................       } 
01332:  BRA    13FA
01334:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
01336:  BCF    FD8.0
01338:  MOVLB  7
0133A:  RLCF   x40,W
0133C:  CLRF   03
0133E:  ADDLW  86
01340:  MOVWF  FE9
01342:  MOVLW  07
01344:  ADDWFC 03,W
01346:  MOVWF  FEA
01348:  MOVFF  FEC,A38
0134C:  MOVF   FED,F
0134E:  MOVFF  FEF,A37
01352:  MOVLB  A
01354:  DECFSZ x37,W
01356:  BRA    13FC
01358:  MOVF   x38,F
0135A:  BNZ   13FC
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
0135C:  BCF    FD8.0
0135E:  MOVLB  7
01360:  RLCF   x40,W
01362:  CLRF   03
01364:  ADDLW  BF
01366:  MOVWF  FE9
01368:  MOVLW  07
0136A:  ADDWFC 03,W
0136C:  MOVWF  FEA
0136E:  MOVFF  FEC,A38
01372:  MOVF   FED,F
01374:  MOVFF  FEF,A37
01378:  MOVLB  A
0137A:  MOVF   x37,F
0137C:  BNZ   13C8
0137E:  MOVF   x38,F
01380:  BNZ   13C8
01382:  BCF    FD8.0
01384:  MOVLB  7
01386:  RLCF   x40,W
01388:  CLRF   03
0138A:  ADDLW  BF
0138C:  MOVWF  01
0138E:  MOVLW  07
01390:  ADDWFC 03,F
01392:  MOVLB  A
01394:  MOVFF  03,A38
01398:  BCF    FD8.0
0139A:  MOVLB  7
0139C:  RLCF   x40,W
0139E:  CLRF   03
013A0:  ADDLW  5E
013A2:  MOVWF  FE9
013A4:  MOVLW  07
013A6:  ADDWFC 03,W
013A8:  MOVWF  FEA
013AA:  MOVFF  FEC,03
013AE:  MOVF   FED,F
013B0:  MOVFF  FEF,A39
013B4:  MOVLB  A
013B6:  MOVFF  A38,FEA
013BA:  MOVFF  01,FE9
013BE:  MOVFF  03,FEC
013C2:  MOVF   FED,F
013C4:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
013C8:  BCF    FD8.0
013CA:  MOVLB  7
013CC:  RLCF   x40,W
013CE:  CLRF   03
013D0:  ADDLW  BF
013D2:  MOVWF  FE9
013D4:  MOVLW  07
013D6:  ADDWFC 03,W
013D8:  MOVWF  FEA
013DA:  MOVLW  FF
013DC:  ADDWF  FEF,F
013DE:  BC    13E4
013E0:  MOVF   FEE,F
013E2:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
013E4:  BCF    FD8.0
013E6:  RLCF   x40,W
013E8:  CLRF   03
013EA:  ADDLW  9A
013EC:  MOVWF  FE9
013EE:  MOVLW  07
013F0:  ADDWFC 03,W
013F2:  MOVWF  FEA
013F4:  CLRF   FEC
013F6:  MOVF   FED,F
013F8:  CLRF   FEF
013FA:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
013FC:  BCF    FD8.0
013FE:  MOVLB  7
01400:  RLCF   x40,W
01402:  CLRF   03
01404:  ADDLW  4E
01406:  MOVWF  FE9
01408:  MOVLW  07
0140A:  ADDWFC 03,W
0140C:  MOVWF  FEA
0140E:  MOVFF  FEC,A38
01412:  MOVF   FED,F
01414:  MOVFF  FEF,A37
01418:  MOVLB  A
0141A:  DECFSZ x37,W
0141C:  BRA    15A4
0141E:  MOVF   x38,F
01420:  BTFSS  FD8.2
01422:  BRA    15A4
....................       if(m_way[motor]==NEG) { 
01424:  BCF    FD8.0
01426:  MOVLB  7
01428:  RLCF   x40,W
0142A:  CLRF   03
0142C:  ADDLW  86
0142E:  MOVWF  FE9
01430:  MOVLW  07
01432:  ADDWFC 03,W
01434:  MOVWF  FEA
01436:  MOVFF  FEC,A38
0143A:  MOVF   FED,F
0143C:  MOVFF  FEF,A37
01440:  MOVLB  A
01442:  DECFSZ x37,W
01444:  BRA    14DE
01446:  MOVF   x38,F
01448:  BNZ   14DE
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
0144A:  BCF    FD8.0
0144C:  MOVLB  7
0144E:  RLCF   x40,W
01450:  CLRF   03
01452:  ADDLW  BF
01454:  MOVWF  FE9
01456:  MOVLW  07
01458:  ADDWFC 03,W
0145A:  MOVWF  FEA
0145C:  MOVFF  FEC,A38
01460:  MOVF   FED,F
01462:  MOVFF  FEF,A37
01466:  BCF    FD8.0
01468:  RLCF   x40,W
0146A:  CLRF   03
0146C:  ADDLW  5E
0146E:  MOVWF  FE9
01470:  MOVLW  07
01472:  ADDWFC 03,W
01474:  MOVWF  FEA
01476:  MOVFF  FEC,03
0147A:  MOVF   FED,F
0147C:  MOVFF  FEF,01
01480:  MOVF   03,W
01482:  MOVLB  A
01484:  SUBWF  x38,W
01486:  BNC   14AA
01488:  BNZ   1490
0148A:  MOVF   01,W
0148C:  SUBWF  x37,W
0148E:  BNC   14AA
01490:  BCF    FD8.0
01492:  MOVLB  7
01494:  RLCF   x40,W
01496:  CLRF   03
01498:  ADDLW  BF
0149A:  MOVWF  FE9
0149C:  MOVLW  07
0149E:  ADDWFC 03,W
014A0:  MOVWF  FEA
014A2:  CLRF   FEC
014A4:  MOVF   FED,F
014A6:  CLRF   FEF
014A8:  MOVLB  A
....................          e_pos[motor]++; 
014AA:  BCF    FD8.0
014AC:  MOVLB  7
014AE:  RLCF   x40,W
014B0:  CLRF   03
014B2:  ADDLW  BF
014B4:  MOVWF  FE9
014B6:  MOVLW  07
014B8:  ADDWFC 03,W
014BA:  MOVWF  FEA
014BC:  MOVLW  01
014BE:  ADDWF  FEE,F
014C0:  BNC   14C4
014C2:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014C4:  BCF    FD8.0
014C6:  RLCF   x40,W
014C8:  CLRF   03
014CA:  ADDLW  9A
014CC:  MOVWF  FE9
014CE:  MOVLW  07
014D0:  ADDWFC 03,W
014D2:  MOVWF  FEA
014D4:  CLRF   FEC
014D6:  MOVF   FED,F
014D8:  CLRF   FEF
....................       } 
014DA:  BRA    15A2
014DC:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
014DE:  BCF    FD8.0
014E0:  MOVLB  7
014E2:  RLCF   x40,W
014E4:  CLRF   03
014E6:  ADDLW  86
014E8:  MOVWF  FE9
014EA:  MOVLW  07
014EC:  ADDWFC 03,W
014EE:  MOVWF  FEA
014F0:  MOVFF  FEC,A38
014F4:  MOVF   FED,F
014F6:  MOVFF  FEF,A37
014FA:  MOVLB  A
014FC:  MOVF   x37,F
014FE:  BNZ   15A4
01500:  MOVF   x38,F
01502:  BNZ   15A4
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01504:  BCF    FD8.0
01506:  MOVLB  7
01508:  RLCF   x40,W
0150A:  CLRF   03
0150C:  ADDLW  BF
0150E:  MOVWF  FE9
01510:  MOVLW  07
01512:  ADDWFC 03,W
01514:  MOVWF  FEA
01516:  MOVFF  FEC,A38
0151A:  MOVF   FED,F
0151C:  MOVFF  FEF,A37
01520:  MOVLB  A
01522:  MOVF   x37,F
01524:  BNZ   1570
01526:  MOVF   x38,F
01528:  BNZ   1570
0152A:  BCF    FD8.0
0152C:  MOVLB  7
0152E:  RLCF   x40,W
01530:  CLRF   03
01532:  ADDLW  BF
01534:  MOVWF  01
01536:  MOVLW  07
01538:  ADDWFC 03,F
0153A:  MOVLB  A
0153C:  MOVFF  03,A38
01540:  BCF    FD8.0
01542:  MOVLB  7
01544:  RLCF   x40,W
01546:  CLRF   03
01548:  ADDLW  5E
0154A:  MOVWF  FE9
0154C:  MOVLW  07
0154E:  ADDWFC 03,W
01550:  MOVWF  FEA
01552:  MOVFF  FEC,03
01556:  MOVF   FED,F
01558:  MOVFF  FEF,A39
0155C:  MOVLB  A
0155E:  MOVFF  A38,FEA
01562:  MOVFF  01,FE9
01566:  MOVFF  03,FEC
0156A:  MOVF   FED,F
0156C:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
01570:  BCF    FD8.0
01572:  MOVLB  7
01574:  RLCF   x40,W
01576:  CLRF   03
01578:  ADDLW  BF
0157A:  MOVWF  FE9
0157C:  MOVLW  07
0157E:  ADDWFC 03,W
01580:  MOVWF  FEA
01582:  MOVLW  FF
01584:  ADDWF  FEF,F
01586:  BC    158C
01588:  MOVF   FEE,F
0158A:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
0158C:  BCF    FD8.0
0158E:  RLCF   x40,W
01590:  CLRF   03
01592:  ADDLW  9A
01594:  MOVWF  FE9
01596:  MOVLW  07
01598:  ADDWFC 03,W
0159A:  MOVWF  FEA
0159C:  CLRF   FEC
0159E:  MOVF   FED,F
015A0:  CLRF   FEF
015A2:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
015A4:  MOVF   1F,W
015A6:  SUBLW  04
015A8:  BTFSS  FD8.2
015AA:  BRA    16DE
015AC:  MOVF   20,F
015AE:  BTFSS  FD8.2
015B0:  BRA    16DE
015B2:  BCF    FD8.0
015B4:  MOVLB  7
015B6:  RLCF   x40,W
015B8:  CLRF   03
015BA:  ADDLW  6A
015BC:  MOVWF  FE9
015BE:  MOVLW  07
015C0:  ADDWFC 03,W
015C2:  MOVWF  FEA
015C4:  MOVFF  FEC,A38
015C8:  MOVF   FED,F
015CA:  MOVFF  FEF,A37
015CE:  MOVLB  A
015D0:  MOVF   x37,W
015D2:  SUBLW  02
015D4:  BTFSS  FD8.2
015D6:  BRA    16DE
015D8:  MOVF   x38,F
015DA:  BTFSS  FD8.2
015DC:  BRA    16DE
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
015DE:  MOVLW  01
015E0:  MOVLB  7
015E2:  ADDWF  x40,W
015E4:  MOVLB  A
015E6:  MOVWF  x37
015E8:  MOVLB  7
015EA:  MOVF   x40,W
015EC:  MULLW  04
015EE:  MOVF   FF3,W
015F0:  CLRF   03
015F2:  ADDLW  A2
015F4:  MOVWF  FE9
015F6:  MOVLW  07
015F8:  ADDWFC 03,W
015FA:  MOVWF  FEA
015FC:  MOVFF  FEF,A38
01600:  MOVFF  FEC,A39
01604:  MOVFF  FEC,A3A
01608:  MOVFF  FEC,A3B
0160C:  BCF    FD8.0
0160E:  RLCF   x40,W
01610:  CLRF   03
01612:  ADDLW  BB
01614:  MOVWF  FE9
01616:  MOVLW  07
01618:  ADDWFC 03,W
0161A:  MOVWF  FEA
0161C:  MOVFF  FEC,A3D
01620:  MOVF   FED,F
01622:  MOVFF  FEF,A3C
01626:  BCF    FD8.0
01628:  RLCF   x40,W
0162A:  CLRF   03
0162C:  ADDLW  BF
0162E:  MOVWF  FE9
01630:  MOVLW  07
01632:  ADDWFC 03,W
01634:  MOVWF  FEA
01636:  MOVFF  FEC,A3F
0163A:  MOVF   FED,F
0163C:  MOVFF  FEF,A3E
01640:  MOVLW  6D
01642:  BTFSS  F9E.4
01644:  BRA    1642
01646:  MOVWF  FAD
01648:  MOVLW  3A
0164A:  BTFSS  F9E.4
0164C:  BRA    164A
0164E:  MOVWF  FAD
01650:  MOVFF  A37,A40
01654:  MOVLW  1B
01656:  MOVLB  A
01658:  MOVWF  x41
0165A:  MOVLB  0
0165C:  RCALL  0F9E
0165E:  MOVLW  2C
01660:  BTFSS  F9E.4
01662:  BRA    1660
01664:  MOVWF  FAD
01666:  MOVFF  7AA,A40
0166A:  MOVLW  1B
0166C:  MOVLB  A
0166E:  MOVWF  x41
01670:  MOVLB  0
01672:  RCALL  0F9E
01674:  MOVLW  61
01676:  MOVWF  FF6
01678:  MOVLW  0F
0167A:  MOVWF  FF7
0167C:  MOVLW  00
0167E:  MOVWF  FF8
01680:  MOVLW  03
01682:  MOVLB  A
01684:  MOVWF  x40
01686:  MOVLB  0
01688:  RCALL  101C
0168A:  MOVLW  41
0168C:  MOVWF  FE9
0168E:  MOVFF  A3B,A43
01692:  MOVFF  A3A,A42
01696:  MOVFF  A39,A41
0169A:  MOVFF  A38,A40
0169E:  RCALL  10E2
016A0:  MOVLW  2C
016A2:  BTFSS  F9E.4
016A4:  BRA    16A2
016A6:  MOVWF  FAD
016A8:  MOVLW  10
016AA:  MOVWF  FE9
016AC:  MOVFF  A3D,A41
016B0:  MOVFF  A3C,A40
016B4:  RCALL  119E
016B6:  MOVLW  2C
016B8:  BTFSS  F9E.4
016BA:  BRA    16B8
016BC:  MOVWF  FAD
016BE:  MOVLW  10
016C0:  MOVWF  FE9
016C2:  MOVFF  A3F,A41
016C6:  MOVFF  A3E,A40
016CA:  RCALL  119E
016CC:  MOVLW  0D
016CE:  BTFSS  F9E.4
016D0:  BRA    16CE
016D2:  MOVWF  FAD
016D4:  MOVLW  0A
016D6:  BTFSS  F9E.4
016D8:  BRA    16D6
016DA:  MOVWF  FAD
016DC:  MOVLB  A
....................    }    
016DE:  MOVLB  0
016E0:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A782:  MOVLB  7
0A784:  MOVF   x40,W
0A786:  XORLW  00
0A788:  MOVLB  0
0A78A:  BZ    A792
0A78C:  XORLW  01
0A78E:  BZ    A822
0A790:  BRA    A8B0
....................       case 0 : if (e_type[motor]==1) { 
0A792:  BCF    FD8.0
0A794:  MOVLB  7
0A796:  RLCF   x40,W
0A798:  CLRF   03
0A79A:  ADDLW  6A
0A79C:  MOVWF  FE9
0A79E:  MOVLW  07
0A7A0:  ADDWFC 03,W
0A7A2:  MOVWF  FEA
0A7A4:  MOVFF  FEC,8C8
0A7A8:  MOVF   FED,F
0A7AA:  MOVFF  FEF,8C7
0A7AE:  MOVLB  8
0A7B0:  DECFSZ xC7,W
0A7B2:  BRA    A7D2
0A7B4:  MOVF   xC8,F
0A7B6:  BNZ   A7D2
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A7B8:  CLRF   03
0A7BA:  MOVLB  7
0A7BC:  MOVF   x40,W
0A7BE:  ADDLW  CB
0A7C0:  MOVWF  FE9
0A7C2:  MOVLW  07
0A7C4:  ADDWFC 03,W
0A7C6:  MOVWF  FEA
0A7C8:  MOVLW  00
0A7CA:  BTFSC  F81.4
0A7CC:  MOVLW  01
0A7CE:  MOVWF  FEF
0A7D0:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A7D2:  BCF    FD8.0
0A7D4:  MOVLB  7
0A7D6:  RLCF   x40,W
0A7D8:  CLRF   03
0A7DA:  ADDLW  6A
0A7DC:  MOVWF  FE9
0A7DE:  MOVLW  07
0A7E0:  ADDWFC 03,W
0A7E2:  MOVWF  FEA
0A7E4:  MOVFF  FEC,8C8
0A7E8:  MOVF   FED,F
0A7EA:  MOVFF  FEF,8C7
0A7EE:  MOVLB  8
0A7F0:  MOVF   xC7,W
0A7F2:  SUBLW  02
0A7F4:  BNZ   A81E
0A7F6:  MOVF   xC8,F
0A7F8:  BNZ   A81E
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A7FA:  CLRF   03
0A7FC:  MOVLB  7
0A7FE:  MOVF   x40,W
0A800:  ADDLW  CB
0A802:  MOVWF  FE9
0A804:  MOVLW  07
0A806:  ADDWFC 03,W
0A808:  MOVWF  FEA
0A80A:  MOVLW  00
0A80C:  BTFSC  F81.4
0A80E:  MOVLW  01
0A810:  MOVLB  8
0A812:  MOVWF  xC9
0A814:  MOVLW  00
0A816:  BTFSC  F81.1
0A818:  MOVLW  01
0A81A:  ANDWF  xC9,W
0A81C:  MOVWF  FEF
....................                } 
....................          break; 
0A81E:  MOVLB  0
0A820:  BRA    A8B0
....................       case 1 : if (e_type[motor]==1) { 
0A822:  BCF    FD8.0
0A824:  MOVLB  7
0A826:  RLCF   x40,W
0A828:  CLRF   03
0A82A:  ADDLW  6A
0A82C:  MOVWF  FE9
0A82E:  MOVLW  07
0A830:  ADDWFC 03,W
0A832:  MOVWF  FEA
0A834:  MOVFF  FEC,8C8
0A838:  MOVF   FED,F
0A83A:  MOVFF  FEF,8C7
0A83E:  MOVLB  8
0A840:  DECFSZ xC7,W
0A842:  BRA    A862
0A844:  MOVF   xC8,F
0A846:  BNZ   A862
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A848:  CLRF   03
0A84A:  MOVLB  7
0A84C:  MOVF   x40,W
0A84E:  ADDLW  CB
0A850:  MOVWF  FE9
0A852:  MOVLW  07
0A854:  ADDWFC 03,W
0A856:  MOVWF  FEA
0A858:  MOVLW  00
0A85A:  BTFSC  F81.5
0A85C:  MOVLW  01
0A85E:  MOVWF  FEF
0A860:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A862:  BCF    FD8.0
0A864:  MOVLB  7
0A866:  RLCF   x40,W
0A868:  CLRF   03
0A86A:  ADDLW  6A
0A86C:  MOVWF  FE9
0A86E:  MOVLW  07
0A870:  ADDWFC 03,W
0A872:  MOVWF  FEA
0A874:  MOVFF  FEC,8C8
0A878:  MOVF   FED,F
0A87A:  MOVFF  FEF,8C7
0A87E:  MOVLB  8
0A880:  MOVF   xC7,W
0A882:  SUBLW  02
0A884:  BNZ   A8AE
0A886:  MOVF   xC8,F
0A888:  BNZ   A8AE
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A88A:  CLRF   03
0A88C:  MOVLB  7
0A88E:  MOVF   x40,W
0A890:  ADDLW  CB
0A892:  MOVWF  FE9
0A894:  MOVLW  07
0A896:  ADDWFC 03,W
0A898:  MOVWF  FEA
0A89A:  MOVLW  00
0A89C:  BTFSC  F81.5
0A89E:  MOVLW  01
0A8A0:  MOVLB  8
0A8A2:  MOVWF  xC9
0A8A4:  MOVLW  00
0A8A6:  BTFSC  F81.2
0A8A8:  MOVLW  01
0A8AA:  ANDWF  xC9,W
0A8AC:  MOVWF  FEF
....................                } 
....................          break; 
0A8AE:  MOVLB  0
....................    } 
0A8B0:  GOTO   A96A (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017CE:  MOVLB  7
017D0:  MOVF   x40,W
017D2:  XORLW  00
017D4:  MOVLB  0
017D6:  BZ    17DE
017D8:  XORLW  01
017DA:  BZ    186E
017DC:  BRA    18FC
....................       case 0 : if (e_type[motor]==1) { 
017DE:  BCF    FD8.0
017E0:  MOVLB  7
017E2:  RLCF   x40,W
017E4:  CLRF   03
017E6:  ADDLW  6A
017E8:  MOVWF  FE9
017EA:  MOVLW  07
017EC:  ADDWFC 03,W
017EE:  MOVWF  FEA
017F0:  MOVFF  FEC,A38
017F4:  MOVF   FED,F
017F6:  MOVFF  FEF,A37
017FA:  MOVLB  A
017FC:  DECFSZ x37,W
017FE:  BRA    181E
01800:  MOVF   x38,F
01802:  BNZ   181E
....................                   e_ch_n[motor]=input(ENC1_IND); 
01804:  CLRF   03
01806:  MOVLB  7
01808:  MOVF   x40,W
0180A:  ADDLW  CB
0180C:  MOVWF  FE9
0180E:  MOVLW  07
01810:  ADDWFC 03,W
01812:  MOVWF  FEA
01814:  MOVLW  00
01816:  BTFSC  F81.4
01818:  MOVLW  01
0181A:  MOVWF  FEF
0181C:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
0181E:  BCF    FD8.0
01820:  MOVLB  7
01822:  RLCF   x40,W
01824:  CLRF   03
01826:  ADDLW  6A
01828:  MOVWF  FE9
0182A:  MOVLW  07
0182C:  ADDWFC 03,W
0182E:  MOVWF  FEA
01830:  MOVFF  FEC,A38
01834:  MOVF   FED,F
01836:  MOVFF  FEF,A37
0183A:  MOVLB  A
0183C:  MOVF   x37,W
0183E:  SUBLW  02
01840:  BNZ   186A
01842:  MOVF   x38,F
01844:  BNZ   186A
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
01846:  CLRF   03
01848:  MOVLB  7
0184A:  MOVF   x40,W
0184C:  ADDLW  CB
0184E:  MOVWF  FE9
01850:  MOVLW  07
01852:  ADDWFC 03,W
01854:  MOVWF  FEA
01856:  MOVLW  00
01858:  BTFSC  F81.4
0185A:  MOVLW  01
0185C:  MOVLB  A
0185E:  MOVWF  x39
01860:  MOVLW  00
01862:  BTFSC  F81.1
01864:  MOVLW  01
01866:  ANDWF  x39,W
01868:  MOVWF  FEF
....................                } 
....................          break; 
0186A:  MOVLB  0
0186C:  BRA    18FC
....................       case 1 : if (e_type[motor]==1) { 
0186E:  BCF    FD8.0
01870:  MOVLB  7
01872:  RLCF   x40,W
01874:  CLRF   03
01876:  ADDLW  6A
01878:  MOVWF  FE9
0187A:  MOVLW  07
0187C:  ADDWFC 03,W
0187E:  MOVWF  FEA
01880:  MOVFF  FEC,A38
01884:  MOVF   FED,F
01886:  MOVFF  FEF,A37
0188A:  MOVLB  A
0188C:  DECFSZ x37,W
0188E:  BRA    18AE
01890:  MOVF   x38,F
01892:  BNZ   18AE
....................                   e_ch_n[motor]=input(ENC2_IND); 
01894:  CLRF   03
01896:  MOVLB  7
01898:  MOVF   x40,W
0189A:  ADDLW  CB
0189C:  MOVWF  FE9
0189E:  MOVLW  07
018A0:  ADDWFC 03,W
018A2:  MOVWF  FEA
018A4:  MOVLW  00
018A6:  BTFSC  F81.5
018A8:  MOVLW  01
018AA:  MOVWF  FEF
018AC:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018AE:  BCF    FD8.0
018B0:  MOVLB  7
018B2:  RLCF   x40,W
018B4:  CLRF   03
018B6:  ADDLW  6A
018B8:  MOVWF  FE9
018BA:  MOVLW  07
018BC:  ADDWFC 03,W
018BE:  MOVWF  FEA
018C0:  MOVFF  FEC,A38
018C4:  MOVF   FED,F
018C6:  MOVFF  FEF,A37
018CA:  MOVLB  A
018CC:  MOVF   x37,W
018CE:  SUBLW  02
018D0:  BNZ   18FA
018D2:  MOVF   x38,F
018D4:  BNZ   18FA
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018D6:  CLRF   03
018D8:  MOVLB  7
018DA:  MOVF   x40,W
018DC:  ADDLW  CB
018DE:  MOVWF  FE9
018E0:  MOVLW  07
018E2:  ADDWFC 03,W
018E4:  MOVWF  FEA
018E6:  MOVLW  00
018E8:  BTFSC  F81.5
018EA:  MOVLW  01
018EC:  MOVLB  A
018EE:  MOVWF  x39
018F0:  MOVLW  00
018F2:  BTFSC  F81.2
018F4:  MOVLW  01
018F6:  ANDWF  x39,W
018F8:  MOVWF  FEF
....................                } 
....................          break; 
018FA:  MOVLB  0
....................    } 
018FC:  GOTO   1A4A (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
016E2:  BCF    FD8.0
016E4:  MOVLB  7
016E6:  RLCF   x40,W
016E8:  CLRF   03
016EA:  ADDLW  BB
016EC:  MOVWF  FE9
016EE:  MOVLW  07
016F0:  ADDWFC 03,W
016F2:  MOVWF  FEA
016F4:  MOVLW  01
016F6:  ADDWF  FEE,F
016F8:  BNC   16FC
016FA:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
016FC:  MOVF   xAA,W
016FE:  XORLW  00
01700:  MOVLB  0
01702:  BZ    170E
01704:  XORLW  01
01706:  BZ    1714
01708:  XORLW  03
0170A:  BZ    1726
0170C:  BRA    1750
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
0170E:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
01710:  BCF    FF0.0
....................          break; 
01712:  BRA    1750
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01714:  MOVLW  02
01716:  MOVLB  7
01718:  MOVWF  xAA
....................                disable_interrupts(INT_EXT1_L2H); 
0171A:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
0171C:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
0171E:  BSF    FF0.3
01720:  BCF    FF1.5
....................          break; 
01722:  MOVLB  0
01724:  BRA    1750
....................       case 2 : edge_mode=1; 
01726:  MOVLW  01
01728:  MOVLB  7
0172A:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
0172C:  BCF    FD8.0
0172E:  RLCF   x40,W
01730:  CLRF   03
01732:  ADDLW  BB
01734:  MOVWF  FE9
01736:  MOVLW  07
01738:  ADDWFC 03,W
0173A:  MOVWF  FEA
0173C:  MOVLW  FF
0173E:  ADDWF  FEF,F
01740:  BC    1746
01742:  MOVF   FEE,F
01744:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
01746:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
01748:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
0174A:  BSF    FF0.3
0174C:  BSF    FF1.5
....................          break; 
0174E:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
01750:  RCALL  1252
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
01752:  BCF    FF0.0
01754:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
01758:  BCF    FD8.0
0175A:  MOVLB  7
0175C:  RLCF   x40,W
0175E:  CLRF   03
01760:  ADDLW  BB
01762:  MOVWF  FE9
01764:  MOVLW  07
01766:  ADDWFC 03,W
01768:  MOVWF  FEA
0176A:  MOVLW  01
0176C:  ADDWF  FEE,F
0176E:  BNC   1772
01770:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
01772:  MOVF   xAA,W
01774:  XORLW  00
01776:  MOVLB  0
01778:  BZ    1784
0177A:  XORLW  01
0177C:  BZ    178A
0177E:  XORLW  03
01780:  BZ    179C
01782:  BRA    17C6
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
01784:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
01786:  BCF    FF0.1
....................          break; 
01788:  BRA    17C6
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
0178A:  MOVLW  02
0178C:  MOVLB  7
0178E:  MOVWF  xAA
....................                disable_interrupts(INT_EXT2_L2H); 
01790:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
01792:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
01794:  BSF    FF0.4
01796:  BCF    FF1.4
....................          break; 
01798:  MOVLB  0
0179A:  BRA    17C6
....................       case 2 : edge_mode=1; 
0179C:  MOVLW  01
0179E:  MOVLB  7
017A0:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
017A2:  BCF    FD8.0
017A4:  RLCF   x40,W
017A6:  CLRF   03
017A8:  ADDLW  BB
017AA:  MOVWF  FE9
017AC:  MOVLW  07
017AE:  ADDWFC 03,W
017B0:  MOVWF  FEA
017B2:  MOVLW  FF
017B4:  ADDWF  FEF,F
017B6:  BC    17BC
017B8:  MOVF   FEE,F
017BA:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017BC:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017BE:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017C0:  BSF    FF0.4
017C2:  BSF    FF1.4
....................          break; 
017C4:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017C6:  RCALL  1252
.................... } 
....................  
.................... // motor step timer interrupt 
017C8:  BCF    FF0.1
017CA:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
01900:  MOVLW  F9
01902:  MOVWF  FB3
01904:  MOVLW  C0
01906:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
01908:  BCF    FD8.0
0190A:  MOVLB  7
0190C:  RLCF   x40,W
0190E:  CLRF   03
01910:  ADDLW  8E
01912:  MOVWF  FE9
01914:  MOVLW  07
01916:  ADDWFC 03,W
01918:  MOVWF  FEA
0191A:  MOVLW  01
0191C:  ADDWF  FEE,F
0191E:  BNC   1922
01920:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
01922:  BCF    FD8.0
01924:  RLCF   x40,W
01926:  CLRF   03
01928:  ADDLW  8E
0192A:  MOVWF  FE9
0192C:  MOVLW  07
0192E:  ADDWFC 03,W
01930:  MOVWF  FEA
01932:  MOVFF  FEC,A38
01936:  MOVF   FED,F
01938:  MOVFF  FEF,A37
0193C:  BCF    FD8.0
0193E:  RLCF   x40,W
01940:  CLRF   03
01942:  ADDLW  4A
01944:  MOVWF  FE9
01946:  MOVLW  07
01948:  ADDWFC 03,W
0194A:  MOVWF  FEA
0194C:  MOVFF  FEC,03
01950:  MOVF   FED,F
01952:  MOVFF  FEF,01
01956:  MOVF   03,W
01958:  MOVLB  A
0195A:  SUBWF  x38,W
0195C:  BTFSS  FD8.0
0195E:  BRA    1A4C
01960:  BNZ   196A
01962:  MOVF   01,W
01964:  SUBWF  x37,W
01966:  BTFSS  FD8.0
01968:  BRA    1A4C
....................    { 
....................       m_step_cnt[motor]++; 
0196A:  MOVLB  7
0196C:  MOVF   x40,W
0196E:  MULLW  04
01970:  MOVF   FF3,W
01972:  CLRF   03
01974:  ADDLW  A2
01976:  MOVWF  FE9
01978:  MOVLW  07
0197A:  ADDWFC 03,W
0197C:  MOVWF  FEA
0197E:  MOVLW  01
01980:  ADDWF  FEE,F
01982:  MOVLW  00
01984:  ADDWFC FEE,F
01986:  ADDWFC FEE,F
01988:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
0198A:  BCF    FD8.0
0198C:  RLCF   x40,W
0198E:  CLRF   03
01990:  ADDLW  9A
01992:  MOVWF  FE9
01994:  MOVLW  07
01996:  ADDWFC 03,W
01998:  MOVWF  FEA
0199A:  MOVLW  01
0199C:  ADDWF  FEE,F
0199E:  BNC   19A2
019A0:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
019A2:  BCF    FD8.0
019A4:  RLCF   x40,W
019A6:  CLRF   03
019A8:  ADDLW  8E
019AA:  MOVWF  FE9
019AC:  MOVLW  07
019AE:  ADDWFC 03,W
019B0:  MOVWF  FEA
019B2:  CLRF   FEC
019B4:  MOVF   FED,F
019B6:  CLRF   FEF
....................  
....................       if (motor==0) 
019B8:  MOVF   x40,F
019BA:  BNZ   19C0
....................       { 
....................          output_toggle(M1_CLOCK); 
019BC:  BTG    F90.4
....................       } 
019BE:  BRA    1A20
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019C0:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019C2:  BCF    FD8.0
019C4:  RLCF   x40,W
019C6:  CLRF   03
019C8:  ADDLW  86
019CA:  MOVWF  FE9
019CC:  MOVLW  07
019CE:  ADDWFC 03,W
019D0:  MOVWF  FEA
019D2:  MOVFF  FEC,A38
019D6:  MOVF   FED,F
019D8:  MOVFF  FEF,A37
019DC:  MOVLB  A
019DE:  MOVF   x37,F
019E0:  BNZ   1A06
019E2:  MOVF   x38,F
019E4:  BNZ   1A06
019E6:  BCF    FD8.0
019E8:  MOVLB  7
019EA:  RLCF   x40,W
019EC:  CLRF   03
019EE:  ADDLW  B3
019F0:  MOVWF  FE9
019F2:  MOVLW  07
019F4:  ADDWFC 03,W
019F6:  MOVWF  FEA
019F8:  MOVLW  FF
019FA:  ADDWF  FEF,F
019FC:  BC    1A02
019FE:  MOVF   FEE,F
01A00:  DECF   FED,F
01A02:  BRA    1A20
01A04:  MOVLB  A
....................          else m_lin_pos[motor]++;          
01A06:  BCF    FD8.0
01A08:  MOVLB  7
01A0A:  RLCF   x40,W
01A0C:  CLRF   03
01A0E:  ADDLW  B3
01A10:  MOVWF  FE9
01A12:  MOVLW  07
01A14:  ADDWFC 03,W
01A16:  MOVWF  FEA
01A18:  MOVLW  01
01A1A:  ADDWF  FEE,F
01A1C:  BNC   1A20
01A1E:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A20:  BCF    FD8.0
01A22:  RLCF   x40,W
01A24:  CLRF   03
01A26:  ADDLW  66
01A28:  MOVWF  FE9
01A2A:  MOVLW  07
01A2C:  ADDWFC 03,W
01A2E:  MOVWF  FEA
01A30:  MOVFF  FEC,A38
01A34:  MOVF   FED,F
01A36:  MOVFF  FEF,A37
01A3A:  MOVLB  A
01A3C:  MOVF   x37,W
01A3E:  SUBLW  03
01A40:  BNZ   1A4C
01A42:  MOVF   x38,F
01A44:  BNZ   1A4C
01A46:  MOVLB  0
01A48:  BRA    17CE
01A4A:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A4C:  BCF    FA1.1
01A4E:  BCF    FA1.1
01A50:  MOVLB  0
01A52:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
089E4:  BCF    FD8.0
089E6:  MOVLB  7
089E8:  RLCF   x40,W
089EA:  CLRF   03
089EC:  ADDLW  4E
089EE:  MOVWF  FE9
089F0:  MOVLW  07
089F2:  ADDWFC 03,W
089F4:  MOVWF  FEA
089F6:  MOVFF  FEC,8D9
089FA:  MOVF   FED,F
089FC:  MOVFF  FEF,8D8
08A00:  MOVLB  8
08A02:  DECFSZ xD8,W
08A04:  BRA    8A54
08A06:  MOVF   xD9,F
08A08:  BNZ   8A54
08A0A:  BCF    FD8.0
08A0C:  MOVLB  7
08A0E:  RLCF   x40,W
08A10:  CLRF   03
08A12:  ADDLW  86
08A14:  MOVWF  01
08A16:  MOVLW  07
08A18:  ADDWFC 03,F
08A1A:  MOVFF  01,8D8
08A1E:  MOVLB  8
08A20:  MOVFF  03,8D9
08A24:  BCF    FD8.0
08A26:  MOVLB  7
08A28:  RLCF   x40,W
08A2A:  CLRF   03
08A2C:  ADDLW  86
08A2E:  MOVWF  FE9
08A30:  MOVLW  07
08A32:  ADDWFC 03,W
08A34:  MOVWF  FEA
08A36:  MOVF   FEF,F
08A38:  BNZ   8A3E
08A3A:  MOVF   FEC,F
08A3C:  BZ    8A42
08A3E:  MOVLW  00
08A40:  BRA    8A44
08A42:  MOVLW  01
08A44:  MOVLB  8
08A46:  MOVFF  8D9,FEA
08A4A:  MOVFF  8D8,FE9
08A4E:  CLRF   FEC
08A50:  MOVF   FED,F
08A52:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
08A54:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
08A56:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
08A58:  BCF    FD8.0
08A5A:  MOVLB  7
08A5C:  RLCF   x40,W
08A5E:  CLRF   03
08A60:  ADDLW  42
08A62:  MOVWF  FE9
08A64:  MOVLW  07
08A66:  ADDWFC 03,W
08A68:  MOVWF  FEA
08A6A:  MOVF   FEF,F
08A6C:  BNZ   8A76
08A6E:  MOVF   FEC,F
08A70:  BNZ   8A76
08A72:  BCF    F90.2
08A74:  BRA    8A78
08A76:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
08A78:  BCF    FD8.0
08A7A:  RLCF   x40,W
08A7C:  CLRF   03
08A7E:  ADDLW  46
08A80:  MOVWF  FE9
08A82:  MOVLW  07
08A84:  ADDWFC 03,W
08A86:  MOVWF  FEA
08A88:  MOVF   FEF,F
08A8A:  BNZ   8A94
08A8C:  MOVF   FEC,F
08A8E:  BNZ   8A94
08A90:  BCF    F90.3
08A92:  BRA    8A96
08A94:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
08A96:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
08A98:  BCF    FD8.0
08A9A:  RLCF   x40,W
08A9C:  CLRF   03
08A9E:  ADDLW  86
08AA0:  MOVWF  FE9
08AA2:  MOVLW  07
08AA4:  ADDWFC 03,W
08AA6:  MOVWF  FEA
08AA8:  MOVF   FEF,F
08AAA:  BNZ   8AB4
08AAC:  MOVF   FEC,F
08AAE:  BNZ   8AB4
08AB0:  BCF    F90.5
08AB2:  BRA    8AB6
08AB4:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08AB6:  BCF    FD8.0
08AB8:  RLCF   x40,W
08ABA:  CLRF   03
08ABC:  ADDLW  56
08ABE:  MOVWF  FE9
08AC0:  MOVLW  07
08AC2:  ADDWFC 03,W
08AC4:  MOVWF  FEA
08AC6:  MOVFF  FEC,8D9
08ACA:  MOVF   FED,F
08ACC:  MOVFF  FEF,8D8
08AD0:  MOVLB  8
08AD2:  RRCF   xD9,F
08AD4:  RRCF   xD8,F
08AD6:  RRCF   xD9,F
08AD8:  RRCF   xD8,F
08ADA:  RRCF   xD9,F
08ADC:  MOVFF  8D8,FBC
08AE0:  RRCF   xD9,F
08AE2:  RRCF   xD9,W
08AE4:  ANDLW  30
08AE6:  MOVWF  00
08AE8:  MOVF   FBB,W
08AEA:  ANDLW  CF
08AEC:  IORWF  00,W
08AEE:  MOVWF  FBB
08AF0:  MOVLB  0
08AF2:  GOTO   8C7C (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08AF6:  BCF    FD8.0
08AF8:  MOVLB  7
08AFA:  RLCF   x40,W
08AFC:  CLRF   03
08AFE:  ADDLW  4E
08B00:  MOVWF  FE9
08B02:  MOVLW  07
08B04:  ADDWFC 03,W
08B06:  MOVWF  FEA
08B08:  MOVFF  FEC,8D9
08B0C:  MOVF   FED,F
08B0E:  MOVFF  FEF,8D8
08B12:  MOVLB  8
08B14:  DECFSZ xD8,W
08B16:  BRA    8B66
08B18:  MOVF   xD9,F
08B1A:  BNZ   8B66
08B1C:  BCF    FD8.0
08B1E:  MOVLB  7
08B20:  RLCF   x40,W
08B22:  CLRF   03
08B24:  ADDLW  86
08B26:  MOVWF  01
08B28:  MOVLW  07
08B2A:  ADDWFC 03,F
08B2C:  MOVFF  01,8D8
08B30:  MOVLB  8
08B32:  MOVFF  03,8D9
08B36:  BCF    FD8.0
08B38:  MOVLB  7
08B3A:  RLCF   x40,W
08B3C:  CLRF   03
08B3E:  ADDLW  86
08B40:  MOVWF  FE9
08B42:  MOVLW  07
08B44:  ADDWFC 03,W
08B46:  MOVWF  FEA
08B48:  MOVF   FEF,F
08B4A:  BNZ   8B50
08B4C:  MOVF   FEC,F
08B4E:  BZ    8B54
08B50:  MOVLW  00
08B52:  BRA    8B56
08B54:  MOVLW  01
08B56:  MOVLB  8
08B58:  MOVFF  8D9,FEA
08B5C:  MOVFF  8D8,FE9
08B60:  CLRF   FEC
08B62:  MOVF   FED,F
08B64:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08B66:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08B68:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08B6A:  BCF    FD8.0
08B6C:  MOVLB  7
08B6E:  RLCF   x40,W
08B70:  CLRF   03
08B72:  ADDLW  42
08B74:  MOVWF  FE9
08B76:  MOVLW  07
08B78:  ADDWFC 03,W
08B7A:  MOVWF  FEA
08B7C:  MOVF   FEF,F
08B7E:  BNZ   8B88
08B80:  MOVF   FEC,F
08B82:  BNZ   8B88
08B84:  BCF    F8D.2
08B86:  BRA    8B8A
08B88:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08B8A:  BCF    FD8.0
08B8C:  RLCF   x40,W
08B8E:  CLRF   03
08B90:  ADDLW  46
08B92:  MOVWF  FE9
08B94:  MOVLW  07
08B96:  ADDWFC 03,W
08B98:  MOVWF  FEA
08B9A:  MOVF   FEF,F
08B9C:  BNZ   8BA6
08B9E:  MOVF   FEC,F
08BA0:  BNZ   8BA6
08BA2:  BCF    F8D.3
08BA4:  BRA    8BA8
08BA6:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08BA8:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08BAA:  BCF    FD8.0
08BAC:  RLCF   x40,W
08BAE:  CLRF   03
08BB0:  ADDLW  86
08BB2:  MOVWF  FE9
08BB4:  MOVLW  07
08BB6:  ADDWFC 03,W
08BB8:  MOVWF  FEA
08BBA:  MOVF   FEF,F
08BBC:  BNZ   8BC6
08BBE:  MOVF   FEC,F
08BC0:  BNZ   8BC6
08BC2:  BCF    F8D.5
08BC4:  BRA    8BC8
08BC6:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08BC8:  BCF    FD8.0
08BCA:  RLCF   x40,W
08BCC:  CLRF   03
08BCE:  ADDLW  56
08BD0:  MOVWF  FE9
08BD2:  MOVLW  07
08BD4:  ADDWFC 03,W
08BD6:  MOVWF  FEA
08BD8:  MOVFF  FEC,8D9
08BDC:  MOVF   FED,F
08BDE:  MOVFF  FEF,8D8
08BE2:  MOVLB  8
08BE4:  RRCF   xD9,F
08BE6:  RRCF   xD8,F
08BE8:  RRCF   xD9,F
08BEA:  RRCF   xD8,F
08BEC:  RRCF   xD9,F
08BEE:  MOVFF  8D8,F4F
08BF2:  RRCF   xD9,F
08BF4:  RRCF   xD9,W
08BF6:  ANDLW  30
08BF8:  MOVWF  00
08BFA:  MOVLB  F
08BFC:  MOVF   x4E,W
08BFE:  ANDLW  CF
08C00:  IORWF  00,W
08C02:  MOVWF  x4E
08C04:  MOVLB  0
08C06:  GOTO   8C7C (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
089D0:  MOVLB  8
089D2:  MOVF   xEC,F
089D4:  BZ    89DC
....................       output_bit(VENC1,ON); 
089D6:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
089D8:  BSF    F8E.7
....................    } 
089DA:  BRA    89E0
....................    else {       
....................       output_bit(VENC1,OFF); 
089DC:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
089DE:  BCF    F8E.7
....................    } 
089E0:  MOVLB  0
089E2:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08D6A:  MOVLB  8
08D6C:  MOVF   xED,F
08D6E:  BNZ   8D96
08D70:  MOVF   xEE,F
08D72:  BNZ   8D96
....................       edge_mode=0; 
08D74:  MOVLB  7
08D76:  CLRF   xAA
....................       switch (motor){ 
08D78:  MOVF   x40,W
08D7A:  XORLW  00
08D7C:  MOVLB  0
08D7E:  BZ    8D86
08D80:  XORLW  01
08D82:  BZ    8D8E
08D84:  BRA    8D94
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08D86:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08D88:  BSF    FF0.3
08D8A:  BCF    FF1.5
....................             break; 
08D8C:  BRA    8D94
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08D8E:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08D90:  BSF    FF0.4
08D92:  BCF    FF1.4
....................             break; 
08D94:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08D96:  DECFSZ xED,W
08D98:  BRA    8DC0
08D9A:  MOVF   xEE,F
08D9C:  BNZ   8DC0
....................       edge_mode=0; 
08D9E:  MOVLB  7
08DA0:  CLRF   xAA
....................       switch (motor){ 
08DA2:  MOVF   x40,W
08DA4:  XORLW  00
08DA6:  MOVLB  0
08DA8:  BZ    8DB0
08DAA:  XORLW  01
08DAC:  BZ    8DB8
08DAE:  BRA    8DBE
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08DB0:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08DB2:  BSF    FF0.3
08DB4:  BSF    FF1.5
....................             break; 
08DB6:  BRA    8DBE
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08DB8:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08DBA:  BSF    FF0.4
08DBC:  BSF    FF1.4
....................             break; 
08DBE:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08DC0:  MOVF   xED,W
08DC2:  SUBLW  02
08DC4:  BNZ   8E16
08DC6:  MOVF   xEE,F
08DC8:  BNZ   8E16
08DCA:  BCF    FD8.0
08DCC:  MOVLB  7
08DCE:  RLCF   x40,W
08DD0:  CLRF   03
08DD2:  ADDLW  6A
08DD4:  MOVWF  FE9
08DD6:  MOVLW  07
08DD8:  ADDWFC 03,W
08DDA:  MOVWF  FEA
08DDC:  MOVFF  FEC,8F0
08DE0:  MOVF   FED,F
08DE2:  MOVFF  FEF,8EF
08DE6:  MOVLB  8
08DE8:  MOVF   xEF,W
08DEA:  SUBLW  02
08DEC:  BNZ   8E16
08DEE:  MOVF   xF0,F
08DF0:  BNZ   8E16
....................       edge_mode=1; 
08DF2:  MOVLW  01
08DF4:  MOVLB  7
08DF6:  MOVWF  xAA
....................       switch (motor){ 
08DF8:  MOVF   x40,W
08DFA:  XORLW  00
08DFC:  MOVLB  0
08DFE:  BZ    8E06
08E00:  XORLW  01
08E02:  BZ    8E0E
08E04:  BRA    8E14
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08E06:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08E08:  BSF    FF0.3
08E0A:  BSF    FF1.5
....................             break; 
08E0C:  BRA    8E14
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08E0E:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08E10:  BSF    FF0.4
08E12:  BSF    FF1.4
....................             break; 
08E14:  MOVLB  8
....................       }  
....................    }     
08E16:  MOVLB  0
08E18:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08F80:  MOVLB  7
08F82:  MOVF   x40,W
08F84:  XORLW  00
08F86:  MOVLB  0
08F88:  BZ    8F90
08F8A:  XORLW  01
08F8C:  BZ    8FBA
08F8E:  BRA    8FE2
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08F90:  BCF    FD8.0
08F92:  MOVLB  7
08F94:  RLCF   x40,W
08F96:  CLRF   03
08F98:  ADDLW  96
08F9A:  MOVWF  FE9
08F9C:  MOVLW  07
08F9E:  ADDWFC 03,W
08FA0:  MOVWF  FEA
08FA2:  MOVFF  FEC,8F0
08FA6:  MOVF   FED,F
08FA8:  MOVFF  FEF,8EF
08FAC:  MOVLW  6E
08FAE:  MOVLB  8
08FB0:  MOVWF  xEE
08FB2:  MOVLB  0
08FB4:  CALL   4FD4
....................          break; 
08FB8:  BRA    8FE2
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08FBA:  BCF    FD8.0
08FBC:  MOVLB  7
08FBE:  RLCF   x40,W
08FC0:  CLRF   03
08FC2:  ADDLW  96
08FC4:  MOVWF  FE9
08FC6:  MOVLW  07
08FC8:  ADDWFC 03,W
08FCA:  MOVWF  FEA
08FCC:  MOVFF  FEC,8F0
08FD0:  MOVF   FED,F
08FD2:  MOVFF  FEF,8EF
08FD6:  MOVLW  70
08FD8:  MOVLB  8
08FDA:  MOVWF  xEE
08FDC:  MOVLB  0
08FDE:  CALL   4FD4
....................          break;          
....................    } 
08FE2:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08E1A:  MOVLB  8
08E1C:  MOVF   xEC,F
08E1E:  BNZ   8E3C
....................    { 
....................       switch (motor) 
08E20:  MOVLB  7
08E22:  MOVF   x40,W
08E24:  XORLW  00
08E26:  MOVLB  0
08E28:  BZ    8E30
08E2A:  XORLW  01
08E2C:  BZ    8E36
08E2E:  BRA    8E3A
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08E30:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08E32:  BCF    FF0.3
....................             break; 
08E34:  BRA    8E3A
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08E36:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08E38:  BCF    FF0.4
....................             break; 
08E3A:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08E3C:  DECFSZ xEC,W
08E3E:  BRA    8EA4
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08E40:  BCF    FD8.0
08E42:  MOVLB  7
08E44:  RLCF   x40,W
08E46:  CLRF   03
08E48:  ADDLW  6A
08E4A:  MOVWF  FE9
08E4C:  MOVLW  07
08E4E:  ADDWFC 03,W
08E50:  MOVWF  FEA
08E52:  MOVFF  FEC,8EE
08E56:  MOVF   FED,F
08E58:  MOVFF  FEF,8ED
08E5C:  MOVLB  8
08E5E:  DECFSZ xED,W
08E60:  BRA    8E70
08E62:  MOVF   xEE,F
08E64:  BNZ   8E70
08E66:  CLRF   xEE
08E68:  CLRF   xED
08E6A:  MOVLB  0
08E6C:  RCALL  8D6A
08E6E:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08E70:  BCF    FD8.0
08E72:  MOVLB  7
08E74:  RLCF   x40,W
08E76:  CLRF   03
08E78:  ADDLW  6A
08E7A:  MOVWF  FE9
08E7C:  MOVLW  07
08E7E:  ADDWFC 03,W
08E80:  MOVWF  FEA
08E82:  MOVFF  FEC,8EE
08E86:  MOVF   FED,F
08E88:  MOVFF  FEF,8ED
08E8C:  MOVLB  8
08E8E:  MOVF   xED,W
08E90:  SUBLW  02
08E92:  BNZ   8EA4
08E94:  MOVF   xEE,F
08E96:  BNZ   8EA4
08E98:  CLRF   xEE
08E9A:  MOVLW  01
08E9C:  MOVWF  xED
08E9E:  MOVLB  0
08EA0:  RCALL  8D6A
08EA2:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08EA4:  MOVF   xEC,W
08EA6:  SUBLW  02
08EA8:  BNZ   8EDE
08EAA:  BCF    FD8.0
08EAC:  MOVLB  7
08EAE:  RLCF   x40,W
08EB0:  CLRF   03
08EB2:  ADDLW  6A
08EB4:  MOVWF  FE9
08EB6:  MOVLW  07
08EB8:  ADDWFC 03,W
08EBA:  MOVWF  FEA
08EBC:  MOVFF  FEC,8EE
08EC0:  MOVF   FED,F
08EC2:  MOVFF  FEF,8ED
08EC6:  MOVLB  8
08EC8:  MOVF   xED,W
08ECA:  SUBLW  02
08ECC:  BNZ   8EDE
08ECE:  MOVF   xEE,F
08ED0:  BNZ   8EDE
....................    { 
....................       enable_enc_isr(2);   
08ED2:  CLRF   xEE
08ED4:  MOVLW  02
08ED6:  MOVWF  xED
08ED8:  MOVLB  0
08EDA:  RCALL  8D6A
08EDC:  MOVLB  8
....................    } 
08EDE:  MOVLB  0
08EE0:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08C0A:  BCF    FD8.0
08C0C:  MOVLB  7
08C0E:  RLCF   x40,W
08C10:  CLRF   03
08C12:  ADDLW  8E
08C14:  MOVWF  FE9
08C16:  MOVLW  07
08C18:  ADDWFC 03,W
08C1A:  MOVWF  FEA
08C1C:  CLRF   FEC
08C1E:  MOVF   FED,F
08C20:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08C22:  BCF    FD8.0
08C24:  RLCF   x40,W
08C26:  CLRF   03
08C28:  ADDLW  BB
08C2A:  MOVWF  FE9
08C2C:  MOVLW  07
08C2E:  ADDWFC 03,W
08C30:  MOVWF  FEA
08C32:  CLRF   FEC
08C34:  MOVF   FED,F
08C36:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08C38:  BCF    FD8.0
08C3A:  RLCF   x40,W
08C3C:  CLRF   03
08C3E:  ADDLW  9A
08C40:  MOVWF  FE9
08C42:  MOVLW  07
08C44:  ADDWFC 03,W
08C46:  MOVWF  FEA
08C48:  CLRF   FEC
08C4A:  MOVF   FED,F
08C4C:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08C4E:  BSF    F8E.1
....................    enc_pwr(ON); 
08C50:  MOVLW  01
08C52:  MOVLB  8
08C54:  MOVWF  xEC
08C56:  MOVLB  0
08C58:  RCALL  89D0
....................    delay_ms(100); 
08C5A:  MOVLW  64
08C5C:  MOVLB  9
08C5E:  MOVWF  xEC
08C60:  MOVLB  0
08C62:  CALL   2910
....................     
....................    switch (motor){ 
08C66:  MOVLB  7
08C68:  MOVF   x40,W
08C6A:  XORLW  00
08C6C:  MOVLB  0
08C6E:  BZ    8C76
08C70:  XORLW  01
08C72:  BZ    8C7A
08C74:  BRA    8C7C
....................       case 0 : motor_setup1(); 
08C76:  BRA    89E4
....................          break; 
08C78:  BRA    8C7C
....................       case 1 : motor_setup2(); 
08C7A:  BRA    8AF6
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08C7C:  BCF    FD8.0
08C7E:  MOVLB  7
08C80:  RLCF   x40,W
08C82:  CLRF   03
08C84:  ADDLW  8A
08C86:  MOVWF  FE9
08C88:  MOVLW  07
08C8A:  ADDWFC 03,W
08C8C:  MOVWF  FEA
08C8E:  MOVFF  FEC,8D9
08C92:  MOVF   FED,F
08C94:  MOVFF  FEF,8D8
08C98:  BCF    FD8.0
08C9A:  RLCF   x40,W
08C9C:  CLRF   03
08C9E:  ADDLW  86
08CA0:  MOVWF  FE9
08CA2:  MOVLW  07
08CA4:  ADDWFC 03,W
08CA6:  MOVWF  FEA
08CA8:  MOVFF  FEC,03
08CAC:  MOVF   FED,F
08CAE:  MOVF   FEF,W
08CB0:  MOVLB  8
08CB2:  SUBWF  xD8,W
08CB4:  BNZ   8CBC
08CB6:  MOVF   03,W
08CB8:  SUBWF  xD9,W
08CBA:  BZ    8D64
....................       m_way_rst[motor]=m_way[motor]; 
08CBC:  BCF    FD8.0
08CBE:  MOVLB  7
08CC0:  RLCF   x40,W
08CC2:  CLRF   03
08CC4:  ADDLW  8A
08CC6:  MOVWF  01
08CC8:  MOVLW  07
08CCA:  ADDWFC 03,F
08CCC:  MOVLB  8
08CCE:  MOVFF  03,8D9
08CD2:  BCF    FD8.0
08CD4:  MOVLB  7
08CD6:  RLCF   x40,W
08CD8:  CLRF   03
08CDA:  ADDLW  86
08CDC:  MOVWF  FE9
08CDE:  MOVLW  07
08CE0:  ADDWFC 03,W
08CE2:  MOVWF  FEA
08CE4:  MOVFF  FEC,03
08CE8:  MOVF   FED,F
08CEA:  MOVFF  FEF,8DA
08CEE:  MOVLB  8
08CF0:  MOVFF  8D9,FEA
08CF4:  MOVFF  01,FE9
08CF8:  MOVFF  03,FEC
08CFC:  MOVF   FED,F
08CFE:  MOVFF  8DA,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08D02:  BCF    FD8.0
08D04:  MOVLB  7
08D06:  RLCF   x40,W
08D08:  CLRF   03
08D0A:  ADDLW  9E
08D0C:  MOVWF  01
08D0E:  MOVLW  07
08D10:  ADDWFC 03,F
08D12:  MOVLB  8
08D14:  MOVFF  03,8D9
08D18:  BCF    FD8.0
08D1A:  MOVLB  7
08D1C:  RLCF   x40,W
08D1E:  CLRF   03
08D20:  ADDLW  66
08D22:  MOVWF  FE9
08D24:  MOVLW  07
08D26:  ADDWFC 03,W
08D28:  MOVWF  FEA
08D2A:  MOVFF  FEC,03
08D2E:  MOVF   FED,F
08D30:  MOVFF  FEF,8DA
08D34:  MOVLB  8
08D36:  MOVFF  8D9,FEA
08D3A:  MOVFF  01,FE9
08D3E:  MOVFF  03,FEC
08D42:  MOVF   FED,F
08D44:  MOVFF  8DA,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08D48:  BCF    FD8.0
08D4A:  MOVLB  7
08D4C:  RLCF   x40,W
08D4E:  CLRF   03
08D50:  ADDLW  66
08D52:  MOVWF  FE9
08D54:  MOVLW  07
08D56:  ADDWFC 03,W
08D58:  MOVWF  FEA
08D5A:  CLRF   FEC
08D5C:  MOVF   FED,F
08D5E:  MOVLW  05
08D60:  MOVWF  FEF
08D62:  MOVLB  8
....................    } 
08D64:  MOVLB  0
08D66:  GOTO   8EE4 (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08EE2:  BRA    8C0A
....................     
....................    m_comp[motor]=FALSE; 
08EE4:  BCF    FD8.0
08EE6:  MOVLB  7
08EE8:  RLCF   x40,W
08EEA:  CLRF   03
08EEC:  ADDLW  AF
08EEE:  MOVWF  FE9
08EF0:  MOVLW  07
08EF2:  ADDWFC 03,W
08EF4:  MOVWF  FEA
08EF6:  CLRF   FEC
08EF8:  MOVF   FED,F
08EFA:  CLRF   FEF
....................     
....................    switch (motor){ 
08EFC:  MOVF   x40,W
08EFE:  XORLW  00
08F00:  MOVLB  0
08F02:  BZ    8F0A
08F04:  XORLW  01
08F06:  BZ    8F1C
08F08:  BRA    8F2C
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08F0A:  MOVLW  B2
08F0C:  MOVLB  8
08F0E:  MOVWF  xEE
08F10:  CLRF   xF0
08F12:  CLRF   xEF
08F14:  MOVLB  0
08F16:  CALL   4FD4
....................          break; 
08F1A:  BRA    8F2C
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08F1C:  MOVLW  B4
08F1E:  MOVLB  8
08F20:  MOVWF  xEE
08F22:  CLRF   xF0
08F24:  CLRF   xEF
08F26:  MOVLB  0
08F28:  CALL   4FD4
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08F2C:  MOVLB  7
08F2E:  MOVF   x40,W
08F30:  XORLW  00
08F32:  MOVLB  0
08F34:  BZ    8F3C
08F36:  XORLW  01
08F38:  BZ    8F40
08F3A:  BRA    8F42
....................       case 0 : output_bit(M1_ENABLE, ON); 
08F3C:  BSF    F90.1
....................          break; 
08F3E:  BRA    8F42
....................       case 1 : output_bit(M2_ENABLE, ON); 
08F40:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08F42:  MOVLW  32
08F44:  MOVLB  9
08F46:  MOVWF  xEC
08F48:  MOVLB  0
08F4A:  CALL   2910
....................     
....................    set_timer3(STEP_INTERVAL); 
08F4E:  MOVLW  F9
08F50:  MOVWF  FB3
08F52:  MOVLW  C0
08F54:  MOVWF  FB2
....................    enc_isr(int_mode); 
08F56:  MOVFF  8D7,8EC
08F5A:  RCALL  8E1A
....................    clear_interrupt(INT_TIMER3); 
08F5C:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08F5E:  BCF    FD8.0
08F60:  MOVLB  7
08F62:  RLCF   x40,W
08F64:  CLRF   03
08F66:  ADDLW  92
08F68:  MOVWF  FE9
08F6A:  MOVLW  07
08F6C:  ADDWFC 03,W
08F6E:  MOVWF  FEA
08F70:  CLRF   FEC
08F72:  MOVF   FED,F
08F74:  MOVLW  01
08F76:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08F78:  BSF    FA0.1
08F7A:  MOVLB  0
08F7C:  GOTO   A1F4 (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
08606:  MOVFF  8DA,8E2
0860A:  MOVFF  8D9,8E1
0860E:  MOVFF  8D8,8E0
08612:  MOVFF  8D7,8DF
....................    enc_res    = e_cpr[motor]; 
08616:  BCF    FD8.0
08618:  MOVLB  7
0861A:  RLCF   x40,W
0861C:  CLRF   03
0861E:  ADDLW  5E
08620:  MOVWF  FE9
08622:  MOVLW  07
08624:  ADDWFC 03,W
08626:  MOVWF  FEA
08628:  MOVLB  8
0862A:  CLRF   xE6
0862C:  CLRF   xE5
0862E:  MOVFF  FEC,8E4
08632:  MOVF   FED,F
08634:  MOVFF  FEF,8E3
....................    ports      = e_ppr[motor]; 
08638:  BCF    FD8.0
0863A:  MOVLB  7
0863C:  RLCF   x40,W
0863E:  CLRF   03
08640:  ADDLW  62
08642:  MOVWF  FE9
08644:  MOVLW  07
08646:  ADDWFC 03,W
08648:  MOVWF  FEA
0864A:  MOVLB  8
0864C:  CLRF   xEE
0864E:  CLRF   xED
08650:  MOVFF  FEC,8EC
08654:  MOVF   FED,F
08656:  MOVFF  FEF,8EB
....................     
....................    enc_res = enc_res * 1000; 
0865A:  MOVFF  8E6,9F9
0865E:  MOVFF  8E5,9F8
08662:  MOVFF  8E4,9F7
08666:  MOVFF  8E3,9F6
0866A:  MOVLB  9
0866C:  CLRF   xFD
0866E:  CLRF   xFC
08670:  MOVLW  03
08672:  MOVWF  xFB
08674:  MOVLW  E8
08676:  MOVWF  xFA
08678:  MOVLB  0
0867A:  CALL   47F0
0867E:  MOVFF  03,8E6
08682:  MOVFF  02,8E5
08686:  MOVFF  01,8E4
0868A:  MOVFF  00,8E3
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
0868E:  BCF    FD8.1
08690:  CLRF   1B
08692:  BTFSC  FF2.7
08694:  BSF    1B.7
08696:  BCF    FF2.7
08698:  MOVFF  8E6,A4F
0869C:  MOVFF  8E5,A4E
086A0:  MOVFF  8E4,A4D
086A4:  MOVFF  8E3,A4C
086A8:  MOVFF  8EE,A53
086AC:  MOVFF  8ED,A52
086B0:  MOVFF  8EC,A51
086B4:  MOVFF  8EB,A50
086B8:  CALL   104E
086BC:  BTFSC  1B.7
086BE:  BSF    FF2.7
086C0:  MOVFF  03,8DE
086C4:  MOVFF  02,8DD
086C8:  MOVFF  01,8DC
086CC:  MOVFF  00,8DB
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
086D0:  MOVFF  8DA,9F9
086D4:  MOVFF  8D9,9F8
086D8:  MOVFF  8D8,9F7
086DC:  MOVFF  8D7,9F6
086E0:  MOVFF  8DE,9FD
086E4:  MOVFF  8DD,9FC
086E8:  MOVFF  8DC,9FB
086EC:  MOVFF  8DB,9FA
086F0:  CALL   47F0
086F4:  MOVLB  8
086F6:  MOVF   xDB,W
086F8:  SUBWF  00,W
086FA:  MOVWF  xDF
086FC:  MOVF   xDC,W
086FE:  SUBWFB 01,W
08700:  MOVWF  xE0
08702:  MOVF   xDD,W
08704:  SUBWFB 02,W
08706:  MOVWF  xE1
08708:  MOVF   xDE,W
0870A:  SUBWFB 03,W
0870C:  MOVWF  xE2
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
0870E:  BCF    FD8.1
08710:  CLRF   1B
08712:  BTFSC  FF2.7
08714:  BSF    1B.7
08716:  BCF    FF2.7
08718:  MOVFF  8E2,A4F
0871C:  MOVFF  8E1,A4E
08720:  MOVFF  8E0,A4D
08724:  MOVFF  8DF,A4C
08728:  MOVLB  A
0872A:  CLRF   x53
0872C:  CLRF   x52
0872E:  MOVLW  03
08730:  MOVWF  x51
08732:  MOVLW  E8
08734:  MOVWF  x50
08736:  MOVLB  0
08738:  CALL   104E
0873C:  BTFSC  1B.7
0873E:  BSF    FF2.7
08740:  MOVFF  03,8EA
08744:  MOVFF  02,8E9
08748:  MOVFF  01,8E8
0874C:  MOVFF  00,8E7
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
08750:  MOVFF  8EA,9F9
08754:  MOVFF  8E9,9F8
08758:  MOVFF  8E8,9F7
0875C:  MOVFF  8E7,9F6
08760:  MOVLB  9
08762:  CLRF   xFD
08764:  CLRF   xFC
08766:  MOVLW  03
08768:  MOVWF  xFB
0876A:  MOVLW  E8
0876C:  MOVWF  xFA
0876E:  MOVLB  0
08770:  CALL   47F0
08774:  MOVFF  03,8EA
08778:  MOVFF  02,8E9
0877C:  MOVFF  01,8E8
08780:  MOVFF  00,8E7
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
08784:  MOVLB  8
08786:  MOVF   xE7,W
08788:  SUBWF  xDF,F
0878A:  MOVF   xE8,W
0878C:  SUBWFB xE0,F
0878E:  MOVF   xE9,W
08790:  SUBWFB xE1,F
08792:  MOVF   xEA,W
08794:  SUBWFB xE2,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
08796:  BCF    FD8.1
08798:  CLRF   1B
0879A:  BTFSC  FF2.7
0879C:  BSF    1B.7
0879E:  BCF    FF2.7
087A0:  MOVFF  8EA,A4F
087A4:  MOVFF  8E9,A4E
087A8:  MOVFF  8E8,A4D
087AC:  MOVFF  8E7,A4C
087B0:  MOVLB  A
087B2:  CLRF   x53
087B4:  CLRF   x52
087B6:  MOVLW  03
087B8:  MOVWF  x51
087BA:  MOVLW  E8
087BC:  MOVWF  x50
087BE:  MOVLB  0
087C0:  CALL   104E
087C4:  BTFSC  1B.7
087C6:  BSF    FF2.7
087C8:  MOVFF  03,8EA
087CC:  MOVFF  02,8E9
087D0:  MOVFF  01,8E8
087D4:  MOVFF  00,8E7
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
087D8:  MOVLB  8
087DA:  MOVF   xE2,F
087DC:  BNZ   87F2
087DE:  MOVF   xE1,F
087E0:  BNZ   87F2
087E2:  MOVF   xE0,W
087E4:  SUBLW  00
087E6:  BC    8802
087E8:  XORLW  FF
087EA:  BNZ   87F2
087EC:  MOVF   xDF,W
087EE:  SUBLW  F3
087F0:  BC    8802
087F2:  MOVLW  01
087F4:  ADDWF  xE7,F
087F6:  BTFSC  FD8.0
087F8:  INCF   xE8,F
087FA:  BTFSC  FD8.2
087FC:  INCF   xE9,F
087FE:  BTFSC  FD8.2
08800:  INCF   xEA,F
....................    return(enc_pos); 
08802:  MOVFF  8E7,00
08806:  MOVFF  8E8,01
0880A:  MOVFF  8E9,02
0880E:  MOVFF  8EA,03
08812:  MOVLB  0
08814:  GOTO   A17C (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
08818:  BCF    FD8.0
0881A:  MOVLB  7
0881C:  RLCF   x40,W
0881E:  CLRF   03
08820:  ADDLW  BF
08822:  MOVWF  FE9
08824:  MOVLW  07
08826:  ADDWFC 03,W
08828:  MOVWF  FEA
0882A:  MOVFF  FEC,03
0882E:  MOVF   FED,F
08830:  MOVFF  FEF,01
08834:  MOVF   03,W
08836:  MOVLB  8
08838:  SUBWF  xDA,W
0883A:  BNC   8902
0883C:  BNZ   8844
0883E:  MOVF   xD9,W
08840:  SUBWF  01,W
08842:  BC    8902
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
08844:  BCF    FD8.0
08846:  MOVLB  7
08848:  RLCF   x40,W
0884A:  CLRF   03
0884C:  ADDLW  BF
0884E:  MOVWF  FE9
08850:  MOVLW  07
08852:  ADDWFC 03,W
08854:  MOVWF  FEA
08856:  MOVFF  FEC,03
0885A:  MOVF   FED,F
0885C:  MOVF   FEF,W
0885E:  MOVLB  8
08860:  SUBWF  xD9,W
08862:  MOVWF  xDB
08864:  MOVF   03,W
08866:  SUBWFB xDA,W
08868:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0886A:  BCF    FD8.0
0886C:  MOVLB  7
0886E:  RLCF   x40,W
08870:  CLRF   03
08872:  ADDLW  5E
08874:  MOVWF  FE9
08876:  MOVLW  07
08878:  ADDWFC 03,W
0887A:  MOVWF  FEA
0887C:  MOVFF  FEC,8DE
08880:  MOVF   FED,F
08882:  MOVFF  FEF,8DD
08886:  BCF    FD8.0
08888:  MOVLB  8
0888A:  RRCF   xDE,W
0888C:  MOVWF  03
0888E:  RRCF   xDD,W
08890:  MOVWF  02
08892:  MOVWF  01
08894:  MOVF   03,W
08896:  SUBWF  xDC,W
08898:  BNC   88E6
0889A:  BNZ   88A2
0889C:  MOVF   xDB,W
0889E:  SUBWF  01,W
088A0:  BC    88E6
....................       { 
....................          m_way[motor] = NEG; 
088A2:  BCF    FD8.0
088A4:  MOVLB  7
088A6:  RLCF   x40,W
088A8:  CLRF   03
088AA:  ADDLW  86
088AC:  MOVWF  FE9
088AE:  MOVLW  07
088B0:  ADDWFC 03,W
088B2:  MOVWF  FEA
088B4:  CLRF   FEC
088B6:  MOVF   FED,F
088B8:  MOVLW  01
088BA:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088BC:  BCF    FD8.0
088BE:  RLCF   x40,W
088C0:  CLRF   03
088C2:  ADDLW  5E
088C4:  MOVWF  FE9
088C6:  MOVLW  07
088C8:  ADDWFC 03,W
088CA:  MOVWF  FEA
088CC:  MOVFF  FEC,8DE
088D0:  MOVF   FED,F
088D2:  MOVFF  FEF,8DD
088D6:  MOVLB  8
088D8:  MOVF   xDB,W
088DA:  SUBWF  xDD,W
088DC:  MOVWF  xDB
088DE:  MOVF   xDC,W
088E0:  SUBWFB xDE,W
088E2:  MOVWF  xDC
....................       } 
088E4:  BRA    8900
....................       else 
....................       { 
....................          m_way[motor] = POS; 
088E6:  BCF    FD8.0
088E8:  MOVLB  7
088EA:  RLCF   x40,W
088EC:  CLRF   03
088EE:  ADDLW  86
088F0:  MOVWF  FE9
088F2:  MOVLW  07
088F4:  ADDWFC 03,W
088F6:  MOVWF  FEA
088F8:  CLRF   FEC
088FA:  MOVF   FED,F
088FC:  CLRF   FEF
088FE:  MOVLB  8
....................       } 
....................    } 
08900:  BRA    89C2
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
08902:  BCF    FD8.0
08904:  MOVLB  7
08906:  RLCF   x40,W
08908:  CLRF   03
0890A:  ADDLW  BF
0890C:  MOVWF  FE9
0890E:  MOVLW  07
08910:  ADDWFC 03,W
08912:  MOVWF  FEA
08914:  MOVFF  FEC,8DE
08918:  MOVF   FED,F
0891A:  MOVFF  FEF,8DD
0891E:  MOVLB  8
08920:  MOVF   xD9,W
08922:  SUBWF  xDD,W
08924:  MOVWF  xDB
08926:  MOVF   xDA,W
08928:  SUBWFB xDE,W
0892A:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0892C:  BCF    FD8.0
0892E:  MOVLB  7
08930:  RLCF   x40,W
08932:  CLRF   03
08934:  ADDLW  5E
08936:  MOVWF  FE9
08938:  MOVLW  07
0893A:  ADDWFC 03,W
0893C:  MOVWF  FEA
0893E:  MOVFF  FEC,8DE
08942:  MOVF   FED,F
08944:  MOVFF  FEF,8DD
08948:  BCF    FD8.0
0894A:  MOVLB  8
0894C:  RRCF   xDE,W
0894E:  MOVWF  03
08950:  RRCF   xDD,W
08952:  MOVWF  02
08954:  MOVWF  01
08956:  MOVF   03,W
08958:  SUBWF  xDC,W
0895A:  BNC   89A6
0895C:  BNZ   8964
0895E:  MOVF   xDB,W
08960:  SUBWF  01,W
08962:  BC    89A6
....................       { 
....................          m_way[motor] = POS; 
08964:  BCF    FD8.0
08966:  MOVLB  7
08968:  RLCF   x40,W
0896A:  CLRF   03
0896C:  ADDLW  86
0896E:  MOVWF  FE9
08970:  MOVLW  07
08972:  ADDWFC 03,W
08974:  MOVWF  FEA
08976:  CLRF   FEC
08978:  MOVF   FED,F
0897A:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
0897C:  BCF    FD8.0
0897E:  RLCF   x40,W
08980:  CLRF   03
08982:  ADDLW  5E
08984:  MOVWF  FE9
08986:  MOVLW  07
08988:  ADDWFC 03,W
0898A:  MOVWF  FEA
0898C:  MOVFF  FEC,8DE
08990:  MOVF   FED,F
08992:  MOVFF  FEF,8DD
08996:  MOVLB  8
08998:  MOVF   xDB,W
0899A:  SUBWF  xDD,W
0899C:  MOVWF  xDB
0899E:  MOVF   xDC,W
089A0:  SUBWFB xDE,W
089A2:  MOVWF  xDC
....................       } 
089A4:  BRA    89C2
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
089A6:  BCF    FD8.0
089A8:  MOVLB  7
089AA:  RLCF   x40,W
089AC:  CLRF   03
089AE:  ADDLW  86
089B0:  MOVWF  FE9
089B2:  MOVLW  07
089B4:  ADDWFC 03,W
089B6:  MOVWF  FEA
089B8:  CLRF   FEC
089BA:  MOVF   FED,F
089BC:  MOVLW  01
089BE:  MOVWF  FEF
089C0:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
089C2:  MOVFF  8DB,01
089C6:  MOVFF  8DC,02
089CA:  MOVLB  0
089CC:  GOTO   A1A8 (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
090D0:  BCF    FD8.0
090D2:  MOVLB  7
090D4:  RLCF   x40,W
090D6:  CLRF   03
090D8:  ADDLW  92
090DA:  MOVWF  FE9
090DC:  MOVLW  07
090DE:  ADDWFC 03,W
090E0:  MOVWF  FEA
090E2:  CLRF   FEC
090E4:  MOVF   FED,F
090E6:  CLRF   FEF
....................           
....................    switch (motor){ 
090E8:  MOVF   x40,W
090EA:  XORLW  00
090EC:  MOVLB  0
090EE:  BZ    90F6
090F0:  XORLW  01
090F2:  BZ    9160
090F4:  BRA    91CE
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
090F6:  BCF    FD8.0
090F8:  MOVLB  7
090FA:  RLCF   x40,W
090FC:  CLRF   03
090FE:  ADDLW  52
09100:  MOVWF  FE9
09102:  MOVLW  07
09104:  ADDWFC 03,W
09106:  MOVWF  FEA
09108:  MOVFF  FEC,8ED
0910C:  MOVF   FED,F
0910E:  MOVFF  FEF,8EC
09112:  MOVLB  8
09114:  MOVF   xEC,F
09116:  BNZ   911C
09118:  MOVF   xED,F
0911A:  BZ    915A
0911C:  BCF    FD8.0
0911E:  MOVLB  7
09120:  RLCF   x40,W
09122:  CLRF   03
09124:  ADDLW  52
09126:  MOVWF  FE9
09128:  MOVLW  07
0912A:  ADDWFC 03,W
0912C:  MOVWF  FEA
0912E:  MOVFF  FEC,8ED
09132:  MOVF   FED,F
09134:  MOVFF  FEF,8EC
09138:  MOVLB  8
0913A:  RRCF   xED,F
0913C:  RRCF   xEC,F
0913E:  RRCF   xED,F
09140:  RRCF   xEC,F
09142:  RRCF   xED,F
09144:  MOVFF  8EC,FBC
09148:  RRCF   xED,F
0914A:  RRCF   xED,W
0914C:  ANDLW  30
0914E:  MOVWF  00
09150:  MOVF   FBB,W
09152:  ANDLW  CF
09154:  IORWF  00,W
09156:  MOVWF  FBB
09158:  BRA    915C
....................                else output_bit(M1_ENABLE, OFF); 
0915A:  BCF    F90.1
....................          break;   
0915C:  MOVLB  0
0915E:  BRA    91CE
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
09160:  BCF    FD8.0
09162:  MOVLB  7
09164:  RLCF   x40,W
09166:  CLRF   03
09168:  ADDLW  52
0916A:  MOVWF  FE9
0916C:  MOVLW  07
0916E:  ADDWFC 03,W
09170:  MOVWF  FEA
09172:  MOVFF  FEC,8ED
09176:  MOVF   FED,F
09178:  MOVFF  FEF,8EC
0917C:  MOVLB  8
0917E:  MOVF   xEC,F
09180:  BNZ   9186
09182:  MOVF   xED,F
09184:  BZ    91C8
09186:  BCF    FD8.0
09188:  MOVLB  7
0918A:  RLCF   x40,W
0918C:  CLRF   03
0918E:  ADDLW  52
09190:  MOVWF  FE9
09192:  MOVLW  07
09194:  ADDWFC 03,W
09196:  MOVWF  FEA
09198:  MOVFF  FEC,8ED
0919C:  MOVF   FED,F
0919E:  MOVFF  FEF,8EC
091A2:  MOVLB  8
091A4:  RRCF   xED,F
091A6:  RRCF   xEC,F
091A8:  RRCF   xED,F
091AA:  RRCF   xEC,F
091AC:  RRCF   xED,F
091AE:  MOVFF  8EC,F4F
091B2:  RRCF   xED,F
091B4:  RRCF   xED,W
091B6:  ANDLW  30
091B8:  MOVWF  00
091BA:  MOVLB  F
091BC:  MOVF   x4E,W
091BE:  ANDLW  CF
091C0:  IORWF  00,W
091C2:  MOVWF  x4E
091C4:  BRA    91CC
091C6:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
091C8:  BCF    F8D.1
091CA:  MOVLB  F
....................          break; 
091CC:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
091CE:  BCF    FA0.1
....................    enc_isr(OFF); 
091D0:  MOVLB  8
091D2:  CLRF   xEC
091D4:  MOVLB  0
091D6:  RCALL  8E1A
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
091D8:  MOVLB  7
091DA:  MOVF   x52,F
091DC:  BNZ   91EC
091DE:  MOVF   x53,F
091E0:  BNZ   91EC
091E2:  MOVF   x54,F
091E4:  BNZ   91EC
091E6:  MOVF   x55,F
091E8:  BNZ   91EC
....................    { 
....................       output_bit(VMOT,OFF); 
091EA:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
091EC:  MOVLB  8
091EE:  CLRF   xEC
091F0:  MOVLB  0
091F2:  CALL   89D0
....................  
....................    if(success==TRUE) 
091F6:  MOVLB  8
091F8:  DECFSZ xEB,W
091FA:  BRA    9396
....................    { 
....................       m_error[motor]=FALSE; 
091FC:  BCF    FD8.0
091FE:  MOVLB  7
09200:  RLCF   x40,W
09202:  CLRF   03
09204:  ADDLW  96
09206:  MOVWF  FE9
09208:  MOVLW  07
0920A:  ADDWFC 03,W
0920C:  MOVWF  FEA
0920E:  CLRF   FEC
09210:  MOVF   FED,F
09212:  CLRF   FEF
....................       wrt_m_error(); 
09214:  MOVLB  0
09216:  RCALL  8F80
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
09218:  BCF    FD8.0
0921A:  MOVLB  7
0921C:  RLCF   x40,W
0921E:  CLRF   03
09220:  ADDLW  66
09222:  MOVWF  FE9
09224:  MOVLW  07
09226:  ADDWFC 03,W
09228:  MOVWF  FEA
0922A:  MOVFF  FEC,8ED
0922E:  MOVF   FED,F
09230:  MOVFF  FEF,8EC
09234:  MOVLB  8
09236:  MOVF   xEC,W
09238:  SUBLW  03
0923A:  BNZ   9272
0923C:  MOVF   xED,F
0923E:  BNZ   9272
....................       { 
....................          e_pos[motor] = 0; 
09240:  BCF    FD8.0
09242:  MOVLB  7
09244:  RLCF   x40,W
09246:  CLRF   03
09248:  ADDLW  BF
0924A:  MOVWF  FE9
0924C:  MOVLW  07
0924E:  ADDWFC 03,W
09250:  MOVWF  FEA
09252:  CLRF   FEC
09254:  MOVF   FED,F
09256:  CLRF   FEF
....................          e_port[motor] = 1; 
09258:  BCF    FD8.0
0925A:  RLCF   x40,W
0925C:  CLRF   03
0925E:  ADDLW  C3
09260:  MOVWF  FE9
09262:  MOVLW  07
09264:  ADDWFC 03,W
09266:  MOVWF  FEA
09268:  CLRF   FEC
0926A:  MOVF   FED,F
0926C:  MOVLW  01
0926E:  MOVWF  FEF
09270:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
09272:  BCF    FD8.0
09274:  MOVLB  7
09276:  RLCF   x40,W
09278:  CLRF   03
0927A:  ADDLW  66
0927C:  MOVWF  FE9
0927E:  MOVLW  07
09280:  ADDWFC 03,W
09282:  MOVWF  FEA
09284:  MOVFF  FEC,8ED
09288:  MOVF   FED,F
0928A:  MOVFF  FEF,8EC
0928E:  MOVLB  8
09290:  MOVF   xEC,W
09292:  SUBLW  02
09294:  BNZ   92E0
09296:  MOVF   xED,F
09298:  BNZ   92E0
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
0929A:  BCF    FD8.0
0929C:  MOVLB  7
0929E:  RLCF   x40,W
092A0:  CLRF   03
092A2:  ADDLW  C3
092A4:  MOVWF  01
092A6:  MOVLW  07
092A8:  ADDWFC 03,F
092AA:  MOVLB  8
092AC:  MOVFF  03,8ED
092B0:  BCF    FD8.0
092B2:  MOVLB  7
092B4:  RLCF   x40,W
092B6:  CLRF   03
092B8:  ADDLW  C7
092BA:  MOVWF  FE9
092BC:  MOVLW  07
092BE:  ADDWFC 03,W
092C0:  MOVWF  FEA
092C2:  MOVFF  FEC,03
092C6:  MOVF   FED,F
092C8:  MOVFF  FEF,8EE
092CC:  MOVLB  8
092CE:  MOVFF  8ED,FEA
092D2:  MOVFF  01,FE9
092D6:  MOVFF  03,FEC
092DA:  MOVF   FED,F
092DC:  MOVFF  8EE,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
092E0:  BCF    FD8.0
092E2:  MOVLB  7
092E4:  RLCF   x40,W
092E6:  CLRF   03
092E8:  ADDLW  66
092EA:  MOVWF  FE9
092EC:  MOVLW  07
092EE:  ADDWFC 03,W
092F0:  MOVWF  FEA
092F2:  MOVFF  FEC,8ED
092F6:  MOVF   FED,F
092F8:  MOVFF  FEF,8EC
092FC:  MOVLB  8
092FE:  MOVF   xEC,W
09300:  SUBLW  02
09302:  BNZ   9308
09304:  MOVF   xED,F
09306:  BZ    9330
09308:  BCF    FD8.0
0930A:  MOVLB  7
0930C:  RLCF   x40,W
0930E:  CLRF   03
09310:  ADDLW  66
09312:  MOVWF  FE9
09314:  MOVLW  07
09316:  ADDWFC 03,W
09318:  MOVWF  FEA
0931A:  MOVFF  FEC,8ED
0931E:  MOVF   FED,F
09320:  MOVFF  FEF,8EC
09324:  MOVLB  8
09326:  MOVF   xEC,W
09328:  SUBLW  03
0932A:  BNZ   9394
0932C:  MOVF   xED,F
0932E:  BNZ   9394
....................       { 
....................          switch(motor) 
09330:  MOVLB  7
09332:  MOVF   x40,W
09334:  XORLW  00
09336:  MOVLB  0
09338:  BZ    9340
0933A:  XORLW  01
0933C:  BZ    936A
0933E:  BRA    9392
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09340:  MOVLW  7E
09342:  MOVLB  8
09344:  MOVWF  xEE
09346:  MOVFF  7C0,8F0
0934A:  MOVFF  7BF,8EF
0934E:  MOVLB  0
09350:  CALL   4FD4
....................                      write16(ADDR_E1_PORT,e_port[0]); 
09354:  MOVLW  AA
09356:  MOVLB  8
09358:  MOVWF  xEE
0935A:  MOVFF  7C4,8F0
0935E:  MOVFF  7C3,8EF
09362:  MOVLB  0
09364:  CALL   4FD4
....................                break; 
09368:  BRA    9392
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
0936A:  MOVLW  80
0936C:  MOVLB  8
0936E:  MOVWF  xEE
09370:  MOVFF  7C2,8F0
09374:  MOVFF  7C1,8EF
09378:  MOVLB  0
0937A:  CALL   4FD4
....................                      write16(ADDR_E2_PORT,e_port[1]); 
0937E:  MOVLW  AC
09380:  MOVLB  8
09382:  MOVWF  xEE
09384:  MOVFF  7C6,8F0
09388:  MOVFF  7C5,8EF
0938C:  MOVLB  0
0938E:  CALL   4FD4
....................                break;             
09392:  MOVLB  8
....................          } 
....................       } 
....................    } 
09394:  BRA    943E
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
09396:  BCF    FD8.0
09398:  MOVLB  7
0939A:  RLCF   x40,W
0939C:  CLRF   03
0939E:  ADDLW  96
093A0:  MOVWF  FE9
093A2:  MOVLW  07
093A4:  ADDWFC 03,W
093A6:  MOVWF  FEA
093A8:  CLRF   FEC
093AA:  MOVF   FED,F
093AC:  MOVLW  01
093AE:  MOVWF  FEF
....................       e_pos[motor] = 0; 
093B0:  BCF    FD8.0
093B2:  RLCF   x40,W
093B4:  CLRF   03
093B6:  ADDLW  BF
093B8:  MOVWF  FE9
093BA:  MOVLW  07
093BC:  ADDWFC 03,W
093BE:  MOVWF  FEA
093C0:  CLRF   FEC
093C2:  MOVF   FED,F
093C4:  CLRF   FEF
....................       e_port[motor] = 0; 
093C6:  BCF    FD8.0
093C8:  RLCF   x40,W
093CA:  CLRF   03
093CC:  ADDLW  C3
093CE:  MOVWF  FE9
093D0:  MOVLW  07
093D2:  ADDWFC 03,W
093D4:  MOVWF  FEA
093D6:  CLRF   FEC
093D8:  MOVF   FED,F
093DA:  CLRF   FEF
....................       switch(motor) 
093DC:  MOVF   x40,W
093DE:  XORLW  00
093E0:  MOVLB  0
093E2:  BZ    93EA
093E4:  XORLW  01
093E6:  BZ    9414
093E8:  BRA    943C
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
093EA:  MOVLW  7E
093EC:  MOVLB  8
093EE:  MOVWF  xEE
093F0:  MOVFF  7C0,8F0
093F4:  MOVFF  7BF,8EF
093F8:  MOVLB  0
093FA:  CALL   4FD4
....................                   write16(ADDR_E1_PORT,e_port[0]); 
093FE:  MOVLW  AA
09400:  MOVLB  8
09402:  MOVWF  xEE
09404:  MOVFF  7C4,8F0
09408:  MOVFF  7C3,8EF
0940C:  MOVLB  0
0940E:  CALL   4FD4
....................             break; 
09412:  BRA    943C
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
09414:  MOVLW  80
09416:  MOVLB  8
09418:  MOVWF  xEE
0941A:  MOVFF  7C2,8F0
0941E:  MOVFF  7C1,8EF
09422:  MOVLB  0
09424:  CALL   4FD4
....................                   write16(ADDR_E2_PORT,e_port[1]); 
09428:  MOVLW  AC
0942A:  MOVLB  8
0942C:  MOVWF  xEE
0942E:  MOVFF  7C6,8F0
09432:  MOVFF  7C5,8EF
09436:  MOVLB  0
09438:  CALL   4FD4
....................             break;             
0943C:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
0943E:  BCF    FD8.0
09440:  MOVLB  7
09442:  RLCF   x40,W
09444:  CLRF   03
09446:  ADDLW  AF
09448:  MOVWF  FE9
0944A:  MOVLW  07
0944C:  ADDWFC 03,W
0944E:  MOVWF  FEA
09450:  CLRF   FEC
09452:  MOVF   FED,F
09454:  MOVLW  01
09456:  MOVWF  FEF
....................     
....................    switch (motor) 
09458:  MOVF   x40,W
0945A:  XORLW  00
0945C:  MOVLB  0
0945E:  BZ    9466
09460:  XORLW  01
09462:  BZ    948E
09464:  BRA    94B4
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
09466:  MOVLW  B2
09468:  MOVLB  8
0946A:  MOVWF  xEE
0946C:  CLRF   xF0
0946E:  MOVLW  01
09470:  MOVWF  xEF
09472:  MOVLB  0
09474:  CALL   4FD4
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
09478:  MOVLW  B6
0947A:  MOVLB  8
0947C:  MOVWF  xEE
0947E:  MOVFF  7B4,8F0
09482:  MOVFF  7B3,8EF
09486:  MOVLB  0
09488:  CALL   4FD4
....................          break; 
0948C:  BRA    94B4
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
0948E:  MOVLW  B4
09490:  MOVLB  8
09492:  MOVWF  xEE
09494:  CLRF   xF0
09496:  MOVLW  01
09498:  MOVWF  xEF
0949A:  MOVLB  0
0949C:  CALL   4FD4
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
094A0:  MOVLW  B8
094A2:  MOVLB  8
094A4:  MOVWF  xEE
094A6:  MOVFF  7B6,8F0
094AA:  MOVFF  7B5,8EF
094AE:  MOVLB  0
094B0:  CALL   4FD4
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
094B4:  MOVF   1F,W
094B6:  SUBLW  04
094B8:  BNZ   955E
094BA:  MOVF   20,F
094BC:  BNZ   955E
....................    { 
....................       if(motor==1) 
094BE:  MOVLB  7
094C0:  DECFSZ x40,W
094C2:  BRA    9560
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
094C4:  BCF    FD8.0
094C6:  RLCF   x40,W
094C8:  CLRF   03
094CA:  ADDLW  AF
094CC:  MOVWF  FE9
094CE:  MOVLW  07
094D0:  ADDWFC 03,W
094D2:  MOVWF  FEA
094D4:  MOVFF  FEC,8ED
094D8:  MOVF   FED,F
094DA:  MOVFF  FEF,8EC
094DE:  BCF    FD8.0
094E0:  RLCF   x40,W
094E2:  CLRF   03
094E4:  ADDLW  B3
094E6:  MOVWF  FE9
094E8:  MOVLW  07
094EA:  ADDWFC 03,W
094EC:  MOVWF  FEA
094EE:  MOVFF  FEC,8EF
094F2:  MOVF   FED,F
094F4:  MOVFF  FEF,8EE
094F8:  MOVLW  56
094FA:  MOVWF  FF6
094FC:  MOVLW  1A
094FE:  MOVWF  FF7
09500:  MOVLW  00
09502:  MOVWF  FF8
09504:  CLRF   1B
09506:  BTFSC  FF2.7
09508:  BSF    1B.7
0950A:  BCF    FF2.7
0950C:  MOVLW  05
0950E:  MOVLB  A
09510:  MOVWF  x40
09512:  MOVLB  0
09514:  CALL   101C
09518:  BTFSC  1B.7
0951A:  BSF    FF2.7
0951C:  MOVLW  10
0951E:  MOVWF  FE9
09520:  CLRF   1B
09522:  BTFSC  FF2.7
09524:  BSF    1B.7
09526:  BCF    FF2.7
09528:  MOVFF  8ED,A41
0952C:  MOVFF  8EC,A40
09530:  CALL   119E
09534:  BTFSC  1B.7
09536:  BSF    FF2.7
09538:  MOVLW  2C
0953A:  BTFSS  F9E.4
0953C:  BRA    953A
0953E:  MOVWF  FAD
09540:  MOVLW  10
09542:  MOVWF  FE9
09544:  MOVFF  8EF,8F1
09548:  MOVFF  8EE,8F0
0954C:  RCALL  8FE4
0954E:  MOVLW  0D
09550:  BTFSS  F9E.4
09552:  BRA    9550
09554:  MOVWF  FAD
09556:  MOVLW  0A
09558:  BTFSS  F9E.4
0955A:  BRA    9558
0955C:  MOVWF  FAD
0955E:  MOVLB  7
....................       } 
....................    } 
09560:  MOVLB  0
09562:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
09690:  BCF    FD8.0
09692:  MOVLB  7
09694:  RLCF   x40,W
09696:  CLRF   03
09698:  ADDLW  6A
0969A:  MOVWF  FE9
0969C:  MOVLW  07
0969E:  ADDWFC 03,W
096A0:  MOVWF  FEA
096A2:  MOVFF  FEC,8EC
096A6:  MOVF   FED,F
096A8:  MOVFF  FEF,8EB
096AC:  MOVLB  8
096AE:  DECFSZ xEB,W
096B0:  BRA    96C0
096B2:  MOVF   xEC,F
096B4:  BNZ   96C0
096B6:  MOVLW  01
096B8:  MOVWF  xEB
096BA:  MOVLB  0
096BC:  RCALL  90D0
096BE:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
096C0:  BCF    FD8.0
096C2:  MOVLB  7
096C4:  RLCF   x40,W
096C6:  CLRF   03
096C8:  ADDLW  6A
096CA:  MOVWF  FE9
096CC:  MOVLW  07
096CE:  ADDWFC 03,W
096D0:  MOVWF  FEA
096D2:  MOVFF  FEC,8EC
096D6:  MOVF   FED,F
096D8:  MOVFF  FEF,8EB
096DC:  MOVLB  8
096DE:  MOVF   xEB,W
096E0:  SUBLW  02
096E2:  BTFSS  FD8.2
096E4:  BRA    9CEE
096E6:  MOVF   xEC,F
096E8:  BTFSS  FD8.2
096EA:  BRA    9CEE
....................       if (e_mode[motor]==2){ 
096EC:  BCF    FD8.0
096EE:  MOVLB  7
096F0:  RLCF   x40,W
096F2:  CLRF   03
096F4:  ADDLW  66
096F6:  MOVWF  FE9
096F8:  MOVLW  07
096FA:  ADDWFC 03,W
096FC:  MOVWF  FEA
096FE:  MOVFF  FEC,8EC
09702:  MOVF   FED,F
09704:  MOVFF  FEF,8EB
09708:  MOVLB  8
0970A:  MOVF   xEB,W
0970C:  SUBLW  02
0970E:  BTFSS  FD8.2
09710:  BRA    9C6A
09712:  MOVF   xEC,F
09714:  BTFSS  FD8.2
09716:  BRA    9C6A
....................          if(nv_product==ECO || nv_product==WMS2){ 
09718:  MOVF   2F,F
0971A:  BNZ   9720
0971C:  MOVF   30,F
0971E:  BZ    972E
09720:  MOVF   2F,W
09722:  SUBLW  03
09724:  BTFSS  FD8.2
09726:  BRA    9872
09728:  MOVF   30,F
0972A:  BTFSS  FD8.2
0972C:  BRA    9872
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
0972E:  BCF    FD8.0
09730:  MOVLB  7
09732:  RLCF   x40,W
09734:  CLRF   03
09736:  ADDLW  AB
09738:  MOVWF  FE9
0973A:  MOVLW  07
0973C:  ADDWFC 03,W
0973E:  MOVWF  FEA
09740:  MOVFF  FEC,9F7
09744:  MOVF   FED,F
09746:  MOVFF  FEF,9F6
0974A:  MOVFF  FEA,8EE
0974E:  MOVFF  FE9,8ED
09752:  MOVLB  9
09754:  CLRF   xF9
09756:  CLRF   xF8
09758:  MOVFF  8DC,9FD
0975C:  MOVFF  8DB,9FC
09760:  MOVFF  8DA,9FB
09764:  MOVFF  8D9,9FA
09768:  MOVLB  0
0976A:  CALL   47F0
0976E:  MOVFF  8EE,FEA
09772:  MOVFF  8ED,FE9
09776:  MOVFF  03,8EE
0977A:  MOVFF  02,8ED
0977E:  MOVFF  01,8EC
09782:  MOVFF  00,8EB
09786:  BCF    FD8.0
09788:  MOVLB  7
0978A:  RLCF   x40,W
0978C:  CLRF   03
0978E:  ADDLW  AB
09790:  MOVWF  FE9
09792:  MOVLW  07
09794:  ADDWFC 03,W
09796:  MOVWF  FEA
09798:  MOVFF  FEC,8F0
0979C:  MOVF   FED,F
0979E:  MOVFF  FEF,8EF
097A2:  BCF    FD8.0
097A4:  MOVLB  8
097A6:  RRCF   xF0,W
097A8:  MOVWF  03
097AA:  RRCF   xEF,W
097AC:  MOVWF  02
097AE:  ADDWF  00,W
097B0:  MOVWF  00
097B2:  MOVF   03,W
097B4:  ADDWFC 01,W
097B6:  MOVWF  01
097B8:  MOVLW  00
097BA:  ADDWFC xED,W
097BC:  MOVWF  02
097BE:  MOVLW  00
097C0:  ADDWFC xEE,W
097C2:  MOVWF  xE6
097C4:  MOVFF  02,8E5
097C8:  MOVFF  01,8E4
097CC:  MOVFF  00,8E3
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
097D0:  BCF    FD8.0
097D2:  MOVLB  7
097D4:  RLCF   x40,W
097D6:  CLRF   03
097D8:  ADDLW  AB
097DA:  MOVWF  FE9
097DC:  MOVLW  07
097DE:  ADDWFC 03,W
097E0:  MOVWF  FEA
097E2:  MOVFF  FEC,9F7
097E6:  MOVF   FED,F
097E8:  MOVFF  FEF,9F6
097EC:  MOVFF  FEA,8EE
097F0:  MOVFF  FE9,8ED
097F4:  MOVLB  9
097F6:  CLRF   xF9
097F8:  CLRF   xF8
097FA:  MOVFF  8DC,9FD
097FE:  MOVFF  8DB,9FC
09802:  MOVFF  8DA,9FB
09806:  MOVFF  8D9,9FA
0980A:  MOVLB  0
0980C:  CALL   47F0
09810:  MOVFF  8EE,FEA
09814:  MOVFF  8ED,FE9
09818:  MOVFF  03,8EE
0981C:  MOVFF  02,8ED
09820:  MOVFF  01,8EC
09824:  MOVFF  00,8EB
09828:  BCF    FD8.0
0982A:  MOVLB  7
0982C:  RLCF   x40,W
0982E:  CLRF   03
09830:  ADDLW  AB
09832:  MOVWF  FE9
09834:  MOVLW  07
09836:  ADDWFC 03,W
09838:  MOVWF  FEA
0983A:  MOVFF  FEC,8F0
0983E:  MOVF   FED,F
09840:  MOVFF  FEF,8EF
09844:  BCF    FD8.0
09846:  MOVLB  8
09848:  RRCF   xF0,W
0984A:  MOVWF  03
0984C:  RRCF   xEF,W
0984E:  MOVWF  02
09850:  SUBWF  00,W
09852:  MOVWF  00
09854:  MOVF   03,W
09856:  SUBWFB 01,W
09858:  MOVWF  01
0985A:  MOVLW  00
0985C:  SUBWFB xED,W
0985E:  MOVWF  02
09860:  MOVLW  00
09862:  SUBWFB xEE,W
09864:  MOVWF  xEA
09866:  MOVFF  02,8E9
0986A:  MOVFF  01,8E8
0986E:  MOVFF  00,8E7
....................          } 
....................          if (nv_product==WMS4){ 
09872:  DECFSZ 2F,W
09874:  BRA    9A8C
09876:  MOVF   30,F
09878:  BTFSS  FD8.2
0987A:  BRA    9A8C
....................             if (end_even_port==FALSE){ 
0987C:  MOVLB  2
0987E:  MOVF   xDB,F
09880:  BNZ   9976
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
09882:  BCF    FD8.0
09884:  MOVLB  7
09886:  RLCF   x40,W
09888:  CLRF   03
0988A:  ADDLW  AB
0988C:  MOVWF  FE9
0988E:  MOVLW  07
09890:  ADDWFC 03,W
09892:  MOVWF  FEA
09894:  MOVFF  FEC,A11
09898:  MOVF   FED,F
0989A:  MOVFF  FEF,A10
0989E:  MOVFF  8DE,A13
098A2:  MOVFF  8DD,A12
098A6:  MOVLB  0
098A8:  CALL   5C98
098AC:  MOVFF  02,8EC
098B0:  MOVFF  01,8EB
098B4:  BCF    FD8.0
098B6:  MOVLB  7
098B8:  RLCF   x40,W
098BA:  CLRF   03
098BC:  ADDLW  AB
098BE:  MOVWF  FE9
098C0:  MOVLW  07
098C2:  ADDWFC 03,W
098C4:  MOVWF  FEA
098C6:  MOVFF  FEC,8EE
098CA:  MOVF   FED,F
098CC:  MOVFF  FEF,8ED
098D0:  BCF    FD8.0
098D2:  MOVLB  8
098D4:  RRCF   xEE,W
098D6:  MOVWF  03
098D8:  RRCF   xED,W
098DA:  MOVWF  02
098DC:  ADDWF  01,W
098DE:  MOVWF  01
098E0:  MOVF   xEC,W
098E2:  ADDWFC 03,F
098E4:  MOVFF  01,8E3
098E8:  MOVFF  03,8E4
098EC:  CLRF   02
098EE:  CLRF   03
098F0:  MOVFF  03,8E6
098F4:  MOVFF  02,8E5
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
098F8:  BCF    FD8.0
098FA:  MOVLB  7
098FC:  RLCF   x40,W
098FE:  CLRF   03
09900:  ADDLW  AB
09902:  MOVWF  FE9
09904:  MOVLW  07
09906:  ADDWFC 03,W
09908:  MOVWF  FEA
0990A:  MOVFF  FEC,A11
0990E:  MOVF   FED,F
09910:  MOVFF  FEF,A10
09914:  MOVFF  8DE,A13
09918:  MOVFF  8DD,A12
0991C:  MOVLB  0
0991E:  CALL   5C98
09922:  MOVFF  02,8EC
09926:  MOVFF  01,8EB
0992A:  BCF    FD8.0
0992C:  MOVLB  7
0992E:  RLCF   x40,W
09930:  CLRF   03
09932:  ADDLW  AB
09934:  MOVWF  FE9
09936:  MOVLW  07
09938:  ADDWFC 03,W
0993A:  MOVWF  FEA
0993C:  MOVFF  FEC,8EE
09940:  MOVF   FED,F
09942:  MOVFF  FEF,8ED
09946:  BCF    FD8.0
09948:  MOVLB  8
0994A:  RRCF   xEE,W
0994C:  MOVWF  03
0994E:  RRCF   xED,W
09950:  MOVWF  02
09952:  SUBWF  01,W
09954:  MOVWF  00
09956:  MOVF   03,W
09958:  SUBWFB xEC,W
0995A:  MOVWF  03
0995C:  MOVF   00,W
0995E:  MOVFF  03,8E8
09962:  CLRF   02
09964:  CLRF   03
09966:  MOVFF  03,8EA
0996A:  MOVFF  02,8E9
0996E:  MOVFF  00,8E7
....................             } 
09972:  BRA    9A8C
09974:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
09976:  DECFSZ xDB,W
09978:  BRA    9A8E
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
0997A:  BCF    FD8.0
0997C:  MOVLB  7
0997E:  RLCF   x40,W
09980:  CLRF   03
09982:  ADDLW  AB
09984:  MOVWF  FE9
09986:  MOVLW  07
09988:  ADDWFC 03,W
0998A:  MOVWF  FEA
0998C:  MOVFF  FEC,A11
09990:  MOVF   FED,F
09992:  MOVFF  FEF,A10
09996:  MOVLW  01
09998:  MOVLB  8
0999A:  SUBWF  xDD,W
0999C:  MOVWF  00
0999E:  MOVLW  00
099A0:  SUBWFB xDE,W
099A2:  MOVWF  03
099A4:  MOVFF  00,8ED
099A8:  MOVWF  xEE
099AA:  MOVFF  FE8,A13
099AE:  MOVFF  00,A12
099B2:  MOVLB  0
099B4:  CALL   5C98
099B8:  MOVFF  02,8EC
099BC:  MOVFF  01,8EB
099C0:  BCF    FD8.0
099C2:  MOVLB  7
099C4:  RLCF   x40,W
099C6:  CLRF   03
099C8:  ADDLW  AB
099CA:  MOVWF  FE9
099CC:  MOVLW  07
099CE:  ADDWFC 03,W
099D0:  MOVWF  FEA
099D2:  MOVFF  FEC,8EE
099D6:  MOVF   FED,F
099D8:  MOVFF  FEF,8ED
099DC:  BCF    FD8.0
099DE:  MOVLB  8
099E0:  RRCF   xEE,W
099E2:  MOVWF  03
099E4:  RRCF   xED,W
099E6:  MOVWF  02
099E8:  ADDWF  01,W
099EA:  MOVWF  01
099EC:  MOVF   xEC,W
099EE:  ADDWFC 03,F
099F0:  MOVFF  01,8E3
099F4:  MOVFF  03,8E4
099F8:  CLRF   02
099FA:  CLRF   03
099FC:  MOVFF  03,8E6
09A00:  MOVFF  02,8E5
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
09A04:  BCF    FD8.0
09A06:  MOVLB  7
09A08:  RLCF   x40,W
09A0A:  CLRF   03
09A0C:  ADDLW  AB
09A0E:  MOVWF  FE9
09A10:  MOVLW  07
09A12:  ADDWFC 03,W
09A14:  MOVWF  FEA
09A16:  MOVFF  FEC,A11
09A1A:  MOVF   FED,F
09A1C:  MOVFF  FEF,A10
09A20:  MOVLW  01
09A22:  MOVLB  8
09A24:  SUBWF  xDD,W
09A26:  MOVWF  00
09A28:  MOVLW  00
09A2A:  SUBWFB xDE,W
09A2C:  MOVWF  03
09A2E:  MOVFF  00,8ED
09A32:  MOVWF  xEE
09A34:  MOVFF  FE8,A13
09A38:  MOVFF  00,A12
09A3C:  MOVLB  0
09A3E:  CALL   5C98
09A42:  MOVFF  02,03
09A46:  MOVFF  01,8E7
09A4A:  MOVFF  02,8E8
09A4E:  CLRF   02
09A50:  CLRF   03
09A52:  MOVFF  03,8EA
09A56:  MOVFF  02,8E9
....................                m_pll = m_pll -(m_ppp[motor]/2); 
09A5A:  BCF    FD8.0
09A5C:  MOVLB  7
09A5E:  RLCF   x40,W
09A60:  CLRF   03
09A62:  ADDLW  AB
09A64:  MOVWF  FE9
09A66:  MOVLW  07
09A68:  ADDWFC 03,W
09A6A:  MOVWF  FEA
09A6C:  MOVFF  FEC,8EC
09A70:  MOVF   FED,F
09A72:  MOVFF  FEF,8EB
09A76:  BCF    FD8.0
09A78:  MOVLB  8
09A7A:  RRCF   xEC,W
09A7C:  MOVWF  03
09A7E:  RRCF   xEB,W
09A80:  SUBWF  xE7,F
09A82:  MOVF   03,W
09A84:  SUBWFB xE8,F
09A86:  MOVLW  00
09A88:  SUBWFB xE9,F
09A8A:  SUBWFB xEA,F
09A8C:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
09A8E:  MOVLB  7
09A90:  MOVF   x40,W
09A92:  MULLW  04
09A94:  MOVF   FF3,W
09A96:  CLRF   03
09A98:  ADDLW  A2
09A9A:  MOVWF  FE9
09A9C:  MOVLW  07
09A9E:  ADDWFC 03,W
09AA0:  MOVWF  FEA
09AA2:  MOVFF  FEF,8EB
09AA6:  MOVFF  FEC,8EC
09AAA:  MOVFF  FEC,8ED
09AAE:  MOVFF  FEC,8EE
09AB2:  MOVLB  8
09AB4:  BTFSC  xE6.7
09AB6:  BRA    9B26
09AB8:  MOVF   xE6,W
09ABA:  SUBWF  xEE,W
09ABC:  BNC   9AD6
09ABE:  BNZ   9B26
09AC0:  MOVF   xE5,W
09AC2:  SUBWF  xED,W
09AC4:  BNC   9AD6
09AC6:  BNZ   9B26
09AC8:  MOVF   xE4,W
09ACA:  SUBWF  xEC,W
09ACC:  BNC   9AD6
09ACE:  BNZ   9B26
09AD0:  MOVF   xEB,W
09AD2:  SUBWF  xE3,W
09AD4:  BNC   9B26
09AD6:  MOVLB  7
09AD8:  MOVF   x40,W
09ADA:  MULLW  04
09ADC:  MOVF   FF3,W
09ADE:  CLRF   03
09AE0:  ADDLW  A2
09AE2:  MOVWF  FE9
09AE4:  MOVLW  07
09AE6:  ADDWFC 03,W
09AE8:  MOVWF  FEA
09AEA:  MOVFF  FEF,8EB
09AEE:  MOVFF  FEC,8EC
09AF2:  MOVFF  FEC,8ED
09AF6:  MOVFF  FEC,8EE
09AFA:  MOVLB  8
09AFC:  BTFSC  xEA.7
09AFE:  BRA    9C6A
09B00:  MOVF   xEE,W
09B02:  SUBWF  xEA,W
09B04:  BTFSS  FD8.0
09B06:  BRA    9C6A
09B08:  BNZ   9B26
09B0A:  MOVF   xED,W
09B0C:  SUBWF  xE9,W
09B0E:  BTFSS  FD8.0
09B10:  BRA    9C6A
09B12:  BNZ   9B26
09B14:  MOVF   xEC,W
09B16:  SUBWF  xE8,W
09B18:  BTFSS  FD8.0
09B1A:  BRA    9C6A
09B1C:  BNZ   9B26
09B1E:  MOVF   xE7,W
09B20:  SUBWF  xEB,W
09B22:  BTFSC  FD8.0
09B24:  BRA    9C6A
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09B26:  MOVLW  01
09B28:  MOVLB  7
09B2A:  ADDWF  x40,W
09B2C:  MOVLB  8
09B2E:  MOVWF  xEB
09B30:  BCF    FD8.0
09B32:  MOVLB  7
09B34:  RLCF   x40,W
09B36:  CLRF   03
09B38:  ADDLW  AB
09B3A:  MOVWF  FE9
09B3C:  MOVLW  07
09B3E:  ADDWFC 03,W
09B40:  MOVWF  FEA
09B42:  MOVFF  FEC,8ED
09B46:  MOVF   FED,F
09B48:  MOVFF  FEF,8EC
09B4C:  MOVF   x40,W
09B4E:  MULLW  04
09B50:  MOVF   FF3,W
09B52:  CLRF   03
09B54:  ADDLW  A2
09B56:  MOVWF  FE9
09B58:  MOVLW  07
09B5A:  ADDWFC 03,W
09B5C:  MOVWF  FEA
09B5E:  MOVFF  FEF,8EE
09B62:  MOVFF  FEC,8EF
09B66:  MOVFF  FEC,8F0
09B6A:  MOVFF  FEC,8F1
09B6E:  MOVLW  66
09B70:  MOVWF  FF6
09B72:  MOVLW  1A
09B74:  MOVWF  FF7
09B76:  MOVLW  00
09B78:  MOVWF  FF8
09B7A:  CLRF   1B
09B7C:  BTFSC  FF2.7
09B7E:  BSF    1B.7
09B80:  BCF    FF2.7
09B82:  MOVLW  05
09B84:  MOVLB  A
09B86:  MOVWF  x40
09B88:  MOVLB  0
09B8A:  CALL   101C
09B8E:  BTFSC  1B.7
09B90:  BSF    FF2.7
09B92:  CLRF   1B
09B94:  BTFSC  FF2.7
09B96:  BSF    1B.7
09B98:  BCF    FF2.7
09B9A:  MOVFF  8EB,A40
09B9E:  MOVLW  1B
09BA0:  MOVLB  A
09BA2:  MOVWF  x41
09BA4:  MOVLB  0
09BA6:  CALL   0F9E
09BAA:  BTFSC  1B.7
09BAC:  BSF    FF2.7
09BAE:  MOVLW  2C
09BB0:  BTFSS  F9E.4
09BB2:  BRA    9BB0
09BB4:  MOVWF  FAD
09BB6:  MOVLW  41
09BB8:  MOVWF  FE9
09BBA:  MOVFF  8DC,8F5
09BBE:  MOVFF  8DB,8F4
09BC2:  MOVFF  8DA,8F3
09BC6:  MOVFF  8D9,8F2
09BCA:  RCALL  9564
09BCC:  MOVLW  2C
09BCE:  BTFSS  F9E.4
09BD0:  BRA    9BCE
09BD2:  MOVWF  FAD
09BD4:  MOVLW  10
09BD6:  MOVWF  FE9
09BD8:  CLRF   1B
09BDA:  BTFSC  FF2.7
09BDC:  BSF    1B.7
09BDE:  BCF    FF2.7
09BE0:  MOVFF  8ED,A41
09BE4:  MOVFF  8EC,A40
09BE8:  CALL   119E
09BEC:  BTFSC  1B.7
09BEE:  BSF    FF2.7
09BF0:  MOVLW  2C
09BF2:  BTFSS  F9E.4
09BF4:  BRA    9BF2
09BF6:  MOVWF  FAD
09BF8:  MOVLW  41
09BFA:  MOVWF  FE9
09BFC:  CLRF   1B
09BFE:  BTFSC  FF2.7
09C00:  BSF    1B.7
09C02:  BCF    FF2.7
09C04:  MOVFF  8F1,A43
09C08:  MOVFF  8F0,A42
09C0C:  MOVFF  8EF,A41
09C10:  MOVFF  8EE,A40
09C14:  CALL   10E2
09C18:  BTFSC  1B.7
09C1A:  BSF    FF2.7
09C1C:  MOVLW  2C
09C1E:  BTFSS  F9E.4
09C20:  BRA    9C1E
09C22:  MOVWF  FAD
09C24:  MOVLW  41
09C26:  MOVWF  FE9
09C28:  MOVFF  8E6,8F5
09C2C:  MOVFF  8E5,8F4
09C30:  MOVFF  8E4,8F3
09C34:  MOVFF  8E3,8F2
09C38:  RCALL  9564
09C3A:  MOVLW  2C
09C3C:  BTFSS  F9E.4
09C3E:  BRA    9C3C
09C40:  MOVWF  FAD
09C42:  MOVLW  41
09C44:  MOVWF  FE9
09C46:  MOVFF  8EA,8F5
09C4A:  MOVFF  8E9,8F4
09C4E:  MOVFF  8E8,8F3
09C52:  MOVFF  8E7,8F2
09C56:  RCALL  9564
09C58:  MOVLW  0D
09C5A:  BTFSS  F9E.4
09C5C:  BRA    9C5A
09C5E:  MOVWF  FAD
09C60:  MOVLW  0A
09C62:  BTFSS  F9E.4
09C64:  BRA    9C62
09C66:  MOVWF  FAD
09C68:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09C6A:  BCF    FD8.0
09C6C:  MOVLB  7
09C6E:  RLCF   x40,W
09C70:  CLRF   03
09C72:  ADDLW  9E
09C74:  MOVWF  01
09C76:  MOVLW  07
09C78:  ADDWFC 03,F
09C7A:  MOVLB  8
09C7C:  MOVFF  03,8EC
09C80:  BCF    FD8.0
09C82:  MOVLB  7
09C84:  RLCF   x40,W
09C86:  CLRF   03
09C88:  ADDLW  66
09C8A:  MOVWF  FE9
09C8C:  MOVLW  07
09C8E:  ADDWFC 03,W
09C90:  MOVWF  FEA
09C92:  MOVFF  FEC,03
09C96:  MOVF   FED,F
09C98:  MOVFF  FEF,8ED
09C9C:  MOVLB  8
09C9E:  MOVFF  8EC,FEA
09CA2:  MOVFF  01,FE9
09CA6:  MOVFF  03,FEC
09CAA:  MOVF   FED,F
09CAC:  MOVFF  8ED,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09CB0:  BCF    FD8.0
09CB2:  MOVLB  7
09CB4:  RLCF   x40,W
09CB6:  CLRF   03
09CB8:  ADDLW  66
09CBA:  MOVWF  FE9
09CBC:  MOVLW  07
09CBE:  ADDWFC 03,W
09CC0:  MOVWF  FEA
09CC2:  CLRF   FEC
09CC4:  MOVF   FED,F
09CC6:  MOVLW  04
09CC8:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09CCA:  MOVF   x40,W
09CCC:  MULLW  04
09CCE:  MOVF   FF3,W
09CD0:  CLRF   03
09CD2:  ADDLW  A2
09CD4:  MOVWF  FE9
09CD6:  MOVLW  07
09CD8:  ADDWFC 03,W
09CDA:  MOVWF  FEA
09CDC:  MOVFF  FEF,8DF
09CE0:  MOVFF  FEC,8E0
09CE4:  MOVFF  FEC,8E1
09CE8:  MOVFF  FEC,8E2
09CEC:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09CEE:  MOVFF  8DF,00
09CF2:  MOVFF  8E0,01
09CF6:  MOVFF  8E1,02
09CFA:  MOVFF  8E2,03
09CFE:  MOVLB  0
09D00:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
0855E:  MOVLB  2
08560:  CLRF   xDB
....................    start_even_port = FALSE; 
08562:  CLRF   xDA
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
08564:  BCF    FD8.0
08566:  MOVLB  7
08568:  RLCF   x40,W
0856A:  CLRF   03
0856C:  ADDLW  C7
0856E:  MOVWF  FE9
08570:  MOVLW  07
08572:  ADDWFC 03,W
08574:  MOVWF  FEA
08576:  MOVFF  FEC,8D9
0857A:  MOVF   FED,F
0857C:  MOVFF  FEF,8D8
08580:  MOVLW  01
08582:  MOVLB  8
08584:  ANDWF  xD8,F
08586:  CLRF   xD9
08588:  MOVF   xD8,F
0858A:  BNZ   8598
0858C:  MOVF   xD9,F
0858E:  BNZ   8598
....................    { 
....................       end_even_port = TRUE; 
08590:  MOVLW  01
08592:  MOVLB  2
08594:  MOVWF  xDB
08596:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
08598:  BCF    FD8.0
0859A:  MOVLB  7
0859C:  RLCF   x40,W
0859E:  CLRF   03
085A0:  ADDLW  C3
085A2:  MOVWF  FE9
085A4:  MOVLW  07
085A6:  ADDWFC 03,W
085A8:  MOVWF  FEA
085AA:  MOVFF  FEC,8D9
085AE:  MOVF   FED,F
085B0:  MOVFF  FEF,8D8
085B4:  MOVLW  01
085B6:  MOVLB  8
085B8:  ANDWF  xD8,F
085BA:  CLRF   xD9
085BC:  MOVF   xD8,F
085BE:  BNZ   85CC
085C0:  MOVF   xD9,F
085C2:  BNZ   85CC
....................    { 
....................       start_even_port = TRUE; 
085C4:  MOVLW  01
085C6:  MOVLB  2
085C8:  MOVWF  xDA
085CA:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
085CC:  MOVLB  2
085CE:  MOVF   xDA,F
085D0:  BNZ   85E6
....................    { 
....................       evenOdd = 0; 
085D2:  MOVLB  8
085D4:  CLRF   xD7
....................       if (TRUE == end_even_port) 
085D6:  MOVLB  2
085D8:  DECFSZ xDB,W
085DA:  BRA    85E4
....................       { 
....................          evenOdd = 1; 
085DC:  MOVLW  01
085DE:  MOVLB  8
085E0:  MOVWF  xD7
085E2:  MOVLB  2
....................       } 
....................    } 
085E4:  BRA    85FA
....................    else 
....................    { 
....................       evenOdd = 2; 
085E6:  MOVLW  02
085E8:  MOVLB  8
085EA:  MOVWF  xD7
....................       if (TRUE == end_even_port) 
085EC:  MOVLB  2
085EE:  DECFSZ xDB,W
085F0:  BRA    85FA
....................       { 
....................          evenOdd = 3; 
085F2:  MOVLW  03
085F4:  MOVLB  8
085F6:  MOVWF  xD7
085F8:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
085FA:  MOVLB  8
085FC:  MOVFF  8D7,01
08600:  MOVLB  0
08602:  GOTO   A050 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09D78:  BCF    FD8.0
09D7A:  MOVLB  7
09D7C:  RLCF   x40,W
09D7E:  CLRF   03
09D80:  ADDLW  86
09D82:  MOVWF  FE9
09D84:  MOVLW  07
09D86:  ADDWFC 03,W
09D88:  MOVWF  FEA
09D8A:  CLRF   FEC
09D8C:  MOVF   FED,F
09D8E:  MOVFF  8C8,FEF
....................    m_step_cnt[motor] = 0; 
09D92:  MOVF   x40,W
09D94:  MULLW  04
09D96:  MOVF   FF3,W
09D98:  CLRF   03
09D9A:  ADDLW  A2
09D9C:  MOVWF  FE9
09D9E:  MOVLW  07
09DA0:  ADDWFC 03,W
09DA2:  MOVWF  FEA
09DA4:  MOVF   FEE,F
09DA6:  MOVF   FEE,F
09DA8:  CLRF   FEC
09DAA:  MOVF   FED,F
09DAC:  CLRF   FEF
09DAE:  MOVF   FED,F
09DB0:  CLRF   FEF
09DB2:  MOVF   FED,F
09DB4:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09DB6:  BCF    FD8.0
09DB8:  RLCF   x40,W
09DBA:  CLRF   03
09DBC:  ADDLW  6E
09DBE:  MOVWF  FE9
09DC0:  MOVLW  07
09DC2:  ADDWFC 03,W
09DC4:  MOVWF  FEA
09DC6:  MOVFF  FEC,8D5
09DCA:  MOVF   FED,F
09DCC:  MOVFF  FEF,8D4
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09DD0:  BCF    FD8.0
09DD2:  RLCF   x40,W
09DD4:  CLRF   03
09DD6:  ADDLW  76
09DD8:  MOVWF  FE9
09DDA:  MOVLW  07
09DDC:  ADDWFC 03,W
09DDE:  MOVWF  FEA
09DE0:  MOVFF  FEC,8DC
09DE4:  MOVF   FED,F
09DE6:  MOVFF  FEF,8DB
09DEA:  BCF    FD8.0
09DEC:  RLCF   x40,W
09DEE:  CLRF   03
09DF0:  ADDLW  5E
09DF2:  MOVWF  FE9
09DF4:  MOVLW  07
09DF6:  ADDWFC 03,W
09DF8:  MOVWF  FEA
09DFA:  MOVFF  FEC,03
09DFE:  MOVF   FED,F
09E00:  MOVFF  FEF,8DD
09E04:  MOVFF  03,8DA
09E08:  MOVFF  03,8DE
09E0C:  MOVLB  0
09E0E:  CALL   2CD4
09E12:  MOVFF  02,8D3
09E16:  MOVFF  01,8D2
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09E1A:  BCF    FD8.0
09E1C:  MOVLB  7
09E1E:  RLCF   x40,W
09E20:  CLRF   03
09E22:  ADDLW  66
09E24:  MOVWF  FE9
09E26:  MOVLW  07
09E28:  ADDWFC 03,W
09E2A:  MOVWF  FEA
09E2C:  MOVFF  FEC,8D8
09E30:  MOVF   FED,F
09E32:  MOVFF  FEF,8D7
09E36:  MOVLB  8
09E38:  MOVF   xD7,W
09E3A:  SUBLW  02
09E3C:  BNZ   9E6C
09E3E:  MOVF   xD8,F
09E40:  BNZ   9E6C
09E42:  BCF    FD8.0
09E44:  MOVLB  7
09E46:  RLCF   x40,W
09E48:  CLRF   03
09E4A:  ADDLW  C3
09E4C:  MOVWF  FE9
09E4E:  MOVLW  07
09E50:  ADDWFC 03,W
09E52:  MOVWF  FEA
09E54:  MOVFF  FEC,8D8
09E58:  MOVF   FED,F
09E5A:  MOVFF  FEF,8D7
09E5E:  MOVLB  8
09E60:  MOVF   xD7,F
09E62:  BNZ   9E6C
09E64:  MOVF   xD8,F
09E66:  BTFSC  FD8.2
09E68:  GOTO   A70A
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09E6C:  BCF    FD8.0
09E6E:  MOVLB  7
09E70:  RLCF   x40,W
09E72:  CLRF   03
09E74:  ADDLW  66
09E76:  MOVWF  FE9
09E78:  MOVLW  07
09E7A:  ADDWFC 03,W
09E7C:  MOVWF  FEA
09E7E:  MOVFF  FEC,8D8
09E82:  MOVF   FED,F
09E84:  MOVFF  FEF,8D7
09E88:  MOVLB  8
09E8A:  MOVF   xD7,W
09E8C:  SUBLW  02
09E8E:  BTFSS  FD8.2
09E90:  BRA    A1EA
09E92:  MOVF   xD8,F
09E94:  BTFSS  FD8.2
09E96:  BRA    A1EA
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09E98:  BCF    FD8.0
09E9A:  MOVLB  7
09E9C:  RLCF   x40,W
09E9E:  CLRF   03
09EA0:  ADDLW  C7
09EA2:  MOVWF  FE9
09EA4:  MOVLW  07
09EA6:  ADDWFC 03,W
09EA8:  MOVWF  FEA
09EAA:  MOVFF  8C9,FEF
09EAE:  MOVFF  8CA,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09EB2:  DECFSZ 2F,W
09EB4:  BRA    A166
09EB6:  MOVF   30,F
09EB8:  BTFSS  FD8.2
09EBA:  BRA    A166
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09EBC:  BCF    FD8.0
09EBE:  RLCF   x40,W
09EC0:  CLRF   03
09EC2:  ADDLW  C7
09EC4:  MOVWF  FE9
09EC6:  MOVLW  07
09EC8:  ADDWFC 03,W
09ECA:  MOVWF  FEA
09ECC:  MOVFF  FEC,8D8
09ED0:  MOVF   FED,F
09ED2:  MOVFF  FEF,8D7
09ED6:  BCF    FD8.0
09ED8:  RLCF   x40,W
09EDA:  CLRF   03
09EDC:  ADDLW  C3
09EDE:  MOVWF  FE9
09EE0:  MOVLW  07
09EE2:  ADDWFC 03,W
09EE4:  MOVWF  FEA
09EE6:  MOVFF  FEC,03
09EEA:  MOVF   FED,F
09EEC:  MOVFF  FEF,01
09EF0:  MOVF   03,W
09EF2:  MOVLB  8
09EF4:  SUBWF  xD8,W
09EF6:  BNC   9F92
09EF8:  BNZ   9F00
09EFA:  MOVF   xD7,W
09EFC:  SUBWF  01,W
09EFE:  BC    9F92
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09F00:  BCF    FD8.0
09F02:  MOVLB  7
09F04:  RLCF   x40,W
09F06:  CLRF   03
09F08:  ADDLW  B7
09F0A:  MOVWF  01
09F0C:  MOVLW  07
09F0E:  ADDWFC 03,F
09F10:  MOVLB  8
09F12:  MOVFF  03,8D8
09F16:  BCF    FD8.0
09F18:  MOVLB  7
09F1A:  RLCF   x40,W
09F1C:  CLRF   03
09F1E:  ADDLW  C7
09F20:  MOVWF  FE9
09F22:  MOVLW  07
09F24:  ADDWFC 03,W
09F26:  MOVWF  FEA
09F28:  MOVFF  FEC,8DA
09F2C:  MOVF   FED,F
09F2E:  MOVFF  FEF,8D9
09F32:  BCF    FD8.0
09F34:  RLCF   x40,W
09F36:  CLRF   03
09F38:  ADDLW  C3
09F3A:  MOVWF  FE9
09F3C:  MOVLW  07
09F3E:  ADDWFC 03,W
09F40:  MOVWF  FEA
09F42:  MOVFF  FEC,03
09F46:  MOVF   FED,F
09F48:  MOVF   FEF,W
09F4A:  MOVLB  8
09F4C:  SUBWF  xD9,W
09F4E:  MOVWF  00
09F50:  MOVF   03,W
09F52:  SUBWFB xDA,W
09F54:  MOVFF  8D8,FEA
09F58:  MOVFF  01,FE9
09F5C:  MOVWF  FEC
09F5E:  MOVF   FED,F
09F60:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F64:  BCF    FD8.0
09F66:  MOVLB  7
09F68:  RLCF   x40,W
09F6A:  CLRF   03
09F6C:  ADDLW  B7
09F6E:  MOVWF  FE9
09F70:  MOVLW  07
09F72:  ADDWFC 03,W
09F74:  MOVWF  FEA
09F76:  MOVFF  FEC,8D8
09F7A:  MOVF   FED,F
09F7C:  MOVFF  FEF,8D7
09F80:  BCF    FD8.0
09F82:  MOVLB  8
09F84:  CLRF   xCC
09F86:  CLRF   xCB
09F88:  RRCF   xD8,W
09F8A:  MOVWF  xCA
09F8C:  RRCF   xD7,W
09F8E:  MOVWF  xC9
....................             } 
09F90:  BRA    A04A
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09F92:  BCF    FD8.0
09F94:  MOVLB  7
09F96:  RLCF   x40,W
09F98:  CLRF   03
09F9A:  ADDLW  B7
09F9C:  MOVWF  01
09F9E:  MOVLW  07
09FA0:  ADDWFC 03,F
09FA2:  MOVFF  01,8D7
09FA6:  MOVLB  8
09FA8:  MOVFF  03,8D8
09FAC:  BCF    FD8.0
09FAE:  MOVLB  7
09FB0:  RLCF   x40,W
09FB2:  CLRF   03
09FB4:  ADDLW  62
09FB6:  MOVWF  FE9
09FB8:  MOVLW  07
09FBA:  ADDWFC 03,W
09FBC:  MOVWF  FEA
09FBE:  MOVFF  FEC,8DA
09FC2:  MOVF   FED,F
09FC4:  MOVFF  FEF,8D9
09FC8:  BCF    FD8.0
09FCA:  RLCF   x40,W
09FCC:  CLRF   03
09FCE:  ADDLW  C3
09FD0:  MOVWF  FE9
09FD2:  MOVLW  07
09FD4:  ADDWFC 03,W
09FD6:  MOVWF  FEA
09FD8:  MOVFF  FEC,03
09FDC:  MOVF   FED,F
09FDE:  MOVF   FEF,W
09FE0:  MOVLB  8
09FE2:  SUBWF  xD9,F
09FE4:  MOVF   03,W
09FE6:  SUBWFB xDA,F
09FE8:  BCF    FD8.0
09FEA:  MOVLB  7
09FEC:  RLCF   x40,W
09FEE:  CLRF   03
09FF0:  ADDLW  C7
09FF2:  MOVWF  FE9
09FF4:  MOVLW  07
09FF6:  ADDWFC 03,W
09FF8:  MOVWF  FEA
09FFA:  MOVFF  FEC,03
09FFE:  MOVF   FED,F
0A000:  MOVF   FEF,W
0A002:  MOVLB  8
0A004:  ADDWF  xD9,W
0A006:  MOVWF  01
0A008:  MOVF   xDA,W
0A00A:  ADDWFC 03,F
0A00C:  MOVFF  8D8,FEA
0A010:  MOVFF  8D7,FE9
0A014:  MOVFF  03,FEC
0A018:  MOVF   FED,F
0A01A:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
0A01E:  BCF    FD8.0
0A020:  MOVLB  7
0A022:  RLCF   x40,W
0A024:  CLRF   03
0A026:  ADDLW  B7
0A028:  MOVWF  FE9
0A02A:  MOVLW  07
0A02C:  ADDWFC 03,W
0A02E:  MOVWF  FEA
0A030:  MOVFF  FEC,8D8
0A034:  MOVF   FED,F
0A036:  MOVFF  FEF,8D7
0A03A:  BCF    FD8.0
0A03C:  MOVLB  8
0A03E:  CLRF   xCC
0A040:  CLRF   xCB
0A042:  RRCF   xD8,W
0A044:  MOVWF  xCA
0A046:  RRCF   xD7,W
0A048:  MOVWF  xC9
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
0A04A:  MOVLB  0
0A04C:  GOTO   855E
0A050:  MOVFF  01,8D6
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
0A054:  BCF    FD8.0
0A056:  MOVLB  7
0A058:  RLCF   x40,W
0A05A:  CLRF   03
0A05C:  ADDLW  C7
0A05E:  MOVWF  FE9
0A060:  MOVLW  07
0A062:  ADDWFC 03,W
0A064:  MOVWF  FEA
0A066:  MOVFF  FEC,8D8
0A06A:  MOVF   FED,F
0A06C:  MOVFF  FEF,8D7
0A070:  MOVLB  8
0A072:  MOVF   xD7,W
0A074:  SUBLW  02
0A076:  BNZ   A0A6
0A078:  MOVF   xD8,F
0A07A:  BNZ   A0A6
0A07C:  BCF    FD8.0
0A07E:  MOVLB  7
0A080:  RLCF   x40,W
0A082:  CLRF   03
0A084:  ADDLW  C3
0A086:  MOVWF  FE9
0A088:  MOVLW  07
0A08A:  ADDWFC 03,W
0A08C:  MOVWF  FEA
0A08E:  MOVFF  FEC,8D8
0A092:  MOVF   FED,F
0A094:  MOVFF  FEF,8D7
0A098:  MOVLB  8
0A09A:  DECFSZ xD7,W
0A09C:  BRA    A0A6
0A09E:  MOVF   xD8,F
0A0A0:  BNZ   A0A6
....................             { 
....................                port_port=4; 
0A0A2:  MOVLW  04
0A0A4:  MOVWF  xD6
....................             } 
....................              
....................             switch(port_port){ 
0A0A6:  MOVF   xD6,W
0A0A8:  ADDLW  FB
0A0AA:  BC    A162
0A0AC:  ADDLW  05
0A0AE:  MOVLB  0
0A0B0:  GOTO   A758
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
0A0B4:  BCF    FD8.0
0A0B6:  MOVLB  7
0A0B8:  RLCF   x40,W
0A0BA:  CLRF   03
0A0BC:  ADDLW  6E
0A0BE:  MOVWF  FE9
0A0C0:  MOVLW  07
0A0C2:  ADDWFC 03,W
0A0C4:  MOVWF  FEA
0A0C6:  MOVFF  FEC,8D5
0A0CA:  MOVF   FED,F
0A0CC:  MOVFF  FEF,8D4
....................                   break; 
0A0D0:  MOVLB  8
0A0D2:  BRA    A162
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A0D4:  BCF    FD8.0
0A0D6:  MOVLB  7
0A0D8:  RLCF   x40,W
0A0DA:  CLRF   03
0A0DC:  ADDLW  7E
0A0DE:  MOVWF  FE9
0A0E0:  MOVLW  07
0A0E2:  ADDWFC 03,W
0A0E4:  MOVWF  FEA
0A0E6:  MOVFF  FEC,03
0A0EA:  MOVF   FED,F
0A0EC:  MOVF   FEF,W
0A0EE:  MOVLB  8
0A0F0:  ADDWF  xD2,W
0A0F2:  MOVWF  xD4
0A0F4:  MOVF   03,W
0A0F6:  ADDWFC xD3,W
0A0F8:  MOVWF  xD5
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A0FA:  BRA    A162
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A0FC:  BCF    FD8.0
0A0FE:  MOVLB  7
0A100:  RLCF   x40,W
0A102:  CLRF   03
0A104:  ADDLW  6E
0A106:  MOVWF  FE9
0A108:  MOVLW  07
0A10A:  ADDWFC 03,W
0A10C:  MOVWF  FEA
0A10E:  MOVFF  FEC,8D5
0A112:  MOVF   FED,F
0A114:  MOVFF  FEF,8D4
....................                         ++m_steps; 
0A118:  MOVLW  01
0A11A:  MOVLB  8
0A11C:  ADDWF  xC9,F
0A11E:  BTFSC  FD8.0
0A120:  INCF   xCA,F
0A122:  BTFSC  FD8.2
0A124:  INCF   xCB,F
0A126:  BTFSC  FD8.2
0A128:  INCF   xCC,F
....................                   break; 
0A12A:  BRA    A162
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A12C:  BCF    FD8.0
0A12E:  MOVLB  7
0A130:  RLCF   x40,W
0A132:  CLRF   03
0A134:  ADDLW  7E
0A136:  MOVWF  FE9
0A138:  MOVLW  07
0A13A:  ADDWFC 03,W
0A13C:  MOVWF  FEA
0A13E:  MOVFF  FEC,03
0A142:  MOVF   FED,F
0A144:  MOVF   FEF,W
0A146:  MOVLB  8
0A148:  ADDWF  xD2,W
0A14A:  MOVWF  xD4
0A14C:  MOVF   03,W
0A14E:  ADDWFC xD3,W
0A150:  MOVWF  xD5
....................  
....................                   break; 
0A152:  BRA    A162
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A154:  MOVFF  8D3,8D5
0A158:  MOVFF  8D2,8D4
....................                   break;     
0A15C:  MOVLB  8
0A15E:  BRA    A162
0A160:  MOVLB  8
....................             } 
....................          } 
0A162:  BRA    A18E
0A164:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A166:  MOVFF  8CC,8DA
0A16A:  MOVFF  8CB,8D9
0A16E:  MOVFF  8CA,8D8
0A172:  MOVFF  8C9,8D7
0A176:  MOVLB  0
0A178:  GOTO   8606
0A17C:  MOVFF  03,8CC
0A180:  MOVFF  02,8CB
0A184:  MOVFF  01,8CA
0A188:  MOVFF  00,8C9
0A18C:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A18E:  DECFSZ xC7,W
0A190:  BRA    A1B8
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A192:  MOVFF  8CA,8D8
0A196:  MOVFF  8C9,8D7
0A19A:  MOVFF  8CA,8DA
0A19E:  MOVFF  8C9,8D9
0A1A2:  MOVLB  0
0A1A4:  GOTO   8818
0A1A8:  MOVLB  8
0A1AA:  CLRF   xCC
0A1AC:  CLRF   xCB
0A1AE:  MOVFF  02,8CA
0A1B2:  MOVFF  01,8C9
....................          } 
0A1B6:  BRA    A1EA
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A1B8:  MOVF   2F,W
0A1BA:  SUBLW  03
0A1BC:  BNZ   A1EA
0A1BE:  MOVF   30,F
0A1C0:  BNZ   A1EA
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A1C2:  BCF    FD8.0
0A1C4:  MOVLB  7
0A1C6:  RLCF   x40,W
0A1C8:  CLRF   03
0A1CA:  ADDLW  BF
0A1CC:  MOVWF  FE9
0A1CE:  MOVLW  07
0A1D0:  ADDWFC 03,W
0A1D2:  MOVWF  FEA
0A1D4:  MOVFF  FEC,03
0A1D8:  MOVF   FED,F
0A1DA:  MOVF   FEF,W
0A1DC:  MOVLB  8
0A1DE:  SUBWF  xC9,F
0A1E0:  MOVF   03,W
0A1E2:  SUBWFB xCA,F
0A1E4:  MOVLW  00
0A1E6:  SUBWFB xCB,F
0A1E8:  SUBWFB xCC,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A1EA:  MOVFF  8CD,8D7
0A1EE:  MOVLB  0
0A1F0:  GOTO   8EE2
....................        
....................       //timeout could be set here!!! 
....................       while (m_running[motor]) 
0A1F4:  BCF    FD8.0
0A1F6:  MOVLB  7
0A1F8:  RLCF   x40,W
0A1FA:  CLRF   03
0A1FC:  ADDLW  92
0A1FE:  MOVWF  FE9
0A200:  MOVLW  07
0A202:  ADDWFC 03,W
0A204:  MOVWF  FEA
0A206:  MOVF   FEF,F
0A208:  BNZ   A210
0A20A:  MOVF   FEC,F
0A20C:  BTFSC  FD8.2
0A20E:  BRA    A706
....................       { 
....................          switch(e_mode[motor]) 
0A210:  BCF    FD8.0
0A212:  RLCF   x40,W
0A214:  CLRF   03
0A216:  ADDLW  66
0A218:  MOVWF  FE9
0A21A:  MOVLW  07
0A21C:  ADDWFC 03,W
0A21E:  MOVWF  FEA
0A220:  MOVF   FEF,W
0A222:  MOVWF  00
0A224:  MOVF   FEE,F
0A226:  MOVF   FED,W
0A228:  MOVWF  03
0A22A:  MOVF   03,W
0A22C:  BNZ   A236
0A22E:  MOVF   00,F
0A230:  MOVLB  0
0A232:  BZ    A284
0A234:  MOVLB  7
0A236:  MOVF   03,W
0A238:  BNZ   A244
0A23A:  MOVLW  01
0A23C:  SUBWF  00,W
0A23E:  MOVLB  0
0A240:  BZ    A2DA
0A242:  MOVLB  7
0A244:  MOVF   03,W
0A246:  BNZ   A252
0A248:  MOVLW  02
0A24A:  SUBWF  00,W
0A24C:  MOVLB  0
0A24E:  BZ    A2DA
0A250:  MOVLB  7
0A252:  MOVF   03,W
0A254:  BNZ   A262
0A256:  MOVLW  03
0A258:  SUBWF  00,W
0A25A:  MOVLB  0
0A25C:  BTFSC  FD8.2
0A25E:  BRA    A3A8
0A260:  MOVLB  7
0A262:  MOVF   03,W
0A264:  BNZ   A272
0A266:  MOVLW  04
0A268:  SUBWF  00,W
0A26A:  MOVLB  0
0A26C:  BTFSC  FD8.2
0A26E:  BRA    A4F8
0A270:  MOVLB  7
0A272:  MOVF   03,W
0A274:  BNZ   A282
0A276:  MOVLW  05
0A278:  SUBWF  00,W
0A27A:  MOVLB  0
0A27C:  BTFSC  FD8.2
0A27E:  BRA    A648
0A280:  MOVLB  7
0A282:  BRA    A700
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A284:  MOVLB  7
0A286:  MOVF   x40,W
0A288:  MULLW  04
0A28A:  MOVF   FF3,W
0A28C:  CLRF   03
0A28E:  ADDLW  A2
0A290:  MOVWF  FE9
0A292:  MOVLW  07
0A294:  ADDWFC 03,W
0A296:  MOVWF  FEA
0A298:  MOVFF  FEF,8D7
0A29C:  MOVFF  FEC,8D8
0A2A0:  MOVFF  FEC,8D9
0A2A4:  MOVFF  FEC,8DA
0A2A8:  MOVLB  8
0A2AA:  MOVF   xCC,W
0A2AC:  SUBWF  xDA,W
0A2AE:  BNC   A2D4
0A2B0:  BNZ   A2C8
0A2B2:  MOVF   xCB,W
0A2B4:  SUBWF  xD9,W
0A2B6:  BNC   A2D4
0A2B8:  BNZ   A2C8
0A2BA:  MOVF   xCA,W
0A2BC:  SUBWF  xD8,W
0A2BE:  BNC   A2D4
0A2C0:  BNZ   A2C8
0A2C2:  MOVF   xC9,W
0A2C4:  SUBWF  xD7,W
0A2C6:  BNC   A2D4
....................                { 
....................                   terminate(1); 
0A2C8:  MOVLW  01
0A2CA:  MOVWF  xEB
0A2CC:  MOVLB  0
0A2CE:  CALL   90D0
0A2D2:  MOVLB  8
....................                } 
....................                break; 
0A2D4:  MOVLB  7
0A2D6:  BRA    A700
0A2D8:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A2DA:  BCF    FD8.0
0A2DC:  MOVLB  7
0A2DE:  RLCF   x40,W
0A2E0:  CLRF   03
0A2E2:  ADDLW  9A
0A2E4:  MOVWF  FE9
0A2E6:  MOVLW  07
0A2E8:  ADDWFC 03,W
0A2EA:  MOVWF  FEA
0A2EC:  MOVFF  FEC,8D8
0A2F0:  MOVF   FED,F
0A2F2:  MOVFF  FEF,8D7
0A2F6:  BCF    FD8.0
0A2F8:  RLCF   x40,W
0A2FA:  CLRF   03
0A2FC:  ADDLW  5A
0A2FE:  MOVWF  FE9
0A300:  MOVLW  07
0A302:  ADDWFC 03,W
0A304:  MOVWF  FEA
0A306:  MOVFF  FEC,03
0A30A:  MOVF   FED,F
0A30C:  MOVFF  FEF,01
0A310:  MOVF   03,W
0A312:  MOVLB  8
0A314:  SUBWF  xD8,W
0A316:  BNC   A32A
0A318:  BNZ   A320
0A31A:  MOVF   01,W
0A31C:  SUBWF  xD7,W
0A31E:  BNC   A32A
....................                { 
....................                   terminate(0); 
0A320:  CLRF   xEB
0A322:  MOVLB  0
0A324:  CALL   90D0
0A328:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A32A:  BCF    FD8.0
0A32C:  MOVLB  7
0A32E:  RLCF   x40,W
0A330:  CLRF   03
0A332:  ADDLW  BB
0A334:  MOVWF  FE9
0A336:  MOVLW  07
0A338:  ADDWFC 03,W
0A33A:  MOVWF  FEA
0A33C:  MOVFF  FEC,8D8
0A340:  MOVF   FED,F
0A342:  MOVFF  FEF,8D7
0A346:  MOVLB  8
0A348:  MOVF   xCC,F
0A34A:  BNZ   A3A2
0A34C:  MOVF   xCB,F
0A34E:  BNZ   A3A2
0A350:  MOVF   xCA,W
0A352:  SUBWF  xD8,W
0A354:  BNC   A3A2
0A356:  BNZ   A35E
0A358:  MOVF   xC9,W
0A35A:  SUBWF  xD7,W
0A35C:  BNC   A3A2
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A35E:  BCF    FD8.0
0A360:  MOVLB  7
0A362:  RLCF   x40,W
0A364:  CLRF   03
0A366:  ADDLW  B7
0A368:  MOVWF  FE9
0A36A:  MOVLW  07
0A36C:  ADDWFC 03,W
0A36E:  MOVWF  FEA
0A370:  MOVFF  FEC,8DE
0A374:  MOVF   FED,F
0A376:  MOVFF  FEF,8DD
0A37A:  MOVFF  8CC,8DC
0A37E:  MOVFF  8CB,8DB
0A382:  MOVFF  8CA,8DA
0A386:  MOVFF  8C9,8D9
0A38A:  MOVLB  0
0A38C:  CALL   9690
0A390:  MOVFF  03,8D1
0A394:  MOVFF  02,8D0
0A398:  MOVFF  01,8CF
0A39C:  MOVFF  00,8CE
0A3A0:  MOVLB  8
....................                } 
....................                break; 
0A3A2:  MOVLB  7
0A3A4:  BRA    A700
0A3A6:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A3A8:  BCF    FD8.0
0A3AA:  MOVLB  7
0A3AC:  RLCF   x40,W
0A3AE:  CLRF   03
0A3B0:  ADDLW  BB
0A3B2:  MOVWF  FE9
0A3B4:  MOVLW  07
0A3B6:  ADDWFC 03,W
0A3B8:  MOVWF  FEA
0A3BA:  MOVFF  FEC,8D8
0A3BE:  MOVF   FED,F
0A3C0:  MOVFF  FEF,8D7
0A3C4:  MOVLB  8
0A3C6:  MOVF   xCC,F
0A3C8:  BNZ   A3E6
0A3CA:  MOVF   xCB,F
0A3CC:  BNZ   A3E6
0A3CE:  MOVF   xCA,W
0A3D0:  SUBWF  xD8,W
0A3D2:  BNC   A3E6
0A3D4:  BNZ   A3DC
0A3D6:  MOVF   xC9,W
0A3D8:  SUBWF  xD7,W
0A3DA:  BNC   A3E6
....................                { 
....................                   terminate(0); 
0A3DC:  CLRF   xEB
0A3DE:  MOVLB  0
0A3E0:  CALL   90D0
0A3E4:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A3E6:  BCF    FD8.0
0A3E8:  MOVLB  7
0A3EA:  RLCF   x40,W
0A3EC:  CLRF   03
0A3EE:  ADDLW  7A
0A3F0:  MOVWF  FE9
0A3F2:  MOVLW  07
0A3F4:  ADDWFC 03,W
0A3F6:  MOVWF  FEA
0A3F8:  MOVFF  FEC,8D8
0A3FC:  MOVF   FED,F
0A3FE:  MOVFF  FEF,8D7
0A402:  MOVLB  8
0A404:  MOVF   xD7,F
0A406:  BNZ   A46C
0A408:  MOVF   xD8,F
0A40A:  BNZ   A46C
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A40C:  CLRF   03
0A40E:  MOVLB  7
0A410:  MOVF   x40,W
0A412:  ADDLW  CB
0A414:  MOVWF  FE9
0A416:  MOVLW  07
0A418:  ADDWFC 03,W
0A41A:  MOVWF  FEA
0A41C:  MOVF   FEF,F
0A41E:  BNZ   A46A
....................                   { 
....................                      wrt_m_error(); 
0A420:  MOVLB  0
0A422:  CALL   8F80
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A426:  BCF    FD8.0
0A428:  MOVLB  7
0A42A:  RLCF   x40,W
0A42C:  CLRF   03
0A42E:  ADDLW  B7
0A430:  MOVWF  FE9
0A432:  MOVLW  07
0A434:  ADDWFC 03,W
0A436:  MOVWF  FEA
0A438:  MOVFF  FEC,8DE
0A43C:  MOVF   FED,F
0A43E:  MOVFF  FEF,8DD
0A442:  MOVFF  8CC,8DC
0A446:  MOVFF  8CB,8DB
0A44A:  MOVFF  8CA,8DA
0A44E:  MOVFF  8C9,8D9
0A452:  MOVLB  0
0A454:  CALL   9690
0A458:  MOVFF  03,8D1
0A45C:  MOVFF  02,8D0
0A460:  MOVFF  01,8CF
0A464:  MOVFF  00,8CE
0A468:  MOVLB  7
0A46A:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A46C:  BCF    FD8.0
0A46E:  MOVLB  7
0A470:  RLCF   x40,W
0A472:  CLRF   03
0A474:  ADDLW  7A
0A476:  MOVWF  FE9
0A478:  MOVLW  07
0A47A:  ADDWFC 03,W
0A47C:  MOVWF  FEA
0A47E:  MOVFF  FEC,8D8
0A482:  MOVF   FED,F
0A484:  MOVFF  FEF,8D7
0A488:  MOVLB  8
0A48A:  DECFSZ xD7,W
0A48C:  BRA    A4F2
0A48E:  MOVF   xD8,F
0A490:  BNZ   A4F2
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A492:  CLRF   03
0A494:  MOVLB  7
0A496:  MOVF   x40,W
0A498:  ADDLW  CB
0A49A:  MOVWF  FE9
0A49C:  MOVLW  07
0A49E:  ADDWFC 03,W
0A4A0:  MOVWF  FEA
0A4A2:  DECFSZ FEF,W
0A4A4:  BRA    A4F0
....................                   { 
....................                      wrt_m_error(); 
0A4A6:  MOVLB  0
0A4A8:  CALL   8F80
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A4AC:  BCF    FD8.0
0A4AE:  MOVLB  7
0A4B0:  RLCF   x40,W
0A4B2:  CLRF   03
0A4B4:  ADDLW  B7
0A4B6:  MOVWF  FE9
0A4B8:  MOVLW  07
0A4BA:  ADDWFC 03,W
0A4BC:  MOVWF  FEA
0A4BE:  MOVFF  FEC,8DE
0A4C2:  MOVF   FED,F
0A4C4:  MOVFF  FEF,8DD
0A4C8:  MOVFF  8CC,8DC
0A4CC:  MOVFF  8CB,8DB
0A4D0:  MOVFF  8CA,8DA
0A4D4:  MOVFF  8C9,8D9
0A4D8:  MOVLB  0
0A4DA:  CALL   9690
0A4DE:  MOVFF  03,8D1
0A4E2:  MOVFF  02,8D0
0A4E6:  MOVFF  01,8CF
0A4EA:  MOVFF  00,8CE
0A4EE:  MOVLB  7
0A4F0:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A4F2:  MOVLB  7
0A4F4:  BRA    A700
0A4F6:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A4F8:  MOVLB  7
0A4FA:  MOVF   x40,W
0A4FC:  MULLW  04
0A4FE:  MOVF   FF3,W
0A500:  CLRF   03
0A502:  ADDLW  A2
0A504:  MOVWF  FE9
0A506:  MOVLW  07
0A508:  ADDWFC 03,W
0A50A:  MOVWF  FEA
0A50C:  MOVFF  FEF,8D7
0A510:  MOVFF  FEC,8D8
0A514:  MOVFF  FEC,8D9
0A518:  MOVFF  FEC,8DA
0A51C:  MOVLB  8
0A51E:  MOVF   xCE,W
0A520:  SUBWF  xD7,F
0A522:  MOVF   xCF,W
0A524:  SUBWFB xD8,F
0A526:  MOVF   xD0,W
0A528:  SUBWFB xD9,F
0A52A:  MOVF   xD1,W
0A52C:  SUBWFB xDA,F
0A52E:  BNZ   A546
0A530:  MOVF   xD9,F
0A532:  BNZ   A546
0A534:  MOVF   xD5,W
0A536:  SUBWF  xD8,W
0A538:  BTFSS  FD8.0
0A53A:  BRA    A642
0A53C:  BNZ   A546
0A53E:  MOVF   xD4,W
0A540:  SUBWF  xD7,W
0A542:  BTFSS  FD8.0
0A544:  BRA    A642
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A546:  BCF    FD8.0
0A548:  MOVLB  7
0A54A:  RLCF   x40,W
0A54C:  CLRF   03
0A54E:  ADDLW  66
0A550:  MOVWF  01
0A552:  MOVLW  07
0A554:  ADDWFC 03,F
0A556:  MOVLB  8
0A558:  MOVFF  03,8D8
0A55C:  BCF    FD8.0
0A55E:  MOVLB  7
0A560:  RLCF   x40,W
0A562:  CLRF   03
0A564:  ADDLW  9E
0A566:  MOVWF  FE9
0A568:  MOVLW  07
0A56A:  ADDWFC 03,W
0A56C:  MOVWF  FEA
0A56E:  MOVFF  FEC,03
0A572:  MOVF   FED,F
0A574:  MOVFF  FEF,8D9
0A578:  MOVLB  8
0A57A:  MOVFF  8D8,FEA
0A57E:  MOVFF  01,FE9
0A582:  MOVFF  03,FEC
0A586:  MOVF   FED,F
0A588:  MOVFF  8D9,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A58C:  MOVLB  7
0A58E:  MOVF   x40,W
0A590:  MULLW  04
0A592:  MOVF   FF3,W
0A594:  CLRF   03
0A596:  ADDLW  A2
0A598:  MOVWF  FE9
0A59A:  MOVLW  07
0A59C:  ADDWFC 03,W
0A59E:  MOVWF  FEA
0A5A0:  MOVFF  FEF,8D7
0A5A4:  MOVFF  FEC,8D8
0A5A8:  MOVFF  FEC,8D9
0A5AC:  MOVFF  FEC,8DA
0A5B0:  MOVLW  84
0A5B2:  MOVWF  FF6
0A5B4:  MOVLW  1A
0A5B6:  MOVWF  FF7
0A5B8:  MOVLW  00
0A5BA:  MOVWF  FF8
0A5BC:  CLRF   1B
0A5BE:  BTFSC  FF2.7
0A5C0:  BSF    1B.7
0A5C2:  BCF    FF2.7
0A5C4:  MOVLW  0B
0A5C6:  MOVLB  A
0A5C8:  MOVWF  x40
0A5CA:  MOVLB  0
0A5CC:  CALL   101C
0A5D0:  BTFSC  1B.7
0A5D2:  BSF    FF2.7
0A5D4:  MOVLW  41
0A5D6:  MOVWF  FE9
0A5D8:  CLRF   1B
0A5DA:  BTFSC  FF2.7
0A5DC:  BSF    1B.7
0A5DE:  BCF    FF2.7
0A5E0:  MOVFF  8DA,A43
0A5E4:  MOVFF  8D9,A42
0A5E8:  MOVFF  8D8,A41
0A5EC:  MOVFF  8D7,A40
0A5F0:  CALL   10E2
0A5F4:  BTFSC  1B.7
0A5F6:  BSF    FF2.7
0A5F8:  MOVLW  2C
0A5FA:  BTFSS  F9E.4
0A5FC:  BRA    A5FA
0A5FE:  MOVWF  FAD
0A600:  MOVLW  41
0A602:  MOVWF  FE9
0A604:  CLRF   1B
0A606:  BTFSC  FF2.7
0A608:  BSF    1B.7
0A60A:  BCF    FF2.7
0A60C:  MOVFF  8D1,A43
0A610:  MOVFF  8D0,A42
0A614:  MOVFF  8CF,A41
0A618:  MOVFF  8CE,A40
0A61C:  CALL   10E2
0A620:  BTFSC  1B.7
0A622:  BSF    FF2.7
0A624:  MOVLW  0D
0A626:  BTFSS  F9E.4
0A628:  BRA    A626
0A62A:  MOVWF  FAD
0A62C:  MOVLW  0A
0A62E:  BTFSS  F9E.4
0A630:  BRA    A62E
0A632:  MOVWF  FAD
....................                   terminate(1); 
0A634:  MOVLW  01
0A636:  MOVLB  8
0A638:  MOVWF  xEB
0A63A:  MOVLB  0
0A63C:  CALL   90D0
0A640:  MOVLB  8
....................                } 
....................                break; 
0A642:  MOVLB  7
0A644:  BRA    A700
0A646:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A648:  MOVLB  7
0A64A:  MOVF   x40,W
0A64C:  MULLW  04
0A64E:  MOVF   FF3,W
0A650:  CLRF   03
0A652:  ADDLW  A2
0A654:  MOVWF  FE9
0A656:  MOVLW  07
0A658:  ADDWFC 03,W
0A65A:  MOVWF  FEA
0A65C:  MOVFF  FEF,8D7
0A660:  MOVFF  FEC,8D8
0A664:  MOVFF  FEC,8D9
0A668:  MOVFF  FEC,8DA
0A66C:  BCF    FD8.0
0A66E:  RLCF   x40,W
0A670:  CLRF   03
0A672:  ADDLW  72
0A674:  MOVWF  FE9
0A676:  MOVLW  07
0A678:  ADDWFC 03,W
0A67A:  MOVWF  FEA
0A67C:  MOVFF  FEC,03
0A680:  MOVF   FED,F
0A682:  MOVFF  FEF,01
0A686:  MOVLB  8
0A688:  MOVF   xDA,F
0A68A:  BNZ   A69E
0A68C:  MOVF   xD9,F
0A68E:  BNZ   A69E
0A690:  MOVF   03,W
0A692:  SUBWF  xD8,W
0A694:  BNC   A6FE
0A696:  BNZ   A69E
0A698:  MOVF   01,W
0A69A:  SUBWF  xD7,W
0A69C:  BNC   A6FE
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A69E:  BCF    FD8.0
0A6A0:  MOVLB  7
0A6A2:  RLCF   x40,W
0A6A4:  CLRF   03
0A6A6:  ADDLW  66
0A6A8:  MOVWF  01
0A6AA:  MOVLW  07
0A6AC:  ADDWFC 03,F
0A6AE:  MOVLB  8
0A6B0:  MOVFF  03,8D8
0A6B4:  BCF    FD8.0
0A6B6:  MOVLB  7
0A6B8:  RLCF   x40,W
0A6BA:  CLRF   03
0A6BC:  ADDLW  9E
0A6BE:  MOVWF  FE9
0A6C0:  MOVLW  07
0A6C2:  ADDWFC 03,W
0A6C4:  MOVWF  FEA
0A6C6:  MOVFF  FEC,03
0A6CA:  MOVF   FED,F
0A6CC:  MOVFF  FEF,8D9
0A6D0:  MOVLB  8
0A6D2:  MOVFF  8D8,FEA
0A6D6:  MOVFF  01,FE9
0A6DA:  MOVFF  03,FEC
0A6DE:  MOVF   FED,F
0A6E0:  MOVFF  8D9,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A6E4:  BCF    FD8.0
0A6E6:  MOVLB  7
0A6E8:  RLCF   x40,W
0A6EA:  CLRF   03
0A6EC:  ADDLW  BB
0A6EE:  MOVWF  FE9
0A6F0:  MOVLW  07
0A6F2:  ADDWFC 03,W
0A6F4:  MOVWF  FEA
0A6F6:  CLRF   FEC
0A6F8:  MOVF   FED,F
0A6FA:  CLRF   FEF
0A6FC:  MOVLB  8
....................                } 
....................                break; 
0A6FE:  MOVLB  7
....................             } 
....................          } 
0A700:  MOVLB  0
0A702:  BRA    A1F4
0A704:  MOVLB  7
....................       } 
....................    } 
0A706:  BRA    A724
0A708:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A70A:  BCF    FD8.0
0A70C:  MOVLB  7
0A70E:  RLCF   x40,W
0A710:  CLRF   03
0A712:  ADDLW  96
0A714:  MOVWF  FE9
0A716:  MOVLW  07
0A718:  ADDWFC 03,W
0A71A:  MOVWF  FEA
0A71C:  CLRF   FEC
0A71E:  MOVF   FED,F
0A720:  MOVLW  01
0A722:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A724:  BCF    FD8.0
0A726:  RLCF   x40,W
0A728:  CLRF   03
0A72A:  ADDLW  96
0A72C:  MOVWF  FE9
0A72E:  MOVLW  07
0A730:  ADDWFC 03,W
0A732:  MOVWF  FEA
0A734:  MOVFF  FEC,8D8
0A738:  MOVF   FED,F
0A73A:  MOVFF  FEF,8D7
0A73E:  MOVLB  8
0A740:  DECFSZ xD7,W
0A742:  BRA    A754
0A744:  MOVF   xD8,F
0A746:  BNZ   A754
....................       wrt_m_error(); 
0A748:  MOVLB  0
0A74A:  CALL   8F80
....................       msg_mer(); 
0A74E:  CALL   9D02
0A752:  MOVLB  8
....................    } 
0A754:  MOVLB  0
0A756:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
170A4:  MOVF   48,F
170A6:  BNZ   170B4
170A8:  MOVF   49,F
170AA:  BNZ   170B4
170AC:  MOVF   4A,F
170AE:  BNZ   170B4
170B0:  MOVF   4B,F
170B2:  BZ    170E0
170B4:  MOVF   4B,F
170B6:  BNZ   170E0
170B8:  MOVF   4A,W
170BA:  SUBLW  00
170BC:  BNC   170E0
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
170BE:  MOVFF  885,8C7
170C2:  MOVFF  886,8C8
170C6:  MOVFF  4B,8CC
170CA:  MOVFF  4A,8CB
170CE:  MOVFF  49,8CA
170D2:  MOVFF  48,8C9
170D6:  MOVFF  887,8CD
170DA:  CALL   9D78
....................    } 
170DE:  BRA    1715C
....................    else if(arg==0) 
170E0:  MOVF   48,F
170E2:  BNZ   17158
170E4:  MOVF   49,F
170E6:  BNZ   17158
170E8:  MOVF   4A,F
170EA:  BNZ   17158
170EC:  MOVF   4B,F
170EE:  BNZ   17158
....................    { 
....................       m_lin_pos[motor]=0; 
170F0:  BCF    FD8.0
170F2:  MOVLB  7
170F4:  RLCF   x40,W
170F6:  CLRF   03
170F8:  ADDLW  B3
170FA:  MOVWF  FE9
170FC:  MOVLW  07
170FE:  ADDWFC 03,W
17100:  MOVWF  FEA
17102:  CLRF   FEC
17104:  MOVF   FED,F
17106:  CLRF   FEF
....................       switch (motor){ 
17108:  MOVF   x40,W
1710A:  XORLW  00
1710C:  MOVLB  0
1710E:  BZ    17116
17110:  XORLW  01
17112:  BZ    17128
17114:  BRA    17138
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
17116:  MOVLW  B6
17118:  MOVLB  8
1711A:  MOVWF  xEE
1711C:  CLRF   xF0
1711E:  CLRF   xEF
17120:  MOVLB  0
17122:  CALL   4FD4
....................             break; 
17126:  BRA    17138
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
17128:  MOVLW  B8
1712A:  MOVLB  8
1712C:  MOVWF  xEE
1712E:  CLRF   xF0
17130:  CLRF   xEF
17132:  MOVLB  0
17134:  CALL   4FD4
....................             break; 
....................       }  
....................       m_error[motor]=0; 
17138:  BCF    FD8.0
1713A:  MOVLB  7
1713C:  RLCF   x40,W
1713E:  CLRF   03
17140:  ADDLW  96
17142:  MOVWF  FE9
17144:  MOVLW  07
17146:  ADDWFC 03,W
17148:  MOVWF  FEA
1714A:  CLRF   FEC
1714C:  MOVF   FED,F
1714E:  CLRF   FEF
....................       wrt_m_error(); 
17150:  MOVLB  0
17152:  CALL   8F80
....................    } 
17156:  BRA    1715C
....................    else cmd_arg(); 
17158:  CALL   B2FE
1715C:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
18B54:  MOVLW  01
18B56:  MOVLB  8
18B58:  MOVWF  xEC
18B5A:  MOVLB  0
18B5C:  CALL   89D0
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18B60:  MOVLW  FA
18B62:  MOVLB  9
18B64:  MOVWF  xEC
18B66:  MOVLB  0
18B68:  CALL   2910
....................       switch(motor) 
18B6C:  MOVLB  7
18B6E:  MOVF   x40,W
18B70:  XORLW  00
18B72:  MOVLB  0
18B74:  BZ    18B7C
18B76:  XORLW  01
18B78:  BZ    18B8E
18B7A:  BRA    18B9E
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18B7C:  MOVLB  8
18B7E:  CLRF   x85
18B80:  BTFSC  F81.4
18B82:  INCF   x85,F
....................             chanA = input(ENC1_PHA); 
18B84:  CLRF   x86
18B86:  BTFSC  F81.1
18B88:  INCF   x86,F
....................             break; 
18B8A:  MOVLB  0
18B8C:  BRA    18B9E
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18B8E:  MOVLB  8
18B90:  CLRF   x85
18B92:  BTFSC  F81.5
18B94:  INCF   x85,F
....................             chanA = input(ENC2_PHA); 
18B96:  CLRF   x86
18B98:  BTFSC  F81.2
18B9A:  INCF   x86,F
....................             break; 
18B9C:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18B9E:  MOVLW  9A
18BA0:  MOVWF  FF6
18BA2:  MOVLW  1A
18BA4:  MOVWF  FF7
18BA6:  MOVLW  00
18BA8:  MOVWF  FF8
18BAA:  CLRF   1B
18BAC:  BTFSC  FF2.7
18BAE:  BSF    1B.7
18BB0:  BCF    FF2.7
18BB2:  MOVLW  04
18BB4:  MOVLB  A
18BB6:  MOVWF  x40
18BB8:  MOVLB  0
18BBA:  CALL   101C
18BBE:  BTFSC  1B.7
18BC0:  BSF    FF2.7
18BC2:  CLRF   1B
18BC4:  BTFSC  FF2.7
18BC6:  BSF    1B.7
18BC8:  BCF    FF2.7
18BCA:  MOVFF  885,A40
18BCE:  MOVLW  1B
18BD0:  MOVLB  A
18BD2:  MOVWF  x41
18BD4:  MOVLB  0
18BD6:  CALL   0F9E
18BDA:  BTFSC  1B.7
18BDC:  BSF    FF2.7
18BDE:  MOVLW  A0
18BE0:  MOVWF  FF6
18BE2:  MOVLW  1A
18BE4:  MOVWF  FF7
18BE6:  MOVLW  00
18BE8:  MOVWF  FF8
18BEA:  CLRF   1B
18BEC:  BTFSC  FF2.7
18BEE:  BSF    1B.7
18BF0:  BCF    FF2.7
18BF2:  MOVLW  07
18BF4:  MOVLB  A
18BF6:  MOVWF  x40
18BF8:  MOVLB  0
18BFA:  CALL   101C
18BFE:  BTFSC  1B.7
18C00:  BSF    FF2.7
18C02:  CLRF   1B
18C04:  BTFSC  FF2.7
18C06:  BSF    1B.7
18C08:  BCF    FF2.7
18C0A:  MOVFF  886,A40
18C0E:  MOVLW  1B
18C10:  MOVLB  A
18C12:  MOVWF  x41
18C14:  MOVLB  0
18C16:  CALL   0F9E
18C1A:  BTFSC  1B.7
18C1C:  BSF    FF2.7
18C1E:  MOVLW  0D
18C20:  BTFSS  F9E.4
18C22:  BRA    18C20
18C24:  MOVWF  FAD
18C26:  MOVLW  0A
18C28:  BTFSS  F9E.4
18C2A:  BRA    18C28
18C2C:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
18C2E:  BTFSS  F9E.5
18C30:  BRA    18C3E
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
18C32:  CALL   0E30
18C36:  MOVF   01,W
18C38:  SUBLW  1B
18C3A:  BNZ   18C3E
....................          { 
....................             break; 
18C3C:  BRA    18C40
....................          } 
....................       } 
18C3E:  BRA    18B60
....................    } 
....................  
....................    delay_ms(100); 
18C40:  MOVLW  64
18C42:  MOVLB  9
18C44:  MOVWF  xEC
18C46:  MOVLB  0
18C48:  CALL   2910
....................    enc_pwr(OFF); 
18C4C:  MOVLB  8
18C4E:  CLRF   xEC
18C50:  MOVLB  0
18C52:  CALL   89D0
18C56:  GOTO   18C72 (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A8B4:  BCF    FD8.0
0A8B6:  MOVLB  7
0A8B8:  RLCF   x40,W
0A8BA:  CLRF   03
0A8BC:  ADDLW  66
0A8BE:  MOVWF  FE9
0A8C0:  MOVLW  07
0A8C2:  ADDWFC 03,W
0A8C4:  MOVWF  FEA
0A8C6:  MOVFF  FEC,8C6
0A8CA:  MOVF   FED,F
0A8CC:  MOVFF  FEF,8C5
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A8D0:  BCF    FD8.0
0A8D2:  RLCF   x40,W
0A8D4:  CLRF   03
0A8D6:  ADDLW  76
0A8D8:  MOVWF  FE9
0A8DA:  MOVLW  07
0A8DC:  ADDWFC 03,W
0A8DE:  MOVWF  FEA
0A8E0:  MOVFF  FEC,8DC
0A8E4:  MOVF   FED,F
0A8E6:  MOVFF  FEF,8DB
0A8EA:  BCF    FD8.0
0A8EC:  RLCF   x40,W
0A8EE:  CLRF   03
0A8F0:  ADDLW  62
0A8F2:  MOVWF  FE9
0A8F4:  MOVLW  07
0A8F6:  ADDWFC 03,W
0A8F8:  MOVWF  FEA
0A8FA:  MOVFF  FEC,03
0A8FE:  MOVF   FED,F
0A900:  MOVFF  FEF,8DD
0A904:  MOVFF  03,8CA
0A908:  MOVFF  03,8DE
0A90C:  MOVLB  0
0A90E:  CALL   2CD4
0A912:  MOVFF  02,8C4
0A916:  MOVFF  01,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A91A:  BCF    FD8.0
0A91C:  MOVLB  7
0A91E:  RLCF   x40,W
0A920:  CLRF   03
0A922:  ADDLW  66
0A924:  MOVWF  FE9
0A926:  MOVLW  07
0A928:  ADDWFC 03,W
0A92A:  MOVWF  FEA
0A92C:  CLRF   FEC
0A92E:  MOVF   FED,F
0A930:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A932:  MOVLB  8
0A934:  CLRF   xC7
0A936:  MOVFF  8C2,8C8
0A93A:  CLRF   xCC
0A93C:  CLRF   xCB
0A93E:  MOVFF  8C4,8CA
0A942:  MOVFF  8C3,8C9
0A946:  MOVLW  01
0A948:  MOVWF  xCD
0A94A:  MOVLB  0
0A94C:  CALL   9D78
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A950:  MOVLW  01
0A952:  MOVLB  8
0A954:  MOVWF  xEC
0A956:  MOVLB  0
0A958:  CALL   89D0
....................    delay_ms(100); 
0A95C:  MOVLW  64
0A95E:  MOVLB  9
0A960:  MOVWF  xEC
0A962:  MOVLB  0
0A964:  CALL   2910
....................    poll_index(); 
0A968:  BRA    A782
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A96A:  BCF    FD8.0
0A96C:  MOVLB  7
0A96E:  RLCF   x40,W
0A970:  CLRF   03
0A972:  ADDLW  5E
0A974:  MOVWF  FE9
0A976:  MOVLW  07
0A978:  ADDWFC 03,W
0A97A:  MOVWF  FEA
0A97C:  MOVFF  FEC,8C8
0A980:  MOVF   FED,F
0A982:  MOVFF  FEF,8C7
0A986:  MOVLW  02
0A988:  MOVLB  8
0A98A:  ADDWF  xC7,W
0A98C:  MOVWF  xC3
0A98E:  MOVLW  00
0A990:  ADDWFC xC8,W
0A992:  MOVWF  xC4
....................    e_mode[motor] = 3; 
0A994:  BCF    FD8.0
0A996:  MOVLB  7
0A998:  RLCF   x40,W
0A99A:  CLRF   03
0A99C:  ADDLW  66
0A99E:  MOVWF  FE9
0A9A0:  MOVLW  07
0A9A2:  ADDWFC 03,W
0A9A4:  MOVWF  FEA
0A9A6:  CLRF   FEC
0A9A8:  MOVF   FED,F
0A9AA:  MOVLW  03
0A9AC:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A9AE:  MOVLB  8
0A9B0:  CLRF   xC7
0A9B2:  MOVFF  8C2,8C8
0A9B6:  CLRF   xCC
0A9B8:  CLRF   xCB
0A9BA:  MOVFF  8C4,8CA
0A9BE:  MOVFF  8C3,8C9
0A9C2:  MOVLW  01
0A9C4:  MOVWF  xCD
0A9C6:  MOVLB  0
0A9C8:  CALL   9D78
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A9CC:  MOVFF  783,8C4
0A9D0:  MOVFF  782,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A9D4:  BCF    FD8.0
0A9D6:  MOVLB  7
0A9D8:  RLCF   x40,W
0A9DA:  CLRF   03
0A9DC:  ADDLW  66
0A9DE:  MOVWF  FE9
0A9E0:  MOVLW  07
0A9E2:  ADDWFC 03,W
0A9E4:  MOVWF  FEA
0A9E6:  CLRF   FEC
0A9E8:  MOVF   FED,F
0A9EA:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0A9EC:  MOVLB  8
0A9EE:  CLRF   xC7
0A9F0:  MOVFF  8C2,8C8
0A9F4:  CLRF   xCC
0A9F6:  CLRF   xCB
0A9F8:  MOVFF  8C4,8CA
0A9FC:  MOVFF  8C3,8C9
0AA00:  MOVLW  01
0AA02:  MOVWF  xCD
0AA04:  MOVLB  0
0AA06:  CALL   9D78
....................  
....................    e_pos[motor] = 0; 
0AA0A:  BCF    FD8.0
0AA0C:  MOVLB  7
0AA0E:  RLCF   x40,W
0AA10:  CLRF   03
0AA12:  ADDLW  BF
0AA14:  MOVWF  FE9
0AA16:  MOVLW  07
0AA18:  ADDWFC 03,W
0AA1A:  MOVWF  FEA
0AA1C:  CLRF   FEC
0AA1E:  MOVF   FED,F
0AA20:  CLRF   FEF
....................    e_port[motor] = 1; 
0AA22:  BCF    FD8.0
0AA24:  RLCF   x40,W
0AA26:  CLRF   03
0AA28:  ADDLW  C3
0AA2A:  MOVWF  FE9
0AA2C:  MOVLW  07
0AA2E:  ADDWFC 03,W
0AA30:  MOVWF  FEA
0AA32:  CLRF   FEC
0AA34:  MOVF   FED,F
0AA36:  MOVLW  01
0AA38:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0AA3A:  BCF    FD8.0
0AA3C:  RLCF   x40,W
0AA3E:  CLRF   03
0AA40:  ADDLW  66
0AA42:  MOVWF  FE9
0AA44:  MOVLW  07
0AA46:  ADDWFC 03,W
0AA48:  MOVWF  FEA
0AA4A:  MOVFF  8C6,FEC
0AA4E:  MOVF   FED,F
0AA50:  MOVFF  8C5,FEF
0AA54:  MOVLB  0
0AA56:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0E0B4:  BCF    FD8.0
0E0B6:  MOVLB  7
0E0B8:  RLCF   x40,W
0E0BA:  CLRF   03
0E0BC:  ADDLW  5E
0E0BE:  MOVWF  FE9
0E0C0:  MOVLW  07
0E0C2:  ADDWFC 03,W
0E0C4:  MOVWF  FEA
0E0C6:  MOVFF  FEC,889
0E0CA:  MOVF   FED,F
0E0CC:  MOVFF  FEF,888
0E0D0:  MOVLW  02
0E0D2:  MOVLB  8
0E0D4:  ADDWF  x88,W
0E0D6:  MOVWF  x86
0E0D8:  MOVLW  00
0E0DA:  ADDWFC x89,W
0E0DC:  MOVWF  x87
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0E0DE:  CLRF   xC7
0E0E0:  MOVFF  885,8C8
0E0E4:  CLRF   xCC
0E0E6:  CLRF   xCB
0E0E8:  MOVFF  887,8CA
0E0EC:  MOVFF  886,8C9
0E0F0:  MOVLW  02
0E0F2:  MOVWF  xCD
0E0F4:  MOVLB  0
0E0F6:  CALL   9D78
0E0FA:  GOTO   E17A (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0AA58:  MOVF   2F,W
0AA5A:  SUBLW  02
0AA5C:  BNZ   AA62
0AA5E:  MOVF   30,F
0AA60:  BZ    AACA
....................    { 
....................       //setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_256); 
....................       //set up valve timeout variable 
....................       /*ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
....................       enable_interrupts(INT_EXT); 
....................  
....................       start_heartbeat(); 
....................  
....................       enable_interrupts(GLOBAL); 
....................       busy_set();*/ 
....................       valve_align_timeout = 0; 
0AA62:  CLRF   3A
0AA64:  CLRF   39
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0AA66:  MOVLW  AC
0AA68:  MOVWF  FF6
0AA6A:  MOVLW  1A
0AA6C:  MOVWF  FF7
0AA6E:  MOVLW  00
0AA70:  MOVWF  FF8
0AA72:  CLRF   1B
0AA74:  BTFSC  FF2.7
0AA76:  BSF    1B.7
0AA78:  BCF    FF2.7
0AA7A:  CALL   0E46
0AA7E:  BTFSC  1B.7
0AA80:  BSF    FF2.7
....................       motor=0; 
0AA82:  MOVLB  7
0AA84:  CLRF   x40
....................       align(0); 
0AA86:  MOVLB  8
0AA88:  CLRF   xC2
0AA8A:  MOVLB  0
0AA8C:  RCALL  A8B4
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0AA8E:  MOVLW  01
0AA90:  MOVLB  7
0AA92:  MOVWF  x40
....................       move_motor(0,0,22000,1); 
0AA94:  MOVLB  8
0AA96:  CLRF   xC7
0AA98:  CLRF   xC8
0AA9A:  CLRF   xCC
0AA9C:  CLRF   xCB
0AA9E:  MOVLW  55
0AAA0:  MOVWF  xCA
0AAA2:  MOVLW  F0
0AAA4:  MOVWF  xC9
0AAA6:  MOVLW  01
0AAA8:  MOVWF  xCD
0AAAA:  MOVLB  0
0AAAC:  CALL   9D78
....................        
....................       m_lin_pos[1]=0; 
0AAB0:  MOVLB  7
0AAB2:  CLRF   xB6
0AAB4:  CLRF   xB5
....................       write16(ADDR_M2_LIN_POS,0); 
0AAB6:  MOVLW  B8
0AAB8:  MOVLB  8
0AABA:  MOVWF  xEE
0AABC:  CLRF   xF0
0AABE:  CLRF   xEF
0AAC0:  MOVLB  0
0AAC2:  CALL   4FD4
....................       valve_align_timeout = -1; 
0AAC6:  SETF   3A
0AAC8:  SETF   39
....................    } 
0AACA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0C202:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C204:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0C206:  BCF    F8E.3
....................   delay_ms(20); 
0C208:  MOVLW  14
0C20A:  MOVLB  9
0C20C:  MOVWF  xEC
0C20E:  MOVLB  0
0C210:  CALL   2910
....................   output_bit(VMOT,  OFF); 
0C214:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0C216:  BCF    F8E.2
0C218:  GOTO   C26E (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C21C:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C21E:  BSF    F8E.1
....................   delay_ms(50); 
0C220:  MOVLW  32
0C222:  MOVLB  9
0C224:  MOVWF  xEC
0C226:  MOVLB  0
0C228:  CALL   2910
....................   output_bit(HB_IN1,ON);           
0C22C:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C22E:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0C230:  BSF    F8E.3
0C232:  GOTO   C26E (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C236:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C238:  BSF    F8E.1
....................   delay_ms(50); 
0C23A:  MOVLW  32
0C23C:  MOVLB  9
0C23E:  MOVWF  xEC
0C240:  MOVLB  0
0C242:  CALL   2910
....................   output_bit(HB_IN1,OFF);           
0C246:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0C248:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0C24A:  BSF    F8E.3
0C24C:  GOTO   C26E (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0C250:  MOVLB  8
0C252:  MOVF   xB5,W
0C254:  XORLW  00
0C256:  MOVLB  0
0C258:  BZ    C264
0C25A:  XORLW  01
0C25C:  BZ    C268
0C25E:  XORLW  03
0C260:  BZ    C26C
0C262:  BRA    C26E
....................       case 0:  HB_all_OFF(); 
0C264:  BRA    C202
....................          break; 
0C266:  BRA    C26E
....................       case 1:  HB_m1_ON(); 
0C268:  BRA    C21C
....................          break; 
0C26A:  BRA    C26E
....................       case 2:  HB_m2_ON(); 
0C26C:  BRA    C236
....................          break; 
....................    } 
0C26E:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
15DA4:  MOVLB  8
15DA6:  CLRF   x89
15DA8:  CLRF   x8A
15DAA:  CLRF   x8B
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
15DAC:  MOVLB  0
15DAE:  BRA    15D3A
15DB0:  MOVFF  01,88A
....................       if (serChar) 
15DB4:  MOVLB  8
15DB6:  MOVF   x8A,F
15DB8:  BZ    15DE2
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
15DBA:  MOVF   x8A,W
15DBC:  SUBLW  24
15DBE:  BNZ   15DC8
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
15DC0:  MOVLW  02
15DC2:  MOVWF  x8B
....................             break; 
15DC4:  BRA    15DEE
....................          }else if (serChar == 'D'){ 
15DC6:  BRA    15DE2
15DC8:  MOVF   x8A,W
15DCA:  SUBLW  44
15DCC:  BNZ   15DDE
....................             wakeup_char_is_D = 1; 
15DCE:  MOVLW  01
15DD0:  MOVLB  7
15DD2:  MOVWF  xCD
....................             wakeUpReason = WAKE_UP_GOOD; 
15DD4:  MOVLW  02
15DD6:  MOVLB  8
15DD8:  MOVWF  x8B
....................             break; 
15DDA:  BRA    15DEE
....................          }else 
15DDC:  BRA    15DE2
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
15DDE:  MOVLW  01
15DE0:  MOVWF  x8B
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
15DE2:  INCF   x89,F
15DE4:  MOVF   x89,W
15DE6:  SUBLW  02
15DE8:  BC    15DEC
....................       { 
....................          break; 
15DEA:  BRA    15DEE
....................       } 
15DEC:  BRA    15DAC
....................    } 
....................  
....................    return (wakeUpReason); 
15DEE:  MOVFF  88B,01
15DF2:  MOVLB  0
15DF4:  GOTO   15E08 (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
15CD2:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
15CD4:  BSF    4D.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
15CD6:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
15CD8:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
15CDA:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
15CDC:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
15CDE:  BSF    FF2.6
15CE0:  GOTO   15CEC (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
15CE4:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
15CE6:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
15CE8:  BCF    4D.0
....................    set_usart_int(); 
15CEA:  BRA    15CD2
....................    kill_wd(); 
15CEC:  CALL   30F6
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
15CF0:  BSF    FF2.4
....................    sleep();  
15CF2:  MOVFF  FD3,00
15CF6:  BCF    FD1.7
15CF8:  BCF    FD3.7
15CFA:  SLEEP 
15CFC:  MOVFF  00,FD3
....................    delay_cycles(1); 
15D00:  NOP   
15D02:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
15DF8:  MOVLB  8
15DFA:  CLRF   x88
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
15DFC:  MOVLB  0
15DFE:  RCALL  15D04
....................  
....................    if (TRUE != rtc_alarm) 
15E00:  BTFSC  4D.0
15E02:  BRA    15ED2
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15E04:  RCALL  15D04
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15E06:  BRA    15DA4
15E08:  MOVFF  01,888
....................       if (WAKE_UP_GOOD == serWakeupReason) 
15E0C:  MOVLB  8
15E0E:  MOVF   x88,W
15E10:  SUBLW  02
15E12:  BNZ   15ECA
....................       { 
....................          sleep_mode = FALSE; 
15E14:  BCF    4D.1
....................          start_heartbeat(); 
15E16:  MOVLB  0
15E18:  CALL   2900
....................          init_hardware(); 
15E1C:  CALL   293A
....................          init_rtc();                      // This is the FAT RTC 
15E20:  CALL   3508
....................          sd_status = init_sdcard(); 
15E24:  CALL   503A
15E28:  MOVFF  01,2DC
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
15E2C:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
15E2E:  MOVLW  01
15E30:  MOVWF  1E
15E32:  MOVLW  A7
15E34:  MOVWF  1D
15E36:  MOVLW  E2
15E38:  MOVWF  FF6
15E3A:  MOVLW  1A
15E3C:  MOVWF  FF7
15E3E:  MOVLW  00
15E40:  MOVWF  FF8
15E42:  CALL   50BE
....................          record_event(); 
15E46:  CALL   84DA
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15E4A:  CLRF   32
15E4C:  MOVLW  01
15E4E:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
15E50:  MOVLW  02
15E52:  MOVLB  8
15E54:  MOVWF  x89
15E56:  MOVFF  31,88A
15E5A:  MOVLB  0
15E5C:  CALL   3412
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................           
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
15E60:  MOVLB  7
15E62:  MOVF   xCD,F
15E64:  BZ    15E88
....................             file_list(file_ptr_rel_new); 
15E66:  MOVLW  03
15E68:  MOVLB  8
15E6A:  MOVWF  x8A
15E6C:  MOVLW  07
15E6E:  MOVWF  x89
15E70:  MOVLB  0
15E72:  CALL   BB24
....................             f_unlink(file_ptr_rel_new); 
15E76:  MOVLW  03
15E78:  MOVLB  8
15E7A:  MOVWF  x8A
15E7C:  MOVLW  07
15E7E:  MOVWF  x89
15E80:  MOVLB  0
15E82:  CALL   BC9E
15E86:  MOVLB  7
....................          } 
....................          if(sd_status>0) 
15E88:  MOVLB  2
15E8A:  MOVF   xDC,F
15E8C:  BZ    15E96
....................          { 
....................             msg_card_fail(); 
15E8E:  MOVLB  0
15E90:  CALL   5080
15E94:  MOVLB  2
....................          } 
....................  
....................           
....................          if (!wakeup_char_is_D){ 
15E96:  MOVLB  7
15E98:  MOVF   xCD,F
15E9A:  BNZ   15EC0
....................             fprintf(COM_A, "@RST\r\n"); 
15E9C:  MOVLW  04
15E9E:  MOVWF  FF6
15EA0:  MOVLW  1B
15EA2:  MOVWF  FF7
15EA4:  MOVLW  00
15EA6:  MOVWF  FF8
15EA8:  CLRF   1B
15EAA:  BTFSC  FF2.7
15EAC:  BSF    1B.7
15EAE:  BCF    FF2.7
15EB0:  MOVLB  0
15EB2:  CALL   0E46
15EB6:  BTFSC  1B.7
15EB8:  BSF    FF2.7
....................             reset_cpu(); 
15EBA:  RESET
....................          }else{ 
15EBC:  BRA    15EC6
15EBE:  MOVLB  7
....................            //go back to sleep 
....................             wakeup_char_is_D = 0; 
15EC0:  CLRF   xCD
....................             initilizeSleepState(); 
15EC2:  MOVLB  0
15EC4:  RCALL  15CE4
....................          } 
....................       } 
15EC6:  BRA    15ED2
15EC8:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
15ECA:  DECFSZ x88,W
15ECC:  BRA    15ED4
....................          { 
....................              
....................             initilizeSleepState(); 
15ECE:  MOVLB  0
15ED0:  RCALL  15CE4
15ED2:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
15ED4:  MOVLW  00
15ED6:  BTFSC  4D.0
15ED8:  MOVLW  01
15EDA:  MOVWF  01
15EDC:  MOVLB  0
15EDE:  GOTO   15EE8 (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
15EE2:  RCALL  15C68
....................    initilizeSleepState(); 
15EE4:  RCALL  15CE4
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
15EE6:  BRA    15DF8
15EE8:  DECFSZ 01,W
15EEA:  BRA    15EF0
....................       { 
....................          rtc_alarm = FALSE; 
15EEC:  BCF    4D.0
....................          break; 
15EEE:  BRA    15EF6
....................       } 
....................  
....................       blip(); 
15EF0:  RCALL  15D04
....................       blip(); 
15EF2:  RCALL  15D04
15EF4:  BRA    15EE6
....................    } 
15EF6:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0ABC6:  MOVF   FD0,W
0ABC8:  ANDLW  0F
0ABCA:  BTFSS  FD0.4
0ABCC:  MOVLW  00
0ABCE:  BSF    FD0.0
0ABD0:  BSF    FD0.1
0ABD2:  BSF    FD0.4
0ABD4:  BSF    FD8.3
0ABD6:  BSF    FD8.4
0ABD8:  ADDLW  F0
0ABDA:  BTFSC  FD8.0
0ABDC:  BRA    ADE8
0ABDE:  ADDLW  10
0ABE0:  GOTO   ADEC
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0ABE4:  MOVLW  0C
0ABE6:  MOVWF  FF6
0ABE8:  MOVLW  1B
0ABEA:  MOVWF  FF7
0ABEC:  MOVLW  00
0ABEE:  MOVWF  FF8
0ABF0:  CLRF   1B
0ABF2:  BTFSC  FF2.7
0ABF4:  BSF    1B.7
0ABF6:  BCF    FF2.7
0ABF8:  CALL   0E46
0ABFC:  BTFSC  1B.7
0ABFE:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AC00:  MOVLW  01
0AC02:  MOVWF  1E
0AC04:  MOVLW  A7
0AC06:  MOVWF  1D
0AC08:  MOVLW  14
0AC0A:  MOVWF  FF6
0AC0C:  MOVLW  1B
0AC0E:  MOVWF  FF7
0AC10:  MOVLW  00
0AC12:  MOVWF  FF8
0AC14:  CALL   50BE
....................          record_event(); 
0AC18:  CALL   84DA
....................          recovery(); 
0AC1C:  RCALL  AA58
....................          break; 
0AC1E:  BRA    ADE8
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AC20:  MOVLW  32
0AC22:  MOVWF  FF6
0AC24:  MOVLW  1B
0AC26:  MOVWF  FF7
0AC28:  MOVLW  00
0AC2A:  MOVWF  FF8
0AC2C:  CLRF   1B
0AC2E:  BTFSC  FF2.7
0AC30:  BSF    1B.7
0AC32:  BCF    FF2.7
0AC34:  CALL   0E46
0AC38:  BTFSC  1B.7
0AC3A:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AC3C:  MOVLW  01
0AC3E:  MOVWF  1E
0AC40:  MOVLW  A7
0AC42:  MOVWF  1D
0AC44:  MOVLW  3A
0AC46:  MOVWF  FF6
0AC48:  MOVLW  1B
0AC4A:  MOVWF  FF7
0AC4C:  MOVLW  00
0AC4E:  MOVWF  FF8
0AC50:  CALL   50BE
....................          record_event(); 
0AC54:  CALL   84DA
....................          recovery(); 
0AC58:  RCALL  AA58
....................          break; 
0AC5A:  BRA    ADE8
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AC5C:  MOVLW  5A
0AC5E:  MOVWF  FF6
0AC60:  MOVLW  1B
0AC62:  MOVWF  FF7
0AC64:  MOVLW  00
0AC66:  MOVWF  FF8
0AC68:  CLRF   1B
0AC6A:  BTFSC  FF2.7
0AC6C:  BSF    1B.7
0AC6E:  BCF    FF2.7
0AC70:  CALL   0E46
0AC74:  BTFSC  1B.7
0AC76:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0AC78:  MOVLW  01
0AC7A:  MOVWF  1E
0AC7C:  MOVLW  A7
0AC7E:  MOVWF  1D
0AC80:  MOVLW  62
0AC82:  MOVWF  FF6
0AC84:  MOVLW  1B
0AC86:  MOVWF  FF7
0AC88:  MOVLW  00
0AC8A:  MOVWF  FF8
0AC8C:  MOVLW  05
0AC8E:  MOVLB  8
0AC90:  MOVWF  xEB
0AC92:  MOVLB  0
0AC94:  RCALL  AACC
0AC96:  MOVLW  10
0AC98:  MOVWF  FE9
0AC9A:  MOVFF  26,8F7
0AC9E:  MOVFF  25,8F6
0ACA2:  RCALL  AAFE
0ACA4:  MOVLW  6A
0ACA6:  MOVWF  FF6
0ACA8:  MOVLW  1B
0ACAA:  MOVWF  FF7
0ACAC:  MOVLW  00
0ACAE:  MOVWF  FF8
0ACB0:  MOVLW  20
0ACB2:  MOVLB  8
0ACB4:  MOVWF  xEB
0ACB6:  MOVLB  0
0ACB8:  RCALL  AACC
....................          record_event(); 
0ACBA:  CALL   84DA
....................          break; 
0ACBE:  BRA    ADE8
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0ACC0:  MOVLW  8C
0ACC2:  MOVWF  FF6
0ACC4:  MOVLW  1B
0ACC6:  MOVWF  FF7
0ACC8:  MOVLW  00
0ACCA:  MOVWF  FF8
0ACCC:  CLRF   1B
0ACCE:  BTFSC  FF2.7
0ACD0:  BSF    1B.7
0ACD2:  BCF    FF2.7
0ACD4:  CALL   0E46
0ACD8:  BTFSC  1B.7
0ACDA:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0ACDC:  MOVLW  01
0ACDE:  MOVWF  1E
0ACE0:  MOVLW  A7
0ACE2:  MOVWF  1D
0ACE4:  MOVLW  94
0ACE6:  MOVWF  FF6
0ACE8:  MOVLW  1B
0ACEA:  MOVWF  FF7
0ACEC:  MOVLW  00
0ACEE:  MOVWF  FF8
0ACF0:  CALL   50BE
....................          record_event(); 
0ACF4:  CALL   84DA
....................          break; 
0ACF8:  BRA    ADE8
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0ACFA:  MOVLW  B8
0ACFC:  MOVWF  FF6
0ACFE:  MOVLW  1B
0AD00:  MOVWF  FF7
0AD02:  MOVLW  00
0AD04:  MOVWF  FF8
0AD06:  CLRF   1B
0AD08:  BTFSC  FF2.7
0AD0A:  BSF    1B.7
0AD0C:  BCF    FF2.7
0AD0E:  CALL   0E46
0AD12:  BTFSC  1B.7
0AD14:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AD16:  MOVLW  01
0AD18:  MOVWF  1E
0AD1A:  MOVLW  A7
0AD1C:  MOVWF  1D
0AD1E:  MOVLW  C0
0AD20:  MOVWF  FF6
0AD22:  MOVLW  1B
0AD24:  MOVWF  FF7
0AD26:  MOVLW  00
0AD28:  MOVWF  FF8
0AD2A:  CALL   50BE
....................          record_event(); 
0AD2E:  CALL   84DA
....................          recovery(); 
0AD32:  RCALL  AA58
....................          break; 
0AD34:  BRA    ADE8
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AD36:  MOVLW  DC
0AD38:  MOVWF  FF6
0AD3A:  MOVLW  1B
0AD3C:  MOVWF  FF7
0AD3E:  MOVLW  00
0AD40:  MOVWF  FF8
0AD42:  CLRF   1B
0AD44:  BTFSC  FF2.7
0AD46:  BSF    1B.7
0AD48:  BCF    FF2.7
0AD4A:  CALL   0E46
0AD4E:  BTFSC  1B.7
0AD50:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AD52:  MOVLW  01
0AD54:  MOVWF  1E
0AD56:  MOVLW  A7
0AD58:  MOVWF  1D
0AD5A:  MOVLW  E4
0AD5C:  MOVWF  FF6
0AD5E:  MOVLW  1B
0AD60:  MOVWF  FF7
0AD62:  MOVLW  00
0AD64:  MOVWF  FF8
0AD66:  CALL   50BE
....................          record_event(); 
0AD6A:  CALL   84DA
....................          output_bit(RTC_CS, ENABLE); 
0AD6E:  BCF    F91.0
....................          spi_write(0x89); 
0AD70:  MOVF   FC9,W
0AD72:  MOVLW  89
0AD74:  MOVWF  FC9
0AD76:  RRCF   FC7,W
0AD78:  BNC   AD76
....................          spi_write(0b11111111); 
0AD7A:  MOVF   FC9,W
0AD7C:  SETF   FC9
0AD7E:  RRCF   FC7,W
0AD80:  BNC   AD7E
....................          spi_read(0x00); 
0AD82:  MOVF   FC9,W
0AD84:  CLRF   FC9
0AD86:  RRCF   FC7,W
0AD88:  BNC   AD86
....................          output_bit(RTC_CS, DISABLE); 
0AD8A:  BSF    F91.0
....................          recovery(); 
0AD8C:  RCALL  AA58
....................          break; 
0AD8E:  BRA    ADE8
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0AD90:  MOVLW  06
0AD92:  MOVWF  FF6
0AD94:  MOVLW  1C
0AD96:  MOVWF  FF7
0AD98:  MOVLW  00
0AD9A:  MOVWF  FF8
0AD9C:  CLRF   1B
0AD9E:  BTFSC  FF2.7
0ADA0:  BSF    1B.7
0ADA2:  BCF    FF2.7
0ADA4:  CALL   0E46
0ADA8:  BTFSC  1B.7
0ADAA:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ADAC:  MOVLW  01
0ADAE:  MOVWF  1E
0ADB0:  MOVLW  A7
0ADB2:  MOVWF  1D
0ADB4:  MOVLW  0E
0ADB6:  MOVWF  FF6
0ADB8:  MOVLW  1C
0ADBA:  MOVWF  FF7
0ADBC:  MOVLW  00
0ADBE:  MOVWF  FF8
0ADC0:  CALL   50BE
....................          record_event(); 
0ADC4:  CALL   84DA
....................          output_bit(RTC_CS, ENABLE); 
0ADC8:  BCF    F91.0
....................          spi_write(0x89); 
0ADCA:  MOVF   FC9,W
0ADCC:  MOVLW  89
0ADCE:  MOVWF  FC9
0ADD0:  RRCF   FC7,W
0ADD2:  BNC   ADD0
....................          spi_write(0b11111111); 
0ADD4:  MOVF   FC9,W
0ADD6:  SETF   FC9
0ADD8:  RRCF   FC7,W
0ADDA:  BNC   ADD8
....................          spi_read(0x00); 
0ADDC:  MOVF   FC9,W
0ADDE:  CLRF   FC9
0ADE0:  RRCF   FC7,W
0ADE2:  BNC   ADE0
....................          output_bit(RTC_CS, DISABLE); 
0ADE4:  BSF    F91.0
....................          recovery(); 
0ADE6:  RCALL  AA58
....................          break; 
....................       }         
....................    } 
0ADE8:  GOTO   1B856 (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02AB8:  MOVLW  1E
02ABA:  MOVLB  8
02ABC:  MOVWF  x97
02ABE:  MOVLB  0
02AC0:  RCALL  29CA
02AC2:  MOVFF  02,30
02AC6:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02ACA:  MOVLW  1C
02ACC:  MOVLB  8
02ACE:  MOVWF  x97
02AD0:  MOVLB  0
02AD2:  RCALL  29CA
02AD4:  MOVFF  02,20
02AD8:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02ADC:  MOVLW  16
02ADE:  MOVLB  8
02AE0:  MOVWF  x97
02AE2:  MOVLB  0
02AE4:  RCALL  29CA
02AE6:  MOVFF  02,22
02AEA:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02AEE:  MOVLW  14
02AF0:  MOVLB  8
02AF2:  MOVWF  x97
02AF4:  MOVLB  0
02AF6:  RCALL  29CA
02AF8:  MOVFF  02,24
02AFC:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02B00:  MOVLB  8
02B02:  CLRF   x97
02B04:  MOVLB  0
02B06:  RCALL  29CA
02B08:  MOVFF  02,26
02B0C:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02B10:  MOVLW  18
02B12:  MOVLB  8
02B14:  MOVWF  x97
02B16:  MOVLB  0
02B18:  RCALL  29CA
02B1A:  MOVFF  02,28
02B1E:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02B22:  MOVLW  02
02B24:  MOVLB  8
02B26:  MOVWF  xB7
02B28:  MOVLB  0
02B2A:  RCALL  2A24
02B2C:  CLRF   32
02B2E:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02B32:  MOVLW  28
02B34:  MOVLB  8
02B36:  MOVWF  xB7
02B38:  MOVLB  0
02B3A:  RCALL  2A24
02B3C:  CLRF   34
02B3E:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02B42:  MOVLW  12
02B44:  MOVLB  8
02B46:  MOVWF  x97
02B48:  MOVLB  0
02B4A:  RCALL  29CA
02B4C:  MOVFF  02,36
02B50:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02B54:  MOVLW  3A
02B56:  MOVLB  8
02B58:  MOVWF  x97
02B5A:  MOVLB  0
02B5C:  RCALL  29CA
02B5E:  MOVFF  02,38
02B62:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02B66:  MOVLW  3C
02B68:  MOVLB  8
02B6A:  MOVWF  x97
02B6C:  MOVLB  0
02B6E:  RCALL  29CA
02B70:  MOVFF  02,3E
02B74:  MOVFF  01,3D
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02B78:  MOVLW  3E
02B7A:  MOVLB  8
02B7C:  MOVWF  x97
02B7E:  MOVLB  0
02B80:  RCALL  29CA
02B82:  MOVFF  02,40
02B86:  MOVFF  01,3F
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02B8A:  MOVLW  40
02B8C:  MOVLB  8
02B8E:  MOVWF  x97
02B90:  MOVLB  0
02B92:  RCALL  29CA
02B94:  MOVFF  02,42
02B98:  MOVFF  01,41
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02B9C:  MOVLW  42
02B9E:  MOVLB  8
02BA0:  MOVWF  x97
02BA2:  MOVLB  0
02BA4:  RCALL  29CA
02BA6:  MOVFF  02,44
02BAA:  MOVFF  01,43
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02BAE:  MOVLW  04
02BB0:  MOVLB  8
02BB2:  MOVWF  xB7
02BB4:  MOVLB  0
02BB6:  RCALL  2A24
02BB8:  MOVFF  01,72D
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02BBC:  MOVLB  8
02BBE:  CLRF   x86
02BC0:  MOVLW  44
02BC2:  MOVWF  x85
02BC4:  MOVLB  0
02BC6:  RCALL  2A4A
02BC8:  MOVFF  03,3F8
02BCC:  MOVFF  02,3F7
02BD0:  MOVFF  01,3F6
02BD4:  MOVFF  00,3F5
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02BD8:  MOVLB  8
02BDA:  CLRF   x86
02BDC:  MOVLW  48
02BDE:  MOVWF  x85
02BE0:  MOVLB  0
02BE2:  RCALL  2A4A
02BE4:  MOVFF  03,3FC
02BE8:  MOVFF  02,3FB
02BEC:  MOVFF  01,3FA
02BF0:  MOVFF  00,3F9
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02BF4:  MOVLB  8
02BF6:  CLRF   x86
02BF8:  MOVLW  4C
02BFA:  MOVWF  x85
02BFC:  MOVLB  0
02BFE:  RCALL  2A4A
02C00:  MOVFF  03,400
02C04:  MOVFF  02,3FF
02C08:  MOVFF  01,3FE
02C0C:  MOVFF  00,3FD
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02C10:  MOVLB  8
02C12:  CLRF   x86
02C14:  MOVLW  52
02C16:  MOVWF  x85
02C18:  MOVLB  0
02C1A:  RCALL  2A4A
02C1C:  MOVFF  03,404
02C20:  MOVFF  02,403
02C24:  MOVFF  01,402
02C28:  MOVFF  00,401
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02C2C:  MOVLB  8
02C2E:  CLRF   x86
02C30:  MOVLW  56
02C32:  MOVWF  x85
02C34:  MOVLB  0
02C36:  RCALL  2A4A
02C38:  MOVFF  03,408
02C3C:  MOVFF  02,407
02C40:  MOVFF  01,406
02C44:  MOVFF  00,405
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02C48:  MOVLB  8
02C4A:  CLRF   x86
02C4C:  MOVLW  5A
02C4E:  MOVWF  x85
02C50:  MOVLB  0
02C52:  RCALL  2A4A
02C54:  MOVFF  03,40C
02C58:  MOVFF  02,40B
02C5C:  MOVFF  01,40A
02C60:  MOVFF  00,409
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02C64:  MOVLB  8
02C66:  CLRF   x86
02C68:  MOVLW  5E
02C6A:  MOVWF  x85
02C6C:  MOVLB  0
02C6E:  RCALL  2A4A
02C70:  MOVFF  03,410
02C74:  MOVFF  02,40F
02C78:  MOVFF  01,40E
02C7C:  MOVFF  00,40D
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02C80:  MOVLB  8
02C82:  CLRF   x86
02C84:  MOVLW  62
02C86:  MOVWF  x85
02C88:  MOVLB  0
02C8A:  RCALL  2A4A
02C8C:  MOVFF  03,414
02C90:  MOVFF  02,413
02C94:  MOVFF  01,412
02C98:  MOVFF  00,411
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02C9C:  MOVLW  20
02C9E:  MOVLB  8
02CA0:  MOVWF  x97
02CA2:  MOVLB  0
02CA4:  RCALL  29CA
02CA6:  MOVFF  02,2A
02CAA:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02CAE:  MOVLW  22
02CB0:  MOVLB  8
02CB2:  MOVWF  x97
02CB4:  MOVLB  0
02CB6:  RCALL  29CA
02CB8:  MOVFF  02,2C
02CBC:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02CC0:  MOVLW  24
02CC2:  MOVLB  8
02CC4:  MOVWF  x97
02CC6:  MOVLB  0
02CC8:  RCALL  29CA
02CCA:  MOVFF  02,2E
02CCE:  MOVFF  01,2D
02CD2:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DEAC:  MOVLW  1C
0DEAE:  MOVLB  8
0DEB0:  MOVWF  xEE
0DEB2:  CLRF   xF0
0DEB4:  CLRF   xEF
0DEB6:  MOVLB  0
0DEB8:  CALL   4FD4
....................    write16(ADDR_SAMPLE,0); 
0DEBC:  MOVLW  16
0DEBE:  MOVLB  8
0DEC0:  MOVWF  xEE
0DEC2:  CLRF   xF0
0DEC4:  CLRF   xEF
0DEC6:  MOVLB  0
0DEC8:  CALL   4FD4
....................    write16(ADDR_INTERVAL,60); 
0DECC:  MOVLW  14
0DECE:  MOVLB  8
0DED0:  MOVWF  xEE
0DED2:  CLRF   xF0
0DED4:  MOVLW  3C
0DED6:  MOVWF  xEF
0DED8:  MOVLB  0
0DEDA:  CALL   4FD4
....................    write16(ADDR_SERIALNO,9999); 
0DEDE:  MOVLB  8
0DEE0:  CLRF   xEE
0DEE2:  MOVLW  27
0DEE4:  MOVWF  xF0
0DEE6:  MOVLW  0F
0DEE8:  MOVWF  xEF
0DEEA:  MOVLB  0
0DEEC:  CALL   4FD4
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DEF0:  MOVLW  18
0DEF2:  MOVLB  8
0DEF4:  MOVWF  xEE
0DEF6:  MOVLW  0D
0DEF8:  MOVWF  xF0
0DEFA:  MOVLW  20
0DEFC:  MOVWF  xEF
0DEFE:  MOVLB  0
0DF00:  CALL   4FD4
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DF04:  MOVLW  02
0DF06:  MOVLB  8
0DF08:  MOVWF  x89
0DF0A:  MOVLW  01
0DF0C:  MOVWF  x8A
0DF0E:  MOVLB  0
0DF10:  CALL   3412
....................    write16(ADDR_MACRO_STEP, 0); 
0DF14:  MOVLW  3A
0DF16:  MOVLB  8
0DF18:  MOVWF  xEE
0DF1A:  CLRF   xF0
0DF1C:  CLRF   xEF
0DF1E:  MOVLB  0
0DF20:  CALL   4FD4
....................    write16(ADDR_COM_ERR,3); 
0DF24:  MOVLW  3C
0DF26:  MOVLB  8
0DF28:  MOVWF  xEE
0DF2A:  CLRF   xF0
0DF2C:  MOVLW  03
0DF2E:  MOVWF  xEF
0DF30:  MOVLB  0
0DF32:  CALL   4FD4
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DF36:  MOVLW  04
0DF38:  MOVLB  8
0DF3A:  MOVWF  x89
0DF3C:  MOVLW  0A
0DF3E:  MOVWF  x8A
0DF40:  MOVLB  0
0DF42:  CALL   3412
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DF46:  MOVLB  8
0DF48:  CLRF   x86
0DF4A:  MOVLW  44
0DF4C:  MOVWF  x85
0DF4E:  CLRF   x8A
0DF50:  CLRF   x89
0DF52:  CLRF   x88
0DF54:  MOVLW  7F
0DF56:  MOVWF  x87
0DF58:  MOVLB  0
0DF5A:  CALL   CD4C
....................    write_float(ADDR_CAL_C1,0); 
0DF5E:  MOVLB  8
0DF60:  CLRF   x86
0DF62:  MOVLW  48
0DF64:  MOVWF  x85
0DF66:  CLRF   x8A
0DF68:  CLRF   x89
0DF6A:  CLRF   x88
0DF6C:  CLRF   x87
0DF6E:  MOVLB  0
0DF70:  CALL   CD4C
....................    write_float(ADDR_CAL_M2,1); 
0DF74:  MOVLB  8
0DF76:  CLRF   x86
0DF78:  MOVLW  4C
0DF7A:  MOVWF  x85
0DF7C:  CLRF   x8A
0DF7E:  CLRF   x89
0DF80:  CLRF   x88
0DF82:  MOVLW  7F
0DF84:  MOVWF  x87
0DF86:  MOVLB  0
0DF88:  CALL   CD4C
....................    write_float(ADDR_CAL_C2,0); 
0DF8C:  MOVLB  8
0DF8E:  CLRF   x86
0DF90:  MOVLW  52
0DF92:  MOVWF  x85
0DF94:  CLRF   x8A
0DF96:  CLRF   x89
0DF98:  CLRF   x88
0DF9A:  CLRF   x87
0DF9C:  MOVLB  0
0DF9E:  CALL   CD4C
....................    write_float(ADDR_CAL_M3,1); 
0DFA2:  MOVLB  8
0DFA4:  CLRF   x86
0DFA6:  MOVLW  56
0DFA8:  MOVWF  x85
0DFAA:  CLRF   x8A
0DFAC:  CLRF   x89
0DFAE:  CLRF   x88
0DFB0:  MOVLW  7F
0DFB2:  MOVWF  x87
0DFB4:  MOVLB  0
0DFB6:  CALL   CD4C
....................    write_float(ADDR_CAL_C3,0); 
0DFBA:  MOVLB  8
0DFBC:  CLRF   x86
0DFBE:  MOVLW  5A
0DFC0:  MOVWF  x85
0DFC2:  CLRF   x8A
0DFC4:  CLRF   x89
0DFC6:  CLRF   x88
0DFC8:  CLRF   x87
0DFCA:  MOVLB  0
0DFCC:  CALL   CD4C
....................    write_float(ADDR_CAL_M4,1); 
0DFD0:  MOVLB  8
0DFD2:  CLRF   x86
0DFD4:  MOVLW  5E
0DFD6:  MOVWF  x85
0DFD8:  CLRF   x8A
0DFDA:  CLRF   x89
0DFDC:  CLRF   x88
0DFDE:  MOVLW  7F
0DFE0:  MOVWF  x87
0DFE2:  MOVLB  0
0DFE4:  CALL   CD4C
....................    write_float(ADDR_CAL_C4,0);  
0DFE8:  MOVLB  8
0DFEA:  CLRF   x86
0DFEC:  MOVLW  62
0DFEE:  MOVWF  x85
0DFF0:  CLRF   x8A
0DFF2:  CLRF   x89
0DFF4:  CLRF   x88
0DFF6:  CLRF   x87
0DFF8:  MOVLB  0
0DFFA:  CALL   CD4C
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0DFFE:  MOVLW  40
0E000:  MOVLB  8
0E002:  MOVWF  xEE
0E004:  MOVLW  4E
0E006:  MOVWF  xF0
0E008:  MOVLW  20
0E00A:  MOVWF  xEF
0E00C:  MOVLB  0
0E00E:  CALL   4FD4
....................    write16(ADDR_D2_TEMP,20000); 
0E012:  MOVLW  42
0E014:  MOVLB  8
0E016:  MOVWF  xEE
0E018:  MOVLW  4E
0E01A:  MOVWF  xF0
0E01C:  MOVLW  20
0E01E:  MOVWF  xEF
0E020:  MOVLB  0
0E022:  CALL   4FD4
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0E026:  MOVLW  20
0E028:  MOVLB  8
0E02A:  MOVWF  xEE
0E02C:  CLRF   xF0
0E02E:  CLRF   xEF
0E030:  MOVLB  0
0E032:  CALL   4FD4
....................    write16(ADDR_VOLUME,22500);  
0E036:  MOVLW  22
0E038:  MOVLB  8
0E03A:  MOVWF  xEE
0E03C:  MOVLW  57
0E03E:  MOVWF  xF0
0E040:  MOVLW  E4
0E042:  MOVWF  xEF
0E044:  MOVLB  0
0E046:  CALL   4FD4
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0E04A:  MOVF   2F,W
0E04C:  SUBLW  02
0E04E:  BNZ   E054
0E050:  MOVF   30,F
0E052:  BZ    E068
0E054:  MOVLW  24
0E056:  MOVLB  8
0E058:  MOVWF  xEE
0E05A:  CLRF   xF0
0E05C:  MOVLW  02
0E05E:  MOVWF  xEF
0E060:  MOVLB  0
0E062:  CALL   4FD4
0E066:  BRA    E07A
....................    else write16(ADDR_PORT,1); 
0E068:  MOVLW  24
0E06A:  MOVLB  8
0E06C:  MOVWF  xEE
0E06E:  CLRF   xF0
0E070:  MOVLW  01
0E072:  MOVWF  xEF
0E074:  MOVLB  0
0E076:  CALL   4FD4
....................     
....................    write16(ADDR_DET_TYPE,1); 
0E07A:  MOVLW  26
0E07C:  MOVLB  8
0E07E:  MOVWF  xEE
0E080:  CLRF   xF0
0E082:  MOVLW  01
0E084:  MOVWF  xEF
0E086:  MOVLB  0
0E088:  CALL   4FD4
....................     
....................    init_nv_vars(); 
0E08C:  CALL   2AB8
0E090:  GOTO   E0AA (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
127FC:  MOVLW  02
127FE:  MOVWF  FEA
12800:  MOVLW  47
12802:  MOVWF  FE9
12804:  CLRF   00
12806:  CLRF   02
12808:  MOVLW  51
1280A:  MOVWF  01
1280C:  CALL   3526
12810:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F91C:  MOVLW  03
0F91E:  MOVWF  FEA
0F920:  MOVLW  25
0F922:  MOVWF  FE9
0F924:  CLRF   00
0F926:  CLRF   02
0F928:  MOVLW  14
0F92A:  MOVWF  01
0F92C:  CALL   3526
0F930:  GOTO   F950 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
13332:  MOVLB  8
13334:  CLRF   xD4
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
13336:  CLRF   FEA
13338:  MOVLW  52
1333A:  MOVWF  FE9
1333C:  CLRF   00
1333E:  CLRF   02
13340:  MOVLW  14
13342:  MOVWF  01
13344:  MOVLB  0
13346:  CALL   3526
....................  
....................    for(n=0; n<20; n++) { 
1334A:  MOVLB  8
1334C:  CLRF   xD5
1334E:  MOVF   xD5,W
13350:  SUBLW  13
13352:  BNC   13398
....................         c = data_buffer[string_pos];  
13354:  CLRF   03
13356:  MOVLB  2
13358:  MOVF   x98,W
1335A:  ADDLW  67
1335C:  MOVWF  FE9
1335E:  MOVLW  00
13360:  ADDWFC 03,W
13362:  MOVWF  FEA
13364:  MOVFF  FEF,8D4
....................         ++string_pos; 
13368:  INCF   x98,F
....................         if (c == '\0') return(1); // found end 
1336A:  MOVLB  8
1336C:  MOVF   xD4,F
1336E:  BNZ   13376
13370:  MOVLW  01
13372:  MOVWF  01
13374:  BRA    1339C
....................         if (c == ',')  return(0); // found seperator  
13376:  MOVF   xD4,W
13378:  SUBLW  2C
1337A:  BNZ   13382
1337C:  MOVLW  00
1337E:  MOVWF  01
13380:  BRA    1339C
....................         sub_string[n] = c; 
13382:  CLRF   03
13384:  MOVF   xD5,W
13386:  ADDLW  52
13388:  MOVWF  FE9
1338A:  MOVLW  00
1338C:  ADDWFC 03,W
1338E:  MOVWF  FEA
13390:  MOVFF  8D4,FEF
13394:  INCF   xD5,F
13396:  BRA    1334E
....................    } 
....................     
....................    return(2); // failed = bad string 
13398:  MOVLW  02
1339A:  MOVWF  01
1339C:  MOVLB  0
1339E:  GOTO   136C8 (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
135DC:  MOVLW  32
135DE:  MOVWF  FF6
135E0:  MOVLW  1C
135E2:  MOVWF  FF7
135E4:  MOVLW  00
135E6:  MOVWF  FF8
135E8:  MOVLW  03
135EA:  MOVWF  FEA
135EC:  MOVLW  3D
135EE:  MOVWF  FE9
135F0:  CALL   FE62
135F4:  MOVF   01,W
135F6:  BZ    1360A
135F8:  XORLW  01
135FA:  BZ    1362A
135FC:  XORLW  03
135FE:  BZ    1364A
13600:  XORLW  01
13602:  BZ    1366A
13604:  XORLW  07
13606:  BZ    1368A
13608:  BRA    136A8
....................       case "NO3" : NO3_array[read_i] = result; 
1360A:  BCF    FD8.0
1360C:  MOVLB  3
1360E:  RLCF   x4A,W
13610:  CLRF   03
13612:  ADDLW  4B
13614:  MOVWF  FE9
13616:  MOVLW  03
13618:  ADDWFC 03,W
1361A:  MOVWF  FEA
1361C:  MOVFF  8D5,FEC
13620:  MOVF   FED,F
13622:  MOVFF  8D4,FEF
....................          break; 
13626:  MOVLB  0
13628:  BRA    136A8
....................       case "NO2" : NO2_array[read_i] = result; 
1362A:  BCF    FD8.0
1362C:  MOVLB  3
1362E:  RLCF   x4A,W
13630:  CLRF   03
13632:  ADDLW  5D
13634:  MOVWF  FE9
13636:  MOVLW  03
13638:  ADDWFC 03,W
1363A:  MOVWF  FEA
1363C:  MOVFF  8D5,FEC
13640:  MOVF   FED,F
13642:  MOVFF  8D4,FEF
....................          break;    
13646:  MOVLB  0
13648:  BRA    136A8
....................       case "PO4" : PO4_array[read_i] = result; 
1364A:  BCF    FD8.0
1364C:  MOVLB  3
1364E:  RLCF   x4A,W
13650:  CLRF   03
13652:  ADDLW  6F
13654:  MOVWF  FE9
13656:  MOVLW  03
13658:  ADDWFC 03,W
1365A:  MOVWF  FEA
1365C:  MOVFF  8D5,FEC
13660:  MOVF   FED,F
13662:  MOVFF  8D4,FEF
....................          break; 
13666:  MOVLB  0
13668:  BRA    136A8
....................       case "NH4" : NH4_array[read_i] = result; 
1366A:  BCF    FD8.0
1366C:  MOVLB  3
1366E:  RLCF   x4A,W
13670:  CLRF   03
13672:  ADDLW  81
13674:  MOVWF  FE9
13676:  MOVLW  03
13678:  ADDWFC 03,W
1367A:  MOVWF  FEA
1367C:  MOVFF  8D5,FEC
13680:  MOVF   FED,F
13682:  MOVFF  8D4,FEF
....................          break; 
13686:  MOVLB  0
13688:  BRA    136A8
....................       case "SiO" : SiO_array[read_i] = result; 
1368A:  BCF    FD8.0
1368C:  MOVLB  3
1368E:  RLCF   x4A,W
13690:  CLRF   03
13692:  ADDLW  93
13694:  MOVWF  FE9
13696:  MOVLW  03
13698:  ADDWFC 03,W
1369A:  MOVWF  FEA
1369C:  MOVFF  8D5,FEC
136A0:  MOVF   FED,F
136A2:  MOVFF  8D4,FEF
....................          break; 
136A6:  MOVLB  0
....................    } 
136A8:  GOTO   13720 (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
136AC:  MOVLB  8
136AE:  CLRF   xCF
136B0:  CLRF   xCE
136B2:  CLRF   xD1
136B4:  CLRF   xD0
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
136B6:  MOVLB  2
136B8:  CLRF   x98
....................     
....................    for (n=0; n<11; ++n){ 
136BA:  MOVLB  8
136BC:  CLRF   xD2
136BE:  MOVF   xD2,W
136C0:  SUBLW  0A
136C2:  BNC   13714
....................       parsed = parse_string(); 
136C4:  MOVLB  0
136C6:  BRA    13332
136C8:  MOVFF  01,8D3
....................       if (parsed == 2) return(0); 
136CC:  MOVLB  8
136CE:  MOVF   xD3,W
136D0:  SUBLW  02
136D2:  BNZ   136DC
136D4:  MOVLW  00
136D6:  MOVWF  01
136D8:  MOVWF  02
136DA:  BRA    1372A
....................       if (n==8) result = atol(sub_string); 
136DC:  MOVF   xD2,W
136DE:  SUBLW  08
136E0:  BNZ   136F6
136E2:  CLRF   xD5
136E4:  MOVLW  52
136E6:  MOVWF  xD4
136E8:  MOVLB  0
136EA:  RCALL  133F8
136EC:  MOVFF  02,8CF
136F0:  MOVFF  01,8CE
136F4:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
136F6:  MOVF   xD2,W
136F8:  SUBLW  0A
136FA:  BNZ   13710
136FC:  CLRF   xD5
136FE:  MOVLW  52
13700:  MOVWF  xD4
13702:  MOVLB  0
13704:  RCALL  133F8
13706:  MOVFF  02,8D1
1370A:  MOVFF  01,8D0
1370E:  MOVLB  8
13710:  INCF   xD2,F
13712:  BRA    136BE
....................    } 
....................    load_parsed_data(result); 
13714:  MOVFF  8CF,8D5
13718:  MOVFF  8CE,8D4
1371C:  MOVLB  0
1371E:  BRA    135DC
....................    return (temp); 
13720:  MOVLB  8
13722:  MOVFF  8D0,01
13726:  MOVFF  8D1,02
1372A:  MOVLB  0
1372C:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D528:  CLRF   FEA
0D52A:  MOVLW  67
0D52C:  MOVWF  FE9
0D52E:  CLRF   00
0D530:  CLRF   02
0D532:  MOVLW  A0
0D534:  MOVWF  01
0D536:  CALL   3526
0D53A:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F934:  MOVLW  03
0F936:  MOVWF  FEA
0F938:  MOVLW  3D
0F93A:  MOVWF  FE9
0F93C:  MOVLW  00
0F93E:  CALL   02E4
0F942:  TBLRD*-
0F944:  TBLRD*+
0F946:  MOVF   FF5,W
0F948:  MOVWF  FEE
0F94A:  IORLW  00
0F94C:  BNZ   F944
....................  
....................    clear_flag_str(); 
0F94E:  BRA    F91C
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F950:  MOVLW  08
0F952:  MOVWF  1E
0F954:  MOVLW  ED
0F956:  MOVWF  1D
0F958:  MOVLW  10
0F95A:  MOVWF  FE9
0F95C:  MOVFF  324,8F7
0F960:  MOVFF  323,8F6
0F964:  CALL   AAFE
....................  
....................    if (macro_flag < 100) { 
0F968:  MOVLB  3
0F96A:  MOVF   x24,F
0F96C:  BNZ   F986
0F96E:  MOVF   x23,W
0F970:  SUBLW  63
0F972:  BNC   F986
....................       temp_str[3] = '\0'; 
0F974:  MOVLB  8
0F976:  CLRF   xF0
....................       temp_str[2] = temp_str[1]; 
0F978:  MOVFF  8EE,8EF
....................       temp_str[1] = temp_str[0]; 
0F97C:  MOVFF  8ED,8EE
....................       temp_str[0] = '0'; 
0F980:  MOVLW  30
0F982:  MOVWF  xED
0F984:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F986:  MOVLB  8
0F988:  MOVF   xED,W
0F98A:  XORLW  30
0F98C:  MOVLB  0
0F98E:  BZ    F9B2
0F990:  XORLW  01
0F992:  BZ    F9D8
0F994:  XORLW  03
0F996:  BZ    F9FE
0F998:  XORLW  01
0F99A:  BZ    FA24
0F99C:  XORLW  07
0F99E:  BZ    FA4A
0F9A0:  XORLW  01
0F9A2:  BZ    FA70
0F9A4:  XORLW  03
0F9A6:  BTFSC  FD8.2
0F9A8:  BRA    FA96
0F9AA:  XORLW  01
0F9AC:  BTFSC  FD8.2
0F9AE:  BRA    FABC
0F9B0:  BRA    FAE4
....................       case '0' : strcopy(chem,"NO3"); 
0F9B2:  MOVLW  03
0F9B4:  MOVWF  FEA
0F9B6:  MOVLW  3D
0F9B8:  MOVWF  FE9
0F9BA:  MOVLW  00
0F9BC:  CALL   02FC
0F9C0:  TBLRD*-
0F9C2:  TBLRD*+
0F9C4:  MOVF   FF5,W
0F9C6:  MOVWF  FEE
0F9C8:  IORLW  00
0F9CA:  BNZ   F9C2
....................                  wave_l=543; 
0F9CC:  MOVLW  02
0F9CE:  MOVLB  8
0F9D0:  MOVWF  xEC
0F9D2:  MOVLW  1F
0F9D4:  MOVWF  xEB
....................          break; 
0F9D6:  BRA    FB08
....................       case '1' : strcopy(chem,"PO4"); 
0F9D8:  MOVLW  03
0F9DA:  MOVWF  FEA
0F9DC:  MOVLW  3D
0F9DE:  MOVWF  FE9
0F9E0:  MOVLW  00
0F9E2:  CALL   0314
0F9E6:  TBLRD*-
0F9E8:  TBLRD*+
0F9EA:  MOVF   FF5,W
0F9EC:  MOVWF  FEE
0F9EE:  IORLW  00
0F9F0:  BNZ   F9E8
....................                  wave_l=880;       
0F9F2:  MOVLW  03
0F9F4:  MOVLB  8
0F9F6:  MOVWF  xEC
0F9F8:  MOVLW  70
0F9FA:  MOVWF  xEB
....................          break; 
0F9FC:  BRA    FB08
....................       case '2' : strcopy(chem,"NH4"); 
0F9FE:  MOVLW  03
0FA00:  MOVWF  FEA
0FA02:  MOVLW  3D
0FA04:  MOVWF  FE9
0FA06:  MOVLW  00
0FA08:  CALL   032C
0FA0C:  TBLRD*-
0FA0E:  TBLRD*+
0FA10:  MOVF   FF5,W
0FA12:  MOVWF  FEE
0FA14:  IORLW  00
0FA16:  BNZ   FA0E
....................                  wave_l=660;       
0FA18:  MOVLW  02
0FA1A:  MOVLB  8
0FA1C:  MOVWF  xEC
0FA1E:  MOVLW  94
0FA20:  MOVWF  xEB
....................          break; 
0FA22:  BRA    FB08
....................       case '3' : strcopy(chem,"SiO"); 
0FA24:  MOVLW  03
0FA26:  MOVWF  FEA
0FA28:  MOVLW  3D
0FA2A:  MOVWF  FE9
0FA2C:  MOVLW  00
0FA2E:  CALL   0344
0FA32:  TBLRD*-
0FA34:  TBLRD*+
0FA36:  MOVF   FF5,W
0FA38:  MOVWF  FEE
0FA3A:  IORLW  00
0FA3C:  BNZ   FA34
....................                  wave_l=810;       
0FA3E:  MOVLW  03
0FA40:  MOVLB  8
0FA42:  MOVWF  xEC
0FA44:  MOVLW  2A
0FA46:  MOVWF  xEB
....................          break; 
0FA48:  BRA    FB08
....................       case '4' : strcopy(chem,"Ure"); 
0FA4A:  MOVLW  03
0FA4C:  MOVWF  FEA
0FA4E:  MOVLW  3D
0FA50:  MOVWF  FE9
0FA52:  MOVLW  00
0FA54:  CALL   035C
0FA58:  TBLRD*-
0FA5A:  TBLRD*+
0FA5C:  MOVF   FF5,W
0FA5E:  MOVWF  FEE
0FA60:  IORLW  00
0FA62:  BNZ   FA5A
....................                  wave_l=525;       
0FA64:  MOVLW  02
0FA66:  MOVLB  8
0FA68:  MOVWF  xEC
0FA6A:  MOVLW  0D
0FA6C:  MOVWF  xEB
....................          break; 
0FA6E:  BRA    FB08
....................       case '5' : strcopy(chem,"NO2"); 
0FA70:  MOVLW  03
0FA72:  MOVWF  FEA
0FA74:  MOVLW  3D
0FA76:  MOVWF  FE9
0FA78:  MOVLW  00
0FA7A:  CALL   0374
0FA7E:  TBLRD*-
0FA80:  TBLRD*+
0FA82:  MOVF   FF5,W
0FA84:  MOVWF  FEE
0FA86:  IORLW  00
0FA88:  BNZ   FA80
....................                  wave_l=543;       
0FA8A:  MOVLW  02
0FA8C:  MOVLB  8
0FA8E:  MOVWF  xEC
0FA90:  MOVLW  1F
0FA92:  MOVWF  xEB
....................          break; 
0FA94:  BRA    FB08
....................       case '6' : strcopy(chem,"Fe_"); 
0FA96:  MOVLW  03
0FA98:  MOVWF  FEA
0FA9A:  MOVLW  3D
0FA9C:  MOVWF  FE9
0FA9E:  MOVLW  00
0FAA0:  CALL   038C
0FAA4:  TBLRD*-
0FAA6:  TBLRD*+
0FAA8:  MOVF   FF5,W
0FAAA:  MOVWF  FEE
0FAAC:  IORLW  00
0FAAE:  BNZ   FAA6
....................                  wave_l=543;       
0FAB0:  MOVLW  02
0FAB2:  MOVLB  8
0FAB4:  MOVWF  xEC
0FAB6:  MOVLW  1F
0FAB8:  MOVWF  xEB
....................          break; 
0FABA:  BRA    FB08
....................       case '7' : strcopy(chem,"Cl_"); 
0FABC:  MOVLW  03
0FABE:  MOVWF  FEA
0FAC0:  MOVLW  3D
0FAC2:  MOVWF  FE9
0FAC4:  MOVLW  00
0FAC6:  CALL   03A4
0FACA:  TBLRD*-
0FACC:  TBLRD*+
0FACE:  MOVF   FF5,W
0FAD0:  MOVWF  FEE
0FAD2:  IORLW  00
0FAD4:  BNZ   FACC
....................                  wave_l=560;       
0FAD6:  MOVLW  02
0FAD8:  MOVLB  8
0FADA:  MOVWF  xEC
0FADC:  MOVLW  30
0FADE:  MOVWF  xEB
....................          break; 
0FAE0:  BRA    FB08
0FAE2:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0FAE4:  MOVLW  03
0FAE6:  MOVWF  FEA
0FAE8:  MOVLW  3D
0FAEA:  MOVWF  FE9
0FAEC:  MOVLW  00
0FAEE:  CALL   02E4
0FAF2:  TBLRD*-
0FAF4:  TBLRD*+
0FAF6:  MOVF   FF5,W
0FAF8:  MOVWF  FEE
0FAFA:  IORLW  00
0FAFC:  BNZ   FAF4
....................                  wave_l=999;       
0FAFE:  MOVLW  03
0FB00:  MOVLB  8
0FB02:  MOVWF  xEC
0FB04:  MOVLW  E7
0FB06:  MOVWF  xEB
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0FB08:  MOVF   xEE,W
0FB0A:  XORLW  31
0FB0C:  MOVLB  0
0FB0E:  BZ    FB2E
0FB10:  XORLW  03
0FB12:  BZ    FB4A
0FB14:  XORLW  01
0FB16:  BZ    FB66
0FB18:  XORLW  07
0FB1A:  BZ    FB82
0FB1C:  XORLW  01
0FB1E:  BZ    FB9E
0FB20:  XORLW  03
0FB22:  BZ    FBBA
0FB24:  XORLW  01
0FB26:  BZ    FBD6
0FB28:  XORLW  0F
0FB2A:  BZ    FBF2
0FB2C:  BRA    FC0E
....................       case '1' : strcopy(anal,"Smp"); 
0FB2E:  MOVLW  03
0FB30:  MOVWF  FEA
0FB32:  MOVLW  42
0FB34:  MOVWF  FE9
0FB36:  MOVLW  00
0FB38:  CALL   03BC
0FB3C:  TBLRD*-
0FB3E:  TBLRD*+
0FB40:  MOVF   FF5,W
0FB42:  MOVWF  FEE
0FB44:  IORLW  00
0FB46:  BNZ   FB3E
....................          break; 
0FB48:  BRA    FC28
....................       case '2' : strcopy(anal,"Std"); 
0FB4A:  MOVLW  03
0FB4C:  MOVWF  FEA
0FB4E:  MOVLW  42
0FB50:  MOVWF  FE9
0FB52:  MOVLW  00
0FB54:  CALL   03D4
0FB58:  TBLRD*-
0FB5A:  TBLRD*+
0FB5C:  MOVF   FF5,W
0FB5E:  MOVWF  FEE
0FB60:  IORLW  00
0FB62:  BNZ   FB5A
....................          break; 
0FB64:  BRA    FC28
....................       case '3' : strcopy(anal,"Cmb"); 
0FB66:  MOVLW  03
0FB68:  MOVWF  FEA
0FB6A:  MOVLW  42
0FB6C:  MOVWF  FE9
0FB6E:  MOVLW  00
0FB70:  CALL   03EC
0FB74:  TBLRD*-
0FB76:  TBLRD*+
0FB78:  MOVF   FF5,W
0FB7A:  MOVWF  FEE
0FB7C:  IORLW  00
0FB7E:  BNZ   FB76
....................          break; 
0FB80:  BRA    FC28
....................       case '4' : strcopy(anal,"Tst"); 
0FB82:  MOVLW  03
0FB84:  MOVWF  FEA
0FB86:  MOVLW  42
0FB88:  MOVWF  FE9
0FB8A:  MOVLW  00
0FB8C:  CALL   0404
0FB90:  TBLRD*-
0FB92:  TBLRD*+
0FB94:  MOVF   FF5,W
0FB96:  MOVWF  FEE
0FB98:  IORLW  00
0FB9A:  BNZ   FB92
....................          break; 
0FB9C:  BRA    FC28
....................       case '5' : strcopy(anal,"Rbl"); 
0FB9E:  MOVLW  03
0FBA0:  MOVWF  FEA
0FBA2:  MOVLW  42
0FBA4:  MOVWF  FE9
0FBA6:  MOVLW  00
0FBA8:  CALL   041C
0FBAC:  TBLRD*-
0FBAE:  TBLRD*+
0FBB0:  MOVF   FF5,W
0FBB2:  MOVWF  FEE
0FBB4:  IORLW  00
0FBB6:  BNZ   FBAE
....................          break; 
0FBB8:  BRA    FC28
....................       case '6' : strcopy(anal,"Cal"); 
0FBBA:  MOVLW  03
0FBBC:  MOVWF  FEA
0FBBE:  MOVLW  42
0FBC0:  MOVWF  FE9
0FBC2:  MOVLW  00
0FBC4:  CALL   0434
0FBC8:  TBLRD*-
0FBCA:  TBLRD*+
0FBCC:  MOVF   FF5,W
0FBCE:  MOVWF  FEE
0FBD0:  IORLW  00
0FBD2:  BNZ   FBCA
....................          break; 
0FBD4:  BRA    FC28
....................       case '7' : strcopy(anal,"Fls"); 
0FBD6:  MOVLW  03
0FBD8:  MOVWF  FEA
0FBDA:  MOVLW  42
0FBDC:  MOVWF  FE9
0FBDE:  MOVLW  00
0FBE0:  CALL   044C
0FBE4:  TBLRD*-
0FBE6:  TBLRD*+
0FBE8:  MOVF   FF5,W
0FBEA:  MOVWF  FEE
0FBEC:  IORLW  00
0FBEE:  BNZ   FBE6
....................          break; 
0FBF0:  BRA    FC28
....................       case '8' : strcopy(anal,"Utl"); 
0FBF2:  MOVLW  03
0FBF4:  MOVWF  FEA
0FBF6:  MOVLW  42
0FBF8:  MOVWF  FE9
0FBFA:  MOVLW  00
0FBFC:  CALL   0464
0FC00:  TBLRD*-
0FC02:  TBLRD*+
0FC04:  MOVF   FF5,W
0FC06:  MOVWF  FEE
0FC08:  IORLW  00
0FC0A:  BNZ   FC02
....................          break;     
0FC0C:  BRA    FC28
....................       default  : strcopy(anal,"XXX"); 
0FC0E:  MOVLW  03
0FC10:  MOVWF  FEA
0FC12:  MOVLW  42
0FC14:  MOVWF  FE9
0FC16:  MOVLW  00
0FC18:  CALL   02E4
0FC1C:  TBLRD*-
0FC1E:  TBLRD*+
0FC20:  MOVF   FF5,W
0FC22:  MOVWF  FEE
0FC24:  IORLW  00
0FC26:  BNZ   FC1E
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0FC28:  MOVLB  8
0FC2A:  MOVF   xEF,W
0FC2C:  XORLW  31
0FC2E:  MOVLB  0
0FC30:  BZ    FC5A
0FC32:  XORLW  03
0FC34:  BZ    FC7A
0FC36:  XORLW  01
0FC38:  BZ    FC9C
0FC3A:  XORLW  07
0FC3C:  BZ    FCBE
0FC3E:  XORLW  01
0FC40:  BZ    FCE0
0FC42:  XORLW  03
0FC44:  BZ    FD02
0FC46:  XORLW  01
0FC48:  BTFSC  FD8.2
0FC4A:  BRA    FD24
0FC4C:  XORLW  0F
0FC4E:  BTFSC  FD8.2
0FC50:  BRA    FD46
0FC52:  XORLW  01
0FC54:  BTFSC  FD8.2
0FC56:  BRA    FD68
0FC58:  BRA    FD8C
....................       case '1' : strcopy(read_t,"I0s"); 
0FC5A:  MOVLW  03
0FC5C:  MOVWF  FEA
0FC5E:  MOVLW  46
0FC60:  MOVWF  FE9
0FC62:  MOVLW  00
0FC64:  CALL   047C
0FC68:  TBLRD*-
0FC6A:  TBLRD*+
0FC6C:  MOVF   FF5,W
0FC6E:  MOVWF  FEE
0FC70:  IORLW  00
0FC72:  BNZ   FC6A
....................                  read_i = 0; 
0FC74:  MOVLB  3
0FC76:  CLRF   x4A
....................          break; 
0FC78:  BRA    FDAA
....................       case '2' : strcopy(read_t,"I1s"); 
0FC7A:  MOVLW  03
0FC7C:  MOVWF  FEA
0FC7E:  MOVLW  46
0FC80:  MOVWF  FE9
0FC82:  MOVLW  00
0FC84:  CALL   0494
0FC88:  TBLRD*-
0FC8A:  TBLRD*+
0FC8C:  MOVF   FF5,W
0FC8E:  MOVWF  FEE
0FC90:  IORLW  00
0FC92:  BNZ   FC8A
....................                  read_i = 1;       
0FC94:  MOVLW  01
0FC96:  MOVLB  3
0FC98:  MOVWF  x4A
....................          break; 
0FC9A:  BRA    FDAA
....................       case '3' : strcopy(read_t,"I0t"); 
0FC9C:  MOVLW  03
0FC9E:  MOVWF  FEA
0FCA0:  MOVLW  46
0FCA2:  MOVWF  FE9
0FCA4:  MOVLW  00
0FCA6:  CALL   04AC
0FCAA:  TBLRD*-
0FCAC:  TBLRD*+
0FCAE:  MOVF   FF5,W
0FCB0:  MOVWF  FEE
0FCB2:  IORLW  00
0FCB4:  BNZ   FCAC
....................                  read_i = 2;       
0FCB6:  MOVLW  02
0FCB8:  MOVLB  3
0FCBA:  MOVWF  x4A
....................          break; 
0FCBC:  BRA    FDAA
....................       case '4' : strcopy(read_t,"I1t"); 
0FCBE:  MOVLW  03
0FCC0:  MOVWF  FEA
0FCC2:  MOVLW  46
0FCC4:  MOVWF  FE9
0FCC6:  MOVLW  00
0FCC8:  CALL   04C4
0FCCC:  TBLRD*-
0FCCE:  TBLRD*+
0FCD0:  MOVF   FF5,W
0FCD2:  MOVWF  FEE
0FCD4:  IORLW  00
0FCD6:  BNZ   FCCE
....................                  read_i = 3;       
0FCD8:  MOVLW  03
0FCDA:  MOVLB  3
0FCDC:  MOVWF  x4A
....................          break; 
0FCDE:  BRA    FDAA
....................       case '5' : strcopy(read_t,"I0r"); 
0FCE0:  MOVLW  03
0FCE2:  MOVWF  FEA
0FCE4:  MOVLW  46
0FCE6:  MOVWF  FE9
0FCE8:  MOVLW  00
0FCEA:  CALL   04DC
0FCEE:  TBLRD*-
0FCF0:  TBLRD*+
0FCF2:  MOVF   FF5,W
0FCF4:  MOVWF  FEE
0FCF6:  IORLW  00
0FCF8:  BNZ   FCF0
....................                  read_i = 4;       
0FCFA:  MOVLW  04
0FCFC:  MOVLB  3
0FCFE:  MOVWF  x4A
....................          break; 
0FD00:  BRA    FDAA
....................       case '6' : strcopy(read_t,"I1r"); 
0FD02:  MOVLW  03
0FD04:  MOVWF  FEA
0FD06:  MOVLW  46
0FD08:  MOVWF  FE9
0FD0A:  MOVLW  00
0FD0C:  CALL   04F4
0FD10:  TBLRD*-
0FD12:  TBLRD*+
0FD14:  MOVF   FF5,W
0FD16:  MOVWF  FEE
0FD18:  IORLW  00
0FD1A:  BNZ   FD12
....................                  read_i = 5;       
0FD1C:  MOVLW  05
0FD1E:  MOVLB  3
0FD20:  MOVWF  x4A
....................          break; 
0FD22:  BRA    FDAA
....................       case '7' : strcopy(read_t,"I0u"); 
0FD24:  MOVLW  03
0FD26:  MOVWF  FEA
0FD28:  MOVLW  46
0FD2A:  MOVWF  FE9
0FD2C:  MOVLW  00
0FD2E:  CALL   050C
0FD32:  TBLRD*-
0FD34:  TBLRD*+
0FD36:  MOVF   FF5,W
0FD38:  MOVWF  FEE
0FD3A:  IORLW  00
0FD3C:  BNZ   FD34
....................                  read_i = 6;       
0FD3E:  MOVLW  06
0FD40:  MOVLB  3
0FD42:  MOVWF  x4A
....................          break; 
0FD44:  BRA    FDAA
....................       case '8' : strcopy(read_t,"I1u"); 
0FD46:  MOVLW  03
0FD48:  MOVWF  FEA
0FD4A:  MOVLW  46
0FD4C:  MOVWF  FE9
0FD4E:  MOVLW  00
0FD50:  CALL   0524
0FD54:  TBLRD*-
0FD56:  TBLRD*+
0FD58:  MOVF   FF5,W
0FD5A:  MOVWF  FEE
0FD5C:  IORLW  00
0FD5E:  BNZ   FD56
....................                  read_i = 7;       
0FD60:  MOVLW  07
0FD62:  MOVLB  3
0FD64:  MOVWF  x4A
....................          break; 
0FD66:  BRA    FDAA
....................       case '9' : strcopy(read_t,"Chk"); 
0FD68:  MOVLW  03
0FD6A:  MOVWF  FEA
0FD6C:  MOVLW  46
0FD6E:  MOVWF  FE9
0FD70:  MOVLW  00
0FD72:  CALL   053C
0FD76:  TBLRD*-
0FD78:  TBLRD*+
0FD7A:  MOVF   FF5,W
0FD7C:  MOVWF  FEE
0FD7E:  IORLW  00
0FD80:  BNZ   FD78
....................                  read_i = 8;       
0FD82:  MOVLW  08
0FD84:  MOVLB  3
0FD86:  MOVWF  x4A
....................          break;        
0FD88:  BRA    FDAA
0FD8A:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FD8C:  MOVLW  03
0FD8E:  MOVWF  FEA
0FD90:  MOVLW  46
0FD92:  MOVWF  FE9
0FD94:  MOVLW  00
0FD96:  CALL   0554
0FD9A:  TBLRD*-
0FD9C:  TBLRD*+
0FD9E:  MOVF   FF5,W
0FDA0:  MOVWF  FEE
0FDA2:  IORLW  00
0FDA4:  BNZ   FD9C
....................                  read_i = 0;       
0FDA6:  MOVLB  3
0FDA8:  CLRF   x4A
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FDAA:  MOVLW  03
0FDAC:  MOVLB  8
0FDAE:  MOVWF  xF9
0FDB0:  MOVLW  25
0FDB2:  MOVWF  xF8
0FDB4:  MOVLW  03
0FDB6:  MOVWF  xFB
0FDB8:  MOVLW  3D
0FDBA:  MOVWF  xFA
0FDBC:  MOVLB  0
0FDBE:  CALL   54DE
....................    strcat(flag_str, (char *)","); 
0FDC2:  MOVLW  2C
0FDC4:  MOVLB  8
0FDC6:  MOVWF  xF4
0FDC8:  CLRF   xF5
0FDCA:  MOVLW  03
0FDCC:  MOVWF  xF9
0FDCE:  MOVLW  25
0FDD0:  MOVWF  xF8
0FDD2:  MOVLW  08
0FDD4:  MOVWF  xFB
0FDD6:  MOVLW  F4
0FDD8:  MOVWF  xFA
0FDDA:  MOVLB  0
0FDDC:  CALL   54DE
....................    strcat(flag_str, anal); 
0FDE0:  MOVLW  03
0FDE2:  MOVLB  8
0FDE4:  MOVWF  xF9
0FDE6:  MOVLW  25
0FDE8:  MOVWF  xF8
0FDEA:  MOVLW  03
0FDEC:  MOVWF  xFB
0FDEE:  MOVLW  42
0FDF0:  MOVWF  xFA
0FDF2:  MOVLB  0
0FDF4:  CALL   54DE
....................    strcat(flag_str, (char *)","); 
0FDF8:  MOVLW  2C
0FDFA:  MOVLB  8
0FDFC:  MOVWF  xF4
0FDFE:  CLRF   xF5
0FE00:  MOVLW  03
0FE02:  MOVWF  xF9
0FE04:  MOVLW  25
0FE06:  MOVWF  xF8
0FE08:  MOVLW  08
0FE0A:  MOVWF  xFB
0FE0C:  MOVLW  F4
0FE0E:  MOVWF  xFA
0FE10:  MOVLB  0
0FE12:  CALL   54DE
....................    strcat(flag_str, read_t);   
0FE16:  MOVLW  03
0FE18:  MOVLB  8
0FE1A:  MOVWF  xF9
0FE1C:  MOVLW  25
0FE1E:  MOVWF  xF8
0FE20:  MOVLW  03
0FE22:  MOVWF  xFB
0FE24:  MOVLW  46
0FE26:  MOVWF  xFA
0FE28:  MOVLB  0
0FE2A:  CALL   54DE
....................     
....................    return wave_l; 
0FE2E:  MOVLB  8
0FE30:  MOVFF  8EB,01
0FE34:  MOVFF  8EC,02
0FE38:  MOVLB  0
0FE3A:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F402:  MOVF   47,W
0F404:  SUBLW  4B
0F406:  BTFSC  FD8.2
0F408:  MOVFF  48,2D6
....................    if (cmd=='L') detector_li = arg; 
0F40C:  MOVF   47,W
0F40E:  SUBLW  4C
0F410:  BNZ   F41A
0F412:  MOVFF  49,2D8
0F416:  MOVFF  48,2D7
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F41A:  MOVF   1F,W
0F41C:  SUBLW  04
0F41E:  BNZ   F4E8
0F420:  MOVF   20,F
0F422:  BNZ   F4E8
0F424:  MOVLW  48
0F426:  MOVWF  FF6
0F428:  MOVLW  1C
0F42A:  MOVWF  FF7
0F42C:  MOVLW  00
0F42E:  MOVWF  FF8
0F430:  CLRF   1B
0F432:  BTFSC  FF2.7
0F434:  BSF    1B.7
0F436:  BCF    FF2.7
0F438:  MOVLW  06
0F43A:  MOVLB  A
0F43C:  MOVWF  x40
0F43E:  MOVLB  0
0F440:  CALL   101C
0F444:  BTFSC  1B.7
0F446:  BSF    FF2.7
0F448:  CLRF   1B
0F44A:  BTFSC  FF2.7
0F44C:  BSF    1B.7
0F44E:  BCF    FF2.7
0F450:  MOVFF  2D5,A40
0F454:  MOVLW  1B
0F456:  MOVLB  A
0F458:  MOVWF  x41
0F45A:  MOVLB  0
0F45C:  CALL   0F9E
0F460:  BTFSC  1B.7
0F462:  BSF    FF2.7
0F464:  MOVLW  5D
0F466:  BTFSS  F9E.4
0F468:  BRA    F466
0F46A:  MOVWF  FAD
0F46C:  MOVLW  5B
0F46E:  BTFSS  F9E.4
0F470:  BRA    F46E
0F472:  MOVWF  FAD
0F474:  MOVF   47,W
0F476:  BTFSS  F9E.4
0F478:  BRA    F476
0F47A:  MOVWF  FAD
0F47C:  MOVLW  54
0F47E:  MOVWF  FF6
0F480:  MOVLW  1C
0F482:  MOVWF  FF7
0F484:  MOVLW  00
0F486:  MOVWF  FF8
0F488:  CLRF   1B
0F48A:  BTFSC  FF2.7
0F48C:  BSF    1B.7
0F48E:  BCF    FF2.7
0F490:  MOVLW  05
0F492:  MOVLB  A
0F494:  MOVWF  x40
0F496:  MOVLB  0
0F498:  CALL   101C
0F49C:  BTFSC  1B.7
0F49E:  BSF    FF2.7
0F4A0:  MOVLW  41
0F4A2:  MOVWF  FE9
0F4A4:  CLRF   1B
0F4A6:  BTFSC  FF2.7
0F4A8:  BSF    1B.7
0F4AA:  BCF    FF2.7
0F4AC:  MOVFF  4B,A43
0F4B0:  MOVFF  4A,A42
0F4B4:  MOVFF  49,A41
0F4B8:  MOVFF  48,A40
0F4BC:  CALL   10E2
0F4C0:  BTFSC  1B.7
0F4C2:  BSF    FF2.7
0F4C4:  MOVLW  5C
0F4C6:  MOVWF  FF6
0F4C8:  MOVLW  1C
0F4CA:  MOVWF  FF7
0F4CC:  MOVLW  00
0F4CE:  MOVWF  FF8
0F4D0:  CLRF   1B
0F4D2:  BTFSC  FF2.7
0F4D4:  BSF    1B.7
0F4D6:  BCF    FF2.7
0F4D8:  MOVLW  03
0F4DA:  MOVLB  A
0F4DC:  MOVWF  x40
0F4DE:  MOVLB  0
0F4E0:  CALL   101C
0F4E4:  BTFSC  1B.7
0F4E6:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F4E8:  CALL   DA78
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F4EC:  MOVLW  2F
0F4EE:  BTFSS  FA4.4
0F4F0:  BRA    F4EE
0F4F2:  MOVLB  F
0F4F4:  MOVWF  x1C
0F4F6:  MOVFF  2D5,8F3
0F4FA:  MOVLW  1B
0F4FC:  MOVLB  8
0F4FE:  MOVWF  xF4
0F500:  MOVLB  0
0F502:  CALL   DAC0
0F506:  MOVF   47,W
0F508:  BTFSS  FA4.4
0F50A:  BRA    F508
0F50C:  MOVLB  F
0F50E:  MOVWF  x1C
0F510:  MOVLW  41
0F512:  MOVWF  FE9
0F514:  MOVFF  4B,8F6
0F518:  MOVFF  4A,8F5
0F51C:  MOVFF  49,8F4
0F520:  MOVFF  48,8F3
0F524:  MOVLB  0
0F526:  BRA    F322
0F528:  MOVLW  0D
0F52A:  BTFSS  FA4.4
0F52C:  BRA    F52A
0F52E:  MOVLB  F
0F530:  MOVWF  x1C
0F532:  MOVLW  0A
0F534:  BTFSS  FA4.4
0F536:  BRA    F534
0F538:  MOVWF  x1C
....................    multidrop_off(); 
0F53A:  MOVLB  0
0F53C:  CALL   DB64
0F540:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12E52:  MOVLB  8
12E54:  CLRF   xEC
12E56:  BCF    xED.0
12E58:  CLRF   xEE
12E5A:  CLRF   xF2
12E5C:  CLRF   xF1
12E5E:  CLRF   xF0
12E60:  CLRF   xEF
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12E62:  MOVLW  02
12E64:  MOVWF  FEA
12E66:  MOVLW  47
12E68:  MOVWF  FE9
12E6A:  CLRF   00
12E6C:  CLRF   02
12E6E:  MOVLW  51
12E70:  MOVWF  01
12E72:  MOVLB  0
12E74:  CALL   3526
....................  
....................    det_cmd(); 
12E78:  CALL   F402
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12E7C:  CALL   5554
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12E80:  MOVLB  8
12E82:  MOVF   xEE,W
12E84:  SUBLW  02
12E86:  BZ    12F1A
12E88:  MOVF   xEE,W
12E8A:  SUBLW  03
12E8C:  BZ    12F1A
12E8E:  MOVF   xEC,W
12E90:  SUBLW  50
12E92:  BNC   12F1A
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12E94:  BTFSS  FA4.5
12E96:  BRA    12ECE
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12E98:  MOVLB  0
12E9A:  RCALL  12E38
12E9C:  MOVFF  01,8EB
....................  
....................          if(startCharacterRcvd) 
12EA0:  MOVLB  8
12EA2:  BTFSS  xED.0
12EA4:  BRA    12EC6
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12EA6:  MOVF   xEC,W
12EA8:  INCF   xEC,F
12EAA:  CLRF   03
12EAC:  ADDLW  47
12EAE:  MOVWF  FE9
12EB0:  MOVLW  02
12EB2:  ADDWFC 03,W
12EB4:  MOVWF  FEA
12EB6:  MOVFF  8EB,FEF
....................             if (CARRIAGE_RET == c) 
12EBA:  MOVF   xEB,W
12EBC:  SUBLW  0D
12EBE:  BNZ   12EC4
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12EC0:  MOVLW  02
12EC2:  MOVWF  xEE
....................             } 
....................          } 
12EC4:  BRA    12ECE
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12EC6:  MOVF   xEB,W
12EC8:  SUBLW  40
12ECA:  BNZ   12ECE
....................             { 
....................                startCharacterRcvd = TRUE; 
12ECC:  BSF    xED.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12ECE:  MOVLW  35
12ED0:  MOVWF  00
12ED2:  DECFSZ 00,F
12ED4:  BRA    12ED2
....................       if (tenMicroSecDelayCounter++ > 500000) 
12ED6:  MOVFF  8F2,8F6
12EDA:  MOVFF  8F1,8F5
12EDE:  MOVFF  8F0,8F4
12EE2:  MOVFF  8EF,8F3
12EE6:  MOVLW  01
12EE8:  ADDWF  xEF,F
12EEA:  BTFSC  FD8.0
12EEC:  INCF   xF0,F
12EEE:  BTFSC  FD8.2
12EF0:  INCF   xF1,F
12EF2:  BTFSC  FD8.2
12EF4:  INCF   xF2,F
12EF6:  MOVF   xF6,F
12EF8:  BNZ   12F14
12EFA:  MOVF   xF5,W
12EFC:  SUBLW  06
12EFE:  BC    12F18
12F00:  XORLW  FF
12F02:  BNZ   12F14
12F04:  MOVF   xF4,W
12F06:  SUBLW  A0
12F08:  BC    12F18
12F0A:  XORLW  FF
12F0C:  BNZ   12F14
12F0E:  MOVF   xF3,W
12F10:  SUBLW  20
12F12:  BC    12F18
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12F14:  MOVLW  03
12F16:  MOVWF  xEE
....................       } 
12F18:  BRA    12E82
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12F1A:  MOVF   xEC,W
12F1C:  SUBLW  50
12F1E:  BC    12F30
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12F20:  MOVF   xEE,W
12F22:  SUBLW  03
12F24:  BZ    12F30
12F26:  MOVF   xEE,W
12F28:  SUBLW  02
12F2A:  BZ    12F30
....................       { 
....................          rcvDataType = SOME_DATA; 
12F2C:  MOVLW  01
12F2E:  MOVWF  xEE
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12F30:  MOVLB  0
12F32:  CALL   5574
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12F36:  MOVLB  8
12F38:  MOVFF  8EE,01
12F3C:  MOVLB  0
12F3E:  GOTO   130B6 (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
10000:  MOVF   1F,F
10002:  BTFSS  FD8.2
10004:  GOTO   1002E
10008:  MOVF   20,F
1000A:  BTFSS  FD8.2
1000C:  GOTO   1002E
10010:  MOVLB  8
10012:  DECFSZ xEC,W
10014:  BRA    10018
10016:  BRA    1001E
10018:  MOVLB  0
1001A:  GOTO   1002E
1001E:  CLRF   FEA
10020:  MOVLW  67
10022:  MOVWF  FE9
10024:  MOVLB  0
10026:  CALL   7996
1002A:  GOTO   1004A
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
1002E:  MOVF   20,F
10030:  BTFSS  FD8.2
10032:  GOTO   10040
10036:  MOVF   1F,W
10038:  SUBLW  03
1003A:  BTFSC  FD8.0
1003C:  GOTO   1004A
10040:  CLRF   FEA
10042:  MOVLW  67
10044:  MOVWF  FE9
10046:  CALL   7996
....................  
....................    if (store==TRUE && sd_status==0) { 
1004A:  MOVLB  8
1004C:  DECFSZ xEB,W
1004E:  GOTO   100B2
10052:  MOVLB  2
10054:  MOVF   xDC,F
10056:  BTFSC  FD8.2
10058:  BRA    10060
1005A:  MOVLB  8
1005C:  GOTO   100B2
....................        
....................       buffer_select = 0; 
10060:  MOVLB  0
10062:  CLRF   x66
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
10064:  MOVLB  8
10066:  CLRF   xED
10068:  MOVLB  0
1006A:  CALL   5586
....................          append_data(file_ptr_raw_all); 
1006E:  MOVLW  02
10070:  MOVLB  8
10072:  MOVWF  xEE
10074:  MOVLW  DD
10076:  MOVWF  xED
10078:  MOVLB  0
1007A:  CALL   82F8
....................       heartbeat(TRUE); 
1007E:  MOVLW  01
10080:  MOVLB  8
10082:  MOVWF  xED
10084:  MOVLB  0
10086:  CALL   5586
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
1008A:  MOVLB  8
1008C:  CLRF   xED
1008E:  MOVLB  0
10090:  CALL   5586
....................          append_data(file_ptr_raw_new); 
10094:  MOVLW  02
10096:  MOVLB  8
10098:  MOVWF  xEE
1009A:  MOVLW  EB
1009C:  MOVWF  xED
1009E:  MOVLB  0
100A0:  CALL   82F8
....................       heartbeat(TRUE); 
100A4:  MOVLW  01
100A6:  MOVLB  8
100A8:  MOVWF  xED
100AA:  MOVLB  0
100AC:  CALL   5586
100B0:  MOVLB  8
....................    } 
100B2:  MOVLB  0
100B4:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12F4E:  CLRF   xE5
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12F42:  MOVLW  0D
12F44:  MOVLB  8
12F46:  MOVWF  xCE
12F48:  MOVLW  0A
12F4A:  MOVWF  xCF
12F4C:  CLRF   xD0
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12F50:  MOVLB  0
12F52:  RCALL  127FC
....................    clear_data_buffer(); 
12F54:  CALL   D528
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12F58:  MOVLW  08
12F5A:  MOVWF  FEA
12F5C:  MOVLW  D1
12F5E:  MOVWF  FE9
12F60:  CLRF   00
12F62:  CLRF   02
12F64:  MOVLW  14
12F66:  MOVWF  01
12F68:  CALL   3526
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12F6C:  MOVLW  01
12F6E:  MOVWF  FEA
12F70:  MOVLW  A7
12F72:  MOVWF  FE9
12F74:  CLRF   00
12F76:  CLRF   02
12F78:  MOVLW  A0
12F7A:  MOVWF  01
12F7C:  CALL   3526
....................  
....................    time_stamp(); 
12F80:  CALL   541A
....................    strcpy(data_buffer, time_stmp_str); 
12F84:  CLRF   FEA
12F86:  MOVLW  67
12F88:  MOVWF  FE9
12F8A:  MOVLW  02
12F8C:  MOVWF  FE2
12F8E:  MOVLW  99
12F90:  MOVWF  FE1
12F92:  MOVF   FE7,F
12F94:  MOVFF  FE6,FEE
12F98:  BNZ   12F92
....................    strcat(data_buffer, (char *)","); 
12F9A:  MOVLW  2C
12F9C:  MOVLB  8
12F9E:  MOVWF  xE9
12FA0:  CLRF   xEA
12FA2:  CLRF   xF9
12FA4:  MOVLW  67
12FA6:  MOVWF  xF8
12FA8:  MOVLW  08
12FAA:  MOVWF  xFB
12FAC:  MOVLW  E9
12FAE:  MOVWF  xFA
12FB0:  MOVLB  0
12FB2:  CALL   54DE
....................  
....................    flag_mod=fmod(macro_flag,10); 
12FB6:  MOVFF  324,918
12FBA:  MOVFF  323,917
12FBE:  CALL   C8F6
12FC2:  MOVFF  03,8EE
12FC6:  MOVFF  02,8ED
12FCA:  MOVFF  01,8EC
12FCE:  MOVFF  00,8EB
12FD2:  MOVFF  03,8F2
12FD6:  MOVFF  02,8F1
12FDA:  MOVFF  01,8F0
12FDE:  MOVFF  00,8EF
12FE2:  MOVLB  8
12FE4:  CLRF   xF6
12FE6:  CLRF   xF5
12FE8:  MOVLW  20
12FEA:  MOVWF  xF4
12FEC:  MOVLW  82
12FEE:  MOVWF  xF3
12FF0:  MOVLB  0
12FF2:  BRA    12BF8
12FF4:  MOVFF  03,916
12FF8:  MOVFF  02,915
12FFC:  MOVFF  01,914
13000:  MOVFF  00,913
13004:  RCALL  12812
13006:  MOVFF  01,8E8
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
1300A:  MOVLB  8
1300C:  DECFSZ xE8,W
1300E:  BRA    13012
13010:  BRA    13018
13012:  MOVF   xE8,W
13014:  SUBLW  03
13016:  BNZ   13036
....................    { 
....................       clear_proc_time_stmp_str(); 
13018:  MOVLB  0
1301A:  BRA    12D60
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
1301C:  MOVLW  02
1301E:  MOVWF  FEA
13020:  MOVLW  B7
13022:  MOVWF  FE9
13024:  MOVLW  02
13026:  MOVWF  FE2
13028:  MOVLW  99
1302A:  MOVWF  FE1
1302C:  MOVF   FE7,F
1302E:  MOVFF  FE6,FEE
13032:  BNZ   1302C
13034:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
13036:  MOVLB  0
13038:  CALL   F934
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
1303C:  MOVLB  8
1303E:  CLRF   xEC
13040:  MOVLW  67
13042:  MOVWF  xEB
13044:  MOVLB  0
13046:  RCALL  12D78
13048:  MOVFF  02,03
1304C:  MOVF   01,W
1304E:  XORLW  FF
13050:  ADDLW  A1
13052:  MOVLB  8
13054:  MOVWF  xEB
13056:  MOVLW  00
13058:  SUBFWB 02,W
1305A:  MOVWF  xEC
1305C:  MOVLW  01
1305E:  SUBWF  xEB,F
13060:  MOVLW  00
13062:  SUBWFB xEC,F
13064:  CLRF   xEE
13066:  MOVLW  67
13068:  MOVWF  xED
1306A:  MOVLW  03
1306C:  MOVWF  xF0
1306E:  MOVLW  25
13070:  MOVWF  xEF
13072:  MOVFF  8EC,8F2
13076:  MOVFF  8EB,8F1
1307A:  MOVLB  0
1307C:  RCALL  12DB4
....................    strcat(data_buffer, (char *)","); 
1307E:  MOVLW  2C
13080:  MOVLB  8
13082:  MOVWF  xE9
13084:  CLRF   xEA
13086:  CLRF   xF9
13088:  MOVLW  67
1308A:  MOVWF  xF8
1308C:  MOVLW  08
1308E:  MOVWF  xFB
13090:  MOVLW  E9
13092:  MOVWF  xFA
13094:  MOVLB  0
13096:  CALL   54DE
....................     
....................    cmd = 'S'; 
1309A:  MOVLW  53
1309C:  MOVWF  47
....................    arg = 1; 
1309E:  CLRF   4B
130A0:  CLRF   4A
130A2:  CLRF   49
130A4:  MOVLW  01
130A6:  MOVWF  48
....................  
....................    for(i = 0; i < 6; i++) 
130A8:  MOVLB  8
130AA:  CLRF   xE6
130AC:  MOVF   xE6,W
130AE:  SUBLW  05
130B0:  BNC   130C8
....................    { 
....................       rcvdData = get_slave_data(); 
130B2:  MOVLB  0
130B4:  BRA    12E52
130B6:  MOVFF  01,8E5
....................       if (DATA_COMPLETE == rcvdData) 
130BA:  MOVLB  8
130BC:  MOVF   xE5,W
130BE:  SUBLW  02
130C0:  BNZ   130C4
....................       { 
....................          break; 
130C2:  BRA    130C8
....................       } 
130C4:  INCF   xE6,F
130C6:  BRA    130AC
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
130C8:  CLRF   xEC
130CA:  MOVLW  67
130CC:  MOVWF  xEB
130CE:  MOVLB  0
130D0:  RCALL  12D78
130D2:  MOVFF  02,03
130D6:  MOVF   01,W
130D8:  XORLW  FF
130DA:  ADDLW  A1
130DC:  MOVLB  8
130DE:  MOVWF  xEB
130E0:  MOVLW  00
130E2:  SUBFWB 02,W
130E4:  MOVWF  xEC
130E6:  MOVLW  01
130E8:  SUBWF  xEB,F
130EA:  MOVLW  00
130EC:  SUBWFB xEC,F
130EE:  CLRF   xEE
130F0:  MOVLW  67
130F2:  MOVWF  xED
130F4:  MOVLW  02
130F6:  MOVWF  xF0
130F8:  MOVLW  47
130FA:  MOVWF  xEF
130FC:  MOVFF  8EC,8F2
13100:  MOVFF  8EB,8F1
13104:  MOVLB  0
13106:  RCALL  12DB4
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
13108:  MOVLW  02
1310A:  MOVLB  8
1310C:  MOVWF  xEC
1310E:  MOVLW  47
13110:  MOVWF  xEB
13112:  MOVLB  0
13114:  RCALL  12D78
13116:  MOVFF  01,8E7
....................    if (rec_len > 0 && rec_len < 12) 
1311A:  MOVLB  8
1311C:  MOVF   xE7,F
1311E:  BZ    1312C
13120:  MOVF   xE7,W
13122:  SUBLW  0B
13124:  BNC   1312C
....................    { 
....................       rcvdData = SHORT_DATA; 
13126:  MOVLW  04
13128:  MOVWF  xE5
....................    } 
1312A:  BRA    13136
....................    else 
....................    { 
....................       if (rec_len > 30) 
1312C:  MOVF   xE7,W
1312E:  SUBLW  1E
13130:  BC    13136
....................       { 
....................          rcvdData = LONG_DATA; 
13132:  MOVLW  05
13134:  MOVWF  xE5
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
13136:  MOVLW  02
13138:  SUBWF  xE5,W
1313A:  ADDLW  FC
1313C:  BC    131A8
1313E:  ADDLW  04
13140:  MOVLB  0
13142:  GOTO   1330A
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
13146:  MOVLB  8
13148:  BRA    131A8
1314A:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
1314C:  MOVLW  08
1314E:  MOVWF  1E
13150:  MOVLW  D1
13152:  MOVWF  1D
13154:  MOVLW  60
13156:  MOVWF  FF6
13158:  MOVLW  1C
1315A:  MOVWF  FF7
1315C:  MOVLW  00
1315E:  MOVWF  FF8
13160:  CALL   50BE
....................          break; 
13164:  MOVLB  8
13166:  BRA    131A8
13168:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
1316A:  MOVLW  08
1316C:  MOVWF  1E
1316E:  MOVLW  D1
13170:  MOVWF  1D
13172:  MOVLW  6A
13174:  MOVWF  FF6
13176:  MOVLW  1C
13178:  MOVWF  FF7
1317A:  MOVLW  00
1317C:  MOVWF  FF8
1317E:  CALL   50BE
....................          break; 
13182:  MOVLB  8
13184:  BRA    131A8
13186:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
13188:  MOVLW  08
1318A:  MOVWF  1E
1318C:  MOVLW  D1
1318E:  MOVWF  1D
13190:  MOVLW  7A
13192:  MOVWF  FF6
13194:  MOVLW  1C
13196:  MOVWF  FF7
13198:  MOVLW  00
1319A:  MOVWF  FF8
1319C:  CALL   50BE
....................          break; 
131A0:  MOVLB  8
131A2:  BRA    131A8
131A4:  MOVLB  0
131A6:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
131A8:  CLRF   xEC
131AA:  MOVLW  67
131AC:  MOVWF  xEB
131AE:  MOVLB  0
131B0:  RCALL  12D78
131B2:  MOVFF  02,03
131B6:  MOVF   01,W
131B8:  XORLW  FF
131BA:  ADDLW  A1
131BC:  MOVLB  8
131BE:  MOVWF  xEB
131C0:  MOVLW  00
131C2:  SUBFWB 02,W
131C4:  MOVWF  xEC
131C6:  MOVLW  01
131C8:  SUBWF  xEB,F
131CA:  MOVLW  00
131CC:  SUBWFB xEC,F
131CE:  CLRF   xEE
131D0:  MOVLW  67
131D2:  MOVWF  xED
131D4:  MOVLW  08
131D6:  MOVWF  xF0
131D8:  MOVLW  D1
131DA:  MOVWF  xEF
131DC:  MOVFF  8EC,8F2
131E0:  MOVFF  8EB,8F1
131E4:  MOVLB  0
131E6:  RCALL  12DB4
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
131E8:  MOVLB  8
131EA:  CLRF   xEC
131EC:  MOVLW  67
131EE:  MOVWF  xEB
131F0:  MOVLB  0
131F2:  RCALL  12D78
131F4:  MOVFF  02,03
131F8:  MOVF   01,W
131FA:  XORLW  FF
131FC:  ADDLW  A1
131FE:  MOVLB  8
13200:  MOVWF  xEB
13202:  MOVLW  00
13204:  SUBFWB 02,W
13206:  MOVWF  xEC
13208:  MOVLW  01
1320A:  SUBWF  xEB,F
1320C:  MOVLW  00
1320E:  SUBWFB xEC,F
13210:  CLRF   xEE
13212:  MOVLW  67
13214:  MOVWF  xED
13216:  MOVLW  08
13218:  MOVWF  xF0
1321A:  MOVLW  CE
1321C:  MOVWF  xEF
1321E:  MOVFF  8EC,8F2
13222:  MOVFF  8EB,8F1
13226:  MOVLB  0
13228:  RCALL  12DB4
....................  
....................    if(DATA_COMPLETE != rcvdData) 
1322A:  MOVLB  8
1322C:  MOVF   xE5,W
1322E:  SUBLW  02
13230:  BZ    132EC
....................    {    //housekeeping 
....................       time_stamp(); 
13232:  MOVLB  0
13234:  CALL   541A
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
13238:  MOVLW  01
1323A:  MOVWF  1E
1323C:  MOVLW  A7
1323E:  MOVWF  1D
13240:  MOVLW  8A
13242:  MOVWF  FF6
13244:  MOVLW  1C
13246:  MOVWF  FF7
13248:  MOVLW  00
1324A:  MOVWF  FF8
1324C:  MOVLW  0A
1324E:  MOVLB  8
13250:  MOVWF  xEB
13252:  MOVLB  0
13254:  CALL   AACC
13258:  MOVFF  1E,FEA
1325C:  MOVFF  1D,FE9
13260:  CLRF   FEF
13262:  MOVLW  08
13264:  MOVWF  FEA
13266:  MOVLW  D1
13268:  MOVWF  FE9
1326A:  CALL   FE3C
1326E:  MOVLW  96
13270:  MOVWF  FF6
13272:  MOVLW  1C
13274:  MOVWF  FF7
13276:  MOVLW  00
13278:  MOVWF  FF8
1327A:  MOVLW  06
1327C:  MOVLB  8
1327E:  MOVWF  xEB
13280:  MOVLB  0
13282:  CALL   AACC
13286:  MOVFF  8E7,8ED
1328A:  MOVLW  1B
1328C:  MOVLB  8
1328E:  MOVWF  xEE
13290:  MOVLB  0
13292:  CALL   5280
13296:  MOVLW  5D
13298:  MOVLB  8
1329A:  MOVWF  xFF
1329C:  MOVLB  0
1329E:  CALL   509E
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
132A2:  MOVLW  01
132A4:  MOVLB  8
132A6:  MOVWF  xEC
132A8:  MOVLW  A7
132AA:  MOVWF  xEB
132AC:  MOVLB  0
132AE:  RCALL  12D78
132B0:  MOVFF  02,03
132B4:  MOVF   01,W
132B6:  XORLW  FF
132B8:  ADDLW  A1
132BA:  MOVLB  8
132BC:  MOVWF  xEB
132BE:  MOVLW  00
132C0:  SUBFWB 02,W
132C2:  MOVWF  xEC
132C4:  MOVLW  01
132C6:  SUBWF  xEB,F
132C8:  MOVLW  00
132CA:  SUBWFB xEC,F
132CC:  MOVLW  01
132CE:  MOVWF  xEE
132D0:  MOVLW  A7
132D2:  MOVWF  xED
132D4:  CLRF   xF0
132D6:  MOVLW  67
132D8:  MOVWF  xEF
132DA:  MOVFF  8EC,8F2
132DE:  MOVFF  8EB,8F1
132E2:  MOVLB  0
132E4:  RCALL  12DB4
....................       record_event(); 
132E6:  CALL   84DA
132EA:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
132EC:  MOVFF  8CC,8EB
132F0:  MOVFF  8CD,8EC
132F4:  MOVLB  0
132F6:  CALL   10000
....................  
....................    return (rcvdData); 
132FA:  CLRF   03
132FC:  MOVLB  8
132FE:  MOVFF  8E5,01
13302:  MOVFF  03,02
13306:  MOVLB  0
13308:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
1372E:  MOVLB  8
13730:  CLRF   xC4
13732:  MOVF   xC4,W
13734:  SUBLW  02
13736:  BTFSS  FD8.0
13738:  BRA    1384E
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
1373A:  MOVFF  8C2,8CC
1373E:  MOVFF  8C3,8CD
13742:  MOVLB  0
13744:  CALL   12F42
13748:  MOVFF  02,03
1374C:  MOVF   01,W
1374E:  SUBLW  02
13750:  BNZ   1375E
13752:  MOVF   03,F
13754:  BNZ   1375E
....................       { 
....................          break; 
13756:  MOVLB  8
13758:  BRA    1384E
....................       } 
1375A:  BRA    1384A
1375C:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
1375E:  MOVLW  01
13760:  MOVLB  8
13762:  ADDWF  xC4,W
13764:  MOVWF  xC5
13766:  MOVLW  A0
13768:  MOVWF  FF6
1376A:  MOVLW  1C
1376C:  MOVWF  FF7
1376E:  MOVLW  00
13770:  MOVWF  FF8
13772:  CLRF   1B
13774:  BTFSC  FF2.7
13776:  BSF    1B.7
13778:  BCF    FF2.7
1377A:  MOVLW  05
1377C:  MOVLB  A
1377E:  MOVWF  x40
13780:  MOVLB  0
13782:  CALL   101C
13786:  BTFSC  1B.7
13788:  BSF    FF2.7
1378A:  CLRF   1B
1378C:  BTFSC  FF2.7
1378E:  BSF    1B.7
13790:  BCF    FF2.7
13792:  MOVFF  8C5,A40
13796:  MOVLW  1B
13798:  MOVLB  A
1379A:  MOVWF  x41
1379C:  MOVLB  0
1379E:  CALL   0F9E
137A2:  BTFSC  1B.7
137A4:  BSF    FF2.7
137A6:  MOVLW  0D
137A8:  BTFSS  F9E.4
137AA:  BRA    137A8
137AC:  MOVWF  FAD
137AE:  MOVLW  0A
137B0:  BTFSS  F9E.4
137B2:  BRA    137B0
137B4:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
137B6:  BCF    F90.7
....................          delay_ms(1000); 
137B8:  MOVLW  04
137BA:  MOVLB  8
137BC:  MOVWF  xC5
137BE:  MOVLW  FA
137C0:  MOVLB  9
137C2:  MOVWF  xEC
137C4:  MOVLB  0
137C6:  CALL   2910
137CA:  MOVLB  8
137CC:  DECFSZ xC5,F
137CE:  BRA    137BE
....................          output_bit(VDET,ON); 
137D0:  BSF    F90.7
....................          delay_ms(1000); 
137D2:  MOVLW  04
137D4:  MOVWF  xC5
137D6:  MOVLW  FA
137D8:  MOVLB  9
137DA:  MOVWF  xEC
137DC:  MOVLB  0
137DE:  CALL   2910
137E2:  MOVLB  8
137E4:  DECFSZ xC5,F
137E6:  BRA    137D6
....................          if (LightTargetFlag==0) 
137E8:  MOVLB  2
137EA:  MOVF   xD9,F
137EC:  BNZ   13834
....................          { 
....................           cmd='K'; 
137EE:  MOVLW  4B
137F0:  MOVWF  47
....................           arg=detector_ch; 
137F2:  CLRF   4B
137F4:  CLRF   4A
137F6:  CLRF   49
137F8:  MOVFF  2D6,48
....................           det_cmd(); 
137FC:  MOVLB  0
137FE:  CALL   F402
....................           delay_ms(1000); 
13802:  MOVLW  04
13804:  MOVLB  8
13806:  MOVWF  xC5
13808:  MOVLW  FA
1380A:  MOVLB  9
1380C:  MOVWF  xEC
1380E:  MOVLB  0
13810:  CALL   2910
13814:  MOVLB  8
13816:  DECFSZ xC5,F
13818:  BRA    13808
....................           cmd='L'; 
1381A:  MOVLW  4C
1381C:  MOVWF  47
....................           arg=detector_li; 
1381E:  CLRF   4B
13820:  CLRF   4A
13822:  MOVFF  2D8,49
13826:  MOVFF  2D7,48
....................           det_cmd(); 
1382A:  MOVLB  0
1382C:  CALL   F402
....................          }  
13830:  BRA    13848
13832:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
13834:  MOVLW  6C
13836:  MOVWF  47
....................           arg=1; 
13838:  CLRF   4B
1383A:  CLRF   4A
1383C:  CLRF   49
1383E:  MOVLW  01
13840:  MOVWF  48
....................           det_cmd(); 
13842:  MOVLB  0
13844:  CALL   F402
13848:  MOVLB  8
....................          }  
....................       } 
1384A:  INCF   xC4,F
1384C:  BRA    13732
....................    } 
....................  
....................    parse_data(); 
1384E:  MOVLB  0
13850:  RCALL  136AC
....................    data_available = TRUE; 
13852:  MOVLW  01
13854:  MOVLB  3
13856:  MOVWF  x3B
....................    macro_flag = 900; 
13858:  MOVLW  03
1385A:  MOVWF  x24
1385C:  MOVLW  84
1385E:  MOVWF  x23
....................  
....................    return; 
13860:  MOVLB  0
13862:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
13BCE:  MOVLB  8
13BD0:  CLRF   xCD
13BD2:  CLRF   xCC
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
13BD4:  MOVLB  0
13BD6:  RCALL  136AC
13BD8:  MOVFF  02,8CD
13BDC:  MOVFF  01,8CC
....................    return (temp); 
13BE0:  MOVLB  8
13BE2:  MOVFF  8CC,01
13BE6:  MOVFF  8CD,02
13BEA:  MOVLB  0
13BEC:  GOTO   13CFE (RETURN)
.................... } 
....................  
.................... void det_temp() 
13BF0:  MOVLB  8
13BF2:  CLRF   xC9
13BF4:  CLRF   xC8
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
13BF6:  MOVLB  2
13BF8:  MOVF   xD5,W
13BFA:  XORLW  01
13BFC:  MOVLB  0
13BFE:  BZ    13C06
13C00:  XORLW  03
13C02:  BZ    13C10
13C04:  BRA    13C1A
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
13C06:  MOVFF  42,8CB
13C0A:  MOVFF  41,8CA
....................          break; 
13C0E:  BRA    13C26
....................       case 2 : target_temp = nv_d2_temp; 
13C10:  MOVFF  44,8CB
13C14:  MOVFF  43,8CA
....................          break; 
13C18:  BRA    13C26
....................       default : target_temp = 20000; 
13C1A:  MOVLW  4E
13C1C:  MOVLB  8
13C1E:  MOVWF  xCB
13C20:  MOVLW  20
13C22:  MOVWF  xCA
....................          break; 
13C24:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
13C26:  MOVLB  8
13C28:  CLRF   xC7
13C2A:  MOVLW  3C
13C2C:  MOVWF  xC6
....................    n = 0; 
13C2E:  CLRF   xC5
13C30:  CLRF   xC4
....................    store=FALSE; 
13C32:  CLRF   xC2
....................    display=FALSE; 
13C34:  CLRF   xC3
....................  
....................    time_stamp(); 
13C36:  MOVLB  0
13C38:  CALL   541A
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
13C3C:  MOVLW  01
13C3E:  MOVWF  1E
13C40:  MOVLW  A7
13C42:  MOVWF  1D
13C44:  MOVLW  AA
13C46:  MOVWF  FF6
13C48:  MOVLW  1C
13C4A:  MOVWF  FF7
13C4C:  MOVLW  00
13C4E:  MOVWF  FF8
13C50:  MOVLW  16
13C52:  MOVLB  8
13C54:  MOVWF  xEB
13C56:  MOVLB  0
13C58:  CALL   AACC
13C5C:  MOVLW  10
13C5E:  MOVWF  FE9
13C60:  MOVFF  8CB,8F7
13C64:  MOVFF  8CA,8F6
13C68:  CALL   AAFE
13C6C:  MOVLW  C3
13C6E:  MOVWF  FF6
13C70:  MOVLW  1C
13C72:  MOVWF  FF7
13C74:  MOVLW  00
13C76:  MOVWF  FF8
13C78:  MOVLW  09
13C7A:  MOVLB  8
13C7C:  MOVWF  xEB
13C7E:  MOVLB  0
13C80:  CALL   AACC
13C84:  MOVLW  10
13C86:  MOVWF  FE9
13C88:  MOVFF  8C9,8F7
13C8C:  MOVFF  8C8,8F6
13C90:  CALL   AAFE
13C94:  MOVLW  CF
13C96:  MOVWF  FF6
13C98:  MOVLW  1C
13C9A:  MOVWF  FF7
13C9C:  MOVLW  00
13C9E:  MOVWF  FF8
13CA0:  MOVLW  0B
13CA2:  MOVLB  8
13CA4:  MOVWF  xEB
13CA6:  MOVLB  0
13CA8:  CALL   AACC
13CAC:  MOVLW  10
13CAE:  MOVWF  FE9
13CB0:  MOVFF  8C5,8F7
13CB4:  MOVFF  8C4,8F6
13CB8:  CALL   AAFE
13CBC:  MOVLW  DD
13CBE:  MOVWF  FF6
13CC0:  MOVLW  1C
13CC2:  MOVWF  FF7
13CC4:  MOVLW  00
13CC6:  MOVWF  FF8
13CC8:  MOVLW  03
13CCA:  MOVLB  8
13CCC:  MOVWF  xEB
13CCE:  MOVLB  0
13CD0:  CALL   AACC
....................    record_event(); 
13CD4:  CALL   84DA
....................  
....................    for (n=1; n<t; ++n) 
13CD8:  MOVLB  8
13CDA:  CLRF   xC5
13CDC:  MOVLW  01
13CDE:  MOVWF  xC4
13CE0:  MOVF   xC5,W
13CE2:  SUBWF  xC7,W
13CE4:  BNC   13D40
13CE6:  BNZ   13CEE
13CE8:  MOVF   xC6,W
13CEA:  SUBWF  xC4,W
13CEC:  BC    13D40
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
13CEE:  MOVFF  8C2,8CC
13CF2:  MOVFF  8C3,8CD
13CF6:  MOVLB  0
13CF8:  CALL   12F42
....................       current_temp=parse_temp(); 
13CFC:  BRA    13BCE
13CFE:  MOVFF  02,8C9
13D02:  MOVFF  01,8C8
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
13D06:  MOVLB  8
13D08:  MOVF   xCB,W
13D0A:  SUBWF  xC9,W
13D0C:  BNC   13D16
13D0E:  BNZ   13D1E
13D10:  MOVF   xCA,W
13D12:  SUBWF  xC8,W
13D14:  BC    13D1E
13D16:  MOVF   xC8,F
13D18:  BNZ   13D22
13D1A:  MOVF   xC9,F
13D1C:  BNZ   13D22
13D1E:  BRA    13D40
13D20:  BRA    13D38
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13D22:  MOVLW  0A
13D24:  MOVWF  xCC
13D26:  MOVLW  FA
13D28:  MOVLB  9
13D2A:  MOVWF  xEC
13D2C:  MOVLB  0
13D2E:  CALL   2910
13D32:  MOVLB  8
13D34:  DECFSZ xCC,F
13D36:  BRA    13D26
13D38:  INCF   xC4,F
13D3A:  BTFSC  FD8.2
13D3C:  INCF   xC5,F
13D3E:  BRA    13CE0
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13D40:  MOVLW  01
13D42:  MOVWF  1E
13D44:  MOVLW  A7
13D46:  MOVWF  1D
13D48:  MOVLW  E2
13D4A:  MOVWF  FF6
13D4C:  MOVLW  1C
13D4E:  MOVWF  FF7
13D50:  MOVLW  00
13D52:  MOVWF  FF8
13D54:  MOVLW  14
13D56:  MOVWF  xEB
13D58:  MOVLB  0
13D5A:  CALL   AACC
13D5E:  MOVLW  10
13D60:  MOVWF  FE9
13D62:  MOVFF  8CB,8F7
13D66:  MOVFF  8CA,8F6
13D6A:  CALL   AAFE
13D6E:  MOVLW  F9
13D70:  MOVWF  FF6
13D72:  MOVLW  1C
13D74:  MOVWF  FF7
13D76:  MOVLW  00
13D78:  MOVWF  FF8
13D7A:  MOVLW  09
13D7C:  MOVLB  8
13D7E:  MOVWF  xEB
13D80:  MOVLB  0
13D82:  CALL   AACC
13D86:  MOVLW  10
13D88:  MOVWF  FE9
13D8A:  MOVFF  8C9,8F7
13D8E:  MOVFF  8C8,8F6
13D92:  CALL   AAFE
13D96:  MOVLW  05
13D98:  MOVWF  FF6
13D9A:  MOVLW  1D
13D9C:  MOVWF  FF7
13D9E:  MOVLW  00
13DA0:  MOVWF  FF8
13DA2:  MOVLW  0B
13DA4:  MOVLB  8
13DA6:  MOVWF  xEB
13DA8:  MOVLB  0
13DAA:  CALL   AACC
13DAE:  MOVLW  10
13DB0:  MOVWF  FE9
13DB2:  MOVFF  8C5,8F7
13DB6:  MOVFF  8C4,8F6
13DBA:  CALL   AAFE
13DBE:  MOVLW  13
13DC0:  MOVWF  FF6
13DC2:  MOVLW  1D
13DC4:  MOVWF  FF7
13DC6:  MOVLW  00
13DC8:  MOVWF  FF8
13DCA:  MOVLW  03
13DCC:  MOVLB  8
13DCE:  MOVWF  xEB
13DD0:  MOVLB  0
13DD2:  CALL   AACC
....................    record_event();    
13DD6:  CALL   84DA
13DDA:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
138A6:  MOVLB  8
138A8:  CLRF   xD5
138AA:  CLRF   xD4
138AC:  CLRF   xD3
138AE:  CLRF   xD2
....................    set_adc_channel(1,VSS); 
138B0:  MOVLW  04
138B2:  MOVWF  01
138B4:  MOVF   FC2,W
138B6:  ANDLW  83
138B8:  IORWF  01,W
138BA:  MOVWF  FC2
138BC:  MOVLW  00
138BE:  MOVWF  01
138C0:  MOVF   FC1,W
138C2:  ANDLW  F8
138C4:  IORWF  01,W
138C6:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
138C8:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
138CA:  MOVLW  01
138CC:  MOVWF  xCF
138CE:  MOVF   xCF,W
138D0:  SUBLW  32
138D2:  BNC   138F8
....................       reading=read_adc(); 
138D4:  BSF    FC2.1
138D6:  BTFSC  FC2.1
138D8:  BRA    138D6
138DA:  MOVFF  FC3,8D6
138DE:  MOVFF  FC4,8D7
138E2:  CLRF   xD8
138E4:  CLRF   xD9
....................       delay_ms(5); 
138E6:  MOVLW  05
138E8:  MOVLB  9
138EA:  MOVWF  xEC
138EC:  MOVLB  0
138EE:  CALL   2910
138F2:  MOVLB  8
138F4:  INCF   xCF,F
138F6:  BRA    138CE
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
138F8:  MOVLW  01
138FA:  MOVWF  xCF
138FC:  MOVF   xCF,W
138FE:  SUBLW  64
13900:  BNC   139AE
....................       reading=read_adc(); 
13902:  BSF    FC2.1
13904:  BTFSC  FC2.1
13906:  BRA    13904
13908:  MOVFF  FC3,8D6
1390C:  MOVFF  FC4,8D7
13910:  CLRF   xD8
13912:  CLRF   xD9
....................       result=(((result*(i-1))+reading)/i); 
13914:  MOVLW  01
13916:  SUBWF  xCF,W
13918:  MOVWF  xDA
1391A:  MOVFF  8D5,9F9
1391E:  MOVFF  8D4,9F8
13922:  MOVFF  8D3,9F7
13926:  MOVFF  8D2,9F6
1392A:  MOVLB  9
1392C:  CLRF   xFD
1392E:  CLRF   xFC
13930:  CLRF   xFB
13932:  MOVWF  xFA
13934:  MOVLB  0
13936:  CALL   47F0
1393A:  MOVFF  03,8DD
1393E:  MOVFF  02,8DC
13942:  MOVFF  01,8DB
13946:  MOVFF  00,8DA
1394A:  MOVLB  8
1394C:  MOVF   xD6,W
1394E:  ADDWF  xDA,F
13950:  MOVF   xD7,W
13952:  ADDWFC xDB,F
13954:  MOVF   xD8,W
13956:  ADDWFC xDC,F
13958:  MOVF   xD9,W
1395A:  ADDWFC xDD,F
1395C:  BCF    FD8.1
1395E:  CLRF   1B
13960:  BTFSC  FF2.7
13962:  BSF    1B.7
13964:  BCF    FF2.7
13966:  MOVFF  8DD,A4F
1396A:  MOVFF  8DC,A4E
1396E:  MOVFF  8DB,A4D
13972:  MOVFF  8DA,A4C
13976:  MOVLB  A
13978:  CLRF   x53
1397A:  CLRF   x52
1397C:  CLRF   x51
1397E:  MOVFF  8CF,A50
13982:  MOVLB  0
13984:  CALL   104E
13988:  BTFSC  1B.7
1398A:  BSF    FF2.7
1398C:  MOVFF  03,8D5
13990:  MOVFF  02,8D4
13994:  MOVFF  01,8D3
13998:  MOVFF  00,8D2
....................       delay_ms(5); 
1399C:  MOVLW  05
1399E:  MOVLB  9
139A0:  MOVWF  xEC
139A2:  MOVLB  0
139A4:  CALL   2910
139A8:  MOVLB  8
139AA:  INCF   xCF,F
139AC:  BRA    138FC
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
139AE:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
139B0:  MOVFF  8D5,9F9
139B4:  MOVFF  8D4,9F8
139B8:  MOVFF  8D3,9F7
139BC:  MOVFF  8D2,9F6
139C0:  MOVLB  9
139C2:  CLRF   xFD
139C4:  CLRF   xFC
139C6:  MOVLW  10
139C8:  MOVWF  xFB
139CA:  MOVLW  25
139CC:  MOVWF  xFA
139CE:  MOVLB  0
139D0:  CALL   47F0
139D4:  MOVFF  03,8DD
139D8:  MOVFF  02,8DC
139DC:  MOVFF  01,8DB
139E0:  MOVFF  00,8DA
139E4:  BCF    FD8.1
139E6:  CLRF   1B
139E8:  BTFSC  FF2.7
139EA:  BSF    1B.7
139EC:  BCF    FF2.7
139EE:  MOVFF  03,A4F
139F2:  MOVFF  02,A4E
139F6:  MOVFF  01,A4D
139FA:  MOVFF  00,A4C
139FE:  MOVLB  A
13A00:  CLRF   x53
13A02:  CLRF   x52
13A04:  CLRF   x51
13A06:  MOVLW  64
13A08:  MOVWF  x50
13A0A:  MOVLB  0
13A0C:  CALL   104E
13A10:  BTFSC  1B.7
13A12:  BSF    FF2.7
13A14:  MOVLW  21
13A16:  MOVLB  8
13A18:  SUBWF  00,W
13A1A:  MOVWF  xD0
13A1C:  MOVLW  50
13A1E:  SUBWFB 01,W
13A20:  MOVWF  xD1
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
13A22:  MOVFF  8D0,01
13A26:  MOVFF  8D1,02
13A2A:  MOVLB  0
13A2C:  GOTO   13A92 (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
13A3C:  CLRF   xC8
13A3E:  CLRF   xC7
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
13A30:  MOVLW  0D
13A32:  MOVLB  8
13A34:  MOVWF  xC4
13A36:  MOVLW  0A
13A38:  MOVWF  xC5
13A3A:  CLRF   xC6
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
13A40:  MOVLB  0
13A42:  CALL   127FC
....................    clear_data_buffer(); 
13A46:  CALL   D528
....................  
....................    time_stamp(); 
13A4A:  CALL   541A
....................    strcpy(data_buffer, time_stmp_str); 
13A4E:  CLRF   FEA
13A50:  MOVLW  67
13A52:  MOVWF  FE9
13A54:  MOVLW  02
13A56:  MOVWF  FE2
13A58:  MOVLW  99
13A5A:  MOVWF  FE1
13A5C:  MOVF   FE7,F
13A5E:  MOVFF  FE6,FEE
13A62:  BNZ   13A5C
....................    strcat(data_buffer, (char *)",Tmp,"); 
13A64:  MOVLW  2C
13A66:  MOVLB  8
13A68:  MOVWF  xC9
13A6A:  MOVLW  54
13A6C:  MOVWF  xCA
13A6E:  MOVLW  6D
13A70:  MOVWF  xCB
13A72:  MOVLW  70
13A74:  MOVWF  xCC
13A76:  MOVLW  2C
13A78:  MOVWF  xCD
13A7A:  CLRF   xCE
13A7C:  CLRF   xF9
13A7E:  MOVLW  67
13A80:  MOVWF  xF8
13A82:  MOVLW  08
13A84:  MOVWF  xFB
13A86:  MOVLW  C9
13A88:  MOVWF  xFA
13A8A:  MOVLB  0
13A8C:  CALL   54DE
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
13A90:  BRA    138A6
13A92:  MOVFF  02,8C8
13A96:  MOVFF  01,8C7
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
13A9A:  MOVLW  02
13A9C:  MOVWF  1E
13A9E:  MOVLW  47
13AA0:  MOVWF  1D
13AA2:  MOVLW  45
13AA4:  MOVWF  FE9
13AA6:  MOVLB  8
13AA8:  CLRF   xF0
13AAA:  CLRF   xEF
13AAC:  MOVFF  8C8,8EE
13AB0:  MOVFF  8C7,8ED
13AB4:  MOVLW  03
13AB6:  MOVWF  xF1
13AB8:  MOVLB  0
13ABA:  CALL   531A
....................  
....................    strcat(slave_reply, endofline); 
13ABE:  MOVLW  02
13AC0:  MOVLB  8
13AC2:  MOVWF  xF9
13AC4:  MOVLW  47
13AC6:  MOVWF  xF8
13AC8:  MOVLW  08
13ACA:  MOVWF  xFB
13ACC:  MOVLW  C4
13ACE:  MOVWF  xFA
13AD0:  MOVLB  0
13AD2:  CALL   54DE
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13AD6:  MOVLB  8
13AD8:  CLRF   xEC
13ADA:  MOVLW  67
13ADC:  MOVWF  xEB
13ADE:  MOVLB  0
13AE0:  CALL   12D78
13AE4:  MOVFF  02,03
13AE8:  MOVF   01,W
13AEA:  XORLW  FF
13AEC:  ADDLW  A1
13AEE:  MOVLB  8
13AF0:  MOVWF  xCF
13AF2:  MOVLW  00
13AF4:  SUBFWB 02,W
13AF6:  MOVWF  xD0
13AF8:  MOVLW  01
13AFA:  SUBWF  xCF,F
13AFC:  MOVLW  00
13AFE:  SUBWFB xD0,F
13B00:  CLRF   xEE
13B02:  MOVLW  67
13B04:  MOVWF  xED
13B06:  MOVLW  02
13B08:  MOVWF  xF0
13B0A:  MOVLW  47
13B0C:  MOVWF  xEF
13B0E:  MOVFF  8D0,8F2
13B12:  MOVFF  8CF,8F1
13B16:  MOVLB  0
13B18:  CALL   12DB4
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
13B1C:  MOVF   1F,F
13B1E:  BNZ   13B3E
13B20:  MOVF   20,F
13B22:  BNZ   13B3E
13B24:  MOVLB  8
13B26:  DECFSZ xC3,W
13B28:  BRA    13B2C
13B2A:  BRA    13B30
13B2C:  MOVLB  0
13B2E:  BRA    13B3E
13B30:  CLRF   FEA
13B32:  MOVLW  67
13B34:  MOVWF  FE9
13B36:  MOVLB  0
13B38:  CALL   7996
13B3C:  BRA    13B52
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
13B3E:  MOVF   20,F
13B40:  BNZ   13B48
13B42:  MOVF   1F,W
13B44:  SUBLW  03
13B46:  BC    13B52
13B48:  CLRF   FEA
13B4A:  MOVLW  67
13B4C:  MOVWF  FE9
13B4E:  CALL   7996
....................  
....................    if (store == TRUE && sd_status==0) { 
13B52:  MOVLB  8
13B54:  DECFSZ xC2,W
13B56:  BRA    13BB6
13B58:  MOVLB  2
13B5A:  MOVF   xDC,F
13B5C:  BTFSC  FD8.2
13B5E:  BRA    13B64
13B60:  MOVLB  8
13B62:  BRA    13BB6
....................       buffer_select = 0; 
13B64:  MOVLB  0
13B66:  CLRF   x66
....................       
....................       heartbeat(FALSE); 
13B68:  MOVLB  8
13B6A:  CLRF   xED
13B6C:  MOVLB  0
13B6E:  CALL   5586
....................          append_data(file_ptr_raw_all); 
13B72:  MOVLW  02
13B74:  MOVLB  8
13B76:  MOVWF  xEE
13B78:  MOVLW  DD
13B7A:  MOVWF  xED
13B7C:  MOVLB  0
13B7E:  CALL   82F8
....................       heartbeat(TRUE); 
13B82:  MOVLW  01
13B84:  MOVLB  8
13B86:  MOVWF  xED
13B88:  MOVLB  0
13B8A:  CALL   5586
....................        
....................       heartbeat(FALSE); 
13B8E:  MOVLB  8
13B90:  CLRF   xED
13B92:  MOVLB  0
13B94:  CALL   5586
....................          append_data(file_ptr_raw_new); 
13B98:  MOVLW  02
13B9A:  MOVLB  8
13B9C:  MOVWF  xEE
13B9E:  MOVLW  EB
13BA0:  MOVWF  xED
13BA2:  MOVLB  0
13BA4:  CALL   82F8
....................       heartbeat(TRUE); 
13BA8:  MOVLW  01
13BAA:  MOVLB  8
13BAC:  MOVWF  xED
13BAE:  MOVLB  0
13BB0:  CALL   5586
13BB4:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13BB6:  MOVLW  03
13BB8:  MOVLB  3
13BBA:  MOVWF  x24
13BBC:  MOVLW  84
13BBE:  MOVWF  x23
....................     
....................    return (temp); 
13BC0:  MOVLB  8
13BC2:  MOVFF  8C7,01
13BC6:  MOVFF  8C8,02
13BCA:  MOVLB  0
13BCC:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
1270E:  MOVLB  8
12710:  MOVF   xC5,W
12712:  ADDLW  FC
12714:  BC    12752
12716:  ADDLW  04
12718:  MOVLB  0
1271A:  GOTO   1275A
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
1271E:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
12720:  BCF    F8C.1
....................          break; 
12722:  MOVLB  8
12724:  BRA    12752
....................       case 1 :  
....................             output_bit(HSW1, ON); 
12726:  BSF    F8C.0
....................          break; 
12728:  MOVLB  8
1272A:  BRA    12752
....................       case 2 :  
....................             output_bit(HSW2, ON); 
1272C:  BSF    F8C.1
....................          break;  
1272E:  MOVLB  8
12730:  BRA    12752
....................       case 3 :  
....................             output_bit(HSW1, ON); 
12732:  BSF    F8C.0
....................             delay_ms(500); 
12734:  MOVLW  02
12736:  MOVLB  8
12738:  MOVWF  xC6
1273A:  MOVLW  FA
1273C:  MOVLB  9
1273E:  MOVWF  xEC
12740:  MOVLB  0
12742:  CALL   2910
12746:  MOVLB  8
12748:  DECFSZ xC6,F
1274A:  BRA    1273A
....................             output_bit(HSW2, ON); 
1274C:  BSF    F8C.1
....................          break;             
1274E:  BRA    12752
12750:  MOVLB  8
....................    } 
....................    heater_stat=set; 
12752:  MOVFF  8C5,4B5
12756:  MOVLB  0
12758:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F82A:  MOVLW  08
0F82C:  MOVLB  8
0F82E:  MOVWF  xCC
0F830:  CLRF   xCB
....................    LED_level_change=2048; 
0F832:  MOVWF  xCE
0F834:  CLRF   xCD
....................     
....................    for (i=0; i<12; i++){ 
0F836:  CLRF   xCA
0F838:  MOVF   xCA,W
0F83A:  SUBLW  0B
0F83C:  BNC   F8B4
....................       DAC_set(1,LED_level); 
0F83E:  MOVLW  01
0F840:  MOVWF  xD3
0F842:  MOVFF  8CC,8D5
0F846:  MOVFF  8CB,8D4
0F84A:  MOVLB  0
0F84C:  RCALL  F578
....................       LED_level_change = LED_level_change/2; 
0F84E:  BCF    FD8.0
0F850:  MOVLB  8
0F852:  RRCF   xCE,F
0F854:  RRCF   xCD,F
....................       ADC_average(200); 
0F856:  CLRF   xD4
0F858:  MOVLW  C8
0F85A:  MOVWF  xD3
0F85C:  MOVLB  0
0F85E:  RCALL  F620
....................       output = ADC_val[2]; 
0F860:  MOVFF  4AA,8D0
0F864:  MOVFF  4A9,8CF
....................       temp = ADC_val[3]; 
0F868:  MOVFF  4AC,8D2
0F86C:  MOVFF  4AB,8D1
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F870:  MOVLB  8
0F872:  MOVF   xC9,W
0F874:  SUBWF  xD0,W
0F876:  BNC   F88A
0F878:  BNZ   F880
0F87A:  MOVF   xCF,W
0F87C:  SUBWF  xC8,W
0F87E:  BC    F88A
....................          LED_level=LED_level-LED_level_change; 
0F880:  MOVF   xCD,W
0F882:  SUBWF  xCB,F
0F884:  MOVF   xCE,W
0F886:  SUBWFB xCC,F
....................       } 
0F888:  BRA    F8B0
....................       else if(output<intensity){ 
0F88A:  MOVF   xD0,W
0F88C:  SUBWF  xC9,W
0F88E:  BNC   F8A2
0F890:  BNZ   F898
0F892:  MOVF   xC8,W
0F894:  SUBWF  xCF,W
0F896:  BC    F8A2
....................          LED_level=LED_level+LED_level_change; 
0F898:  MOVF   xCD,W
0F89A:  ADDWF  xCB,F
0F89C:  MOVF   xCE,W
0F89E:  ADDWFC xCC,F
....................       } 
0F8A0:  BRA    F8B0
....................       else if(output==intensity) break; 
0F8A2:  MOVF   xC8,W
0F8A4:  SUBWF  xCF,W
0F8A6:  BNZ   F8B0
0F8A8:  MOVF   xC9,W
0F8AA:  SUBWF  xD0,W
0F8AC:  BTFSC  FD8.2
0F8AE:  BRA    F8B4
0F8B0:  INCF   xCA,F
0F8B2:  BRA    F838
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F8B4:  MOVLW  01
0F8B6:  MOVWF  xD3
0F8B8:  MOVFF  8CC,8D5
0F8BC:  MOVFF  8CB,8D4
0F8C0:  MOVLB  0
0F8C2:  RCALL  F578
0F8C4:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F8C6:  MOVLW  01
0F8C8:  MOVLB  8
0F8CA:  MOVWF  xC7
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F8CC:  MOVF   xC5,F
0F8CE:  BNZ   F8D4
0F8D0:  MOVF   xC6,F
0F8D2:  BZ    F8E8
0F8D4:  MOVF   xC6,W
0F8D6:  SUBLW  0F
0F8D8:  BNC   F8E8
0F8DA:  MOVFF  8C6,8C9
0F8DE:  MOVFF  8C5,8C8
0F8E2:  MOVLB  0
0F8E4:  RCALL  F82A
0F8E6:  MOVLB  8
....................   if(intensity == 0) { 
0F8E8:  MOVF   xC5,F
0F8EA:  BNZ   F90E
0F8EC:  MOVF   xC6,F
0F8EE:  BNZ   F90E
....................       DAC_set(1, 0); 
0F8F0:  MOVLW  01
0F8F2:  MOVWF  xD3
0F8F4:  CLRF   xD5
0F8F6:  CLRF   xD4
0F8F8:  MOVLB  0
0F8FA:  RCALL  F578
....................       DAC_set(2, 0); 
0F8FC:  MOVLW  02
0F8FE:  MOVLB  8
0F900:  MOVWF  xD3
0F902:  CLRF   xD5
0F904:  CLRF   xD4
0F906:  MOVLB  0
0F908:  RCALL  F578
....................    } 
0F90A:  BRA    F912
0F90C:  MOVLB  8
....................    else valid=FALSE; 
0F90E:  CLRF   xC7
0F910:  MOVLB  0
....................    return(valid); 
0F912:  MOVLB  8
0F914:  MOVFF  8C7,01
0F918:  MOVLB  0
0F91A:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FE9C:  MOVLW  18
0FE9E:  MOVWF  FF6
0FEA0:  MOVLW  1D
0FEA2:  MOVWF  FF7
0FEA4:  MOVLW  00
0FEA6:  MOVWF  FF8
0FEA8:  MOVLW  03
0FEAA:  MOVWF  FEA
0FEAC:  MOVLW  3D
0FEAE:  MOVWF  FE9
0FEB0:  RCALL  FE62
0FEB2:  MOVF   01,W
0FEB4:  BZ    FEC8
0FEB6:  XORLW  01
0FEB8:  BZ    FEE8
0FEBA:  XORLW  03
0FEBC:  BZ    FF08
0FEBE:  XORLW  01
0FEC0:  BZ    FF28
0FEC2:  XORLW  07
0FEC4:  BZ    FF48
0FEC6:  BRA    FF66
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FEC8:  BCF    FD8.0
0FECA:  MOVLB  3
0FECC:  RLCF   x4A,W
0FECE:  CLRF   03
0FED0:  ADDLW  4B
0FED2:  MOVWF  FE9
0FED4:  MOVLW  03
0FED6:  ADDWFC 03,W
0FED8:  MOVWF  FEA
0FEDA:  MOVFF  4A8,FEC
0FEDE:  MOVF   FED,F
0FEE0:  MOVFF  4A7,FEF
....................          break; 
0FEE4:  MOVLB  0
0FEE6:  BRA    FF66
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FEE8:  BCF    FD8.0
0FEEA:  MOVLB  3
0FEEC:  RLCF   x4A,W
0FEEE:  CLRF   03
0FEF0:  ADDLW  5D
0FEF2:  MOVWF  FE9
0FEF4:  MOVLW  03
0FEF6:  ADDWFC 03,W
0FEF8:  MOVWF  FEA
0FEFA:  MOVFF  4A8,FEC
0FEFE:  MOVF   FED,F
0FF00:  MOVFF  4A7,FEF
....................          break;    
0FF04:  MOVLB  0
0FF06:  BRA    FF66
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FF08:  BCF    FD8.0
0FF0A:  MOVLB  3
0FF0C:  RLCF   x4A,W
0FF0E:  CLRF   03
0FF10:  ADDLW  6F
0FF12:  MOVWF  FE9
0FF14:  MOVLW  03
0FF16:  ADDWFC 03,W
0FF18:  MOVWF  FEA
0FF1A:  MOVFF  4A8,FEC
0FF1E:  MOVF   FED,F
0FF20:  MOVFF  4A7,FEF
....................          break; 
0FF24:  MOVLB  0
0FF26:  BRA    FF66
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FF28:  BCF    FD8.0
0FF2A:  MOVLB  3
0FF2C:  RLCF   x4A,W
0FF2E:  CLRF   03
0FF30:  ADDLW  81
0FF32:  MOVWF  FE9
0FF34:  MOVLW  03
0FF36:  ADDWFC 03,W
0FF38:  MOVWF  FEA
0FF3A:  MOVFF  4A8,FEC
0FF3E:  MOVF   FED,F
0FF40:  MOVFF  4A7,FEF
....................          break; 
0FF44:  MOVLB  0
0FF46:  BRA    FF66
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FF48:  BCF    FD8.0
0FF4A:  MOVLB  3
0FF4C:  RLCF   x4A,W
0FF4E:  CLRF   03
0FF50:  ADDLW  93
0FF52:  MOVWF  FE9
0FF54:  MOVLW  03
0FF56:  ADDWFC 03,W
0FF58:  MOVWF  FEA
0FF5A:  MOVFF  4A8,FEC
0FF5E:  MOVF   FED,F
0FF60:  MOVFF  4A7,FEF
....................          break; 
0FF64:  MOVLB  0
....................    } 
0FF66:  GOTO   102F8 (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
100B6:  MOVFF  8C3,8D4
100BA:  MOVFF  8C2,8D3
100BE:  CALL   F620
....................     
....................    v_supply = read_supply(); 
100C2:  CALL   50FC
100C6:  MOVFF  02,8C8
100CA:  MOVFF  01,8C7
....................        
....................    RTC_reset_HT(); 
100CE:  CALL   34B2
....................    RTC_read(); 
100D2:  CALL   3344
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
100D6:  RCALL  F934
100D8:  MOVFF  02,8CA
100DC:  MOVFF  01,8C9
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
100E0:  MOVLB  8
100E2:  DECFSZ xC6,W
100E4:  BRA    1010E
100E6:  MOVLW  10
100E8:  MOVWF  FE9
100EA:  CLRF   1B
100EC:  BTFSC  FF2.7
100EE:  BSF    1B.7
100F0:  BCF    FF2.7
100F2:  MOVFF  4AA,A41
100F6:  MOVFF  4A9,A40
100FA:  MOVLB  0
100FC:  CALL   119E
10100:  BTFSC  1B.7
10102:  BSF    FF2.7
10104:  MOVLW  2C
10106:  BTFSS  F9E.4
10108:  BRA    10106
1010A:  MOVWF  FAD
1010C:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
1010E:  CLRF   1E
10110:  MOVLW  67
10112:  MOVWF  1D
10114:  MOVFF  72A,8ED
10118:  MOVLW  01
1011A:  MOVWF  xEE
1011C:  MOVLB  0
1011E:  CALL   5280
10122:  MOVLW  2F
10124:  MOVLB  8
10126:  MOVWF  xFF
10128:  MOVLB  0
1012A:  CALL   509E
1012E:  MOVFF  729,8ED
10132:  MOVLW  01
10134:  MOVLB  8
10136:  MOVWF  xEE
10138:  MOVLB  0
1013A:  CALL   5280
1013E:  MOVLW  2F
10140:  MOVLB  8
10142:  MOVWF  xFF
10144:  MOVLB  0
10146:  CALL   509E
1014A:  MOVFF  72B,8ED
1014E:  MOVLW  01
10150:  MOVLB  8
10152:  MOVWF  xEE
10154:  MOVLB  0
10156:  CALL   5280
1015A:  MOVLW  20
1015C:  MOVLB  8
1015E:  MOVWF  xFF
10160:  MOVLB  0
10162:  CALL   509E
10166:  MOVFF  727,8ED
1016A:  MOVLW  01
1016C:  MOVLB  8
1016E:  MOVWF  xEE
10170:  MOVLB  0
10172:  CALL   5280
10176:  MOVLW  3A
10178:  MOVLB  8
1017A:  MOVWF  xFF
1017C:  MOVLB  0
1017E:  CALL   509E
10182:  MOVFF  726,8ED
10186:  MOVLW  01
10188:  MOVLB  8
1018A:  MOVWF  xEE
1018C:  MOVLB  0
1018E:  CALL   5280
10192:  MOVLW  3A
10194:  MOVLB  8
10196:  MOVWF  xFF
10198:  MOVLB  0
1019A:  CALL   509E
1019E:  MOVFF  725,8ED
101A2:  MOVLW  01
101A4:  MOVLB  8
101A6:  MOVWF  xEE
101A8:  MOVLB  0
101AA:  CALL   5280
101AE:  MOVLW  2C
101B0:  MOVLB  8
101B2:  MOVWF  xFF
101B4:  MOVLB  0
101B6:  CALL   509E
101BA:  MOVLW  04
101BC:  MOVWF  FE9
101BE:  MOVLB  8
101C0:  CLRF   xF0
101C2:  CLRF   xEF
101C4:  MOVFF  8C8,8EE
101C8:  MOVFF  8C7,8ED
101CC:  MOVLW  02
101CE:  MOVWF  xF1
101D0:  MOVLB  0
101D2:  CALL   531A
101D6:  MOVLW  2C
101D8:  MOVLB  8
101DA:  MOVWF  xFF
101DC:  MOVLB  0
101DE:  CALL   509E
101E2:  MOVFF  1E,FEA
101E6:  MOVFF  1D,FE9
101EA:  CLRF   FEF
101EC:  MOVLW  03
101EE:  MOVWF  FEA
101F0:  MOVLW  3D
101F2:  MOVWF  FE9
101F4:  RCALL  FE3C
101F6:  MOVLW  2C
101F8:  MOVLB  8
101FA:  MOVWF  xFF
101FC:  MOVLB  0
101FE:  CALL   509E
10202:  MOVFF  1E,FEA
10206:  MOVFF  1D,FE9
1020A:  CLRF   FEF
1020C:  MOVLW  03
1020E:  MOVWF  FEA
10210:  MOVLW  42
10212:  MOVWF  FE9
10214:  RCALL  FE3C
10216:  MOVLW  2C
10218:  MOVLB  8
1021A:  MOVWF  xFF
1021C:  MOVLB  0
1021E:  CALL   509E
10222:  MOVFF  1E,FEA
10226:  MOVFF  1D,FE9
1022A:  CLRF   FEF
1022C:  MOVLW  03
1022E:  MOVWF  FEA
10230:  MOVLW  46
10232:  MOVWF  FE9
10234:  RCALL  FE3C
10236:  MOVLW  2C
10238:  MOVLB  8
1023A:  MOVWF  xFF
1023C:  MOVLB  0
1023E:  CALL   509E
10242:  MOVLW  10
10244:  MOVWF  FE9
10246:  MOVFF  26,8F7
1024A:  MOVFF  25,8F6
1024E:  CALL   AAFE
10252:  MOVLW  2C
10254:  MOVLB  8
10256:  MOVWF  xFF
10258:  MOVLB  0
1025A:  CALL   509E
1025E:  MOVLW  10
10260:  MOVWF  FE9
10262:  MOVFF  8CA,8F7
10266:  MOVFF  8C9,8F6
1026A:  CALL   AAFE
1026E:  MOVLW  2C
10270:  MOVLB  8
10272:  MOVWF  xFF
10274:  MOVLB  0
10276:  CALL   509E
1027A:  MOVFF  4B5,8ED
1027E:  MOVLW  1B
10280:  MOVLB  8
10282:  MOVWF  xEE
10284:  MOVLB  0
10286:  CALL   5280
1028A:  MOVLW  2C
1028C:  MOVLB  8
1028E:  MOVWF  xFF
10290:  MOVLB  0
10292:  CALL   509E
10296:  MOVLW  10
10298:  MOVWF  FE9
1029A:  MOVFF  4A8,8F7
1029E:  MOVFF  4A7,8F6
102A2:  CALL   AAFE
102A6:  MOVLW  2C
102A8:  MOVLB  8
102AA:  MOVWF  xFF
102AC:  MOVLB  0
102AE:  CALL   509E
102B2:  MOVLW  10
102B4:  MOVWF  FE9
102B6:  MOVFF  4AE,8F7
102BA:  MOVFF  4AD,8F6
102BE:  CALL   AAFE
102C2:  MOVLW  2C
102C4:  MOVLB  8
102C6:  MOVWF  xFF
102C8:  MOVLB  0
102CA:  CALL   509E
102CE:  MOVLW  10
102D0:  MOVWF  FE9
102D2:  MOVFF  4AC,8F7
102D6:  MOVFF  4AB,8F6
102DA:  CALL   AAFE
102DE:  MOVLW  0D
102E0:  MOVLB  8
102E2:  MOVWF  xFF
102E4:  MOVLB  0
102E6:  CALL   509E
102EA:  MOVLW  0A
102EC:  MOVLB  8
102EE:  MOVWF  xFF
102F0:  MOVLB  0
102F2:  CALL   509E
....................  
....................    load_scanned_data();  
102F6:  BRA    FE9C
....................  
....................    display_rec(store, display); 
102F8:  MOVFF  8C4,8EB
102FC:  MOVFF  8C5,8EC
10300:  RCALL  10000
....................     
....................    data_available = TRUE; 
10302:  MOVLW  01
10304:  MOVLB  3
10306:  MOVWF  x3B
....................    macro_flag = 900; 
10308:  MOVLW  03
1030A:  MOVWF  x24
1030C:  MOVLW  84
1030E:  MOVWF  x23
10310:  MOVLB  0
10312:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
10314:  MOVLB  8
10316:  CLRF   x8B
10318:  CLRF   x8A
....................    channel=channel-20000; 
1031A:  MOVLW  20
1031C:  SUBWF  x87,F
1031E:  MOVLW  4E
10320:  SUBWFB x88,F
....................     
....................    for (i=0; i<9; i++){ 
10322:  CLRF   x89
10324:  MOVF   x89,W
10326:  SUBLW  08
10328:  BNC   103CA
....................       DAC_set(channel, setting); 
1032A:  MOVFF  887,8D3
1032E:  MOVFF  88B,8D5
10332:  MOVFF  88A,8D4
10336:  MOVLB  0
10338:  CALL   F578
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
1033C:  MOVLW  2E
1033E:  MOVWF  FF6
10340:  MOVLW  1D
10342:  MOVWF  FF7
10344:  MOVLW  00
10346:  MOVWF  FF8
10348:  CLRF   1B
1034A:  BTFSC  FF2.7
1034C:  BSF    1B.7
1034E:  BCF    FF2.7
10350:  MOVLW  05
10352:  MOVLB  A
10354:  MOVWF  x40
10356:  MOVLB  0
10358:  CALL   101C
1035C:  BTFSC  1B.7
1035E:  BSF    FF2.7
10360:  MOVLW  10
10362:  MOVWF  FE9
10364:  CLRF   1B
10366:  BTFSC  FF2.7
10368:  BSF    1B.7
1036A:  BCF    FF2.7
1036C:  MOVFF  888,A41
10370:  MOVFF  887,A40
10374:  CALL   119E
10378:  BTFSC  1B.7
1037A:  BSF    FF2.7
1037C:  MOVLW  2C
1037E:  BTFSS  F9E.4
10380:  BRA    1037E
10382:  MOVWF  FAD
10384:  MOVLW  10
10386:  MOVWF  FE9
10388:  CLRF   1B
1038A:  BTFSC  FF2.7
1038C:  BSF    1B.7
1038E:  BCF    FF2.7
10390:  MOVFF  88B,A41
10394:  MOVFF  88A,A40
10398:  CALL   119E
1039C:  BTFSC  1B.7
1039E:  BSF    FF2.7
103A0:  MOVLW  2C
103A2:  BTFSS  F9E.4
103A4:  BRA    103A2
103A6:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
103A8:  MOVLB  8
103AA:  CLRF   xC3
103AC:  MOVLW  C8
103AE:  MOVWF  xC2
103B0:  CLRF   xC4
103B2:  MOVLW  01
103B4:  MOVWF  xC5
103B6:  MOVWF  xC6
103B8:  MOVLB  0
103BA:  RCALL  100B6
....................       setting = setting+500; 
103BC:  MOVLW  F4
103BE:  MOVLB  8
103C0:  ADDWF  x8A,F
103C2:  MOVLW  01
103C4:  ADDWFC x8B,F
103C6:  INCF   x89,F
103C8:  BRA    10324
....................    } 
103CA:  MOVLB  0
103CC:  GOTO   1049C (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
*
0FF6A:  MOVLB  8
0FF6C:  CLRF   x87
0FF6E:  CLRF   x86
....................     
....................    for (i=0; i<9; i++){ 
0FF70:  CLRF   x85
0FF72:  MOVF   x85,W
0FF74:  SUBLW  08
0FF76:  BNC   FFEE
....................       LED_SAR(intensity); 
0FF78:  MOVFF  887,8C9
0FF7C:  MOVFF  886,8C8
0FF80:  MOVLB  0
0FF82:  RCALL  F82A
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
0FF84:  MOVLW  3C
0FF86:  MOVWF  FF6
0FF88:  MOVLW  1D
0FF8A:  MOVWF  FF7
0FF8C:  MOVLW  00
0FF8E:  MOVWF  FF8
0FF90:  CLRF   1B
0FF92:  BTFSC  FF2.7
0FF94:  BSF    1B.7
0FF96:  BCF    FF2.7
0FF98:  MOVLW  07
0FF9A:  MOVLB  A
0FF9C:  MOVWF  x40
0FF9E:  MOVLB  0
0FFA0:  CALL   101C
0FFA4:  BTFSC  1B.7
0FFA6:  BSF    FF2.7
0FFA8:  MOVLW  10
0FFAA:  MOVWF  FE9
0FFAC:  CLRF   1B
0FFAE:  BTFSC  FF2.7
0FFB0:  BSF    1B.7
0FFB2:  BCF    FF2.7
0FFB4:  MOVFF  887,A41
0FFB8:  MOVFF  886,A40
0FFBC:  CALL   119E
0FFC0:  BTFSC  1B.7
0FFC2:  BSF    FF2.7
0FFC4:  MOVLW  2C
0FFC6:  BTFSS  F9E.4
0FFC8:  BRA    FFC6
0FFCA:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
0FFCC:  MOVLB  8
0FFCE:  CLRF   xC3
0FFD0:  MOVLW  C8
0FFD2:  MOVWF  xC2
0FFD4:  CLRF   xC4
0FFD6:  MOVLW  01
0FFD8:  MOVWF  xC5
0FFDA:  MOVWF  xC6
0FFDC:  MOVLB  0
0FFDE:  RCALL  100B6
....................       intensity = intensity+500; 
0FFE0:  MOVLW  F4
0FFE2:  MOVLB  8
0FFE4:  ADDWF  x86,F
0FFE6:  MOVLW  01
0FFE8:  ADDWFC x87,F
0FFEA:  INCF   x85,F
0FFEC:  BRA    FF72
....................    } 
0FFEE:  MOVLB  0
0FFF0:  GOTO   1049C (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
030BA:  MOVLB  8
030BC:  CLRF   xB6
030BE:  MOVF   xB6,W
030C0:  SUBLW  20
030C2:  BNC   30D8
030C4:  CLRF   03
030C6:  MOVF   xB6,W
030C8:  ADDLW  B7
030CA:  MOVWF  FE9
030CC:  MOVLW  04
030CE:  ADDWFC 03,W
030D0:  MOVWF  FEA
030D2:  CLRF   FEF
030D4:  INCF   xB6,F
030D6:  BRA    30BE
030D8:  MOVLB  0
030DA:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
030DC:  MOVF   2F,W
030DE:  SUBLW  02
030E0:  BNZ   30EA
030E2:  MOVF   30,F
030E4:  BNZ   30EA
030E6:  MOVLW  00
030E8:  MOVWF  F99
....................    init_valve_status(); 
030EA:  RCALL  30BA
....................    bus_pwr_status=0; 
030EC:  MOVLB  4
030EE:  CLRF   xB6
030F0:  MOVLB  0
030F2:  GOTO   1B7B2 (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0ED66:  MOVLW  48
0ED68:  MOVWF  FF6
0ED6A:  MOVLW  1D
0ED6C:  MOVWF  FF7
0ED6E:  MOVLW  00
0ED70:  MOVWF  FF8
0ED72:  CLRF   1B
0ED74:  BTFSC  FF2.7
0ED76:  BSF    1B.7
0ED78:  BCF    FF2.7
0ED7A:  CALL   0E46
0ED7E:  BTFSC  1B.7
0ED80:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0ED82:  MOVLW  01
0ED84:  MOVLB  8
0ED86:  MOVWF  xB6
0ED88:  MOVF   xB6,W
0ED8A:  SUBLW  08
0ED8C:  BNC   EDF6
0ED8E:  CLRF   03
0ED90:  MOVF   xB6,W
0ED92:  ADDLW  B7
0ED94:  MOVWF  FE9
0ED96:  MOVLW  04
0ED98:  ADDWFC 03,W
0ED9A:  MOVWF  FEA
0ED9C:  MOVFF  FEF,8B7
0EDA0:  CLRF   1B
0EDA2:  BTFSC  FF2.7
0EDA4:  BSF    1B.7
0EDA6:  BCF    FF2.7
0EDA8:  MOVFF  8B6,A40
0EDAC:  MOVLW  01
0EDAE:  MOVLB  A
0EDB0:  MOVWF  x41
0EDB2:  MOVLB  0
0EDB4:  CALL   0F9E
0EDB8:  BTFSC  1B.7
0EDBA:  BSF    FF2.7
0EDBC:  MOVLW  5B
0EDBE:  BTFSS  F9E.4
0EDC0:  BRA    EDBE
0EDC2:  MOVWF  FAD
0EDC4:  CLRF   1B
0EDC6:  BTFSC  FF2.7
0EDC8:  BSF    1B.7
0EDCA:  BCF    FF2.7
0EDCC:  MOVFF  8B7,A40
0EDD0:  MOVLW  1B
0EDD2:  MOVLB  A
0EDD4:  MOVWF  x41
0EDD6:  MOVLB  0
0EDD8:  CALL   0F9E
0EDDC:  BTFSC  1B.7
0EDDE:  BSF    FF2.7
0EDE0:  MOVLW  5D
0EDE2:  BTFSS  F9E.4
0EDE4:  BRA    EDE2
0EDE6:  MOVWF  FAD
0EDE8:  MOVLW  20
0EDEA:  BTFSS  F9E.4
0EDEC:  BRA    EDEA
0EDEE:  MOVWF  FAD
0EDF0:  MOVLB  8
0EDF2:  INCF   xB6,F
0EDF4:  BRA    ED88
....................    fprintf(COM_A, "\r\n"); 
0EDF6:  MOVLW  0D
0EDF8:  BTFSS  F9E.4
0EDFA:  BRA    EDF8
0EDFC:  MOVWF  FAD
0EDFE:  MOVLW  0A
0EE00:  BTFSS  F9E.4
0EE02:  BRA    EE00
0EE04:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EE06:  MOVLW  4E
0EE08:  MOVWF  FF6
0EE0A:  MOVLW  1D
0EE0C:  MOVWF  FF7
0EE0E:  MOVLW  00
0EE10:  MOVWF  FF8
0EE12:  CLRF   1B
0EE14:  BTFSC  FF2.7
0EE16:  BSF    1B.7
0EE18:  BCF    FF2.7
0EE1A:  MOVLB  0
0EE1C:  CALL   0E46
0EE20:  BTFSC  1B.7
0EE22:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EE24:  MOVLW  09
0EE26:  MOVLB  8
0EE28:  MOVWF  xB6
0EE2A:  MOVF   xB6,W
0EE2C:  SUBLW  10
0EE2E:  BNC   EE98
0EE30:  CLRF   03
0EE32:  MOVF   xB6,W
0EE34:  ADDLW  B7
0EE36:  MOVWF  FE9
0EE38:  MOVLW  04
0EE3A:  ADDWFC 03,W
0EE3C:  MOVWF  FEA
0EE3E:  MOVFF  FEF,8B7
0EE42:  CLRF   1B
0EE44:  BTFSC  FF2.7
0EE46:  BSF    1B.7
0EE48:  BCF    FF2.7
0EE4A:  MOVFF  8B6,A40
0EE4E:  MOVLW  01
0EE50:  MOVLB  A
0EE52:  MOVWF  x41
0EE54:  MOVLB  0
0EE56:  CALL   0F9E
0EE5A:  BTFSC  1B.7
0EE5C:  BSF    FF2.7
0EE5E:  MOVLW  5B
0EE60:  BTFSS  F9E.4
0EE62:  BRA    EE60
0EE64:  MOVWF  FAD
0EE66:  CLRF   1B
0EE68:  BTFSC  FF2.7
0EE6A:  BSF    1B.7
0EE6C:  BCF    FF2.7
0EE6E:  MOVFF  8B7,A40
0EE72:  MOVLW  1B
0EE74:  MOVLB  A
0EE76:  MOVWF  x41
0EE78:  MOVLB  0
0EE7A:  CALL   0F9E
0EE7E:  BTFSC  1B.7
0EE80:  BSF    FF2.7
0EE82:  MOVLW  5D
0EE84:  BTFSS  F9E.4
0EE86:  BRA    EE84
0EE88:  MOVWF  FAD
0EE8A:  MOVLW  20
0EE8C:  BTFSS  F9E.4
0EE8E:  BRA    EE8C
0EE90:  MOVWF  FAD
0EE92:  MOVLB  8
0EE94:  INCF   xB6,F
0EE96:  BRA    EE2A
....................    fprintf(COM_A, "\r\n"); 
0EE98:  MOVLW  0D
0EE9A:  BTFSS  F9E.4
0EE9C:  BRA    EE9A
0EE9E:  MOVWF  FAD
0EEA0:  MOVLW  0A
0EEA2:  BTFSS  F9E.4
0EEA4:  BRA    EEA2
0EEA6:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EEA8:  MOVLW  54
0EEAA:  MOVWF  FF6
0EEAC:  MOVLW  1D
0EEAE:  MOVWF  FF7
0EEB0:  MOVLW  00
0EEB2:  MOVWF  FF8
0EEB4:  CLRF   1B
0EEB6:  BTFSC  FF2.7
0EEB8:  BSF    1B.7
0EEBA:  BCF    FF2.7
0EEBC:  MOVLB  0
0EEBE:  CALL   0E46
0EEC2:  BTFSC  1B.7
0EEC4:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EEC6:  MOVLW  11
0EEC8:  MOVLB  8
0EECA:  MOVWF  xB6
0EECC:  MOVF   xB6,W
0EECE:  SUBLW  18
0EED0:  BNC   EF3A
0EED2:  CLRF   03
0EED4:  MOVF   xB6,W
0EED6:  ADDLW  B7
0EED8:  MOVWF  FE9
0EEDA:  MOVLW  04
0EEDC:  ADDWFC 03,W
0EEDE:  MOVWF  FEA
0EEE0:  MOVFF  FEF,8B7
0EEE4:  CLRF   1B
0EEE6:  BTFSC  FF2.7
0EEE8:  BSF    1B.7
0EEEA:  BCF    FF2.7
0EEEC:  MOVFF  8B6,A40
0EEF0:  MOVLW  01
0EEF2:  MOVLB  A
0EEF4:  MOVWF  x41
0EEF6:  MOVLB  0
0EEF8:  CALL   0F9E
0EEFC:  BTFSC  1B.7
0EEFE:  BSF    FF2.7
0EF00:  MOVLW  5B
0EF02:  BTFSS  F9E.4
0EF04:  BRA    EF02
0EF06:  MOVWF  FAD
0EF08:  CLRF   1B
0EF0A:  BTFSC  FF2.7
0EF0C:  BSF    1B.7
0EF0E:  BCF    FF2.7
0EF10:  MOVFF  8B7,A40
0EF14:  MOVLW  1B
0EF16:  MOVLB  A
0EF18:  MOVWF  x41
0EF1A:  MOVLB  0
0EF1C:  CALL   0F9E
0EF20:  BTFSC  1B.7
0EF22:  BSF    FF2.7
0EF24:  MOVLW  5D
0EF26:  BTFSS  F9E.4
0EF28:  BRA    EF26
0EF2A:  MOVWF  FAD
0EF2C:  MOVLW  20
0EF2E:  BTFSS  F9E.4
0EF30:  BRA    EF2E
0EF32:  MOVWF  FAD
0EF34:  MOVLB  8
0EF36:  INCF   xB6,F
0EF38:  BRA    EECC
....................    fprintf(COM_A, "\r\n"); 
0EF3A:  MOVLW  0D
0EF3C:  BTFSS  F9E.4
0EF3E:  BRA    EF3C
0EF40:  MOVWF  FAD
0EF42:  MOVLW  0A
0EF44:  BTFSS  F9E.4
0EF46:  BRA    EF44
0EF48:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EF4A:  MOVLW  5A
0EF4C:  MOVWF  FF6
0EF4E:  MOVLW  1D
0EF50:  MOVWF  FF7
0EF52:  MOVLW  00
0EF54:  MOVWF  FF8
0EF56:  CLRF   1B
0EF58:  BTFSC  FF2.7
0EF5A:  BSF    1B.7
0EF5C:  BCF    FF2.7
0EF5E:  MOVLB  0
0EF60:  CALL   0E46
0EF64:  BTFSC  1B.7
0EF66:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EF68:  MOVLW  19
0EF6A:  MOVLB  8
0EF6C:  MOVWF  xB6
0EF6E:  MOVF   xB6,W
0EF70:  SUBLW  20
0EF72:  BNC   EFDC
0EF74:  CLRF   03
0EF76:  MOVF   xB6,W
0EF78:  ADDLW  B7
0EF7A:  MOVWF  FE9
0EF7C:  MOVLW  04
0EF7E:  ADDWFC 03,W
0EF80:  MOVWF  FEA
0EF82:  MOVFF  FEF,8B7
0EF86:  CLRF   1B
0EF88:  BTFSC  FF2.7
0EF8A:  BSF    1B.7
0EF8C:  BCF    FF2.7
0EF8E:  MOVFF  8B6,A40
0EF92:  MOVLW  01
0EF94:  MOVLB  A
0EF96:  MOVWF  x41
0EF98:  MOVLB  0
0EF9A:  CALL   0F9E
0EF9E:  BTFSC  1B.7
0EFA0:  BSF    FF2.7
0EFA2:  MOVLW  5B
0EFA4:  BTFSS  F9E.4
0EFA6:  BRA    EFA4
0EFA8:  MOVWF  FAD
0EFAA:  CLRF   1B
0EFAC:  BTFSC  FF2.7
0EFAE:  BSF    1B.7
0EFB0:  BCF    FF2.7
0EFB2:  MOVFF  8B7,A40
0EFB6:  MOVLW  1B
0EFB8:  MOVLB  A
0EFBA:  MOVWF  x41
0EFBC:  MOVLB  0
0EFBE:  CALL   0F9E
0EFC2:  BTFSC  1B.7
0EFC4:  BSF    FF2.7
0EFC6:  MOVLW  5D
0EFC8:  BTFSS  F9E.4
0EFCA:  BRA    EFC8
0EFCC:  MOVWF  FAD
0EFCE:  MOVLW  20
0EFD0:  BTFSS  F9E.4
0EFD2:  BRA    EFD0
0EFD4:  MOVWF  FAD
0EFD6:  MOVLB  8
0EFD8:  INCF   xB6,F
0EFDA:  BRA    EF6E
....................    fprintf(COM_A, "\r\n");    
0EFDC:  MOVLW  0D
0EFDE:  BTFSS  F9E.4
0EFE0:  BRA    EFDE
0EFE2:  MOVWF  FAD
0EFE4:  MOVLW  0A
0EFE6:  BTFSS  F9E.4
0EFE8:  BRA    EFE6
0EFEA:  MOVWF  FAD
0EFEC:  MOVLB  0
0EFEE:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
144B6:  MOVF   1F,W
144B8:  SUBLW  04
144BA:  BNZ   14524
144BC:  MOVF   20,F
144BE:  BNZ   14524
144C0:  MOVLW  60
144C2:  MOVWF  FF6
144C4:  MOVLW  1D
144C6:  MOVWF  FF7
144C8:  MOVLW  00
144CA:  MOVWF  FF8
144CC:  CLRF   1B
144CE:  BTFSC  FF2.7
144D0:  BSF    1B.7
144D2:  BCF    FF2.7
144D4:  MOVLW  0C
144D6:  MOVLB  A
144D8:  MOVWF  x40
144DA:  MOVLB  0
144DC:  CALL   101C
144E0:  BTFSC  1B.7
144E2:  BSF    FF2.7
144E4:  MOVLW  10
144E6:  MOVWF  FE9
144E8:  CLRF   1B
144EA:  BTFSC  FF2.7
144EC:  BSF    1B.7
144EE:  BCF    FF2.7
144F0:  MOVFF  8B7,A41
144F4:  MOVFF  8B6,A40
144F8:  CALL   119E
144FC:  BTFSC  1B.7
144FE:  BSF    FF2.7
14500:  MOVLW  6F
14502:  MOVWF  FF6
14504:  MOVLW  1D
14506:  MOVWF  FF7
14508:  MOVLW  00
1450A:  MOVWF  FF8
1450C:  CLRF   1B
1450E:  BTFSC  FF2.7
14510:  BSF    1B.7
14512:  BCF    FF2.7
14514:  MOVLW  03
14516:  MOVLB  A
14518:  MOVWF  x40
1451A:  MOVLB  0
1451C:  CALL   101C
14520:  BTFSC  1B.7
14522:  BSF    FF2.7
....................  
....................    multidrop_on(); 
14524:  CALL   DA78
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
14528:  MOVLW  74
1452A:  MOVWF  FF6
1452C:  MOVLW  1D
1452E:  MOVWF  FF7
14530:  MOVLW  00
14532:  MOVWF  FF8
14534:  MOVLW  03
14536:  MOVLB  8
14538:  MOVWF  xB8
1453A:  MOVLB  0
1453C:  CALL   DA8C
14540:  MOVLW  10
14542:  MOVWF  FE9
14544:  MOVFF  8B7,8B9
14548:  MOVFF  8B6,8B8
1454C:  BRA    143FC
1454E:  MOVLW  0D
14550:  BTFSS  FA4.4
14552:  BRA    14550
14554:  MOVLB  F
14556:  MOVWF  x1C
....................    multidrop_off(); 
14558:  MOVLB  0
1455A:  CALL   DB64
....................  
....................    delay_ms(100); 
1455E:  MOVLW  64
14560:  MOVLB  9
14562:  MOVWF  xEC
14564:  MOVLB  0
14566:  CALL   2910
1456A:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0DBB6:  MOVF   1F,W
0DBB8:  SUBLW  04
0DBBA:  BNZ   DC24
0DBBC:  MOVF   20,F
0DBBE:  BNZ   DC24
0DBC0:  MOVLW  7C
0DBC2:  MOVWF  FF6
0DBC4:  MOVLW  1D
0DBC6:  MOVWF  FF7
0DBC8:  MOVLW  00
0DBCA:  MOVWF  FF8
0DBCC:  CLRF   1B
0DBCE:  BTFSC  FF2.7
0DBD0:  BSF    1B.7
0DBD2:  BCF    FF2.7
0DBD4:  MOVLW  0C
0DBD6:  MOVLB  A
0DBD8:  MOVWF  x40
0DBDA:  MOVLB  0
0DBDC:  CALL   101C
0DBE0:  BTFSC  1B.7
0DBE2:  BSF    FF2.7
0DBE4:  CLRF   1B
0DBE6:  BTFSC  FF2.7
0DBE8:  BSF    1B.7
0DBEA:  BCF    FF2.7
0DBEC:  MOVFF  8B6,A40
0DBF0:  MOVLW  1B
0DBF2:  MOVLB  A
0DBF4:  MOVWF  x41
0DBF6:  MOVLB  0
0DBF8:  CALL   0F9E
0DBFC:  BTFSC  1B.7
0DBFE:  BSF    FF2.7
0DC00:  MOVLW  8A
0DC02:  MOVWF  FF6
0DC04:  MOVLW  1D
0DC06:  MOVWF  FF7
0DC08:  MOVLW  00
0DC0A:  MOVWF  FF8
0DC0C:  CLRF   1B
0DC0E:  BTFSC  FF2.7
0DC10:  BSF    1B.7
0DC12:  BCF    FF2.7
0DC14:  MOVLW  03
0DC16:  MOVLB  A
0DC18:  MOVWF  x40
0DC1A:  MOVLB  0
0DC1C:  CALL   101C
0DC20:  BTFSC  1B.7
0DC22:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0DC24:  RCALL  DA78
....................       fprintf(COM_B, "/1c%u\r",chip); 
0DC26:  MOVLW  8E
0DC28:  MOVWF  FF6
0DC2A:  MOVLW  1D
0DC2C:  MOVWF  FF7
0DC2E:  MOVLW  00
0DC30:  MOVWF  FF8
0DC32:  MOVLW  03
0DC34:  MOVLB  8
0DC36:  MOVWF  xB8
0DC38:  MOVLB  0
0DC3A:  RCALL  DA8C
0DC3C:  MOVFF  8B6,8F3
0DC40:  MOVLW  1B
0DC42:  MOVLB  8
0DC44:  MOVWF  xF4
0DC46:  MOVLB  0
0DC48:  RCALL  DAC0
0DC4A:  MOVLW  0D
0DC4C:  BTFSS  FA4.4
0DC4E:  BRA    DC4C
0DC50:  MOVLB  F
0DC52:  MOVWF  x1C
....................    multidrop_off(); 
0DC54:  MOVLB  0
0DC56:  RCALL  DB64
....................    delay_ms(100); 
0DC58:  MOVLW  64
0DC5A:  MOVLB  9
0DC5C:  MOVWF  xEC
0DC5E:  MOVLB  0
0DC60:  CALL   2910
....................  
....................    multidrop_on(); 
0DC64:  RCALL  DA78
....................      fprintf(COM_B, "/1s256\r"); 
0DC66:  MOVLW  96
0DC68:  MOVWF  FF6
0DC6A:  MOVLW  1D
0DC6C:  MOVWF  FF7
0DC6E:  MOVLW  00
0DC70:  MOVWF  FF8
0DC72:  BRA    DB86
....................    multidrop_off();  
0DC74:  RCALL  DB64
....................    delay_ms(100); 
0DC76:  MOVLW  64
0DC78:  MOVLB  9
0DC7A:  MOVWF  xEC
0DC7C:  MOVLB  0
0DC7E:  CALL   2910
0DC82:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
1456C:  MOVLB  8
1456E:  MOVF   xB5,W
14570:  ADDLW  DF
14572:  BTFSC  FD8.0
14574:  BRA    14960
14576:  ADDLW  21
14578:  MOVLB  0
1457A:  GOTO   14992
....................       case 0 : sol_chip_cmd(1); 
1457E:  MOVLW  01
14580:  MOVLB  8
14582:  MOVWF  xB6
14584:  MOVLB  0
14586:  CALL   DBB6
....................                sol_switch_cmd(0); 
1458A:  MOVLB  8
1458C:  CLRF   xB7
1458E:  CLRF   xB6
14590:  MOVLB  0
14592:  RCALL  144B6
....................                sol_chip_cmd(2); 
14594:  MOVLW  02
14596:  MOVLB  8
14598:  MOVWF  xB6
1459A:  MOVLB  0
1459C:  CALL   DBB6
....................                sol_switch_cmd(0); 
145A0:  MOVLB  8
145A2:  CLRF   xB7
145A4:  CLRF   xB6
145A6:  MOVLB  0
145A8:  RCALL  144B6
....................                sol_chip_cmd(3); 
145AA:  MOVLW  03
145AC:  MOVLB  8
145AE:  MOVWF  xB6
145B0:  MOVLB  0
145B2:  CALL   DBB6
....................                sol_switch_cmd(0); 
145B6:  MOVLB  8
145B8:  CLRF   xB7
145BA:  CLRF   xB6
145BC:  MOVLB  0
145BE:  RCALL  144B6
....................                sol_chip_cmd(4); 
145C0:  MOVLW  04
145C2:  MOVLB  8
145C4:  MOVWF  xB6
145C6:  MOVLB  0
145C8:  CALL   DBB6
....................                sol_switch_cmd(0); 
145CC:  MOVLB  8
145CE:  CLRF   xB7
145D0:  CLRF   xB6
145D2:  MOVLB  0
145D4:  RCALL  144B6
....................                init_valve_status(); 
145D6:  CALL   30BA
....................          break; 
145DA:  MOVLB  8
145DC:  BRA    14960
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
145DE:  MOVLW  01
145E0:  MOVLB  8
145E2:  MOVWF  xB6
145E4:  MOVLB  0
145E6:  CALL   DBB6
....................                sol_switch_cmd(1); 
145EA:  MOVLB  8
145EC:  CLRF   xB7
145EE:  MOVLW  01
145F0:  MOVWF  xB6
145F2:  MOVLB  0
145F4:  RCALL  144B6
....................          break;     
145F6:  MOVLB  8
145F8:  BRA    14960
....................       case 2 : sol_chip_cmd(1); 
145FA:  MOVLW  01
145FC:  MOVLB  8
145FE:  MOVWF  xB6
14600:  MOVLB  0
14602:  CALL   DBB6
....................                sol_switch_cmd(2); 
14606:  MOVLB  8
14608:  CLRF   xB7
1460A:  MOVLW  02
1460C:  MOVWF  xB6
1460E:  MOVLB  0
14610:  RCALL  144B6
....................          break;           
14612:  MOVLB  8
14614:  BRA    14960
....................       case 3 : sol_chip_cmd(1); 
14616:  MOVLW  01
14618:  MOVLB  8
1461A:  MOVWF  xB6
1461C:  MOVLB  0
1461E:  CALL   DBB6
....................                sol_switch_cmd(4); 
14622:  MOVLB  8
14624:  CLRF   xB7
14626:  MOVLW  04
14628:  MOVWF  xB6
1462A:  MOVLB  0
1462C:  RCALL  144B6
....................          break;  
1462E:  MOVLB  8
14630:  BRA    14960
....................       case 4 : sol_chip_cmd(1); 
14632:  MOVLW  01
14634:  MOVLB  8
14636:  MOVWF  xB6
14638:  MOVLB  0
1463A:  CALL   DBB6
....................                sol_switch_cmd(8); 
1463E:  MOVLB  8
14640:  CLRF   xB7
14642:  MOVLW  08
14644:  MOVWF  xB6
14646:  MOVLB  0
14648:  RCALL  144B6
....................          break;  
1464A:  MOVLB  8
1464C:  BRA    14960
....................       case 5 : sol_chip_cmd(1); 
1464E:  MOVLW  01
14650:  MOVLB  8
14652:  MOVWF  xB6
14654:  MOVLB  0
14656:  CALL   DBB6
....................                sol_switch_cmd(16); 
1465A:  MOVLB  8
1465C:  CLRF   xB7
1465E:  MOVLW  10
14660:  MOVWF  xB6
14662:  MOVLB  0
14664:  RCALL  144B6
....................          break;  
14666:  MOVLB  8
14668:  BRA    14960
....................       case 6 : sol_chip_cmd(1); 
1466A:  MOVLW  01
1466C:  MOVLB  8
1466E:  MOVWF  xB6
14670:  MOVLB  0
14672:  CALL   DBB6
....................                sol_switch_cmd(32); 
14676:  MOVLB  8
14678:  CLRF   xB7
1467A:  MOVLW  20
1467C:  MOVWF  xB6
1467E:  MOVLB  0
14680:  RCALL  144B6
....................          break;  
14682:  MOVLB  8
14684:  BRA    14960
....................       case 7 : sol_chip_cmd(1); 
14686:  MOVLW  01
14688:  MOVLB  8
1468A:  MOVWF  xB6
1468C:  MOVLB  0
1468E:  CALL   DBB6
....................                sol_switch_cmd(64); 
14692:  MOVLB  8
14694:  CLRF   xB7
14696:  MOVLW  40
14698:  MOVWF  xB6
1469A:  MOVLB  0
1469C:  RCALL  144B6
....................          break;  
1469E:  MOVLB  8
146A0:  BRA    14960
....................       case 8 : sol_chip_cmd(1); 
146A2:  MOVLW  01
146A4:  MOVLB  8
146A6:  MOVWF  xB6
146A8:  MOVLB  0
146AA:  CALL   DBB6
....................                sol_switch_cmd(128); 
146AE:  MOVLB  8
146B0:  CLRF   xB7
146B2:  MOVLW  80
146B4:  MOVWF  xB6
146B6:  MOVLB  0
146B8:  RCALL  144B6
....................          break;   
146BA:  MOVLB  8
146BC:  BRA    14960
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
146BE:  MOVLW  02
146C0:  MOVLB  8
146C2:  MOVWF  xB6
146C4:  MOVLB  0
146C6:  CALL   DBB6
....................                sol_switch_cmd(1); 
146CA:  MOVLB  8
146CC:  CLRF   xB7
146CE:  MOVLW  01
146D0:  MOVWF  xB6
146D2:  MOVLB  0
146D4:  RCALL  144B6
....................          break;     
146D6:  MOVLB  8
146D8:  BRA    14960
....................       case 10 : sol_chip_cmd(2); 
146DA:  MOVLW  02
146DC:  MOVLB  8
146DE:  MOVWF  xB6
146E0:  MOVLB  0
146E2:  CALL   DBB6
....................                sol_switch_cmd(2); 
146E6:  MOVLB  8
146E8:  CLRF   xB7
146EA:  MOVLW  02
146EC:  MOVWF  xB6
146EE:  MOVLB  0
146F0:  RCALL  144B6
....................          break;           
146F2:  MOVLB  8
146F4:  BRA    14960
....................       case 11 : sol_chip_cmd(2); 
146F6:  MOVLW  02
146F8:  MOVLB  8
146FA:  MOVWF  xB6
146FC:  MOVLB  0
146FE:  CALL   DBB6
....................                sol_switch_cmd(4); 
14702:  MOVLB  8
14704:  CLRF   xB7
14706:  MOVLW  04
14708:  MOVWF  xB6
1470A:  MOVLB  0
1470C:  RCALL  144B6
....................          break;  
1470E:  MOVLB  8
14710:  BRA    14960
....................       case 12 : sol_chip_cmd(2); 
14712:  MOVLW  02
14714:  MOVLB  8
14716:  MOVWF  xB6
14718:  MOVLB  0
1471A:  CALL   DBB6
....................                sol_switch_cmd(8); 
1471E:  MOVLB  8
14720:  CLRF   xB7
14722:  MOVLW  08
14724:  MOVWF  xB6
14726:  MOVLB  0
14728:  RCALL  144B6
....................          break;  
1472A:  MOVLB  8
1472C:  BRA    14960
....................       case 13 : sol_chip_cmd(2); 
1472E:  MOVLW  02
14730:  MOVLB  8
14732:  MOVWF  xB6
14734:  MOVLB  0
14736:  CALL   DBB6
....................                sol_switch_cmd(16); 
1473A:  MOVLB  8
1473C:  CLRF   xB7
1473E:  MOVLW  10
14740:  MOVWF  xB6
14742:  MOVLB  0
14744:  RCALL  144B6
....................          break;  
14746:  MOVLB  8
14748:  BRA    14960
....................       case 14 : sol_chip_cmd(2); 
1474A:  MOVLW  02
1474C:  MOVLB  8
1474E:  MOVWF  xB6
14750:  MOVLB  0
14752:  CALL   DBB6
....................                sol_switch_cmd(32); 
14756:  MOVLB  8
14758:  CLRF   xB7
1475A:  MOVLW  20
1475C:  MOVWF  xB6
1475E:  MOVLB  0
14760:  RCALL  144B6
....................          break;  
14762:  MOVLB  8
14764:  BRA    14960
....................       case 15 : sol_chip_cmd(2); 
14766:  MOVLW  02
14768:  MOVLB  8
1476A:  MOVWF  xB6
1476C:  MOVLB  0
1476E:  CALL   DBB6
....................                sol_switch_cmd(64); 
14772:  MOVLB  8
14774:  CLRF   xB7
14776:  MOVLW  40
14778:  MOVWF  xB6
1477A:  MOVLB  0
1477C:  RCALL  144B6
....................          break;  
1477E:  MOVLB  8
14780:  BRA    14960
....................       case 16 : sol_chip_cmd(2); 
14782:  MOVLW  02
14784:  MOVLB  8
14786:  MOVWF  xB6
14788:  MOVLB  0
1478A:  CALL   DBB6
....................                sol_switch_cmd(128); 
1478E:  MOVLB  8
14790:  CLRF   xB7
14792:  MOVLW  80
14794:  MOVWF  xB6
14796:  MOVLB  0
14798:  RCALL  144B6
....................          break;   
1479A:  MOVLB  8
1479C:  BRA    14960
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
1479E:  MOVLW  03
147A0:  MOVLB  8
147A2:  MOVWF  xB6
147A4:  MOVLB  0
147A6:  CALL   DBB6
....................                sol_switch_cmd(1); 
147AA:  MOVLB  8
147AC:  CLRF   xB7
147AE:  MOVLW  01
147B0:  MOVWF  xB6
147B2:  MOVLB  0
147B4:  RCALL  144B6
....................          break;     
147B6:  MOVLB  8
147B8:  BRA    14960
....................       case 18 : sol_chip_cmd(3); 
147BA:  MOVLW  03
147BC:  MOVLB  8
147BE:  MOVWF  xB6
147C0:  MOVLB  0
147C2:  CALL   DBB6
....................                sol_switch_cmd(2); 
147C6:  MOVLB  8
147C8:  CLRF   xB7
147CA:  MOVLW  02
147CC:  MOVWF  xB6
147CE:  MOVLB  0
147D0:  RCALL  144B6
....................          break;           
147D2:  MOVLB  8
147D4:  BRA    14960
....................       case 19 : sol_chip_cmd(3); 
147D6:  MOVLW  03
147D8:  MOVLB  8
147DA:  MOVWF  xB6
147DC:  MOVLB  0
147DE:  CALL   DBB6
....................                sol_switch_cmd(4); 
147E2:  MOVLB  8
147E4:  CLRF   xB7
147E6:  MOVLW  04
147E8:  MOVWF  xB6
147EA:  MOVLB  0
147EC:  RCALL  144B6
....................          break;  
147EE:  MOVLB  8
147F0:  BRA    14960
....................       case 20 : sol_chip_cmd(3); 
147F2:  MOVLW  03
147F4:  MOVLB  8
147F6:  MOVWF  xB6
147F8:  MOVLB  0
147FA:  CALL   DBB6
....................                sol_switch_cmd(8); 
147FE:  MOVLB  8
14800:  CLRF   xB7
14802:  MOVLW  08
14804:  MOVWF  xB6
14806:  MOVLB  0
14808:  RCALL  144B6
....................          break;  
1480A:  MOVLB  8
1480C:  BRA    14960
....................       case 21 : sol_chip_cmd(3); 
1480E:  MOVLW  03
14810:  MOVLB  8
14812:  MOVWF  xB6
14814:  MOVLB  0
14816:  CALL   DBB6
....................                sol_switch_cmd(16); 
1481A:  MOVLB  8
1481C:  CLRF   xB7
1481E:  MOVLW  10
14820:  MOVWF  xB6
14822:  MOVLB  0
14824:  RCALL  144B6
....................          break;  
14826:  MOVLB  8
14828:  BRA    14960
....................       case 22 : sol_chip_cmd(3); 
1482A:  MOVLW  03
1482C:  MOVLB  8
1482E:  MOVWF  xB6
14830:  MOVLB  0
14832:  CALL   DBB6
....................                sol_switch_cmd(32); 
14836:  MOVLB  8
14838:  CLRF   xB7
1483A:  MOVLW  20
1483C:  MOVWF  xB6
1483E:  MOVLB  0
14840:  RCALL  144B6
....................          break;  
14842:  MOVLB  8
14844:  BRA    14960
....................       case 23 : sol_chip_cmd(3); 
14846:  MOVLW  03
14848:  MOVLB  8
1484A:  MOVWF  xB6
1484C:  MOVLB  0
1484E:  CALL   DBB6
....................                sol_switch_cmd(64); 
14852:  MOVLB  8
14854:  CLRF   xB7
14856:  MOVLW  40
14858:  MOVWF  xB6
1485A:  MOVLB  0
1485C:  RCALL  144B6
....................          break;  
1485E:  MOVLB  8
14860:  BRA    14960
....................       case 24 : sol_chip_cmd(3); 
14862:  MOVLW  03
14864:  MOVLB  8
14866:  MOVWF  xB6
14868:  MOVLB  0
1486A:  CALL   DBB6
....................                sol_switch_cmd(128); 
1486E:  MOVLB  8
14870:  CLRF   xB7
14872:  MOVLW  80
14874:  MOVWF  xB6
14876:  MOVLB  0
14878:  RCALL  144B6
....................          break;      
1487A:  MOVLB  8
1487C:  BRA    14960
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
1487E:  MOVLW  04
14880:  MOVLB  8
14882:  MOVWF  xB6
14884:  MOVLB  0
14886:  CALL   DBB6
....................                sol_switch_cmd(1); 
1488A:  MOVLB  8
1488C:  CLRF   xB7
1488E:  MOVLW  01
14890:  MOVWF  xB6
14892:  MOVLB  0
14894:  RCALL  144B6
....................          break;     
14896:  MOVLB  8
14898:  BRA    14960
....................       case 26 : sol_chip_cmd(4); 
1489A:  MOVLW  04
1489C:  MOVLB  8
1489E:  MOVWF  xB6
148A0:  MOVLB  0
148A2:  CALL   DBB6
....................                sol_switch_cmd(2); 
148A6:  MOVLB  8
148A8:  CLRF   xB7
148AA:  MOVLW  02
148AC:  MOVWF  xB6
148AE:  MOVLB  0
148B0:  RCALL  144B6
....................          break;           
148B2:  MOVLB  8
148B4:  BRA    14960
....................       case 27 : sol_chip_cmd(4); 
148B6:  MOVLW  04
148B8:  MOVLB  8
148BA:  MOVWF  xB6
148BC:  MOVLB  0
148BE:  CALL   DBB6
....................                sol_switch_cmd(4); 
148C2:  MOVLB  8
148C4:  CLRF   xB7
148C6:  MOVLW  04
148C8:  MOVWF  xB6
148CA:  MOVLB  0
148CC:  RCALL  144B6
....................          break;  
148CE:  MOVLB  8
148D0:  BRA    14960
....................       case 28 : sol_chip_cmd(4); 
148D2:  MOVLW  04
148D4:  MOVLB  8
148D6:  MOVWF  xB6
148D8:  MOVLB  0
148DA:  CALL   DBB6
....................                sol_switch_cmd(8); 
148DE:  MOVLB  8
148E0:  CLRF   xB7
148E2:  MOVLW  08
148E4:  MOVWF  xB6
148E6:  MOVLB  0
148E8:  RCALL  144B6
....................          break;  
148EA:  MOVLB  8
148EC:  BRA    14960
....................       case 29 : sol_chip_cmd(4); 
148EE:  MOVLW  04
148F0:  MOVLB  8
148F2:  MOVWF  xB6
148F4:  MOVLB  0
148F6:  CALL   DBB6
....................                sol_switch_cmd(16); 
148FA:  MOVLB  8
148FC:  CLRF   xB7
148FE:  MOVLW  10
14900:  MOVWF  xB6
14902:  MOVLB  0
14904:  RCALL  144B6
....................          break;  
14906:  MOVLB  8
14908:  BRA    14960
....................       case 30 : sol_chip_cmd(4); 
1490A:  MOVLW  04
1490C:  MOVLB  8
1490E:  MOVWF  xB6
14910:  MOVLB  0
14912:  CALL   DBB6
....................                sol_switch_cmd(32); 
14916:  MOVLB  8
14918:  CLRF   xB7
1491A:  MOVLW  20
1491C:  MOVWF  xB6
1491E:  MOVLB  0
14920:  RCALL  144B6
....................          break;  
14922:  MOVLB  8
14924:  BRA    14960
....................       case 31 : sol_chip_cmd(4); 
14926:  MOVLW  04
14928:  MOVLB  8
1492A:  MOVWF  xB6
1492C:  MOVLB  0
1492E:  CALL   DBB6
....................                sol_switch_cmd(64); 
14932:  MOVLB  8
14934:  CLRF   xB7
14936:  MOVLW  40
14938:  MOVWF  xB6
1493A:  MOVLB  0
1493C:  RCALL  144B6
....................          break;  
1493E:  MOVLB  8
14940:  BRA    14960
....................       case 32 : sol_chip_cmd(4); 
14942:  MOVLW  04
14944:  MOVLB  8
14946:  MOVWF  xB6
14948:  MOVLB  0
1494A:  CALL   DBB6
....................                sol_switch_cmd(128); 
1494E:  MOVLB  8
14950:  CLRF   xB7
14952:  MOVLW  80
14954:  MOVWF  xB6
14956:  MOVLB  0
14958:  RCALL  144B6
....................          break; 
1495A:  MOVLB  8
1495C:  BRA    14960
1495E:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
14960:  MOVF   xB5,F
14962:  BZ    1497C
14964:  MOVF   xB5,W
14966:  SUBLW  20
14968:  BNC   1497C
1496A:  CLRF   03
1496C:  MOVF   xB5,W
1496E:  ADDLW  B7
14970:  MOVWF  FE9
14972:  MOVLW  04
14974:  ADDWFC 03,W
14976:  MOVWF  FEA
14978:  MOVLW  01
1497A:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
1497C:  MOVF   1F,W
1497E:  SUBLW  04
14980:  BNZ   1498E
14982:  MOVF   20,F
14984:  BNZ   1498E
14986:  MOVLB  0
14988:  CALL   ED66
1498C:  MOVLB  8
1498E:  MOVLB  0
14990:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
1050A:  MOVLB  8
1050C:  CLRF   x9D
1050E:  MOVF   x9D,W
10510:  SUBLW  07
10512:  BNC   1052E
10514:  BCF    FD8.0
10516:  RLCF   x9D,W
10518:  CLRF   03
1051A:  ADDLW  4B
1051C:  MOVWF  FE9
1051E:  MOVLW  03
10520:  ADDWFC 03,W
10522:  MOVWF  FEA
10524:  CLRF   FEC
10526:  MOVF   FED,F
10528:  CLRF   FEF
1052A:  INCF   x9D,F
1052C:  BRA    1050E
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
1052E:  CLRF   x9D
10530:  MOVF   x9D,W
10532:  SUBLW  07
10534:  BNC   10550
10536:  BCF    FD8.0
10538:  RLCF   x9D,W
1053A:  CLRF   03
1053C:  ADDLW  5D
1053E:  MOVWF  FE9
10540:  MOVLW  03
10542:  ADDWFC 03,W
10544:  MOVWF  FEA
10546:  CLRF   FEC
10548:  MOVF   FED,F
1054A:  CLRF   FEF
1054C:  INCF   x9D,F
1054E:  BRA    10530
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
10550:  CLRF   x9D
10552:  MOVF   x9D,W
10554:  SUBLW  07
10556:  BNC   10572
10558:  BCF    FD8.0
1055A:  RLCF   x9D,W
1055C:  CLRF   03
1055E:  ADDLW  6F
10560:  MOVWF  FE9
10562:  MOVLW  03
10564:  ADDWFC 03,W
10566:  MOVWF  FEA
10568:  CLRF   FEC
1056A:  MOVF   FED,F
1056C:  CLRF   FEF
1056E:  INCF   x9D,F
10570:  BRA    10552
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
10572:  CLRF   x9D
10574:  MOVF   x9D,W
10576:  SUBLW  07
10578:  BNC   10594
1057A:  BCF    FD8.0
1057C:  RLCF   x9D,W
1057E:  CLRF   03
10580:  ADDLW  81
10582:  MOVWF  FE9
10584:  MOVLW  03
10586:  ADDWFC 03,W
10588:  MOVWF  FEA
1058A:  CLRF   FEC
1058C:  MOVF   FED,F
1058E:  CLRF   FEF
10590:  INCF   x9D,F
10592:  BRA    10574
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
10594:  CLRF   x9D
10596:  MOVF   x9D,W
10598:  SUBLW  07
1059A:  BNC   105B6
1059C:  BCF    FD8.0
1059E:  RLCF   x9D,W
105A0:  CLRF   03
105A2:  ADDLW  93
105A4:  MOVWF  FE9
105A6:  MOVLW  03
105A8:  ADDWFC 03,W
105AA:  MOVWF  FEA
105AC:  CLRF   FEC
105AE:  MOVF   FED,F
105B0:  CLRF   FEF
105B2:  INCF   x9D,F
105B4:  BRA    10596
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
105B6:  MOVLW  04
105B8:  MOVWF  FEA
105BA:  MOVLW  25
105BC:  MOVWF  FE9
105BE:  CLRF   00
105C0:  CLRF   02
105C2:  MOVLW  44
105C4:  MOVWF  01
105C6:  MOVLB  0
105C8:  CALL   3526
105CC:  GOTO   153D2 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10E58:  MOVLB  8
10E5A:  CLRF   xC2
10E5C:  MOVF   xC2,W
10E5E:  SUBLW  03
10E60:  BNC   10E80
10E62:  MOVF   xC2,W
10E64:  MULLW  04
10E66:  MOVF   FF3,W
10E68:  CLRF   03
10E6A:  ADDLW  A5
10E6C:  MOVWF  FE9
10E6E:  MOVLW  03
10E70:  ADDWFC 03,W
10E72:  MOVWF  FEA
10E74:  CLRF   FEF
10E76:  CLRF   FEC
10E78:  CLRF   FEC
10E7A:  CLRF   FEC
10E7C:  INCF   xC2,F
10E7E:  BRA    10E5C
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10E80:  MOVLB  3
10E82:  MOVF   x4B,F
10E84:  BTFSS  FD8.2
10E86:  BRA    10E8C
10E88:  MOVF   x4C,F
10E8A:  BZ    10F26
10E8C:  MOVF   x4D,F
10E8E:  BNZ   10E94
10E90:  MOVF   x4E,F
10E92:  BZ    10F26
....................       blank = NO3_array[0]; 
10E94:  MOVFF  34C,918
10E98:  MOVFF  34B,917
10E9C:  MOVLB  0
10E9E:  CALL   C8F6
10EA2:  MOVFF  03,8C6
10EA6:  MOVFF  02,8C5
10EAA:  MOVFF  01,8C4
10EAE:  MOVFF  00,8C3
....................       react = NO3_array[1]; 
10EB2:  MOVFF  34E,918
10EB6:  MOVFF  34D,917
10EBA:  CALL   C8F6
10EBE:  MOVFF  03,8CA
10EC2:  MOVFF  02,8C9
10EC6:  MOVFF  01,8C8
10ECA:  MOVFF  00,8C7
....................       ratio = blank / react; 
10ECE:  MOVFF  8C6,8FE
10ED2:  MOVFF  8C5,8FD
10ED6:  MOVFF  8C4,8FC
10EDA:  MOVFF  8C3,8FB
10EDE:  MOVFF  8CA,902
10EE2:  MOVFF  8C9,901
10EE6:  MOVFF  8C8,900
10EEA:  MOVFF  8C7,8FF
10EEE:  CALL   C92C
10EF2:  MOVFF  03,8CE
10EF6:  MOVFF  02,8CD
10EFA:  MOVFF  01,8CC
10EFE:  MOVFF  00,8CB
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10F02:  MOVFF  8CE,8D2
10F06:  MOVFF  8CD,8D1
10F0A:  MOVFF  8CC,8D0
10F0E:  MOVFF  8CB,8CF
10F12:  RCALL  10BD6
10F14:  MOVFF  03,3A8
10F18:  MOVFF  02,3A7
10F1C:  MOVFF  01,3A6
10F20:  MOVFF  00,3A5
10F24:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10F26:  MOVF   x4F,F
10F28:  BNZ   10F2E
10F2A:  MOVF   x50,F
10F2C:  BZ    10FC8
10F2E:  MOVF   x51,F
10F30:  BNZ   10F36
10F32:  MOVF   x52,F
10F34:  BZ    10FC8
....................       blank = NO3_array[2]; 
10F36:  MOVFF  350,918
10F3A:  MOVFF  34F,917
10F3E:  MOVLB  0
10F40:  CALL   C8F6
10F44:  MOVFF  03,8C6
10F48:  MOVFF  02,8C5
10F4C:  MOVFF  01,8C4
10F50:  MOVFF  00,8C3
....................       react = NO3_array[3]; 
10F54:  MOVFF  352,918
10F58:  MOVFF  351,917
10F5C:  CALL   C8F6
10F60:  MOVFF  03,8CA
10F64:  MOVFF  02,8C9
10F68:  MOVFF  01,8C8
10F6C:  MOVFF  00,8C7
....................       ratio = blank / react;    
10F70:  MOVFF  8C6,8FE
10F74:  MOVFF  8C5,8FD
10F78:  MOVFF  8C4,8FC
10F7C:  MOVFF  8C3,8FB
10F80:  MOVFF  8CA,902
10F84:  MOVFF  8C9,901
10F88:  MOVFF  8C8,900
10F8C:  MOVFF  8C7,8FF
10F90:  CALL   C92C
10F94:  MOVFF  03,8CE
10F98:  MOVFF  02,8CD
10F9C:  MOVFF  01,8CC
10FA0:  MOVFF  00,8CB
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10FA4:  MOVFF  8CE,8D2
10FA8:  MOVFF  8CD,8D1
10FAC:  MOVFF  8CC,8D0
10FB0:  MOVFF  8CB,8CF
10FB4:  RCALL  10BD6
10FB6:  MOVFF  03,3AC
10FBA:  MOVFF  02,3AB
10FBE:  MOVFF  01,3AA
10FC2:  MOVFF  00,3A9
10FC6:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10FC8:  MOVF   x53,F
10FCA:  BNZ   10FD0
10FCC:  MOVF   x54,F
10FCE:  BZ    1106A
10FD0:  MOVF   x55,F
10FD2:  BNZ   10FD8
10FD4:  MOVF   x56,F
10FD6:  BZ    1106A
....................       blank = NO3_array[4]; 
10FD8:  MOVFF  354,918
10FDC:  MOVFF  353,917
10FE0:  MOVLB  0
10FE2:  CALL   C8F6
10FE6:  MOVFF  03,8C6
10FEA:  MOVFF  02,8C5
10FEE:  MOVFF  01,8C4
10FF2:  MOVFF  00,8C3
....................       react = NO3_array[5]; 
10FF6:  MOVFF  356,918
10FFA:  MOVFF  355,917
10FFE:  CALL   C8F6
11002:  MOVFF  03,8CA
11006:  MOVFF  02,8C9
1100A:  MOVFF  01,8C8
1100E:  MOVFF  00,8C7
....................       ratio = blank / react; 
11012:  MOVFF  8C6,8FE
11016:  MOVFF  8C5,8FD
1101A:  MOVFF  8C4,8FC
1101E:  MOVFF  8C3,8FB
11022:  MOVFF  8CA,902
11026:  MOVFF  8C9,901
1102A:  MOVFF  8C8,900
1102E:  MOVFF  8C7,8FF
11032:  CALL   C92C
11036:  MOVFF  03,8CE
1103A:  MOVFF  02,8CD
1103E:  MOVFF  01,8CC
11042:  MOVFF  00,8CB
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
11046:  MOVFF  8CE,8D2
1104A:  MOVFF  8CD,8D1
1104E:  MOVFF  8CC,8D0
11052:  MOVFF  8CB,8CF
11056:  RCALL  10BD6
11058:  MOVFF  03,3B0
1105C:  MOVFF  02,3AF
11060:  MOVFF  01,3AE
11064:  MOVFF  00,3AD
11068:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
1106A:  MOVF   x57,F
1106C:  BNZ   11072
1106E:  MOVF   x58,F
11070:  BZ    1110C
11072:  MOVF   x59,F
11074:  BNZ   1107A
11076:  MOVF   x5A,F
11078:  BZ    1110C
....................       blank = NO3_array[6]; 
1107A:  MOVFF  358,918
1107E:  MOVFF  357,917
11082:  MOVLB  0
11084:  CALL   C8F6
11088:  MOVFF  03,8C6
1108C:  MOVFF  02,8C5
11090:  MOVFF  01,8C4
11094:  MOVFF  00,8C3
....................       react = NO3_array[7]; 
11098:  MOVFF  35A,918
1109C:  MOVFF  359,917
110A0:  CALL   C8F6
110A4:  MOVFF  03,8CA
110A8:  MOVFF  02,8C9
110AC:  MOVFF  01,8C8
110B0:  MOVFF  00,8C7
....................       ratio = blank / react; 
110B4:  MOVFF  8C6,8FE
110B8:  MOVFF  8C5,8FD
110BC:  MOVFF  8C4,8FC
110C0:  MOVFF  8C3,8FB
110C4:  MOVFF  8CA,902
110C8:  MOVFF  8C9,901
110CC:  MOVFF  8C8,900
110D0:  MOVFF  8C7,8FF
110D4:  CALL   C92C
110D8:  MOVFF  03,8CE
110DC:  MOVFF  02,8CD
110E0:  MOVFF  01,8CC
110E4:  MOVFF  00,8CB
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
110E8:  MOVFF  8CE,8D2
110EC:  MOVFF  8CD,8D1
110F0:  MOVFF  8CC,8D0
110F4:  MOVFF  8CB,8CF
110F8:  RCALL  10BD6
110FA:  MOVFF  03,3B4
110FE:  MOVFF  02,3B3
11102:  MOVFF  01,3B2
11106:  MOVFF  00,3B1
1110A:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
1110C:  MOVLW  04
1110E:  MOVWF  1E
11110:  MOVLW  25
11112:  MOVWF  1D
11114:  MOVLW  9E
11116:  MOVWF  FF6
11118:  MOVLW  1D
1111A:  MOVWF  FF7
1111C:  MOVLW  00
1111E:  MOVWF  FF8
11120:  MOVLW  06
11122:  MOVLB  8
11124:  MOVWF  xEB
11126:  MOVLB  0
11128:  CALL   AACC
1112C:  MOVLW  10
1112E:  MOVWF  FE9
11130:  MOVFF  34C,8F7
11134:  MOVFF  34B,8F6
11138:  CALL   AAFE
1113C:  MOVLW  A7
1113E:  MOVWF  FF6
11140:  MOVLW  1D
11142:  MOVWF  FF7
11144:  MOVLW  00
11146:  MOVWF  FF8
11148:  MOVLW  07
1114A:  MOVLB  8
1114C:  MOVWF  xEB
1114E:  MOVLB  0
11150:  CALL   AACC
11154:  MOVLW  10
11156:  MOVWF  FE9
11158:  MOVFF  34E,8F7
1115C:  MOVFF  34D,8F6
11160:  CALL   AAFE
11164:  MOVLW  B1
11166:  MOVWF  FF6
11168:  MOVLW  1D
1116A:  MOVWF  FF7
1116C:  MOVLW  00
1116E:  MOVWF  FF8
11170:  MOVLW  09
11172:  MOVLB  8
11174:  MOVWF  xEB
11176:  MOVLB  0
11178:  CALL   AACC
1117C:  MOVLW  89
1117E:  MOVWF  FE9
11180:  MOVFF  3A8,8D2
11184:  MOVFF  3A7,8D1
11188:  MOVFF  3A6,8D0
1118C:  MOVFF  3A5,8CF
11190:  MOVLW  04
11192:  MOVLB  8
11194:  MOVWF  xD3
11196:  MOVLB  0
11198:  RCALL  10C42
1119A:  MOVLW  BF
1119C:  MOVWF  FF6
1119E:  MOVLW  1D
111A0:  MOVWF  FF7
111A2:  MOVLW  00
111A4:  MOVWF  FF8
111A6:  MOVLW  07
111A8:  MOVLB  8
111AA:  MOVWF  xEB
111AC:  MOVLB  0
111AE:  CALL   AACC
111B2:  MOVLW  10
111B4:  MOVWF  FE9
111B6:  MOVFF  350,8F7
111BA:  MOVFF  34F,8F6
111BE:  CALL   AAFE
111C2:  MOVLW  C9
111C4:  MOVWF  FF6
111C6:  MOVLW  1D
111C8:  MOVWF  FF7
111CA:  MOVLW  00
111CC:  MOVWF  FF8
111CE:  MOVLW  07
111D0:  MOVLB  8
111D2:  MOVWF  xEB
111D4:  MOVLB  0
111D6:  CALL   AACC
111DA:  MOVLW  10
111DC:  MOVWF  FE9
111DE:  MOVFF  352,8F7
111E2:  MOVFF  351,8F6
111E6:  CALL   AAFE
111EA:  MOVLW  D3
111EC:  MOVWF  FF6
111EE:  MOVLW  1D
111F0:  MOVWF  FF7
111F2:  MOVLW  00
111F4:  MOVWF  FF8
111F6:  MOVLW  09
111F8:  MOVLB  8
111FA:  MOVWF  xEB
111FC:  MOVLB  0
111FE:  CALL   AACC
11202:  MOVLW  89
11204:  MOVWF  FE9
11206:  MOVFF  3AC,8D2
1120A:  MOVFF  3AB,8D1
1120E:  MOVFF  3AA,8D0
11212:  MOVFF  3A9,8CF
11216:  MOVLW  04
11218:  MOVLB  8
1121A:  MOVWF  xD3
1121C:  MOVLB  0
1121E:  RCALL  10C42
11220:  MOVLW  E1
11222:  MOVWF  FF6
11224:  MOVLW  1D
11226:  MOVWF  FF7
11228:  MOVLW  00
1122A:  MOVWF  FF8
1122C:  MOVLW  07
1122E:  MOVLB  8
11230:  MOVWF  xEB
11232:  MOVLB  0
11234:  CALL   AACC
11238:  MOVLW  10
1123A:  MOVWF  FE9
1123C:  MOVFF  354,8F7
11240:  MOVFF  353,8F6
11244:  CALL   AAFE
11248:  MOVLW  EB
1124A:  MOVWF  FF6
1124C:  MOVLW  1D
1124E:  MOVWF  FF7
11250:  MOVLW  00
11252:  MOVWF  FF8
11254:  MOVLW  07
11256:  MOVLB  8
11258:  MOVWF  xEB
1125A:  MOVLB  0
1125C:  CALL   AACC
11260:  MOVLW  10
11262:  MOVWF  FE9
11264:  MOVFF  356,8F7
11268:  MOVFF  355,8F6
1126C:  CALL   AAFE
11270:  MOVLW  F5
11272:  MOVWF  FF6
11274:  MOVLW  1D
11276:  MOVWF  FF7
11278:  MOVLW  00
1127A:  MOVWF  FF8
1127C:  MOVLW  09
1127E:  MOVLB  8
11280:  MOVWF  xEB
11282:  MOVLB  0
11284:  CALL   AACC
11288:  MOVLW  89
1128A:  MOVWF  FE9
1128C:  MOVFF  3B0,8D2
11290:  MOVFF  3AF,8D1
11294:  MOVFF  3AE,8D0
11298:  MOVFF  3AD,8CF
1129C:  MOVLW  04
1129E:  MOVLB  8
112A0:  MOVWF  xD3
112A2:  MOVLB  0
112A4:  RCALL  10C42
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
112A6:  MOVF   1F,W
112A8:  SUBLW  02
112AA:  BNZ   112B0
112AC:  MOVF   20,F
112AE:  BZ    112F0
112B0:  MOVLW  04
112B2:  MOVWF  FF6
112B4:  MOVLW  1E
112B6:  MOVWF  FF7
112B8:  MOVLW  00
112BA:  MOVWF  FF8
112BC:  CLRF   1B
112BE:  BTFSC  FF2.7
112C0:  BSF    1B.7
112C2:  BCF    FF2.7
112C4:  MOVLW  09
112C6:  MOVLB  A
112C8:  MOVWF  x40
112CA:  MOVLB  0
112CC:  CALL   101C
112D0:  BTFSC  1B.7
112D2:  BSF    FF2.7
112D4:  MOVLW  04
112D6:  MOVWF  FEA
112D8:  MOVLW  25
112DA:  MOVWF  FE9
112DC:  CALL   7996
112E0:  MOVLW  0D
112E2:  BTFSS  F9E.4
112E4:  BRA    112E2
112E6:  MOVWF  FAD
112E8:  MOVLW  0A
112EA:  BTFSS  F9E.4
112EC:  BRA    112EA
112EE:  MOVWF  FAD
112F0:  GOTO   125FC (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
112F4:  MOVLB  8
112F6:  CLRF   xC2
112F8:  MOVF   xC2,W
112FA:  SUBLW  03
112FC:  BNC   1131C
112FE:  MOVF   xC2,W
11300:  MULLW  04
11302:  MOVF   FF3,W
11304:  CLRF   03
11306:  ADDLW  B5
11308:  MOVWF  FE9
1130A:  MOVLW  03
1130C:  ADDWFC 03,W
1130E:  MOVWF  FEA
11310:  CLRF   FEF
11312:  CLRF   FEC
11314:  CLRF   FEC
11316:  CLRF   FEC
11318:  INCF   xC2,F
1131A:  BRA    112F8
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
1131C:  MOVLB  3
1131E:  MOVF   x5D,F
11320:  BTFSS  FD8.2
11322:  BRA    11328
11324:  MOVF   x5E,F
11326:  BZ    113C2
11328:  MOVF   x5F,F
1132A:  BNZ   11330
1132C:  MOVF   x60,F
1132E:  BZ    113C2
....................       blank = NO2_array[0]; 
11330:  MOVFF  35E,918
11334:  MOVFF  35D,917
11338:  MOVLB  0
1133A:  CALL   C8F6
1133E:  MOVFF  03,8C6
11342:  MOVFF  02,8C5
11346:  MOVFF  01,8C4
1134A:  MOVFF  00,8C3
....................       react = NO2_array[1]; 
1134E:  MOVFF  360,918
11352:  MOVFF  35F,917
11356:  CALL   C8F6
1135A:  MOVFF  03,8CA
1135E:  MOVFF  02,8C9
11362:  MOVFF  01,8C8
11366:  MOVFF  00,8C7
....................       ratio = blank / react; 
1136A:  MOVFF  8C6,8FE
1136E:  MOVFF  8C5,8FD
11372:  MOVFF  8C4,8FC
11376:  MOVFF  8C3,8FB
1137A:  MOVFF  8CA,902
1137E:  MOVFF  8C9,901
11382:  MOVFF  8C8,900
11386:  MOVFF  8C7,8FF
1138A:  CALL   C92C
1138E:  MOVFF  03,8CE
11392:  MOVFF  02,8CD
11396:  MOVFF  01,8CC
1139A:  MOVFF  00,8CB
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
1139E:  MOVFF  8CE,8D2
113A2:  MOVFF  8CD,8D1
113A6:  MOVFF  8CC,8D0
113AA:  MOVFF  8CB,8CF
113AE:  RCALL  10BD6
113B0:  MOVFF  03,3B8
113B4:  MOVFF  02,3B7
113B8:  MOVFF  01,3B6
113BC:  MOVFF  00,3B5
113C0:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
113C2:  MOVF   x61,F
113C4:  BNZ   113CA
113C6:  MOVF   x62,F
113C8:  BZ    11466
113CA:  MOVF   x63,F
113CC:  BNZ   113D2
113CE:  MOVF   x64,F
113D0:  BZ    11466
....................       blank = NO2_array[2]; 
113D2:  MOVFF  362,918
113D6:  MOVFF  361,917
113DA:  MOVLB  0
113DC:  CALL   C8F6
113E0:  MOVFF  03,8C6
113E4:  MOVFF  02,8C5
113E8:  MOVFF  01,8C4
113EC:  MOVFF  00,8C3
....................       react = NO2_array[3]; 
113F0:  MOVFF  364,918
113F4:  MOVFF  363,917
113F8:  CALL   C8F6
113FC:  MOVFF  03,8CA
11400:  MOVFF  02,8C9
11404:  MOVFF  01,8C8
11408:  MOVFF  00,8C7
....................       ratio = blank / react;    
1140C:  MOVFF  8C6,8FE
11410:  MOVFF  8C5,8FD
11414:  MOVFF  8C4,8FC
11418:  MOVFF  8C3,8FB
1141C:  MOVFF  8CA,902
11420:  MOVFF  8C9,901
11424:  MOVFF  8C8,900
11428:  MOVFF  8C7,8FF
1142C:  CALL   C92C
11430:  MOVFF  03,8CE
11434:  MOVFF  02,8CD
11438:  MOVFF  01,8CC
1143C:  MOVFF  00,8CB
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
11440:  MOVFF  8CE,8D2
11444:  MOVFF  8CD,8D1
11448:  MOVFF  8CC,8D0
1144C:  MOVFF  8CB,8CF
11450:  CALL   10BD6
11454:  MOVFF  03,3BC
11458:  MOVFF  02,3BB
1145C:  MOVFF  01,3BA
11460:  MOVFF  00,3B9
11464:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
11466:  MOVF   x65,F
11468:  BNZ   1146E
1146A:  MOVF   x66,F
1146C:  BZ    1150A
1146E:  MOVF   x67,F
11470:  BNZ   11476
11472:  MOVF   x68,F
11474:  BZ    1150A
....................       blank = NO2_array[4]; 
11476:  MOVFF  366,918
1147A:  MOVFF  365,917
1147E:  MOVLB  0
11480:  CALL   C8F6
11484:  MOVFF  03,8C6
11488:  MOVFF  02,8C5
1148C:  MOVFF  01,8C4
11490:  MOVFF  00,8C3
....................       react = NO2_array[5]; 
11494:  MOVFF  368,918
11498:  MOVFF  367,917
1149C:  CALL   C8F6
114A0:  MOVFF  03,8CA
114A4:  MOVFF  02,8C9
114A8:  MOVFF  01,8C8
114AC:  MOVFF  00,8C7
....................       ratio = blank / react; 
114B0:  MOVFF  8C6,8FE
114B4:  MOVFF  8C5,8FD
114B8:  MOVFF  8C4,8FC
114BC:  MOVFF  8C3,8FB
114C0:  MOVFF  8CA,902
114C4:  MOVFF  8C9,901
114C8:  MOVFF  8C8,900
114CC:  MOVFF  8C7,8FF
114D0:  CALL   C92C
114D4:  MOVFF  03,8CE
114D8:  MOVFF  02,8CD
114DC:  MOVFF  01,8CC
114E0:  MOVFF  00,8CB
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
114E4:  MOVFF  8CE,8D2
114E8:  MOVFF  8CD,8D1
114EC:  MOVFF  8CC,8D0
114F0:  MOVFF  8CB,8CF
114F4:  CALL   10BD6
114F8:  MOVFF  03,3C0
114FC:  MOVFF  02,3BF
11500:  MOVFF  01,3BE
11504:  MOVFF  00,3BD
11508:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
1150A:  MOVF   x69,F
1150C:  BNZ   11512
1150E:  MOVF   x6A,F
11510:  BZ    115AE
11512:  MOVF   x6B,F
11514:  BNZ   1151A
11516:  MOVF   x6C,F
11518:  BZ    115AE
....................       blank = NO2_array[6]; 
1151A:  MOVFF  36A,918
1151E:  MOVFF  369,917
11522:  MOVLB  0
11524:  CALL   C8F6
11528:  MOVFF  03,8C6
1152C:  MOVFF  02,8C5
11530:  MOVFF  01,8C4
11534:  MOVFF  00,8C3
....................       react = NO2_array[7]; 
11538:  MOVFF  36C,918
1153C:  MOVFF  36B,917
11540:  CALL   C8F6
11544:  MOVFF  03,8CA
11548:  MOVFF  02,8C9
1154C:  MOVFF  01,8C8
11550:  MOVFF  00,8C7
....................       ratio = blank / react; 
11554:  MOVFF  8C6,8FE
11558:  MOVFF  8C5,8FD
1155C:  MOVFF  8C4,8FC
11560:  MOVFF  8C3,8FB
11564:  MOVFF  8CA,902
11568:  MOVFF  8C9,901
1156C:  MOVFF  8C8,900
11570:  MOVFF  8C7,8FF
11574:  CALL   C92C
11578:  MOVFF  03,8CE
1157C:  MOVFF  02,8CD
11580:  MOVFF  01,8CC
11584:  MOVFF  00,8CB
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
11588:  MOVFF  8CE,8D2
1158C:  MOVFF  8CD,8D1
11590:  MOVFF  8CC,8D0
11594:  MOVFF  8CB,8CF
11598:  CALL   10BD6
1159C:  MOVFF  03,3C4
115A0:  MOVFF  02,3C3
115A4:  MOVFF  01,3C2
115A8:  MOVFF  00,3C1
115AC:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
115AE:  MOVLW  04
115B0:  MOVWF  1E
115B2:  MOVLW  25
115B4:  MOVWF  1D
115B6:  MOVLW  12
115B8:  MOVWF  FF6
115BA:  MOVLW  1E
115BC:  MOVWF  FF7
115BE:  MOVLW  00
115C0:  MOVWF  FF8
115C2:  MOVLW  06
115C4:  MOVLB  8
115C6:  MOVWF  xEB
115C8:  MOVLB  0
115CA:  CALL   AACC
115CE:  MOVLW  10
115D0:  MOVWF  FE9
115D2:  MOVFF  35E,8F7
115D6:  MOVFF  35D,8F6
115DA:  CALL   AAFE
115DE:  MOVLW  1B
115E0:  MOVWF  FF6
115E2:  MOVLW  1E
115E4:  MOVWF  FF7
115E6:  MOVLW  00
115E8:  MOVWF  FF8
115EA:  MOVLW  07
115EC:  MOVLB  8
115EE:  MOVWF  xEB
115F0:  MOVLB  0
115F2:  CALL   AACC
115F6:  MOVLW  10
115F8:  MOVWF  FE9
115FA:  MOVFF  360,8F7
115FE:  MOVFF  35F,8F6
11602:  CALL   AAFE
11606:  MOVLW  25
11608:  MOVWF  FF6
1160A:  MOVLW  1E
1160C:  MOVWF  FF7
1160E:  MOVLW  00
11610:  MOVWF  FF8
11612:  MOVLW  09
11614:  MOVLB  8
11616:  MOVWF  xEB
11618:  MOVLB  0
1161A:  CALL   AACC
1161E:  MOVLW  89
11620:  MOVWF  FE9
11622:  MOVFF  3B8,8D2
11626:  MOVFF  3B7,8D1
1162A:  MOVFF  3B6,8D0
1162E:  MOVFF  3B5,8CF
11632:  MOVLW  04
11634:  MOVLB  8
11636:  MOVWF  xD3
11638:  MOVLB  0
1163A:  CALL   10C42
1163E:  MOVLW  33
11640:  MOVWF  FF6
11642:  MOVLW  1E
11644:  MOVWF  FF7
11646:  MOVLW  00
11648:  MOVWF  FF8
1164A:  MOVLW  07
1164C:  MOVLB  8
1164E:  MOVWF  xEB
11650:  MOVLB  0
11652:  CALL   AACC
11656:  MOVLW  10
11658:  MOVWF  FE9
1165A:  MOVFF  362,8F7
1165E:  MOVFF  361,8F6
11662:  CALL   AAFE
11666:  MOVLW  3D
11668:  MOVWF  FF6
1166A:  MOVLW  1E
1166C:  MOVWF  FF7
1166E:  MOVLW  00
11670:  MOVWF  FF8
11672:  MOVLW  07
11674:  MOVLB  8
11676:  MOVWF  xEB
11678:  MOVLB  0
1167A:  CALL   AACC
1167E:  MOVLW  10
11680:  MOVWF  FE9
11682:  MOVFF  364,8F7
11686:  MOVFF  363,8F6
1168A:  CALL   AAFE
1168E:  MOVLW  47
11690:  MOVWF  FF6
11692:  MOVLW  1E
11694:  MOVWF  FF7
11696:  MOVLW  00
11698:  MOVWF  FF8
1169A:  MOVLW  09
1169C:  MOVLB  8
1169E:  MOVWF  xEB
116A0:  MOVLB  0
116A2:  CALL   AACC
116A6:  MOVLW  89
116A8:  MOVWF  FE9
116AA:  MOVFF  3BC,8D2
116AE:  MOVFF  3BB,8D1
116B2:  MOVFF  3BA,8D0
116B6:  MOVFF  3B9,8CF
116BA:  MOVLW  04
116BC:  MOVLB  8
116BE:  MOVWF  xD3
116C0:  MOVLB  0
116C2:  CALL   10C42
116C6:  MOVLW  55
116C8:  MOVWF  FF6
116CA:  MOVLW  1E
116CC:  MOVWF  FF7
116CE:  MOVLW  00
116D0:  MOVWF  FF8
116D2:  MOVLW  07
116D4:  MOVLB  8
116D6:  MOVWF  xEB
116D8:  MOVLB  0
116DA:  CALL   AACC
116DE:  MOVLW  10
116E0:  MOVWF  FE9
116E2:  MOVFF  366,8F7
116E6:  MOVFF  365,8F6
116EA:  CALL   AAFE
116EE:  MOVLW  5F
116F0:  MOVWF  FF6
116F2:  MOVLW  1E
116F4:  MOVWF  FF7
116F6:  MOVLW  00
116F8:  MOVWF  FF8
116FA:  MOVLW  07
116FC:  MOVLB  8
116FE:  MOVWF  xEB
11700:  MOVLB  0
11702:  CALL   AACC
11706:  MOVLW  10
11708:  MOVWF  FE9
1170A:  MOVFF  368,8F7
1170E:  MOVFF  367,8F6
11712:  CALL   AAFE
11716:  MOVLW  69
11718:  MOVWF  FF6
1171A:  MOVLW  1E
1171C:  MOVWF  FF7
1171E:  MOVLW  00
11720:  MOVWF  FF8
11722:  MOVLW  09
11724:  MOVLB  8
11726:  MOVWF  xEB
11728:  MOVLB  0
1172A:  CALL   AACC
1172E:  MOVLW  89
11730:  MOVWF  FE9
11732:  MOVFF  3C0,8D2
11736:  MOVFF  3BF,8D1
1173A:  MOVFF  3BE,8D0
1173E:  MOVFF  3BD,8CF
11742:  MOVLW  04
11744:  MOVLB  8
11746:  MOVWF  xD3
11748:  MOVLB  0
1174A:  CALL   10C42
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
1174E:  MOVF   1F,W
11750:  SUBLW  02
11752:  BNZ   11758
11754:  MOVF   20,F
11756:  BZ    11798
11758:  MOVLW  78
1175A:  MOVWF  FF6
1175C:  MOVLW  1E
1175E:  MOVWF  FF7
11760:  MOVLW  00
11762:  MOVWF  FF8
11764:  CLRF   1B
11766:  BTFSC  FF2.7
11768:  BSF    1B.7
1176A:  BCF    FF2.7
1176C:  MOVLW  09
1176E:  MOVLB  A
11770:  MOVWF  x40
11772:  MOVLB  0
11774:  CALL   101C
11778:  BTFSC  1B.7
1177A:  BSF    FF2.7
1177C:  MOVLW  04
1177E:  MOVWF  FEA
11780:  MOVLW  25
11782:  MOVWF  FE9
11784:  CALL   7996
11788:  MOVLW  0D
1178A:  BTFSS  F9E.4
1178C:  BRA    1178A
1178E:  MOVWF  FAD
11790:  MOVLW  0A
11792:  BTFSS  F9E.4
11794:  BRA    11792
11796:  MOVWF  FAD
11798:  GOTO   125FC (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
1179C:  MOVLB  8
1179E:  CLRF   xC2
117A0:  MOVF   xC2,W
117A2:  SUBLW  03
117A4:  BNC   117C4
117A6:  MOVF   xC2,W
117A8:  MULLW  04
117AA:  MOVF   FF3,W
117AC:  CLRF   03
117AE:  ADDLW  C5
117B0:  MOVWF  FE9
117B2:  MOVLW  03
117B4:  ADDWFC 03,W
117B6:  MOVWF  FEA
117B8:  CLRF   FEF
117BA:  CLRF   FEC
117BC:  CLRF   FEC
117BE:  CLRF   FEC
117C0:  INCF   xC2,F
117C2:  BRA    117A0
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
117C4:  MOVLB  3
117C6:  MOVF   x6F,F
117C8:  BTFSS  FD8.2
117CA:  BRA    117D0
117CC:  MOVF   x70,F
117CE:  BZ    1186C
117D0:  MOVF   x71,F
117D2:  BNZ   117D8
117D4:  MOVF   x72,F
117D6:  BZ    1186C
....................       blank = PO4_array[0]; 
117D8:  MOVFF  370,918
117DC:  MOVFF  36F,917
117E0:  MOVLB  0
117E2:  CALL   C8F6
117E6:  MOVFF  03,8C6
117EA:  MOVFF  02,8C5
117EE:  MOVFF  01,8C4
117F2:  MOVFF  00,8C3
....................       react = PO4_array[1]; 
117F6:  MOVFF  372,918
117FA:  MOVFF  371,917
117FE:  CALL   C8F6
11802:  MOVFF  03,8CA
11806:  MOVFF  02,8C9
1180A:  MOVFF  01,8C8
1180E:  MOVFF  00,8C7
....................       ratio = blank / react; 
11812:  MOVFF  8C6,8FE
11816:  MOVFF  8C5,8FD
1181A:  MOVFF  8C4,8FC
1181E:  MOVFF  8C3,8FB
11822:  MOVFF  8CA,902
11826:  MOVFF  8C9,901
1182A:  MOVFF  8C8,900
1182E:  MOVFF  8C7,8FF
11832:  CALL   C92C
11836:  MOVFF  03,8CE
1183A:  MOVFF  02,8CD
1183E:  MOVFF  01,8CC
11842:  MOVFF  00,8CB
....................       PO4_abs_array[0] = log10(ratio); 
11846:  MOVFF  8CE,8D2
1184A:  MOVFF  8CD,8D1
1184E:  MOVFF  8CC,8D0
11852:  MOVFF  8CB,8CF
11856:  CALL   10BD6
1185A:  MOVFF  03,3C8
1185E:  MOVFF  02,3C7
11862:  MOVFF  01,3C6
11866:  MOVFF  00,3C5
1186A:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
1186C:  MOVF   x73,F
1186E:  BNZ   11874
11870:  MOVF   x74,F
11872:  BZ    11910
11874:  MOVF   x75,F
11876:  BNZ   1187C
11878:  MOVF   x76,F
1187A:  BZ    11910
....................       blank = PO4_array[2]; 
1187C:  MOVFF  374,918
11880:  MOVFF  373,917
11884:  MOVLB  0
11886:  CALL   C8F6
1188A:  MOVFF  03,8C6
1188E:  MOVFF  02,8C5
11892:  MOVFF  01,8C4
11896:  MOVFF  00,8C3
....................       react = PO4_array[3]; 
1189A:  MOVFF  376,918
1189E:  MOVFF  375,917
118A2:  CALL   C8F6
118A6:  MOVFF  03,8CA
118AA:  MOVFF  02,8C9
118AE:  MOVFF  01,8C8
118B2:  MOVFF  00,8C7
....................       ratio = blank / react;    
118B6:  MOVFF  8C6,8FE
118BA:  MOVFF  8C5,8FD
118BE:  MOVFF  8C4,8FC
118C2:  MOVFF  8C3,8FB
118C6:  MOVFF  8CA,902
118CA:  MOVFF  8C9,901
118CE:  MOVFF  8C8,900
118D2:  MOVFF  8C7,8FF
118D6:  CALL   C92C
118DA:  MOVFF  03,8CE
118DE:  MOVFF  02,8CD
118E2:  MOVFF  01,8CC
118E6:  MOVFF  00,8CB
....................       PO4_abs_array[1] = log10(ratio); 
118EA:  MOVFF  8CE,8D2
118EE:  MOVFF  8CD,8D1
118F2:  MOVFF  8CC,8D0
118F6:  MOVFF  8CB,8CF
118FA:  CALL   10BD6
118FE:  MOVFF  03,3CC
11902:  MOVFF  02,3CB
11906:  MOVFF  01,3CA
1190A:  MOVFF  00,3C9
1190E:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
11910:  MOVF   x77,F
11912:  BNZ   11918
11914:  MOVF   x78,F
11916:  BZ    119B4
11918:  MOVF   x79,F
1191A:  BNZ   11920
1191C:  MOVF   x7A,F
1191E:  BZ    119B4
....................       blank = PO4_array[4]; 
11920:  MOVFF  378,918
11924:  MOVFF  377,917
11928:  MOVLB  0
1192A:  CALL   C8F6
1192E:  MOVFF  03,8C6
11932:  MOVFF  02,8C5
11936:  MOVFF  01,8C4
1193A:  MOVFF  00,8C3
....................       react = PO4_array[5]; 
1193E:  MOVFF  37A,918
11942:  MOVFF  379,917
11946:  CALL   C8F6
1194A:  MOVFF  03,8CA
1194E:  MOVFF  02,8C9
11952:  MOVFF  01,8C8
11956:  MOVFF  00,8C7
....................       ratio = blank / react; 
1195A:  MOVFF  8C6,8FE
1195E:  MOVFF  8C5,8FD
11962:  MOVFF  8C4,8FC
11966:  MOVFF  8C3,8FB
1196A:  MOVFF  8CA,902
1196E:  MOVFF  8C9,901
11972:  MOVFF  8C8,900
11976:  MOVFF  8C7,8FF
1197A:  CALL   C92C
1197E:  MOVFF  03,8CE
11982:  MOVFF  02,8CD
11986:  MOVFF  01,8CC
1198A:  MOVFF  00,8CB
....................       PO4_abs_array[2] = log10(ratio); 
1198E:  MOVFF  8CE,8D2
11992:  MOVFF  8CD,8D1
11996:  MOVFF  8CC,8D0
1199A:  MOVFF  8CB,8CF
1199E:  CALL   10BD6
119A2:  MOVFF  03,3D0
119A6:  MOVFF  02,3CF
119AA:  MOVFF  01,3CE
119AE:  MOVFF  00,3CD
119B2:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
119B4:  MOVF   x7B,F
119B6:  BNZ   119BC
119B8:  MOVF   x7C,F
119BA:  BZ    11A58
119BC:  MOVF   x7D,F
119BE:  BNZ   119C4
119C0:  MOVF   x7E,F
119C2:  BZ    11A58
....................       blank = PO4_array[6]; 
119C4:  MOVFF  37C,918
119C8:  MOVFF  37B,917
119CC:  MOVLB  0
119CE:  CALL   C8F6
119D2:  MOVFF  03,8C6
119D6:  MOVFF  02,8C5
119DA:  MOVFF  01,8C4
119DE:  MOVFF  00,8C3
....................       react = PO4_array[7]; 
119E2:  MOVFF  37E,918
119E6:  MOVFF  37D,917
119EA:  CALL   C8F6
119EE:  MOVFF  03,8CA
119F2:  MOVFF  02,8C9
119F6:  MOVFF  01,8C8
119FA:  MOVFF  00,8C7
....................       ratio = blank / react; 
119FE:  MOVFF  8C6,8FE
11A02:  MOVFF  8C5,8FD
11A06:  MOVFF  8C4,8FC
11A0A:  MOVFF  8C3,8FB
11A0E:  MOVFF  8CA,902
11A12:  MOVFF  8C9,901
11A16:  MOVFF  8C8,900
11A1A:  MOVFF  8C7,8FF
11A1E:  CALL   C92C
11A22:  MOVFF  03,8CE
11A26:  MOVFF  02,8CD
11A2A:  MOVFF  01,8CC
11A2E:  MOVFF  00,8CB
....................       PO4_abs_array[3] = log10(ratio); 
11A32:  MOVFF  8CE,8D2
11A36:  MOVFF  8CD,8D1
11A3A:  MOVFF  8CC,8D0
11A3E:  MOVFF  8CB,8CF
11A42:  CALL   10BD6
11A46:  MOVFF  03,3D4
11A4A:  MOVFF  02,3D3
11A4E:  MOVFF  01,3D2
11A52:  MOVFF  00,3D1
11A56:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
11A58:  MOVLW  04
11A5A:  MOVWF  1E
11A5C:  MOVLW  25
11A5E:  MOVWF  1D
11A60:  MOVLW  86
11A62:  MOVWF  FF6
11A64:  MOVLW  1E
11A66:  MOVWF  FF7
11A68:  MOVLW  00
11A6A:  MOVWF  FF8
11A6C:  MOVLW  06
11A6E:  MOVLB  8
11A70:  MOVWF  xEB
11A72:  MOVLB  0
11A74:  CALL   AACC
11A78:  MOVLW  10
11A7A:  MOVWF  FE9
11A7C:  MOVFF  370,8F7
11A80:  MOVFF  36F,8F6
11A84:  CALL   AAFE
11A88:  MOVLW  8F
11A8A:  MOVWF  FF6
11A8C:  MOVLW  1E
11A8E:  MOVWF  FF7
11A90:  MOVLW  00
11A92:  MOVWF  FF8
11A94:  MOVLW  07
11A96:  MOVLB  8
11A98:  MOVWF  xEB
11A9A:  MOVLB  0
11A9C:  CALL   AACC
11AA0:  MOVLW  10
11AA2:  MOVWF  FE9
11AA4:  MOVFF  372,8F7
11AA8:  MOVFF  371,8F6
11AAC:  CALL   AAFE
11AB0:  MOVLW  99
11AB2:  MOVWF  FF6
11AB4:  MOVLW  1E
11AB6:  MOVWF  FF7
11AB8:  MOVLW  00
11ABA:  MOVWF  FF8
11ABC:  MOVLW  09
11ABE:  MOVLB  8
11AC0:  MOVWF  xEB
11AC2:  MOVLB  0
11AC4:  CALL   AACC
11AC8:  MOVLW  89
11ACA:  MOVWF  FE9
11ACC:  MOVFF  3C8,8D2
11AD0:  MOVFF  3C7,8D1
11AD4:  MOVFF  3C6,8D0
11AD8:  MOVFF  3C5,8CF
11ADC:  MOVLW  04
11ADE:  MOVLB  8
11AE0:  MOVWF  xD3
11AE2:  MOVLB  0
11AE4:  CALL   10C42
11AE8:  MOVLW  A7
11AEA:  MOVWF  FF6
11AEC:  MOVLW  1E
11AEE:  MOVWF  FF7
11AF0:  MOVLW  00
11AF2:  MOVWF  FF8
11AF4:  MOVLW  07
11AF6:  MOVLB  8
11AF8:  MOVWF  xEB
11AFA:  MOVLB  0
11AFC:  CALL   AACC
11B00:  MOVLW  10
11B02:  MOVWF  FE9
11B04:  MOVFF  374,8F7
11B08:  MOVFF  373,8F6
11B0C:  CALL   AAFE
11B10:  MOVLW  B1
11B12:  MOVWF  FF6
11B14:  MOVLW  1E
11B16:  MOVWF  FF7
11B18:  MOVLW  00
11B1A:  MOVWF  FF8
11B1C:  MOVLW  07
11B1E:  MOVLB  8
11B20:  MOVWF  xEB
11B22:  MOVLB  0
11B24:  CALL   AACC
11B28:  MOVLW  10
11B2A:  MOVWF  FE9
11B2C:  MOVFF  376,8F7
11B30:  MOVFF  375,8F6
11B34:  CALL   AAFE
11B38:  MOVLW  BB
11B3A:  MOVWF  FF6
11B3C:  MOVLW  1E
11B3E:  MOVWF  FF7
11B40:  MOVLW  00
11B42:  MOVWF  FF8
11B44:  MOVLW  09
11B46:  MOVLB  8
11B48:  MOVWF  xEB
11B4A:  MOVLB  0
11B4C:  CALL   AACC
11B50:  MOVLW  89
11B52:  MOVWF  FE9
11B54:  MOVFF  3CC,8D2
11B58:  MOVFF  3CB,8D1
11B5C:  MOVFF  3CA,8D0
11B60:  MOVFF  3C9,8CF
11B64:  MOVLW  04
11B66:  MOVLB  8
11B68:  MOVWF  xD3
11B6A:  MOVLB  0
11B6C:  CALL   10C42
11B70:  MOVLW  C9
11B72:  MOVWF  FF6
11B74:  MOVLW  1E
11B76:  MOVWF  FF7
11B78:  MOVLW  00
11B7A:  MOVWF  FF8
11B7C:  MOVLW  07
11B7E:  MOVLB  8
11B80:  MOVWF  xEB
11B82:  MOVLB  0
11B84:  CALL   AACC
11B88:  MOVLW  10
11B8A:  MOVWF  FE9
11B8C:  MOVFF  378,8F7
11B90:  MOVFF  377,8F6
11B94:  CALL   AAFE
11B98:  MOVLW  D3
11B9A:  MOVWF  FF6
11B9C:  MOVLW  1E
11B9E:  MOVWF  FF7
11BA0:  MOVLW  00
11BA2:  MOVWF  FF8
11BA4:  MOVLW  07
11BA6:  MOVLB  8
11BA8:  MOVWF  xEB
11BAA:  MOVLB  0
11BAC:  CALL   AACC
11BB0:  MOVLW  10
11BB2:  MOVWF  FE9
11BB4:  MOVFF  37A,8F7
11BB8:  MOVFF  379,8F6
11BBC:  CALL   AAFE
11BC0:  MOVLW  DD
11BC2:  MOVWF  FF6
11BC4:  MOVLW  1E
11BC6:  MOVWF  FF7
11BC8:  MOVLW  00
11BCA:  MOVWF  FF8
11BCC:  MOVLW  09
11BCE:  MOVLB  8
11BD0:  MOVWF  xEB
11BD2:  MOVLB  0
11BD4:  CALL   AACC
11BD8:  MOVLW  89
11BDA:  MOVWF  FE9
11BDC:  MOVFF  3D0,8D2
11BE0:  MOVFF  3CF,8D1
11BE4:  MOVFF  3CE,8D0
11BE8:  MOVFF  3CD,8CF
11BEC:  MOVLW  04
11BEE:  MOVLB  8
11BF0:  MOVWF  xD3
11BF2:  MOVLB  0
11BF4:  CALL   10C42
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
11BF8:  MOVF   1F,W
11BFA:  SUBLW  02
11BFC:  BNZ   11C02
11BFE:  MOVF   20,F
11C00:  BZ    11C42
11C02:  MOVLW  EC
11C04:  MOVWF  FF6
11C06:  MOVLW  1E
11C08:  MOVWF  FF7
11C0A:  MOVLW  00
11C0C:  MOVWF  FF8
11C0E:  CLRF   1B
11C10:  BTFSC  FF2.7
11C12:  BSF    1B.7
11C14:  BCF    FF2.7
11C16:  MOVLW  09
11C18:  MOVLB  A
11C1A:  MOVWF  x40
11C1C:  MOVLB  0
11C1E:  CALL   101C
11C22:  BTFSC  1B.7
11C24:  BSF    FF2.7
11C26:  MOVLW  04
11C28:  MOVWF  FEA
11C2A:  MOVLW  25
11C2C:  MOVWF  FE9
11C2E:  CALL   7996
11C32:  MOVLW  0D
11C34:  BTFSS  F9E.4
11C36:  BRA    11C34
11C38:  MOVWF  FAD
11C3A:  MOVLW  0A
11C3C:  BTFSS  F9E.4
11C3E:  BRA    11C3C
11C40:  MOVWF  FAD
11C42:  GOTO   125FC (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
11C46:  MOVLB  8
11C48:  CLRF   xC2
11C4A:  MOVF   xC2,W
11C4C:  SUBLW  03
11C4E:  BNC   11C6E
11C50:  MOVF   xC2,W
11C52:  MULLW  04
11C54:  MOVF   FF3,W
11C56:  CLRF   03
11C58:  ADDLW  D5
11C5A:  MOVWF  FE9
11C5C:  MOVLW  03
11C5E:  ADDWFC 03,W
11C60:  MOVWF  FEA
11C62:  CLRF   FEF
11C64:  CLRF   FEC
11C66:  CLRF   FEC
11C68:  CLRF   FEC
11C6A:  INCF   xC2,F
11C6C:  BRA    11C4A
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
11C6E:  MOVLB  3
11C70:  MOVF   x81,F
11C72:  BTFSS  FD8.2
11C74:  BRA    11C7A
11C76:  MOVF   x82,F
11C78:  BZ    11D16
11C7A:  MOVF   x83,F
11C7C:  BNZ   11C82
11C7E:  MOVF   x84,F
11C80:  BZ    11D16
....................       blank = NH4_array[0]; 
11C82:  MOVFF  382,918
11C86:  MOVFF  381,917
11C8A:  MOVLB  0
11C8C:  CALL   C8F6
11C90:  MOVFF  03,8C6
11C94:  MOVFF  02,8C5
11C98:  MOVFF  01,8C4
11C9C:  MOVFF  00,8C3
....................       react = NH4_array[1]; 
11CA0:  MOVFF  384,918
11CA4:  MOVFF  383,917
11CA8:  CALL   C8F6
11CAC:  MOVFF  03,8CA
11CB0:  MOVFF  02,8C9
11CB4:  MOVFF  01,8C8
11CB8:  MOVFF  00,8C7
....................       ratio = blank / react; 
11CBC:  MOVFF  8C6,8FE
11CC0:  MOVFF  8C5,8FD
11CC4:  MOVFF  8C4,8FC
11CC8:  MOVFF  8C3,8FB
11CCC:  MOVFF  8CA,902
11CD0:  MOVFF  8C9,901
11CD4:  MOVFF  8C8,900
11CD8:  MOVFF  8C7,8FF
11CDC:  CALL   C92C
11CE0:  MOVFF  03,8CE
11CE4:  MOVFF  02,8CD
11CE8:  MOVFF  01,8CC
11CEC:  MOVFF  00,8CB
....................       NH4_abs_array[0] = log10(ratio); 
11CF0:  MOVFF  8CE,8D2
11CF4:  MOVFF  8CD,8D1
11CF8:  MOVFF  8CC,8D0
11CFC:  MOVFF  8CB,8CF
11D00:  CALL   10BD6
11D04:  MOVFF  03,3D8
11D08:  MOVFF  02,3D7
11D0C:  MOVFF  01,3D6
11D10:  MOVFF  00,3D5
11D14:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
11D16:  MOVF   x85,F
11D18:  BNZ   11D1E
11D1A:  MOVF   x86,F
11D1C:  BZ    11DBA
11D1E:  MOVF   x87,F
11D20:  BNZ   11D26
11D22:  MOVF   x88,F
11D24:  BZ    11DBA
....................       blank = NH4_array[2]; 
11D26:  MOVFF  386,918
11D2A:  MOVFF  385,917
11D2E:  MOVLB  0
11D30:  CALL   C8F6
11D34:  MOVFF  03,8C6
11D38:  MOVFF  02,8C5
11D3C:  MOVFF  01,8C4
11D40:  MOVFF  00,8C3
....................       react = NH4_array[3]; 
11D44:  MOVFF  388,918
11D48:  MOVFF  387,917
11D4C:  CALL   C8F6
11D50:  MOVFF  03,8CA
11D54:  MOVFF  02,8C9
11D58:  MOVFF  01,8C8
11D5C:  MOVFF  00,8C7
....................       ratio = blank / react;    
11D60:  MOVFF  8C6,8FE
11D64:  MOVFF  8C5,8FD
11D68:  MOVFF  8C4,8FC
11D6C:  MOVFF  8C3,8FB
11D70:  MOVFF  8CA,902
11D74:  MOVFF  8C9,901
11D78:  MOVFF  8C8,900
11D7C:  MOVFF  8C7,8FF
11D80:  CALL   C92C
11D84:  MOVFF  03,8CE
11D88:  MOVFF  02,8CD
11D8C:  MOVFF  01,8CC
11D90:  MOVFF  00,8CB
....................       NH4_abs_array[1] = log10(ratio); 
11D94:  MOVFF  8CE,8D2
11D98:  MOVFF  8CD,8D1
11D9C:  MOVFF  8CC,8D0
11DA0:  MOVFF  8CB,8CF
11DA4:  CALL   10BD6
11DA8:  MOVFF  03,3DC
11DAC:  MOVFF  02,3DB
11DB0:  MOVFF  01,3DA
11DB4:  MOVFF  00,3D9
11DB8:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11DBA:  MOVF   x89,F
11DBC:  BNZ   11DC2
11DBE:  MOVF   x8A,F
11DC0:  BZ    11E5E
11DC2:  MOVF   x8B,F
11DC4:  BNZ   11DCA
11DC6:  MOVF   x8C,F
11DC8:  BZ    11E5E
....................       blank = NH4_array[4]; 
11DCA:  MOVFF  38A,918
11DCE:  MOVFF  389,917
11DD2:  MOVLB  0
11DD4:  CALL   C8F6
11DD8:  MOVFF  03,8C6
11DDC:  MOVFF  02,8C5
11DE0:  MOVFF  01,8C4
11DE4:  MOVFF  00,8C3
....................       react = NH4_array[5]; 
11DE8:  MOVFF  38C,918
11DEC:  MOVFF  38B,917
11DF0:  CALL   C8F6
11DF4:  MOVFF  03,8CA
11DF8:  MOVFF  02,8C9
11DFC:  MOVFF  01,8C8
11E00:  MOVFF  00,8C7
....................       ratio = blank / react; 
11E04:  MOVFF  8C6,8FE
11E08:  MOVFF  8C5,8FD
11E0C:  MOVFF  8C4,8FC
11E10:  MOVFF  8C3,8FB
11E14:  MOVFF  8CA,902
11E18:  MOVFF  8C9,901
11E1C:  MOVFF  8C8,900
11E20:  MOVFF  8C7,8FF
11E24:  CALL   C92C
11E28:  MOVFF  03,8CE
11E2C:  MOVFF  02,8CD
11E30:  MOVFF  01,8CC
11E34:  MOVFF  00,8CB
....................       NH4_abs_array[2] = log10(ratio); 
11E38:  MOVFF  8CE,8D2
11E3C:  MOVFF  8CD,8D1
11E40:  MOVFF  8CC,8D0
11E44:  MOVFF  8CB,8CF
11E48:  CALL   10BD6
11E4C:  MOVFF  03,3E0
11E50:  MOVFF  02,3DF
11E54:  MOVFF  01,3DE
11E58:  MOVFF  00,3DD
11E5C:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11E5E:  MOVF   x8D,F
11E60:  BNZ   11E66
11E62:  MOVF   x8E,F
11E64:  BZ    11F02
11E66:  MOVF   x8F,F
11E68:  BNZ   11E6E
11E6A:  MOVF   x90,F
11E6C:  BZ    11F02
....................       blank = NH4_array[6]; 
11E6E:  MOVFF  38E,918
11E72:  MOVFF  38D,917
11E76:  MOVLB  0
11E78:  CALL   C8F6
11E7C:  MOVFF  03,8C6
11E80:  MOVFF  02,8C5
11E84:  MOVFF  01,8C4
11E88:  MOVFF  00,8C3
....................       react = NH4_array[7]; 
11E8C:  MOVFF  390,918
11E90:  MOVFF  38F,917
11E94:  CALL   C8F6
11E98:  MOVFF  03,8CA
11E9C:  MOVFF  02,8C9
11EA0:  MOVFF  01,8C8
11EA4:  MOVFF  00,8C7
....................       ratio = blank / react; 
11EA8:  MOVFF  8C6,8FE
11EAC:  MOVFF  8C5,8FD
11EB0:  MOVFF  8C4,8FC
11EB4:  MOVFF  8C3,8FB
11EB8:  MOVFF  8CA,902
11EBC:  MOVFF  8C9,901
11EC0:  MOVFF  8C8,900
11EC4:  MOVFF  8C7,8FF
11EC8:  CALL   C92C
11ECC:  MOVFF  03,8CE
11ED0:  MOVFF  02,8CD
11ED4:  MOVFF  01,8CC
11ED8:  MOVFF  00,8CB
....................       NH4_abs_array[3] = log10(ratio); 
11EDC:  MOVFF  8CE,8D2
11EE0:  MOVFF  8CD,8D1
11EE4:  MOVFF  8CC,8D0
11EE8:  MOVFF  8CB,8CF
11EEC:  CALL   10BD6
11EF0:  MOVFF  03,3E4
11EF4:  MOVFF  02,3E3
11EF8:  MOVFF  01,3E2
11EFC:  MOVFF  00,3E1
11F00:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11F02:  MOVLW  04
11F04:  MOVWF  1E
11F06:  MOVLW  25
11F08:  MOVWF  1D
11F0A:  MOVLW  FA
11F0C:  MOVWF  FF6
11F0E:  MOVLW  1E
11F10:  MOVWF  FF7
11F12:  MOVLW  00
11F14:  MOVWF  FF8
11F16:  MOVLW  06
11F18:  MOVLB  8
11F1A:  MOVWF  xEB
11F1C:  MOVLB  0
11F1E:  CALL   AACC
11F22:  MOVLW  10
11F24:  MOVWF  FE9
11F26:  MOVFF  382,8F7
11F2A:  MOVFF  381,8F6
11F2E:  CALL   AAFE
11F32:  MOVLW  03
11F34:  MOVWF  FF6
11F36:  MOVLW  1F
11F38:  MOVWF  FF7
11F3A:  MOVLW  00
11F3C:  MOVWF  FF8
11F3E:  MOVLW  07
11F40:  MOVLB  8
11F42:  MOVWF  xEB
11F44:  MOVLB  0
11F46:  CALL   AACC
11F4A:  MOVLW  10
11F4C:  MOVWF  FE9
11F4E:  MOVFF  384,8F7
11F52:  MOVFF  383,8F6
11F56:  CALL   AAFE
11F5A:  MOVLW  0D
11F5C:  MOVWF  FF6
11F5E:  MOVLW  1F
11F60:  MOVWF  FF7
11F62:  MOVLW  00
11F64:  MOVWF  FF8
11F66:  MOVLW  09
11F68:  MOVLB  8
11F6A:  MOVWF  xEB
11F6C:  MOVLB  0
11F6E:  CALL   AACC
11F72:  MOVLW  89
11F74:  MOVWF  FE9
11F76:  MOVFF  3D8,8D2
11F7A:  MOVFF  3D7,8D1
11F7E:  MOVFF  3D6,8D0
11F82:  MOVFF  3D5,8CF
11F86:  MOVLW  04
11F88:  MOVLB  8
11F8A:  MOVWF  xD3
11F8C:  MOVLB  0
11F8E:  CALL   10C42
11F92:  MOVLW  1B
11F94:  MOVWF  FF6
11F96:  MOVLW  1F
11F98:  MOVWF  FF7
11F9A:  MOVLW  00
11F9C:  MOVWF  FF8
11F9E:  MOVLW  07
11FA0:  MOVLB  8
11FA2:  MOVWF  xEB
11FA4:  MOVLB  0
11FA6:  CALL   AACC
11FAA:  MOVLW  10
11FAC:  MOVWF  FE9
11FAE:  MOVFF  386,8F7
11FB2:  MOVFF  385,8F6
11FB6:  CALL   AAFE
11FBA:  MOVLW  25
11FBC:  MOVWF  FF6
11FBE:  MOVLW  1F
11FC0:  MOVWF  FF7
11FC2:  MOVLW  00
11FC4:  MOVWF  FF8
11FC6:  MOVLW  07
11FC8:  MOVLB  8
11FCA:  MOVWF  xEB
11FCC:  MOVLB  0
11FCE:  CALL   AACC
11FD2:  MOVLW  10
11FD4:  MOVWF  FE9
11FD6:  MOVFF  388,8F7
11FDA:  MOVFF  387,8F6
11FDE:  CALL   AAFE
11FE2:  MOVLW  2F
11FE4:  MOVWF  FF6
11FE6:  MOVLW  1F
11FE8:  MOVWF  FF7
11FEA:  MOVLW  00
11FEC:  MOVWF  FF8
11FEE:  MOVLW  09
11FF0:  MOVLB  8
11FF2:  MOVWF  xEB
11FF4:  MOVLB  0
11FF6:  CALL   AACC
11FFA:  MOVLW  89
11FFC:  MOVWF  FE9
11FFE:  MOVFF  3DC,8D2
12002:  MOVFF  3DB,8D1
12006:  MOVFF  3DA,8D0
1200A:  MOVFF  3D9,8CF
1200E:  MOVLW  04
12010:  MOVLB  8
12012:  MOVWF  xD3
12014:  MOVLB  0
12016:  CALL   10C42
1201A:  MOVLW  3D
1201C:  MOVWF  FF6
1201E:  MOVLW  1F
12020:  MOVWF  FF7
12022:  MOVLW  00
12024:  MOVWF  FF8
12026:  MOVLW  07
12028:  MOVLB  8
1202A:  MOVWF  xEB
1202C:  MOVLB  0
1202E:  CALL   AACC
12032:  MOVLW  10
12034:  MOVWF  FE9
12036:  MOVFF  38A,8F7
1203A:  MOVFF  389,8F6
1203E:  CALL   AAFE
12042:  MOVLW  47
12044:  MOVWF  FF6
12046:  MOVLW  1F
12048:  MOVWF  FF7
1204A:  MOVLW  00
1204C:  MOVWF  FF8
1204E:  MOVLW  07
12050:  MOVLB  8
12052:  MOVWF  xEB
12054:  MOVLB  0
12056:  CALL   AACC
1205A:  MOVLW  10
1205C:  MOVWF  FE9
1205E:  MOVFF  38C,8F7
12062:  MOVFF  38B,8F6
12066:  CALL   AAFE
1206A:  MOVLW  51
1206C:  MOVWF  FF6
1206E:  MOVLW  1F
12070:  MOVWF  FF7
12072:  MOVLW  00
12074:  MOVWF  FF8
12076:  MOVLW  09
12078:  MOVLB  8
1207A:  MOVWF  xEB
1207C:  MOVLB  0
1207E:  CALL   AACC
12082:  MOVLW  89
12084:  MOVWF  FE9
12086:  MOVFF  3E0,8D2
1208A:  MOVFF  3DF,8D1
1208E:  MOVFF  3DE,8D0
12092:  MOVFF  3DD,8CF
12096:  MOVLW  04
12098:  MOVLB  8
1209A:  MOVWF  xD3
1209C:  MOVLB  0
1209E:  CALL   10C42
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
120A2:  MOVF   1F,W
120A4:  SUBLW  02
120A6:  BNZ   120AC
120A8:  MOVF   20,F
120AA:  BZ    120EC
120AC:  MOVLW  60
120AE:  MOVWF  FF6
120B0:  MOVLW  1F
120B2:  MOVWF  FF7
120B4:  MOVLW  00
120B6:  MOVWF  FF8
120B8:  CLRF   1B
120BA:  BTFSC  FF2.7
120BC:  BSF    1B.7
120BE:  BCF    FF2.7
120C0:  MOVLW  09
120C2:  MOVLB  A
120C4:  MOVWF  x40
120C6:  MOVLB  0
120C8:  CALL   101C
120CC:  BTFSC  1B.7
120CE:  BSF    FF2.7
120D0:  MOVLW  04
120D2:  MOVWF  FEA
120D4:  MOVLW  25
120D6:  MOVWF  FE9
120D8:  CALL   7996
120DC:  MOVLW  0D
120DE:  BTFSS  F9E.4
120E0:  BRA    120DE
120E2:  MOVWF  FAD
120E4:  MOVLW  0A
120E6:  BTFSS  F9E.4
120E8:  BRA    120E6
120EA:  MOVWF  FAD
120EC:  GOTO   125FC (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
120F0:  MOVLB  8
120F2:  CLRF   xC2
120F4:  MOVF   xC2,W
120F6:  SUBLW  03
120F8:  BNC   12118
120FA:  MOVF   xC2,W
120FC:  MULLW  04
120FE:  MOVF   FF3,W
12100:  CLRF   03
12102:  ADDLW  E5
12104:  MOVWF  FE9
12106:  MOVLW  03
12108:  ADDWFC 03,W
1210A:  MOVWF  FEA
1210C:  CLRF   FEF
1210E:  CLRF   FEC
12110:  CLRF   FEC
12112:  CLRF   FEC
12114:  INCF   xC2,F
12116:  BRA    120F4
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
12118:  MOVLB  3
1211A:  MOVF   x93,F
1211C:  BTFSS  FD8.2
1211E:  BRA    12124
12120:  MOVF   x94,F
12122:  BZ    121C0
12124:  MOVF   x95,F
12126:  BNZ   1212C
12128:  MOVF   x96,F
1212A:  BZ    121C0
....................       blank = SiO_array[0]; 
1212C:  MOVFF  394,918
12130:  MOVFF  393,917
12134:  MOVLB  0
12136:  CALL   C8F6
1213A:  MOVFF  03,8C6
1213E:  MOVFF  02,8C5
12142:  MOVFF  01,8C4
12146:  MOVFF  00,8C3
....................       react = SiO_array[1]; 
1214A:  MOVFF  396,918
1214E:  MOVFF  395,917
12152:  CALL   C8F6
12156:  MOVFF  03,8CA
1215A:  MOVFF  02,8C9
1215E:  MOVFF  01,8C8
12162:  MOVFF  00,8C7
....................       ratio = blank / react; 
12166:  MOVFF  8C6,8FE
1216A:  MOVFF  8C5,8FD
1216E:  MOVFF  8C4,8FC
12172:  MOVFF  8C3,8FB
12176:  MOVFF  8CA,902
1217A:  MOVFF  8C9,901
1217E:  MOVFF  8C8,900
12182:  MOVFF  8C7,8FF
12186:  CALL   C92C
1218A:  MOVFF  03,8CE
1218E:  MOVFF  02,8CD
12192:  MOVFF  01,8CC
12196:  MOVFF  00,8CB
....................       SiO_abs_array[0] = log10(ratio); 
1219A:  MOVFF  8CE,8D2
1219E:  MOVFF  8CD,8D1
121A2:  MOVFF  8CC,8D0
121A6:  MOVFF  8CB,8CF
121AA:  CALL   10BD6
121AE:  MOVFF  03,3E8
121B2:  MOVFF  02,3E7
121B6:  MOVFF  01,3E6
121BA:  MOVFF  00,3E5
121BE:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
121C0:  MOVF   x97,F
121C2:  BNZ   121C8
121C4:  MOVF   x98,F
121C6:  BZ    12264
121C8:  MOVF   x99,F
121CA:  BNZ   121D0
121CC:  MOVF   x9A,F
121CE:  BZ    12264
....................       blank = SiO_array[2]; 
121D0:  MOVFF  398,918
121D4:  MOVFF  397,917
121D8:  MOVLB  0
121DA:  CALL   C8F6
121DE:  MOVFF  03,8C6
121E2:  MOVFF  02,8C5
121E6:  MOVFF  01,8C4
121EA:  MOVFF  00,8C3
....................       react = SiO_array[3]; 
121EE:  MOVFF  39A,918
121F2:  MOVFF  399,917
121F6:  CALL   C8F6
121FA:  MOVFF  03,8CA
121FE:  MOVFF  02,8C9
12202:  MOVFF  01,8C8
12206:  MOVFF  00,8C7
....................       ratio = blank / react;    
1220A:  MOVFF  8C6,8FE
1220E:  MOVFF  8C5,8FD
12212:  MOVFF  8C4,8FC
12216:  MOVFF  8C3,8FB
1221A:  MOVFF  8CA,902
1221E:  MOVFF  8C9,901
12222:  MOVFF  8C8,900
12226:  MOVFF  8C7,8FF
1222A:  CALL   C92C
1222E:  MOVFF  03,8CE
12232:  MOVFF  02,8CD
12236:  MOVFF  01,8CC
1223A:  MOVFF  00,8CB
....................       SiO_abs_array[1] = log10(ratio); 
1223E:  MOVFF  8CE,8D2
12242:  MOVFF  8CD,8D1
12246:  MOVFF  8CC,8D0
1224A:  MOVFF  8CB,8CF
1224E:  CALL   10BD6
12252:  MOVFF  03,3EC
12256:  MOVFF  02,3EB
1225A:  MOVFF  01,3EA
1225E:  MOVFF  00,3E9
12262:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
12264:  MOVF   x9B,F
12266:  BNZ   1226C
12268:  MOVF   x9C,F
1226A:  BZ    12308
1226C:  MOVF   x9D,F
1226E:  BNZ   12274
12270:  MOVF   x9E,F
12272:  BZ    12308
....................       blank = SiO_array[4]; 
12274:  MOVFF  39C,918
12278:  MOVFF  39B,917
1227C:  MOVLB  0
1227E:  CALL   C8F6
12282:  MOVFF  03,8C6
12286:  MOVFF  02,8C5
1228A:  MOVFF  01,8C4
1228E:  MOVFF  00,8C3
....................       react = SiO_array[5]; 
12292:  MOVFF  39E,918
12296:  MOVFF  39D,917
1229A:  CALL   C8F6
1229E:  MOVFF  03,8CA
122A2:  MOVFF  02,8C9
122A6:  MOVFF  01,8C8
122AA:  MOVFF  00,8C7
....................       ratio = blank / react; 
122AE:  MOVFF  8C6,8FE
122B2:  MOVFF  8C5,8FD
122B6:  MOVFF  8C4,8FC
122BA:  MOVFF  8C3,8FB
122BE:  MOVFF  8CA,902
122C2:  MOVFF  8C9,901
122C6:  MOVFF  8C8,900
122CA:  MOVFF  8C7,8FF
122CE:  CALL   C92C
122D2:  MOVFF  03,8CE
122D6:  MOVFF  02,8CD
122DA:  MOVFF  01,8CC
122DE:  MOVFF  00,8CB
....................       SiO_abs_array[2] = log10(ratio); 
122E2:  MOVFF  8CE,8D2
122E6:  MOVFF  8CD,8D1
122EA:  MOVFF  8CC,8D0
122EE:  MOVFF  8CB,8CF
122F2:  CALL   10BD6
122F6:  MOVFF  03,3F0
122FA:  MOVFF  02,3EF
122FE:  MOVFF  01,3EE
12302:  MOVFF  00,3ED
12306:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
12308:  MOVF   x9F,F
1230A:  BNZ   12310
1230C:  MOVF   xA0,F
1230E:  BZ    123AC
12310:  MOVF   xA1,F
12312:  BNZ   12318
12314:  MOVF   xA2,F
12316:  BZ    123AC
....................       blank = SiO_array[6]; 
12318:  MOVFF  3A0,918
1231C:  MOVFF  39F,917
12320:  MOVLB  0
12322:  CALL   C8F6
12326:  MOVFF  03,8C6
1232A:  MOVFF  02,8C5
1232E:  MOVFF  01,8C4
12332:  MOVFF  00,8C3
....................       react = SiO_array[7]; 
12336:  MOVFF  3A2,918
1233A:  MOVFF  3A1,917
1233E:  CALL   C8F6
12342:  MOVFF  03,8CA
12346:  MOVFF  02,8C9
1234A:  MOVFF  01,8C8
1234E:  MOVFF  00,8C7
....................       ratio = blank / react; 
12352:  MOVFF  8C6,8FE
12356:  MOVFF  8C5,8FD
1235A:  MOVFF  8C4,8FC
1235E:  MOVFF  8C3,8FB
12362:  MOVFF  8CA,902
12366:  MOVFF  8C9,901
1236A:  MOVFF  8C8,900
1236E:  MOVFF  8C7,8FF
12372:  CALL   C92C
12376:  MOVFF  03,8CE
1237A:  MOVFF  02,8CD
1237E:  MOVFF  01,8CC
12382:  MOVFF  00,8CB
....................       SiO_abs_array[3] = log10(ratio); 
12386:  MOVFF  8CE,8D2
1238A:  MOVFF  8CD,8D1
1238E:  MOVFF  8CC,8D0
12392:  MOVFF  8CB,8CF
12396:  CALL   10BD6
1239A:  MOVFF  03,3F4
1239E:  MOVFF  02,3F3
123A2:  MOVFF  01,3F2
123A6:  MOVFF  00,3F1
123AA:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
123AC:  MOVLW  04
123AE:  MOVWF  1E
123B0:  MOVLW  25
123B2:  MOVWF  1D
123B4:  MOVLW  6E
123B6:  MOVWF  FF6
123B8:  MOVLW  1F
123BA:  MOVWF  FF7
123BC:  MOVLW  00
123BE:  MOVWF  FF8
123C0:  MOVLW  06
123C2:  MOVLB  8
123C4:  MOVWF  xEB
123C6:  MOVLB  0
123C8:  CALL   AACC
123CC:  MOVLW  10
123CE:  MOVWF  FE9
123D0:  MOVFF  394,8F7
123D4:  MOVFF  393,8F6
123D8:  CALL   AAFE
123DC:  MOVLW  77
123DE:  MOVWF  FF6
123E0:  MOVLW  1F
123E2:  MOVWF  FF7
123E4:  MOVLW  00
123E6:  MOVWF  FF8
123E8:  MOVLW  07
123EA:  MOVLB  8
123EC:  MOVWF  xEB
123EE:  MOVLB  0
123F0:  CALL   AACC
123F4:  MOVLW  10
123F6:  MOVWF  FE9
123F8:  MOVFF  396,8F7
123FC:  MOVFF  395,8F6
12400:  CALL   AAFE
12404:  MOVLW  81
12406:  MOVWF  FF6
12408:  MOVLW  1F
1240A:  MOVWF  FF7
1240C:  MOVLW  00
1240E:  MOVWF  FF8
12410:  MOVLW  09
12412:  MOVLB  8
12414:  MOVWF  xEB
12416:  MOVLB  0
12418:  CALL   AACC
1241C:  MOVLW  89
1241E:  MOVWF  FE9
12420:  MOVFF  3E8,8D2
12424:  MOVFF  3E7,8D1
12428:  MOVFF  3E6,8D0
1242C:  MOVFF  3E5,8CF
12430:  MOVLW  04
12432:  MOVLB  8
12434:  MOVWF  xD3
12436:  MOVLB  0
12438:  CALL   10C42
1243C:  MOVLW  8F
1243E:  MOVWF  FF6
12440:  MOVLW  1F
12442:  MOVWF  FF7
12444:  MOVLW  00
12446:  MOVWF  FF8
12448:  MOVLW  07
1244A:  MOVLB  8
1244C:  MOVWF  xEB
1244E:  MOVLB  0
12450:  CALL   AACC
12454:  MOVLW  10
12456:  MOVWF  FE9
12458:  MOVFF  398,8F7
1245C:  MOVFF  397,8F6
12460:  CALL   AAFE
12464:  MOVLW  99
12466:  MOVWF  FF6
12468:  MOVLW  1F
1246A:  MOVWF  FF7
1246C:  MOVLW  00
1246E:  MOVWF  FF8
12470:  MOVLW  07
12472:  MOVLB  8
12474:  MOVWF  xEB
12476:  MOVLB  0
12478:  CALL   AACC
1247C:  MOVLW  10
1247E:  MOVWF  FE9
12480:  MOVFF  39A,8F7
12484:  MOVFF  399,8F6
12488:  CALL   AAFE
1248C:  MOVLW  A3
1248E:  MOVWF  FF6
12490:  MOVLW  1F
12492:  MOVWF  FF7
12494:  MOVLW  00
12496:  MOVWF  FF8
12498:  MOVLW  09
1249A:  MOVLB  8
1249C:  MOVWF  xEB
1249E:  MOVLB  0
124A0:  CALL   AACC
124A4:  MOVLW  89
124A6:  MOVWF  FE9
124A8:  MOVFF  3EC,8D2
124AC:  MOVFF  3EB,8D1
124B0:  MOVFF  3EA,8D0
124B4:  MOVFF  3E9,8CF
124B8:  MOVLW  04
124BA:  MOVLB  8
124BC:  MOVWF  xD3
124BE:  MOVLB  0
124C0:  CALL   10C42
124C4:  MOVLW  B1
124C6:  MOVWF  FF6
124C8:  MOVLW  1F
124CA:  MOVWF  FF7
124CC:  MOVLW  00
124CE:  MOVWF  FF8
124D0:  MOVLW  07
124D2:  MOVLB  8
124D4:  MOVWF  xEB
124D6:  MOVLB  0
124D8:  CALL   AACC
124DC:  MOVLW  10
124DE:  MOVWF  FE9
124E0:  MOVFF  39C,8F7
124E4:  MOVFF  39B,8F6
124E8:  CALL   AAFE
124EC:  MOVLW  BB
124EE:  MOVWF  FF6
124F0:  MOVLW  1F
124F2:  MOVWF  FF7
124F4:  MOVLW  00
124F6:  MOVWF  FF8
124F8:  MOVLW  07
124FA:  MOVLB  8
124FC:  MOVWF  xEB
124FE:  MOVLB  0
12500:  CALL   AACC
12504:  MOVLW  10
12506:  MOVWF  FE9
12508:  MOVFF  39E,8F7
1250C:  MOVFF  39D,8F6
12510:  CALL   AAFE
12514:  MOVLW  C5
12516:  MOVWF  FF6
12518:  MOVLW  1F
1251A:  MOVWF  FF7
1251C:  MOVLW  00
1251E:  MOVWF  FF8
12520:  MOVLW  09
12522:  MOVLB  8
12524:  MOVWF  xEB
12526:  MOVLB  0
12528:  CALL   AACC
1252C:  MOVLW  89
1252E:  MOVWF  FE9
12530:  MOVFF  3F0,8D2
12534:  MOVFF  3EF,8D1
12538:  MOVFF  3EE,8D0
1253C:  MOVFF  3ED,8CF
12540:  MOVLW  04
12542:  MOVLB  8
12544:  MOVWF  xD3
12546:  MOVLB  0
12548:  CALL   10C42
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
1254C:  MOVF   1F,W
1254E:  SUBLW  02
12550:  BNZ   12556
12552:  MOVF   20,F
12554:  BZ    12596
12556:  MOVLW  D4
12558:  MOVWF  FF6
1255A:  MOVLW  1F
1255C:  MOVWF  FF7
1255E:  MOVLW  00
12560:  MOVWF  FF8
12562:  CLRF   1B
12564:  BTFSC  FF2.7
12566:  BSF    1B.7
12568:  BCF    FF2.7
1256A:  MOVLW  09
1256C:  MOVLB  A
1256E:  MOVWF  x40
12570:  MOVLB  0
12572:  CALL   101C
12576:  BTFSC  1B.7
12578:  BSF    FF2.7
1257A:  MOVLW  04
1257C:  MOVWF  FEA
1257E:  MOVLW  25
12580:  MOVWF  FE9
12582:  CALL   7996
12586:  MOVLW  0D
12588:  BTFSS  F9E.4
1258A:  BRA    12588
1258C:  MOVWF  FAD
1258E:  MOVLW  0A
12590:  BTFSS  F9E.4
12592:  BRA    12590
12594:  MOVWF  FAD
12596:  GOTO   125FC (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
1259A:  MOVLW  04
1259C:  MOVWF  FEA
1259E:  MOVLW  25
125A0:  MOVWF  FE9
125A2:  MOVLW  00
125A4:  CALL   056C
125A8:  TBLRD*-
125AA:  TBLRD*+
125AC:  MOVF   FF5,W
125AE:  MOVWF  FEE
125B0:  IORLW  00
125B2:  BNZ   125AA
....................     
....................    switch (chem){ 
125B4:  MOVLW  E2
125B6:  MOVWF  FF6
125B8:  MOVLW  1F
125BA:  MOVWF  FF7
125BC:  MOVLW  00
125BE:  MOVWF  FF8
125C0:  MOVLW  03
125C2:  MOVWF  FEA
125C4:  MOVLW  3D
125C6:  MOVWF  FE9
125C8:  CALL   FE62
125CC:  MOVF   01,W
125CE:  BZ    125E2
125D0:  XORLW  01
125D2:  BZ    125E8
125D4:  XORLW  03
125D6:  BZ    125EE
125D8:  XORLW  01
125DA:  BZ    125F4
125DC:  XORLW  07
125DE:  BZ    125FA
125E0:  BRA    125FC
....................       case "NO3" : calc_abs_NO3(); 
125E2:  GOTO   10E58
....................          break; 
125E6:  BRA    125FC
....................       case "NO2" : calc_abs_NO2 (); 
125E8:  GOTO   112F4
....................          break;    
125EC:  BRA    125FC
....................       case "PO4" : calc_abs_PO4(); 
125EE:  GOTO   1179C
....................          break; 
125F2:  BRA    125FC
....................       case "NH4" : calc_abs_NH4(); 
125F4:  GOTO   11C46
....................          break; 
125F8:  BRA    125FC
....................       case "SiO" : calc_abs_SiO(); 
125FA:  BRA    120F0
....................          break; 
....................    } 
125FC:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
125FE:  CALL   D528
....................     
....................    if (data_available == TRUE) { 
12602:  MOVLB  3
12604:  DECFSZ x3B,W
12606:  BRA    1270A
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
12608:  MOVLB  8
1260A:  CLRF   xF9
1260C:  MOVLW  67
1260E:  MOVWF  xF8
12610:  MOVLW  02
12612:  MOVWF  xFB
12614:  MOVLW  B7
12616:  MOVWF  xFA
12618:  MOVLB  0
1261A:  CALL   54DE
....................       strcat(data_buffer, comma); 
1261E:  MOVLB  8
12620:  CLRF   xF9
12622:  MOVLW  67
12624:  MOVWF  xF8
12626:  MOVLW  03
12628:  MOVWF  xFB
1262A:  MOVLW  39
1262C:  MOVWF  xFA
1262E:  MOVLB  0
12630:  CALL   54DE
....................       strcat(data_buffer, chem); 
12634:  MOVLB  8
12636:  CLRF   xF9
12638:  MOVLW  67
1263A:  MOVWF  xF8
1263C:  MOVLW  03
1263E:  MOVWF  xFB
12640:  MOVLW  3D
12642:  MOVWF  xFA
12644:  MOVLB  0
12646:  CALL   54DE
....................       strcat(data_buffer, comma); 
1264A:  MOVLB  8
1264C:  CLRF   xF9
1264E:  MOVLW  67
12650:  MOVWF  xF8
12652:  MOVLW  03
12654:  MOVWF  xFB
12656:  MOVLW  39
12658:  MOVWF  xFA
1265A:  MOVLB  0
1265C:  CALL   54DE
....................       strcat(data_buffer, abs_str); 
12660:  MOVLB  8
12662:  CLRF   xF9
12664:  MOVLW  67
12666:  MOVWF  xF8
12668:  MOVLW  04
1266A:  MOVWF  xFB
1266C:  MOVLW  25
1266E:  MOVWF  xFA
12670:  MOVLB  0
12672:  CALL   54DE
....................       strcat(data_buffer, endofline); 
12676:  MOVLB  8
12678:  CLRF   xF9
1267A:  MOVLW  67
1267C:  MOVWF  xF8
1267E:  MOVLW  07
12680:  MOVWF  xFB
12682:  MOVLW  CE
12684:  MOVWF  xFA
12686:  MOVLB  0
12688:  CALL   54DE
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
1268C:  MOVF   1F,W
1268E:  SUBLW  04
12690:  BNZ   126B0
12692:  MOVF   20,F
12694:  BNZ   126B0
12696:  CLRF   FEA
12698:  MOVLW  67
1269A:  MOVWF  FE9
1269C:  CALL   7996
126A0:  MOVLW  0D
126A2:  BTFSS  F9E.4
126A4:  BRA    126A2
126A6:  MOVWF  FAD
126A8:  MOVLW  0A
126AA:  BTFSS  F9E.4
126AC:  BRA    126AA
126AE:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
126B0:  MOVLB  2
126B2:  MOVF   xDC,F
126B4:  BNZ   12708
....................        
....................          buffer_select = 0; 
126B6:  MOVLB  0
126B8:  CLRF   x66
....................           
....................          heartbeat(FALSE); 
126BA:  MOVLB  8
126BC:  CLRF   xED
126BE:  MOVLB  0
126C0:  CALL   5586
....................             append_data(file_ptr_rel_all); 
126C4:  MOVLW  02
126C6:  MOVLB  8
126C8:  MOVWF  xEE
126CA:  MOVLW  F9
126CC:  MOVWF  xED
126CE:  MOVLB  0
126D0:  CALL   82F8
....................          heartbeat(TRUE);          
126D4:  MOVLW  01
126D6:  MOVLB  8
126D8:  MOVWF  xED
126DA:  MOVLB  0
126DC:  CALL   5586
....................           
....................          heartbeat(FALSE); 
126E0:  MOVLB  8
126E2:  CLRF   xED
126E4:  MOVLB  0
126E6:  CALL   5586
....................             append_data(file_ptr_rel_new);    
126EA:  MOVLW  03
126EC:  MOVLB  8
126EE:  MOVWF  xEE
126F0:  MOVLW  07
126F2:  MOVWF  xED
126F4:  MOVLB  0
126F6:  CALL   82F8
....................          heartbeat(TRUE); 
126FA:  MOVLW  01
126FC:  MOVLB  8
126FE:  MOVWF  xED
12700:  MOVLB  0
12702:  CALL   5586
12706:  MOVLB  2
12708:  MOVLB  3
....................       } 
....................    } 
1270A:  MOVLB  0
1270C:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D63E:  MOVLW  2C
0D640:  MOVLB  8
0D642:  MOVWF  x9E
0D644:  CLRF   x9F
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D646:  MOVLW  0D
0D648:  MOVWF  xA0
0D64A:  MOVLW  0A
0D64C:  MOVWF  xA1
0D64E:  CLRF   xA2
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D650:  MOVLB  0
0D652:  RCALL  D528
....................    time_stamp(); 
0D654:  CALL   541A
....................    strcat(data_buffer, time_stmp_str); 
0D658:  MOVLB  8
0D65A:  CLRF   xF9
0D65C:  MOVLW  67
0D65E:  MOVWF  xF8
0D660:  MOVLW  02
0D662:  MOVWF  xFB
0D664:  MOVLW  99
0D666:  MOVWF  xFA
0D668:  MOVLB  0
0D66A:  CALL   54DE
....................    strcat(data_buffer, comma); 
0D66E:  MOVLB  8
0D670:  CLRF   xF9
0D672:  MOVLW  67
0D674:  MOVWF  xF8
0D676:  MOVLW  08
0D678:  MOVWF  xFB
0D67A:  MOVLW  9E
0D67C:  MOVWF  xFA
0D67E:  MOVLB  0
0D680:  CALL   54DE
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D684:  MOVLW  08
0D686:  MOVWF  1E
0D688:  MOVLW  A3
0D68A:  MOVWF  1D
0D68C:  MOVFF  89D,8ED
0D690:  MOVLW  1B
0D692:  MOVLB  8
0D694:  MOVWF  xEE
0D696:  MOVLB  0
0D698:  CALL   5280
0D69C:  MOVLW  2C
0D69E:  MOVLB  8
0D6A0:  MOVWF  xFF
0D6A2:  MOVLB  0
0D6A4:  CALL   509E
0D6A8:  MOVLW  10
0D6AA:  MOVWF  FE9
0D6AC:  MOVFF  2A,8F7
0D6B0:  MOVFF  29,8F6
0D6B4:  CALL   AAFE
0D6B8:  MOVLW  2C
0D6BA:  MOVLB  8
0D6BC:  MOVWF  xFF
0D6BE:  MOVLB  0
0D6C0:  CALL   509E
0D6C4:  MOVLW  10
0D6C6:  MOVWF  FE9
0D6C8:  MOVFF  24,8F7
0D6CC:  MOVFF  23,8F6
0D6D0:  CALL   AAFE
0D6D4:  MOVLW  2C
0D6D6:  MOVLB  8
0D6D8:  MOVWF  xFF
0D6DA:  MOVLB  0
0D6DC:  CALL   509E
0D6E0:  MOVLW  10
0D6E2:  MOVWF  FE9
0D6E4:  MOVFF  2C,8F7
0D6E8:  MOVFF  2B,8F6
0D6EC:  CALL   AAFE
0D6F0:  MOVLW  2C
0D6F2:  MOVLB  8
0D6F4:  MOVWF  xFF
0D6F6:  MOVLB  0
0D6F8:  CALL   509E
0D6FC:  MOVLW  10
0D6FE:  MOVWF  FE9
0D700:  MOVFF  2E,8F7
0D704:  MOVFF  2D,8F6
0D708:  CALL   AAFE
0D70C:  MOVLW  2C
0D70E:  MOVLB  8
0D710:  MOVWF  xFF
0D712:  MOVLB  0
0D714:  CALL   509E
0D718:  MOVLW  10
0D71A:  MOVWF  FE9
0D71C:  MOVFF  22,8F7
0D720:  MOVFF  21,8F6
0D724:  CALL   AAFE
0D728:  MOVLW  2C
0D72A:  MOVLB  8
0D72C:  MOVWF  xFF
0D72E:  MOVLB  0
0D730:  CALL   509E
0D734:  MOVLW  10
0D736:  MOVWF  FE9
0D738:  MOVFF  7C8,8F7
0D73C:  MOVFF  7C7,8F6
0D740:  CALL   AAFE
0D744:  MOVLW  2C
0D746:  MOVLB  8
0D748:  MOVWF  xFF
0D74A:  MOVLB  0
0D74C:  CALL   509E
0D750:  MOVLW  10
0D752:  MOVWF  FE9
0D754:  MOVFF  7B6,8C2
0D758:  MOVFF  7B5,8C1
0D75C:  BRA    D53C
....................    strcat(data_buffer, config_str); 
0D75E:  MOVLB  8
0D760:  CLRF   xF9
0D762:  MOVLW  67
0D764:  MOVWF  xF8
0D766:  MOVLW  08
0D768:  MOVWF  xFB
0D76A:  MOVLW  A3
0D76C:  MOVWF  xFA
0D76E:  MOVLB  0
0D770:  CALL   54DE
....................    strcat(data_buffer, endofline); 
0D774:  MOVLB  8
0D776:  CLRF   xF9
0D778:  MOVLW  67
0D77A:  MOVWF  xF8
0D77C:  MOVLW  08
0D77E:  MOVWF  xFB
0D780:  MOVLW  A0
0D782:  MOVWF  xFA
0D784:  MOVLB  0
0D786:  CALL   54DE
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D78A:  CLRF   FEA
0D78C:  MOVLW  67
0D78E:  MOVWF  FE9
0D790:  CALL   7996
0D794:  MOVLW  0D
0D796:  BTFSS  F9E.4
0D798:  BRA    D796
0D79A:  MOVWF  FAD
0D79C:  MOVLW  0A
0D79E:  BTFSS  F9E.4
0D7A0:  BRA    D79E
0D7A2:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D7A4:  MOVLB  2
0D7A6:  MOVF   xDC,F
0D7A8:  BNZ   D7FC
....................     
....................       buffer_select = 0; 
0D7AA:  MOVLB  0
0D7AC:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
0D7AE:  MOVLB  8
0D7B0:  CLRF   xED
0D7B2:  MOVLB  0
0D7B4:  CALL   5586
....................          append_data(file_ptr_raw_all); 
0D7B8:  MOVLW  02
0D7BA:  MOVLB  8
0D7BC:  MOVWF  xEE
0D7BE:  MOVLW  DD
0D7C0:  MOVWF  xED
0D7C2:  MOVLB  0
0D7C4:  CALL   82F8
....................       heartbeat(TRUE);          
0D7C8:  MOVLW  01
0D7CA:  MOVLB  8
0D7CC:  MOVWF  xED
0D7CE:  MOVLB  0
0D7D0:  CALL   5586
....................        
....................       heartbeat(FALSE); 
0D7D4:  MOVLB  8
0D7D6:  CLRF   xED
0D7D8:  MOVLB  0
0D7DA:  CALL   5586
....................          append_data(file_ptr_raw_new);    
0D7DE:  MOVLW  02
0D7E0:  MOVLB  8
0D7E2:  MOVWF  xEE
0D7E4:  MOVLW  EB
0D7E6:  MOVWF  xED
0D7E8:  MOVLB  0
0D7EA:  CALL   82F8
....................       heartbeat(TRUE); 
0D7EE:  MOVLW  01
0D7F0:  MOVLB  8
0D7F2:  MOVWF  xED
0D7F4:  MOVLB  0
0D7F6:  CALL   5586
0D7FA:  MOVLB  2
....................    } 
0D7FC:  MOVLB  0
0D7FE:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
15298:  MOVLW  2C
1529A:  MOVLB  8
1529C:  MOVWF  xA0
1529E:  CLRF   xA1
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
152A0:  MOVLW  0D
152A2:  MOVWF  xA2
152A4:  MOVLW  0A
152A6:  MOVWF  xA3
152A8:  CLRF   xA4
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
152AA:  MOVLB  0
152AC:  CALL   D528
....................    time_stamp(); 
152B0:  CALL   541A
....................    strcat(data_buffer, time_stmp_str); 
152B4:  MOVLB  8
152B6:  CLRF   xF9
152B8:  MOVLW  67
152BA:  MOVWF  xF8
152BC:  MOVLW  02
152BE:  MOVWF  xFB
152C0:  MOVLW  99
152C2:  MOVWF  xFA
152C4:  MOVLB  0
152C6:  CALL   54DE
....................    strcat(data_buffer, comma); 
152CA:  MOVLB  8
152CC:  CLRF   xF9
152CE:  MOVLW  67
152D0:  MOVWF  xF8
152D2:  MOVLW  08
152D4:  MOVWF  xFB
152D6:  MOVLW  A0
152D8:  MOVWF  xFA
152DA:  MOVLB  0
152DC:  CALL   54DE
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
152E0:  MOVLW  08
152E2:  MOVWF  1E
152E4:  MOVLW  A5
152E6:  MOVWF  1D
152E8:  MOVFF  89D,8ED
152EC:  MOVLW  1B
152EE:  MOVLB  8
152F0:  MOVWF  xEE
152F2:  MOVLB  0
152F4:  CALL   5280
152F8:  MOVLW  2C
152FA:  MOVLB  8
152FC:  MOVWF  xFF
152FE:  MOVLB  0
15300:  CALL   509E
15304:  MOVLW  10
15306:  MOVWF  FE9
15308:  MOVFF  89F,8F7
1530C:  MOVFF  89E,8F6
15310:  CALL   AAFE
....................    strcat(data_buffer, config_str); 
15314:  MOVLB  8
15316:  CLRF   xF9
15318:  MOVLW  67
1531A:  MOVWF  xF8
1531C:  MOVLW  08
1531E:  MOVWF  xFB
15320:  MOVLW  A5
15322:  MOVWF  xFA
15324:  MOVLB  0
15326:  CALL   54DE
....................    strcat(data_buffer, endofline); 
1532A:  MOVLB  8
1532C:  CLRF   xF9
1532E:  MOVLW  67
15330:  MOVWF  xF8
15332:  MOVLW  08
15334:  MOVWF  xFB
15336:  MOVLW  A2
15338:  MOVWF  xFA
1533A:  MOVLB  0
1533C:  CALL   54DE
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
15340:  MOVF   1F,W
15342:  SUBLW  04
15344:  BNZ   15364
15346:  MOVF   20,F
15348:  BNZ   15364
1534A:  CLRF   FEA
1534C:  MOVLW  67
1534E:  MOVWF  FE9
15350:  CALL   7996
15354:  MOVLW  0D
15356:  BTFSS  F9E.4
15358:  BRA    15356
1535A:  MOVWF  FAD
1535C:  MOVLW  0A
1535E:  BTFSS  F9E.4
15360:  BRA    1535E
15362:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
15364:  MOVLB  2
15366:  MOVF   xDC,F
15368:  BNZ   153BC
....................     
....................       buffer_select = 0; 
1536A:  MOVLB  0
1536C:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
1536E:  MOVLB  8
15370:  CLRF   xED
15372:  MOVLB  0
15374:  CALL   5586
....................          append_data(file_ptr_raw_all); 
15378:  MOVLW  02
1537A:  MOVLB  8
1537C:  MOVWF  xEE
1537E:  MOVLW  DD
15380:  MOVWF  xED
15382:  MOVLB  0
15384:  CALL   82F8
....................       heartbeat(TRUE);          
15388:  MOVLW  01
1538A:  MOVLB  8
1538C:  MOVWF  xED
1538E:  MOVLB  0
15390:  CALL   5586
....................        
....................       heartbeat(FALSE); 
15394:  MOVLB  8
15396:  CLRF   xED
15398:  MOVLB  0
1539A:  CALL   5586
....................          append_data(file_ptr_raw_new);    
1539E:  MOVLW  02
153A0:  MOVLB  8
153A2:  MOVWF  xEE
153A4:  MOVLW  EB
153A6:  MOVWF  xED
153A8:  MOVLB  0
153AA:  CALL   82F8
....................       heartbeat(TRUE); 
153AE:  MOVLW  01
153B0:  MOVLB  8
153B2:  MOVWF  xED
153B4:  MOVLB  0
153B6:  CALL   5586
153BA:  MOVLB  2
....................    } 
153BC:  MOVLB  0
153BE:  GOTO   1555A (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUvY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D370:  BSF    F90.7
....................    delay_ms(500); 
0D372:  MOVLW  02
0D374:  MOVLB  8
0D376:  MOVWF  xC2
0D378:  MOVLW  FA
0D37A:  MOVLB  9
0D37C:  MOVWF  xEC
0D37E:  MOVLB  0
0D380:  CALL   2910
0D384:  MOVLB  8
0D386:  DECFSZ xC2,F
0D388:  BRA    D378
....................    bus_pwr_status=1; 
0D38A:  MOVLW  01
0D38C:  MOVLB  4
0D38E:  MOVWF  xB6
0D390:  MOVLB  0
0D392:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D394:  BCF    F90.7
....................    delay_ms(100); 
0D396:  MOVLW  64
0D398:  MOVLB  9
0D39A:  MOVWF  xEC
0D39C:  MOVLB  0
0D39E:  CALL   2910
....................    bus_pwr_status=0; 
0D3A2:  MOVLB  4
0D3A4:  CLRF   xB6
0D3A6:  MOVLB  0
0D3A8:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
17FAA:  MOVLB  8
17FAC:  CLRF   x97
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
17FAE:  CLRF   x97
17FB0:  MOVF   x97,W
17FB2:  SUBLW  31
17FB4:  BNC   17FCA
....................       string_arg[i] = 0; 
17FB6:  CLRF   03
17FB8:  MOVF   x97,W
17FBA:  ADDLW  25
17FBC:  MOVWF  FE9
17FBE:  MOVLW  08
17FC0:  ADDWFC 03,W
17FC2:  MOVWF  FEA
17FC4:  CLRF   FEF
17FC6:  INCF   x97,F
17FC8:  BRA    17FB0
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
17FCA:  CLRF   x97
17FCC:  MOVF   x97,W
17FCE:  SUBLW  31
17FD0:  BNC   1804A
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
17FD2:  CLRF   03
17FD4:  MOVF   x97,W
17FD6:  ADDLW  25
17FD8:  MOVWF  FE9
17FDA:  MOVLW  08
17FDC:  ADDWFC 03,W
17FDE:  MOVWF  FEA
17FE0:  MOVFF  FEA,89B
17FE4:  MOVFF  FE9,89A
17FE8:  MOVLB  0
17FEA:  CALL   0E30
17FEE:  MOVFF  89B,FEA
17FF2:  MOVFF  89A,FE9
17FF6:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
17FFA:  DECFSZ 4C,W
17FFC:  BRA    1801A
....................       { 
....................          fputc(string_arg[i],COM_A); 
17FFE:  CLRF   03
18000:  MOVLB  8
18002:  MOVF   x97,W
18004:  ADDLW  25
18006:  MOVWF  FE9
18008:  MOVLW  08
1800A:  ADDWFC 03,W
1800C:  MOVWF  FEA
1800E:  MOVFF  FEF,898
18012:  MOVF   x98,W
18014:  MOVLB  0
18016:  CALL   AEB8
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
1801A:  CLRF   03
1801C:  MOVLB  8
1801E:  MOVF   x97,W
18020:  ADDLW  25
18022:  MOVWF  FE9
18024:  MOVLW  08
18026:  ADDWFC 03,W
18028:  MOVWF  FEA
1802A:  MOVF   FEF,W
1802C:  SUBLW  0D
1802E:  BZ    18044
18030:  CLRF   03
18032:  MOVF   x97,W
18034:  ADDLW  25
18036:  MOVWF  FE9
18038:  MOVLW  08
1803A:  ADDWFC 03,W
1803C:  MOVWF  FEA
1803E:  MOVF   FEF,W
18040:  SUBLW  0A
18042:  BNZ   18046
....................       { 
....................          break; 
18044:  BRA    1804A
....................       } 
18046:  INCF   x97,F
18048:  BRA    17FCC
....................    } 
1804A:  MOVLB  0
1804C:  GOTO   18374 (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
181F2:  MOVLB  8
181F4:  CLRF   x97
....................    macro_arg = 0; 
181F6:  CLRF   x99
181F8:  CLRF   x98
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
181FA:  MOVF   x97,W
181FC:  SUBLW  0D
181FE:  BZ    1828A
....................       number = fgetc(COM_A); 
18200:  MOVLB  0
18202:  CALL   0E30
18206:  MOVFF  01,897
....................       if (com_echo == TRUE) 
1820A:  DECFSZ 4C,W
1820C:  BRA    1821E
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
1820E:  MOVLB  8
18210:  MOVF   x97,W
18212:  SUBLW  0D
18214:  BZ    18220
18216:  MOVF   x97,W
18218:  MOVLB  0
1821A:  CALL   AEB8
1821E:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
18220:  MOVF   x97,W
18222:  SUBLW  2F
18224:  BC    1825A
18226:  MOVF   x97,W
18228:  SUBLW  39
1822A:  BNC   1825A
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
1822C:  MOVLW  30
1822E:  SUBWF  x97,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
18230:  MOVFF  899,A11
18234:  MOVFF  898,A10
18238:  MOVLB  A
1823A:  CLRF   x13
1823C:  MOVLW  0A
1823E:  MOVWF  x12
18240:  MOVLB  0
18242:  CALL   5C98
18246:  MOVFF  02,899
1824A:  MOVFF  01,898
....................          macro_arg = macro_arg + number;                // for each number 
1824E:  MOVLB  8
18250:  MOVF   x97,W
18252:  ADDWF  x98,F
18254:  MOVLW  00
18256:  ADDWFC x99,F
....................       } 
18258:  BRA    18288
....................       else if (number == CARRIAGE_RET) 
1825A:  MOVF   x97,W
1825C:  SUBLW  0D
1825E:  BNZ   18280
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
18260:  INCFSZ x98,W
18262:  BRA    1826A
18264:  INCFSZ x99,W
18266:  BRA    1826A
18268:  BRA    18276
1826A:  MOVFF  898,01
1826E:  MOVFF  899,02
18272:  BRA    1828A
18274:  BRA    1827E
....................          else return(65535); 
18276:  MOVLW  FF
18278:  MOVWF  01
1827A:  MOVWF  02
1827C:  BRA    1828A
....................       } 
1827E:  BRA    18288
....................       else 
....................       { 
....................          return(65535); 
18280:  MOVLW  FF
18282:  MOVWF  01
18284:  MOVWF  02
18286:  BRA    1828A
....................       } 
18288:  BRA    181FA
....................    } 
1828A:  MOVLB  0
1828C:  GOTO   1839E (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
17D34:  MOVF   2F,W
17D36:  MOVWF  00
17D38:  MOVF   30,W
17D3A:  MOVWF  03
17D3C:  BNZ   17D42
17D3E:  MOVF   00,F
17D40:  BZ    17D68
17D42:  MOVF   03,W
17D44:  BNZ   17D4E
17D46:  MOVLW  03
17D48:  SUBWF  00,W
17D4A:  BTFSC  FD8.2
17D4C:  BRA    17E2C
17D4E:  MOVF   03,W
17D50:  BNZ   17D5A
17D52:  MOVLW  01
17D54:  SUBWF  00,W
17D56:  BTFSC  FD8.2
17D58:  BRA    17E2C
17D5A:  MOVF   03,W
17D5C:  BNZ   17D66
17D5E:  MOVLW  02
17D60:  SUBWF  00,W
17D62:  BTFSC  FD8.2
17D64:  BRA    17EA2
17D66:  BRA    17F10
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
17D68:  MOVLB  8
17D6A:  MOVF   x9B,F
17D6C:  BNZ   17D9C
17D6E:  MOVF   x9A,W
17D70:  SUBLW  23
17D72:  BZ    17D96
17D74:  MOVF   x9A,W
17D76:  SUBLW  25
17D78:  BZ    17D96
17D7A:  MOVF   x9A,W
17D7C:  SUBLW  3B
17D7E:  BZ    17D96
17D80:  MOVF   x9A,W
17D82:  SUBLW  4D
17D84:  BZ    17D96
17D86:  MOVF   x9A,W
17D88:  SUBLW  5A
17D8A:  BZ    17D96
17D8C:  MOVF   x9A,W
17D8E:  SUBLW  72
17D90:  BZ    17D96
17D92:  MOVLW  00
17D94:  BRA    17D98
17D96:  MOVLW  01
17D98:  MOVWF  x9C
17D9A:  BRA    17E28
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
17D9C:  MOVF   x9A,W
17D9E:  SUBLW  23
17DA0:  BZ    17E24
17DA2:  MOVF   x9A,W
17DA4:  SUBLW  25
17DA6:  BZ    17E24
17DA8:  MOVF   x9A,W
17DAA:  SUBLW  2B
17DAC:  BZ    17E24
17DAE:  MOVF   x9A,W
17DB0:  SUBLW  2D
17DB2:  BZ    17E24
17DB4:  MOVF   x9A,W
17DB6:  SUBLW  2F
17DB8:  BZ    17E24
17DBA:  MOVF   x9A,W
17DBC:  SUBLW  3B
17DBE:  BZ    17E24
17DC0:  MOVF   x9A,W
17DC2:  SUBLW  41
17DC4:  BZ    17E24
17DC6:  MOVF   x9A,W
17DC8:  SUBLW  42
17DCA:  BC    17DD2
17DCC:  MOVF   x9A,W
17DCE:  SUBLW  44
17DD0:  BC    17E24
17DD2:  MOVF   x9A,W
17DD4:  SUBLW  45
17DD6:  BC    17DDE
17DD8:  MOVF   x9A,W
17DDA:  SUBLW  48
17DDC:  BC    17E24
17DDE:  MOVF   x9A,W
17DE0:  SUBLW  4A
17DE2:  BC    17DEA
17DE4:  MOVF   x9A,W
17DE6:  SUBLW  4C
17DE8:  BC    17E24
17DEA:  MOVF   x9A,W
17DEC:  SUBLW  4F
17DEE:  BC    17DF6
17DF0:  MOVF   x9A,W
17DF2:  SUBLW  55
17DF4:  BC    17E24
17DF6:  MOVF   x9A,W
17DF8:  SUBLW  59
17DFA:  BZ    17E24
17DFC:  MOVF   x9A,W
17DFE:  SUBLW  64
17E00:  BZ    17E24
17E02:  MOVF   x9A,W
17E04:  SUBLW  69
17E06:  BZ    17E24
17E08:  MOVF   x9A,W
17E0A:  SUBLW  6C
17E0C:  BZ    17E24
17E0E:  MOVF   x9A,W
17E10:  SUBLW  70
17E12:  BZ    17E24
17E14:  MOVF   x9A,W
17E16:  SUBLW  72
17E18:  BZ    17E24
17E1A:  MOVF   x9A,W
17E1C:  SUBLW  76
17E1E:  BZ    17E24
17E20:  MOVLW  00
17E22:  BRA    17E26
17E24:  MOVLW  01
17E26:  MOVWF  x9C
....................          break; 
17E28:  MOVLB  0
17E2A:  BRA    17F10
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
17E2C:  MOVLB  8
17E2E:  MOVF   x9B,F
17E30:  BNZ   17E5A
17E32:  MOVF   x9A,W
17E34:  SUBLW  23
17E36:  BZ    17E54
17E38:  MOVF   x9A,W
17E3A:  SUBLW  3B
17E3C:  BZ    17E54
17E3E:  MOVF   x9A,W
17E40:  SUBLW  4A
17E42:  BZ    17E54
17E44:  MOVF   x9A,W
17E46:  SUBLW  4D
17E48:  BZ    17E54
17E4A:  MOVF   x9A,W
17E4C:  SUBLW  50
17E4E:  BZ    17E54
17E50:  MOVLW  00
17E52:  BRA    17E56
17E54:  MOVLW  01
17E56:  MOVWF  x9C
17E58:  BRA    17E9E
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
17E5A:  MOVF   x9A,W
17E5C:  SUBLW  23
17E5E:  BZ    17E9A
17E60:  MOVF   x9A,W
17E62:  SUBLW  2B
17E64:  BZ    17E9A
17E66:  MOVF   x9A,W
17E68:  SUBLW  2D
17E6A:  BZ    17E9A
17E6C:  MOVF   x9A,W
17E6E:  SUBLW  3B
17E70:  BZ    17E9A
17E72:  MOVF   x9A,W
17E74:  SUBLW  42
17E76:  BZ    17E9A
17E78:  MOVF   x9A,W
17E7A:  SUBLW  47
17E7C:  BZ    17E9A
17E7E:  MOVF   x9A,W
17E80:  SUBLW  4F
17E82:  BC    17E8A
17E84:  MOVF   x9A,W
17E86:  SUBLW  52
17E88:  BC    17E9A
17E8A:  MOVF   x9A,W
17E8C:  SUBLW  54
17E8E:  BZ    17E9A
17E90:  MOVF   x9A,W
17E92:  SUBLW  59
17E94:  BZ    17E9A
17E96:  MOVLW  00
17E98:  BRA    17E9C
17E9A:  MOVLW  01
17E9C:  MOVWF  x9C
....................          break;   
17E9E:  MOVLB  0
17EA0:  BRA    17F10
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17EA2:  MOVLB  8
17EA4:  MOVF   x9B,F
17EA6:  BNZ   17ECA
17EA8:  MOVF   x9A,W
17EAA:  SUBLW  23
17EAC:  BZ    17EC4
17EAE:  MOVF   x9A,W
17EB0:  SUBLW  3B
17EB2:  BZ    17EC4
17EB4:  MOVF   x9A,W
17EB6:  SUBLW  4D
17EB8:  BZ    17EC4
17EBA:  MOVF   x9A,W
17EBC:  SUBLW  50
17EBE:  BZ    17EC4
17EC0:  MOVLW  00
17EC2:  BRA    17EC6
17EC4:  MOVLW  01
17EC6:  MOVWF  x9C
17EC8:  BRA    17F0E
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
17ECA:  MOVF   x9A,W
17ECC:  SUBLW  23
17ECE:  BZ    17F0A
17ED0:  MOVF   x9A,W
17ED2:  SUBLW  2B
17ED4:  BZ    17F0A
17ED6:  MOVF   x9A,W
17ED8:  SUBLW  2D
17EDA:  BZ    17F0A
17EDC:  MOVF   x9A,W
17EDE:  SUBLW  3B
17EE0:  BZ    17F0A
17EE2:  MOVF   x9A,W
17EE4:  SUBLW  42
17EE6:  BC    17EEE
17EE8:  MOVF   x9A,W
17EEA:  SUBLW  44
17EEC:  BC    17F0A
17EEE:  MOVF   x9A,W
17EF0:  SUBLW  4F
17EF2:  BC    17EFA
17EF4:  MOVF   x9A,W
17EF6:  SUBLW  51
17EF8:  BC    17F0A
17EFA:  MOVF   x9A,W
17EFC:  SUBLW  53
17EFE:  BZ    17F0A
17F00:  MOVF   x9A,W
17F02:  SUBLW  59
17F04:  BZ    17F0A
17F06:  MOVLW  00
17F08:  BRA    17F0C
17F0A:  MOVLW  01
17F0C:  MOVWF  x9C
....................          break;   
17F0E:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17F10:  MOVLB  8
17F12:  MOVFF  89C,01
17F16:  MOVLB  0
17F18:  GOTO   17F44 (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17F1C:  MOVLW  01
17F1E:  MOVLB  8
17F20:  MOVWF  x99
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17F22:  MOVLB  0
17F24:  CALL   0E30
17F28:  MOVFF  01,898
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17F2C:  DECFSZ 4C,W
17F2E:  BRA    17F3A
17F30:  MOVLB  8
17F32:  MOVF   x98,W
17F34:  MOVLB  0
17F36:  CALL   AEB8
....................          valid_macro = check_macro(e, macro); 
17F3A:  MOVFF  898,89A
17F3E:  MOVFF  897,89B
17F42:  BRA    17D34
17F44:  MOVFF  01,899
....................       if (valid_macro == TRUE) { 
17F48:  MOVLB  8
17F4A:  DECFSZ x99,W
17F4C:  BRA    17F56
....................          return(e); 
17F4E:  MOVFF  898,01
17F52:  BRA    17F62
....................       } 
17F54:  BRA    17F5C
....................       else return(0); 
17F56:  MOVLW  00
17F58:  MOVWF  01
17F5A:  BRA    17F62
....................    } while (valid_macro == TRUE); 
17F5C:  DECFSZ x99,W
17F5E:  BRA    17F62
17F60:  BRA    17F22
17F62:  MOVLB  0
17F64:  GOTO   18356 (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
182DC:  BCF    FD8.0
182DE:  MOVLB  8
182E0:  RLCF   x9A,W
182E2:  CLRF   03
182E4:  ADDLW  D1
182E6:  MOVWF  FE9
182E8:  MOVLW  07
182EA:  ADDWFC 03,W
182EC:  MOVWF  FEA
182EE:  MOVFF  FEC,8A0
182F2:  MOVF   FED,F
182F4:  MOVFF  FEF,89F
182F8:  MOVFF  89C,A11
182FC:  MOVFF  89B,A10
18300:  MOVLB  A
18302:  CLRF   x13
18304:  MOVLW  03
18306:  MOVWF  x12
18308:  MOVLB  0
1830A:  CALL   5C98
1830E:  MOVF   01,W
18310:  MOVLB  8
18312:  ADDWF  x9F,W
18314:  MOVWF  x9D
18316:  MOVF   02,W
18318:  ADDWFC xA0,W
1831A:  MOVWF  x9E
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
1831C:  MOVFF  89E,8A8
18320:  MOVFF  89D,8A7
18324:  MOVFF  897,8A9
18328:  MOVLB  0
1832A:  RCALL  18050
....................     
....................    ++addr; 
1832C:  MOVLB  8
1832E:  INCF   x9D,F
18330:  BTFSC  FD8.2
18332:  INCF   x9E,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
18334:  MOVFF  89E,8A0
18338:  MOVFF  89D,89F
1833C:  MOVFF  899,8A2
18340:  MOVFF  898,8A1
18344:  MOVLB  0
18346:  BRA    18290
18348:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
180B0:  BCF    FD8.0
180B2:  MOVLB  8
180B4:  RLCF   x98,W
180B6:  CLRF   03
180B8:  ADDLW  D1
180BA:  MOVWF  FE9
180BC:  MOVLW  07
180BE:  ADDWFC 03,W
180C0:  MOVWF  FEA
180C2:  MOVFF  FEC,8A1
180C6:  MOVF   FED,F
180C8:  MOVFF  FEF,8A0
180CC:  MOVFF  89A,A11
180D0:  MOVFF  899,A10
180D4:  MOVLB  A
180D6:  CLRF   x13
180D8:  MOVLW  03
180DA:  MOVWF  x12
180DC:  MOVLB  0
180DE:  CALL   5C98
180E2:  MOVF   01,W
180E4:  MOVLB  8
180E6:  ADDWF  xA0,W
180E8:  MOVWF  x9D
180EA:  MOVF   02,W
180EC:  ADDWFC xA1,W
180EE:  MOVWF  x9E
....................    write_ext_eeprom(addr, macro_cmd); 
180F0:  MOVFF  89E,8A8
180F4:  MOVFF  89D,8A7
180F8:  MOVFF  897,8A9
180FC:  MOVLB  0
180FE:  RCALL  18050
....................     
....................    int i = 0; 
18100:  MOVLB  8
18102:  CLRF   x9F
....................    addr = string_address[macro] + (count*50); 
18104:  BCF    FD8.0
18106:  RLCF   x98,W
18108:  CLRF   03
1810A:  ADDLW  FB
1810C:  MOVWF  FE9
1810E:  MOVLW  07
18110:  ADDWFC 03,W
18112:  MOVWF  FEA
18114:  MOVFF  FEC,8A1
18118:  MOVF   FED,F
1811A:  MOVFF  FEF,8A0
1811E:  MOVFF  89C,A11
18122:  MOVFF  89B,A10
18126:  MOVLB  A
18128:  CLRF   x13
1812A:  MOVLW  32
1812C:  MOVWF  x12
1812E:  MOVLB  0
18130:  CALL   5C98
18134:  MOVF   01,W
18136:  MOVLB  8
18138:  ADDWF  xA0,W
1813A:  MOVWF  x9D
1813C:  MOVF   02,W
1813E:  ADDWFC xA1,W
18140:  MOVWF  x9E
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
18142:  MOVF   x9C,F
18144:  BNZ   1819A
18146:  MOVF   x9B,W
18148:  SUBLW  14
1814A:  BNC   1819A
....................       for(i = 0; i<50; i++) { 
1814C:  CLRF   x9F
1814E:  MOVF   x9F,W
18150:  SUBLW  31
18152:  BNC   18198
....................          write_ext_eeprom(addr + i, string_arg[i]); 
18154:  MOVF   x9F,W
18156:  ADDWF  x9D,W
18158:  MOVWF  xA0
1815A:  MOVLW  00
1815C:  ADDWFC x9E,W
1815E:  MOVWF  xA1
18160:  CLRF   03
18162:  MOVF   x9F,W
18164:  ADDLW  25
18166:  MOVWF  FE9
18168:  MOVLW  08
1816A:  ADDWFC 03,W
1816C:  MOVWF  FEA
1816E:  MOVFF  FEF,8A9
18172:  MOVFF  8A1,8A8
18176:  MOVFF  8A0,8A7
1817A:  MOVLB  0
1817C:  RCALL  18050
....................          if(string_arg[i] == 0){ 
1817E:  CLRF   03
18180:  MOVLB  8
18182:  MOVF   x9F,W
18184:  ADDLW  25
18186:  MOVWF  FE9
18188:  MOVLW  08
1818A:  ADDWFC 03,W
1818C:  MOVWF  FEA
1818E:  MOVF   FEF,F
18190:  BNZ   18194
....................             break; 
18192:  BRA    18198
....................          } 
18194:  INCF   x9F,F
18196:  BRA    1814E
....................       
....................       } 
....................    }else{ 
18198:  BRA    181EC
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
1819A:  MOVLW  CA
1819C:  MOVWF  FF6
1819E:  MOVLW  20
181A0:  MOVWF  FF7
181A2:  MOVLW  00
181A4:  MOVWF  FF8
181A6:  CLRF   1B
181A8:  BTFSC  FF2.7
181AA:  BSF    1B.7
181AC:  BCF    FF2.7
181AE:  MOVLW  1E
181B0:  MOVLB  A
181B2:  MOVWF  x40
181B4:  MOVLB  0
181B6:  CALL   101C
181BA:  BTFSC  1B.7
181BC:  BSF    FF2.7
181BE:  MOVLW  10
181C0:  MOVWF  FE9
181C2:  CLRF   1B
181C4:  BTFSC  FF2.7
181C6:  BSF    1B.7
181C8:  BCF    FF2.7
181CA:  MOVFF  89A,A41
181CE:  MOVFF  899,A40
181D2:  CALL   119E
181D6:  BTFSC  1B.7
181D8:  BSF    FF2.7
181DA:  MOVLW  0A
181DC:  BTFSS  F9E.4
181DE:  BRA    181DC
181E0:  MOVWF  FAD
181E2:  MOVLW  0D
181E4:  BTFSS  F9E.4
181E6:  BRA    181E4
181E8:  MOVWF  FAD
181EA:  MOVLB  8
....................    } 
181EC:  MOVLB  0
181EE:  GOTO   1838E (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
1852E:  CALL   105D0
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
18532:  MOVLW  3B
18534:  MOVLB  8
18536:  MOVWF  x97
18538:  CLRF   x99
1853A:  CLRF   x98
1853C:  CLRF   x9A
1853E:  CLRF   x9C
18540:  CLRF   x9B
18542:  MOVLB  0
18544:  RCALL  182DC
....................     
....................    write_macro_line(59, 0, 1, 0); 
18546:  MOVLW  3B
18548:  MOVLB  8
1854A:  MOVWF  x97
1854C:  CLRF   x99
1854E:  CLRF   x98
18550:  MOVLW  01
18552:  MOVWF  x9A
18554:  CLRF   x9C
18556:  CLRF   x9B
18558:  MOVLB  0
1855A:  RCALL  182DC
....................    write_macro_line(59, 0, 2, 0); 
1855C:  MOVLW  3B
1855E:  MOVLB  8
18560:  MOVWF  x97
18562:  CLRF   x99
18564:  CLRF   x98
18566:  MOVLW  02
18568:  MOVWF  x9A
1856A:  CLRF   x9C
1856C:  CLRF   x9B
1856E:  MOVLB  0
18570:  RCALL  182DC
....................    write_macro_line(59, 0, 3, 0); 
18572:  MOVLW  3B
18574:  MOVLB  8
18576:  MOVWF  x97
18578:  CLRF   x99
1857A:  CLRF   x98
1857C:  MOVLW  03
1857E:  MOVWF  x9A
18580:  CLRF   x9C
18582:  CLRF   x9B
18584:  MOVLB  0
18586:  RCALL  182DC
....................    write_macro_line(59, 0, 4, 0); 
18588:  MOVLW  3B
1858A:  MOVLB  8
1858C:  MOVWF  x97
1858E:  CLRF   x99
18590:  CLRF   x98
18592:  MOVLW  04
18594:  MOVWF  x9A
18596:  CLRF   x9C
18598:  CLRF   x9B
1859A:  MOVLB  0
1859C:  RCALL  182DC
....................    write_macro_line(59, 0, 5, 0); 
1859E:  MOVLW  3B
185A0:  MOVLB  8
185A2:  MOVWF  x97
185A4:  CLRF   x99
185A6:  CLRF   x98
185A8:  MOVLW  05
185AA:  MOVWF  x9A
185AC:  CLRF   x9C
185AE:  CLRF   x9B
185B0:  MOVLB  0
185B2:  RCALL  182DC
....................    write_macro_line(59, 0, 6, 0); 
185B4:  MOVLW  3B
185B6:  MOVLB  8
185B8:  MOVWF  x97
185BA:  CLRF   x99
185BC:  CLRF   x98
185BE:  MOVLW  06
185C0:  MOVWF  x9A
185C2:  CLRF   x9C
185C4:  CLRF   x9B
185C6:  MOVLB  0
185C8:  RCALL  182DC
....................    write_macro_line(59, 0, 7, 0); 
185CA:  MOVLW  3B
185CC:  MOVLB  8
185CE:  MOVWF  x97
185D0:  CLRF   x99
185D2:  CLRF   x98
185D4:  MOVLW  07
185D6:  MOVWF  x9A
185D8:  CLRF   x9C
185DA:  CLRF   x9B
185DC:  MOVLB  0
185DE:  RCALL  182DC
....................    write_macro_line(59, 0, 8, 0); 
185E0:  MOVLW  3B
185E2:  MOVLB  8
185E4:  MOVWF  x97
185E6:  CLRF   x99
185E8:  CLRF   x98
185EA:  MOVLW  08
185EC:  MOVWF  x9A
185EE:  CLRF   x9C
185F0:  CLRF   x9B
185F2:  MOVLB  0
185F4:  RCALL  182DC
....................     
....................    write_macro_line(59, 0, 9, 0); 
185F6:  MOVLW  3B
185F8:  MOVLB  8
185FA:  MOVWF  x97
185FC:  CLRF   x99
185FE:  CLRF   x98
18600:  MOVLW  09
18602:  MOVWF  x9A
18604:  CLRF   x9C
18606:  CLRF   x9B
18608:  MOVLB  0
1860A:  RCALL  182DC
....................    write_macro_line(59, 0, 10, 0); 
1860C:  MOVLW  3B
1860E:  MOVLB  8
18610:  MOVWF  x97
18612:  CLRF   x99
18614:  CLRF   x98
18616:  MOVLW  0A
18618:  MOVWF  x9A
1861A:  CLRF   x9C
1861C:  CLRF   x9B
1861E:  MOVLB  0
18620:  RCALL  182DC
....................    write_macro_line(59, 0, 11, 0); 
18622:  MOVLW  3B
18624:  MOVLB  8
18626:  MOVWF  x97
18628:  CLRF   x99
1862A:  CLRF   x98
1862C:  MOVLW  0B
1862E:  MOVWF  x9A
18630:  CLRF   x9C
18632:  CLRF   x9B
18634:  MOVLB  0
18636:  RCALL  182DC
....................    write_macro_line(59, 0, 12, 0); 
18638:  MOVLW  3B
1863A:  MOVLB  8
1863C:  MOVWF  x97
1863E:  CLRF   x99
18640:  CLRF   x98
18642:  MOVLW  0C
18644:  MOVWF  x9A
18646:  CLRF   x9C
18648:  CLRF   x9B
1864A:  MOVLB  0
1864C:  RCALL  182DC
....................    write_macro_line(59, 0, 13, 0); 
1864E:  MOVLW  3B
18650:  MOVLB  8
18652:  MOVWF  x97
18654:  CLRF   x99
18656:  CLRF   x98
18658:  MOVLW  0D
1865A:  MOVWF  x9A
1865C:  CLRF   x9C
1865E:  CLRF   x9B
18660:  MOVLB  0
18662:  RCALL  182DC
....................    write_macro_line(59, 0, 14, 0); 
18664:  MOVLW  3B
18666:  MOVLB  8
18668:  MOVWF  x97
1866A:  CLRF   x99
1866C:  CLRF   x98
1866E:  MOVLW  0E
18670:  MOVWF  x9A
18672:  CLRF   x9C
18674:  CLRF   x9B
18676:  MOVLB  0
18678:  RCALL  182DC
....................    write_macro_line(59, 0, 15, 0); 
1867A:  MOVLW  3B
1867C:  MOVLB  8
1867E:  MOVWF  x97
18680:  CLRF   x99
18682:  CLRF   x98
18684:  MOVLW  0F
18686:  MOVWF  x9A
18688:  CLRF   x9C
1868A:  CLRF   x9B
1868C:  MOVLB  0
1868E:  RCALL  182DC
....................    write_macro_line(59, 0, 16, 0); 
18690:  MOVLW  3B
18692:  MOVLB  8
18694:  MOVWF  x97
18696:  CLRF   x99
18698:  CLRF   x98
1869A:  MOVLW  10
1869C:  MOVWF  x9A
1869E:  CLRF   x9C
186A0:  CLRF   x9B
186A2:  MOVLB  0
186A4:  RCALL  182DC
186A6:  GOTO   186DE (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
17F68:  MOVLB  8
17F6A:  CLRF   x97
....................     
....................    heartbeat(FALSE); 
17F6C:  CLRF   xED
17F6E:  MOVLB  0
17F70:  CALL   5586
....................     
....................    while(mcc != CARRIAGE_RET){ 
17F74:  MOVLB  8
17F76:  MOVF   x97,W
17F78:  SUBLW  0D
17F7A:  BZ    17F9C
....................       if (kbhit(COM_A)) { 
17F7C:  BTFSS  F9E.5
17F7E:  BRA    17F9A
....................          mcc=fgetc(COM_A); 
17F80:  MOVLB  0
17F82:  CALL   0E30
17F86:  MOVFF  01,897
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
17F8A:  DECFSZ 4C,W
17F8C:  BRA    17F98
17F8E:  MOVLB  8
17F90:  MOVF   x97,W
17F92:  MOVLB  0
17F94:  CALL   AEB8
17F98:  MOVLB  8
....................       } 
17F9A:  BRA    17F76
....................    } 
....................     
....................    heartbeat(TRUE); 
17F9C:  MOVLW  01
17F9E:  MOVWF  xED
17FA0:  MOVLB  0
17FA2:  CALL   5586
17FA6:  GOTO   18366 (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
1834A:  MOVLB  8
1834C:  CLRF   x96
....................     
....................    macro_cmd = get_cmd(macro); 
1834E:  MOVFF  88E,897
18352:  MOVLB  0
18354:  BRA    17F1C
18356:  MOVFF  01,893
....................    if (macro_cmd == 35){  
1835A:  MOVLB  8
1835C:  MOVF   x93,W
1835E:  SUBLW  23
18360:  BNZ   1836A
....................       macro_comment();        // # = 35 
18362:  MOVLB  0
18364:  BRA    17F68
....................    }else if(macro_cmd == 112){// 112 is p 
18366:  BRA    183EC
18368:  MOVLB  8
1836A:  MOVF   x93,W
1836C:  SUBLW  70
1836E:  BNZ   18396
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
18370:  MOVLB  0
18372:  BRA    17FAA
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
18374:  MOVFF  893,897
18378:  MOVFF  88E,898
1837C:  MOVFF  890,89A
18380:  MOVFF  88F,899
18384:  MOVFF  892,89C
18388:  MOVFF  891,89B
1838C:  BRA    180B0
....................       valid_macro = TRUE; 
1838E:  MOVLW  01
18390:  MOVLB  8
18392:  MOVWF  x96
....................    }else{ 
18394:  BRA    183EA
....................       if (macro_cmd != 0) { 
18396:  MOVF   x93,F
18398:  BZ    183C0
....................          macro_arg = get_arg(); 
1839A:  MOVLB  0
1839C:  BRA    181F2
1839E:  MOVFF  02,895
183A2:  MOVFF  01,894
....................          if (macro_arg != 65535) valid_macro = TRUE; 
183A6:  MOVLB  8
183A8:  INCFSZ x94,W
183AA:  BRA    183B2
183AC:  INCFSZ x95,W
183AE:  BRA    183B2
183B0:  BRA    183B8
183B2:  MOVLW  01
183B4:  MOVWF  x96
183B6:  BRA    183BE
....................          else return(macro_cmd); 
183B8:  MOVFF  893,01
183BC:  BRA    183F2
....................       }else return(macro_cmd); 
183BE:  BRA    183C6
183C0:  MOVFF  893,01
183C4:  BRA    183F2
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
183C6:  MOVFF  893,897
183CA:  MOVFF  895,899
183CE:  MOVFF  894,898
183D2:  MOVFF  88E,89A
183D6:  MOVFF  890,89C
183DA:  MOVFF  88F,89B
183DE:  MOVLB  0
183E0:  RCALL  182DC
....................       return(macro_cmd); 
183E2:  MOVLB  8
183E4:  MOVFF  893,01
183E8:  BRA    183F2
183EA:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
183EC:  MOVLB  8
183EE:  MOVFF  893,01
183F2:  MOVLB  0
183F4:  GOTO   1843A (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
183F8:  MOVLB  8
183FA:  CLRF   x8D
183FC:  CLRF   x8C
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
183FE:  CLRF   x88
18400:  CLRF   x87
....................    valid_macro = TRUE; 
18402:  MOVLW  01
18404:  MOVWF  x89
....................    macro_cmd = 1; 
18406:  MOVWF  x8A
....................     
....................    init_ext_eeprom(); 
18408:  MOVLB  0
1840A:  CALL   105D0
....................     
....................    fprintf(COM_A, ":"); 
1840E:  MOVLW  3A
18410:  BTFSS  F9E.4
18412:  BRA    18410
18414:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
18416:  MOVLB  8
18418:  MOVF   x8A,W
1841A:  SUBLW  3B
1841C:  BZ    18480
1841E:  MOVF   x8A,F
18420:  BZ    18480
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
18422:  MOVFF  886,88E
18426:  MOVFF  888,890
1842A:  MOVFF  887,88F
1842E:  MOVFF  88D,892
18432:  MOVFF  88C,891
18436:  MOVLB  0
18438:  BRA    1834A
1843A:  MOVFF  01,88A
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
1843E:  MOVLB  8
18440:  MOVF   x8A,W
18442:  SUBLW  70
18444:  BNZ   1844C
....................          count++; 
18446:  INCF   x8C,F
18448:  BTFSC  FD8.2
1844A:  INCF   x8D,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
1844C:  MOVF   x8A,W
1844E:  SUBLW  23
18450:  BZ    18458
18452:  INCF   x87,F
18454:  BTFSC  FD8.2
18456:  INCF   x88,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
18458:  MOVF   x8A,W
1845A:  SUBLW  3B
1845C:  BZ    1847E
1845E:  MOVLW  EE
18460:  MOVWF  FF6
18462:  MOVLW  20
18464:  MOVWF  FF7
18466:  MOVLW  00
18468:  MOVWF  FF8
1846A:  CLRF   1B
1846C:  BTFSC  FF2.7
1846E:  BSF    1B.7
18470:  BCF    FF2.7
18472:  MOVLB  0
18474:  CALL   0E46
18478:  BTFSC  1B.7
1847A:  BSF    FF2.7
1847C:  MOVLB  8
1847E:  BRA    18418
....................    }       
....................    if (macro_cmd == 0){ 
18480:  MOVF   x8A,F
18482:  BNZ   18518
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
18484:  MOVLW  F2
18486:  MOVWF  FF6
18488:  MOVLW  20
1848A:  MOVWF  FF7
1848C:  MOVLW  00
1848E:  MOVWF  FF8
18490:  CLRF   1B
18492:  BTFSC  FF2.7
18494:  BSF    1B.7
18496:  BCF    FF2.7
18498:  MOVLB  0
1849A:  CALL   0E46
1849E:  BTFSC  1B.7
184A0:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
184A2:  MOVLW  1A
184A4:  MOVWF  FF6
184A6:  MOVLW  21
184A8:  MOVWF  FF7
184AA:  MOVLW  00
184AC:  MOVWF  FF8
184AE:  CLRF   1B
184B0:  BTFSC  FF2.7
184B2:  BSF    1B.7
184B4:  BCF    FF2.7
184B6:  MOVLW  15
184B8:  MOVLB  A
184BA:  MOVWF  x40
184BC:  MOVLB  0
184BE:  CALL   101C
184C2:  BTFSC  1B.7
184C4:  BSF    FF2.7
184C6:  MOVLW  10
184C8:  MOVWF  FE9
184CA:  MOVFF  888,8F1
184CE:  MOVFF  887,8F0
184D2:  CALL   8FE4
184D6:  MOVLW  32
184D8:  MOVWF  FF6
184DA:  MOVLW  21
184DC:  MOVWF  FF7
184DE:  MOVLW  00
184E0:  MOVWF  FF8
184E2:  CLRF   1B
184E4:  BTFSC  FF2.7
184E6:  BSF    1B.7
184E8:  BCF    FF2.7
184EA:  MOVLW  03
184EC:  MOVLB  A
184EE:  MOVWF  x40
184F0:  MOVLB  0
184F2:  CALL   101C
184F6:  BTFSC  1B.7
184F8:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
184FA:  MOVLW  36
184FC:  MOVWF  FF6
184FE:  MOVLW  21
18500:  MOVWF  FF7
18502:  MOVLW  00
18504:  MOVWF  FF8
18506:  CLRF   1B
18508:  BTFSC  FF2.7
1850A:  BSF    1B.7
1850C:  BCF    FF2.7
1850E:  CALL   0E46
18512:  BTFSC  1B.7
18514:  BSF    FF2.7
18516:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
18518:  MOVLW  0D
1851A:  BTFSS  F9E.4
1851C:  BRA    1851A
1851E:  MOVWF  FAD
18520:  MOVLW  0A
18522:  BTFSS  F9E.4
18524:  BRA    18522
18526:  MOVWF  FAD
18528:  MOVLB  0
1852A:  GOTO   186C6 (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
186E8:  BCF    FD8.0
186EA:  MOVLB  8
186EC:  RLCF   x8B,W
186EE:  CLRF   03
186F0:  ADDLW  D1
186F2:  MOVWF  FE9
186F4:  MOVLW  07
186F6:  ADDWFC 03,W
186F8:  MOVWF  FEA
186FA:  MOVFF  FEC,894
186FE:  MOVF   FED,F
18700:  MOVFF  FEF,893
18704:  MOVFF  88D,A11
18708:  MOVFF  88C,A10
1870C:  MOVLB  A
1870E:  CLRF   x13
18710:  MOVLW  03
18712:  MOVWF  x12
18714:  MOVLB  0
18716:  CALL   5C98
1871A:  MOVF   01,W
1871C:  MOVLB  8
1871E:  ADDWF  x93,W
18720:  MOVWF  x8E
18722:  MOVF   02,W
18724:  ADDWFC x94,W
18726:  MOVWF  x8F
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
18728:  MOVFF  88F,8CC
1872C:  MOVFF  88E,8CB
18730:  MOVLB  0
18732:  CALL   10608
18736:  MOVFF  01,890
....................    ++addr; 
1873A:  MOVLB  8
1873C:  INCF   x8E,F
1873E:  BTFSC  FD8.2
18740:  INCF   x8F,F
....................    macro_arg = read16_ext_eeprom(addr); 
18742:  MOVFF  88F,8C3
18746:  MOVFF  88E,8C2
1874A:  MOVLB  0
1874C:  CALL   1071C
18750:  MOVFF  02,892
18754:  MOVFF  01,891
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
18758:  MOVLB  8
1875A:  MOVF   x90,W
1875C:  BTFSS  F9E.4
1875E:  BRA    1875C
18760:  MOVWF  FAD
18762:  MOVLW  10
18764:  MOVWF  FE9
18766:  CLRF   1B
18768:  BTFSC  FF2.7
1876A:  BSF    1B.7
1876C:  BCF    FF2.7
1876E:  MOVFF  892,A41
18772:  MOVFF  891,A40
18776:  MOVLB  0
18778:  CALL   119E
1877C:  BTFSC  1B.7
1877E:  BSF    FF2.7
18780:  MOVLW  0D
18782:  BTFSS  F9E.4
18784:  BRA    18782
18786:  MOVWF  FAD
18788:  MOVLW  0A
1878A:  BTFSS  F9E.4
1878C:  BRA    1878A
1878E:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
18790:  MOVLB  8
18792:  MOVFF  890,01
18796:  MOVLB  0
18798:  GOTO   187CC (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
14348:  BCF    FD8.0
1434A:  MOVLB  8
1434C:  RLCF   xB7,W
1434E:  CLRF   03
14350:  ADDLW  D1
14352:  MOVWF  FE9
14354:  MOVLW  07
14356:  ADDWFC 03,W
14358:  MOVWF  FEA
1435A:  MOVFF  FEC,8C0
1435E:  MOVF   FED,F
14360:  MOVFF  FEF,8BF
14364:  MOVFF  8B9,A11
14368:  MOVFF  8B8,A10
1436C:  MOVLB  A
1436E:  CLRF   x13
14370:  MOVLW  03
14372:  MOVWF  x12
14374:  MOVLB  0
14376:  CALL   5C98
1437A:  MOVF   01,W
1437C:  MOVLB  8
1437E:  ADDWF  xBF,W
14380:  MOVWF  xBA
14382:  MOVF   02,W
14384:  ADDWFC xC0,W
14386:  MOVWF  xBB
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
14388:  MOVFF  8BB,8CC
1438C:  MOVFF  8BA,8CB
14390:  MOVLB  0
14392:  CALL   10608
14396:  MOVFF  01,8BC
....................    ++addr; 
1439A:  MOVLB  8
1439C:  INCF   xBA,F
1439E:  BTFSC  FD8.2
143A0:  INCF   xBB,F
....................    macro_arg = read16_ext_eeprom(addr); 
143A2:  MOVFF  8BB,8C3
143A6:  MOVFF  8BA,8C2
143AA:  MOVLB  0
143AC:  CALL   1071C
143B0:  MOVFF  02,8BE
143B4:  MOVFF  01,8BD
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
143B8:  MOVLB  8
143BA:  MOVF   xBC,W
143BC:  BTFSS  F9E.4
143BE:  BRA    143BC
143C0:  MOVWF  FAD
143C2:  MOVLW  10
143C4:  MOVWF  FE9
143C6:  CLRF   1B
143C8:  BTFSC  FF2.7
143CA:  BSF    1B.7
143CC:  BCF    FF2.7
143CE:  MOVFF  8BE,A41
143D2:  MOVFF  8BD,A40
143D6:  MOVLB  0
143D8:  CALL   119E
143DC:  BTFSC  1B.7
143DE:  BSF    FF2.7
143E0:  MOVLW  0D
143E2:  BTFSS  F9E.4
143E4:  BRA    143E2
143E6:  MOVWF  FAD
143E8:  MOVLW  0A
143EA:  BTFSS  F9E.4
143EC:  BRA    143EA
143EE:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
143F0:  MOVLB  8
143F2:  MOVFF  8BC,01
143F6:  MOVLB  0
143F8:  GOTO   14BD0 (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
10662:  BCF    FD8.0
10664:  MOVLB  8
10666:  RLCF   xB5,W
10668:  CLRF   03
1066A:  ADDLW  FB
1066C:  MOVWF  FE9
1066E:  MOVLW  07
10670:  ADDWFC 03,W
10672:  MOVWF  FEA
10674:  MOVFF  FEC,8BE
10678:  MOVF   FED,F
1067A:  MOVFF  FEF,8BD
1067E:  MOVFF  8B9,A11
10682:  MOVFF  8B8,A10
10686:  MOVLB  A
10688:  CLRF   x13
1068A:  MOVLW  32
1068C:  MOVWF  x12
1068E:  MOVLB  0
10690:  CALL   5C98
10694:  MOVF   01,W
10696:  MOVLB  8
10698:  ADDWF  xBD,W
1069A:  MOVWF  xBA
1069C:  MOVF   02,W
1069E:  ADDWFC xBE,W
106A0:  MOVWF  xBB
....................     
....................    int i = 0; 
106A2:  CLRF   xBC
....................    for(i = 0; i < 50; i++){ 
106A4:  CLRF   xBC
106A6:  MOVF   xBC,W
106A8:  SUBLW  31
106AA:  BNC   106C0
....................       string_arg[i] = 0; 
106AC:  CLRF   03
106AE:  MOVF   xBC,W
106B0:  ADDLW  25
106B2:  MOVWF  FE9
106B4:  MOVLW  08
106B6:  ADDWFC 03,W
106B8:  MOVWF  FEA
106BA:  CLRF   FEF
106BC:  INCF   xBC,F
106BE:  BRA    106A6
....................    }  
....................    for(i = 0; i < 50; i++){ 
106C0:  CLRF   xBC
106C2:  MOVF   xBC,W
106C4:  SUBLW  31
106C6:  BNC   10718
....................       string_arg[i] = read_ext_eeprom(addr + i); 
106C8:  CLRF   03
106CA:  MOVF   xBC,W
106CC:  ADDLW  25
106CE:  MOVWF  01
106D0:  MOVLW  08
106D2:  ADDWFC 03,F
106D4:  MOVFF  01,8BD
106D8:  MOVFF  03,8BE
106DC:  MOVF   xBC,W
106DE:  ADDWF  xBA,W
106E0:  MOVWF  xBF
106E2:  MOVLW  00
106E4:  ADDWFC xBB,W
106E6:  MOVWF  xC0
106E8:  MOVWF  xCC
106EA:  MOVFF  8BF,8CB
106EE:  MOVLB  0
106F0:  RCALL  10608
106F2:  MOVFF  8BE,FEA
106F6:  MOVFF  8BD,FE9
106FA:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
106FE:  CLRF   03
10700:  MOVLB  8
10702:  MOVF   xBC,W
10704:  ADDLW  25
10706:  MOVWF  FE9
10708:  MOVLW  08
1070A:  ADDWFC 03,W
1070C:  MOVWF  FEA
1070E:  MOVF   FEF,F
10710:  BNZ   10714
....................          break; 
10712:  BRA    10718
....................       } 
10714:  INCF   xBC,F
10716:  BRA    106C2
....................    }   
10718:  MOVLB  0
1071A:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
1879C:  MOVLB  8
1879E:  CLRF   x8A
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
187A0:  CLRF   x88
187A2:  CLRF   x87
....................    macro_cmd = 1; 
187A4:  MOVLW  01
187A6:  MOVWF  x89
....................     
....................    init_ext_eeprom(); 
187A8:  MOVLB  0
187AA:  CALL   105D0
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
187AE:  MOVLB  8
187B0:  MOVF   x88,W
187B2:  SUBLW  03
187B4:  BNC   187FC
187B6:  MOVF   x89,W
187B8:  SUBLW  3B
187BA:  BZ    187FC
....................       macro_cmd = read_macro_line(macro, line); 
187BC:  MOVFF  886,88B
187C0:  MOVFF  888,88D
187C4:  MOVFF  887,88C
187C8:  MOVLB  0
187CA:  BRA    186E8
187CC:  MOVFF  01,889
....................       if(macro_cmd == 'p'){ 
187D0:  MOVLB  8
187D2:  MOVF   x89,W
187D4:  SUBLW  70
187D6:  BNZ   187F4
....................          read_macro_line_string(macro,line,count); 
187D8:  MOVFF  886,8B5
187DC:  MOVFF  888,8B7
187E0:  MOVFF  887,8B6
187E4:  CLRF   xB9
187E6:  MOVFF  88A,8B8
187EA:  MOVLB  0
187EC:  CALL   10662
....................          count++; 
187F0:  MOVLB  8
187F2:  INCF   x8A,F
....................       } 
....................       ++line; 
187F4:  INCF   x87,F
187F6:  BTFSC  FD8.2
187F8:  INCF   x88,F
187FA:  BRA    187B0
....................    } 
187FC:  MOVLB  0
187FE:  GOTO   1881E (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D33A:  MOVLB  8
0D33C:  CLRF   xC5
0D33E:  CLRF   xC4
0D340:  MOVF   xC5,W
0D342:  SUBWF  xC3,W
0D344:  BNC   D36C
0D346:  BNZ   D34E
0D348:  MOVF   xC2,W
0D34A:  SUBWF  xC4,W
0D34C:  BC    D36C
....................       delay_ms(1000); 
0D34E:  MOVLW  04
0D350:  MOVWF  xC6
0D352:  MOVLW  FA
0D354:  MOVLB  9
0D356:  MOVWF  xEC
0D358:  MOVLB  0
0D35A:  CALL   2910
0D35E:  MOVLB  8
0D360:  DECFSZ xC6,F
0D362:  BRA    D352
0D364:  INCF   xC4,F
0D366:  BTFSC  FD8.2
0D368:  INCF   xC5,F
0D36A:  BRA    D340
....................    }  
0D36C:  MOVLB  0
0D36E:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0D302:  BCF    FD8.0
0D304:  MOVLB  7
0D306:  RLCF   x40,W
0D308:  CLRF   03
0D30A:  ADDLW  96
0D30C:  MOVWF  FE9
0D30E:  MOVLW  07
0D310:  ADDWFC 03,W
0D312:  MOVWF  FEA
0D314:  MOVFF  FEC,8C4
0D318:  MOVF   FED,F
0D31A:  MOVFF  FEF,8C3
0D31E:  MOVLB  8
0D320:  DECFSZ xC3,W
0D322:  BRA    D32E
0D324:  MOVF   xC4,F
0D326:  BNZ   D32E
....................    { 
....................       macro_status = 'e'; 
0D328:  MOVLW  65
0D32A:  MOVWF  xC2
....................    } 
0D32C:  BRA    D332
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D32E:  MOVLW  61
0D330:  MOVWF  xC2
....................    } 
....................    return(macro_status); 
0D332:  MOVFF  8C2,01
0D336:  MOVLB  0
0D338:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
13864:  DECFSZ 45,W
13866:  BRA    1387A
13868:  MOVF   46,F
1386A:  BNZ   1387A
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
1386C:  MOVLW  01
1386E:  MOVLB  8
13870:  MOVWF  xC2
13872:  MOVWF  xC3
13874:  MOVLB  0
13876:  RCALL  1372E
....................    } 
13878:  BRA    138A4
....................    else if(nv_det_type==2 || nv_det_type==3) 
1387A:  MOVF   45,W
1387C:  SUBLW  02
1387E:  BNZ   13884
13880:  MOVF   46,F
13882:  BZ    1388E
13884:  MOVF   45,W
13886:  SUBLW  03
13888:  BNZ   138A4
1388A:  MOVF   46,F
1388C:  BNZ   138A4
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
1388E:  MOVLB  8
13890:  CLRF   xC3
13892:  MOVLW  C8
13894:  MOVWF  xC2
13896:  MOVLW  01
13898:  MOVWF  xC4
1389A:  MOVWF  xC5
1389C:  CLRF   xC6
1389E:  MOVLB  0
138A0:  CALL   100B6
....................    } 
138A4:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
12782:  DECFSZ 45,W
12784:  BRA    127A0
12786:  MOVF   46,F
12788:  BNZ   127A0
....................       cmd = macro_cmd; 
1278A:  MOVFF  8C2,47
....................       arg = macro_arg; 
1278E:  CLRF   4B
12790:  CLRF   4A
12792:  MOVFF  8C4,49
12796:  MOVFF  8C3,48
....................       det_cmd(); 
1279A:  CALL   F402
....................    } 
1279E:  BRA    127BA
....................    else if(nv_det_type==2 || nv_det_type==3) { 
127A0:  MOVF   45,W
127A2:  SUBLW  02
127A4:  BNZ   127AA
127A6:  MOVF   46,F
127A8:  BZ    127B4
127AA:  MOVF   45,W
127AC:  SUBLW  03
127AE:  BNZ   127BA
127B0:  MOVF   46,F
127B2:  BNZ   127BA
....................       set_heaters(macro_arg); 
127B4:  MOVFF  8C3,8C5
127B8:  RCALL  1270E
....................    } 
127BA:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
127BC:  DECFSZ 45,W
127BE:  BRA    127DA
127C0:  MOVF   46,F
127C2:  BNZ   127DA
....................       cmd = macro_cmd; 
127C4:  MOVFF  8C2,47
....................       arg = macro_arg; 
127C8:  CLRF   4B
127CA:  CLRF   4A
127CC:  MOVFF  8C4,49
127D0:  MOVFF  8C3,48
....................       det_cmd(); 
127D4:  CALL   F402
....................    } 
127D8:  BRA    127FA
....................    else if(nv_det_type==2 || nv_det_type==3) { 
127DA:  MOVF   45,W
127DC:  SUBLW  02
127DE:  BNZ   127E4
127E0:  MOVF   46,F
127E2:  BZ    127EE
127E4:  MOVF   45,W
127E6:  SUBLW  03
127E8:  BNZ   127FA
127EA:  MOVF   46,F
127EC:  BNZ   127FA
....................       set_LED(macro_arg); 
127EE:  MOVFF  8C4,8C6
127F2:  MOVFF  8C3,8C5
127F6:  CALL   F8C6
....................    } 
127FA:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13F38:  MOVLW  65
13F3A:  MOVLB  8
13F3C:  MOVWF  xC1
....................     
....................    addr = macro_address[macro] + (line*3); 
13F3E:  BCF    FD8.0
13F40:  RLCF   xB7,W
13F42:  CLRF   03
13F44:  ADDLW  D1
13F46:  MOVWF  FE9
13F48:  MOVLW  07
13F4A:  ADDWFC 03,W
13F4C:  MOVWF  FEA
13F4E:  MOVFF  FEC,8C3
13F52:  MOVF   FED,F
13F54:  MOVFF  FEF,8C2
13F58:  MOVFF  8B9,A11
13F5C:  MOVFF  8B8,A10
13F60:  MOVLB  A
13F62:  CLRF   x13
13F64:  MOVLW  03
13F66:  MOVWF  x12
13F68:  MOVLB  0
13F6A:  CALL   5C98
13F6E:  MOVF   01,W
13F70:  MOVLB  8
13F72:  ADDWF  xC2,W
13F74:  MOVWF  xBC
13F76:  MOVF   02,W
13F78:  ADDWFC xC3,W
13F7A:  MOVWF  xBD
....................  
....................    init_ext_eeprom(); 
13F7C:  MOVLB  0
13F7E:  CALL   105D0
....................    macro_cmd = read_ext_eeprom(addr); 
13F82:  MOVFF  8BD,8CC
13F86:  MOVFF  8BC,8CB
13F8A:  CALL   10608
13F8E:  MOVFF  01,8BE
....................    ++addr; 
13F92:  MOVLB  8
13F94:  INCF   xBC,F
13F96:  BTFSC  FD8.2
13F98:  INCF   xBD,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13F9A:  MOVFF  8BD,8C3
13F9E:  MOVFF  8BC,8C2
13FA2:  MOVLB  0
13FA4:  CALL   1071C
13FA8:  MOVFF  02,8C0
13FAC:  MOVFF  01,8BF
....................    //} 
....................    heartbeat(TRUE); 
13FB0:  MOVLW  01
13FB2:  MOVLB  8
13FB4:  MOVWF  xED
13FB6:  MOVLB  0
13FB8:  CALL   5586
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13FBC:  MOVF   2F,F
13FBE:  BTFSS  FD8.2
13FC0:  BRA    14284
13FC2:  MOVF   30,F
13FC4:  BTFSS  FD8.2
13FC6:  BRA    14284
....................       switch(macro_cmd) 
13FC8:  MOVLW  2B
13FCA:  MOVLB  8
13FCC:  SUBWF  xBE,W
13FCE:  ADDLW  B4
13FD0:  BTFSC  FD8.0
13FD2:  BRA    14286
13FD4:  ADDLW  4C
13FD6:  MOVLB  0
13FD8:  GOTO   14290
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13FDC:  CALL   1259A
....................             store_rel_data(); 
13FE0:  CALL   125FE
....................             macro_status = 'a'; 
13FE4:  MOVLW  61
13FE6:  MOVLB  8
13FE8:  MOVWF  xC1
....................             break; 
13FEA:  BRA    14286
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
13FEC:  MOVLW  08
13FEE:  MOVWF  FEA
13FF0:  MOVLW  25
13FF2:  MOVWF  FE9
13FF4:  CALL   7996
13FF8:  MOVLW  0D
13FFA:  BTFSS  F9E.4
13FFC:  BRA    13FFA
13FFE:  MOVWF  FAD
14000:  MOVLW  0A
14002:  BTFSS  F9E.4
14004:  BRA    14002
14006:  MOVWF  FAD
....................             macro_status = 'a'; 
14008:  MOVLW  61
1400A:  MOVLB  8
1400C:  MOVWF  xC1
....................             break; 
1400E:  BRA    14286
....................          case 'C' : 
....................             calc_abs_data(); 
14010:  CALL   1259A
....................             break; 
14014:  MOVLB  8
14016:  BRA    14286
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
14018:  MOVFF  8C0,8C3
1401C:  MOVFF  8BF,8C2
14020:  CALL   D33A
....................             macro_status = 'a'; 
14024:  MOVLW  61
14026:  MOVLB  8
14028:  MOVWF  xC1
....................             break; 
1402A:  BRA    14286
....................          case 'F' : macro_flag = macro_arg; 
1402C:  MOVFF  8C0,324
14030:  MOVFF  8BF,323
....................                     macro_status = 'a'; 
14034:  MOVLW  61
14036:  MOVLB  8
14038:  MOVWF  xC1
....................             break ; 
1403A:  BRA    14286
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
1403C:  MOVFF  8BF,2D5
....................                     macro_status = 'a'; 
14040:  MOVLW  61
14042:  MOVLB  8
14044:  MOVWF  xC1
....................             break ; 
14046:  BRA    14286
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14048:  MOVFF  8BE,8C2
1404C:  MOVFF  8C0,8C4
14050:  MOVFF  8BF,8C3
14054:  CALL   12782
....................                     macro_status = 'a'; 
14058:  MOVLW  61
1405A:  MOVLB  8
1405C:  MOVWF  xC1
....................             break; 
1405E:  BRA    14286
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14060:  MOVFF  8BE,8C2
14064:  MOVFF  8C0,8C4
14068:  MOVFF  8BF,8C3
1406C:  CALL   12782
....................                     macro_status = 'a'; 
14070:  MOVLW  61
14072:  MOVLB  8
14074:  MOVWF  xC1
....................             break; 
14076:  BRA    14286
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14078:  MOVFF  8C0,8DC
1407C:  MOVFF  8BF,8DB
14080:  MOVLB  8
14082:  CLRF   xDE
14084:  MOVLW  64
14086:  MOVWF  xDD
14088:  MOVLB  0
1408A:  CALL   2CD4
1408E:  MOVFF  02,74D
14092:  MOVFF  01,74C
....................                     macro_status = 'a'; 
14096:  MOVLW  61
14098:  MOVLB  8
1409A:  MOVWF  xC1
....................             break;    
1409C:  BRA    14286
....................          case 'l' : LightTargetFlag = 1; 
1409E:  MOVLW  01
140A0:  MOVLB  2
140A2:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
140A4:  MOVFF  8BE,8C2
140A8:  MOVFF  8C0,8C4
140AC:  MOVFF  8BF,8C3
140B0:  MOVLB  0
140B2:  CALL   127BC
....................                     delay_ms(10000); 
140B6:  MOVLW  28
140B8:  MOVLB  8
140BA:  MOVWF  xC2
140BC:  MOVLW  FA
140BE:  MOVLB  9
140C0:  MOVWF  xEC
140C2:  MOVLB  0
140C4:  CALL   2910
140C8:  MOVLB  8
140CA:  DECFSZ xC2,F
140CC:  BRA    140BC
....................                     macro_status = 'a'; 
140CE:  MOVLW  61
140D0:  MOVWF  xC1
....................             break;        
140D2:  BRA    14286
....................          case 'L' : LightTargetFlag = 0; 
140D4:  MOVLB  2
140D6:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
140D8:  MOVFF  8BE,8C2
140DC:  MOVFF  8C0,8C4
140E0:  MOVFF  8BF,8C3
140E4:  MOVLB  0
140E6:  CALL   127BC
....................                     macro_status = 'a'; 
140EA:  MOVLW  61
140EC:  MOVLB  8
140EE:  MOVWF  xC1
....................             break; 
140F0:  BRA    14286
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
140F2:  MOVFF  8BE,47
....................                     arg = macro_arg; 
140F6:  CLRF   4B
140F8:  CLRF   4A
140FA:  MOVFF  8C0,49
140FE:  MOVFF  8BF,48
....................                     det_cmd(); 
14102:  CALL   F402
....................                     macro_status = 'a'; 
14106:  MOVLW  61
14108:  MOVLB  8
1410A:  MOVWF  xC1
....................             break ; 
1410C:  BRA    14286
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
1410E:  MOVLB  8
14110:  DECFSZ xBF,W
14112:  BRA    14120
14114:  MOVF   xC0,F
14116:  BNZ   14120
14118:  MOVLB  0
1411A:  CALL   13864
1411E:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14120:  MOVF   xBF,W
14122:  SUBLW  02
14124:  BNZ   14136
14126:  MOVF   xC0,F
14128:  BNZ   14136
1412A:  MOVLW  01
1412C:  MOVWF  xC2
1412E:  MOVWF  xC3
14130:  MOVLB  0
14132:  RCALL  13A30
14134:  MOVLB  8
....................                     macro_status = 'a'; 
14136:  MOVLW  61
14138:  MOVWF  xC1
....................             break ;  
1413A:  BRA    14286
....................          case 'T' : det_temp(); 
1413C:  RCALL  13BF0
....................                     macro_status = 'a'; 
1413E:  MOVLW  61
14140:  MOVLB  8
14142:  MOVWF  xC1
....................             break; 
14144:  BRA    14286
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14146:  MOVLW  01
14148:  MOVLB  7
1414A:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
1414C:  MOVLB  8
1414E:  CLRF   xC7
14150:  CLRF   xC8
14152:  CLRF   xCC
14154:  CLRF   xCB
14156:  MOVFF  8C0,8CA
1415A:  MOVFF  8BF,8C9
1415E:  MOVWF  xCD
14160:  MOVLB  0
14162:  CALL   9D78
....................                     macro_status=step_err_status(); 
14166:  CALL   D302
1416A:  MOVFF  01,8C1
....................             break; 
1416E:  MOVLB  8
14170:  BRA    14286
....................          case '-' : motor=1; 
14172:  MOVLW  01
14174:  MOVLB  7
14176:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14178:  MOVLB  8
1417A:  CLRF   xC7
1417C:  MOVWF  xC8
1417E:  CLRF   xCC
14180:  CLRF   xCB
14182:  MOVFF  8C0,8CA
14186:  MOVFF  8BF,8C9
1418A:  MOVWF  xCD
1418C:  MOVLB  0
1418E:  CALL   9D78
....................                     macro_status=step_err_status(); 
14192:  CALL   D302
14196:  MOVFF  01,8C1
....................             break; 
1419A:  MOVLB  8
1419C:  BRA    14286
....................          case 'G' : motor=0; 
1419E:  MOVLB  7
141A0:  CLRF   x40
....................                     align(0); 
141A2:  MOVLB  8
141A4:  CLRF   xC2
141A6:  MOVLB  0
141A8:  CALL   A8B4
....................                     macro_status=step_err_status(); 
141AC:  CALL   D302
141B0:  MOVFF  01,8C1
....................             break ;           
141B4:  MOVLB  8
141B6:  BRA    14286
....................          case 'P' : motor=0; 
141B8:  MOVLB  7
141BA:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
141BC:  MOVLW  01
141BE:  MOVLB  8
141C0:  MOVWF  xC7
141C2:  CLRF   xC8
141C4:  CLRF   xCC
141C6:  CLRF   xCB
141C8:  MOVFF  8C0,8CA
141CC:  MOVFF  8BF,8C9
141D0:  MOVWF  xCD
141D2:  MOVLB  0
141D4:  CALL   9D78
....................                     macro_status=step_err_status(); 
141D8:  CALL   D302
141DC:  MOVFF  01,8C1
....................             break; 
141E0:  MOVLB  8
141E2:  BRA    14286
....................          case 'Q' : motor=0; 
141E4:  MOVLB  7
141E6:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
141E8:  MOVLB  8
141EA:  CLRF   xC7
141EC:  CLRF   xC8
141EE:  CLRF   xCC
141F0:  CLRF   xCB
141F2:  MOVFF  8C0,8CA
141F6:  MOVFF  8BF,8C9
141FA:  MOVLW  01
141FC:  MOVWF  xCD
141FE:  MOVLB  0
14200:  CALL   9D78
....................                     macro_status=step_err_status(); 
14204:  CALL   D302
14208:  MOVFF  01,8C1
....................             break; 
1420C:  MOVLB  8
1420E:  BRA    14286
....................          case 'R' : motor=0; 
14210:  MOVLB  7
14212:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
14214:  MOVLB  8
14216:  CLRF   xC7
14218:  MOVLW  01
1421A:  MOVWF  xC8
1421C:  CLRF   xCC
1421E:  CLRF   xCB
14220:  MOVFF  8C0,8CA
14224:  MOVFF  8BF,8C9
14228:  MOVWF  xCD
1422A:  MOVLB  0
1422C:  CALL   9D78
....................                     macro_status=step_err_status(); 
14230:  CALL   D302
14234:  MOVFF  01,8C1
....................             break; 
14238:  MOVLB  8
1423A:  BRA    14286
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
1423C:  MOVLB  8
1423E:  DECFSZ xBF,W
14240:  BRA    14250
14242:  MOVF   xC0,F
14244:  BNZ   14250
14246:  MOVLB  0
14248:  CALL   D370
1424C:  BRA    1425E
1424E:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14250:  MOVF   xBF,F
14252:  BNZ   14260
14254:  MOVF   xC0,F
14256:  BNZ   14260
14258:  MOVLB  0
1425A:  CALL   D394
1425E:  MOVLB  8
....................                     macro_status = 'a'; 
14260:  MOVLW  61
14262:  MOVWF  xC1
....................             break; 
14264:  BRA    14286
....................          case 'v': 
....................             arg = macro_arg; 
14266:  CLRF   4B
14268:  CLRF   4A
1426A:  MOVFF  8C0,49
1426E:  MOVFF  8BF,48
....................             command_v(); 
14272:  RCALL  13DDC
....................             macro_status = 'a'; 
14274:  MOVLW  61
14276:  MOVLB  8
14278:  MOVWF  xC1
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
1427A:  BRA    14286
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
1427C:  MOVLW  66
1427E:  MOVLB  8
14280:  MOVWF  xC1
....................             break ; 
14282:  BRA    14286
14284:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
14286:  MOVFF  8C1,01
1428A:  MOVLB  0
1428C:  GOTO   14B98 (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
149F4:  MOVLW  65
149F6:  MOVLB  8
149F8:  MOVWF  xA7
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
149FA:  BCF    FD8.0
149FC:  RLCF   x9D,W
149FE:  CLRF   03
14A00:  ADDLW  D1
14A02:  MOVWF  FE9
14A04:  MOVLW  07
14A06:  ADDWFC 03,W
14A08:  MOVWF  FEA
14A0A:  MOVFF  FEC,8B6
14A0E:  MOVF   FED,F
14A10:  MOVFF  FEF,8B5
14A14:  MOVFF  89F,03
14A18:  MOVFF  89E,FE9
14A1C:  MOVFF  89F,FEA
14A20:  MOVFF  FEC,A11
14A24:  MOVF   FED,F
14A26:  MOVFF  FEF,A10
14A2A:  MOVLB  A
14A2C:  CLRF   x13
14A2E:  MOVLW  03
14A30:  MOVWF  x12
14A32:  MOVLB  0
14A34:  CALL   5C98
14A38:  MOVF   01,W
14A3A:  MOVLB  8
14A3C:  ADDWF  xB5,W
14A3E:  MOVWF  xA2
14A40:  MOVF   02,W
14A42:  ADDWFC xB6,W
14A44:  MOVWF  xA3
....................  
....................    init_ext_eeprom(); 
14A46:  MOVLB  0
14A48:  CALL   105D0
....................    macro_cmd = read_ext_eeprom(addr); 
14A4C:  MOVFF  8A3,8CC
14A50:  MOVFF  8A2,8CB
14A54:  CALL   10608
14A58:  MOVFF  01,8A4
....................    ++addr; 
14A5C:  MOVLB  8
14A5E:  INCF   xA2,F
14A60:  BTFSC  FD8.2
14A62:  INCF   xA3,F
....................    if(macro_cmd == 'p'){ 
14A64:  MOVF   xA4,W
14A66:  SUBLW  70
14A68:  BNZ   14A8E
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
14A6A:  MOVFF  89D,8B5
14A6E:  MOVFF  89F,8B7
14A72:  MOVFF  89E,8B6
14A76:  MOVFF  858,8B9
14A7A:  MOVFF  857,8B8
14A7E:  MOVLB  0
14A80:  CALL   10662
....................       count1++; 
14A84:  MOVLB  8
14A86:  INCF   x57,F
14A88:  BTFSC  FD8.2
14A8A:  INCF   x58,F
....................    }else{ 
14A8C:  BRA    14AA6
....................    macro_arg = read16_ext_eeprom(addr); 
14A8E:  MOVFF  8A3,8C3
14A92:  MOVFF  8A2,8C2
14A96:  MOVLB  0
14A98:  CALL   1071C
14A9C:  MOVFF  02,8A6
14AA0:  MOVFF  01,8A5
14AA4:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
14AA6:  MOVLW  01
14AA8:  MOVWF  xED
14AAA:  MOVLB  0
14AAC:  CALL   5586
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
14AB0:  MOVF   2F,F
14AB2:  BTFSS  FD8.2
14AB4:  BRA    14F1A
14AB6:  MOVF   30,F
14AB8:  BTFSS  FD8.2
14ABA:  BRA    14F1A
....................       switch(macro_cmd){ 
14ABC:  MOVLW  2B
14ABE:  MOVLB  8
14AC0:  SUBWF  xA4,W
14AC2:  ADDLW  B4
14AC4:  BTFSC  FD8.0
14AC6:  BRA    14F16
14AC8:  ADDLW  4C
14ACA:  MOVLB  0
14ACC:  GOTO   151E0
....................          case 'A' : 
....................             calc_abs_data(); 
14AD0:  CALL   1259A
....................             store_rel_data(); 
14AD4:  CALL   125FE
....................             macro_status = 'a'; 
14AD8:  MOVLW  61
14ADA:  MOVLB  8
14ADC:  MOVWF  xA7
....................             break; 
14ADE:  BRA    14F16
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
14AE0:  MOVLW  08
14AE2:  MOVWF  FEA
14AE4:  MOVLW  25
14AE6:  MOVWF  FE9
14AE8:  CALL   7996
14AEC:  MOVLW  0D
14AEE:  BTFSS  F9E.4
14AF0:  BRA    14AEE
14AF2:  MOVWF  FAD
14AF4:  MOVLW  0A
14AF6:  BTFSS  F9E.4
14AF8:  BRA    14AF6
14AFA:  MOVWF  FAD
....................             macro_status = 'a'; 
14AFC:  MOVLW  61
14AFE:  MOVLB  8
14B00:  MOVWF  xA7
....................             break; 
14B02:  BRA    14F16
....................          case 'C' : 
....................             calc_abs_data(); 
14B04:  CALL   1259A
....................             break; 
14B08:  MOVLB  8
14B0A:  BRA    14F16
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
14B0C:  MOVLB  8
14B0E:  CLRF   xAB
14B10:  CLRF   xAA
14B12:  CLRF   xA9
14B14:  CLRF   xA8
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14B16:  MOVFF  89F,03
14B1A:  MOVFF  89E,FE9
14B1E:  MOVFF  89F,FEA
14B22:  MOVLW  01
14B24:  ADDWF  FEE,F
14B26:  BNC   14B2A
14B28:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
14B2A:  MOVFF  89E,FE9
14B2E:  MOVFF  89F,FEA
14B32:  CLRF   xAF
14B34:  CLRF   xAE
14B36:  MOVFF  FEC,8AD
14B3A:  MOVF   FED,F
14B3C:  MOVFF  FEF,8AC
14B40:  CLRF   xB3
14B42:  CLRF   xB2
14B44:  CLRF   xB1
14B46:  CLRF   xB0
....................                    
....................                   while(count < macro_arg){ 
14B48:  MOVF   xAB,F
14B4A:  BTFSS  FD8.2
14B4C:  BRA    14C88
14B4E:  MOVF   xAA,F
14B50:  BTFSS  FD8.2
14B52:  BRA    14C88
14B54:  MOVF   xA9,W
14B56:  SUBWF  xA6,W
14B58:  BTFSS  FD8.0
14B5A:  BRA    14C88
14B5C:  BNZ   14B66
14B5E:  MOVF   xA5,W
14B60:  SUBWF  xA8,W
14B62:  BTFSC  FD8.0
14B64:  BRA    14C88
....................                      char curr = 'A'; 
14B66:  MOVLW  41
14B68:  MOVWF  xB4
....................                      while(curr != '%'){ 
14B6A:  MOVF   xB4,W
14B6C:  SUBLW  25
14B6E:  BZ    14BDA
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
14B70:  MOVFF  89F,03
14B74:  MOVFF  89E,FE9
14B78:  MOVFF  89F,FEA
14B7C:  MOVFF  FEC,8B9
14B80:  MOVF   FED,F
14B82:  MOVFF  FEF,8B8
14B86:  MOVFF  89D,8B7
14B8A:  MOVFF  8A1,8BB
14B8E:  MOVFF  8A0,8BA
14B92:  MOVLB  0
14B94:  GOTO   13F38
....................                         (*line)++; 
14B98:  MOVFF  89F,03
14B9C:  MOVLB  8
14B9E:  MOVF   x9E,W
14BA0:  MOVWF  FE9
14BA2:  MOVFF  03,FEA
14BA6:  MOVLW  01
14BA8:  ADDWF  FEE,F
14BAA:  BNC   14BAE
14BAC:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
14BAE:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
14BB0:  MOVFF  89F,03
14BB4:  MOVFF  89E,FE9
14BB8:  MOVFF  89F,FEA
14BBC:  MOVFF  FEC,8B9
14BC0:  MOVF   FED,F
14BC2:  MOVFF  FEF,8B8
14BC6:  MOVFF  89D,8B7
14BCA:  MOVLB  0
14BCC:  GOTO   14348
14BD0:  MOVFF  01,8B4
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14BD4:  BSF    F91.5
14BD6:  MOVLB  8
14BD8:  BRA    14B6A
....................                      } 
....................                      end_line = (*line); 
14BDA:  MOVFF  89E,FE9
14BDE:  MOVFF  89F,FEA
14BE2:  CLRF   xB3
14BE4:  CLRF   xB2
14BE6:  MOVFF  FEC,8B1
14BEA:  MOVF   FED,F
14BEC:  MOVFF  FEF,8B0
....................                      count++; 
14BF0:  MOVLW  01
14BF2:  ADDWF  xA8,F
14BF4:  BTFSC  FD8.0
14BF6:  INCF   xA9,F
14BF8:  BTFSC  FD8.2
14BFA:  INCF   xAA,F
14BFC:  BTFSC  FD8.2
14BFE:  INCF   xAB,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
14C00:  MOVF   xA8,W
14C02:  SUBWF  xA5,W
14C04:  MOVWF  xB5
14C06:  MOVF   xA9,W
14C08:  SUBWFB xA6,W
14C0A:  MOVWF  xB6
14C0C:  MOVLW  00
14C0E:  SUBFWB xAA,W
14C10:  MOVWF  xB7
14C12:  MOVLW  00
14C14:  SUBFWB xAB,W
14C16:  MOVWF  xB8
14C18:  MOVLW  4E
14C1A:  MOVWF  FF6
14C1C:  MOVLW  21
14C1E:  MOVWF  FF7
14C20:  MOVLW  00
14C22:  MOVWF  FF8
14C24:  CLRF   1B
14C26:  BTFSC  FF2.7
14C28:  BSF    1B.7
14C2A:  BCF    FF2.7
14C2C:  MOVLW  11
14C2E:  MOVLB  A
14C30:  MOVWF  x40
14C32:  MOVLB  0
14C34:  CALL   101C
14C38:  BTFSC  1B.7
14C3A:  BSF    FF2.7
14C3C:  MOVLW  41
14C3E:  MOVWF  FE9
14C40:  CLRF   1B
14C42:  BTFSC  FF2.7
14C44:  BSF    1B.7
14C46:  BCF    FF2.7
14C48:  MOVFF  8B8,A43
14C4C:  MOVFF  8B7,A42
14C50:  MOVFF  8B6,A41
14C54:  MOVFF  8B5,A40
14C58:  CALL   10E2
14C5C:  BTFSC  1B.7
14C5E:  BSF    FF2.7
14C60:  MOVLW  0D
14C62:  BTFSS  F9E.4
14C64:  BRA    14C62
14C66:  MOVWF  FAD
14C68:  MOVLW  0A
14C6A:  BTFSS  F9E.4
14C6C:  BRA    14C6A
14C6E:  MOVWF  FAD
....................                      (*line) = start_line; 
14C70:  MOVFF  89F,03
14C74:  MOVLB  8
14C76:  MOVFF  89E,FE9
14C7A:  MOVFF  89F,FEA
14C7E:  MOVFF  8AC,FEF
14C82:  MOVFF  8AD,FEC
14C86:  BRA    14B48
....................                   } 
....................                   (*line) = end_line + 1; 
14C88:  MOVFF  89E,FE9
14C8C:  MOVFF  89F,FEA
14C90:  MOVLW  01
14C92:  ADDWF  xB0,W
14C94:  MOVWF  FEF
14C96:  MOVLW  00
14C98:  ADDWFC xB1,W
14C9A:  MOVWF  FEC
....................                   macro_status = 'a'; 
14C9C:  MOVLW  61
14C9E:  MOVWF  xA7
....................             break; 
14CA0:  BRA    14F16
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
14CA2:  MOVFF  8A6,8C3
14CA6:  MOVFF  8A5,8C2
14CAA:  CALL   D33A
....................                     macro_status = 'a'; 
14CAE:  MOVLW  61
14CB0:  MOVLB  8
14CB2:  MOVWF  xA7
....................             break; 
14CB4:  BRA    14F16
....................          case 'F' : macro_flag = macro_arg; 
14CB6:  MOVFF  8A6,324
14CBA:  MOVFF  8A5,323
....................                     macro_status = 'a'; 
14CBE:  MOVLW  61
14CC0:  MOVLB  8
14CC2:  MOVWF  xA7
....................             break ; 
14CC4:  BRA    14F16
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14CC6:  MOVFF  8A5,2D5
....................                     macro_status = 'a'; 
14CCA:  MOVLW  61
14CCC:  MOVLB  8
14CCE:  MOVWF  xA7
....................             break ; 
14CD0:  BRA    14F16
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14CD2:  MOVFF  8A4,8C2
14CD6:  MOVFF  8A6,8C4
14CDA:  MOVFF  8A5,8C3
14CDE:  CALL   12782
....................                     macro_status = 'a'; 
14CE2:  MOVLW  61
14CE4:  MOVLB  8
14CE6:  MOVWF  xA7
....................             break; 
14CE8:  BRA    14F16
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14CEA:  MOVFF  8A4,8C2
14CEE:  MOVFF  8A6,8C4
14CF2:  MOVFF  8A5,8C3
14CF6:  CALL   12782
....................                     macro_status = 'a'; 
14CFA:  MOVLW  61
14CFC:  MOVLB  8
14CFE:  MOVWF  xA7
....................             break; 
14D00:  BRA    14F16
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14D02:  MOVFF  8A6,8DC
14D06:  MOVFF  8A5,8DB
14D0A:  MOVLB  8
14D0C:  CLRF   xDE
14D0E:  MOVLW  64
14D10:  MOVWF  xDD
14D12:  MOVLB  0
14D14:  CALL   2CD4
14D18:  MOVFF  02,74D
14D1C:  MOVFF  01,74C
....................                     macro_status = 'a'; 
14D20:  MOVLW  61
14D22:  MOVLB  8
14D24:  MOVWF  xA7
....................             break;    
14D26:  BRA    14F16
....................          case 'l' : LightTargetFlag = 1; 
14D28:  MOVLW  01
14D2A:  MOVLB  2
14D2C:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
14D2E:  MOVFF  8A4,8C2
14D32:  MOVFF  8A6,8C4
14D36:  MOVFF  8A5,8C3
14D3A:  MOVLB  0
14D3C:  CALL   127BC
....................                     delay_ms(10000); 
14D40:  MOVLW  28
14D42:  MOVLB  8
14D44:  MOVWF  xB5
14D46:  MOVLW  FA
14D48:  MOVLB  9
14D4A:  MOVWF  xEC
14D4C:  MOVLB  0
14D4E:  CALL   2910
14D52:  MOVLB  8
14D54:  DECFSZ xB5,F
14D56:  BRA    14D46
....................                     macro_status = 'a'; 
14D58:  MOVLW  61
14D5A:  MOVWF  xA7
....................             break;        
14D5C:  BRA    14F16
....................          case 'L' : LightTargetFlag = 0; 
14D5E:  MOVLB  2
14D60:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
14D62:  MOVFF  8A4,8C2
14D66:  MOVFF  8A6,8C4
14D6A:  MOVFF  8A5,8C3
14D6E:  MOVLB  0
14D70:  CALL   127BC
....................                     macro_status = 'a'; 
14D74:  MOVLW  61
14D76:  MOVLB  8
14D78:  MOVWF  xA7
....................             break; 
14D7A:  BRA    14F16
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
14D7C:  MOVFF  8A4,47
....................                     arg = macro_arg; 
14D80:  CLRF   4B
14D82:  CLRF   4A
14D84:  MOVFF  8A6,49
14D88:  MOVFF  8A5,48
....................                     det_cmd(); 
14D8C:  CALL   F402
....................                     macro_status = 'a'; 
14D90:  MOVLW  61
14D92:  MOVLB  8
14D94:  MOVWF  xA7
....................             break ; 
14D96:  BRA    14F16
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
14D98:  MOVLB  8
14D9A:  DECFSZ xA5,W
14D9C:  BRA    14DAA
14D9E:  MOVF   xA6,F
14DA0:  BNZ   14DAA
14DA2:  MOVLB  0
14DA4:  CALL   13864
14DA8:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14DAA:  MOVF   xA5,W
14DAC:  SUBLW  02
14DAE:  BNZ   14DC2
14DB0:  MOVF   xA6,F
14DB2:  BNZ   14DC2
14DB4:  MOVLW  01
14DB6:  MOVWF  xC2
14DB8:  MOVWF  xC3
14DBA:  MOVLB  0
14DBC:  CALL   13A30
14DC0:  MOVLB  8
....................                     macro_status = 'a'; 
14DC2:  MOVLW  61
14DC4:  MOVWF  xA7
....................             break ;  
14DC6:  BRA    14F16
....................          case 'T' : det_temp(); 
14DC8:  CALL   13BF0
....................                     macro_status = 'a'; 
14DCC:  MOVLW  61
14DCE:  MOVLB  8
14DD0:  MOVWF  xA7
....................             break; 
14DD2:  BRA    14F16
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14DD4:  MOVLW  01
14DD6:  MOVLB  7
14DD8:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14DDA:  MOVLB  8
14DDC:  CLRF   xC7
14DDE:  CLRF   xC8
14DE0:  CLRF   xCC
14DE2:  CLRF   xCB
14DE4:  MOVFF  8A6,8CA
14DE8:  MOVFF  8A5,8C9
14DEC:  MOVWF  xCD
14DEE:  MOVLB  0
14DF0:  CALL   9D78
....................                     macro_status=step_err_status(); 
14DF4:  CALL   D302
14DF8:  MOVFF  01,8A7
....................             break; 
14DFC:  MOVLB  8
14DFE:  BRA    14F16
....................          case '-' : motor=1; 
14E00:  MOVLW  01
14E02:  MOVLB  7
14E04:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14E06:  MOVLB  8
14E08:  CLRF   xC7
14E0A:  MOVWF  xC8
14E0C:  CLRF   xCC
14E0E:  CLRF   xCB
14E10:  MOVFF  8A6,8CA
14E14:  MOVFF  8A5,8C9
14E18:  MOVWF  xCD
14E1A:  MOVLB  0
14E1C:  CALL   9D78
....................                     macro_status=step_err_status(); 
14E20:  CALL   D302
14E24:  MOVFF  01,8A7
....................             break; 
14E28:  MOVLB  8
14E2A:  BRA    14F16
....................          case 'G' : motor=0; 
14E2C:  MOVLB  7
14E2E:  CLRF   x40
....................                     align(0); 
14E30:  MOVLB  8
14E32:  CLRF   xC2
14E34:  MOVLB  0
14E36:  CALL   A8B4
....................                     macro_status=step_err_status(); 
14E3A:  CALL   D302
14E3E:  MOVFF  01,8A7
....................             break ;           
14E42:  MOVLB  8
14E44:  BRA    14F16
....................          case 'P' : motor=0; 
14E46:  MOVLB  7
14E48:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
14E4A:  MOVLW  01
14E4C:  MOVLB  8
14E4E:  MOVWF  xC7
14E50:  CLRF   xC8
14E52:  CLRF   xCC
14E54:  CLRF   xCB
14E56:  MOVFF  8A6,8CA
14E5A:  MOVFF  8A5,8C9
14E5E:  MOVWF  xCD
14E60:  MOVLB  0
14E62:  CALL   9D78
....................                     macro_status=step_err_status(); 
14E66:  CALL   D302
14E6A:  MOVFF  01,8A7
....................             break; 
14E6E:  MOVLB  8
14E70:  BRA    14F16
....................          case 'Q' : motor=0; 
14E72:  MOVLB  7
14E74:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
14E76:  MOVLB  8
14E78:  CLRF   xC7
14E7A:  CLRF   xC8
14E7C:  CLRF   xCC
14E7E:  CLRF   xCB
14E80:  MOVFF  8A6,8CA
14E84:  MOVFF  8A5,8C9
14E88:  MOVLW  01
14E8A:  MOVWF  xCD
14E8C:  MOVLB  0
14E8E:  CALL   9D78
....................                     macro_status=step_err_status(); 
14E92:  CALL   D302
14E96:  MOVFF  01,8A7
....................             break; 
14E9A:  MOVLB  8
14E9C:  BRA    14F16
....................          case 'R' : motor=0; 
14E9E:  MOVLB  7
14EA0:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
14EA2:  MOVLB  8
14EA4:  CLRF   xC7
14EA6:  MOVLW  01
14EA8:  MOVWF  xC8
14EAA:  CLRF   xCC
14EAC:  CLRF   xCB
14EAE:  MOVFF  8A6,8CA
14EB2:  MOVFF  8A5,8C9
14EB6:  MOVWF  xCD
14EB8:  MOVLB  0
14EBA:  CALL   9D78
....................                     macro_status=step_err_status(); 
14EBE:  CALL   D302
14EC2:  MOVFF  01,8A7
....................             break; 
14EC6:  MOVLB  8
14EC8:  BRA    14F16
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14ECA:  MOVLB  8
14ECC:  DECFSZ xA5,W
14ECE:  BRA    14EDE
14ED0:  MOVF   xA6,F
14ED2:  BNZ   14EDE
14ED4:  MOVLB  0
14ED6:  CALL   D370
14EDA:  BRA    14EEC
14EDC:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14EDE:  MOVF   xA5,F
14EE0:  BNZ   14EEE
14EE2:  MOVF   xA6,F
14EE4:  BNZ   14EEE
14EE6:  MOVLB  0
14EE8:  CALL   D394
14EEC:  MOVLB  8
....................                     macro_status = 'a'; 
14EEE:  MOVLW  61
14EF0:  MOVWF  xA7
....................             break; 
14EF2:  BRA    14F16
....................          case 'v':  
....................             arg = macro_arg; 
14EF4:  CLRF   4B
14EF6:  CLRF   4A
14EF8:  MOVFF  8A6,49
14EFC:  MOVFF  8A5,48
....................             command_v(); 
14F00:  CALL   13DDC
....................             macro_status = 'a'; 
14F04:  MOVLW  61
14F06:  MOVLB  8
14F08:  MOVWF  xA7
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
14F0A:  BRA    14F16
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14F0C:  MOVLW  66
14F0E:  MOVLB  8
14F10:  MOVWF  xA7
....................             break ; 
14F12:  BRA    14F16
14F14:  MOVLB  8
....................       } 
....................    } 
14F16:  BRA    151D6
14F18:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14F1A:  DECFSZ 2F,W
14F1C:  BRA    14F22
14F1E:  MOVF   30,F
14F20:  BZ    14F30
14F22:  MOVF   2F,W
14F24:  SUBLW  03
14F26:  BTFSS  FD8.2
14F28:  BRA    150AE
14F2A:  MOVF   30,F
14F2C:  BTFSS  FD8.2
14F2E:  BRA    150AE
....................       switch(macro_cmd){ 
14F30:  MOVLB  8
14F32:  MOVF   xA4,W
14F34:  XORLW  2B
14F36:  MOVLB  0
14F38:  BZ    14F66
14F3A:  XORLW  06
14F3C:  BZ    14F90
14F3E:  XORLW  6F
14F40:  BZ    14FBA
14F42:  XORLW  05
14F44:  BZ    14FCC
14F46:  XORLW  17
14F48:  BZ    14FE4
14F4A:  XORLW  01
14F4C:  BZ    1500E
14F4E:  XORLW  03
14F50:  BZ    15038
14F52:  XORLW  06
14F54:  BTFSC  FD8.2
14F56:  BRA    15062
14F58:  XORLW  0D
14F5A:  BTFSC  FD8.2
14F5C:  BRA    15078
14F5E:  XORLW  62
14F60:  BTFSC  FD8.2
14F62:  BRA    150A4
14F64:  BRA    150AC
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14F66:  MOVLW  01
14F68:  MOVLB  7
14F6A:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14F6C:  MOVLB  8
14F6E:  CLRF   xC7
14F70:  CLRF   xC8
14F72:  CLRF   xCC
14F74:  CLRF   xCB
14F76:  MOVFF  8A6,8CA
14F7A:  MOVFF  8A5,8C9
14F7E:  MOVWF  xCD
14F80:  MOVLB  0
14F82:  CALL   9D78
....................                     macro_status=step_err_status(); 
14F86:  CALL   D302
14F8A:  MOVFF  01,8A7
....................             break; 
14F8E:  BRA    150AC
....................          case '-' : motor=1; 
14F90:  MOVLW  01
14F92:  MOVLB  7
14F94:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14F96:  MOVLB  8
14F98:  CLRF   xC7
14F9A:  MOVWF  xC8
14F9C:  CLRF   xCC
14F9E:  CLRF   xCB
14FA0:  MOVFF  8A6,8CA
14FA4:  MOVFF  8A5,8C9
14FA8:  MOVWF  xCD
14FAA:  MOVLB  0
14FAC:  CALL   9D78
....................                     macro_status=step_err_status(); 
14FB0:  CALL   D302
14FB4:  MOVFF  01,8A7
....................             break; 
14FB8:  BRA    150AC
....................          case 'B' : h_bridge(macro_arg); 
14FBA:  MOVFF  8A5,8B5
14FBE:  CALL   C250
....................                     macro_status = 'a'; 
14FC2:  MOVLW  61
14FC4:  MOVLB  8
14FC6:  MOVWF  xA7
....................             break;             
14FC8:  MOVLB  0
14FCA:  BRA    150AC
....................          case 'G' : motor=0; 
14FCC:  MOVLB  7
14FCE:  CLRF   x40
....................                     align(0); 
14FD0:  MOVLB  8
14FD2:  CLRF   xC2
14FD4:  MOVLB  0
14FD6:  CALL   A8B4
....................                     macro_status=step_err_status(); 
14FDA:  CALL   D302
14FDE:  MOVFF  01,8A7
....................             break ;           
14FE2:  BRA    150AC
....................          case 'P' : motor=0; 
14FE4:  MOVLB  7
14FE6:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1);   
14FE8:  MOVLB  8
14FEA:  CLRF   xC7
14FEC:  CLRF   xC8
14FEE:  CLRF   xCC
14FF0:  CLRF   xCB
14FF2:  MOVFF  8A1,8CA
14FF6:  MOVFF  8A0,8C9
14FFA:  MOVLW  01
14FFC:  MOVWF  xCD
14FFE:  MOVLB  0
15000:  CALL   9D78
....................                     macro_status=step_err_status(); 
15004:  CALL   D302
15008:  MOVFF  01,8A7
....................             break; 
1500C:  BRA    150AC
....................          case 'Q' : motor=0; 
1500E:  MOVLB  7
15010:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1); 
15012:  MOVLB  8
15014:  CLRF   xC7
15016:  CLRF   xC8
15018:  CLRF   xCC
1501A:  CLRF   xCB
1501C:  MOVFF  8A1,8CA
15020:  MOVFF  8A0,8C9
15024:  MOVLW  01
15026:  MOVWF  xCD
15028:  MOVLB  0
1502A:  CALL   9D78
....................                     macro_status=step_err_status(); 
1502E:  CALL   D302
15032:  MOVFF  01,8A7
....................             break; 
15036:  BRA    150AC
....................          case 'R' : motor=0; 
15038:  MOVLB  7
1503A:  CLRF   x40
....................                     move_motor(0,1,mmacro_var,1); 
1503C:  MOVLB  8
1503E:  CLRF   xC7
15040:  MOVLW  01
15042:  MOVWF  xC8
15044:  CLRF   xCC
15046:  CLRF   xCB
15048:  MOVFF  8A1,8CA
1504C:  MOVFF  8A0,8C9
15050:  MOVWF  xCD
15052:  MOVLB  0
15054:  CALL   9D78
....................                     macro_status=step_err_status(); 
15058:  CALL   D302
1505C:  MOVFF  01,8A7
....................             break; 
15060:  BRA    150AC
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
15062:  MOVFF  8A6,8C3
15066:  MOVFF  8A5,8C2
1506A:  CALL   D33A
....................                     macro_status = 'a'; 
1506E:  MOVLW  61
15070:  MOVLB  8
15072:  MOVWF  xA7
....................             break; 
15074:  MOVLB  0
15076:  BRA    150AC
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
15078:  MOVLB  8
1507A:  DECFSZ xA5,W
1507C:  BRA    1508C
1507E:  MOVF   xA6,F
15080:  BNZ   1508C
15082:  MOVLB  0
15084:  CALL   D370
15088:  BRA    1509A
1508A:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
1508C:  MOVF   xA5,F
1508E:  BNZ   1509C
15090:  MOVF   xA6,F
15092:  BNZ   1509C
15094:  MOVLB  0
15096:  CALL   D394
1509A:  MOVLB  8
....................                     macro_status = 'a'; 
1509C:  MOVLW  61
1509E:  MOVWF  xA7
....................             break; 
150A0:  MOVLB  0
150A2:  BRA    150AC
....................          case ';' : macro_status = 'f'; 
150A4:  MOVLW  66
150A6:  MOVLB  8
150A8:  MOVWF  xA7
....................             break;            
150AA:  MOVLB  0
....................       } 
....................    } 
150AC:  BRA    151D4
....................    else if (nv_product==AWS){ 
150AE:  MOVF   2F,W
150B0:  SUBLW  02
150B2:  BTFSS  FD8.2
150B4:  BRA    151D4
150B6:  MOVF   30,F
150B8:  BTFSS  FD8.2
150BA:  BRA    151D4
....................       switch(macro_cmd){ 
150BC:  MOVLB  8
150BE:  MOVF   xA4,W
150C0:  XORLW  2B
150C2:  MOVLB  0
150C4:  BZ    150EA
150C6:  XORLW  06
150C8:  BZ    15114
150CA:  XORLW  6E
150CC:  BZ    1513E
150CE:  XORLW  07
150D0:  BZ    15150
150D2:  XORLW  14
150D4:  BZ    15166
150D6:  XORLW  01
150D8:  BZ    15178
150DA:  XORLW  02
150DC:  BZ    1518A
150DE:  XORLW  0A
150E0:  BZ    151A0
150E2:  XORLW  62
150E4:  BTFSC  FD8.2
150E6:  BRA    151CC
150E8:  BRA    151D4
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
150EA:  MOVLW  01
150EC:  MOVLB  7
150EE:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
150F0:  MOVLB  8
150F2:  CLRF   xC7
150F4:  CLRF   xC8
150F6:  CLRF   xCC
150F8:  CLRF   xCB
150FA:  MOVFF  8A6,8CA
150FE:  MOVFF  8A5,8C9
15102:  MOVWF  xCD
15104:  MOVLB  0
15106:  CALL   9D78
....................                     macro_status=step_err_status(); 
1510A:  CALL   D302
1510E:  MOVFF  01,8A7
....................             break; 
15112:  BRA    151D4
....................          case '-' : motor=1; 
15114:  MOVLW  01
15116:  MOVLB  7
15118:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
1511A:  MOVLB  8
1511C:  CLRF   xC7
1511E:  MOVWF  xC8
15120:  CLRF   xCC
15122:  CLRF   xCB
15124:  MOVFF  8A6,8CA
15128:  MOVFF  8A5,8C9
1512C:  MOVWF  xCD
1512E:  MOVLB  0
15130:  CALL   9D78
....................                     macro_status=step_err_status(); 
15134:  CALL   D302
15138:  MOVFF  01,8A7
....................             break; 
1513C:  BRA    151D4
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
1513E:  MOVFF  8A5,8B6
15142:  CALL   DBB6
....................                     macro_status = 'a';  
15146:  MOVLW  61
15148:  MOVLB  8
1514A:  MOVWF  xA7
....................             break;          
1514C:  MOVLB  0
1514E:  BRA    151D4
....................          case 'D' : delay_sec(macro_arg); 
15150:  MOVFF  8A6,8C3
15154:  MOVFF  8A5,8C2
15158:  CALL   D33A
....................                     macro_status = 'a'; 
1515C:  MOVLW  61
1515E:  MOVLB  8
15160:  MOVWF  xA7
....................             break; 
15162:  MOVLB  0
15164:  BRA    151D4
....................          case 'P' : sol_switch(mmacro_var); 
15166:  MOVFF  8A0,8B5
1516A:  CALL   1456C
....................                     macro_status = 'a'; 
1516E:  MOVLW  61
15170:  MOVLB  8
15172:  MOVWF  xA7
....................             break;              
15174:  MOVLB  0
15176:  BRA    151D4
....................          case 'Q' : sol_switch(macro_arg); 
15178:  MOVFF  8A5,8B5
1517C:  CALL   1456C
....................                     macro_status = 'a'; 
15180:  MOVLW  61
15182:  MOVLB  8
15184:  MOVWF  xA7
....................             break;             
15186:  MOVLB  0
15188:  BRA    151D4
....................          case 'S' : sol_switch_cmd(macro_arg); 
1518A:  MOVFF  8A6,8B7
1518E:  MOVFF  8A5,8B6
15192:  CALL   144B6
....................                     macro_status = 'a'; 
15196:  MOVLW  61
15198:  MOVLB  8
1519A:  MOVWF  xA7
....................             break; 
1519C:  MOVLB  0
1519E:  BRA    151D4
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
151A0:  MOVLB  8
151A2:  DECFSZ xA5,W
151A4:  BRA    151B4
151A6:  MOVF   xA6,F
151A8:  BNZ   151B4
151AA:  MOVLB  0
151AC:  CALL   D370
151B0:  BRA    151C2
151B2:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
151B4:  MOVF   xA5,F
151B6:  BNZ   151C4
151B8:  MOVF   xA6,F
151BA:  BNZ   151C4
151BC:  MOVLB  0
151BE:  CALL   D394
151C2:  MOVLB  8
....................                     macro_status = 'a'; 
151C4:  MOVLW  61
151C6:  MOVWF  xA7
....................             break;               
151C8:  MOVLB  0
151CA:  BRA    151D4
....................          case ';' : macro_status = 'f'; 
151CC:  MOVLW  66
151CE:  MOVLB  8
151D0:  MOVWF  xA7
....................             break;            
151D2:  MOVLB  0
151D4:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
151D6:  MOVFF  8A7,01
151DA:  MOVLB  0
151DC:  GOTO   154F4 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
153C2:  MOVLB  8
153C4:  CLRF   x58
153C6:  CLRF   x57
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
153C8:  MOVLB  0
153CA:  CALL   50E6
....................    clear_data_arrays(); 
153CE:  GOTO   1050A
....................     
....................    line = 0;  
153D2:  MOVLB  8
153D4:  CLRF   x9B
153D6:  CLRF   x9A
....................    macro_status = 'a'; 
153D8:  MOVLW  61
153DA:  MOVWF  x9C
....................    data_available = FALSE; 
153DC:  MOVLB  3
153DE:  CLRF   x3B
....................    macro_flag = 900; 
153E0:  MOVLW  03
153E2:  MOVWF  x24
153E4:  MOVLW  84
153E6:  MOVWF  x23
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
153E8:  MOVLW  01
153EA:  MOVWF  1E
153EC:  MOVLW  A7
153EE:  MOVWF  1D
153F0:  MOVLW  66
153F2:  MOVWF  FF6
153F4:  MOVLW  21
153F6:  MOVWF  FF7
153F8:  MOVLW  00
153FA:  MOVWF  FF8
153FC:  MOVLW  07
153FE:  MOVLB  8
15400:  MOVWF  xEB
15402:  MOVLB  0
15404:  CALL   AACC
15408:  MOVFF  897,8ED
1540C:  MOVLW  1B
1540E:  MOVLB  8
15410:  MOVWF  xEE
15412:  MOVLB  0
15414:  CALL   5280
15418:  MOVLW  6F
1541A:  MOVWF  FF6
1541C:  MOVLW  21
1541E:  MOVWF  FF7
15420:  MOVLW  00
15422:  MOVWF  FF8
15424:  MOVLW  09
15426:  MOVLB  8
15428:  MOVWF  xEB
1542A:  MOVLB  0
1542C:  CALL   AACC
....................    record_event();    
15430:  CALL   84DA
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
15434:  MOVLB  8
15436:  MOVF   x9B,W
15438:  SUBLW  03
1543A:  BNC   1550C
1543C:  MOVF   x9C,W
1543E:  SUBLW  61
15440:  BNZ   1550C
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
15442:  MOVF   1F,W
15444:  SUBLW  04
15446:  BNZ   154DA
15448:  MOVF   20,F
1544A:  BNZ   154DA
....................                                                macro_status, (line + 1)); 
1544C:  MOVLW  01
1544E:  ADDWF  x9A,W
15450:  MOVWF  x9D
15452:  MOVLW  00
15454:  ADDWFC x9B,W
15456:  MOVWF  x9E
15458:  MOVLW  7A
1545A:  MOVWF  FF6
1545C:  MOVLW  21
1545E:  MOVWF  FF7
15460:  MOVLW  00
15462:  MOVWF  FF8
15464:  CLRF   1B
15466:  BTFSC  FF2.7
15468:  BSF    1B.7
1546A:  BCF    FF2.7
1546C:  MOVLW  05
1546E:  MOVLB  A
15470:  MOVWF  x40
15472:  MOVLB  0
15474:  CALL   101C
15478:  BTFSC  1B.7
1547A:  BSF    FF2.7
1547C:  MOVLB  8
1547E:  MOVF   x9C,W
15480:  BTFSS  F9E.4
15482:  BRA    15480
15484:  MOVWF  FAD
15486:  MOVLW  5D
15488:  BTFSS  F9E.4
1548A:  BRA    15488
1548C:  MOVWF  FAD
1548E:  MOVLW  5B
15490:  BTFSS  F9E.4
15492:  BRA    15490
15494:  MOVWF  FAD
15496:  MOVLW  10
15498:  MOVWF  FE9
1549A:  CLRF   1B
1549C:  BTFSC  FF2.7
1549E:  BSF    1B.7
154A0:  BCF    FF2.7
154A2:  MOVFF  89E,A41
154A6:  MOVFF  89D,A40
154AA:  MOVLB  0
154AC:  CALL   119E
154B0:  BTFSC  1B.7
154B2:  BSF    FF2.7
154B4:  MOVLW  86
154B6:  MOVWF  FF6
154B8:  MOVLW  21
154BA:  MOVWF  FF7
154BC:  MOVLW  00
154BE:  MOVWF  FF8
154C0:  CLRF   1B
154C2:  BTFSC  FF2.7
154C4:  BSF    1B.7
154C6:  BCF    FF2.7
154C8:  MOVLW  03
154CA:  MOVLB  A
154CC:  MOVWF  x40
154CE:  MOVLB  0
154D0:  CALL   101C
154D4:  BTFSC  1B.7
154D6:  BSF    FF2.7
154D8:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
154DA:  MOVFF  897,89D
154DE:  MOVLW  08
154E0:  MOVWF  x9F
154E2:  MOVLW  9A
154E4:  MOVWF  x9E
154E6:  MOVFF  899,8A1
154EA:  MOVFF  898,8A0
154EE:  MOVLB  0
154F0:  GOTO   149F4
154F4:  MOVFF  01,89C
....................       ++line; 
154F8:  MOVLB  8
154FA:  INCF   x9A,F
154FC:  BTFSC  FD8.2
154FE:  INCF   x9B,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
15500:  DECFSZ 50,W
15502:  BRA    1550A
....................          macro_status = 'g'; 
15504:  MOVLW  67
15506:  MOVWF  x9C
....................          break;    
15508:  BRA    1550C
....................       } 
1550A:  BRA    15436
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
1550C:  MOVF   2F,W
1550E:  MOVWF  00
15510:  MOVF   30,W
15512:  MOVWF  03
15514:  MOVF   03,W
15516:  BNZ   15522
15518:  MOVLW  01
1551A:  SUBWF  00,W
1551C:  MOVLB  0
1551E:  BZ    15540
15520:  MOVLB  8
15522:  MOVF   03,W
15524:  BNZ   15530
15526:  MOVLW  03
15528:  SUBWF  00,W
1552A:  MOVLB  0
1552C:  BZ    15540
1552E:  MOVLB  8
15530:  MOVF   03,W
15532:  BNZ   1553E
15534:  MOVLW  02
15536:  SUBWF  00,W
15538:  MOVLB  0
1553A:  BZ    1554C
1553C:  MOVLB  8
1553E:  BRA    1555C
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
15540:  MOVFF  897,89D
15544:  CALL   D63E
....................          break; 
15548:  MOVLB  8
1554A:  BRA    1555C
....................       case AWS : store_aws_data(macro,mmacro_var); 
1554C:  MOVFF  897,89D
15550:  MOVFF  899,89F
15554:  MOVFF  898,89E
15558:  BRA    15298
....................          break; 
1555A:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
1555C:  MOVLW  61
1555E:  SUBWF  x9C,W
15560:  ADDLW  F9
15562:  BC    1564E
15564:  ADDLW  07
15566:  MOVLB  0
15568:  GOTO   156FA
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
1556C:  MOVLW  8A
1556E:  MOVWF  FF6
15570:  MOVLW  21
15572:  MOVWF  FF7
15574:  MOVLW  00
15576:  MOVWF  FF8
15578:  CLRF   1B
1557A:  BTFSC  FF2.7
1557C:  BSF    1B.7
1557E:  BCF    FF2.7
15580:  CALL   0E46
15584:  BTFSC  1B.7
15586:  BSF    FF2.7
....................          break; 
15588:  MOVLB  8
1558A:  BRA    1564E
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
1558C:  MOVLW  92
1558E:  MOVWF  FF6
15590:  MOVLW  21
15592:  MOVWF  FF7
15594:  MOVLW  00
15596:  MOVWF  FF8
15598:  CLRF   1B
1559A:  BTFSC  FF2.7
1559C:  BSF    1B.7
1559E:  BCF    FF2.7
155A0:  CALL   0E46
155A4:  BTFSC  1B.7
155A6:  BSF    FF2.7
....................          break; 
155A8:  MOVLB  8
155AA:  BRA    1564E
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
155AC:  MOVLW  9A
155AE:  MOVWF  FF6
155B0:  MOVLW  21
155B2:  MOVWF  FF7
155B4:  MOVLW  00
155B6:  MOVWF  FF8
155B8:  CLRF   1B
155BA:  BTFSC  FF2.7
155BC:  BSF    1B.7
155BE:  BCF    FF2.7
155C0:  CALL   0E46
155C4:  BTFSC  1B.7
155C6:  BSF    FF2.7
....................          break; 
155C8:  MOVLB  8
155CA:  BRA    1564E
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
155CC:  MOVLW  A2
155CE:  MOVWF  FF6
155D0:  MOVLW  21
155D2:  MOVWF  FF7
155D4:  MOVLW  00
155D6:  MOVWF  FF8
155D8:  CLRF   1B
155DA:  BTFSC  FF2.7
155DC:  BSF    1B.7
155DE:  BCF    FF2.7
155E0:  CALL   0E46
155E4:  BTFSC  1B.7
155E6:  BSF    FF2.7
....................          break; 
155E8:  MOVLB  8
155EA:  BRA    1564E
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
155EC:  MOVLW  AA
155EE:  MOVWF  FF6
155F0:  MOVLW  21
155F2:  MOVWF  FF7
155F4:  MOVLW  00
155F6:  MOVWF  FF8
155F8:  CLRF   1B
155FA:  BTFSC  FF2.7
155FC:  BSF    1B.7
155FE:  BCF    FF2.7
15600:  CALL   0E46
15604:  BTFSC  1B.7
15606:  BSF    FF2.7
....................          break;    
15608:  MOVLB  8
1560A:  BRA    1564E
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
1560C:  MOVLW  B2
1560E:  MOVWF  FF6
15610:  MOVLW  21
15612:  MOVWF  FF7
15614:  MOVLW  00
15616:  MOVWF  FF8
15618:  CLRF   1B
1561A:  BTFSC  FF2.7
1561C:  BSF    1B.7
1561E:  BCF    FF2.7
15620:  CALL   0E46
15624:  BTFSC  1B.7
15626:  BSF    FF2.7
....................          break;    
15628:  MOVLB  8
1562A:  BRA    1564E
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
1562C:  MOVLW  BA
1562E:  MOVWF  FF6
15630:  MOVLW  21
15632:  MOVWF  FF7
15634:  MOVLW  00
15636:  MOVWF  FF8
15638:  CLRF   1B
1563A:  BTFSC  FF2.7
1563C:  BSF    1B.7
1563E:  BCF    FF2.7
15640:  CALL   0E46
15644:  BTFSC  1B.7
15646:  BSF    FF2.7
....................          break;           
15648:  MOVLB  8
1564A:  BRA    1564E
1564C:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
1564E:  MOVLW  01
15650:  MOVWF  1E
15652:  MOVLW  A7
15654:  MOVWF  1D
15656:  MOVLW  C2
15658:  MOVWF  FF6
1565A:  MOVLW  21
1565C:  MOVWF  FF7
1565E:  MOVLW  00
15660:  MOVWF  FF8
15662:  MOVLW  07
15664:  MOVWF  xEB
15666:  MOVLB  0
15668:  CALL   AACC
1566C:  MOVFF  897,8ED
15670:  MOVLW  1B
15672:  MOVLB  8
15674:  MOVWF  xEE
15676:  MOVLB  0
15678:  CALL   5280
1567C:  MOVLW  CB
1567E:  MOVWF  FF6
15680:  MOVLW  21
15682:  MOVWF  FF7
15684:  MOVLW  00
15686:  MOVWF  FF8
15688:  MOVLW  09
1568A:  MOVLB  8
1568C:  MOVWF  xEB
1568E:  MOVLB  0
15690:  CALL   AACC
15694:  MOVFF  89C,8FF
15698:  CALL   509E
1569C:  MOVLW  D6
1569E:  MOVWF  FF6
156A0:  MOVLW  21
156A2:  MOVWF  FF7
156A4:  MOVLW  00
156A6:  MOVWF  FF8
156A8:  MOVLW  07
156AA:  MOVLB  8
156AC:  MOVWF  xEB
156AE:  MOVLB  0
156B0:  CALL   AACC
156B4:  MOVLW  10
156B6:  MOVWF  FE9
156B8:  MOVFF  89B,8F7
156BC:  MOVFF  89A,8F6
156C0:  CALL   AAFE
156C4:  MOVLW  E0
156C6:  MOVWF  FF6
156C8:  MOVLW  21
156CA:  MOVWF  FF7
156CC:  MOVLW  00
156CE:  MOVWF  FF8
156D0:  MOVLW  03
156D2:  MOVLB  8
156D4:  MOVWF  xEB
156D6:  MOVLB  0
156D8:  CALL   AACC
....................    record_event(); 
156DC:  CALL   84DA
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
156E0:  MOVLB  8
156E2:  MOVF   x9C,W
156E4:  SUBLW  66
156E6:  BZ    156F6
156E8:  MOVF   x9C,W
156EA:  SUBLW  67
156EC:  BZ    156F6
156EE:  MOVLB  0
156F0:  CALL   AA58
156F4:  MOVLB  8
156F6:  MOVLB  0
156F8:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15FA8:  MOVLW  01
15FAA:  MOVLB  8
15FAC:  MOVWF  x8F
....................    while (macro_batch == TRUE){ 
15FAE:  DECFSZ x8F,W
15FB0:  BRA    16236
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15FB2:  MOVFF  38,A11
15FB6:  MOVFF  37,A10
15FBA:  MOVLB  A
15FBC:  CLRF   x13
15FBE:  MOVLW  03
15FC0:  MOVWF  x12
15FC2:  MOVLB  0
15FC4:  CALL   5C98
15FC8:  MOVF   01,W
15FCA:  MOVLB  7
15FCC:  ADDWF  xD1,W
15FCE:  MOVLB  8
15FD0:  MOVWF  x8A
15FD2:  MOVF   02,W
15FD4:  MOVLB  7
15FD6:  ADDWFC xD2,W
15FD8:  MOVLB  8
15FDA:  MOVWF  x8B
....................       init_ext_eeprom(); 
15FDC:  MOVLB  0
15FDE:  CALL   105D0
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
15FE2:  MOVFF  88B,8CC
15FE6:  MOVFF  88A,8CB
15FEA:  CALL   10608
15FEE:  MOVFF  01,88C
....................       ++addr; 
15FF2:  MOVLB  8
15FF4:  INCF   x8A,F
15FF6:  BTFSC  FD8.2
15FF8:  INCF   x8B,F
....................       macro_arg = read16_ext_eeprom(addr); 
15FFA:  MOVFF  88B,8C3
15FFE:  MOVFF  88A,8C2
16002:  MOVLB  0
16004:  CALL   1071C
16008:  MOVFF  02,88E
1600C:  MOVFF  01,88D
....................       ++addr; 
16010:  MOVLB  8
16012:  INCF   x8A,F
16014:  BTFSC  FD8.2
16016:  INCF   x8B,F
....................       ++addr;      
16018:  INCF   x8A,F
1601A:  BTFSC  FD8.2
1601C:  INCF   x8B,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
1601E:  MOVF   x8C,W
16020:  SUBLW  4D
16022:  BTFSS  FD8.2
16024:  BRA    1614E
16026:  MOVF   x8D,F
16028:  BNZ   16030
1602A:  MOVF   x8E,F
1602C:  BTFSC  FD8.2
1602E:  BRA    1614E
....................          { 
....................          RTC_reset_HT(); 
16030:  MOVLB  0
16032:  CALL   34B2
....................          RTC_read(); 
16036:  CALL   3344
....................          RTC_display(); 
1603A:  CALL   E28A
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
1603E:  MOVLW  E4
16040:  MOVWF  FF6
16042:  MOVLW  21
16044:  MOVWF  FF7
16046:  MOVLW  00
16048:  MOVWF  FF8
1604A:  CLRF   1B
1604C:  BTFSC  FF2.7
1604E:  BSF    1B.7
16050:  BCF    FF2.7
16052:  MOVLW  09
16054:  MOVLB  A
16056:  MOVWF  x40
16058:  MOVLB  0
1605A:  CALL   101C
1605E:  BTFSC  1B.7
16060:  BSF    FF2.7
16062:  MOVLB  8
16064:  MOVF   x8C,W
16066:  BTFSS  F9E.4
16068:  BRA    16066
1606A:  MOVWF  FAD
1606C:  MOVLW  10
1606E:  MOVWF  FE9
16070:  CLRF   1B
16072:  BTFSC  FF2.7
16074:  BSF    1B.7
16076:  BCF    FF2.7
16078:  MOVFF  88E,A41
1607C:  MOVFF  88D,A40
16080:  MOVLB  0
16082:  CALL   119E
16086:  BTFSC  1B.7
16088:  BSF    FF2.7
1608A:  MOVLW  F2
1608C:  MOVWF  FF6
1608E:  MOVLW  21
16090:  MOVWF  FF7
16092:  MOVLW  00
16094:  MOVWF  FF8
16096:  CLRF   1B
16098:  BTFSC  FF2.7
1609A:  BSF    1B.7
1609C:  BCF    FF2.7
1609E:  MOVLW  03
160A0:  MOVLB  A
160A2:  MOVWF  x40
160A4:  MOVLB  0
160A6:  CALL   101C
160AA:  BTFSC  1B.7
160AC:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
160AE:  MOVLW  01
160B0:  ADDWF  21,W
160B2:  MOVLB  8
160B4:  MOVWF  x90
160B6:  MOVLW  00
160B8:  ADDWFC 22,W
160BA:  MOVWF  x91
160BC:  MOVLW  F6
160BE:  MOVWF  FF6
160C0:  MOVLW  21
160C2:  MOVWF  FF7
160C4:  MOVLW  00
160C6:  MOVWF  FF8
160C8:  CLRF   1B
160CA:  BTFSC  FF2.7
160CC:  BSF    1B.7
160CE:  BCF    FF2.7
160D0:  MOVLW  07
160D2:  MOVLB  A
160D4:  MOVWF  x40
160D6:  MOVLB  0
160D8:  CALL   101C
160DC:  BTFSC  1B.7
160DE:  BSF    FF2.7
160E0:  MOVLW  09
160E2:  MOVWF  FE9
160E4:  CLRF   1B
160E6:  BTFSC  FF2.7
160E8:  BSF    1B.7
160EA:  BCF    FF2.7
160EC:  MOVFF  891,A41
160F0:  MOVFF  890,A40
160F4:  CALL   119E
160F8:  BTFSC  1B.7
160FA:  BSF    FF2.7
160FC:  MOVLW  02
160FE:  MOVWF  FF6
16100:  MOVLW  22
16102:  MOVWF  FF7
16104:  MOVLW  00
16106:  MOVWF  FF8
16108:  CLRF   1B
1610A:  BTFSC  FF2.7
1610C:  BSF    1B.7
1610E:  BCF    FF2.7
16110:  MOVLW  04
16112:  MOVLB  A
16114:  MOVWF  x40
16116:  MOVLB  0
16118:  CALL   101C
1611C:  BTFSC  1B.7
1611E:  BSF    FF2.7
16120:  MOVLW  09
16122:  MOVWF  FE9
16124:  CLRF   1B
16126:  BTFSC  FF2.7
16128:  BSF    1B.7
1612A:  BCF    FF2.7
1612C:  MOVFF  28,A41
16130:  MOVFF  27,A40
16134:  CALL   119E
16138:  BTFSC  1B.7
1613A:  BSF    FF2.7
1613C:  MOVLW  0D
1613E:  BTFSS  F9E.4
16140:  BRA    1613E
16142:  MOVWF  FAD
16144:  MOVLW  0A
16146:  BTFSS  F9E.4
16148:  BRA    16146
1614A:  MOVWF  FAD
1614C:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
1614E:  MOVF   28,W
16150:  SUBWF  22,W
16152:  BNC   16160
16154:  BNZ   1615C
16156:  MOVF   27,W
16158:  SUBWF  21,W
1615A:  BNC   16160
....................          {macro_cmd = 'Z';} 
1615C:  MOVLW  5A
1615E:  MOVWF  x8C
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
16160:  MOVF   x8C,W
16162:  XORLW  72
16164:  MOVLB  0
16166:  BZ    1617A
16168:  XORLW  57
1616A:  BZ    1619C
1616C:  XORLW  68
1616E:  BZ    161D2
16170:  XORLW  17
16172:  BZ    16208
16174:  XORLW  61
16176:  BZ    16214
16178:  BRA    1621E
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
1617A:  INCF   37,F
1617C:  BTFSC  FD8.2
1617E:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
16180:  MOVLB  8
16182:  CLRF   x60
16184:  CLRF   x5F
16186:  MOVFF  38,85E
1618A:  MOVFF  37,85D
....................                master_macro_loop_count = macro_arg; 
1618E:  CLRF   x5C
16190:  CLRF   x5B
16192:  MOVFF  88E,85A
16196:  MOVFF  88D,859
....................             break; 
1619A:  BRA    1622A
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
1619C:  MOVLB  8
1619E:  MOVF   x5C,F
161A0:  BNZ   161B0
161A2:  MOVF   x5B,F
161A4:  BNZ   161B0
161A6:  MOVF   x5A,F
161A8:  BNZ   161B0
161AA:  MOVF   x59,W
161AC:  SUBLW  01
161AE:  BC    161CA
....................                   nv_macro_step = master_macro_loop_start; 
161B0:  MOVFF  85E,38
161B4:  MOVFF  85D,37
....................                   master_macro_loop_count--; 
161B8:  MOVLW  FF
161BA:  ADDWF  x59,F
161BC:  BTFSS  FD8.0
161BE:  ADDWF  x5A,F
161C0:  BTFSS  FD8.0
161C2:  ADDWF  x5B,F
161C4:  BTFSS  FD8.0
161C6:  ADDWF  x5C,F
....................                }else{ 
161C8:  BRA    161D0
....................                   nv_macro_step++; 
161CA:  INCF   37,F
161CC:  BTFSC  FD8.2
161CE:  INCF   38,F
....................                } 
....................             break; 
161D0:  BRA    1622A
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
161D2:  MOVLB  8
161D4:  MOVF   x8E,F
161D6:  BNZ   16206
161D8:  MOVF   x8D,W
161DA:  SUBLW  14
161DC:  BNC   16206
....................                   play_macro(macro_arg,0);     // casts to int8 
161DE:  MOVFF  88D,897
161E2:  CLRF   x99
161E4:  CLRF   x98
161E6:  MOVLB  0
161E8:  CALL   153C2
....................                   delay_ms(100); 
161EC:  MOVLW  64
161EE:  MOVLB  9
161F0:  MOVWF  xEC
161F2:  MOVLB  0
161F4:  CALL   2910
....................                   ++nv_sample; 
161F8:  INCF   21,F
161FA:  BTFSC  FD8.2
161FC:  INCF   22,F
....................                   ++nv_macro_step; 
161FE:  INCF   37,F
16200:  BTFSC  FD8.2
16202:  INCF   38,F
16204:  MOVLB  8
....................                } 
....................                break; 
16206:  BRA    1622A
....................             case 'Z' : ++nv_macro_step; 
16208:  INCF   37,F
1620A:  BTFSC  FD8.2
1620C:  INCF   38,F
....................                        macro_batch = FALSE; 
1620E:  MOVLB  8
16210:  CLRF   x8F
....................                break; 
16212:  BRA    1622A
....................             case ';' : nv_macro_step = 0; 
16214:  CLRF   38
16216:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
16218:  MOVLB  8
1621A:  BRA    1622A
1621C:  MOVLB  0
....................             default  : cmd_err(); 
1621E:  CALL   BFC0
....................                        macro_cmd = 'e'; 
16222:  MOVLW  65
16224:  MOVLB  8
16226:  MOVWF  x8C
....................                        macro_batch = FALSE; 
16228:  CLRF   x8F
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
1622A:  DECFSZ 50,W
1622C:  BRA    16234
....................             macro_cmd = ';'; 
1622E:  MOVLW  3B
16230:  MOVWF  x8C
....................             break;         // 17 = CTRL-Q (quit) 
16232:  BRA    16236
....................          } 
16234:  BRA    15FAE
....................    } 
....................    return (macro_cmd); 
16236:  MOVFF  88C,01
1623A:  MOVLB  0
1623C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D3AA:  MOVLB  8
0D3AC:  MOVF   x8C,W
0D3AE:  XORLW  2B
0D3B0:  MOVLB  0
0D3B2:  BZ    D3E2
0D3B4:  XORLW  06
0D3B6:  BZ    D40A
0D3B8:  XORLW  6F
0D3BA:  BZ    D432
0D3BC:  XORLW  05
0D3BE:  BZ    D444
0D3C0:  XORLW  17
0D3C2:  BZ    D45A
0D3C4:  XORLW  01
0D3C6:  BZ    D48A
0D3C8:  XORLW  03
0D3CA:  BTFSC  FD8.2
0D3CC:  BRA    D4B2
0D3CE:  XORLW  06
0D3D0:  BTFSC  FD8.2
0D3D2:  BRA    D4DA
0D3D4:  XORLW  0D
0D3D6:  BTFSC  FD8.2
0D3D8:  BRA    D4EE
0D3DA:  XORLW  62
0D3DC:  BTFSC  FD8.2
0D3DE:  BRA    D516
0D3E0:  BRA    D51E
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D3E2:  MOVLW  01
0D3E4:  MOVLB  7
0D3E6:  MOVWF  x40
....................                  move_motor(0,0,macro_arg,1); 
0D3E8:  MOVLB  8
0D3EA:  CLRF   xC7
0D3EC:  CLRF   xC8
0D3EE:  CLRF   xCC
0D3F0:  CLRF   xCB
0D3F2:  MOVFF  88E,8CA
0D3F6:  MOVFF  88D,8C9
0D3FA:  MOVWF  xCD
0D3FC:  MOVLB  0
0D3FE:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D402:  RCALL  D302
0D404:  MOVFF  01,88F
....................          break; 
0D408:  BRA    D51E
....................       case '-' : motor=1; 
0D40A:  MOVLW  01
0D40C:  MOVLB  7
0D40E:  MOVWF  x40
....................                  move_motor(0,1,macro_arg,1); 
0D410:  MOVLB  8
0D412:  CLRF   xC7
0D414:  MOVWF  xC8
0D416:  CLRF   xCC
0D418:  CLRF   xCB
0D41A:  MOVFF  88E,8CA
0D41E:  MOVFF  88D,8C9
0D422:  MOVWF  xCD
0D424:  MOVLB  0
0D426:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D42A:  RCALL  D302
0D42C:  MOVFF  01,88F
....................          break; 
0D430:  BRA    D51E
....................       case 'B' : h_bridge(macro_arg); 
0D432:  MOVFF  88D,8B5
0D436:  CALL   C250
....................                  macro_status = 'a'; 
0D43A:  MOVLW  61
0D43C:  MOVLB  8
0D43E:  MOVWF  x8F
....................          break; 
0D440:  MOVLB  0
0D442:  BRA    D51E
....................       case 'G' : motor=0; 
0D444:  MOVLB  7
0D446:  CLRF   x40
....................                  align(0); 
0D448:  MOVLB  8
0D44A:  CLRF   xC2
0D44C:  MOVLB  0
0D44E:  CALL   A8B4
....................                  macro_status=step_err_status(); 
0D452:  RCALL  D302
0D454:  MOVFF  01,88F
....................          break ;           
0D458:  BRA    D51E
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D45A:  MOVFF  88E,2E
0D45E:  MOVFF  88D,2D
....................                  motor=0; 
0D462:  MOVLB  7
0D464:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1);   
0D466:  MOVLB  8
0D468:  CLRF   xC7
0D46A:  CLRF   xC8
0D46C:  CLRF   xCC
0D46E:  CLRF   xCB
0D470:  MOVFF  88E,8CA
0D474:  MOVFF  88D,8C9
0D478:  MOVLW  01
0D47A:  MOVWF  xCD
0D47C:  MOVLB  0
0D47E:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D482:  RCALL  D302
0D484:  MOVFF  01,88F
....................          break; 
0D488:  BRA    D51E
....................       case 'Q' : motor=0; 
0D48A:  MOVLB  7
0D48C:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1); 
0D48E:  MOVLB  8
0D490:  CLRF   xC7
0D492:  CLRF   xC8
0D494:  CLRF   xCC
0D496:  CLRF   xCB
0D498:  MOVFF  88E,8CA
0D49C:  MOVFF  88D,8C9
0D4A0:  MOVLW  01
0D4A2:  MOVWF  xCD
0D4A4:  MOVLB  0
0D4A6:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D4AA:  RCALL  D302
0D4AC:  MOVFF  01,88F
....................          break; 
0D4B0:  BRA    D51E
....................       case 'R' : motor=0; 
0D4B2:  MOVLB  7
0D4B4:  CLRF   x40
....................                  move_motor(0,1,macro_arg,1); 
0D4B6:  MOVLB  8
0D4B8:  CLRF   xC7
0D4BA:  MOVLW  01
0D4BC:  MOVWF  xC8
0D4BE:  CLRF   xCC
0D4C0:  CLRF   xCB
0D4C2:  MOVFF  88E,8CA
0D4C6:  MOVFF  88D,8C9
0D4CA:  MOVWF  xCD
0D4CC:  MOVLB  0
0D4CE:  CALL   9D78
....................                  macro_status=step_err_status(); 
0D4D2:  RCALL  D302
0D4D4:  MOVFF  01,88F
....................          break; 
0D4D8:  BRA    D51E
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D4DA:  MOVFF  88E,8C3
0D4DE:  MOVFF  88D,8C2
0D4E2:  RCALL  D33A
....................                  macro_status = 'a'; 
0D4E4:  MOVLW  61
0D4E6:  MOVLB  8
0D4E8:  MOVWF  x8F
....................          break; 
0D4EA:  MOVLB  0
0D4EC:  BRA    D51E
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D4EE:  MOVLB  8
0D4F0:  DECFSZ x8D,W
0D4F2:  BRA    D500
0D4F4:  MOVF   x8E,F
0D4F6:  BNZ   D500
0D4F8:  MOVLB  0
0D4FA:  RCALL  D370
0D4FC:  BRA    D50C
0D4FE:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D500:  MOVF   x8D,F
0D502:  BNZ   D50E
0D504:  MOVF   x8E,F
0D506:  BNZ   D50E
0D508:  MOVLB  0
0D50A:  RCALL  D394
0D50C:  MOVLB  8
....................                  macro_status = 'a'; 
0D50E:  MOVLW  61
0D510:  MOVWF  x8F
....................          break;           
0D512:  MOVLB  0
0D514:  BRA    D51E
....................       case ';' : macro_status = 'f'; 
0D516:  MOVLW  66
0D518:  MOVLB  8
0D51A:  MOVWF  x8F
....................          break;            
0D51C:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D51E:  MOVLB  8
0D520:  MOVFF  88F,01
0D524:  MOVLB  0
0D526:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D800:  MOVF   2E,F
0D802:  BNZ   D80A
0D804:  MOVF   2D,W
0D806:  SUBLW  01
0D808:  BC    D81C
0D80A:  MOVF   2E,F
0D80C:  BNZ   D81C
0D80E:  MOVF   2D,W
0D810:  SUBLW  30
0D812:  BNC   D81C
0D814:  DECFSZ 2F,W
0D816:  BRA    D81C
0D818:  MOVF   30,F
0D81A:  BZ    D83A
0D81C:  MOVF   2E,F
0D81E:  BNZ   D826
0D820:  MOVF   2D,W
0D822:  SUBLW  01
0D824:  BC    D844
0D826:  MOVF   2E,F
0D828:  BNZ   D844
0D82A:  MOVF   2D,W
0D82C:  SUBLW  32
0D82E:  BNC   D844
0D830:  MOVF   2F,W
0D832:  SUBLW  03
0D834:  BNZ   D844
0D836:  MOVF   30,F
0D838:  BNZ   D844
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D83A:  MOVLW  61
0D83C:  MOVLB  8
0D83E:  MOVWF  x8B
....................    } 
0D840:  BRA    D84C
0D842:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D844:  MOVLW  65
0D846:  MOVLB  8
0D848:  MOVWF  x8B
....................       goto end_macro;       
0D84A:  BRA    D8FC
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D84C:  MOVLW  59
0D84E:  MOVWF  x8C
0D850:  CLRF   x8E
0D852:  MOVLW  01
0D854:  MOVWF  x8D
0D856:  MOVLB  0
0D858:  RCALL  D3AA
0D85A:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D85E:  MOVLB  8
0D860:  MOVF   x8B,W
0D862:  SUBLW  61
0D864:  BTFSS  FD8.2
0D866:  BRA    D8FC
....................    macro_status = play_wms_macro_cmd('G',1); 
0D868:  MOVLW  47
0D86A:  MOVWF  x8C
0D86C:  CLRF   x8E
0D86E:  MOVLW  01
0D870:  MOVWF  x8D
0D872:  MOVLB  0
0D874:  RCALL  D3AA
0D876:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D87A:  MOVLB  8
0D87C:  MOVF   x8B,W
0D87E:  SUBLW  61
0D880:  BTFSS  FD8.2
0D882:  BRA    D8FC
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D884:  MOVLW  2D
0D886:  MOVWF  x8C
0D888:  MOVFF  2C,88E
0D88C:  MOVFF  2B,88D
0D890:  MOVLB  0
0D892:  RCALL  D3AA
0D894:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D898:  MOVLB  8
0D89A:  MOVF   x8B,W
0D89C:  SUBLW  61
0D89E:  BTFSS  FD8.2
0D8A0:  BRA    D8FC
....................    macro_status = play_wms_macro_cmd('P',port); 
0D8A2:  MOVLW  50
0D8A4:  MOVWF  x8C
0D8A6:  MOVFF  88A,88E
0D8AA:  MOVFF  889,88D
0D8AE:  MOVLB  0
0D8B0:  RCALL  D3AA
0D8B2:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro;    
0D8B6:  MOVLB  8
0D8B8:  MOVF   x8B,W
0D8BA:  SUBLW  61
0D8BC:  BTFSS  FD8.2
0D8BE:  BRA    D8FC
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D8C0:  MOVLW  2B
0D8C2:  MOVWF  x8C
0D8C4:  MOVFF  2C,88E
0D8C8:  MOVFF  2B,88D
0D8CC:  MOVLB  0
0D8CE:  RCALL  D3AA
0D8D0:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8D4:  MOVLB  8
0D8D6:  MOVF   x8B,W
0D8D8:  SUBLW  61
0D8DA:  BTFSS  FD8.2
0D8DC:  BRA    D8FC
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D8DE:  MOVLW  59
0D8E0:  MOVWF  x8C
0D8E2:  CLRF   x8E
0D8E4:  CLRF   x8D
0D8E6:  MOVLB  0
0D8E8:  RCALL  D3AA
0D8EA:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8EE:  MOVLB  8
0D8F0:  MOVF   x8B,W
0D8F2:  SUBLW  61
0D8F4:  BTFSS  FD8.2
0D8F6:  BRA    D8FC
....................    macro_status='f';  
0D8F8:  MOVLW  66
0D8FA:  MOVWF  x8B
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D8FC:  CLRF   x9D
0D8FE:  MOVLB  0
0D900:  RCALL  D63E
....................    
....................    switch(macro_status){ 
0D902:  MOVLW  61
0D904:  MOVLB  8
0D906:  SUBWF  x8B,W
0D908:  ADDLW  FA
0D90A:  BC    D9DE
0D90C:  ADDLW  06
0D90E:  MOVLB  0
0D910:  GOTO   D9E2
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D914:  MOVF   1F,F
0D916:  BNZ   D91C
0D918:  MOVF   20,F
0D91A:  BZ    D938
0D91C:  MOVLW  0E
0D91E:  MOVWF  FF6
0D920:  MOVLW  22
0D922:  MOVWF  FF7
0D924:  MOVLW  00
0D926:  MOVWF  FF8
0D928:  CLRF   1B
0D92A:  BTFSC  FF2.7
0D92C:  BSF    1B.7
0D92E:  BCF    FF2.7
0D930:  CALL   0E46
0D934:  BTFSC  1B.7
0D936:  BSF    FF2.7
....................          break; 
0D938:  MOVLB  8
0D93A:  BRA    D9DE
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D93C:  MOVLW  16
0D93E:  MOVWF  FF6
0D940:  MOVLW  22
0D942:  MOVWF  FF7
0D944:  MOVLW  00
0D946:  MOVWF  FF8
0D948:  CLRF   1B
0D94A:  BTFSC  FF2.7
0D94C:  BSF    1B.7
0D94E:  BCF    FF2.7
0D950:  CALL   0E46
0D954:  BTFSC  1B.7
0D956:  BSF    FF2.7
....................          break; 
0D958:  MOVLB  8
0D95A:  BRA    D9DE
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D95C:  MOVLW  1E
0D95E:  MOVWF  FF6
0D960:  MOVLW  22
0D962:  MOVWF  FF7
0D964:  MOVLW  00
0D966:  MOVWF  FF8
0D968:  CLRF   1B
0D96A:  BTFSC  FF2.7
0D96C:  BSF    1B.7
0D96E:  BCF    FF2.7
0D970:  CALL   0E46
0D974:  BTFSC  1B.7
0D976:  BSF    FF2.7
....................          break; 
0D978:  MOVLB  8
0D97A:  BRA    D9DE
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D97C:  MOVLW  26
0D97E:  MOVWF  FF6
0D980:  MOVLW  22
0D982:  MOVWF  FF7
0D984:  MOVLW  00
0D986:  MOVWF  FF8
0D988:  CLRF   1B
0D98A:  BTFSC  FF2.7
0D98C:  BSF    1B.7
0D98E:  BCF    FF2.7
0D990:  CALL   0E46
0D994:  BTFSC  1B.7
0D996:  BSF    FF2.7
....................          break; 
0D998:  MOVLB  8
0D99A:  BRA    D9DE
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D99C:  MOVLW  2E
0D99E:  MOVWF  FF6
0D9A0:  MOVLW  22
0D9A2:  MOVWF  FF7
0D9A4:  MOVLW  00
0D9A6:  MOVWF  FF8
0D9A8:  CLRF   1B
0D9AA:  BTFSC  FF2.7
0D9AC:  BSF    1B.7
0D9AE:  BCF    FF2.7
0D9B0:  CALL   0E46
0D9B4:  BTFSC  1B.7
0D9B6:  BSF    FF2.7
....................          break;    
0D9B8:  MOVLB  8
0D9BA:  BRA    D9DE
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D9BC:  MOVLW  36
0D9BE:  MOVWF  FF6
0D9C0:  MOVLW  22
0D9C2:  MOVWF  FF7
0D9C4:  MOVLW  00
0D9C6:  MOVWF  FF8
0D9C8:  CLRF   1B
0D9CA:  BTFSC  FF2.7
0D9CC:  BSF    1B.7
0D9CE:  BCF    FF2.7
0D9D0:  CALL   0E46
0D9D4:  BTFSC  1B.7
0D9D6:  BSF    FF2.7
....................          break;           
0D9D8:  MOVLB  8
0D9DA:  BRA    D9DE
0D9DC:  MOVLB  8
....................    } 
0D9DE:  MOVLB  0
0D9E0:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
1647E:  MOVLB  8
16480:  MOVF   x88,W
16482:  BTFSC  FD8.2
16484:  DECF   x89,F
16486:  DECF   x88,F
....................    addr = macro_address[0] + (step*9); 
16488:  MOVFF  889,A11
1648C:  MOVFF  888,A10
16490:  MOVLB  A
16492:  CLRF   x13
16494:  MOVLW  09
16496:  MOVWF  x12
16498:  MOVLB  0
1649A:  CALL   5C98
1649E:  MOVF   01,W
164A0:  MOVLB  7
164A2:  ADDWF  xD1,W
164A4:  MOVLB  8
164A6:  MOVWF  x8A
164A8:  MOVF   02,W
164AA:  MOVLB  7
164AC:  ADDWFC xD2,W
164AE:  MOVLB  8
164B0:  MOVWF  x8B
....................     
....................    init_ext_eeprom(); 
164B2:  MOVLB  0
164B4:  CALL   105D0
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
164B8:  MOVFF  88B,8CC
164BC:  MOVFF  88A,8CB
164C0:  CALL   10608
164C4:  MOVFF  01,88C
....................    ++addr; 
164C8:  MOVLB  8
164CA:  INCF   x8A,F
164CC:  BTFSC  FD8.2
164CE:  INCF   x8B,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
164D0:  MOVFF  88B,8C3
164D4:  MOVFF  88A,8C2
164D8:  MOVLB  0
164DA:  CALL   1071C
164DE:  MOVFF  02,890
164E2:  MOVFF  01,88F
....................    ++addr; 
164E6:  MOVLB  8
164E8:  INCF   x8A,F
164EA:  BTFSC  FD8.2
164EC:  INCF   x8B,F
....................    ++addr; 
164EE:  INCF   x8A,F
164F0:  BTFSC  FD8.2
164F2:  INCF   x8B,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
164F4:  MOVFF  88B,8CC
164F8:  MOVFF  88A,8CB
164FC:  MOVLB  0
164FE:  CALL   10608
16502:  MOVFF  01,88D
....................    ++addr; 
16506:  MOVLB  8
16508:  INCF   x8A,F
1650A:  BTFSC  FD8.2
1650C:  INCF   x8B,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
1650E:  MOVFF  88B,8C3
16512:  MOVFF  88A,8C2
16516:  MOVLB  0
16518:  CALL   1071C
1651C:  MOVFF  02,892
16520:  MOVFF  01,891
....................    ++addr; 
16524:  MOVLB  8
16526:  INCF   x8A,F
16528:  BTFSC  FD8.2
1652A:  INCF   x8B,F
....................    ++addr; 
1652C:  INCF   x8A,F
1652E:  BTFSC  FD8.2
16530:  INCF   x8B,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
16532:  MOVFF  88B,8CC
16536:  MOVFF  88A,8CB
1653A:  MOVLB  0
1653C:  CALL   10608
16540:  MOVFF  01,88E
....................    ++addr; 
16544:  MOVLB  8
16546:  INCF   x8A,F
16548:  BTFSC  FD8.2
1654A:  INCF   x8B,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
1654C:  MOVFF  88B,8C3
16550:  MOVFF  88A,8C2
16554:  MOVLB  0
16556:  CALL   1071C
1655A:  MOVFF  02,894
1655E:  MOVFF  01,893
....................    ++addr; 
16562:  MOVLB  8
16564:  INCF   x8A,F
16566:  BTFSC  FD8.2
16568:  INCF   x8B,F
....................    ++addr; 
1656A:  INCF   x8A,F
1656C:  BTFSC  FD8.2
1656E:  INCF   x8B,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16570:  MOVFF  88B,8CC
16574:  MOVFF  88A,8CB
16578:  MOVLB  0
1657A:  CALL   10608
1657E:  MOVFF  01,895
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
16582:  MOVLB  8
16584:  MOVF   x8C,W
16586:  SUBLW  4A
16588:  BTFSS  FD8.2
1658A:  BRA    16660
1658C:  MOVF   x8D,W
1658E:  SUBLW  50
16590:  BNZ   16660
16592:  MOVF   x8E,W
16594:  SUBLW  4D
16596:  BNZ   16660
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
16598:  MOVF   x8C,W
1659A:  BTFSS  F9E.4
1659C:  BRA    1659A
1659E:  MOVWF  FAD
165A0:  MOVLW  10
165A2:  MOVWF  FE9
165A4:  CLRF   1B
165A6:  BTFSC  FF2.7
165A8:  BSF    1B.7
165AA:  BCF    FF2.7
165AC:  MOVFF  890,A41
165B0:  MOVFF  88F,A40
165B4:  MOVLB  0
165B6:  CALL   119E
165BA:  BTFSC  1B.7
165BC:  BSF    FF2.7
165BE:  MOVLW  2C
165C0:  BTFSS  F9E.4
165C2:  BRA    165C0
165C4:  MOVWF  FAD
165C6:  MOVLB  8
165C8:  MOVF   x8D,W
165CA:  BTFSS  F9E.4
165CC:  BRA    165CA
165CE:  MOVWF  FAD
165D0:  MOVLW  10
165D2:  MOVWF  FE9
165D4:  CLRF   1B
165D6:  BTFSC  FF2.7
165D8:  BSF    1B.7
165DA:  BCF    FF2.7
165DC:  MOVFF  892,A41
165E0:  MOVFF  891,A40
165E4:  MOVLB  0
165E6:  CALL   119E
165EA:  BTFSC  1B.7
165EC:  BSF    FF2.7
165EE:  MOVLW  2C
165F0:  BTFSS  F9E.4
165F2:  BRA    165F0
165F4:  MOVWF  FAD
165F6:  MOVLB  8
165F8:  MOVF   x8E,W
165FA:  BTFSS  F9E.4
165FC:  BRA    165FA
165FE:  MOVWF  FAD
16600:  MOVLW  10
16602:  MOVWF  FE9
16604:  CLRF   1B
16606:  BTFSC  FF2.7
16608:  BSF    1B.7
1660A:  BCF    FF2.7
1660C:  MOVFF  894,A41
16610:  MOVFF  893,A40
16614:  MOVLB  0
16616:  CALL   119E
1661A:  BTFSC  1B.7
1661C:  BSF    FF2.7
1661E:  MOVLW  0D
16620:  BTFSS  F9E.4
16622:  BRA    16620
16624:  MOVWF  FAD
16626:  MOVLW  0A
16628:  BTFSS  F9E.4
1662A:  BRA    16628
1662C:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
1662E:  MOVFF  890,24
16632:  MOVFF  88F,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
16636:  MOVLB  8
16638:  MOVF   x93,F
1663A:  BNZ   16640
1663C:  MOVF   x94,F
1663E:  BZ    1665E
16640:  MOVF   x94,F
16642:  BNZ   1665E
16644:  MOVF   x93,W
16646:  SUBLW  10
16648:  BNC   1665E
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
1664A:  MOVFF  893,897
1664E:  MOVFF  892,899
16652:  MOVFF  891,898
16656:  MOVLB  0
16658:  CALL   153C2
1665C:  MOVLB  8
....................       } 
....................    } 
1665E:  BRA    1666C
....................    else { 
....................       cmd_err(); 
16660:  MOVLB  0
16662:  CALL   BFC0
....................       macro_end = 59; 
16666:  MOVLW  3B
16668:  MOVLB  8
1666A:  MOVWF  x95
....................    } 
....................     
....................    return (macro_end); 
1666C:  MOVFF  895,01
16670:  MOVLB  0
16672:  GOTO   1675C (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
1685E:  MOVLB  8
16860:  MOVF   x8C,W
16862:  BTFSC  FD8.2
16864:  DECF   x8D,F
16866:  DECF   x8C,F
....................    addr = macro_address[0] + (step*6); 
16868:  MOVFF  88D,A11
1686C:  MOVFF  88C,A10
16870:  MOVLB  A
16872:  CLRF   x13
16874:  MOVLW  06
16876:  MOVWF  x12
16878:  MOVLB  0
1687A:  CALL   5C98
1687E:  MOVF   01,W
16880:  MOVLB  7
16882:  ADDWF  xD1,W
16884:  MOVLB  8
16886:  MOVWF  x8E
16888:  MOVF   02,W
1688A:  MOVLB  7
1688C:  ADDWFC xD2,W
1688E:  MOVLB  8
16890:  MOVWF  x8F
....................     
....................    init_ext_eeprom(); 
16892:  MOVLB  0
16894:  CALL   105D0
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
16898:  MOVFF  88F,8CC
1689C:  MOVFF  88E,8CB
168A0:  CALL   10608
168A4:  MOVFF  01,890
....................    ++addr; 
168A8:  MOVLB  8
168AA:  INCF   x8E,F
168AC:  BTFSC  FD8.2
168AE:  INCF   x8F,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
168B0:  MOVFF  88F,8C3
168B4:  MOVFF  88E,8C2
168B8:  MOVLB  0
168BA:  CALL   1071C
168BE:  MOVFF  02,893
168C2:  MOVFF  01,892
....................    ++addr; 
168C6:  MOVLB  8
168C8:  INCF   x8E,F
168CA:  BTFSC  FD8.2
168CC:  INCF   x8F,F
....................    ++addr; 
168CE:  INCF   x8E,F
168D0:  BTFSC  FD8.2
168D2:  INCF   x8F,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
168D4:  MOVFF  88F,8CC
168D8:  MOVFF  88E,8CB
168DC:  MOVLB  0
168DE:  CALL   10608
168E2:  MOVFF  01,891
....................    ++addr; 
168E6:  MOVLB  8
168E8:  INCF   x8E,F
168EA:  BTFSC  FD8.2
168EC:  INCF   x8F,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
168EE:  MOVFF  88F,8C3
168F2:  MOVFF  88E,8C2
168F6:  MOVLB  0
168F8:  CALL   1071C
168FC:  MOVFF  02,895
16900:  MOVFF  01,894
....................    ++addr; 
16904:  MOVLB  8
16906:  INCF   x8E,F
16908:  BTFSC  FD8.2
1690A:  INCF   x8F,F
....................    ++addr; 
1690C:  INCF   x8E,F
1690E:  BTFSC  FD8.2
16910:  INCF   x8F,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16912:  MOVFF  88F,8CC
16916:  MOVFF  88E,8CB
1691A:  MOVLB  0
1691C:  CALL   10608
16920:  MOVFF  01,896
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
16924:  MOVLB  8
16926:  MOVF   x90,W
16928:  SUBLW  50
1692A:  BNZ   169CE
1692C:  MOVF   x91,W
1692E:  SUBLW  4D
16930:  BNZ   169CE
....................        
....................       RTC_read(); 
16932:  MOVLB  0
16934:  CALL   3344
....................       RTC_display(); 
16938:  CALL   E28A
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
1693C:  MOVLB  8
1693E:  MOVF   x90,W
16940:  BTFSS  F9E.4
16942:  BRA    16940
16944:  MOVWF  FAD
16946:  MOVLW  10
16948:  MOVWF  FE9
1694A:  CLRF   1B
1694C:  BTFSC  FF2.7
1694E:  BSF    1B.7
16950:  BCF    FF2.7
16952:  MOVFF  893,A41
16956:  MOVFF  892,A40
1695A:  MOVLB  0
1695C:  CALL   119E
16960:  BTFSC  1B.7
16962:  BSF    FF2.7
16964:  MOVLW  2C
16966:  BTFSS  F9E.4
16968:  BRA    16966
1696A:  MOVWF  FAD
1696C:  MOVLB  8
1696E:  MOVF   x91,W
16970:  BTFSS  F9E.4
16972:  BRA    16970
16974:  MOVWF  FAD
16976:  MOVLW  10
16978:  MOVWF  FE9
1697A:  CLRF   1B
1697C:  BTFSC  FF2.7
1697E:  BSF    1B.7
16980:  BCF    FF2.7
16982:  MOVFF  895,A41
16986:  MOVFF  894,A40
1698A:  MOVLB  0
1698C:  CALL   119E
16990:  BTFSC  1B.7
16992:  BSF    FF2.7
16994:  MOVLW  0D
16996:  BTFSS  F9E.4
16998:  BRA    16996
1699A:  MOVWF  FAD
1699C:  MOVLW  0A
1699E:  BTFSS  F9E.4
169A0:  BRA    1699E
169A2:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
169A4:  MOVLB  8
169A6:  MOVF   x94,F
169A8:  BNZ   169AE
169AA:  MOVF   x95,F
169AC:  BZ    169CC
169AE:  MOVF   x95,F
169B0:  BNZ   169CC
169B2:  MOVF   x94,W
169B4:  SUBLW  10
169B6:  BNC   169CC
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
169B8:  MOVFF  894,897
169BC:  MOVFF  893,899
169C0:  MOVFF  892,898
169C4:  MOVLB  0
169C6:  CALL   153C2
169CA:  MOVLB  8
....................       } 
....................    } 
169CC:  BRA    169DA
....................    else { 
....................       cmd_err(); 
169CE:  MOVLB  0
169D0:  CALL   BFC0
....................       macro_end = 59; 
169D4:  MOVLW  3B
169D6:  MOVLB  8
169D8:  MOVWF  x96
....................    } 
....................     
....................    return (macro_end); 
169DA:  MOVFF  896,01
169DE:  MOVLB  0
169E0:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
1625C:  MOVF   24,W
1625E:  SUBWF  36,W
16260:  BTFSS  FD8.0
16262:  BRA    1646A
16264:  BNZ   1626E
16266:  MOVF   23,W
16268:  SUBWF  35,W
1626A:  BTFSS  FD8.0
1626C:  BRA    1646A
1626E:  MOVF   33,F
16270:  BTFSS  FD8.2
16272:  BRA    1646A
16274:  MOVF   34,F
16276:  BTFSS  FD8.2
16278:  BRA    1646A
....................       { 
....................          nv_elapsed = 0; 
1627A:  CLRF   36
1627C:  CLRF   35
....................  
....................          init_hardware(); 
1627E:  CALL   293A
....................          sd_status = init_sdcard(); 
16282:  CALL   503A
16286:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
1628A:  MOVLB  2
1628C:  MOVF   xDC,F
1628E:  BZ    16298
16290:  MOVLB  0
16292:  CALL   5080
16296:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16298:  MOVLW  01
1629A:  MOVWF  1E
1629C:  MOVLW  A7
1629E:  MOVWF  1D
162A0:  MOVLW  3E
162A2:  MOVWF  FF6
162A4:  MOVLW  22
162A6:  MOVWF  FF7
162A8:  MOVLW  00
162AA:  MOVWF  FF8
162AC:  MOVLW  14
162AE:  MOVLB  8
162B0:  MOVWF  xEB
162B2:  MOVLB  0
162B4:  CALL   AACC
162B8:  MOVLW  10
162BA:  MOVWF  FE9
162BC:  MOVFF  22,8F7
162C0:  MOVFF  21,8F6
162C4:  CALL   AAFE
162C8:  MOVLW  55
162CA:  MOVWF  FF6
162CC:  MOVLW  22
162CE:  MOVWF  FF7
162D0:  MOVLW  00
162D2:  MOVWF  FF8
162D4:  MOVLW  09
162D6:  MOVLB  8
162D8:  MOVWF  xEB
162DA:  MOVLB  0
162DC:  CALL   AACC
....................          record_event();          
162E0:  CALL   84DA
....................              
....................          macro_cmd = master_macro_eco(); 
162E4:  RCALL  15FA8
162E6:  MOVFF  01,887
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
162EA:  MOVLW  16
162EC:  MOVLB  8
162EE:  MOVWF  xEE
162F0:  MOVFF  22,8F0
162F4:  MOVFF  21,8EF
162F8:  MOVLB  0
162FA:  CALL   4FD4
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
162FE:  MOVLW  3A
16300:  MOVLB  8
16302:  MOVWF  xEE
16304:  MOVFF  38,8F0
16308:  MOVFF  37,8EF
1630C:  MOVLB  0
1630E:  CALL   4FD4
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
16312:  DECFSZ 50,W
16314:  BRA    16338
....................          { 
....................             disable_interrupts (INT_EXT); 
16316:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
16318:  CLRF   32
1631A:  MOVLW  01
1631C:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
1631E:  MOVLW  02
16320:  MOVLB  8
16322:  MOVWF  x89
16324:  MOVFF  31,88A
16328:  MOVLB  0
1632A:  CALL   3412
....................             busy_clear(); 
1632E:  CALL   AEB0
....................             return (user_quit); 
16332:  MOVFF  50,01
16336:  BRA    1647A
....................          } 
....................  
....................          motor_sleep_rdy(); 
16338:  CALL   2998
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
1633C:  MOVLW  01
1633E:  MOVWF  1E
16340:  MOVLW  A7
16342:  MOVWF  1D
16344:  MOVLW  60
16346:  MOVWF  FF6
16348:  MOVLW  22
1634A:  MOVWF  FF7
1634C:  MOVLW  00
1634E:  MOVWF  FF8
16350:  MOVLW  14
16352:  MOVLB  8
16354:  MOVWF  xEB
16356:  MOVLB  0
16358:  CALL   AACC
1635C:  MOVLW  10
1635E:  MOVWF  FE9
16360:  MOVFF  22,8F7
16364:  MOVFF  21,8F6
16368:  CALL   AAFE
1636C:  MOVLW  77
1636E:  MOVWF  FF6
16370:  MOVLW  22
16372:  MOVWF  FF7
16374:  MOVLW  00
16376:  MOVWF  FF8
16378:  MOVLW  0C
1637A:  MOVLB  8
1637C:  MOVWF  xEB
1637E:  MOVLB  0
16380:  CALL   AACC
....................          record_event();  
16384:  CALL   84DA
....................           
....................          if (macro_cmd == 'e') 
16388:  MOVLB  8
1638A:  MOVF   x87,W
1638C:  SUBLW  65
1638E:  BNZ   163E2
....................          { 
....................             disable_interrupts (INT_EXT); 
16390:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
16392:  MOVLW  01
16394:  MOVWF  1E
16396:  MOVLW  A7
16398:  MOVWF  1D
1639A:  MOVLW  84
1639C:  MOVWF  FF6
1639E:  MOVLW  22
163A0:  MOVWF  FF7
163A2:  MOVLW  00
163A4:  MOVWF  FF8
163A6:  MOVLW  14
163A8:  MOVWF  xEB
163AA:  MOVLB  0
163AC:  CALL   AACC
163B0:  MOVLW  10
163B2:  MOVWF  FE9
163B4:  MOVFF  22,8F7
163B8:  MOVFF  21,8F6
163BC:  CALL   AAFE
163C0:  MOVLW  9B
163C2:  MOVWF  FF6
163C4:  MOVLW  22
163C6:  MOVWF  FF7
163C8:  MOVLW  00
163CA:  MOVWF  FF8
163CC:  MOVLW  09
163CE:  MOVLB  8
163D0:  MOVWF  xEB
163D2:  MOVLB  0
163D4:  CALL   AACC
....................             record_event();  
163D8:  CALL   84DA
....................             cmd_err(); 
163DC:  CALL   BFC0
163E0:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
163E2:  MOVF   28,W
163E4:  SUBWF  22,W
163E6:  BNC   1646C
163E8:  BNZ   163F0
163EA:  MOVF   27,W
163EC:  SUBWF  21,W
163EE:  BNC   1646C
....................          { 
....................             disable_interrupts (INT_EXT); 
163F0:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
163F2:  MOVLW  01
163F4:  MOVWF  1E
163F6:  MOVLW  A7
163F8:  MOVWF  1D
163FA:  MOVLW  A6
163FC:  MOVWF  FF6
163FE:  MOVLW  22
16400:  MOVWF  FF7
16402:  MOVLW  00
16404:  MOVWF  FF8
16406:  MOVLW  14
16408:  MOVWF  xEB
1640A:  MOVLB  0
1640C:  CALL   AACC
16410:  MOVLW  10
16412:  MOVWF  FE9
16414:  MOVFF  22,8F7
16418:  MOVFF  21,8F6
1641C:  CALL   AAFE
16420:  MOVLW  BD
16422:  MOVWF  FF6
16424:  MOVLW  22
16426:  MOVWF  FF7
16428:  MOVLW  00
1642A:  MOVWF  FF8
1642C:  MOVLW  0F
1642E:  MOVLB  8
16430:  MOVWF  xEB
16432:  MOVLB  0
16434:  CALL   AACC
....................             record_event();   
16438:  CALL   84DA
....................             msg_max(); 
1643C:  RCALL  1623E
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
1643E:  CLRF   34
16440:  MOVLW  01
16442:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
16444:  MOVLW  28
16446:  MOVLB  8
16448:  MOVWF  x89
1644A:  MOVFF  33,88A
1644E:  MOVLB  0
16450:  CALL   3412
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
16454:  CLRF   32
16456:  MOVLW  01
16458:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
1645A:  MOVLW  02
1645C:  MOVLB  8
1645E:  MOVWF  x89
16460:  MOVFF  31,88A
16464:  MOVLB  0
16466:  CALL   3412
1646A:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
1646C:  MOVLB  0
1646E:  RCALL  15EE2
16470:  BRA    1625C
....................    } 
....................     
....................    busy_clear(); 
16472:  CALL   AEB0
....................    return (user_quit); 
16476:  MOVFF  50,01
1647A:  GOTO   16D9E (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16676:  MOVF   24,W
16678:  SUBWF  36,W
1667A:  BTFSS  FD8.0
1667C:  BRA    1684C
1667E:  BNZ   16688
16680:  MOVF   23,W
16682:  SUBWF  35,W
16684:  BTFSS  FD8.0
16686:  BRA    1684C
....................       { 
....................          nv_elapsed = 0; 
16688:  CLRF   36
1668A:  CLRF   35
....................  
....................          init_hardware(); 
1668C:  CALL   293A
....................          sd_status = init_sdcard(); 
16690:  CALL   503A
16694:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
16698:  MOVLB  2
1669A:  MOVF   xDC,F
1669C:  BZ    166A6
1669E:  MOVLB  0
166A0:  CALL   5080
166A4:  MOVLB  2
....................  
....................          ++nv_sample; 
166A6:  INCF   21,F
166A8:  BTFSC  FD8.2
166AA:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
166AC:  MOVLW  40
166AE:  BTFSS  F9E.4
166B0:  BRA    166AE
166B2:  MOVWF  FAD
166B4:  MOVLW  53
166B6:  BTFSS  F9E.4
166B8:  BRA    166B6
166BA:  MOVWF  FAD
166BC:  MOVLW  09
166BE:  MOVWF  FE9
166C0:  CLRF   1B
166C2:  BTFSC  FF2.7
166C4:  BSF    1B.7
166C6:  BCF    FF2.7
166C8:  MOVFF  22,A41
166CC:  MOVFF  21,A40
166D0:  MOVLB  0
166D2:  CALL   119E
166D6:  BTFSC  1B.7
166D8:  BSF    FF2.7
166DA:  MOVLW  0D
166DC:  BTFSS  F9E.4
166DE:  BRA    166DC
166E0:  MOVWF  FAD
166E2:  MOVLW  0A
166E4:  BTFSS  F9E.4
166E6:  BRA    166E4
166E8:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
166EA:  MOVLW  01
166EC:  MOVWF  1E
166EE:  MOVLW  A7
166F0:  MOVWF  1D
166F2:  MOVLW  CE
166F4:  MOVWF  FF6
166F6:  MOVLW  22
166F8:  MOVWF  FF7
166FA:  MOVLW  00
166FC:  MOVWF  FF8
166FE:  MOVLW  14
16700:  MOVLB  8
16702:  MOVWF  xEB
16704:  MOVLB  0
16706:  CALL   AACC
1670A:  MOVLW  10
1670C:  MOVWF  FE9
1670E:  MOVFF  22,8F7
16712:  MOVFF  21,8F6
16716:  CALL   AAFE
1671A:  MOVLW  E5
1671C:  MOVWF  FF6
1671E:  MOVLW  22
16720:  MOVWF  FF7
16722:  MOVLW  00
16724:  MOVWF  FF8
16726:  MOVLW  09
16728:  MOVLB  8
1672A:  MOVWF  xEB
1672C:  MOVLB  0
1672E:  CALL   AACC
....................          record_event();   
16732:  CALL   84DA
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16736:  MOVLW  16
16738:  MOVLB  8
1673A:  MOVWF  xEE
1673C:  MOVFF  22,8F0
16740:  MOVFF  21,8EF
16744:  MOVLB  0
16746:  CALL   4FD4
....................  
....................          if (nv_macro_mode==TRUE) 
1674A:  DECFSZ 29,W
1674C:  BRA    16762
1674E:  MOVF   2A,F
16750:  BNZ   16762
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
16752:  MOVFF  22,889
16756:  MOVFF  21,888
1675A:  BRA    1647E
1675C:  MOVFF  01,887
....................          } 
16760:  BRA    167CA
....................          else 
....................          { 
....................             time_stamp(); 
16762:  CALL   541A
....................             play_wms_hard_macro(nv_port); 
16766:  MOVFF  2E,88A
1676A:  MOVFF  2D,889
1676E:  CALL   D800
....................             ++nv_port; 
16772:  INCF   2D,F
16774:  BTFSC  FD8.2
16776:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
16778:  MOVF   2E,F
1677A:  BNZ   16782
1677C:  MOVF   2D,W
1677E:  SUBLW  01
16780:  BC    16794
16782:  MOVF   2E,F
16784:  BNZ   16794
16786:  MOVF   2D,W
16788:  SUBLW  30
1678A:  BNC   16794
1678C:  DECFSZ 2F,W
1678E:  BRA    16794
16790:  MOVF   30,F
16792:  BZ    167B2
16794:  MOVF   2E,F
16796:  BNZ   1679E
16798:  MOVF   2D,W
1679A:  SUBLW  01
1679C:  BC    167C8
1679E:  MOVF   2E,F
167A0:  BNZ   167C8
167A2:  MOVF   2D,W
167A4:  SUBLW  32
167A6:  BNC   167C8
167A8:  MOVF   2F,W
167AA:  SUBLW  03
167AC:  BNZ   167C8
167AE:  MOVF   30,F
167B0:  BNZ   167C8
....................             { 
....................                write16(ADDR_PORT, nv_port);             
167B2:  MOVLW  24
167B4:  MOVLB  8
167B6:  MOVWF  xEE
167B8:  MOVFF  2E,8F0
167BC:  MOVFF  2D,8EF
167C0:  MOVLB  0
167C2:  CALL   4FD4
....................             } 
167C6:  BRA    167CA
....................             else disable_interrupts (INT_EXT); 
167C8:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
167CA:  DECFSZ 50,W
167CC:  BRA    167F0
....................          { 
....................             disable_interrupts (INT_EXT); 
167CE:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
167D0:  CLRF   32
167D2:  MOVLW  01
167D4:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
167D6:  MOVLW  02
167D8:  MOVLB  8
167DA:  MOVWF  x89
167DC:  MOVFF  31,88A
167E0:  MOVLB  0
167E2:  CALL   3412
....................             busy_clear(); 
167E6:  CALL   AEB0
....................             return (user_quit); 
167EA:  MOVFF  50,01
167EE:  BRA    1685A
....................          } 
....................           
....................          motor_sleep_rdy(); 
167F0:  CALL   2998
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
167F4:  MOVLW  01
167F6:  MOVWF  1E
167F8:  MOVLW  A7
167FA:  MOVWF  1D
167FC:  MOVLW  F0
167FE:  MOVWF  FF6
16800:  MOVLW  22
16802:  MOVWF  FF7
16804:  MOVLW  00
16806:  MOVWF  FF8
16808:  MOVLW  14
1680A:  MOVLB  8
1680C:  MOVWF  xEB
1680E:  MOVLB  0
16810:  CALL   AACC
16814:  MOVLW  10
16816:  MOVWF  FE9
16818:  MOVFF  22,8F7
1681C:  MOVFF  21,8F6
16820:  CALL   AAFE
16824:  MOVLW  07
16826:  MOVWF  FF6
16828:  MOVLW  23
1682A:  MOVWF  FF7
1682C:  MOVLW  00
1682E:  MOVWF  FF8
16830:  MOVLW  0C
16832:  MOVLB  8
16834:  MOVWF  xEB
16836:  MOVLB  0
16838:  CALL   AACC
....................          record_event();  
1683C:  CALL   84DA
....................           
....................          if (macro_end == ';') 
16840:  MOVLB  8
16842:  MOVF   x87,W
16844:  SUBLW  3B
16846:  BNZ   1684A
....................          { 
....................             disable_interrupts (INT_EXT); 
16848:  BCF    FF2.4
1684A:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
1684C:  CALL   15EE2
16850:  BRA    16676
....................    } 
....................    busy_clear(); 
16852:  CALL   AEB0
....................    return (user_quit); 
16856:  MOVFF  50,01
1685A:  GOTO   16DA6 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
169E2:  MOVF   24,W
169E4:  SUBWF  36,W
169E6:  BTFSS  FD8.0
169E8:  BRA    16BA2
169EA:  BNZ   169F4
169EC:  MOVF   23,W
169EE:  SUBWF  35,W
169F0:  BTFSS  FD8.0
169F2:  BRA    16BA2
....................       { 
....................          nv_elapsed = 0; 
169F4:  CLRF   36
169F6:  CLRF   35
....................  
....................          init_hardware(); 
169F8:  CALL   293A
....................          sd_status = init_sdcard(); 
169FC:  CALL   503A
16A00:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
16A04:  MOVLB  2
16A06:  MOVF   xDC,F
16A08:  BZ    16A12
16A0A:  MOVLB  0
16A0C:  CALL   5080
16A10:  MOVLB  2
....................  
....................          ++nv_sample; 
16A12:  INCF   21,F
16A14:  BTFSC  FD8.2
16A16:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
16A18:  MOVLW  40
16A1A:  BTFSS  F9E.4
16A1C:  BRA    16A1A
16A1E:  MOVWF  FAD
16A20:  MOVLW  53
16A22:  BTFSS  F9E.4
16A24:  BRA    16A22
16A26:  MOVWF  FAD
16A28:  MOVLW  09
16A2A:  MOVWF  FE9
16A2C:  CLRF   1B
16A2E:  BTFSC  FF2.7
16A30:  BSF    1B.7
16A32:  BCF    FF2.7
16A34:  MOVFF  22,A41
16A38:  MOVFF  21,A40
16A3C:  MOVLB  0
16A3E:  CALL   119E
16A42:  BTFSC  1B.7
16A44:  BSF    FF2.7
16A46:  MOVLW  0D
16A48:  BTFSS  F9E.4
16A4A:  BRA    16A48
16A4C:  MOVWF  FAD
16A4E:  MOVLW  0A
16A50:  BTFSS  F9E.4
16A52:  BRA    16A50
16A54:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16A56:  MOVLW  01
16A58:  MOVWF  1E
16A5A:  MOVLW  A7
16A5C:  MOVWF  1D
16A5E:  MOVLW  14
16A60:  MOVWF  FF6
16A62:  MOVLW  23
16A64:  MOVWF  FF7
16A66:  MOVLW  00
16A68:  MOVWF  FF8
16A6A:  MOVLW  14
16A6C:  MOVLB  8
16A6E:  MOVWF  xEB
16A70:  MOVLB  0
16A72:  CALL   AACC
16A76:  MOVLW  10
16A78:  MOVWF  FE9
16A7A:  MOVFF  22,8F7
16A7E:  MOVFF  21,8F6
16A82:  CALL   AAFE
16A86:  MOVLW  2B
16A88:  MOVWF  FF6
16A8A:  MOVLW  23
16A8C:  MOVWF  FF7
16A8E:  MOVLW  00
16A90:  MOVWF  FF8
16A92:  MOVLW  09
16A94:  MOVLB  8
16A96:  MOVWF  xEB
16A98:  MOVLB  0
16A9A:  CALL   AACC
....................          record_event();   
16A9E:  CALL   84DA
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16AA2:  MOVLW  16
16AA4:  MOVLB  8
16AA6:  MOVWF  xEE
16AA8:  MOVFF  22,8F0
16AAC:  MOVFF  21,8EF
16AB0:  MOVLB  0
16AB2:  CALL   4FD4
....................  
....................          macro_end = master_macro_aws(nv_sample); 
16AB6:  MOVFF  22,88D
16ABA:  MOVFF  21,88C
16ABE:  RCALL  1685E
16AC0:  MOVFF  01,887
....................           
....................          if (user_quit == TRUE) 
16AC4:  DECFSZ 50,W
16AC6:  BRA    16AEA
....................          { 
....................             disable_interrupts (INT_EXT); 
16AC8:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
16ACA:  CLRF   32
16ACC:  MOVLW  01
16ACE:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16AD0:  MOVLW  02
16AD2:  MOVLB  8
16AD4:  MOVWF  x89
16AD6:  MOVFF  31,88A
16ADA:  MOVLB  0
16ADC:  CALL   3412
....................             busy_clear(); 
16AE0:  CALL   AEB0
....................             return (user_quit); 
16AE4:  MOVFF  50,01
16AE8:  BRA    16BB4
....................          } 
....................           
....................          motor_sleep_rdy(); 
16AEA:  CALL   2998
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16AEE:  MOVLW  01
16AF0:  MOVWF  1E
16AF2:  MOVLW  A7
16AF4:  MOVWF  1D
16AF6:  MOVLW  36
16AF8:  MOVWF  FF6
16AFA:  MOVLW  23
16AFC:  MOVWF  FF7
16AFE:  MOVLW  00
16B00:  MOVWF  FF8
16B02:  MOVLW  14
16B04:  MOVLB  8
16B06:  MOVWF  xEB
16B08:  MOVLB  0
16B0A:  CALL   AACC
16B0E:  MOVLW  10
16B10:  MOVWF  FE9
16B12:  MOVFF  22,8F7
16B16:  MOVFF  21,8F6
16B1A:  CALL   AAFE
16B1E:  MOVLW  4D
16B20:  MOVWF  FF6
16B22:  MOVLW  23
16B24:  MOVWF  FF7
16B26:  MOVLW  00
16B28:  MOVWF  FF8
16B2A:  MOVLW  0C
16B2C:  MOVLB  8
16B2E:  MOVWF  xEB
16B30:  MOVLB  0
16B32:  CALL   AACC
....................          record_event();  
16B36:  CALL   84DA
....................           
....................          if (macro_end == ';') 
16B3A:  MOVLB  8
16B3C:  MOVF   x87,W
16B3E:  SUBLW  3B
16B40:  BNZ   16B44
....................          { 
....................             disable_interrupts (INT_EXT); 
16B42:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16B44:  MOVF   28,W
16B46:  SUBWF  22,W
16B48:  BNC   16BA4
16B4A:  BNZ   16B52
16B4C:  MOVF   27,W
16B4E:  SUBWF  21,W
16B50:  BNC   16BA4
....................          { 
....................             disable_interrupts (INT_EXT); 
16B52:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16B54:  MOVLW  01
16B56:  MOVWF  1E
16B58:  MOVLW  A7
16B5A:  MOVWF  1D
16B5C:  MOVLW  5A
16B5E:  MOVWF  FF6
16B60:  MOVLW  23
16B62:  MOVWF  FF7
16B64:  MOVLW  00
16B66:  MOVWF  FF8
16B68:  MOVLW  14
16B6A:  MOVWF  xEB
16B6C:  MOVLB  0
16B6E:  CALL   AACC
16B72:  MOVLW  10
16B74:  MOVWF  FE9
16B76:  MOVFF  22,8F7
16B7A:  MOVFF  21,8F6
16B7E:  CALL   AAFE
16B82:  MOVLW  71
16B84:  MOVWF  FF6
16B86:  MOVLW  23
16B88:  MOVWF  FF7
16B8A:  MOVLW  00
16B8C:  MOVWF  FF8
16B8E:  MOVLW  0F
16B90:  MOVLB  8
16B92:  MOVWF  xEB
16B94:  MOVLB  0
16B96:  CALL   AACC
....................             record_event();   
16B9A:  CALL   84DA
....................             msg_max(); 
16B9E:  CALL   1623E
16BA2:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
16BA4:  MOVLB  0
16BA6:  CALL   15EE2
16BAA:  BRA    169E2
....................    } 
....................    busy_clear(); 
16BAC:  CALL   AEB0
....................    return (user_quit); 
16BB0:  MOVFF  50,01
16BB4:  GOTO   16DAE (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
16BB8:  CALL   29C0
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
16BBC:  MOVLW  01
16BBE:  MOVWF  1E
16BC0:  MOVLW  A7
16BC2:  MOVWF  1D
16BC4:  MOVLW  82
16BC6:  MOVWF  FF6
16BC8:  MOVLW  23
16BCA:  MOVWF  FF7
16BCC:  MOVLW  00
16BCE:  MOVWF  FF8
16BD0:  CALL   50BE
....................    record_event(); 
16BD4:  CALL   84DA
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
16BD8:  MOVLW  01
16BDA:  MOVWF  1E
16BDC:  MOVLW  A7
16BDE:  MOVWF  1D
16BE0:  MOVLW  9C
16BE2:  MOVWF  FF6
16BE4:  MOVLW  23
16BE6:  MOVWF  FF7
16BE8:  MOVLW  00
16BEA:  MOVWF  FF8
16BEC:  MOVLW  0C
16BEE:  MOVLB  8
16BF0:  MOVWF  xEB
16BF2:  MOVLB  0
16BF4:  CALL   AACC
16BF8:  MOVLW  10
16BFA:  MOVWF  FE9
16BFC:  MOVFF  26,8F7
16C00:  MOVFF  25,8F6
16C04:  CALL   AAFE
16C08:  MOVLW  AB
16C0A:  MOVWF  FF6
16C0C:  MOVLW  23
16C0E:  MOVWF  FF7
16C10:  MOVLW  00
16C12:  MOVWF  FF8
16C14:  MOVLW  06
16C16:  MOVLB  8
16C18:  MOVWF  xEB
16C1A:  MOVLB  0
16C1C:  CALL   AACC
16C20:  MOVLW  10
16C22:  MOVWF  FE9
16C24:  MOVFF  24,8F7
16C28:  MOVFF  23,8F6
16C2C:  CALL   AAFE
16C30:  MOVLW  B4
16C32:  MOVWF  FF6
16C34:  MOVLW  23
16C36:  MOVWF  FF7
16C38:  MOVLW  00
16C3A:  MOVWF  FF8
16C3C:  MOVLW  06
16C3E:  MOVLB  8
16C40:  MOVWF  xEB
16C42:  MOVLB  0
16C44:  CALL   AACC
16C48:  MOVLW  10
16C4A:  MOVWF  FE9
16C4C:  MOVFF  28,8F7
16C50:  MOVFF  27,8F6
16C54:  CALL   AAFE
16C58:  MOVLW  BD
16C5A:  MOVWF  FF6
16C5C:  MOVLW  23
16C5E:  MOVWF  FF7
16C60:  MOVLW  00
16C62:  MOVWF  FF8
16C64:  MOVLW  03
16C66:  MOVLB  8
16C68:  MOVWF  xEB
16C6A:  MOVLB  0
16C6C:  CALL   AACC
....................    record_event(); 
16C70:  CALL   84DA
....................     
....................    user_quit = FALSE; 
16C74:  CLRF   50
....................     
....................    nv_cmd_mode = FALSE; 
16C76:  CLRF   32
16C78:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
16C7A:  MOVLW  02
16C7C:  MOVLB  8
16C7E:  MOVWF  x89
16C80:  MOVFF  31,88A
16C84:  MOVLB  0
16C86:  CALL   3412
....................  
....................    RTC_set_AFE(); 
16C8A:  GOTO   15728
....................    // check if start is earlier than now 
....................    RTC_late(); 
16C8E:  CALL   15780
....................    // show clock 
....................    RTC_display(); 
16C92:  CALL   E28A
....................    // show alarm 
....................    RTC_display_alarm(); 
16C96:  CALL   E4EA
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
16C9A:  CALL   15C46
....................  
....................    if (alarm_passed == FALSE){ 
16C9E:  BTFSC  4D.3
16CA0:  BRA    16CA2
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
16CA2:  MOVLW  00
16CA4:  BTFSC  4D.3
16CA6:  MOVLW  01
16CA8:  MOVLB  8
16CAA:  MOVWF  x87
16CAC:  MOVLW  01
16CAE:  MOVWF  1E
16CB0:  MOVLW  A7
16CB2:  MOVWF  1D
16CB4:  MOVLW  C2
16CB6:  MOVWF  FF6
16CB8:  MOVLW  23
16CBA:  MOVWF  FF7
16CBC:  MOVLW  00
16CBE:  MOVWF  FF8
16CC0:  MOVLW  14
16CC2:  MOVWF  xEB
16CC4:  MOVLB  0
16CC6:  CALL   AACC
16CCA:  MOVLW  10
16CCC:  MOVWF  FE9
16CCE:  MOVFF  22,8F7
16CD2:  MOVFF  21,8F6
16CD6:  CALL   AAFE
16CDA:  MOVLW  D9
16CDC:  MOVWF  FF6
16CDE:  MOVLW  23
16CE0:  MOVWF  FF7
16CE2:  MOVLW  00
16CE4:  MOVWF  FF8
16CE6:  MOVLW  08
16CE8:  MOVLB  8
16CEA:  MOVWF  xEB
16CEC:  MOVLB  0
16CEE:  CALL   AACC
16CF2:  MOVFF  887,8ED
16CF6:  MOVLW  1B
16CF8:  MOVLB  8
16CFA:  MOVWF  xEE
16CFC:  MOVLB  0
16CFE:  CALL   5280
16D02:  MOVLW  E3
16D04:  MOVWF  FF6
16D06:  MOVLW  23
16D08:  MOVWF  FF7
16D0A:  MOVLW  00
16D0C:  MOVWF  FF8
16D0E:  MOVLW  03
16D10:  MOVLB  8
16D12:  MOVWF  xEB
16D14:  MOVLB  0
16D16:  CALL   AACC
....................    record_event();  
16D1A:  CALL   84DA
....................  
....................    while (TRUE == RTC_read_flags_running) 
16D1E:  BTFSS  4D.2
16D20:  BRA    16D24
....................    { 
....................       ; 
16D22:  BRA    16D1E
....................    } 
....................    RTC_read_flags_running = TRUE; 
16D24:  BSF    4D.2
16D26:  CLRF   1B
16D28:  BTFSC  FF2.7
16D2A:  BSF    1B.7
16D2C:  BCF    FF2.7
....................    RTC_read_flags(); 
16D2E:  CALL   0DD0
16D32:  BTFSC  1B.7
16D34:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
16D36:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
16D38:  CALL   2998
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
16D3C:  BTFSC  4D.3
16D3E:  BRA    16D60
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16D40:  MOVLW  01
16D42:  MOVWF  1E
16D44:  MOVLW  A7
16D46:  MOVWF  1D
16D48:  MOVLW  E8
16D4A:  MOVWF  FF6
16D4C:  MOVLW  23
16D4E:  MOVWF  FF7
16D50:  MOVLW  00
16D52:  MOVWF  FF8
16D54:  CALL   50BE
....................       record_event(); 
16D58:  CALL   84DA
....................       go_to_sleep(); 
16D5C:  CALL   15EE2
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16D60:  GOTO   15EF8
....................    nv_elapsed = nv_interval; 
16D64:  MOVFF  24,36
16D68:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
16D6C:  MOVFF  2F,00
16D70:  MOVF   30,W
16D72:  MOVWF  03
16D74:  BNZ   16D7A
16D76:  MOVF   00,F
16D78:  BZ    16D9A
16D7A:  MOVF   03,W
16D7C:  BNZ   16D84
16D7E:  MOVLW  01
16D80:  SUBWF  00,W
16D82:  BZ    16DA4
16D84:  MOVF   03,W
16D86:  BNZ   16D8E
16D88:  MOVLW  03
16D8A:  SUBWF  00,W
16D8C:  BZ    16DA4
16D8E:  MOVF   03,W
16D90:  BNZ   16D98
16D92:  MOVLW  02
16D94:  SUBWF  00,W
16D96:  BZ    16DAC
16D98:  BRA    16DB2
....................       case ECO: user_quit = auto_sample_eco(); 
16D9A:  GOTO   1625C
16D9E:  MOVFF  01,50
....................          break; 
16DA2:  BRA    16DB2
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
16DA4:  BRA    16676
16DA6:  MOVFF  01,50
....................          break; 
16DAA:  BRA    16DB2
....................       case AWS: user_quit = auto_sample_aws(); 
16DAC:  BRA    169E2
16DAE:  MOVFF  01,50
....................          break;          
....................    } 
....................    return(user_quit); 
16DB2:  MOVFF  50,01
16DB6:  GOTO   16EC8 (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BF90:  MOVF   48,F
0BF92:  BNZ   BFA0
0BF94:  MOVF   49,F
0BF96:  BNZ   BFA0
0BF98:  MOVF   4A,F
0BF9A:  BNZ   BFA0
0BF9C:  MOVF   4B,F
0BF9E:  BZ    BFB8
0BFA0:  MOVF   4B,F
0BFA2:  BNZ   BFB8
0BFA4:  MOVF   4A,F
0BFA6:  BNZ   BFB8
0BFA8:  MOVF   49,F
0BFAA:  BNZ   BFB8
0BFAC:  MOVF   48,W
0BFAE:  SUBLW  02
0BFB0:  BNC   BFB8
....................       detector = arg; 
0BFB2:  MOVFF  48,2D5
....................    } 
0BFB6:  BRA    BFBC
....................    else cmd_arg(); 
0BFB8:  CALL   B2FE
0BFBC:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0BFDE:  MOVF   48,F
0BFE0:  BNZ   BFEE
0BFE2:  MOVF   49,F
0BFE4:  BNZ   BFEE
0BFE6:  MOVF   4A,F
0BFE8:  BNZ   BFEE
0BFEA:  MOVF   4B,F
0BFEC:  BZ    C048
0BFEE:  MOVF   4B,F
0BFF0:  BNZ   C048
0BFF2:  MOVF   4A,W
0BFF4:  SUBLW  00
0BFF6:  BNC   C048
....................       switch (detector){ 
0BFF8:  MOVLB  2
0BFFA:  MOVF   xD5,W
0BFFC:  XORLW  01
0BFFE:  MOVLB  0
0C000:  BZ    C008
0C002:  XORLW  03
0C004:  BZ    C026
0C006:  BRA    C044
....................          case 1 : nv_d1_temp = arg; 
0C008:  MOVFF  49,42
0C00C:  MOVFF  48,41
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0C010:  MOVLW  40
0C012:  MOVLB  8
0C014:  MOVWF  xEE
0C016:  MOVFF  42,8F0
0C01A:  MOVFF  41,8EF
0C01E:  MOVLB  0
0C020:  CALL   4FD4
....................             break; 
0C024:  BRA    C046
....................          case 2 : nv_d2_temp = arg; 
0C026:  MOVFF  49,44
0C02A:  MOVFF  48,43
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0C02E:  MOVLW  42
0C030:  MOVLB  8
0C032:  MOVWF  xEE
0C034:  MOVFF  44,8F0
0C038:  MOVFF  43,8EF
0C03C:  MOVLB  0
0C03E:  CALL   4FD4
....................             break; 
0C042:  BRA    C046
....................          default : cmd_err(); 
0C044:  RCALL  BFC0
....................             break; 
....................       } 
....................    } 
0C046:  BRA    C0EE
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0C048:  MOVF   48,F
0C04A:  BNZ   C0EA
0C04C:  MOVF   49,F
0C04E:  BNZ   C0EA
0C050:  MOVF   4A,F
0C052:  BNZ   C0EA
0C054:  MOVF   4B,F
0C056:  BNZ   C0EA
0C058:  MOVLW  FE
0C05A:  MOVWF  FF6
0C05C:  MOVLW  23
0C05E:  MOVWF  FF7
0C060:  MOVLW  00
0C062:  MOVWF  FF8
0C064:  CLRF   1B
0C066:  BTFSC  FF2.7
0C068:  BSF    1B.7
0C06A:  BCF    FF2.7
0C06C:  MOVLW  03
0C06E:  MOVLB  A
0C070:  MOVWF  x40
0C072:  MOVLB  0
0C074:  CALL   101C
0C078:  BTFSC  1B.7
0C07A:  BSF    FF2.7
0C07C:  MOVLW  10
0C07E:  MOVWF  FE9
0C080:  CLRF   1B
0C082:  BTFSC  FF2.7
0C084:  BSF    1B.7
0C086:  BCF    FF2.7
0C088:  MOVFF  42,A41
0C08C:  MOVFF  41,A40
0C090:  CALL   119E
0C094:  BTFSC  1B.7
0C096:  BSF    FF2.7
0C098:  MOVLW  04
0C09A:  MOVWF  FF6
0C09C:  MOVLW  24
0C09E:  MOVWF  FF7
0C0A0:  MOVLW  00
0C0A2:  MOVWF  FF8
0C0A4:  CLRF   1B
0C0A6:  BTFSC  FF2.7
0C0A8:  BSF    1B.7
0C0AA:  BCF    FF2.7
0C0AC:  MOVLW  04
0C0AE:  MOVLB  A
0C0B0:  MOVWF  x40
0C0B2:  MOVLB  0
0C0B4:  CALL   101C
0C0B8:  BTFSC  1B.7
0C0BA:  BSF    FF2.7
0C0BC:  MOVLW  10
0C0BE:  MOVWF  FE9
0C0C0:  CLRF   1B
0C0C2:  BTFSC  FF2.7
0C0C4:  BSF    1B.7
0C0C6:  BCF    FF2.7
0C0C8:  MOVFF  44,A41
0C0CC:  MOVFF  43,A40
0C0D0:  CALL   119E
0C0D4:  BTFSC  1B.7
0C0D6:  BSF    FF2.7
0C0D8:  MOVLW  0D
0C0DA:  BTFSS  F9E.4
0C0DC:  BRA    C0DA
0C0DE:  MOVWF  FAD
0C0E0:  MOVLW  0A
0C0E2:  BTFSS  F9E.4
0C0E4:  BRA    C0E2
0C0E6:  MOVWF  FAD
0C0E8:  BRA    C0EE
....................    else cmd_arg(); 
0C0EA:  CALL   B2FE
0C0EE:  GOTO   C154 (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0C0F2:  MOVF   4B,F
0C0F4:  BNZ   C122
0C0F6:  MOVF   4A,F
0C0F8:  BNZ   C122
0C0FA:  MOVF   49,F
0C0FC:  BNZ   C122
0C0FE:  MOVF   48,W
0C100:  SUBLW  01
0C102:  BNC   C122
....................       nv_macro_mode = arg; 
0C104:  MOVFF  49,2A
0C108:  MOVFF  48,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0C10C:  MOVLW  20
0C10E:  MOVLB  8
0C110:  MOVWF  xEE
0C112:  MOVFF  2A,8F0
0C116:  MOVFF  29,8EF
0C11A:  MOVLB  0
0C11C:  CALL   4FD4
....................    } 
0C120:  BRA    C126
....................    else cmd_arg(); 
0C122:  CALL   B2FE
0C126:  GOTO   C154 (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0C12A:  MOVF   2F,W
0C12C:  MOVWF  00
0C12E:  MOVF   30,W
0C130:  MOVWF  03
0C132:  BNZ   C138
0C134:  MOVF   00,F
0C136:  BZ    C14E
0C138:  MOVF   03,W
0C13A:  BNZ   C142
0C13C:  MOVLW  01
0C13E:  SUBWF  00,W
0C140:  BZ    C152
0C142:  MOVF   03,W
0C144:  BNZ   C14C
0C146:  MOVLW  03
0C148:  SUBWF  00,W
0C14A:  BZ    C152
0C14C:  BRA    C154
....................       case ECO : commandAe(); 
0C14E:  BRA    BFDE
....................          break; 
0C150:  BRA    C154
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0C152:  BRA    C0F2
....................          break; 
....................    } 
0C154:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0C158:  MOVF   48,F
0C15A:  BNZ   C168
0C15C:  MOVF   49,F
0C15E:  BNZ   C168
0C160:  MOVF   4A,F
0C162:  BNZ   C168
0C164:  MOVF   4B,F
0C166:  BZ    C198
0C168:  MOVF   4B,F
0C16A:  BNZ   C198
0C16C:  MOVF   4A,F
0C16E:  BNZ   C198
0C170:  MOVF   49,F
0C172:  BNZ   C198
0C174:  MOVF   48,W
0C176:  SUBLW  03
0C178:  BNC   C198
....................       nv_det_type = arg; 
0C17A:  MOVFF  49,46
0C17E:  MOVFF  48,45
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0C182:  MOVLW  26
0C184:  MOVLB  8
0C186:  MOVWF  xEE
0C188:  MOVFF  46,8F0
0C18C:  MOVFF  45,8EF
0C190:  MOVLB  0
0C192:  CALL   4FD4
....................    } 
0C196:  BRA    C1FE
....................    else if(arg==0) { 
0C198:  MOVF   48,F
0C19A:  BNZ   C1FA
0C19C:  MOVF   49,F
0C19E:  BNZ   C1FA
0C1A0:  MOVF   4A,F
0C1A2:  BNZ   C1FA
0C1A4:  MOVF   4B,F
0C1A6:  BNZ   C1FA
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0C1A8:  MOVLW  0E
0C1AA:  MOVWF  FF6
0C1AC:  MOVLW  24
0C1AE:  MOVWF  FF7
0C1B0:  MOVLW  00
0C1B2:  MOVWF  FF8
0C1B4:  CLRF   1B
0C1B6:  BTFSC  FF2.7
0C1B8:  BSF    1B.7
0C1BA:  BCF    FF2.7
0C1BC:  MOVLW  05
0C1BE:  MOVLB  A
0C1C0:  MOVWF  x40
0C1C2:  MOVLB  0
0C1C4:  CALL   101C
0C1C8:  BTFSC  1B.7
0C1CA:  BSF    FF2.7
0C1CC:  MOVLW  10
0C1CE:  MOVWF  FE9
0C1D0:  CLRF   1B
0C1D2:  BTFSC  FF2.7
0C1D4:  BSF    1B.7
0C1D6:  BCF    FF2.7
0C1D8:  MOVFF  46,A41
0C1DC:  MOVFF  45,A40
0C1E0:  CALL   119E
0C1E4:  BTFSC  1B.7
0C1E6:  BSF    FF2.7
0C1E8:  MOVLW  0D
0C1EA:  BTFSS  F9E.4
0C1EC:  BRA    C1EA
0C1EE:  MOVWF  FAD
0C1F0:  MOVLW  0A
0C1F2:  BTFSS  F9E.4
0C1F4:  BRA    C1F2
0C1F6:  MOVWF  FAD
....................    } 
0C1F8:  BRA    C1FE
....................    else cmd_arg(); 
0C1FA:  CALL   B2FE
0C1FE:  GOTO   C2C0 (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0C270:  MOVF   4B,F
0C272:  BNZ   C28E
0C274:  MOVF   4A,F
0C276:  BNZ   C28E
0C278:  MOVF   49,F
0C27A:  BNZ   C28E
0C27C:  MOVF   48,W
0C27E:  SUBLW  03
0C280:  BNC   C28E
....................       hb_cmd=arg; 
0C282:  MOVFF  48,885
....................       h_bridge(hb_cmd); 
0C286:  MOVFF  885,8B5
0C28A:  RCALL  C250
....................    } 
0C28C:  BRA    C292
....................    else cmd_arg(); 
0C28E:  CALL   B2FE
0C292:  GOTO   C2C0 (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0C296:  MOVF   2F,W
0C298:  MOVWF  00
0C29A:  MOVF   30,W
0C29C:  MOVWF  03
0C29E:  BNZ   C2A4
0C2A0:  MOVF   00,F
0C2A2:  BZ    C2BA
0C2A4:  MOVF   03,W
0C2A6:  BNZ   C2AE
0C2A8:  MOVLW  01
0C2AA:  SUBWF  00,W
0C2AC:  BZ    C2BE
0C2AE:  MOVF   03,W
0C2B0:  BNZ   C2B8
0C2B2:  MOVLW  03
0C2B4:  SUBWF  00,W
0C2B6:  BZ    C2BE
0C2B8:  BRA    C2C0
....................       case ECO : commandBe(); 
0C2BA:  BRA    C158
....................          break; 
0C2BC:  BRA    C2C0
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0C2BE:  BRA    C270
....................          break; 
....................    } 
0C2C0:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CDBA:  MOVF   48,W
0CDBC:  MOVWF  00
0CDBE:  MOVF   49,W
0CDC0:  MOVWF  03
0CDC2:  BNZ   CDC8
0CDC4:  MOVF   00,F
0CDC6:  BZ    CE2A
0CDC8:  MOVF   03,W
0CDCA:  BNZ   CDD4
0CDCC:  MOVLW  01
0CDCE:  SUBWF  00,W
0CDD0:  BTFSC  FD8.2
0CDD2:  BRA    D01A
0CDD4:  MOVF   03,W
0CDD6:  BNZ   CDE0
0CDD8:  MOVLW  02
0CDDA:  SUBWF  00,W
0CDDC:  BTFSC  FD8.2
0CDDE:  BRA    D076
0CDE0:  MOVF   03,W
0CDE2:  BNZ   CDEC
0CDE4:  MOVLW  03
0CDE6:  SUBWF  00,W
0CDE8:  BTFSC  FD8.2
0CDEA:  BRA    D0D2
0CDEC:  MOVF   03,W
0CDEE:  BNZ   CDF8
0CDF0:  MOVLW  04
0CDF2:  SUBWF  00,W
0CDF4:  BTFSC  FD8.2
0CDF6:  BRA    D12E
0CDF8:  MOVF   03,W
0CDFA:  BNZ   CE04
0CDFC:  MOVLW  05
0CDFE:  SUBWF  00,W
0CE00:  BTFSC  FD8.2
0CE02:  BRA    D18A
0CE04:  MOVF   03,W
0CE06:  BNZ   CE10
0CE08:  MOVLW  06
0CE0A:  SUBWF  00,W
0CE0C:  BTFSC  FD8.2
0CE0E:  BRA    D1E6
0CE10:  MOVF   03,W
0CE12:  BNZ   CE1C
0CE14:  MOVLW  07
0CE16:  SUBWF  00,W
0CE18:  BTFSC  FD8.2
0CE1A:  BRA    D242
0CE1C:  MOVF   03,W
0CE1E:  BNZ   CE28
0CE20:  MOVLW  08
0CE22:  SUBWF  00,W
0CE24:  BTFSC  FD8.2
0CE26:  BRA    D29E
0CE28:  BRA    D2FA
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CE2A:  MOVLW  1A
0CE2C:  MOVWF  FF6
0CE2E:  MOVLW  24
0CE30:  MOVWF  FF7
0CE32:  MOVLW  00
0CE34:  MOVWF  FF8
0CE36:  CLRF   1B
0CE38:  BTFSC  FF2.7
0CE3A:  BSF    1B.7
0CE3C:  BCF    FF2.7
0CE3E:  MOVLW  04
0CE40:  MOVLB  A
0CE42:  MOVWF  x40
0CE44:  MOVLB  0
0CE46:  CALL   101C
0CE4A:  BTFSC  1B.7
0CE4C:  BSF    FF2.7
0CE4E:  MOVLW  89
0CE50:  MOVWF  FE9
0CE52:  MOVFF  3F8,888
0CE56:  MOVFF  3F7,887
0CE5A:  MOVFF  3F6,886
0CE5E:  MOVFF  3F5,885
0CE62:  MOVLW  05
0CE64:  MOVLB  8
0CE66:  MOVWF  x89
0CE68:  MOVLB  0
0CE6A:  RCALL  C674
0CE6C:  MOVLW  2C
0CE6E:  BTFSS  F9E.4
0CE70:  BRA    CE6E
0CE72:  MOVWF  FAD
0CE74:  MOVLW  89
0CE76:  MOVWF  FE9
0CE78:  MOVFF  3FC,888
0CE7C:  MOVFF  3FB,887
0CE80:  MOVFF  3FA,886
0CE84:  MOVFF  3F9,885
0CE88:  MOVLW  05
0CE8A:  MOVLB  8
0CE8C:  MOVWF  x89
0CE8E:  MOVLB  0
0CE90:  CALL   C674
0CE94:  MOVLW  0D
0CE96:  BTFSS  F9E.4
0CE98:  BRA    CE96
0CE9A:  MOVWF  FAD
0CE9C:  MOVLW  0A
0CE9E:  BTFSS  F9E.4
0CEA0:  BRA    CE9E
0CEA2:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CEA4:  MOVLW  2C
0CEA6:  MOVWF  FF6
0CEA8:  MOVLW  24
0CEAA:  MOVWF  FF7
0CEAC:  MOVLW  00
0CEAE:  MOVWF  FF8
0CEB0:  CLRF   1B
0CEB2:  BTFSC  FF2.7
0CEB4:  BSF    1B.7
0CEB6:  BCF    FF2.7
0CEB8:  MOVLW  04
0CEBA:  MOVLB  A
0CEBC:  MOVWF  x40
0CEBE:  MOVLB  0
0CEC0:  CALL   101C
0CEC4:  BTFSC  1B.7
0CEC6:  BSF    FF2.7
0CEC8:  MOVLW  89
0CECA:  MOVWF  FE9
0CECC:  MOVFF  400,888
0CED0:  MOVFF  3FF,887
0CED4:  MOVFF  3FE,886
0CED8:  MOVFF  3FD,885
0CEDC:  MOVLW  05
0CEDE:  MOVLB  8
0CEE0:  MOVWF  x89
0CEE2:  MOVLB  0
0CEE4:  CALL   C674
0CEE8:  MOVLW  2C
0CEEA:  BTFSS  F9E.4
0CEEC:  BRA    CEEA
0CEEE:  MOVWF  FAD
0CEF0:  MOVLW  89
0CEF2:  MOVWF  FE9
0CEF4:  MOVFF  404,888
0CEF8:  MOVFF  403,887
0CEFC:  MOVFF  402,886
0CF00:  MOVFF  401,885
0CF04:  MOVLW  05
0CF06:  MOVLB  8
0CF08:  MOVWF  x89
0CF0A:  MOVLB  0
0CF0C:  CALL   C674
0CF10:  MOVLW  0D
0CF12:  BTFSS  F9E.4
0CF14:  BRA    CF12
0CF16:  MOVWF  FAD
0CF18:  MOVLW  0A
0CF1A:  BTFSS  F9E.4
0CF1C:  BRA    CF1A
0CF1E:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CF20:  MOVLW  3E
0CF22:  MOVWF  FF6
0CF24:  MOVLW  24
0CF26:  MOVWF  FF7
0CF28:  MOVLW  00
0CF2A:  MOVWF  FF8
0CF2C:  CLRF   1B
0CF2E:  BTFSC  FF2.7
0CF30:  BSF    1B.7
0CF32:  BCF    FF2.7
0CF34:  MOVLW  04
0CF36:  MOVLB  A
0CF38:  MOVWF  x40
0CF3A:  MOVLB  0
0CF3C:  CALL   101C
0CF40:  BTFSC  1B.7
0CF42:  BSF    FF2.7
0CF44:  MOVLW  89
0CF46:  MOVWF  FE9
0CF48:  MOVFF  408,888
0CF4C:  MOVFF  407,887
0CF50:  MOVFF  406,886
0CF54:  MOVFF  405,885
0CF58:  MOVLW  05
0CF5A:  MOVLB  8
0CF5C:  MOVWF  x89
0CF5E:  MOVLB  0
0CF60:  CALL   C674
0CF64:  MOVLW  2C
0CF66:  BTFSS  F9E.4
0CF68:  BRA    CF66
0CF6A:  MOVWF  FAD
0CF6C:  MOVLW  89
0CF6E:  MOVWF  FE9
0CF70:  MOVFF  40C,888
0CF74:  MOVFF  40B,887
0CF78:  MOVFF  40A,886
0CF7C:  MOVFF  409,885
0CF80:  MOVLW  05
0CF82:  MOVLB  8
0CF84:  MOVWF  x89
0CF86:  MOVLB  0
0CF88:  CALL   C674
0CF8C:  MOVLW  0D
0CF8E:  BTFSS  F9E.4
0CF90:  BRA    CF8E
0CF92:  MOVWF  FAD
0CF94:  MOVLW  0A
0CF96:  BTFSS  F9E.4
0CF98:  BRA    CF96
0CF9A:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CF9C:  MOVLW  50
0CF9E:  MOVWF  FF6
0CFA0:  MOVLW  24
0CFA2:  MOVWF  FF7
0CFA4:  MOVLW  00
0CFA6:  MOVWF  FF8
0CFA8:  CLRF   1B
0CFAA:  BTFSC  FF2.7
0CFAC:  BSF    1B.7
0CFAE:  BCF    FF2.7
0CFB0:  MOVLW  05
0CFB2:  MOVLB  A
0CFB4:  MOVWF  x40
0CFB6:  MOVLB  0
0CFB8:  CALL   101C
0CFBC:  BTFSC  1B.7
0CFBE:  BSF    FF2.7
0CFC0:  MOVLW  89
0CFC2:  MOVWF  FE9
0CFC4:  MOVFF  410,888
0CFC8:  MOVFF  40F,887
0CFCC:  MOVFF  40E,886
0CFD0:  MOVFF  40D,885
0CFD4:  MOVLW  05
0CFD6:  MOVLB  8
0CFD8:  MOVWF  x89
0CFDA:  MOVLB  0
0CFDC:  CALL   C674
0CFE0:  MOVLW  2C
0CFE2:  BTFSS  F9E.4
0CFE4:  BRA    CFE2
0CFE6:  MOVWF  FAD
0CFE8:  MOVLW  89
0CFEA:  MOVWF  FE9
0CFEC:  MOVFF  414,888
0CFF0:  MOVFF  413,887
0CFF4:  MOVFF  412,886
0CFF8:  MOVFF  411,885
0CFFC:  MOVLW  05
0CFFE:  MOVLB  8
0D000:  MOVWF  x89
0D002:  MOVLB  0
0D004:  CALL   C674
0D008:  MOVLW  0D
0D00A:  BTFSS  F9E.4
0D00C:  BRA    D00A
0D00E:  MOVWF  FAD
0D010:  MOVLW  0A
0D012:  BTFSS  F9E.4
0D014:  BRA    D012
0D016:  MOVWF  FAD
....................                   break; 
0D018:  BRA    D2FE
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0D01A:  MOVLW  64
0D01C:  MOVWF  FF6
0D01E:  MOVLW  24
0D020:  MOVWF  FF7
0D022:  MOVLW  00
0D024:  MOVWF  FF8
0D026:  CLRF   1B
0D028:  BTFSC  FF2.7
0D02A:  BSF    1B.7
0D02C:  BCF    FF2.7
0D02E:  CALL   0E46
0D032:  BTFSC  1B.7
0D034:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0D036:  RCALL  CD06
0D038:  MOVFF  03,3F8
0D03C:  MOVFF  02,3F7
0D040:  MOVFF  01,3F6
0D044:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");   
0D048:  MOVLW  0D
0D04A:  BTFSS  F9E.4
0D04C:  BRA    D04A
0D04E:  MOVWF  FAD
0D050:  MOVLW  0A
0D052:  BTFSS  F9E.4
0D054:  BRA    D052
0D056:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0D058:  MOVLB  8
0D05A:  CLRF   x86
0D05C:  MOVLW  44
0D05E:  MOVWF  x85
0D060:  MOVFF  3F8,88A
0D064:  MOVFF  3F7,889
0D068:  MOVFF  3F6,888
0D06C:  MOVFF  3F5,887
0D070:  MOVLB  0
0D072:  RCALL  CD4C
....................          break; 
0D074:  BRA    D2FE
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0D076:  MOVLW  6C
0D078:  MOVWF  FF6
0D07A:  MOVLW  24
0D07C:  MOVWF  FF7
0D07E:  MOVLW  00
0D080:  MOVWF  FF8
0D082:  CLRF   1B
0D084:  BTFSC  FF2.7
0D086:  BSF    1B.7
0D088:  BCF    FF2.7
0D08A:  CALL   0E46
0D08E:  BTFSC  1B.7
0D090:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0D092:  RCALL  CD06
0D094:  MOVFF  03,3FC
0D098:  MOVFF  02,3FB
0D09C:  MOVFF  01,3FA
0D0A0:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n");  
0D0A4:  MOVLW  0D
0D0A6:  BTFSS  F9E.4
0D0A8:  BRA    D0A6
0D0AA:  MOVWF  FAD
0D0AC:  MOVLW  0A
0D0AE:  BTFSS  F9E.4
0D0B0:  BRA    D0AE
0D0B2:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0D0B4:  MOVLB  8
0D0B6:  CLRF   x86
0D0B8:  MOVLW  48
0D0BA:  MOVWF  x85
0D0BC:  MOVFF  3FC,88A
0D0C0:  MOVFF  3FB,889
0D0C4:  MOVFF  3FA,888
0D0C8:  MOVFF  3F9,887
0D0CC:  MOVLB  0
0D0CE:  RCALL  CD4C
....................          break; 
0D0D0:  BRA    D2FE
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0D0D2:  MOVLW  74
0D0D4:  MOVWF  FF6
0D0D6:  MOVLW  24
0D0D8:  MOVWF  FF7
0D0DA:  MOVLW  00
0D0DC:  MOVWF  FF8
0D0DE:  CLRF   1B
0D0E0:  BTFSC  FF2.7
0D0E2:  BSF    1B.7
0D0E4:  BCF    FF2.7
0D0E6:  CALL   0E46
0D0EA:  BTFSC  1B.7
0D0EC:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0D0EE:  RCALL  CD06
0D0F0:  MOVFF  03,400
0D0F4:  MOVFF  02,3FF
0D0F8:  MOVFF  01,3FE
0D0FC:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n"); 
0D100:  MOVLW  0D
0D102:  BTFSS  F9E.4
0D104:  BRA    D102
0D106:  MOVWF  FAD
0D108:  MOVLW  0A
0D10A:  BTFSS  F9E.4
0D10C:  BRA    D10A
0D10E:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0D110:  MOVLB  8
0D112:  CLRF   x86
0D114:  MOVLW  4C
0D116:  MOVWF  x85
0D118:  MOVFF  400,88A
0D11C:  MOVFF  3FF,889
0D120:  MOVFF  3FE,888
0D124:  MOVFF  3FD,887
0D128:  MOVLB  0
0D12A:  RCALL  CD4C
....................          break; 
0D12C:  BRA    D2FE
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0D12E:  MOVLW  7C
0D130:  MOVWF  FF6
0D132:  MOVLW  24
0D134:  MOVWF  FF7
0D136:  MOVLW  00
0D138:  MOVWF  FF8
0D13A:  CLRF   1B
0D13C:  BTFSC  FF2.7
0D13E:  BSF    1B.7
0D140:  BCF    FF2.7
0D142:  CALL   0E46
0D146:  BTFSC  1B.7
0D148:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0D14A:  RCALL  CD06
0D14C:  MOVFF  03,404
0D150:  MOVFF  02,403
0D154:  MOVFF  01,402
0D158:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");  
0D15C:  MOVLW  0D
0D15E:  BTFSS  F9E.4
0D160:  BRA    D15E
0D162:  MOVWF  FAD
0D164:  MOVLW  0A
0D166:  BTFSS  F9E.4
0D168:  BRA    D166
0D16A:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0D16C:  MOVLB  8
0D16E:  CLRF   x86
0D170:  MOVLW  52
0D172:  MOVWF  x85
0D174:  MOVFF  3FC,88A
0D178:  MOVFF  3FB,889
0D17C:  MOVFF  3FA,888
0D180:  MOVFF  3F9,887
0D184:  MOVLB  0
0D186:  RCALL  CD4C
....................          break; 
0D188:  BRA    D2FE
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0D18A:  MOVLW  84
0D18C:  MOVWF  FF6
0D18E:  MOVLW  24
0D190:  MOVWF  FF7
0D192:  MOVLW  00
0D194:  MOVWF  FF8
0D196:  CLRF   1B
0D198:  BTFSC  FF2.7
0D19A:  BSF    1B.7
0D19C:  BCF    FF2.7
0D19E:  CALL   0E46
0D1A2:  BTFSC  1B.7
0D1A4:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0D1A6:  RCALL  CD06
0D1A8:  MOVFF  03,408
0D1AC:  MOVFF  02,407
0D1B0:  MOVFF  01,406
0D1B4:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");   
0D1B8:  MOVLW  0D
0D1BA:  BTFSS  F9E.4
0D1BC:  BRA    D1BA
0D1BE:  MOVWF  FAD
0D1C0:  MOVLW  0A
0D1C2:  BTFSS  F9E.4
0D1C4:  BRA    D1C2
0D1C6:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0D1C8:  MOVLB  8
0D1CA:  CLRF   x86
0D1CC:  MOVLW  56
0D1CE:  MOVWF  x85
0D1D0:  MOVFF  408,88A
0D1D4:  MOVFF  407,889
0D1D8:  MOVFF  406,888
0D1DC:  MOVFF  405,887
0D1E0:  MOVLB  0
0D1E2:  RCALL  CD4C
....................          break; 
0D1E4:  BRA    D2FE
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0D1E6:  MOVLW  8C
0D1E8:  MOVWF  FF6
0D1EA:  MOVLW  24
0D1EC:  MOVWF  FF7
0D1EE:  MOVLW  00
0D1F0:  MOVWF  FF8
0D1F2:  CLRF   1B
0D1F4:  BTFSC  FF2.7
0D1F6:  BSF    1B.7
0D1F8:  BCF    FF2.7
0D1FA:  CALL   0E46
0D1FE:  BTFSC  1B.7
0D200:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0D202:  RCALL  CD06
0D204:  MOVFF  03,40C
0D208:  MOVFF  02,40B
0D20C:  MOVFF  01,40A
0D210:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");  
0D214:  MOVLW  0D
0D216:  BTFSS  F9E.4
0D218:  BRA    D216
0D21A:  MOVWF  FAD
0D21C:  MOVLW  0A
0D21E:  BTFSS  F9E.4
0D220:  BRA    D21E
0D222:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0D224:  MOVLB  8
0D226:  CLRF   x86
0D228:  MOVLW  5A
0D22A:  MOVWF  x85
0D22C:  MOVFF  40C,88A
0D230:  MOVFF  40B,889
0D234:  MOVFF  40A,888
0D238:  MOVFF  409,887
0D23C:  MOVLB  0
0D23E:  RCALL  CD4C
....................          break; 
0D240:  BRA    D2FE
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0D242:  MOVLW  94
0D244:  MOVWF  FF6
0D246:  MOVLW  24
0D248:  MOVWF  FF7
0D24A:  MOVLW  00
0D24C:  MOVWF  FF8
0D24E:  CLRF   1B
0D250:  BTFSC  FF2.7
0D252:  BSF    1B.7
0D254:  BCF    FF2.7
0D256:  CALL   0E46
0D25A:  BTFSC  1B.7
0D25C:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0D25E:  RCALL  CD06
0D260:  MOVFF  03,410
0D264:  MOVFF  02,40F
0D268:  MOVFF  01,40E
0D26C:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");   
0D270:  MOVLW  0D
0D272:  BTFSS  F9E.4
0D274:  BRA    D272
0D276:  MOVWF  FAD
0D278:  MOVLW  0A
0D27A:  BTFSS  F9E.4
0D27C:  BRA    D27A
0D27E:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0D280:  MOVLB  8
0D282:  CLRF   x86
0D284:  MOVLW  5E
0D286:  MOVWF  x85
0D288:  MOVFF  410,88A
0D28C:  MOVFF  40F,889
0D290:  MOVFF  40E,888
0D294:  MOVFF  40D,887
0D298:  MOVLB  0
0D29A:  RCALL  CD4C
....................          break; 
0D29C:  BRA    D2FE
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0D29E:  MOVLW  9E
0D2A0:  MOVWF  FF6
0D2A2:  MOVLW  24
0D2A4:  MOVWF  FF7
0D2A6:  MOVLW  00
0D2A8:  MOVWF  FF8
0D2AA:  CLRF   1B
0D2AC:  BTFSC  FF2.7
0D2AE:  BSF    1B.7
0D2B0:  BCF    FF2.7
0D2B2:  CALL   0E46
0D2B6:  BTFSC  1B.7
0D2B8:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0D2BA:  RCALL  CD06
0D2BC:  MOVFF  03,414
0D2C0:  MOVFF  02,413
0D2C4:  MOVFF  01,412
0D2C8:  MOVFF  00,411
....................                fprintf(COM_A,"\r\n");  
0D2CC:  MOVLW  0D
0D2CE:  BTFSS  F9E.4
0D2D0:  BRA    D2CE
0D2D2:  MOVWF  FAD
0D2D4:  MOVLW  0A
0D2D6:  BTFSS  F9E.4
0D2D8:  BRA    D2D6
0D2DA:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0D2DC:  MOVLB  8
0D2DE:  CLRF   x86
0D2E0:  MOVLW  62
0D2E2:  MOVWF  x85
0D2E4:  MOVFF  414,88A
0D2E8:  MOVFF  413,889
0D2EC:  MOVFF  412,888
0D2F0:  MOVFF  411,887
0D2F4:  MOVLB  0
0D2F6:  RCALL  CD4C
....................          break;         
0D2F8:  BRA    D2FE
....................       default: cmd_arg(); 
0D2FA:  CALL   B2FE
....................          break; 
....................    } 
0D2FE:  GOTO   DCF4 (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0DA0E:  MOVF   4B,F
0DA10:  BNZ   DA20
0DA12:  MOVF   4A,F
0DA14:  BNZ   DA20
0DA16:  MOVF   49,F
0DA18:  BNZ   DA20
0DA1A:  MOVF   48,W
0DA1C:  SUBLW  01
0DA1E:  BC    DA70
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0DA20:  MOVF   4B,F
0DA22:  BNZ   DA3A
0DA24:  MOVF   4A,F
0DA26:  BNZ   DA3A
0DA28:  MOVF   49,F
0DA2A:  BNZ   DA3A
0DA2C:  MOVF   48,W
0DA2E:  SUBLW  30
0DA30:  BNC   DA3A
0DA32:  DECFSZ 2F,W
0DA34:  BRA    DA3A
0DA36:  MOVF   30,F
0DA38:  BZ    DA56
0DA3A:  MOVF   4B,F
0DA3C:  BNZ   DA6A
0DA3E:  MOVF   4A,F
0DA40:  BNZ   DA6A
0DA42:  MOVF   49,F
0DA44:  BNZ   DA6A
0DA46:  MOVF   48,W
0DA48:  SUBLW  32
0DA4A:  BNC   DA6A
0DA4C:  MOVF   2F,W
0DA4E:  SUBLW  03
0DA50:  BNZ   DA6A
0DA52:  MOVF   30,F
0DA54:  BNZ   DA6A
....................          port=arg; 
0DA56:  MOVFF  49,886
0DA5A:  MOVFF  48,885
....................          play_wms_hard_macro(port);    
0DA5E:  MOVFF  886,88A
0DA62:  MOVFF  885,889
0DA66:  RCALL  D800
....................       } 
0DA68:  BRA    DA6E
....................       else cmd_arg(); 
0DA6A:  CALL   B2FE
....................    } 
0DA6E:  BRA    DA74
....................    else cmd_arg(); 
0DA70:  CALL   B2FE
0DA74:  GOTO   DCF4 (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0DC84:  MOVF   48,F
0DC86:  BNZ   DC94
0DC88:  MOVF   49,F
0DC8A:  BNZ   DC94
0DC8C:  MOVF   4A,F
0DC8E:  BNZ   DC94
0DC90:  MOVF   4B,F
0DC92:  BZ    DCB2
0DC94:  MOVF   4B,F
0DC96:  BNZ   DCB2
0DC98:  MOVF   4A,F
0DC9A:  BNZ   DCB2
0DC9C:  MOVF   49,F
0DC9E:  BNZ   DCB2
0DCA0:  MOVF   48,W
0DCA2:  SUBLW  04
0DCA4:  BNC   DCB2
....................       chip=arg; 
0DCA6:  MOVFF  48,885
....................       sol_chip_cmd(chip); 
0DCAA:  MOVFF  885,8B6
0DCAE:  RCALL  DBB6
....................    } 
0DCB0:  BRA    DCB6
....................    else cmd_arg();    
0DCB2:  CALL   B2FE
0DCB6:  GOTO   DCF4 (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0DCBA:  MOVF   2F,W
0DCBC:  MOVWF  00
0DCBE:  MOVF   30,W
0DCC0:  MOVWF  03
0DCC2:  BNZ   DCC8
0DCC4:  MOVF   00,F
0DCC6:  BZ    DCE8
0DCC8:  MOVF   03,W
0DCCA:  BNZ   DCD2
0DCCC:  MOVLW  01
0DCCE:  SUBWF  00,W
0DCD0:  BZ    DCEE
0DCD2:  MOVF   03,W
0DCD4:  BNZ   DCDC
0DCD6:  MOVLW  03
0DCD8:  SUBWF  00,W
0DCDA:  BZ    DCEE
0DCDC:  MOVF   03,W
0DCDE:  BNZ   DCE6
0DCE0:  MOVLW  02
0DCE2:  SUBWF  00,W
0DCE4:  BZ    DCF2
0DCE6:  BRA    DCF4
....................       case ECO : commandCe(); 
0DCE8:  GOTO   CDBA
....................          break; 
0DCEC:  BRA    DCF4
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0DCEE:  BRA    DA0E
....................          break; 
0DCF0:  BRA    DCF4
....................       case AWS : commandCa(); 
0DCF2:  BRA    DC84
....................          break;          
....................    } 
0DCF4:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0DCF8:  MOVF   48,W
0DCFA:  MOVWF  00
0DCFC:  MOVF   49,W
0DCFE:  MOVWF  03
0DD00:  BNZ   DD06
0DD02:  MOVF   00,F
0DD04:  BZ    DD26
0DD06:  MOVF   03,W
0DD08:  BNZ   DD10
0DD0A:  MOVLW  01
0DD0C:  SUBWF  00,W
0DD0E:  BZ    DD38
0DD10:  MOVF   03,W
0DD12:  BNZ   DD1A
0DD14:  MOVLW  02
0DD16:  SUBWF  00,W
0DD18:  BZ    DD5A
0DD1A:  MOVF   03,W
0DD1C:  BNZ   DD24
0DD1E:  MOVLW  03
0DD20:  SUBWF  00,W
0DD22:  BZ    DD6C
0DD24:  BRA    DD8E
....................       case 0 : file_list(file_ptr_raw_all); 
0DD26:  MOVLW  02
0DD28:  MOVLB  8
0DD2A:  MOVWF  x8A
0DD2C:  MOVLW  DD
0DD2E:  MOVWF  x89
0DD30:  MOVLB  0
0DD32:  CALL   BB24
....................          break; 
0DD36:  BRA    DD92
....................       case 1 : file_list(file_ptr_raw_new); 
0DD38:  MOVLW  02
0DD3A:  MOVLB  8
0DD3C:  MOVWF  x8A
0DD3E:  MOVLW  EB
0DD40:  MOVWF  x89
0DD42:  MOVLB  0
0DD44:  CALL   BB24
....................                f_unlink(file_ptr_raw_new); 
0DD48:  MOVLW  02
0DD4A:  MOVLB  8
0DD4C:  MOVWF  x8A
0DD4E:  MOVLW  EB
0DD50:  MOVWF  x89
0DD52:  MOVLB  0
0DD54:  CALL   BC9E
....................          break; 
0DD58:  BRA    DD92
....................       case 2 : file_list(file_ptr_rel_all); 
0DD5A:  MOVLW  02
0DD5C:  MOVLB  8
0DD5E:  MOVWF  x8A
0DD60:  MOVLW  F9
0DD62:  MOVWF  x89
0DD64:  MOVLB  0
0DD66:  CALL   BB24
....................          break; 
0DD6A:  BRA    DD92
....................       case 3 : file_list(file_ptr_rel_new); 
0DD6C:  MOVLW  03
0DD6E:  MOVLB  8
0DD70:  MOVWF  x8A
0DD72:  MOVLW  07
0DD74:  MOVWF  x89
0DD76:  MOVLB  0
0DD78:  CALL   BB24
....................                f_unlink(file_ptr_rel_new); 
0DD7C:  MOVLW  03
0DD7E:  MOVLB  8
0DD80:  MOVWF  x8A
0DD82:  MOVLW  07
0DD84:  MOVWF  x89
0DD86:  MOVLB  0
0DD88:  CALL   BC9E
....................          break;  
0DD8C:  BRA    DD92
....................       default : cmd_arg(); 
0DD8E:  CALL   B2FE
....................          break; 
....................    } 
0DD92:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DD96:  MOVF   48,W
0DD98:  MOVWF  00
0DD9A:  MOVF   49,W
0DD9C:  MOVWF  03
0DD9E:  BNZ   DDA4
0DDA0:  MOVF   00,F
0DDA2:  BZ    DDB0
0DDA4:  MOVF   03,W
0DDA6:  BNZ   DDAE
0DDA8:  MOVLW  02
0DDAA:  SUBWF  00,W
0DDAC:  BZ    DE2A
0DDAE:  BRA    DEA4
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DDB0:  MOVLW  A8
0DDB2:  MOVWF  FF6
0DDB4:  MOVLW  24
0DDB6:  MOVWF  FF7
0DDB8:  MOVLW  00
0DDBA:  MOVWF  FF8
0DDBC:  CLRF   1B
0DDBE:  BTFSC  FF2.7
0DDC0:  BSF    1B.7
0DDC2:  BCF    FF2.7
0DDC4:  CALL   0E46
0DDC8:  BTFSC  1B.7
0DDCA:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DDCC:  CALL   0E30
0DDD0:  MOVFF  01,885
....................       if(result == 'Y'){ 
0DDD4:  MOVLB  8
0DDD6:  MOVF   x85,W
0DDD8:  SUBLW  59
0DDDA:  BNZ   DE0A
....................       f_unlink(file_ptr_raw_all); 
0DDDC:  MOVLW  02
0DDDE:  MOVWF  x8A
0DDE0:  MOVLW  DD
0DDE2:  MOVWF  x89
0DDE4:  MOVLB  0
0DDE6:  CALL   BC9E
....................       printf("File deleted!\n\r"); 
0DDEA:  MOVLW  E4
0DDEC:  MOVWF  FF6
0DDEE:  MOVLW  24
0DDF0:  MOVWF  FF7
0DDF2:  MOVLW  00
0DDF4:  MOVWF  FF8
0DDF6:  CLRF   1B
0DDF8:  BTFSC  FF2.7
0DDFA:  BSF    1B.7
0DDFC:  BCF    FF2.7
0DDFE:  CALL   0E46
0DE02:  BTFSC  1B.7
0DE04:  BSF    FF2.7
....................       }else{ 
0DE06:  BRA    DE28
0DE08:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DE0A:  MOVLW  F4
0DE0C:  MOVWF  FF6
0DE0E:  MOVLW  24
0DE10:  MOVWF  FF7
0DE12:  MOVLW  00
0DE14:  MOVWF  FF8
0DE16:  CLRF   1B
0DE18:  BTFSC  FF2.7
0DE1A:  BSF    1B.7
0DE1C:  BCF    FF2.7
0DE1E:  MOVLB  0
0DE20:  CALL   0E46
0DE24:  BTFSC  1B.7
0DE26:  BSF    FF2.7
....................       } 
....................          break; 
0DE28:  BRA    DEA8
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DE2A:  MOVLW  0A
0DE2C:  MOVWF  FF6
0DE2E:  MOVLW  25
0DE30:  MOVWF  FF7
0DE32:  MOVLW  00
0DE34:  MOVWF  FF8
0DE36:  CLRF   1B
0DE38:  BTFSC  FF2.7
0DE3A:  BSF    1B.7
0DE3C:  BCF    FF2.7
0DE3E:  CALL   0E46
0DE42:  BTFSC  1B.7
0DE44:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DE46:  CALL   0E30
0DE4A:  MOVFF  01,885
....................          if(result == 'Y'){ 
0DE4E:  MOVLB  8
0DE50:  MOVF   x85,W
0DE52:  SUBLW  59
0DE54:  BNZ   DE84
....................             f_unlink(file_ptr_rel_all); 
0DE56:  MOVLW  02
0DE58:  MOVWF  x8A
0DE5A:  MOVLW  F9
0DE5C:  MOVWF  x89
0DE5E:  MOVLB  0
0DE60:  CALL   BC9E
....................             printf("File deleted!\n\r"); 
0DE64:  MOVLW  4E
0DE66:  MOVWF  FF6
0DE68:  MOVLW  25
0DE6A:  MOVWF  FF7
0DE6C:  MOVLW  00
0DE6E:  MOVWF  FF8
0DE70:  CLRF   1B
0DE72:  BTFSC  FF2.7
0DE74:  BSF    1B.7
0DE76:  BCF    FF2.7
0DE78:  CALL   0E46
0DE7C:  BTFSC  1B.7
0DE7E:  BSF    FF2.7
....................          }else{ 
0DE80:  BRA    DEA2
0DE82:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DE84:  MOVLW  5E
0DE86:  MOVWF  FF6
0DE88:  MOVLW  25
0DE8A:  MOVWF  FF7
0DE8C:  MOVLW  00
0DE8E:  MOVWF  FF8
0DE90:  CLRF   1B
0DE92:  BTFSC  FF2.7
0DE94:  BSF    1B.7
0DE96:  BCF    FF2.7
0DE98:  MOVLB  0
0DE9A:  CALL   0E46
0DE9E:  BTFSC  1B.7
0DEA0:  BSF    FF2.7
....................          } 
....................          break; 
0DEA2:  BRA    DEA8
....................       default : cmd_arg(); 
0DEA4:  CALL   B2FE
....................          break;          
....................    } 
0DEA8:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0E094:  MOVF   48,W
0E096:  SUBLW  95
0E098:  BNZ   E0AC
0E09A:  MOVF   49,W
0E09C:  SUBLW  15
0E09E:  BNZ   E0AC
0E0A0:  MOVF   4A,F
0E0A2:  BNZ   E0AC
0E0A4:  MOVF   4B,F
0E0A6:  BNZ   E0AC
....................       reset_nv_vars(); 
0E0A8:  BRA    DEAC
....................    } 
0E0AA:  BRA    E0B0
....................    else cmd_arg(); 
0E0AC:  CALL   B2FE
0E0B0:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0E0FE:  MOVF   2F,F
0E100:  BNZ   E106
0E102:  MOVF   30,F
0E104:  BZ    E118
0E106:  DECFSZ 2F,W
0E108:  BRA    E10E
0E10A:  MOVF   30,F
0E10C:  BZ    E118
0E10E:  MOVF   2F,W
0E110:  SUBLW  03
0E112:  BNZ   E18A
0E114:  MOVF   30,F
0E116:  BNZ   E18A
....................    { 
....................       busy_set(); 
0E118:  CALL   29C0
....................  
....................       switch(arg) 
0E11C:  MOVFF  48,00
0E120:  MOVF   49,W
0E122:  MOVWF  03
0E124:  BNZ   E12C
0E126:  MOVLW  01
0E128:  SUBWF  00,W
0E12A:  BZ    E142
0E12C:  MOVF   03,W
0E12E:  BNZ   E136
0E130:  MOVLW  02
0E132:  SUBWF  00,W
0E134:  BZ    E152
0E136:  MOVF   03,W
0E138:  BNZ   E140
0E13A:  MOVLW  03
0E13C:  SUBWF  00,W
0E13E:  BZ    E17C
0E140:  BRA    E182
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0E142:  MOVLB  7
0E144:  CLRF   x40
....................             align(0); 
0E146:  MOVLB  8
0E148:  CLRF   xC2
0E14A:  MOVLB  0
0E14C:  CALL   A8B4
....................             break; 
0E150:  BRA    E186
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0E152:  MOVF   48,W
0E154:  SUBLW  02
0E156:  BNZ   E17A
0E158:  MOVF   49,F
0E15A:  BNZ   E17A
0E15C:  MOVF   4A,F
0E15E:  BNZ   E17A
0E160:  MOVF   4B,F
0E162:  BNZ   E17A
0E164:  MOVF   1F,W
0E166:  SUBLW  04
0E168:  BNZ   E17A
0E16A:  MOVF   20,F
0E16C:  BNZ   E17A
....................             { 
....................                motor=0; 
0E16E:  MOVLB  7
0E170:  CLRF   x40
....................                cal_disk(0); 
0E172:  MOVLB  8
0E174:  CLRF   x85
0E176:  MOVLB  0
0E178:  BRA    E0B4
....................             } 
....................             break; 
0E17A:  BRA    E186
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0E17C:  CALL   AA58
....................             break; 
0E180:  BRA    E186
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0E182:  CALL   B2FE
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0E186:  CALL   AEB0
....................    } 
0E18A:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E664:  DECFSZ 48,W
0E666:  BRA    EA84
0E668:  MOVF   49,F
0E66A:  BTFSS  FD8.2
0E66C:  BRA    EA84
0E66E:  MOVF   4A,F
0E670:  BTFSS  FD8.2
0E672:  BRA    EA84
0E674:  MOVF   4B,F
0E676:  BTFSS  FD8.2
0E678:  BRA    EA84
....................       v_supply = read_supply(); 
0E67A:  CALL   50FC
0E67E:  MOVFF  02,886
0E682:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0E686:  CALL   34B2
....................       RTC_read(); 
0E68A:  CALL   3344
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E68E:  MOVLW  74
0E690:  MOVWF  FF6
0E692:  MOVLW  25
0E694:  MOVWF  FF7
0E696:  MOVLW  00
0E698:  MOVWF  FF8
0E69A:  CLRF   1B
0E69C:  BTFSC  FF2.7
0E69E:  BSF    1B.7
0E6A0:  BCF    FF2.7
0E6A2:  MOVLW  04
0E6A4:  MOVLB  A
0E6A6:  MOVWF  x40
0E6A8:  MOVLB  0
0E6AA:  CALL   101C
0E6AE:  BTFSC  1B.7
0E6B0:  BSF    FF2.7
0E6B2:  MOVLW  10
0E6B4:  MOVWF  FE9
0E6B6:  CLRF   1B
0E6B8:  BTFSC  FF2.7
0E6BA:  BSF    1B.7
0E6BC:  BCF    FF2.7
0E6BE:  MOVFF  26,A41
0E6C2:  MOVFF  25,A40
0E6C6:  CALL   119E
0E6CA:  BTFSC  1B.7
0E6CC:  BSF    FF2.7
0E6CE:  MOVLW  20
0E6D0:  BTFSS  F9E.4
0E6D2:  BRA    E6D0
0E6D4:  MOVWF  FAD
0E6D6:  MOVLW  49
0E6D8:  BTFSS  F9E.4
0E6DA:  BRA    E6D8
0E6DC:  MOVWF  FAD
0E6DE:  MOVLW  10
0E6E0:  MOVWF  FE9
0E6E2:  CLRF   1B
0E6E4:  BTFSC  FF2.7
0E6E6:  BSF    1B.7
0E6E8:  BCF    FF2.7
0E6EA:  MOVFF  24,A41
0E6EE:  MOVFF  23,A40
0E6F2:  CALL   119E
0E6F6:  BTFSC  1B.7
0E6F8:  BSF    FF2.7
0E6FA:  MOVLW  20
0E6FC:  BTFSS  F9E.4
0E6FE:  BRA    E6FC
0E700:  MOVWF  FAD
0E702:  MOVLW  4E
0E704:  BTFSS  F9E.4
0E706:  BRA    E704
0E708:  MOVWF  FAD
0E70A:  MOVLW  10
0E70C:  MOVWF  FE9
0E70E:  CLRF   1B
0E710:  BTFSC  FF2.7
0E712:  BSF    1B.7
0E714:  BCF    FF2.7
0E716:  MOVFF  22,A41
0E71A:  MOVFF  21,A40
0E71E:  CALL   119E
0E722:  BTFSC  1B.7
0E724:  BSF    FF2.7
0E726:  MOVLW  2F
0E728:  BTFSS  F9E.4
0E72A:  BRA    E728
0E72C:  MOVWF  FAD
0E72E:  MOVLW  10
0E730:  MOVWF  FE9
0E732:  CLRF   1B
0E734:  BTFSC  FF2.7
0E736:  BSF    1B.7
0E738:  BCF    FF2.7
0E73A:  MOVFF  28,A41
0E73E:  MOVFF  27,A40
0E742:  CALL   119E
0E746:  BTFSC  1B.7
0E748:  BSF    FF2.7
0E74A:  MOVLW  20
0E74C:  BTFSS  F9E.4
0E74E:  BRA    E74C
0E750:  MOVWF  FAD
0E752:  MOVLW  58
0E754:  BTFSS  F9E.4
0E756:  BRA    E754
0E758:  MOVWF  FAD
0E75A:  MOVLW  10
0E75C:  MOVWF  FE9
0E75E:  CLRF   1B
0E760:  BTFSC  FF2.7
0E762:  BSF    1B.7
0E764:  BCF    FF2.7
0E766:  MOVFF  20,A41
0E76A:  MOVFF  1F,A40
0E76E:  CALL   119E
0E772:  BTFSC  1B.7
0E774:  BSF    FF2.7
0E776:  MOVLW  20
0E778:  BTFSS  F9E.4
0E77A:  BRA    E778
0E77C:  MOVWF  FAD
0E77E:  MOVLW  55
0E780:  BTFSS  F9E.4
0E782:  BRA    E780
0E784:  MOVWF  FAD
0E786:  CLRF   1B
0E788:  BTFSC  FF2.7
0E78A:  BSF    1B.7
0E78C:  BCF    FF2.7
0E78E:  MOVFF  740,A40
0E792:  MOVLW  1B
0E794:  MOVLB  A
0E796:  MOVWF  x41
0E798:  MOVLB  0
0E79A:  CALL   0F9E
0E79E:  BTFSC  1B.7
0E7A0:  BSF    FF2.7
0E7A2:  MOVLW  20
0E7A4:  BTFSS  F9E.4
0E7A6:  BRA    E7A4
0E7A8:  MOVWF  FAD
0E7AA:  MOVLW  04
0E7AC:  MOVWF  FE9
0E7AE:  MOVLB  8
0E7B0:  CLRF   x8A
0E7B2:  CLRF   x89
0E7B4:  MOVFF  886,888
0E7B8:  MOVFF  885,887
0E7BC:  MOVLW  02
0E7BE:  MOVWF  x8B
0E7C0:  MOVLB  0
0E7C2:  RCALL  E18E
0E7C4:  MOVLW  98
0E7C6:  MOVWF  FF6
0E7C8:  MOVLW  25
0E7CA:  MOVWF  FF7
0E7CC:  MOVLW  00
0E7CE:  MOVWF  FF8
0E7D0:  CLRF   1B
0E7D2:  BTFSC  FF2.7
0E7D4:  BSF    1B.7
0E7D6:  BCF    FF2.7
0E7D8:  MOVLW  03
0E7DA:  MOVLB  A
0E7DC:  MOVWF  x40
0E7DE:  MOVLB  0
0E7E0:  CALL   101C
0E7E4:  BTFSC  1B.7
0E7E6:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E7E8:  MOVLW  9C
0E7EA:  MOVWF  FF6
0E7EC:  MOVLW  25
0E7EE:  MOVWF  FF7
0E7F0:  MOVLW  00
0E7F2:  MOVWF  FF8
0E7F4:  CLRF   1B
0E7F6:  BTFSC  FF2.7
0E7F8:  BSF    1B.7
0E7FA:  BCF    FF2.7
0E7FC:  MOVLW  09
0E7FE:  MOVLB  A
0E800:  MOVWF  x40
0E802:  MOVLB  0
0E804:  CALL   101C
0E808:  BTFSC  1B.7
0E80A:  BSF    FF2.7
0E80C:  MOVLW  10
0E80E:  MOVWF  FE9
0E810:  CLRF   1B
0E812:  BTFSC  FF2.7
0E814:  BSF    1B.7
0E816:  BCF    FF2.7
0E818:  MOVFF  7C4,A41
0E81C:  MOVFF  7C3,A40
0E820:  CALL   119E
0E824:  BTFSC  1B.7
0E826:  BSF    FF2.7
0E828:  MOVLW  A8
0E82A:  MOVWF  FF6
0E82C:  MOVLW  25
0E82E:  MOVWF  FF7
0E830:  MOVLW  00
0E832:  MOVWF  FF8
0E834:  CLRF   1B
0E836:  BTFSC  FF2.7
0E838:  BSF    1B.7
0E83A:  BCF    FF2.7
0E83C:  MOVLW  05
0E83E:  MOVLB  A
0E840:  MOVWF  x40
0E842:  MOVLB  0
0E844:  CALL   101C
0E848:  BTFSC  1B.7
0E84A:  BSF    FF2.7
0E84C:  MOVLW  10
0E84E:  MOVWF  FE9
0E850:  MOVFF  7B6,8F1
0E854:  MOVFF  7B5,8F0
0E858:  CALL   8FE4
0E85C:  MOVLW  0D
0E85E:  BTFSS  F9E.4
0E860:  BRA    E85E
0E862:  MOVWF  FAD
0E864:  MOVLW  0A
0E866:  BTFSS  F9E.4
0E868:  BRA    E866
0E86A:  MOVWF  FAD
....................       RTC_display(); 
0E86C:  RCALL  E28A
....................       if (RTCfmt == 0) 
0E86E:  MOVF   4F,F
0E870:  BTFSS  FD8.2
0E872:  BRA    E978
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E874:  MOVLW  B4
0E876:  MOVWF  FF6
0E878:  MOVLW  25
0E87A:  MOVWF  FF7
0E87C:  MOVLW  00
0E87E:  MOVWF  FF8
0E880:  CLRF   1B
0E882:  BTFSC  FF2.7
0E884:  BSF    1B.7
0E886:  BCF    FF2.7
0E888:  MOVLW  05
0E88A:  MOVLB  A
0E88C:  MOVWF  x40
0E88E:  MOVLB  0
0E890:  CALL   101C
0E894:  BTFSC  1B.7
0E896:  BSF    FF2.7
0E898:  CLRF   1B
0E89A:  BTFSC  FF2.7
0E89C:  BSF    1B.7
0E89E:  BCF    FF2.7
0E8A0:  MOVFF  73A,A40
0E8A4:  MOVLW  01
0E8A6:  MOVLB  A
0E8A8:  MOVWF  x41
0E8AA:  MOVLB  0
0E8AC:  CALL   0F9E
0E8B0:  BTFSC  1B.7
0E8B2:  BSF    FF2.7
0E8B4:  MOVLW  2F
0E8B6:  BTFSS  F9E.4
0E8B8:  BRA    E8B6
0E8BA:  MOVWF  FAD
0E8BC:  CLRF   1B
0E8BE:  BTFSC  FF2.7
0E8C0:  BSF    1B.7
0E8C2:  BCF    FF2.7
0E8C4:  MOVFF  73B,A40
0E8C8:  MOVLW  01
0E8CA:  MOVLB  A
0E8CC:  MOVWF  x41
0E8CE:  MOVLB  0
0E8D0:  CALL   0F9E
0E8D4:  BTFSC  1B.7
0E8D6:  BSF    FF2.7
0E8D8:  MOVLW  2F
0E8DA:  BTFSS  F9E.4
0E8DC:  BRA    E8DA
0E8DE:  MOVWF  FAD
0E8E0:  CLRF   1B
0E8E2:  BTFSC  FF2.7
0E8E4:  BSF    1B.7
0E8E6:  BCF    FF2.7
0E8E8:  MOVFF  73C,A40
0E8EC:  MOVLW  01
0E8EE:  MOVLB  A
0E8F0:  MOVWF  x41
0E8F2:  MOVLB  0
0E8F4:  CALL   0F9E
0E8F8:  BTFSC  1B.7
0E8FA:  BSF    FF2.7
0E8FC:  MOVLW  20
0E8FE:  BTFSS  F9E.4
0E900:  BRA    E8FE
0E902:  MOVWF  FAD
0E904:  CLRF   1B
0E906:  BTFSC  FF2.7
0E908:  BSF    1B.7
0E90A:  BCF    FF2.7
0E90C:  MOVFF  73D,A40
0E910:  MOVLW  01
0E912:  MOVLB  A
0E914:  MOVWF  x41
0E916:  MOVLB  0
0E918:  CALL   0F9E
0E91C:  BTFSC  1B.7
0E91E:  BSF    FF2.7
0E920:  MOVLW  3A
0E922:  BTFSS  F9E.4
0E924:  BRA    E922
0E926:  MOVWF  FAD
0E928:  CLRF   1B
0E92A:  BTFSC  FF2.7
0E92C:  BSF    1B.7
0E92E:  BCF    FF2.7
0E930:  MOVFF  73E,A40
0E934:  MOVLW  01
0E936:  MOVLB  A
0E938:  MOVWF  x41
0E93A:  MOVLB  0
0E93C:  CALL   0F9E
0E940:  BTFSC  1B.7
0E942:  BSF    FF2.7
0E944:  MOVLW  3A
0E946:  BTFSS  F9E.4
0E948:  BRA    E946
0E94A:  MOVWF  FAD
0E94C:  CLRF   1B
0E94E:  BTFSC  FF2.7
0E950:  BSF    1B.7
0E952:  BCF    FF2.7
0E954:  MOVFF  73F,A40
0E958:  MOVLW  01
0E95A:  MOVLB  A
0E95C:  MOVWF  x41
0E95E:  MOVLB  0
0E960:  CALL   0F9E
0E964:  BTFSC  1B.7
0E966:  BSF    FF2.7
0E968:  MOVLW  0D
0E96A:  BTFSS  F9E.4
0E96C:  BRA    E96A
0E96E:  MOVWF  FAD
0E970:  MOVLW  0A
0E972:  BTFSS  F9E.4
0E974:  BRA    E972
0E976:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E978:  DECFSZ 4F,W
0E97A:  BRA    EA80
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E97C:  MOVLW  DA
0E97E:  MOVWF  FF6
0E980:  MOVLW  25
0E982:  MOVWF  FF7
0E984:  MOVLW  00
0E986:  MOVWF  FF8
0E988:  CLRF   1B
0E98A:  BTFSC  FF2.7
0E98C:  BSF    1B.7
0E98E:  BCF    FF2.7
0E990:  MOVLW  05
0E992:  MOVLB  A
0E994:  MOVWF  x40
0E996:  MOVLB  0
0E998:  CALL   101C
0E99C:  BTFSC  1B.7
0E99E:  BSF    FF2.7
0E9A0:  CLRF   1B
0E9A2:  BTFSC  FF2.7
0E9A4:  BSF    1B.7
0E9A6:  BCF    FF2.7
0E9A8:  MOVFF  73B,A40
0E9AC:  MOVLW  01
0E9AE:  MOVLB  A
0E9B0:  MOVWF  x41
0E9B2:  MOVLB  0
0E9B4:  CALL   0F9E
0E9B8:  BTFSC  1B.7
0E9BA:  BSF    FF2.7
0E9BC:  MOVLW  2F
0E9BE:  BTFSS  F9E.4
0E9C0:  BRA    E9BE
0E9C2:  MOVWF  FAD
0E9C4:  CLRF   1B
0E9C6:  BTFSC  FF2.7
0E9C8:  BSF    1B.7
0E9CA:  BCF    FF2.7
0E9CC:  MOVFF  73A,A40
0E9D0:  MOVLW  01
0E9D2:  MOVLB  A
0E9D4:  MOVWF  x41
0E9D6:  MOVLB  0
0E9D8:  CALL   0F9E
0E9DC:  BTFSC  1B.7
0E9DE:  BSF    FF2.7
0E9E0:  MOVLW  2F
0E9E2:  BTFSS  F9E.4
0E9E4:  BRA    E9E2
0E9E6:  MOVWF  FAD
0E9E8:  CLRF   1B
0E9EA:  BTFSC  FF2.7
0E9EC:  BSF    1B.7
0E9EE:  BCF    FF2.7
0E9F0:  MOVFF  73C,A40
0E9F4:  MOVLW  01
0E9F6:  MOVLB  A
0E9F8:  MOVWF  x41
0E9FA:  MOVLB  0
0E9FC:  CALL   0F9E
0EA00:  BTFSC  1B.7
0EA02:  BSF    FF2.7
0EA04:  MOVLW  20
0EA06:  BTFSS  F9E.4
0EA08:  BRA    EA06
0EA0A:  MOVWF  FAD
0EA0C:  CLRF   1B
0EA0E:  BTFSC  FF2.7
0EA10:  BSF    1B.7
0EA12:  BCF    FF2.7
0EA14:  MOVFF  73D,A40
0EA18:  MOVLW  01
0EA1A:  MOVLB  A
0EA1C:  MOVWF  x41
0EA1E:  MOVLB  0
0EA20:  CALL   0F9E
0EA24:  BTFSC  1B.7
0EA26:  BSF    FF2.7
0EA28:  MOVLW  3A
0EA2A:  BTFSS  F9E.4
0EA2C:  BRA    EA2A
0EA2E:  MOVWF  FAD
0EA30:  CLRF   1B
0EA32:  BTFSC  FF2.7
0EA34:  BSF    1B.7
0EA36:  BCF    FF2.7
0EA38:  MOVFF  73E,A40
0EA3C:  MOVLW  01
0EA3E:  MOVLB  A
0EA40:  MOVWF  x41
0EA42:  MOVLB  0
0EA44:  CALL   0F9E
0EA48:  BTFSC  1B.7
0EA4A:  BSF    FF2.7
0EA4C:  MOVLW  3A
0EA4E:  BTFSS  F9E.4
0EA50:  BRA    EA4E
0EA52:  MOVWF  FAD
0EA54:  CLRF   1B
0EA56:  BTFSC  FF2.7
0EA58:  BSF    1B.7
0EA5A:  BCF    FF2.7
0EA5C:  MOVFF  73F,A40
0EA60:  MOVLW  01
0EA62:  MOVLB  A
0EA64:  MOVWF  x41
0EA66:  MOVLB  0
0EA68:  CALL   0F9E
0EA6C:  BTFSC  1B.7
0EA6E:  BSF    FF2.7
0EA70:  MOVLW  0D
0EA72:  BTFSS  F9E.4
0EA74:  BRA    EA72
0EA76:  MOVWF  FAD
0EA78:  MOVLW  0A
0EA7A:  BTFSS  F9E.4
0EA7C:  BRA    EA7A
0EA7E:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0EA80:  RCALL  E414
....................       RTC_display_alarm(); 
0EA82:  RCALL  E4EA
....................    } 
0EA84:  GOTO   F298 (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0EA88:  DECFSZ 48,W
0EA8A:  BRA    ED62
0EA8C:  MOVF   49,F
0EA8E:  BTFSS  FD8.2
0EA90:  BRA    ED62
0EA92:  MOVF   4A,F
0EA94:  BTFSS  FD8.2
0EA96:  BRA    ED62
0EA98:  MOVF   4B,F
0EA9A:  BTFSS  FD8.2
0EA9C:  BRA    ED62
....................       v_supply = read_supply(); 
0EA9E:  CALL   50FC
0EAA2:  MOVFF  02,886
0EAA6:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0EAAA:  CALL   34B2
....................       RTC_read(); 
0EAAE:  CALL   3344
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0EAB2:  MOVLW  41
0EAB4:  BTFSS  F9E.4
0EAB6:  BRA    EAB4
0EAB8:  MOVWF  FAD
0EABA:  MOVLW  10
0EABC:  MOVWF  FE9
0EABE:  CLRF   1B
0EAC0:  BTFSC  FF2.7
0EAC2:  BSF    1B.7
0EAC4:  BCF    FF2.7
0EAC6:  MOVFF  2A,A41
0EACA:  MOVFF  29,A40
0EACE:  CALL   119E
0EAD2:  BTFSC  1B.7
0EAD4:  BSF    FF2.7
0EAD6:  MOVLW  20
0EAD8:  BTFSS  F9E.4
0EADA:  BRA    EAD8
0EADC:  MOVWF  FAD
0EADE:  MOVLW  49
0EAE0:  BTFSS  F9E.4
0EAE2:  BRA    EAE0
0EAE4:  MOVWF  FAD
0EAE6:  MOVLW  10
0EAE8:  MOVWF  FE9
0EAEA:  CLRF   1B
0EAEC:  BTFSC  FF2.7
0EAEE:  BSF    1B.7
0EAF0:  BCF    FF2.7
0EAF2:  MOVFF  24,A41
0EAF6:  MOVFF  23,A40
0EAFA:  CALL   119E
0EAFE:  BTFSC  1B.7
0EB00:  BSF    FF2.7
0EB02:  MOVLW  20
0EB04:  BTFSS  F9E.4
0EB06:  BRA    EB04
0EB08:  MOVWF  FAD
0EB0A:  MOVLW  4C
0EB0C:  BTFSS  F9E.4
0EB0E:  BRA    EB0C
0EB10:  MOVWF  FAD
0EB12:  MOVLW  10
0EB14:  MOVWF  FE9
0EB16:  CLRF   1B
0EB18:  BTFSC  FF2.7
0EB1A:  BSF    1B.7
0EB1C:  BCF    FF2.7
0EB1E:  MOVFF  2C,A41
0EB22:  MOVFF  2B,A40
0EB26:  CALL   119E
0EB2A:  BTFSC  1B.7
0EB2C:  BSF    FF2.7
0EB2E:  MOVLW  20
0EB30:  BTFSS  F9E.4
0EB32:  BRA    EB30
0EB34:  MOVWF  FAD
0EB36:  MOVLW  51
0EB38:  BTFSS  F9E.4
0EB3A:  BRA    EB38
0EB3C:  MOVWF  FAD
0EB3E:  MOVLW  10
0EB40:  MOVWF  FE9
0EB42:  CLRF   1B
0EB44:  BTFSC  FF2.7
0EB46:  BSF    1B.7
0EB48:  BCF    FF2.7
0EB4A:  MOVFF  2E,A41
0EB4E:  MOVFF  2D,A40
0EB52:  CALL   119E
0EB56:  BTFSC  1B.7
0EB58:  BSF    FF2.7
0EB5A:  MOVLW  20
0EB5C:  BTFSS  F9E.4
0EB5E:  BRA    EB5C
0EB60:  MOVWF  FAD
0EB62:  MOVLW  53
0EB64:  BTFSS  F9E.4
0EB66:  BRA    EB64
0EB68:  MOVWF  FAD
0EB6A:  MOVLW  10
0EB6C:  MOVWF  FE9
0EB6E:  CLRF   1B
0EB70:  BTFSC  FF2.7
0EB72:  BSF    1B.7
0EB74:  BCF    FF2.7
0EB76:  MOVFF  22,A41
0EB7A:  MOVFF  21,A40
0EB7E:  CALL   119E
0EB82:  BTFSC  1B.7
0EB84:  BSF    FF2.7
0EB86:  MOVLW  20
0EB88:  BTFSS  F9E.4
0EB8A:  BRA    EB88
0EB8C:  MOVWF  FAD
0EB8E:  MOVLW  04
0EB90:  MOVWF  FE9
0EB92:  MOVLB  8
0EB94:  CLRF   x8A
0EB96:  CLRF   x89
0EB98:  MOVFF  886,888
0EB9C:  MOVFF  885,887
0EBA0:  MOVLW  02
0EBA2:  MOVWF  x8B
0EBA4:  MOVLB  0
0EBA6:  CALL   E18E
0EBAA:  MOVLW  1E
0EBAC:  MOVWF  FF6
0EBAE:  MOVLW  26
0EBB0:  MOVWF  FF7
0EBB2:  MOVLW  00
0EBB4:  MOVWF  FF8
0EBB6:  CLRF   1B
0EBB8:  BTFSC  FF2.7
0EBBA:  BSF    1B.7
0EBBC:  BCF    FF2.7
0EBBE:  MOVLW  03
0EBC0:  MOVLB  A
0EBC2:  MOVWF  x40
0EBC4:  MOVLB  0
0EBC6:  CALL   101C
0EBCA:  BTFSC  1B.7
0EBCC:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0EBCE:  MOVLW  22
0EBD0:  MOVWF  FF6
0EBD2:  MOVLW  26
0EBD4:  MOVWF  FF7
0EBD6:  MOVLW  00
0EBD8:  MOVWF  FF8
0EBDA:  CLRF   1B
0EBDC:  BTFSC  FF2.7
0EBDE:  BSF    1B.7
0EBE0:  BCF    FF2.7
0EBE2:  MOVLW  09
0EBE4:  MOVLB  A
0EBE6:  MOVWF  x40
0EBE8:  MOVLB  0
0EBEA:  CALL   101C
0EBEE:  BTFSC  1B.7
0EBF0:  BSF    FF2.7
0EBF2:  MOVLW  10
0EBF4:  MOVWF  FE9
0EBF6:  CLRF   1B
0EBF8:  BTFSC  FF2.7
0EBFA:  BSF    1B.7
0EBFC:  BCF    FF2.7
0EBFE:  MOVFF  7C4,A41
0EC02:  MOVFF  7C3,A40
0EC06:  CALL   119E
0EC0A:  BTFSC  1B.7
0EC0C:  BSF    FF2.7
0EC0E:  MOVLW  2E
0EC10:  MOVWF  FF6
0EC12:  MOVLW  26
0EC14:  MOVWF  FF7
0EC16:  MOVLW  00
0EC18:  MOVWF  FF8
0EC1A:  CLRF   1B
0EC1C:  BTFSC  FF2.7
0EC1E:  BSF    1B.7
0EC20:  BCF    FF2.7
0EC22:  MOVLW  05
0EC24:  MOVLB  A
0EC26:  MOVWF  x40
0EC28:  MOVLB  0
0EC2A:  CALL   101C
0EC2E:  BTFSC  1B.7
0EC30:  BSF    FF2.7
0EC32:  MOVLW  10
0EC34:  MOVWF  FE9
0EC36:  MOVFF  7B6,8F1
0EC3A:  MOVFF  7B5,8F0
0EC3E:  CALL   8FE4
0EC42:  MOVLW  0D
0EC44:  BTFSS  F9E.4
0EC46:  BRA    EC44
0EC48:  MOVWF  FAD
0EC4A:  MOVLW  0A
0EC4C:  BTFSS  F9E.4
0EC4E:  BRA    EC4C
0EC50:  MOVWF  FAD
....................       RTC_display(); 
0EC52:  CALL   E28A
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EC56:  MOVLW  3A
0EC58:  MOVWF  FF6
0EC5A:  MOVLW  26
0EC5C:  MOVWF  FF7
0EC5E:  MOVLW  00
0EC60:  MOVWF  FF8
0EC62:  CLRF   1B
0EC64:  BTFSC  FF2.7
0EC66:  BSF    1B.7
0EC68:  BCF    FF2.7
0EC6A:  MOVLW  05
0EC6C:  MOVLB  A
0EC6E:  MOVWF  x40
0EC70:  MOVLB  0
0EC72:  CALL   101C
0EC76:  BTFSC  1B.7
0EC78:  BSF    FF2.7
0EC7A:  CLRF   1B
0EC7C:  BTFSC  FF2.7
0EC7E:  BSF    1B.7
0EC80:  BCF    FF2.7
0EC82:  MOVFF  73A,A40
0EC86:  MOVLW  01
0EC88:  MOVLB  A
0EC8A:  MOVWF  x41
0EC8C:  MOVLB  0
0EC8E:  CALL   0F9E
0EC92:  BTFSC  1B.7
0EC94:  BSF    FF2.7
0EC96:  MOVLW  2F
0EC98:  BTFSS  F9E.4
0EC9A:  BRA    EC98
0EC9C:  MOVWF  FAD
0EC9E:  CLRF   1B
0ECA0:  BTFSC  FF2.7
0ECA2:  BSF    1B.7
0ECA4:  BCF    FF2.7
0ECA6:  MOVFF  73B,A40
0ECAA:  MOVLW  01
0ECAC:  MOVLB  A
0ECAE:  MOVWF  x41
0ECB0:  MOVLB  0
0ECB2:  CALL   0F9E
0ECB6:  BTFSC  1B.7
0ECB8:  BSF    FF2.7
0ECBA:  MOVLW  2F
0ECBC:  BTFSS  F9E.4
0ECBE:  BRA    ECBC
0ECC0:  MOVWF  FAD
0ECC2:  CLRF   1B
0ECC4:  BTFSC  FF2.7
0ECC6:  BSF    1B.7
0ECC8:  BCF    FF2.7
0ECCA:  MOVFF  73C,A40
0ECCE:  MOVLW  01
0ECD0:  MOVLB  A
0ECD2:  MOVWF  x41
0ECD4:  MOVLB  0
0ECD6:  CALL   0F9E
0ECDA:  BTFSC  1B.7
0ECDC:  BSF    FF2.7
0ECDE:  MOVLW  20
0ECE0:  BTFSS  F9E.4
0ECE2:  BRA    ECE0
0ECE4:  MOVWF  FAD
0ECE6:  CLRF   1B
0ECE8:  BTFSC  FF2.7
0ECEA:  BSF    1B.7
0ECEC:  BCF    FF2.7
0ECEE:  MOVFF  73D,A40
0ECF2:  MOVLW  01
0ECF4:  MOVLB  A
0ECF6:  MOVWF  x41
0ECF8:  MOVLB  0
0ECFA:  CALL   0F9E
0ECFE:  BTFSC  1B.7
0ED00:  BSF    FF2.7
0ED02:  MOVLW  3A
0ED04:  BTFSS  F9E.4
0ED06:  BRA    ED04
0ED08:  MOVWF  FAD
0ED0A:  CLRF   1B
0ED0C:  BTFSC  FF2.7
0ED0E:  BSF    1B.7
0ED10:  BCF    FF2.7
0ED12:  MOVFF  73E,A40
0ED16:  MOVLW  01
0ED18:  MOVLB  A
0ED1A:  MOVWF  x41
0ED1C:  MOVLB  0
0ED1E:  CALL   0F9E
0ED22:  BTFSC  1B.7
0ED24:  BSF    FF2.7
0ED26:  MOVLW  3A
0ED28:  BTFSS  F9E.4
0ED2A:  BRA    ED28
0ED2C:  MOVWF  FAD
0ED2E:  CLRF   1B
0ED30:  BTFSC  FF2.7
0ED32:  BSF    1B.7
0ED34:  BCF    FF2.7
0ED36:  MOVFF  73F,A40
0ED3A:  MOVLW  01
0ED3C:  MOVLB  A
0ED3E:  MOVWF  x41
0ED40:  MOVLB  0
0ED42:  CALL   0F9E
0ED46:  BTFSC  1B.7
0ED48:  BSF    FF2.7
0ED4A:  MOVLW  0D
0ED4C:  BTFSS  F9E.4
0ED4E:  BRA    ED4C
0ED50:  MOVWF  FAD
0ED52:  MOVLW  0A
0ED54:  BTFSS  F9E.4
0ED56:  BRA    ED54
0ED58:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0ED5A:  CALL   E414
....................       RTC_display_alarm(); 
0ED5E:  CALL   E4EA
....................    } 
0ED62:  GOTO   F298 (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0EFF0:  DECFSZ 48,W
0EFF2:  BRA    F258
0EFF4:  MOVF   49,F
0EFF6:  BTFSS  FD8.2
0EFF8:  BRA    F258
0EFFA:  MOVF   4A,F
0EFFC:  BTFSS  FD8.2
0EFFE:  BRA    F258
0F000:  MOVF   4B,F
0F002:  BTFSS  FD8.2
0F004:  BRA    F258
....................       v_supply = read_supply(); 
0F006:  CALL   50FC
0F00A:  MOVFF  02,886
0F00E:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0F012:  CALL   34B2
....................       RTC_read(); 
0F016:  CALL   3344
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0F01A:  MOVLW  49
0F01C:  BTFSS  F9E.4
0F01E:  BRA    F01C
0F020:  MOVWF  FAD
0F022:  MOVLW  10
0F024:  MOVWF  FE9
0F026:  CLRF   1B
0F028:  BTFSC  FF2.7
0F02A:  BSF    1B.7
0F02C:  BCF    FF2.7
0F02E:  MOVFF  24,A41
0F032:  MOVFF  23,A40
0F036:  CALL   119E
0F03A:  BTFSC  1B.7
0F03C:  BSF    FF2.7
0F03E:  MOVLW  20
0F040:  BTFSS  F9E.4
0F042:  BRA    F040
0F044:  MOVWF  FAD
0F046:  MOVLW  4E
0F048:  BTFSS  F9E.4
0F04A:  BRA    F048
0F04C:  MOVWF  FAD
0F04E:  MOVLW  10
0F050:  MOVWF  FE9
0F052:  CLRF   1B
0F054:  BTFSC  FF2.7
0F056:  BSF    1B.7
0F058:  BCF    FF2.7
0F05A:  MOVFF  22,A41
0F05E:  MOVFF  21,A40
0F062:  CALL   119E
0F066:  BTFSC  1B.7
0F068:  BSF    FF2.7
0F06A:  MOVLW  2F
0F06C:  BTFSS  F9E.4
0F06E:  BRA    F06C
0F070:  MOVWF  FAD
0F072:  MOVLW  10
0F074:  MOVWF  FE9
0F076:  CLRF   1B
0F078:  BTFSC  FF2.7
0F07A:  BSF    1B.7
0F07C:  BCF    FF2.7
0F07E:  MOVFF  28,A41
0F082:  MOVFF  27,A40
0F086:  CALL   119E
0F08A:  BTFSC  1B.7
0F08C:  BSF    FF2.7
0F08E:  MOVLW  20
0F090:  BTFSS  F9E.4
0F092:  BRA    F090
0F094:  MOVWF  FAD
0F096:  MOVLW  50
0F098:  BTFSS  F9E.4
0F09A:  BRA    F098
0F09C:  MOVWF  FAD
0F09E:  MOVLW  10
0F0A0:  MOVWF  FE9
0F0A2:  CLRF   1B
0F0A4:  BTFSC  FF2.7
0F0A6:  BSF    1B.7
0F0A8:  BCF    FF2.7
0F0AA:  MOVFF  2E,A41
0F0AE:  MOVFF  2D,A40
0F0B2:  CALL   119E
0F0B6:  BTFSC  1B.7
0F0B8:  BSF    FF2.7
0F0BA:  MOVLW  20
0F0BC:  BTFSS  F9E.4
0F0BE:  BRA    F0BC
0F0C0:  MOVWF  FAD
0F0C2:  MOVLW  04
0F0C4:  MOVWF  FE9
0F0C6:  MOVLB  8
0F0C8:  CLRF   x8A
0F0CA:  CLRF   x89
0F0CC:  MOVFF  886,888
0F0D0:  MOVFF  885,887
0F0D4:  MOVLW  02
0F0D6:  MOVWF  x8B
0F0D8:  MOVLB  0
0F0DA:  CALL   E18E
0F0DE:  MOVLW  78
0F0E0:  MOVWF  FF6
0F0E2:  MOVLW  26
0F0E4:  MOVWF  FF7
0F0E6:  MOVLW  00
0F0E8:  MOVWF  FF8
0F0EA:  CLRF   1B
0F0EC:  BTFSC  FF2.7
0F0EE:  BSF    1B.7
0F0F0:  BCF    FF2.7
0F0F2:  MOVLW  03
0F0F4:  MOVLB  A
0F0F6:  MOVWF  x40
0F0F8:  MOVLB  0
0F0FA:  CALL   101C
0F0FE:  BTFSC  1B.7
0F100:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0F102:  MOVLW  7C
0F104:  MOVWF  FF6
0F106:  MOVLW  26
0F108:  MOVWF  FF7
0F10A:  MOVLW  00
0F10C:  MOVWF  FF8
0F10E:  CLRF   1B
0F110:  BTFSC  FF2.7
0F112:  BSF    1B.7
0F114:  BCF    FF2.7
0F116:  MOVLW  09
0F118:  MOVLB  A
0F11A:  MOVWF  x40
0F11C:  MOVLB  0
0F11E:  CALL   101C
0F122:  BTFSC  1B.7
0F124:  BSF    FF2.7
0F126:  MOVLW  10
0F128:  MOVWF  FE9
0F12A:  MOVFF  7B6,8F1
0F12E:  MOVFF  7B5,8F0
0F132:  CALL   8FE4
0F136:  MOVLW  0D
0F138:  BTFSS  F9E.4
0F13A:  BRA    F138
0F13C:  MOVWF  FAD
0F13E:  MOVLW  0A
0F140:  BTFSS  F9E.4
0F142:  BRA    F140
0F144:  MOVWF  FAD
....................       display_valve_status(); 
0F146:  RCALL  ED66
....................       RTC_display(); 
0F148:  CALL   E28A
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0F14C:  MOVLW  8C
0F14E:  MOVWF  FF6
0F150:  MOVLW  26
0F152:  MOVWF  FF7
0F154:  MOVLW  00
0F156:  MOVWF  FF8
0F158:  CLRF   1B
0F15A:  BTFSC  FF2.7
0F15C:  BSF    1B.7
0F15E:  BCF    FF2.7
0F160:  MOVLW  05
0F162:  MOVLB  A
0F164:  MOVWF  x40
0F166:  MOVLB  0
0F168:  CALL   101C
0F16C:  BTFSC  1B.7
0F16E:  BSF    FF2.7
0F170:  CLRF   1B
0F172:  BTFSC  FF2.7
0F174:  BSF    1B.7
0F176:  BCF    FF2.7
0F178:  MOVFF  73A,A40
0F17C:  MOVLW  01
0F17E:  MOVLB  A
0F180:  MOVWF  x41
0F182:  MOVLB  0
0F184:  CALL   0F9E
0F188:  BTFSC  1B.7
0F18A:  BSF    FF2.7
0F18C:  MOVLW  2F
0F18E:  BTFSS  F9E.4
0F190:  BRA    F18E
0F192:  MOVWF  FAD
0F194:  CLRF   1B
0F196:  BTFSC  FF2.7
0F198:  BSF    1B.7
0F19A:  BCF    FF2.7
0F19C:  MOVFF  73B,A40
0F1A0:  MOVLW  01
0F1A2:  MOVLB  A
0F1A4:  MOVWF  x41
0F1A6:  MOVLB  0
0F1A8:  CALL   0F9E
0F1AC:  BTFSC  1B.7
0F1AE:  BSF    FF2.7
0F1B0:  MOVLW  2F
0F1B2:  BTFSS  F9E.4
0F1B4:  BRA    F1B2
0F1B6:  MOVWF  FAD
0F1B8:  CLRF   1B
0F1BA:  BTFSC  FF2.7
0F1BC:  BSF    1B.7
0F1BE:  BCF    FF2.7
0F1C0:  MOVFF  73C,A40
0F1C4:  MOVLW  01
0F1C6:  MOVLB  A
0F1C8:  MOVWF  x41
0F1CA:  MOVLB  0
0F1CC:  CALL   0F9E
0F1D0:  BTFSC  1B.7
0F1D2:  BSF    FF2.7
0F1D4:  MOVLW  20
0F1D6:  BTFSS  F9E.4
0F1D8:  BRA    F1D6
0F1DA:  MOVWF  FAD
0F1DC:  CLRF   1B
0F1DE:  BTFSC  FF2.7
0F1E0:  BSF    1B.7
0F1E2:  BCF    FF2.7
0F1E4:  MOVFF  73D,A40
0F1E8:  MOVLW  01
0F1EA:  MOVLB  A
0F1EC:  MOVWF  x41
0F1EE:  MOVLB  0
0F1F0:  CALL   0F9E
0F1F4:  BTFSC  1B.7
0F1F6:  BSF    FF2.7
0F1F8:  MOVLW  3A
0F1FA:  BTFSS  F9E.4
0F1FC:  BRA    F1FA
0F1FE:  MOVWF  FAD
0F200:  CLRF   1B
0F202:  BTFSC  FF2.7
0F204:  BSF    1B.7
0F206:  BCF    FF2.7
0F208:  MOVFF  73E,A40
0F20C:  MOVLW  01
0F20E:  MOVLB  A
0F210:  MOVWF  x41
0F212:  MOVLB  0
0F214:  CALL   0F9E
0F218:  BTFSC  1B.7
0F21A:  BSF    FF2.7
0F21C:  MOVLW  3A
0F21E:  BTFSS  F9E.4
0F220:  BRA    F21E
0F222:  MOVWF  FAD
0F224:  CLRF   1B
0F226:  BTFSC  FF2.7
0F228:  BSF    1B.7
0F22A:  BCF    FF2.7
0F22C:  MOVFF  73F,A40
0F230:  MOVLW  01
0F232:  MOVLB  A
0F234:  MOVWF  x41
0F236:  MOVLB  0
0F238:  CALL   0F9E
0F23C:  BTFSC  1B.7
0F23E:  BSF    FF2.7
0F240:  MOVLW  0D
0F242:  BTFSS  F9E.4
0F244:  BRA    F242
0F246:  MOVWF  FAD
0F248:  MOVLW  0A
0F24A:  BTFSS  F9E.4
0F24C:  BRA    F24A
0F24E:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0F250:  CALL   E414
....................       RTC_display_alarm(); 
0F254:  CALL   E4EA
....................    } 
0F258:  GOTO   F298 (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0F25C:  MOVF   2F,W
0F25E:  MOVWF  00
0F260:  MOVF   30,W
0F262:  MOVWF  03
0F264:  BNZ   F26A
0F266:  MOVF   00,F
0F268:  BZ    F28A
0F26A:  MOVF   03,W
0F26C:  BNZ   F274
0F26E:  MOVLW  01
0F270:  SUBWF  00,W
0F272:  BZ    F290
0F274:  MOVF   03,W
0F276:  BNZ   F27E
0F278:  MOVLW  03
0F27A:  SUBWF  00,W
0F27C:  BZ    F290
0F27E:  MOVF   03,W
0F280:  BNZ   F288
0F282:  MOVLW  02
0F284:  SUBWF  00,W
0F286:  BZ    F296
0F288:  BRA    F298
....................       case ECO : commandHe(); 
0F28A:  GOTO   E664
....................          break; 
0F28E:  BRA    F298
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0F290:  GOTO   EA88
....................          break; 
0F294:  BRA    F298
....................       case AWS : commandHa(); 
0F296:  BRA    EFF0
....................          break;          
....................    } 
0F298:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0F29C:  MOVF   48,F
0F29E:  BNZ   F2AC
0F2A0:  MOVF   49,F
0F2A2:  BNZ   F2AC
0F2A4:  MOVF   4A,F
0F2A6:  BNZ   F2AC
0F2A8:  MOVF   4B,F
0F2AA:  BZ    F2E0
0F2AC:  MOVF   4B,F
0F2AE:  BNZ   F2E0
0F2B0:  MOVF   4A,F
0F2B2:  BNZ   F2E0
0F2B4:  MOVF   49,W
0F2B6:  SUBLW  FD
0F2B8:  BNC   F2E0
0F2BA:  BNZ   F2C2
0F2BC:  MOVF   48,W
0F2BE:  SUBLW  20
0F2C0:  BNC   F2E0
....................       nv_interval = arg; 
0F2C2:  MOVFF  49,24
0F2C6:  MOVFF  48,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0F2CA:  MOVLW  14
0F2CC:  MOVLB  8
0F2CE:  MOVWF  xEE
0F2D0:  MOVFF  24,8F0
0F2D4:  MOVFF  23,8EF
0F2D8:  MOVLB  0
0F2DA:  CALL   4FD4
....................    } 
0F2DE:  BRA    F2E4
....................    else cmd_arg(); 
0F2E0:  CALL   B2FE
0F2E4:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0F2E8:  MOVF   4B,F
0F2EA:  BNZ   F31A
0F2EC:  MOVF   4A,F
0F2EE:  BNZ   F31A
0F2F0:  MOVF   49,W
0F2F2:  SUBLW  27
0F2F4:  BNC   F31A
0F2F6:  BNZ   F2FE
0F2F8:  MOVF   48,W
0F2FA:  SUBLW  0F
0F2FC:  BNC   F31A
....................       nv_serial = arg; 
0F2FE:  MOVFF  49,26
0F302:  MOVFF  48,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0F306:  MOVLB  8
0F308:  CLRF   xEE
0F30A:  MOVFF  26,8F0
0F30E:  MOVFF  25,8EF
0F312:  MOVLB  0
0F314:  CALL   4FD4
....................    } 
0F318:  BRA    F31E
....................    else cmd_arg(); 
0F31A:  CALL   B2FE
0F31E:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F542:  MOVF   2F,F
0F544:  BNZ   F574
0F546:  MOVF   30,F
0F548:  BNZ   F574
....................        
....................       if (arg > 0 && arg < 3){ 
0F54A:  MOVF   48,F
0F54C:  BNZ   F55A
0F54E:  MOVF   49,F
0F550:  BNZ   F55A
0F552:  MOVF   4A,F
0F554:  BNZ   F55A
0F556:  MOVF   4B,F
0F558:  BZ    F570
0F55A:  MOVF   4B,F
0F55C:  BNZ   F570
0F55E:  MOVF   4A,F
0F560:  BNZ   F570
0F562:  MOVF   49,F
0F564:  BNZ   F570
0F566:  MOVF   48,W
0F568:  SUBLW  02
0F56A:  BNC   F570
....................          det_cmd(); 
0F56C:  RCALL  F402
....................       } 
0F56E:  BRA    F574
....................       else cmd_arg(); 
0F570:  CALL   B2FE
....................        
....................    } 
0F574:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
103D0:  MOVF   4B,F
103D2:  BNZ   1043E
103D4:  MOVF   4A,F
103D6:  BNZ   1043E
103D8:  MOVF   49,W
103DA:  SUBLW  0F
103DC:  BNC   1043E
....................       switch (nv_det_type){ 
103DE:  MOVFF  45,00
103E2:  MOVF   46,W
103E4:  MOVWF  03
103E6:  BNZ   103EE
103E8:  MOVLW  01
103EA:  SUBWF  00,W
103EC:  BZ    10404
103EE:  MOVF   03,W
103F0:  BNZ   103F8
103F2:  MOVLW  02
103F4:  SUBWF  00,W
103F6:  BZ    1040A
103F8:  MOVF   03,W
103FA:  BNZ   10402
103FC:  MOVLW  03
103FE:  SUBWF  00,W
10400:  BZ    10428
10402:  BRA    1043C
....................          case 1 : det_cmd(); 
10404:  CALL   F402
....................             break; 
10408:  BRA    1043C
....................          case 2 : DAC_set(1,arg); 
1040A:  MOVFF  49,886
1040E:  MOVFF  48,885
10412:  MOVLW  01
10414:  MOVLB  8
10416:  MOVWF  xD3
10418:  MOVFF  886,8D5
1041C:  MOVFF  885,8D4
10420:  MOVLB  0
10422:  CALL   F578
....................             break; 
10426:  BRA    1043C
....................          case 3 : set_LED(arg); 
10428:  MOVFF  49,886
1042C:  MOVFF  48,885
10430:  MOVFF  886,8C6
10434:  MOVFF  885,8C5
10438:  CALL   F8C6
....................             break; 
....................       } 
....................    } 
1043C:  BRA    1049C
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
1043E:  MOVF   4B,F
10440:  BNZ   10456
10442:  MOVF   4A,F
10444:  BNZ   10456
10446:  MOVF   49,W
10448:  SUBLW  4D
1044A:  BC    10480
1044C:  XORLW  FF
1044E:  BNZ   10456
10450:  MOVF   48,W
10452:  SUBLW  20
10454:  BC    10480
10456:  MOVF   4B,F
10458:  BNZ   10480
1045A:  MOVF   4A,F
1045C:  BNZ   10480
1045E:  MOVF   49,W
10460:  SUBLW  4E
10462:  BNC   10480
10464:  BNZ   1046C
10466:  MOVF   48,W
10468:  SUBLW  22
1046A:  BNC   10480
1046C:  MOVFF  49,886
10470:  MOVFF  48,885
10474:  MOVFF  886,888
10478:  MOVFF  885,887
1047C:  BRA    10314
1047E:  BRA    1049C
....................    else if(arg==30001)set_LED_test(); 
10480:  MOVF   48,W
10482:  SUBLW  31
10484:  BNZ   10498
10486:  MOVF   49,W
10488:  SUBLW  75
1048A:  BNZ   10498
1048C:  MOVF   4A,F
1048E:  BNZ   10498
10490:  MOVF   4B,F
10492:  BNZ   10498
10494:  BRA    FF6A
10496:  BRA    1049C
....................    else cmd_arg(); 
10498:  CALL   B2FE
1049C:  GOTO   10506 (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
104A0:  MOVF   4B,F
104A2:  BNZ   104D4
104A4:  MOVF   4A,F
104A6:  BNZ   104D4
104A8:  MOVF   49,W
104AA:  SUBLW  57
104AC:  BNC   104D4
104AE:  BNZ   104B6
104B0:  MOVF   48,W
104B2:  SUBLW  E4
104B4:  BNC   104D4
....................       nv_volume = arg; 
104B6:  MOVFF  49,2C
104BA:  MOVFF  48,2B
....................       write16(ADDR_VOLUME, nv_volume); 
104BE:  MOVLW  22
104C0:  MOVLB  8
104C2:  MOVWF  xEE
104C4:  MOVFF  2C,8F0
104C8:  MOVFF  2B,8EF
104CC:  MOVLB  0
104CE:  CALL   4FD4
....................    } 
104D2:  BRA    104D8
....................    else cmd_arg(); 
104D4:  CALL   B2FE
104D8:  GOTO   10506 (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
104DC:  MOVF   2F,W
104DE:  MOVWF  00
104E0:  MOVF   30,W
104E2:  MOVWF  03
104E4:  BNZ   104EA
104E6:  MOVF   00,F
104E8:  BZ    10500
104EA:  MOVF   03,W
104EC:  BNZ   104F4
104EE:  MOVLW  01
104F0:  SUBWF  00,W
104F2:  BZ    10504
104F4:  MOVF   03,W
104F6:  BNZ   104FE
104F8:  MOVLW  03
104FA:  SUBWF  00,W
104FC:  BZ    10504
104FE:  BRA    10506
....................       case ECO : commandLe(); 
10500:  BRA    103D0
....................          break; 
10502:  BRA    10506
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
10504:  BRA    104A0
....................          break; 
....................    } 
10506:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
16DBA:  CALL   29C0
....................     
....................    user_quit = FALSE; 
16DBE:  CLRF   50
....................     
....................    if(arg > 0 && arg < 21) 
16DC0:  MOVF   48,F
16DC2:  BNZ   16DD0
16DC4:  MOVF   49,F
16DC6:  BNZ   16DD0
16DC8:  MOVF   4A,F
16DCA:  BNZ   16DD0
16DCC:  MOVF   4B,F
16DCE:  BZ    16E4C
16DD0:  MOVF   4B,F
16DD2:  BNZ   16E4C
16DD4:  MOVF   4A,F
16DD6:  BNZ   16E4C
16DD8:  MOVF   49,F
16DDA:  BNZ   16E4C
16DDC:  MOVF   48,W
16DDE:  SUBLW  14
16DE0:  BNC   16E4C
....................    { 
....................       macro = arg; 
16DE2:  MOVFF  48,886
....................       switch(nv_product){ 
16DE6:  MOVFF  2F,00
16DEA:  MOVF   30,W
16DEC:  MOVWF  03
16DEE:  BNZ   16DF4
16DF0:  MOVF   00,F
16DF2:  BZ    16E14
16DF4:  MOVF   03,W
16DF6:  BNZ   16DFE
16DF8:  MOVLW  01
16DFA:  SUBWF  00,W
16DFC:  BZ    16E14
16DFE:  MOVF   03,W
16E00:  BNZ   16E08
16E02:  MOVLW  03
16E04:  SUBWF  00,W
16E06:  BZ    16E14
16E08:  MOVF   03,W
16E0A:  BNZ   16E12
16E0C:  MOVLW  02
16E0E:  SUBWF  00,W
16E10:  BZ    16E3A
16E12:  BRA    16E4A
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
16E14:  MOVLW  01
16E16:  MOVLB  7
16E18:  ADDWF  xC3,W
16E1A:  MOVLB  8
16E1C:  MOVWF  x87
16E1E:  MOVLW  00
16E20:  MOVLB  7
16E22:  ADDWFC xC4,W
16E24:  MOVLB  8
16E26:  MOVWF  x88
16E28:  MOVFF  886,897
16E2C:  MOVWF  x99
16E2E:  MOVFF  887,898
16E32:  MOVLB  0
16E34:  CALL   153C2
....................             break; 
16E38:  BRA    16E4A
....................          case AWS : play_macro(macro,nv_port); 
16E3A:  MOVFF  886,897
16E3E:  MOVFF  2E,899
16E42:  MOVFF  2D,898
16E46:  CALL   153C2
....................             break; 
....................       } 
....................    }    
16E4A:  BRA    16ED2
....................    else if (arg == 0) 
16E4C:  MOVF   48,F
16E4E:  BNZ   16ECE
16E50:  MOVF   49,F
16E52:  BNZ   16ECE
16E54:  MOVF   4A,F
16E56:  BNZ   16ECE
16E58:  MOVF   4B,F
16E5A:  BNZ   16ECE
....................    { 
....................       //start watchdog at beginning of logging mode 
....................       //RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
16E5C:  BCF    F91.0
....................       spi_write(0x89); 
16E5E:  MOVF   FC9,W
16E60:  MOVLW  89
16E62:  MOVWF  FC9
16E64:  RRCF   FC7,W
16E66:  BNC   16E64
....................       spi_write(0b11111111); 
16E68:  MOVF   FC9,W
16E6A:  SETF   FC9
16E6C:  RRCF   FC7,W
16E6E:  BNC   16E6C
....................       spi_read(0x00); 
16E70:  MOVF   FC9,W
16E72:  CLRF   FC9
16E74:  RRCF   FC7,W
16E76:  BNC   16E74
....................       output_bit(RTC_CS, DISABLE); 
16E78:  BSF    F91.0
....................        
....................       MaxSamples=FALSE; 
16E7A:  CLRF   34
16E7C:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
16E7E:  MOVLW  28
16E80:  MOVLB  8
16E82:  MOVWF  x89
16E84:  MOVFF  33,88A
16E88:  MOVLB  0
16E8A:  CALL   3412
....................       if (LoggingReentry != TRUE) 
16E8E:  MOVLB  8
16E90:  DECFSZ x85,W
16E92:  BRA    16E96
16E94:  BRA    16EAE
....................       { 
....................          nv_sample = 0; 
16E96:  CLRF   22
16E98:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
16E9A:  MOVLW  16
16E9C:  MOVWF  xEE
16E9E:  MOVFF  22,8F0
16EA2:  MOVFF  21,8EF
16EA6:  MOVLB  0
16EA8:  CALL   4FD4
16EAC:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
16EAE:  CLRF   x85
....................       nv_macro_step = 0; 
16EB0:  CLRF   38
16EB2:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
16EB4:  MOVLW  3A
16EB6:  MOVWF  xEE
16EB8:  MOVFF  38,8F0
16EBC:  MOVFF  37,8EF
16EC0:  MOVLB  0
16EC2:  CALL   4FD4
....................       user_quit = auto_sample_ready(); 
16EC6:  BRA    16BB8
16EC8:  MOVFF  01,50
....................    } 
16ECC:  BRA    16ED2
....................    else cmd_arg(); 
16ECE:  CALL   B2FE
....................     
....................    busy_clear(); 
16ED2:  CALL   AEB0
16ED6:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
16ED8:  MOVF   48,F
16EDA:  BNZ   16EE8
16EDC:  MOVF   49,F
16EDE:  BNZ   16EE8
16EE0:  MOVF   4A,F
16EE2:  BNZ   16EE8
16EE4:  MOVF   4B,F
16EE6:  BZ    16F1C
16EE8:  MOVF   4B,F
16EEA:  BNZ   16F1C
16EEC:  MOVF   4A,F
16EEE:  BNZ   16F1C
16EF0:  MOVF   49,W
16EF2:  SUBLW  0D
16EF4:  BNC   16F1C
16EF6:  BNZ   16EFE
16EF8:  MOVF   48,W
16EFA:  SUBLW  AC
16EFC:  BNC   16F1C
....................       nv_max_samples = arg; 
16EFE:  MOVFF  49,28
16F02:  MOVFF  48,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
16F06:  MOVLW  18
16F08:  MOVLB  8
16F0A:  MOVWF  xEE
16F0C:  MOVFF  28,8F0
16F10:  MOVFF  27,8EF
16F14:  MOVLB  0
16F16:  CALL   4FD4
....................    } 
16F1A:  BRA    16F62
....................    else if(arg == 0) { 
16F1C:  MOVF   48,F
16F1E:  BNZ   16F5E
16F20:  MOVF   49,F
16F22:  BNZ   16F5E
16F24:  MOVF   4A,F
16F26:  BNZ   16F5E
16F28:  MOVF   4B,F
16F2A:  BNZ   16F5E
....................       nv_sample = 0; 
16F2C:  CLRF   22
16F2E:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16F30:  MOVLW  16
16F32:  MOVLB  8
16F34:  MOVWF  xEE
16F36:  MOVFF  22,8F0
16F3A:  MOVFF  21,8EF
16F3E:  MOVLB  0
16F40:  CALL   4FD4
....................       nv_macro_step = 0; 
16F44:  CLRF   38
16F46:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16F48:  MOVLW  3A
16F4A:  MOVLB  8
16F4C:  MOVWF  xEE
16F4E:  MOVFF  38,8F0
16F52:  MOVFF  37,8EF
16F56:  MOVLB  0
16F58:  CALL   4FD4
....................    } 
16F5C:  BRA    16F62
....................    else cmd_arg(); 
16F5E:  CALL   B2FE
16F62:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
17080:  DECFSZ 48,W
17082:  BRA    1709C
17084:  MOVF   49,F
17086:  BNZ   1709C
17088:  MOVF   4A,F
1708A:  BNZ   1709C
1708C:  MOVF   4B,F
1708E:  BNZ   1709C
....................    { 
....................       bus_on(); 
17090:  CALL   D370
....................       open_pipe(); 
17094:  BRA    16F74
....................       bus_off(); 
17096:  CALL   D394
....................    } 
1709A:  BRA    170A0
....................    else cmd_arg(); 
1709C:  CALL   B2FE
170A0:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
1715E:  MOVLB  7
17160:  DECFSZ x41,W
17162:  BRA    17166
17164:  CLRF   x40
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
17166:  MOVF   48,F
17168:  BNZ   17178
1716A:  MOVF   49,F
1716C:  BNZ   17178
1716E:  MOVF   4A,F
17170:  BNZ   17178
17172:  MOVF   4B,F
17174:  BTFSC  FD8.2
17176:  BRA    17240
17178:  BCF    FD8.0
1717A:  RLCF   x40,W
1717C:  CLRF   03
1717E:  ADDLW  62
17180:  MOVWF  FE9
17182:  MOVLW  07
17184:  ADDWFC 03,W
17186:  MOVWF  FEA
17188:  MOVFF  FEC,03
1718C:  MOVF   FED,F
1718E:  MOVFF  FEF,01
17192:  MOVF   4B,F
17194:  BNZ   17240
17196:  MOVF   4A,F
17198:  BNZ   17240
1719A:  MOVF   49,W
1719C:  SUBWF  03,W
1719E:  BNC   17240
171A0:  BNZ   171A8
171A2:  MOVF   48,W
171A4:  SUBWF  01,W
171A6:  BNC   17240
....................       if(e_mode[motor]==2){     // if port mode then move 
171A8:  BCF    FD8.0
171AA:  RLCF   x40,W
171AC:  CLRF   03
171AE:  ADDLW  66
171B0:  MOVWF  FE9
171B2:  MOVLW  07
171B4:  ADDWFC 03,W
171B6:  MOVWF  FEA
171B8:  MOVFF  FEC,886
171BC:  MOVF   FED,F
171BE:  MOVFF  FEF,885
171C2:  MOVLB  8
171C4:  MOVF   x85,W
171C6:  SUBLW  02
171C8:  BNZ   17236
171CA:  MOVF   x86,F
171CC:  BNZ   17236
....................          switch (nv_product){ 
171CE:  MOVF   2F,W
171D0:  MOVWF  00
171D2:  MOVF   30,W
171D4:  MOVWF  03
171D6:  MOVF   03,W
171D8:  BNZ   171E2
171DA:  MOVF   00,F
171DC:  MOVLB  0
171DE:  BZ    17200
171E0:  MOVLB  8
171E2:  MOVF   03,W
171E4:  BNZ   171F0
171E6:  MOVLW  01
171E8:  SUBWF  00,W
171EA:  MOVLB  0
171EC:  BZ    17212
171EE:  MOVLB  8
171F0:  MOVF   03,W
171F2:  BNZ   171FE
171F4:  MOVLW  03
171F6:  SUBWF  00,W
171F8:  MOVLB  0
171FA:  BZ    17224
171FC:  MOVLB  8
171FE:  BRA    17234
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
17200:  MOVLW  01
17202:  MOVLB  8
17204:  MOVWF  x85
17206:  CLRF   x86
17208:  MOVWF  x87
1720A:  MOVLB  0
1720C:  RCALL  170A4
....................                break;             
1720E:  MOVLB  8
17210:  BRA    17234
....................             case WMS4: command_move(0,0,1); 
17212:  MOVLB  8
17214:  CLRF   x85
17216:  CLRF   x86
17218:  MOVLW  01
1721A:  MOVWF  x87
1721C:  MOVLB  0
1721E:  RCALL  170A4
....................                break; 
17220:  MOVLB  8
17222:  BRA    17234
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
17224:  MOVLB  8
17226:  CLRF   x85
17228:  CLRF   x86
1722A:  MOVLW  01
1722C:  MOVWF  x87
1722E:  MOVLB  0
17230:  RCALL  170A4
....................                break; 
17232:  MOVLB  8
....................          } 
....................       } 
17234:  BRA    1723E
....................       else cmd_err();                           // else error 
17236:  MOVLB  0
17238:  CALL   BFC0
1723C:  MOVLB  8
....................    } 
1723E:  BRA    17248
....................    else cmd_arg(); 
17240:  MOVLB  0
17242:  CALL   B2FE
17246:  MOVLB  8
17248:  MOVLB  0
1724A:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
1724C:  MOVF   4B,F
1724E:  BNZ   1727C
17250:  MOVF   4A,F
17252:  BNZ   1727C
17254:  MOVF   49,F
17256:  BNZ   1727C
17258:  MOVF   48,W
1725A:  SUBLW  30
1725C:  BNC   1727C
....................       nv_port = arg; 
1725E:  MOVFF  49,2E
17262:  MOVFF  48,2D
....................       write16(ADDR_PORT, nv_port); 
17266:  MOVLW  24
17268:  MOVLB  8
1726A:  MOVWF  xEE
1726C:  MOVFF  2E,8F0
17270:  MOVFF  2D,8EF
17274:  MOVLB  0
17276:  CALL   4FD4
....................    } 
1727A:  BRA    17280
....................    else cmd_arg(); 
1727C:  CALL   B2FE
17280:  GOTO   172BC (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
17284:  MOVF   2F,W
17286:  MOVWF  00
17288:  MOVF   30,W
1728A:  MOVWF  03
1728C:  BNZ   17292
1728E:  MOVF   00,F
17290:  BZ    172B2
17292:  MOVF   03,W
17294:  BNZ   1729C
17296:  MOVLW  01
17298:  SUBWF  00,W
1729A:  BZ    172B6
1729C:  MOVF   03,W
1729E:  BNZ   172A6
172A0:  MOVLW  03
172A2:  SUBWF  00,W
172A4:  BZ    172B6
172A6:  MOVF   03,W
172A8:  BNZ   172B0
172AA:  MOVLW  02
172AC:  SUBWF  00,W
172AE:  BZ    172BA
172B0:  BRA    172BC
....................       case ECO : commandPe(); 
172B2:  RCALL  1715E
....................          break; 
172B4:  BRA    172BC
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
172B6:  RCALL  1715E
....................          break; 
172B8:  BRA    172BC
....................       case AWS : commandPa(); 
172BA:  BRA    1724C
....................          break;          
....................    } 
172BC:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
17308:  MOVLB  4
1730A:  DECFSZ xB6,W
1730C:  BRA    17338
....................     
....................       if(arg<33){ 
1730E:  MOVF   4B,F
17310:  BNZ   17330
17312:  MOVF   4A,F
17314:  BNZ   17330
17316:  MOVF   49,F
17318:  BNZ   17330
1731A:  MOVF   48,W
1731C:  SUBLW  20
1731E:  BNC   17330
....................          valve=arg;    
17320:  MOVFF  48,885
....................          sol_switch(valve); 
17324:  MOVFF  885,8B5
17328:  MOVLB  0
1732A:  CALL   1456C
....................       }  
1732E:  BRA    17336
....................       else cmd_arg(); 
17330:  MOVLB  0
17332:  CALL   B2FE
....................    } 
17336:  BRA    1733E
....................    else cmd_err(); 
17338:  MOVLB  0
1733A:  CALL   BFC0
1733E:  GOTO   1736E (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
172C0:  MOVF   48,F
172C2:  BNZ   172D0
172C4:  MOVF   49,F
172C6:  BNZ   172D0
172C8:  MOVF   4A,F
172CA:  BNZ   172D0
172CC:  MOVF   4B,F
172CE:  BZ    17300
172D0:  MOVF   4B,F
172D2:  BNZ   17300
172D4:  MOVF   4A,F
172D6:  BNZ   17300
172D8:  MOVF   49,F
172DA:  BNZ   17300
172DC:  MOVF   48,W
172DE:  SUBLW  32
172E0:  BNC   17300
....................       nv_port = arg; 
172E2:  MOVFF  49,2E
172E6:  MOVFF  48,2D
....................       write16(ADDR_SAMPLE, nv_port); 
172EA:  MOVLW  16
172EC:  MOVLB  8
172EE:  MOVWF  xEE
172F0:  MOVFF  2E,8F0
172F4:  MOVFF  2D,8EF
172F8:  MOVLB  0
172FA:  CALL   4FD4
....................    } 
172FE:  BRA    17304
....................    else cmd_arg(); 
17300:  CALL   B2FE
17304:  GOTO   1736E (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
17342:  MOVF   2F,W
17344:  MOVWF  00
17346:  MOVF   30,W
17348:  MOVWF  03
1734A:  BNZ   17352
1734C:  MOVLW  01
1734E:  SUBWF  00,W
17350:  BZ    17368
17352:  MOVF   03,W
17354:  BNZ   1735C
17356:  MOVLW  03
17358:  SUBWF  00,W
1735A:  BZ    17368
1735C:  MOVF   03,W
1735E:  BNZ   17366
17360:  MOVLW  02
17362:  SUBWF  00,W
17364:  BZ    1736C
17366:  BRA    1736E
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
17368:  BRA    172C0
....................          break; 
1736A:  BRA    1736E
....................       case AWS : commandQa(); 
1736C:  BRA    17308
....................          break;          
....................    } 
1736E:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
17372:  CALL   29C0
....................     
....................    nv_macro_step = 0; 
17376:  CLRF   38
17378:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
1737A:  MOVLW  3A
1737C:  MOVLB  8
1737E:  MOVWF  xEE
17380:  MOVFF  38,8F0
17384:  MOVFF  37,8EF
17388:  MOVLB  0
1738A:  CALL   4FD4
....................     
....................    user_quit = FALSE; 
1738E:  CLRF   50
....................     
....................    if (arg > 0 && arg < 3501){ 
17390:  MOVF   48,F
17392:  BNZ   173A0
17394:  MOVF   49,F
17396:  BNZ   173A0
17398:  MOVF   4A,F
1739A:  BNZ   173A0
1739C:  MOVF   4B,F
1739E:  BZ    1744C
173A0:  MOVF   4B,F
173A2:  BNZ   1744C
173A4:  MOVF   4A,F
173A6:  BNZ   1744C
173A8:  MOVF   49,W
173AA:  SUBLW  0D
173AC:  BNC   1744C
173AE:  BNZ   173B6
173B0:  MOVF   48,W
173B2:  SUBLW  AC
173B4:  BNC   1744C
....................       samples = arg; 
173B6:  MOVFF  49,887
173BA:  MOVFF  48,886
....................       user_quit = FALSE; 
173BE:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
173C0:  MOVLB  8
173C2:  CLRF   x89
173C4:  CLRF   x88
173C6:  MOVF   x89,W
173C8:  SUBWF  x87,W
173CA:  BNC   1744A
173CC:  BNZ   173D4
173CE:  MOVF   x86,W
173D0:  SUBWF  x88,W
173D2:  BC    1744A
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
173D4:  MOVLW  01
173D6:  ADDWF  x88,W
173D8:  MOVWF  x8A
173DA:  MOVLW  00
173DC:  ADDWFC x89,W
173DE:  MOVWF  x8B
173E0:  MOVLW  B2
173E2:  MOVWF  FF6
173E4:  MOVLW  26
173E6:  MOVWF  FF7
173E8:  MOVLW  00
173EA:  MOVWF  FF8
173EC:  CLRF   1B
173EE:  BTFSC  FF2.7
173F0:  BSF    1B.7
173F2:  BCF    FF2.7
173F4:  MOVLW  05
173F6:  MOVLB  A
173F8:  MOVWF  x40
173FA:  MOVLB  0
173FC:  CALL   101C
17400:  BTFSC  1B.7
17402:  BSF    FF2.7
17404:  MOVLW  09
17406:  MOVWF  FE9
17408:  CLRF   1B
1740A:  BTFSC  FF2.7
1740C:  BSF    1B.7
1740E:  BCF    FF2.7
17410:  MOVFF  88B,A41
17414:  MOVFF  88A,A40
17418:  CALL   119E
1741C:  BTFSC  1B.7
1741E:  BSF    FF2.7
17420:  MOVLW  0D
17422:  BTFSS  F9E.4
17424:  BRA    17422
17426:  MOVWF  FAD
17428:  MOVLW  0A
1742A:  BTFSS  F9E.4
1742C:  BRA    1742A
1742E:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
17430:  CALL   15FA8
17434:  MOVFF  01,885
....................          if (macro_cmd == ';') break; 
17438:  MOVLB  8
1743A:  MOVF   x85,W
1743C:  SUBLW  3B
1743E:  BTFSC  FD8.2
17440:  BRA    1744A
17442:  INCF   x88,F
17444:  BTFSC  FD8.2
17446:  INCF   x89,F
17448:  BRA    173C6
1744A:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
1744C:  CALL   AEB0
17450:  GOTO   17610 (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
17454:  MOVF   48,F
17456:  BNZ   17464
17458:  MOVF   49,F
1745A:  BNZ   17464
1745C:  MOVF   4A,F
1745E:  BNZ   17464
17460:  MOVF   4B,F
17462:  BZ    174A8
17464:  MOVF   4B,F
17466:  BNZ   174A8
17468:  MOVF   4A,F
1746A:  BNZ   174A8
1746C:  MOVF   49,F
1746E:  BNZ   174A8
17470:  MOVF   48,W
17472:  SUBLW  2F
17474:  BNC   174A8
....................       n=arg; 
17476:  MOVFF  48,888
....................       port=2; 
1747A:  MOVLB  8
1747C:  CLRF   x86
1747E:  MOVLW  02
17480:  MOVWF  x85
....................       for(i=0;i<n;++i){ 
17482:  CLRF   x87
17484:  MOVF   x88,W
17486:  SUBWF  x87,W
17488:  BC    174A4
....................          play_wms_hard_macro(port); 
1748A:  MOVFF  886,88A
1748E:  MOVFF  885,889
17492:  MOVLB  0
17494:  CALL   D800
....................          ++port; 
17498:  MOVLB  8
1749A:  INCF   x85,F
1749C:  BTFSC  FD8.2
1749E:  INCF   x86,F
174A0:  INCF   x87,F
174A2:  BRA    17484
....................       } 
....................    } 
174A4:  BRA    174AE
174A6:  MOVLB  0
....................    else cmd_arg(); 
174A8:  CALL   B2FE
174AC:  MOVLB  8
174AE:  MOVLB  0
174B0:  GOTO   17610 (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
174B4:  CALL   29C0
....................     
....................    nv_macro_step = 0; 
174B8:  CLRF   38
174BA:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
174BC:  MOVLW  3A
174BE:  MOVLB  8
174C0:  MOVWF  xEE
174C2:  MOVFF  38,8F0
174C6:  MOVFF  37,8EF
174CA:  MOVLB  0
174CC:  CALL   4FD4
....................     
....................    user_quit = FALSE; 
174D0:  CLRF   50
....................     
....................    if (arg > 0 && arg < 241){ 
174D2:  MOVF   48,F
174D4:  BNZ   174E4
174D6:  MOVF   49,F
174D8:  BNZ   174E4
174DA:  MOVF   4A,F
174DC:  BNZ   174E4
174DE:  MOVF   4B,F
174E0:  BTFSC  FD8.2
174E2:  BRA    175D0
174E4:  MOVF   4B,F
174E6:  BTFSS  FD8.2
174E8:  BRA    175D0
174EA:  MOVF   4A,F
174EC:  BTFSS  FD8.2
174EE:  BRA    175D0
174F0:  MOVF   49,F
174F2:  BTFSS  FD8.2
174F4:  BRA    175D0
174F6:  MOVF   48,W
174F8:  SUBLW  F0
174FA:  BNC   175D0
....................       samples = arg; 
174FC:  MOVFF  49,887
17500:  MOVFF  48,886
....................       user_quit = FALSE; 
17504:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
17506:  MOVLB  8
17508:  CLRF   x89
1750A:  CLRF   x88
1750C:  MOVF   x89,W
1750E:  SUBWF  x87,W
17510:  BNC   175CE
17512:  BNZ   1751A
17514:  MOVF   x86,W
17516:  SUBWF  x88,W
17518:  BC    175CE
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
1751A:  MOVLW  01
1751C:  ADDWF  x88,W
1751E:  MOVWF  x8A
17520:  MOVLW  00
17522:  ADDWFC x89,W
17524:  MOVWF  x8B
17526:  MOVLW  C0
17528:  MOVWF  FF6
1752A:  MOVLW  26
1752C:  MOVWF  FF7
1752E:  MOVLW  00
17530:  MOVWF  FF8
17532:  CLRF   1B
17534:  BTFSC  FF2.7
17536:  BSF    1B.7
17538:  BCF    FF2.7
1753A:  MOVLW  05
1753C:  MOVLB  A
1753E:  MOVWF  x40
17540:  MOVLB  0
17542:  CALL   101C
17546:  BTFSC  1B.7
17548:  BSF    FF2.7
1754A:  MOVLW  09
1754C:  MOVWF  FE9
1754E:  CLRF   1B
17550:  BTFSC  FF2.7
17552:  BSF    1B.7
17554:  BCF    FF2.7
17556:  MOVFF  88B,A41
1755A:  MOVFF  88A,A40
1755E:  CALL   119E
17562:  BTFSC  1B.7
17564:  BSF    FF2.7
17566:  MOVLW  0D
17568:  BTFSS  F9E.4
1756A:  BRA    17568
1756C:  MOVWF  FAD
1756E:  MOVLW  0A
17570:  BTFSS  F9E.4
17572:  BRA    17570
17574:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
17576:  MOVLW  01
17578:  MOVLB  8
1757A:  ADDWF  x88,W
1757C:  MOVWF  x8A
1757E:  MOVLW  00
17580:  ADDWFC x89,W
17582:  MOVWF  x8B
17584:  MOVWF  x8D
17586:  MOVFF  88A,88C
1758A:  MOVLB  0
1758C:  CALL   1685E
17590:  MOVFF  01,885
....................          ++nv_sample;                     // increment sample number 
17594:  INCF   21,F
17596:  BTFSC  FD8.2
17598:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
1759A:  MOVLW  16
1759C:  MOVLB  8
1759E:  MOVWF  xEE
175A0:  MOVFF  22,8F0
175A4:  MOVFF  21,8EF
175A8:  MOVLB  0
175AA:  CALL   4FD4
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
175AE:  MOVF   27,W
175B0:  SUBWF  21,W
175B2:  BNZ   175BA
175B4:  MOVF   28,W
175B6:  SUBWF  22,W
175B8:  BZ    175C2
175BA:  MOVLB  8
175BC:  MOVF   x85,W
175BE:  SUBLW  3B
175C0:  BNZ   175C6
175C2:  MOVLB  8
175C4:  BRA    175CE
175C6:  INCF   x88,F
175C8:  BTFSC  FD8.2
175CA:  INCF   x89,F
175CC:  BRA    1750C
175CE:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
175D0:  CALL   AEB0
175D4:  GOTO   17610 (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
175D8:  MOVF   2F,W
175DA:  MOVWF  00
175DC:  MOVF   30,W
175DE:  MOVWF  03
175E0:  BNZ   175E6
175E2:  MOVF   00,F
175E4:  BZ    17606
175E6:  MOVF   03,W
175E8:  BNZ   175F0
175EA:  MOVLW  01
175EC:  SUBWF  00,W
175EE:  BZ    1760A
175F0:  MOVF   03,W
175F2:  BNZ   175FA
175F4:  MOVLW  03
175F6:  SUBWF  00,W
175F8:  BZ    1760A
175FA:  MOVF   03,W
175FC:  BNZ   17604
175FE:  MOVLW  02
17600:  SUBWF  00,W
17602:  BZ    1760E
17604:  BRA    17610
....................       case ECO : commandRe(); 
17606:  BRA    17372
....................          break; 
17608:  BRA    17610
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
1760A:  BRA    17454
....................          break; 
1760C:  BRA    17610
....................       case AWS : commandRa(); 
1760E:  BRA    174B4
....................          break;          
....................    } 
17610:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
17614:  CALL   29C0
....................     
....................    switch(arg){ 
17618:  MOVFF  48,00
1761C:  MOVF   49,W
1761E:  MOVWF  03
17620:  BNZ   17628
17622:  MOVLW  01
17624:  SUBWF  00,W
17626:  BZ    17634
17628:  MOVF   03,W
1762A:  BNZ   17632
1762C:  MOVLW  02
1762E:  SUBWF  00,W
17630:  BZ    17678
17632:  BRA    17688
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
17634:  DECFSZ 45,W
17636:  BRA    1764C
17638:  MOVF   46,F
1763A:  BNZ   1764C
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
1763C:  MOVLB  8
1763E:  CLRF   xC2
17640:  MOVLW  01
17642:  MOVWF  xC3
17644:  MOVLB  0
17646:  CALL   1372E
....................       } 
1764A:  BRA    17676
....................       else if(nv_det_type==2 || nv_det_type==3) 
1764C:  MOVF   45,W
1764E:  SUBLW  02
17650:  BNZ   17656
17652:  MOVF   46,F
17654:  BZ    17660
17656:  MOVF   45,W
17658:  SUBLW  03
1765A:  BNZ   17676
1765C:  MOVF   46,F
1765E:  BNZ   17676
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
17660:  MOVLB  8
17662:  CLRF   xC3
17664:  MOVLW  C8
17666:  MOVWF  xC2
17668:  CLRF   xC4
1766A:  MOVLW  01
1766C:  MOVWF  xC5
1766E:  CLRF   xC6
17670:  MOVLB  0
17672:  CALL   100B6
....................       } 
....................       break;                                                        //200 scans,don't store,display 
17676:  BRA    1768C
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
17678:  MOVLB  8
1767A:  CLRF   xC2
1767C:  MOVLW  01
1767E:  MOVWF  xC3
17680:  MOVLB  0
17682:  CALL   13A30
....................       break; 
17686:  BRA    1768C
....................    default: cmd_arg(); 
17688:  CALL   B2FE
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
1768C:  CALL   AEB0
17690:  GOTO   1773C (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
17694:  MOVF   4B,F
17696:  BNZ   176C8
17698:  MOVF   4A,F
1769A:  BNZ   176C8
1769C:  MOVF   49,W
1769E:  SUBLW  04
176A0:  BNC   176C8
176A2:  BNZ   176AA
176A4:  MOVF   48,W
176A6:  SUBLW  00
176A8:  BNC   176C8
....................       nv_sample = arg; 
176AA:  MOVFF  49,22
176AE:  MOVFF  48,21
....................       write16(ADDR_SAMPLE, nv_sample); 
176B2:  MOVLW  16
176B4:  MOVLB  8
176B6:  MOVWF  xEE
176B8:  MOVFF  22,8F0
176BC:  MOVFF  21,8EF
176C0:  MOVLB  0
176C2:  CALL   4FD4
....................    } 
176C6:  BRA    176CC
....................    else cmd_arg(); 
176C8:  CALL   B2FE
176CC:  GOTO   1773C (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
176D0:  MOVF   4B,F
176D2:  BNZ   176FC
176D4:  MOVF   4A,F
176D6:  BNZ   176FC
176D8:  MOVF   49,W
176DA:  SUBLW  01
176DC:  BNC   176FC
176DE:  BNZ   176E6
176E0:  MOVF   48,W
176E2:  SUBLW  02
176E4:  BNC   176FC
....................       setting = arg; 
176E6:  MOVFF  49,886
176EA:  MOVFF  48,885
....................       sol_switch_cmd(setting); 
176EE:  MOVFF  886,8B7
176F2:  MOVFF  885,8B6
176F6:  CALL   144B6
....................    } 
176FA:  BRA    17700
....................    else cmd_arg(); 
176FC:  CALL   B2FE
17700:  GOTO   1773C (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
17704:  MOVF   2F,W
17706:  MOVWF  00
17708:  MOVF   30,W
1770A:  MOVWF  03
1770C:  BNZ   17712
1770E:  MOVF   00,F
17710:  BZ    17732
17712:  MOVF   03,W
17714:  BNZ   1771C
17716:  MOVLW  01
17718:  SUBWF  00,W
1771A:  BZ    17736
1771C:  MOVF   03,W
1771E:  BNZ   17726
17720:  MOVLW  03
17722:  SUBWF  00,W
17724:  BZ    17736
17726:  MOVF   03,W
17728:  BNZ   17730
1772A:  MOVLW  02
1772C:  SUBWF  00,W
1772E:  BZ    1773A
17730:  BRA    1773C
....................       case ECO : commandSe(); 
17732:  BRA    17614
....................          break; 
17734:  BRA    1773C
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
17736:  BRA    17694
....................          break; 
17738:  BRA    1773C
....................       case AWS : commandSa(); 
1773A:  BRA    176D0
....................          break;          
....................    } 
1773C:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
17CA2:  MOVLW  CE
17CA4:  MOVWF  FF6
17CA6:  MOVLW  26
17CA8:  MOVWF  FF7
17CAA:  MOVLW  00
17CAC:  MOVWF  FF8
17CAE:  CLRF   1B
17CB0:  BTFSC  FF2.7
17CB2:  BSF    1B.7
17CB4:  BCF    FF2.7
17CB6:  CALL   0E46
17CBA:  BTFSC  1B.7
17CBC:  BSF    FF2.7
....................    fputc('>',COM_A); 
17CBE:  MOVLW  3E
17CC0:  CALL   AEB8
....................    RTCfmt=fgetc(COM_A); 
17CC4:  CALL   0E30
17CC8:  MOVFF  01,4F
....................    if (com_echo == TRUE) 
17CCC:  DECFSZ 4C,W
17CCE:  BRA    17CD6
....................       { 
....................       fputc(RTCfmt,COM_A); 
17CD0:  MOVF   4F,W
17CD2:  CALL   AEB8
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
17CD6:  MOVLW  30
17CD8:  SUBWF  4F,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
17CDA:  MOVF   4F,W
17CDC:  SUBLW  01
17CDE:  BNC   17D14
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
17CE0:  MOVLW  FA
17CE2:  MOVWF  FF6
17CE4:  MOVLW  26
17CE6:  MOVWF  FF7
17CE8:  MOVLW  00
17CEA:  MOVWF  FF8
17CEC:  CALL   AE86
17CF0:  MOVLW  0D
17CF2:  BTFSS  F9E.4
17CF4:  BRA    17CF2
17CF6:  MOVWF  FAD
17CF8:  MOVLW  0A
17CFA:  BTFSS  F9E.4
17CFC:  BRA    17CFA
17CFE:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
17D00:  MOVLW  1A
17D02:  MOVLB  8
17D04:  MOVWF  xEE
17D06:  CLRF   xF0
17D08:  MOVFF  4F,8EF
17D0C:  MOVLB  0
17D0E:  CALL   4FD4
....................       }  
17D12:  BRA    17D18
....................    else cmd_arg(); 
17D14:  CALL   B2FE
....................     
....................    if(arg == 1) 
17D18:  DECFSZ 48,W
17D1A:  BRA    17D2C
17D1C:  MOVF   49,F
17D1E:  BNZ   17D2C
17D20:  MOVF   4A,F
17D22:  BNZ   17D2C
17D24:  MOVF   4B,F
17D26:  BNZ   17D2C
....................    { 
....................       RTC_Set(); 
17D28:  BRA    17B58
....................    } 
17D2A:  BRA    17D30
....................    else cmd_arg(); 
17D2C:  CALL   B2FE
17D30:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
186AA:  MOVF   4B,F
186AC:  BNZ   186C8
186AE:  MOVF   4A,F
186B0:  BNZ   186C8
186B2:  MOVF   49,F
186B4:  BNZ   186C8
186B6:  MOVF   48,W
186B8:  SUBLW  14
186BA:  BNC   186C8
....................       macro = arg; 
186BC:  MOVFF  48,885
....................       upload_macro(macro);    
186C0:  MOVFF  885,886
186C4:  BRA    183F8
....................    }    
186C6:  BRA    186E4
....................    else if (arg == 5525){ 
186C8:  MOVF   48,W
186CA:  SUBLW  95
186CC:  BNZ   186E0
186CE:  MOVF   49,W
186D0:  SUBLW  15
186D2:  BNZ   186E0
186D4:  MOVF   4A,F
186D6:  BNZ   186E0
186D8:  MOVF   4B,F
186DA:  BNZ   186E0
....................       write_blank_macros(); 
186DC:  BRA    1852E
....................    } 
186DE:  BRA    186E4
....................    else cmd_arg(); 
186E0:  CALL   B2FE
186E4:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
18802:  MOVF   4B,F
18804:  BNZ   18820
18806:  MOVF   4A,F
18808:  BNZ   18820
1880A:  MOVF   49,F
1880C:  BNZ   18820
1880E:  MOVF   48,W
18810:  SUBLW  14
18812:  BNC   18820
....................       macro = arg;  
18814:  MOVFF  48,885
....................       read_macro(macro); 
18818:  MOVFF  885,886
1881C:  BRA    1879C
....................    }    
1881E:  BRA    18824
....................    else cmd_arg(); 
18820:  CALL   B2FE
18824:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
18976:  DECFSZ 48,W
18978:  BRA    18992
1897A:  MOVF   49,F
1897C:  BNZ   18992
1897E:  MOVF   4A,F
18980:  BNZ   18992
18982:  MOVF   4B,F
18984:  BNZ   18992
....................       //fprintf(COM_A,"1\r\n"); 
....................       RTC_alarm(); 
18986:  BRA    18828
....................       //fprintf(COM_A,"2\r\n"); 
....................       RTC_late(); 
18988:  CALL   15780
....................       //fprintf(COM_A,"3\r\n"); 
....................       RTC_alarm_status(); 
1898C:  CALL   15C46
....................       //fprintf(COM_A,"4\r\n"); 
....................    } 
18990:  BRA    18996
....................    else cmd_arg(); 
18992:  CALL   B2FE
18996:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
1899A:  MOVF   48,W
1899C:  MOVWF  00
1899E:  MOVF   49,W
189A0:  MOVWF  03
189A2:  BNZ   189A8
189A4:  MOVF   00,F
189A6:  BZ    189DC
189A8:  MOVF   03,W
189AA:  BNZ   189B2
189AC:  MOVLW  02
189AE:  SUBWF  00,W
189B0:  BZ    189DC
189B2:  MOVF   03,W
189B4:  BNZ   189BC
189B6:  MOVLW  03
189B8:  SUBWF  00,W
189BA:  BZ    189DC
189BC:  MOVF   03,W
189BE:  BNZ   189C6
189C0:  MOVLW  04
189C2:  SUBWF  00,W
189C4:  BZ    189DC
189C6:  MOVF   03,W
189C8:  BNZ   189D0
189CA:  MOVLW  05
189CC:  SUBWF  00,W
189CE:  BZ    189DC
189D0:  MOVF   03,W
189D2:  BNZ   189DA
189D4:  MOVLW  06
189D6:  SUBWF  00,W
189D8:  BZ    189DC
189DA:  BRA    189FA
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
189DC:  MOVFF  49,20
189E0:  MOVFF  48,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
189E4:  MOVLW  1C
189E6:  MOVLB  8
189E8:  MOVWF  xEE
189EA:  MOVFF  20,8F0
189EE:  MOVFF  1F,8EF
189F2:  MOVLB  0
189F4:  CALL   4FD4
....................          break; 
189F8:  BRA    189FE
....................       default: cmd_arg(); 
189FA:  CALL   B2FE
....................          break; 
....................    } 
189FE:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
18A02:  CALL   29C0
....................     
....................    switch(arg){ 
18A06:  MOVFF  48,00
18A0A:  MOVF   49,W
18A0C:  MOVWF  03
18A0E:  BNZ   18A14
18A10:  MOVF   00,F
18A12:  BZ    18A98
18A14:  MOVF   03,W
18A16:  BNZ   18A1E
18A18:  MOVLW  0A
18A1A:  SUBWF  00,W
18A1C:  BZ    18A98
18A1E:  MOVF   03,W
18A20:  BNZ   18A28
18A22:  MOVLW  01
18A24:  SUBWF  00,W
18A26:  BZ    18AA0
18A28:  MOVF   03,W
18A2A:  BNZ   18A32
18A2C:  MOVLW  0B
18A2E:  SUBWF  00,W
18A30:  BZ    18AA0
18A32:  MOVF   03,W
18A34:  BNZ   18A3C
18A36:  MOVLW  14
18A38:  SUBWF  00,W
18A3A:  BZ    18AAA
18A3C:  MOVF   03,W
18A3E:  BNZ   18A46
18A40:  MOVLW  15
18A42:  SUBWF  00,W
18A44:  BZ    18AB0
18A46:  MOVF   03,W
18A48:  BNZ   18A50
18A4A:  MOVLW  1E
18A4C:  SUBWF  00,W
18A4E:  BZ    18AB6
18A50:  MOVF   03,W
18A52:  BNZ   18A5A
18A54:  MOVLW  1F
18A56:  SUBWF  00,W
18A58:  BZ    18ABC
18A5A:  MOVF   03,W
18A5C:  BNZ   18A64
18A5E:  MOVLW  28
18A60:  SUBWF  00,W
18A62:  BZ    18AC2
18A64:  MOVF   03,W
18A66:  BNZ   18A6E
18A68:  MOVLW  29
18A6A:  SUBWF  00,W
18A6C:  BZ    18AC8
18A6E:  MOVF   03,W
18A70:  BNZ   18A78
18A72:  MOVLW  32
18A74:  SUBWF  00,W
18A76:  BZ    18ACE
18A78:  MOVF   03,W
18A7A:  BNZ   18A82
18A7C:  MOVLW  33
18A7E:  SUBWF  00,W
18A80:  BZ    18AD4
18A82:  MOVF   03,W
18A84:  BNZ   18A8C
18A86:  MOVLW  3C
18A88:  SUBWF  00,W
18A8A:  BZ    18ADA
18A8C:  MOVF   03,W
18A8E:  BNZ   18A96
18A90:  MOVLW  3D
18A92:  SUBWF  00,W
18A94:  BZ    18AE8
18A96:  BRA    18AFA
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
18A98:  BCF    F90.7
....................                bus_pwr_status=0; 
18A9A:  MOVLB  4
18A9C:  CLRF   xB6
....................          break; 
18A9E:  BRA    18B00
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18AA0:  BSF    F90.7
....................                bus_pwr_status=1; 
18AA2:  MOVLW  01
18AA4:  MOVLB  4
18AA6:  MOVWF  xB6
....................          break; 
18AA8:  BRA    18B00
....................       case 20: output_bit(VMOT,OFF); 
18AAA:  BCF    F8E.1
....................          break; 
18AAC:  MOVLB  4
18AAE:  BRA    18B00
....................       case 21: output_bit(VMOT,ON); 
18AB0:  BSF    F8E.1
....................          break; 
18AB2:  MOVLB  4
18AB4:  BRA    18B00
....................       case 30: output_bit(VENC1,OFF); 
18AB6:  BCF    F8E.6
....................          break; 
18AB8:  MOVLB  4
18ABA:  BRA    18B00
....................       case 31: output_bit(VENC1,ON); 
18ABC:  BSF    F8E.6
....................          break; 
18ABE:  MOVLB  4
18AC0:  BRA    18B00
....................       case 40: output_bit(VENC2,OFF); 
18AC2:  BCF    F8E.7
....................          break; 
18AC4:  MOVLB  4
18AC6:  BRA    18B00
....................       case 41: output_bit(VENC2,ON); 
18AC8:  BSF    F8E.7
....................          break; 
18ACA:  MOVLB  4
18ACC:  BRA    18B00
....................       case 50: output_bit(VHBRDG,OFF); 
18ACE:  BCF    F8E.2
....................          break; 
18AD0:  MOVLB  4
18AD2:  BRA    18B00
....................       case 51: output_bit(VHBRDG,ON); 
18AD4:  BSF    F8E.2
....................          break;          
18AD6:  MOVLB  4
18AD8:  BRA    18B00
....................       case 60: set_heaters(0); 
18ADA:  MOVLB  8
18ADC:  CLRF   xC5
18ADE:  MOVLB  0
18AE0:  CALL   1270E
....................          break; 
18AE4:  MOVLB  4
18AE6:  BRA    18B00
....................       case 61: set_heaters(3); 
18AE8:  MOVLW  03
18AEA:  MOVLB  8
18AEC:  MOVWF  xC5
18AEE:  MOVLB  0
18AF0:  CALL   1270E
....................          break; 
18AF4:  MOVLB  4
18AF6:  BRA    18B00
18AF8:  MOVLB  0
....................       default : cmd_arg(); 
18AFA:  CALL   B2FE
....................          break;          
18AFE:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
18B00:  MOVLB  0
18B02:  CALL   AEB0
18B06:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
18B0A:  MOVF   48,F
18B0C:  BNZ   18B28
18B0E:  MOVF   49,F
18B10:  BNZ   18B28
18B12:  MOVF   4A,F
18B14:  BNZ   18B28
18B16:  MOVF   4B,F
18B18:  BNZ   18B28
....................       motor_sleep_rdy(); 
18B1A:  CALL   2998
....................       shutdown(); 
18B1E:  CALL   15C68
....................       go_to_sleep(); 
18B22:  CALL   15EE2
....................    } 
18B26:  BRA    18B2C
....................    else cmd_arg(); 
18B28:  CALL   B2FE
18B2C:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
18C5A:  DECFSZ 48,W
18C5C:  BRA    18C6E
18C5E:  MOVF   49,F
18C60:  BNZ   18C6E
18C62:  MOVF   4A,F
18C64:  BNZ   18C6E
18C66:  MOVF   4B,F
18C68:  BNZ   18C6E
18C6A:  BRA    18B54
18C6C:  BRA    18C72
....................    else cmd_arg(); 
18C6E:  CALL   B2FE
18C72:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
18C76:  MOVF   4B,F
18C78:  BNZ   18D08
18C7A:  MOVF   4A,F
18C7C:  BNZ   18D08
18C7E:  MOVF   49,W
18C80:  SUBLW  27
18C82:  BNC   18D08
18C84:  BNZ   18C8C
18C86:  MOVF   48,W
18C88:  SUBLW  10
18C8A:  BNC   18D08
....................       m_bklsh[motor] = arg; 
18C8C:  BCF    FD8.0
18C8E:  MOVLB  7
18C90:  RLCF   x40,W
18C92:  CLRF   03
18C94:  ADDLW  72
18C96:  MOVWF  FE9
18C98:  MOVLW  07
18C9A:  ADDWFC 03,W
18C9C:  MOVWF  FEA
18C9E:  MOVFF  48,FEF
18CA2:  MOVFF  49,FEC
....................       switch(motor){ 
18CA6:  MOVF   x40,W
18CA8:  XORLW  00
18CAA:  MOVLB  0
18CAC:  BZ    18CB4
18CAE:  XORLW  01
18CB0:  BZ    18CDE
18CB2:  BRA    18D06
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
18CB4:  BCF    FD8.0
18CB6:  MOVLB  7
18CB8:  RLCF   x40,W
18CBA:  CLRF   03
18CBC:  ADDLW  72
18CBE:  MOVWF  FE9
18CC0:  MOVLW  07
18CC2:  ADDWFC 03,W
18CC4:  MOVWF  FEA
18CC6:  MOVFF  FEC,8F0
18CCA:  MOVF   FED,F
18CCC:  MOVFF  FEF,8EF
18CD0:  MOVLW  72
18CD2:  MOVLB  8
18CD4:  MOVWF  xEE
18CD6:  MOVLB  0
18CD8:  CALL   4FD4
....................             break; 
18CDC:  BRA    18D06
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
18CDE:  BCF    FD8.0
18CE0:  MOVLB  7
18CE2:  RLCF   x40,W
18CE4:  CLRF   03
18CE6:  ADDLW  72
18CE8:  MOVWF  FE9
18CEA:  MOVLW  07
18CEC:  ADDWFC 03,W
18CEE:  MOVWF  FEA
18CF0:  MOVFF  FEC,8F0
18CF4:  MOVF   FED,F
18CF6:  MOVFF  FEF,8EF
18CFA:  MOVLW  74
18CFC:  MOVLB  8
18CFE:  MOVWF  xEE
18D00:  MOVLB  0
18D02:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
18D06:  BRA    18D0C
....................    else cmd_arg();    
18D08:  CALL   B2FE
18D0C:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... //Turn individual dio pins on and off 
.................... void command_c(){ 
....................    if(arg == 0){ 
18D10:  MOVF   48,F
18D12:  BNZ   18D24
18D14:  MOVF   49,F
18D16:  BNZ   18D24
18D18:  MOVF   4A,F
18D1A:  BNZ   18D24
18D1C:  MOVF   4B,F
18D1E:  BNZ   18D24
....................       output_bit(PIN_J7,0); 
18D20:  BCF    F91.7
....................    }else if(arg == 1){ 
18D22:  BRA    18D54
18D24:  DECFSZ 48,W
18D26:  BRA    18D38
18D28:  MOVF   49,F
18D2A:  BNZ   18D38
18D2C:  MOVF   4A,F
18D2E:  BNZ   18D38
18D30:  MOVF   4B,F
18D32:  BNZ   18D38
....................       output_bit(PIN_J7,1); 
18D34:  BSF    F91.7
....................    }else{ 
18D36:  BRA    18D54
....................       RTC_reset_HT(); 
18D38:  CALL   34B2
....................       output_bit(RTC_CS, ENABLE); 
18D3C:  BCF    F91.0
....................       spi_write(0x89); 
18D3E:  MOVF   FC9,W
18D40:  MOVLW  89
18D42:  MOVWF  FC9
18D44:  RRCF   FC7,W
18D46:  BNC   18D44
....................       spi_write(arg); 
18D48:  MOVF   FC9,W
18D4A:  MOVFF  48,FC9
18D4E:  RRCF   FC7,W
18D50:  BNC   18D4E
....................       output_bit(RTC_CS, DISABLE); 
18D52:  BSF    F91.0
....................    } 
18D54:  GOTO   1B22A (RETURN)
.................... } 
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
18D58:  MOVF   4B,F
18D5A:  BNZ   18DE6
18D5C:  MOVF   4A,F
18D5E:  BNZ   18DE6
18D60:  MOVF   49,F
18D62:  BNZ   18DE6
18D64:  MOVF   48,W
18D66:  SUBLW  01
18D68:  BNC   18DE6
....................       m_pos_dir[motor] = arg; 
18D6A:  BCF    FD8.0
18D6C:  MOVLB  7
18D6E:  RLCF   x40,W
18D70:  CLRF   03
18D72:  ADDLW  4E
18D74:  MOVWF  FE9
18D76:  MOVLW  07
18D78:  ADDWFC 03,W
18D7A:  MOVWF  FEA
18D7C:  MOVFF  48,FEF
18D80:  MOVFF  49,FEC
....................       switch(motor){ 
18D84:  MOVF   x40,W
18D86:  XORLW  00
18D88:  MOVLB  0
18D8A:  BZ    18D92
18D8C:  XORLW  01
18D8E:  BZ    18DBC
18D90:  BRA    18DE4
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
18D92:  BCF    FD8.0
18D94:  MOVLB  7
18D96:  RLCF   x40,W
18D98:  CLRF   03
18D9A:  ADDLW  4E
18D9C:  MOVWF  FE9
18D9E:  MOVLW  07
18DA0:  ADDWFC 03,W
18DA2:  MOVWF  FEA
18DA4:  MOVFF  FEC,8F0
18DA8:  MOVF   FED,F
18DAA:  MOVFF  FEF,8EF
18DAE:  MOVLW  92
18DB0:  MOVLB  8
18DB2:  MOVWF  xEE
18DB4:  MOVLB  0
18DB6:  CALL   4FD4
....................             break; 
18DBA:  BRA    18DE4
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
18DBC:  BCF    FD8.0
18DBE:  MOVLB  7
18DC0:  RLCF   x40,W
18DC2:  CLRF   03
18DC4:  ADDLW  4E
18DC6:  MOVWF  FE9
18DC8:  MOVLW  07
18DCA:  ADDWFC 03,W
18DCC:  MOVWF  FEA
18DCE:  MOVFF  FEC,8F0
18DD2:  MOVF   FED,F
18DD4:  MOVFF  FEF,8EF
18DD8:  MOVLW  94
18DDA:  MOVLB  8
18DDC:  MOVWF  xEE
18DDE:  MOVLB  0
18DE0:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
18DE4:  BRA    18DEA
....................    else cmd_arg();    
18DE6:  CALL   B2FE
18DEA:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
18DEE:  MOVF   4B,F
18DF0:  BNZ   18E80
18DF2:  MOVF   4A,F
18DF4:  BNZ   18E80
18DF6:  MOVF   49,W
18DF8:  SUBLW  27
18DFA:  BNC   18E80
18DFC:  BNZ   18E04
18DFE:  MOVF   48,W
18E00:  SUBLW  10
18E02:  BNC   18E80
....................       e_cpr[motor] = arg; 
18E04:  BCF    FD8.0
18E06:  MOVLB  7
18E08:  RLCF   x40,W
18E0A:  CLRF   03
18E0C:  ADDLW  5E
18E0E:  MOVWF  FE9
18E10:  MOVLW  07
18E12:  ADDWFC 03,W
18E14:  MOVWF  FEA
18E16:  MOVFF  48,FEF
18E1A:  MOVFF  49,FEC
....................       switch(motor){ 
18E1E:  MOVF   x40,W
18E20:  XORLW  00
18E22:  MOVLB  0
18E24:  BZ    18E2C
18E26:  XORLW  01
18E28:  BZ    18E56
18E2A:  BRA    18E7E
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
18E2C:  BCF    FD8.0
18E2E:  MOVLB  7
18E30:  RLCF   x40,W
18E32:  CLRF   03
18E34:  ADDLW  5E
18E36:  MOVWF  FE9
18E38:  MOVLW  07
18E3A:  ADDWFC 03,W
18E3C:  MOVWF  FEA
18E3E:  MOVFF  FEC,8F0
18E42:  MOVF   FED,F
18E44:  MOVFF  FEF,8EF
18E48:  MOVLW  A2
18E4A:  MOVLB  8
18E4C:  MOVWF  xEE
18E4E:  MOVLB  0
18E50:  CALL   4FD4
....................             break; 
18E54:  BRA    18E7E
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
18E56:  BCF    FD8.0
18E58:  MOVLB  7
18E5A:  RLCF   x40,W
18E5C:  CLRF   03
18E5E:  ADDLW  5E
18E60:  MOVWF  FE9
18E62:  MOVLW  07
18E64:  ADDWFC 03,W
18E66:  MOVWF  FEA
18E68:  MOVFF  FEC,8F0
18E6C:  MOVF   FED,F
18E6E:  MOVFF  FEF,8EF
18E72:  MOVLW  A4
18E74:  MOVLB  8
18E76:  MOVWF  xEE
18E78:  MOVLB  0
18E7A:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
18E7E:  BRA    18E84
....................    else cmd_arg();    
18E80:  CALL   B2FE
18E84:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18E88:  MOVF   4B,F
18E8A:  BNZ   18EA0
18E8C:  MOVF   4A,F
18E8E:  BNZ   18EA0
18E90:  MOVF   49,F
18E92:  BNZ   18EA0
18E94:  MOVF   48,W
18E96:  SUBLW  01
18E98:  BNC   18EA0
18E9A:  MOVFF  48,741
18E9E:  BRA    18EA4
....................    else cmd_arg();    
18EA0:  CALL   B2FE
18EA4:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18EA8:  MOVF   4B,F
18EAA:  BNZ   18F3A
18EAC:  MOVF   4A,F
18EAE:  BNZ   18F3A
18EB0:  MOVF   49,W
18EB2:  SUBLW  EA
18EB4:  BNC   18F3A
18EB6:  BNZ   18EBE
18EB8:  MOVF   48,W
18EBA:  SUBLW  60
18EBC:  BNC   18F3A
....................       m_gb_err[motor] = arg; 
18EBE:  BCF    FD8.0
18EC0:  MOVLB  7
18EC2:  RLCF   x40,W
18EC4:  CLRF   03
18EC6:  ADDLW  5A
18EC8:  MOVWF  FE9
18ECA:  MOVLW  07
18ECC:  ADDWFC 03,W
18ECE:  MOVWF  FEA
18ED0:  MOVFF  48,FEF
18ED4:  MOVFF  49,FEC
....................       switch(motor){ 
18ED8:  MOVF   x40,W
18EDA:  XORLW  00
18EDC:  MOVLB  0
18EDE:  BZ    18EE6
18EE0:  XORLW  01
18EE2:  BZ    18F10
18EE4:  BRA    18F38
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18EE6:  BCF    FD8.0
18EE8:  MOVLB  7
18EEA:  RLCF   x40,W
18EEC:  CLRF   03
18EEE:  ADDLW  5A
18EF0:  MOVWF  FE9
18EF2:  MOVLW  07
18EF4:  ADDWFC 03,W
18EF6:  MOVWF  FEA
18EF8:  MOVFF  FEC,8F0
18EFC:  MOVF   FED,F
18EFE:  MOVFF  FEF,8EF
18F02:  MOVLW  9E
18F04:  MOVLB  8
18F06:  MOVWF  xEE
18F08:  MOVLB  0
18F0A:  CALL   4FD4
....................             break; 
18F0E:  BRA    18F38
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
18F10:  BCF    FD8.0
18F12:  MOVLB  7
18F14:  RLCF   x40,W
18F16:  CLRF   03
18F18:  ADDLW  5A
18F1A:  MOVWF  FE9
18F1C:  MOVLW  07
18F1E:  ADDWFC 03,W
18F20:  MOVWF  FEA
18F22:  MOVFF  FEC,8F0
18F26:  MOVF   FED,F
18F28:  MOVFF  FEF,8EF
18F2C:  MOVLW  A0
18F2E:  MOVLB  8
18F30:  MOVWF  xEE
18F32:  MOVLB  0
18F34:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
18F38:  BRA    18F3E
....................    else cmd_arg();    
18F3A:  CALL   B2FE
18F3E:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
18F42:  MOVF   4B,F
18F44:  BNZ   1900E
18F46:  MOVF   4A,F
18F48:  BNZ   1900E
18F4A:  MOVF   49,F
18F4C:  BNZ   1900E
18F4E:  MOVF   48,W
18F50:  SUBLW  64
18F52:  BNC   1900E
....................       hold_pc=arg; 
18F54:  MOVFF  49,886
18F58:  MOVFF  48,885
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
18F5C:  BCF    FD8.0
18F5E:  MOVLB  7
18F60:  RLCF   x40,W
18F62:  CLRF   03
18F64:  ADDLW  52
18F66:  MOVWF  FE9
18F68:  MOVLW  07
18F6A:  ADDWFC 03,W
18F6C:  MOVWF  FEA
18F6E:  MOVFF  886,A11
18F72:  MOVFF  885,A10
18F76:  MOVLW  01
18F78:  MOVLB  A
18F7A:  MOVWF  x13
18F7C:  SETF   x12
18F7E:  MOVLB  0
18F80:  CALL   5C98
18F84:  MOVFF  02,88A
18F88:  MOVFF  01,889
18F8C:  MOVFF  02,8DC
18F90:  MOVFF  01,8DB
18F94:  MOVLB  8
18F96:  CLRF   xDE
18F98:  MOVLW  64
18F9A:  MOVWF  xDD
18F9C:  MOVLB  0
18F9E:  CALL   2CD4
18FA2:  MOVFF  01,FEF
18FA6:  MOVFF  02,FEC
....................       switch(motor){ 
18FAA:  MOVLB  7
18FAC:  MOVF   x40,W
18FAE:  XORLW  00
18FB0:  MOVLB  0
18FB2:  BZ    18FBA
18FB4:  XORLW  01
18FB6:  BZ    18FE4
18FB8:  BRA    1900C
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
18FBA:  BCF    FD8.0
18FBC:  MOVLB  7
18FBE:  RLCF   x40,W
18FC0:  CLRF   03
18FC2:  ADDLW  52
18FC4:  MOVWF  FE9
18FC6:  MOVLW  07
18FC8:  ADDWFC 03,W
18FCA:  MOVWF  FEA
18FCC:  MOVFF  FEC,8F0
18FD0:  MOVF   FED,F
18FD2:  MOVFF  FEF,8EF
18FD6:  MOVLW  96
18FD8:  MOVLB  8
18FDA:  MOVWF  xEE
18FDC:  MOVLB  0
18FDE:  CALL   4FD4
....................             break; 
18FE2:  BRA    1900C
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
18FE4:  BCF    FD8.0
18FE6:  MOVLB  7
18FE8:  RLCF   x40,W
18FEA:  CLRF   03
18FEC:  ADDLW  52
18FEE:  MOVWF  FE9
18FF0:  MOVLW  07
18FF2:  ADDWFC 03,W
18FF4:  MOVWF  FEA
18FF6:  MOVFF  FEC,8F0
18FFA:  MOVF   FED,F
18FFC:  MOVFF  FEF,8EF
19000:  MOVLW  98
19002:  MOVLB  8
19004:  MOVWF  xEE
19006:  MOVLB  0
19008:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1900C:  BRA    19012
....................    else cmd_arg();    
1900E:  CALL   B2FE
19012:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
19016:  MOVF   4B,F
19018:  BNZ   190EA
1901A:  MOVF   4A,F
1901C:  BNZ   190EA
1901E:  MOVF   49,W
19020:  SUBLW  EA
19022:  BNC   190EA
19024:  BNZ   1902C
19026:  MOVF   48,W
19028:  SUBLW  60
1902A:  BNC   190EA
....................       m_stp_int[motor] = (arg/100); 
1902C:  BCF    FD8.0
1902E:  MOVLB  7
19030:  RLCF   x40,W
19032:  CLRF   03
19034:  ADDLW  4A
19036:  MOVWF  FE9
19038:  MOVLW  07
1903A:  ADDWFC 03,W
1903C:  MOVWF  FEA
1903E:  MOVFF  FEA,888
19042:  MOVFF  FE9,887
19046:  BCF    FD8.1
19048:  CLRF   1B
1904A:  BTFSC  FF2.7
1904C:  BSF    1B.7
1904E:  BCF    FF2.7
19050:  MOVFF  4B,A4F
19054:  MOVFF  4A,A4E
19058:  MOVFF  49,A4D
1905C:  MOVFF  48,A4C
19060:  MOVLB  A
19062:  CLRF   x53
19064:  CLRF   x52
19066:  CLRF   x51
19068:  MOVLW  64
1906A:  MOVWF  x50
1906C:  MOVLB  0
1906E:  CALL   104E
19072:  BTFSC  1B.7
19074:  BSF    FF2.7
19076:  MOVFF  888,FEA
1907A:  MOVFF  887,FE9
1907E:  MOVFF  00,FEF
19082:  MOVFF  01,FEC
....................       switch(motor){ 
19086:  MOVLB  7
19088:  MOVF   x40,W
1908A:  XORLW  00
1908C:  MOVLB  0
1908E:  BZ    19096
19090:  XORLW  01
19092:  BZ    190C0
19094:  BRA    190E8
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
19096:  BCF    FD8.0
19098:  MOVLB  7
1909A:  RLCF   x40,W
1909C:  CLRF   03
1909E:  ADDLW  4A
190A0:  MOVWF  FE9
190A2:  MOVLW  07
190A4:  ADDWFC 03,W
190A6:  MOVWF  FEA
190A8:  MOVFF  FEC,8F0
190AC:  MOVF   FED,F
190AE:  MOVFF  FEF,8EF
190B2:  MOVLW  8E
190B4:  MOVLB  8
190B6:  MOVWF  xEE
190B8:  MOVLB  0
190BA:  CALL   4FD4
....................             break; 
190BE:  BRA    190E8
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
190C0:  BCF    FD8.0
190C2:  MOVLB  7
190C4:  RLCF   x40,W
190C6:  CLRF   03
190C8:  ADDLW  4A
190CA:  MOVWF  FE9
190CC:  MOVLW  07
190CE:  ADDWFC 03,W
190D0:  MOVWF  FEA
190D2:  MOVFF  FEC,8F0
190D6:  MOVF   FED,F
190D8:  MOVFF  FEF,8EF
190DC:  MOVLW  90
190DE:  MOVLB  8
190E0:  MOVWF  xEE
190E2:  MOVLB  0
190E4:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
190E8:  BRA    190EE
....................    else cmd_arg();    
190EA:  CALL   B2FE
190EE:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
190F2:  MOVF   4B,F
190F4:  BNZ   19184
190F6:  MOVF   4A,F
190F8:  BNZ   19184
190FA:  MOVF   49,W
190FC:  SUBLW  27
190FE:  BNC   19184
19100:  BNZ   19108
19102:  MOVF   48,W
19104:  SUBLW  10
19106:  BNC   19184
....................       m_run[motor] = arg; 
19108:  BCF    FD8.0
1910A:  MOVLB  7
1910C:  RLCF   x40,W
1910E:  CLRF   03
19110:  ADDLW  6E
19112:  MOVWF  FE9
19114:  MOVLW  07
19116:  ADDWFC 03,W
19118:  MOVWF  FEA
1911A:  MOVFF  48,FEF
1911E:  MOVFF  49,FEC
....................       switch(motor){ 
19122:  MOVF   x40,W
19124:  XORLW  00
19126:  MOVLB  0
19128:  BZ    19130
1912A:  XORLW  01
1912C:  BZ    1915A
1912E:  BRA    19182
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
19130:  BCF    FD8.0
19132:  MOVLB  7
19134:  RLCF   x40,W
19136:  CLRF   03
19138:  ADDLW  6E
1913A:  MOVWF  FE9
1913C:  MOVLW  07
1913E:  ADDWFC 03,W
19140:  MOVWF  FEA
19142:  MOVFF  FEC,8F0
19146:  MOVF   FED,F
19148:  MOVFF  FEF,8EF
1914C:  MOVLW  76
1914E:  MOVLB  8
19150:  MOVWF  xEE
19152:  MOVLB  0
19154:  CALL   4FD4
....................             break; 
19158:  BRA    19182
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
1915A:  BCF    FD8.0
1915C:  MOVLB  7
1915E:  RLCF   x40,W
19160:  CLRF   03
19162:  ADDLW  6E
19164:  MOVWF  FE9
19166:  MOVLW  07
19168:  ADDWFC 03,W
1916A:  MOVWF  FEA
1916C:  MOVFF  FEC,8F0
19170:  MOVF   FED,F
19172:  MOVFF  FEF,8EF
19176:  MOVLW  78
19178:  MOVLB  8
1917A:  MOVWF  xEE
1917C:  MOVLB  0
1917E:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
19182:  BRA    19188
....................    else cmd_arg();    
19184:  CALL   B2FE
19188:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
1918C:  MOVF   4B,F
1918E:  BNZ   1921A
19190:  MOVF   4A,F
19192:  BNZ   1921A
19194:  MOVF   49,F
19196:  BNZ   1921A
19198:  MOVF   48,W
1919A:  SUBLW  03
1919C:  BNC   1921A
....................       e_mode[motor] = arg; 
1919E:  BCF    FD8.0
191A0:  MOVLB  7
191A2:  RLCF   x40,W
191A4:  CLRF   03
191A6:  ADDLW  66
191A8:  MOVWF  FE9
191AA:  MOVLW  07
191AC:  ADDWFC 03,W
191AE:  MOVWF  FEA
191B0:  MOVFF  48,FEF
191B4:  MOVFF  49,FEC
....................       switch(motor){ 
191B8:  MOVF   x40,W
191BA:  XORLW  00
191BC:  MOVLB  0
191BE:  BZ    191C6
191C0:  XORLW  01
191C2:  BZ    191F0
191C4:  BRA    19218
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
191C6:  BCF    FD8.0
191C8:  MOVLB  7
191CA:  RLCF   x40,W
191CC:  CLRF   03
191CE:  ADDLW  66
191D0:  MOVWF  FE9
191D2:  MOVLW  07
191D4:  ADDWFC 03,W
191D6:  MOVWF  FEA
191D8:  MOVFF  FEC,8F0
191DC:  MOVF   FED,F
191DE:  MOVFF  FEF,8EF
191E2:  MOVLW  82
191E4:  MOVLB  8
191E6:  MOVWF  xEE
191E8:  MOVLB  0
191EA:  CALL   4FD4
....................             break; 
191EE:  BRA    19218
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
191F0:  BCF    FD8.0
191F2:  MOVLB  7
191F4:  RLCF   x40,W
191F6:  CLRF   03
191F8:  ADDLW  66
191FA:  MOVWF  FE9
191FC:  MOVLW  07
191FE:  ADDWFC 03,W
19200:  MOVWF  FEA
19202:  MOVFF  FEC,8F0
19206:  MOVF   FED,F
19208:  MOVFF  FEF,8EF
1920C:  MOVLW  84
1920E:  MOVLB  8
19210:  MOVWF  xEE
19212:  MOVLB  0
19214:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
19218:  BRA    1921E
....................    else cmd_arg();    
1921A:  CALL   B2FE
1921E:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
19E82:  MOVF   4B,F
19E84:  BNZ   19F10
19E86:  MOVF   4A,F
19E88:  BNZ   19F10
19E8A:  MOVF   49,F
19E8C:  BNZ   19F10
19E8E:  MOVF   48,W
19E90:  SUBLW  01
19E92:  BNC   19F10
....................       m_mode[motor] = arg; 
19E94:  BCF    FD8.0
19E96:  MOVLB  7
19E98:  RLCF   x40,W
19E9A:  CLRF   03
19E9C:  ADDLW  46
19E9E:  MOVWF  FE9
19EA0:  MOVLW  07
19EA2:  ADDWFC 03,W
19EA4:  MOVWF  FEA
19EA6:  MOVFF  48,FEF
19EAA:  MOVFF  49,FEC
....................       switch(motor){ 
19EAE:  MOVF   x40,W
19EB0:  XORLW  00
19EB2:  MOVLB  0
19EB4:  BZ    19EBC
19EB6:  XORLW  01
19EB8:  BZ    19EE6
19EBA:  BRA    19F0E
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19EBC:  BCF    FD8.0
19EBE:  MOVLB  7
19EC0:  RLCF   x40,W
19EC2:  CLRF   03
19EC4:  ADDLW  46
19EC6:  MOVWF  FE9
19EC8:  MOVLW  07
19ECA:  ADDWFC 03,W
19ECC:  MOVWF  FEA
19ECE:  MOVFF  FEC,8F0
19ED2:  MOVF   FED,F
19ED4:  MOVFF  FEF,8EF
19ED8:  MOVLW  8A
19EDA:  MOVLB  8
19EDC:  MOVWF  xEE
19EDE:  MOVLB  0
19EE0:  CALL   4FD4
....................             break; 
19EE4:  BRA    19F0E
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19EE6:  BCF    FD8.0
19EE8:  MOVLB  7
19EEA:  RLCF   x40,W
19EEC:  CLRF   03
19EEE:  ADDLW  46
19EF0:  MOVWF  FE9
19EF2:  MOVLW  07
19EF4:  ADDWFC 03,W
19EF6:  MOVWF  FEA
19EF8:  MOVFF  FEC,8F0
19EFC:  MOVF   FED,F
19EFE:  MOVFF  FEF,8EF
19F02:  MOVLW  8C
19F04:  MOVLB  8
19F06:  MOVWF  xEE
19F08:  MOVLB  0
19F0A:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
19F0E:  BRA    19F14
....................    else cmd_arg();    
19F10:  CALL   B2FE
19F14:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19F18:  MOVF   4B,F
19F1A:  BNZ   19FA6
19F1C:  MOVF   4A,F
19F1E:  BNZ   19FA6
19F20:  MOVF   49,F
19F22:  BNZ   19FA6
19F24:  MOVF   48,W
19F26:  SUBLW  01
19F28:  BNC   19FA6
....................       e_index[motor] = arg; 
19F2A:  BCF    FD8.0
19F2C:  MOVLB  7
19F2E:  RLCF   x40,W
19F30:  CLRF   03
19F32:  ADDLW  7A
19F34:  MOVWF  FE9
19F36:  MOVLW  07
19F38:  ADDWFC 03,W
19F3A:  MOVWF  FEA
19F3C:  MOVFF  48,FEF
19F40:  MOVFF  49,FEC
....................       switch(motor){ 
19F44:  MOVF   x40,W
19F46:  XORLW  00
19F48:  MOVLB  0
19F4A:  BZ    19F52
19F4C:  XORLW  01
19F4E:  BZ    19F7C
19F50:  BRA    19FA4
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
19F52:  BCF    FD8.0
19F54:  MOVLB  7
19F56:  RLCF   x40,W
19F58:  CLRF   03
19F5A:  ADDLW  7A
19F5C:  MOVWF  FE9
19F5E:  MOVLW  07
19F60:  ADDWFC 03,W
19F62:  MOVWF  FEA
19F64:  MOVFF  FEC,8F0
19F68:  MOVF   FED,F
19F6A:  MOVFF  FEF,8EF
19F6E:  MOVLW  BA
19F70:  MOVLB  8
19F72:  MOVWF  xEE
19F74:  MOVLB  0
19F76:  CALL   4FD4
....................             break; 
19F7A:  BRA    19FA4
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
19F7C:  BCF    FD8.0
19F7E:  MOVLB  7
19F80:  RLCF   x40,W
19F82:  CLRF   03
19F84:  ADDLW  7A
19F86:  MOVWF  FE9
19F88:  MOVLW  07
19F8A:  ADDWFC 03,W
19F8C:  MOVWF  FEA
19F8E:  MOVFF  FEC,8F0
19F92:  MOVF   FED,F
19F94:  MOVFF  FEF,8EF
19F98:  MOVLW  BC
19F9A:  MOVLB  8
19F9C:  MOVWF  xEE
19F9E:  MOVLB  0
19FA0:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
19FA4:  BRA    19FAA
....................    else cmd_arg();    
19FA6:  CALL   B2FE
19FAA:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
19FAE:  MOVF   4B,F
19FB0:  BNZ   1A040
19FB2:  MOVF   4A,F
19FB4:  BNZ   1A040
19FB6:  MOVF   49,W
19FB8:  SUBLW  01
19FBA:  BNC   1A040
19FBC:  BNZ   19FC4
19FBE:  MOVF   48,W
19FC0:  SUBLW  0A
19FC2:  BNC   1A040
....................        evn_so[motor] = arg; 
19FC4:  BCF    FD8.0
19FC6:  MOVLB  7
19FC8:  RLCF   x40,W
19FCA:  CLRF   03
19FCC:  ADDLW  7E
19FCE:  MOVWF  FE9
19FD0:  MOVLW  07
19FD2:  ADDWFC 03,W
19FD4:  MOVWF  FEA
19FD6:  MOVFF  48,FEF
19FDA:  MOVFF  49,FEC
....................        switch(motor){ 
19FDE:  MOVF   x40,W
19FE0:  XORLW  00
19FE2:  MOVLB  0
19FE4:  BZ    19FEC
19FE6:  XORLW  01
19FE8:  BZ    1A016
19FEA:  BRA    1A03E
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
19FEC:  BCF    FD8.0
19FEE:  MOVLB  7
19FF0:  RLCF   x40,W
19FF2:  CLRF   03
19FF4:  ADDLW  7E
19FF6:  MOVWF  FE9
19FF8:  MOVLW  07
19FFA:  ADDWFC 03,W
19FFC:  MOVWF  FEA
19FFE:  MOVFF  FEC,8F0
1A002:  MOVF   FED,F
1A004:  MOVFF  FEF,8EF
1A008:  MOVLW  BE
1A00A:  MOVLB  8
1A00C:  MOVWF  xEE
1A00E:  MOVLB  0
1A010:  CALL   4FD4
....................             break; 
1A014:  BRA    1A03E
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
1A016:  BCF    FD8.0
1A018:  MOVLB  7
1A01A:  RLCF   x40,W
1A01C:  CLRF   03
1A01E:  ADDLW  7E
1A020:  MOVWF  FE9
1A022:  MOVLW  07
1A024:  ADDWFC 03,W
1A026:  MOVWF  FEA
1A028:  MOVFF  FEC,8F0
1A02C:  MOVF   FED,F
1A02E:  MOVFF  FEF,8EF
1A032:  MOVLW  C0
1A034:  MOVLB  8
1A036:  MOVWF  xEE
1A038:  MOVLB  0
1A03A:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1A03E:  BRA    1A044
....................    else cmd_arg();    
1A040:  CALL   B2FE
1A044:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
1A048:  MOVF   4B,F
1A04A:  BNZ   1A0DA
1A04C:  MOVF   4A,F
1A04E:  BNZ   1A0DA
1A050:  MOVF   49,W
1A052:  SUBLW  03
1A054:  BNC   1A0DA
1A056:  BNZ   1A05E
1A058:  MOVF   48,W
1A05A:  SUBLW  E8
1A05C:  BNC   1A0DA
....................       e_ppr[motor] = arg; 
1A05E:  BCF    FD8.0
1A060:  MOVLB  7
1A062:  RLCF   x40,W
1A064:  CLRF   03
1A066:  ADDLW  62
1A068:  MOVWF  FE9
1A06A:  MOVLW  07
1A06C:  ADDWFC 03,W
1A06E:  MOVWF  FEA
1A070:  MOVFF  48,FEF
1A074:  MOVFF  49,FEC
....................       switch(motor){ 
1A078:  MOVF   x40,W
1A07A:  XORLW  00
1A07C:  MOVLB  0
1A07E:  BZ    1A086
1A080:  XORLW  01
1A082:  BZ    1A0B0
1A084:  BRA    1A0D8
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
1A086:  BCF    FD8.0
1A088:  MOVLB  7
1A08A:  RLCF   x40,W
1A08C:  CLRF   03
1A08E:  ADDLW  62
1A090:  MOVWF  FE9
1A092:  MOVLW  07
1A094:  ADDWFC 03,W
1A096:  MOVWF  FEA
1A098:  MOVFF  FEC,8F0
1A09C:  MOVF   FED,F
1A09E:  MOVFF  FEF,8EF
1A0A2:  MOVLW  A6
1A0A4:  MOVLB  8
1A0A6:  MOVWF  xEE
1A0A8:  MOVLB  0
1A0AA:  CALL   4FD4
....................             break; 
1A0AE:  BRA    1A0D8
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
1A0B0:  BCF    FD8.0
1A0B2:  MOVLB  7
1A0B4:  RLCF   x40,W
1A0B6:  CLRF   03
1A0B8:  ADDLW  62
1A0BA:  MOVWF  FE9
1A0BC:  MOVLW  07
1A0BE:  ADDWFC 03,W
1A0C0:  MOVWF  FEA
1A0C2:  MOVFF  FEC,8F0
1A0C6:  MOVF   FED,F
1A0C8:  MOVFF  FEF,8EF
1A0CC:  MOVLW  A8
1A0CE:  MOVLB  8
1A0D0:  MOVWF  xEE
1A0D2:  MOVLB  0
1A0D4:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1A0D8:  BRA    1A0DE
....................    else cmd_arg();    
1A0DA:  CALL   B2FE
1A0DE:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
1A0E2:  MOVF   48,F
1A0E4:  BNZ   1A0F6
1A0E6:  MOVF   49,F
1A0E8:  BNZ   1A0F6
1A0EA:  MOVF   4A,F
1A0EC:  BNZ   1A0F6
1A0EE:  MOVF   4B,F
1A0F0:  BNZ   1A0F6
1A0F2:  BCF    F8E.1
1A0F4:  BRA    1A0FA
....................    else cmd_arg();    
1A0F6:  CALL   B2FE
1A0FA:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1ABDE:  MOVF   48,F
1ABE0:  BNZ   1AC30
1ABE2:  MOVF   49,F
1ABE4:  BNZ   1AC30
1ABE6:  MOVF   4A,F
1ABE8:  BNZ   1AC30
1ABEA:  MOVF   4B,F
1ABEC:  BNZ   1AC30
....................       switch (nv_product) { 
1ABEE:  MOVFF  2F,00
1ABF2:  MOVF   30,W
1ABF4:  MOVWF  03
1ABF6:  BNZ   1ABFC
1ABF8:  MOVF   00,F
1ABFA:  BZ    1AC1C
1ABFC:  MOVF   03,W
1ABFE:  BNZ   1AC06
1AC00:  MOVLW  01
1AC02:  SUBWF  00,W
1AC04:  BZ    1AC22
1AC06:  MOVF   03,W
1AC08:  BNZ   1AC10
1AC0A:  MOVLW  02
1AC0C:  SUBWF  00,W
1AC0E:  BZ    1AC28
1AC10:  MOVF   03,W
1AC12:  BNZ   1AC1A
1AC14:  MOVLW  03
1AC16:  SUBWF  00,W
1AC18:  BZ    1AC2C
1AC1A:  BRA    1AC2E
....................          case ECO : rst_step_vars_eco(); 
1AC1C:  GOTO   1A0FE
....................             break; 
1AC20:  BRA    1AC2E
....................          case WMS4 : rst_step_vars_wms4(); 
1AC22:  GOTO   1A3E8
....................             break; 
1AC26:  BRA    1AC2E
....................          case AWS : rst_step_vars_aws(); 
1AC28:  BRA    1A694
....................             break;             
1AC2A:  BRA    1AC2E
....................          case WMS2 : rst_step_vars_wms2(); 
1AC2C:  BRA    1A92E
....................             break; 
....................       } 
....................    }  
1AC2E:  BRA    1AC34
....................    else cmd_arg(); 
1AC30:  CALL   B2FE
1AC34:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1AC38:  MOVF   4B,F
1AC3A:  BTFSS  FD8.2
1AC3C:  BRA    1AD3E
1AC3E:  MOVF   4A,W
1AC40:  SUBLW  00
1AC42:  BTFSS  FD8.0
1AC44:  BRA    1AD3E
....................       m_spr[motor] = arg; 
1AC46:  BCF    FD8.0
1AC48:  MOVLB  7
1AC4A:  RLCF   x40,W
1AC4C:  CLRF   03
1AC4E:  ADDLW  76
1AC50:  MOVWF  FE9
1AC52:  MOVLW  07
1AC54:  ADDWFC 03,W
1AC56:  MOVWF  FEA
1AC58:  MOVFF  48,FEF
1AC5C:  MOVFF  49,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1AC60:  BCF    FD8.0
1AC62:  RLCF   x40,W
1AC64:  CLRF   03
1AC66:  ADDLW  AB
1AC68:  MOVWF  01
1AC6A:  MOVLW  07
1AC6C:  ADDWFC 03,F
1AC6E:  MOVFF  01,885
1AC72:  MOVLB  8
1AC74:  MOVFF  03,886
1AC78:  BCF    FD8.0
1AC7A:  MOVLB  7
1AC7C:  RLCF   x40,W
1AC7E:  CLRF   03
1AC80:  ADDLW  76
1AC82:  MOVWF  FE9
1AC84:  MOVLW  07
1AC86:  ADDWFC 03,W
1AC88:  MOVWF  FEA
1AC8A:  MOVFF  FEC,8DC
1AC8E:  MOVF   FED,F
1AC90:  MOVFF  FEF,8DB
1AC94:  BCF    FD8.0
1AC96:  RLCF   x40,W
1AC98:  CLRF   03
1AC9A:  ADDLW  62
1AC9C:  MOVWF  FE9
1AC9E:  MOVLW  07
1ACA0:  ADDWFC 03,W
1ACA2:  MOVWF  FEA
1ACA4:  MOVFF  FEC,03
1ACA8:  MOVF   FED,F
1ACAA:  MOVFF  FEF,8DD
1ACAE:  MOVFF  03,88A
1ACB2:  MOVFF  03,8DE
1ACB6:  MOVLB  0
1ACB8:  CALL   2CD4
1ACBC:  MOVFF  02,888
1ACC0:  BCF    FD8.0
1ACC2:  MOVLB  8
1ACC4:  RLCF   01,W
1ACC6:  MOVWF  02
1ACC8:  RLCF   x88,W
1ACCA:  MOVFF  886,FEA
1ACCE:  MOVFF  885,FE9
1ACD2:  MOVWF  FEC
1ACD4:  MOVF   FED,F
1ACD6:  MOVFF  02,FEF
....................       switch(motor){ 
1ACDA:  MOVLB  7
1ACDC:  MOVF   x40,W
1ACDE:  XORLW  00
1ACE0:  MOVLB  0
1ACE2:  BZ    1ACEA
1ACE4:  XORLW  01
1ACE6:  BZ    1AD14
1ACE8:  BRA    1AD3C
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1ACEA:  BCF    FD8.0
1ACEC:  MOVLB  7
1ACEE:  RLCF   x40,W
1ACF0:  CLRF   03
1ACF2:  ADDLW  76
1ACF4:  MOVWF  FE9
1ACF6:  MOVLW  07
1ACF8:  ADDWFC 03,W
1ACFA:  MOVWF  FEA
1ACFC:  MOVFF  FEC,8F0
1AD00:  MOVF   FED,F
1AD02:  MOVFF  FEF,8EF
1AD06:  MOVLW  AE
1AD08:  MOVLB  8
1AD0A:  MOVWF  xEE
1AD0C:  MOVLB  0
1AD0E:  CALL   4FD4
....................             break; 
1AD12:  BRA    1AD3C
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1AD14:  BCF    FD8.0
1AD16:  MOVLB  7
1AD18:  RLCF   x40,W
1AD1A:  CLRF   03
1AD1C:  ADDLW  76
1AD1E:  MOVWF  FE9
1AD20:  MOVLW  07
1AD22:  ADDWFC 03,W
1AD24:  MOVWF  FEA
1AD26:  MOVFF  FEC,8F0
1AD2A:  MOVF   FED,F
1AD2C:  MOVFF  FEF,8EF
1AD30:  MOVLW  B0
1AD32:  MOVLB  8
1AD34:  MOVWF  xEE
1AD36:  MOVLB  0
1AD38:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1AD3C:  BRA    1AD42
....................    else cmd_arg();    
1AD3E:  CALL   B2FE
1AD42:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1AD46:  MOVF   4B,F
1AD48:  BNZ   1ADD4
1AD4A:  MOVF   4A,F
1AD4C:  BNZ   1ADD4
1AD4E:  MOVF   49,F
1AD50:  BNZ   1ADD4
1AD52:  MOVF   48,W
1AD54:  SUBLW  02
1AD56:  BNC   1ADD4
....................       e_type[motor] = arg; 
1AD58:  BCF    FD8.0
1AD5A:  MOVLB  7
1AD5C:  RLCF   x40,W
1AD5E:  CLRF   03
1AD60:  ADDLW  6A
1AD62:  MOVWF  FE9
1AD64:  MOVLW  07
1AD66:  ADDWFC 03,W
1AD68:  MOVWF  FEA
1AD6A:  MOVFF  48,FEF
1AD6E:  MOVFF  49,FEC
....................       switch(motor){ 
1AD72:  MOVF   x40,W
1AD74:  XORLW  00
1AD76:  MOVLB  0
1AD78:  BZ    1AD80
1AD7A:  XORLW  01
1AD7C:  BZ    1ADAA
1AD7E:  BRA    1ADD2
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1AD80:  BCF    FD8.0
1AD82:  MOVLB  7
1AD84:  RLCF   x40,W
1AD86:  CLRF   03
1AD88:  ADDLW  6A
1AD8A:  MOVWF  FE9
1AD8C:  MOVLW  07
1AD8E:  ADDWFC 03,W
1AD90:  MOVWF  FEA
1AD92:  MOVFF  FEC,8F0
1AD96:  MOVF   FED,F
1AD98:  MOVFF  FEF,8EF
1AD9C:  MOVLW  7A
1AD9E:  MOVLB  8
1ADA0:  MOVWF  xEE
1ADA2:  MOVLB  0
1ADA4:  CALL   4FD4
....................             break; 
1ADA8:  BRA    1ADD2
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1ADAA:  BCF    FD8.0
1ADAC:  MOVLB  7
1ADAE:  RLCF   x40,W
1ADB0:  CLRF   03
1ADB2:  ADDLW  6A
1ADB4:  MOVWF  FE9
1ADB6:  MOVLW  07
1ADB8:  ADDWFC 03,W
1ADBA:  MOVWF  FEA
1ADBC:  MOVFF  FEC,8F0
1ADC0:  MOVF   FED,F
1ADC2:  MOVFF  FEF,8EF
1ADC6:  MOVLW  7C
1ADC8:  MOVLB  8
1ADCA:  MOVWF  xEE
1ADCC:  MOVLB  0
1ADCE:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1ADD2:  BRA    1ADD8
....................    else cmd_arg();    
1ADD4:  CALL   B2FE
1ADD8:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... //currently used to test dio pins 
.................... void command_v(){ 
....................    if(arg == 00){ 
*
13DDC:  MOVF   48,F
13DDE:  BNZ   13DF0
13DE0:  MOVF   49,F
13DE2:  BNZ   13DF0
13DE4:  MOVF   4A,F
13DE6:  BNZ   13DF0
13DE8:  MOVF   4B,F
13DEA:  BNZ   13DF0
....................       output_bit(PIN_D0,0); 
13DEC:  BCF    F8C.0
....................    }else if(arg == 01){ 
13DEE:  BRA    13F36
13DF0:  DECFSZ 48,W
13DF2:  BRA    13E04
13DF4:  MOVF   49,F
13DF6:  BNZ   13E04
13DF8:  MOVF   4A,F
13DFA:  BNZ   13E04
13DFC:  MOVF   4B,F
13DFE:  BNZ   13E04
....................       output_bit(PIN_D0,1); 
13E00:  BSF    F8C.0
....................    }else if(arg == 10){ 
13E02:  BRA    13F36
13E04:  MOVF   48,W
13E06:  SUBLW  0A
13E08:  BNZ   13E1A
13E0A:  MOVF   49,F
13E0C:  BNZ   13E1A
13E0E:  MOVF   4A,F
13E10:  BNZ   13E1A
13E12:  MOVF   4B,F
13E14:  BNZ   13E1A
....................       output_bit(PIN_D1,0); 
13E16:  BCF    F8C.1
....................    }else if(arg == 11){ 
13E18:  BRA    13F36
13E1A:  MOVF   48,W
13E1C:  SUBLW  0B
13E1E:  BNZ   13E30
13E20:  MOVF   49,F
13E22:  BNZ   13E30
13E24:  MOVF   4A,F
13E26:  BNZ   13E30
13E28:  MOVF   4B,F
13E2A:  BNZ   13E30
....................       output_bit(PIN_D1,1); 
13E2C:  BSF    F8C.1
....................    }else if(arg == 20){ 
13E2E:  BRA    13F36
13E30:  MOVF   48,W
13E32:  SUBLW  14
13E34:  BNZ   13E46
13E36:  MOVF   49,F
13E38:  BNZ   13E46
13E3A:  MOVF   4A,F
13E3C:  BNZ   13E46
13E3E:  MOVF   4B,F
13E40:  BNZ   13E46
....................       output_bit(PIN_D2,0); 
13E42:  BCF    F8C.2
....................    }else if(arg == 21){ 
13E44:  BRA    13F36
13E46:  MOVF   48,W
13E48:  SUBLW  15
13E4A:  BNZ   13E5C
13E4C:  MOVF   49,F
13E4E:  BNZ   13E5C
13E50:  MOVF   4A,F
13E52:  BNZ   13E5C
13E54:  MOVF   4B,F
13E56:  BNZ   13E5C
....................       output_bit(PIN_D2,1); 
13E58:  BSF    F8C.2
....................    }else if(arg == 30){ 
13E5A:  BRA    13F36
13E5C:  MOVF   48,W
13E5E:  SUBLW  1E
13E60:  BNZ   13E72
13E62:  MOVF   49,F
13E64:  BNZ   13E72
13E66:  MOVF   4A,F
13E68:  BNZ   13E72
13E6A:  MOVF   4B,F
13E6C:  BNZ   13E72
....................       output_bit(PIN_D3,0); 
13E6E:  BCF    F8C.3
....................    }else if(arg == 31){ 
13E70:  BRA    13F36
13E72:  MOVF   48,W
13E74:  SUBLW  1F
13E76:  BNZ   13E88
13E78:  MOVF   49,F
13E7A:  BNZ   13E88
13E7C:  MOVF   4A,F
13E7E:  BNZ   13E88
13E80:  MOVF   4B,F
13E82:  BNZ   13E88
....................       output_bit(PIN_D3,1); 
13E84:  BSF    F8C.3
....................    }else if(arg == 40){ 
13E86:  BRA    13F36
13E88:  MOVF   48,W
13E8A:  SUBLW  28
13E8C:  BNZ   13E9E
13E8E:  MOVF   49,F
13E90:  BNZ   13E9E
13E92:  MOVF   4A,F
13E94:  BNZ   13E9E
13E96:  MOVF   4B,F
13E98:  BNZ   13E9E
....................       output_bit(PIN_D4,0); 
13E9A:  BCF    F8C.4
....................    }else if(arg == 41){ 
13E9C:  BRA    13F36
13E9E:  MOVF   48,W
13EA0:  SUBLW  29
13EA2:  BNZ   13EB4
13EA4:  MOVF   49,F
13EA6:  BNZ   13EB4
13EA8:  MOVF   4A,F
13EAA:  BNZ   13EB4
13EAC:  MOVF   4B,F
13EAE:  BNZ   13EB4
....................       output_bit(PIN_D4,1); 
13EB0:  BSF    F8C.4
....................    }else if(arg == 50){ 
13EB2:  BRA    13F36
13EB4:  MOVF   48,W
13EB6:  SUBLW  32
13EB8:  BNZ   13ECA
13EBA:  MOVF   49,F
13EBC:  BNZ   13ECA
13EBE:  MOVF   4A,F
13EC0:  BNZ   13ECA
13EC2:  MOVF   4B,F
13EC4:  BNZ   13ECA
....................       output_bit(PIN_D5,0); 
13EC6:  BCF    F8C.5
....................    }else if(arg == 51){ 
13EC8:  BRA    13F36
13ECA:  MOVF   48,W
13ECC:  SUBLW  33
13ECE:  BNZ   13EE0
13ED0:  MOVF   49,F
13ED2:  BNZ   13EE0
13ED4:  MOVF   4A,F
13ED6:  BNZ   13EE0
13ED8:  MOVF   4B,F
13EDA:  BNZ   13EE0
....................       output_bit(PIN_D5,1); 
13EDC:  BSF    F8C.5
....................    }else if(arg == 60){ 
13EDE:  BRA    13F36
13EE0:  MOVF   48,W
13EE2:  SUBLW  3C
13EE4:  BNZ   13EF6
13EE6:  MOVF   49,F
13EE8:  BNZ   13EF6
13EEA:  MOVF   4A,F
13EEC:  BNZ   13EF6
13EEE:  MOVF   4B,F
13EF0:  BNZ   13EF6
....................       output_bit(PIN_D6,0); 
13EF2:  BCF    F8C.6
....................    }else if(arg == 61){ 
13EF4:  BRA    13F36
13EF6:  MOVF   48,W
13EF8:  SUBLW  3D
13EFA:  BNZ   13F0C
13EFC:  MOVF   49,F
13EFE:  BNZ   13F0C
13F00:  MOVF   4A,F
13F02:  BNZ   13F0C
13F04:  MOVF   4B,F
13F06:  BNZ   13F0C
....................       output_bit(PIN_D6,1); 
13F08:  BSF    F8C.6
....................    }else if(arg == 70){ 
13F0A:  BRA    13F36
13F0C:  MOVF   48,W
13F0E:  SUBLW  46
13F10:  BNZ   13F22
13F12:  MOVF   49,F
13F14:  BNZ   13F22
13F16:  MOVF   4A,F
13F18:  BNZ   13F22
13F1A:  MOVF   4B,F
13F1C:  BNZ   13F22
....................       output_bit(PIN_D7,0); 
13F1E:  BCF    F8C.7
....................    }else if(arg == 71){ 
13F20:  BRA    13F36
13F22:  MOVF   48,W
13F24:  SUBLW  47
13F26:  BNZ   13F36
13F28:  MOVF   49,F
13F2A:  BNZ   13F36
13F2C:  MOVF   4A,F
13F2E:  BNZ   13F36
13F30:  MOVF   4B,F
13F32:  BNZ   13F36
....................       output_bit(PIN_D7,1); 
13F34:  BSF    F8C.7
....................    } 
13F36:  RETURN 0
.................... } 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1AE14:  MOVF   4B,F
1AE16:  BNZ   1AEE0
1AE18:  MOVF   4A,F
1AE1A:  BNZ   1AEE0
1AE1C:  MOVF   49,F
1AE1E:  BNZ   1AEE0
1AE20:  MOVF   48,W
1AE22:  SUBLW  64
1AE24:  BNC   1AEE0
....................       drive_pc=arg; 
1AE26:  MOVFF  49,886
1AE2A:  MOVFF  48,885
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1AE2E:  BCF    FD8.0
1AE30:  MOVLB  7
1AE32:  RLCF   x40,W
1AE34:  CLRF   03
1AE36:  ADDLW  56
1AE38:  MOVWF  FE9
1AE3A:  MOVLW  07
1AE3C:  ADDWFC 03,W
1AE3E:  MOVWF  FEA
1AE40:  MOVFF  886,A11
1AE44:  MOVFF  885,A10
1AE48:  MOVLW  01
1AE4A:  MOVLB  A
1AE4C:  MOVWF  x13
1AE4E:  SETF   x12
1AE50:  MOVLB  0
1AE52:  CALL   5C98
1AE56:  MOVFF  02,88A
1AE5A:  MOVFF  01,889
1AE5E:  MOVFF  02,8DC
1AE62:  MOVFF  01,8DB
1AE66:  MOVLB  8
1AE68:  CLRF   xDE
1AE6A:  MOVLW  64
1AE6C:  MOVWF  xDD
1AE6E:  MOVLB  0
1AE70:  CALL   2CD4
1AE74:  MOVFF  01,FEF
1AE78:  MOVFF  02,FEC
....................       switch(motor){ 
1AE7C:  MOVLB  7
1AE7E:  MOVF   x40,W
1AE80:  XORLW  00
1AE82:  MOVLB  0
1AE84:  BZ    1AE8C
1AE86:  XORLW  01
1AE88:  BZ    1AEB6
1AE8A:  BRA    1AEDE
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1AE8C:  BCF    FD8.0
1AE8E:  MOVLB  7
1AE90:  RLCF   x40,W
1AE92:  CLRF   03
1AE94:  ADDLW  56
1AE96:  MOVWF  FE9
1AE98:  MOVLW  07
1AE9A:  ADDWFC 03,W
1AE9C:  MOVWF  FEA
1AE9E:  MOVFF  FEC,8F0
1AEA2:  MOVF   FED,F
1AEA4:  MOVFF  FEF,8EF
1AEA8:  MOVLW  9A
1AEAA:  MOVLB  8
1AEAC:  MOVWF  xEE
1AEAE:  MOVLB  0
1AEB0:  CALL   4FD4
....................             break; 
1AEB4:  BRA    1AEDE
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1AEB6:  BCF    FD8.0
1AEB8:  MOVLB  7
1AEBA:  RLCF   x40,W
1AEBC:  CLRF   03
1AEBE:  ADDLW  56
1AEC0:  MOVWF  FE9
1AEC2:  MOVLW  07
1AEC4:  ADDWFC 03,W
1AEC6:  MOVWF  FEA
1AEC8:  MOVFF  FEC,8F0
1AECC:  MOVF   FED,F
1AECE:  MOVFF  FEF,8EF
1AED2:  MOVLW  9C
1AED4:  MOVLB  8
1AED6:  MOVWF  xEE
1AED8:  MOVLB  0
1AEDA:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1AEDE:  BRA    1AEE4
....................    else cmd_arg();    
1AEE0:  CALL   B2FE
1AEE4:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1AEE8:  MOVF   4B,F
1AEEA:  BNZ   1AF7A
1AEEC:  MOVF   4A,F
1AEEE:  BNZ   1AF7A
1AEF0:  MOVF   49,W
1AEF2:  SUBLW  27
1AEF4:  BNC   1AF7A
1AEF6:  BNZ   1AEFE
1AEF8:  MOVF   48,W
1AEFA:  SUBLW  0F
1AEFC:  BNC   1AF7A
....................        align_os[motor] = arg; 
1AEFE:  BCF    FD8.0
1AF00:  MOVLB  7
1AF02:  RLCF   x40,W
1AF04:  CLRF   03
1AF06:  ADDLW  82
1AF08:  MOVWF  FE9
1AF0A:  MOVLW  07
1AF0C:  ADDWFC 03,W
1AF0E:  MOVWF  FEA
1AF10:  MOVFF  48,FEF
1AF14:  MOVFF  49,FEC
....................        switch(motor){ 
1AF18:  MOVF   x40,W
1AF1A:  XORLW  00
1AF1C:  MOVLB  0
1AF1E:  BZ    1AF26
1AF20:  XORLW  01
1AF22:  BZ    1AF50
1AF24:  BRA    1AF78
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1AF26:  BCF    FD8.0
1AF28:  MOVLB  7
1AF2A:  RLCF   x40,W
1AF2C:  CLRF   03
1AF2E:  ADDLW  82
1AF30:  MOVWF  FE9
1AF32:  MOVLW  07
1AF34:  ADDWFC 03,W
1AF36:  MOVWF  FEA
1AF38:  MOVFF  FEC,8F0
1AF3C:  MOVF   FED,F
1AF3E:  MOVFF  FEF,8EF
1AF42:  MOVLW  C2
1AF44:  MOVLB  8
1AF46:  MOVWF  xEE
1AF48:  MOVLB  0
1AF4A:  CALL   4FD4
....................             break; 
1AF4E:  BRA    1AF78
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1AF50:  BCF    FD8.0
1AF52:  MOVLB  7
1AF54:  RLCF   x40,W
1AF56:  CLRF   03
1AF58:  ADDLW  82
1AF5A:  MOVWF  FE9
1AF5C:  MOVLW  07
1AF5E:  ADDWFC 03,W
1AF60:  MOVWF  FEA
1AF62:  MOVFF  FEC,8F0
1AF66:  MOVF   FED,F
1AF68:  MOVFF  FEF,8EF
1AF6C:  MOVLW  C4
1AF6E:  MOVLB  8
1AF70:  MOVWF  xEE
1AF72:  MOVLB  0
1AF74:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1AF78:  BRA    1AF7E
....................    else cmd_arg();    
1AF7A:  CALL   B2FE
1AF7E:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1AF82:  MOVF   4B,F
1AF84:  BNZ   1B010
1AF86:  MOVF   4A,F
1AF88:  BNZ   1B010
1AF8A:  MOVF   49,F
1AF8C:  BNZ   1B010
1AF8E:  MOVF   48,W
1AF90:  SUBLW  01
1AF92:  BNC   1B010
....................       m_ctrl[motor] = arg; 
1AF94:  BCF    FD8.0
1AF96:  MOVLB  7
1AF98:  RLCF   x40,W
1AF9A:  CLRF   03
1AF9C:  ADDLW  42
1AF9E:  MOVWF  FE9
1AFA0:  MOVLW  07
1AFA2:  ADDWFC 03,W
1AFA4:  MOVWF  FEA
1AFA6:  MOVFF  48,FEF
1AFAA:  MOVFF  49,FEC
....................       switch(motor){ 
1AFAE:  MOVF   x40,W
1AFB0:  XORLW  00
1AFB2:  MOVLB  0
1AFB4:  BZ    1AFBC
1AFB6:  XORLW  01
1AFB8:  BZ    1AFE6
1AFBA:  BRA    1B00E
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1AFBC:  BCF    FD8.0
1AFBE:  MOVLB  7
1AFC0:  RLCF   x40,W
1AFC2:  CLRF   03
1AFC4:  ADDLW  42
1AFC6:  MOVWF  FE9
1AFC8:  MOVLW  07
1AFCA:  ADDWFC 03,W
1AFCC:  MOVWF  FEA
1AFCE:  MOVFF  FEC,8F0
1AFD2:  MOVF   FED,F
1AFD4:  MOVFF  FEF,8EF
1AFD8:  MOVLW  86
1AFDA:  MOVLB  8
1AFDC:  MOVWF  xEE
1AFDE:  MOVLB  0
1AFE0:  CALL   4FD4
....................             break; 
1AFE4:  BRA    1B00E
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1AFE6:  BCF    FD8.0
1AFE8:  MOVLB  7
1AFEA:  RLCF   x40,W
1AFEC:  CLRF   03
1AFEE:  ADDLW  42
1AFF0:  MOVWF  FE9
1AFF2:  MOVLW  07
1AFF4:  ADDWFC 03,W
1AFF6:  MOVWF  FEA
1AFF8:  MOVFF  FEC,8F0
1AFFC:  MOVF   FED,F
1AFFE:  MOVFF  FEF,8EF
1B002:  MOVLW  88
1B004:  MOVLB  8
1B006:  MOVWF  xEE
1B008:  MOVLB  0
1B00A:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1B00E:  BRA    1B014
....................    else cmd_arg();    
1B010:  CALL   B2FE
1B014:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1ADDC:  MOVF   48,W
1ADDE:  MOVWF  00
1ADE0:  MOVF   49,W
1ADE2:  MOVWF  03
1ADE4:  BNZ   1ADEC
1ADE6:  MOVLW  01
1ADE8:  SUBWF  00,W
1ADEA:  BZ    1ADF8
1ADEC:  MOVF   03,W
1ADEE:  BNZ   1ADF6
1ADF0:  MOVLW  02
1ADF2:  SUBWF  00,W
1ADF4:  BZ    1ADFE
1ADF6:  BRA    1AE08
....................       case 1: motor = 0; 
1ADF8:  MOVLB  7
1ADFA:  CLRF   x40
....................          break; 
1ADFC:  BRA    1AE0E
....................       case 2: motor = 1; 
1ADFE:  MOVLW  01
1AE00:  MOVLB  7
1AE02:  MOVWF  x40
....................          break; 
1AE04:  BRA    1AE0E
1AE06:  MOVLB  0
....................       default : cmd_arg(); 
1AE08:  CALL   B2FE
....................          break; 
1AE0C:  MOVLB  7
....................    } 
1AE0E:  MOVLB  0
1AE10:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1B018:  MOVF   48,F
1B01A:  BNZ   1B028
1B01C:  MOVF   49,F
1B01E:  BNZ   1B028
1B020:  MOVF   4A,F
1B022:  BNZ   1B028
1B024:  MOVF   4B,F
1B026:  BZ    1B086
1B028:  MOVF   4B,F
1B02A:  BNZ   1B086
1B02C:  MOVF   4A,F
1B02E:  BNZ   1B086
1B030:  MOVF   49,F
1B032:  BNZ   1B086
1B034:  MOVF   48,W
1B036:  SUBLW  02
1B038:  BNC   1B086
....................       switch(arg){ 
1B03A:  MOVFF  48,00
1B03E:  MOVF   49,W
1B040:  MOVWF  03
1B042:  BNZ   1B04A
1B044:  MOVLW  01
1B046:  SUBWF  00,W
1B048:  BZ    1B056
1B04A:  MOVF   03,W
1B04C:  BNZ   1B054
1B04E:  MOVLW  02
1B050:  SUBWF  00,W
1B052:  BZ    1B06E
1B054:  BRA    1B084
....................          case 1 : e_pos[0] = 0; 
1B056:  MOVLB  7
1B058:  CLRF   xC0
1B05A:  CLRF   xBF
....................                   write16(ADDR_E1_POS, 0); 
1B05C:  MOVLW  7E
1B05E:  MOVLB  8
1B060:  MOVWF  xEE
1B062:  CLRF   xF0
1B064:  CLRF   xEF
1B066:  MOVLB  0
1B068:  CALL   4FD4
....................             break; 
1B06C:  BRA    1B084
....................          case 2 : e_pos[1] = 0; 
1B06E:  MOVLB  7
1B070:  CLRF   xC2
1B072:  CLRF   xC1
....................                   write16(ADDR_E2_POS, 0); 
1B074:  MOVLW  80
1B076:  MOVLB  8
1B078:  MOVWF  xEE
1B07A:  CLRF   xF0
1B07C:  CLRF   xEF
1B07E:  MOVLB  0
1B080:  CALL   4FD4
....................             break;             
....................       } 
....................    } 
1B084:  BRA    1B08A
....................    else cmd_arg();  
1B086:  CALL   B2FE
1B08A:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
19222:  DECFSZ 48,W
19224:  GOTO   19E7A
19228:  MOVF   49,F
1922A:  BTFSS  FD8.2
1922C:  GOTO   19E7A
19230:  MOVF   4A,F
19232:  BTFSS  FD8.2
19234:  GOTO   19E7A
19238:  MOVF   4B,F
1923A:  BTFSS  FD8.2
1923C:  GOTO   19E7A
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
19240:  MOVFF  753,A11
19244:  MOVFF  752,A10
19248:  MOVLB  A
1924A:  CLRF   x13
1924C:  MOVLW  64
1924E:  MOVWF  x12
19250:  MOVLB  0
19252:  CALL   5C98
19256:  MOVFF  02,88C
1925A:  MOVFF  01,88B
1925E:  MOVFF  02,8DC
19262:  MOVFF  01,8DB
19266:  MOVLW  01
19268:  MOVLB  8
1926A:  MOVWF  xDE
1926C:  SETF   xDD
1926E:  MOVLB  0
19270:  CALL   2CD4
19274:  MOVFF  02,886
19278:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
1927C:  MOVFF  757,A11
19280:  MOVFF  756,A10
19284:  MOVLB  A
19286:  CLRF   x13
19288:  MOVLW  64
1928A:  MOVWF  x12
1928C:  MOVLB  0
1928E:  CALL   5C98
19292:  MOVFF  02,88C
19296:  MOVFF  01,88B
1929A:  MOVFF  02,8DC
1929E:  MOVFF  01,8DB
192A2:  MOVLW  01
192A4:  MOVLB  8
192A6:  MOVWF  xDE
192A8:  SETF   xDD
192AA:  MOVLB  0
192AC:  CALL   2CD4
192B0:  MOVFF  02,888
192B4:  MOVFF  01,887
....................       step_us  =   m_stp_int[0]*100; 
192B8:  MOVFF  74B,A11
192BC:  MOVFF  74A,A10
192C0:  MOVLB  A
192C2:  CLRF   x13
192C4:  MOVLW  64
192C6:  MOVWF  x12
192C8:  MOVLB  0
192CA:  CALL   5C98
192CE:  MOVFF  02,88A
192D2:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
192D6:  MOVLW  12
192D8:  MOVWF  FF6
192DA:  MOVLW  27
192DC:  MOVWF  FF7
192DE:  MOVLW  00
192E0:  MOVWF  FF8
192E2:  CLRF   1B
192E4:  BTFSC  FF2.7
192E6:  BSF    1B.7
192E8:  BCF    FF2.7
192EA:  CALL   0E46
192EE:  BTFSC  1B.7
192F0:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
192F2:  MOVLW  62
192F4:  BTFSS  F9E.4
192F6:  BRA    192F4
192F8:  MOVWF  FAD
192FA:  MOVLW  3A
192FC:  BTFSS  F9E.4
192FE:  BRA    192FC
19300:  MOVWF  FAD
19302:  MOVLW  10
19304:  MOVWF  FE9
19306:  CLRF   1B
19308:  BTFSC  FF2.7
1930A:  BSF    1B.7
1930C:  BCF    FF2.7
1930E:  MOVFF  773,A41
19312:  MOVFF  772,A40
19316:  CALL   119E
1931A:  BTFSC  1B.7
1931C:  BSF    FF2.7
1931E:  MOVLW  0D
19320:  BTFSS  F9E.4
19322:  BRA    19320
19324:  MOVWF  FAD
19326:  MOVLW  0A
19328:  BTFSS  F9E.4
1932A:  BRA    19328
1932C:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
1932E:  MOVLW  63
19330:  BTFSS  F9E.4
19332:  BRA    19330
19334:  MOVWF  FAD
19336:  MOVLW  3A
19338:  BTFSS  F9E.4
1933A:  BRA    19338
1933C:  MOVWF  FAD
1933E:  MOVLW  41
19340:  MOVWF  FE9
19342:  CLRF   1B
19344:  BTFSC  FF2.7
19346:  BSF    1B.7
19348:  BCF    FF2.7
1934A:  MOVFF  7A5,A43
1934E:  MOVFF  7A4,A42
19352:  MOVFF  7A3,A41
19356:  MOVFF  7A2,A40
1935A:  CALL   10E2
1935E:  BTFSC  1B.7
19360:  BSF    FF2.7
19362:  MOVLW  2F
19364:  BTFSS  F9E.4
19366:  BRA    19364
19368:  MOVWF  FAD
1936A:  MOVLW  10
1936C:  MOVWF  FE9
1936E:  CLRF   1B
19370:  BTFSC  FF2.7
19372:  BSF    1B.7
19374:  BCF    FF2.7
19376:  MOVFF  7BC,A41
1937A:  MOVFF  7BB,A40
1937E:  CALL   119E
19382:  BTFSC  1B.7
19384:  BSF    FF2.7
19386:  MOVLW  2F
19388:  BTFSS  F9E.4
1938A:  BRA    19388
1938C:  MOVWF  FAD
1938E:  MOVLW  10
19390:  MOVWF  FE9
19392:  CLRF   1B
19394:  BTFSC  FF2.7
19396:  BSF    1B.7
19398:  BCF    FF2.7
1939A:  MOVFF  7C0,A41
1939E:  MOVFF  7BF,A40
193A2:  CALL   119E
193A6:  BTFSC  1B.7
193A8:  BSF    FF2.7
193AA:  MOVLW  0D
193AC:  BTFSS  F9E.4
193AE:  BRA    193AC
193B0:  MOVWF  FAD
193B2:  MOVLW  0A
193B4:  BTFSS  F9E.4
193B6:  BRA    193B4
193B8:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
193BA:  MOVLW  64
193BC:  BTFSS  F9E.4
193BE:  BRA    193BC
193C0:  MOVWF  FAD
193C2:  MOVLW  3A
193C4:  BTFSS  F9E.4
193C6:  BRA    193C4
193C8:  MOVWF  FAD
193CA:  MOVLW  10
193CC:  MOVWF  FE9
193CE:  CLRF   1B
193D0:  BTFSC  FF2.7
193D2:  BSF    1B.7
193D4:  BCF    FF2.7
193D6:  MOVFF  74F,A41
193DA:  MOVFF  74E,A40
193DE:  CALL   119E
193E2:  BTFSC  1B.7
193E4:  BSF    FF2.7
193E6:  MOVLW  0D
193E8:  BTFSS  F9E.4
193EA:  BRA    193E8
193EC:  MOVWF  FAD
193EE:  MOVLW  0A
193F0:  BTFSS  F9E.4
193F2:  BRA    193F0
193F4:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
193F6:  MOVLW  65
193F8:  BTFSS  F9E.4
193FA:  BRA    193F8
193FC:  MOVWF  FAD
193FE:  MOVLW  3A
19400:  BTFSS  F9E.4
19402:  BRA    19400
19404:  MOVWF  FAD
19406:  MOVLW  10
19408:  MOVWF  FE9
1940A:  CLRF   1B
1940C:  BTFSC  FF2.7
1940E:  BSF    1B.7
19410:  BCF    FF2.7
19412:  MOVFF  75F,A41
19416:  MOVFF  75E,A40
1941A:  CALL   119E
1941E:  BTFSC  1B.7
19420:  BSF    FF2.7
19422:  MOVLW  0D
19424:  BTFSS  F9E.4
19426:  BRA    19424
19428:  MOVWF  FAD
1942A:  MOVLW  0A
1942C:  BTFSS  F9E.4
1942E:  BRA    1942C
19430:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19432:  MOVLW  66
19434:  BTFSS  F9E.4
19436:  BRA    19434
19438:  MOVWF  FAD
1943A:  MOVLW  3A
1943C:  BTFSS  F9E.4
1943E:  BRA    1943C
19440:  MOVWF  FAD
19442:  CLRF   1B
19444:  BTFSC  FF2.7
19446:  BSF    1B.7
19448:  BCF    FF2.7
1944A:  MOVFF  741,A40
1944E:  MOVLW  1B
19450:  MOVLB  A
19452:  MOVWF  x41
19454:  MOVLB  0
19456:  CALL   0F9E
1945A:  BTFSC  1B.7
1945C:  BSF    FF2.7
1945E:  MOVLW  0D
19460:  BTFSS  F9E.4
19462:  BRA    19460
19464:  MOVWF  FAD
19466:  MOVLW  0A
19468:  BTFSS  F9E.4
1946A:  BRA    19468
1946C:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
1946E:  MOVLW  67
19470:  BTFSS  F9E.4
19472:  BRA    19470
19474:  MOVWF  FAD
19476:  MOVLW  3A
19478:  BTFSS  F9E.4
1947A:  BRA    19478
1947C:  MOVWF  FAD
1947E:  MOVLW  10
19480:  MOVWF  FE9
19482:  CLRF   1B
19484:  BTFSC  FF2.7
19486:  BSF    1B.7
19488:  BCF    FF2.7
1948A:  MOVFF  75B,A41
1948E:  MOVFF  75A,A40
19492:  CALL   119E
19496:  BTFSC  1B.7
19498:  BSF    FF2.7
1949A:  MOVLW  0D
1949C:  BTFSS  F9E.4
1949E:  BRA    1949C
194A0:  MOVWF  FAD
194A2:  MOVLW  0A
194A4:  BTFSS  F9E.4
194A6:  BRA    194A4
194A8:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
194AA:  MOVLW  68
194AC:  BTFSS  F9E.4
194AE:  BRA    194AC
194B0:  MOVWF  FAD
194B2:  MOVLW  3A
194B4:  BTFSS  F9E.4
194B6:  BRA    194B4
194B8:  MOVWF  FAD
194BA:  MOVLW  10
194BC:  MOVWF  FE9
194BE:  CLRF   1B
194C0:  BTFSC  FF2.7
194C2:  BSF    1B.7
194C4:  BCF    FF2.7
194C6:  MOVFF  886,A41
194CA:  MOVFF  885,A40
194CE:  CALL   119E
194D2:  BTFSC  1B.7
194D4:  BSF    FF2.7
194D6:  MOVLW  0D
194D8:  BTFSS  F9E.4
194DA:  BRA    194D8
194DC:  MOVWF  FAD
194DE:  MOVLW  0A
194E0:  BTFSS  F9E.4
194E2:  BRA    194E0
194E4:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
194E6:  MOVLW  69
194E8:  BTFSS  F9E.4
194EA:  BRA    194E8
194EC:  MOVWF  FAD
194EE:  MOVLW  3A
194F0:  BTFSS  F9E.4
194F2:  BRA    194F0
194F4:  MOVWF  FAD
194F6:  MOVLW  10
194F8:  MOVWF  FE9
194FA:  CLRF   1B
194FC:  BTFSC  FF2.7
194FE:  BSF    1B.7
19500:  BCF    FF2.7
19502:  MOVFF  88A,A41
19506:  MOVFF  889,A40
1950A:  CALL   119E
1950E:  BTFSC  1B.7
19510:  BSF    FF2.7
19512:  MOVLW  0D
19514:  BTFSS  F9E.4
19516:  BRA    19514
19518:  MOVWF  FAD
1951A:  MOVLW  0A
1951C:  BTFSS  F9E.4
1951E:  BRA    1951C
19520:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
19522:  MOVLW  6A
19524:  BTFSS  F9E.4
19526:  BRA    19524
19528:  MOVWF  FAD
1952A:  MOVLW  3A
1952C:  BTFSS  F9E.4
1952E:  BRA    1952C
19530:  MOVWF  FAD
19532:  MOVLW  10
19534:  MOVWF  FE9
19536:  CLRF   1B
19538:  BTFSC  FF2.7
1953A:  BSF    1B.7
1953C:  BCF    FF2.7
1953E:  MOVFF  76F,A41
19542:  MOVFF  76E,A40
19546:  CALL   119E
1954A:  BTFSC  1B.7
1954C:  BSF    FF2.7
1954E:  MOVLW  0D
19550:  BTFSS  F9E.4
19552:  BRA    19550
19554:  MOVWF  FAD
19556:  MOVLW  0A
19558:  BTFSS  F9E.4
1955A:  BRA    19558
1955C:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
1955E:  MOVLW  6B
19560:  BTFSS  F9E.4
19562:  BRA    19560
19564:  MOVWF  FAD
19566:  MOVLW  3A
19568:  BTFSS  F9E.4
1956A:  BRA    19568
1956C:  MOVWF  FAD
1956E:  MOVLW  10
19570:  MOVWF  FE9
19572:  CLRF   1B
19574:  BTFSC  FF2.7
19576:  BSF    1B.7
19578:  BCF    FF2.7
1957A:  MOVFF  767,A41
1957E:  MOVFF  766,A40
19582:  CALL   119E
19586:  BTFSC  1B.7
19588:  BSF    FF2.7
1958A:  MOVLW  0D
1958C:  BTFSS  F9E.4
1958E:  BRA    1958C
19590:  MOVWF  FAD
19592:  MOVLW  0A
19594:  BTFSS  F9E.4
19596:  BRA    19594
19598:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
1959A:  MOVLW  6D
1959C:  BTFSS  F9E.4
1959E:  BRA    1959C
195A0:  MOVWF  FAD
195A2:  MOVLW  3A
195A4:  BTFSS  F9E.4
195A6:  BRA    195A4
195A8:  MOVWF  FAD
195AA:  MOVLW  10
195AC:  MOVWF  FE9
195AE:  CLRF   1B
195B0:  BTFSC  FF2.7
195B2:  BSF    1B.7
195B4:  BCF    FF2.7
195B6:  MOVFF  747,A41
195BA:  MOVFF  746,A40
195BE:  CALL   119E
195C2:  BTFSC  1B.7
195C4:  BSF    FF2.7
195C6:  MOVLW  0D
195C8:  BTFSS  F9E.4
195CA:  BRA    195C8
195CC:  MOVWF  FAD
195CE:  MOVLW  0A
195D0:  BTFSS  F9E.4
195D2:  BRA    195D0
195D4:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
195D6:  MOVLW  6E
195D8:  BTFSS  F9E.4
195DA:  BRA    195D8
195DC:  MOVWF  FAD
195DE:  MOVLW  3A
195E0:  BTFSS  F9E.4
195E2:  BRA    195E0
195E4:  MOVWF  FAD
195E6:  MOVLW  10
195E8:  MOVWF  FE9
195EA:  CLRF   1B
195EC:  BTFSC  FF2.7
195EE:  BSF    1B.7
195F0:  BCF    FF2.7
195F2:  MOVFF  77B,A41
195F6:  MOVFF  77A,A40
195FA:  CALL   119E
195FE:  BTFSC  1B.7
19600:  BSF    FF2.7
19602:  MOVLW  0D
19604:  BTFSS  F9E.4
19606:  BRA    19604
19608:  MOVWF  FAD
1960A:  MOVLW  0A
1960C:  BTFSS  F9E.4
1960E:  BRA    1960C
19610:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
19612:  MOVLW  6F
19614:  BTFSS  F9E.4
19616:  BRA    19614
19618:  MOVWF  FAD
1961A:  MOVLW  3A
1961C:  BTFSS  F9E.4
1961E:  BRA    1961C
19620:  MOVWF  FAD
19622:  MOVLW  10
19624:  MOVWF  FE9
19626:  CLRF   1B
19628:  BTFSC  FF2.7
1962A:  BSF    1B.7
1962C:  BCF    FF2.7
1962E:  MOVFF  77F,A41
19632:  MOVFF  77E,A40
19636:  CALL   119E
1963A:  BTFSC  1B.7
1963C:  BSF    FF2.7
1963E:  MOVLW  0D
19640:  BTFSS  F9E.4
19642:  BRA    19640
19644:  MOVWF  FAD
19646:  MOVLW  0A
19648:  BTFSS  F9E.4
1964A:  BRA    19648
1964C:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
1964E:  MOVLW  70
19650:  BTFSS  F9E.4
19652:  BRA    19650
19654:  MOVWF  FAD
19656:  MOVLW  3A
19658:  BTFSS  F9E.4
1965A:  BRA    19658
1965C:  MOVWF  FAD
1965E:  MOVLW  10
19660:  MOVWF  FE9
19662:  CLRF   1B
19664:  BTFSC  FF2.7
19666:  BSF    1B.7
19668:  BCF    FF2.7
1966A:  MOVFF  7C4,A41
1966E:  MOVFF  7C3,A40
19672:  CALL   119E
19676:  BTFSC  1B.7
19678:  BSF    FF2.7
1967A:  MOVLW  2F
1967C:  BTFSS  F9E.4
1967E:  BRA    1967C
19680:  MOVWF  FAD
19682:  MOVLW  10
19684:  MOVWF  FE9
19686:  CLRF   1B
19688:  BTFSC  FF2.7
1968A:  BSF    1B.7
1968C:  BCF    FF2.7
1968E:  MOVFF  763,A41
19692:  MOVFF  762,A40
19696:  CALL   119E
1969A:  BTFSC  1B.7
1969C:  BSF    FF2.7
1969E:  MOVLW  0D
196A0:  BTFSS  F9E.4
196A2:  BRA    196A0
196A4:  MOVWF  FAD
196A6:  MOVLW  0A
196A8:  BTFSS  F9E.4
196AA:  BRA    196A8
196AC:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
196AE:  MOVLW  71
196B0:  BTFSS  F9E.4
196B2:  BRA    196B0
196B4:  MOVWF  FAD
196B6:  MOVLW  3A
196B8:  BTFSS  F9E.4
196BA:  BRA    196B8
196BC:  MOVWF  FAD
196BE:  MOVLW  10
196C0:  MOVWF  FE9
196C2:  CLRF   1B
196C4:  BTFSC  FF2.7
196C6:  BSF    1B.7
196C8:  BCF    FF2.7
196CA:  MOVFF  797,A41
196CE:  MOVFF  796,A40
196D2:  CALL   119E
196D6:  BTFSC  1B.7
196D8:  BSF    FF2.7
196DA:  MOVLW  0D
196DC:  BTFSS  F9E.4
196DE:  BRA    196DC
196E0:  MOVWF  FAD
196E2:  MOVLW  0A
196E4:  BTFSS  F9E.4
196E6:  BRA    196E4
196E8:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
196EA:  MOVLW  73
196EC:  BTFSS  F9E.4
196EE:  BRA    196EC
196F0:  MOVWF  FAD
196F2:  MOVLW  3A
196F4:  BTFSS  F9E.4
196F6:  BRA    196F4
196F8:  MOVWF  FAD
196FA:  MOVLW  10
196FC:  MOVWF  FE9
196FE:  CLRF   1B
19700:  BTFSC  FF2.7
19702:  BSF    1B.7
19704:  BCF    FF2.7
19706:  MOVFF  777,A41
1970A:  MOVFF  776,A40
1970E:  CALL   119E
19712:  BTFSC  1B.7
19714:  BSF    FF2.7
19716:  MOVLW  0D
19718:  BTFSS  F9E.4
1971A:  BRA    19718
1971C:  MOVWF  FAD
1971E:  MOVLW  0A
19720:  BTFSS  F9E.4
19722:  BRA    19720
19724:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
19726:  MOVLW  74
19728:  BTFSS  F9E.4
1972A:  BRA    19728
1972C:  MOVWF  FAD
1972E:  MOVLW  3A
19730:  BTFSS  F9E.4
19732:  BRA    19730
19734:  MOVWF  FAD
19736:  MOVLW  10
19738:  MOVWF  FE9
1973A:  CLRF   1B
1973C:  BTFSC  FF2.7
1973E:  BSF    1B.7
19740:  BCF    FF2.7
19742:  MOVFF  76B,A41
19746:  MOVFF  76A,A40
1974A:  CALL   119E
1974E:  BTFSC  1B.7
19750:  BSF    FF2.7
19752:  MOVLW  0D
19754:  BTFSS  F9E.4
19756:  BRA    19754
19758:  MOVWF  FAD
1975A:  MOVLW  0A
1975C:  BTFSS  F9E.4
1975E:  BRA    1975C
19760:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19762:  MOVLW  01
19764:  MOVLB  7
19766:  ADDWF  x40,W
19768:  MOVLB  8
1976A:  MOVWF  x8B
1976C:  MOVLW  75
1976E:  BTFSS  F9E.4
19770:  BRA    1976E
19772:  MOVWF  FAD
19774:  MOVLW  3A
19776:  BTFSS  F9E.4
19778:  BRA    19776
1977A:  MOVWF  FAD
1977C:  CLRF   1B
1977E:  BTFSC  FF2.7
19780:  BSF    1B.7
19782:  BCF    FF2.7
19784:  MOVFF  88B,A40
19788:  MOVLW  1B
1978A:  MOVLB  A
1978C:  MOVWF  x41
1978E:  MOVLB  0
19790:  CALL   0F9E
19794:  BTFSC  1B.7
19796:  BSF    FF2.7
19798:  MOVLW  0D
1979A:  BTFSS  F9E.4
1979C:  BRA    1979A
1979E:  MOVWF  FAD
197A0:  MOVLW  0A
197A2:  BTFSS  F9E.4
197A4:  BRA    197A2
197A6:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
197A8:  MOVLW  77
197AA:  BTFSS  F9E.4
197AC:  BRA    197AA
197AE:  MOVWF  FAD
197B0:  MOVLW  3A
197B2:  BTFSS  F9E.4
197B4:  BRA    197B2
197B6:  MOVWF  FAD
197B8:  MOVLW  10
197BA:  MOVWF  FE9
197BC:  CLRF   1B
197BE:  BTFSC  FF2.7
197C0:  BSF    1B.7
197C2:  BCF    FF2.7
197C4:  MOVFF  888,A41
197C8:  MOVFF  887,A40
197CC:  CALL   119E
197D0:  BTFSC  1B.7
197D2:  BSF    FF2.7
197D4:  MOVLW  0D
197D6:  BTFSS  F9E.4
197D8:  BRA    197D6
197DA:  MOVWF  FAD
197DC:  MOVLW  0A
197DE:  BTFSS  F9E.4
197E0:  BRA    197DE
197E2:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
197E4:  MOVLW  78
197E6:  BTFSS  F9E.4
197E8:  BRA    197E6
197EA:  MOVWF  FAD
197EC:  MOVLW  3A
197EE:  BTFSS  F9E.4
197F0:  BRA    197EE
197F2:  MOVWF  FAD
197F4:  MOVLW  10
197F6:  MOVWF  FE9
197F8:  CLRF   1B
197FA:  BTFSC  FF2.7
197FC:  BSF    1B.7
197FE:  BCF    FF2.7
19800:  MOVFF  783,A41
19804:  MOVFF  782,A40
19808:  CALL   119E
1980C:  BTFSC  1B.7
1980E:  BSF    FF2.7
19810:  MOVLW  0D
19812:  BTFSS  F9E.4
19814:  BRA    19812
19816:  MOVWF  FAD
19818:  MOVLW  0A
1981A:  BTFSS  F9E.4
1981C:  BRA    1981A
1981E:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
19820:  MOVLW  79
19822:  BTFSS  F9E.4
19824:  BRA    19822
19826:  MOVWF  FAD
19828:  MOVLW  3A
1982A:  BTFSS  F9E.4
1982C:  BRA    1982A
1982E:  MOVWF  FAD
19830:  MOVLW  10
19832:  MOVWF  FE9
19834:  CLRF   1B
19836:  BTFSC  FF2.7
19838:  BSF    1B.7
1983A:  BCF    FF2.7
1983C:  MOVFF  743,A41
19840:  MOVFF  742,A40
19844:  CALL   119E
19848:  BTFSC  1B.7
1984A:  BSF    FF2.7
1984C:  MOVLW  0D
1984E:  BTFSS  F9E.4
19850:  BRA    1984E
19852:  MOVWF  FAD
19854:  MOVLW  0A
19856:  BTFSS  F9E.4
19858:  BRA    19856
1985A:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
1985C:  MOVFF  755,A11
19860:  MOVFF  754,A10
19864:  MOVLB  A
19866:  CLRF   x13
19868:  MOVLW  64
1986A:  MOVWF  x12
1986C:  MOVLB  0
1986E:  CALL   5C98
19872:  MOVFF  02,88C
19876:  MOVFF  01,88B
1987A:  MOVFF  02,8DC
1987E:  MOVFF  01,8DB
19882:  MOVLW  01
19884:  MOVLB  8
19886:  MOVWF  xDE
19888:  SETF   xDD
1988A:  MOVLB  0
1988C:  CALL   2CD4
19890:  MOVFF  02,886
19894:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19898:  MOVFF  759,A11
1989C:  MOVFF  758,A10
198A0:  MOVLB  A
198A2:  CLRF   x13
198A4:  MOVLW  64
198A6:  MOVWF  x12
198A8:  MOVLB  0
198AA:  CALL   5C98
198AE:  MOVFF  02,88C
198B2:  MOVFF  01,88B
198B6:  MOVFF  02,8DC
198BA:  MOVFF  01,8DB
198BE:  MOVLW  01
198C0:  MOVLB  8
198C2:  MOVWF  xDE
198C4:  SETF   xDD
198C6:  MOVLB  0
198C8:  CALL   2CD4
198CC:  MOVFF  02,888
198D0:  MOVFF  01,887
....................       step_us  =   m_stp_int[1]*100; 
198D4:  MOVFF  74D,A11
198D8:  MOVFF  74C,A10
198DC:  MOVLB  A
198DE:  CLRF   x13
198E0:  MOVLW  64
198E2:  MOVWF  x12
198E4:  MOVLB  0
198E6:  CALL   5C98
198EA:  MOVFF  02,88A
198EE:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
198F2:  MOVLW  1E
198F4:  MOVWF  FF6
198F6:  MOVLW  27
198F8:  MOVWF  FF7
198FA:  MOVLW  00
198FC:  MOVWF  FF8
198FE:  CLRF   1B
19900:  BTFSC  FF2.7
19902:  BSF    1B.7
19904:  BCF    FF2.7
19906:  CALL   0E46
1990A:  BTFSC  1B.7
1990C:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
1990E:  MOVLW  62
19910:  BTFSS  F9E.4
19912:  BRA    19910
19914:  MOVWF  FAD
19916:  MOVLW  3A
19918:  BTFSS  F9E.4
1991A:  BRA    19918
1991C:  MOVWF  FAD
1991E:  MOVLW  10
19920:  MOVWF  FE9
19922:  CLRF   1B
19924:  BTFSC  FF2.7
19926:  BSF    1B.7
19928:  BCF    FF2.7
1992A:  MOVFF  775,A41
1992E:  MOVFF  774,A40
19932:  CALL   119E
19936:  BTFSC  1B.7
19938:  BSF    FF2.7
1993A:  MOVLW  0D
1993C:  BTFSS  F9E.4
1993E:  BRA    1993C
19940:  MOVWF  FAD
19942:  MOVLW  0A
19944:  BTFSS  F9E.4
19946:  BRA    19944
19948:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
1994A:  MOVLW  63
1994C:  BTFSS  F9E.4
1994E:  BRA    1994C
19950:  MOVWF  FAD
19952:  MOVLW  3A
19954:  BTFSS  F9E.4
19956:  BRA    19954
19958:  MOVWF  FAD
1995A:  MOVLW  41
1995C:  MOVWF  FE9
1995E:  CLRF   1B
19960:  BTFSC  FF2.7
19962:  BSF    1B.7
19964:  BCF    FF2.7
19966:  MOVFF  7A9,A43
1996A:  MOVFF  7A8,A42
1996E:  MOVFF  7A7,A41
19972:  MOVFF  7A6,A40
19976:  CALL   10E2
1997A:  BTFSC  1B.7
1997C:  BSF    FF2.7
1997E:  MOVLW  2F
19980:  BTFSS  F9E.4
19982:  BRA    19980
19984:  MOVWF  FAD
19986:  MOVLW  10
19988:  MOVWF  FE9
1998A:  CLRF   1B
1998C:  BTFSC  FF2.7
1998E:  BSF    1B.7
19990:  BCF    FF2.7
19992:  MOVFF  7BE,A41
19996:  MOVFF  7BD,A40
1999A:  CALL   119E
1999E:  BTFSC  1B.7
199A0:  BSF    FF2.7
199A2:  MOVLW  2F
199A4:  BTFSS  F9E.4
199A6:  BRA    199A4
199A8:  MOVWF  FAD
199AA:  MOVLW  10
199AC:  MOVWF  FE9
199AE:  CLRF   1B
199B0:  BTFSC  FF2.7
199B2:  BSF    1B.7
199B4:  BCF    FF2.7
199B6:  MOVFF  7C2,A41
199BA:  MOVFF  7C1,A40
199BE:  CALL   119E
199C2:  BTFSC  1B.7
199C4:  BSF    FF2.7
199C6:  MOVLW  0D
199C8:  BTFSS  F9E.4
199CA:  BRA    199C8
199CC:  MOVWF  FAD
199CE:  MOVLW  0A
199D0:  BTFSS  F9E.4
199D2:  BRA    199D0
199D4:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
199D6:  MOVLW  64
199D8:  BTFSS  F9E.4
199DA:  BRA    199D8
199DC:  MOVWF  FAD
199DE:  MOVLW  3A
199E0:  BTFSS  F9E.4
199E2:  BRA    199E0
199E4:  MOVWF  FAD
199E6:  MOVLW  10
199E8:  MOVWF  FE9
199EA:  CLRF   1B
199EC:  BTFSC  FF2.7
199EE:  BSF    1B.7
199F0:  BCF    FF2.7
199F2:  MOVFF  751,A41
199F6:  MOVFF  750,A40
199FA:  CALL   119E
199FE:  BTFSC  1B.7
19A00:  BSF    FF2.7
19A02:  MOVLW  0D
19A04:  BTFSS  F9E.4
19A06:  BRA    19A04
19A08:  MOVWF  FAD
19A0A:  MOVLW  0A
19A0C:  BTFSS  F9E.4
19A0E:  BRA    19A0C
19A10:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
19A12:  MOVLW  65
19A14:  BTFSS  F9E.4
19A16:  BRA    19A14
19A18:  MOVWF  FAD
19A1A:  MOVLW  3A
19A1C:  BTFSS  F9E.4
19A1E:  BRA    19A1C
19A20:  MOVWF  FAD
19A22:  MOVLW  10
19A24:  MOVWF  FE9
19A26:  CLRF   1B
19A28:  BTFSC  FF2.7
19A2A:  BSF    1B.7
19A2C:  BCF    FF2.7
19A2E:  MOVFF  761,A41
19A32:  MOVFF  760,A40
19A36:  CALL   119E
19A3A:  BTFSC  1B.7
19A3C:  BSF    FF2.7
19A3E:  MOVLW  0D
19A40:  BTFSS  F9E.4
19A42:  BRA    19A40
19A44:  MOVWF  FAD
19A46:  MOVLW  0A
19A48:  BTFSS  F9E.4
19A4A:  BRA    19A48
19A4C:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19A4E:  MOVLW  66
19A50:  BTFSS  F9E.4
19A52:  BRA    19A50
19A54:  MOVWF  FAD
19A56:  MOVLW  3A
19A58:  BTFSS  F9E.4
19A5A:  BRA    19A58
19A5C:  MOVWF  FAD
19A5E:  CLRF   1B
19A60:  BTFSC  FF2.7
19A62:  BSF    1B.7
19A64:  BCF    FF2.7
19A66:  MOVFF  741,A40
19A6A:  MOVLW  1B
19A6C:  MOVLB  A
19A6E:  MOVWF  x41
19A70:  MOVLB  0
19A72:  CALL   0F9E
19A76:  BTFSC  1B.7
19A78:  BSF    FF2.7
19A7A:  MOVLW  0D
19A7C:  BTFSS  F9E.4
19A7E:  BRA    19A7C
19A80:  MOVWF  FAD
19A82:  MOVLW  0A
19A84:  BTFSS  F9E.4
19A86:  BRA    19A84
19A88:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
19A8A:  MOVLW  67
19A8C:  BTFSS  F9E.4
19A8E:  BRA    19A8C
19A90:  MOVWF  FAD
19A92:  MOVLW  3A
19A94:  BTFSS  F9E.4
19A96:  BRA    19A94
19A98:  MOVWF  FAD
19A9A:  MOVLW  10
19A9C:  MOVWF  FE9
19A9E:  CLRF   1B
19AA0:  BTFSC  FF2.7
19AA2:  BSF    1B.7
19AA4:  BCF    FF2.7
19AA6:  MOVFF  75D,A41
19AAA:  MOVFF  75C,A40
19AAE:  CALL   119E
19AB2:  BTFSC  1B.7
19AB4:  BSF    FF2.7
19AB6:  MOVLW  0D
19AB8:  BTFSS  F9E.4
19ABA:  BRA    19AB8
19ABC:  MOVWF  FAD
19ABE:  MOVLW  0A
19AC0:  BTFSS  F9E.4
19AC2:  BRA    19AC0
19AC4:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19AC6:  MOVLW  68
19AC8:  BTFSS  F9E.4
19ACA:  BRA    19AC8
19ACC:  MOVWF  FAD
19ACE:  MOVLW  3A
19AD0:  BTFSS  F9E.4
19AD2:  BRA    19AD0
19AD4:  MOVWF  FAD
19AD6:  MOVLW  10
19AD8:  MOVWF  FE9
19ADA:  CLRF   1B
19ADC:  BTFSC  FF2.7
19ADE:  BSF    1B.7
19AE0:  BCF    FF2.7
19AE2:  MOVFF  886,A41
19AE6:  MOVFF  885,A40
19AEA:  CALL   119E
19AEE:  BTFSC  1B.7
19AF0:  BSF    FF2.7
19AF2:  MOVLW  0D
19AF4:  BTFSS  F9E.4
19AF6:  BRA    19AF4
19AF8:  MOVWF  FAD
19AFA:  MOVLW  0A
19AFC:  BTFSS  F9E.4
19AFE:  BRA    19AFC
19B00:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
19B02:  MOVLW  69
19B04:  BTFSS  F9E.4
19B06:  BRA    19B04
19B08:  MOVWF  FAD
19B0A:  MOVLW  3A
19B0C:  BTFSS  F9E.4
19B0E:  BRA    19B0C
19B10:  MOVWF  FAD
19B12:  MOVLW  10
19B14:  MOVWF  FE9
19B16:  CLRF   1B
19B18:  BTFSC  FF2.7
19B1A:  BSF    1B.7
19B1C:  BCF    FF2.7
19B1E:  MOVFF  88A,A41
19B22:  MOVFF  889,A40
19B26:  CALL   119E
19B2A:  BTFSC  1B.7
19B2C:  BSF    FF2.7
19B2E:  MOVLW  0D
19B30:  BTFSS  F9E.4
19B32:  BRA    19B30
19B34:  MOVWF  FAD
19B36:  MOVLW  0A
19B38:  BTFSS  F9E.4
19B3A:  BRA    19B38
19B3C:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
19B3E:  MOVLW  6A
19B40:  BTFSS  F9E.4
19B42:  BRA    19B40
19B44:  MOVWF  FAD
19B46:  MOVLW  3A
19B48:  BTFSS  F9E.4
19B4A:  BRA    19B48
19B4C:  MOVWF  FAD
19B4E:  MOVLW  10
19B50:  MOVWF  FE9
19B52:  CLRF   1B
19B54:  BTFSC  FF2.7
19B56:  BSF    1B.7
19B58:  BCF    FF2.7
19B5A:  MOVFF  771,A41
19B5E:  MOVFF  770,A40
19B62:  CALL   119E
19B66:  BTFSC  1B.7
19B68:  BSF    FF2.7
19B6A:  MOVLW  0D
19B6C:  BTFSS  F9E.4
19B6E:  BRA    19B6C
19B70:  MOVWF  FAD
19B72:  MOVLW  0A
19B74:  BTFSS  F9E.4
19B76:  BRA    19B74
19B78:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
19B7A:  MOVLW  6B
19B7C:  BTFSS  F9E.4
19B7E:  BRA    19B7C
19B80:  MOVWF  FAD
19B82:  MOVLW  3A
19B84:  BTFSS  F9E.4
19B86:  BRA    19B84
19B88:  MOVWF  FAD
19B8A:  MOVLW  10
19B8C:  MOVWF  FE9
19B8E:  CLRF   1B
19B90:  BTFSC  FF2.7
19B92:  BSF    1B.7
19B94:  BCF    FF2.7
19B96:  MOVFF  769,A41
19B9A:  MOVFF  768,A40
19B9E:  CALL   119E
19BA2:  BTFSC  1B.7
19BA4:  BSF    FF2.7
19BA6:  MOVLW  0D
19BA8:  BTFSS  F9E.4
19BAA:  BRA    19BA8
19BAC:  MOVWF  FAD
19BAE:  MOVLW  0A
19BB0:  BTFSS  F9E.4
19BB2:  BRA    19BB0
19BB4:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
19BB6:  MOVLW  6D
19BB8:  BTFSS  F9E.4
19BBA:  BRA    19BB8
19BBC:  MOVWF  FAD
19BBE:  MOVLW  3A
19BC0:  BTFSS  F9E.4
19BC2:  BRA    19BC0
19BC4:  MOVWF  FAD
19BC6:  MOVLW  10
19BC8:  MOVWF  FE9
19BCA:  CLRF   1B
19BCC:  BTFSC  FF2.7
19BCE:  BSF    1B.7
19BD0:  BCF    FF2.7
19BD2:  MOVFF  749,A41
19BD6:  MOVFF  748,A40
19BDA:  CALL   119E
19BDE:  BTFSC  1B.7
19BE0:  BSF    FF2.7
19BE2:  MOVLW  0D
19BE4:  BTFSS  F9E.4
19BE6:  BRA    19BE4
19BE8:  MOVWF  FAD
19BEA:  MOVLW  0A
19BEC:  BTFSS  F9E.4
19BEE:  BRA    19BEC
19BF0:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
19BF2:  MOVLW  6E
19BF4:  BTFSS  F9E.4
19BF6:  BRA    19BF4
19BF8:  MOVWF  FAD
19BFA:  MOVLW  3A
19BFC:  BTFSS  F9E.4
19BFE:  BRA    19BFC
19C00:  MOVWF  FAD
19C02:  MOVLW  10
19C04:  MOVWF  FE9
19C06:  CLRF   1B
19C08:  BTFSC  FF2.7
19C0A:  BSF    1B.7
19C0C:  BCF    FF2.7
19C0E:  MOVFF  77D,A41
19C12:  MOVFF  77C,A40
19C16:  CALL   119E
19C1A:  BTFSC  1B.7
19C1C:  BSF    FF2.7
19C1E:  MOVLW  0D
19C20:  BTFSS  F9E.4
19C22:  BRA    19C20
19C24:  MOVWF  FAD
19C26:  MOVLW  0A
19C28:  BTFSS  F9E.4
19C2A:  BRA    19C28
19C2C:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
19C2E:  MOVLW  6F
19C30:  BTFSS  F9E.4
19C32:  BRA    19C30
19C34:  MOVWF  FAD
19C36:  MOVLW  3A
19C38:  BTFSS  F9E.4
19C3A:  BRA    19C38
19C3C:  MOVWF  FAD
19C3E:  MOVLW  10
19C40:  MOVWF  FE9
19C42:  CLRF   1B
19C44:  BTFSC  FF2.7
19C46:  BSF    1B.7
19C48:  BCF    FF2.7
19C4A:  MOVFF  781,A41
19C4E:  MOVFF  780,A40
19C52:  CALL   119E
19C56:  BTFSC  1B.7
19C58:  BSF    FF2.7
19C5A:  MOVLW  0D
19C5C:  BTFSS  F9E.4
19C5E:  BRA    19C5C
19C60:  MOVWF  FAD
19C62:  MOVLW  0A
19C64:  BTFSS  F9E.4
19C66:  BRA    19C64
19C68:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
19C6A:  MOVLW  70
19C6C:  BTFSS  F9E.4
19C6E:  BRA    19C6C
19C70:  MOVWF  FAD
19C72:  MOVLW  3A
19C74:  BTFSS  F9E.4
19C76:  BRA    19C74
19C78:  MOVWF  FAD
19C7A:  MOVLW  10
19C7C:  MOVWF  FE9
19C7E:  CLRF   1B
19C80:  BTFSC  FF2.7
19C82:  BSF    1B.7
19C84:  BCF    FF2.7
19C86:  MOVFF  7C6,A41
19C8A:  MOVFF  7C5,A40
19C8E:  CALL   119E
19C92:  BTFSC  1B.7
19C94:  BSF    FF2.7
19C96:  MOVLW  2F
19C98:  BTFSS  F9E.4
19C9A:  BRA    19C98
19C9C:  MOVWF  FAD
19C9E:  MOVLW  10
19CA0:  MOVWF  FE9
19CA2:  CLRF   1B
19CA4:  BTFSC  FF2.7
19CA6:  BSF    1B.7
19CA8:  BCF    FF2.7
19CAA:  MOVFF  765,A41
19CAE:  MOVFF  764,A40
19CB2:  CALL   119E
19CB6:  BTFSC  1B.7
19CB8:  BSF    FF2.7
19CBA:  MOVLW  0D
19CBC:  BTFSS  F9E.4
19CBE:  BRA    19CBC
19CC0:  MOVWF  FAD
19CC2:  MOVLW  0A
19CC4:  BTFSS  F9E.4
19CC6:  BRA    19CC4
19CC8:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
19CCA:  MOVLW  71
19CCC:  BTFSS  F9E.4
19CCE:  BRA    19CCC
19CD0:  MOVWF  FAD
19CD2:  MOVLW  3A
19CD4:  BTFSS  F9E.4
19CD6:  BRA    19CD4
19CD8:  MOVWF  FAD
19CDA:  MOVLW  10
19CDC:  MOVWF  FE9
19CDE:  CLRF   1B
19CE0:  BTFSC  FF2.7
19CE2:  BSF    1B.7
19CE4:  BCF    FF2.7
19CE6:  MOVFF  799,A41
19CEA:  MOVFF  798,A40
19CEE:  CALL   119E
19CF2:  BTFSC  1B.7
19CF4:  BSF    FF2.7
19CF6:  MOVLW  0D
19CF8:  BTFSS  F9E.4
19CFA:  BRA    19CF8
19CFC:  MOVWF  FAD
19CFE:  MOVLW  0A
19D00:  BTFSS  F9E.4
19D02:  BRA    19D00
19D04:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
19D06:  MOVLW  73
19D08:  BTFSS  F9E.4
19D0A:  BRA    19D08
19D0C:  MOVWF  FAD
19D0E:  MOVLW  3A
19D10:  BTFSS  F9E.4
19D12:  BRA    19D10
19D14:  MOVWF  FAD
19D16:  MOVLW  10
19D18:  MOVWF  FE9
19D1A:  CLRF   1B
19D1C:  BTFSC  FF2.7
19D1E:  BSF    1B.7
19D20:  BCF    FF2.7
19D22:  MOVFF  779,A41
19D26:  MOVFF  778,A40
19D2A:  CALL   119E
19D2E:  BTFSC  1B.7
19D30:  BSF    FF2.7
19D32:  MOVLW  0D
19D34:  BTFSS  F9E.4
19D36:  BRA    19D34
19D38:  MOVWF  FAD
19D3A:  MOVLW  0A
19D3C:  BTFSS  F9E.4
19D3E:  BRA    19D3C
19D40:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
19D42:  MOVLW  74
19D44:  BTFSS  F9E.4
19D46:  BRA    19D44
19D48:  MOVWF  FAD
19D4A:  MOVLW  3A
19D4C:  BTFSS  F9E.4
19D4E:  BRA    19D4C
19D50:  MOVWF  FAD
19D52:  MOVLW  10
19D54:  MOVWF  FE9
19D56:  CLRF   1B
19D58:  BTFSC  FF2.7
19D5A:  BSF    1B.7
19D5C:  BCF    FF2.7
19D5E:  MOVFF  76D,A41
19D62:  MOVFF  76C,A40
19D66:  CALL   119E
19D6A:  BTFSC  1B.7
19D6C:  BSF    FF2.7
19D6E:  MOVLW  0D
19D70:  BTFSS  F9E.4
19D72:  BRA    19D70
19D74:  MOVWF  FAD
19D76:  MOVLW  0A
19D78:  BTFSS  F9E.4
19D7A:  BRA    19D78
19D7C:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19D7E:  MOVLW  01
19D80:  MOVLB  7
19D82:  ADDWF  x40,W
19D84:  MOVLB  8
19D86:  MOVWF  x8B
19D88:  MOVLW  75
19D8A:  BTFSS  F9E.4
19D8C:  BRA    19D8A
19D8E:  MOVWF  FAD
19D90:  MOVLW  3A
19D92:  BTFSS  F9E.4
19D94:  BRA    19D92
19D96:  MOVWF  FAD
19D98:  CLRF   1B
19D9A:  BTFSC  FF2.7
19D9C:  BSF    1B.7
19D9E:  BCF    FF2.7
19DA0:  MOVFF  88B,A40
19DA4:  MOVLW  1B
19DA6:  MOVLB  A
19DA8:  MOVWF  x41
19DAA:  MOVLB  0
19DAC:  CALL   0F9E
19DB0:  BTFSC  1B.7
19DB2:  BSF    FF2.7
19DB4:  MOVLW  0D
19DB6:  BTFSS  F9E.4
19DB8:  BRA    19DB6
19DBA:  MOVWF  FAD
19DBC:  MOVLW  0A
19DBE:  BTFSS  F9E.4
19DC0:  BRA    19DBE
19DC2:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19DC4:  MOVLW  77
19DC6:  BTFSS  F9E.4
19DC8:  BRA    19DC6
19DCA:  MOVWF  FAD
19DCC:  MOVLW  3A
19DCE:  BTFSS  F9E.4
19DD0:  BRA    19DCE
19DD2:  MOVWF  FAD
19DD4:  MOVLW  10
19DD6:  MOVWF  FE9
19DD8:  CLRF   1B
19DDA:  BTFSC  FF2.7
19DDC:  BSF    1B.7
19DDE:  BCF    FF2.7
19DE0:  MOVFF  888,A41
19DE4:  MOVFF  887,A40
19DE8:  CALL   119E
19DEC:  BTFSC  1B.7
19DEE:  BSF    FF2.7
19DF0:  MOVLW  0D
19DF2:  BTFSS  F9E.4
19DF4:  BRA    19DF2
19DF6:  MOVWF  FAD
19DF8:  MOVLW  0A
19DFA:  BTFSS  F9E.4
19DFC:  BRA    19DFA
19DFE:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
19E00:  MOVLW  78
19E02:  BTFSS  F9E.4
19E04:  BRA    19E02
19E06:  MOVWF  FAD
19E08:  MOVLW  3A
19E0A:  BTFSS  F9E.4
19E0C:  BRA    19E0A
19E0E:  MOVWF  FAD
19E10:  MOVLW  10
19E12:  MOVWF  FE9
19E14:  CLRF   1B
19E16:  BTFSC  FF2.7
19E18:  BSF    1B.7
19E1A:  BCF    FF2.7
19E1C:  MOVFF  785,A41
19E20:  MOVFF  784,A40
19E24:  CALL   119E
19E28:  BTFSC  1B.7
19E2A:  BSF    FF2.7
19E2C:  MOVLW  0D
19E2E:  BTFSS  F9E.4
19E30:  BRA    19E2E
19E32:  MOVWF  FAD
19E34:  MOVLW  0A
19E36:  BTFSS  F9E.4
19E38:  BRA    19E36
19E3A:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
19E3C:  MOVLW  79
19E3E:  BTFSS  F9E.4
19E40:  BRA    19E3E
19E42:  MOVWF  FAD
19E44:  MOVLW  3A
19E46:  BTFSS  F9E.4
19E48:  BRA    19E46
19E4A:  MOVWF  FAD
19E4C:  MOVLW  10
19E4E:  MOVWF  FE9
19E50:  CLRF   1B
19E52:  BTFSC  FF2.7
19E54:  BSF    1B.7
19E56:  BCF    FF2.7
19E58:  MOVFF  745,A41
19E5C:  MOVFF  744,A40
19E60:  CALL   119E
19E64:  BTFSC  1B.7
19E66:  BSF    FF2.7
19E68:  MOVLW  0D
19E6A:  BTFSS  F9E.4
19E6C:  BRA    19E6A
19E6E:  MOVWF  FAD
19E70:  MOVLW  0A
19E72:  BTFSS  F9E.4
19E74:  BRA    19E72
19E76:  MOVWF  FAD
....................    } 
19E78:  BRA    19E7E
....................    else cmd_arg(); 
19E7A:  CALL   B2FE
19E7E:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BF46:  MOVF   48,W
0BF48:  SUBLW  0D
0BF4A:  BNZ   BF6A
0BF4C:  MOVF   49,W
0BF4E:  SUBLW  07
0BF50:  BNZ   BF6A
0BF52:  MOVF   4A,F
0BF54:  BNZ   BF6A
0BF56:  MOVF   4B,F
0BF58:  BNZ   BF6A
0BF5A:  MOVLW  03
0BF5C:  MOVLB  8
0BF5E:  MOVWF  x8A
0BF60:  MOVLW  15
0BF62:  MOVWF  x89
0BF64:  MOVLB  0
0BF66:  RCALL  BB24
0BF68:  BRA    BF8C
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BF6A:  MOVF   48,W
0BF6C:  SUBLW  98
0BF6E:  BNZ   BF8C
0BF70:  MOVF   49,W
0BF72:  SUBLW  07
0BF74:  BNZ   BF8C
0BF76:  MOVF   4A,F
0BF78:  BNZ   BF8C
0BF7A:  MOVF   4B,F
0BF7C:  BNZ   BF8C
0BF7E:  MOVLW  03
0BF80:  MOVLB  8
0BF82:  MOVWF  x8A
0BF84:  MOVLW  15
0BF86:  MOVWF  x89
0BF88:  MOVLB  0
0BF8A:  RCALL  BC9E
0BF8C:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0B358:  MOVF   48,W
0B35A:  MOVWF  00
0B35C:  MOVFF  49,03
0B360:  MOVLW  15
0B362:  SUBWF  49,W
0B364:  BNZ   B36C
0B366:  MOVLW  95
0B368:  SUBWF  00,W
0B36A:  BZ    B392
0B36C:  MOVLW  15
0B36E:  SUBWF  03,W
0B370:  BNZ   B378
0B372:  MOVLW  96
0B374:  SUBWF  00,W
0B376:  BZ    B3C4
0B378:  MOVLW  15
0B37A:  SUBWF  03,W
0B37C:  BNZ   B384
0B37E:  MOVLW  97
0B380:  SUBWF  00,W
0B382:  BZ    B3FA
0B384:  MOVLW  15
0B386:  SUBWF  03,W
0B388:  BNZ   B390
0B38A:  MOVLW  98
0B38C:  SUBWF  00,W
0B38E:  BZ    B430
0B390:  BRA    B464
....................       case 5525 : nv_product = ECO; 
0B392:  CLRF   30
0B394:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B396:  MOVLW  1E
0B398:  MOVLB  8
0B39A:  MOVWF  xEE
0B39C:  CLRF   xF0
0B39E:  CLRF   xEF
0B3A0:  MOVLB  0
0B3A2:  CALL   4FD4
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B3A6:  MOVLW  01
0B3A8:  MOVWF  1E
0B3AA:  MOVLW  A7
0B3AC:  MOVWF  1D
0B3AE:  MOVLW  2A
0B3B0:  MOVWF  FF6
0B3B2:  MOVLW  27
0B3B4:  MOVWF  FF7
0B3B6:  MOVLW  00
0B3B8:  MOVWF  FF8
0B3BA:  CALL   50BE
....................                   record_event(); 
0B3BE:  CALL   84DA
....................          break; 
0B3C2:  BRA    B464
....................       case 5526 : nv_product = WMS4; 
0B3C4:  CLRF   30
0B3C6:  MOVLW  01
0B3C8:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B3CA:  MOVLW  1E
0B3CC:  MOVLB  8
0B3CE:  MOVWF  xEE
0B3D0:  CLRF   xF0
0B3D2:  MOVLW  01
0B3D4:  MOVWF  xEF
0B3D6:  MOVLB  0
0B3D8:  CALL   4FD4
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B3DC:  MOVLW  01
0B3DE:  MOVWF  1E
0B3E0:  MOVLW  A7
0B3E2:  MOVWF  1D
0B3E4:  MOVLW  3A
0B3E6:  MOVWF  FF6
0B3E8:  MOVLW  27
0B3EA:  MOVWF  FF7
0B3EC:  MOVLW  00
0B3EE:  MOVWF  FF8
0B3F0:  CALL   50BE
....................                   record_event();                   
0B3F4:  CALL   84DA
....................          break;    
0B3F8:  BRA    B464
....................       case 5527 : nv_product = AWS; 
0B3FA:  CLRF   30
0B3FC:  MOVLW  02
0B3FE:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B400:  MOVLW  1E
0B402:  MOVLB  8
0B404:  MOVWF  xEE
0B406:  CLRF   xF0
0B408:  MOVLW  02
0B40A:  MOVWF  xEF
0B40C:  MOVLB  0
0B40E:  CALL   4FD4
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B412:  MOVLW  01
0B414:  MOVWF  1E
0B416:  MOVLW  A7
0B418:  MOVWF  1D
0B41A:  MOVLW  50
0B41C:  MOVWF  FF6
0B41E:  MOVLW  27
0B420:  MOVWF  FF7
0B422:  MOVLW  00
0B424:  MOVWF  FF8
0B426:  CALL   50BE
....................                   record_event();                   
0B42A:  CALL   84DA
....................          break;   
0B42E:  BRA    B464
....................       case 5528 : nv_product = WMS2; 
0B430:  CLRF   30
0B432:  MOVLW  03
0B434:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B436:  MOVLW  1E
0B438:  MOVLB  8
0B43A:  MOVWF  xEE
0B43C:  CLRF   xF0
0B43E:  MOVLW  03
0B440:  MOVWF  xEF
0B442:  MOVLB  0
0B444:  CALL   4FD4
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B448:  MOVLW  01
0B44A:  MOVWF  1E
0B44C:  MOVLW  A7
0B44E:  MOVWF  1D
0B450:  MOVLW  60
0B452:  MOVWF  FF6
0B454:  MOVLW  27
0B456:  MOVWF  FF7
0B458:  MOVLW  00
0B45A:  MOVWF  FF8
0B45C:  CALL   50BE
....................                   record_event();                   
0B460:  CALL   84DA
....................          break;            
....................    } 
0B464:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0B31C:  MOVF   48,W
0B31E:  MOVWF  00
0B320:  MOVF   49,W
0B322:  MOVWF  03
0B324:  BNZ   B32A
0B326:  MOVF   00,F
0B328:  BZ    B340
0B32A:  MOVF   03,W
0B32C:  BNZ   B334
0B32E:  MOVLW  01
0B330:  SUBWF  00,W
0B332:  BZ    B346
0B334:  MOVF   03,W
0B336:  BNZ   B33E
0B338:  MOVLW  02
0B33A:  SUBWF  00,W
0B33C:  BZ    B34C
0B33E:  BRA    B352
....................       case 0 : kill_wd(); 
0B340:  CALL   30F6
....................          break; 
0B344:  BRA    B354
....................       case 1 : start_heartbeat(); 
0B346:  CALL   2900
....................          break; 
0B34A:  BRA    B354
....................       case 2 : suspend_heartbeat(); 
0B34C:  CALL   5554
....................          break; 
0B350:  BRA    B354
....................       default : cmd_arg(); 
0B352:  RCALL  B2FE
....................          break; 
....................    } 
0B354:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0B25C:  MOVF   48,W
0B25E:  MOVWF  00
0B260:  MOVF   49,W
0B262:  MOVWF  03
0B264:  BNZ   B26A
0B266:  MOVF   00,F
0B268:  BZ    B278
0B26A:  MOVLW  15
0B26C:  SUBWF  03,W
0B26E:  BNZ   B276
0B270:  MOVLW  95
0B272:  SUBWF  00,W
0B274:  BZ    B2D6
0B276:  BRA    B2FA
....................       case 0:     signon(); 
0B278:  CALL   3148
....................                   fprintf(COM_A, __DATE__); 
0B27C:  MOVLW  76
0B27E:  MOVWF  FF6
0B280:  MOVLW  27
0B282:  MOVWF  FF7
0B284:  MOVLW  00
0B286:  MOVWF  FF8
0B288:  CLRF   1B
0B28A:  BTFSC  FF2.7
0B28C:  BSF    1B.7
0B28E:  BCF    FF2.7
0B290:  CALL   0E46
0B294:  BTFSC  1B.7
0B296:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B298:  MOVLW  0D
0B29A:  BTFSS  F9E.4
0B29C:  BRA    B29A
0B29E:  MOVWF  FAD
0B2A0:  MOVLW  0A
0B2A2:  BTFSS  F9E.4
0B2A4:  BRA    B2A2
0B2A6:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0B2A8:  MOVLW  80
0B2AA:  MOVWF  FF6
0B2AC:  MOVLW  27
0B2AE:  MOVWF  FF7
0B2B0:  MOVLW  00
0B2B2:  MOVWF  FF8
0B2B4:  CLRF   1B
0B2B6:  BTFSC  FF2.7
0B2B8:  BSF    1B.7
0B2BA:  BCF    FF2.7
0B2BC:  CALL   0E46
0B2C0:  BTFSC  1B.7
0B2C2:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B2C4:  MOVLW  0D
0B2C6:  BTFSS  F9E.4
0B2C8:  BRA    B2C6
0B2CA:  MOVWF  FAD
0B2CC:  MOVLW  0A
0B2CE:  BTFSS  F9E.4
0B2D0:  BRA    B2CE
0B2D2:  MOVWF  FAD
....................          break; 
0B2D4:  BRA    B2FA
....................       case 5525 : kill_wd(); 
0B2D6:  CALL   30F6
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0B2DA:  MOVLW  8A
0B2DC:  MOVWF  FF6
0B2DE:  MOVLW  27
0B2E0:  MOVWF  FF7
0B2E2:  MOVLW  00
0B2E4:  MOVWF  FF8
0B2E6:  CLRF   1B
0B2E8:  BTFSC  FF2.7
0B2EA:  BSF    1B.7
0B2EC:  BCF    FF2.7
0B2EE:  CALL   0E46
0B2F2:  BTFSC  1B.7
0B2F4:  BSF    FF2.7
....................                   load_program(); 
0B2F6:  CALL   1F800
....................          break; 
....................    } 
0B2FA:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
18B2E:  MOVF   48,W
18B30:  MOVWF  00
18B32:  MOVF   49,W
18B34:  MOVWF  03
18B36:  BNZ   18B3C
18B38:  MOVF   00,F
18B3A:  BZ    18B48
18B3C:  MOVF   03,W
18B3E:  BNZ   18B46
18B40:  MOVLW  01
18B42:  SUBWF  00,W
18B44:  BZ    18B4C
18B46:  BRA    18B50
....................       case 0 : cmd_set=0;  // user 
18B48:  CLRF   51
....................          break; 
18B4A:  BRA    18B50
....................       case 1 : cmd_set=1;  // full 
18B4C:  MOVLW  01
18B4E:  MOVWF  51
....................          break; 
....................    } 
18B50:  GOTO   1B22A (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1B08E:  CALL   AEB0
....................     
....................    switch (cmd) 
1B092:  MOVLW  23
1B094:  SUBWF  47,W
1B096:  ADDLW  A8
1B098:  BTFSC  FD8.0
1B09A:  BRA    1B22A
1B09C:  ADDLW  58
1B09E:  GOTO   1B22E
....................    { 
....................       case '&': commandFW(); 
1B0A2:  GOTO   B25C
....................          break; 
1B0A6:  BRA    1B22A
....................       case '#': command_hash(); 
1B0A8:  GOTO   B31C
....................          break;          
1B0AC:  BRA    1B22A
....................       case '%': command_prod(); 
1B0AE:  GOTO   B358
....................          break; 
1B0B2:  BRA    1B22A
....................       case '*': command_star(); 
1B0B4:  GOTO   BF46
....................          break;       
1B0B8:  BRA    1B22A
....................       // standard commands 
....................       case '/': command_addr(); 
1B0BA:  GOTO   BF90
....................          break; 
1B0BE:  BRA    1B22A
....................       case 'A': commandA(); 
1B0C0:  GOTO   C12A
....................          break; 
1B0C4:  BRA    1B22A
....................       case 'B': commandB(); 
1B0C6:  GOTO   C296
....................          break; 
1B0CA:  BRA    1B22A
....................       case 'C': commandC(); 
1B0CC:  GOTO   DCBA
....................          break; 
1B0D0:  BRA    1B22A
....................       case 'D': commandD(); 
1B0D2:  GOTO   DCF8
....................          break; 
1B0D6:  BRA    1B22A
....................       case 'E': commandE(); 
1B0D8:  GOTO   DD96
....................          break;          
1B0DC:  BRA    1B22A
....................       case 'F': commandF(); 
1B0DE:  GOTO   E094
....................          break;          
1B0E2:  BRA    1B22A
....................       case 'G': commandG(); 
1B0E4:  GOTO   E0FE
....................          break; 
1B0E8:  BRA    1B22A
....................       case 'H': commandH(); 
1B0EA:  GOTO   F25C
....................          break; 
1B0EE:  BRA    1B22A
....................       case 'I': commandI(); 
1B0F0:  GOTO   F29C
....................          break;    
1B0F4:  BRA    1B22A
....................       case 'J': commandJ(); 
1B0F6:  GOTO   F2E8
....................          break;      
1B0FA:  BRA    1B22A
....................       case 'K': commandK(); 
1B0FC:  GOTO   F542
....................          break;    
1B100:  BRA    1B22A
....................       case 'L': commandL(); 
1B102:  GOTO   104DC
....................          break;             
1B106:  BRA    1B22A
....................       case 'M': commandM(FALSE); 
1B108:  MOVLB  8
1B10A:  CLRF   x85
1B10C:  MOVLB  0
1B10E:  CALL   16DBA
....................          break;   
1B112:  BRA    1B22A
....................       case 'N': commandN(); 
1B114:  GOTO   16ED8
....................          break;          
1B118:  BRA    1B22A
....................       case 'O': commandO(); 
1B11A:  GOTO   17080
....................          break;    
1B11E:  BRA    1B22A
....................       case 'P': commandP(); 
1B120:  GOTO   17284
....................          break;  
1B124:  BRA    1B22A
....................       case 'Q': commandQ(); 
1B126:  GOTO   17342
....................          break;              
1B12A:  BRA    1B22A
....................       case 'R': commandR(); 
1B12C:  GOTO   175D8
....................          break;    
1B130:  BRA    1B22A
....................       case 'S': commandS(); 
1B132:  GOTO   17704
....................          break;  
1B136:  BRA    1B22A
....................       case 'T': commandT(); 
1B138:  GOTO   17CA2
....................          break;            
1B13C:  BRA    1B22A
....................       case 'U': commandU(); 
1B13E:  GOTO   186AA
....................          break;           
1B142:  BRA    1B22A
....................       case 'V': commandV(); 
1B144:  GOTO   18802
....................          break; 
1B148:  BRA    1B22A
....................       case 'W': commandW(); 
1B14A:  GOTO   18976
....................          break; 
1B14E:  BRA    1B22A
....................       case 'X': commandX(); 
1B150:  GOTO   1899A
....................          break; 
1B154:  BRA    1B22A
....................       case 'Y': commandY(); 
1B156:  GOTO   18A02
....................          break;  
1B15A:  BRA    1B22A
....................       case 'Z': commandZ(); 
1B15C:  CALL   18B0A
....................          break;    
1B160:  BRA    1B22A
....................       // stepper 
....................       case '^': command_set(); 
1B162:  GOTO   18B2E
....................          break;       
1B166:  BRA    1B22A
....................       case '+': if(m_fixed==1) motor=1; 
1B168:  MOVLB  7
1B16A:  DECFSZ x41,W
1B16C:  BRA    1B172
1B16E:  MOVLW  01
1B170:  MOVWF  x40
....................                 command_move(0,0,1); 
1B172:  MOVLB  8
1B174:  CLRF   x85
1B176:  CLRF   x86
1B178:  MOVLW  01
1B17A:  MOVWF  x87
1B17C:  MOVLB  0
1B17E:  CALL   170A4
....................          break; 
1B182:  BRA    1B22A
....................       case '-': if(m_fixed==1) motor=1; 
1B184:  MOVLB  7
1B186:  DECFSZ x41,W
1B188:  BRA    1B18E
1B18A:  MOVLW  01
1B18C:  MOVWF  x40
....................                 command_move(0,1,1); 
1B18E:  MOVLB  8
1B190:  CLRF   x85
1B192:  MOVLW  01
1B194:  MOVWF  x86
1B196:  MOVWF  x87
1B198:  MOVLB  0
1B19A:  CALL   170A4
....................          break; 
1B19E:  BRA    1B22A
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1B1A0:  GOTO   18C5A
....................          break;     
1B1A4:  BRA    1B22A
....................       case 'b': command_b(); 
1B1A6:  GOTO   18C76
....................          break; 
1B1AA:  BRA    1B22A
....................       case 'c': command_c(); 
1B1AC:  GOTO   18D10
....................          break; 
1B1B0:  BRA    1B22A
....................       case 'd': command_d(); 
1B1B2:  GOTO   18D58
....................          break;          
1B1B6:  BRA    1B22A
....................       case 'e': command_e(); 
1B1B8:  GOTO   18DEE
....................          break;       
1B1BC:  BRA    1B22A
....................       case 'f': command_f(); 
1B1BE:  GOTO   18E88
....................          break; 
1B1C2:  BRA    1B22A
....................       case 'g': command_g(); 
1B1C4:  GOTO   18EA8
....................          break;          
1B1C8:  BRA    1B22A
....................       case 'h': command_h(); 
1B1CA:  GOTO   18F42
....................          break; 
1B1CE:  BRA    1B22A
....................       case 'i': command_i(); 
1B1D0:  GOTO   19016
....................          break;   
1B1D4:  BRA    1B22A
....................       case 'j': command_j(); 
1B1D6:  GOTO   190F2
....................          break;           
1B1DA:  BRA    1B22A
....................       case 'k': command_k(); 
1B1DC:  GOTO   1918C
....................          break;          
1B1E0:  BRA    1B22A
....................       case 'l': step_var_list(); 
1B1E2:  GOTO   19222
....................          break;          
1B1E6:  BRA    1B22A
....................       case 'm': command_m(); 
1B1E8:  GOTO   19E82
....................          break;    
1B1EC:  BRA    1B22A
....................       case 'n': command_n(); 
1B1EE:  GOTO   19F18
....................          break; 
1B1F2:  BRA    1B22A
....................       case 'o': command_o(); 
1B1F4:  GOTO   19FAE
....................          break;    
1B1F8:  BRA    1B22A
....................       case 'p': command_p(); 
1B1FA:  GOTO   1A048
....................          break;   
1B1FE:  BRA    1B22A
....................       case 'q': command_q(); 
1B200:  GOTO   1A0E2
....................          break; 
1B204:  BRA    1B22A
....................       case 'r': command_r(); 
1B206:  BRA    1ABDE
....................          break;    
1B208:  BRA    1B22A
....................       case 's': command_s(); 
1B20A:  BRA    1AC38
....................          break;           
1B20C:  BRA    1B22A
....................       case 't': command_t(); 
1B20E:  BRA    1AD46
....................          break;          
1B210:  BRA    1B22A
....................       case 'u': command_u(); 
1B212:  BRA    1ADDC
....................          break; 
1B214:  BRA    1B22A
....................       case 'v': command_v(); 
1B216:  CALL   13DDC
....................          break; 
1B21A:  BRA    1B22A
....................       case 'w': command_w(); 
1B21C:  BRA    1AE14
....................          break; 
1B21E:  BRA    1B22A
....................       case 'x': command_x(); 
1B220:  BRA    1AEE8
....................          break;    
1B222:  BRA    1B22A
....................       case 'y': command_y(); 
1B224:  BRA    1AF82
....................          break;  
1B226:  BRA    1B22A
....................       case 'z': command_z(); 
1B228:  BRA    1B018
....................          break;           
....................    } 
1B22A:  GOTO   1B34E (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg2() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0B198:  MOVF   51,F
0B19A:  BNZ   B1EC
0B19C:  MOVLB  8
0B19E:  MOVF   x85,W
0B1A0:  SUBLW  24
0B1A2:  BC    B1AA
0B1A4:  MOVF   x85,W
0B1A6:  SUBLW  26
0B1A8:  BC    B1E4
0B1AA:  MOVF   x85,W
0B1AC:  SUBLW  29
0B1AE:  BC    B1B6
0B1B0:  MOVF   x85,W
0B1B2:  SUBLW  2B
0B1B4:  BC    B1E4
0B1B6:  MOVF   x85,W
0B1B8:  SUBLW  2D
0B1BA:  BZ    B1E4
0B1BC:  MOVF   x85,W
0B1BE:  SUBLW  2F
0B1C0:  BZ    B1E4
0B1C2:  MOVF   x85,W
0B1C4:  SUBLW  40
0B1C6:  BC    B1CE
0B1C8:  MOVF   x85,W
0B1CA:  SUBLW  42
0B1CC:  BC    B1E4
0B1CE:  MOVF   x85,W
0B1D0:  SUBLW  43
0B1D2:  BC    B1DA
0B1D4:  MOVF   x85,W
0B1D6:  SUBLW  5A
0B1D8:  BC    B1E4
0B1DA:  MOVF   x85,W
0B1DC:  SUBLW  5E
0B1DE:  BZ    B1E4
0B1E0:  MOVLW  00
0B1E2:  BRA    B1E6
0B1E4:  MOVLW  01
0B1E6:  MOVWF  x86
0B1E8:  BRA    B24E
0B1EA:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0B1EC:  DECFSZ 51,W
0B1EE:  BRA    B250
0B1F0:  MOVLB  8
0B1F2:  MOVF   x85,W
0B1F4:  SUBLW  23
0B1F6:  BZ    B24A
0B1F8:  MOVF   x85,W
0B1FA:  SUBLW  24
0B1FC:  BC    B204
0B1FE:  MOVF   x85,W
0B200:  SUBLW  26
0B202:  BC    B24A
0B204:  MOVF   x85,W
0B206:  SUBLW  29
0B208:  BC    B210
0B20A:  MOVF   x85,W
0B20C:  SUBLW  2B
0B20E:  BC    B24A
0B210:  MOVF   x85,W
0B212:  SUBLW  2D
0B214:  BZ    B24A
0B216:  MOVF   x85,W
0B218:  SUBLW  2F
0B21A:  BZ    B24A
0B21C:  MOVF   x85,W
0B21E:  SUBLW  40
0B220:  BC    B228
0B222:  MOVF   x85,W
0B224:  SUBLW  42
0B226:  BC    B24A
0B228:  MOVF   x85,W
0B22A:  SUBLW  43
0B22C:  BC    B234
0B22E:  MOVF   x85,W
0B230:  SUBLW  5A
0B232:  BC    B24A
0B234:  MOVF   x85,W
0B236:  SUBLW  5E
0B238:  BZ    B24A
0B23A:  MOVF   x85,W
0B23C:  SUBLW  60
0B23E:  BC    B246
0B240:  MOVF   x85,W
0B242:  SUBLW  7A
0B244:  BC    B24A
0B246:  MOVLW  00
0B248:  BRA    B24C
0B24A:  MOVLW  01
0B24C:  MOVWF  x86
0B24E:  MOVLB  0
....................    return(valid); 
0B250:  MOVLB  8
0B252:  MOVFF  886,01
0B256:  MOVLB  0
0B258:  GOTO   1B306 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(!check_cmd(cmd)) 
*
1B2FE:  MOVFF  47,885
1B302:  GOTO   B198
1B306:  MOVF   01,F
1B308:  BNZ   1B32C
....................       fputs("\r\n@INV", COM_A); 
1B30A:  MOVLW  C8
1B30C:  MOVWF  FF6
1B30E:  MOVLW  27
1B310:  MOVWF  FF7
1B312:  MOVLW  00
1B314:  MOVWF  FF8
1B316:  CALL   AE86
1B31A:  MOVLW  0D
1B31C:  BTFSS  F9E.4
1B31E:  BRA    1B31C
1B320:  MOVWF  FAD
1B322:  MOVLW  0A
1B324:  BTFSS  F9E.4
1B326:  BRA    1B324
1B328:  MOVWF  FAD
1B32A:  BRA    1B34E
....................    else{ 
....................       fputs("\r\n@OK! ", COM_A); 
1B32C:  MOVLW  D0
1B32E:  MOVWF  FF6
1B330:  MOVLW  27
1B332:  MOVWF  FF7
1B334:  MOVLW  00
1B336:  MOVWF  FF8
1B338:  CALL   AE86
1B33C:  MOVLW  0D
1B33E:  BTFSS  F9E.4
1B340:  BRA    1B33E
1B342:  MOVWF  FAD
1B344:  MOVLW  0A
1B346:  BTFSS  F9E.4
1B348:  BRA    1B346
1B34A:  MOVWF  FAD
....................       select_cmd(); 
1B34C:  BRA    1B08E
....................    } 
1B34E:  GOTO   1B562 (RETURN)
.................... } 
.................... void proc_cmd2() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
....................    else fputs("@INV", COM_A); 
.................... } 
....................  
.................... void command_prompt(){ 
1B352:  MOVLB  8
1B354:  CLRF   x64
1B356:  CLRF   x65
1B358:  CLRF   x66
....................    int8 good_val = FALSE; 
....................    int8 i = 0; 
....................    char temp = 0; 
....................    char input_string[30]; 
....................     
....................    //Disable rtc watchdog 
....................    output_bit(RTC_CS, ENABLE); 
1B35A:  BCF    F91.0
....................    spi_write(0x89); 
1B35C:  MOVF   FC9,W
1B35E:  MOVLW  89
1B360:  MOVWF  FC9
1B362:  RRCF   FC7,W
1B364:  BNC   1B362
....................    spi_write(0b00000000); 
1B366:  MOVF   FC9,W
1B368:  CLRF   FC9
1B36A:  RRCF   FC7,W
1B36C:  BNC   1B36A
....................    spi_read(0x00); 
1B36E:  MOVF   FC9,W
1B370:  CLRF   FC9
1B372:  RRCF   FC7,W
1B374:  BNC   1B372
....................    output_bit(RTC_CS, DISABLE); 
1B376:  BSF    F91.0
....................     
....................     
....................    nv_cmd_mode = TRUE; 
1B378:  CLRF   32
1B37A:  MOVLW  01
1B37C:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1B37E:  MOVLW  02
1B380:  MOVWF  x89
1B382:  MOVFF  31,88A
1B386:  MOVLB  0
1B388:  CALL   3412
....................     
....................    fputs("@CMD", COM_A); 
1B38C:  MOVLW  DE
1B38E:  MOVWF  FF6
1B390:  MOVLW  27
1B392:  MOVWF  FF7
1B394:  MOVLW  00
1B396:  MOVWF  FF8
1B398:  CALL   AE86
1B39C:  MOVLW  0D
1B39E:  BTFSS  F9E.4
1B3A0:  BRA    1B39E
1B3A2:  MOVWF  FAD
1B3A4:  MOVLW  0A
1B3A6:  BTFSS  F9E.4
1B3A8:  BRA    1B3A6
1B3AA:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1B3AC:  MOVLW  01
1B3AE:  MOVWF  1E
1B3B0:  MOVLW  A7
1B3B2:  MOVWF  1D
1B3B4:  MOVLW  E4
1B3B6:  MOVWF  FF6
1B3B8:  MOVLW  27
1B3BA:  MOVWF  FF7
1B3BC:  MOVLW  00
1B3BE:  MOVWF  FF8
1B3C0:  CALL   50BE
....................    record_event(); 
1B3C4:  CALL   84DA
....................     
....................    busy_clear(); 
1B3C8:  CALL   AEB0
....................     
....................    cmd_set=0; // user 
1B3CC:  CLRF   51
....................     
....................    do { 
....................       for(i = 0; i<30; i++){ 
1B3CE:  MOVLB  8
1B3D0:  CLRF   x65
1B3D2:  MOVF   x65,W
1B3D4:  SUBLW  1D
1B3D6:  BNC   1B3EC
....................          input_string[i] = 0; 
1B3D8:  CLRF   03
1B3DA:  MOVF   x65,W
1B3DC:  ADDLW  67
1B3DE:  MOVWF  FE9
1B3E0:  MOVLW  08
1B3E2:  ADDWFC 03,W
1B3E4:  MOVWF  FEA
1B3E6:  CLRF   FEF
1B3E8:  INCF   x65,F
1B3EA:  BRA    1B3D2
....................    
....................       } 
....................       i = 0; 
1B3EC:  CLRF   x65
....................       fputc('>',COM_A); 
1B3EE:  MOVLW  3E
1B3F0:  MOVLB  0
1B3F2:  CALL   AEB8
....................       temp = 0; 
1B3F6:  MOVLB  8
1B3F8:  CLRF   x66
....................       while(temp != CARRIAGE_RET){ 
1B3FA:  MOVF   x66,W
1B3FC:  SUBLW  0D
1B3FE:  BZ    1B496
....................          temp = fgetc(COM_A); 
1B400:  MOVLB  0
1B402:  CALL   0E30
1B406:  MOVFF  01,866
....................          //Backspace character 
....................          if(temp != 8){ 
1B40A:  MOVLB  8
1B40C:  MOVF   x66,W
1B40E:  SUBLW  08
1B410:  BZ    1B43C
....................             if (com_echo == TRUE) 
1B412:  DECFSZ 4C,W
1B414:  BRA    1B420
....................             { 
....................                fputc(temp,COM_A); 
1B416:  MOVF   x66,W
1B418:  MOVLB  0
1B41A:  CALL   AEB8
1B41E:  MOVLB  8
....................             } 
....................             if(temp!= CARRIAGE_RET){ 
1B420:  MOVF   x66,W
1B422:  SUBLW  0D
1B424:  BZ    1B43A
....................                input_string[i] = temp; 
1B426:  CLRF   03
1B428:  MOVF   x65,W
1B42A:  ADDLW  67
1B42C:  MOVWF  FE9
1B42E:  MOVLW  08
1B430:  ADDWFC 03,W
1B432:  MOVWF  FEA
1B434:  MOVFF  866,FEF
....................                i++; 
1B438:  INCF   x65,F
....................             } 
....................          }else{ 
1B43A:  BRA    1B494
....................             //backspace code 
....................             if(i != 0){ 
1B43C:  MOVF   x65,F
1B43E:  BZ    1B494
....................                input_string[i-1] = 0; 
1B440:  MOVLW  01
1B442:  SUBWF  x65,W
1B444:  CLRF   03
1B446:  ADDLW  67
1B448:  MOVWF  FE9
1B44A:  MOVLW  08
1B44C:  ADDWFC 03,W
1B44E:  MOVWF  FEA
1B450:  CLRF   FEF
....................                i--; 
1B452:  DECF   x65,F
....................                //Clear buffer and overwrite with previous minus one character 
....................                fputc('\r',COM_A); 
1B454:  MOVLW  0D
1B456:  MOVLB  0
1B458:  CALL   AEB8
....................                fprintf(COM_A,"                                       "); 
1B45C:  MOVLW  F6
1B45E:  MOVWF  FF6
1B460:  MOVLW  27
1B462:  MOVWF  FF7
1B464:  MOVLW  00
1B466:  MOVWF  FF8
1B468:  CLRF   1B
1B46A:  BTFSC  FF2.7
1B46C:  BSF    1B.7
1B46E:  BCF    FF2.7
1B470:  CALL   0E46
1B474:  BTFSC  1B.7
1B476:  BSF    FF2.7
....................                fputc('\r',COM_A); 
1B478:  MOVLW  0D
1B47A:  CALL   AEB8
....................                fprintf(COM_A,">"); 
1B47E:  MOVLW  3E
1B480:  BTFSS  F9E.4
1B482:  BRA    1B480
1B484:  MOVWF  FAD
....................                fprintf(COM_A,input_string); 
1B486:  MOVLW  08
1B488:  MOVWF  FEA
1B48A:  MOVLW  67
1B48C:  MOVWF  FE9
1B48E:  CALL   7996
1B492:  MOVLB  8
....................                 
....................             } 
....................          } 
1B494:  BRA    1B3FA
....................       } 
....................       cmd = input_string[0]; 
1B496:  MOVFF  867,47
....................       if (cmd == '?'){ 
1B49A:  MOVF   47,W
1B49C:  SUBLW  3F
1B49E:  BNZ   1B4AA
....................          msg_busy(); 
1B4A0:  MOVLB  0
1B4A2:  GOTO   AEC0
....................       }else if (input_string[1] == 0){ 
1B4A6:  BRA    1B562
1B4A8:  MOVLB  8
1B4AA:  MOVF   x68,F
1B4AC:  BNZ   1B4D6
....................          fputs("\r\n@ARG ", COM_A); 
1B4AE:  MOVLW  1E
1B4B0:  MOVWF  FF6
1B4B2:  MOVLW  28
1B4B4:  MOVWF  FF7
1B4B6:  MOVLW  00
1B4B8:  MOVWF  FF8
1B4BA:  MOVLB  0
1B4BC:  CALL   AE86
1B4C0:  MOVLW  0D
1B4C2:  BTFSS  F9E.4
1B4C4:  BRA    1B4C2
1B4C6:  MOVWF  FAD
1B4C8:  MOVLW  0A
1B4CA:  BTFSS  F9E.4
1B4CC:  BRA    1B4CA
1B4CE:  MOVWF  FAD
....................          good_val = FALSE; 
1B4D0:  MOVLB  8
1B4D2:  CLRF   x64
....................       }else{ 
1B4D4:  BRA    1B564
....................       i = 1; 
1B4D6:  MOVLW  01
1B4D8:  MOVWF  x65
....................       //fputs("\r\n",COM_A); 
....................       //Check that argument is digits only 
....................       while(input_string[i] != 0){ 
1B4DA:  CLRF   03
1B4DC:  MOVF   x65,W
1B4DE:  ADDLW  67
1B4E0:  MOVWF  FE9
1B4E2:  MOVLW  08
1B4E4:  ADDWFC 03,W
1B4E6:  MOVWF  FEA
1B4E8:  MOVF   FEF,F
1B4EA:  BZ    1B53C
....................       //fputc(input_string[i],COM_A); 
....................          if(!isdigit(input_string[i])){ 
1B4EC:  CLRF   03
1B4EE:  MOVF   x65,W
1B4F0:  ADDLW  67
1B4F2:  MOVWF  FE9
1B4F4:  MOVLW  08
1B4F6:  ADDWFC 03,W
1B4F8:  MOVWF  FEA
1B4FA:  MOVFF  FEF,885
1B4FE:  MOVF   x85,W
1B500:  SUBLW  2F
1B502:  BC    1B50A
1B504:  MOVF   x85,W
1B506:  SUBLW  39
1B508:  BC    1B534
....................             fputs("\r\n@ARG ", COM_A); 
1B50A:  MOVLW  26
1B50C:  MOVWF  FF6
1B50E:  MOVLW  28
1B510:  MOVWF  FF7
1B512:  MOVLW  00
1B514:  MOVWF  FF8
1B516:  MOVLB  0
1B518:  CALL   AE86
1B51C:  MOVLW  0D
1B51E:  BTFSS  F9E.4
1B520:  BRA    1B51E
1B522:  MOVWF  FAD
1B524:  MOVLW  0A
1B526:  BTFSS  F9E.4
1B528:  BRA    1B526
1B52A:  MOVWF  FAD
....................             good_val = FALSE; 
1B52C:  MOVLB  8
1B52E:  CLRF   x64
....................             break; 
1B530:  BRA    1B53C
....................          }else{ 
1B532:  BRA    1B538
....................             good_val = TRUE; 
1B534:  MOVLW  01
1B536:  MOVWF  x64
....................          } 
....................          i++; 
1B538:  INCF   x65,F
1B53A:  BRA    1B4DA
....................       } 
....................       if(!good_val){ 
1B53C:  MOVF   x64,F
1B53E:  BNZ   1B542
....................          continue; 
1B540:  BRA    1B564
....................       } 
....................       //convert arg from string to int32 
....................       arg = atoi32(input_string+1); 
1B542:  MOVLW  08
1B544:  MOVWF  x86
1B546:  MOVLW  68
1B548:  MOVWF  x85
1B54A:  MOVLB  0
1B54C:  GOTO   AF02
1B550:  MOVFF  03,4B
1B554:  MOVFF  02,4A
1B558:  MOVFF  01,49
1B55C:  MOVFF  00,48
....................        
....................       proc_cmd(); 
1B560:  BRA    1B2FE
1B562:  MOVLB  8
....................       } 
....................        
....................       /*if (cmd == '?') msg_busy(); 
....................       else{  
....................             proc_cmd(); 
....................              
....................       }*/ 
....................    } while(nv_cmd_mode == TRUE); 
1B564:  DECFSZ 31,W
1B566:  BRA    1B56E
1B568:  MOVF   32,F
1B56A:  BTFSC  FD8.2
1B56C:  BRA    1B3D0
1B56E:  MOVLB  0
1B570:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void command_prompt2() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................    char temp_cmd = 0; 
....................    nv_cmd_mode = TRUE; 
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
....................     
....................    fputs("@CMD", COM_A); 
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
....................    record_event(); 
....................     
....................    busy_clear(); 
....................     
....................    cmd_set=0; // user 
....................     
....................    do { 
....................       fputc('>',COM_A); 
....................       cmd=fgetc(COM_A); 
....................          temp_cmd = cmd; 
....................          if (com_echo == TRUE) 
....................          { 
....................             fputc(cmd,COM_A); 
....................          } 
....................          if (cmd == '?') msg_busy(); 
....................          else proc_cmd(); 
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
.................... } 
....................  
....................  
.................... void main() 
1B572:  CLRF   FF8
1B574:  BCF    FD0.7
1B576:  BSF    07.7
1B578:  MOVLW  70
1B57A:  MOVWF  FD3
1B57C:  MOVLW  40
1B57E:  MOVWF  F9B
1B580:  CLRF   F64
1B582:  CLRF   1C
1B584:  BSF    F65.3
1B586:  MOVWF  FAF
1B588:  MOVLW  03
1B58A:  MOVWF  FD4
1B58C:  MOVLW  A6
1B58E:  MOVWF  FAC
1B590:  MOVLW  90
1B592:  MOVWF  FAB
1B594:  MOVLB  F
1B596:  BSF    x20.3
1B598:  MOVLW  82
1B59A:  MOVWF  x1E
1B59C:  MOVLW  06
1B59E:  MOVWF  x1F
1B5A0:  MOVLW  A6
1B5A2:  MOVWF  x21
1B5A4:  MOVLW  90
1B5A6:  MOVWF  x22
1B5A8:  BSF    F65.3
1B5AA:  MOVLW  40
1B5AC:  MOVWF  FAF
1B5AE:  MOVLW  03
1B5B0:  MOVWF  FD4
1B5B2:  MOVLW  A6
1B5B4:  MOVWF  FAC
1B5B6:  MOVLW  90
1B5B8:  MOVWF  FAB
1B5BA:  CLRF   1E
1B5BC:  CLRF   1D
1B5BE:  SETF   3A
1B5C0:  SETF   39
1B5C2:  SETF   3C
1B5C4:  SETF   3B
1B5C6:  CLRF   46
1B5C8:  MOVLW  01
1B5CA:  MOVWF  45
1B5CC:  MOVWF  4C
1B5CE:  BCF    4D.0
1B5D0:  BCF    4D.1
1B5D2:  BCF    4D.2
1B5D4:  MOVLB  0
1B5D6:  CLRF   x66
1B5D8:  MOVLB  2
1B5DA:  MOVWF  xD9
1B5DC:  MOVLB  3
1B5DE:  CLRF   x3B
1B5E0:  MOVLB  4
1B5E2:  CLRF   xE7
1B5E4:  MOVWF  xED
1B5E6:  MOVLW  04
1B5E8:  MOVLB  7
1B5EA:  MOVWF  x13
1B5EC:  MOVLW  EE
1B5EE:  MOVWF  x12
1B5F0:  CLRF   xCD
1B5F2:  MOVLB  8
1B5F4:  CLRF   x58
1B5F6:  CLRF   x57
1B5F8:  CLRF   x5C
1B5FA:  CLRF   x5B
1B5FC:  CLRF   x5A
1B5FE:  CLRF   x59
1B600:  CLRF   x60
1B602:  CLRF   x5F
1B604:  CLRF   x5E
1B606:  CLRF   x5D
1B608:  MOVLW  00
1B60A:  MOVLB  F
1B60C:  MOVWF  x23
1B60E:  MOVWF  x24
1B610:  MOVWF  x25
1B612:  BCF    FC1.3
1B614:  BCF    FC1.4
1B616:  BCF    FC1.5
1B618:  CLRF   x2E
1B61A:  CLRF   x2F
1B61C:  CLRF   x54
1B61E:  BRA    1B6E0
1B620:  DATA 44,02
1B622:  DATA DD,20
1B624:  DATA 64,72
1B626:  DATA 61,77
1B628:  DATA 5F,61
1B62A:  DATA 6C,6C
1B62C:  DATA 2E,63
1B62E:  DATA 73,76
1B630:  DATA 00,20
1B632:  DATA 64,72
1B634:  DATA 61,77
1B636:  DATA 5F,6E
1B638:  DATA 65,77
1B63A:  DATA 2E,63
1B63C:  DATA 73,76
1B63E:  DATA 00,20
1B640:  DATA 64,72
1B642:  DATA 65,6C
1B644:  DATA 5F,61
1B646:  DATA 6C,6C
1B648:  DATA 2E,63
1B64A:  DATA 73,76
1B64C:  DATA 00,20
1B64E:  DATA 64,72
1B650:  DATA 65,6C
1B652:  DATA 5F,6E
1B654:  DATA 65,77
1B656:  DATA 2E,63
1B658:  DATA 73,76
1B65A:  DATA 00,20
1B65C:  DATA 65,76
1B65E:  DATA 65,6E
1B660:  DATA 74,73
1B662:  DATA 2E,74
1B664:  DATA 78,74
1B666:  DATA 00,02
1B668:  DATA 03,39
1B66A:  DATA 2C,00
1B66C:  DATA 02,04
1B66E:  DATA D8,00
1B670:  DATA 00,10
1B672:  DATA 07,14
1B674:  DATA 46,41
1B676:  DATA 54,31
1B678:  DATA 32,46
1B67A:  DATA 41,54
1B67C:  DATA 31,36
1B67E:  DATA 46,41
1B680:  DATA 54,33
1B682:  DATA 32,00
1B684:  DATA 57,07
1B686:  DATA CE,0D
1B688:  DATA 0A,00
1B68A:  DATA 00,03
1B68C:  DATA 00,0F
1B68E:  DATA 00,1B
1B690:  DATA 00,27
1B692:  DATA 00,33
1B694:  DATA 00,3F
1B696:  DATA 00,4B
1B698:  DATA 00,57
1B69A:  DATA 00,63
1B69C:  DATA 00,6F
1B69E:  DATA 00,7B
1B6A0:  DATA 00,87
1B6A2:  DATA 00,93
1B6A4:  DATA 00,9F
1B6A6:  DATA 00,AB
1B6A8:  DATA 00,B7
1B6AA:  DATA 00,C3
1B6AC:  DATA 48,B1
1B6AE:  DATA 70,D4
1B6B0:  DATA 98,F7
1B6B2:  DATA C0,1A
1B6B4:  DATA 00,CF
1B6B6:  DATA 28,F2
1B6B8:  DATA 50,15
1B6BA:  DATA 78,38
1B6BC:  DATA A0,5B
1B6BE:  DATA C8,7E
1B6C0:  DATA F0,A1
1B6C2:  DATA 18,C5
1B6C4:  DATA 40,E8
1B6C6:  DATA 68,0B
1B6C8:  DATA 90,2E
1B6CA:  DATA B8,51
1B6CC:  DATA E0,74
1B6CE:  DATA 08,98
1B6D0:  DATA 30,BB
1B6D2:  DATA 58,DE
1B6D4:  DATA 80,01
1B6D6:  DATA A8,24
1B6D8:  DATA D0,47
1B6DA:  DATA F8,6A
1B6DC:  DATA 20,8E
1B6DE:  DATA 00,00
1B6E0:  MOVLW  01
1B6E2:  MOVWF  FF8
1B6E4:  MOVLW  B6
1B6E6:  MOVWF  FF7
1B6E8:  MOVLW  20
1B6EA:  MOVWF  FF6
1B6EC:  TBLRD*+
1B6EE:  MOVF   FF5,W
1B6F0:  MOVWF  00
1B6F2:  XORLW  00
1B6F4:  BZ    1B71C
1B6F6:  TBLRD*+
1B6F8:  MOVF   FF5,W
1B6FA:  MOVWF  01
1B6FC:  BTFSC  FE8.7
1B6FE:  BRA    1B70A
1B700:  ANDLW  0F
1B702:  MOVWF  FEA
1B704:  TBLRD*+
1B706:  MOVFF  FF5,FE9
1B70A:  BTFSC  01.6
1B70C:  TBLRD*+
1B70E:  BTFSS  01.6
1B710:  TBLRD*+
1B712:  MOVFF  FF5,FEE
1B716:  DCFSNZ 00,F
1B718:  BRA    1B6EC
1B71A:  BRA    1B70E
1B71C:  CLRF   FF8
1B71E:  MOVLB  8
1B720:  CLRF   x61
1B722:  CLRF   x63
1B724:  CLRF   x62
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B726:  BCF    FF2.6
1B728:  BCF    FF2.7
1B72A:  BTFSC  FF2.7
1B72C:  BRA    1B728
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B72E:  BCF    FC6.5
1B730:  MOVLW  21
1B732:  MOVWF  FC6
1B734:  MOVLW  40
1B736:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B738:  BCF    F67.5
1B73A:  MOVLW  21
1B73C:  MOVWF  F67
1B73E:  MOVLW  40
1B740:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B742:  MOVLW  00
1B744:  MOVLB  F
1B746:  MOVWF  x23
1B748:  MOVWF  x24
1B74A:  MOVLW  1F
1B74C:  MOVWF  x25
1B74E:  BCF    FC1.3
1B750:  BSF    FC1.4
1B752:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B754:  MOVF   FC0,W
1B756:  ANDLW  C0
1B758:  IORLW  07
1B75A:  MOVWF  FC0
1B75C:  BSF    FC0.7
1B75E:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B760:  MOVLW  87
1B762:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B764:  MOVLW  37
1B766:  MOVWF  FCD
1B768:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B76A:  MOVLB  0
1B76C:  GOTO   28C4
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B770:  CLRF   FB0
1B772:  MOVLW  07
1B774:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B776:  MOVLW  04
1B778:  MOVLB  F
1B77A:  MOVWF  x2E
1B77C:  MOVWF  x2F
1B77E:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B780:  MOVLW  70
1B782:  MOVWF  FD3
1B784:  MOVLW  40
1B786:  MOVWF  F9B
1B788:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B78A:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B78C:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B78E:  MOVLB  0
1B790:  CALL   2900
....................  
....................    enable_interrupts(GLOBAL); 
1B794:  MOVLW  C0
1B796:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
1B798:  CALL   293A
....................    motor_sleep_rdy(); 
1B79C:  CALL   2998
....................  
....................    sleep_mode = FALSE;    
1B7A0:  BCF    4D.1
....................    busy_set(); 
1B7A2:  CALL   29C0
....................     
....................    init_nv_vars(); 
1B7A6:  CALL   2AB8
....................    get_step_vars(); 
1B7AA:  CALL   2D1A
....................    init_aws(); 
1B7AE:  GOTO   30DC
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B7B2:  CALL   30F6
....................    blink(); 
1B7B6:  GOTO   30FC
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B7BA:  CALL   3148
....................     
....................    RTC_read(); 
1B7BE:  CALL   3344
....................    RTC_last_power(); 
1B7C2:  GOTO   3442
....................    RTC_reset_HT();   
1B7C6:  CALL   34B2
....................    RTC_read(); 
1B7CA:  CALL   3344
1B7CE:  CLRF   1B
1B7D0:  BTFSC  FF2.7
1B7D2:  BSF    1B.7
1B7D4:  BCF    FF2.7
....................    RTC_read_flags(); 
1B7D6:  CALL   0DD0
1B7DA:  BTFSC  1B.7
1B7DC:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B7DE:  MOVF   3F,F
1B7E0:  BNZ   1B7E6
1B7E2:  MOVF   40,F
1B7E4:  BZ    1B836
1B7E6:  MOVLW  46
1B7E8:  MOVWF  FF6
1B7EA:  MOVLW  28
1B7EC:  MOVWF  FF7
1B7EE:  MOVLW  00
1B7F0:  MOVWF  FF8
1B7F2:  CLRF   1B
1B7F4:  BTFSC  FF2.7
1B7F6:  BSF    1B.7
1B7F8:  BCF    FF2.7
1B7FA:  MOVLW  04
1B7FC:  MOVLB  A
1B7FE:  MOVWF  x40
1B800:  MOVLB  0
1B802:  CALL   101C
1B806:  BTFSC  1B.7
1B808:  BSF    FF2.7
1B80A:  MOVLW  10
1B80C:  MOVWF  FE9
1B80E:  CLRF   1B
1B810:  BTFSC  FF2.7
1B812:  BSF    1B.7
1B814:  BCF    FF2.7
1B816:  MOVFF  40,A41
1B81A:  MOVFF  3F,A40
1B81E:  CALL   119E
1B822:  BTFSC  1B.7
1B824:  BSF    FF2.7
1B826:  MOVLW  0D
1B828:  BTFSS  F9E.4
1B82A:  BRA    1B828
1B82C:  MOVWF  FAD
1B82E:  MOVLW  0A
1B830:  BTFSS  F9E.4
1B832:  BRA    1B830
1B834:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B836:  CALL   3508
....................    sd_status = init_sdcard(); 
1B83A:  CALL   503A
1B83E:  MOVFF  01,2DC
....................    if(sd_status>0) msg_card_fail(); 
1B842:  MOVLB  2
1B844:  MOVF   xDC,F
1B846:  BZ    1B850
1B848:  MOVLB  0
1B84A:  CALL   5080
1B84E:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
1B850:  MOVLB  0
1B852:  GOTO   ABC6
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B856:  MOVLB  7
1B858:  MOVF   x96,F
1B85A:  BNZ   1B868
1B85C:  MOVF   x97,F
1B85E:  BNZ   1B868
1B860:  MOVF   x98,F
1B862:  BNZ   1B868
1B864:  MOVF   x99,F
1B866:  BZ    1B870
1B868:  MOVLB  0
1B86A:  CALL   9D02
1B86E:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B870:  MOVF   xAF,F
1B872:  BNZ   1B8F6
1B874:  MOVF   xB0,F
1B876:  BNZ   1B8F6
....................       e_port[0]=0; 
1B878:  CLRF   xC4
1B87A:  CLRF   xC3
....................       write16(ADDR_E1_PORT,0); 
1B87C:  MOVLW  AA
1B87E:  MOVLB  8
1B880:  MOVWF  xEE
1B882:  CLRF   xF0
1B884:  CLRF   xEF
1B886:  MOVLB  0
1B888:  CALL   4FD4
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B88C:  MOVLW  50
1B88E:  MOVWF  FF6
1B890:  MOVLW  28
1B892:  MOVWF  FF7
1B894:  MOVLW  00
1B896:  MOVWF  FF8
1B898:  CLRF   1B
1B89A:  BTFSC  FF2.7
1B89C:  BSF    1B.7
1B89E:  BCF    FF2.7
1B8A0:  MOVLW  05
1B8A2:  MOVLB  A
1B8A4:  MOVWF  x40
1B8A6:  MOVLB  0
1B8A8:  CALL   101C
1B8AC:  BTFSC  1B.7
1B8AE:  BSF    FF2.7
1B8B0:  MOVLW  10
1B8B2:  MOVWF  FE9
1B8B4:  CLRF   1B
1B8B6:  BTFSC  FF2.7
1B8B8:  BSF    1B.7
1B8BA:  BCF    FF2.7
1B8BC:  MOVFF  7B0,A41
1B8C0:  MOVFF  7AF,A40
1B8C4:  CALL   119E
1B8C8:  BTFSC  1B.7
1B8CA:  BSF    FF2.7
1B8CC:  MOVLW  2C
1B8CE:  BTFSS  F9E.4
1B8D0:  BRA    1B8CE
1B8D2:  MOVWF  FAD
1B8D4:  MOVLW  10
1B8D6:  MOVWF  FE9
1B8D8:  MOVFF  7C4,8F1
1B8DC:  MOVFF  7C3,8F0
1B8E0:  CALL   8FE4
1B8E4:  MOVLW  0D
1B8E6:  BTFSS  F9E.4
1B8E8:  BRA    1B8E6
1B8EA:  MOVWF  FAD
1B8EC:  MOVLW  0A
1B8EE:  BTFSS  F9E.4
1B8F0:  BRA    1B8EE
1B8F2:  MOVWF  FAD
1B8F4:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B8F6:  MOVF   xB1,F
1B8F8:  BNZ   1B97C
1B8FA:  MOVF   xB2,F
1B8FC:  BNZ   1B97C
....................       m_lin_pos[1]=-1; 
1B8FE:  SETF   xB6
1B900:  SETF   xB5
....................       write16(ADDR_M2_LIN_POS, -1); 
1B902:  MOVLW  B8
1B904:  MOVLB  8
1B906:  MOVWF  xEE
1B908:  SETF   xF0
1B90A:  SETF   xEF
1B90C:  MOVLB  0
1B90E:  CALL   4FD4
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B912:  MOVLW  60
1B914:  MOVWF  FF6
1B916:  MOVLW  28
1B918:  MOVWF  FF7
1B91A:  MOVLW  00
1B91C:  MOVWF  FF8
1B91E:  CLRF   1B
1B920:  BTFSC  FF2.7
1B922:  BSF    1B.7
1B924:  BCF    FF2.7
1B926:  MOVLW  05
1B928:  MOVLB  A
1B92A:  MOVWF  x40
1B92C:  MOVLB  0
1B92E:  CALL   101C
1B932:  BTFSC  1B.7
1B934:  BSF    FF2.7
1B936:  MOVLW  10
1B938:  MOVWF  FE9
1B93A:  CLRF   1B
1B93C:  BTFSC  FF2.7
1B93E:  BSF    1B.7
1B940:  BCF    FF2.7
1B942:  MOVFF  7B2,A41
1B946:  MOVFF  7B1,A40
1B94A:  CALL   119E
1B94E:  BTFSC  1B.7
1B950:  BSF    FF2.7
1B952:  MOVLW  2C
1B954:  BTFSS  F9E.4
1B956:  BRA    1B954
1B958:  MOVWF  FAD
1B95A:  MOVLW  10
1B95C:  MOVWF  FE9
1B95E:  MOVFF  7B6,8F1
1B962:  MOVFF  7B5,8F0
1B966:  CALL   8FE4
1B96A:  MOVLW  0D
1B96C:  BTFSS  F9E.4
1B96E:  BRA    1B96C
1B970:  MOVWF  FAD
1B972:  MOVLW  0A
1B974:  BTFSS  F9E.4
1B976:  BRA    1B974
1B978:  MOVWF  FAD
1B97A:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1B97C:  MOVF   31,F
1B97E:  BNZ   1BA22
1B980:  MOVF   32,F
1B982:  BNZ   1BA22
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1B984:  MOVLW  70
1B986:  MOVWF  FF6
1B988:  MOVLW  28
1B98A:  MOVWF  FF7
1B98C:  MOVLW  00
1B98E:  MOVWF  FF8
1B990:  CLRF   1B
1B992:  BTFSC  FF2.7
1B994:  BSF    1B.7
1B996:  BCF    FF2.7
1B998:  MOVLB  0
1B99A:  CALL   0E46
1B99E:  BTFSC  1B.7
1B9A0:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1B9A2:  MOVLB  8
1B9A4:  MOVF   x63,F
1B9A6:  BNZ   1B9D4
1B9A8:  MOVF   x62,W
1B9AA:  SUBLW  63
1B9AC:  BNC   1B9D4
1B9AE:  MOVF   x61,W
1B9B0:  SUBLW  1B
1B9B2:  BZ    1B9D4
....................       { 
....................          EscNum=TestForEsc(); 
1B9B4:  MOVLB  0
1B9B6:  GOTO   AE2C
1B9BA:  MOVFF  01,861
....................          if(EscNum == ESCAPE) command_prompt(); 
1B9BE:  MOVLB  8
1B9C0:  MOVF   x61,W
1B9C2:  SUBLW  1B
1B9C4:  BNZ   1B9CC
1B9C6:  MOVLB  0
1B9C8:  RCALL  1B352
1B9CA:  MOVLB  8
....................          EscCount++; 
1B9CC:  INCF   x62,F
1B9CE:  BTFSC  FD8.2
1B9D0:  INCF   x63,F
1B9D2:  BRA    1B9A4
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1B9D4:  DECFSZ 33,W
1B9D6:  BRA    1B9EC
1B9D8:  MOVF   34,F
1B9DA:  BNZ   1B9EC
....................       { 
....................          arg=0; 
1B9DC:  CLRF   4B
1B9DE:  CLRF   4A
1B9E0:  CLRF   49
1B9E2:  CLRF   48
....................          commandZ(); 
1B9E4:  MOVLB  0
1B9E6:  CALL   18B0A
1B9EA:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1B9EC:  MOVLW  A8
1B9EE:  MOVWF  FF6
1B9F0:  MOVLW  28
1B9F2:  MOVWF  FF7
1B9F4:  MOVLW  00
1B9F6:  MOVWF  FF8
1B9F8:  CLRF   1B
1B9FA:  BTFSC  FF2.7
1B9FC:  BSF    1B.7
1B9FE:  BCF    FF2.7
1BA00:  MOVLB  0
1BA02:  CALL   0E46
1BA06:  BTFSC  1B.7
1BA08:  BSF    FF2.7
....................       arg = 0; 
1BA0A:  CLRF   4B
1BA0C:  CLRF   4A
1BA0E:  CLRF   49
1BA10:  CLRF   48
....................       commandM(TRUE); 
1BA12:  MOVLW  01
1BA14:  MOVLB  8
1BA16:  MOVWF  x85
1BA18:  MOVLB  0
1BA1A:  CALL   16DBA
....................    } 
1BA1E:  BRA    1BA26
1BA20:  MOVLB  7
....................    else 
....................    { 
....................       command_prompt(); 
1BA22:  MOVLB  0
1BA24:  RCALL  1B352
....................    } 
....................  
....................    reset_cpu(); 
1BA26:  RESET
.................... } 
....................  
1BA28:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 2878   PUT NOBROWNOUT BORV18 ZPBORM NOWDT WDT1024
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
